<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martinfowler.com/articles/data-fetch-spa.html">Original</a>
    <h1>Data Fetching for Single-Page Apps</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Today, most applications can send hundreds of requests for a single page.
    For example, my Twitter home page sends around 300 requests, and an Amazon
    product details page sends around 600 requests. Some of them are for static
    assets (JavaScript, CSS, font files, icons, etc.), but there are still
    around 100 requests for async data fetching - either for timelines, friends,
    or product recommendations, as well as analytics events. That’s quite a
    lot.</p>

<p>The main reason a page may contain so many requests is to improve
    performance and user experience, specifically to make the application <i>feel</i>
    faster to the end users. The era of blank pages taking 5 seconds to load is
    long gone. In modern web applications, users typically see a basic page with
    style and other elements in less than a second, with additional pieces
    loading progressively.</p>

<p>Take the Amazon product detail page as an example. The navigation and top
    bar appear almost immediately, followed by the product images, brief, and
    descriptions. Then, as you scroll, &#34;Sponsored&#34; content, ratings,
    recommendations, view histories, and more appear.Often, a user only wants a
    quick glance or to compare products (and check availability), making
    sections like &#34;Customers who bought this item also bought&#34; less critical and
    suitable for loading via separate requests.</p>

<p>Breaking down the content into smaller pieces and loading them in
    parallel is an effective strategy, but it&#39;s far from enough in large
    applications. There are many other aspects to consider when it comes to
    fetch data correctly and efficiently. Data fetching is a chellenging, not
    only because the nature of async programming doesn&#39;t fit our linear mindset,
    and there are so many factors can cause a network call to fail, but also
    there are too many not-obvious cases to consider under the hood (data
    format, security, cache, token expiry, etc.).</p>

<p>In this article, I would like to discuss some common problems and
    patterns you should consider when it comes to fetching data in your frontend
    applications.</p>

<p>We&#39;ll begin with the <a href="#async-state-handler">Asynchronous State Handler</a> pattern, which decouples
    data fetching from the UI, streamlining your application architecture. Next,
    we&#39;ll delve into <a href="#fallback-markup">Fallback Markup</a>, enhancing the intuitiveness of your data
    fetching logic. To accelerate the initial data loading process, we&#39;ll
    explore strategies for avoiding <a href="#request-waterfall"> Request
    Waterfall</a> and implementing <a href="#parallel-data-fetching">Parallel Data Fetching</a>. Our discussion will then cover <a href="#code-splitting">Code Splitting</a> to defer
    loading non-critical application parts and <a href="#prefetching">Prefetching</a> data based on user
    interactions to elevate the user experience.</p>

<p>I believe discussing these concepts through a straightforward example is
    the best approach. I aim to start simply and then introduce more complexity
    in a manageable way. I also plan to keep code snippets, particularly for
    styling (I&#39;m utilizing TailwindCSS for the UI, which can result in lengthy
    snippets in a React component), to a minimum. For those interested in the
    complete details, I&#39;ve made them available <a href="https://github.com/abruzzi/react-network-advanced-client-side">in this
    repository</a>.</p>

<p>Advancements are also happening on the server side, with techniques like
    Streaming Server-Side Rendering and Server Components gaining traction in
    various frameworks. Additionally, a number of experimental methods are
    emerging. However, these topics, while potentially just as crucial, might be
    explored in a future article. For now, this discussion will concentrate
    solely on front-end data fetching patterns.</p>

<p>It&#39;s important to note that the techniques we&#39;re covering are not
    exclusive to React or any specific frontend framework or library. I&#39;ve
    chosen React for illustration purposes due to my extensive experience with
    it in recent years. However, principles like <a href="#code-splitting">Code Splitting</a>,
    <a href="#prefetching">Prefetching</a> are
    applicable across frameworks like Angular or Vue.js. The examples I&#39;ll share
    are common scenarios you might encounter in frontend development, regardless
    of the framework you use.</p>

<p>That said, let’s dive into the example we’re going to use throughout the
    article, a <code>Profile</code> screen of a Single-Page Application. It&#39;s a typical
    application you might have used before, or at least the scenario is typical.
    We need to fetch data from server side and then at frontend to build the UI
    dynamically with JavaScript.</p>

<section id="IntroducingTheApplication">
<h2>Introducing the application</h2>

<p>To begin with, on <code>Profile</code> we’ll show the user’s brief (including
      name, avatar, and a short description), and then we also want to show
      their connections (similar to followers on Twitter or LinkedIn
      connections). We&#39;ll need to fetch user and their connections data from
      remote service, and then assembling these data with UI on the screen.</p>

<div id="user-brief-and-friends.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/user-brief-and-friends.png"/></p><p>Figure 1: Profile screen</p>
</div>



<p>The data are from two separate API calls, the user brief API
      <code>/users/&lt;id&gt;</code> returns user brief for a given user id, which is a simple
      object described as follows:</p>

<pre>{
  &#34;id&#34;: &#34;u1&#34;,
  &#34;name&#34;: &#34;Juntao Qiu&#34;,
  &#34;bio&#34;: &#34;Developer, Educator, Author&#34;,
  &#34;interests&#34;: [
    &#34;Technology&#34;,
    &#34;Outdoors&#34;,
    &#34;Travel&#34;
  ]
}
</pre>

<p>And the friend API <code>/users/&lt;id&gt;/friends</code> endpoint returns a list of
      friends for a given user, each list item in the response is the same as
      the above user data. The reason we have two endpoints instead of returning
      a <code>friends</code> section of the user API is that there are cases where one
      could have too many friends (say 1,000), but most people don&#39;t have many.
      This in-balance data structure can be pretty tricky, especially when we
      need to paginate. The point here is that there are cases we need to deal
      with multiple network requests.</p>
</section>

<section id="ABriefIntroductionToRelevantReactConcepts">
<h2>A brief introduction to relevant React concepts</h2>

<p>As this article leverages React to illustrate various patterns, I do
      not assume you know much about React. Rather than expecting you to spend a lot
      of time trying to find the right parts in the React documentation, I will
      briefly introduce those concepts we&#39;re going to utilize throughout this
      article. If you already understand what React components are, and the
      use of the 
      <code>useState</code> and <code>useEffect</code> hooks, you may 
      <a href="#implement-profile">use this link</a> to skip ahead to the next
      section. </p>

<p>For those seeking a more thorough tutorial, the <a href="https://react.dev/">new React documentation</a> is an excellent
      resource.</p>

<section id="WhatIsAReactComponent">
<h3>What is a React Component?</h3>

<p>In React, components are the fundamental building blocks. To put it
        simply, a React component is a function that returns a piece of UI,
        which can be as straightforward as a fragment of HTML. Consider the
        creation of a component that renders a navigation bar:</p>

<pre>import React from &#39;react&#39;;

function Navigation() {
  return (
    &lt;nav&gt;
      &lt;ol&gt;
        &lt;li&gt;Home&lt;/li&gt;
        &lt;li&gt;Blogs&lt;/li&gt;
        &lt;li&gt;Books&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/nav&gt;
  );
}
</pre>

<p>At first glance, the mixture of JavaScript with HTML tags might seem
        strange (it&#39;s called JSX, a syntax extension to JavaScript. For those
        using TypeScript, a similar syntax called TSX is used). To make this
        code functional, a compiler is required to translate the JSX into valid
        JavaScript code. After being compiled by <a href="https://babeljs.io/">Babel</a>,
        the code would roughly translate to the following:</p>

<pre>function Navigation() {
  return React.createElement(
    &#34;nav&#34;,
    null,
    React.createElement(
      &#34;ol&#34;,
      null,
      React.createElement(&#34;li&#34;, null, &#34;Home&#34;),
      React.createElement(&#34;li&#34;, null, &#34;Blogs&#34;),
      React.createElement(&#34;li&#34;, null, &#34;Books&#34;)
    )
  );
}
</pre>

<p>Note here the translated code has a function called
        <code>React.createElement</code>, which is a foundational function in
        React for creating elements. JSX written in React components is compiled
        down to <code>React.createElement</code> calls behind the scenes.</p>

<p>The basic syntax of <code>React.createElement</code> is:</p>

<pre>React.createElement(type, [props], [...children])
</pre>

<ul>
<li><code>type</code>: A string (e.g., &#39;div&#39;, &#39;span&#39;) indicating the type of
          DOM node to create, or a React component (class or functional) for
          more sophisticated structures.</li>

<li><code>props</code>: An object containing properties passed to the
          element or component, including event handlers, styles, and attributes
          like <code>className</code> and <code>id</code>.</li>

<li><code>children</code>: These optional arguments can be additional
          <code>React.createElement</code> calls, strings, numbers, or any mix
          thereof, representing the element&#39;s children.</li>
</ul>

<p>For instance, a simple element can be created with
        <code>React.createElement</code> as follows:</p>

<pre>React.createElement(&#39;div&#39;, { className: &#39;greeting&#39; }, &#39;Hello, world!&#39;);
</pre>

<p>This is analogous to the JSX version:</p>

<pre>&lt;div className=&#34;greeting&#34;&gt;Hello, world!&lt;/div&gt;
</pre>

<p>Beneath the surface, React invokes the native DOM API (e.g.,
        <code>document.createElement(&#34;ol&#34;)</code>) to generate DOM elements as necessary.
        You can then assemble your custom components into a tree, similar to
        HTML code:</p>

<pre>import React from &#39;react&#39;;
import Navigation from &#39;./Navigation.tsx&#39;;
import Content from &#39;./Content.tsx&#39;;
import Sidebar from &#39;./Sidebar.tsx&#39;;
import ProductList from &#39;./ProductList.tsx&#39;;

function App() {
  return &lt;Page /&gt;;
}

function Page() {
  return &lt;Container&gt;
    &lt;Navigation /&gt;
    &lt;Content&gt;
      &lt;Sidebar /&gt;
      &lt;ProductList /&gt;
    &lt;/Content&gt;
    &lt;Footer /&gt;
  &lt;/Container&gt;;
}
</pre>

<p>Ultimately, your application requires a root node to mount to, at
        which point React assumes control and manages subsequent renders and
        re-renders:</p>

<pre>import ReactDOM from &#34;react-dom/client&#34;;
import App from &#34;./App.tsx&#34;;

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;));
root.render(&lt;App /&gt;);
</pre>
</section>

<section id="GeneratingDynamicContentWithJsx">
<h3>Generating Dynamic Content with JSX</h3>

<p>The initial example demonstrates a straightforward use case, but
        let&#39;s explore how we can create content dynamically. For instance, how
        can we generate a list of data dynamically? In React, as illustrated
        earlier, a component is fundamentally a function, enabling us to pass
        parameters to it.</p>

<pre>import React from &#39;react&#39;;

function Navigation({ nav }) {
  return (
    &lt;nav&gt;
      &lt;ol&gt;
        {nav.map(item =&gt; &lt;li key={item}&gt;{item}&lt;/li&gt;)}
      &lt;/ol&gt;
    &lt;/nav&gt;
  );
}
</pre>

<p>In this modified <code>Navigation</code> component, we anticipate the
        parameter to be an array of strings. We utilize the <code>map</code>
        function to iterate over each item, transforming them into
        <code>&lt;li&gt;</code> elements. The curly braces <code>{}</code> signify
        that the enclosed JavaScript expression should be evaluated and
        rendered. For those curious about the compiled version of this dynamic
        content handling:</p>

<pre>function Navigation(props) {
  var nav = props.nav;

  return React.createElement(
    &#34;nav&#34;,
    null,
    React.createElement(
      &#34;ol&#34;,
      null,
      nav.map(function(item) {
        return React.createElement(&#34;li&#34;, { key: item }, item);
      })
    )
  );
}
</pre>

<p>Instead of invoking <code>Navigation</code> as a regular function,
        employing JSX syntax renders the component invocation more akin to
        writing markup, enhancing readability:</p>

<pre>// Instead of this
Navigation([&#34;Home&#34;, &#34;Blogs&#34;, &#34;Books&#34;])

// We do this
&lt;Navigation nav={[&#34;Home&#34;, &#34;Blogs&#34;, &#34;Books&#34;]} /&gt;
</pre>

<p>Components in React can receive diverse data, known as props, to
        modify their behavior, much like passing arguments into a function (the
        distinction lies in using JSX syntax, making the code more familiar and
        readable to those with HTML knowledge, which aligns well with the skill
        set of most frontend developers).</p>

<pre>import React from &#39;react&#39;;
import Checkbox from &#39;./Checkbox&#39;;
import BookList from &#39;./BookList&#39;;

function App() {
  let showNewOnly = false; // This flag&#39;s value is typically set based on specific logic.

  const filteredBooks = showNewOnly
    ? booksData.filter(book =&gt; book.isNewPublished)
    : booksData;

  return (
    &lt;div&gt;
      &lt;Checkbox checked={showNewOnly}&gt;
        Show New Published Books Only
      &lt;/Checkbox&gt;
      &lt;BookList books={filteredBooks} /&gt;
    &lt;/div&gt;
  );
}
</pre>

<p>In this illustrative code snippet (non-functional but intended to
        demonstrate the concept), we manipulate the <code>BookList</code>
        component&#39;s displayed content by passing it an array of books. Depending
        on the <code>showNewOnly</code> flag, this array is either all available
        books or only those that are newly published, showcasing how props can
        be used to dynamically adjust component output.</p>
</section>

<section id="ManagingInternalStateBetweenRendersUsestate">
<h3>Managing Internal State Between Renders: useState</h3>

<p>Building user interfaces (UI) often transcends the generation of
        static HTML. Components frequently need to &#34;remember&#34; certain states and
        respond to user interactions dynamically. For instance, when a user
        clicks an &#34;Add&#34; button in a Product component, it&#39;s necessary to update
        the ShoppingCart component to reflect both the total price and the
        updated item list.</p>

<p>In the previous code snippet, attempting to set the
        <code>showNewOnly</code> variable to <code>true</code> within an event
        handler does not achieve the desired effect:</p>

<pre>function App () {
  let showNewOnly = false;

  const handleCheckboxChange = () =&gt; {
    showNewOnly = true; // this doesn&#39;t work
  };

  const filteredBooks = showNewOnly
    ? booksData.filter(book =&gt; book.isNewPublished)
    : booksData;

  return (
    &lt;div&gt;
      &lt;Checkbox checked={showNewOnly} onChange={handleCheckboxChange}&gt;
        Show New Published Books Only
      &lt;/Checkbox&gt;

      &lt;BookList books={filteredBooks}/&gt;
    &lt;/div&gt;
  );
};
</pre>

<p>This approach falls short because local variables inside a function
        component do not persist between renders. When React re-renders this
        component, it does so from scratch, disregarding any changes made to
        local variables since these do not trigger re-renders. React remains
        unaware of the need to update the component to reflect new data.</p>

<p>This limitation underscores the necessity for React&#39;s
        <code>state</code>. Specifically, functional components leverage the
        <code>useState</code> hook to remember states across renders. Revisiting
        the <code>App</code> example, we can effectively remember the
        <code>showNewOnly</code> state as follows:</p>

<pre>import React, { useState } from &#39;react&#39;;
import Checkbox from &#39;./Checkbox&#39;;
import BookList from &#39;./BookList&#39;;

function App () {
  const [showNewOnly, setShowNewOnly] = useState(false);

  const handleCheckboxChange = () =&gt; {
    setShowNewOnly(!showNewOnly);
  };

  const filteredBooks = showNewOnly
    ? booksData.filter(book =&gt; book.isNewPublished)
    : booksData;

  return (
    &lt;div&gt;
      &lt;Checkbox checked={showNewOnly} onChange={handleCheckboxChange}&gt;
        Show New Published Books Only
      &lt;/Checkbox&gt;

      &lt;BookList books={filteredBooks}/&gt;
    &lt;/div&gt;
  );
};
</pre>

<p>The <code>useState</code> hook is a cornerstone of React&#39;s Hooks system,
        introduced to enable functional components to manage internal state. It
        introduces state to functional components, encapsulated by the following
        syntax:</p>

<pre>const [state, setState] = useState(initialState);
</pre>

<ul>
<li><code>initialState</code>: This argument is the initial
          value of the state variable. It can be a simple value like a number,
          string, boolean, or a more complex object or array. The
          <code>initialState</code> is only used during the first render to
          initialize the state.</li>

<li><i>Return Value</i>: <code>useState</code> returns an array with
          two elements. The first element is the current state value, and the
          second element is a function that allows updating this value. By using
          array destructuring, we assign names to these returned items,
          typically <code>state</code> and <code>setState</code>, though you can
          choose any valid variable names.</li>

<li><code>state</code>: Represents the current value of the
          state. It&#39;s the value that will be used in the component&#39;s UI and
          logic.</li>

<li><code>setState</code>: A function to update the state. This function
          accepts a new state value or a function that produces a new state based
          on the previous state. When called, it schedules an update to the
          component&#39;s state and triggers a re-render to reflect the changes.</li>
</ul>

<p>React treats state as a snapshot; updating it doesn&#39;t alter the
        existing state variable but instead triggers a re-render. During this
        re-render, React acknowledges the updated state, ensuring the
        <code>BookList</code> component receives the correct data, thereby
        reflecting the updated book list to the user. This snapshot-like
        behavior of state facilitates the dynamic and responsive nature of React
        components, enabling them to react intuitively to user interactions and
        other changes.</p>
</section>

<section id="ManagingSideEffectsUseeffect">
<h3>Managing Side Effects: useEffect</h3>

<p>Before diving deeper into our discussion, it&#39;s crucial to address the
        concept of side effects. Side effects are operations that interact with
        the outside world from the React ecosystem. Common examples include
        fetching data from a remote server or dynamically manipulating the DOM,
        such as changing the page title.</p>

<p>React is primarily concerned with rendering data to the DOM and does
        not inherently handle data fetching or direct DOM manipulation. To
        facilitate these side effects, React provides the <code>useEffect</code>
        hook. This hook allows the execution of side effects after React has
        completed its rendering process. If these side effects result in data
        changes, React schedules a re-render to reflect these updates.</p>

<p>The <code>useEffect</code> Hook accepts two arguments:</p>

<ul>
<li>A function containing the side effect logic.</li>

<li>An optional dependency array specifying when the side effect should be
          re-invoked.</li>
</ul>

<p>Omitting the second argument causes the side effect to run after
        every render. Providing an empty array <code>[]</code> signifies that your effect
        doesn’t depend on any values from props or state, thus not needing to
        re-run. Including specific values in the array means the side effect
        only re-executes if those values change.</p>

<p>When dealing with asynchronous data fetching, the workflow within
        <code>useEffect</code> entails initiating a network request. Once the data is
        retrieved, it is captured via the <code>useState</code> hook, updating the
        component&#39;s internal state and preserving the fetched data across
        renders. React, recognizing the state update, undertakes another render
        cycle to incorporate the new data.</p>

<p>Here&#39;s a practical example about data fetching and state
        management:</p>

<pre>import { useEffect, useState } from &#34;react&#34;;

type User = {
  id: string;
  name: string;
};

const UserSection = ({ id }) =&gt; {
  const [user, setUser] = useState&lt;User | undefined&gt;();

  useEffect(() =&gt; {
    const fetchUser = async () =&gt; {
      const response = await fetch(`/api/users/${id}`);
      const jsonData = await response.json();
      setUser(jsonData);
    };

    fetchUser();
  }, [id]);

  return &lt;div&gt;
    &lt;h2&gt;{user?.name}&lt;/h2&gt;
  &lt;/div&gt;;
};
</pre>

<p>In the code snippet above, within <code>useEffect</code>, an
        asynchronous function <code>fetchUser</code> is defined and then
        immediately invoked. This pattern is necessary because
        <code>useEffect</code> does not directly support async functions as its
        callback. The async function is defined to use <code>await</code> for
        the fetch operation, ensuring that the code execution waits for the
        response and then processes the JSON data. Once the data is available,
        it updates the component&#39;s state via <code>setUser</code>.</p>

<p>The dependency array <code>[id]</code> at the end of the
        <code>useEffect</code> call ensures that the effect runs again only if
        <code>id</code> changes, which prevents unnecessary network requests on
        every render and fetches new user data when the <code>id</code> prop
        updates.</p>

<p>This approach to handling asynchronous data fetching within
        <code>useEffect</code> is a standard practice in React development, offering a
        structured and efficient way to integrate async operations into the
        React component lifecycle.</p>

<p>In addition, in practical applications, managing different states
        such as loading, error, and data presentation is essential too (we&#39;ll
        see it how it works in the following section). For example, consider
        implementing status indicators within a User component to reflect
        loading, error, or data states, enhancing the user experience by
        providing feedback during data fetching operations.</p>

<div id="status-of-profile-component.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/status-of-profile-component.png"/></p><p>Figure 2: Different statuses of a
        component</p>
</div>



<p>This overview offers just a quick glimpse into the concepts utilized
        throughout this article. For a deeper dive into additional concepts and
        patterns, I recommend exploring the <a href="https://react.dev/">new React
        documentation</a> or consulting other online resources.
        With this foundation, you should now be equipped to join me as we delve
        into the data fetching patterns discussed herein.</p>
</section>
</section>

<section id="implement-profile">
<h2>Implement the Profile component</h2>

<p>Let’s create the <code>Profile</code> component to make a request and
      render the result. In typical React applications, this data fetching is
      handled inside a <code>useEffect</code> block. Here&#39;s an example of how
      this might be implemented:</p>

<pre>import { useEffect, useState } from &#34;react&#34;;

const Profile = ({ id }: { id: string }) =&gt; {
  const [user, setUser] = useState&lt;User | undefined&gt;();

  useEffect(() =&gt; {
    const fetchUser = async () =&gt; {
      const response = await fetch(`/api/users/${id}`);
      const jsonData = await response.json();
      setUser(jsonData);
    };

    fetchUser();
  }, [id]);

  return (
    &lt;UserBrief user={user} /&gt;
  );
};
</pre>

<p>This initial approach assumes network requests complete
      instantaneously, which is often not the case. Real-world scenarios require
      handling varying network conditions, including delays and failures. To
      manage these effectively, we incorporate loading and error states into our
      component. This addition allows us to provide feedback to the user during
      data fetching, such as displaying a loading indicator or a skeleton screen
      if the data is delayed, and handling errors when they occur.</p>

<p>Here’s how the enhanced component looks with added loading and error
      management:</p>

<pre>import { useEffect, useState } from &#34;react&#34;;
import { get } from &#34;../utils.ts&#34;;

import type { User } from &#34;../types.ts&#34;;

const Profile = ({ id }: { id: string }) =&gt; {
  const [loading, setLoading] = useState&lt;boolean&gt;(false);
  const [error, setError] = useState&lt;Error | undefined&gt;();
  const [user, setUser] = useState&lt;User | undefined&gt;();

  useEffect(() =&gt; {
    const fetchUser = async () =&gt; {
      try {
        setLoading(true);
        const data = await get&lt;User&gt;(`/users/${id}`);
        setUser(data);
      } catch (e) {
        setError(e as Error);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [id]);

  if (loading || !user) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  return (
    &lt;&gt;
      {user &amp;&amp; &lt;UserBrief user={user} /&gt;}
    &lt;/&gt;
  );
};
</pre>

<p>Now in <code>Profile</code> component, we initiate states for loading,
      errors, and user data with <code>useState</code>. Using
      <code>useEffect</code>, we fetch user data based on <code>id</code>,
      toggling loading status and handling errors accordingly. Upon successful
      data retrieval, we update the user state, else display a loading
      indicator.</p>

<p>The <code>get</code> function, as demonstrated below, simplifies
      fetching data from a specific endpoint by appending the endpoint to a
      predefined base URL. It checks the response&#39;s success status and either
      returns the parsed JSON data or throws an error for unsuccessful requests,
      streamlining error handling and data retrieval in our application. Note
      it&#39;s pure TypeScript code and can be used in other non-React parts of the
      application.</p>

<pre>const baseurl = &#34;https://icodeit.com.au/api/v2&#34;;

async function get&lt;T&gt;(url: string): Promise&lt;T&gt; {
  const response = await fetch(`${baseurl}${url}`);

  if (!response.ok) {
    throw new Error(&#34;Network response was not ok&#34;);
  }

  return await response.json() as Promise&lt;T&gt;;
}
</pre>

<p>React will try to render the component initially, but as the data
      <code>user</code> isn’t available, it returns &#34;loading...&#34; in a
      <code>div</code>. Then the <code>useEffect</code> is invoked, and the
      request is kicked off. Once at some point, the response returns, React
      re-renders the <code>Profile</code> component with <code>user</code>
      fulfilled, so you can now see the user section with name, avatar, and
      title.</p>

<p>If we visualize the timeline of the above code, you will see
      the following sequence. The browser firstly downloads the HTML page, and
      then when it encounters script tags and style tags, it might stop and
      download these files, and then parse them to form the final page. Note
      that this is a relatively complicated process, and I’m oversimplifying
      here, but the basic idea of the sequence is correct.</p>

<div id="timeline-1-1-one-request-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/timeline-1-1-one-request-trans.png"/></p><p>Figure 3: Fetching user
      data</p>
</div>



<p>So React can start to render only when the JS are parsed and executed,
      and then it finds the <code>useEffect</code> for data fetching; it has to wait until
      the data is available for a re-render.</p>

<p>Now in the browser, we can see a &#34;loading...&#34; when the application
      starts, and then after a few seconds (we can simulate such case by add
      some delay in the API endpoints) the user brief section shows up when data
      is loaded.</p>

<div id="user-brief.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/user-brief.png"/></p><p>Figure 4: User brief component</p>
</div>



<p>This code structure (in useEffect to trigger request, and update states
      like <code>loading</code> and <code>error</code> correspondingly) is
      widely used across React codebases. In applications of regular size, it&#39;s
      common to find numerous instances of such same data-fetching logic
      dispersed throughout various components.</p>
</section>

<section id="async-state-handler">
<h2>Asynchronous State Handler</h2>

<p>Wrap asynchronous queries with meta-queries for the state of the
      query.</p>

<p>Remote calls can be slow, and it&#39;s essential not to let the UI freeze
      while these calls are being made. Therefore, we handle them asynchronously
      and use indicators to show that a process is underway, which makes the
      user experience better - knowing that something is happening.</p>

<p>Additionally, remote calls might fail due to connection issues,
      requiring clear communication of these failures to the user. Therefore,
      it&#39;s best to encapsulate each remote call within a handler module that
      manages results, progress updates, and errors. This module allows the UI
      to access metadata about the status of the call, enabling it to display
      alternative information or options if the expected results fail to
      materialize.</p>

<p>A simple implementation could be a function <code>getAsyncStates</code> that
      returns these metadata, it takes a URL as its parameter and returns an
      object containing information essential for managing asynchronous
      operations. This setup allows us to appropriately respond to different
      states of a network request, whether it&#39;s in progress, successfully
      resolved, or has encountered an error.</p>

<pre>const { loading, error, data } = getAsyncStates(url);

if (loading) {
  // Display a loading spinner
}

if (error) {
  // Display an error message
}

// Proceed to render using the data
</pre>

<p>The assumption here is that <code>getAsyncStates</code> initiates the
      network request automatically upon being called. However, this might not
      always align with the caller&#39;s needs. To offer more control, we can also
      expose a <code>fetch</code> function within the returned object, allowing
      the initiation of the request at a more appropriate time, according to the
      caller&#39;s discretion. Additionally, a <code>refetch</code> function could
      be provided to enable the caller to re-initiate the request as needed,
      such as after an error or when updated data is required. The
      <code>fetch</code> and <code>refetch</code> functions can be identical in
      implementation, or <code>refetch</code> might include logic to check for
      cached results and only re-fetch data if necessary.</p>

<pre>const { loading, error, data, fetch, refetch } = getAsyncStates(url);

const onInit = () =&gt; {
  fetch();
};

const onRefreshClicked = () =&gt; {
  refetch();
};

if (loading) {
  // Display a loading spinner
}

if (error) {
  // Display an error message
}

// Proceed to render using the data
</pre>

<p>This pattern provides a versatile approach to handling asynchronous
      requests, giving developers the flexibility to trigger data fetching
      explicitly and manage the UI&#39;s response to loading, error, and success
      states effectively. By decoupling the fetching logic from its initiation,
      applications can adapt more dynamically to user interactions and other
      runtime conditions, enhancing the user experience and application
      reliability.</p>

<section id="ImplementingAsynchronousStateHandlerInReactWithHooks">
<h3>Implementing Asynchronous State Handler in React with hooks</h3>

<p>The pattern can be implemented in different frontend libraries. For
        instance, we could distill this approach into a custom Hook in a React
        application for the Profile component:</p>

<pre>import { useEffect, useState } from &#34;react&#34;;
import { get } from &#34;../utils.ts&#34;;

const useUser = (id: string) =&gt; {
  const [loading, setLoading] = useState&lt;boolean&gt;(false);
  const [error, setError] = useState&lt;Error | undefined&gt;();
  const [user, setUser] = useState&lt;User | undefined&gt;();

  useEffect(() =&gt; {
    const fetchUser = async () =&gt; {
      try {
        setLoading(true);
        const data = await get&lt;User&gt;(`/users/${id}`);
        setUser(data);
      } catch (e) {
        setError(e as Error);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [id]);

  return {
    loading,
    error,
    user,
  };
};
</pre>

<p>Please note that in the custom Hook, we don&#39;t have any JSX code -
        meaning it&#39;s totally UI free but sharable stateful logic. And the
        <code>useUser</code> launch data automatically when called. Within the Profile
        component, leveraging the <code>useUser</code> Hook simplifies its logic:</p>

<pre>import { useUser } from &#39;./useUser.ts&#39;;
import UserBrief from &#39;./UserBrief.tsx&#39;;

const Profile = ({ id }: { id: string }) =&gt; {
  const { loading, error, user } = useUser(id);

  if (loading || !user) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  if (error) {
    return &lt;div&gt;Something went wrong...&lt;/div&gt;;
  }

  return (
    &lt;&gt;
      {user &amp;&amp; &lt;UserBrief user={user} /&gt;}
    &lt;/&gt;
  );
};
</pre>
</section>

<section id="GeneralizingParameterUsage">
<h3>Generalizing Parameter Usage</h3>

<p>In most applications, fetching different types of data—from user
        details on a homepage to product lists in search results and
        recommendations beneath them—is a common requirement. Writing separate
        fetch functions for each type of data can be tedious and difficult to
        maintain. A better approach is to abstract this functionality into a
        generic, reusable hook that can handle various data types
        efficiently.</p>

<p>Consider treating remote API endpoints as services, and use a generic
        <code>useService</code> hook that accepts a URL as a parameter while managing all
        the metadata associated with an asynchronous request:</p>

<pre>import { get } from &#34;../utils.ts&#34;;

function useService&lt;T&gt;(url: string) {
  const [loading, setLoading] = useState&lt;boolean&gt;(false);
  const [error, setError] = useState&lt;Error | undefined&gt;();
  const [data, setData] = useState&lt;T | undefined&gt;();

  const fetch = async () =&gt; {
    try {
      setLoading(true);
      const data = await get&lt;T&gt;(url);
      setData(data);
    } catch (e) {
      setError(e as Error);
    } finally {
      setLoading(false);
    }
  };

  return {
    loading,
    error,
    data,
    fetch,
  };
}
</pre>

<p>This hook abstracts the data fetching process, making it easier to
        integrate into any component that needs to retrieve data from a remote
        source. It also centralizes common error handling scenarios, such as
        treating specific errors differently:</p>

<pre>import { useService } from &#39;./useService.ts&#39;;

const {
  loading,
  error,
  data: user,
  fetch: fetchUser,
} = useService(`/users/${id}`);
</pre>

<p>By using useService, we can simplify how components fetch and handle
        data, making the codebase cleaner and more maintainable.</p>
</section>

<section id="VariationOfThePattern">
<h3>Variation of the pattern</h3>

<p>A variation of the <code>useUser</code> would be expose the
        <code>fetchUsers</code> function, and it does not trigger the data
        fetching itself:</p>

<pre>import { useState } from &#34;react&#34;;

const useUser = (id: string) =&gt; {
  // define the states

  const fetchUser = async () =&gt; {
    try {
      setLoading(true);
      const data = await get&lt;User&gt;(`/users/${id}`);
      setUser(data);
    } catch (e) {
      setError(e as Error);
    } finally {
      setLoading(false);
    }
  };

  return {
    loading,
    error,
    user,
    fetchUser,
  };
};
</pre>

<p>And then on the calling site, <code>Profile</code> component use
        <code>useEffect</code> to fetch the data and render different
        states.</p>

<pre>const Profile = ({ id }: { id: string }) =&gt; {
  const { loading, error, user, fetchUser } = useUser(id);

  useEffect(() =&gt; {
    fetchUser();
  }, []);

  // render correspondingly
};
</pre>

<p>The advantage of this division is the ability to reuse these stateful
        logics across different components. For instance, another component
        needing the same data (a user API call with a user ID) can simply import
        the <code>useUser</code> Hook and utilize its states. Different UI
        components might choose to interact with these states in various ways,
        perhaps using alternative loading indicators (a smaller spinner that
        fits to the calling component) or error messages, yet the fundamental
        logic of fetching data remains consistent and shared.</p>
</section>

<section id="async-state-handler-when">
<h3>When to use it</h3>

<p>Separating data fetching logic from UI components can sometimes
        introduce unnecessary complexity, particularly in smaller applications.
        Keeping this logic integrated within the component, similar to the
        css-in-js approach, simplifies navigation and is easier for some
        developers to manage. In my article, <a href="http://harihareswara.net/articles/modularizing-react-apps.html">Modularizing
        React Applications with Established UI Patterns</a>, I explored
        various levels of complexity in application structures. For applications
        that are limited in scope — with just a few pages and several data
        fetching operations — it&#39;s often practical and also recommended to
        maintain data fetching <i>within</i> the UI components.</p>

<p>However, as your application scales and the development team grows,
        this strategy may lead to inefficiencies. Deep component trees can slow
        down your application (we will see examples as well as how to address
        them in the following sections) and generate redundant boilerplate code.
        Introducing an Asynchronous State Handler can mitigate these issues by
        decoupling data fetching from UI rendering, enhancing both performance
        and maintainability.</p>

<p>It’s crucial to balance simplicity with structured approaches as your
        project evolves. This ensures your development practices remain
        effective and responsive to the application&#39;s needs, maintaining optimal
        performance and developer efficiency regardless of the project
        scale.</p>
</section>
</section>

<section id="ImplementTheFriendsList">
<h2>Implement the Friends list</h2>

<p>Now let’s have a look at the second section of the Profile - the friend
      list. We can create a separate component <code>Friends</code> and fetch data in it
      (by using a useService custom hook we defined above), and the logic is
      pretty similar to what we see above in the <code>Profile</code> component.</p>

<pre>const Friends = ({ id }: { id: string }) =&gt; {
  const { loading, error, data: friends } = useService(`/users/${id}/friends`);

  // loading &amp; error handling...

  return (
    &lt;div&gt;
      &lt;h2&gt;Friends&lt;/h2&gt;
      &lt;div&gt;
        {friends.map((user) =&gt; (
        // render user list
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</pre>

<p>And then in the Profile component, we can use Friends as a regular
      component, and pass in <code>id</code> as a prop:</p>

<pre>const Profile = ({ id }: { id: string }) =&gt; {
  //...

  return (
    &lt;&gt;
      {user &amp;&amp; &lt;UserBrief user={user} /&gt;}
      &lt;Friends id={id} /&gt;
    &lt;/&gt;
  );
};
</pre>

<p>The code works fine, and it looks pretty clean and readable,
      <code>UserBrief</code> renders a <code>user</code> object passed in, while
      <code>Friends</code> manage its own data fetching and rendering logic
      altogether. If we visualize the component tree, it would be something like
      this:</p>

<div id="async-components-1-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/async-components-1-trans.png"/></p><p>Figure 5: Component structure</p>
</div>



<p>Both the <code>Profile</code> and <code>Friends</code> have logic for
      data fetching, loading checks, and error handling. Since there are two
      separate data fetching calls, and if we look at the request timeline, we
      will notice something interesting.</p>

<div id="timeline-1-2-waterfall-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/timeline-1-2-waterfall-trans.png"/></p><p>Figure 6: Request waterfall</p>
</div>



<p>The <code>Friends</code> component won&#39;t initiate data fetching until the user
      state is set. This is referred to as the <b id="fetch-on-render">Fetch-On-Render</b> approach,
      where the initial rendering is paused because the data isn&#39;t available,
      requiring React to wait for the data to be retrieved from the server
      side.</p>

<p>This waiting period is somewhat inefficient, considering that while
      React&#39;s rendering process only takes a few milliseconds, data fetching can
      take significantly longer, often seconds. As a result, the <code>Friends</code>
      component spends most of its time idle, waiting for data. This scenario
      leads to a common challenge known as the <b id="request-waterfall">Request Waterfall</b>, a frequent
      occurrence in frontend applications that involve multiple data fetching
      operations.</p>
</section>

<section id="parallel-data-fetching">
<h2>Parallel Data Fetching</h2>

<p>Run remote data fetches in parallel to minimize wait time</p>

<p>Imagine when we build a larger application that a component that
      requires data can be deeply nested in the component tree, to make the
      matter worse these components are developed by different teams, it’s hard
      to see whom we’re blocking.</p>

<div id="timeline-1-3-waterfall-more-requests-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/timeline-1-3-waterfall-more-requests-trans.png"/></p><p>Figure 7: Request waterfall</p>
</div>



<p><a href="#request-waterfall"> Request Waterfalls</a> can degrade user
      experience, something we aim to avoid. Analyzing the data, we see that the
      user API and friends API are independent and can be fetched in parallel.
      Initiating these parallel requests becomes critical for application
      performance.</p>

<p>One approach is to centralize data fetching at a higher level, near the
      root. Early in the application&#39;s lifecycle, we start all data fetches
      simultaneously. Components dependent on this data wait only for the
      slowest request, typically resulting in faster overall load times.</p>

<p>We could use the <b>Promise</b> API <code>Promise.all</code> to send
      both requests for the user’s basic information and their friends list.
      <code>Promise.all</code> is a JavaScript method that allows for the
      concurrent execution of multiple promises. It takes an array of promises
      as input and returns a single Promise that resolves when all of the input
      promises have resolved, providing their results as an array. If any of the
      promises fail, <code>Promise.all</code> immediately rejects with the
      reason of the first promise that rejects.</p>

<p>For instance, at the application&#39;s root, we can define a comprehensive
      data model:</p>

<pre>type ProfileState = {
  user: User;
  friends: User[];
};

const getProfileData = async (id: string) =&gt;
  Promise.all([
    get&lt;User&gt;(`/users/${id}`),
    get&lt;User[]&gt;(`/users/${id}/friends`),
  ]);

const App = () =&gt; {
  // fetch data at the very begining of the application launch
  const onInit = () =&gt; {
    const [user, friends] = await getProfileData(id);
  }

  // render the sub tree correspondingly
}
</pre>

<section id="ImplementingParallelDataFetchingInReact">
<h3>Implementing Parallel Data Fetching in React</h3>

<p>Upon application launch, data fetching begins, abstracting the
        fetching process from subcomponents. For example, in Profile component,
        both UserBrief and Friends are presentational components that react to
        the passed data. This way we could develop these component separately
        (adding styles for different states, for example). These presentational
        components normally are easy to test and modify as we have separate the
        data fetching and rendering.</p>

<p>We can define a custom hook <code>useProfileData</code> that facilitates
        parallel fetching of data related to a user and their friends by using
        <code>Promise.all</code>. This method allows simultaneous requests, optimizing the
        loading process and structuring the data into a predefined format known
        as <code>ProfileData</code>.</p>

<p>Here’s a breakdown of the hook implementation:</p>

<pre>import { useCallback, useEffect, useState } from &#34;react&#34;;

type ProfileData = {
  user: User;
  friends: User[];
};

const useProfileData = (id: string) =&gt; {
  const [loading, setLoading] = useState&lt;boolean&gt;(false);
  const [error, setError] = useState&lt;Error | undefined&gt;(undefined);
  const [profileState, setProfileState] = useState&lt;ProfileData&gt;();

  const fetchProfileState = useCallback(async () =&gt; {
    try {
      setLoading(true);
      const [user, friends] = await Promise.all([
        get&lt;User&gt;(`/users/${id}`),
        get&lt;User[]&gt;(`/users/${id}/friends`),
      ]);
      setProfileState({ user, friends });
    } catch (e) {
      setError(e as Error);
    } finally {
      setLoading(false);
    }
  }, [id]);

  return {
    loading,
    error,
    profileState,
    fetchProfileState,
  };

};
</pre>

<p>This hook provides the <code>Profile</code> component with the
        necessary data states (<code>loading</code>, <code>error</code>,
        <code>profileState</code>) along with a <code>fetchProfileState</code>
        function, enabling the component to initiate the fetch operation as
        needed. Note here we use <code>useCallback</code> hook to wrap the async
        function for data fetching. The useCallback hook in React is used to
        memoize functions, ensuring that the same function instance is
        maintained across component re-renders unless its dependencies change.
        Similar to the useEffect, it accepts the function and a dependency
        array, the function will only be recreated if any of these dependencies
        change, thereby avoiding unintended behavior in React&#39;s rendering
        cycle.</p>

<p>The <code>Profile</code> component uses this hook and controls the data fetching
        timing via <code>useEffect</code>:</p>

<pre>const Profile = ({ id }: { id: string }) =&gt; {
  const { loading, error, profileState, fetchProfileState } = useProfileData(id);

  useEffect(() =&gt; {
    fetchProfileState();
  }, [fetchProfileState]);

  if (loading) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  if (error) {
    return &lt;div&gt;Something went wrong...&lt;/div&gt;;
  }

  return (
    &lt;&gt;
      {profileState &amp;&amp; (
        &lt;&gt;
          &lt;UserBrief user={profileState.user} /&gt;
          &lt;Friends users={profileState.friends} /&gt;
        &lt;/&gt;
      )}
    &lt;/&gt;
  );
};
</pre>

<p>This approach is also known as <b id="fetch-then-render">Fetch-Then-Render</b>, suggesting that the aim
        is to initiate requests as early as possible during page load.
        Subsequently, the fetched data is utilized to drive React&#39;s rendering of
        the application, bypassing the need to manage data fetching amidst the
        rendering process. This strategy simplifies the rendering process,
        making the code easier to test and modify.</p>

<p>And the component structure, if visualized, would be like the
        following illustration</p>

<div id="async-components-2-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/async-components-2-trans.png"/></p><p>Figure 8: Component structure after refactoring</p>
</div>



<p>And the timeline is much shorter than the previous one as we send two
        requests in parallel. The <code>Friends</code> component can render in a few
        milliseconds as when it starts to render, the data is already ready and
        passed in.</p>

<div id="timeline-1-4-parallel-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/timeline-1-4-parallel-trans.png"/></p><p>Figure 9: Parallel requests</p>
</div>



<p>Note that the longest wait time depends on the slowest network
        request, which is much faster than the sequential ones. And if we could
        send as many of these independent requests at the same time at an upper
        level of the component tree, a better user experience can be
        expected.</p>

<p>As applications expand, managing an increasing number of requests at
        root level becomes challenging. This is particularly true for components
        distant from the root, where passing down data becomes cumbersome. One
        approach is to store all data globally, accessible via functions (like
        Redux or the React Context API), avoiding deep prop drilling.</p>
</section>

<section id="parallel-data-fetching-when">
<h3>When to use it</h3>

<p>Running queries in parallel is useful whenever such queries may be
        slow and don&#39;t significantly interfere with each others&#39; performance.
        This is usually the case with remote queries. Even if the remote
        machine&#39;s I/O and computation is fast, there&#39;s always potential latency
        issues in the remote calls. The main disadvantage for parallel queries
        is setting them up with some kind of asynchronous mechanism, which may be
        difficult in some language environments.</p>

<p>The main reason to not use parallel data fetching is when we don&#39;t
        know what data needs to be fetched until we&#39;ve already fetched some
        data. Certain scenarios require sequential data fetching due to
        dependencies between requests. For instance, consider a scenario on a
        <code>Profile</code> page where generating a personalized recommendation feed
        depends on first acquiring the user&#39;s <b>interests</b> from a user API.</p>

<p>Here&#39;s an example response from the user API that includes
        interests:</p>

<pre>{
  &#34;id&#34;: &#34;u1&#34;,
  &#34;name&#34;: &#34;Juntao Qiu&#34;,
  &#34;bio&#34;: &#34;Developer, Educator, Author&#34;,
  &#34;interests&#34;: [
    &#34;Technology&#34;,
    &#34;Outdoors&#34;,
    &#34;Travel&#34;
  ]
}
</pre>

<p>In such cases, the recommendation feed can only be fetched <b>after</b>
        receiving the user&#39;s interests from the initial API call. This
        sequential dependency prevents us from utilizing parallel fetching, as
        the second request relies on data obtained from the first.</p>

<p>Given these constraints, it becomes important to discuss alternative
        strategies in asynchronous data management. One such strategy is 
        <a href="#fallback-markup">Fallback Markup</a>. This approach allows developers to specify what
        data is needed and how it should be fetched in a way that clearly
        defines dependencies, making it easier to manage complex data
        relationships in an application.</p>

<p>Another example of when arallel Data Fetching is not applicable is
        that in scenarios involving user interactions that require real-time
        data validation.</p>

<p>Consider the case of a list where each item has an &#34;Approve&#34; context
        menu. When a user clicks on the &#34;Approve&#34; option for an item, a dropdown
        menu appears offering choices to either &#34;Approve&#34; or &#34;Reject.&#34; If this
        item&#39;s approval status could be changed by another admin concurrently,
        then the menu options must reflect the most current state to avoid
        conflicting actions.</p>

<div id="approval-list.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/approval-list.png"/></p><p>Figure 10: The approval list that require in-time
        states</p>
</div>



<p>To handle this, a service call is initiated each time the context
        menu is activated. This service fetches the latest status of the item,
        ensuring that the dropdown is constructed with the most accurate and
        current options available at that moment. As a result, these requests
        cannot be made in parallel with other data-fetching activities since the
        dropdown&#39;s contents depend entirely on the real-time status fetched from
        the server.</p>
</section>
</section>

<section id="fallback-markup">
<h2>Fallback Markup</h2>

<p>Specify fallback displays in the page markup</p>

<p>This pattern leverages abstractions provided by frameworks or libraries
      to handle the data retrieval process, including managing states like
      loading, success, and error, behind the scenes. It allows developers to
      focus on the structure and presentation of data in their applications,
      promoting cleaner and more maintainable code.</p>

<p>Let&#39;s take another look at the <code>Friends</code> component in the above
      section. It has to maintain three different states and register the
      callback in <code>useEffect</code>, setting the flag correctly at the right time,
      arrange the different UI for different states:</p>

<pre>const Friends = ({ id }: { id: string }) =&gt; {
  //...
  const {
    loading,
    error,
    data: friends,
    fetch: fetchFriends,
  } = useService(`/users/${id}/friends`);

  useEffect(() =&gt; {
    fetchFriends();
  }, []);

  if (loading) {
    // show loading indicator
  }

  if (error) {
    // show error message component
  }

  // show the acutal friend list
};
</pre>

<p>You will notice that <b>inside</b> a component we have to deal with
      different states, even we extract custom Hook to reduce the noise in a
      component, we still need to pay good attention to handling
      <code>loading</code> and <code>error</code> inside a component. These
      boilerplate code can be cumbersome and distracting, often cluttering the
      readability of our codebase.</p>

<p>If we think of declarative API, like how we build our UI with JSX, the
      code can be written in the following manner that allows you to focus on
      <b>what the component is doing - not how to do it</b>:</p>

<pre>&lt;WhenError fallback={&lt;ErrorMessage /&gt;}&gt;
  &lt;WhenInProgress fallback={&lt;Loading /&gt;}&gt;
    &lt;Friends /&gt;
  &lt;/WhenInProgress&gt;
&lt;/WhenError&gt;
</pre>

<p>In the above code snippet, the intention is simple and clear: when an
      error occurs, <code>ErrorMessage</code> is displayed. While the operation is in
      progress, Loading is shown. Once the operation completes without errors,
      the Friends component is rendered.</p>

<p>And the code snippet above is pretty similiar to what already be
      implemented in a few libraries (including React and Vue.js). For example,
      the new <code>Suspense</code> in React allows developers to more effectively manage
      asynchronous operations within their components, improving the handling of
      loading states, error states, and the orchestration of concurrent
      tasks.</p>

<section id="ImplementingFallbackMarkupInReactWithSuspense">
<h3>Implementing Fallback Markup in React with Suspense</h3>

<p><code>Suspense</code> in React is a mechanism for efficiently handling
        asynchronous operations, such as data fetching or resource loading, in a
        declarative manner. By wrapping components in a <code>Suspense</code> boundary,
        developers can specify fallback content to display while waiting for the
        component&#39;s data dependencies to be fulfilled, streamlining the user
        experience during loading states.</p>

<p>While with the Suspense API, in the <code>Friends</code> you describe what you
        want to get and then render:</p>

<pre>import useSWR from &#34;swr&#34;;
import { get } from &#34;../utils.ts&#34;;

function Friends({ id }: { id: string }) {
  const { data: users } = useSWR(&#34;/api/profile&#34;, () =&gt; get&lt;User[]&gt;(`/users/${id}/friends`), {
    suspense: true,
  });

  return (
    &lt;div&gt;
      &lt;h2&gt;Friends&lt;/h2&gt;
      &lt;div&gt;
        {friends.map((user) =&gt; (
          &lt;Friend user={user} key={user.id} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</pre>

<p>And declaratively when you use the <code>Friends</code>, you use
        <code>Suspense</code> boundary to wrap around the <code>Friends</code>
        component:</p>

<pre>&lt;Suspense fallback={&lt;FriendsSkeleton /&gt;}&gt;
  &lt;Friends id={id} /&gt;
&lt;/Suspense&gt;
</pre>

<p><code>Suspense</code> manages the asynchronous loading of the
        <code>Friends</code> component, showing a <code>FriendsSkeleton</code> 
        placeholder until the component&#39;s data dependencies are
        resolved. This setup ensures that the user interface remains responsive
        and informative during data fetching, improving the overall user
        experience.</p>
</section>

<section id="UseThePatternInVue.js">
<h3>Use the pattern in Vue.js</h3>

<p>It&#39;s worth noting that Vue.js is also exploring a similar
        experimental pattern, where you can employ Fallback Markup using:</p>

<pre>&lt;Suspense&gt;
  &lt;template #default&gt;
    &lt;AsyncComponent /&gt;
  &lt;/template&gt;
  &lt;template #fallback&gt;
    Loading...
  &lt;/template&gt;
&lt;/Suspense&gt;
</pre>

<p>Upon the first render, <code>&lt;Suspense&gt;</code> attempts to render
        its default content behind the scenes. Should it encounter any
        asynchronous dependencies during this phase, it transitions into a
        pending state, where the fallback content is displayed instead. Once all
        the asynchronous dependencies are successfully loaded,
        <code>&lt;Suspense&gt;</code> moves to a resolved state, and the content
        initially intended for display (the default slot content) is
        rendered.</p>
</section>

<section id="DecidingPlacementForTheLoadingComponent">
<h3>Deciding Placement for the Loading Component</h3>

<p>You may wonder where to place the <code>FriendsSkeleton</code>
        component and who should manage it. Typically, without using Fallback
        Markup, this decision is straightforward and handled directly within the
        component that manages the data fetching:</p>

<pre>const Friends = ({ id }: { id: string }) =&gt; {
  // Data fetching logic here...

  if (loading) {
    // Display loading indicator
  }

  if (error) {
    // Display error message component
  }

  // Render the actual friend list
};
</pre>

<p>In this setup, the logic for displaying loading indicators or error
        messages is naturally situated within the <code>Friends</code> component. However,
        adopting Fallback Markup  shifts this responsibility to the
        component’s consumer:</p>

<pre>&lt;Suspense fallback={&lt;FriendsSkeleton /&gt;}&gt;
  &lt;Friends id={id} /&gt;
&lt;/Suspense&gt;
</pre>

<p>In real-world applications, the optimal approach to handling loading
        experiences depends significantly on the desired user interaction and
        the structure of the application. For instance, a hierarchical loading
        approach where a parent component ceases to show a loading indicator
        while its children components continue can disrupt the user experience.
        Thus, it&#39;s crucial to carefully consider at what level within the
        component hierarchy the loading indicators or skeleton placeholders
        should be displayed.</p>

<p>Think of <code>Friends</code> and <code>FriendsSkeleton</code> as two
        distinct component states—one representing the presence of data, and the
        other, the absence. This concept is somewhat analogous to using a <a href="https://martinfowler.com/eaaCatalog/specialCase.html">Speical Case</a> pattern in object-oriented
        programming, where <code>FriendsSkeleton</code> serves as the &#39;null&#39;
        state handling for the <code>Friends</code> component.</p>

<p>The key is to determine the granularity with which you want to
        display loading indicators and to maintain consistency in these
        decisions across your application. Doing so helps achieve a smoother and
        more predictable user experience.</p>
</section>

<section id="fallback-markup-when">
<h3>When to use it</h3>

<p>Using Fallback Markup in your UI simplifies code by enhancing its readability
        and maintainability. This pattern is particularly effective when utilizing
        standard components for various states such as loading, errors, skeletons, and
        empty views across your application. It reduces redundancy and cleans up
        boilerplate code, allowing components to focus solely on rendering and
        functionality.</p>

<p>Fallback Markup, such as React&#39;s Suspense, standardizes the handling of
        asynchronous loading, ensuring a consistent user experience. It also improves
        application performance by optimizing resource loading and rendering, which is
        especially beneficial in complex applications with deep component trees.</p>

<p>However, the effectiveness of Fallback Markup depends on the capabilities of
        the framework you are using. For example, React&#39;s implementation of Suspense for
        data fetching still requires third-party libraries, and Vue’s support for
        similar features is experimental. Moreover, while Fallback Markup can reduce
        complexity in managing state across components, it may introduce overhead in
        simpler applications where managing state directly within components could
        suffice. Additionally, this pattern may limit detailed control over loading and
        error states—situations where different error types need distinct handling might
        not be as easily managed with a generic fallback approach.</p>
</section>
</section>

<section id="IntroducingUserdetailcardComponent">
<h2>Introducing UserDetailCard component</h2>

<p>Let’s say we need a feature that when users hover on top of a <code>Friend</code>,
      we show a popup so they can see more details about that user.</p>

<div id="user-brief-and-friends-user-detail.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/user-brief-and-friends-user-detail.png"/></p><p>Figure 11: Showing user detail
      card component when hover</p>
</div>



<p>When the popup shows up, we need to send another service call to get
      the user details (like their homepage and number of connections, etc.). We
      will need to update the <code>Friend</code> component ((the one we use to
      render each item in the Friends list) ) to something like the
      following.</p>

<pre>import { Popover, PopoverContent, PopoverTrigger } from &#34;@nextui-org/react&#34;;
import { UserBrief } from &#34;./user.tsx&#34;;

import UserDetailCard from &#34;./user-detail-card.tsx&#34;;

export const Friend = ({ user }: { user: User }) =&gt; {
  return (
    &lt;Popover placement=&#34;bottom&#34; showArrow offset={10}&gt;
      &lt;PopoverTrigger&gt;
        &lt;button&gt;
          &lt;UserBrief user={user} /&gt;
        &lt;/button&gt;
      &lt;/PopoverTrigger&gt;
      &lt;PopoverContent&gt;
        &lt;UserDetailCard id={user.id} /&gt;
      &lt;/PopoverContent&gt;
    &lt;/Popover&gt;
  );
};
</pre>

<p>The <code>UserDetailCard</code>, is pretty similar to the
      <code>Profile</code> component, it sends a request to load data and then
      renders the result once it gets the response.</p>

<pre>export function UserDetailCard({ id }: { id: string }) {
  const { loading, error, detail } = useUserDetail(id);

  if (loading || !detail) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  return (
    &lt;div&gt;
    {/* render the user detail*/}
    &lt;/div&gt;
  );
}
</pre>

<p>We’re using <code>Popover</code> and the supporting components from
      <code>nextui</code>, which provides a lot of beautiful and out-of-box
      components for building modern UI. The only problem here, however, is that
      the package itself is relatively big, also not everyone uses the feature
      (hover and show details), so loading that extra large package for everyone
      isn’t ideal - it would be better to load the <code>UserDetailCard</code>
      on demand - whenever it’s required.</p>

<div id="async-components-3-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/async-components-3-trans.png"/></p><p>Figure 12: Component structure with
      UserDetailCard</p>
</div>


</section>

<section id="code-splitting">
<h2>Code Splitting</h2>

<p>Divide code into separate modules and dynamically load them as
      needed.</p>

<p>Code Splitting addresses the issue of large bundle sizes in web
      applications by dividing the bundle into smaller chunks that are loaded as
      needed, rather than all at once. This improves initial load time and
      performance, especially important for large applications or those with
      many routes.</p>

<p>This optimization is typically carried out at build time, where complex
      or sizable modules are segregated into distinct bundles. These are then
      dynamically loaded, either in response to user interactions or
      preemptively, in a manner that does not hinder the critical rendering path
      of the application.</p>

<section id="LeveragingTheDynamicImportOperator">
<h3>Leveraging the Dynamic Import Operator</h3>

<p>The dynamic import operator in JavaScript streamlines the process of
        loading modules. Though it may resemble a function call in your code,
        such as <code>import(&#34;./user-detail-card.tsx&#34;)</code>, it&#39;s important to
        recognize that <code>import</code> is actually a keyword, not a
        function. This operator enables the asynchronous and dynamic loading of
        JavaScript modules.</p>

<p>With dynamic import, you can load a module on demand. For example, we
        only load a module when a button is clicked:</p>

<pre>button.addEventListener(&#34;click&#34;, (e) =&gt; {

  import(&#34;/modules/some-useful-module.js&#34;)
    .then((module) =&gt; {
      module.doSomethingInteresting();
    })
    .catch(error =&gt; {
      console.error(&#34;Failed to load the module:&#34;, error);
    });
});
</pre>

<p>The module is not loaded during the initial page load. Instead, the
        <code>import()</code> call is placed inside an event listener so it only
        be loaded when, and if, the user interacts with that button.</p>

<p>You can use dynamic import operator in React and libraries like
        Vue.js. React simplifies the code splitting and lazy load through the
        <code>React.lazy</code> and <code>Suspense</code> APIs. By wrapping the
        import statement with <code>React.lazy</code>, and subsequently wrapping
        the component, for instance, <code>UserDetailCard</code>, with
        <code>Suspense</code>, React defers the component rendering until the
        required module is loaded. During this loading phase, a fallback UI is
        presented, seamlessly transitioning to the actual component upon load
        completion.</p>

<pre>import React, { Suspense } from &#34;react&#34;;
import { Popover, PopoverContent, PopoverTrigger } from &#34;@nextui-org/react&#34;;
import { UserBrief } from &#34;./user.tsx&#34;;

const UserDetailCard = React.lazy(() =&gt; import(&#34;./user-detail-card.tsx&#34;));

export const Friend = ({ user }: { user: User }) =&gt; {
  return (
    &lt;Popover placement=&#34;bottom&#34; showArrow offset={10}&gt;
      &lt;PopoverTrigger&gt;
        &lt;button&gt;
          &lt;UserBrief user={user} /&gt;
        &lt;/button&gt;
      &lt;/PopoverTrigger&gt;
      &lt;PopoverContent&gt;
        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
          &lt;UserDetailCard id={user.id} /&gt;
        &lt;/Suspense&gt;
      &lt;/PopoverContent&gt;
    &lt;/Popover&gt;
  );
};
</pre>

<p>This snippet defines a <code>Friend</code> component displaying user
        details within a popover from Next UI, which appears upon interaction.
        It leverages <code>React.lazy</code> for code splitting, loading the
        <code>UserDetailCard</code> component only when needed. This
        lazy-loading, combined with <code>Suspense</code>, enhances performance
        by splitting the bundle and showing a fallback during the load.</p>

<p>If we visualize the above code, it renders in the following
        sequence.</p>

<div id="timeline-1-5-dynamic-load-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/timeline-1-5-dynamic-load-trans.png"/></p><p>Figure 13: Dynamic load component
        when needed</p>
</div>



<p>Note that when the user hovers and we download
        the JavaScript bundle, there will be some extra time for the browser to
        parse the JavaScript. Once that part of the work is done, we can get the
        user details by calling <code>/users/&lt;id&gt;/details</code> API.
        Eventually, we can use that data to render the content of the popup
        <code>UserDetailCard</code>.</p>
</section>

<section id="code-splitting-when">
<h3>When to use it</h3>

<p>Splitting out extra bundles and loading them on demand is a viable
        strategy, but it&#39;s crucial to consider how you implement it. Requesting
        and processing an additional bundle can indeed save bandwidth and lets
        users only load what they need. However, this approach might also slow
        down the user experience in certain scenarios. For example, if a user
        hovers over a button that triggers a bundle load, it could take a few
        seconds to load, parse, and execute the JavaScript necessary for
        rendering. Even though this delay occurs only during the first
        interaction, it might not provide the ideal experience.</p>

<p>To improve perceived performance, effectively using React Suspense to
        display a skeleton or another loading indicator can help make the
        loading process seem quicker. Additionally, if the separate bundle is
        not significantly large, integrating it into the main bundle could be a
        more straightforward and cost-effective approach. This way, when a user
        hovers over components like <code>UserBrief</code>, the response can be
        immediate, enhancing the user interaction without the need for separate
        loading steps.</p>
</section>

<section id="LazyLoadInOtherFrontendLibraries">
<h3>Lazy load in other frontend libraries</h3>

<p>Again, this pattern is widely adopted in other frontend libraries as
        well. For example, you can use <code>defineAsyncComponent</code> in Vue.js to
        achieve the samiliar result - only load a component when you need it to
        render:</p>

<pre>&lt;template&gt;
  &lt;Popover placement=&#34;bottom&#34; show-arrow offset=&#34;10&#34;&gt;
  &lt;!-- the rest of the template --&gt;
  &lt;/Popover&gt;
&lt;/template&gt;

&lt;script&gt;
import { defineAsyncComponent } from &#39;vue&#39;;
import Popover from &#39;path-to-popover-component&#39;;
import UserBrief from &#39;./UserBrief.vue&#39;;

const UserDetailCard = defineAsyncComponent(() =&gt; import(&#39;./UserDetailCard.vue&#39;));

// rendering logic
&lt;/script&gt;
</pre>

<p>The function <code>defineAsyncComponent</code> defines an async
        component which is lazy loaded only when it is rendered just like the
        <code>React.lazy</code>.</p>

<p>As you might have already seen the noticed, we are running into a <a href="#request-waterfall"> Request Waterfall</a> here again: we load the
        JavaScript bundle first, and then when it execute it sequentially call
        user details API, which makes some extra waiting time. We could request
        the JavaScript bundle and the network request parallely. Meaning,
        whenever a <code>Friend</code> component is hovered, we can trigger a
        network request (for the data to render the user details) and cache the
        result, so that by the time when the bundle is downloaded, we can use
        the data to render the component immediately.</p>
</section>
</section>

<section id="prefetching">
<h2>Prefetching</h2>

<p>Prefetch data before it may be needed to reduce latency if it is.</p>

<p>Prefetching involves loading resources or data ahead of their actual
      need, aiming to decrease wait times during subsequent operations. This
      technique is particularly beneficial in scenarios where user actions can
      be predicted, such as navigating to a different page or displaying a modal
      dialog that requires remote data.</p>

<p>In practice, prefetching can be
      implemented using the native HTML <code>&lt;link&gt;</code> tag with a
      <code>rel=&#34;preload&#34;</code> attribute, or programmatically via the
      <code>fetch</code> API to load data or resources in advance. For data that
      is predetermined, the simplest approach is to use the
      <code>&lt;link&gt;</code> tag within the HTML <code>&lt;head&gt;</code>:</p>

<pre>&lt;!doctype html&gt;
&lt;html lang=&#34;en&#34;&gt;
  &lt;head&gt;
    &lt;link rel=&#34;preload&#34; href=&#34;/bootstrap.js&#34; as=&#34;script&#34;&gt;

    &lt;link rel=&#34;preload&#34; href=&#34;/users/u1&#34; as=&#34;fetch&#34; crossorigin=&#34;anonymous&#34;&gt;
    &lt;link rel=&#34;preload&#34; href=&#34;/users/u1/friends&#34; as=&#34;fetch&#34; crossorigin=&#34;anonymous&#34;&gt;

    &lt;script type=&#34;module&#34; src=&#34;/app.js&#34;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&#34;root&#34;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>With this setup, the requests for <code>bootstrap.js</code> and user API are sent
      as soon as the HTML is parsed, significantly earlier than when other
      scripts are processed. The browser will then cache the data, ensuring it
      is ready when your application initializes.</p>

<p>However, it&#39;s often not possible to know the precise URLs ahead of
      time, requiring a more dynamic approach to prefetching. This is typically
      managed programmatically, often through event handlers that trigger
      prefetching based on user interactions or other conditions.</p>

<p>For example, attaching a <code>mouseover</code> event listener to a button can
      trigger the prefetching of data. This method allows the data to be fetched
      and stored, perhaps in a local state or cache, ready for immediate use
      when the actual component or content requiring the data is interacted with
      or rendered. This proactive loading minimizes latency and enhances the
      user experience by having data ready ahead of time.</p>

<pre>document.getElementById(&#39;button&#39;).addEventListener(&#39;mouseover&#39;, () =&gt; {
  fetch(`/user/${user.id}/details`)
    .then(response =&gt; response.json())
    .then(data =&gt; {
      sessionStorage.setItem(&#39;userDetails&#39;, JSON.stringify(data));
    })
    .catch(error =&gt; console.error(error));
});
</pre>

<p>And in the place that needs the data to render, it reads from
      <code>sessionStorage</code> when available, otherwise showing a loading indicator.
      Normally the user experiense would be much faster.</p>

<section id="ImplementingPrefetchingInReact">
<h3>Implementing Prefetching in React</h3>

<p>For example, we can use <code>preload</code> from the
        <code>swr</code> package (the function name is a bit misleading, but it
        is performing a prefetch here), and then register an
        <code>onMouseEnter</code> event to the trigger component of
        <code>Popover</code>,</p>

<pre>import { preload } from &#34;swr&#34;;
import { getUserDetail } from &#34;../api.ts&#34;;

const UserDetailCard = React.lazy(() =&gt; import(&#34;./user-detail-card.tsx&#34;));

export const Friend = ({ user }: { user: User }) =&gt; {
  const handleMouseEnter = () =&gt; {
    preload(`/user/${user.id}/details`, () =&gt; getUserDetail(user.id));
  };

  return (
    &lt;Popover placement=&#34;bottom&#34; showArrow offset={10}&gt;
      &lt;PopoverTrigger&gt;
        &lt;button onMouseEnter={handleMouseEnter}&gt;
          &lt;UserBrief user={user} /&gt;
        &lt;/button&gt;
      &lt;/PopoverTrigger&gt;
      &lt;PopoverContent&gt;
        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
          &lt;UserDetailCard id={user.id} /&gt;
        &lt;/Suspense&gt;
      &lt;/PopoverContent&gt;
    &lt;/Popover&gt;
  );
};
</pre>

<p>That way, the popup itself can have much less time to render, which
        brings a better user experience.</p>

<div id="timeline-1-6-preload-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/timeline-1-6-preload-trans.png"/></p><p>Figure 14: Dynamic load with prefetch
        in parallel</p>
</div>



<p>So when a user hovers on a <code>Friend</code>, we download the
        corresponding JavaScript bundle as well as download the data needed to
        render the UserDetailCard, and by the time <code>UserDetailCard</code>
        renders, it sees the existing data and renders immediately.</p>

<div id="async-components-4-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/async-components-4-trans.png"/></p><p>Figure 15: Component structure with
        dynamic load</p>
</div>



<p>As the data fetching and loading is shifted to <code>Friend</code>
        component, and for <code>UserDetailCard</code>, it reads from the local
        cache maintained by <code>swr</code>.</p>

<pre>import useSWR from &#34;swr&#34;;

export function UserDetailCard({ id }: { id: string }) {
  const { data: detail, isLoading: loading } = useSWR(
    `/user/${id}/details`,
    () =&gt; getUserDetail(id)
  );

  if (loading || !detail) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  return (
    &lt;div&gt;
    {/* render the user detail*/}
    &lt;/div&gt;
  );
}
</pre>

<p>This component uses the <code>useSWR</code> hook for data fetching,
        making the <code>UserDetailCard</code> dynamically load user details
        based on the given <code>id</code>. <code>useSWR</code> offers efficient
        data fetching with caching, revalidation, and automatic error handling.
        The component displays a loading state until the data is fetched. Once
        the data is available, it proceeds to render the user details.</p>

<p>In summary, we&#39;ve already explored critical data fetching strategies:
        <a href="#async-state-handler">Asynchronous State Handler</a> , <a href="#parallel-data-fetching">Parallel Data Fetching</a> ,
        <a href="#fallback-markup">Fallback Markup</a> , <a href="#code-splitting">Code Splitting</a> and <a href="#prefetching">Prefetching</a> . Elevating requests for parallel execution
        enhances efficiency, though it&#39;s not always straightforward, especially
        when dealing with components developed by different teams without full
        visibility. Code splitting allows for the dynamic loading of
        non-critical resources based on user interaction, like clicks or hovers,
        utilizing prefetching to parallelize resource loading.</p>
</section>

<section id="prefetching-when">
<h3>When to use it</h3>

<p>Consider applying prefetching when you notice that the initial load time of
          your application is becoming slow, or there are many features that aren&#39;t
          immediately necessary on the initial screen but could be needed shortly after.
          Prefetching is particularly useful for resources that are triggered by user
          interactions, such as mouse-overs or clicks. While the browser is busy fetching
          other resources, such as JavaScript bundles or assets, prefetching can load
          additional data in advance, thus preparing for when the user actually needs to
          see the content. By loading resources during idle times, prefetching utilizes the
          network more efficiently, spreading the load over time rather than causing spikes
          in demand.</p>

<p>It’s wise to follow a general guideline: don&#39;t implement complex patterns like
        prefetching until they are clearly needed. This might be the case if performance
        issues become apparent, especially during initial loads, or if a significant
        portion of your users access the app from mobile devices, which typically have
        less bandwidth and slower JavaScript engines. Also, consider that there are other
        performance optimization tactics such as caching at various levels, using CDNs
        for static assets, and ensuring assets are compressed. These methods can enhance
        performance with simpler configurations and without additional coding. The
        effectiveness of prefetching relies on accurately predicting user actions.
        Incorrect assumptions can lead to ineffective prefetching and even degrade the
        user experience by delaying the loading of actually needed resources.</p>
</section>
</section>

<section id="ChoosingTheRightPattern">
<h2>Choosing the right pattern</h2>



<p>Selecting the appropriate pattern for data fetching and rendering in
      web development is not one-size-fits-all. Often, multiple strategies are
      combined to meet specific requirements. For example, you might need to
      generate some content on the server side - using Server-Side Rendering
      techniques - supplemented by client-side <a href="#fetch-then-render">
      Fetch-Then-Render</a> for dynamic
      content. Furthermore, non-essential sections can be split into separate
      bundles for lazy loading, possibly with <a href="#prefetching">Prefetching</a> triggered by user
      actions, such as hover or click.</p>

<p>Consider the Jira issue page as an example. The top navigation and
      sidebar are static, loading first to give users immediate context. Early
      on, you&#39;re presented with the issue&#39;s title, description, and key details
      like the Reporter and Assignee. For less immediate information, such as
      the History section at an issue&#39;s bottom, it loads only upon user
      interaction, like clicking a tab. This utilizes lazy loading and data
      fetching to efficiently manage resources and enhance user experience.</p>

<div id="multiple-patterns-trans.png"><p><img src="http://harihareswara.net/posts/2024/things-i-wish-id-done-before-catching-covid/data-fetch-spa/multiple-patterns-trans.png"/></p><p>Figure 16: Using patterns together</p>
</div>



<p>Moreover, certain strategies require additional setup compared to
      default, less optimized solutions. For instance, implementing <a href="#code-splitting">Code Splitting</a>  requires bundler support. If your current bundler lacks this
      capability, an upgrade may be required, which could be impractical for
      older, less stable systems.</p>

<p>We&#39;ve covered a wide range of patterns and how they apply to various
      challenges. I realize there&#39;s quite a bit to take in, from code examples
      to diagrams. If you&#39;re looking for a more guided approach, I&#39;ve put
      together <a href="https://www.icodeit.com.au/tutorials/advanced-network-patterns-react">a comprehensive tutorial</a> on my
      website, or if you only want to have a look at the working code, they are
      all hosted <a href="https://github.com/abruzzi/react-network-advanced-client-side">in this github repo</a>.</p>
</section>

<section id="Conclusion">
<h2>Conclusion</h2>

<p>Data fetching is a nuanced aspect of development, yet mastering the
      appropriate techniques can vastly enhance our applications. As we conclude
      our journey through data fetching and content rendering strategies within
      the context of React, it&#39;s crucial to highlight our main insights:</p>

<ul>
<li><b><a href="#async-state-handler">Asynchronous State Handler</a></b>: Utilize custom hooks or composable APIs to
        abstract data fetching and state management away from your components. This
        pattern centralizes asynchronous logic, simplifying component design and
        enhancing reusability across your application.</li>

<li><b><a href="#fallback-markup">Fallback Markup</a></b>: React&#39;s enhanced Suspense model supports a more
        declarative approach to fetching data asynchronously, streamlining your
        codebase.</li>

<li><b><a href="#parallel-data-fetching">Parallel Data Fetching</a></b>: Maximize efficiency by fetching data in
        parallel, reducing wait times and boosting the responsiveness of your
        application.</li>

<li><b><a href="#code-splitting">Code Splitting</a></b>: Employ lazy loading for non-essential
        components during the initial load, leveraging Suspense for graceful
        handling of loading states and code splitting, thereby ensuring your
        application remains performant.</li>

<li><b><a href="#prefetching">Prefetching</a></b>: By preemptively loading data based on predicted user
        actions, you can achieve a smooth and fast user experience.</li>
</ul>

<p>While these insights were framed within the React ecosystem, it&#39;s
      essential to recognize that these patterns are not confined to React
      alone. They are broadly applicable and beneficial strategies that can—and
      should—be adapted for use with other libraries and frameworks. By
      thoughtfully implementing these approaches, developers can create
      applications that are not just efficient and scalable, but also offer a
      superior user experience through effective data fetching and content
      rendering practices.</p>
</section>

<hr/>
</div></div>
  </body>
</html>
