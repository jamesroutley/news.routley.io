<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonyfinn.com/blog/jj/">Original</a>
    <h1>Jujutsu (jj), a Git compatible VCS</h1>
    
    <div id="readability-page-1" class="page"><div>
        

<p>It&#39;s quite a common opinion that git (while a big improvement on
what came before) still has plenty of rough edges, particularly
with regards to the user interface. At the same time, there&#39;s
also a significant barrier to entry for a new version control
system with all the tooling that&#39;s built up around git over
the years, particularly if you want to try it in your workplace
without migrating the entire company.</p>
<p><a href="https://github..com/martinvonz/jj">jj</a> is one of the latest round of git-compatible version control
systems which allows you to have a better experience locally,
without having to abandon everything that depends on git. I&#39;ve
been trying it out now for about two months, and this post shares
some of my thoughts.</p>
<h3 id="my-background-with-version-control-systems">My background with version control systems</h3>
<p>I first learned of the concept of a version control system
from a <a href="https://blog.codinghorror.com/setting-up-subversion-on-windows">Coding Horror blog post on SVN</a> back
when I was still in school in 2007. I used SVN for a few
personal projects, and even pushed some to Google Code.</p>
<p>Some time in the intervening years, probably on Hacker News, I
started hearing about this new DVCS thing. However it was hard to
get Git running on Windows, which I was using at the time, so I
initially ignored it (as much as Github <em>did</em> look nicer than
Google Code)</p>
<p>A few years later, Joel Spolsky published the sadly-now-offline
<a href="https://web.archive.org/web/20180104040234/http://hginit.com">hginit</a>. This was a guide for Mercurial (<code>hg</code>).
Mercurial had a clone of the SVN UI I was using
(TortoiseHg), was much easier to install on Windows, and
hginit explained it in a way that was much easier to understand.
<code>hg</code> even had a github-like hosting site in Bitbucket, which even
had free private repos, unlike Github at that time.</p>
<p>I actually held onto <code>hg</code> longer than most outside Facebook, but
the writing was on the wall and I mostly migrated to git around
2014 - this was also when I started working professionally, and
my workplace had just undergone a SVN to git migration shortly
before I joined. That said, I still had some personal hg repos
until bitbucket shut down their hosting support in
<a href="https://tonyfinn.com/blog/jj/bitbucket-hg-eol">2020</a>.</p>
<p>Despite not really using the advanced features of hg, and later
becoming the person who received a lot of the git questions in
future teams, I always felt that hg had a much more usable UI
and it seemed unfortunate that git never got there. Still, it
would be swimming against the flow too much to use something
like <a href="https://github.com/schacon/hg-git">hg-git</a>, so I basically used git and learned its rough
edges and that was more or less fine for the next several years.</p>
<h3 id="use-cases">Use Cases</h3>
<p>I have three use cases for a version control system:</p>
<ol>
<li>Work. The company I work for, Personio, has a few different
types of repo - a legacy monolith PHP application with 10s
of commits a day, a monorepo for frontend services with similar traffic, and a number of backend microservices with
less frequent changes.</li>
<li>Open Source. I&#39;ve got a couple of open source libraries
like <a href="https://gitlab.com/tonyfinn/kdbx-rs">kdbx-rs</a> which occasionally recieve third party
contributions on Gitlab.com or Github.com but are mostly
maintained by me</li>
<li>Side projects. I have personal private side projects that
I work on that are mostly just me, but even then I sometimes
have branched work or work on different devices. This website
is one :)</li>
</ol>
<h3 id="a-change-in-the-landscape">A change in the landscape</h3>
<p><a href="https://sapling-scm.com">Sapling</a> was my first big sign that there
was a new wave of VCSes around that might provide a new option.
While the likes of <a href="https://fossil-scm.org">Fossil</a> and <a href="https://darcs.net">Darcs</a> had always
been out there, having to convince everyone to abandon Git
(and especially Github for open source or Gitlab in companies)
meant that trying out a new VCS yourself felt like a waste of
time.</p>
<p>Sapling is Facebook&#39;s fork of Mercurial, with a
number of major QOL features built in and the backend replaced
by Git. This means that you could use Sapling on a project while
all the rest of your team mates use Git and all your git-based
CI tools will continue along happily.</p>
<p>Earlier this year I decided I would try out one of the new wave
of VCSes, to see what I was missing.</p>
<p>Sapling is the most mature of these git-compatible replacement
solutions, but it had one fatal missing feature which meant I
couldn&#39;t use it in my workplace - <a href="https://sapling-scm.com/docs/git/signing">it didn&#39;t support SSH signing
of commits</a>.</p>
<p><code>jj</code> (despite generally being less mature/feature complete) did
have this, so I decided to experiment with <code>jj</code>. In the last 1.5
months, I have now ran a single digit number of git commands as I
started using <code>jj</code> everywhere.</p>
<h3 id="jj-vs-git">jj vs git</h3>
<p><code>jj</code> has two backends, the native backend and the <code>git</code> backend.
While the native backend is tested for use in <code>jj</code>, given the
world of tooling and hosting options out there, it&#39;s assumed
that you&#39;ll be using the git backend. So for most users, <code>jj</code>
functions as a layer on top of git.</p>
<p>The biggest difference between jj and git is that git revolves
around <strong>commits</strong> as the main unit of change, while <code>jj</code>
revolves around <strong>changesets</strong>. Unlike a commit, a change set
provides a stable identifier around a set of changes even as
those changes are revised, which is both convenient for CLI use
and enables the other improvements around merging and automatic
rebasing. For example, if you revise a commit, then the commit
ID changes, but the changeset ID stays the same. This means <code>jj</code>
knows to rebase all subsequent changes on that updated commit.
It&#39;s a bit like <code>commit --amend</code> anywhere, and without the
two steps of <code>commit --fixup</code> and autosquash.</p>
<p>Another major difference between <code>jj</code> and <code>git</code> is that the
primary method of branching is anonymous branches. This might
be more familiar to <code>hg</code> users, and depending on your
workflow might be anywhere from very convenient to irrelevant. In
particular, if you need to make MRs with a system like github,
then you&#39;ll probably still be naming your branches with the
<code>bookmark</code> feature. But you don&#39;t have to, and if you&#39;re
using a trunk based development workflow or a tool like gerrit,
this saves an extra step.</p>
<p><code>jj</code> generally tries to reduce the number of concepts a
developer needs to understand. This comes through in both the
simpler UI, and in the smaller number of concepts to deal with.</p>
<p>Some examples:</p>
<ul>
<li>stashes in git? Just use commits.</li>
<li>Does a system
need both fast forward merges <em>and</em> rebases? <code>jj</code> goes with
just rebases.</li>
<li>Do you need a bunch of commands for different types of merge,
or can you just create a new change with a list
of parents?</li>
<li>Working copy? Just a commit.</li>
</ul>
<p>To elaborate on the idea that the working copy is just a commit
— every <code>jj</code> command updates that working copy commit to
include all files from your checkout. . I&#39;ve seen many
of my colleagues who default to <code>git add -A</code> or
<code>git commit -a</code> so for them this kind of change would be
nice, but if you&#39;re someone like me who used to deliberately
assemble commits with <code>git add</code>, you&#39;ll need to learn a new
workflow (<code>jj</code> offers two options – <code>jj split</code> which might
be more familiar to those used to <code>git add [-p]</code> and the
<code>jj squash</code> workflow which more builds on the fact that the
working copy is just a commit).</p>
<p>A final difference worth commmenting on is that the <code>jj log</code>
command is smarter by default than <code>git log</code>. As with Sapling, it
will show you an abbreviated tree of all the commits you
care about (tracked branches, the trunk, and local
branches, though this is configurable). This is more useful than
the default in git of just showing the ancestors of the current
<code>HEAD</code> commit.</p>
<h3 id="the-good">The Good</h3>
<p>A developer of a competing (but not git compatible) VCS described
<code>jj</code> as a better <code>git rerere</code>, and while that was meant as a
criticism on how far it can diverge from <code>git</code>, it is a very nice
feature. On more active repos like the monolith application, I&#39;ve
often got into the situation of fixing the same merge conflict
repeatedly and <code>jj</code> so far has handled the situations which would
cause that much better. It even manages to handle this despite
my workplace enforcing squash merges on MRs with just one comment.
It makes working on multiple changes, including some dependent changes, much nicer.</p>
<p>Similarly, Steve Klabnik&#39;s in progress tutorial clued me in on
the flow where you can
<a href="https://steveklabnik.github.io/jujutsu-tutorial/advanced/simultaneous-edits.html">rebase all your branches</a> at once when
there&#39;s new updates. This also showed me that you can also work
on the merged state of
all your changes, so you can know they&#39;ll all merge cleanly into
the final result, even if things are broken up into smaller PRs
for the sake of your teammates reviewing it. Previously this was
painful enough that I&#39;d often find something else to work on
while some changes were awaiting review.</p>
<p>The CLI is a lot more consistent than git and so was very quick
to pick up. There&#39;s a serious effort to keep the number of
command and concepts down, without ending up like the very
overloaded <code>git checkout</code> and <code>git reset</code> commands. (Or even
like <code>git switch</code> and <code>git restore</code>, which while they have a better
seperation of concerns, can still be unclear).</p>
<p>Having concepts like the stash and the working copy be &#34;just
a commit&#34; does wonders for simplifying the mental model. I was
a heavy <code>stash</code> user, both for handling context switches, and
for things like having an easy way to apply a debugging config,
and having that concept represented by commits makes it much
easier to deal with when &#34;stashes&#34; don&#39;t cleanly apply. With
<code>git stash</code> you basically just need to recreate the stash
if you don&#39;t want to deal with fixing the conflict every
time but with <code>jj</code> you can just rebase your changeset. You
<em>could</em> make yourself use commits for this in git, and I&#39;ve
tried at times, but it&#39;s really swimming against the tide.</p>
<p>I think I arrived just after they made <code>jj split</code> nicer to
use for splitting changes into seperate commits, but I do
suggest that you try the
<a href="https://steveklabnik.github.io/jujutsu-tutorial/real-world-workflows/the-squash-workflow.htmla"><code>jj squash</code> workflow</a>. It&#39;s a
little different to how you work with git (or what a squash
workflow is in git, for those who are not fans of the
common pattern of squashing a branch into a single commit always)
but it was pretty easy to get used to.</p>
<p>Revsets are nice. They&#39;re not the as big to me as they seem to be
to others, but I always have terrible trouble remembering if it&#39;s
<code>HEAD^^</code> or <code>HEAD~~</code> or <code>HEAD^2</code> or <code>HEAD~2</code> etc., (or which
need shell escaping) for referring to a few
commits ago. The revset language seems more logical to me.</p>
<h3 id="the-bad">The Bad</h3>
<p><code>jj</code> is still under active development, and
so some features are missing or undecided on if they&#39;ll ever
support them. For example, it&#39;s not clear if <code>tag</code> is totally
needed as a different concept to <code>bookmark</code> so <code>jj</code> doesn&#39;t
support them. But e.g. the Gitlab/Github UI for releases
expect tags, so I had to drop down to <code>git</code> to tag <code>v0.5.2</code>
of <code>kdbx-rs</code> earlier this month.</p>
<p>This also means there&#39;s a decent amount of churn. For example
NixOS 24.05 comes with version 0.17.0 which is about 4 months
old, while homebrew comes with version 0.22.0 which is a couple
of weeks old. There&#39;s enough drift that commands that work in one
do not work in the other, so I resorted to installing 0.22.0 from
<code>nixpkgs-unstable</code> for my personal machines.</p>
<p>This also applies to core concepts - for example, the latest
release renames <code>branch</code>es to <code>bookmark</code>s and all their
associated commands. <code>jj branch</code> still works for now and prints
a warning about it being deprecated in favour of the renamed
version, but this is the level of early development <code>jj</code> is at.</p>
<p>For SSH support, <code>jj</code> has two options. There&#39;s the
inbuilt <code>libgit2</code> ssh (based on <code>libssh</code>), or if there&#39;s a
running <code>ssh-agent</code>, it will connect to that agent. My experience
is that the the <code>libgit2</code> ssh stuff is effectively non-functional
on any of my setups. It probably works if you have a single unencrypted key
at <code>~/.ssh/id_rsa</code> or <code>~/.ssh/id_ed25519</code>, but between keys in
password managers at work and SSH certificates in my personal
environment, I don&#39;t fit into that bucket, so I need to make
sure all my keys are loaded into my <code>ssh-agent</code> before performing
<code>jj git fetch</code> or <code>jj git push</code>.</p>
<p>There&#39;s still a couple of rough edges. For example, on one
of my repos, I had renamed <code>master</code> to <code>main</code> some months ago,
but started working on a checkout that still had a local
<code>master</code> branch. <code>jj</code> decided that was the main upstream branch,
and then when I fetched from the remote, that deleted the
<code>master</code> branch and broke... basically everything in <code>jj</code> in
that repo. I filed a <a href="https://github.com/martinvonz/jj/issues/4616">bug report</a> and in
fairness to the <code>jj</code>developers, there was a MR merged <a href="https://github.com/martinvonz/jj/pulls/4617">the same
day</a> to check for this error state and give
resolution steps to the user.</p>
<p>CLI confusion is also still sometimes present. One example is
that many <code>jj</code> commmands can take a <code>-r</code>
revision parameter or a combo of <code>--from</code> and <code>--to</code> to operate
on a range, but <code>-r</code> can also refer to a range. It feels liklocal
or <code>.direnv</code> directories (which might appear to contain e.g.
all of <code>nixpkgs</code>, multiple times). This makes nix operations
very slow and disk space heavy, which is especially frustrating
if you use <code>direnv</code> as it makes your shell prompt very slow.</p>
<h3 id="the-ugly">The Ugly</h3>
<p><code>jj</code> has two modes. There&#39;s the colocated mode, where the
underlying <code>.git</code> folder is directly exposed so the repo appears
to <code>jj</code>-unaware tools as a git repo (though one with a dangling
HEAD pointer), and the seperated repo where the <code>.git</code> folder
is hidden within the <code>.jj</code> folder, or entirely elsewhere on
disk. Generally, it feels cleaner to use the mode where <code>jj</code>
manages the <code>git</code> repo out of sight - for example, my shell
<code>git</code> prompt is basically noise for a dangling <code>HEAD</code> commit
and my editor will proudly tell me about how much it has staged
even though <code>jj</code> doesn&#39;t use the staging area.</p>
<p>However, one tool which really doesn&#39;t work well with the <code>.git</code>
folder hidden is Nix, specifically with flakes. flakes piggy
back on git for a number of important details like tracking
input files, and in the absence of the <code>.git</code> folder will fall
back to storing <em>everything</em> in the git store. And I really
mean everything. The <code>.jj</code> folder, the <code>.git</code> folder
that is undereath that, those files you&#39;ve <code>.gitignore</code>&#39;d like <code>node_modules</code>
or <code>.direnv</code> directories (which might appear to contain e.g.
all of <code>nixpkgs</code>, multiple times). This makes nix operations
very slow and disk space heavy, which is especially frustrating
if you use <code>direnv</code> as it makes your shell prompt very slow.</p>
<p>There is a fix for the nix interaction though, which is to just
always use colocated repos if you&#39;re using Nix. And this is more
on Nix than it is on <code>jj</code>, it would be good to have a
<code>flakeignore</code> or have it only import paths referenced in
<code>flake.nix</code> into the store, but given I&#39;ve previously done a
multi-part series on Nix Flakes, I figured I should warn people
about this poor interaction.</p>
<h3 id="what-next">What next?</h3>
<p>I still intend to try out Sapling at some stage. There&#39;s a
<a href="https://martinvonz.github.io/jj/latest/sapling-comparison/">comparison on the jj website</a>, but it was nice
for <code>jj</code> that I could make the change <em>everywhere, all at once</em>
while Sapling is not yet usable in my work setting. But maybe
I&#39;ll try it on some personal projects or maybe their SSH signing
setup will become flexible enough to accomodate my employer&#39;s
setup.</p>
<p>Other than that though, <code>jj</code> has proven itself enough that it&#39;s
going to be how I interact with <code>git</code> from now on.</p>
<hr/>

    </div></div>
  </body>
</html>
