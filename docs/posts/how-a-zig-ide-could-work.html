<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2023/02/10/how-a-zig-ide-could-work.html">Original</a>
    <h1>How a Zig IDE Could Work</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>

    
<p>Zig is a very interesting language from an IDE point of view.
Some aspects of it are friendly to IDEs, like a very minimal and simple-to-parse syntax
(Zig can even be <em>correctly</em> lexed line-by-line, very cool!),
the absence of syntactic macros, and ability to do a great deal of semantic analysis on a file-by-file basis, in parallel.
On the other hand, <code>comptime</code>.
I accidentally spent sometime yesterday thinking about how to build an IDE for that, this post is a result.</p>
<section id="How-Does-the-Zig-Compiler-Work">

    <h2>
    <a href="#How-Does-the-Zig-Compiler-Work">How Does the Zig Compiler Work? </a>
    </h2>
<p>It’s useful to discuss a bit how the compiler works today.
For something more thorough, refer to this excellent series of posts: <a href="https://mitchellh.com/zig">https://mitchellh.com/zig</a>.</p>
<p>First, each Zig file is parsed into an AST.
Delightfully, parsing doesn’t require any context whatsoever, it’s a pure <code>[]const u8 -&gt; Ast</code> function, and the resulting Ast is just a piece of data.</p>
<p>After parsing, the Ast is converted to an intermediate representation, Zir.
This is where Zig diverges a bit from more typical statically compiled languages.
Zir actually resembles something like Python’s bytecode — an intermediate representation that an interpreter for a dynamically-typed language would use.
That’s because it <em>is</em> an interpreter’s IR — the next stage would use Zir to evaluate comptime.</p>
<p>Let’s look at an example:</p>

<figure>


<pre><code>fn generic_add(comptime T: type, lhs: T, rhs: T) T {</code>
<code>  return lhs + rhs;</code>
<code>}</code></pre>

</figure>
<p>Here, the Zir for <code>generic_add</code> would encode addition as a typeless operation, because we don’t know types at this point.
In particular, <code>T</code> can be whatever.
When the compiler would <em>instantiate</em> <code>generic_add</code> with different <code>T</code>s, like <code>generic_add(u32, ...)</code>, <code>generic_add(f64, ...)</code>, it will re-use the same Zir for different instantiations.
That’s the two purposes of Zir: to directly evaluate code at compile time, and to serve as a template for monomorphisation.</p>
<p>The next stage is where the magic happens — the compiler partially evaluates dynamically typed Zir to convert it into a fairly standard statically typed IR.
The process starts at the <code>main</code> function.
The compiler more or less tries to evaluate the Zir.
If it sees something like <code>90 + 2</code>, it directly evaluates that to <code>92</code>.
For something which can’t be evaluated at compile time, like <code>a + 2</code> where <code>a</code> is a runtime variable, the compiler generates typed IR for addition (as, at this point, we already know the type of <code>a</code>).</p>
<p>When the compiler sees something like</p>

<figure>


<pre><code>const T = u8;</code>
<code>const x = generic_add(T, a, b);</code></pre>

</figure>
<p>the compiler monomorphises the generic call.
It checks that all comptime arguments (<code>T</code>) are fully evaluated, and starts partial evaluation of the called function, with comptime parameters fixed to particular values (this of course is memoized).</p>
<p>The whole process is lazy — only things transitively used from main are analyzed.
Compiler won’t complain about something like</p>

<figure>


<pre><code>fn unused() void {</code>
<code>    1 + &#34;&#34;;</code>
<code>}</code></pre>

</figure>
<p>This looks perfectly fine at the Zir level, and the compiler will not move beyond Zir unless the function is actually called somewhere.</p>
</section>
<section id="And-an-IDE">

    <h2>
    <a href="#And-an-IDE">And an IDE? </a>
    </h2>
<p>IDE adds several dimensions to the compiler:</p>
<ul>
<li>
works with incomplete and incorrect code
</li>
<li>
works with code which rapidly changes over time
</li>
<li>
gives results immediately, there is no edit/compile cycle
</li>
<li>
provides source to source transformations
</li>
</ul>
<p>The hard bit is the combination of rapid changes and immediate results.
This is usually achieved using some smart, language-specific combination of</p>
<ul>
<li>
<p>Incrementality: although changes are frequent and plentiful, they are local, and it is often possible to re-use large chunks of previous analysis.</p>
</li>
<li>
<p>Laziness: unlike a compiler, an IDE does not need full analysis results for the entirety of the codebase.
Usually, analysis of the function which is currently being edited is the only time-critical part, everything else can be done asynchronously, later.</p>
</li>
</ul>
<p>This post gives an overview of some specific fruitful combinations of the two ideas:</p>
<p><a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html">https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html</a></p>
<p>How can we apply the ideas to Zig?
Let’s use this as our running example:</p>

<figure>


<pre><code>fn guinea_pig(comptime T: type, foo: Foo) void {</code>
<code>    foo.&lt;complete here&gt;;</code>
<code></code>
<code>    helper(T).&lt;here&gt;;</code>
<code></code>
<code>    var t: T = undefined;</code>
<code>    t.&lt;and here&gt;;</code>
<code>}</code></pre>

</figure>
<p>There are two, separate interesting questions to ask here:</p>
<ul>
<li>
what result do we even want here?
</li>
<li>
how to achieve that given strict performance requirements?
</li>
</ul>
</section>
<section id="Just-Compile-Everything">

    <h2>
    <a href="#Just-Compile-Everything">Just Compile Everything </a>
    </h2>
<p>It’s useful to start with a pedantically correct approach.
Let’s run our usual compilation (recursively monomorphising called functions starting from the <code>main</code>).
The result would contain a bunch of different monomorphisations of <code>guinea_pig</code>, for different values of <code>T</code>.
For each <em>specific</em> monomorphisation it’s now clear what is the correct answer.
For the unspecialized case as written in the source code, the IDE can now show something reasonable by combining partial results from each monomorphisation.</p>
<p>There are several issues with this approach.</p>
<p><em>First</em>, collecting the <em>full</em> set of monomorphisations is not well-defined in the presence of conditional compilation.
Even if you run the “full” compilation starting from main, today compiler assumes some particular environment (eg, Windows or Linux), which doesn’t give you a full picture.
There’s a fascinating issue about multibuilds — making the compiler process all combinations of conditional compilation flags at the same time: <a href="https://github.com/ziglang/zig/issues/3028">zig#3028</a>.
With my IDE writer hat on, I really hope it gets in, as it will move IDE support from inherently heuristic territory, to something where, in principle, there’s a correct result (even if might not be particularly easy to compute).</p>
<p>The <em>second</em> problem is that this probably is going to be much too slow.
If you think about IDE support for the first time, a very tantalizing idea is to try to lean just into incremental compilation.
Specifically, you can imagine a compiler that maintains fully type-checked and resolved view of the code at all times.
If a user edits something, the compiler just incrementally changes what needs to be changed.
So the trick for IDE-grade interactive performance is just to implement sufficiently advanced incremental compilation.</p>
<p>The problem with sufficiently incremental compiler is that even the perfect incrementality, which does the minimal required amount of work, will be slow in a non-insignificant amount of cases.
The nature of code is that a small change to the source in a single place might lead to a large change to resolved types all over the project.
For examples, changing the name of some popular type invalidates all the code that uses this type.
That’s the fundamental reason why IDE try hard to maintain an ability to <em>not</em> analyze everything.</p>
<p>On the other hand, at the end of the day you’ll have to do this work at least by the time you run the tests.
And Zig’s compiler is written from the ground up to be very incremental and very fast, so perhaps this will be good enough?
My current gut feeling is that the answer is no — even if you <em>can</em> re-analyze everything in, say, 100ms, that’ll still require burning the battery for essentially useless work.
Usually, there’s a lot more atomic small edits for a single test run.</p>
<p>The <em>third</em> problem with the approach of collection all monomorphisations is that it simply does not work if the function isn’t actually called, yet.
Which is common in incomplete code that is being written, exactly the use-case where the IDE is most useful!</p>
</section>
<section id="Compile-Only-What-We-Need">

    <h2>
    <a href="#Compile-Only-What-We-Need">Compile Only What We Need </a>
    </h2>
<p>Thinking about the “full” approach more, it feels like it could be, at least in theory, optimized somewhat.
Recall that in this approach we have a graph of function instantiations, which starts at the root (<code>main</code>), and contains various monomorphisations of <code>guinea_pig</code> on paths reachable from the root.</p>
<p>It is clear we actually don’t need the full graph to answer queries about instantiations of <code>guinea_pig</code>.
For example, if we have something like</p>

<figure>


<pre><code>fn helper() i32 {</code>
<code>    ...</code>
<code>}</code></pre>

</figure>
<p>and the <code>helper</code> does not (transitively) call <code>guinea_pig</code>, we can avoid looking into its body, as the signature is enough to analyze everything else.</p>
<p>More precisely, given the graph of monomorphizations, we can select minimal subgraph which includes all paths from <code>main</code> to <code>guinea_pig</code> instantiations, as well as all the functions whose bodies we need to process to understand their signatures.
My intuition is that the size of that subgraph is going to be much smaller than the whole thing, and, in principle, an algorithm which would analyze only that subgraph should be speedy enough in practice.</p>
<p>The problem though is that, as far as I know, it’s not possible to understand what belongs to the subgraph without analysing the whole thing!
In particular, using compile-time reflection our <code>guinea_pig</code> can be called through something like <code>comptime &#34;guinea&#34; ++ &#34;_pig&#34;</code>.
Its impossible to infere call graph just from Zir.</p>
<p>And of course this does not help the case where the function isn’t called at all.</p>
</section>
<section id="Abstract-Comptime-Interpretation">

    <h2>
    <a href="#Abstract-Comptime-Interpretation">Abstract Comptime Interpretation </a>
    </h2>
<p>It is possible to approach</p>

<figure>


<pre><code>fn guinea_pig(comptime T: type, foo: Foo) void {</code>
<code>    foo.&lt;complete here&gt;;</code>
<code></code>
<code>    helper(T).&lt;here&gt;;</code>
<code></code>
<code>    var t: T = undefined;</code>
<code>    t.&lt;and here&gt;;</code>
<code>}</code></pre>

</figure>
<p>from a different direction.
What if we just treat this function as the root of our graph?
We can’d do that exactly, because it has some comptime parameters.
But we <em>can</em> say that we have some opaque values for the parameters: <code>T = opaquevalue</code>.
Of course, we won’t be able to fully evaluate everything and things like <code>if (T == int)</code> would probably need to propagate opaqueness.
At the same time, something like the result of <code>BoundedArray(opaque)</code> would still be pretty useful for an IDE.</p>
<p>I am wondering if there’s even perhaps some compilation-time savings in this approach?
My understanding (which might be very wrong!) is that if a generic function contains something like <code>90 + 2</code>, this expression would be comptime-evaluated anew for every instantiation.
In theory, what we could do is to partially evaluate this function substituting opaque values for comptime parameters, and then, for any specific instantiation, we can use the result of this partial evaluation as a template.
Not sure what that would mean precisely though: it definitely would be more complicated than just substituting <code>T</code>s in the result.</p>
</section>
<section id="What-is-to-Be-Done">

    <h2>
    <a href="#What-is-to-Be-Done">What is to Be Done? </a>
    </h2>
<p>Ast and Zir infra is good.
It is per-file, so it naturally just works in an IDE.</p>
<p><a href="https://github.com/ziglang/zig/issues/3028">Multibuilds</a> are important.
I am somewhat skeptical that they’ll actually fly, and its not a complete game over if they don’t
(Rust has the same problem with conditional compilation, and it does create fundamental problems for both the users and authors of IDEs, but the end result is still pretty useful).
Still, if Zig does ship multibuilds, that’d be awesome.</p>
<p>Given the unused function problem, I think its impossible to avoid at least some amount of abstract interpretation, so <code>Sema</code> has to learn to deal with opaque values.</p>
<p>With abstract interpretation machinery in place, it can be used as a first, responsive layer of IDE support.</p>
<p>Computing the full set of monomoprizations in background can be used to augment these limited synchronous features with precise results asynchronously.
Though, this might be tough to express in existing editor UIs.
Eg, the goto definition result is now an asynchronous stream of values.</p>
<p>Discussion on <a href="https://old.reddit.com/r/Zig/comments/10ysssh/blog_post_how_a_zig_ide_could_work/">/r/zig</a>.</p>
</section>
</article>
  </div></div>
  </body>
</html>
