<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://praydog.com/reverse-engineering/2023/07/03/uevr.html">Original</a>
    <h1>UEVR: An Exploration of Advanced Game Hacking Techniques (2023)</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <header>
<a href="https://medium.com/">home..</a>

  <ul>
  
    <li>
      <a href="https://github.com/praydog">
        github
      </a>
        
    </li>
  
    <li>
      <a href="https://patreon.com/praydog">
        donations
      </a>
        
    </li>
  
    <li>
      <a href="https://medium.com/articles.html">
        articles
      </a>
        
    </li>
  
    <li>
      <a href="https://medium.com/feed.xml">
        feed
      </a>
        
    </li>
  
</ul>

  

</header>


<p>
  
    <span>praydog</span> / 
  
  
    <span>July 2023</span>
  


  
  
  (9023 Words, 
  51 Minutes)
  

</p>




  


<ul>
  <li>
    <p>Disclaimer: Most of what is talked about here is not new, and has been used in the security industry for a long time. This article is meant to show how these techniques can be used to locate functions, variables, and structure offsets within games, rather than identify malware.</p>
  </li>
  <li>
    <p>Disclaimer 2: This article assumes an x86-64 binary target, compiled under Windows, using the Microsoft Visual C++ compiler. Some of the techniques may not be applicable to other platforms/compilers, or may require some modifications.</p>
  </li>
</ul>

<p>The sphere of game hacking and modding has a rich history, tightly knit with a well-known practice called AOB (Array of Bytes) scanning, also known as signature scanning. This method, similarly employed within the realm of security, is a traditional approach used to detect malicious code or, in the context of modding and hacking, locate specific areas within a program’s memory.</p>

<p>In the realm of security, there exists a suite of techniques encompassing static, dynamic, and heuristic analysis. For the purpose of this discussion, we’ll refer to this group of methods as “binary analysis”. The question: could we leverage these techniques to create more robust code scanning techniques? This isn’t about superseding signature scanning; instead, it’s about broadening our capabilities, adding more depth to our strategies.</p>

<p>Automated binary analysis, static and dynamic, while not a novel approach, is sometimes applied within the game hacking community but is less frequently discussed. However, when used appropriately, these techniques can offer a powerful enhancement to - or even an alternative for - traditional AOB scanning. There are other reasons why these techniques would be used, but that is not the focus of this article.</p>

<p>Many of the techniques described here require the reader to have already identified areas of interest via something like IDA Pro, x64dbg, Cheat Engine, or other tools. From there, we will use automated techniques to locate these areas of interest, such as functions, global variables, or structure offsets.</p>

<p>Let’s start by introducing a practical project that demonstrates these advanced techniques in action. The <strong>Unreal Engine Virtual Reality project (UEVR)</strong> is a real-world initiative I’ve been working on that uses many of the techniques described in this article.</p>

<h2 id="a-real-world-project">A Real World Project</h2>
<p>Theory is great, but it’s not very useful without practical application.</p>

<p>That’s why there is a project I have been working on that uses many of these techniques. It’s meant to work on almost any Unreal Engine game. 
It adds 6DOF VR support to as many Unreal Engine games as possible, with little to no intervention required for the most part on the user’s end (kind of like an emulator in an ideal state).</p>

<p>Using many of the techniques described here, it is possible to make such a project. It’s called <a href="https://github.com/praydog/UEVR">UEVR</a>. This project has been my playground for experimenting with these techniques, and it’s been a great learning experience.</p>

<p>For information on just how many games (hundreds confirmed at the time of writing) it works on, and to <em>what degree</em>, see the <a href="https://docs.google.com/spreadsheets/d/1ZcjCQwzPOltaRZnpYU5_HPihEDareZq_0Ww1DZQ4USw/edit#gid=0">compatibility list</a>.</p>

<h3 id="the-core-goals-of-uevr">The core goals of UEVR</h3>

<ul>
  <li>At a base level, it must at least provide full 6DOF head tracking and stereoscopic rendering</li>
  <li>The game UI must be corrected and displayed in world space</li>
  <li>It must be robust, and work on as many Unreal Engine games as possible</li>
  <li>It must be easy to use, and not require any technical knowledge to use (inject and <em>mostly</em> forget)
    <ul>
      <li>There may be cases with extremely problematic games where this might not be the case, but it should be the exception, not the rule</li>
    </ul>
  </li>
  <li>It must be performant, and not cause any noticeable performance impact on the game
    <ul>
      <li>However, VR in and of itself is a performance intensive task, so there will be some performance impact</li>
      <li>However, care is taken so the core code is performant</li>
      <li>The project takes advantage of using the native stereo rendering pipeline built into UE by default, so this is already an optimization</li>
    </ul>
  </li>
  <li>It must be extremely generic, and not require any fixes for specific games, and only operate on the assumption that the target is operating under the Unreal Engine</li>
  <li>Provide modders with an API to add motion controller support (<a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/GettingStarted/">Blueprint</a> and C++)</li>
  <li>Provide the user with ways to tweak their experience, and to fix game specific issues that may arise
    <ul>
      <li>An in-game menu with controller support to tweak settings</li>
      <li>Options to choose OpenVR or OpenXR</li>
      <li>Common <a href="https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/DevelopmentSetup/Tools/ConsoleManager/">CVars</a> to fix issues, or enhance the experience</li>
      <li>Multiple rendering methods to choose from to fix things like rendering issues or crashes</li>
      <li>Ways to tweak the world scale, camera offset</li>
      <li>Features such as Decoupled Pitch to reduce motion sickness</li>
      <li>A homebrew console that has access to all of the CVars, and not just the common ones, as well as the commands of the Unreal Engine</li>
    </ul>
  </li>
</ul>

<p>UEVR uses the following libraries:</p>

<ul>
  <li><a href="https://github.com/cursey/safetyhook">safetyhook</a> for function hooking (inline and <a href="https://aixxe.net/2022/12/safetyhook-midfn-hooking">mid-hooks</a>)</li>
  <li><a href="https://github.com/bitdefender/bddisasm">bddisasm and bdshemu</a> for disassembly and emulation</li>
  <li><a href="https://github.com/cursey/kananlib">kananlib</a> which is a library I helped write which contains many of these techniques</li>
</ul>

<details>
<summary>Click here to see an overview of the techniques used in UEVR, and how it works in general</summary>

<div>
    
    <h3 id="piggybacks-off-of-a-built-in-unreal-engine-command-line-mechanism-called--emulatestereo-which-emulates-a-stereo-device-splitting-the-desktop-screen-in-two-with-two-cameras-at-separate-positions">Piggybacks off of a built-in Unreal Engine command-line mechanism called <code>-emulatestereo</code> which “emulates” a stereo device, splitting the desktop screen in two with two cameras at separate positions</h3>
    <ul>
      <li><code>-emulatestereo</code> uses a built-in class called <code>FFakeStereoRendering</code> which inherits from <code>IStereoRendering</code>, which UEVR aims to hook</li>
      <li>For reference, <code>IStereoRendering</code> contains virtuals relevant to creating a proper stereoscopic image, these include:
        <ul>
          <li>A method for overriding the projection matrices</li>
          <li>A method for overriding the view matrices (rotation via euler angles, position via vec3)</li>
          <li>A method for modifying how the viewport is presented (left/right eye width/height/x/y)</li>
          <li>A method for creating a texture as a viewport render target
            <ul>
              <li>The default <code>FFakeStereoRendering</code> interface does not implement this</li>
              <li>This allows the VR headset to get a full resolution image at the runtime’s requested resolution</li>
              <li>Using dynamic analysis from the return address of this virtual, we can locate the real function that creates textures
                <ul>
                  <li>For context, if our function returns <code>false</code>, the engine falls back to its own texture creation method</li>
                  <li>This is also abused to create our UI render target at the same time</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    
    <h3 id="string-reference-analysis-is-used-in-several-places-to-find-the-relevant-structures-and-functions-for-this-process">String reference analysis is used in several places to find the relevant structures and functions for this process</h3>
    <ul>
      <li>For its initial starting and <a href="#anchors">anchor</a> points, it uses string reference scanning to locate:
        <ul>
          <li>The <code>GEngine</code> global object
            <ul>
              <li>The <code>&#34;CALIBRATEMOTION&#34;</code> string has always been referenced near a reference to <code>GEngine</code> since early in UE4 development</li>
              <li>Finds the function start where this string is referenced in and looks for global variables via <a href="#static-analysis-disassembly-at-runtime">static analysis</a></li>
              <li>This is the <code>UGameEngine</code> instance</li>
              <li>Contains the <code>StereoRenderingDevice</code> object among other things</li>
              <li>Needed to call <code>InitializeHMDDevice</code> to create an <code>FFakeStereoRendering</code> instance</li>
            </ul>
          </li>
          <li>The vtable for <code>FFakeStereoRendering</code>
            <ul>
              <li>There are various configuration strings referenced within the constructor for <code>FFakeStereoRendering</code></li>
              <li>Finds the function start where these strings are referenced and looks for a <code>LEA</code> instruction via <a href="#static-analysis-disassembly-at-runtime">static analysis</a></li>
              <li>There are some cases where it appears to have been #ifdef’d out, but this is extremely rare
                <ul>
                  <li>If this happens, UEVR will manually construct a plausible <code>IStereoRendering</code> vtable and use that instead</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>The function for <code>UGameEngine::InitializeHMDDevice</code>
            <ul>
              <li>There is a reference to the string <code>&#34;emulatestereo&#34;</code> and a reference to the CVar for <code>r.EnableStereoEmulation</code> in this function</li>
              <li>This allows us to create an <code>FFakeStereoRendering</code> instance without telling the user to use <code>-emulatestereo</code>
                <ul>
                  <li>A few methods are used to achieve this, the main one is forcing <code>r.EnableStereoEmulation</code> to <code>1</code></li>
                  <li>The other is tricking the game into thinking <code>-emulatestereo</code> was passed in as a command-line argument via code-patching</li>
                </ul>
              </li>
              <li>After this is called, we can bruteforce scan for the <code>FFakeStereoRendering</code> vtable we found earlier inside of the global <code>GEngine</code> object to obtain the object and offset</li>
              <li>Alternatives/fallbacks are in place to auto-locate the offset in <code>UGameEngine</code> for the <code>StereoRenderingDevice</code> for manual creation if either one of these processes fail</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    
    <h3 id="tries-to-minimize-use-of-plain-aobs-signatures">Tries to minimize use of plain AOBs (signatures)</h3>
    <ul>
      <li>Only uses them when necessary</li>
      <li>Only uses them in a localized scenario (such as within the bounds of a function or near an <a href="#anchors">anchor</a> point)</li>
      <li>Instead relies mainly on string refs, and prefers disassembly
        <ul>
          <li>Unique string references are preferred, but not required (strings that are referenced in only one place)</li>
          <li>Strings are human readable, easier to maintain, more likely to reside within the binary through updates, and are less likely to change</li>
        </ul>
      </li>
    </ul>

    
    <h3 id="using-several-of-these-techniques-uevr-analyzes-the-ffakestereorendering-vtable-and-identifies-the-relevant-vtable-indices-which-has-changed-a-lot-over-the-years-of-unreal-engine-development">Using several of these techniques, UEVR analyzes the <code>FFakeStereoRendering</code> vtable and identifies the relevant vtable indices (which has changed a lot over the years of Unreal Engine development)</h3>
    <ul>
      <li>A few of the ways it finds relevant virtual functions to replace:
        <ul>
          <li>Emulation
            <ul>
              <li>This is necessary to deal with obfuscation, it has been seen in the wild on these virtuals</li>
              <li>Obfuscation seen ranged anywhere from a simple <code>jmp</code> wrapper to multiple layers of control flow obfuscation to simply <code>return true</code></li>
            </ul>
          </li>
          <li>General disassembly</li>
          <li>Signature scanning</li>
          <li>Presence of references to specific strings</li>
          <li>Presence of calls to imports like <code>tanf</code> or <code>tan</code></li>
          <li>Presence of a large amount of xmm registers
            <ul>
              <li>This also detects UE5 based on usage of double precision xmm instructions</li>
            </ul>
          </li>
          <li><a href="#heuristic-analysis">Heuristic analysis</a> and <a href="#anchors">anchor</a> points
            <ul>
              <li>Like assuming that a certain virtual lies a specific distance from another if things like:
                <ul>
                  <li>Multiple or single functions return <code>nullptr</code> in a row preceding it</li>
                  <li>Multiple or single functions return <code>true</code> or <code>false</code> in a row preceding it</li>
                  <li>Multiple functions mix <code>nullptr</code> and <code>true</code>/<code>false</code> returns, forming a unique pattern</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    
    <h3 id="it-replaces-the-relevant-vtable-indices-with-hooks-to-its-own-functions-for-proper-output-to-a-vr-headset-using-the-openvropenxr-apis-as-well-as-d3d11d3d12">It replaces the relevant vtable indices with hooks to its own functions for proper output to a VR headset (using the OpenVR/OpenXR APIs, as well as D3D11/D3D12)</h3>

    
    <h3 id="it-goes-even-further-by-using-these-techniques-in-several-different-ways-such-as">It goes even further by using these techniques in several different ways such as</h3>
    <ul>
      <li>Using the return addresses or call stack of some of the virtual functions as <a href="#anchors">anchor</a> points to:
        <ul>
          <li>Find other functions, variables, and offsets of interest</li>
          <li>Find the local player object by using call stack analysis, <a href="#data-flow-analysis">data flow analysis</a> and <a href="https://aixxe.net/2022/12/safetyhook-midfn-hooking">mid-function hooks</a>
            <ul>
              <li>This can be found via other methods, but I did not want to construct a completely new method for this</li>
              <li>Relied instead on methods I already had in place, taking advantage of the fact that some of the virtuals in the vtable are called from functions where the local player is the <code>this</code> pointer</li>
            </ul>
          </li>
          <li>After the local player is found, its vtable is bruteforced to locate the <code>PostInitProperties</code> function
            <ul>
              <li>Using path exhaustive disassembly, it checks for references to the <code>GEngine</code> global, it’s the only function that does this within the vtable
                <ul>
                  <li>This method is necessary because it doesn’t always reside within the first call stack level</li>
                </ul>
              </li>
              <li>When calling this function, a <a href="https://learn.microsoft.com/en-us/windows/win32/debug/using-a-vectored-exception-handler">vectored exception handler</a> must be setup to catch exceptions that occur on development/debug builds of games
                <ul>
                  <li>It also goes even further and tries to patch out any exception-causing calls and instructions beforehand through path exhaustion</li>
                  <li>This is because the engine will assert if a view state is already created for any eye (so, if this function was called already)</li>
                </ul>
              </li>
              <li>Calling this function will create the second view state for the other eye, so we don’t crash when doing stereo rendering</li>
              <li>This function is normally called by the engine when enabling VR or using <code>-emulatestereo</code> immediately when the game starts, but not at any point afterwards</li>
            </ul>
          </li>
          <li>Find and hook the texture creation function in combination with <a href="https://aixxe.net/2022/12/safetyhook-midfn-hooking">mid hooks</a>
            <ul>
              <li>In particular, this is achieved by performing emulation and disassembly after the return address of <code>IStereoRenderTargetManager::AllocateRenderTargetTexture</code>, placing the <a href="https://aixxe.net/2022/12/safetyhook-midfn-hooking">mid hook</a> right before the call to the creation function, as well as after</li>
              <li>This is used not only to create our viewport render target, but to create our UI render target as well</li>
            </ul>
          </li>
          <li>Find the calling function or walk the callstack</li>
          <li>Insert <em>other</em> hooks on areas of interest (inline and mid hooks)</li>
        </ul>
      </li>
      <li>Locates and hooks <code>UGameEngine::Tick</code> in a few ways:
        <ul>
          <li>Multiple <a href="#string-reference-scanning">string reference</a> options</li>
          <li>Vtable analysis after locating <code>UEngine::Tick</code> pure virtual as a reference point</li>
          <li>In extreme cases it can try hooking it via call stack analysis from the <code>UGameViewportClient::Draw</code> hook if all fails</li>
          <li>Code path exhaustion via <a href="#static-analysis-disassembly-at-runtime">static analysis</a> to locate specific strings buried deep within the function like <code>&#34;causeevent=&#34;</code>
            <ul>
              <li>Does this by disassembling all of <code>UGameEngine</code>’s virtual functions (after we’ve found <code>GEngine</code>)</li>
              <li>Follows all branches that are possible from a static perspective (hence, path exhaustion)</li>
              <li>This is necessary sometimes because:
                <ul>
                  <li>Compiler optimizations or obfuscation</li>
                  <li>Sometimes the string identifying the function is buried beneath several jmps or calls (direct and indirect)</li>
                  <li>Locating the start of the function after finding the stringref sometimes fails</li>
                  <li>Attempting to use emulation may not cover the specific branch path the string resides in</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>This function is very important which necessitates multiple fallbacks</li>
        </ul>
      </li>
      <li>Locates and hooks <code>UGameViewportClient::Draw</code>
        <ul>
          <li>Looks for a reference to the string <code>&#34;CanvasObject&#34;</code> in the function</li>
          <li>There can be multiple references to this <code>&#34;CanvasObject&#34;</code> string because:
            <ul>
              <li>There can be multiple viewport types</li>
              <li>We only need one specific one, so we have to analyze each function that this string is contained in</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Locates and hooks <code>FViewport::Draw</code> by analyzing the call stack from a <code>UGameViewportClient::Draw</code> hook</li>
      <li>Locates and hooks <code>FSlateRHIRenderer::DrawWindow_RenderThread</code> by:
        <ul>
          <li>Analyzing where the <code>Slate.DrawToVRRenderTarget</code> CVar is referenced</li>
          <li>If this fails, analyzes the return address of <code>IStereoRendering::RenderTexture_RenderThread</code> which is directly called within <code>FSlateRHIRenderer::DrawWindow_RenderThread</code></li>
          <li>This is used to force the game to render the UI to our UI render target instead of the viewport render target
            <ul>
              <li>Done by replacing one of the argument’s member fields with our UI render target temporarily
                <ul>
                  <li>This particular field offset is obtained by bruteforce and emulation of all vtables residing within the object</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Locates the <code>ViewExtensions</code> member of <code>UGameEngine</code>:
        <ul>
          <li>This is done by assuming that it’s fixed distance ahead of the <code>StereoRenderingDevice</code> member offset
            <ul>
              <li>This can be seen as using the <code>StereoRenderingDevice</code> offset as an <a href="#anchors">anchor</a> point</li>
              <li>This <a href="#heuristic-analysis">assumption</a> was made by seeing that it’s held true for years of Unreal Engine development</li>
            </ul>
          </li>
          <li>This particular interface is very powerful and allows us to insert hooks at various points in the rendering pipeline</li>
        </ul>
      </li>
      <li>After locating the <code>ViewExtensions</code> member:
        <ul>
          <li>It inserts a dummy vtable that has many variants of the same function using template metaprogramming</li>
          <li>The purpose of this is to locate various functions of interest, based on how the virtual functions are being called, and how often</li>
          <li>It also uses this to bruteforce the offset for the frame count within the <code>ViewFamily</code> passed to <code>BeginRenderViewFamily</code> and others
            <ul>
              <li>Detects which offsets that have integer-like values that are increasing by 1 every call</li>
              <li>The frame count is used by UEVR to track the flow of rendering data until DXGI presents the frame
                <ul>
                  <li>This mainly allows technologies like the runtime’s <a href="https://en.wikipedia.org/wiki/Asynchronous_reprojection">Asynchronous Reprojection</a> to work correctly</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>After these steps are done, it inserts the final vtable with the indices found from the analysis</li>
        </ul>
      </li>
      <li>Locates and hooks the <code>FSceneView</code> constructor
        <ul>
          <li>There are two strings in this function, <code>&#34;r.TranslucentSortPolicy&#34;</code> and <code>&#34;vr.InstancedStereo&#34;</code></li>
          <li>This is a bit complex though, because <code>&#34;r.TranslucentSortPolicy&#34;</code> is actually referenced in multiple functions</li>
          <li>Also, the <code>&#34;vr.InstancedStereo&#34;</code> string isn’t guaranteed to be at the same call stack level as the other string
            <ul>
              <li>It’s sometimes nested within a call inside the constructor</li>
            </ul>
          </li>
          <li>Because of this, we need to locate all <code>&#34;r.TranslucentSortPolicy&#34;</code> references, and then analyze each function to see if it contains the <code>&#34;vr.InstancedStereo&#34;</code> string
            <ul>
              <li>We do this by exhaustively disassembling each function and following all possible branches until we find an instruction that references the <code>&#34;vr.InstancedStereo&#34;</code> string</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Uses static and dynamic analysis to locate virtual function indices for the <code>IConsoleVariable</code> vtable
        <ul>
          <li>After locating a CVar, the vtable is bruteforced and analyzed to find the indices of functions that are used by the engine
            <ul>
              <li><code>Set</code></li>
              <li><code>GetInt</code></li>
              <li><code>GetFloat</code></li>
              <li><code>Execute</code> (For IConsoleCommand)</li>
            </ul>
          </li>
          <li>After locating destructor-like function(s), these functions are known to be ahead of them</li>
          <li>Through behavior analysis and heuristic guesswork, the indices of the functions are found</li>
        </ul>
      </li>
    </ul>

    
    <h3 id="utilizes-several-fallback-techniques-in-case-the-main-techniques-fail-such-as">Utilizes several fallback techniques in-case the main techniques fail such as:</h3>
    <ul>
      <li>Hardcoded vtable indices in extreme cases based on PDB dumps of compiled release builds of Unreal Engine</li>
      <li>Detection of different texture creation methods and accounting for them</li>
      <li>Detection of older UE games based on how the virtual functions are laid out
        <ul>
          <li>This can manifest in several ways
            <ul>
              <li>Missing virtual functions</li>
              <li>Repeating virtual functions (such as multiple nullptr returns in a row followed by a valid function)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    
    <ul>
      <li>Bruteforces through the texture vtable to find certain functions (such as those that return an <code>ID3D12Resource</code> pointer)
        <ul>
          <li>It does this by checking if the returned pointer’s vtable resides within any of the DirectX DLLs</li>
        </ul>
      </li>
      <li>Bruteforces through certain structures to find offsets based on what they point to</li>
      <li>All of these analysis techniques are used instead of using PDB dumps because various factors can cause differences in shipped code and PDB dumps
        <ul>
          <li>This includes compiler optimizations, obfuscation, and other factors such as adjustments made by the game developers</li>
        </ul>
      </li>
    </ul>

    
    <h3 id="finds-other-non-essential-things-such-as">Finds other non-essential things such as:</h3>
    <ul>
      <li>The <code>GUObjectArray</code> global variable
        <ul>
          <li>Searches for two strings that must reside in the same function
            <ul>
              <li>This is an extremely precise heuristic, especially when dealing with multiple string refs for one string</li>
            </ul>
          </li>
          <li>These strings have been present in the engine for years</li>
          <li>Fully disassembles the function, looking for displacements</li>
          <li>Uses structure analysis against each displacement to probe for the <code>GUObjectArray</code> global variable
            <ul>
              <li>Checks that integer values in the structure look like integers</li>
              <li>Checks that the pointer to the objects is a valid pointer</li>
              <li>Checks that the first element of the array is a valid pointer and points to a valid vtable</li>
            </ul>
          </li>
          <li>Once a suitable candidate has been identified:
            <ul>
              <li>Goes even further and detects &lt;= UE 4.10 (which is an inlined array) through similar structure analysis</li>
              <li>Goes even further and checks for the chunked variant of the array through similar structure analysis</li>
              <li>Detects the distance between <code>FUObjectItem</code> elements via bruteforce scanning for valid pointers to <code>UObjectBase</code></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Bruteforces offsets for various <code>UObject</code>, <code>FField</code>, <code>FProperty</code>, etc… structures
        <ul>
          <li>Uses known structure relationships to probe for offsets</li>
        </ul>
      </li>
      <li>The <code>FName::ToString()</code> function
        <ul>
          <li>Easily found via multiple string references</li>
          <li>Can sometimes be inlined, so there are fallbacks in place</li>
        </ul>
      </li>
    </ul>

    <h3 id="there-are-various-other-techniques-used-but-they-are-too-numerous-to-list-here-or-the-intricacies-are-too-complex-to-explain-in-a-short-summary">There are various other techniques used, but they are too numerous to list here or the intricacies are too complex to explain in a short summary</h3>

    
  </div>

</details>
<h3 id="overall-in-essence-tries-very-hard-to-recreate-what-the-official-vr-plugins-for-the-unreal-engine-do-without-requiring-the-game-to-include-them">Overall, in essence: tries very hard to recreate what the official VR plugins for the Unreal Engine do, without requiring the game to include them</h3>

<h3 id="for-context-the-official-vr-plugins-are-what-allow-the-engine-to-render-to-the-hmd-properly-in-the-first-place-they-act-as-a-bridge-between-the-engine-and-the-hmd-sdks">For context: the official VR plugins are what allow the engine to render to the HMD properly in the first place, they act as a bridge between the engine and the HMD SDKs</h3>



<h2 id="a-brief-history-of-signatures">A Brief History of Signatures</h2>

<p>AOB scanning, or signature scanning, have long been used as a means to locate specific areas in a program’s memory. The technique consists of identifying unique sequences of bytes that correspond to certain operations or data. This practice, which started in the field of antivirus software, quickly found its way to the modding/hacking community, where it became an essential tool. These sequence of bytes can be a function prologue, a magic number, a specific string, and many other things.</p>

<p>One such industry tool that employs signatures is <a href="https://github.com/VirusTotal/yara">YARA</a>, a versatile malware identification and classification tool. <a href="https://github.com/VirusTotal/yara">YARA</a> leverages signatures as part of its sets of rules that identify malware based on binary or textual patterns. The use of signatures, while effective in some scenarios, often encounters issues when dealing with complex game updates, function changes, engine differences, or compiler changes, mainly due to its rigidity and specificity.</p>

<h2 id="binary-analysis-in-the-security-industry">Binary Analysis in the Security Industry</h2>

<p>Unlike AOBs, binary analysis isn’t dependent on specific byte patterns. Instead, it examines the structural and behavioral patterns in a program. In cybersecurity, binary analysis is used to detect unknown viruses or malware by looking at how they behave or how they are structured, instead of looking for a known virus signature. It’s also used to perform formal verification of software, which is the process of proving or disproving the correctness of a program with respect to a certain formal specification or property. Software like <a href="https://github.com/BinaryAnalysisPlatform/bap">BAP</a> is used to perform formal verification of software.</p>

<p>The implementation of binary analysis is broad and ranges from simple static binary analysis to more sophisticated techniques such as emulation, symbolic execution, taint analysis, control flow analysis, and more. These techniques can be used to locate specific areas of interest in a way that is resistant to updates and changes.</p>

<h2 id="bridging-the-gap">Bridging the Gap</h2>

<p>Historically, the game hacking community is well-known for using techniques seen in the wild well before research from the security industry is released. However, despite the potential benefits, the adoption of automated binary analysis for locating key areas has been slow: it is complex, and some may see it as overkill.</p>

<p>The community often prefers AOBs for their simplicity, but advanced modders might find binary analysis a potent addition to their arsenal, especially if working with a prolific game engine, or if the game is frequently updated and more robust techniques are needed to locate areas of interest.</p>

<p>A particularly compelling use case for automated binary analysis is with specific game engines that power many games. The technique’s ability to locate shared engine functions can exceed that of a signature if used correctly. Automated binary analysis is generally more resilient to game updates in general, as it’s not dependent on specific byte patterns. However, it’s not a silver bullet, and it’s not without its own set of challenges. It can also be quite slow if not done with care.</p>

<p>Localized emulation of functions, symbolic execution, general disassembly (static analysis) using libraries, data flow analysis, and string reference analysis, offer a solid addition to the modder’s arsenal.</p>

<p>While these techniques are powerful on their own, when some, or all of these techniques are combined, they become powerful tools for locating functions, addresses, and structure offsets that can withstand the test of time.</p>

<h2 id="the-techniques">The Techniques</h2>
<h3 id="emulation">Emulation</h3>
<p>The first thought that usually comes to mind when thinking about emulation is the use of a virtual machine to run a program, or a program to emulate a game console. However, emulation can also be used to run a function in a controlled environment and observe its behavior. This technique is particularly useful when dealing with functions that are difficult to analyze statically.</p>

<p>Given an <a href="#anchors">anchor</a> instruction to start from (this assumes you know how to find this instruction in the first place, for example with an AOB or string reference lookup, even the entry point of the program), we can emulate the function (or set of instructions) and observe its behavior.
Along the way, we can look for function calls to <em>other</em> functions of interest, look for specific memory operations (such as accesses of global variables), look for specific values in registers, look for accesses into structures to find specific field offsets, or just trace the flow of data in general.</p>

<p>One can argue that some of those things can just be found simply with a disassembly pass, but here are some counterpoints:</p>

<ul>
  <li>Some of the operations may be indirect (like accessing memory via a register dereference)</li>
  <li>The function may be too complex to analyze statically (for example, if it’s obfuscated or has many branches)</li>
  <li>There may be a conditional branch which you only want to go a specific way (via setting a register to a specific value, for example), which is where linear disassembly falls short</li>
</ul>

<p>In C/C++, libraries such as <a href="https://github.com/JonathanSalwan/Triton">Triton</a>, <a href="https://github.com/unicorn-engine/unicorn">Unicorn</a>, and <a href="https://github.com/bitdefender/bddisasm">bddisasm’s bdshemu</a> can be used to emulate functions.</p>

<p>In Python, libraries such as <a href="https://github.com/cea-sec/miasm">miasm</a>, <a href="https://github.com/unicorn-engine/unicorn">Unicorn</a>, <a href="https://github.com/qilingframework/qiling">qiling</a>, or <a href="https://github.com/JonathanSalwan/Triton">Triton</a> can be used to emulate functions.</p>

<h3 id="symbolic-execution">Symbolic Execution</h3>
<p><a href="https://en.wikipedia.org/wiki/Symbolic_execution">Symbolic execution</a> is similar to emulation in that it runs a function in a controlled environment. However, instead of running the function, it analyzes the function’s code and generates a set of constraints that represent the function’s behavior. This particular technique is not used here, but worth mentioning.</p>

<p>The simplest example I can give here is that symbolic execution has the ability to figure out what inputs can drive a specific function or program to end up at a certain instruction. Example being, product key activation functions, where you can figure out what key will make the program think it’s valid.</p>

<p>The only similar technique we use to this is the enhancement to <a href="#static-analysis-disassembly-at-runtime">static analysis</a> to explore all paths.</p>

<p>In C++, libraries such as <a href="https://github.com/JonathanSalwan/Triton">Triton</a> can be used to symbolically execute functions.</p>

<p>In Python, <a href="https://github.com/cea-sec/miasm">miasm</a>, <a href="https://github.com/angr/angr">angr</a> can be used to symbolically execute functions.</p>

<h3 id="data-flow-analysis">Data Flow Analysis</h3>
<p><a href="https://en.wikipedia.org/wiki/Data-flow_analysis">Data flow analysis</a> is the process of tracking the flow of data in a program. This technique is commonly used in the security industry to track user input and identify potential vulnerabilities. However, it can also be used to track the flow of data in a program and identify specific operations or functions of interest.</p>

<p>In this particular context, given an anchor point (such as a function or instruction), we can “taint” a register or memory location with a magic number and track its flow throughout the code using emulation. This can be used for a few things, such as:</p>

<ul>
  <li>Behavior verification
    <ul>
      <li>If the taint value flows into a memory write (direct or indirect), we can verify that the piece of code writes to memory if this is what we were looking for</li>
      <li>If the taint flows to, for example, the RAX register after a function call, we can verify that the function returns a value in RAX</li>
    </ul>
  </li>
  <li>Locating global variables in a specific way
    <ul>
      <li>Proceeding from the previous example, if the taint value (from RAX) flows to a global variable, we can assume this is our target global variable we were looking for. This is quite different than just performing a disassembly or emulation and looking for the first memory write to a global variable, as the analysis will only track the flow of the taint value which could be somewhere after the first seen memory write to a global.</li>
    </ul>
  </li>
</ul>

<p>The same libraries used for emulation can be used for data flow and/or taint analysis.</p>

<h3 id="structural-analysis">Structural Analysis</h3>
<p>Structural analysis, in this context, refers to the analysis of structures (or classes) in a program. This is particularly useful when dealing with C++ programs, as C++ classes are often represented as structures in the binary. This technique is used to locate specific fields in a structure, such as offsets, sizes, and types. It can also just be used to verify that a structure is what we expect it to be.</p>

<p>If we know the general layout of a structure beforehand, we can probe specific areas of memory to see if the structure layout matches. If a structure is supposed to have a valid pointer at <code>0x10</code>, we can check the offset at <code>0x10</code> from a specific pointer, check if it points to valid memory. Combining this with several other checks, like making sure integers look like valid integers, and strings look like valid strings, we can verify that the structure is what we expect it to be.</p>

<p>This technique also works if you know the general layout of the structure, but not the exact offsets within the structure. Using that information, we can perform bruteforce-like checks against the entire structure to obtain the offsets of the fields we are looking for.</p>

<p>An example being, in the <code>UStruct</code> structure in Unreal Engine 4/5, there is a field called <code>SuperStruct</code>. If we have full access to the <code>GUObjectArray</code> already, we can find the:</p>

<ul>
  <li><code>UStruct</code> class</li>
  <li><code>UField</code> class</li>
  <li><code>UObject</code> class</li>
</ul>

<p>Using the pointers to these classes, we can scan over the <code>UStruct</code> structure until we see a pointer to the <code>UField</code> class. If we do, we perform the same check on the <code>UField</code> structure until we see a pointer to the <code>UObject</code> class. If we do, we can assume that the <code>SuperStruct</code> field is at the given offset, because all of these classes are supposed to point to eachother via the <code>SuperStruct</code> field.</p>

<h3 id="static-analysis-disassembly-at-runtime">Static Analysis (Disassembly at Runtime)</h3>
<p><a href="https://en.wikipedia.org/wiki/Static_program_analysis">Static analysis</a> is the process of analyzing a program’s code without running it. Disassemblers such as IDA, Ghidra, or Binary Ninja are commonly used to perform static analysis. However, in the context of runtime binary analysis, static analysis can be used to analyze a function’s code and look for specific patterns or behavior at runtime using libraries such as:</p>

<ul>
  <li><a href="https://github.com/capstone-engine/capstone">Capstone</a></li>
  <li><a href="https://github.com/bitdefender/bddisasm">bddisasm</a></li>
  <li><a href="https://github.com/zyantific/zydis">zydis</a></li>
</ul>

<p>Using libraries such as these, we can not only perform simple linear disassembly, we can also perform more complex disassembly techniques such as recursive traversal of code paths.</p>

<p>An example, we could disassemble forward, and by using a virtual instruction pointer and list of branches to analyze:</p>
<ul>
  <li>If a call is seen, we detect this as a branch and add it to a list of branches to be analyzed</li>
  <li>If an unconditional jmp is seen, we replace our virtual instruction pointer with the target address</li>
  <li>If a conditional jmp is seen, we can traverse both paths, and add them both to the list of branches to be analyzed</li>
</ul>

<p>This traversal technique is particularly useful because:</p>
<ul>
  <li>The piece of data we’re looking for may be buried deep within a function</li>
</ul>

<h3 id="string-reference-scanning">String Reference Scanning</h3>
<p>String reference scanning is a technique that involves combing through the program’s memory for references to specific strings. In conventional software analysis tools like IDA or x64dbg, cross-references to strings are often used as a reliable method for locating functions during manual analysis. However, leveraging string references within the context of automated runtime binary analysis in the game hacking community is less frequently discussed.</p>

<p>String reference scanning <em>is</em> a form of signature scanning, but due to its reliance on human-readable data, it is more reliable than traditional signature scanning, which usually looks for byte patterns of instructions which may change for a variety of reasons that the original programmer was not even aware of.</p>

<p>Deploying string reference scanning can accomplish several goals:</p>

<ul>
  <li>It can serve as a structured, human-readable alternative to traditional AOBs</li>
  <li>It can act as a starting point or <a href="#anchors">‘anchor’</a> from which other binary analysis techniques can launch</li>
  <li>Once a reference address is identified, it can be used to locate the containing function through a variety of techniques:
    <ul>
      <li>On Windows systems, this could involve using the Exception Directory (a component of the PE file format) or the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-rtllookupfunctionentry">RtlLookupFunctionEntry</a> function</li>
      <li>Other techniques might include scanning backwards for int3 padding, searching for a function prologue, or scanning until the address is pointed to (non-relatively) by doing a full pointer scan of the module’s mapped memory (indicating a virtual function table)</li>
    </ul>
  </li>
</ul>

<p>Disassemblers such as IDA commonly employ this technique to display cross-references to strings. The difference here is it would be performed at runtime. We wouldn’t have the luxury of disassembling the entire program though; this would be too slow, it would have to be a purpose-built scan that employs localized disassembly.</p>

<p>There are some complexities involved because string references on x86-64 are usually relative as part of an instruction operand. So, a special scanning technique that scans the memory byte-by-byte, treating 4 bytes as the “relative” offset, would be required.</p>

<div><div><pre><code><span>// This would need to be used at every address that is scanned for a string reference</span>
<span>// where customOffset is 4</span>
<span>// This assumes that the immediate is the last operand, which is sometimes not the case</span>
<span>// but it&#39;s the most common case so it&#39;s not really a big deal</span>
<span>uintptr_t</span> <span>calculate_absolute</span><span>(</span><span>uintptr_t</span> <span>address</span><span>,</span> <span>uint8_t</span> <span>customOffset</span> <span>/*= 4*/</span><span>)</span> <span>{</span>
    <span>auto</span> <span>offset</span> <span>=</span> <span>*</span><span>(</span><span>int32_t</span><span>*</span><span>)</span><span>address</span><span>;</span>

    <span>return</span> <span>address</span> <span>+</span> <span>customOffset</span> <span>+</span> <span>offset</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>There’s also the issue that this would only give you the address within the middle of the instruction, where the relative operand is. If you need the start of the instruction, you need to get creative. For example, you could have a list of valid prefixes for address references, and scan backwards until you find one of those prefixes, or you could use the technique(s) described earlier that can get you the start of the containing function. From there, you can disassemble forward until the bounds of the instruction encapsulate the address reference.</p>

<p>This same technique can also just be applied to references to any data in general, not just strings. But, since strings are the easiest to scan for from the get-go, it’s a good starting point. If trying to find references to data in general, you would need to know how to find that data in the first place (such as by using or combining the other techniques talked about here).</p>

<p>There is an IDA plugin I wrote a while back which allows the user to click on any address, and it will look for any string references that are near a reference to that particular address. It will only display areas where only the <em>first</em> occurrence of the string reference is near the address. It orders them and displays them in a list based on distance to the target address reference.</p>

<p><a href="https://github.com/praydog/IDA-String-Reference-Locator-Plugin">IDA String Reference Locator</a></p>



<p>Result of using this plugin on the <code>FName</code> constructor in the Unreal Engine</p>

<div>
  <div><div><pre><code><span>/*
4.27:
[address hidden] + 0x8 NumNetGUIDsPending
[address hidden] + 0x7 SkeletalMeshComponentClothTick
[address hidden] + 0x7 DefaultModulationPlugin
[address hidden] + 0x4 Oculus Quest2
[address hidden] + 0x4 FSequencerPlayerAnimSequence
[address hidden] + 0x4 EndPhysicsTick
[address hidden] + 0x4 StartPhysicsTick
[address hidden] + 0x4 TickAnimationSharing
[address hidden] + 0x4 LakeCollisionComponent
[address hidden] + 0x4 SkeletalMeshComponentEndPhysicsTick
[address hidden] + 0x4 Behavior
[address hidden] + 0x4 FSlateMouseEventsMetaData
[address hidden] + 0x4 FSlateCursorMetaData
[address hidden] + 0x4 SoundExporterWAV
[address hidden] + 0x4 FReflectionMetaData
[address hidden] + 0x4 GameDefaultMap
[address hidden] + 0x4 Test FName
[address hidden] + 0x4 WaterBodyCollision
[address hidden] + 0x4 WidgetTree
[address hidden] + 0x4 FTagMetaData
[address hidden] + 0x4 FSlateToolTipMetaData
[address hidden] + 0x4 ParticleSystemManager
[address hidden] + 0x4 Plugins
[address hidden] + 0x4 FNavigationMetaData
[address hidden] + 0x4 FSceneViewExtensionContext
*/</span>

<span>/*
4.14:
[address hidden] + 0x8 bIsPlaying
[address hidden] + 0x8 FLandscapeUniformShaderParameters
[address hidden] + 0x8 STAT_ColorList
[address hidden] + 0x7 OPUS
[address hidden] + 0x4 LightComponent
[address hidden] + 0x4 FPostProcessMaterialNode
[address hidden] + 0x4 SoundExporterWAV
[address hidden] + 0x4 Component
[address hidden] + 0x4 STextBlock
[address hidden] + 0x4 FLightPropagationVolumeSettings
[address hidden] + 0x4 CraneCameraMount
[address hidden] + 0x4 Priority
[address hidden] + 0x4 FTagMetaData
[address hidden] + 0x4 FNavigationMetaData
*/</span>

<span>/*
Present in both (and 5.0.3+):
+ 0x4 FTagMetaData
+ 0x4 FNavigationMetaData
*/</span>
</code></pre></div>  </div>
</div>


<h3 id="heuristic-analysis">Heuristic Analysis</h3>
<p>Heuristic analysis is essentially inferring something about a program given specific patterns or behavior. This is a very broad term, and can be used to describe a lot of things, and some of the techniques talked about so far can fall under this umbrella, or be used in the process of heuristic analysis. It can be used to describe rule of thumb techniques which make educated assumptions, can have a good chance of working, though are not guaranteed to work.</p>

<p>For example, a heuristic for locating a specific global variable in a game engine could be to look for a function that contains a specific string reference, and checking the most accessed global variable inside the function using static analysis, and assuming this is what we’re looking for. We came up with these specific rules by analyzing a few different sample binaries, and the source code of the engine.</p>

<p>This can describe the offline process (such as manual analysis in IDA) AND the automated techniques we will need to use at the same time, providing instructions to two different groups of reverse engineers. This very specific example will be explored down below.</p>

<h3 id="call-stack-analysis">Call Stack Analysis</h3>
<p>Another powerful technique that is especially useful for finding <a href="#anchors">anchors</a> to use for other techniques is call stack analysis. We can use Windows functions like <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlcapturestackbacktrace">RtlCaptureStackBackTrace</a> to do this.</p>

<p>The call stack shows us the chain of calls that got us to a particular function. It’s a list of return addresses. Note, there must be hook on this function or the thread must be intercepted in some way to get the call stack.</p>

<p>Using these return addresses we can:</p>

<ul>
  <li>Use them as <a href="#anchors">anchors</a> to scan for other things using the techniques described previously</li>
  <li>Locate the function they are contained in</li>
  <li>Locate the function that called the function they are contained in (and so on…)</li>
</ul>

<h3 id="anchors">Anchors</h3>
<p>Anchors, or reference points, in the context of both exploit development and game hacking, refer to specific points or references within a codebase or memory space that serve as starting points or ‘fixed’ locations for further code analysis or manipulation. These anchors could be functions, global variables, return addresses, or essentially any identifiable piece of code or data.</p>

<p>In the realm of exploit development, anchor points play a crucial role, especially when dealing with mitigations like <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address Space Layout Randomization (ASLR)</a>. ASLR randomizes the memory locations of key data areas, making it more difficult for attackers to predict where in memory their payloads or shellcode will reside. Here, the concept of an anchor or ‘fixed’ point is invaluable, allowing an attacker to navigate the memory space in a deterministic manner, despite the randomization.</p>

<p>When talking about signatures in the context of game hacking, they are usually used to scan through an entire module. If scanning from an anchor point, and limiting the size, it can drastically reduce false positives, and can also allow the signature to be smaller.</p>

<p>Anchor points can also apply to offsets or virtuals. We can sometimes assume that an offset to a member, or a virtual index can sometimes precede or be ahead of another offset/virtual index based on previous analysis.</p>

<p>One may ask: “Well, how do I find an anchor in the first place?”</p>

<p>There’s a few different ways:</p>

<ul>
  <li>AOB (signature) scanning
    <ul>
      <li>This is the most common way to find an anchor, and is usually used to find a function’s prologue</li>
    </ul>
  </li>
  <li>String reference scanning</li>
  <li>The callstack from a function hook</li>
  <li>Virtual function tables</li>
  <li>Leveraging RTTI-like systems or scripting systems built into the game engine
    <ul>
      <li>We can use the functions or other data these expose as anchors</li>
      <li>For example, engines like Unity (and the RE Engine! Check out my <a href="https://github.com/praydog/REFramework/">REFramework</a> project) use Mono and IL2CPP which expose most of the game’s classes and functions to the C# API. These functions can be used as anchors to find non-exposed (native) functions and data that they reference within the function’s code.</li>
      <li>Engines like Unreal expose many classes and methods to the Blueprint API, however it is far less than Unity, which makes this a much more compelling use case to find non-exposed functions and pieces of data residing within them.</li>
      <li>Some engines use an embedded scripting language such as Lua, notable examples include
        <ul>
          <li>Source Engine (1 &amp; 2)
            <ul>
              <li>Apex Legends</li>
              <li>Counter-Strike: Global Offensive</li>
              <li>Dota 2</li>
              <li>Garry’s Mod</li>
            </ul>
          </li>
          <li>Cyberpunk 2077 (See <a href="https://github.com/maximegmd/CyberEngineTweaks">CyberEngineTweaks</a> which takes advantage of this)</li>
          <li>NieR: Automata (See <a href="https://github.com/praydog/AutomataMP">AutomataMP</a> which takes advantage of this)</li>
          <li>All of the Souls games incl. Elden Ring and Sekiro</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>An interesting note: when enough anchors are gathered, the need for signatures is reduced. This is because the anchors can be used to find other anchors, and so on. This is a very powerful concept, and is the basis for a lot of the techniques described here.</p>

<h2 id="a-practical-example-string-reference-scanning-for-anchors-static-and-heuristic-analysis">A Practical Example: String Reference Scanning for Anchors, Static and Heuristic Analysis</h2>
<p>Take this function for example, which is robust enough to work across hundreds of UE4/5 games. It’s a function that finds the <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/HAL/IConsoleManager/">IConsoleManager</a> interface, which is used to interact with the game’s console.</p>



<div>

  <div><div><pre><code><span>namespace</span> <span>detail</span> <span>{</span>
<span>sdk</span><span>::</span><span>FConsoleManager</span><span>**</span> <span>try_find_console_manager</span><span>(</span><span>const</span> <span>std</span><span>::</span><span>wstring</span><span>&amp;</span> <span>string_candidate</span><span>)</span> <span>{</span>
    <span>SPDLOG_INFO</span><span>(</span><span>&#34;Finding IConsoleManager...&#34;</span><span>);</span>

    <span>const</span> <span>auto</span> <span>now</span> <span>=</span> <span>std</span><span>::</span><span>chrono</span><span>::</span><span>steady_clock</span><span>::</span><span>now</span><span>();</span>

    <span>const</span> <span>auto</span> <span>core_module</span> <span>=</span> <span>sdk</span><span>::</span><span>get_ue_module</span><span>(</span><span>L&#34;Core&#34;</span><span>);</span>
    <span>const</span> <span>auto</span> <span>candidate_string</span> <span>=</span> <span>utility</span><span>::</span><span>scan_string</span><span>(</span><span>core_module</span><span>,</span> <span>string_candidate</span><span>.</span><span>c_str</span><span>());</span>

    <span>if</span> <span>(</span><span>!</span><span>candidate_string</span><span>)</span> <span>{</span>
        <span>SPDLOG_ERROR</span><span>(</span><span>&#34;Failed to find {} string&#34;</span><span>,</span> <span>utility</span><span>::</span><span>narrow</span><span>(</span><span>string_candidate</span><span>));</span>
        <span>return</span> <span>nullptr</span><span>;</span>
    <span>}</span>

    <span>const</span> <span>auto</span> <span>candidate_stringref</span> <span>=</span> <span>utility</span><span>::</span><span>scan_displacement_reference</span><span>(</span><span>core_module</span><span>,</span> <span>*</span><span>candidate_string</span><span>);</span>

    <span>if</span> <span>(</span><span>!</span><span>candidate_stringref</span><span>)</span> <span>{</span>
        <span>SPDLOG_ERROR</span><span>(</span><span>&#34;Failed to find {} stringref&#34;</span><span>,</span> <span>utility</span><span>::</span><span>narrow</span><span>(</span><span>string_candidate</span><span>));</span>
        <span>return</span> <span>nullptr</span><span>;</span>
    <span>}</span>

    <span>SPDLOG_INFO</span><span>(</span><span>&#34;Found {} stringref: {:x}&#34;</span><span>,</span> <span>utility</span><span>::</span><span>narrow</span><span>(</span><span>string_candidate</span><span>),</span> <span>(</span><span>uintptr_t</span><span>)</span><span>*</span><span>candidate_stringref</span><span>);</span>

    <span>// This might need to be improved a bit, it can be insanely slow on obfuscated builds</span>
    <span>const</span> <span>auto</span> <span>containing_function</span> <span>=</span> <span>utility</span><span>::</span><span>find_function_start_with_call</span><span>(</span><span>*</span><span>candidate_stringref</span><span>);</span>

    <span>if</span> <span>(</span><span>!</span><span>containing_function</span><span>)</span> <span>{</span>
        <span>SPDLOG_ERROR</span><span>(</span><span>&#34;Failed to find containing function&#34;</span><span>);</span>
        <span>return</span> <span>nullptr</span><span>;</span>
    <span>}</span>
    
    <span>// Disassemble the function and look for references to global variables</span>
    <span>std</span><span>::</span><span>unordered_map</span><span>&lt;</span><span>uintptr_t</span><span>,</span> <span>size_t</span><span>&gt;</span> <span>global_variable_references</span><span>{};</span>
    <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>std</span><span>::</span><span>tuple</span><span>&lt;</span><span>uintptr_t</span><span>,</span> <span>size_t</span><span>&gt;&gt;</span> <span>highest_global_variable_reference</span><span>{};</span>

    <span>utility</span><span>::</span><span>exhaustive_decode</span><span>((</span><span>uint8_t</span><span>*</span><span>)</span><span>*</span><span>containing_function</span><span>,</span> <span>20</span><span>,</span> <span>[</span><span>&amp;</span><span>](</span><span>INSTRUX</span><span>&amp;</span> <span>ix</span><span>,</span> <span>uintptr_t</span> <span>ip</span><span>)</span> <span>-&gt;</span> <span>utility</span><span>::</span><span>ExhaustionResult</span> <span>{</span>
        <span>if</span> <span>(</span><span>std</span><span>::</span><span>string_view</span><span>{</span><span>ix</span><span>.</span><span>Mnemonic</span><span>}.</span><span>starts_with</span><span>(</span><span>&#34;CALL&#34;</span><span>))</span> <span>{</span>
            <span>return</span> <span>utility</span><span>::</span><span>ExhaustionResult</span><span>::</span><span>STEP_OVER</span><span>;</span>
        <span>}</span>

        <span>// Checks if the instruction can possibly return a displacement, and if it does, resolve it</span>
        <span>// an example could be &#34;mov rax, [rip + 0x12345678]&#34; where the displacement is rip + 0x12345678 (an absolute address)</span>
        <span>const</span> <span>auto</span> <span>displacement</span> <span>=</span> <span>utility</span><span>::</span><span>resolve_displacement</span><span>(</span><span>ip</span><span>);</span>

        <span>if</span> <span>(</span><span>!</span><span>displacement</span><span>)</span> <span>{</span>
            <span>return</span> <span>utility</span><span>::</span><span>ExhaustionResult</span><span>::</span><span>CONTINUE</span><span>;</span>
        <span>}</span>

        <span>// hinges on IConsoleManager actually being constructed and assigned</span>
        <span>if</span> <span>(</span><span>!</span><span>IsBadReadPtr</span><span>((</span><span>void</span><span>*</span><span>)</span><span>*</span><span>displacement</span><span>,</span> <span>sizeof</span><span>(</span><span>void</span><span>*</span><span>))</span> <span>&amp;&amp;</span> <span>!</span><span>IsBadReadPtr</span><span>(</span><span>*</span><span>(</span><span>void</span><span>**</span><span>)</span><span>*</span><span>displacement</span><span>,</span> <span>sizeof</span><span>(</span><span>void</span><span>*</span><span>)))</span> <span>{</span>
            <span>global_variable_references</span><span>[</span><span>*</span><span>displacement</span><span>]</span><span>++</span><span>;</span>

            <span>if</span> <span>(</span><span>!</span><span>highest_global_variable_reference</span> <span>||</span> <span>global_variable_references</span><span>[</span><span>*</span><span>displacement</span><span>]</span> <span>&gt;</span> <span>std</span><span>::</span><span>get</span><span>&lt;</span><span>1</span><span>&gt;</span><span>(</span><span>*</span><span>highest_global_variable_reference</span><span>))</span> <span>{</span>
                <span>highest_global_variable_reference</span> <span>=</span> <span>std</span><span>::</span><span>make_tuple</span><span>(</span><span>*</span><span>displacement</span><span>,</span> <span>global_variable_references</span><span>[</span><span>*</span><span>displacement</span><span>]);</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> <span>utility</span><span>::</span><span>ExhaustionResult</span><span>::</span><span>CONTINUE</span><span>;</span>
    <span>});</span>

    <span>if</span> <span>(</span><span>!</span><span>highest_global_variable_reference</span><span>)</span> <span>{</span>
        <span>SPDLOG_ERROR</span><span>(</span><span>&#34;Failed to find any references to global variables&#34;</span><span>);</span>
        <span>return</span> <span>nullptr</span><span>;</span>
    <span>}</span>

    <span>SPDLOG_INFO</span><span>(</span><span>&#34;Found IConsoleManager**: {:x}&#34;</span><span>,</span> <span>(</span><span>uintptr_t</span><span>)</span><span>std</span><span>::</span><span>get</span><span>&lt;</span><span>0</span><span>&gt;</span><span>(</span><span>*</span><span>highest_global_variable_reference</span><span>));</span>
    <span>SPDLOG_INFO</span><span>(</span><span>&#34;Points to IConsoleManager*: {:x}&#34;</span><span>,</span> <span>*</span><span>(</span><span>uintptr_t</span><span>*</span><span>)</span><span>std</span><span>::</span><span>get</span><span>&lt;</span><span>0</span><span>&gt;</span><span>(</span><span>*</span><span>highest_global_variable_reference</span><span>));</span>

    <span>const</span> <span>auto</span> <span>diff</span> <span>=</span> <span>std</span><span>::</span><span>chrono</span><span>::</span><span>duration_cast</span><span>&lt;</span><span>std</span><span>::</span><span>chrono</span><span>::</span><span>milliseconds</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>chrono</span><span>::</span><span>steady_clock</span><span>::</span><span>now</span><span>()</span> <span>-</span> <span>now</span><span>).</span><span>count</span><span>();</span>
    <span>SPDLOG_INFO</span><span>(</span><span>&#34;Took {}ms to find IConsoleManager&#34;</span><span>,</span> <span>diff</span><span>);</span>

    <span>return</span> <span>(</span><span>sdk</span><span>::</span><span>FConsoleManager</span><span>**</span><span>)</span><span>std</span><span>::</span><span>get</span><span>&lt;</span><span>0</span><span>&gt;</span><span>(</span><span>*</span><span>highest_global_variable_reference</span><span>);</span>
<span>}</span>
<span>}</span>

<span>namespace</span> <span>sdk</span> <span>{</span>
<span>FConsoleManager</span><span>*</span> <span>FConsoleManager</span><span>::</span><span>get</span><span>()</span> <span>{</span>
    <span>static</span> <span>auto</span> <span>result</span> <span>=</span> <span>[]()</span> <span>-&gt;</span> <span>FConsoleManager</span><span>**</span> <span>{</span>
        <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>wstring</span><span>&gt;</span> <span>candidates</span> <span>{</span>
            <span>L&#34;r.DumpingMovie&#34;</span><span>,</span>
            <span>L&#34;vr.pixeldensity&#34;</span>
        <span>};</span>

        <span>const</span> <span>auto</span> <span>now</span> <span>=</span> <span>std</span><span>::</span><span>chrono</span><span>::</span><span>steady_clock</span><span>::</span><span>now</span><span>();</span>

        <span>for</span> <span>(</span><span>const</span> <span>auto</span><span>&amp;</span> <span>candidate</span> <span>:</span> <span>candidates</span><span>)</span> <span>{</span>
            <span>SPDLOG_INFO</span><span>(</span><span>&#34;Trying to find IConsoleManager with candidate: {}&#34;</span><span>,</span> <span>utility</span><span>::</span><span>narrow</span><span>(</span><span>candidate</span><span>));</span>
            <span>auto</span> <span>result</span> <span>=</span> <span>detail</span><span>::</span><span>try_find_console_manager</span><span>(</span><span>candidate</span><span>);</span>

            <span>if</span> <span>(</span><span>result</span><span>)</span> <span>{</span>
                <span>SPDLOG_INFO</span><span>(</span><span>&#34;Took {}ms to search through all candidates&#34;</span><span>,</span> <span>std</span><span>::</span><span>chrono</span><span>::</span><span>duration_cast</span><span>&lt;</span><span>std</span><span>::</span><span>chrono</span><span>::</span><span>milliseconds</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>chrono</span><span>::</span><span>steady_clock</span><span>::</span><span>now</span><span>()</span> <span>-</span> <span>now</span><span>).</span><span>count</span><span>());</span>
                <span>return</span> <span>result</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>SPDLOG_ERROR</span><span>(</span><span>&#34;Failed to find IConsoleManager&#34;</span><span>);</span>

        <span>return</span> <span>nullptr</span><span>;</span>
    <span>}();</span>

    <span>if</span> <span>(</span><span>result</span> <span>==</span> <span>nullptr</span><span>)</span> <span>{</span>
        <span>return</span> <span>nullptr</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>*</span><span>result</span><span>;</span>
<span>}</span>
<span>}</span>
</code></pre></div>  </div>
</div>


<p>Let’s break this down:</p>

<ol>
  <li>It scans for the string data inside the Core module that’s passed in as an argument (<code>&#34;r.DumpingMovie&#34;</code> or <code>&#34;vr.pixeldensity&#34;</code> in this case)</li>
  <li>It scans for a reference to that string data</li>
  <li>It locates the containing function of that reference</li>
  <li>It disassembles the containing function and looks for references to global variables</li>
  <li>It finds the global variable reference that’s referenced the most, this is likely to be the global variable that holds the pointer to the IConsoleManager instance. This can be considered a form of heuristic analysis, as it’s not guaranteed to work, but it’s likely to work in most cases based on sample binaries analyzed manually prior to writing this function.</li>
</ol>

<p>From a manual perspective, recreating this entire process from the perspective of a reverse engineer would look something like this:</p>

<h3 id="phase-1-find-the-string-data-utilityscan_string-in-the-code">Phase 1: Find the string data (<code>utility::scan_string</code> in the code)</h3>

<p><img src="https://medium.com/images/uevr-07-03/string_identification.png" alt="stringref"/></p>

<h3 id="phase-2-head-to-the-cross-reference-shown-in-the-ui-utilityscan_displacement_reference-in-the-code">Phase 2: Head to the cross-reference shown in the UI (<code>utility::scan_displacement_reference</code> in the code)</h3>

<p><img src="https://medium.com/images/uevr-07-03/string_crossref.png" alt="crossref"/></p>

<h3 id="phase-3-locate-the-start-of-the-function-scroll-up-a-bit-utilityfind_function_start_with_call-in-the-code">Phase 3: Locate the start of the function (scroll up a bit) (<code>utility::find_function_start_with_call</code> in the code)</h3>

<p><img src="https://medium.com/images/uevr-07-03/string_function_start.png" alt="function_start"/></p>

<h3 id="phase-4-scan-through-the-disassembly-listing-looking-for-the-most-referenced-global-variable-utilityexhaustive_decode-in-the-code">Phase 4: Scan through the disassembly listing looking for the most referenced global variable (<code>utility::exhaustive_decode</code> in the code)</h3>

<p><img src="https://medium.com/images/uevr-07-03/global_count1.png" alt="global_count1"/></p>

<p><img src="https://medium.com/images/uevr-07-03/global_count2.png" alt="global_count2"/></p>

<h3 id="phase-5-rename-the-global-variable-to-something-meaningful-returning-the-result-in-the-code">Phase 5: Rename the global variable to something meaningful (returning the result in the code)</h3>

<p><img src="https://medium.com/images/uevr-07-03/global_rename.png" alt="global_rename"/></p>

<p>This kind of approach is going for more of a human-oriented approach, where we’re trying to replicate the process a human would go through to find the IConsoleManager instance. Doing it like this allows us to easily maintain the code.</p>

<p>While more complex than an AOB, this set of techniques can be more robust, as it’s not reliant on a specific set of instruction bytes being present in the game’s executable other than the string data itself. Rather, it’s dependent on these strings being referenced by the game’s code, which is much more likely to remain consistent across different versions of the game, no matter how they’re referenced, whether with a <code>LEA</code> instruction, a <code>MOV</code> instruction, or something else entirely. The same goes for the global variables: we’re checking for global displacement references, which can be several different kinds of instructions.</p>

<p>If it fails at any point, we have multiple options to use as the IConsoleManager instance is used in many, many other places near unique strings, and we can simply try again with a different string.</p>

<p>In contrast, while an AOB <em>could</em> work here, it may require multiple variants to be written, not necessarily for each version of the game, but to account for function changes, edge cases, different compiler versions, obfuscated code, and more. It’s also much more likely to break, as it’s dependent on a specific set of bytes (a specific instruction) being present in the game’s executable, which is more likely to change for the reasons stated, and sometimes updates to the game in general can break AOBs. I would argue <em>for</em> using an AOB though if there was a magic constant being used in the function though.</p>

<p>To explain how I came up with these strings to look for, I looked through the source code, and through the disassembly listing in IDA in several samples. I found that these strings were referenced in the same function that the IConsoleManager instance was referenced in.</p>

<h2 id="in-defense-of-signatures">In Defense of Signatures</h2>
<p>While it may seem as if this article is trying to dissuade from using signatures, that’s not the case. Signatures are still a very useful tool in the reverse engineer’s arsenal, and can be used in conjunction with the techniques discussed in this article to improve their effectiveness.</p>

<p>I would still very much advocate for signatures if there was a magic constant being used somewhere in an instruction as well. An example being:</p>
<pre><code>mov eax, 0xdeadbeef
</code></pre>

<p>While it’s possible the mnemonic may change, or the bytes may partially change, the constant referenced within it may remain the same, and can be used as a signature. I could see a form of obfuscation breaking this assumption, however.</p>

<p>The techniques described here are usually going to be slower than a straight signature scan, and may not be feasible in some cases. The degree varies, and can range anywhere from a few milliseconds to a few seconds, depending on the complexity of the binary. Moreso if it’s obfuscated in some way, which not only bloats the size of the executuable, but also messes up the code, and other things like the Windows exception directory. However, this may be a tradeoff between speed and robustness.</p>

<p>Signatures may also be the only option if the target encrypts all of its strings, has very minimal strings in the first place, there’s no feasible anchor points to work with, or doing deep automated analysis may eat up too much time. These methods are in no way easy to come up with an attack plan either, it may just be easier and quicker to write a signature, it may be the case that there’s not enough samples to come up with a broad set of heuristics either.</p>

<p>There’s also more advanced signature scanning techniques which operate on “nibbles” (4 bits) instead of whole bytes, which can be used to make signatures more robust, and less likely to break. Tools like <a href="https://github.com/VirusTotal/yara">YARA</a> also have “jump” sequences for their signatures, which can be used to skip over N amount of bytes, within a specific range, which can be used to make signatures more robust as well.</p>

<h2 id="in-closing">In Closing</h2>

<p>The entire point I am trying to get across is that the process of locating certain functions or data structure by a reverse engineer manually in IDA, can be automated in the form of runtime code. If the process taken to get to a specific location manually is broken down by how it was achieved, the same can be achieved in code.</p>

<p>Case in point: If a reverse engineer finds a string reference in IDA that leads them to the function they want, this same exact process can be recreated in code. Even going an extreme step further: If they had to step through the code in a debugger to find the function they want, this same exact process can be recreated in code in the form of emulation or disassembly.</p>

<p>The techniques discussed in this article aren’t intended to displace traditional tools such as AOB scanning, which undeniably hold their unique advantages and a place of importance in the hacker’s toolkit.</p>


        
          <p>© 2023 praydog
           
          •
           Theme  <a href="https://github.com/abhinavs/moonwalk" target="_blank" rel="noreferrer">Moonwalk</a>
        </p>
      </div>
    </div></div>
  </body>
</html>
