<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stopa.io/post/292">Original</a>
    <h1>Llisp: Lisp in Lisp</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><span><p>Last week I had a thought: “What’s the simplest Lisp interpreter I could write, which supports macros?&#34;</p><p>A weekend of Clojure hacking and some confusion later, a REPL was born. In this essay, we’ll go through the same journey and make our own Lisp interpreter, which supports macros…in Clojure! Let’s call it, LLisp: a lisp in a lisp. </p><p>By the end, you’ll write your own macros in your own darn programming language! Let’s get into it.</p><p>Okay, let’s sketch out the basic idea behind what we need to do: </p><p><span><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc1NC1lMTg0NmZlNC0yM2I3LTQ3ZTctYjJmNy1lMjJiMDJlZmU2NmQucG5n" alt="image"/></span></p><p>A programmer writes some code. So far, it’s just text, and there’s not much we can do with that. We <em>read</em> the programmer’s text, and convert it into data-structures. We can do something with data-structures: we can <em>evaluate</em> data-structures, and return whatever the programmer intended. </p><p>If we can convert <code>&#34;(+ 1 1)&#34;</code> into <code>2</code>, we have ourselves the roots of a programming language.</p><p>Let’s handle “2. Read”. If a programmer writes text like <code>&#34;(+ 1 1)&#34;</code>, we want to convert it to data-structures. Something like:</p><pre><code><span>(</span><span>read-string</span><span> </span><span>&#34;(+ 1 1)&#34;</span><span>)</span>
<span>; =&gt;</span>
<span>(</span><span>+</span><span> </span><span>1</span><span> </span><span>1</span><span>)</span></code></pre><p>We <em>could</em> write <code>read-string</code> ourselves. For the simplest case it’s pretty easy <sup>[<!-- -->1<!-- -->]</sup>. But, we’re in Clojure after all, and Clojure already understands how to read Lisp code. Let’s just cheat and use Clojure’s <code>edn</code>: </p><pre><code><span>(</span><span>ns</span><span> simple-lisp.core</span>
<span>  (</span><span>:refer-clojure</span><span> </span><span>:exclude</span><span> [eval read read-string])</span>
<span>  (</span><span>:require</span><span> [clojure.edn </span><span>:refer</span><span> [read read-string]]))</span></code></pre><p>And voila, <code>read-string</code> does what we want:</p><pre><code><span>(</span><span>read-string</span><span> </span><span>&#34;(+ 1 1)&#34;</span><span>)</span>
<span>; =&gt;</span>
<span>(</span><span>+</span><span> </span><span>1</span><span> </span><span>1</span><span>)</span></code></pre><p>Okay, now to “3. Evaluate”. Remember, our goal is to take data-structures, evaluate **them and return whatever the programmer intended. We can begin with a simple function like this: </p><pre><code><span>(</span><span>defn</span><span> eval [form] </span>
<span>  </span><span>;; TODO </span>
<span>  )</span></code></pre><h2 id="evaluating-literals">Evaluating Literals</h2><p>Let’s get the easy things out of the way. Some things just evaluate to themselves: if a programmer wrote <code>12</code> for example, all we’d have to do is to return the number <code>12</code>. This is the same for strings (<code>&#34;foo&#34;</code>), characters (<code>\b</code>), and booleans (<code>true</code>). They’re literals<em>.</em> </p><p>Here’s how we can evaluate literals. Let’s detect them first:</p><pre><code><span>(</span><span>def</span><span> literal?</span>
<span>  (</span><span>some-fn</span><span> string? number? boolean? char? nil?))</span></code></pre><p>If you haven’t seen <code>some-fn</code> before, this is one of clojure’s many <a href="https://clojuredocs.org/clojure.core/some-fn" target="_blank">handy and powerful</a> utilities. Now we can handle literals in <code>eval</code>: </p><pre><code><span>(</span><span>defn</span><span> eval [form]</span>
<span>  (</span><span>cond</span>
<span>    (</span><span>literal?</span><span> form) form))</span></code></pre><p>And boom, our programming language starts to do something:</p><pre><code><span>(</span><span>eval</span><span> (</span><span>read-string</span><span> </span><span>&#34;12&#34;</span><span>))</span>
<span>; =&gt; 12</span></code></pre><h2 id="introducing-quote">Introducing Quote</h2><p>Let’s get to <code>quote</code>. Quote is a crucial form in Lisp. It lets you write code that <em>does not</em> evaluate. For example: </p><pre><code><span>(</span><span>quote</span><span> (</span><span>+</span><span> </span><span>1</span><span> </span><span>1</span><span>))</span>
<span>; =&gt; </span>
<span>(</span><span>+</span><span> </span><span>1</span><span> </span><span>1</span><span>)</span></code></pre><p>Because <code>(+ 1 1)</code> was inside <code>quote</code>, we didn’t evaluate it to return <code>2</code>. Instead we returned the expression itself. This seems weird if you come from languages that don’t support quotes, but it’s used all the time in Lisp. In fact, there’s a shortcut for it: </p><pre><code><span>&#39;(+ </span><span>1</span><span> </span><span>1</span><span>) </span></code></pre><p>When this is read, it converts to </p><pre><code><span>(</span><span>quote</span><span> (</span><span>+</span><span> </span><span>1</span><span> </span><span>1</span><span>))</span></code></pre><p>Thankfully, edn’s <code>read-string</code> does this for us. 🙂 </p><h2 id="evaluating-quote">Evaluating Quote</h2><p>So, how do we <em>evaluate</em> quote? Let’s first create a function that can detect them:</p><pre><code><span>(</span><span>defn</span><span> seq-starts-with? [starts-with form]</span>
<span>  (</span><span>and</span><span> (</span><span>seqable?</span><span> form) (</span><span>=</span><span> (</span><span>first</span><span> form) starts-with)))</span>
<!-- -->
<span>(</span><span>def</span><span> quote? (</span><span>partial</span><span> seq-starts-with? &#39;quote))</span></code></pre><p>We see if our form is a list, and the first element is the symbol <code>quote</code></p><pre><code><span>(</span><span>quote?</span><span> (</span><span>read-string</span><span> </span><span>&#34;&#39;(+ 1 1)&#34;</span><span>))</span>
<span>; =&gt; </span>
<span>true</span></code></pre><p>Works like a charm. Now let’s update <code>eval</code>:</p><pre><code><span>(</span><span>defn</span><span> eval [form]</span>
<span>  (</span><span>cond</span>
<span>    (</span><span>literal?</span><span> form) form</span>
<span>    (</span><span>quote?</span><span> form) (</span><span>second</span><span> form)))</span></code></pre><p>If our form is a <code>quote</code>, we return the “second” part of it. And voila,</p><pre><code><span>(</span><span>eval</span><span> (</span><span>read-string</span><span> </span><span>&#34;(quote (+ 1 1))&#34;</span><span>))</span>
<span>; =&gt; (+ 1 1)</span></code></pre><h2 id="introducing-symbols">Introducing Symbols</h2><p>Next, we come to symbols. Symbols are a special Lisp data type. They’re like variables, in the sense that when we <em>evaluate a</em> symbol<em>,</em> we **look it up.</p><p><span><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc2MS01YmQ2ODhlOS00ZDEzLTQ3ZjMtYTg4My1lYTZhMTdlYWRjNjEucG5n" alt="image"/></span></p><p>Look it up where? Our interpreter will need some kind of <code>environment</code>, that keeps track of all the variables we defined. If we had an environment, where the symbol <code>fav-num</code> pointed to <code>41</code> for example, here’s what evaluating <code>fav-num</code> would look like:</p><pre><code><span>(</span><span>eval</span><span> env (</span><span>read-string</span><span> </span><span>&#34;fav-num&#34;</span><span>))</span>
<span>; =&gt; </span>
<span>41</span></code></pre><h2 id="evaluating-symbols">Evaluating Symbols</h2><p>Let’s first create this <code>environment</code>. We can use java’s <code>Hashmap</code> to keep a mapping of symbols to their values. </p><p>Let’s import java’s Hashmap:</p><pre><code><span>(</span><span>ns</span><span> simple-lisp.core</span>
<span>  (</span><span>:refer-clojure</span><span> </span><span>:exclude</span><span> [eval read read-string])</span>
<span>  (</span><span>:require</span><span> [clojure.edn </span><span>:refer</span><span> [read read-string]])</span>
<span>  (</span><span>:import</span><span> (</span><span>java.util</span><span> HashMap)))</span></code></pre><p>And make a quick function to create an <code>env</code> map:</p><pre><code><span>(</span><span>defn</span><span> env [] {</span><span>:globe</span><span> (</span><span>HashMap.</span><span> {&#39;fav-num </span><span>41</span><span>})})</span></code></pre><p>Now, we can accept an <code>env</code> map in <code>eval</code>, and start to handle symbols: </p><pre><code><span>(</span><span>defn</span><span> eval [env form]</span>
<span>  (</span><span>cond</span>
<span>    (</span><span>literal?</span><span> form) form</span>
<span>    (</span><span>quote?</span><span> form) (</span><span>second</span><span> form)</span>
<span>    (</span><span>symbol?</span><span> form) (</span><span>lookup-symbol</span><span> env form)))</span></code></pre><p>Clojure already has a handy <code>symbol?</code> function, which we can use. When that’s true, we’ll <code>lookup-symbol</code>. Here’s how <code>lookup-symbol</code> could look: </p><pre><code><span>(</span><span>defn</span><span> lookup-symbol [{</span><span>:keys</span><span> [globe]} sym]</span>
<span>  (</span><span>let</span><span> [v (</span><span>when</span><span> (</span><span>contains?</span><span> globe sym) [(</span><span>get</span><span> globe sym)])]</span>
<span>    (</span><span>assert</span><span> v (</span><span>format</span><span> </span><span>&#34;expected value for sym = %s&#34;</span><span> sym))</span>
<span>    (</span><span>first</span><span> v)))</span></code></pre><p>And with that, symbols work! </p><pre><code><span>(</span><span>eval</span><span> (</span><span>env</span><span>) (</span><span>read-string</span><span> </span><span>&#34;fav-num&#34;</span><span>))</span>
<span>; =&gt; </span>
<span>41</span></code></pre><h2 id="evaluation-primitives">Evaluation Primitives</h2><p>Next up, let’s take an important step to making <code>(+ 1 1)</code> work. We’ll want to have <code>+</code> mean something. What should the symbol <code>+</code> point too? </p><p>How about Clojure functions?</p><pre><code><span>(</span><span>defn</span><span> env [] {</span><span>:globe</span><span> (</span><span>HashMap.</span><span> {&#39;+ + &#39;fav-num </span><span>41</span><span>})})</span></code></pre><p>If we did that, now whenever we evaluate the symbol <code>+</code>, it would return a clojure function:</p><pre><code><span>(</span><span>eval</span><span> (</span><span>env</span><span>) (</span><span>read-string</span><span> </span><span>&#34;+&#34;</span><span>))</span>
<span>; =&gt; #object[clojure.core$_PLUS_ 0x4efcb4b5 &#34;<a href="https://stopa.io/cdn-cgi/l/email-protection" data-cfemail="70131c1f1a0502155e131f0215542f203c25232f304415161312441245">[email protected]</a>&#34;]</span></code></pre><p>And if we “received” a clojure function in eval, we can just treat it as a literal: </p><pre><code><span>(</span><span>def</span><span> literal?</span>
<span>  (</span><span>some-fn</span><span> string? number? boolean? char? nil? fn?))</span></code></pre><pre><code><span>(</span><span>eval (</span><span>env</span><span>)</span><span> </span><span>+</span><span>)</span>
<span>; </span><span>=&gt;</span><span> </span><span>#</span><span>object</span><span>[clojure.core$_PLUS_ 0x4efcb4b5 &#34;<a href="https://stopa.io/cdn-cgi/l/email-protection" data-cfemail="ceada2a1a4bbbcabe0ada1bcabea919e829b9d918efaaba8adacfaacfb">[email protected]</a>&#34;]</span></code></pre><p>This is one small step in our essay, but a giant step for our Lisp. Every element in <code>(+ 1 1)</code>  can now be evaluated.</p><h2 id="primitive-applications">Primitive Applications</h2><p>So how do we run these functions? Well, let’s update <code>eval</code> , to handle lists like <code>(+ 1 1)</code>:</p><pre><code><span>(</span><span>defn</span><span> eval [env form]</span>
<span>  (</span><span>cond</span>
<span>    (</span><span>literal?</span><span> form) form</span>
<span>    (</span><span>quote?</span><span> form) (</span><span>second</span><span> form)</span>
<span>    (</span><span>symbol?</span><span> form) (</span><span>lookup-symbol</span><span> env form)</span>
<span>    </span><span>:else</span><span> (</span><span>eval-application</span><span> env form)))</span></code></pre><p>Easy. If we <em>can’t</em> figure out what the <code>form</code> is, it <em>must</em> be list, and it must mean we want to run it! Here’s how <code>eval-application</code> could work:</p><pre><code><span>(</span><span>defn</span><span> eval-application [env [f &amp; args]]</span>
<span>  (</span><span>let</span><span> [f-evaled (</span><span>eval</span><span> env f)]</span>
<span>    (</span><span>cond</span>
<span>      (</span><span>fn?</span><span> f-evaled) (</span><span>apply</span><span> f-evaled (</span><span>eval-many</span><span> env args)))))</span></code></pre><p>In <code>eval-application</code> , we evaluate the <em>first</em> part of our list. In our example, this would be the symbol <code>+</code>, which would return a clojure function. </p><p>If <code>f-evaled</code> is a clojure function (which it is), we would run: </p><pre><code><span>(</span><span>apply</span><span> f-evaled (</span><span>eval-many</span><span> env args))</span></code></pre><p><code>eval-many</code> is just a helper to evaluate a list of forms: </p><pre><code><span>(</span><span>defn</span><span> eval-many [e forms] (</span><span>map</span><span> (</span><span>partial</span><span> eval e) forms))</span></code></pre><p><code>args</code> would be <code>(1 1)</code>, so <code>eval-many</code> would return <code>(1 1)</code>, and that means we’d get the equivalent of:</p><pre><code><span>(</span><span>apply</span><span> + &#39;(</span><span>1</span><span> </span><span>1</span><span>))</span></code></pre><p>That would return <code>2</code>, and babam, we have <code>(+ 1 1)</code> working!</p><pre><code><span>(</span><span>eval</span><span> (</span><span>env</span><span>) (</span><span>read-string</span><span> </span><span>&#34;(+ 1 1)&#34;</span><span>)</span>
<span>; =&gt; </span>
<span>2</span></code></pre><p>Remember, we evaluate recursively, so we can do some intricate stuff already:</p><pre><code><span>(</span><span>eval</span><span> (</span><span>env</span><span>) (</span><span>read-string</span><span> </span><span>&#34;(+ 1 (+ 1 fav-num))&#34;</span><span>)</span>
<span>; =&gt; </span>
<span>43</span></code></pre><h2 id="introducing-def">Introducing def</h2><p>Oky doke, we have an environment, we got symbols that can look stuff up in that environment, and we can even evaluate <code>(+ 1 (+ 1 fav-num))</code>.</p><p>But, how are we going to <em>define</em> variables? For example, let’s say we wanted to have the symbol <code>second-fav</code> point to <code>42</code>. </p><p>Well, we can introduce a special form. Something like this: </p><pre><code><span>(</span><span>def</span><span> second-fav (</span><span>+</span><span> </span><span>1</span><span> fav-num))</span></code></pre><p>If we receive this <code>def</code> form, we’d just update our environment, to point the symbol <code>second-fav</code> to whatever the evaluation of <code>(+ 1 fav-num)</code>  would be. </p><h2 id="evaluating-def">Evaluating def</h2><p>That sounds like a plan. Let’s detect this form first:</p><pre><code><span>(</span><span>def</span><span> def? (</span><span>partial</span><span> seq-starts-with? &#39;def))</span></code></pre><p>And update <code>eval</code> to handle it: </p><pre><code><span>(</span><span>defn</span><span> eval [env form]</span>
<span>  (</span><span>cond</span>
<span>    (</span><span>literal?</span><span> form) form</span>
<span>    (</span><span>quote?</span><span> form) (</span><span>second</span><span> form)</span>
<span>    (</span><span>symbol?</span><span> form) (</span><span>lookup-symbol</span><span> env form)</span>
<span>    (</span><span>def?</span><span> form) (</span><span>eval-def</span><span> env form)</span>
<span>    </span><span>:else</span><span> (</span><span>eval-application</span><span> env form)))</span></code></pre><p>And here’s all <code>eval-def</code> would need to do:</p><pre><code><span>(</span><span>defn</span><span> eval-def [env [_ k v]]</span>
<span>  (</span><span>assert</span><span> (</span><span>symbol?</span><span> k) (</span><span>format</span><span> </span><span>&#34;expected k = %s to be a symbol&#34;</span><span> k))</span>
<span>  (</span><span>.put</span><span> (</span><span>:globe</span><span> env) k (</span><span>eval</span><span> env v)))</span></code></pre><p>Here, we know the first argument to <code>def</code> is the symbol, <code>k</code>. The second is the <em>value</em> <code>v</code> we want to save. So, we update our environment’s <code>globe</code> Hashmap, and point the symbol <code>k</code>, to whatever <code>(eval env v)</code> is. In our case, <code>k</code> would be <code>second-fav</code>, <code>v</code> would be <code>(+ 1 fav-num)</code>, and <code>(eval env v)</code> would become <code>42</code>.</p><p>Prettyy cool, this works! </p><pre><code><span>(</span><span>let</span><span> [e (</span><span>env</span><span>)] </span>
<span>    (</span><span>eval</span><span> e (</span><span>read-string</span><span> </span><span>&#34;(def second-fav (+ 1 fav-num))&#34;</span><span>))</span>
<span>    (</span><span>eval</span><span> e (</span><span>read-string</span><span> </span><span>&#34;second-fav&#34;</span><span>)))</span>
<span>; =&gt; </span>
<span>42</span></code></pre><h2 id="introducing-if">Introducing if</h2><p>Okay, let’s implement one more special form. We need something to handle conditional logic:</p><pre><code><span>(</span><span>if</span><span> (</span><span>=</span><span> fav-num </span><span>41</span><span>) &#39;yess &#39;noo))</span></code></pre><p>When we get <code>if</code>, we’ll can evaluate the test form: <code>(= fav-num 41)</code>. If that’s true, we’ll then evaluate the true case <code>&#39;yess</code>. Otherwise, we’ll evaluate the false case: <code>&#39;noo</code>. Sounds like a plan. </p><h2 id="evaluating-if">Evaluating if</h2><p>To implement if, as usual let’s detect it first:</p><pre><code><span>(</span><span>def</span><span> if? (</span><span>partial</span><span> seq-starts-with? &#39;if))</span></code></pre><p>Then use it in <code>eval</code>: </p><pre><code><span>(</span><span>defn</span><span> eval [env form]</span>
<span>  (</span><span>cond</span>
<span>    (</span><span>literal?</span><span> form) form</span>
<span>    (</span><span>quote?</span><span> form) (</span><span>second</span><span> form)</span>
<span>    (</span><span>symbol?</span><span> form) (</span><span>lookup-symbol</span><span> env form)</span>
<span>    (</span><span>def?</span><span> form) (</span><span>eval-def</span><span> env form)</span>
<span>    (</span><span>if?</span><span> form) (</span><span>eval-if</span><span> env form)</span>
<span>    </span><span>:else</span><span> (</span><span>eval-application</span><span> env form)))</span></code></pre><p>And here’s what <code>eval-if</code> could look like: </p><pre><code><span>(</span><span>defn</span><span> eval-if [env [_ test-form </span><span>when-true</span><span> </span><span>when-false</span><span>]]</span>
<span>  (</span><span>let</span><span> [evaled-test (</span><span>eval</span><span> env test-form)]</span>
<span>    (</span><span>eval</span><span> env (</span><span>if</span><span> evaled-test </span><span>when-true</span><span> </span><span>when-false</span><span>))))</span></code></pre><p>Just a few lines, following our description to a tee. We see if <code>evaled-test</code> is true. Then, we either evaluate <code>when-true</code>, or <code>when-false</code>. </p><p>While we’re at it, let’s add a bunch of nice primitive functions in our <code>env</code>: </p><pre><code><span>(</span><span>defn</span><span> env [] {</span><span>:globe</span><span> (</span><span>HashMap.</span><span> {&#39;+ + &#39;= = &#39;list list &#39;map map &#39;concat concat</span>
<span>                                &#39;first first &#39;second second &#39;not not &#39;fav-num </span><span>41</span><span>})})</span></code></pre><p>And bam. Our little interpreter can do quite a lot now!</p><pre><code><span>    (</span><span>eval</span><span> (</span><span>env</span><span>) (</span><span>read-string</span><span> </span><span>&#34;(if (= fav-num 41) &#39;yess &#39;noo)&#34;</span><span>))</span>
<span>    </span><span>; =&gt; yess</span></code></pre><h2 id="introducing-functions">Introducing Functions</h2><p>Let’s take things up a notch. We have Clojure’s <code>+</code> and so on, but what if our programmer wanted to write <em>their own</em> functions? Here’s an example:</p><pre><code><span>((</span><span>clo</span><span> (</span><span>x</span><span>) (</span><span>+</span><span> x fav-num) </span><span>2</span><span>))</span></code></pre><p>Here, the programmer wrote a function that takes  <code>x</code> and adds <code>fav-num</code> to it.</p><p>Say they wrote this. How can we run their function? Well, their definition has an <code>arguments</code> and a <code>body</code>. In this case, it’s <code>(x)</code> and <code>(+ x fav-num)</code> respectively. In this example, the function is called with <code>2</code>.</p><p>Here’s the insight: If we could just evaluate <code>(+ x fav-num)</code>, in an environment where <code>x</code> points to <code>2</code>, voila, it’ll be like we <em>ran</em> the function! Here’s a diagram to explain the idea:</p><p><span><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc2OC00MzBkN2ZjMC05MDQyLTQ0ZGUtYmYyOS0zNjM4ZjA5YTllYzkucG5n" alt="image"/></span></p><p>How can we point <code>x</code> to <code>2</code>? We can’t just update our our <code>globe</code> Hashmap, because then <code>x</code> would be <em>permanently</em> set to <code>2</code>, even when the <code>body</code> was done evaluating. </p><p>So we want a new idea. A <code>scope</code>. We can think of <code>scope</code> as an environment, where the changes we make only last while <code>body</code> is being evaluated.  If we can introduce a concept like this, we’ll have functions! </p><h2 id="evaluating-functions">Evaluating Functions</h2><p>Okay, let’s get this to work. First, let’s make sure that if someone writes <code>(clo (x) (+ x 1))</code>, we don’t actually try to <code>eval-application</code>. Instead, we should treat this as a new <code>closure</code> literal. </p><p>We can detect it:</p><pre><code><span>(</span><span>def</span><span> closure? (</span><span>partial</span><span> seq-starts-with? &#39;clo))</span></code></pre><p>And update our <code>literal?</code>: </p><pre><code><span>(</span><span>def</span><span> literal?</span>
<span>  (</span><span>some-fn</span><span> string? number? boolean? char? nil? fn? closure?))</span></code></pre><p>Now, if a user just writes a function, it’ll return itself: </p><pre><code><span>(</span><span>eval</span><span> (</span><span>env</span><span>) (</span><span>read-string</span><span> </span><span>&#34;(clo (x) (+ x fav-num))&#34;</span><span>))</span>
<span>; =&gt; (clo (x) (+ x fav-num))</span></code></pre><p>Next, let’s update our <code>environment</code>, to have a new <code>scope</code> map: </p><pre><code><span>(</span><span>defn</span><span> env [] {</span><span>:globe</span><span> (</span><span>HashMap.</span><span> {&#39;+ + &#39;= = &#39;list list &#39;map map &#39;concat concat</span>
<span>                                &#39;first first &#39;second second &#39;fav-num </span><span>41</span><span>})</span>
<span>              </span><span>:scope</span><span> {}})</span></code></pre><p>And let’s update <code>lookup-symbol</code>, to <em>also</em> look up variables in scope: </p><pre><code><span>(</span><span>defn</span><span> lookup-symbol [{</span><span>:keys</span><span> [globe scope]} sym]</span>
<span>  (</span><span>let</span><span> [v (</span><span>some</span><span> (</span><span>fn</span><span> [m] (</span><span>when</span><span> (</span><span>contains?</span><span> m sym) [(</span><span>get</span><span> m sym)]))</span>
<span>                [globe scope])]</span>
<span>    (</span><span>assert</span><span> v (</span><span>format</span><span> </span><span>&#34;expected value for sym = %s&#34;</span><span> sym))</span>
<span>    (</span><span>first</span><span> v)))</span></code></pre><p>Closer and closer. Now let’s make it run. If we wrote this: </p><pre><code><span>((</span><span>clo</span><span> (</span><span>x</span><span>) (</span><span>+</span><span> x fav-num)) </span><span>1</span><span>)</span></code></pre><p>This list would go to <code>eval-application</code>. Let’s update it:</p><pre><code><span>(</span><span>defn</span><span> eval-application [env [f &amp; args]]</span>
<span>  (</span><span>let</span><span> [f-evaled (</span><span>eval</span><span> env f)]</span>
<span>    (</span><span>cond</span>
<span>      (</span><span>fn?</span><span> f-evaled) (</span><span>apply</span><span> f-evaled (</span><span>eval-many</span><span> env args))</span>
<span>      (</span><span>closure?</span><span> f-evaled) (</span><span>eval-closure</span><span> env f-evaled (</span><span>eval-many</span><span> env args)))))</span></code></pre><p><code>f-evaled</code> would be <code>(clo (x) (+ x fav-num))</code>. This would mean <code>(closure? f-evaled)</code> would become true. </p><p>We’d evaluate every argument with <code>(eval-many env args)</code>, which would be <code>(1)</code>, and give this off to <code>eval-closure</code>. Here’s how <code>eval-closure</code> could look:</p><pre><code><span>(</span><span>defn</span><span> eval-closure [env [_ syms body] args]</span>
<span>  (</span><span>eval</span><span> (</span><span>assoc</span><span> env </span><span>:scope</span><span> (</span><span>assign-vars</span><span> syms args)) body))</span></code></pre><p>We’d do exactly as we did in the diagram. We’d get <code>syms</code>, which would be <code>(x)</code>, and <code>args</code>, which would be <code>(1)</code>. We’d then create a new scope: </p><pre><code><span>(</span><span>defn</span><span> assign-vars [syms args]</span>
<span>  (</span><span>assert</span><span> (</span><span>=</span><span> (</span><span>count</span><span> syms) (</span><span>count</span><span> args))</span>
<span>          (</span><span>format</span><span> </span><span>&#34;syms and args must match syms: %s args: %s&#34;</span>
<span>                  (</span><span>vec</span><span> syms) (</span><span>vec</span><span> args)))</span>
<span>  (</span><span>into</span><span> {} (</span><span>map</span><span> vector syms args)))</span></code></pre><p>That’s <code>{x 2}</code>. We’d merge it into our environment, and then evaluate <code>body</code>. </p><p>All of a sudden, <code>(+ x fav-num)</code> will become <code>43</code>!  </p><pre><code><span>(</span><span>eval</span><span> (</span><span>env</span><span>) (</span><span>read-string</span><span> </span><span>&#34;((clo (x) (+ x fav-num)) 2)&#34;</span><span>))</span>
<span>; =&gt; 43</span></code></pre><h2 id="introducing-lexical-scope">Introducing Lexical Scope</h2><p>Now, these functions are fine and all, but we can do <em>more.</em> Many languages support lexical scoping. For example, we can do this in javascript: </p><pre><code><span>const</span><span> </span><span>makeAdder</span><span> </span><span>=</span><span> (</span><span>n</span><span>) </span><span>=&gt;</span><span> (</span><span>a</span><span>) </span><span>=&gt;</span><span> </span><span>n</span><span> </span><span>+</span><span> </span><span>a</span>
<span>const</span><span> </span><span>addTwo</span><span> </span><span>=</span><span> </span><span>makeAdder</span><span>(</span><span>2</span><span>);</span>
<span>addTwo</span><span>(</span><span>4</span><span>) </span>
<span>// =&gt; </span>
<span>6</span></code></pre><p>Here, <code>makeAdder</code> returned a function. This function remembered the value of <code>n</code> <em>where it was defined</em>. How can we make this work in our own language?  </p><p>Okay, first things first, let’s say that we let the programmer see the current scope. Here’s an example of what I mean:</p><pre><code><span>((</span><span>clo</span><span> (</span><span>x</span><span>) scope) </span><span>2</span><span>)</span>
<span>; =&gt; </span>
<span>{x </span><span>2</span><span>}</span></code></pre><p>This special <code>scope</code> symbol, when evaluated returned <code>{x 2}</code>, the <em>current</em> scope! </p><p>Nice now, what if we updated our function literal? It could look something like this:</p><pre><code><span>(</span><span>clo</span><span> {n </span><span>2</span><span>} (</span><span>a</span><span>) (</span><span>+</span><span> n a))</span></code></pre><p>Here, we have a special spot for the <code>scope</code>! When we define the function, if we could just “plop” the scope of wherever it was defined in there, badabing badaboom, we’d support lexical scoping! </p><p>Here’s how our <code>make-adder</code> could work: </p><pre><code><span>(</span><span>def</span><span> make-adder (</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>n</span><span>) </span>
<span>                  (</span><span>list</span><span> &#39;clo scope &#39;(y) &#39;(+ y n)))) </span>
<span>(</span><span>def</span><span> add-two (</span><span>make-adder</span><span> </span><span>2</span><span>))</span>
<span>(</span><span>add-two</span><span> </span><span>4</span><span>)</span>
<span>; =&gt; </span>
<span>6</span></code></pre><p>When we run <code>(make-adder 2)</code> we’d evaluate <code>(list &#39;clo scope &#39;(y) &#39;(+ y n))</code>. That would return <code>(clo {n 2} (y) (+ y n))</code>! All of a sudden, we support lexical scoping. </p><p>You may think it’s weird that we wrote <code>(list &#39;clo scope &#39;(y) &#39;(+ y n)))</code> — quote verbose. But, hey, we’ll support macros soon, and that help us write this in a spiffy way. Just you wait 🙂. </p><h2 id="implementing-lexical-scope">Implementing Lexical Scope</h2><p>Okay. that’s a lot of explaining, but the changes will be simple. First we need to make sure that if we get a <code>scope</code> symbol, we return the current scope:</p><pre><code><span>(</span><span>defn</span><span> lookup-symbol [{</span><span>:keys</span><span> [globe scope]} sym]</span>
<span>  (</span><span>let</span><span> [v (</span><span>some</span><span> (</span><span>fn</span><span> [m] (</span><span>when</span><span> (</span><span>contains?</span><span> m sym) [(</span><span>get</span><span> m sym)]))</span>
<span>                [{&#39;scope scope} globe scope])]</span>
<span>    (</span><span>assert</span><span> v (</span><span>format</span><span> </span><span>&#34;expected value for sym = %s&#34;</span><span> sym))</span>
<span>    (</span><span>first</span><span> v)))</span></code></pre><p>And now all we need to do, is to update <code>eval-closure</code>: </p><pre><code><span>(</span><span>defn</span><span> eval-closure [env [_ scope syms body] args]</span>
<span>  (</span><span>eval</span><span> (</span><span>assoc</span><span> env </span><span>:scope</span><span> (</span><span>merge</span><span> scope (</span><span>assign-vars</span><span> syms args))) body))</span></code></pre><p>Here we take the <code>scope</code> <em>from</em> the closure itself! With that, lexical scoping works! </p><pre><code><span>(((</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>x</span><span>)</span>
<span>        (</span><span>list</span><span> &#39;clo scope &#39;(y) &#39;(+ y x))) </span><span>2</span><span>) </span><span>4</span><span>)</span>
<span>; =&gt; </span>
<span>6</span></code></pre><h2 id="introducing-macros">Introducing Macros</h2><p>Now, we have all we need to implement macros! Let’s think about what macros really are. </p><p>Imagine writing the function <code>unless</code>:</p><pre><code><span>(</span><span>def</span><span> unless (</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>test</span><span> v)</span>
<span>              (</span><span>if</span><span> (</span><span>not</span><span> test) v)))</span></code></pre><p>Will it work? If we ran <code>(unless (= fav-num 41) &#39;yes)</code>, it <em>would</em> return the symbol <code>yes</code>. </p><p>But what if we ran this? </p><pre><code><span>(</span><span>unless</span><span> (</span><span>=</span><span> fav-num </span><span>41</span><span>) (</span><span>throw-error</span><span>))</span></code></pre><p>Since <code>unless</code> is a function, we would evaluate each argument first right? In that case, we’d evaluate <code>(= fav-num 41)</code>, which would be <code>true</code>. But, we’d <em>also</em> evaluate <code>(throw-error)</code>. That would break our program. This defeats the whole purpose of <code>unless</code> , as <code>(throw-error)</code>  was supposed to run <em>only</em> when <code>test</code> was false.</p><p><span><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc3Mi1hNTlmNGJkOC1mNDc1LTQxMGMtODFmYi02YWI2NjlhNDY1OTEucG5n" alt="image"/></span></p><p>Now, imagine we wrote the <em>macro</em> unless: </p><pre><code><span>(</span><span>def</span><span> unless (</span><span>mac</span><span> (</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>test</span><span> v)</span>
<span>                    (</span><span>list</span><span> &#39;if (</span><span>list</span><span> &#39;not test) v))))</span></code></pre><p>If we ran <code>(unless (= fav-num 41) (throw-error))</code>, here’s what would happen:</p><p>The value of <code>test</code> would not be <code>true</code>, it would actually be the list <code>(= fav-num 41)</code>.  Similarly, we wouldn’t evaluate <code>(throw-error)</code> . <code>v</code> would just be the actual list <code>(throw-error)</code>. </p><p><em>The arguments to a macro are not evaluated.</em> When the macro runs, it returns <em>code.</em> The result of </p><pre><code><span>(</span><span>list</span><span> &#39;if (</span><span>list</span><span> &#39;not test) v))</span></code></pre><p>would become</p><pre><code><span>(</span><span>if</span><span> (</span><span>not</span><span> (</span><span>=</span><span> fav</span><span>-</span><span>num </span><span>41</span><span>)) (</span><span>throw</span><span>-</span><span>error))</span></code></pre><p>And when we evaluated <em>that,</em> things would work as expected! <code>(throw-error)</code> would never evaluate.</p><p>This is the key difference between functions and macros.  Functions take <em>evaluated values</em> as arguments and return evaluated values. Macros receive <em>unevaluated</em> arguments, return <em>code, and that code is evaluated.</em></p><p><span><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc3OS1mMDMxNWQyNS1lZjZlLTQzYjktOTBiNy1jMmYyMDE2YTkyOGIucG5n" alt="image"/></span></p><p>An important piece to note is that we eval <em>twice.</em> We give the macro the unevaluated arguments, which returns new code, and we once again <em>evaluate</em> that. </p><p>So, how can we support this?</p><h2 id="evaluating-macros">Evaluating Macros</h2><p>So much explanation, for such little code. Are you ready? Let’s add macros. </p><p>First, let’s use this new structure for a macro: a macro is a list that begins with <code>mac</code>, and has closure inside:</p><pre><code><span>(</span><span>mac</span><span> (</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>...</span><span>))</span></code></pre><p>We can detect macro, and mark it as a literal: </p><pre><code><span>(</span><span>def</span><span> macro? (</span><span>partial</span><span> seq-starts-with? &#39;mac))</span>
<span>    </span>
<span>(</span><span>def</span><span> literal?</span>
<span>  (</span><span>some-fn</span><span> string? number? boolean? char? nil? fn? closure? macro?))</span></code></pre><p>Next, we’ll want to update <code>eval-application</code>: </p><pre><code><span>(</span><span>defn</span><span> eval-application [env [f &amp; args]]</span>
<span>  (</span><span>let</span><span> [f-evaled (</span><span>eval</span><span> env f)]</span>
<span>    (</span><span>cond</span>
<span>      (</span><span>fn?</span><span> f-evaled) (</span><span>apply</span><span> f-evaled (</span><span>eval-many</span><span> env args))</span>
<span>      (</span><span>closure?</span><span> f-evaled) (</span><span>eval-closure</span><span> env f-evaled (</span><span>eval-many</span><span> env args))</span>
<span>      (</span><span>macro?</span><span> f-evaled) (</span><span>eval-macro</span><span> env f-evaled args))))</span></code></pre><p>Before we always ran <code>(eval-many env args)</code>. But this time, if it’s a macro, we pass in <code>args</code> directly! That’s the ”code” itself 🙂. </p><p>And now for <code>eval-macro</code>: </p><pre><code><span>(</span><span>defn</span><span> eval-macro [env [_ clo] args]</span>
<span>  (</span><span>eval</span><span> env</span>
<span>        (</span><span>eval</span><span> env (</span><span>concat</span><span> [clo] (</span><span>map</span><span> (</span><span>partial</span><span> list &#39;quote) args)))))</span></code></pre><p>Oh my god. 3 lines!! We do exactly as we said in our diagram: </p><p><span><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc5MC02MWFhOTQ5OC05NDgzLTQ4ODYtOGRiMC1lYmM3NzE1OTM2MzkucG5n" alt="image"/></span></p><p>We take the “closure” out of our macro, and <em>run</em> it with <em>unevaluated</em> args. We can do that just by wrapping each <code>arg</code> in a quote: <code>(map (partial list &#39;quote) args)</code>. </p><p>Once we have the resulting code, we <em>evaluate</em> that again, and boom, we have macros.</p><pre><code><span>(</span><span>def</span><span> unless (</span><span>mac</span><span> (</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>test</span><span> v)</span>
<span>                    (</span><span>list</span><span> &#39;if (</span><span>list</span><span> &#39;not test) v))))</span>
<span>; works!</span>
<span>(</span><span>unless</span><span> (</span><span>=</span><span> fav-num </span><span>41</span><span>) (</span><span>throw-error</span><span>))</span></code></pre><p>Okay, we have a Lisp that supports macros. Let’s go ahead and write some of our own! </p><h2 id="defmacro">defmacro</h2><p>Let’s get meta off the bat. Notice what we do when we define a macro:</p><pre><code><span>(</span><span>def</span><span> unless (</span><span>mac</span><span> (</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>test</span><span> v)</span>
<span>                      (</span><span>list</span><span> &#39;if (</span><span>list</span><span> &#39;not test) v))))</span></code></pre><p>This whole  <code>(mac (clo nil …))</code> business is a bit unnecessary. Let’s just write macro that does this for us!</p><pre><code><span>(</span><span>def</span><span> defmacro</span>
<span>      (</span><span>mac</span><span> (</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>n</span><span> p e)</span>
<span>                (</span><span>list</span><span> &#39;def n</span>
<span>                      (</span><span>list</span><span> &#39;mac (</span><span>list</span><span> &#39;clo </span><span>nil</span><span> p e))))))</span></code></pre><p>This generates the code <code>(def n (mac (clo nil …)))</code>. Now we could write: </p><pre><code><span>(</span><span>defmacro</span><span> unless (</span><span>test</span><span> v) </span>
<span>  (</span><span>list</span><span> &#39;if (</span><span>list</span><span> &#39;not test) v))</span></code></pre><p>Cool! </p><h2 id="fn">fn</h2><p>Okay, remember how we wrote our function for lexical scoping? </p><pre><code><span>(</span><span>def</span><span> make-adder (</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>n</span><span>)</span>
<span>                      (</span><span>list</span><span> &#39;clo scope &#39;(y) &#39;(+ y n))))</span></code></pre><p>Let’s have a macro write this for us: </p><pre><code><span>(</span><span>defmacro</span><span> fn (</span><span>args</span><span> body)</span>
<span>              (</span><span>list</span><span> &#39;list &#39;&#39;clo &#39;scope</span>
<span>                    (</span><span>list</span><span> &#39;quote args)</span>
<span>                    (</span><span>list</span><span> &#39;quote body)))</span></code></pre><p>Here’s what happens if we wrote: </p><pre><code><span>(</span><span>def</span><span> make-adder (</span><span>clo</span><span> </span><span>nil</span><span> (</span><span>n</span><span>)</span>
<span>                    (</span><span>fn</span><span> (</span><span>y</span><span>) (</span><span>+</span><span> y n))))</span>
<!-- -->
<span>(</span><span>def</span><span> add-two (</span><span>make-adder</span><span> </span><span>2</span><span>))</span></code></pre><p>When the macro expansion for <code>fn</code> runs, the <code>args</code> would would be <code>(y)</code> and <code>body</code> <code>(+ y n)</code>. So</p><pre><code><span>(</span><span>list</span><span> &#39;list &#39;&#39;clo &#39;scope</span>
<span>      (</span><span>list</span><span> &#39;quote args)</span>
<span>      (</span><span>list</span><span> &#39;quote body))</span></code></pre><p>would expand to</p><pre><code><span>(</span><span>list</span><span> &#39;clo scope &#39;(y) &#39;(+ y n))</span></code></pre><p>and that’s <em>exactly</em> what we wrote by hand! Bam, now we can use <code>fn</code> instead of this whole <code>&#39;clo scope</code> business.</p><h2 id="defn">defn</h2><p>Now if we wanted to define functions, we could write: </p><pre><code><span>(</span><span>def</span><span> add-fav-num (</span><span>fn</span><span> (</span><span>x</span><span>) (</span><span>+</span><span> x fav-num)))</span></code></pre><p>But we can make it tighter. Let’s add a <code>defn</code> macro, so we could write: </p><pre><code><span>(</span><span>defn</span><span> add-fav-num (</span><span>x</span><span>) (</span><span>+</span><span> x fav-num))</span></code></pre><p>Easy peasy:</p><pre><code><span>(</span><span>defmacro</span><span> defn (</span><span>n</span><span> args body)</span>
<span>  (</span><span>list</span><span> &#39;def n (</span><span>list</span><span> &#39;fn args body)))</span></code></pre><h2 id="let">let</h2><p>One more cool macro. Right now, there’s no real way to define temporary variables. Something like: </p><pre><code><span>(</span><span>let</span><span> ((</span><span>x</span><span> </span><span>1</span><span>) (</span><span>y</span><span> </span><span>2</span><span>)) </span>
<span>  (</span><span>+</span><span> x y))</span>
<span>; =&gt; </span>
<span>3</span></code></pre><p>How could we support it? Well, what if we <em>rewrote</em> <code>(let …)</code> to: </p><pre><code><span>((</span><span>fn</span><span> (</span><span>x</span><span> y) (</span><span>+</span><span> x y)) </span><span>1</span><span> </span><span>2</span><span>)</span></code></pre><p>We could just use the argument list of a function to create these variables! Perfecto. Here’s the macro: </p><pre><code><span>(</span><span>defmacro</span><span> let (</span><span>pairs</span><span> body)</span>
<span>  (</span><span>concat</span><span> (</span><span>list</span><span> (</span><span>list</span><span> &#39;fn (</span><span>map</span><span> first pairs) body))</span>
<span>                (</span><span>map</span><span> second pairs)))</span></code></pre><p>What a journey. 80 lines, 4000 words, and hopefully a fun time 🙂. You now have a Lisp with macros, and you’ve written some cool ones yourself. Here’s the <a href="https://github.com/stopachka/llisp/blob/main/src/llisp/core.clj" target="_blank">full source</a> if you’d like to follow along from there.</p><p><strong>Credits</strong></p><p>The idea to represent macros and closures like this, came from PG’s <a href="http://www.paulgraham.com/bel.html" target="_blank">Bel</a>. </p><p><em>Thanks to Mark Shlick, Daniel Woelfel for reviewing drafts of this essay.</em> </p></span></p></div></div></div></div>
  </body>
</html>
