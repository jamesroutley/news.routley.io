<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openjdk.java.net/jeps/419">Original</a>
    <h1>JEP 419: Foreign Function and Memory API</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="Summary">Summary</h2>
<p>Introduce an API by which Java programs can interoperate with code and data outside of the Java runtime. By efficiently invoking foreign functions (i.e., code outside the JVM), and by safely accessing foreign memory (i.e., memory not managed by the JVM), the API enables Java programs to call native libraries and process native data without the brittleness and danger of JNI.</p>
<h2 id="History">History</h2>
<p>The Foreign Function &amp; Memory API was proposed by <a href="https://openjdk.java.net/jeps/412">JEP 412</a> and targeted to Java 17 in mid 2021 as an incubating API. It combined two earlier incubating APIs: the Foreign-Memory Access API and the Foreign Linker API. This JEP proposes to incorporate refinements based on feedback, and to re-incubate the API in Java 18. The following changes are included in this refresh:</p>
<ul>
<li>Support for more carriers, such as <code>boolean</code> and <code>MemoryAddress</code>, in memory access var handles;</li>
<li>A more general dereference API, available in both the <code>MemorySegment</code> and <code>MemoryAddress</code> interfaces;</li>
<li>A simpler API to obtain downcall method handles, where passing a <code>MethodType</code> parameter is no longer required;</li>
<li>A simpler API to manage temporal dependencies between resource scopes; and</li>
<li>A new API to copy Java arrays to and from memory segments.</li>
</ul>
<h2 id="Goals">Goals</h2>
<ul>
<li>
<p><em>Ease of use</em> — Replace the Java Native Interface (<a href="https://docs.oracle.com/en/java/javase/16/docs/specs/jni/index.html">JNI</a>) with a superior, pure-Java development model.</p>
</li>
<li>
<p><em>Performance</em>  — Provide performance that is comparable to, if not better than, existing APIs such as JNI and <code>sun.misc.Unsafe</code>.</p>
</li>
<li>
<p><em>Generality</em> — Provide ways to operate on different kinds of foreign memory (e.g., native memory, persistent memory, and managed heap memory) and, over time, to accommodate other platforms (e.g., 32-bit x86) and foreign functions written in languages other than C (e.g., C++, Fortran).</p>
</li>
<li>
<p><em>Safety</em> —  Disable unsafe operations by default, allowing them only after explicit opt-in from application developers or end users.</p>
</li>
</ul>
<h2 id="Non-goals">Non-goals</h2>
<p>It is not a goal to</p>
<ul>
<li>Re-implement JNI on top of this API, or otherwise change JNI in any way;</li>
<li>Re-implement legacy Java APIs, such as <code>sun.misc.Unsafe</code>, on top of this API;</li>
<li>Provide tooling that mechanically generates Java code from native-code header files; or</li>
<li>Change how Java applications that interact with native libraries are packaged and deployed (e.g., via multi-platform JAR files).</li>
</ul>
<h2 id="Motivation">Motivation</h2>
<p>The Java Platform has always offered a rich foundation to library and application developers who wish to reach beyond the JVM and interact with other platforms. Java APIs expose non-Java resources conveniently and reliably, whether to access remote data (JDBC), invoke web services (HTTP client), serve remote clients (NIO channels), or communicate with local processes (Unix-domain sockets). Unfortunately, Java developers still face significant obstacles in accessing an important kind of non-Java resource: code and data on the same machine as the JVM, but outside the Java runtime.</p>
<h3 id="Foreign-memory">Foreign memory</h3>
<p>Data stored in memory outside the Java runtime is referred to as <em>off-heap</em> data. (The <em>heap</em> is where Java objects live — <em>on-heap</em> data — and where garbage collectors do their work.) Accessing off-heap data is critical for the performance of popular Java libraries such as <a href="https://github.com/tensorflow/tensorflow">Tensorflow</a>, <a href="https://ignite.apache.org">Ignite</a>, <a href="https://lucene.apache.org/">Lucene</a>, and <a href="https://netty.io">Netty</a>, primarily because it lets them avoid the cost and unpredictability associated with garbage collection. It also allows data structures to be serialized and deserialized by mapping files into memory via, e.g., <a href="https://en.wikipedia.org/wiki/Mmap"><code>mmap</code></a>. However, the Java Platform does not provide a satisfactory solution for accessing off-heap data.</p>
<ul>
<li>
<p>The <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html"><code>ByteBuffer</code> API</a> allows for the creation of <em>direct</em> byte buffers that are allocated off-heap, but their maximum size is two gigabytes and they are not deallocated promptly. These and other limitations stem from the  fact that the <code>ByteBuffer</code> API was designed not only for off-heap memory access but also for producer/consumer exchanges of bulk data in areas such as charset encoding/decoding and partial I/O operations. In that context it has not been possible to satisfy the many requests for off-heap enhancements filed over the years (e.g., <a href="https://bugs.openjdk.java.net/browse/JDK-4496703">4496703</a>, <a href="https://bugs.openjdk.java.net/browse/JDK-6558368">6558368</a>, <a href="https://bugs.openjdk.java.net/browse/JDK-4837564">4837564</a>, and <a href="https://bugs.openjdk.java.net/browse/JDK-5029431">5029431</a>).</p>
</li>
<li>
<p>The <a href="https://hg.openjdk.java.net/jdk/jdk/file/tip/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java"><code>sun.misc.Unsafe</code> API</a> exposes memory access operations for on-heap data that also work for off-heap data. Using <code>Unsafe</code> is efficient because its memory access operations are defined as HotSpot JVM intrinsics and optimized by the JIT compiler. However, using <code>Unsafe</code> is dangerous because it allows access to any memory location. This means that a Java program can crash the JVM by accessing an already-freed location; for this and other reasons, the use of <code>Unsafe</code> has always been <a href="https://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html">strongly discouraged</a>.</p>
</li>
<li>
<p>Using JNI to call a native library which then accesses off-heap data is possible, but the performance overhead seldom makes it applicable: Going from Java to native is several orders of magnitude slower than accessing memory because JNI method calls do not benefit from many common JIT optimizations such as inlining.</p>
</li>
</ul>
<p>In summary, when it comes to accessing off-heap data, Java developers face a dilemma: Should they choose a safe but inefficient path (<code>ByteBuffer</code>) or should they abandon safety in favor of performance (<code>Unsafe</code>)? What they in fact require is a supported API for accessing off-heap data (i.e., foreign memory) designed from the ground up to be safe and with JIT optimizations in mind.</p>
<h3 id="Foreign-functions">Foreign functions</h3>
<p>JNI has supported the invocation of native code (i.e., foreign functions) since Java 1.1, but it is inadequate for many reasons.</p>
<ul>
<li>
<p>JNI involves several tedious artifacts: a Java API (<code>native</code> methods), a C header file derived from the Java API, and a C implementation that calls the native library of interest. Java developers must work across multiple toolchains to keep platform-dependent artifacts in sync, which is especially burdensome when the native library evolves rapidly.</p>
</li>
<li>
<p>JNI can only interoperate with libraries written in languages, typically C and C++, that use the calling convention of the operating system and CPU for which the JVM was built.  A <code>native</code> method cannot be used to invoke a function written in a language that uses a different convention.</p>
</li>
<li>
<p>JNI does not reconcile the Java type system with the C type system. Aggregate data in Java is represented with objects, but aggregate data in C is represented with structs, so any Java object passed to a <code>native</code> method must be laboriously unpacked by native code. For example, consider a record class <code>Person</code> in Java: Passing a <code>Person</code> object to a <code>native</code> method will require the native code to use JNI&#39;s C API to extract fields (e.g., <code>firstName</code> and <code>lastName</code>) from the object. As a result, Java developers sometimes flatten their data into a single object (e.g., a byte array or a direct byte buffer) but more often, since passing Java objects via JNI is slow, they use the <code>Unsafe</code> API to allocate off-heap memory and pass its address to a <code>native</code> method as a <code>long</code> — which makes the Java code tragically unsafe!</p>
</li>
</ul>
<p>Over the years, numerous frameworks have emerged to fill the gaps left by JNI, including <a href="https://github.com/java-native-access/jna">JNA</a>, <a href="https://github.com/jnr/jnr-ffi">JNR</a> and <a href="https://github.com/bytedeco/javacpp">JavaCPP</a>. While these frameworks are often a marked improvement over JNI, the situation is still less than ideal, especially when compared with languages which offer first-class native interoperation. For example, Python&#39;s <a href="https://docs.python.org/3/library/ctypes.html">ctypes</a> package can dynamically wrap functions in native libraries without any glue code. Other languages, such as <a href="https://rust-lang.github.io/rust-bindgen/">Rust</a>, provide tools which mechanically derive native wrappers from C/C++ header files.</p>
<p>Ultimately, Java developers should have a supported API that lets them straightforwardly consume any native library deemed useful for a particular task, without the tedious glue and clunkiness of JNI. An excellent abstraction to build upon is <em>method handles</em>, introduced in Java 7 to support fast dynamic languages on the JVM. Exposing native code via method handles would radically simplify the task of writing, building, and distributing Java libraries which depend upon native libraries. Furthermore, an API capable of modeling foreign functions (i.e., native code) and foreign memory (i.e., off-heap data) would provide a solid foundation for third-party native interoperation frameworks.</p>
<h2 id="Description">Description</h2>
<p>The Foreign Function &amp; Memory API (FFM API) defines classes and interfaces so that client code in libraries and applications can</p>
<ul>
<li>Allocate foreign memory</li>
<li>Manipulate and access structured foreign memory</li>
<li>Manage the lifecycle of foreign resources (<code>ResourceScope</code>), and</li>
<li>Call foreign functions (<code>SymbolLookup</code>, <code>CLinker</code>, and <code>NativeSymbol</code>).</li>
</ul>
<p>The FFM API resides in the <code>jdk.incubator.foreign</code> package of the <code>jdk.incubator.foreign</code> module.</p>
<h3 id="Example">Example</h3>
<p>As a brief example of using the FFM API, here is Java code that obtains a method handle for a C library function <code>radixsort</code> and then uses it to sort four strings which start life in a Java array (a few details are elided):</p>
<pre><code>// 1. Find foreign function on the C library path
CLinker linker = CLinker.getInstance();
MethodHandle radixSort = linker.downcallHandle(
                             linker.lookup(&#34;radixsort&#34;), ...);
// 2. Allocate on-heap memory to store four strings
String[] javaStrings   = { &#34;mouse&#34;, &#34;cat&#34;, &#34;dog&#34;, &#34;car&#34; };
// 3. Allocate off-heap memory to store four pointers
MemorySegment offHeap  = MemorySegment.allocateNative(
                             MemoryLayout.ofSequence(javaStrings.length,
                                                     ValueLayout.ADDRESS), ...);
// 4. Copy the strings from on-heap to off-heap
for (int i = 0; i &lt; javaStrings.length; i++) {
    // Allocate a string off-heap, then store a pointer to it
    MemorySegment cString = implicitAllocator().allocateUtf8String(javaStrings[i]);
    offHeap.setAtIndex(ValueLayout.ADDRESS, i, cString);
}
// 5. Sort the off-heap data by calling the foreign function
radixSort.invoke(offHeap, javaStrings.length, MemoryAddress.NULL, &#39;\0&#39;);
// 6. Copy the (reordered) strings from off-heap to on-heap
for (int i = 0; i &lt; javaStrings.length; i++) {
    MemoryAddress cStringPtr = offHeap.getAtIndex(ValueLayout.ADDRESS, i);
    javaStrings[i] = cStringPtr.getUtf8String(0);
}
assert Arrays.equals(javaStrings, new String[] {&#34;car&#34;, &#34;cat&#34;, &#34;dog&#34;, &#34;mouse&#34;});  // true</code></pre>
<p>This code is far clearer than any solution that uses JNI, since implicit conversions and memory dereferences that would have been hidden behind <code>native</code> method calls are now expressed directly in Java. Modern Java idioms can also be used; for example, streams can allow for multiple threads to copy data between on-heap and off-heap memory in parallel.</p>
<h3 id="Memory-segments">Memory segments</h3>
<p>A <em>memory segment</em> is an abstraction that models a contiguous region of memory, located either off-heap or on-heap. Memory segments can be</p>
<ul>
<li><em>Native</em> segments, allocated from scratch in native memory (e.g., via <code>malloc</code>),</li>
<li><em>Mapped</em> segments, wrapped around a region of mapped native memory (e.g., via <code>mmap</code>), or</li>
<li><em>Array</em> or <em>buffer</em> segments, wrapped around memory associated with existing Java arrays or byte buffers, respectively.</li>
</ul>
<p>All memory segments provide strongly enforced spatial, temporal, and thread-confinement guarantees which make memory dereference operations safe. For example, the following code allocates 100 bytes off-heap:</p>
<pre><code>MemorySegment segment = MemorySegment.allocateNative(100,
                                                     newImplicitScope());</code></pre>
<p>The <em>spatial bounds</em> of a segment determine the range of memory addresses associated with the segment. The bounds of the segment in the code above are defined by a <em>base address</em> <code>b</code>, expressed as a <code>MemoryAddress</code> instance, and a size in bytes (100), resulting in a range of addresses from <code>b</code> to <code>b</code> + 99, inclusive.</p>
<p>The <em>temporal bounds</em> of a segment determine the lifetime of the segment, that is, when the segment will be deallocated. A segment&#39;s lifetime and thread-confinement state is modeled by a <code>ResourceScope</code> abstraction, discussed <a href="#Resource-scopes">below</a>. The resource scope in the code above is a new <em>shared</em> scope, which ensures that the memory associated with this segment is freed when the <code>MemorySegment</code> object is deemed unreachable by the garbage collector. The shared scope also ensures that the memory segment is accessible from multiple threads.</p>
<p>In other words, the code above creates a segment whose behavior closely matches that of a <code>ByteBuffer</code> allocated with the <code>allocateDirect</code> factory. The FFM API also supports deterministic memory release and other thread-confinement options, discussed <a href="#Resource-scopes">below</a>.</p>
<h3 id="Dereferencing-segments">Dereferencing segments</h3>
<p>To dereference some data in a memory segment, we need to take into account several factors:</p>
<ul>
<li>The number of bytes to be dereferenced,</li>
<li>The alignment constraints of the address at which dereference occurs,</li>
<li>The endianness with which bytes are stored in said memory region, and</li>
<li>The Java type to be used in the dereference operation (e.g. <code>int</code> vs <code>float</code>).</li>
</ul>
<p>All these characteristics are captured in the <code>ValueLayout</code> abstraction. For example, the predefined <code>JAVA_INT</code> value layout is four bytes wide, has no alignment constraints, uses the native platform endianness (e.g., little-endian on Linux/x64), and is associated with the Java type <code>int</code>.</p>
<p>Memory segments have simple dereference methods to read and write values from and to memory segments. These methods accept a value layout, which uniquely specifies the properties of the dereference operation. For example, we can write 25 <code>int</code> values at consecutive offsets in a memory segment using the following code:</p>
<pre><code>MemorySegment segment = MemorySegment.allocateNative(100,
                                                     newImplicitScope());
for (int i = 0; i &lt; 25; i++) {
    segment.setAtIndex(ValueLayout.JAVA_INT,
                       /* index */ i,
                       /* value to write */ i);
}</code></pre>
<h3 id="Memory-layouts-and-structured-access">Memory layouts and structured access</h3>
<p>Consider the following C declaration, which defines an array of <code>Point</code> structs, where each <code>Point</code> struct has two members, namely <code>Point.x</code> and <code>Point.y</code>:</p>
<pre><code>struct Point {
   int x;
   int y;
} pts[10];</code></pre>
<p>Using the dereference methods shown in the previous section, to initialize such a native array we would have to write the following code:</p>
<pre><code>MemorySegment segment = MemorySegment.allocateNative(2 * 4 * 10,
                                                     newImplicitScope());
for (int i = 0; i &lt; 10; i++) {
    segment.setAtIndex(ValueLayout.JAVA_INT,
                       /* index */ (i * 2),
                       /* value to write */ i); // x
    segment.setAtIndex(ValueLayout.JAVA_INT,
                       /* index */ (i * 2) + 1,
                       /* value to write */ i); // y
}</code></pre>
<p>To reduce the need for tedious calculations about memory layout (e.g., <code>(i * 2) + 1</code> in the example above), a <code>MemoryLayout</code> can be used to describe the content of a memory segment in a more declarative fashion. For example, the desired layout of the native memory segment in the examples above can be described in the following way:</p>
<pre><code>SequenceLayout ptsLayout
    = MemoryLayout.sequenceLayout(10,
                                  MemoryLayout.structLayout(
                                      ValueLayout.JAVA_INT.withName(&#34;x&#34;),
                                      ValueLayout.JAVA_INT.withName(&#34;y&#34;)));</code></pre>
<p>This creates a <em>sequence memory layout</em> containing ten repetitions of a <em>struct layout</em> whose elements are two <code>JAVA_INT</code> layouts named <code>x</code> and <code>y</code>, respectively. Given this layout, we can avoid calculating offsets in our code by creating a <em>memory-access var handle</em>, a special kind of <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/invoke/VarHandle.html">var handle</a> which accepts a <code>MemorySegment</code> parameter (the segment to be dereferenced) followed by one or more <code>long</code> coordinates (the indices at which the dereference operation should occur):</p>
<pre><code>VarHandle xHandle    // (MemorySegment, long) -&gt; int
    = ptsLayout.varHandle(PathElement.sequenceElement(),
                          PathElement.groupElement(&#34;x&#34;));
VarHandle yHandle    // (MemorySegment, long) -&gt; int
    = ptsLayout.varHandle(PathElement.sequenceElement(),
                          PathElement.groupElement(&#34;y&#34;));

MemorySegment segment = MemorySegment.allocateNative(ptsLayout,
                                                     newImplicitScope());
for (int i = 0; i &lt; ptsLayout.elementCount().getAsLong(); i++) {
    xHandle.set(segment,
                /* index */ (long) i,
                /* value to write */ i); // x
    yHandle.set(segment,
                /* index */ (long) i,
                /* value to write */ i); // y
}</code></pre>
<p>The <code>ptsLayout</code> object drives the creation of the memory-access var handle through the creation of a <em>layout path</em>, which is used to select a nested layout from a complex layout expression. Since the selected value layout is associated with the Java type <code>int</code>, the type of the resulting var handles <code>xHandle</code> and <code>yHandle</code> will also be <code>int</code>. Moreover, since the selected value layout is defined inside a sequence layout, the resulting var handles acquire an extra coordinate of type <code>long</code>, namely the index of the <code>Point</code> struct whose coordinate is to be read or written. The <code>ptsLayout</code> object also drives the allocation of the native memory segment, which is based upon size and alignment information derived from the layout. Offset computations are no longer needed inside the loop since distinct var handles are used to initialize the <code>Point.x</code> and <code>Point.y</code> elements.</p>
<h3 id="Resource-scopes">Resource scopes</h3>
<p>All of the examples above use non-deterministic deallocation: The memory associated with the allocated segments is deallocated by the garbage collector after the memory segment instance becomes unreachable. We say that such segments are <em>implicitly deallocated</em>.</p>
<p>There are cases where the client might want to control when memory deallocation occurs. Suppose, e.g., that a large memory segment is mapped from a file using <code>MemorySegment::map</code>. The client might prefer to release (i.e., unmap) the memory associated with the segment as soon as the segment is no longer required rather than wait for the garbage collector to do so, since waiting could adversely affect the application&#39;s performance.</p>
<p>Memory segments support deterministic deallocation through <em>resource scopes</em>. A resource scope models the lifecycle of one or more <em>resources,</em> such as memory segments. A newly-created resource scope is in the <em>alive</em> state, which means that all the resources it manages can be accessed safely. At the client&#39;s request a resource scope can be <em>closed</em> so that access to the resources managed by the scope is no longer allowed. The <code>ResourceScope</code> class implements the <code>AutoCloseable</code> interface so that resource scopes work with the <a href="https://docs.oracle.com/javase/specs/jls/se16/html/jls-14.html#jls-14.20.3">try-with-resources</a> statement:</p>
<pre><code>try (ResourceScope scope = ResourceScope.newConfinedScope()) {
    MemorySegment s1 = MemorySegment.map(Path.of(&#34;someFile&#34;),
                                         0, 100000,
                                         MapMode.READ_WRITE, scope);
    MemorySegment s2 = MemorySegment.allocateNative(100, scope);
    ...
} // both segments released here</code></pre>
<p>This code creates a resource scope and uses it to create two segments: a mapped segment (<code>s1</code>) and a native segment (<code>s2</code>). The lifecycle of the two segments is tied to the lifetime of the resource scope, so accessing the segments (e.g., dereferencing them with memory-access var handles) outside of the try-with-resources statement will cause a runtime exception to be thrown.</p>
<p>In addition to managing a memory segment&#39;s lifetime, a resource scope also controls which threads can access the segment. A <em>confined</em> resource scope restricts access to the thread which created the scope, whereas a <em>shared</em> resource scope allows access from any thread.</p>
<p>Resource scopes, whether confined or shared, can be associated with a <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ref/Cleaner.html"><code>java.lang.ref.Cleaner</code></a> object that performs implicit deallocation in case the resource scope becomes unreachable while the scope is still alive, thus preventing accidental memory leaks.</p>
<h3 id="Segment-allocators">Segment allocators</h3>
<p>Memory allocation can often be a bottleneck when clients use off-heap memory. The FFM API therefore includes a <code>SegmentAllocator</code> abstraction, which defines useful operations to allocate and initialize memory segments. Segment allocators are obtained via factories in the <code>SegmentAllocator</code> interface. One such factory returns the <em>implicit allocator</em>, that is, an allocator which allocates native segments backed by a fresh implicit scope. Other, more optimized allocators are also provided. For example, the following code creates an arena-based allocator and uses it to allocate a segment whose content is initialized from a Java <code>int</code> array:</p>
<pre><code>try (ResourceScope scope = ResourceScope.newConfinedScope()) {
    SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);
    for (int i = 0 ; i &lt; 100 ; i++) {
        MemorySegment s = allocator.allocateArray(JAVA_INT,
                                                  new int[] { 1, 2, 3, 4, 5 });
        ...
    }
    ...
} // all memory allocated is released here</code></pre>
<p>This code creates a confined resource scope and then creates an <em>unbounded arena allocator</em> associated with that scope. This allocator allocates a segment of memory and responds to allocation requests by returning slices of that pre-allocated segment. If the current segment does not have sufficient space to accommodate an allocation request then a new segment is allocated. All of the memory associated with the segments created by the allocator (i.e., in the body of the <code>for</code> loop) is deallocated  atomically when the resource scope associated with the arena allocator is closed. This technique combines the advantages of deterministic deallocation, provided by the <code>ResourceScope</code> abstraction, with a more flexible and scalable allocation scheme. It can be very useful when writing code which manages a large number of off-heap segments.</p>
<h3 id="Unsafe-memory-segments">Unsafe memory segments</h3>
<p>So far, we have seen memory segments, memory addresses, and memory layouts. Dereference operations are only possible on memory segments. Since a memory segment has spatial and temporal bounds, the Java runtime ensures that the memory associated with a given segment is dereferenced safely. However, there are situations where clients might only have a <code>MemoryAddress</code> instance, as is often the case when interacting with native code. To dereference a memory address, a client has two options:</p>
<ul>
<li>
<p>First, the client can use one of the dereference methods defined in the <code>MemoryAddress</code> class. These methods are unsafe because a memory address has no spatial or temporal bounds, and thus the FFM API has no way to ensure that the memory location being dereferenced is valid.</p>
</li>
<li>
<p>Alternatively, the client can unsafely turn the address into a segment via the <code>MemorySegment::ofAddressNative</code> factory. This factory attaches fresh spatial and temporal bounds to an otherwise raw memory address in order to allow dereference operations. The memory segment returned by this factory is <em>unsafe:</em> A raw memory address might be associated with a memory region that is 10 bytes long, but the client might accidentally overestimate the size of the region and create an unsafe memory segment that is 100 bytes long. Later, this might result in attempts to dereference memory outside the bounds of the memory region associated with the unsafe segment, which might cause a JVM crash or, worse, result in silent memory corruption.</p>
</li>
</ul>
<p>Both of these options are unsafe and are therefore considered <em>restricted operations</em>, which are disabled by default (see more <a href="#Safety">below</a>).</p>
<h3 id="Looking-up-foreign-functions">Looking up foreign functions</h3>
<p>The first ingredient of any support for foreign functions is a mechanism to load native libraries. JNI accomplishes this with the <code>System::loadLibrary</code> and <code>System::load</code> methods, which internally map into calls to <code>dlopen</code> or its equivalent. Libraries loaded using these methods are always associated with a class loader, namely the loader of the class which called the method. The association between libraries and class loaders is crucial because it governs the lifecycle of loaded libraries: Only when a class loader is no longer reachable can all of its libraries be unloaded safely.</p>
<p>The FFM API does not provide new methods for loading native libraries. Developers use the <code>System::loadLibrary</code> and <code>System::load</code> methods to load native libraries to be invoked via the FFM API. The association between libraries and class loaders is preserved, so that libraries will be unloaded in the same predictable manner as with JNI.</p>
<p>The FFM API, unlike JNI, provides the ability to find the address of a given symbol in a loaded library. This capability, represented by a <code>SymbolLookup</code> object, is crucial for linking Java code to foreign functions (see <a href="#Linking-Java-code-to-foreign-functions">below</a>). There are two ways to obtain a <code>SymbolLookup</code> object:</p>
<ul>
<li>
<p>By invoking <code>SymbolLookup::loaderLookup</code>, which returns a symbol lookup which locates all the symbols in all the libraries loaded by the current class loader, or</p>
</li>
<li>
<p>By obtaining a <code>CLinker</code> instance, which implements the <code>SymbolLookup</code> interface and can be used to look up platform-specific symbols in the standard C library.</p>
</li>
</ul>
<p>Given a symbol lookup, a client can find a foreign function with the <code>SymbolLookup::lookup(String)</code> method. If the named function is present among the symbols seen by the symbol lookup then the method returns a <code>NativeSymbol</code> that points to the function&#39;s entry point. For example, the following code loads the OpenGL library, causing it to be associated with the current class loader, and finds the address of its <code>glGetString</code> function:</p>
<pre><code>System.loadLibrary(&#34;GL&#34;);
SymbolLookup loaderLookup  = SymbolLookup.loaderLookup();
NativeSymbol clangVersion = loaderLookup.lookup(&#34;glGetString&#34;).get();</code></pre>
<h3 id="Linking-Java-code-to-foreign-functions">Linking Java code to foreign functions</h3>
<p>The <code>CLinker</code> interface is the core of how Java code interoperates with native code. While the <code>CLinker</code> focuses on providing interoperation between Java and C libraries, the concepts in the interface are general enough to support other non-Java languages in future. The interface enables both <em>downcalls</em> (calls from Java code to native code) and <em>upcalls</em> (calls from native code back to Java code).</p>
<pre><code>interface CLinker {
    MethodHandle downcallHandle(NativeSymbol func,
                                FunctionDescriptor function);
    NativeSymbol upcallStub(MethodHandle target,
                          FunctionDescriptor function,
                          ResourceScope scope);
}</code></pre>
<p>For downcalls, the <code>downcallHandle</code> method takes the address of a foreign function — typically, a <code>NativeSymbol</code> obtained from a library lookup — and exposes the foreign function as a <em>downcall method handle</em>. Later, Java code invokes the downcall method handle by calling its <code>invoke</code> (or <code>invokeExact</code>) method, and the foreign function runs. Any arguments passed to the method handle&#39;s <code>invoke</code> method are passed on to the foreign function.</p>
<p>For upcalls, the <code>upcallStub</code> method takes a method handle — typically, one which refers to a Java method, rather than a downcall method handle — and converts it to a <code>NativeSymbol</code> instance. Later, the native symbol is passed as an argument when Java code invokes a downcall method handle. In effect, the native symbol serves as a function pointer. (For more information on upcalls, see <a href="#Upcalls">below</a>.)</p>
<p>Suppose we wish to downcall from Java to the <code>strlen</code> function defined in the standard C library:</p>
<pre><code>size_t strlen(const char *s);</code></pre>
<p>A downcall method handle that exposes <code>strlen</code> can be obtained as follows (the details of <code>FunctionDescriptor</code> will be described shortly):</p>
<pre><code>CLinker linker = CLinker.systemCLinker();
MethodHandle strlen = linker.downcallHandle(
    linker.lookup(&#34;strlen&#34;).get(),
    FunctionDescriptor.of(JAVA_LONG, ADDRESS)
);</code></pre>
<p>Invoking the downcall method handle will run <code>strlen</code> and make its result available in Java. For the argument to <code>strlen</code>, we use a helper method to convert a Java string into an off-heap memory segment (using the implicit allocator) which is then passed by-reference:</p>
<pre><code>MemorySegment str = implicitAllocator().allocateUtf8String(&#34;Hello&#34;);
long len          = strlen.invoke(cString);  // 5</code></pre>
<p>Method handles work well for exposing foreign functions because the JVM already optimizes the invocation of method handles all the way down to native code. When a method handle refers to a method in a <code>class</code> file, invoking the method handle typically causes the target method to be JIT-compiled; subsequently, the JVM interprets the Java bytecode that calls <code>MethodHandle::invokeExact</code> by transferring control to the assembly code generated for the target method. Thus, a traditional method handle in Java targets non-Java code behind the scenes; a downcall method handle is a natural extension that lets developers target non-Java code explicitly. Method handles also enjoy a property called <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/invoke/MethodHandle.html#sigpoly"><em>signature polymorphism</em></a> which allows box-free invocation with primitive arguments. In sum, method handles let the <code>CLinker</code> expose foreign functions in a natural, efficient, and extensible manner.</p>
<h3 id="Describing-C-types-in-Java">Describing C types in Java</h3>
<p>To create a downcall method handle, the FFM API requires the client to provide a <code>FunctionDescriptor</code> that describes the C parameter types and C return type of the target C function. C types are described in the FFM API by <code>MemoryLayout</code> objects such as <code>ValueLayout</code> for scalar C types and <code>GroupLayout</code> for C struct types. Clients usually have <code>MemoryLayout</code> objects on hand to dereference data in foreign memory, and can reuse them to obtain a <code>FunctionDescriptor</code>.</p>
<p>The FFM API also uses the <code>FunctionDescriptor</code> to derive the type of the downcall method handle. Every method handle is strongly typed, which means it is stringent about the number and types of the arguments that can be passed to its <code>invokeExact</code> method at run time. For example, a method handle created to take one <code>MemoryAddress</code> argument cannot be invoked via <code>invokeExact(&lt;MemoryAddress&gt;, &lt;MemoryAddress&gt;)</code>, even though <code>invokeExact</code> is a varargs method. The type of the downcall method handle describes the Java signature which clients must use when invoking the downcall method handle. It is, effectively, the Java view of the C function.</p>
<p>As an example, suppose a downcall method handle should expose a C function that takes a C <code>int</code> and returns a C <code>long</code>. On Linux/x64 and macOS/x64, the C types <code>long</code> and <code>int</code> are associated with the predefined layouts <code>JAVA_LONG</code> and <code>JAVA_INT</code> respectively, so the required <code>FunctionDescriptor</code> can be obtained with <code>FunctionDescriptor.of(JAVA_LONG, JAVA_INT)</code>. The <code>CLinker</code> will then arrange for the type of the downcall method handle to be the Java signature <code>int</code> to <code>long</code>.</p>
<p>Clients must be aware of the current platform if they target C functions which use scalar types such as <code>long</code>, <code>int</code>, and <code>size_t</code>. This is because the association of scalar C types with layout constants varies by platform. On Windows/x64, a C long is associated with the <code>JAVA_INT</code> layout, so the required <code>FunctionDescriptor</code> would be <code>FunctionDescriptor.of(JAVA_INT, JAVA_INT)</code> and the type of the downcall method handle would be the Java signature <code>int</code> to <code>int</code>.</p>
<p>As another example, suppose a downcall method handle should expose a void C function that takes a pointer. On all platforms, a C pointer type is associated with the predefined layout <code>ADDRESS</code>, so the required <code>FunctionDescriptor</code> can be obtained with <code>FunctionDescriptor.ofVoid(ADDRESS)</code>. The <code>CLinker</code> will then arrange for the type of the downcall method handle to be the Java signature <code>Addressable</code> to <code>void</code>. <code>Addressable</code> is a common supertype of entities in the FFM API that can be passed by reference, such as <code>MemorySegment</code>, <code>MemoryAddress</code>, and <code>NativeSymbol</code>.</p>
<p>Clients can use C pointers without being aware of the current platform. Clients do not need to know the size of pointers on the current platform, since the size of the <code>ADDRESS</code> layout is inferred from the current platform, nor do clients need to distinguish between C pointer types such as <code>int*</code> and <code>char**</code>.</p>
<p>Finally, unlike JNI, the <code>CLinker</code> supports passing structured data to foreign functions. Suppose a downcall method handle should expose a <code>void</code> C function that takes a struct, described by the following layout:</p>
<pre><code>MemoryLayout SYSTEMTIME  = MemoryLayout.ofStruct(
  JAVA_SHORT.withName(&#34;wYear&#34;),      JAVA_SHORT.withName(&#34;wMonth&#34;),
  JAVA_SHORT.withName(&#34;wDayOfWeek&#34;), JAVA_SHORT.withName(&#34;wDay&#34;),
  JAVA_SHORT.withName(&#34;wHour&#34;),      JAVA_SHORT.withName(&#34;wMinute&#34;),
  JAVA_SHORT.withName(&#34;wSecond&#34;),    JAVA_SHORT.withName(&#34;wMilliseconds&#34;)
);</code></pre>
<p>The required <code>FunctionDescriptor</code> can be obtained with <code>FunctionDescriptor.ofVoid(SYSTEMTIME)</code>. The <code>CLinker</code> will arrange for the type of the downcall method handle to be the Java signature <code>MemorySegment</code> to <code>void</code>.</p>
<p>The memory layout associated with a C struct type must be a composite layout which defines the sub-layouts for all the fields in the C struct, including any platform-dependent padding a native compiler might insert.</p>
<p>If a C function returns a by-value struct (not shown here) then a fresh memory segment must be allocated off-heap and returned to the Java client. To achieve this, the method handle returned by <code>downcallHandle</code> requires an additional <code>SegmentAllocator</code> argument which the FFM API uses to allocate a memory segment to hold the struct returned by the C function.</p>
<p>As mentioned earlier, the <code>CLinker</code> is focused on providing interoperation between Java and C libraries, but it is language-neutral: It has no specific knowledge of how C types are defined, so clients are responsible for obtaining suitable layout definitions for C types. This choice is deliberate, since layout definitions for C types — whether simple scalars or complex structs — are ultimately platform-dependent, and can therefore be mechanically generated by a tool that has an intimate understanding of the given target platform.</p>
<h3 id="Packaging-Java-arguments-for-C-functions">Packaging Java arguments for C functions</h3>
<p>A <em>calling convention</em> enables interoperation between different languages by specifying how code in one language invokes a function in another language, passes arguments, and receives results. The <code>CLinker</code> API is neutral with respect to calling conventions, but the <code>CLinker</code> implementation implements several calling conventions out-of-the-box: Linux/x64, Linux/AArch64, macOS/x64, and Windows/x64. Being written in Java, it is far easier to maintain and extend than JNI, whose calling conventions are hardwired into HotSpot&#39;s C++ code.</p>
<p>Consider the <code>FunctionDescriptor</code> obtained above for the <code>SYSTEMTIME</code> struct/layout. Given the calling convention of the OS and CPU where the JVM is running, the <code>CLinker</code> uses the <code>FunctionDescriptor</code> to infer how the struct&#39;s fields should be passed to the C function when a downcall method handle is invoked with a <code>MemorySegment</code> argument. For one calling convention, the <code>CLinker</code> could arrange to decompose the incoming memory segment, pass the first four fields using general CPU registers, and pass the remaining fields on the C stack. For a different calling convention, the <code>CLinker</code> could arrange to pass the struct indirectly by allocating a region of memory, bulk-copying the contents of the incoming memory segment into that region, and passing a pointer to that memory region to the C function. This lowest-level packaging of arguments happens behind the scenes, without any need for supervision by client code.</p>
<h3 id="Upcalls">Upcalls</h3>
<p>Sometimes it is useful to pass Java code as a function pointer to some foreign function. We can do that by using the <code>CLinker</code> support for upcalls. In this section we build, piece by piece, a more sophisticated example which demonstrates the full power of the <code>CLinker</code>, with full bidirectional interoperation of both code and data across the Java/native boundary.</p>
<p>Consider the following function defined in the standard C library:</p>
<pre><code>void qsort(void *base, size_t nmemb, size_t size,
           int (*compar)(const void *, const void *));</code></pre>
<p>To call <code>qsort</code> from Java, we first need to create a downcall method handle:</p>
<pre><code>CLinker linker = CLinker.systemCLinker();
MethodHandle qsort = linker.downcallHandle(
    linker.lookup(&#34;qsort&#34;).get(),
    FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)
);</code></pre>
<p>As before, we use the <code>JAVA_LONG</code> layout to map the C <code>size_t</code> type, and we use the <code>ADDRESS</code> layout for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).</p>
<p><code>qsort</code> sorts the contents of an array using a custom comparator function, <code>compar</code>, passed as a function pointer. Therefore, to invoke the downcall method handle we need a function pointer to pass as the last parameter to the method handle&#39;s <code>invokeExact</code> method. <code>CLinker::upcallStub</code> helps us create function pointers by using existing method handles, as follows.</p>
<p>First, we write a <code>static</code> method in Java that compares two <code>long</code> values, represented indirectly as <code>MemoryAddress</code> objects:</p>
<pre><code>class Qsort {
    static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {
        return addr1.get(JAVA_INT, 0) - addr2.get(JAVA_INT, 0);
    }
}</code></pre>
<p>Second, we create a method handle pointing to the Java comparator method:</p>
<pre><code>MethodHandle comparHandle
    = MethodHandles.lookup()
                   .findStatic(Qsort.class, &#34;qsortCompare&#34;,
                               MethodType.methodType(int.class,
                                                     MemoryAddress.class,
                                                     MemoryAddress.class));</code></pre>
<p>Third, now that we have a method handle for our Java comparator we can create a function pointer using <code>CLinker::upcallStub</code>. Just as for downcalls, we describe the signature of the function pointer using a <code>FunctionDescriptor</code>:</p>
<pre><code>NativeSymbol comparFunc =
  linker.upcallStub(comparHandle,
                    /* A Java description of a C function
                       implemented by a Java method! */
                    FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS),
                    newImplicitScope());
);</code></pre>
<p>We finally have a memory address, <code>comparFunc</code>, which points to a stub that can be used to invoke our Java comparator function, and so we now have all we need to invoke the <code>qsort</code> downcall handle:</p>
<pre><code>MemorySegment array = implicitAllocator().allocateArray(
                                          ValueLayout.JAVA_INT,
                                          new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 });
qsort.invoke(array, 10L, 4L, comparFunc);
int[] sorted = array.toIntArray(); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</code></pre>
<p>This code creates an off-heap array, copies the contents of a Java array into it, and then passes the array to the <code>qsort</code> handle along with the comparator function we obtained from the <code>CLinker</code>. After the invocation, the contents of the off-heap array will be sorted according to our comparator function, written in Java. We then extract a new Java array from the segment, which contains the sorted elements.</p>
<h3 id="Safety">Safety</h3>
<p>Fundamentally, any interaction between Java code and native code can compromise the integrity of the Java Platform. Linking to a C function in a precompiled library is inherently unreliable because the Java runtime cannot guarantee that the function&#39;s signature matches the expectations of the Java code, or even that a symbol in a C library is really a function. Moreover, even if a suitable function is linked, actually calling the function can lead to low-level failures, such as segmentation faults, that end up crashing the VM. Such failures cannot be prevented by the Java runtime or caught by Java code.</p>
<p>Native code that uses JNI functions is especially dangerous. Such code can access JDK internals without command-line flags (e.g., <code>--add-opens</code>), by using functions such as <a href="https://docs.oracle.com/en/java/javase/16/docs/specs/jni/functions.html#accessing-fields-of-objects"><code>getStaticField</code></a> and <a href="https://docs.oracle.com/en/java/javase/16/docs/specs/jni/functions.html#calling-instance-methods"><code>callVirtualMethod</code></a>. It can also change the values of <code>final</code> fields long after they are initialized. Allowing native code to bypass the checks applied to Java code undermines every boundary and assumption in the JDK. In other words, JNI is inherently unsafe.</p>
<p>JNI cannot be disabled, so there is no way to ensure that Java code will not call native code which uses dangerous JNI functions. This is a risk to platform integrity that is almost invisible to application developers and end users because 99% of the use of these functions is typically from third, fourth, and fifth-party libraries sandwiched between the application and the JDK.</p>
<p>Most of the FFM API is safe by design. Many scenarios that required the use of JNI and native code in the past can be accomplished by calling methods in the FFM API, which cannot compromise the Java Platform. For example, a primary use case for JNI, flexible memory allocation, is supported with a simple method, <code>MemorySegment::allocateNative</code>, that involves no native code and always returns memory managed by the Java runtime. Generally speaking, Java code that uses the FFM API cannot crash the JVM.</p>
<p>Part of the FFM API, however, is inherently unsafe. When interacting with the <code>CLinker</code>, Java code can request a downcall method handle by specifying parameter types that are incompatible with those of the underlying C function. Invoking the downcall method handle in Java will result in the same kind of outcome — a VM crash, or undefined behavior — that can occur when invoking a <code>native</code> method in JNI. The FFM API can also produce unsafe segments, that is, memory segments whose spatial and temporal bounds are user-provided and cannot be verified by the Java runtime (see <code>MemorySegment::ofAddressNative</code>).</p>
<p>The unsafe methods in the FFM API do not pose the same risks as JNI functions; they cannot, e.g., change the values of <code>final</code> fields in Java objects. On the other hand, the unsafe methods in the FFM API are easy to call from Java code. For this reason, the use of unsafe methods in the FFM API is <em>restricted:</em> Access to unsafe methods is disabled by default, so that invoking such methods throws an <code>IllegalAccessException</code>. To enable access to unsafe methods for code in some module M, specify <code>java --enable-native-access=M</code> on the command line. (Specify multiple modules in a comma-separated list; specify <code>ALL-UNNAMED</code> to enable access for all code on the class path.) Most methods of the FFM API are safe, and Java code can use those methods regardless of whether <code>--enable-native-access</code> is given.</p>
<p>We do not propose here to restrict any aspect of JNI. It will still be possible to call <code>native</code> methods in Java, and for native code to call unsafe JNI functions. However, it is likely that we will restrict JNI in some way in a future release. For example, unsafe JNI functions such as <a href="https://docs.oracle.com/en/java/javase/16/docs/specs/jni/functions.html#newdirectbytebuffer"><code>newDirectByteBuffer</code></a> may be disabled by default, just like unsafe methods in the FFM API. More broadly, the JNI mechanism is so irredeemably dangerous that we hope libraries will prefer the pure-Java FFM API for both safe and unsafe operations so that, in time, we can disable all of JNI by default. This aligns with the broader Java roadmap of making the platform safe out-of-the-box, requiring end users to opt into unsafe activities such as breaking strong encapsulation or linking to unknown code.</p>
<p>We do not propose here to change <code>sun.misc.Unsafe</code> in any way. The FFM API&#39;s support for off-heap memory is an excellent alternative to the wrappers around <code>malloc</code> and <code>free</code> in <code>sun.misc.Unsafe</code>, namely <code>allocateMemory</code>, <code>setMemory</code>, <code>copyMemory</code>, and <code>freeMemory</code>. We hope that libraries and applications that require off-heap storage adopt the FFM API so that, in time, we can deprecate and then eventually remove these <code>sun.misc.Unsafe</code> methods.</p>
<h2 id="Alternatives">Alternatives</h2>
<p>Keep using <code>java.nio.ByteBuffer</code>, <code>sun.misc.Unsafe</code>, JNI, and other third-party frameworks.</p>
<h2 id="Risks-and-Assumptions">Risks and Assumptions</h2>
<p>Creating an API to access foreign memory in a way that is both safe and efficient is a daunting task. Since the spatial and temporal checks described in the previous sections need to be performed upon every access, it is crucial that JIT compilers be able to optimize away these checks by, e.g., hoisting them outside of hot loops. The JIT implementations will likely require some work to ensure that uses of the API are as efficient and optimizable as uses of existing APIs such as <code>ByteBuffer</code> and <code>Unsafe</code>. The JIT implementations will also require work to ensure that uses of the native method handles retrieved from the API are at least as efficient and optimizable as uses of existing JNI native methods.</p>
<h2 id="Dependencies">Dependencies</h2>
<ul>
<li>
<p>The Foreign Function &amp; Memory API can be used to access non-volatile memory, already possible via <a href="https://openjdk.java.net/jeps/352">JEP 352 (Non-Volatile Mapped Byte Buffers)</a>, in a more general and efficient way.</p>
</li>
<li>
<p>The work described here will likely enable subsequent work to provide a tool, <code>jextract</code>, which, starting from the header files for a given native library, mechanically generates the native method handles required to interoperate with that library. This will further reduce the overhead of using native libraries from Java.</p>
</li>
</ul>
</div></div>
  </body>
</html>
