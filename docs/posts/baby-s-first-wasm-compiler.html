<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scattered-thoughts.net/writing/babys-first-wasm-compiler/">Original</a>
    <h1>Baby&#39;s first wasm compiler</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p><em>This is part of a series. See the list of posts <a href="https://www.wildlondon.org.uk/#mvs">here</a></em>.</p>
<p>I made a compiler from a toy language to wasm. The code quality is very much plan-to-throw-one-away. I&#39;m just trying to get a feel for the amount of effort involved in a non-optimizing compiler.</p>
<p>The toy language is mostly unsurprising. It has number, strings, maps (hashtables) and first-class functions, and is dynamically typed. The only unusual part is <a href="https://kyouko-taiga.github.io/assets/papers/jot2022-mvs.pdf">mutable value semantics</a>. </p>
<pre><code><span>// nested maps
</span><span>let mut x = [foo = [bar = 1]];
</span><span>
</span><span>// y is a copy of x
</span><span>let y = x;
</span><span>
</span><span>// z captures a copy of x
</span><span>let z = fn [] x;
</span><span>
</span><span>// mutate x
</span><span>set x.foo.bar = x.foo.bar + 1;
</span><span>assert[x == [&#39;foo&#39; = [&#39;bar&#39; = 2]]];
</span><span>
</span><span>// y and z are unchanged
</span><span>assert[y == [&#39;foo&#39; = [&#39;bar&#39; = 1]]];
</span><span>assert[z[] == [&#39;foo&#39; = [&#39;bar&#39; = 1]]];
</span><span>
</span><span>// inc-x takes a mutable reference
</span><span>let inc-x = fn [mut x] set x.foo.bar = x.foo.bar + 1;
</span><span>
</span><span>// y is changed
</span><span>inc-x[mut y];
</span><span>assert[y == [&#39;foo&#39; = [&#39;bar&#39; = 2]]];
</span></code></pre>
<p>I already have a <a href="https://github.com/jamii/jams/blob/5dc5bfeb686b09347f26ecb00d107003f57fc89d/0004-mvs-to-wasm/lib/Semantalyzer.zig#L230">tree-walking interpreter</a> lying around which mostly turns ast nodes into calls into the runtime. So plan is to do the minimum viable compiler:</p>
<ol>
<li>Compile the runtime to wasm.</li>
<li>Compile toy programs into a series of calls to the runtime.</li>
<li>Link 1 and 2.</li>
</ol>
<h2 id="runtime-wasm">runtime -&gt; wasm</h2>
<p>The runtime is written in zig, so let&#39;s figure out how to compile it to wasm.</p>
<pre><code><span>&gt; zig version
</span><span>0.11.0
</span><span>
</span><span>&gt; cat test.zig
</span><span>export fn foo(x: usize) usize {
</span><span>    return x + 1;
</span><span>}
</span><span>
</span><span>&gt; zig build-lib test.zig -target wasm32-freestanding -O ReleaseSmall
</span><span>
</span><span>&gt; ls         
</span><span>libtest.a  libtest.a.o  test.zig
</span></code></pre>
<p>That&#39;s what I&#39;d expect to get from compiling native code. Where is the wasm? </p>
<pre><code><span>&gt; file libtest.a
</span><span>libtest.a: current ar archive
</span><span>
</span><span>&gt; ar t libtest.a
</span><span>./libtest.a.o
</span><span>
</span><span>&gt; file libtest.a.o
</span><span>libtest.a.o: WebAssembly (wasm) binary module version 0x1 (MVP)
</span><span>
</span><span>&gt; wasm2wat libtest.a.o
</span><span>(module
</span><span>  (type (;0;) (func (param i32) (result i32)))
</span><span>  (import &#34;env&#34; &#34;__linear_memory&#34; (memory (;0;) 0))
</span><span>  (func $foo (type 0) (param i32) (result i32)
</span><span>    local.get 0))
</span></code></pre>
<p>So <code>libtest.a</code> is just an achive containing a copy of <code>libtest.a.o</code>, which despite the name is actually a wasm file. </p>
<p>That wasm file isn&#39;t self-contained - it expects to import memory from elsewhere rather than defining the memory itself. </p>
<p>We can get a self-contained version by, weirdly, asking for a dynamically linked library.</p>
<pre><code><span>&gt; zig build-lib test.zig -target wasm32-freestanding -O ReleaseSmall -dynamic
</span><span>
</span><span>&gt; ls
</span><span>test.wasm  test.wasm.o  test.zig
</span><span>
</span><span>&gt; wasm2wat test.wasm.o
</span><span>(module
</span><span>  (type (;0;) (func (param i32) (result i32)))
</span><span>  (import &#34;env&#34; &#34;__linear_memory&#34; (memory (;0;) 0))
</span><span>  (func $foo (type 0) (param i32) (result i32)
</span><span>    local.get 0))
</span><span>
</span><span>&gt; wasm2wat test.wasm
</span><span>(module
</span><span>  (memory (;0;) 16)
</span><span>  (global (;0;) (mut i32) (i32.const 1048576))
</span><span>  (export &#34;memory&#34; (memory 0)))
</span></code></pre>
<p><code>test.wasm.o</code> looks the same as <code>libtest.a.o</code> did before, but we now also have <code>test.wasm</code> which contains a nice standalone module that defines it&#39;s own memory and can be run in a wasm runtime without any further ado.</p>
<p>Why does asking for <code>-dynamic</code> give us this? </p>
<p>As best I can tell, it&#39;s because all of this tooling was designed for c whose notions of linking are subtly different from wasm&#39;s. Plus, when working on a larger project you might do c-style linking to compile multiple c libraries into a single wasm module, which then takes part in wasm-style linking with other wasm libraries. To make matters worse, the standards for how wasm components will be linked <a href="https://github.com/WebAssembly/component-model">isn&#39;t even finished</a>.</p>
<p>So in the meantime people are just doing their best to map existing commands to something useful.</p>
<p>Another surprising outcome is that <code>test.wasm</code> doesn&#39;t contain the function <code>foo</code>. I found <a href="https://github.com/ziglang/zig/pull/14102#issuecomment-1366839552">a comment</a> explaining that it isn&#39;t obvious how c notions of symbol visibility should correspond to what is visible during wasm linking, so the currrent solution is to to manually specify which symbols we want to make visible in the wasm module.</p>
<p>The easiest thing is to ask for &#39;everything&#39; by passing <code>-rdynamic</code>.</p>
<pre><code><span>&gt; zig build-lib test.zig -target wasm32-freestanding -O ReleaseSmall -dynamic -rdynamic
</span><span>
</span><span>&gt; wasm2wat test.wasm 
</span><span>(module
</span><span>  (type (;0;) (func (param i32) (result i32)))
</span><span>  (func (;0;) (type 0) (param i32) (result i32)
</span><span>    local.get 0)
</span><span>  (memory (;0;) 16)
</span><span>  (global (;0;) (mut i32) (i32.const 1048576))
</span><span>  (export &#34;memory&#34; (memory 0))
</span><span>  (export &#34;foo&#34; (func 0)))
</span></code></pre>
<p>Now we have &#34;foo&#34; exported from the final module.</p>
<p>Also note that <code>global</code>. We&#39;ll come back to that soon.</p>
<h2 id="c-abi">c abi</h2>
<p>So we started with <code>fn foo(x: usize) usize</code> and ended up with <code>(func (param i32) (result i32))</code>. That makes sense.</p>
<p>But wasm only has scalar types, so what happens if we pass a struct?</p>
<pre><code><span>&gt; cat test.zig
</span><span>const Bar = extern struct { x: usize, y: usize };
</span><span>
</span><span>export fn foo(bar: Bar) Bar {
</span><span>    return Bar{ .x = bar.x + 1, .y = bar.y + 2 };
</span><span>}
</span><span>
</span><span>&gt; zig build-lib test.zig -target wasm32-freestanding -O ReleaseSmall -dynamic -rdynamic &amp;&amp; wasm2wat test.wasm -f
</span><span>(module
</span><span>  (type (;0;) (func (param i32 i32)))
</span><span>  (func (;0;) (type 0) (param i32 i32)
</span><span>    (i32.store
</span><span>      (local.get 0)
</span><span>      (i32.add
</span><span>        (i32.load
</span><span>          (local.get 1))
</span><span>        (i32.const 1)))
</span><span>    (i32.store offset=4
</span><span>      (local.get 0)
</span><span>      (i32.add
</span><span>        (i32.load offset=4
</span><span>          (local.get 1))
</span><span>        (i32.const 2))))
</span><span>  (memory (;0;) 16)
</span><span>  (global (;0;) (mut i32) (i32.const 1048576))
</span><span>  (export &#34;memory&#34; (memory 0))
</span><span>  (export &#34;foo&#34; (func 0)))
</span></code></pre>
<p>Since we&#39;re passing and returning <code>Bar</code> by value we might have expected to get <code>(func (param i32 i32) (result i32 i32))</code> - a function that takes two integers (<code>x</code> and <code>y</code>) and return two integers.</p>
<p>Instead we got <code>(func (param i32 i32))</code> which means that this function takes two integers and returns nothing. Uh oh.</p>
<p>Let&#39;s look at the body to figure out what&#39;s going on. </p>
<p>The use of <code>store</code> and <code>load</code> tells us that the locals are being used as pointers rather than values. We <code>load</code> from <code>(local.get 1)</code> and <code>store</code> to <code>(local.get 0)</code>, so local 1 is a pointer to <code>bar</code> and local 0 is a pointer to the return value.</p>
<p>So the way this function is expected to be used is that the caller allocates stack space for the return value and then passes a pointer to return value and a pointer to the input value.</p>
<p>A nice way to demonstrate this is to rewrite <code>foo</code> to use that calling convention explicitly. This generates exactly the same code!</p>
<pre><code><span>&gt; cat test.zig
</span><span>const Bar = extern struct { x: usize, y: usize };
</span><span>
</span><span>export fn foo(result: *Bar, bar: *Bar) void {
</span><span>    result.* = Bar{ .x = bar.x + 1, .y = bar.y + 2 };
</span><span>}
</span><span>
</span><span>&gt; zig build-lib test.zig -target wasm32-freestanding -O ReleaseSmall -dynamic -rdynamic &amp;&amp; wasm2wat test.wasm -f
</span><span>(module
</span><span>  (type (;0;) (func (param i32 i32)))
</span><span>  (func (;0;) (type 0) (param i32 i32)
</span><span>    (i32.store
</span><span>      (local.get 0)
</span><span>      (i32.add
</span><span>        (i32.load
</span><span>          (local.get 1))
</span><span>        (i32.const 1)))
</span><span>    (i32.store offset=4
</span><span>      (local.get 0)
</span><span>      (i32.add
</span><span>        (i32.load offset=4
</span><span>          (local.get 1))
</span><span>        (i32.const 2))))
</span><span>  (memory (;0;) 16)
</span><span>  (global (;0;) (mut i32) (i32.const 1048576))
</span><span>  (export &#34;memory&#34; (memory 0))
</span><span>  (export &#34;foo&#34; (func 0)))
</span></code></pre>
<p>Usually <code>extern</code> functions in zig implement the standard c calling convention for the target platform, but there is no standard c calling convention for wasm! So zig just tries to do <a href="https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md">whatever clang does</a>.</p>
<p>Rather than trying to maintain this conversion in my head, I found that it was easier to only ever use types that map to a single wasm scalar. So <a href="https://github.com/jamii/jams/blob/5b2e6c15d2891ca0ab147c2e95bfd9d810945dcf/0004-mvs-to-wasm/lib/runtime_wasm.zig">runtime_wasm.zig</a> is full of glue code like this:</p>
<pre data-lang="zig"><code data-lang="zig"><span>export fn </span><span>equal</span><span>(</span><span>result</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>a</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>b</span><span>: </span><span>*</span><span>Value</span><span>) </span><span>void </span><span>{
</span><span>    result</span><span>.* =</span><span> Value.</span><span>fromBool</span><span>(Value.</span><span>equal</span><span>(a</span><span>.*</span><span>,</span><span> b</span><span>.*</span><span>))</span><span>;
</span><span>}
</span></code></pre>
<h2 id="mvs-abi">mvs abi</h2>
<p>So let&#39;s start thinking about how we&#39;re going to represent values. </p>
<p>We actually aren&#39;t faced with much choice. At some point we&#39;re going to call some kind of runtime function like:</p>
<pre data-lang="zig"><code data-lang="zig"><span>export fn </span><span>equal</span><span>(</span><span>result</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>a</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>b</span><span>: </span><span>*</span><span>Value</span><span>) </span><span>void </span><span>{
</span><span>    result</span><span>.* =</span><span> Value.</span><span>fromBool</span><span>(Value.</span><span>equal</span><span>(a</span><span>.*</span><span>,</span><span> b</span><span>.*</span><span>))</span><span>;
</span><span>}
</span></code></pre>
<p>This expects a pointer to a value. But in wasm there is no way to take a pointer to a variable on the stack. (This is a necessary limitation to allow sandboxes to reason about variables at compile-time).</p>
<p>How does llvm deal with this? Let&#39;s try to observe a pointer to the stack.</p>
<pre><code><span>&gt; cat test.zig
</span><span>export fn foo(x: **usize) void {
</span><span>    var y: usize = 0;
</span><span>    x.* = &amp;y;
</span><span>}
</span><span>
</span><span>&gt; zig build-lib test.zig -target wasm32-freestanding -O ReleaseSmall -dynamic -rdynamic &amp;&amp; wasm2wat test.wasm -f
</span><span>(module
</span><span>  (type (;0;) (func (param i32)))
</span><span>  (func (;0;) (type 0) (param i32)
</span><span>    (global.set 0
</span><span>      (i32.sub
</span><span>        (global.get 0)
</span><span>        (i32.const 16))))
</span><span>    (i32.store
</span><span>      (local.get 0)
</span><span>      (i32.add
</span><span>        (global.get 0)
</span><span>        (i32.const 12)))
</span><span>    (global.set 0
</span><span>      (i32.add
</span><span>        (global.get 0)
</span><span>        (i32.const 16))))
</span><span>  (memory (;0;) 16)
</span><span>  (global (;0;) (mut i32) (i32.const 1048576))
</span><span>  (export &#34;memory&#34; (memory 0))
</span><span>  (export &#34;foo&#34; (func 0)))
</span></code></pre>
<p>(If you try this for yourself you&#39;ll get something slightly more complicated - I manually undid an optimization to make the code a little clearer).</p>
<p>That <code>(global (;0;) ...)</code> is the &#39;shadow stack pointer&#39;. The shadow stack is a region of the wasm memory that llvm reserves for anything that is stack-allocated and whose pointer might escape or be observed.</p>
<p>Let&#39;s go through the body of <code>foo</code> in detail. </p>
<pre><code><span>// Global 0 is the shadow stack pointer.
</span><span>
</span><span>// Push the `foo` frame on the shadow stack.
</span><span>// ssp -= 16
</span><span>(global.set 0
</span><span>  (i32.sub
</span><span>    (global.get 0)
</span><span>    (i32.const 16))))
</span><span>
</span><span>// x.* = ssp + 12
</span><span>(i32.store
</span><span>  (local.get 0)
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 12)))
</span><span>
</span><span>// Pop the `foo` frame from the shadow stack.
</span><span>// ssp += 16
</span><span>(global.set 0
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 16))))
</span></code></pre>
<p>Not every stack-allocated value ends up on the shadow stack! Many can be optimized into scalar local variables by the <a href="https://llvm.org/docs/Passes.html#sroa-scalar-replacement-of-aggregates">SROA</a> pass. Let&#39;s try stack-allocating a struct but not observing the address.</p>
<pre><code><span>&gt; cat test.zig
</span><span>const Bar = extern struct { x: usize, y: usize };
</span><span>
</span><span>extern fn random() bool;
</span><span>
</span><span>export fn foo() usize {
</span><span>    var bar = Bar{ .x = 1, .y = 1 };
</span><span>    while (random()) {
</span><span>        bar.x += bar.y;
</span><span>        bar.y *= bar.x;
</span><span>    }
</span><span>    return bar.x + bar.y;
</span><span>}
</span><span>
</span><span>&gt; zig build-lib test.zig -target wasm32-freestanding -O ReleaseSmall -dynamic -rdynamic &amp;&amp; wasm2wat test.wasm -f
</span><span>(module
</span><span>  (type (;0;) (func (result i32)))
</span><span>  (import &#34;env&#34; &#34;random&#34; (func (;0;) (type 0)))
</span><span>  (func (;1;) (type 0) (result i32)
</span><span>    (local i32 i32)
</span><span>    (local.set 0
</span><span>      (i32.const 1))
</span><span>    (local.set 1
</span><span>      (i32.const 1))
</span><span>    (block  ;; label = @1
</span><span>      (loop  ;; label = @2
</span><span>        (local.set 1
</span><span>          (i32.add
</span><span>            (local.get 1)
</span><span>            (local.get 0)))
</span><span>        (br_if 1 (;@1;)
</span><span>          (i32.eqz
</span><span>            (i32.and
</span><span>              (call 0)
</span><span>              (i32.const 1))))
</span><span>        (local.set 0
</span><span>          (i32.mul
</span><span>            (local.get 1)
</span><span>            (local.get 0)))
</span><span>        (br 0 (;@2;))))
</span><span>    (local.get 1))
</span><span>  (memory (;0;) 16)
</span><span>  (global (;0;) (mut i32) (i32.const 1048576))
</span><span>  (export &#34;memory&#34; (memory 0))
</span><span>  (export &#34;foo&#34; (func 1)))
</span></code></pre>
<p>Since we never observed the address of <code>bar</code>, the optimizer can split it into two wasm variables <code>(local i32 i32)</code> rather than using the shadow stack.</p>
<p>(It&#39;s really hard to come up with an example that actually produces two variables instead of reusing existing variables, or constant-folding away the entire calculation).</p>
<p>Anyway, the upshot of this is that the runtime wants pointers to linear memory. Since mutable value semantics produce values with nicely stack-shaped lifetimes, the path of least resistance is to store all values on the shadow stack and pass all function parameters (including the return value) by pointer. The c abi has metastasized into our language!</p>
<h2 id="binaryen">binaryen</h2>
<p>While it&#39;s easy enough to emit wasm by hand, I wanted to try out <a href="https://github.com/WebAssembly/binaryen">binaryen</a> anyway for it&#39;s optimization passes.</p>
<p>Building it with clang and trying to link it to a zig program caused segfaults. This kinda suprised me - I know that mixing compilers is a bad idea with c++ but it&#39;s usually worked fine for me when I&#39;m only consuming a c wrapper. </p>
<p>But I found a gist showing how to tweak the build to use <code>zig cc</code> and got it to work with only <a href="https://github.com/WebAssembly/binaryen/commit/ce4846a61fa1a751a894210512fcbcd8188fd1de">minor changes</a>.</p>
<p>Here&#39;s the binaryen hello world translated directly to zig:</p>
<pre data-lang="zig"><code data-lang="zig"><span>const</span><span> c </span><span>= </span><span>@cImport</span><span>({
</span><span>    </span><span>@cInclude</span><span>(</span><span>&#34;binaryen-c.h&#34;</span><span>)</span><span>;
</span><span>})</span><span>;
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>const</span><span> module </span><span>=</span><span> c.</span><span>BinaryenModuleCreate</span><span>()</span><span>;
</span><span>
</span><span>    </span><span>// Create a function type for  i32 (i32, i32)
</span><span>    </span><span>var</span><span> ii </span><span>=</span><span> [</span><span>_</span><span>:</span><span>0</span><span>]</span><span>c.BinaryenType</span><span>{ c.</span><span>BinaryenTypeInt32</span><span>()</span><span>,</span><span> c.</span><span>BinaryenTypeInt32</span><span>() }</span><span>;
</span><span>    </span><span>const</span><span> params </span><span>=</span><span> c.</span><span>BinaryenTypeCreate</span><span>(</span><span>&amp;</span><span>ii</span><span>, </span><span>2</span><span>)</span><span>;
</span><span>    </span><span>const</span><span> results </span><span>=</span><span> c.</span><span>BinaryenTypeInt32</span><span>()</span><span>;
</span><span>
</span><span>    </span><span>// Get the 0 and 1 arguments, and add them
</span><span>    </span><span>const</span><span> x </span><span>=</span><span> c.</span><span>BinaryenLocalGet</span><span>(module</span><span>, </span><span>0</span><span>,</span><span> c.</span><span>BinaryenTypeInt32</span><span>())</span><span>;
</span><span>    </span><span>const</span><span> y </span><span>=</span><span> c.</span><span>BinaryenLocalGet</span><span>(module</span><span>, </span><span>1</span><span>,</span><span> c.</span><span>BinaryenTypeInt32</span><span>())</span><span>;
</span><span>    </span><span>const</span><span> add </span><span>=</span><span> c.</span><span>BinaryenBinary</span><span>(module</span><span>,</span><span> c.</span><span>BinaryenAddInt32</span><span>()</span><span>,</span><span> x</span><span>,</span><span> y)</span><span>;
</span><span>
</span><span>    </span><span>// Create the add function
</span><span>    </span><span>// Note: no additional local variables
</span><span>    </span><span>// Note: no basic blocks here, we are an AST. The function body is just an
</span><span>    </span><span>// expression node.
</span><span>    </span><span>const</span><span> adder </span><span>=</span><span> c.</span><span>BinaryenAddFunction</span><span>(module</span><span>, </span><span>&#34;adder&#34;</span><span>,</span><span> params</span><span>,</span><span> results</span><span>, </span><span>null</span><span>, </span><span>0</span><span>,</span><span> add)</span><span>;
</span><span>    </span><span>_ </span><span>=</span><span> adder</span><span>;
</span><span>
</span><span>    </span><span>// Print it out
</span><span>    c.</span><span>BinaryenModulePrint</span><span>(module)</span><span>;
</span><span>
</span><span>    </span><span>// Clean up the module, which owns all the objects we created above
</span><span>    c.</span><span>BinaryenModuleDispose</span><span>(module)</span><span>;
</span><span>}
</span></code></pre>
<p>And it&#39;s output:</p>
<pre><code><span>&gt; zig run ./lib/binaryen.zig -Ideps/binaryen/src/ deps/binaryen/lib/libbinaryen.a -lc++
</span><span>(module
</span><span> (type $i32_i32_=&gt;_i32 (func (param i32 i32) (result i32)))
</span><span> (func $adder (param $0 i32) (param $1 i32) (result i32)
</span><span>  (i32.add
</span><span>   (local.get $0)
</span><span>   (local.get $1)
</span><span>  )
</span><span> )
</span><span>)
</span></code></pre>
<p>I do wish the binaryen api was somewhat better documented. In particular, whether or not various pointers are allowed to be null is something I had to figure out by trial and error.</p>
<p>It&#39;s also kinda verbose - if I was going to use binaryen heavily I would want to write a zig wrapper to turn eg <code>c.BinaryenLocalGet(module, 0, c.BinaryenTypeInt32())</code> into <code>module.localGet(0, .int32)</code>, and to use slices instead of separate pointer/length pairs. </p>
<p>But the api is straightforward and the memory management is really simple. Everything belongs to <code>module</code> and is freed by <code>BinaryenModuleDispose</code>. All the other types are either simple value types or are integer handles to arena-allocated data in <code>module</code>.</p>
<h2 id="linking">linking</h2>
<p>So I have the runtime compiled to wasm and I can emit wasm from binaryen. Now I need to figure out how to get one to call the other. After some extended googling I figured I have three options:</p>
<ol>
<li>Copy <a href="https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md">clangs linking format</a>, which embeds custom sections in the wasm module to describe relocations etc.</li>
<li>Use wasm imports/exports and either link at runtime or use <a href="https://github.com/WebAssembly/binaryen#wasm-merge">wasm-merge</a>.</li>
<li>Read in <code>runtime.wasm</code> and directly modify it.</li>
</ol>
<p>1 seemed like a lot of work. Binaryen <a href="https://github.com/WebAssembly/binaryen/issues/1307">doesn&#39;t provide support</a> for emitting relocations or creating the custom sections, so I&#39;d have to encode the custom sections myself, change indices to be relocatable as a post-pass on the binaryen outut and figure out any mistakes via trial-and-error with <a href="https://lld.llvm.org/WebAssembly.html">wasm-ld</a>.</p>
<p>So I tried both 2 and 3 and ended up commiting to 2, using wasm-merge. Neither worked particularly well, but mostly because of gaps in the binaryen api (see below).</p>
<p>For approach 3 the entry point is <code>BinaryenModuleRead</code>. This converts a binary wasm module into a mutable binaryen ast. Just one problem:</p>
<pre><code><span>warning: unknown subopcode 183 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 226 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 41 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 6 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 6 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 6 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 5 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 5 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 5 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 5 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 5 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 5 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 5 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 5 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 91 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 58 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 58 (this may be an unsupported version of DWARF)
</span><span>warning: unknown subopcode 6 (this may be an unsupported version of DWARF)
</span><span>Fatal: TODO: DW_LNE_define_file
</span></code></pre>
<p>When I try to read a debug or release-safe build of runtime_wasm.zig I hit <a href="https://github.com/WebAssembly/binaryen/blob/ce4846a61fa1a751a894210512fcbcd8188fd1de//src/wasm/wasm-debug.cpp#L165">this todo</a> which results in a panic. The same happens for approach 2 in <code>wasm-merge</code>.</p>
<p>Not the end of the world. I do want to use release-safe for all the bounds checks etc (I only used release-small for the examples above to make the output fit on the page). But I can strip out the debug info.</p>
<pre><code><span>&gt; zig build-lib lib/runtime_wasm.zig -target wasm32-freestanding -dynamic -rdynamic -O ReleaseSafe -fstrip
</span></code></pre>
<p>Now binaryen can read the module and we can try actually generating some interesting code. </p>
<h2 id="shadow-stack">shadow stack</h2>
<p>First thing we need to do is access the shadow stack by reading the stack pointer address from the global variable. To emit a <code>global.get</code> in binaryen we use:</p>
<pre data-lang="c"><code data-lang="c"><span>BINARYEN_API BinaryenExpressionRef </span><span>BinaryenGlobalGet</span><span>(BinaryenModuleRef </span><span>module</span><span>,
</span><span>                                                     </span><span>const char</span><span>* </span><span>name</span><span>,
</span><span>                                                     BinaryenType </span><span>type</span><span>)</span><span>;
</span></code></pre>
<p>It takes the name of the global rather than the index - using names makes it easier to parallelize codegen and then calculate the indexes later. </p>
<p>Unfortunately, stripping the debug info also strips the name of the global. There is no way to get around this in the binaryen api! We can get a handle to the global using <code>BinaryenGetGlobalByIndex</code> but this handle can&#39;t be used to set a name or to emit code referring to that global. We can add new globals, but we can&#39;t remove the existing global first because <code>BinaryenRemoveGlobal</code> also takes a name rather than an index.</p>
<p>Using approach 2 runs into similar problems. The <code>runtime.wasm</code> module doesn&#39;t export it&#39;s stack pointer global. And there is no way to refer to it in zig code so we can&#39;t export getters/setters.</p>
<p>If we go back to <code>runtime.wasm.o</code>, the non-self-contained version, it expects to import the stack pointer rather than defining it itself. But it also imports a bunch of functions which I don&#39;t know how to provide (presumably wasm-ld provides these during linking?):</p>
<pre><code><span>  (import &#34;env&#34; &#34;memset&#34; (func (;1;) (type 5)))
</span><span>  (import &#34;env&#34; &#34;memcpy&#34; (func (;2;) (type 5)))
</span><span>  (import &#34;env&#34; &#34;__stack_pointer&#34; (global (;0;) (mut i32)))
</span><span>  (import &#34;env&#34; &#34;__multi3&#34; (func (;3;) (type 14)))
</span><span>  (import &#34;env&#34; &#34;__fixunsdfti&#34; (func (;4;) (type 2)))
</span><span>  (import &#34;env&#34; &#34;__floatuntidf&#34; (func (;5;) (type 15)))
</span><span>  (import &#34;env&#34; &#34;__ashlti3&#34; (func (;6;) (type 16)))
</span><span>  (import &#34;env&#34; &#34;__udivti3&#34; (func (;7;) (type 14)))
</span><span>  (import &#34;env&#34; &#34;__umodti3&#34; (func (;8;) (type 14)))
</span></code></pre>
<p>So, first gross hack of the project: we&#39;ll just create a second shadow stack rather than sharing the first one. We define a global stack pointer and call runtime.start to allocate space in the wasm memory:</p>
<pre data-lang="zig"><code data-lang="zig"><span>_ </span><span>=</span><span> c.</span><span>BinaryenAddGlobal</span><span>(self.module</span><span>.?</span><span>, </span><span>&#34;__yet_another_stack_pointer&#34;</span><span>,</span><span> c.</span><span>BinaryenTypeInt32</span><span>()</span><span>, </span><span>true</span><span>,</span><span> c.</span><span>BinaryenConst</span><span>(self.module</span><span>.?</span><span>,</span><span> c.</span><span>BinaryenLiteralInt32</span><span>(data_start)))</span><span>;
</span><span>
</span><span>// ...
</span><span>
</span><span>block[</span><span>0</span><span>] </span><span>=</span><span> self.</span><span>runtimeCall0</span><span>(
</span><span>    </span><span>&#34;runtime_start&#34;</span><span>,
</span><span>    &amp;.{
</span><span>        c.</span><span>BinaryenConst</span><span>(self.module</span><span>.?</span><span>,</span><span> c.</span><span>BinaryenLiteralInt32</span><span>(</span><span>@bitCast</span><span>(</span><span>@as</span><span>(u32</span><span>, </span><span>@intCast</span><span>(
</span><span>            std.math.</span><span>divCeil</span><span>(
</span><span>                usize</span><span>,
</span><span>                data_start </span><span>+</span><span> self.strings.items.len</span><span>,
</span><span>                </span><span>16 </span><span>* </span><span>1024</span><span>,
</span><span>            ) </span><span>catch unreachable</span><span>,
</span><span>        )))))</span><span>,
</span><span>    }</span><span>,
</span><span>)</span><span>;
</span><span>
</span><span>// ...
</span><span>
</span><span>c.</span><span>BinaryenSetStart</span><span>(
</span><span>    self.module</span><span>.?</span><span>,
</span><span>    c.</span><span>BinaryenAddFunction</span><span>(
</span><span>        self.module</span><span>.?</span><span>,
</span><span>        </span><span>&#34;start&#34;</span><span>,
</span><span>        c.</span><span>BinaryenTypeNone</span><span>()</span><span>,
</span><span>        c.</span><span>BinaryenTypeNone</span><span>()</span><span>,
</span><span>        </span><span>null</span><span>,
</span><span>        </span><span>0</span><span>,
</span><span>        c.</span><span>BinaryenBlock</span><span>(self.module</span><span>.?</span><span>, </span><span>null</span><span>,</span><span> block.ptr</span><span>, </span><span>@intCast</span><span>(block.len)</span><span>,</span><span> c.</span><span>BinaryenTypeNone</span><span>())</span><span>,
</span><span>    )</span><span>,
</span><span>)</span><span>;
</span></code></pre>
<pre data-lang="zig"><code data-lang="zig"><span>export fn </span><span>start</span><span>(</span><span>pages</span><span>: </span><span>usize</span><span>) </span><span>void </span><span>{
</span><span>    </span><span>assert</span><span>(</span><span>@wasmMemoryGrow</span><span>(</span><span>0</span><span>,</span><span> pages </span><span>- </span><span>@wasmMemorySize</span><span>(</span><span>0</span><span>)) </span><span>&gt;= </span><span>0</span><span>)</span><span>;
</span><span>}
</span></code></pre>
<p>The layout now looks like this:</p>
<ul>
<li>0:1048576 = runtime stack</li>
<li>1048576:? = runtime data</li>
<li>?:(2*1048576) = program stack</li>
<li>(2 * 1048576):? = program data</li>
</ul>
<p>The first shadow stack starts at 1048576 and counts down to 0, so when the stack overflows we&#39;ll get a trap.</p>
<p>The second shadow stack starts at 1048576*2 and counts down to, uh, whereever the end of the runtime data section is, at which point it will start corrupting memory. Not a great solution.</p>
<h2 id="constants">constants</h2>
<p>Emitting numbers is easy enough.</p>
<pre><code><span>// mvs
</span><span>2.5
</span><span>
</span><span>// wasm
</span><span>// call runtime.createNumber
</span><span>(call 1
</span><span>  // ssp + 0
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 0))
</span><span>  // 2.5
</span><span>  (f64.const 0x1.4p+1 (;=2.5;)))
</span></code></pre>
<pre data-lang="zig"><code data-lang="zig"><span>// runtime
</span><span>export fn </span><span>createNumber</span><span>(</span><span>ptr</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>number</span><span>: </span><span>f64</span><span>) </span><span>void </span><span>{
</span><span>    ptr</span><span>.* =</span><span> .{ .number </span><span>=</span><span> number }</span><span>;
</span><span>}
</span></code></pre>
<p>Emitting code for maps is also pretty reasonable. We first create an empty map and then set the keys one by one:</p>
<pre><code><span>// mvs
</span><span>[1 = 2, 3 = 4]
</span><span>
</span><span>// wasm
</span><span>// call runtime.createMap(ssp+0)
</span><span>(call 3
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 0)))
</span><span>// call runtime.createNumber(ssp+32, 1)
</span><span>(call 1
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 32))
</span><span>  (f64.const 0x1p+0 (;=1;)))
</span><span>// call runtime.createNumber(ssp+64, 2)
</span><span>(call 1
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 64))
</span><span>  (f64.const 0x1p+1 (;=2;)))
</span><span>// call runtime.mapSet(ssp+0, ssp+32, ssp+64)
</span><span>(call 11
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 0))
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 32))
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 64)))
</span><span>// etc...
</span></code></pre>
<pre data-lang="zig"><code data-lang="zig"><span>// runtime
</span><span>const</span><span> global_allocator </span><span>=</span><span> std.heap.wasm_allocator</span><span>;
</span><span>export fn </span><span>createMap</span><span>(</span><span>ptr</span><span>: </span><span>*</span><span>Value</span><span>) </span><span>void </span><span>{
</span><span>    ptr</span><span>.* =</span><span> .{ .map </span><span>=</span><span> Map.</span><span>init</span><span>(global_allocator) }</span><span>;
</span><span>}
</span><span>export fn </span><span>mapSet</span><span>(</span><span>map</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>key</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>value</span><span>: </span><span>*</span><span>Value</span><span>) </span><span>void </span><span>{
</span><span>    map</span><span>.*</span><span>.map.</span><span>put</span><span>(key</span><span>.*</span><span>,</span><span> value</span><span>.*</span><span>) </span><span>catch </span><span>oom</span><span>()</span><span>;
</span><span>}
</span></code></pre>
<p>Emitting code for strings is almost reasonable. We just call runtime.createString with a pointer to some constant data in memory:</p>
<pre><code><span>// mvs
</span><span>&#34;foo&#34;
</span><span>
</span><span>// wasm
</span><span>// call runtime.createString
</span><span>(call 2
</span><span>  // ssp+0
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 0))
</span><span>  // pointer to string data
</span><span>  (i32.const 2097152)
</span><span>  // string length
</span><span>  (i32.const 3))
</span></code></pre>
<pre data-lang="zig"><code data-lang="zig"><span>// runtime
</span><span>export fn </span><span>createString</span><span>(</span><span>ptr</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>string_ptr</span><span>:</span><span> [</span><span>*</span><span>]</span><span>const u8</span><span>, </span><span>string_len</span><span>: </span><span>usize</span><span>) </span><span>void </span><span>{
</span><span>    ptr</span><span>.* =</span><span> .{ .string </span><span>=</span><span> global_allocator.</span><span>dupe</span><span>(u8</span><span>,</span><span> string_ptr[0</span><span>..</span><span>string_len]) </span><span>catch </span><span>oom</span><span>() }</span><span>;
</span><span>}
</span></code></pre>
<p>But how does that string data get into memory in the first place? </p>
<p>Wasm has data sections for this. Here&#39;s one from runtime.wasm:</p>
<pre><code><span>(data $builtin.panic_messages.index_out_of_bounds__anon_1647 (i32.const 78) &#34;index out of bounds\00&#34;)
</span></code></pre>
<p>You can see it has a name, an offset (78) in memory and some bytes to copy at that offset. </p>
<p>Data sections can also be marked passsive, in which case there is no offset but we can use the <code>memory.init</code> instruction to copy the data into memory later.</p>
<p>The api in binaryen for data sections is combined with the memory api:</p>
<pre data-lang="c"><code data-lang="c"><span>// This will create a memory, overwriting any existing memory
</span><span>// Each memory has data in segments, a start offset in segmentOffsets, and a
</span><span>// size in segmentSizes. exportName can be NULL
</span><span>BINARYEN_API </span><span>void </span><span>BinaryenSetMemory</span><span>(BinaryenModuleRef </span><span>module</span><span>,
</span><span>                                    BinaryenIndex </span><span>initial</span><span>,
</span><span>                                    BinaryenIndex </span><span>maximum</span><span>,
</span><span>                                    </span><span>const char</span><span>* </span><span>exportName</span><span>,
</span><span>                                    </span><span>const char</span><span>** </span><span>segments</span><span>,
</span><span>                                    </span><span>bool</span><span>* </span><span>segmentPassive</span><span>,
</span><span>                                    BinaryenExpressionRef</span><span>* </span><span>segmentOffsets</span><span>,
</span><span>                                    BinaryenIndex</span><span>* </span><span>segmentSizes</span><span>,
</span><span>                                    BinaryenIndex </span><span>numSegments</span><span>,
</span><span>                                    </span><span>bool </span><span>shared</span><span>,
</span><span>                                    </span><span>bool </span><span>memory64</span><span>,
</span><span>                                    </span><span>const char</span><span>* </span><span>name</span><span>)</span><span>;
</span></code></pre>
<p>I really just want to add a single passive segment but, fine, this is doable.</p>
<p>With segmentPasivse set to true, passing any expression for segmentOffset produces:</p>
<pre><code><span>[wasm-validator error in module] 0x1c18308 != (nil): passive segment should not have an offset, on 
</span><span>(i32.const 0)
</span></code></pre>
<p>I eventually figured out that I&#39;m supposed pass a null pointer for the segmentOffset expression.</p>
<p>Now we have to get that data into memory using the <code>memory.init</code> instruction:</p>
<pre data-lang="c"><code data-lang="c"><span>BINARYEN_API </span><span>BinaryenExpressionRef
</span><span>BinaryenMemoryInit</span><span>(BinaryenModuleRef module</span><span>,
</span><span>                   </span><span>const char</span><span>*</span><span> segment</span><span>,
</span><span>                   BinaryenExpressionRef dest</span><span>,
</span><span>                   BinaryenExpressionRef offset</span><span>,
</span><span>                   BinaryenExpressionRef size</span><span>,
</span><span>                   </span><span>const char</span><span>*</span><span> memoryName)</span><span>;
</span></code></pre>
<p>It&#39;s not clear at first what <code>const char* segment</code> is supposed to be. It can&#39;t be the segment data because I set that in <code>BinaryenSetMemory</code>. Maybe it&#39;s the segment&#39;s name, but <code>BinaryenSetMemory</code> didn&#39;t ask me for segment names. </p>
<p>Looking at the implementation for <code>BinrayenSetMemory</code> though I can see that it sets names using <code>Name::fromInt(i)</code> so the name for my string data segment is <code>&#34;0&#34;</code> :|</p>
<p>So with all that put together I get:</p>
<pre><code><span>error: Uncaught CompileError: WebAssembly.Module(): memory count of 2 exceeds internal limit of 1 @+211
</span><span>const wasmModule = new WebAssembly.Module(wasmCode);
</span><span>                   ^
</span></code></pre>
<p>There is a memory in the runtime, and calling <code>BinaryenSetMemory</code> in the compiler creates another memory. We only want one! But there doesn&#39;t seem to be way in binaryen to either create a passive data segment without creating a memory, nor to delete a memory once it&#39;s created.</p>
<p>So, second gross hack of the project. We&#39;ll just turn all the string data into individual <code>store</code> instructions in the start function, byte by byte.</p>
<p>Here&#39;s the <code>store</code> intruction:</p>
<pre data-lang="c"><code data-lang="c"><span>// Store: align can be 0, in which case it will be the natural alignment (equal
</span><span>// to bytes)
</span><span>BINARYEN_API BinaryenExpressionRef </span><span>BinaryenStore</span><span>(BinaryenModuleRef </span><span>module</span><span>,
</span><span>                                                 </span><span>uint32_t </span><span>bytes</span><span>,
</span><span>                                                 </span><span>uint32_t </span><span>offset</span><span>,
</span><span>                                                 </span><span>uint32_t </span><span>align</span><span>,
</span><span>                                                 BinaryenExpressionRef </span><span>ptr</span><span>,
</span><span>                                                 BinaryenExpressionRef </span><span>value</span><span>,
</span><span>                                                 BinaryenType </span><span>type</span><span>,
</span><span>                                                 </span><span>const char</span><span>* </span><span>memoryName</span><span>)</span><span>;
</span></code></pre>
<p>It takes the name of the memory. Which we don&#39;t have.</p>
<p>We could import the memory from the runtime, but although wasm-merge resolves this correctly is doesn&#39;t delete the import statement, leaving us with both a defined memory and a memory import with the same name, which doesn&#39;t work.</p>
<p><code>BinaryenStore</code> doesn&#39;t allow <code>memoryName</code> to be null either - it segfaults.</p>
<p>The second gross hack is going to get grosser. We&#39;ll export a <code>setByte</code> function from the runtime and call that intead of <code>store</code>.</p>
<pre><code><span>(func (;28;) (type 5)
</span><span>  // Call runtime.start
</span><span>  (call 0
</span><span>    (i32.const 129))
</span><span>  // runtime.setByte(2097152, &#39;f&#39;)
</span><span>  (call 17
</span><span>    (i32.const 2097152)
</span><span>    (i32.const 102))
</span><span>  // runtime.setByte(2097153, &#39;o&#39;)
</span><span>  (call 17
</span><span>    (i32.const 2097153)
</span><span>    (i32.const 111))
</span><span>  // runtime.setByte(2097154, &#39;o&#39;)
</span><span>  (call 17
</span><span>    (i32.const 2097154)
</span><span>    (i32.const 111)))
</span><span>(start 28)
</span></code></pre>
<pre data-lang="zig"><code data-lang="zig"><span>export fn </span><span>set_byte</span><span>(</span><span>ptr</span><span>: </span><span>*</span><span>u8</span><span>, </span><span>byte</span><span>: </span><span>u8</span><span>) </span><span>void </span><span>{
</span><span>    ptr</span><span>.* =</span><span> byte</span><span>;
</span><span>}
</span></code></pre>
<p>This is incredibly wasteful, both in terms of code size and startup time. But it works.</p>
<h2 id="closures">closures</h2>
<p>Closures at least were easy. </p>
<p>There is no way to take a pointer to a function. Instead we can put function references into a special table and then call them via integer handles.</p>
<pre data-lang="zig"><code data-lang="zig"><span>_ </span><span>=</span><span> c.</span><span>BinaryenAddTable</span><span>(
</span><span>    self.module</span><span>.?</span><span>,
</span><span>    </span><span>&#34;fns&#34;</span><span>,
</span><span>    </span><span>@intCast</span><span>(self.fns.items.len)</span><span>,
</span><span>    </span><span>@intCast</span><span>(self.fns.items.len)</span><span>,
</span><span>    c.</span><span>BinaryenTypeFuncref</span><span>()</span><span>,
</span><span>)</span><span>;
</span><span>const</span><span> fn_names </span><span>=</span><span> self.allocator.</span><span>alloc</span><span>([</span><span>*</span><span>c]</span><span>const</span><span> u8</span><span>,</span><span> self.fns.items.len) </span><span>catch </span><span>oom</span><span>()</span><span>;
</span><span>for </span><span>(fn_names</span><span>,</span><span> self.fns.items) </span><span>|*</span><span>fn_name_c</span><span>,</span><span> fn_name</span><span>|</span><span> fn_name_c</span><span>.* =</span><span> fn_name.ptr</span><span>;
</span><span>_ </span><span>=</span><span> c.</span><span>BinaryenAddActiveElementSegment</span><span>(
</span><span>    self.module</span><span>.?</span><span>,
</span><span>    </span><span>&#34;fns&#34;</span><span>,
</span><span>    </span><span>&#34;fns_init&#34;</span><span>,
</span><span>    fn_names.ptr</span><span>,
</span><span>    </span><span>@intCast</span><span>(fn_names.len)</span><span>,
</span><span>    c.</span><span>BinaryenConst</span><span>(self.module</span><span>.?</span><span>,</span><span> c.</span><span>BinaryenLiteralInt32</span><span>(</span><span>0</span><span>))</span><span>,
</span><span>)</span><span>;
</span></code></pre>
<p>Closures are created much like maps.</p>
<pre><code><span>// mvs
</span><span>let x = 42;
</span><span>let f = fn [y] x + y;
</span><span>f[4]
</span><span>
</span><span>// wasm
</span><span>...
</span><span>// creating `f`:
</span><span>// call runtime.createFn(ssp+64, ix=0, arg_count=1, capture_count=1)
</span><span>(call 4
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 64))
</span><span>  (i32.const 0)
</span><span>  (i32.const 1)
</span><span>  (i32.const 1))
</span><span>// call runtime.copy(runtime.fnGetCapture(ssp+64, 0), ssp+32)
</span><span>(call 14
</span><span>  (call 9
</span><span>    (i32.add
</span><span>      (global.get 0)
</span><span>      (i32.const 64))
</span><span>    (i32.const 0))
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 32)))
</span><span>...
</span><span>// calling `f`:
</span><span>// call runtime.createNumber(ssp+128, 4)
</span><span>(call 1
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 128))
</span><span>  (f64.const 0x1p+2 (;=4;)))
</span><span>// call_indirect(runtime.fnGetIx(ssp+64), ssp+64, ssp+128)
</span><span>(call_indirect (type 0)
</span><span>  (call 10
</span><span>    (i32.add
</span><span>      (global.get 0)
</span><span>      (i32.const 64)))
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 96))
</span><span>  (i32.add
</span><span>    (global.get 0)
</span><span>    (i32.const 128)))
</span></code></pre>
<pre data-lang="zig"><code data-lang="zig"><span>// runtime
</span><span>export fn </span><span>createFn</span><span>(</span><span>ptr</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>fn_ix</span><span>: </span><span>u32</span><span>, </span><span>mut_count</span><span>: </span><span>u32</span><span>, </span><span>capture_count</span><span>: </span><span>u32</span><span>) </span><span>void </span><span>{
</span><span>    ptr</span><span>.* =</span><span> .{ .@</span><span>&#34;fn&#34; </span><span>=</span><span> .{
</span><span>        .ix </span><span>=</span><span> fn_ix</span><span>,
</span><span>        .muts </span><span>=</span><span> global_allocator.</span><span>alloc</span><span>(bool</span><span>,</span><span> mut_count) </span><span>catch </span><span>oom</span><span>()</span><span>,
</span><span>        .captures </span><span>=</span><span> global_allocator.</span><span>alloc</span><span>(Value</span><span>,</span><span> capture_count) </span><span>catch </span><span>oom</span><span>()</span><span>,
</span><span>    } }</span><span>;
</span><span>}
</span><span>export fn </span><span>copy</span><span>(</span><span>ptr_a</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>ptr_b</span><span>: </span><span>*</span><span>const Value</span><span>) </span><span>void </span><span>{
</span><span>    ptr_a</span><span>.* =</span><span> ptr_b.</span><span>copy</span><span>(global_allocator)</span><span>;
</span><span>}
</span><span>export fn </span><span>fnGetCapture</span><span>(</span><span>ptr</span><span>: </span><span>*</span><span>Value</span><span>, </span><span>capture_ix</span><span>: </span><span>u32</span><span>) </span><span>*</span><span>Value </span><span>{
</span><span>    </span><span>return </span><span>&amp;</span><span>ptr</span><span>.*</span><span>.@</span><span>&#34;fn&#34;</span><span>.captures[capture_ix]</span><span>;
</span><span>}
</span><span>export fn </span><span>fnGetIx</span><span>(</span><span>ptr</span><span>: </span><span>*</span><span>Value</span><span>) </span><span>u32 </span><span>{
</span><span>    </span><span>return</span><span> ptr</span><span>.*</span><span>.@</span><span>&#34;fn&#34;</span><span>.ix</span><span>;
</span><span>}
</span></code></pre>
<p>The function body itself takes a couple of extra parameters: </p>
<ul>
<li>Local 0 is a pointer to the return value.</li>
<li>Local 1 is a pointer to the fn itself, from which we can read the captures. </li>
</ul>
<pre><code><span>(func (;27;) (type 0) (param i32 i32 i32)
</span><span>  // ssp -= 64
</span><span>  (global.set 0
</span><span>    (i32.sub
</span><span>      (global.get 0)
</span><span>      (i32.const 64)))
</span><span>  // call runtime.move(ssp+0, runtime.fnGetCapture(fn, 0))
</span><span>  (call 13
</span><span>    (i32.add
</span><span>      (global.get 0)
</span><span>      (i32.const 0))
</span><span>    (call 9
</span><span>      (local.get 1)
</span><span>      (i32.const 0)))
</span><span>  // call runtime.move(ssp+32, y)
</span><span>  (call 13
</span><span>    (i32.add
</span><span>      (global.get 0)
</span><span>      (i32.const 32))
</span><span>    (local.get 2))
</span><span>  // call runtime.add(return_value, ssp+0, ssp+32)
</span><span>  (call 23
</span><span>    (local.get 0)
</span><span>    (i32.add
</span><span>      (global.get 0)
</span><span>      (i32.const 0))
</span><span>    (i32.add
</span><span>      (global.get 0)
</span><span>      (i32.const 32)))
</span><span>  // ssp += 64
</span><span>  (global.set 0
</span><span>    (i32.add
</span><span>      (global.get 0)
</span><span>      (i32.const 64))))
</span></code></pre>
<p>That&#39;s it. No gross hacks.</p>
<p>I did represent all functions as closures with indirect calls, which is pretty inefficient, but it should be pretty simple to add a constant folding pass before the compiler which turns statically-knowable call-sites into direct calls instead.</p>
<h2 id="next">next</h2>
<p>Aside from gaps in binaryen, writing the compiler in this runtime-heavy style was pretty trivial. The binaryen cpp internals seems much more capable than the c api, so I could just extend the c api. But it&#39;s not actually giving me that much anyway. The main pros of using binaryen to emit wasm are:</p>
<ul>
<li>Being able to generate chunks of ast bottom-up rather than top-down. But I generate code top-down anyway.</li>
<li>Being able to express the ast as a tree rather than as linear operations. But the calling convention I&#39;m using doesn&#39;t return values directly from functions, so I have to write in a linear style anyway.</li>
<li>Being able to refer to names of objects rather than numeric indices. But I already know the numeric indices, so my names are usually eg &#34;42&#34;.</li>
</ul>
<p>So I&#39;m managing to hit a bunch of gaps in binaryen by doing weird linking shenanigans and then missing out on all the good stuff that it provides. For the next compiler I&#39;m tempted to emit my own wasm in immediate-mode style. Something like:</p>
<pre data-lang="zig"><code data-lang="zig"><span>// binaryen style
</span><span>
</span><span>const</span><span> block </span><span>=</span><span> self.allocator.</span><span>alloc</span><span>(c.BinaryenExpressionRef</span><span>,</span><span> map.keys.len </span><span>+ </span><span>1</span><span>) </span><span>catch </span><span>oom</span><span>()</span><span>;
</span><span>block[</span><span>0</span><span>] </span><span>=</span><span> self.</span><span>runtimeCall0</span><span>(</span><span>&#34;createMap&#34;</span><span>,</span><span> &amp;.{map_location})</span><span>;
</span><span>for </span><span>(block[1</span><span>..</span><span>]</span><span>,</span><span> map.keys</span><span>,</span><span> map.values) </span><span>|*</span><span>set_expr</span><span>,</span><span> key_expr_id</span><span>,</span><span> value_expr_id</span><span>| </span><span>{
</span><span>    </span><span>const</span><span> key_offset </span><span>= </span><span>shadowPush</span><span>(scope)</span><span>;
</span><span>    </span><span>const</span><span> value_offset </span><span>= </span><span>shadowPush</span><span>(scope)</span><span>;
</span><span>    </span><span>const</span><span> key_location </span><span>=</span><span> self.</span><span>shadowPtr</span><span>(key_offset)</span><span>;
</span><span>    </span><span>const</span><span> value_location </span><span>=</span><span> self.</span><span>shadowPtr</span><span>(value_offset)</span><span>;
</span><span>    </span><span>var</span><span> set_block </span><span>=</span><span> [</span><span>_</span><span>]</span><span>c.BinaryenExpressionRef</span><span>{
</span><span>        </span><span>try</span><span> self.</span><span>compileExpr</span><span>(scope</span><span>,</span><span> key_location</span><span>,</span><span> key_expr_id)</span><span>,
</span><span>        </span><span>try</span><span> self.</span><span>compileExpr</span><span>(scope</span><span>,</span><span> value_location</span><span>,</span><span> value_expr_id)</span><span>,
</span><span>        self.</span><span>runtimeCall0</span><span>(</span><span>&#34;mapSet&#34;</span><span>,</span><span> &amp;.{map_location</span><span>,</span><span> key_location</span><span>,</span><span> value_location})</span><span>;
</span><span>        }</span><span>,
</span><span>    )</span><span>;
</span><span>    }</span><span>;
</span><span>    set_expr</span><span>.* =</span><span> c.</span><span>BinaryenBlock</span><span>(self.module</span><span>.?</span><span>, </span><span>null</span><span>, </span><span>&amp;</span><span>set_block</span><span>, </span><span>@intCast</span><span>(set_block.len)</span><span>,</span><span> c.</span><span>BinaryenTypeNone</span><span>())</span><span>;
</span><span>    </span><span>shadowPop</span><span>(scope</span><span>,</span><span> value_offset)</span><span>;
</span><span>    </span><span>shadowPop</span><span>(scope</span><span>,</span><span> key_offset)</span><span>;
</span><span>}
</span><span>return</span><span> c.</span><span>BinaryenBlock</span><span>(self.module</span><span>.?</span><span>, </span><span>null</span><span>,</span><span> block.ptr</span><span>, </span><span>@intCast</span><span>(block.len)</span><span>,</span><span> c.</span><span>BinaryenTypeNone</span><span>())</span><span>;
</span><span>
</span><span>// immediate-mode style
</span><span>
</span><span>const</span><span> map_location </span><span>=</span><span> self.</span><span>shadowPush</span><span>()</span><span>;
</span><span>
</span><span>self.</span><span>blockStart</span><span>()</span><span>;
</span><span>defer</span><span> self.</span><span>blockEnd</span><span>()</span><span>;
</span><span>
</span><span>self.</span><span>runtimeCall0</span><span>(</span><span>&#34;createMap&#34;</span><span>,</span><span> &amp;.{map_location})</span><span>;
</span><span>for </span><span>(map.keys</span><span>,</span><span> map.values) </span><span>|</span><span>key_expr_id</span><span>,</span><span> value_expr_id</span><span>| </span><span>{
</span><span>    </span><span>const</span><span> key_location </span><span>= </span><span>try</span><span> self.</span><span>compileExpr</span><span>(key_expr_id)</span><span>;
</span><span>    </span><span>defer</span><span> self.</span><span>shadowPop</span><span>(key_location)</span><span>;
</span><span>
</span><span>    </span><span>const</span><span> value_location </span><span>= </span><span>try</span><span> self.</span><span>compileExpr</span><span>(value_expr_id)</span><span>;
</span><span>    </span><span>defer</span><span> self.</span><span>shadowPop</span><span>(value_location)</span><span>;
</span><span>
</span><span>    self.</span><span>runtimeCall0</span><span>(</span><span>&#34;mapSet&#34;</span><span>,</span><span> &amp;.{map_location</span><span>,</span><span> key_location</span><span>,</span><span> value_location})</span><span>;
</span><span>}
</span><span>
</span><span>return</span><span> map_location</span><span>;
</span></code></pre>
<p>Probably still worth using binaryen for validating and optimizing the output though.</p>
<p>I&#39;ll stick with using the wasm linking model instead of the c linking model. If nothing else, I want to reserve the option to reload individual modules rather than having to recompile and reload the entire program. I <em>think</em> I can make that work with wasm linking by emitting indirect calls between modules and editing the indirect function table when the new module is loaded. I do need to measure the overhead of calling between wasm modules in various runtimes though.</p>
<p>This prototype is no good for measuring performance because I didn&#39;t do any of the copy-elision or ref-counting optimizations that make mutable value semantics practical (don&#39;t tell anyone, but I didn&#39;t even emit the code to free values when they&#39;re dropped). </p>
<p>The value representation is also terrible. If I was planning on sticking with a fully dynamic language it would make sense to do pointer tagging and NaN-boxing, but I think something closer to Julia is a better bet.</p>
<p>The output size isn&#39;t bad: around 48kb for a small program that uses all the different value types. A huge chunk of that is the constant data section from the runtime and I have no idea what&#39;s in there.</p>
<p>I&#39;ve <a href="https://github.com/ziglang/zig/issues/16639">proposed</a> a separate, more explicit wasm abi for zig that only supports wasm scalars but allows using multivalue returns. This would allow doing things like return small structs by value rather than being forced into adopting the c calling convention at the runtime boundary.</p>
<p>Probably the next step is to figure out if the performance (both compile-time and run-time) can meet my goals. Maybe measure existing languages that have non-llvm wasm backends, and also try compiling a simple static language to wasm. I&#39;ll have to look at different wasm backends too - there&#39;s a huge variety in compile-time / run-time tradeoffs.</p>

</article></div>
  </body>
</html>
