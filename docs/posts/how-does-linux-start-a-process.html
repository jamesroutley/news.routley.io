<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iq.thc.org/how-does-linux-start-a-process">Original</a>
    <h1>How does Linux start a process</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><span><span></span><img alt="How does Linux start a process" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694703736184/c0f26e9e-cfa0-4c43-a6cf-c053ea6efcf7.jpeg?w=1600&amp;h=840&amp;fit=crop&amp;crop=entropy&amp;auto=compress,format&amp;format=webp" decoding="async" data-nimg="responsive"/></span></p><p><h2>...and how to ptrace the entry point and m3ss w1th da stack.</h2></p></div></div><div><section><div><div id="post-content-parent"><div id="post-content-wrapper"><p>In this article, you will learn what happens inside the Linux Kernel when a process calls <code>execve()</code>, how the Kernel prepares the stack and how control is then passed to the userland process for execution.</p>
<p>I had to learn this for the development of <a target="_blank" href="https://github.com/hackerschoice/zapper">Zapper</a> - a Linux tool to delete all command line options from any process (without needing root).</p>
<h3 id="heading-overview">Overview</h3>
<ol>
<li><p>The Kernel receives SYS_execve() by a userland program.</p>
</li>
<li><p>The Kernel reads the executable file (specific sections) into specific memory locations.</p>
</li>
<li><p>The Kernel prepares the stack, heap, signals, ...</p>
</li>
<li><p>The Kernel passes execution to the userland program.</p>
</li>
</ol>
<h3 id="heading-examining-a-binary">Examining a binary</h3>
<p>Let us start with a simple Linux C program:</p>
<pre><code><span><span>int</span> <span>main</span><span>(<span>int</span> argc, <span>char</span> *argv[<span>0</span>])</span> </span>{
        <span>return</span> <span>0</span>;
}
</code></pre>
<p>Compile it with <code>gcc -static -o none none.c</code> and find out some details:</p>
<pre><code><span>$</span> <span>readelf</span> <span>-h</span> <span>none</span>
<span>ELF Header:</span>
  <span>Magic:</span>   <span>7f</span> <span>45</span> <span>4c</span> <span>46</span> <span>02</span> <span>01</span> <span>01</span> <span>03</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>
  <span>Class:</span>                             <span>ELF64</span>
  <span>Data:</span>                              <span>2</span><span>&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - GNU
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x4014f0
  Start of program headers:          64 (bytes into file)
  Start of section headers:          760112 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         10
  Size of section headers:           64 (bytes)
  Number of section headers:         30
  Section header string table index: 29</span>
</code></pre>
<p>The first instructions start at the &#39;Entry Point&#39; at <code>0x4014f0</code>. These instructions were created by the compiler (<code>gcc</code>, <code>go</code>, etc). They differ by compiler.</p>
<p>Let&#39;s load the binary into gdb and <code>disass 0x4014f0</code> the instructions. The instructions perform a bit of housekeeping but eventually will call <code>main()</code> (or the GoLang equivalent).</p>
<p>Let&#39;s set a break-point at the Entry Point (<code>0x4014f0</code>)and run the app with two command line options (<code>firstarg</code> and <code>secondarg</code>):</p>
<pre><code><span>gdb</span> <span>./none</span>
<span>pwndbg&gt;</span> <span>disass</span> <span>0x4014f0</span>
<span>pwndbg&gt;</span> <span>br</span> <span>*0x4014f0</span>
<span>pwndbg&gt;</span> <span>r</span> <span>firstarg</span> <span>secondarg</span>
 <span>►</span> <span>0x4014f0</span> <span>&lt;_start&gt;</span>       <span>xor</span>    <span>ebp,</span> <span>ebp</span>
   <span>0x4014f2</span> <span>&lt;_start+2&gt;</span>     <span>mov</span>    <span>r9,</span> <span>rdx</span>
   <span>0x4014f5</span> <span>&lt;_start+5&gt;</span>     <span>pop</span>    <span>rsi</span>
[<span>...</span>]
<span>──────────────────────[</span> <span>STACK</span> <span>]──────────────────────</span>
<span>00</span><span>:0000│</span> <span>rsp</span> <span>0x7ffca4229540</span> <span>◂—</span> <span>0x3</span>
<span>01</span><span>:0008│</span>     <span>0x7ffca4229548</span> <span>—▸</span> <span>0x7ffca422a4b3</span> <span>◂—</span> <span>&#39;/sec/root/none&#39;</span>
<span>02</span><span>:0010│</span>     <span>0x7ffca4229550</span> <span>—▸</span> <span>0x7ffca422a4c2</span> <span>◂—</span> <span>&#39;firstarg&#39;</span>
<span>03</span><span>:0018│</span>     <span>0x7ffca4229558</span> <span>—▸</span> <span>0x7ffca422a4cb</span> <span>◂—</span> <span>&#39;secondarg&#39;</span>
<span>04</span><span>:0020│</span>     <span>0x7ffca4229560</span> <span>◂—</span> <span>0x0</span>
<span>05</span><span>:0028│</span>     <span>0x7ffca4229568</span> <span>—▸</span> <span>0x7ffca422a4d5</span> <span>◂—</span> <span>&#39;BASH_ENV=/etc/shellrc&#39;</span>
[<span>...</span>]
</code></pre>
<p>(If you are using gdb without pwngdb then you may need to <code>x/64a $rsp</code> to list the first 64 entries from the stack.)</p>
<p>The Stack Pointer <code>rsp</code> is at <code>0x7ffd4f48bd10</code>. Let&#39;s find out the end of the stack with <code>grep -F &#39;[stack]&#39; /proc/$(pidof none)/maps</code>:</p>
<pre><code><span>7ffd4f46c000-7ffd4f48d000</span> <span>rw-p</span> <span>00000000</span> <span>00</span><span>:00</span> <span>0</span>         [<span>stack</span>]
</code></pre>
<p>The Kernel has allocated the stack memory from <code>0x7ffd4f46c000</code> to <code>0x7ffd4f48d000</code> - a total of 132 KB. It will grow dynamically up to 8MB (<code>ulimit -s</code> kilobytes). Our program (so far; see <code>rsp</code>) only uses the stack from the <code>rsp</code> address (<code>0x7ffd4f48bd10</code>) down to the same end of the stack (<code>0x7ffd4f48d000</code>) - a total of 4,848 bytes (<code>echo $((0x7ffd4f48d000 - 0x7ffd4f48bd10))</code> == 4848).</p>
<p>This is the &#39;birth&#39; of the execution: The Kernel, in all its braveness, has passed control to our program. Our program is about to execute its very first instruction - to take its very first step (so to say).</p>
<p>What is on the stack right now is all the information the program gets from the Kernel to run. It contains the argument list, the environment variables and a lot of other interesting information.</p>
<p>For <a target="_blank" href="https://github.com/hackerschoice/zapper">Zapper</a> we had to manipulate the argument list, move stack values around, adjust the pointers and then pass control back to the program - without it falling over. It was prudent to understand a bit better what the Kernel had put on the stack.</p>
<p>Let&#39;s dump the stack:</p>
<pre><code><span>pwndbg&gt;</span> <span>dump</span> <span>binary</span> <span>memory</span> <span>stack.dat</span> <span>$rsp</span> <span>0x7ffd4f48d000</span>
</code></pre>
<p>and load it into <code>hd &lt;stack.dat</code> or <code>xxd &lt;stac.dat</code> and have a little sneak preview...</p>
<pre><code> <span>03</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>  <span>b3</span> <span>a4</span> <span>22</span> <span>a4</span> <span>fc</span> <span>7f</span> <span>00</span> <span>00</span>  <span>|..........&#34;.....|</span>
 <span>c2</span> <span>a4</span> <span>22</span> <span>a4</span> <span>fc</span> <span>7f</span> <span>00</span> <span>00</span>  <span>cb</span> <span>a4</span> <span>22</span> <span>a4</span> <span>fc</span> <span>7f</span> <span>00</span> <span>00</span>  <span>|..&#34;.......&#34;.....|</span>
 <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>  <span>d5</span> <span>a4</span> <span>22</span> <span>a4</span> <span>fc</span> <span>7f</span> <span>00</span> <span>00</span>  <span>|..........&#34;.....|</span>
 <span>eb</span> <span>a4</span> <span>22</span> <span>a4</span> <span>fc</span> <span>7f</span> <span>00</span> <span>00</span>  <span>11</span> <span>a5</span> <span>22</span> <span>a4</span> <span>fc</span> <span>7f</span> <span>00</span> <span>00</span>  <span>|..&#34;.......&#34;.....|</span>
 <span>25</span> <span>a5</span> <span>22</span> <span>a4</span> <span>fc</span> <span>7f</span> <span>00</span> <span>00</span>  <span>30</span> <span>a5</span> <span>22</span> <span>a4</span> <span>fc</span> <span>7f</span> <span>00</span> <span>00</span>  <span>|%.&#34;.....0.&#34;.....|</span>
[<span>...</span>]
 <span>b4</span> <span>5c</span> <span>18</span> <span>e0</span> <span>ed</span> <span>f9</span> <span>fb</span> <span>0d</span>  <span>30</span> <span>78</span> <span>38</span> <span>36</span> <span>5f</span> <span>36</span> <span>34</span> <span>00</span>  <span>|.\......0x86_64.|</span>
 <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>  <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>  <span>|................|</span>
<span>*</span>
 <span>00</span> <span>00</span> <span>00</span> <span>2f</span> <span>73</span> <span>65</span> <span>63</span> <span>2f</span>  <span>72</span> <span>6f</span> <span>6f</span> <span>74</span> <span>2f</span> <span>6e</span> <span>6f</span> <span>6e</span>  <span>|.../sec/root/non|</span>
 <span>65</span> <span>00</span> <span>66</span> <span>69</span> <span>72</span> <span>73</span> <span>74</span> <span>61</span>  <span>72</span> <span>67</span> <span>00</span> <span>73</span> <span>65</span> <span>63</span> <span>6f</span> <span>6e</span>  <span>|e.firstarg.secon|</span>
 <span>64</span> <span>61</span> <span>72</span> <span>67</span> <span>00</span> <span>42</span> <span>41</span> <span>53</span>  <span>48</span> <span>5f</span> <span>45</span> <span>4e</span> <span>56</span> <span>3d</span> <span>2f</span> <span>65</span>  <span>|darg.BASH_ENV=/e|</span>
 <span>74</span> <span>63</span> <span>2f</span> <span>73</span> <span>68</span> <span>65</span> <span>6c</span> <span>6c</span>  <span>72</span> <span>63</span> <span>00</span> <span>43</span> <span>48</span> <span>45</span> <span>41</span> <span>54</span>  <span>|tc/shellrc.CHEAT|</span>
 <span>5f</span> <span>43</span> <span>4f</span> <span>4e</span> <span>46</span> <span>49</span> <span>47</span> <span>5f</span>  <span>50</span> <span>41</span> <span>54</span> <span>48</span> <span>3d</span> <span>2f</span> <span>65</span> <span>74</span>  <span>|_CONFIG_PATH=/et|</span>
[<span>...</span>]
 <span>55</span> <span>4d</span> <span>4e</span> <span>53</span> <span>3d</span> <span>31</span> <span>31</span> <span>38</span>  <span>00</span> <span>2f</span> <span>73</span> <span>65</span> <span>63</span> <span>2f</span> <span>72</span> <span>6f</span>  <span>|UMNS=118./sec/ro|</span>
 <span>6f</span> <span>74</span> <span>2f</span> <span>6e</span> <span>6f</span> <span>6e</span> <span>65</span> <span>00</span>  <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>  <span>|ot/none.........|</span>
</code></pre>
<p>Lots of pointers. Lots of strings. Lots of unknowns.</p>
<p>Let&#39;s follow the call from <code>execve()</code> to the new program&#39;s entry point.</p>
<p>The <code>execve()</code> calls the Kernel via a syscall which then calls <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/exec.c#L2091">do_execve</a><a target="_blank" href="https://elixir.bootlin.com/linux/v3.18/source/fs/exec.c#L1604">()</a>:</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694689587779/d00e7f77-f08b-45ae-8f5e-8c4317a08ca4.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>Eventually, this ends up in <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/exec.c#L1870"><code>do_execveat_common()</code></a>. The <code>bprm</code> structure is created and assigned all kinds of information about the program (see <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/include/linux/binfmts.h#L18">binfmts.h</a>).</p>
<p>Important to us, the program&#39;s filename, environment variables and options (<code>argv</code>) are copied from Kernel memory to the process&#39;s stack. The stack grows UP towards the lower addresses: The first item put on the stack (the <code>bprm-&gt;filename</code>) is thus at the largest address on the stack (the bottom) and above it (e.g. smaller addresses) comes the envp and then the argv.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694692329780/0d59e630-8ee6-46d7-9c4b-4b085d47ec81.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>We follow to <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/exec.c#L1803"><code>bprm_execve()</code></a> where some checks are completed before calling <code>exec_binprm()</code>. From there into <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/exec.c#L1709"><code>search_binary_handler()</code></a> where the Kernel checks if the binary is ELF, a shebang (<code>#!</code>) or any other type registered via the binfmt-misc module. The kernel then calls the appropriate function to load the binary.</p>
<p>In our case, it&#39;s an ELF binary and so <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/binfmt_elf.c#L824"><code>load_elf_binary()</code></a> is called. The kernel creates the memory and thereafter maps the sections from the binary file into memory and also calls <code>begin_new_exec()</code> to set all credentials and permissions for the new process.</p>
<p>The kernel then checks if the ELF binary should be loaded by an interpreter (<code>ld.so</code>):</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694695192603/88c3de6a-d9c7-47db-9cb9-ec9e50cbe616.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>or, in the case of a static binary like ours, loaded directly without an interpreter:</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694695234011/ebddbec8-18c2-4a50-adbf-a458fa1898aa.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>Finally, <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/binfmt_elf.c#L174"><code>create_elf_tables()</code></a> is called. This is where all the stack magic happens that we are interested in.</p>
<p>First, the function <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/binfmt_elf.c#L202">arch_align_stack()</a> adds a random amount of zeros to the stack (e.g. stack randomization) to make (some) buffer overflow exploits work (a little) less reliably. It also aligns the stack to 16 bytes.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694700797913/5634c916-d11f-4969-b3f8-e36463c2b81c.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>The kernel then puts <code>x86_64\0</code> onto the stack and next adds 16 bytes of random data on top (which libc uses as a seed for its PRNG):</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694696469130/3e834162-db00-4142-87e6-77be6bb79aeb.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>The kernel then creates the elf auxiliary table: A collection of (id, value) pairs that describe useful information about the program being run and the environment it is running in, communicated from the kernel to user space.</p>
<p>The list ends with a Zero Identifier and Zero value (e.g. 16 bytes of 0x00). There are about 20 entries (320 bytes) in the list.</p>
<p>The table starts with ARCH_DLINFO (which expands to AT_SYSINFO_EHDR + <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/auxvec.h#L37">AT_MINSIGSTKSZ</a>). The &#39;Identifiers&#39; are defined in <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/auxvec.h">auxvec.h</a>.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694698104767/d2eec03d-7591-46e3-b24d-909c23ce04e7.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>In <code>gdb</code> the elf auxiliary table looks like this:</p>
<pre><code>[<span>...</span> <span>above</span> <span>is</span> <span>argc</span> <span>...</span>]
[<span>...</span> <span>above</span> <span>is</span> <span>argvp</span> <span>...</span>]
[<span>...</span> <span>above</span> <span>here</span> <span>is</span> <span>envp</span> <span>...</span>]
<span>0x7ffca42296a8:</span> <span>0x21</span>    <span>0x7ffca4351000</span>    <span>&lt;--</span> <span>AT_SYSINFO_EDHR</span>
<span>0x7ffca42296b8:</span> <span>0x33</span>    <span>0xd30</span>             <span>&lt;--</span> <span>AT_MINSIGSTKSZ</span>
<span>0x7ffca42296c8:</span> <span>0x10</span>    <span>0x178bfbff</span>        <span>&lt;--</span> <span>AT_HWCAP</span>
<span>0x7ffca42296d8:</span> <span>0x6</span>     <span>0x1000</span>            <span>&lt;--</span> <span>AT_PAGESZ</span>
<span>0x7ffca42296e8:</span> <span>0x11</span>    <span>0x64</span>
<span>0x7ffca42296f8:</span> <span>0x3</span>     <span>0x400040</span>
<span>0x7ffca4229708:</span> <span>0x4</span>     <span>0x38</span>
<span>0x7ffca4229718:</span> <span>0x5</span>     <span>0xa</span>
<span>0x7ffca4229728:</span> <span>0x7</span>     <span>0x0</span>
<span>0x7ffca4229738:</span> <span>0x8</span>     <span>0x0</span>
<span>0x7ffca4229748:</span> <span>0x9</span>     <span>0x4014f0</span>         <span>&lt;--</span> <span>Our</span> <span>entry</span> <span>point</span>
<span>0x7ffca4229758:</span> <span>0xb</span>     <span>0x0</span>
<span>0x7ffca4229768:</span> <span>0xc</span>     <span>0x0</span>
<span>0x7ffca4229778:</span> <span>0xd</span>     <span>0x0</span>
<span>0x7ffca4229788:</span> <span>0xe</span>     <span>0x0</span>
<span>0x7ffca4229798:</span> <span>0x17</span>    <span>0x0</span>
<span>0x7ffca42297a8:</span> <span>0x19</span>    <span>0x7ffca42297f9</span>   <span>&lt;--</span> <span>Ptr</span> <span>to</span> <span>Random</span>
<span>0x7ffca42297b8:</span> <span>0x1a</span>    <span>0x2</span>
<span>0x7ffca42297c8:</span> <span>0x1f</span>    <span>0x7ffca422afe9</span>   <span>&lt;--</span> <span>Ptr</span> <span>to</span> <span>filename</span>
<span>0x7ffca42297d8:</span> <span>0xf</span>     <span>0x7ffca4229809</span>   <span>&lt;--</span> <span>Ptr</span> <span>to</span> <span>x86_64</span>
<span>0x7ffca42297e8:</span> <span>0x0</span>     <span>0x0</span>                  <span>&lt;--</span> <span>NULL</span> <span>+</span> <span>NULL</span>
[<span>...</span> <span>ELF</span> <span>table</span> <span>stops</span> <span>here</span> <span>...</span>]
<span>0x7ffca42297f8:</span> <span>0xe8e8de3a49831f00</span>      <span>0xdfbf9ede0185cb4</span> <span>&lt;--</span> <span>RND16</span>
<span>0x7ffca4229808:</span> <span>0x34365f363878af</span>        <span>0x0</span>  <span>&lt;--</span> <span>&#34;x86_64&#34;</span> <span>+</span> <span>&#39;\0&#39;</span>
[<span>...</span> <span>below</span> <span>is</span> <span>empty</span> <span>space</span> <span>from</span> <span>stack</span> <span>randomization</span> <span>...</span>]
[<span>...</span> <span>below</span> <span>are</span> <span>argv</span> <span>strings</span> <span>...</span>]
[<span>...</span> <span>below</span> <span>are</span> <span>env</span> <span>strings</span> <span>...</span>]
[<span>...</span> <span>last</span> <span>is</span> <span>the</span> <span>filename</span> <span>(/root/none)</span> <span>...</span>]
</code></pre>
<p>Thereafter the kernel allocates stack memory to store the elf-aux-table, the argv- and env-pointers and the argc value (+1) and aligns the top of the stack to 16 bytes:</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694703139943/ea499340-0f4c-43ef-865d-7b3abb117915.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>...and then puts the argc, argv-pointers and env-pointers onto the stack:</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694699550671/e81d5364-e1ca-4430-85d1-aed8ba36b5d9.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>...and then copies the elf_info (from above) on the stack (<a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/binfmt_elf.c#L300">aligned</a>; below the env pointers).</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694703262167/5b7d8832-4116-4bec-8d28-34bfefcf37fc.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p><em>(The clever reader may have noticed that &#39;RND16&#39; does not start at an aligned address - 0x7ffca42297f9: It is because RND16 was put on the stack before the</em> <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/binfmt_elf.c#L303"><em>STACK_ROUND()</em></a> <em>call to put the elf-info table and env/argv pointers).</em></p>
<p>Now back in load_elf_binary(), the kernel sets the registers, clears some stuff and finally (!) calls <a target="_blank" href="https://elixir.bootlin.com/linux/v5.19.17/source/fs/binfmt_elf.c#L1348">START_THREAD()</a> to start the program.</p>
<p><strong>Afterthought</strong>: Someone pointed out the article at <a target="_blank" href="https://lwn.net/Articles/631631/">https://lwn.net/Articles/631631/</a> with better ASCII art than mine 🫶. The layout of the stack before execution (upside down; starting at the largest address and growing downwards towards the smaller addresses):</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694724110033/82d347db-00e2-4fd9-8511-aea40f7a67fd.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<h3 id="heading-how-to-zapper">How to Zapper</h3>
<p>Wheeee. What a ride. For Zapper we ptrace() at the entry-point, increase the stack to make a copy of argv/env-strings, adjust all the pointers to point to &#39;our&#39; copy of the argv/env-strings and ZERO the original ones to 0x00. The kernel does not know about it and still references the now zero&#39;d argv/env-strings and ...wush..they are gone from the process list.</p>
<hr/>
<p>Join us on Telegram: <a target="_blank" href="https://t.me/thcorg">https://t.me/thcorg</a></p>
</div></div></div></section></div></div>
  </body>
</html>
