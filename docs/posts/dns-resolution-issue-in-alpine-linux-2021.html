<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://christoph.luppri.ch/fixing-dns-resolution-for-ruby-on-alpine-linux">Original</a>
    <h1>DNS resolution issue in Alpine Linux (2021)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>I recently ran into a weird issue after switching an application’s container base image from Debian to Alpine Linux. Things worked out fine in staging and sandbox environments, but suddenly in production (of course!) the application failed to resolve a service it needs to talk to.</p>

<p>After going through the usual checklist (is the service up, is it a temporary networking issue, is this happening all the time on all nodes, etc.) and a few hours of tearing our hair out, we identified this to be a combination of issues with the DNS implementation in Alpine Linux and the DNS service (Google DNS) we’re using.</p>

<p>The first issue is about the lack of support of musl libc, the C standard library that powers Alpine Linux, for DNS over TCP or EDNS (Extension Mechanisms for DNS).</p>

<p>The second issue might be a security measure to prevent DNS amplification attacks, but I’m not entirely sure about this.</p>

<p><strong>Disclaimer:</strong> I’m not a DNS expert at all. I only watched talks and read into mailing lists to dig into the issue we’ve been seeing and think I found a reasonable explanation.</p>

<h2 id="looking-into-dns">Looking into DNS</h2>

<p>DNS originally and still primarily talks over UDP on port 53. A DNS query is a single UDP packet, to which a DNS server sends back a DNS answer, again in a single UDP packet. However, because DNS answers are getting bigger and bigger (in our case the issues stems from running Kubernetes, with an ingress on every node of our Kubernetes cluster so a complete answer would return 30+ IP addresses), the standard was extended by two options:</p>

<ul>
  <li>Increasing the size of the UPD packet above 512 bytes via the Extension Mechanism for DNS (EDNS)</li>
  <li>Switching the protocol from UDP to TCP</li>
</ul>

<p>Alpine Linux, or rather musl libc, doesn’t support either of those options. To replicate the situation we’ve been running into, you can either start up an Alpine docker image or use <code>dig</code> with the <code>+noedns</code> and the <code>+ignore</code> flags. The first one will disable EDNS support, the second one disables retries via TCP in case the truncation flag was set in the initial DNS response via UDP.</p>

<figure><pre><code>$ dig +noedns +ignore service.com @8.8.8.8

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; +noedns +ignore service.com @8.8.8.8
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 38861
;; flags: qr tc rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;service.com. IN	A

;; Query time: 45 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Sat Jun 26 21:35:44 CEST 2021
;; MSG SIZE rcvd: 30</code></pre>
<figcaption>Simulating the behaviour of musl libc with dig on macOS</figcaption></figure>

<p>As you can see, the <code>tc</code> (which is short for <em>truncation</em>) is set, but there’s no (truncated) answer section. How come?</p>

<p>Well, took me some time to figure this out. This section made me think: <a href="https://developers.google.com/speed/public-dns/docs/security#rate_limit">https://developers.google.com/speed/public-dns/docs/security#rate_limit</a></p>

<blockquote>
  <p>If DNS queries over UDP from one source IP address exceed the average bandwidth or amplification limit consistently (the occasional large response will pass), queries may be dropped or only a small response may be sent. Small responses may be an error response or an empty response with the truncation bit set (so that most legitimate queries will be retried via TCP and succeed). Not all systems or programs will retry via TCP, and DNS over TCP may be blocked by firewalls on the client side, so some applications may not operate correctly when replies are truncated. Nonetheless, truncation allows RFC-compliant clients to work properly in most cases.</p>
</blockquote>

<p>That’s exactly what we’ve been seeing - answers have the truncation flag set, but an empty response. So Google DNS (and other DNS providers) is essentially forcing clients to upgrade from UDP to TCP in order to not be vulnerable or enable DNS amplification attacks. Pretty clever!</p>

<h2 id="how-do-i-fix-my-application">How do I fix my application?</h2>

<p>Rich Felker, the maintainer of musl libc, <a href="https://twitter.com/RichFelker/status/994667677112156161">suggests</a> using a DNS library in your language/environment of choice which supports DNS over TCP. In fact, that’s not too hard, most languages already have this as part of their standard library or a package.</p>

<p>For Ruby, this is as simple as doing a <code>require &#39;resolv-replace&#39;</code> somewhere at the very start of your application (e.g. in your <code>config/application.rb</code> file before any code is run).</p>

<p>For Erlang/Elixir, you need to <a href="https://erlang.org/doc/apps/erts/inet_cfg.html">supply an Inet configuration file</a> to tell Erlang to use its custom <a href="https://erlang.org/doc/man/inet_res.html">DNS client</a>:</p>

<figure><pre><code>%% /cfg_files/erl_inetrc
%% -- ERLANG INET CONFIGURATION FILE --
%% read the hosts file
{file, hosts, &#34;/etc/hosts&#34;}.
%% specify lookup method
{lookup, [file, dns]}.

$ export ERL_INETRC=./cfg_files/erl_inetrc</code></pre>
<figcaption>Configuring Erlang to use its custom DNS resolver</figcaption></figure>

  </div></div>
  </body>
</html>
