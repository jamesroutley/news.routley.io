<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evanjones.ca/fork-is-dangerous.html">Original</a>
    <h1>Fork() without exec() is dangerous in large programs (2016)</h1>
    
    <div id="readability-page-1" class="page"><div>

<h3>[ 2016-August-16 20:42 ]</h3>
<p>The UNIX fork() system call seems like an elegant way to process tasks in parallel. It creates a copy of the current process, allowing tasks to read the same memory, without needing fine-grained synchronization. Unfortunately, you need to use it extremely carefully in large programs because fork in a multi-threaded program can easily cause deadlocks in the child process. In the child process, only the thread that called fork continues running. Other threads no longer exist. If a thread was holding a lock, it will remain locked forever [<a href="http://www.linuxprogrammingblog.com/threads-and-fork-think-twice-before-using-them">1</a>, <a href="http://thorstenball.com/blog/2014/10/13/why-threads-cant-fork/">2</a>, <a href="https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md#death-tests-and-threads">3</a>]. The next call to a function that needs a locks, like malloc, can deadlock waiting on a thread that is not running.</p>

<p>Most large programs today use threads, either intentionally or accidentally, since many libraries use threads without making it obvious. This makes it very easy for someone to add threads to some part of the program, which can then cause rare hangs in forked child processes in some other part, far removed from where the threads were added. Chrome, which intentionally uses multiple processes and threads, has <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=35374#c51">run into this issue</a>, which I think that is good evidence that it is hard to get right, even if you are aware this is a potential problem.</p>

<p>At <a href="https://www.bluecore.com/">Bluecore</a>, we ran into this accidentally. We don&#39;t explicitly use threads or fork anywhere, but some libraries and tools that we use do. The original problem was that our test suite started hanging on Mac OS X. It turns out that <em>many</em> Mac OS X system libraries use libdispatch (a.k.a. <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/">Grand Central Dispatch</a>) for inter-process communication with system processes. In an attempt to avoid rare and hard-to-reproduce bugs, libdispatch explicitly &#34;poisons&#34; the child process when forking, causing the next use to crash. This caused our unit test suite to hang, waiting for children that were dead. In this article, I&#39;ll describe how you can safely use fork if you really must, as well as a deep dive into this specific Python crash, and why it really has no workaround.</p>


<h2>How to use fork safely</h2>

<p>I have three suggestions, in priority order:</p>

<ol>
<li><strong>Only use fork to immediately call exec (or just use posix_spawn)</strong>. This is the least error-prone. However, you really do need to immediately call exec. Most other functions, including malloc, are unsafe. If you do need to do some complex work, you must do it in the parent, before the fork (<a href="https://github.com/google/googletest/issues/33">example</a>). <a href="https://cppwisdom.quora.com/Why-threads-and-fork-dont-mix">Others support this opinion</a>. Using posix_spawn is even better, since it is <a href="https://github.com/rtomayko/posix-spawn#benchmarks">more efficient</a> and more explicit.</li>

<li><strong>Fork a worker at the beginning of your program, before there can be other threads</strong>. You then tell this worker to fork additional processes. You must ensure that nothing accidentally starts a thread before this worker is started. This is actually complicated in large C++ programs where static constructors run before the main function (e.g. <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=35374#c51">the Chrome bug I mentioned above</a>). To me, this doesn&#39;t seem to have many advantages over calling exec() on the same binary.</li>

<li><strong>Only use fork in toy programs</strong>. The challenge is that successful toy programs grow into large ones, and large programs eventually use threads. It might be best just to not bother.</li>
</ol>


<h2>Hanging Python unit tests</h2>

<p>When I ran into this problem, I was just trying to run all of <a href="https://www.bluecore.com/">Bluecore</a>&#39;s unit tests on my Mac laptop. We use <a href="http://nose.readthedocs.io/en/latest/">nose</a>&#39;s <a href="http://nose.readthedocs.io/en/latest/doc_tests/test_multiprocess/multiprocess.html">multiprocess mode</a>, which uses <a href="https://docs.python.org/2/library/multiprocessing.html">Python&#39;s multiprocessing module</a> to utilize multiple CPUs. Unfortunately, the tests hung, even though they passed on our Linux test server. I figured we had some trivial bug, so I ran subsets of our tests until I isolated the problem to a single directory. Strangely, each test worked when run by itself. It was only when I ran the whole directory with nose that it got stuck. It was the <code>--parallel=4</code> option, which uses multiple processes, that caused the hang. The parent process was waiting for a message from a child worker. Looking at the children using <code>ps</code> showed that it had already exited. After adding a ton of print messages, I found that the child process was actually crashing.</p>


<h2>Python crash</h2>

<p>It should <em>not</em> be possible to crash the Python interpreter, so now I was <em>really</em> interested. I didn&#39;t really know where to start, so I decided use &#34;brute force&#34; and simplify the crash as much as possible. I removed pieces of the test and checked if it still crashed. After a few hours, I managed to reduce it to <a href="https://github.com/evanj/fork-thread-bugs/blob/master/osx_python_crash_v1.py">a program which crashes Python 2.7 and 3.4 on Mac OS X</a>, by using sqlite3 in the parent and urllib2 in the child. For future Google searchers, the OS X crash report contains &#34;crashed on child side of fork pre-exec&#34; and it crashes in <code>_dispatch_async_f_slow</code> in <code>libdispatch.dylib</code>.</p>

<p>Searching for fork, libdispatch and the crash message eventually led to me <a href="http://ludovicrousseau.blogspot.com/2015/01/os-x-yosemite-bug-pcsc-functions-crash.html">an article about a similar bug</a>, which gave me the clue that not calling urllib2 in the parent avoided the crash. This gave me the workaround I needed to fix the unit tests, but did not really explain why it was crashing. I eventually ended up digging through the <a href="https://opensource.apple.com/source/libdispatch/">source to libdispatch</a>, which Apple doesn&#39;t make easy to find. I searched the code for &#34;fork&#34;, which led me to the following function (with minor reformatting for conciseness):</p>

<pre><code>void dispatch_atfork_child(void) {
  void *crash = (void *)0x100;

  /* ... unnecessary stuff removed ... */
  _dispatch_child_of_unsafe_fork = true;

  _dispatch_main_q.dq_items_head = crash;
  _dispatch_main_q.dq_items_tail = crash;
  /* ... more stuff set to = crash ... */
}
</code></pre>

<p>This shows that libdispatch registers a function to be called after fork, and uses it to explicitly crash if the child uses it. Presumably the authors thought it was better to reliably crash rather than run into extremely rare hangs or other unreliable behaviour.</p>

<p>So why are the Python urllib2 and sqlite3 modules using libdispatch? The stack trace from lldb shows that urllib2 reads the Mac OS X system proxy settings using <code>SCDynamicStoreCopyProxies</code>, which calls <code>_CFPrefsWithDaemonConnection</code>, which then calls a library named <code>libxpc.so</code> and finally <code>libdispatch</code>. I&#39;m guessing from the names that the preferences are loaded by communicating with another process. For SQLite, the problem only occurs when using <code>libsqlite3.dylib</code> that comes with Mac OS X. If you build your own version of SQLite, it doesn&#39;t happen. I&#39;m not exactly sure what Apple&#39;s version is doing, but poking around with lldb shows that it calls <code>dispatch_async</code> from <code>sqlite3_initialize</code>, using the libdispatch main queue. I suspect this is because Apple&#39;s Core Data API uses SQLite, so this may be something to support UI applications.</p>


<h2>Fixing the problem in Python</h2>

<p>I <a href="http://bugs.python.org/issue27126">filed a bug on the Python bug tracker</a>, in an attempt to fix this in Python itself. Unfortunately, there doesn&#39;t appear to be a good way to solve it. We could make some changes to avoid the issue specifically with urllib2 and sqlite, but searching the Internet shows there are other ways to cause this crash, such using fork in a Python program that has a GUI. Unfortunately, this means it is going to go unresolved, and anything that uses multiprocessing on Mac OS X could cause this crash. In general, it seems best to avoid fork entirely.</p>

</div></div>
  </body>
</html>
