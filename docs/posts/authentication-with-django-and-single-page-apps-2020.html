<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mikesukmanowsky.com/blog/authentication-with-django-and-spas">Original</a>
    <h1>Authentication with Django and Single Page Apps (2020)</h1>
    
    <div id="readability-page-1" class="page"><p title="2020-09-14T02:00:00.000Z">Published <!-- -->over 2 years<!-- --> ago.</p><div><p>When using Django for a single page application like a React, Vue or Angular app, a typical first initial question is: &#34;how do I handle authentication?&#34;</p><p>There are a few options out there for people:</p><ul><li>Use <a href="https://simpleisbetterthancomplex.com/tutorial/2018/12/19/how-to-use-jwt-authentication-with-django-rest-framework.html">JSON Web Tokens</a></li><li>Use REST Framework&#39;s <a href="https://www.django-rest-framework.org/api-guide/authentication/#tokenauthentication"><code>TokenAuthentication</code></a></li><li>Use <a href="http://james1345.github.io/django-rest-knox/">django-rest-knox</a> (an improvement over REST Framework&#39;s <code>TokenAuthentication</code>)</li></ul><p>It&#39;s definitely a cause for <a href="https://www.reddit.com/r/django/comments/irs2of/can_i_use_both_jwt_and_regular_tokens_in_one_drf/">confusion</a> among developers (myself included).</p><p>I&#39;d like to offer a third option: <strong>just use Django</strong>. If you&#39;re just curious about the code for how to do this, check out the <a href="https://github.com/msukmanowsky/django-spa-auth">sample Django and React app</a>.</p><p>Let&#39;s first look at the options mentioned above and explain their short comings.</p><p><a href="https://jwt.io/introduction/">JWTs</a> are a newish (<a href="https://en.wikipedia.org/wiki/JSON_Web_Token">2010</a>) standard for representing claims between two parties.</p><p>The &#34;claim&#34; can be anything but usually it&#39;s as simple as: &#34;I&#39;m user 1234, please let me access the resource at <code>/api/something</code>&#34;.</p><p>The server can quickly validate that the claim is accurate using the hashed signature contained within a JWT (for more info, read the <a href="https://jwt.io/introduction/">JWT introduction</a>).</p><p>So on every request, we send the JWT via an HTTP header:</p><p>OK cool, we may not understand everything when it comes to JWTs, but we get that a server gives us a token, we include it on every request, and we get access to our protected <code>/api/something</code> resource.</p><p>But if we need to send this on every request, we need to persist these credentials somewhere. In a native mobile environments, there are <a href="https://docs.expo.io/versions/latest/sdk/securestore/">secure options</a>, but on browsers we only have <code>localStorage</code> or <code>sessionStorage</code>, both of which are <a href="https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage">100% insecure</a>.</p><p>Both <code>localStorage</code> and <code>sessionStorage</code> are vulnerable to <a href="https://owasp.org/www-community/attacks/xss/">cross site scripting (XSS)</a> attacks.</p><p>Browsers really only have one place that&#39;s safe from these attacks: cookies (note non-HTTP cookies stored and accessible via <code>document.cookie</code> are not secure as other scripts are able to read these). We could store JWTs in cookies, but there are still more fundamental issues with JWTs.</p><p>First and most importantly, JWTs are <a href="https://owasp.org/www-chapter-vancouver/assets/presentations/2020-01_Attacking_and_Securing_JWT.pdf">vulnerable to brute force attacks</a> once intercepted. Thus, they&#39;re stongly recommended as a temporary authentication mechanism to obtain something more secure like a session ID or OAuth access token (stored via cookie).</p><p>The other issue with JWTs is that they <strong>cannot be invalidated</strong> which is an issue if you want to handle any of these cases:</p><ul><li>logout</li><li>compromised accounts</li><li>password changes</li><li>permission changes</li><li>user de-provisioning</li></ul><p>In short, if you do use JWTs, please ensure they are short lived and exchanged for something more secure.</p><p><a href="https://www.django-rest-framework.org/">Django REST Framework</a> offers a built in <a href="https://www.django-rest-framework.org/api-guide/authentication/#tokenauthentication"><code>TokenAuthentication</code></a> mechanism which creates secret tokens for every user and issues them via a built in view (<code>rest_framework.authtoken.views.obtain_auth_token</code>).</p><p>Upon successful authentication, that view returns a JSON response with token we can send via an HTTP header:</p><p>This method is fine, but again in a browser context we&#39;re stuck with the same dilemma: <strong>where do we store this token?</strong></p><p>If only Django gave us a secure token stored via cookies that we could use on every request...oh wait, it does!</p><p>Django&#39;s contains a <a href="https://docs.djangoproject.com/en/3.1/topics/auth/default/#how-to-log-a-user-in"><code>login()</code></a> method which conveniently issues a <code>sessionid</code> cookie in the HTTP response.</p><p>REST Framework provides a <a href="https://www.django-rest-framework.org/api-guide/authentication/#sessionauthentication"><code>SessionAuthentication</code></a> class which can already use this cookie to autheniticate all requests.</p><p>This sound like exactly what we need but how exactly would it work?</p><h2>How Would This Work?</h2><p>If you&#39;re impatent by now, feel free to view the full <a href="https://github.com/msukmanowsky/django-spa-auth">sample Django + React app</a>.</p><p>First, we&#39;ll want to subclass REST Framework&#39;s <code>BasicAuthentication</code> to <a href="https://stackoverflow.com/questions/9859627/how-to-prevent-browser-to-invoke-basic-auth-popup-and-handle-401-error-using-jqu?lq=1">prevent a browser from presenting a login popup if a user provides invalid credentials</a>.</p><p>Next, we&#39;ll wire up a few views that let us <code>login</code> and <code>logout</code> (I&#39;ve also included a <code>me</code> view which lets us check if a user is authenticated):</p><p>Assuming these are connected via URLs like <code>/api/auth/login</code> and <code>/api/auth/logout</code>, React can easily make use of these to <a href="https://github.com/msukmanowsky/django-spa-auth/blob/master/webapp/src/App.tsx#L17-L33">login</a> and <a href="https://github.com/msukmanowsky/django-spa-auth/blob/master/webapp/src/App.tsx#L34-L54">logout</a> users.</p><h2>The Perks of Sessions</h2><p>When it comes to security, old and boring technologies are great because it often means tons of time has passed to find and address vulnerabilities.</p><p>If we set a few more settings in Django, we&#39;ll enable additional security:</p><p>Session cookies and those settings above buy you a few things:</p><ol><li><p><strong>Secure authentication for &#34;free&#34;</strong>: when your <code>/api/auth/login</code> route responds <code>200 OK</code>, you just redirect a user and you&#39;re on your way. No auth credentials to store within <code>localStorage</code> or <code>sessionStorage</code>. Your browser takes care of sending the <code>sessionid</code> cookie on all requests to your API.</p></li><li><p><strong>No credential snooping</strong>: The <code>HTTPONLY</code> flag tells browsers to not let JavaScript code read this cookie so no concerns about third-party code sniffing session credentials. The <code>SECURE</code> flag ensures the cookie is only sent over an SSL connection (HTTPS) so no risk of man-in-the-middle attacks.</p></li><li><p><strong>Implicit Token Invalidation</strong>: By default, Django&#39;s session cookie will expire 2 weeks after inactivity but you can configure that with <code>SESSION_COOKIE_AGE</code>. So you get an automatic &#34;logout after 2 weeks of inactivity&#34;. You get this automatically without running a script to clean up expired tokens.</p></li><li><p><strong>Explicit Token Invalidation</strong>: You can logout users with the <code>/api/auth/logout</code> endpoint where Django will call <code>logout()</code> and clear the session cookie.</p></li></ol><p>Of course, if you want to check if a user is authenticated or not, you could always add something like a <code>/me</code> endpoint to your API which you&#39;d check at app startup. If that endpoint returns <code>200 OK</code>, you&#39;re all set, if it returns <code>401 Unauthorized</code>, you know you have to redirect to a login page.</p><h2>But what about Mobile Apps?</h2><p>I&#39;m not an expert here, but to the best of my knowledge, both iOS and Android support secure cookie storage and if a platform doesn&#39;t, you can always read the <code>sessionid</code> cookie and store it somewhere securely.</p><p>Like a lot of developers, I went down a rabbit hole when it came to how to handle authentication when supporting a single page app. It turns out, the tried and tested methods not only work just fine here, but they have significant security advantages over the new kids on the block.</p><p>Hope this helps and if you have questions or comments, hit me up on <a href="https://twitter.com/msukmanowsky">twitter</a>!</p></div></div>
  </body>
</html>
