<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://herecomesthemoon.net/2024/11/two-factions-of-cpp/">Original</a>
    <h1>The two factions of C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div>
   <article>
    <section id="content">
     
     <div>
      <div>
       <figure data-imgstate="dither">
        <img alt="Zero Ranger." data-dither="/2024/11/two-factions-of-cpp/images/dithers/not-bad-at-all_dithered.png" data-original="https://herecomesthemoon.net/2024/11/two-factions-of-cpp/images/not-bad-at-all_hu130da105ae916814d5129db49a9c3717_341311_800x800_fit_q90_h2_box_3.webp" loading="lazy" src="https://herecomesthemoon.net/2024/11/two-factions-of-cpp/images/dithers/not-bad-at-all_dithered.png"/>
        <div>
         <figcaption>
          <span>
           Zero Ranger.
          </span>
          <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
           <rect height="24.28" width="24.28" x="13.51" y="13.58">
           </rect>
           <rect height="24.28" width="24.28" x="37.93" y="37.86">
           </rect>
           <rect height="24.28" width="24.28" x="62.21" y="13.58">
           </rect>
           <rect height="24.28" width="24.28" x="13.51" y="62.14">
           </rect>
           <rect height="24.28" width="24.28" x="62.21" y="62.14">
           </rect>
          </svg>
          <p><span>
            Toggle original/dithered image
           </span>
          </p>
         </figcaption>
        </div>
       </figure>
      </div>
      <p>
       There seems to be a lot of fighting and arguing over the future of C++.
      </p>
      <p>
       On Reddit and a certain orange website, definitely, but also surely at the official C++ standard committee meetings. You don’t need to look very far.
      </p>
      <p>
       <strong>
        EDIT (25-11-2024):
       </strong>
       Typos and phrasing. Mentioned on
       <a href="https://news.ycombinator.com/item?id=42231489" target="_blank">
        HN
       </a>
       ,
       <a href="https://www.reddit.com/r/cpp/comments/1gyxhss/the_two_factions_of_c/" target="_blank">
        r/cpp
       </a>
       ,
       <a href="https://lobste.rs/s/owmlgx/two_factions_c" target="_blank">
        lobste.rs
       </a>
       .
      </p>
      <h2 id="the-absolute-state-of-c">
       The Absolute State (of C++)
      </h2>
      <p>
       It looks like we’re in the following situation:
      </p>
      <ul>
       <li>
        C++’s Evolution Working Group (EWG) just
        <a href="https://github.com/cplusplus/papers/issues/2121#issuecomment-2494153010" target="_blank">
         achieved consensus
        </a>
        on adopting
        <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r0.pdf" target="_blank">
         P3466 R0 - (Re)affirm design principles for future C++ evolution
        </a>
        :
        <ul>
         <li>
          This means no ABI breaks, retain link compatibility with C and previous C++.
         </li>
         <li>
          It also means no ‘viral annotations’ (no lifetime annotations, for example).
          <sup id="fnref:1">
           <a href="#fn:1" role="doc-noteref">
            1
           </a>
          </sup>
         </li>
         <li>
          It doubles down on a set of incompatible goals, ie. no ABI break and the zero-overhead-principle.
          <sup id="fnref:2">
           <a href="#fn:2" role="doc-noteref">
            2
           </a>
          </sup>
         </li>
         <li>
          Whether this is good or bad, it is a (literal) doubling down on the current trajectory of the C++ language.
         </li>
        </ul>
       </li>
      </ul>
      <p>
       In the meantime:
      </p>
      <ul>
       <li>
        The US government wants people to stop using C++:
        <ul>
         <li>
          <a href="https://www.cisa.gov/resources-tools/resources/product-security-bad-practices" target="_blank">
           The CISA
          </a>
         </li>
         <li>
          <a href="https://media.defense.gov/2022/Nov/10/2003112742/-1/-1/0/CSI_SOFTWARE_MEMORY_SAFETY.PDF" target="_blank">
           The NSA
          </a>
         </li>
         <li>
          <a href="https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf" target="_blank">
           The White House, apparently.
          </a>
         </li>
         <li>
          No, really. Various branches of the US government have released papers, reports, recommendation to warn the industry against usage of memory-unsafe languages.
         </li>
        </ul>
       </li>
       <li>
        All sorts of big tech players are adopting Rust:
        <ul>
         <li>
          Microsoft is apparently
          <a href="https://www.theregister.com/2023/04/27/microsoft_windows_rust/" target="_blank">
           rewriting core-libraries in Rust
          </a>
          .
         </li>
         <li>
          Google seems to
          <a href="https://security.googleblog.com/2021/04/rust-in-android-platform.html" target="_blank">
           be committing to Rust
          </a>
          , and in fact started working on a
          <a href="https://github.com/google/crubit" target="_blank">
           bidirectional C++/Rust interop tool
          </a>
          .
         </li>
         <li>
          AWS is
          <a href="https://aws.amazon.com/blogs/devops/why-aws-is-the-best-place-to-run-rust/" target="_blank">
           using Rust
          </a>
          .
         </li>
         <li>
          etc.
         </li>
        </ul>
       </li>
       <li>
        Speaking of big tech, did you notice that
        <a href="https://herbsutter.com/2024/11/11/a-new-chapter-and-a-pivotal-year-for-cpp/" target="_blank">
         Herb Sutter is leaving Microsoft
        </a>
        , and that it seems like
        <a href="https://www.reddit.com/r/cpp/comments/1gkdr6e/msvc_c23_support/" target="_blank">
         MSVC is slow to implement C++23 features, and asking the community for prioritization
        </a>
        .
       </li>
       <li>
        The infamous
        <a href="https://cor3ntin.github.io/posts/abi/" target="_blank">
         Prague ABI-vote
        </a>
        happened (tl;dr: “C++23 will not break ABI, it’s unclear if it ever will.”), Google supposedly significantly lowered its participation in the C++ development process, and instead started to work on
        <a href="https://www.youtube.com/watch?v=omrY53kbVoA" target="_blank">
         their own C++ successor language
        </a>
        . They even have a
        <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/difficulties_improving_cpp.md" target="_blank">
         summary
        </a>
        outlining all of the issues they had trying to improve C++.
        <sup id="fnref:3">
         <a href="#fn:3" role="doc-noteref">
          3
         </a>
        </sup>
       </li>
       <li>
        <a href="https://thephd.dev/finally-embed-in-c23" target="_blank">
         Stories
        </a>
        of people trying their best to participate in the C++-standard committee process across multiple years, only to be chewed up and spit out are widely known and shared throughout the community. (A feature landing in
        <em>
         C
        </em>
        first doesn’t help either.)
       </li>
       <li>
        Modules are still not implemented.
        <a href="https://arewemodulesyet.org/" target="_blank">
         Are we modules yet?
        </a>
        <img alt="image" src="https://sawyer.dev/2024/11/two-factions-of-cpp/images/modules.png"/>
       </li>
       <li>
        <a href="https://isocpp.org/files/papers/P3081R0.pdf" target="_blank">
         ‘Safety Profiles’
        </a>
        are still in a weird state with no existing implementation, trying to retrofit
        <em>
         some
        </em>
        amount of safety onto existing C++ code while minimizing changes to existing code. Sean Baxter himself
        <a href="https://www.circle-lang.org/draft-profiles.html" target="_blank">
         took a stance
        </a>
        against profiles, and described C++ as “underspecified”.
       </li>
      </ul>
      <p>
       I don’t know about you, but if I were to look at all of this
       <em>
        as an outsider
       </em>
       , it sure would look as if C++ is
       <em>
        basically falling apart
       </em>
       , and as if a vast amount of people lost faith in the ability of C++’s committee to
       <em>
        somehow
       </em>
       stay on top of this.
       <sup id="fnref:4">
        <a href="#fn:4" role="doc-noteref">
         4
        </a>
       </sup>
      </p>
      <h2 id="two-cultures">
       Two Cultures
      </h2>
      <p>
       People seem to be looking for other solutions.
      </p>
      <p>
       Say, Google. Google evidently lost faith in ’the process’ ever since the ABI-vote. This isn’t a loss of faith in the language itself, Google has one of the largest C++ codebases in the world, and it has served them incredibly well. It’s a loss of faith in the language’s ability to evolve as pressure mounts from different angles (potential government regulations, competing languages, a desire for better performance and safety guarantees from key players, etc.).
      </p>
      <p>
       So what’s the problem? Why doesn’t C++ just…change?
      </p>
      <p>
       Well, figuring that out is easy. Just
       <a href="https://isocpp.org/files/papers/P3081R0.pdf" target="_blank">
        look at what Herb Sutter said in his paper on profiles
       </a>
       :
      </p>
      <blockquote>
       <p>
        “
        <strong>
         We must minimize the need to change existing code.
        </strong>
        For adoption in existing code, decades of experience has consistently shown that most customers with large code bases cannot and will not change even 1% of their lines of code in order to satisfy strictness rules, not even for safety reasons unless regulatory requirements compel them to do so.” – Herb Sutter
       </p>
      </blockquote>
      <p>
       Cool. Is anyone surprised by this? I don’t think so.
      </p>
      <p>
       Now, let’s contrast this with
       <a href="https://isocpp.org/wiki/faq/wg21#chandler-carruth" target="_blank">
        Chandler Carruth’s biography on the WG21 member page
       </a>
       :
      </p>
      <blockquote>
       <p>
        I led the design of
        <strong>
         C++ tooling and automated refactoring systems built on top of Clang
        </strong>
        and now part of the Clang project. […]
        </p>
      </blockquote>
      <p>
       Oh. Do you see it? (Yes you do, I highlighted it.)
      </p>
      <p>
       It’s “automated tooling”. Except it’s not
       <em>
        just
       </em>
       that, automated migration tooling is just the peak, the single brightly glowing example.
      </p>
      <p>
       We’re basically seeing a conflict between two starkly different camps of C++-users:
      </p>
      <ul>
       <li>
        Relatively modern, capable tech corporations that understand that their code is an asset. (This isn’t strictly
        <em>
         big
        </em>
        tech. Any sane greenfield C++ startup will also fall into this category.)
       </li>
       <li>
        Everyone else. Every ancient corporation where people are still fighting over how to indent their code, and some young engineer is begging management to allow him to set up a linter.
       </li>
      </ul>
      <p>
       One of these groups will be capable of handling a migration
       <em>
        somewhat
       </em>
       gracefully, and it’s the group that is capable of
       <strong>
        building their C++ stack from versioned source
       </strong>
       , not the group that still uses ancient pre-built libraries from 1998.
      </p>
      <p>
       This ability, to build the entire entire dependency stack from versioned source (preferably with automated tests) is probably the most critical dividing line between the two camps.
      </p>
      <p>
       In practice, of course, this is a gradient. I can only imagine how much sweat, tears, bills and blood must’ve flown to turn big tech codebases from terrifying balls of mud into semi-manageable, buildable, linted, properly versioned, slightly-less-terrifying balls of mud.
      </p>
      <p>
       With the bias of hindsight, it’s easy to think of all of this as inevitable: There was a clear disconnect between the needs of corporations such as Google (who use relatively modern C++, have automated tooling and testing, and modern infrastructure), and the (very strong) desire for backwards compatibility.
      </p>
      <p>
       To go out on a limb, the notion of a single, dialect-free and unified C++ seems like it’s been
       <strong>
        dead for years
       </strong>
       .
       <sup id="fnref:5">
        <a href="#fn:5" role="doc-noteref">
         5
        </a>
       </sup>
       We have, at the very least, two major flavors of C++:
      </p>
      <ul>
       <li>
        Any
        <em>
         remotely
        </em>
        modern C++. Everything can be built from versioned source using some sort of dedicated, clean and unified build process that’s at least slightly more sophisticated than raw CMake, and sort of looks like it just works if you squint a little. Some sort of static analyzers, formatter, linter.
        <em>
         Any
        </em>
        sort of agreement that keeping a codebase clean and modern is worthwhile. Probably at least C++17, with
        <code>
         uniqe_ptr
        </code>
        ,
        <code>
         constexpr
        </code>
        , lambdas,
        <code>
         optional
        </code>
        , but
        <em>
         that’s not the point
        </em>
        . What matters is the tooling.
       </li>
       <li>
        Legacy C++. Anything that’s not that. Any C++ that’s been sitting in ancient, dusted-up servers of a medium-sized bank. Any C++ that relies on some utterly ancient chunk of compiled code, whose source has been lost, and whose original authors are unreachable. Any C++ that sits deployed on pet-type servers, to the point that spinning it up anywhere else would take an engineer a full month just to figure out all of the implicit dependencies, configs, and environment variables. Any codebase which is primarily classified as a cost-center.
        <em>
         Any code where building any used binary from source requires more than a few button presses, or is straight-up impossible.
        </em>
       </li>
      </ul>
      <p>
       You’ll notice that the main difference isn’t about C++ itself at all. The difference is
       <em>
        tooling
       </em>
       and the ability to build from versioned source in any clean, well-defined manner. Ideally, even the ability to
       <em>
        deploy
       </em>
       without needing to remember that one flag or environment variable the previous guy usually set to keep everything from imploding.
      </p>
      <p>
       How much of eg. Google’s codebase is following ‘modern’ C++ idioms is pretty much secondary to whether the tooling is good, and whether it can be built from source.
      </p>
      <p>
       A lot of people will tell you that tooling isn’t the responsibility of the C++ standard committee, and
       <em>
        they are right
       </em>
       . Tooling isn’t the responsibility of the C++ standard committee,
       <em>
        because the C++ standard committee abdicates any responsibility for it
       </em>
       (it focuses on specifications for the C++ language,
       <em>
        not
       </em>
       on concrete implementations)
       <sup id="fnref:6">
        <a href="#fn:6" role="doc-noteref">
         6
        </a>
       </sup>
       . This is by design, and it’s hard to blame them considering the legacy baggage. C++ is a standard unifying different implementations.
      </p>
      <p>
       That said, if there’s
       <em>
        one
       </em>
       thing which Go got right, it’s that tooling matters. C++, in comparison, is from a prehistoric age before linters were invented. C++ has no unified build system, it has nothing even close to a unified package management system, it is incredibly hard to parse and analyze (this is
       <em>
        terrible
       </em>
       for tooling), and is fighting a horrifying uphill battle against Hyrum’s Law for every change that needs to be made.
      </p>
      <p>
       There’s a massive, growing rift between those two factions (good tooling, can effortlessly build from source vs. poor tooling, can’t build from source), and I honestly don’t see it closing anytime soon.
      </p>
      <p>
       The C++ committee seems pretty committed (committeed, if you will) to maintaining backwards compatibility, no matter the cost.
      </p>
      <p>
       I don’t necessary disagree with this, by the way! Backwards compatibility is a
       <em>
        huge
       </em>
       deal for a lot of people, for very good reasons. Other people don’t care nearly as much. It doesn’t matter which group is “right”: It’s just that these are incompatible views.
      </p>
      <h2 id="consequences">
       Consequences
      </h2>
      <p>
       This is why profiles are the way they are: Safety Profiles are
       <em>
        not
       </em>
       intended to solve the problems of modern, tech-savvy C++ corporations. They’re intended to bring improvements
       <em>
        without
       </em>
       requiring any changes to old code.
      </p>
      <p>
       Likewise, modules. You’re intended to be able to “just” import a header file as a module, and there should not be any sort of backwards compatibility issues.
      </p>
      <p>
       Of course,
       <em>
        everyone
       </em>
       loves features which can just be dropped-in and bring improvements without requiring any changes to old code. But it’s pretty clear that these features are designed (first and foremost) with the goal of ’legacy C++’ in mind. Any feature that would require a migration from legacy C++ is a non-starter for the C++ committee since, as Herb Sutter said, you essentially cannot expect people to migrate.
      </p>
      <p>
       (Again, building features with ’legacy C++’ in mind is not bad. It’s a completely sensible decision. )
      </p>
      <p>
       This is something which I try to keep in mind when I look at C++ papers: There’s two large audiences here. One is that of modern C++, the other is that of legacy C++. These two camps disagree fiercely, and many papers are written with the needs of one specific group in mind.
      </p>
      <p>
       This, obviously, leads to a lot of people talking past each other: Despite what people think, Safety Profiles and Safe C++ are trying to solve
       <em>
        completely different problems, for different audiences
       </em>
       , not the same ones.
      </p>
      <p>
       The C++-committee is trying to keep this rift from widening. That’s, presumably, why anything in the direction of
       <a href="https://safecpp.org/draft.html" target="_blank">
        Safe C++ by Sean Baxter
       </a>
       is a non-starter for them. This is a radical, sweeping change that could create a fundamentally new way of writing C++.
      </p>
      <p>
       Of course, there’s also the question of whether specific C++ standard committee members are just being very, very stubborn, and grasping at straws to prevent an evolution which they personally aesthetically disagree with.
      </p>
      <p>
       Far be it from me to accuse anyone, but it wouldn’t be the first time I heard that the C++ committee applied double standards such as: “We expect a full, working implementation across several working compilers from you if you’d like to see this proposal approved, but we’re still happy to commit to certain vast projects (eg. modules, profiles) that have no functioning proof of concept implementation.”
      </p>
      <p>
       If
       <em>
        this
       </em>
       were the case (I genuinely cannot say) then I really wouldn’t know for how much longer C++ could continue going down that road without a much more dramatic split.
      </p>
      <p>
       And all of that that is not even getting into the massive can of worms and problems that’d be caused by breaking ABI compatibility.
      </p>
     </div>
    </section>
    <section id="reference">
     
    </section>
   </article>
  </div></div>
  </body>
</html>
