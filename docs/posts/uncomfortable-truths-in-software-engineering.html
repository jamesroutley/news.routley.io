<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/uncomfortable-truths-in-software-engineering/">Original</a>
    <h1>Uncomfortable Truths in Software Engineering</h1>
    
    <div id="readability-page-1" class="page"><div>
        
         <h3>New Post: ADTs in TLA+</h3>
<p><a href="https://www.hillelwayne.com/post/tla-adt/" target="_blank">Using Abstract Data Types in TLA+</a>. It’s an adaptation of part of my <a href="https://www.youtube.com/watch?v=91J0M9yEY04" target="_blank">TLAConf</a> talk. It’s also a lot more advanced than most of the material I put online, and I expect it to only be useful to experienced TLA+ users. But that stuff is important, too. The community has made a lot of improvements in beginner-level instruction, so now there’s more of an audience for advanced techniques. I want those people to keep learning, too. </p>
<p>I don’t really have a formalized theory of the impact of “skill ceilings”, but I want to think they’re bad. In particular I’m pretty jealous of the Haskell community, which is really good at forever raising the skill ceiling. You can argue they don’t give enough priority to beginners and intermediates, and I think that’s a fair critique, but I also believe they do a much better job of pushing the boundaries of their world than other language commuities do. And I want that in formal methods, too.</p>
<p>See also: <a href="https://www.benkuhn.net/blub/" target="_blank">Blub Studies</a>.</p>

<p>Between the <a href="https://www.hillelwayne.com/post/alloy6/" target="_blank">Alloy 6</a> drop, a workshop, and some personal stuff, I’ve been really frazzled mentally. I’m hoping to have the mental capacity to go back to full newsletters next week, but for now, I want to do something a little lighter on me.<sup id="fnref:lighter"><a href="#fn:lighter">1</a></sup> So here are some uncomfortable truths I believe about software engineering!</p>
<p>To be clear, these are uncomfortable truths <em>to me</em>. You might think they’re all great things! And I <em>believe</em> them, but I’m not committed to them. I haven’t deeply researched all of these, you might be able to convince me otherwise, things could change about the culture, etc. I didn’t bother to sort these or make sure they’re not redundant.  So here we go:</p>
<ol>
<li>Most people don’t care about the things I care about, for any possible definition of “things”, “care”, and “I”.<ul>
<li>But <em>especially</em> so with me, given I care about weird exotic technology at the boundary of programming.</li>
</ul>
</li>
<li>Sophisticated DSLs with special syntax are probably a dead-end. Ruby and Scala both leaned hard into this and neither got it to catch on.</li>
<li>Absent other factors, statically-typed languages are better for large projects than dynamically-typed languages. There’s no rigorous academic evidence for this, but a lot of companies have been backporting typescript/mypy/sorbet onto existing dynamic codebases and the case studies have been overwhelmingly positive. While dynamic languages can be the right choice for a large project, you have to make the case for <em>why</em> it’s the right choice, like a killer library, something particular to the domain, etc.</li>
<li>Empirical research on software engineering is a trainwreck and will remain a trainwreck for the forseeable future.</li>
<li>Formal methods will never be mainstream, nor will property-based testing, nor will any correctness technique that requires a large amount of training to be effective, no matter how effective it actually is.<ul>
<li>Software projects are highly vulnerable to entropy. Any technique or process that requires continuous upkeep is going to decay, unless the C-suite commits to maintaining it.</li>
</ul>
</li>
<li>We don’t have the Alan Kay / Free Software / Hypercard dream of everybody having control over their own computer because integrating with disparate APIs is really fucking hard and takes a lot of work to do. This will never get better, because API design is decentralized and everybody is going to make different decisions with their APIs.<ul>
<li>Also, “trivial knowledge” blocks most projects from happening. To work with any new API or domain, you have to learn a lot of stuff that is “trivial” to an experienced user of that API, but you have to repeat the learning process for every single thing you want to add in, which doesn’t scale.</li>
<li>Also also, making software customizable / interfaceable is really hard on the developers for little benefit, since most people won’t use it anyway, so there’s better use of their resources.</li>
<li>Also also also, most muggles don’t <em>want</em> to program their own computers, much in the same way that most muggles don’t want to do their own taxes or wire their own houses.</li>
</ul>
</li>
<li>Despite my personal reservations, pairing is probably better than two solo devs if both pairers can handle it. Mobbing is probably better than pairing.<ul>
<li>I should probably write why I think this, but that’s a whole essay in itself. Basically it comes back to “trivial knowledge” being a blocker, which is elided with mobbing.</li>
</ul>
</li>
<li>Teams predominantly care about intra-team friction in their practices. They will prefer tools and techniques that everybody already knows over things that only one person knows and everybody else has to learn. This means that new ideas have to fight much, <em>much</em> harder to be adopted by teams than by individuals.<ul>
<li>Teams will never broadly adopt Sphinx/rST or Sphinx/MyST, because everybody already knows how to use markdown.</li>
<li>Did I mention formal methods will never be mainstream?</li>
</ul>
</li>
<li>The Unix philosophy of “do one thing well” doesn’t actually work that well. <a href="https://danluu.com/cli-complexity/" target="_blank">Dan Luu</a> explains this better than I could.</li>
<li>TDD/FP/Agile zealots are probably zealots because adopting TDD/FP/Agile/Whatever made them better programmers than they were before. If the choice is between them being zealots and them not learning the new techniques, it’s probably better for their company and their development that they’re zealots.<ul>
<li>I mean it would be better if they learned TDD/FP/Agile/Whatever <em>without</em> becoming zealots, and incorporated their ideas into an overall synthesis of a nuanced programming philosophy, but I don’t think most people are interested in doing that anyway.</li>
<li>Possibly because “synthesizing a nuanced programming philosophy” only matters / is useful to a very small slice of programmers, because it’s honestly a kinda weird thing to expect <em>tens of millions of people</em> to be that weirdly obsessive about their job.</li>
</ul>
</li>
<li>Any technical interview is going to be gameable and exclusionary to <em>some</em> underrepresented group/background. It’s very possible that our current dysfunctional interviewing practices are still, somehow, close to optimal.</li>
<li>The open source maintainer problem isn’t going to get much better in the near future.<ul>
<li>People are gonna keep blaming “Capitalism” for this.</li>
<li>People are gonna keep blaming “Capitalism” for a lot of irrelevant things.</li>
<li>People are gonna argue with me about blaming “Capitalism”.</li>
<li>Goddamn I am so tired of “the problem is CAPITALISM” takes <em>and they will never stop</em></li>
</ul>
</li>
<li>We’re never going to get the broader SE culture to care about things like performance, compatibility, accessibility, security, or privacy, at least not without legal regulations that are enforced.<ul>
<li>And regulations are written in blood, so we’ll only get enforced legal regulations after a lack of accessibility <em>kills people</em>.<sup id="fnref:kill"><a href="#fn:kill">2</a></sup></li>
</ul>
</li>
</ol>
<hr/>
<p>A lot of these are really cynical, but they’re about the overall software engineering world, which consists of hundreds of thousands of companies and tens of millions of developers. We can still make things <em>locally</em> better, and that’s enough for me to keep trying.</p>
<h3>Update for the Hacker News Crowd</h3>
<p>This was sent as part of an email newsletter; you can subscribe <a href="https://buttondown.email/hillelwayne/" target="_blank">here</a>. Common topics are <a href="https://buttondown.email/hillelwayne/archive/there-was-no-formal-methods-winter/" target="_blank">software history</a>, <a href="https://buttondown.email/hillelwayne/archive/formal-specification-languages/" target="_blank">formal methods</a>, the <a href="https://buttondown.email/hillelwayne/archive/reject-simplicity-embrace-complexity/" target="_blank">theory of software engineering</a>, and <a href="https://buttondown.email/hillelwayne/archive/whats-the-most-expensive-software-per-byte/" target="_blank">silly research dives</a>. I also have a <a href="https://www.hillelwayne.com/" target="_blank">website</a> where I put my more polished and heavily-edited writing (the newsletter is more for off-the-cuff stuff). Updates are usually 1x a week.</p>

         
     </div></div>
  </body>
</html>
