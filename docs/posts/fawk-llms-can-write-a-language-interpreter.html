<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martin.janiczek.cz/2025/11/21/fawk-llms-can-write-a-language-interpreter.html">Original</a>
    <h1>FAWK: LLMs can write a language interpreter</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/BlogPosting">
  

  <div itemprop="articleBody">
    <p>After reading the book <a href="https://www.awk.dev/">The AWK Programming Language</a>
<em>(recommended!)</em>, I was planning to try <a href="https://en.wikipedia.org/wiki/AWK">AWK</a>
out on this year’s Advent of Code. Having some time off from work this week, I
tried to implement <a href="https://adventofcode.com/2016/day/22">one of the problems</a>
in it to get some practice, set up my tooling, see how hard AWK would be,
and… I found I’m FP-pilled.</p>

<p>I <em>knew</em> I’m addicted to the combination of algebraic data types (tagged unions)
and exhaustive pattern matching, but what got me this time was immutability,
lexical scope and the basic human right of being allowed to return arrays from
functions.</p>

<p>Part 1 of the Advent of Code problem was easy enough, but for part 2 (basically
a shortest path search with a twist, to not spoil too much), I found myself
unable to switch from my usual <a href="https://martin.janiczek.cz/2023/06/27/fp-pattern-list-of-todos.html">functional BFS
approach</a>
to something mutable, and ended up trying to implement my functional approach in
AWK.</p>

<p>It got hairy very fast: I needed to implement:</p>
<ul>
  <li>hashing of strings and 2D arrays (by piping to <code>md5sum</code>)</li>
  <li>a global <del>set</del> array of seen states</li>
  <li>a way to serialize and deserialize a 2D array to/from a string</li>
  <li>and a few associative arrays for retrieving this serialized array by its
hash.</li>
</ul>

<p>I was very lost by the time I had all this; I spent hours just solving what felt
like <em>accidental complexity</em>; things that I’d take for granted in more modern
languages.</p>

<p>Now, I know nobody said AWK is modern, or functional, or that it promises any
convenience for anything other than one-liners and basic scripts that fit under
a handful of lines. I don’t want to sound like I expect AWK to do any of this;
I knew I was stretching the tool when going in. But I couldn’t shake the feeling
that there’s a beautiful AWK-like language within reach, an iteration on the AWK
design (the pattern-action way of thinking is beautiful) that also gives us a
few of the things programming language designers have learnt over the 48 years
since AWK was born.</p>

<h2 id="dreaming-of-functional-awk">Dreaming of functional AWK</h2>

<p>Stopping my attempts to solve the AoC puzzle in pure AWK, I wondered: what am I
missing here?</p>

<p>What if AWK had <strong>first-class arrays?</strong></p>

<pre><code>BEGIN {
  # array literals
  normal   = [1, 2, 3]
  nested   = [[1,2], [3,4]]
  assoc    = [&#34;foo&#34; =&gt; &#34;bar&#34;, &#34;baz&#34; =&gt; &#34;quux&#34;]
  multidim = [(1,&#34;abc&#34;) =&gt; 999]

  five = range(1,5)
  analyze(five)
  print five  # --&gt; still [1, 2, 3, 4, 5]! was passed by value
}

function range(a,b) {
  r = []
  for (i = a; i &lt;= b; i++) {
    r[length(r)] = i
  }
  return r  # arrays can be returned!
}

function analyze(arr) {
  arr[0] = 100
  print arr[0]  # --&gt; 100, only within this function
}
</code></pre>

<p>What if AWK had <strong>first-class functions and lambdas?</strong></p>

<pre><code>BEGIN {
  # construct anonymous functions
  double = (x) =&gt; { x * 2 }
  add = (a, b) =&gt; { c = a + b; return c }

  # functions can be passed as values
  apply = (func, value) =&gt; { func(value) }

  print apply(double,add(1,3))  # --&gt; 8
  print apply(inc,5)  # --&gt; 6
}

function inc(a) { return a + 1 }
</code></pre>

<p>What if AWK had <strong>lexical scope</strong> instead of dynamic scope?</p>

<pre><code># No need for this hack anymore ↓     ↓
#function foo(a, b         ,local1, local2) {
function foo(a, b) {
  local1 = a + b
  local2 = a - b
  return local1 + local2
}

BEGIN {
  c = foo(1,2)
  print(local1)  # --&gt; 0, the local1 from foo() didn&#39;t leak!
}
</code></pre>

<p>What if AWK had <strong>explicit globals</strong>, and everything else was <strong>local by default?</strong></p>

<pre><code>BEGIN { global count }
END {
  foo()
  print count  # --&gt; 1
  print mylocal # --&gt; 0, didn&#39;t leak
}
function foo() { count++; mylocal++ }
</code></pre>

<p>(This one, admittedly, might make programs a bit more verbose. I’m willing to
pay that cost.)</p>

<p>What if AWK had <strong>pipelines?</strong> (OK, now I’m reaching for syntax sugar…)</p>

<pre><code>BEGIN {
  result = [1, 2, 3, 4, 5] 
      |&gt; filter((x) =&gt; { x % 2 == 0 })
      |&gt; map((x) =&gt; { x * x })
      |&gt; reduce((acc, x) =&gt; { acc + x }, 0)

  print &#34;Result:&#34;, result
}
</code></pre>

<h2 id="making-it-happen">Making it happen</h2>

<blockquote>
  <p>TL;DR: <a href="https://github.com/Janiczek/fawk"><code>Janiczek/fawk</code> on GitHub</a></p>
</blockquote>

<p>Now for the crazy, LLM-related part of the post. I didn’t want to spend days
implementing AWK from scratch or tweaking somebody else’s implementation. So I
tried to use Cursor Agent for a larger task than I usually do (I tend to ask
for very small targeted edits), and asked Sonnet 4.5 for <a href="https://github.com/Janiczek/fawk/pull/1/files">a README with code
examples</a>, and then <a href="https://github.com/Janiczek/fawk/pull/2/files">a full
implementation in Python</a>.</p>

<p>And it did it.</p>

<blockquote>
  <p>Note: I also asked for implementations in C, Haskell and Rust at the same
time, not knowing if any of the four would succeed, and they all seem to have
produced code that at least compiles/runs. I haven’t tried to test them or
even run them though. The PRs are
<a href="https://github.com/Janiczek/fawk/pulls?q=is%3Apr+is%3Aclosed">here</a>.</p>
</blockquote>

<p>I was very impressed—I still am! I expected the LLM to stumble and flail
around and ultimately get nothing done, but it did what I asked it for (gave me
an interpreter that could run <em>those specific examples</em>), and over the course
of a few chat sessions, I guided it towards implementing more and more of “the
rest of AWK”, together with an excessive amount of end-to-end tests.</p>

<p><a href="https://github.com/Janiczek/fawk/tree/main/tests">Take a look at those tests!</a></p>

<p>The only time I could see it struggle was when I asked it to implement arbitrary
precision floating point operations without using an external library like
<code>mpmath</code>. It attempted to use Taylor series, but couldn’t get it right for at
least a few minutes. I chickened out and told it to <code>uv add mpmath</code> and simplify
the interpreter code. In a moment it was done.</p>

<p>Other things that I thought it would choke on, like <code>print</code> being both a
statement (with <code>&gt;</code> and <code>&gt;&gt;</code> redirection support) and an expression, or
multi-dimensional arrays, or multi-line records, these were all implemented
correctly. Updating the test suite to also check for backwards compatibility
with <a href="https://www.gnu.org/software/gawk/">GAWK</a> - not an issue. Lexical scoping
and tricky closure environment behaviour - handled that just fine.</p>

<h2 id="what-now">What now?</h2>

<p>As the cool kids say, I have to <em>update my priors.</em> The frontier of what the
LLMs can do has moved since the last time I tried to vibe-code something. I
didn’t expect to have a working interpreter <em>the same day</em> I dreamt of a new
programming language. It now seems possible.</p>

<p>The downside of vibe coding the whole interpreter is that I have zero knowledge
of the code. I only interacted with the agent by telling it to implement a
thing and write tests for it, and I only <em>really</em> reviewed the tests. I reckon
this would be an issue in the future when I want to manually make some change
in the actual code, because I have no familiarity with it.</p>

<blockquote>
  <p>This also opened new questions for me wrt. my other projects where I’ve
previously run out of steam, eg. trying to implement a <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner type
system</a> for my
dream forever-WIP programming language <a href="https://cara-lang.com/">Cara</a>. It seems
I can now just ask the LLM to do it, and it will? But then, I don’t want to fall
into the trap where I am no longer able to work on the codebase myself. I want
to be familiar with and able to tinker on the code. I’d need to spend my time
reviewing and reading code instead of writing everything myself. Perhaps that’s
OK.</p>
</blockquote>

<p>Performance of FAWK might be an issue as well, though right now it’s a non-goal,
given my intended use case is throwaway scripts for Advent of Code, nothing
user-facing.  And who knows, based on what I’ve seen, maybe I can instruct it to
<em>rewrite it in Rust</em> and have a decent chance of success?</p>

<p>For now, I’ll go dogfood my shiny new vibe-coded black box of a programming
language on the Advent of Code problem (and as many of the 2025 puzzles as I
can), and see what rough edges I can find. I expect them to be equal parts “not
implemented yet” and “unexpected interactions of new PL features with the old
ones”.</p>

<p>If you’re willing to jump through some Python project dependency hoops, you can
try to use FAWK too at your own risk, at <a href="https://github.com/Janiczek/fawk"><code>Janiczek/fawk</code> on
GitHub</a>.</p>

    <hr/>





  </div>

  
</article></div>
  </body>
</html>
