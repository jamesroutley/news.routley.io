<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codeandbitters.com/main-as-usize/">Original</a>
    <h1>Let rand = main as usize (2022)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
                                <p>The other day I made a joke on twitter, and learned some interesting things about raw pointers in Rust.</p>
<p>The abridged joke goes something like this:</p>
<blockquote>
<p>Yosh: What do you mean Rust doesn&#39;t ship with <code>rand</code> built-in?</p>
</blockquote>
<blockquote>
<p>Me: ASLR to the rescue!</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> rand = main as </span><span>usize</span><span>;
</span><span>    dbg!(rand);
</span><span>}
</span></code></pre>
</blockquote>
<p><img src="https://codeandbitters.com/images/rust_logo_hand_drawn_1b.png" alt="Rust Logo" width="320" height="256"/></p>
<h4 id="part-1-explaining-the-joke">Part 1: Explaining the joke<a href="#part-1-explaining-the-joke"> §</a>
</h4>
<p>Explaining the joke is bad form, but there is some valuable technical detail here.</p>
<p>The most important thing is ASLR (Address Space Layout Randomization). When software has memory safety bugs like buffer overflows, it&#39;s easy for an attacker to blast hostile data into a process&#39;s stack. That hostile data could replace the address that the currently running function will return to, giving the attacker the ability to execute some arbitrary instructions.</p>
<p>This would be bad. One of the mitigations that engineers came up with is to have each program execute at a randomized virtual address, to make such attacks harder. It&#39;s debatable whether this is effective at turning away attacks, but that&#39;s the goal, and ASLR is enabled on almost every operating system in use today.</p>
<p>Let me annotate my joke program a little bit:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>// By calling this &#34;rand&#34;, I&#39;m pretending that this line of code is
</span><span>    </span><span>// a random number generator.
</span><span>    </span><span>let</span><span> rand = main as </span><span>usize</span><span>;
</span><span>    </span><span>//          ^        ^
</span><span>    </span><span>//          |        \-- that address as a pointer-sized integer
</span><span>    </span><span>//          |
</span><span>    </span><span>//          \-- the address of the main function
</span><span>
</span><span>    dbg!(rand); </span><span>// print out the result
</span><span>}
</span></code></pre>
<p>This program assumes that ASLR is used by the host operating system, which caused the program to run at a random address. Our program observes the address that <code>main</code> is located at, and uses that as our random value.</p>
<p>It&#39;s reasonable to wonder whether the address of <code>main</code> might be a static value, or that the Rust compiler might use some static address rather than recomputing at runtime due to ASLR. This isn&#39;t the case, though: experimentally we can verify that the value does change on each execution.</p>
<p>This is a dirty hack, and I don&#39;t recommend doing this in real programs. ASLR isn&#39;t a good random number generator. The address doesn&#39;t change that much, and under some conditions may not change at all. Even in the best circumstances, a program can only acquire one random value this way, so two different modules both using this trick would use the same value. Real random number generators are fast and readily available (at least, on any platform capable of using ASLR). Please use a well-regarded RNG istead of a hack like this.</p>
<h4 id="part-2-i-learn-things-about-rust-pointers">Part 2: I learn things about Rust pointers<a href="#part-2-i-learn-things-about-rust-pointers"> §</a>
</h4>
<p>The code I above isn&#39;t exactly what I posted on twitter. The original post looked like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> rand = main as </span><span>*const fn</span><span>() as </span><span>usize</span><span>;
</span><span>    dbg!(rand);
</span><span>}
</span></code></pre>
<p>This wasn&#39;t well-written code. The two-step cast is just habit, because of situations like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>print_address</span><span>(</span><span>int_ref</span><span>: &amp;</span><span>u32</span><span>) {
</span><span>    </span><span>let</span><span> px = int_ref as </span><span>*const u32 </span><span>as </span><span>usize</span><span>;
</span><span>    dbg!(px);
</span><span>}
</span></code></pre>
<p>In many cases Rust won&#39;t allow us to cast a reference address directly to an integer; we have to go by way of a raw pointer.</p>
<p>Function pointers don&#39;t work the same way, though.</p>
<p>I didn&#39;t realize that there is no such thing as a &#34;raw function pointer&#34; in Rust. <code>fn()</code> is itself a pointer type, so <code>*const fn()</code> is a raw pointer to a function pointer, which doesn&#39;t make sense in this context.</p>
<p>Since there is no syntax for &#34;raw function pointer&#34;, the compiler will let you substitute any other raw pointer type. Several tutorials use <code>foo as *const ()</code> (pointer to unit) to temporarily hold an untyped function pointer.</p>
<p>For those expecting to the usual Rust guard rails, it&#39;s surprising that the compiler allows casting between arbitrary raw pointer types outside of an <code>unsafe</code> block. This feels really dangerous— even though we can&#39;t do anything with the pointer outside of an <code>unsafe</code> block, creating a raw pointer usually implies that an unsafe block will eventually do something with it. I kind of wish that this pointer casting required <code>unsafe</code>, just because this code should send up red flags, and probably deserves a close look during code review.</p>
<p>I feel a little bad that while making a joke by doing something that&#39;s a little evil, I accidentally inserted a really evil cast that is highly misleading to the reader.</p>
<p>If I wanted to go all-in on the evil cast I could do something like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> rand = main as </span><span>*const </span><span>rand::rngs::OsRng as </span><span>usize</span><span>;
</span><span>    dbg!(rand);
</span><span>}
</span></code></pre>
<p>A few people pointed out that there are a few instances of programs that actually do try to harvest some randomness from the program&#39;s address. There&#39;s probably a place for a dirty hack like that, but I would feel a bit icky if I ever published code like that myself.</p>
<p>Thanks to @yoshuawuyts for setting up the joke, and to @eddyb for pointing out my pointer mistake, and everyone else who commented!</p>
<p>Comments? Get in touch on <a href="https://twitter.com/codeandbitters">twitter: @codeandbitters</a></p>

                            </div></div>
  </body>
</html>
