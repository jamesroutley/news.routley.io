<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2021/11/15/esbuild-vue/">Original</a>
    <h1>Some notes on using esbuild</h1>
    
    

<p>Hello!</p>

<p>I&rsquo;ve been writing more frontend code in the last year or two &ndash; I&rsquo;ve been making a bunch of little Vue projects. (for example <a href="https://nginx-playground.wizardzines.com/">nginx playground</a>, <a href="https://sql-playground.wizardzines.com/">sql playground</a>, <a href="https://dns-lookup.jvns.ca/">this dns lookup tool</a>, and a couple of others)</p>

<p>My general approach to frontend development has been pretty &ldquo;pretend it&rsquo;s 2005&rdquo; &ndash; I usually
have an <code>index.html</code> file, a <code>script.js</code> file, and then I do a <code>&lt;script
src=&quot;script.js&quot;&gt;</code> and that&rsquo;s it. You can see an <a href="https://github.com/jvns/dns-lookup/tree/main/site">example of that approach here</a>.</p>

<p>This has been working mostly ok for me, but sometimes I run into problems. So I
wanted to talk about one of those problems, a solution I found
(<a href="https://esbuild.github.io/">esbuild</a>!), and what I needed to learn to solve the problem (some very basic facts about how npm builds work).</p>

<p>Some of the facts in this post might
be wrong because still I don&rsquo;t understand Javascript build systems that well.</p>

<h3 id="problem-1-libraries-that-tell-you-to-npm-install-them">problem 1: libraries that tell you to <code>npm install</code> them</h3>

<p>Sometimes I see Javascript libraries that I&rsquo;m interested in using, and they
have installation instructions like this:</p>

<pre><code>npm install vue-jcrop
</code></pre>

<p>and code examples to use the library that look like this:</p>

<pre><code>import { Jcrop } from 'vue-jcrop';
</code></pre>

<p>Until last week, I found this completely mystifying &ndash; I had no idea what
<code>import</code> was doing and I didn&rsquo;t understand how to use libraries in that way.</p>

<p>I still don&rsquo;t totally understand but I understand a tiny
bit more now and I will try to explain what I&rsquo;ve learned.</p>

<h3 id="problem-2-i-don-t-understand-frontend-build-tools">problem 2: I don&rsquo;t understand frontend build tools</h3>

<p>Of course, the obvious way to solve problem 1 is to use Vue.js the &ldquo;normal&rdquo;
way where I install it with <code>npm</code> and use Vite or <code>vue-cli-service</code> or
whatever.</p>

<p>I&rsquo;ve used those tools before once or twice &ndash; there&rsquo;s this project generator
called <code>vue create</code> which will set up everything for you properly, and it
totally works.</p>

<p>But I stopped using those tools and went back to my old <code>&lt;script
src=&quot;script.js&quot;&gt;</code> system because I don&rsquo;t understand what those
<code>vue-cli-service</code> and <code>vite</code> are doing and I didn&rsquo;t feel confident that I could
fix them when they break. So I&rsquo;d rather stick to a setup that I actually
understand.</p>

<p>I think the reason <code>vue-cli-service</code> is so confusing to me is that it&rsquo;s
actually doing many different things &ndash; I think it:</p>

<ul>
<li>compiles Vue templates</li>
<li>runs Babel (??)</li>
<li>does type checking for Typescript (if you&rsquo;re using typescript)</li>
<li>does all of the above with webpack which I will not try to explain much
because I don&rsquo;t understand it, I think it&rsquo;s a system with a million plugins
that does a million things</li>
<li>probably some other things I&rsquo;m forgetting or don&rsquo;t even know about</li>
</ul>

<p>If I were working on a big frontend project I&rsquo;d probably use those tools
whether or not I understood them because they do useful things. But I haven&rsquo;t been using them.</p>

<h3 id="esbuild-a-simple-way-to-resolve-import-s">esbuild: a simple way to resolve <code>import</code>s</h3>

<p>Okay! Let&rsquo;s get to the point of the post!</p>

<p>Recently I learned about <code>esbuild</code> which is a new JS build tool written in Go. I&rsquo;m excited
about it because it lets me use <code>import</code>s in my code without using a giant build
pipeline that I don&rsquo;t understand. I&rsquo;m also used to the style
of command-line tools written in Go so it feels more &ldquo;natural&rdquo; to me than other tools written in Javascript do.</p>

<p>Basically <code>esbuild</code> can resolve all the imports and then bundle everything into 1 big file.</p>

<p>So let&rsquo;s say I want to use <code>vue</code> in my library. I can get it working by doing these 4 steps:</p>

<p><strong>step 1: install the library I want</strong></p>

<p><code>npm install vue</code> or whatever.</p>

<p><strong>step 2: import it in script.js</strong></p>

<pre><code>import Vue from 'vue';
</code></pre>

<p><strong>step 3: run <code>esbuild</code> to bundle it</strong></p>

<pre><code>$ esbuild script.js  --bundle --minify  --outfile=bundle.js
</code></pre>

<p><strong>step 4: add a <code>&lt;script src='bundle.js'&gt;</code>;</strong></p>

<p>Then I need to replace all of my script tags with just one script (<code>&lt;script src=&quot;bundle.js&quot;&gt;</code>) in my HTML, and everything should just work, right?</p>

<p>This all seemed very simple and I was super excited about this, but&hellip;</p>

<h3 id="problem-3-it-didn-t-work">problem 3: it didn&rsquo;t work</h3>

<p>I was really excited about this, but when I tried it
(<code>import Vue from 'vue'</code>), it didn&rsquo;t work! I was really baffled by this, but I was eventually able to figure it out with some help from people who understood Javascript.
(spoiler: it wasn&rsquo;t esbuild&rsquo;s fault!)</p>

<p>To understand why my <code>import</code> didn&rsquo;t work, I needed to learn a little bit more
about how frontend packaging works. So let&rsquo;s talk about that.</p>

<p>First, I was getting this error message in the JS console (which of course I didn&rsquo;t see until the 20th time I looked at the console)</p>

<blockquote>
<p>[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</p>
</blockquote>

<p>This was bad, because I was compiling my Vue templates at runtime, so I
definitely needed the template compiler. So I just needed to convince <code>esbuild</code>
to give me the version of Vue with the template compiler. But how?</p>

<h3 id="frontend-libraries-can-have-many-different-build-artifacts">frontend libraries can have many different build artifacts</h3>

<p>Apparently frontend libraries often have many different
build artifacts! For example, here are all of the different Vue build
artifacts I have on my computer, excluding the minified versions:</p>

<pre><code>$ ls node_modules/vue/dist | grep -v min
README.md
vue.common.dev.js
vue.common.js
vue.common.prod.js
vue.esm.browser.js
vue.esm.js
vue.js
vue.runtime.common.dev.js
vue.runtime.common.js
vue.runtime.common.prod.js
vue.runtime.esm.js
vue.runtime.js
</code></pre>

<p>I think the different options being expressed here are:</p>

<ul>
<li>dev vs prod (how verbose are the error messages?)</li>
<li>runtime vs not-runtime (does it include a template compiler?)</li>
<li>whatever the difference between <code>vue.js</code> vs <code>vue.esm.js</code> vs <code>vue.common.js</code> is (something about ES6 modules vs CommonJS???)</li>
</ul>

<h3 id="how-the-build-artifact-usually-gets-chosen-webpack-or-something">how the build artifact usually gets chosen: webpack or something</h3>

<p>I think the way Vue.js usually chooses which Vue version <code>import</code> uses is through a config file called <code>vue.config.ts</code></p>

<p>As far as I can tell, this usually gets processed through some code <a href="https://github.com/vuejs/vue-cli/blob/e76a7a893c173209be8e800c4de357556d01dc67/packages/%40vue/cli-service/lib/config/base.js#L69-L71">in this file</a> that looks like this:</p>

<pre><code>      webpackConfig.resolve
        .alias
          .set(
            'vue$',
            options.runtimeCompiler
              ? 'vue/dist/vue.esm.js'
              : 'vue/dist/vue.runtime.esm.js'
          )
</code></pre>

<p>Even though I have no idea how Webpack works, this is pretty helpful! It&rsquo;s
saying that if I want the runtime compiler, I need to use <code>vue.esm.js</code>
intead of <code>vue.runtime.esm.js</code>.  I can do that!</p>

<h3 id="what-build-artifact-is-esbuild-loading">what build artifact is esbuild loading?</h3>

<p>I also double checked which version of <code>Vue</code> esbuild is loading using strace, because I love strace:</p>

<p>I made a file called <code>blah.js</code> that looks like this:</p>

<pre><code>import Vue from 'vue';

const app = new Vue()
</code></pre>

<p>and saw which files it opened, like this: (you have to scroll right to see the filenames)</p>

<pre><code>$ strace -e openat -f  esbuild blah.js  --bundle --outfile=/dev/null
openat(AT_FDCWD, &quot;/home/bork/work/mess-with-dns/frontend/package.json&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/home/bork/work/mess-with-dns/frontend/blah.js&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/home/bork/work/mess-with-dns/frontend/node_modules/vue/package.json&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/home/bork/work/mess-with-dns/frontend/node_modules/vue/dist/vue.runtime.esm.js&quot;, O_RDONLY|O_CLOEXEC) = 3
</code></pre>

<p>It looks like it just opens <code>package.json</code> and <code>vue.runtime.esm.js</code>. <code>package.json</code> has this <code>main</code> key, which must be what&rsquo;s directing esbuild to
load <code>vue.runtime.esm.js</code>. I guess that&rsquo;s part of the ES6 modules spec or
something.</p>

<pre><code>  &quot;main&quot;: &quot;dist/vue.runtime.common.js&quot;,
</code></pre>

<h3 id="importing-the-template-compiler-version-of-vue-fixed-everything">importing the template compiler version of Vue fixed everything</h3>

<p>Importing the version of Vue with the template compiler was very simple in the end, I just needed to do</p>

<pre><code>import Vue from 'vue/dist/vue.esm.js'
</code></pre>

<p>instead of</p>

<pre><code>import Vue from 'vue'
</code></pre>

<p>and then <code>esbuild</code> worked! Hooray! Now I can just put that <code>esbuild</code>
incantation in a bash script which is how I run all my builds for tiny projects
like this.</p>

<h3 id="npm-install-gives-you-all-the-build-artifacts"><code>npm install</code> gives you all the build artifacts</h3>

<p>This is a simple thing but I didn&rsquo;t really understand it before &ndash; it seems like <code>npm install vue</code>:</p>

<ol>
<li>the package maintainer runs <code>npm run build</code> at some point and then publishes the package to the NPM registry</li>
<li><code>npm install</code> downloads the Vue source into <code>node_modules</code>, as well as the build artifacts</li>
</ol>

<p>I think that&rsquo;s right?</p>

<p><code>npm run build</code> can run any arbitrary program, but the convention seems to be
for it to create build artifacts that end up in <code>node_modules/vue/dist</code>. Maybe
the <code>dist</code> folder is standardized by npm somehow? I&rsquo;m not sure.</p>

<h3 id="not-every-npm-package-has-a-dist-directory">not every NPM package has a <code>dist/</code> directory</h3>

<p>There&rsquo;s a cool NPM package called <a href="https://github.com/glitchdotcom/friendly-words">friendly-words</a> from Glitch. If I run
<code>npm install friendly-words</code>, it doesn&rsquo;t have a <code>dist/</code> directory.</p>

<p>It was explained to me that this is because this a package intended to be run
on the <em>backend</em>, so it doesn&rsquo;t package itself into a single Javascript file
build artifact in the same way. Instead it just loads files from disk at
runtime &ndash; this is basically what it does:</p>

<pre><code>$ cat node_modules/friendly-words/index.js 
const data = require('./generated/words.json');

exports.objects = data.objects;
exports.predicates = data.predicates;
exports.teams = data.teams;
exports.collections = data.collections;
</code></pre>

<h3 id="people-seem-to-prefer-import-over-require-for-frontend-code">people seem to prefer <code>import</code> over <code>require</code> for frontend code</h3>

<p>Here&rsquo;s what I&rsquo;ve understood about <code>import</code> vs <code>require</code> so far:</p>

<ul>
<li>there are two ways to use <code>import</code> / <code>require</code>, you can do a build step to collapse all the imports and put everything into one file (which is what I&rsquo;m doing), or you can do the imports/requires at runtime</li>
<li>browsers can&rsquo;t do <code>require</code> at runtime, only <code>import</code>. This is because <code>require</code> loads the code synchronously</li>
<li>there are 2 standards (CommonJS and ES6 modules), and that <code>require</code> is CommonJS and <code>import</code> is ES6 modules.</li>
<li><code>import</code> seems to be a lot more restricted than <code>require</code> in general (which is good)</li>
</ul>

<p>I think this means that I should use <code>import</code> and not <code>require</code> in my frontend code.</p>

<h3 id="it-s-exciting-to-be-able-to-do-imports">it&rsquo;s exciting to be able to do imports</h3>

<p>I&rsquo;m pretty excited to be able to do imports in a way that I actually almost
understand for the first time. I don&rsquo;t think it&rsquo;s going to make <em>that</em> big of a
difference to my projects (they&rsquo;re still very small!).</p>

<p>I don&rsquo;t understand everything
<code>esbuild</code> is doing, but it feels a lot more approachable and transparent than
the Webpack-based tools that I&rsquo;ve used previously.</p>

<p>The other thing I like about <code>esbuild</code> is that it&rsquo;s a static Go binary, so I
feel more confident that I&rsquo;ll be able to get it to work in the future than with
tool written in Javascript, just because I understand the Javascript ecosystem
so poorly. And it&rsquo;s super fast, which is great.</p>

  </body>
</html>
