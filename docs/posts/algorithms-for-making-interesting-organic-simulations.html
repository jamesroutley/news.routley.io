<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bleuje.com/physarum-explanation/">Original</a>
    <h1>Algorithms for making interesting organic simulations</h1>
    
    <div id="readability-page-1" class="page"><div>
            <h2>Algorithms for making interesting organic simulations</h2>

            <p>The purpose of this article is to explain techiques that enabled me to make simulations like the one
                below, along with a lot of other organic looking things. We will focus on algorithmic techniques for
                artistic purpose
                rather than scientific meaning.</p>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="https://bleuje.com/videos/physarum-no11small.jpg">
                <source src="https://physarum-media.bleuje.com/physarum-no11small.mp4" type="video/mp4"/>
            </video>

            <hr/>

            <h2>1. Physarum algorithm from Jeff Jones (2010)</h2>

            <p>Jeff Jones presented a simulation algorithm that reproduces the behavior of organisms such
                as <a href="https://en.wikipedia.org/wiki/Physarum_polycephalum"><em>Physarum polycephalum</em></a>.
                It is explained in <a href="https://uwe-repository.worktribe.com/output/980579/characteristics-of-pattern-formation-and-evolution-in-approximations-of-physarum-transport-networks">this
                    paper</a>.</p>

            <p>Results typically look like this: <span>(source: screenshots from implementation by Amanda
                    Ghassaei)</span></p>

            <p><img src="https://bleuje.com/physarum-explanation/images/amanda-physarum-screenshot-0.png" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/amanda-physarum-screenshot-1.png" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/amanda-physarum-screenshot-2.png" alt=""/>
            </p>

            <h3>General principle</h3>
            <p>The basic idea is that particles (also called agents) move around, leaving a trail behind them and trying
                to follow the trails
                they detect.</p>

            <p>Below is an interactive explanation of a single agent, <em>without representing the trail update</em>.
                <span>Please don&#39;t mind the glitch after slider change :)</span>
            </p>

            

            

            <h4>Detailed description of the algorithm</h4>

            <p>A large number of agents move in a 2D space.</p>

            <p>
                At each iteration of the algorithm, agents deposit trail on an
                image called a <strong>trail map</strong>, just by adding a value to a pixel of the image. In the above
                illustration, each cell represents a pixel of the trail map image.</p>

            <p><u>Agent attributes:</u>
            </p><ul>
                <li>2D position <strong>(x,y)</strong></li>
                <li>orientation: an <strong>angle</strong> called <strong>heading</strong></li>
            </ul>

            <p>Here are the different steps for an iteration of the algorithm:</p>

            <u>1. Sensing:</u>
            <ul>
                <li>Each agent &#34;looks&#34; at three places: straight ahead, slightly right, and slightly
                    left. <span>sometimes not so slightly</span>
                </li>
                <li>The distance from the agent to the 3 sensor places is defined by the parameter <strong>Sensor
                        Distance</strong> <span>(SD)</span>.</li>
                <li>The side angle is a parameter called <strong>Sensor Angle</strong> <span>(SA)</span>.
                </li>
                <li>The agent detects the trail intensity at those three positions/pixels.</li>

            </ul>

            <u>2. Rotation and movement:</u>
            <ul>
                <li>If the highest value is to the left or right, the agent turns in that direction.</li>
                <li>The turn angle is controlled by the parameter <strong>Rotation Angle</strong> <span>(RA)</span>.</li>
                <li>If the highest value is straight ahead, the agent doesn&#39;t rotate.</li>
                <li>Actually in the case where straight ahead is the lowest value, the agent makes a random choice
                    between left and right.</li>
                <li>After potentially turning, the agent moves forward by a distance called <strong>Move Distance
                    </strong> <span>(MD)</span>.</li>
            </ul>

            <p><u>3. Deposit:</u> the agents add a value to the trail map at their new position.</p>

            <p><u>4. Trail diffusion and decay:</u>
                At each iteration, after deposit of all agents, the trail is slightly diffused (a sort of blur effect on
                the image), and multiplied by a <strong>decay factor</strong> (for example <strong>0.75</strong>) to
                keep things stable. A more precise
                explanation will be given later. <span>Although the trail is a 2D
                    image,
                    artistically it&#39;s often better not to display it directly, and instead only show the
                    particles.</span>
            </p>

            <p>By modifying the four main parameters (SD, SA, RA, MD), various simulated behaviors can be observed.

                The algorithm from Jeff Jones can have more complex features than this but I&#39;m giving a simple version
                that&#39;s used for what is described next in this article.</p>

            <h3>Real interactive implementation with few agents.</h3>

            <p>The simulation below implements the algorithm, there are just too few particles and too few pixels for
                cool
                structures to appear!</p>

            

            

            <p><span>You can check out <a href="https://apps.amandaghassaei.com/gpu-io/examples/physarum/#:~:text=This%20app%20simulates%20the%20network,Written%20by%20Amanda%20Ghassaei">this
                        very nice webpage</a> by Amanda Ghassaei, to see the simulation with a lot of particles and with
                    controllable sliders.</span></p>

            <p>Another explanation/review of this algorithm from Jeff Jones can be found <a href="https://cargocollective.com/sagejenson/physarum">here</a>. It has a pretty drawing to sum up
                the algorithm.</p>

            <details>
                <summary>Show explanation image by Sage Jenson</summary>
                <img src="https://payload.cargocollective.com/1/18/598881/13800048/diagram_670.jpg" alt="Sage Jenson physarum explanation diagram"/>
            </details>

            <hr/>

            <h2>2. <em>36 Points</em> by Sage Jenson (2019-2022)</h2>

            <p>A more complex version of the previous algorithm can be found in the work <strong><a href="https://sagejenson.com/36points/"><em>36 Points</em></a></strong> by Sage Jenson, which
                displays amazing varied behaviours. Press letters or digits of your keyboard to
                change the Point. <span> 26 letters + 10 digits = 36</span>
            </p>

            <p>It uses a single algorithm and each Point represents different parameters, which result
                in different behaviours.

                A Point corresponds to a behaviour obtained with 20 parameters (so mathematically this project shows 36
                points of ℝ²⁰).
            </p>

            <p><img src="https://bleuje.com/physarum-explanation/images/sage-36points-1.png" alt="36 Points image 1"/>
                <img src="https://bleuje.com/physarum-explanation/images/sage-36points-2.png" alt="36 Points image 2"/>
                <img src="https://bleuje.com/physarum-explanation/images/sage-36points-3.png" alt="36 Points image 3"/>
                <img src="https://bleuje.com/physarum-explanation/images/sage-36points-4.png" alt="36 Points image 4"/>
                <img src="https://bleuje.com/physarum-explanation/images/sage-36points-5.png" alt="36 Points image 5"/>
                <img src="https://bleuje.com/physarum-explanation/images/sage-36points-6.png" alt="36 Points image 6"/>
            </p>

            <p>The above images show 6 Points. <span><a href="https://retrospective.feralfile.com/ff1/artists/sage-jenson-3kv">(found there)</a></span>
            </p>

            <h3>Main idea</h3>

            <p>Looking at the code we can understand some clever ideas. The most important one is to make the parameters
                of the classic algorithm different depending on the value <strong>\( x \)</strong> of the trail map at
                the particle&#39;s position.</p>

            <p>The formulas below are used:</p>

            <p>
                $$
                \begin{eqnarray}
                \text{sensor distance} &amp;=&amp; p_1 + p_2 \cdot x^{p_3} \nonumber \\
                \text{sensor angle} &amp;=&amp; p_4 + p_5 \cdot x^{p_6} \nonumber \\
                \text{rotation angle} &amp;=&amp; p_7 + p_8 \cdot x^{p_9} \nonumber \\
                \text{move distance} &amp;=&amp; p_{10} + p_{11} \cdot x^{p_{12}}
                \end{eqnarray}
                $$
            </p>

            <p>For each iteration, we first get the value <strong>\( x \)</strong> of the trail map at the particle&#39;s
                position,
                and then with the previous formulas we just do the same as the previous classic algorithm. That gives us
                12
                parameters to play with instead of 4.</p>

            <p>Below is an update of the animated explanation with a single agent. This is using fixed parameters.</p>

            

            

            <p>I think adding interactive sliders to control the 12 parameters wouldn&#39;t add much value for the
                explanation.
            </p>

            <h3>Other idea</h3>

            <p>There are 2 other parameters that are important to use: two offsets to rather get <strong>\( x
                    \)</strong>
                near the particle position.</p>
            <p>The first one is an absolute vertical offset <strong>\( p_{13} \)</strong> (&#34;absolute&#34; meaning the
                heading of the particle
                doesn&#39;t matter). The second one, <strong>\( p_{14} \)</strong>, is an offset relatively to the
                particle&#39;s heading (getting \( x \) ahead of the particle),</p>

            <p>A piece of code for that part can look like this:</p>

            

            <h3>Respawn</h3>

            <p>Another thing in <em>36 Points</em> is that in addition to position and heading attributes, there is a
                progress attribute so that each particle periodically respawns at a random position.</p>

            <h3>Other comments</h3>

            <p>Simply by using variations of the 14 parameters that were previously described, very different and
                interesting behaviours can be obtained. At this point maybe we should not call the results &#34;physarum
                simulations&#34;, but rather &#34;speculative biology&#34; as Sage seems to state. </p>

            <p>I haven&#39;t used the 6 other parameters from <em>36 Points</em>: for example the decay factor is one of
                them (I use a fixed value to 0.75). </p>

            <p>Sage&#39;s piece of code <span><a href="https://gist.github.com/Bleuje/1e497df4505ca24c39ab3930a95700b3">(link)</a></span> that
                implements the particle update with these techniques
                has the following <strong>license</strong>: </p>

            <hr/>

            <h2>3. Bleuje implementation</h2>

            <p>You can find my implementation of the previous algorithm on github: <strong><a href="https://github.com/Bleuje/physarum-36p">physarum-36p</a></strong></p>

            <p>Although I use the techniques described in the previous part that come from <em>36 Points</em>, my
                implementation is different, and because of that I added a 15th parameter to make some points of <em>36
                    Points</em> work. It&#39;s simply some rescaling factor for the sensed \( x \). A lot of points from
                <em>36 Points</em> don&#39;t work at all with my implementation, and those that work mostly give different
                behaviours. I also added new points.
            </p>

            <p>Below is a video showing what this implementation produces for 22 different Points (each one having 15
                parameters).</p>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="images/bleuje-22-points-screenshot.png">
                <source src="https://physarum-media.bleuje.com/bleuje-22-points.mp4" type="video/mp4"/>
            </video>

            <p>Below is a description of what the code is doing.</p>

            <h3>Real-time setup</h3>

            <p>In order to have real-time fast computation, we can use shaders to compute the algorithm on the GPU. I&#39;m
                using compute shaders and openFrameworks to manage them and the interface. The particles updates are
                done in parallel, same for the trail map updates in other shaders. It can run smoothly with millions of
                particles.
            </p>

            <p>There are 4 shaders:</p>

            <ul>
                <li>A shader that just resets counters to zero.</li>
                <li>Particle update/move, incrementing counter on new pixel postion.</li>
                <li>Trail deposit from counter, and pretty image production.</li>
                <li>Diffusion + decay on trail map.</li>
            </ul>

            <h3>Diffusion and decay algorithm</h3>

            <p>The diffusion is using a 3x3 cells kernel, as explained in the code below.</p>

            <details>
                <summary>Show code for diffusion and decay step</summary>
                
            </details>

            <p>The implementation is actually a bit different because we &#34;loop&#34; the image at the borders. <span><a href="https://github.com/Bleuje/physarum-36p/blob/main/bin/data/shaders/computeshader_diffusion.glsl">(link
                        to actual code)</a></span> </p>

            <h3>Deposit on trail map</h3>

            <p>There is a counter of particles on each pixel of the trail map. The counters are set to 0 at the
                beginning ot
                each iteration of the algorithm. After they move, the particles increment the counter at their position,
                which can be done in parallel thanks to the atomicAdd function in glsl.</p>

            <p>To update the trail map, we add \( \sqrt{k} \times f \) to the trail map image, where \( k \) is the
                particles count at the pixel and \( f \) some constant deposit factor. This part is a personal idea, I
                find that
                it works quite well. I also limit the count to a maximum value.</p>

            <p>Here is simplified code for that part. <span><a href="https://github.com/Bleuje/physarum-36p/blob/main/bin/data/shaders/computeshader_deposit.glsl">(link
                        to actual code)</a></span></p>

            <details>
                <summary>Show GLSL code piece for particle deposit step</summary>
                
            </details>

            <h3>Important differences compared to <em>36 Points</em></h3>

            <p>The trail map in <em>36 Points</em> works differently compared to what I described. If I understand
                correctly, in <em>36 Points</em> particles are like transparent dots that are added on the trail map
                image. It results that the
                trail map doesn&#39;t have values larger than the opaque value 1.</p>

            <p>In my implementation there is no such limit on trail map values, so when getting the value \( x \) we
                clamp it to avoid a value larger than 1: \( x = \min(x,1) \).</p>

            <p>Another difference is that trail map sensing can be done either at the nearest pixel or using continuous
                sampling. Unlike <em>36 Points</em>, in this implementation I do it on nearest pixel as
                shown in the animated illustration.
            </p>

            <details>
                <summary><span>Remarks about sensing on image</span></summary>
                <span>
                    <p>I realized/remembered this implementation difference after writing the article. After testing
                        the difference, it feels like the continuous sampling doesn&#39;t necessarily give more interesting
                        results. But you should do it if you want to imitate <em>36 Points</em>.</p>

                    <p>Here are some GLSL snippets for sensing, depending on the method you choose. By the way, wrapping
                        is implemented here.</p>

                    <details>
                        <summary>Show GLSL code for nearest pixel sampling</summary>
                        
                    </details>

                    <details>
                        <summary>Show GLSL code for continuous sampling (interpolating between pixels)</summary>
                        
                    </details>

                    <p>For continuous sampling we could also use the texture function in GLSL like Sage, though that
                        requires setup changes in my implementation.</p>

                </span>
            </details>

            <h3>Move shader</h3>

            <p>With the previous explanations we can give simplified code for the particle move and update.</p>

            <details>
                <summary>Show GLSL code piece for particle update/move (the most important code)</summary>
                
            </details>

            <span><a href="https://github.com/Bleuje/physarum-36p/blob/main/bin/data/shaders/computeshader_move.glsl">(link
                    to actual code)</a></span>

            <h3>Displayed image</h3>

            <p>To get the image to display, the particles count on a pixel can be mapped to brightness in [0,1], non
                linearly. The deposit shader does it at the same time as doing the deposit on trail map.</p>

            <p>Some screenshots to end this section:</p>

            <p><img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-1.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-2.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-3.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-4.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-5.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-6.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-7.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-8.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-9.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-10.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-11.jpg" alt=""/>
                <img src="https://bleuje.com/physarum-explanation/images/bleuje-22-points-12.jpg" alt=""/>
            </p>

            <hr/>

            <h2>4. Color experiments</h2>

            <p>A natural thing to do to obtain more colorful simulations is to map the counter of particles on a pixel
                to a color gradient, typically from black to white with various colors in between.</p>

            <p>I experimented with something more complex. The trail map image has two channels: one is the classic
                trail map, the other one is the trail map with a delay. When determining the color of a pixel, we check
                for the difference between trail map and delayed trail map at this pixel. The difference interpolates
                the previous color (with a gradient) towards white or another gradient. With that technique, areas where
                there is more change can have different colors. The interpolation amount can also be different with
                distance from the center.</p>

            <p><span><a href="https://github.com/Bleuje/interactive-physarum/blob/main/bin/data/shaders/computeshader_deposit.glsl">Link
                        to an implementation</a></span></p>

            <p><img src="https://physarum-media.bleuje.com/screenshots/color-screenshot-1-light.png" alt=""/>
                <img src="https://physarum-media.bleuje.com/screenshots/color-screenshot-3-light.png" alt=""/>
                <img src="https://physarum-media.bleuje.com/screenshots/color-screenshot-4-light.png" alt=""/>
                <img src="https://physarum-media.bleuje.com/screenshots/color-screenshot-2-light.png" alt=""/>
            </p>

            <hr/>

            <h2>5. Weird velocity effect experiment</h2>

            <p>At some point I wanted to experiment with adding velocity attributes to particles, so that they have some
                kind of inertia.</p>

            <p>I don&#39;t remember how, but with my experiments I arrived at a technique that can produce smooth and
                intricate results. It&#39;s described in the code below.</p>

            <details>
                <summary>Show GLSL code piece for weird effect</summary>
                
            </details>

            <p>In the videos below, after 3 seconds the effect is activated.</p>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="images/effect-g-small.jpg">
                <source src="https://physarum-media.bleuje.com/effect-g-small.mp4" type="video/mp4"/>
            </video>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="images/effect-v-small.jpg">
                <source src="https://physarum-media.bleuje.com/effect-v-small.mp4" type="video/mp4"/>
            </video>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="images/effect-m-small.jpg">
                <source src="https://physarum-media.bleuje.com/effect-m-small.mp4" type="video/mp4"/>
            </video>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="images/effect-q-small.jpg">
                <source src="https://physarum-media.bleuje.com/effect-q-small.mp4" type="video/mp4"/>
            </video>

            <hr/>

            <h2>6. Playful interaction ideas, points mixing</h2>

            <p>I&#39;ve been making a playful version of these algorithms. The main idea is that there is a cursor that the
                user controls, through mouse or joystick, and different Points are spatially mixed. <span>Note: letters here are mapped to diffent points than in <em>36
                        Points</em>.</span></p>

            <p><img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-1.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-1.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-2.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-2.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-4.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-4.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-5.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-5.png"/>
            </p>

            <p>At the
                center of the cursor the simulation parameters use the first Point and far from cursor it&#39;s the second
                one. In the area in between, interpolation is done to get parameters. The interpolation parameter is
                defined with a gaussian function, and the size of the cursor is a standard deviation \( \sigma \). Let&#39;s
                call \( \mathbf{P} \) the particle position, and \( \mathbf{C} \) the cursor position. I also use the
                word pen instead of
                cursor.</p>

            <p>
                $$t = \exp\left( -\frac{\|\mathbf{P} - \mathbf{C}\|^2}{\sigma^2} \right)$$
                $$\text{param} = (1-t) \times \text{BackgroundPoint.param} + t \times \text{CursorPoint.param} $$
            </p>

            <p>We do this for all Point parameters of the simulation.</p>

            <p>The user can control pen size and navigate through Point choices.</p>

            <h3>Spawning action</h3>

            <p>The user can spawn particles at some positions: the desired spawn position is given as uniform to the
                move
                shader, and each particle has a small probability of going to that location. So the spawning
                doesn&#39;t actually add new particles.</p>

            <h3>My big interactive physarum project</h3>

            <p>I open sourced the project where all of this and more features are implemented, it can be used as
                playful artistic installation with one or two players using gamepads. Link:</p>
            <p><a href="https://github.com/Bleuje/interactive-physarum">Interactive physarum repository</a></p>

            <p><img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-1.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-1.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-9.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-9.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-12.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-12.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-13.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-13.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-6.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-6.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-7.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-7.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-8.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-8.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-14.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-14.png"/>
                <img data-src="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-10.png" alt="" data-full="https://physarum-media.bleuje.com/screenshots/interactive-physarum-v2-10.png"/>
            </p>

            <hr/>

            <h2>7. Other experiments</h2>

            <p>The algorithm has enough elements to allow for a lot of room for experimentation.</p>

            <h3>Example 1</h3>

            <p>Here is an example where the heading of the particle is used to interpolate parameters between two
                Points.
            </p>

            <p>
                $$t = 0.5 + 0.5 \times \sin(\text{heading} + f(x,y,\text{time}))$$
                $$\text{param} = (1-t) \times \text{Point1.param} + t \times \text{Point2.param} $$
            </p>

            <p>\( f(x,y,\text{time}) \) is a function to play with. Mostly with that technique the simulation below
                was obtained.</p>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="https://bleuje.com/videos/physarum-no14small.jpg">
                <source src="https://physarum-media.bleuje.com/physarum-no14small.mp4" type="video/mp4"/>
            </video>

            <p>Another thing that was used is that particle random respawn has different probability depending on the
                sensed value at particle position.</p>

            <h3>Example 2</h3>

            <p>For the simulations below, the main technique was using negative effect amount with the technique that
                was described earlier in the velocity effect section (see &#34;effectAmount&#34; variable):</p>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="https://bleuje.com/videos/physarum-no15small.jpg">
                <source src="https://physarum-media.bleuje.com/physarum-no15small.mp4" type="video/mp4"/>
            </video>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="https://bleuje.com/videos/physarum-no16small.jpg">
                <source src="https://physarum-media.bleuje.com/physarum-no16small.mp4" type="video/mp4"/>
            </video>

            <h3>Example 3</h3>

            <p>In the velocity effect code given earlier, we can force adding some velocity.</p>

            

            <p>With that technique and higher respawn probability when further from center, the simulation below was
                obtained:</p>

            <video width="100%" controls="" playsinline="" muted="" preload="none" poster="https://bleuje.com/videos/physarum-no13small.jpg">
                <source src="https://physarum-media.bleuje.com/physarum-no13small.mp4" type="video/mp4"/>
            </video>

            <hr/>

            <h2>8. Additional resources</h2>

            <ul>
                <li><a href="https://denizbicer.com/202408-UnderstandingPhysarum.html">Interactive explanation for the
                        classic
                        physarum simulation</a>, by Deniz Bicer</li>

                <li><a href="https://github.com/fogleman/physarum/">A go implementation with nice results</a>, by
                    Michael Fogleman</li>
                <li><a href="https://www.youtube.com/watch?v=X-iSQQgOd1A">Presentation video by Sebastian Lague</a></li>
                <li> <a href="https://apps.amandaghassaei.com/gpu-io/examples/physarum/#:~:text=This%20app%20simulates%20the%20network,Written%20by%20Amanda%20Ghassaei">Real-time
                        web implementation</a> with parameters control, by Amanda Ghassaei</li>
                <li>Reminder: <a href="https://cargocollective.com/sagejenson/physarum">Sage&#39;s explanation and comments
                        about physarum simulation</a></li>

            </ul>
            

            <hr/>

            <h2>9. Last remarks</h2>

            <p>If you followed well this article you can understand that I would not have achieved these results without
                borrowing ideas and parameters from <a href="https://sagejenson.com/36points/"><em>36 Points</em></a>.
                The content of this page uses the same license as its key piece of code
                <span>(<strong>License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported
                        License</strong>)</span>.
            </p>

            <p>Some of my experiments seem to force the behaviour and structure, rather than letting them emerge
                naturally from uniform rules. Sometimes I don&#39;t feel proud about that aspect! It loses the speculative
                biology quality.</p>

            <p>I hope this article can inspire people to build their own experiments.</p>

            <p>Thanks for reading!</p>

            <p><span>Contact: etin.jacob (at) gmail.com</span></p>

            <hr/>

            <span>by Etienne Jacob, article under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode">CC BY-NC-SA 3.0</a></span>

        </div></div>
  </body>
</html>
