<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dusted.codes/dotnet-blazor">Original</a>
    <h1>.NET Blazor</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p><img src="https://cdn.dusted.codes/images/blog-posts/2023-11-19/dotnet-blazor-banner.png" alt=".NET Blazor"/></p>
<p>.NET Blazor has been touted as a revolutionary framework that allows .NET developers to build interactive web applications using C# instead of JavaScript. It&#39;s mainly aimed at ASP.NET Core developers who want to build SPA-like apps leveraging the .NET ecosystem and a wealth of existing libraries and tools available via NuGet. It&#39;s Microsoft&#39;s latest instalment in an attempt to gain traction amongst frontend developers. With the <a href="https://devblogs.microsoft.com/dotnet/announcing-dotnet-8/">recent release of .NET 8</a> Microsoft announced even more improvements to Blazor, most notably introducing a new rendering mode called &#34;Static Server-side Rendering (SSR)&#34;.</p>
<p>But what exactly is <a href="https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor">Blazor</a> and how does it enable C# to work in the browser? More interestingly, how does it compare to traditional JavaScript based SPA frameworks with which it aims to compete with?</p>
<h2 id="blazor-wasm">Blazor WASM</h2>
<p>Blazor has been on a journey and in order to understand Blazor&#39;s current state one has to look at its evolution starting from the beginning. <a href="https://devblogs.microsoft.com/dotnet/get-started-building-net-web-apps-in-the-browser-with-blazor/">Launched in 2018</a>, Blazor initially started as an experimental project, aiming to leverage WebAssembly to run C# directly in the browser, allowing developers to build SPAs using .NET. This idea was realized with Blazor WebAssembly, which allowed the .NET runtime to execute on the client.</p>
<p>Blazor WebAssembly, commonly abbreviated as Blazor WASM, offers the most SPA-like experience among all Blazor options. When a user first visits a Blazor WASM application, the browser downloads the .NET runtime along with the application&#39;s assemblies (lots of .dlls) and any other required content onto the user&#39;s browser. The downloaded runtime is a WebAssembly-based .NET runtime (essentially a .NET interpreter) which is executed inside the browser&#39;s WebAssembly engine. This runtime is responsible for executing the compiled C# code entirely in the browser.</p>
<p>Although Blazor WASM applications are primarily written in C#, they can still interoperate with JavaScript code. This allows the use of existing JavaScript libraries and access to browser APIs which are not directly exposed to WebAssembly.</p>
<p>While Blazor WASM has received plenty of initial praise and has been improved over time, it&#39;s also been met with key criticisms which often revolve around the following areas:</p>
<ul>
<li>
<p><strong>Initial load time</strong>:</p>
</li>
<li>
<p><strong>Performance</strong>:</p>
</li>
<li>
<p><strong>Compatibility</strong>:</p>
</li>
<li>
<p><strong>SEO challenges</strong>:</p>
</li>
<li>
<p><strong>Complexities of interop with JavaScript</strong>:</p>
</li>
</ul>
<h2 id="blazor-server">Blazor Server</h2>
<p>To counter act some of these critiques, <a href="https://devblogs.microsoft.com/dotnet/blazor-server-in-net-core-3-0-scenarios-and-performance/">Blazor Server was introduced a year after Blazor WebAssembly</a>, enabling server-side C# code to handle UI updates over a <a href="https://learn.microsoft.com/en-us/aspnet/signalr/overview/getting-started/introduction-to-signalr">SignalR</a> connection. Unlike in Blazor WASM, the client-side UI is maintained by the server in a .NET Core application. After the initial request, a WebSocket connection is established between the client and the server using ASP.NET Core and SignalR.</p>
<p>When a user interacts with the UI, the event is sent over the SignalR connection to the server. The server processes the event and any UI updates are rendered on the server. The server then calculates the diff between the current and the new UI and sends it back to the client over the persistent SignalR connection. This process keeps the client and server UIs in sync. Since the UI logic runs on the server, the actual rendering logic as well as the .NET runtime doesn&#39;t need to be downloaded to the client, resulting in a much smaller download footprint, directly addressing one of the major criticisms of Blazor WASM.</p>
<p>However, while innovative in its approach, Blazor Server has several downsides of its own which need to be considered:</p>
<ul>
<li>
<p><strong>Latency</strong>:</p>
</li>
<li>
<p><strong>Scalability issues</strong>:</p>
</li>
<li>
<p><strong>Server resource usage</strong>:</p>
</li>
<li>
<p><strong>Reliance on SignalR</strong>:</p>
</li>
<li>
<p><strong>No offline support</strong>:</p>
</li>
<li>
<p><strong>ASP.NET Core Server requirement</strong>:</p>
</li>
</ul>
<h2 id="blazor-static-ssr">Blazor Static SSR</h2>
<p>Despite Blazor&#39;s versatility, both the WASM and Server rendering modes suffer from serious drawbacks which make Blazor a difficult choice over traditional SPA frameworks, which by comparison don&#39;t share any of Blazor&#39;s problems and are architecturally simpler too.</p>
<p>Being aware of these challenges, Microsoft tackled some of the primary concerns of Blazor WASM and Server by rolling out <a href="https://www.youtube.com/watch?v=YwZdtLEtROA">Blazor Static SSR</a>:</p>
<p><img src="https://cdn.dusted.codes/images/blog-posts/2023-11-19/blazor-wasm-vs-blazor-server-vs-blazor-ssr.png" alt="Blazor WASM vs. Blazor Server vs. Blazor Static Server-side Rendering"/></p>
<p>Blazor Static SSR, as shown in the diagram above, is a third rendering option which operates entirely independent of WASM or SignalR, instead leveraging an open HTTP connection to stream UI updates to the client. This approach, known as <a href="https://www.debugbear.com/blog/server-side-rendering">static site rendering</a>, involves generating web pages server-side and transmitting the fully composed HTML to the client, where it then gets wired back into the DOM to function as a dynamic application.</p>
<p>During an initial page load, Blazor Static SSR behaves similarly to a traditional server-side application by delivering a complete HTML page to the user&#39;s browser. Additionally, it fetches a <code>blazor.server.js</code> script that establishes a long lived HTTP connection to an ASP.NET Core server. This connection is used to stream UI updates to the client. This architecture is more straightforward, much like a classic server-rendered website, yet it provides a dynamic, SPA-like experience by selectively updating portions of the DOM and therefore eliminating the need for full page reloads.</p>
<p>The benefits over Blazor WASM and Blazor Server are twofold:</p>
<ul>
<li>
<p><strong>Reduced load times</strong>:</p>
</li>
<li>
<p><strong>Scalability</strong>:</p>
</li>
</ul>
<p>Nonetheless, Blazor Static SSR is not an actual SPA framework in the traditional sense. It doesn&#39;t allow for rich interactivity beyond web forms and simple navigation. It also doesn&#39;t allow for real-time updates as there is no code running on the client after the initial page was loaded:</p>
<p><img src="https://cdn.dusted.codes/images/blog-posts/2023-11-19/blazor-static-ssr-overview.png" alt="Blazor Static SSR Overview"/></p>
<p>To combat this, Blazor starting with .NET 8 enables the mixing of different modes and introduces a fourth rendering option called <strong>Auto mode</strong>.</p>
<p><img src="https://cdn.dusted.codes/images/blog-posts/2023-11-19/blazor-mixed-modes.png" alt="Blazor Mixed Modes"/></p>
<p>In order to add interactivity to a Blazor Static SSR website one has to go back to creating either Blazor WASM or Blazor Server components. The auto rendering option aims to counter the main issues of Blazor WASM&#39;s slow load times and Blazor Server&#39;s requirement for a SignalR connection by using both rendering modes at different times:</p>
<p><img src="https://cdn.dusted.codes/images/blog-posts/2023-11-19/blazor-auto-mode.png" alt="Blazor Static SSR Overview"/></p>
<p>A Blazor component operating in Auto-mode starts off by establishing a SignalR connection to enable immediate interactivity and bypass extended load times. Concurrently, it discreetly fetches the .NET runtime and all necessary dependencies to function as a Blazor WASM application. For later visits, Blazor transitions from the Server to the WASM version, maintaining SPA responsiveness without further dependence on the SignalR connection.</p>
<p>It&#39;s a fascinating approach which undoubtedly doesn&#39;t lack creativity or ambition. Even so, Blazor Static SSR incorporated with interactive components poses some old and new challenges too:</p>
<ul>
<li>
<p><strong>No interactivity without WASM or SignalR</strong>:</p>
</li>
<li>
<p><strong>Increased complexity</strong>:</p>
</li>
<li>
<p><strong>No serverless deployments</strong>:</p>
</li>
<li>
<p><strong>No offline support</strong>:</p>
</li>
<li>
<p><strong>Caching challenges</strong>:</p>
</li>
</ul>
<p>Having said that, Blazor Static SSR also comes with a few benefits when it&#39;s not mixed with WASM or Server together:</p>
<ul>
<li>
<p><strong>SEO Friendliness</strong>:</p>
</li>
<li>
<p><strong>Fast initial load</strong>:</p>
</li>
<li>
<p><strong>Stability across browsers</strong>:</p>
</li>
</ul>
<h2 id="blazor-vs-traditional-javascript-spas">Blazor vs. traditional JavaScript SPAs</h2>
<p>Overall Blazor is a remarkable achievement with buckets of originality and technical finesse, however with the exception of Blazor WASM, Blazor Server and Blazor Static SSR behave quite differently to traditional SPAs.</p>
<p>Neither Blazor Server or Blazor Static SSR load all the necessary HTML, JavaScript and CSS upfront. They have a hard dependency on an ASP.NET Core backend, can&#39;t be hosted serverless and require a constant connection to a server. The frontend is not separated from the backend and data is not fetched using APIs. Typical SPAs maintain state on the client side. The user&#39;s interactions with the application can change the state, and the UI updates accordingly without a server round-trip. Since SPAs don&#39;t require page reloads for content updates, they can offer a smoother and faster user experience that is similar to desktop applications. With conventional SPAs the same code can often be shared between web and mobile apps, another advantage over Blazor Server or Static SSR. The clean separation between the frontend and the backend makes the overall mental model simpler and allows to efficiently split the disciplines between different teams.</p>
<h3 id="blazor-wasm-vs-javascript-spas">Blazor WASM vs. JavaScript SPAs</h3>
<p>Blazor WASM stands out as the only rendering option which fully aligns with the ethos of a conventional SPA. Unfortunately the heavy nature of having to run the .NET Runtime over WebAssembly puts it at a significant disadvantage over comparable JavaScript frameworks.</p>
<h3 id="blazor-server-vs-javascript-spas">Blazor Server vs. JavaScript SPAs</h3>
<p>While Blazor Server is technically intriguing, offering a unique approach to web development, it paradoxically combines the limitations of both, a Single-Page Application and a server-intensive architecture, at the same time. To some extent Blazor Server represents a &#34;worst of both worlds&#34; scenario. Personally it&#39;s my least favourite option and I can&#39;t see any future in this design.</p>
<h3 id="blazor-static-ssr-vs-javascript-spas">Blazor Static SSR vs. JavaScript SPAs</h3>
<p>Blazor Static SSR deviates the most from the paradigm of a SPA. Apart from being placed under the Blazor brand it diverges significantly from the framework&#39;s initial architecture. <strong>Ironically this is where its strengths lie as well</strong>. Given that SPAs are inherently accompanied by their own set of challenges, the necessity for a SPA must be well-justified, or otherwise opting for a server-rendered application can be a more straightforward and preferable solution most of the times.</p>
<p>In my view, Blazor Static SSR is a compelling option that deserves to be its own framework, enabling .NET developers to enrich the functionality of everyday ASP.NET Core.</p>
<h2 id="a-word-of-caution">A word of caution</h2>
<p><img src="https://cdn.dusted.codes/images/blog-posts/2023-11-19/dotnet-blazor-vs-javascript-spas.png" alt=".NET Blazor vs. JavaScript SPAs"/></p>
<p>Would I opt for Blazor today? To be candid, probably not. While I maintain a hopeful stance on Blazor, I must remain truthful to myself. I&#39;ve never been the person who blindly champions every Microsoft technology without critical thought. The truth is, currently Blazor is evolving into an unwieldy beast. In spite of its four rendering modes, intricate layers of complexity, and clever technical fixes, it still falls short when compared to established SPAs. This situation leads me to question the longevity of Microsoft&#39;s commitment and how long Blazor will be around. The parallels with Silverlight are hard to ignore, and without the .NET team delivering a technically sound framework, I find it hard to envision widespread adoption beyond a comparatively small group of dedicated C# enthusiasts who will accept any insanity over the thought of using JS.</p>
<h2 id="an-untapped-opportunity">An untapped opportunity?</h2>
<p><img src="https://cdn.dusted.codes/images/blog-posts/2023-11-19/blazor-csharp-to-js-transpiler.png" alt=".NET Blazor reimagined?"/></p>
<p>As I reach the end of this blog post I want to finish on a positive note. I dare to say it, but could C# learn another thing from F#? Thanks to <a href="https://fable.io">Fable</a>, an F# to JavaScript transpiler, F# developers have been able to create rich interactive SPAs using F# for quite some time. Developed in 2016, Fable was originally built on top of <a href="https://babeljs.io">Babel</a>, an ECMAScript 2015+ to JavaScript compiler. Wouldn&#39;t something similar work for C#? As I see it this could pave the way for a very appealing C# framework that circumvents the complexities around WASM and SignalR.</p>
<p><strong>Blazor not only in name but in glory too.</strong></p>
<p>In fact, I&#39;m quite surprised that we haven&#39;t seen such a development yet, but perhaps it&#39;s a matter of perspective. Maybe it has been a case of the wrong team looking at the wrong problem all along? After all the ASP.NET Core team excels in web development and not compiler design. Not every problem needs to be solved using SignalR or streaming APIs. Perhaps it&#39;s time to put a hold on more rendering modes and looking at Blazor through a different lens?</p>
<p>In my view, without doubt, this is the best path forward and I shall remain hopeful until then.</p>

    </div></div>
  </body>
</html>
