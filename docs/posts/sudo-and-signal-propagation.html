<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dxuuu.xyz/sudo.html">Original</a>
    <h1>Sudo and signal propagation</h1>
    
    <div id="readability-page-1" class="page">

<p>This week I spent some time debugging a curious case where signals
were not being delivered to a <code>sudo</code>’ed process.</p>
<p>Consider this shell script:</p>
<pre><code>#!/bin/bash

sudo timeout 5 dd if=/dev/urandom of=/dev/null &amp;
sudo_pid=$!
sudo kill $sudo_pid

if ps -p $sudo_pid &amp;&gt;/dev/null; then
  echo Still running
else
  echo Dead
fi</code></pre>
<p>What should be printed? If you guessed “Dead”, then you would be
correct:</p>
<pre><code>$ ./sudo_kill.sh
Dead</code></pre>
<p>However, when run in CI, I was seeing the opposite. The following is
run from a recreated CI environment (through docker):</p>
<pre><code><a href="https://dxuuu.xyz/cdn-cgi/l/email-protection" data-cfemail="aacec5c9c1cfd8eac9ce9d9b9898999e999acc9e">[email protected]</a>$ ./sudo_kill.sh
Still running</code></pre>
<h2 id="signal-propagation">Signal propagation</h2>
<p>Before going deeper, we need a little background on how
<code>sudo</code> handles signals.</p>
<p>According to the man page:</p>
<blockquote>
<p>When the command is run as a child of the sudo process, sudo will
relay signals it receives to the command. The SIGINT and SIGQUIT signals
are only relayed when the command is being run in a new pty or when the
signal was sent by a user process, not the kernel. This prevents the
command from receiving SIGINT twice each time the user enters control-C.
Some signals, such as SIGSTOP and SIGKILL, cannot be caught and thus
will not be relayed to the command.</p>
</blockquote>
<p>This makes sense. Signals need to be relayed by <code>sudo</code> to
the process it’s managing. Otherwise, scripts would need to calculate
the child PID or send signals to the appropriate process group (a rather
arcane concept). It is much simpler to run a backgrounded
<code>sudo</code> instance and send signals to <code>$!</code> (as we
did in the test script).</p>
<p>However, there are some drawbacks to this approach. The documentation
goes on to say:</p>
<blockquote>
<p>As a special case, sudo will not relay signals that were sent by the
command it is running. This prevents the command from accidentally
killing itself. On some systems, the reboot(8) utility sends SIGTERM to
all non-system processes other than itself before rebooting the system.
This prevents sudo from relaying the SIGTERM signal it received back to
reboot(8), which might then exit before the system was actually
rebooted, leaving it in a half-dead state similar to single user
mode.</p>
</blockquote>
<p>While this note is not directly related to our curious issue (b/c we
are not getting <code>dd</code> to send signals), it is important to
note there are special cases carved out.</p>
<h2 id="changes-in-sudo">Changes in sudo</h2>
<p>Keeping in mind the aforementioned signal propagation corner cases,
the obvious suspect is a change in <code>sudo</code>. From comparing the
local version to the CI version (<code>1.9.13p2</code> vs
<code>1.8.21p2</code>), we discover <a href="https://www.sudo.ws/repos/sudo/rev/d1bf60eac57f">this commit</a>
which landed in <code>1.9.13p1</code>.</p>
<p>The old behavior (before the change) was to:</p>
<blockquote>
<p>Only forward user-generated signals not sent by a process in the
command’s own process group. […]</p>
</blockquote>
<p>This explains the discrepancy we saw earlier. <code>bash</code> runs
all the commands in the script in the same process group, so
<code>kill</code>’s signals were being ignored by <code>sudo</code> b/c
<code>kill</code> is in the same process group as <code>dd</code>.</p>
<p>In my opinion this is surprising and unexpected, if only because this
behavior is undocumented. That being said, I did manage to find a zero
point <a href="https://stackoverflow.com/a/68879134">stack overflow</a>
answer for a <code>setsid</code> workaround. But I think that just
proves my point.</p>
<p>Fortunately, as of November 2022, the new behavior is to:</p>
<blockquote>
<p>[…] forward signals from a process in the same pgrp if the pgrp
leader is not either sudo or the command itself. […]</p>
</blockquote>
<p>which fixes the script use case and obviates the need for a
<code>setsid</code> workaround.</p>
<h2 id="complexity">Complexity</h2>
<p>I had remarked a few months ago I was surprised <a href="https://github.com/sudo-project/sudo">the sudo project</a> has
over 12,000 commits. Now I am no longer surprised. Behind a rather
simple interface (from the common use case perspective) lies a mountain
of complexity. That being said, I’m still quite surprised it took <a href="https://www.sudo.ws/about/history/">over 40 years</a> for this
surprising and undocumented behavior to be fixed.</p>


</div>
  </body>
</html>
