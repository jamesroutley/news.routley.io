<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://haskellforall.com/2026/02/beyond-agentic-coding">Original</a>
    <h1>Beyond agentic coding</h1>
    
    <div id="readability-page-1" class="page"><div><p>I&#39;m generally pretty pro-AI with one major exception: agentic coding.  My consistent impression is that agentic coding does not actually improve productivity and deteriorates the user&#39;s comfort and familiarity with the codebase.  I formed that impression from:</p>
<ul>
<li>
<p><a href="https://haskellforall.com/2026/02/my-experience-with-vibe-coding">my own personal experiences</a></p>
<p>Every time I use agentic coding tools I&#39;m consistently unimpressed with the quality of the results.</p>
</li>
<li>
<p>my experiences interviewing candidates</p>
<p>I allow interview candidates to use agentic coding tools and candidates who do so consistently performed <em>worse</em> than other candidates, failing to complete the challenge or producing incorrect results<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>.  This was a huge surprise to me at first because I expected agentic coding to confer an unfair advantage but … nope!</p>
</li>
<li>
<p>research studies</p>
<p>Studies like the <a href="https://metr.org/blog/2025-07-10-early-2025-ai-experienced-os-dev-study/">Becker study</a> and <a href="https://arxiv.org/abs/2601.20245">Shen study</a> show that users of agentic coding perform no better and sometimes worse when you measure productivity in terms of fixed outcomes rather than code velocity/volume.</p>
</li>
</ul>
<p>I don&#39;t believe agentic coding is a lost cause, but I do believe agentic coding in its present incarnation is doing more harm than good to software development.  I also believe it is still worthwhile to push on the inadequacies of agentic coding so that it empowers developers and improves code quality.</p>
<p>However, in this post I&#39;m taking a different tack: I want to present other ways to leverage AI for software development.  I believe that agentic coding has so captured the cultural imagination that people are sleeping on other good and underexplored solutions to AI-assisted software development.</p>
<h2>The master cue</h2>
<p>I like to design tools and interfaces from first principles rather than reacting to industry trends/hype and I&#39;ve accrued quite a few general design principles from over a decade of working in DevProd and also an even longer history of open source projects and contributions.</p>
<p>One of those design principles is my personal &#34;master cue&#34;, which is:</p>
<blockquote>
<p>A good tool or interface should keep the user in a flow state as long as possible</p>
</blockquote>
<p>This principle isn&#39;t even specific to AI-assisted software development, and yet still highlights why agentic coding sometimes misses the mark.  Both studies and developer testimonials show that agentic coding breaks flow and keeps developers in an idle/interruptible holding pattern more than ordinary coding.</p>
<p>For example, the <a href="https://arxiv.org/abs/2507.09089">Becker study</a> took screen recordings and saw that idle time approximately doubled:</p>
<p><img src="https://haskellforall.com/imgs/beyond-agentic-coding/idle-time.png" alt=""/></p>
<p>I believe we can improve AI-assisted coding tools (agentic or not) if we set our north star to “preserve flow state”.</p>
<h2>Calm technology</h2>
<p><a href="https://calmtech.com/">Calm technology</a> is a design discipline that promotes flow state in tools that we build.  The design principles most relevant to coding are:</p>
<ul>
<li>
<p>tools should minimize demands on our attention</p>
<p>Interruptions and intrusions on our attention break us out of flow state.</p>
</li>
<li>
<p>tools should be built to be “pass-through”</p>
<p>A tool is not meant to be the object of our attention; rather the tool should <em>reveal</em> the true object of our attention (the thing the tool acts upon), rather than obscuring it.  The more we use the tool the more the tool fades into the background of our awareness while still supporting our work.</p>
</li>
<li>
<p>tools should create and enhance calm (thus the name: calm technology)</p>
<p>A state of calm helps users enter and maintain flow state.</p>
</li>
</ul>
<h2>Non-LLM examples of calm technology</h2>
<p>Engineers already use “calm” tools and interfaces as part of our work and here are a couple of examples you&#39;re probably already familiar with:</p>
<h3>Inlay hints</h3>
<p>IDEs (like VSCode) can support <a href="https://code.visualstudio.com/docs/typescript/typescript-editing#_inlay-hints">inlay hints</a> that sprinkle the code with useful annotations for the reader, such as inferred type annotations:</p>
<p><img src="https://haskellforall.com/imgs/beyond-agentic-coding/inlay-hints.png" alt=""/></p>
<p>These types of inlay hints embody calm design principles because:</p>
<ul>
<li>
<p>they minimize demands on our attention</p>
<p>They exist on the periphery of our attention, available for us if we&#39;re interested but unobtrusive if we&#39;re not interested.</p>
</li>
<li>
<p>they are built to be “pass-through”</p>
<p>They don&#39;t replace or substitute the code that we are editing.  They enhance the code editing experience but the user is still in direct contact with the edited code.  The more we use type hints the more they fade into the background of our awareness and the more the code remains the focus of our attention.</p>
</li>
<li>
<p>they create and enhance calm</p>
<p>They promote a sense of calm by informing our understanding of the code <strong>passively</strong>.  As one of the <a href="https://calmtech.com/">Calm Technology</a> principles puts it: <em>“Technology can communicate, but doesn&#39;t need to speak”.</em></p>
</li>
</ul>
<h3>File tree previews</h3>
<p>Tools like VSCode or GitHub&#39;s pull request viewer let you preview at a glance changes to the file tree, like this:</p>
<p><img src="https://haskellforall.com/imgs/beyond-agentic-coding/file-tree-1.png" alt=""/></p>
<p>You might think to yourself “this is a very uninteresting thing to use as an example” but that&#39;s exactly the point.  The best tools (designed with the principles of calm technology) are pervasive and <strong>boring</strong> things that we take for granted (like light switches) and that have faded so strongly into the background of our attention that we forget they even exist as a part of our daily workflow (also like light switches).</p>
<p>File tree previews:</p>
<ul>
<li>
<p>minimize demands on our attention</p>
<p>They&#39;re there if we need the information, but easy to ignore (or even forget they exist) if we don&#39;t use them.</p>
</li>
<li>
<p>are built to be “pass-through”</p>
<p>When we interact with the file tree viewer we are interacting directly with the filesystem and the interaction between the representation (the viewer) and the reality (the filesystem) feels direct, snappy, and precise.  The more we use the viewer the more the representation becomes indistinguishable from the reality in our minds.</p>
</li>
<li>
<p>create and enhance calm</p>
<p>We do not need to constantly interact with the file tree to gather up-to-date information about our project structure.  It passively updates in the background as we make changes to the project and those updates are unobtrusive and not attention-grabbing.</p>
</li>
</ul>
<h2>Chat-based coding agents are not calm</h2>
<p>We can think about the limitations of chat-based agentic coding tools through this same lens:</p>
<ul>
<li>
<p>they place high demands on our attention</p>
<p>The user has to either sit and wait for the agent to report back or do something else and run the LLM in a semi-autonomous manner.  However, even semi-autonomous sessions prevent the user from entering flow state because they have to remain interruptible.</p>
</li>
<li>
<p>they are not built to be “pass-through”</p>
<p>Chat agents are a highly mediated interface to the code which is <strong>indirect</strong> (we interact more with the agent than the code), <strong>slow</strong> (we spend a lot of time waiting), and <strong>imprecise</strong> (English is a <a href="https://www.cs.utexas.edu/~EWD/transcriptions/EWD06xx/EWD667.html">dull interface</a>).</p>
</li>
<li>
<p>they undermine calm</p>
<p>The user needs to constantly stimulate the chat to gather new information or update their understanding of the code (the chat agent doesn&#39;t inform the user&#39;s understanding passively or quietly).  Chat agents are also fine-tuned to maximize engagement.</p>
</li>
</ul>
<h2>Prior art for calm design</h2>
<h3>Inline suggestions from GitHub Copilot</h3>
<p>One of the earliest examples of an AI coding assistant that begins to model calm design principles is the OG AI-assistant: <a href="https://code.visualstudio.com/docs/copilot/ai-powered-suggestions">GitHub Copilot&#39;s support for inline suggestions</a>, with some caveats I&#39;ll go into.</p>
<p><img src="https://haskellforall.com/imgs/beyond-agentic-coding/inline-suggestions.png" alt=""/></p>
<p>This does one thing really well:</p>
<ul>
<li>
<p>it&#39;s built to be “pass-through”</p>
<p>The user is still interacting directly with the code and the suggestions are reasonably snappy.  The user can also ignore or type through the suggestion.</p>
</li>
</ul>
<p>However, by default these inline suggestions violate other calm technology principles:</p>
<ul>
<li>
<p>they demand our attention</p>
<p>By default Copilot presents the suggestions quite frequently and the user has to pause what they&#39;re doing to examine the output of the suggestion.  After enough times the user begins to condition themselves into regularly pausing and waiting for a suggestion which breaks them out of a flow state.  Now instead of being proactive the user&#39;s been conditioned by the tool to be reactive.</p>
</li>
<li>
<p>they undermine calm</p>
<p>GitHub Copilot&#39;s inline suggestion interface is visually busy and intrusive.  Even if the user ignores every suggestion the effect is still disruptive: suggestions appear on the user&#39;s screen in the center of their visual focus and the user has to decide on the spot whether to accept or ignore them before proceeding further.  The user also can&#39;t easily passively absorb information presented in this way: understanding each suggestion requires the user&#39;s focused attention.</p>
</li>
</ul>
<p>… <em>buuuuut</em> these issues are partially fixable by disabling the automatic suggestions and requiring them to be explicitly triggered by <code>Alt</code> + <code>\</code>.  However, unfortunately that also disables the next feature, which I like even more:</p>
<h3>Next edit suggestions (also from GitHub Copilot)</h3>
<p><a href="https://code.visualstudio.com/docs/copilot/ai-powered-suggestions#_next-edit-suggestions">Next edit suggestions</a> are a related GitHub Copilot feature that display related follow-up edits throughout the file/project and let the user cycle between them and possibly accept each suggested change.  They behave like a “super-charged find and replace”:</p>
<video controls="" preload="metadata" playsinline="">
  <source src="https://code.visualstudio.com/assets/docs/copilot/inline-suggestions/nes-video.mp4" type="video/mp4"/>
</video>
<p>These suggestions do an amazing job of keeping the user in a flow state:</p>
<ul>
<li>
<p>they minimize demand on the user&#39;s attention</p>
<p>The cognitive load on the user is smaller than inline suggestions because the suggestions are more likely to be bite-sized (and therefore easier for a human to review and accept).</p>
</li>
<li>
<p>they&#39;re built to be “pass-through”</p>
<p>Just like inline suggestions, next edit suggestions still keep the user in close contact with the code they are modifying.</p>
</li>
<li>
<p>they create and enhance calm</p>
<p>Suggestions are presented in an unobtrusive way: they aren&#39;t dumped in the dead center of the user&#39;s attention and they don&#39;t demand immediate review.  They exist on the periphery of the user&#39;s attention as code suggestions that the user can ignore or focus on at their leisure.</p>
</li>
</ul>
<h2>AI-assisted calm technology</h2>
<p>I believe there is a lot of untapped potential in AI-assisted coding tools and in this section I&#39;ll sketch a few small examples of how we can embody calm technology design principles in building the next generation of coding tools.</p>
<h3>Facet-based project navigation</h3>
<p>You could browse a project by a tree of semantic facets.  For example, if you were editing <a href="https://github.com/dhall-lang/dhall-haskell">the Haskell implementation of Dhall</a> the tree viewer might look like this prototype I hacked up<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>:</p>
<video controls="" preload="metadata" playsinline="">
  <source src="/imgs/beyond-agentic-coding/semantic-facets.mp4" type="video/mp4"/>
</video>
<p>The goal here is to not only provide a quick way to explore the project by intent, but to also improve the user&#39;s understanding of the project the more they use the feature.  &#34;String interpolation regression&#34; is so much more informative than <code>dhall/tests/format/issue2078A.dhall</code><sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup>.</p>
<p>Also, the above video is based on a real tool and not just a mock.  You can find the code I used to generate that tree of semantics facets <a href="https://github.com/Gabriella439/facet-navigator">here</a> and I&#39;ll write up another post soon walking through how that code works.</p>
<h3>Automated commit refactor</h3>
<p>You could take an editor session, a diff, or a pull request and automatically split it into a series of more focused commits that are easier for people to review.  This is one of the cases where the AI can <em>reduce</em> human review labor (most agentic coding tools <em>create</em> more human review labor).</p>
<p>There is <a href="https://softwareengineering.stackexchange.com/questions/458416/how-to-decompose-a-large-git-commit-with-an-ai">some prior art here</a> but this is still a nascent area of development.</p>
<h3>File lens</h3>
<p>You could add two new tools to the user&#39;s toolbar or context menu: <em>“Focus on…”</em> and <em>“Edit as…”.</em></p>
<p><em>“Focus on…”</em> would allow the user to specify what they&#39;re interested in changing and present only files and lines of code related to their specified interest.  For example, if they want to focus on “command line options” then only related files and lines of code would be shown in the editor and other lines of code would be hidden/collapsed/folded.  This would basically be like “Zen mode” but for editing a feature domain of interest.</p>
<p><em>“Edit as…”</em> would allow the user to edit the file or selected code as if it were a different programming language or file format.  For example, someone who was new to Haskell could edit a Haskell file “as Python” and then after finishing their edits the AI attempts to back-propagate their changes to Haskell.  Or someone modifying a command-line parser could edit the file “as YAML” and be presented with a simplified YAML representation of the command line options which they could modify to add new options.</p>
<h2>Conclusion</h2>
<p>This is obviously not a comprehensive list of ideas, but I wrote this to encourage people to think of more innovative ways to incorporate AI into people&#39;s workflows besides just building yet another chatbot.  I strongly believe that <a href="https://haskellforall.com/2026/01/chat-is-least-interesting-interface-to">chat is the least interesting interface to LLMs</a> and AI-assisted software development is no exception to this.</p>
</div></div>
  </body>
</html>
