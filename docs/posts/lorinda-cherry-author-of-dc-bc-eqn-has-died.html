<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ncwit.org/profile/lorinda-cherry/">Original</a>
    <h1>Lorinda Cherry, author of dc, bc, eqn has died</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<p>In which we ponder the Functional Nature of Life, The Universe, and Everything.
Please feel free to follow through the weeds, or jump straight to the bottom
for my 2 nano BTC on the matter. (Or my current state of mind, at any rate.)</p>
<p>Disclaimer: I live in the Land of Lisp, meditate in the Church of Alonzo, and
am ever-wary of The State. Only converts <em>might</em> find some entertainment value.</p>
<blockquote>
<p><em>“For the love of State is the root of all evil: which while some coveted after,</em>
<em>they have erred from Lambda the Ultimate, and pierced themselves through with</em>
<em>many sorrows.&#34;</em></p>
</blockquote>
<ul>
<li><a href="#is-it-already-suffusing-your-very-being">Is it already suffusing your very being?</a></li>
<li><a href="#is-it-mathematics">Is it Mathematics?</a></li>
<li><a href="#is-it-being-declarative">Is it being “declarative”?</a></li>
<li><a href="#is-it-being-data-oriented">Is it being “data-oriented”?</a></li>
<li><a href="#is-it-about-statelessness">Is it about “Statelessness”?</a></li>
<li><a href="#is-it-about-managed-environments">Is it about “managed” environments?</a></li>
<li><a href="#is-it-about-following-some-discipline-and-maybe-automating-it">Is it about following some discipline, and maybe automating it?</a></li>
<li><a href="#my-2-nano-btc-on-the-matter">My 2 nano BTC on the matter</a></li>
</ul>
<hr/>
<h2 id="is-it-already-suffusing-your-very-being">Is it already suffusing your very being?<a href="#is-it-already-suffusing-your-very-being" arialabel="Anchor">⌗</a> </h2>
<p>Because so-called “Functional Programming” started becoming pretty sexy over
the 2010s. By the 2020s, it started infiltrating all the things, small and big
and hyperscaled.</p>
<p>Now you can’t get people to shut up about their declarative infrastructure-as-code
as-YAML microservices-first infinitely elastic shared-nothing event-sourced
map-reducing lambda architecture marvels.</p>
<p>Now your VCs and your board nod sagely when these words flash past in your slick
OKR plan vision strategy slide decks. Now they further <em>“Hey, quick question”</em>
you to same-page on your strategy for blockchain and smart contracts. And
general web3 readiness. So does every novice hire it seems, no matter their role.</p>
<p>Now—and be honest, OK?—don’t you feel like everybody should just mentally
lie down for a few minutes in their metaverse, pass around the meta-ayahuasca,
and after the purge just ask simple meta-questions about FP and life for a
change? Because, for the love of lambda, we haven’t even gotten a breather
from the fast-nearing AI supremacy?</p>
<p>No? OK, consider the following incomplete list of traits commonly attributed
to the “Functional” paradigm of programming languages and of systems. Alongside,
consider:</p>
<ul>
<li>Which traits does your pet programming language (or system) provide by default?</li>
<li>Which traits do you create yourself in your programs (and systems)?</li>
<li>Which traits draw the hard line between “Functional” and other kinds of
programs (and systems)?</li>
<li>Which traits <em>really</em> matter?</li>
<li>Why would you even want any of it in the first place?</li>
</ul>
<p>And will we really achieve world domination with FP? (Yes, we will.)</p>
<h2 id="is-it-mathematics">Is it Mathematics?<a href="#is-it-mathematics" arialabel="Anchor">⌗</a> </h2>
<p>Is it about writing “pure” functions?</p>
<p>This is a bit of a tautology. A function is “pure” by definition. It specifies
a fixed mapping of an input domain to an output domain. When invoked, it
changes nothing about the state of the world. Which begs the question, how can
a thing that <em>does</em> nothing be computationally useful? (Spoiler: it isn’t in
isolation, unless of course, you figure out a way to use the computational
uselessness to turn staggeringly larger amounts of electricity into progressively
smaller fragments of your imagination, on a blockchain somewhere). But I digress…</p>
<p>Must we further also have “first-class” functions?</p>
<p>Ones that we can pass around as values? This lets us describe all manner of
deferred computations, including un-computable absurdities like infinite sequences,
and partial applications that will sit around forever if we don’t complete them.</p>
<p>And do we absolutely <em>need</em> the solid ground of Lambda Calculus or Category
Theory to <em>pre-exist</em>?</p>
<p>That’s an easy one to refute, but these things have become rather holy grail-y
now. If you don’t know your monad laws, I’m sorry you’re not permitted near
functions any more. Oh, and what about proofs? These are in the process of
holy-grailing too…</p>
<h2 id="is-it-being-declarative">Is it being “declarative”?<a href="#is-it-being-declarative" arialabel="Anchor">⌗</a> </h2>
<p>Reduce/ravel/plan/derive/goal-seek?</p>
<p>To be “declarative” is to want to write down a set of constraints or rules
or input-output relationships, and leave it to the system to figure out not
only <em>what operations</em> to perform, but also <em>how</em> and <em>when</em> to perform them.</p>
<p>The declarative world is thrice-removed from the “procedural” world, where we
have to tell the computer the what, how, and when in excruciating detail.</p>
<p>SQL, Prolog, APL are seen as “highly declarative” languages. CSS is also a
highly declarative language (which, I feel, is why people have a really hard
time with it—CSS is a <em>constraint mechanism</em> but our minds are strongly
conditioned for procedural thinking).</p>
<p>And maybe AI is the currently-ultimate expression of being “declarative”. We
declare that we don’t even know what to declare, and write a meta-declaration
and hope to Lambda that it will figure out the declaration that we should have
fed to the computer in the first place.</p>
<h2 id="is-it-being-data-oriented">Is it being “data-oriented”?<a href="#is-it-being-data-oriented" arialabel="Anchor">⌗</a> </h2>
<p>viz., choosing to work in terms of inert “literal” entities like JSON or EDN
or XML or some structured binary encoding, instead of “live” objects with
internal state? Asynchronous message-passing instead of synchronous remote
procedure calls (whether through object graphs, or across computer networks)?</p>
<p>Is it about adhering to the principle of referential transparency; i.e. the
equivalence of evaluated functions and literal data?</p>
<h2 id="is-it-about-statelessness">Is it about “Statelessness”?<a href="#is-it-about-statelessness" arialabel="Anchor">⌗</a> </h2>
<p>No machine registers? No place-oriented “mutable” state? No pointers? No
shared references? No side effects? Yes laziness? Yes append-only storage?
Yes event sourcing?</p>
<h2 id="is-it-about-managed-environments">Is it about “managed” environments?<a href="#is-it-about-managed-environments" arialabel="Anchor">⌗</a> </h2>
<p>Language mechanisms that relieve us of the burden and perils of malloc/free?</p>
<p>Garbage collection? Immutable persistent data structures? Type-directed
compile-time memory access/use control? Multi-Version Concurrency Control?</p>
<p>Kubernetes?</p>
<h2 id="is-it-about-following-some-discipline-and-maybe-automating-it">Is it about following some discipline, and maybe automating it?<a href="#is-it-about-following-some-discipline-and-maybe-automating-it" arialabel="Anchor">⌗</a> </h2>
<p>viz. a <em>system</em> or a design philosophy of doing things, such as:</p>
<ul>
<li>An accountant-like state management practice.</li>
<li>Carefully manipulating state only when absolutely necessary.</li>
<li>Hard-wiring FP traits into a programming language / system.</li>
<li>Choosing a strict single-process, non-branching, forward-looping-only
method of flow control.</li>
<li>Having standard, highly general purpose compositional interfaces oriented
around streaming data flow?</li>
<li>Eiffel-like Design-By-Contract? (Which is surprisingly “functional”.)</li>
<li>Continuation-passing style?</li>
<li>… etc?</li>
</ul>
<h2 id="my-2-nano-btc-on-the-matter">My 2 nano BTC on the matter<a href="#my-2-nano-btc-on-the-matter" arialabel="Anchor">⌗</a> </h2>
<p>I think all of our popular programming systems are object-oriented <em>and</em>
imperative by default, whether explicitly or implicitly. Now they all seem
to be adding “functional” looking features too. But to me, the functional-ness
of a language (or a system) is not about the feature set, but fundamentally
about its default (automatic) relationship with The State (of the world).</p>
<p><strong>The “Object-Oriented” way</strong> inexorably pushes us to clone reality.</p>
<p>We ingest and manage as much state and behaviour as possible, in order to
emulate the world. This, by construction, requires us to operate based on
theories and assumptions (internal state) doomed to always lag and diverge
from reality. In other words, it’s a synchronization problem mixed with the
impossible ideal of wanting to make the actual run-time look like the apparent
run-time. Concurrency quickly reveals the difficulties of trying this.</p>
<p><strong>The “Imperative” way</strong> is more like doing open heart surgery.</p>
<p>We have to get in there and manually orchestrate control flow, interrupt things,
and get the whole of it to mutate in-place <em>while it is running</em>. The race
condition is always imminent—will we close first, or will it stop first?
We never <em>really</em> know if the seemingly routine procedure will cause something
totally unrelated to blow up in our faces this time around. Meanwhile we have
very sharp instruments in hand, and have to do a lot of it by <em>fingerspitzengefühl</em>
because half the time we literally can’t see where to cut or clamp or suture.
I didn’t train for this but I hope you have. For at least 10 years. You have,
right? … Right?</p>
<p><strong>The “Functional” way</strong> wants to completely invert these models.</p>
<p>It tries to expel all system state from inside to the outside. In so doing, it
immerses itself in world-state and tries to be a new conduit for different
parts of outside reality to communicate, hoping to make it behave to our liking.
This, by construction, forces us to think explicitly in terms of events
(discrete sensing and sequencing of world updates, i.e. facts), messaging
(encoding and transmitting facts as data), and time (asynchronicity, consistency,
consensus).</p>
<p>The functional way is also totally different from how we experience the world.
The world is a concurrent, recurrent, parallel, fractal distributed system of
systems. And it is also stochastic and full of discontinuities. We have evolved
to form just-about-good-enough models of reality in our heads, in very bounded
contexts, to the extent necessary for survival. These internal models smooth
over all sorts of discontinuities, resist change while survival odds feel good,
and determine how we behave regardless of what might actually be out there.
We learn imperatively by poking and prodding the world around us while it hums
along. I think this is why it takes serious effort to learn the “functional”
way. We have to upend our entire mental model of how to do things in the world.</p>
<p><strong>Maybe pure data at rest</strong> is the only truly “functional” thing?</p>
<p>Maybe not. Like a pure function, pure data at rest does nothing and so is
useless to us when dormant. Besides, it is “pure” <em>only</em> for the duration
entropy permits its complete un-corrupted recovery. Ultimately, the laws of
Physics will always win. To muddy the waters a bit more, even the purest of
pure functional systems contain state; signals in flight or some in-progress
computation.</p>
<p>The only saving grace is that in a highly functional system, any run-time
state is entirely recoverable, reproducible, discrete, and isolated.</p>
<p><strong>All said, everything mutates sooner or later.</strong></p>
<p>I don’t know how to navigate this, except to remind myself about The Thing
That Actually Matters… to always remember that The State is the frenemy.</p>
<p>So while it pleases me that so many wish to eagerly embrace the Functional Way,
it is good to be soberly mindful of scopes, lifetimes, margins, error budgets,
and bounds of reality (state) and of data (information about reality). Good
situational awareness will lead us to build highly functional systems that
keep The State where it belongs, and still do useful things with it.</p>
<p>And all <em>that</em> said, I leave you with this prayer:</p>
<div><pre tabindex="0"><code data-lang="text">O Lambda the Ultimate,
bless the reader of these words.

That their core be functional,
and their functions be pure.

That their data be immutable,
so they may know the value of values.

That their systems be composable,
so they may grow and scale with grace.

That their States only mutate
in pleasantly surprising ways.

For otherwise nothing lives.
Nothing evolves.

In the name of the alpha,
the beta, and the eta...

(λx.x x) (λx.x x)
</code></pre></div>
</div></div></div>
  </body>
</html>
