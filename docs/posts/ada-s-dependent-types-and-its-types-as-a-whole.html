<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nytpu.com/gemlog/2024-12-27">Original</a>
    <h1>Ada&#39;s dependent types, and its types as a whole</h1>
    
    <div id="readability-page-1" class="page"><article>
			
			<h3>December 27, 2024 (Updated: December 27, 2024)</h3>
			<!-- automatically generated by gemroff <https://git.sr.ht/~nytpu/gemroff/> -->
<p>So I like to joke occasionally on the Fediverse that when looking at Wikipedia&#39;s <a href="https://en.wikipedia.org/wiki/Dependent_type#Comparison_of_languages_with_dependent_types">list of programming languages supporting dependent types</a>:</p>
<blockquote>
<p>It&#39;s tons of extremely complex functional languages, formal theorem provers, and… Ada, a random Government Language dating back to 1983.</p>
<p>Also you&#39;ll note that at no point in any Ada documentation anywhere do they feel the need to bring up set theory or the λ cube when explaining how dependent types work :P</p>
</blockquote>
<p>I just love the juxtaposition of the highly formalized academic/research/for-fun languages with a very bureaucratic-feeling language whose design philosophy is very similar to COBOL&#39;s.<sup id="fnref:1"><a href="#fn:1">1</a></sup></p>
<p>But then I&#39;ll usually get one of a few functional programmers/type theory people that follow me to ask about Ada&#39;s dependent types, and this time I felt the motivation to write a big post explaining dependent types in Ada. And I really want to illustrate how how the designers were really just trying to achieve a specific goal, and coincidentally their solution meets the formal definition of dependent types.</p>
<p>Note that I&#39;m really not knowledgeable about functional programming or type theory at all so I can&#39;t really speak much about it, although I am fairly skilled with Ada.</p>

<h2 id="adas-dependent-types">Ada&#39;s Dependent Types</h2>

<p>First-off, for context here&#39;s a very simplified summary of what I&#39;m talking about since it is a rare feature: dependent types are just <q>types that depend on some concrete value</q>. So, for example, a structure with an array field whose length depends on another field in the struct—one of the primary applications of Ada&#39;s dependent types<sup id="fnref:2"><a href="#fn:2">2</a></sup>.</p>
<p>I also need to touch on one of Ada&#39;s design philosophies, which is to avoid dynamic allocation unless actually necessary for safety reasons, since it doesn&#39;t have a borrow checker for fully-safe allocation like Rust does<sup id="fnref:3"><a href="#fn:3">3</a></sup>. The key problem is that when you use one single call stack to both store return addresses and local variables, a called function can&#39;t return the contents of one of its stack-allocated variables <q>upwards</q> because the callee needs to be able to pop off the return address and have the stack pointer be precisely where it was before it got called. Instead, any larger-than-register returned value has to have its stack slots be allocated by the caller, <em>with a size known to the caller</em>. Ada solves this by having a second non-call stack<sup id="fnref:4"><a href="#fn:4">4</a></sup> that functions can allocate compile-time unknown space on and return that upward, without needing dynamic allocation and preserving the nice scoping and free lexical deallocation that a stack provides. The only time you really need dynamic allocation in Ada is when you&#39;re interworking with C/C++/Fortran/COBOL<sup id="fnref:5"><a href="#fn:5">5</a></sup>, or if you have an aggregate type that contains an object of unknown length, e.g. an array of strings, where you have to dynamically allocate all the strings and then the array of pointers can be handled like normal (Ada has a rich container library so it&#39;s rare you need to think about it at all). Allowing use of the second stack rather than dynamic allocation (i.e. avoiding needing a pointer elsewhere in order to encapsulate an undefined-length objects within another object) is a key motivator for one style of Ada&#39;s dependent types.</p>
<p><a href="https://nytpu.com/gemlog/2024-12-27-2">Here is an addendum detailing dynamic allocation and the secondary stack in much more detail.</a></p>

<p>And now an overview of Ada&#39;s type system because I feel them developing dependent types mostly-independently is really just a natural extension of its type system. If you&#39;re familiar with Ada already, I&#39;m just going over basic derived types and subtypes, discriminated records, and type predicates. And tangentially things like indefinite types and how they work with subprograms and being nested in other aggregate types.</p>
<p>Firstly, Ada&#39;s type system was ahead of its time in 1983, in the sense that it&#39;s focused on modeling (and enforcing) the <em>intent</em> of the type, and letting the compiler do the work of mapping your intent to underlying machine types<sup id="fnref:6"><a href="#fn:6">6</a></sup>. So, for instance, while there is an <code>Integer</code> type that corresponds to some efficient machine integer like C&#39;s <code>int</code>, unless you need a generic integer you&#39;d typically prefer to do something like this (this is probably not an ideal way to represent a social security number, it&#39;s just an example):</p>
<pre>type Social_Security_Number is range 0 .. 999_99_9999;
</pre>
<p>This is a completely new numeric type, but you could also make it derived type of <code>Integer</code> to allow well-defined type conversions, (although the conversions would require an explicit typecast since they&#39;re distinct but compatible types. To avoid needing explicit casts you&#39;d use the <code>subtype</code> keyword instead of <code>type</code>).</p>
<p>As an extension of that, arrays allow using arbitrary integer types as their indices. They actually don&#39;t need to start at 0 or 1 or anything, they can use any bounds that make the most sense for your application (with the main caveat being that you have to use <code>Arr&#39;First</code> &amp; <code>Arr&#39;Last</code> or <code>Arr&#39;Range,</code> rather than being able to just go from 0 to <code>Arr&#39;Length - 1</code>). So, for instance, here&#39;s an array type:</p>
<pre>type My_Integer is range -20 .. 20;
type My_Array_Constrained is array (My_Integer) of Whatever_Type;
</pre>
<p>Or, more concisely if the integer type isn&#39;t needed anywhere outside of the array type:</p>
<pre>type My_Array_Constrained is array (-20 .. 20) of Whatever_Type;
</pre>

<p>But that&#39;s fairly limiting, because instances of <code>My_Array</code> must always be exactly 41 elements long with bounds from -20 to 20. So you can make an array with bounds determined at instantiation instead of at the type declaration:</p>
<pre>type My_Integer is range -20 .. 20;
type My_Array is array (My_Integer range &lt;&gt;) of Whatever_Type;
</pre>
<p><code>&lt;&gt;</code> is called <q>box</q> and is used all over Ada as a placeholder for some unknown thing (e.g. a placeholder type in generics). Any specific instance of <code>My_Array</code> can have arbitrary lower and upper bounds as long as they&#39;re contained within the range of <code>My_Integer</code>.</p>
<p>To use that type, you could make an instance like this:</p>
<pre>Arr_1 : My_Array(-15 .. -5);
Arr_2 : My_Array := (11 =&gt; 0, 12 =&gt; 1, 13 =&gt; 2, 14 =&gt; 3); -- implicitly determined length and bounds
</pre>
<p>It should be noted that while these instances are descendants of <code>My_Array</code>, they are still distinct types that are implicitly created on-the-fly, and are unnamed. You could declare it a new named type instead if you wanted:</p>
<pre>type My_Array_Constrained is new My_Array(-15 .. -5);
Arr_1 : My_Array_Constrained;
</pre>
<p>Both declarations of <code>Arr_1</code> are nearly equivalent, except the second one has a named type and could be easily assigned to another instance of <code>My_Array_Constrained</code> without explicitly copying slices of the same length.</p>
<p>And now we already technically have dependent types, because arrays with indefinite bounds can be created based off of a function parameter or other compile-time unknown value. For example (this is being excessively explicit about named types to prove it&#39;s true dependent typing):</p>
<pre>type My_Integer is range -20 .. 20;
type My_Array is array (My_Integer range &lt;&gt;) of Integer;
subtype My_Length is My_Integer range 0 .. My_Integer&#39;Last; -- Technically unnecessary

function Make_Array (Len : My_Length) return My_Array is
   -- Declarative area, where all of the local variables and types and nested
   -- functions and whatever would be declared

   -- Make a subtype using the provided length.  Will raise an exception if
   -- the upper bound is outside of the range of My_Integer.
   subtype Dynamically_Created_Array is My_Array(My_Integer&#39;First .. My_Integer&#39;First + Len);

   -- Create an instance of that subtype with all-zero contents.
   Arr : Dynamically_Created_Array := (others =&gt; 0);
begin
   -- Function body, where the procedural stuff is done.  Presumably we
   -- would do some processing here rather than just returning the array.
   -- Returning Dynamically_Created_Array is safe because it&#39;s a compatible
   -- subtype of My_Array.
   return Arr;
end Make_Array;
</pre>

<p>But of course there&#39;s more, what if you want to use <code>My_Array</code> inside of a record (Ada&#39;s term for a structure)? You could just have one of a fixed length of course:</p>
<pre>type My_Record_Constrained is record
   Field : My_Array(-15 .. -5);
end record;
</pre>
<p>And note that that Field&#39;s length can be computed at runtime if you need, just by using a function to compute one or both bounds instead of specifying literals. But all instances of <code>My_Record_Constrained</code> in the entire program would still have the same sized field that&#39;s only calculated once, at program startup<sup id="fnref:7"><a href="#fn:7">7</a></sup>.</p>
<p>It&#39;d be really convenient to keep the flexibility to determine the size at instantiation time like we have with standalone arrays. So there&#39;s the concept of <q>discriminants</q>, which are like standard record fields but are treated specially and can be depended on by the types of normal fields of the record. For instance:</p>
<pre>type My_Record (Top : My_Integer) is record
   Field : My_Array(My_Integer&#39;First .. Top);
end record;
</pre>
<p><code>My_Integer&#39;First</code> gives the lowest valid value for the integer type. <code>Top</code> can be read like any other record field but you can&#39;t modify it after the type is instantiated since that would require reallocation and moving stuff around if there were fields before and after the discriminated array. You&#39;d declare an instance like this to make <code>Rec.Field</code> have bounds from -20 to -5:</p>
<pre>Rec : My_Record(-5);
</pre>

<p>That example could be extended with a second discriminant to allow defining both the start and end bounds, etc. And there, that&#39;s it, that&#39;s also a dependent type! There is an implicit unnamed type that&#39;s recognized by the type system, that depends on a value at runtime. There&#39;s other things you can do rather than just using the discriminant as the length of an array. And you can do things like have an embedded record whose discriminant depends on a discriminant in the outer record and such. And there&#39;s also <q>variant records</q> which are just tagged unions where the tag (any signed/unsigned integer or enumeration type) is declared in the same place as the discriminant is above.</p>
<p>But Ada 2012 introduced even more capable dependent types as part of its <a href="https://en.wikipedia.org/wiki/Design_by_contract">design by contract system</a><sup id="fnref:8"><a href="#fn:8">8</a></sup>. Say you want to allow <code>My_Record</code> to specify both the lower and upper bounds as discriminants. Well, you can just do that, even though the instantiator could specify a lower bound that&#39;s greater than the upper bound, that&#39;s fine because in Ada that&#39;s just how you make an array with a length of 0. But say, in a contrived example, that you always want at least one element. You could add a type predicate, which is I think is somewhat analogous to what theorem provers would call <q>tactics</q>? You provide an expression acting on the value of the type and will be enforced as being true either at compile-time (for static predicates) or at runtime (for dynamic predicates). For example:</p>
<pre>type My_Record (Top, Bottom : My_Integer) is record
   Field : My_Array(Bottom .. Top);
end record
   with Dynamic_Predicate =&gt; Bottom &lt;= Top;
</pre>

<p>Or you could not use discriminants at all:</p>
<pre>type Pair is record
   A, B : Integer;
end record
   with Dynamic_Predicate =&gt; B &gt; A;
</pre>

<p>Type predicates and invariants (and also function pre/postconditions) are great for non-dependent type uses too, but that&#39;s getting too off-topic for this already plodding post. Although it is neat to be able to do things like</p>
<pre>type Even is new Integer
   with Dynamic_Predicate =&gt; Even mod 2 = 0;
</pre>
<pre>type Day_Of_Week is (Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday);
subtype Weekday is Day_Of_Week range Monday .. Friday;
-- Filthy Americans creating this problem for themselves
subtype Weekend is Day_Of_Week
   with Static_Predicate =&gt; Weekend in Saturday | Sunday;
</pre>


<h2 id="the-strange-interplay-between-academic-languages-and-business-languages">The Strange Interplay Between “Academic Languages” and “Business Languages”</h2>

<p>Something I find very interesting is that there&#39;s a strange interplay between a very get-things-done oriented language like SPARK (the formally verified subset of Ada) which wants to verify correctness in a program, and functional programming theory that provides ways to reason about the correctness of programs. And yet functional programming languages themselves nor the theory directly isn&#39;t suited for what SPARK does, because they prefer purity and usefulness <em>for developing the theory further</em> over things like allowing side-effects in a way that doesn&#39;t confuse imperative programmers (*cough*​monads​*cough*) or the compiled code being efficient enough for low-power embedded targets.</p>
<p>Note that I&#39;m not implying that functional programming languages can&#39;t <q>get things done</q>, they just tend to be focused on different goals than Ada and SPARK are. Because if you&#39;re interested in the theory why would you care about the small set of high-integrity embedded developers over being able to express what you need to in the most natural way possible? And similarly, SPARK had concrete requirements for a specific set of tasks different from what academics want, and it just happened that theorem provers and FP theory can be applied to those problems to great effect.</p>
<p>I feel somewhat like this with Ada as a whole. Really, lots of its type system often stumbles across interesting concepts in type theory, but just from them reaching for some goal of correctness or flexibility rather than because of actual type theory. Although I haven&#39;t had more than a casual IRC chat with any of the standardizers so maybe they did actually get their ideas directly from type theory and just fit them into a non-academic language, rather than stumbling across the concept like I hypothesize here.</p>
<ol>
<li id="fn:1" value="1"><p>Like, Ada&#39;s entire design is basically the U.S. DoD making a <a href="https://en.wikisource.org/wiki/Steelman_language_requirements">list of requirements that they considered mandatory for a high-integrity, embedded programming language</a>, and then paying government contractors to design a language meeting those requirements, without caring if it&#39;s <q>fun</q> or <q>breaking new ground</q> or <q>mathematical purity</q>. Not that that&#39;s necessarily a good design philosophy, it just makes the language very different from many; and is what reminds me of COBOL which was made similarly: businesses designing a language to their requirements without regard for any of the things academic computer scientists of the time cared about. <a href="#fnref:1">↩︎</a></p></li>
<li id="fn:2" value="2"><p>And a natural extension of C&#39;s flexible array members if their length was enforced to match to the field in the struct storing it. <a href="#fnref:2">↩︎</a></p></li>
<li id="fn:3" value="3"><p>SPARK, the formally verified subset of Ada, does have a borrow checker though! <a href="#fnref:3">↩︎</a></p></li>
<li id="fn:4" value="4"><p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/ada/libgnat/s-secsta.adb;hb=HEAD#l39">Comments in the GCC GNAT source code</a> and some <a href="https://docs.adacore.com/gnat_ugx-docs/html/gnat_ugx/gnat_ugx/the_stacks.html#the-secondary-stack">documentation on configuring the second stack for embedded targets</a> is the only real documentation on how the second stack works in detail that I know of. Probably because while I consider it a brilliant solution, the secondary stack is actually an implementation detail and the standard just mandates <q>you have to be able to return indefinite types</q>. An implementation could in theory dynamically allocate and insert malloc and free calls appropriately in the caller and callee code. <a href="#fnref:4">↩︎</a></p></li>
<li id="fn:5" value="5"><p>The Ada specification has official, albeit optional-to-implement, APIs for interfacing with all of those languages lol <a href="#fnref:5">↩︎</a></p></li>
<li id="fn:6" value="6"><p>Not relevant to the point I&#39;m making in this post, but if in a given application you do care about the machine types, there is a whole featureset of <q>representation clauses</q> that allow you to very precisely state the underlying size and layout of a primitive type, array, or structure/record. The compiler will generate the required bit-shifts and masks for you when reading or writing fields of an object of that type, and the specified representation is always how it&#39;s stored in memory and doesn&#39;t need a separate (de)serialization step, making it convenient for memory-mapped I/O (since Ada also lets you specify the precise address of a variable without needing pointers or poking the linker directly).</p>
<p>These features, amongst a few others similarly intended for easy low-level programming, are actually the main reason I personally use Ada since their convenience and simplicity is unmatched in any other programming language in existence AFAIK. <a href="#fnref:6">↩︎</a></p></li>
<li id="fn:7" value="7"><p>To be precise: it is calculated when the <q>elaboration code</q> for the package containing that type is called, which is typically but not always at program startup or when dlopened; but may be at any point prior to the containing package or any dependent package being used. The precise point and order in which elaboration is performed is determined by the <q>binder</q> and may be delayed from program startup if the main() is overridden to be a program in some other language rather than the entrypoint emitted by the binder. <a href="#fnref:7">↩︎</a></p></li>
<li id="fn:8" value="8"><p>The other main thing that I love about the language <a href="#fnref:8">↩︎</a></p></li>
</ol>
		</article></div>
  </body>
</html>
