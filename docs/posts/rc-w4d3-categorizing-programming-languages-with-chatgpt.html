<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://payments.posthaven.com/rc-w4d3-getting-chatgpt-to-categorize-programming-languages">Original</a>
    <h1>RC W4D3 - Categorizing programming languages with ChatGPT</h1>
    
    <div id="readability-page-1" class="page"><div id="post_body_1950906">
    
      <div><p>In a prior <a href="https://payments.posthaven.com/rc-w4d1-expressiveness-vs-interpretability-in-programming-languages">post</a>, I shared a quote from Chelsea Troy comparing expressiveness vs interpretability in programming languages. I thought it would be interesting to get ChatGPT to categorize other languages based on this measure.</p><p>We start with Ruby being expressive (there&#39;s more than one way to do it) vs Python being interpretable (there should be one obvious way to do it). We continue on this rather simplistic thread. We get PHP and Perl in the expressive camp, Go in the interpretable camp.</p><p>Now ChatGPT seems to cop out with Rust, saying it’s emphasizes both expressiveness and interpretability. Functional languages like Haskell, Scala and Elixir are in this camp too. Then we have another camp of system languages that emphasize performance like C and Zig.</p><p>What’s also interesting is having this categorization in order of release date, here adding more languages. </p><ol>
<li>Emphasis on expressiveness: Prolog (1972), Perl (1987), Lua (1993), JavaScript (1995), PHP (1995), Ruby (1995)<br/>
</li>
<li>Emphasis on interpretability: COBOL (1959), Python (1991), Go (2009)</li>
<li>Both expressiveness and interpretability: Haskell (1990), OCaml (1996), Erlang (1998), Scala (2004), F# (2005), Elixir (2011), Rust (2010), Swift (2014)<br/>
</li>
<li>Less expressive and less interpretable: Fortran(1957), C (1972), C++ (1985), Java (1995), Kotlin (2011), Zig (2015)</li>
</ol><p>For funsies I got ChatGPT to divvy up languages into more groups <a href="https://gist.github.com/savarin/60b617f7394f7f2895e80310aea0e83c">here</a>. Note that &#39;interpretability&#39; changes meaning from &#39;easy for humans to parse&#39; with 4 camps to &#39;easy for machines to parse&#39; with 8 camps, more context <a href="https://gist.github.com/savarin/c59fcc3669a36751598e4c4555abe33f">here</a>.</p><p>In yesterday’s <a href="https://payments.posthaven.com/rc-w4d2-what-can-i-do-to-improve-my-python-skills">post</a> I shared David Beazley&#39;s advice on improving Python skills. Today I’m reminded of Peter Norvig’s <a href="https://norvig.com/21-days.html">advice</a> along the same thread.</p><blockquote><p>Learn at least a half dozen programming languages. Include one language that emphasizes class abstractions (like Java or C++), one that emphasizes functional abstraction (like Lisp or ML or Haskell), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), and one that emphasizes parallelism (like Clojure or Go).</p></blockquote><p>In the <a href="https://payments.posthaven.com/rc-w3d5-focusing-on-the-process">post</a> prior to yesterday, I wrote about wanting to learn how generative models work under the hood alongside functional languages. This feels more fun. This <a href="http://worrydream.com/LadderOfAbstraction/">caption</a> by Bret Victor encapsulates this desire to explore (also inspired by Chelsea Troy&#39;s <a href="https://chelseatroy.com/2019/11/02/sicp-introduction-on-learning-the-abstract/">post</a>).</p><blockquote>
<p>How do we explore? If you move to a new city, you might learn the territory by walking around. Or you might peruse a map. But far more effective than either is both together — a street-level experience with higher-level guidance.</p>
<p>Likewise, the most powerful way to gain insight into a system is by moving between levels of abstraction. Many designers do this instinctively. But it’s easy to get stuck on the ground, experiencing concrete systems with no higher-level view. It’s also easy to get stuck in the clouds, working entirely with abstract equations or aggregate statistics.</p>
</blockquote></div>
    
  </div></div>
  </body>
</html>
