<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://taconomical.com">Original</a>
    <h1>How economical is your local Taco Bell?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p><strong>Mypy</strong> is a typechecker for Python. It’s not the official typechecker for Python. There is no official typechecker. But Mypy seems to be the official-est. I use it, and it’s mostly pretty great.</p>

<p>Mypy has a <strong>bug</strong>. Big deal, lots of software has bugs. But this bug seems to have been deliberately chosen on the basis of some <strong>misguided code ideology</strong>. I think the ideology ought to be discarded and the bug ought to be fixed.</p>

<p>Before describing the bug, I would like to speak about <strong>static typing in Python</strong>. Python is renowned for how <a href="https://xkcd.com/353/">freeing</a> it feels. You can write some code and run it, just like that. Static typing, on the other hand, is often associated with the feeling of arbitrary restrictions. <em>Why does the compiler keep complaining, just let me run my code!</em> So it is sometimes thought that <strong>static typechecking runs counter to the spirit of Python</strong>.</p>

<p>But <strong>static typing remains totally optional</strong>. Everyone is free to write Python without declaring types and free to run it without checking anything. Of course, the freedom to run code without typechecking is a lot like the freedom to ride in a car without a seatbelt. <em>The freedom to encounter runtime type errors, so liberating!</em></p>

<p>No, I’m just kidding (somewhat). <strong>Freedom really is a valuable aspect of the Python experience.</strong> Users don’t want to be burdened with doing a bunch of paperwork before they can try something out. At the same time, some users would prefer to know about type errors before runtime, especially in already-existing Python codebases. Optional, incremental typechecking is a great way to balance freedom and correctness in Python.<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup></p>

<p><strong>Freedom is important in Python, get it?</strong> We’ll come back to this later. Okay, now on to the bug. Consider this code:</p>

<figure><pre><code data-lang="python"><span>from</span> <span>__future__</span> <span>import</span> <span>annotations</span>

<span>from</span> <span>random</span> <span>import</span> <span>randint</span>

<span>class</span> <span>WhatIsIt</span><span>:</span>
    <span>def</span> <span>__new__</span><span>(</span><span>cls</span><span>)</span> <span>-&gt;</span> <span>int</span> <span>|</span> <span>WhatIsIt</span><span>:</span>
        <span>if</span> <span>randint</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>):</span>
            <span>return</span> <span>object</span><span>.</span><span>__new__</span><span>(</span><span>cls</span><span>)</span>
        <span>else</span><span>:</span>
            <span>return</span> <span>5</span>

<span>def</span> <span>check</span><span>(</span><span>x</span><span>:</span> <span>WhatIsIt</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
    <span>assert</span> <span>isinstance</span><span>(</span><span>x</span><span>,</span> <span>WhatIsIt</span><span>)</span>

<span>x</span> <span>=</span> <span>WhatIsIt</span><span>()</span>

<span>check</span><span>(</span><span>x</span><span>)</span></code></pre></figure>

<p>What happens when <code>check(x)</code> is called? The function asserts that its argument is an instance of <code>WhatIsIt</code>. So if variable <code>x</code> is <em>not</em> a <code>WhatIsIt</code>, an <code>AssertionError</code> will be raised; otherwise, nothing will happen.</p>

<p>That variable <code>x</code> – what is it? Its value comes from the <code>WhatIsIt</code> constructor, so it must be a <code>WhatIsIt</code>, right?</p>

<p>Well, no. That constructor – <code>WhatIsIt.__new__</code> – usually returns an instance of <code>WhatIsIt</code>, but occasionally it returns an <code>int</code>. Notice that this is explicitly annotated in its return type: <code>int | WhatIsIt</code>.</p>

<p>According to its type annotations, the function <code>check</code> expects a <code>WhatIsIt</code> argument. So the call <code>check(x)</code> is a type error, since <code>x</code> could be an <code>int</code>. But Mypy doesn’t say anything about that. Instead, it raises a different warning:</p>

<figure><pre><code data-lang="nil">error: &#34;__new__&#34; must return a class instance (got &#34;int | WhatIsIt&#34;)  [misc]</code></pre></figure>

<p>It says that the <code>__new__</code> constructor “must” return a class instance. <strong><a href="https://nickdrozd.github.io/2020/04/23/idris-interfaces.html">“Must” is a funny word</a></strong>, straddling the distinction between “is” and “ought”. In this case, the “is” interpretation of “must” is literally false: it just simply is not the case that a constructor must return an instance of its class. As the example here shows, a constructor very much can return something else. <strong>So the “must” here seems to mean “ought”</strong>, as in “<code>__new__</code> <em>ought</em> to return a class instance”.</p>

<p>This is just an <strong>opinion</strong>. It’s a fine opinion to hold, and if a <strong>linter</strong> warned about this, there would be no problem. But the job of a typechecker is not to give opinions. A typechecker has just one job: analyze the types and warn about inconsistencies.</p>

<p>Okay, I guess Mypy is oddly opinionated about the practice of returning something other than a class instance from a class constructor. Just disable the warning then:</p>

<figure><pre><code data-lang="python"><span>class</span> <span>WhatIsIt</span><span>:</span>
    <span>def</span> <span>__new__</span><span>(</span><span>cls</span><span>)</span> <span>-&gt;</span> <span>int</span> <span>|</span> <span>WhatIsIt</span><span>:</span>  <span># type: ignore[misc]
</span>        <span>...</span></code></pre></figure>

<p>After this change, Mypy reports: <code>Success: no issues found in 1 source file</code>. But this is a <strong>false negative</strong>! There is a type error sitting right there! Apparently Mypy is so committed to its <strong>constructor-instance ideology</strong> that it refuses to do any further typechecking, <em>even when the constructor is clearly and correctly annotated</em>. This is a <strong>full-blown type-inference bug</strong>, and it ought to be fixed.</p>

<p>There is an opposing point of view that says: <em>the obvious thing for a constructor to do is to return an instance, and in fact that is what is actually done in practically all cases, and doing otherwise <strong>violates an overwhelmingly common assumption</strong></em>. But this argument itself violates an even more important tenent, namely <strong>Pythonic freedom</strong>.</p>

<p>Here is the reality of the situation: the <code>__new__</code> constructor can return anything. Regardless of what it <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__">“should”</a> return, Python allows for writing class constructors that can return whatever. <strong>That is the freedom of Python, and it is exactly why the language is so great.</strong> There is no good reason why this freedom should not be accomodated to as great an extant as possible.</p>



<ol>
  <li>Have you ever written a <code>__new__</code> constructor to return something other than a class instance? Did this lead to any confusion?</li>
  <li>Wait, what is <code>__new__</code>? Is that the same as <code>__init__</code>?</li>
  <li>How do other languages deal with constructors returning objects of different types?</li>
  <li>Python allows users to write and run code quickly. This often comes at the expense of all sorts of runtime errors. Is this actually a good trade-off?</li>
  <li>Is static typing in Python a good idea?</li>
</ol>



<p><sup><a id="fn.1" href="#fnr.1">1</a></sup> There is an argument against typechecking in Python that says typing is inappropriate because Python is a “scripting language”. But as far as I can tell, “scripting language” just means a language without static types. So this argument is patently circular and therefore very stupid.</p>

  </div></div>
  </body>
</html>
