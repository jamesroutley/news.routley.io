<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://news.ycombinator.com/item?id=38252963">Original</a>
    <h1>Show HN: Bitemporal â€“ Binary JSON database system and event store</h1>
    
    <div id="readability-page-1" class="page"><div><td colspan="2"></td><td><div><p>I had already posted the project a couple of years ago, and it gained some interest, but a lot of stuff has been done since then, especially regarding performance, a completely new JSON store, a REST API, various internals refactored, an improved JSONiq based query engine allowing updates, implementing set-oriented join optimizations, a now already dated web UI, a new Kotlin based CLI, a Python and TypeScript client to ease the use of Sirix... First prototypes from a precursor stem already from 2005.</p><p>So, what is it all about?</p><p>The system uses ideas from ZFS (a keyed index trie, storing checksums in parent pages...) and Git (a persistent index structure that shares unchanged pages between revisions) but appends new tree roots on each commit [1][2].</p><p>It is a JSON DBS. The system stores fine granular JSON nodes. Thus, there&#39;s almost no limit to the structure and size of an object. Objects can be arbitrarily nested, and updates are cheap.</p><p>On a high level, it supports space-efficient snapshots, tracking changes by an author / optional commit messages, time travel queries, reverting to previous revisions (while all revisions in-between still exist for audits...), or retrieving the changes of whole (sub)trees.</p><p>On the one hand, it&#39;s, thus, a bitemporal DBS, but on the other hand, it can be used as a simple event store. It stores the state after an event or a change occurs and tracks the changes.</p><p>Thus, an entity, a node in the JSON structure, can be updated to new values and eventually be removed while the history is easily retrievable, or we can easily revert to a previous state. The system assigns a unique ID to each new node, which never changes and is never reused (even after the deletion of the node). Thus, the system stores the state after the change/event and the event itself (the change event).</p><p>The leaf pages of the index structures are not simply copied during a write, but a sliding window algorithm is applied, such that only modified nodes and nodes that fall out of the sliding window have to be written. A predefined window length is configurable. The system avoids write-peaks, which would occur due to full snapshots and having to read a long chain of incremental changes in between.</p><p>Thus, it&#39;s best suited for fast flash drives with fast random reads and sequential writes. Data is never overwritten thus, audit trails are given for free.</p><p>Another aspect is that the system does not need a WAL (that is basically a second data store) due to atomic switches of a root index page and a single permitted read/write transaction (txn) concurrently and in parallel to N read-only txns, which are bound to specific revisions during the start. Reads do not involve any locks.[2]</p><p>A path summary, an unordered set of all paths to leaf nodes in the tree, is built and enables various optimizations. Furthermore, a rolling hash is optionally built, whereas all ancestor node hashes are adapted during inserts.</p><p>A dated Jupyter notebook with some examples can be found in [3], and overall documentation in [4].</p><p>The query engine[5] Brackit is retargetable (a couple of interfaces and rewrite rules have to be implemented for DB systems) and especially finds implicit joins and applies known algorithms from the relational DB systems world to optimize joins and aggregate functions due to set-oriented processing of the operators.[6]</p><p>I&#39;ve given an interview in [7], but I&#39;m usually very nervous, so don&#39;t judge too harshly.</p><p>Give it a try, and happy coding!</p><p>Kind regards</p><p>Johannes</p><p>[1] <a href="https://sirix.io" rel="nofollow noreferrer">https://sirix.io</a> | <a href="https://github.com/sirixdb/sirix">https://github.com/sirixdb/sirix</a></p><p>[2] <a href="https://sirix.io/docs/concepts.html" rel="nofollow noreferrer">https://sirix.io/docs/concepts.html</a></p><p>[3] <a href="https://colab.research.google.com/drive/1NNn1nwSbK6hAekzo1YbED52RI3NMqqbG#scrollTo=CBWQIvc0Ov3P" rel="nofollow noreferrer">https://colab.research.google.com/drive/1NNn1nwSbK6hAekzo1Yb...</a></p><p>[4] <a href="https://sirix.io/docs/" rel="nofollow noreferrer">https://sirix.io/docs/</a></p><p>[5] <a href="http://brackit.io" rel="nofollow noreferrer">http://brackit.io</a></p><p>[6] <a href="https://colab.research.google.com/drive/19eC-UfJVm_gCjY--koOWN50sgiFa5hSC" rel="nofollow noreferrer">https://colab.research.google.com/drive/19eC-UfJVm_gCjY--koO...</a></p><p>[7] <a href="https://youtu.be/Ee-5ruydgqo?si=Ift73d49w84RJWb2" rel="nofollow noreferrer">https://youtu.be/Ee-5ruydgqo?si=Ift73d49w84RJWb2</a></p></div></td></div></div>
  </body>
</html>
