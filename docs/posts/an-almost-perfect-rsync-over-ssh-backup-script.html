<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.zazu.berlin/software/a-almost-perfect-rsync-over-ssh-backup-script.html">Original</a>
    <h1>An almost perfect rsync over SSH backup script</h1>
    
    <div id="readability-page-1" class="page"><div>
			<p>Last updated on 25. Februar 2022 </p>			
<h2>Why and What</h2>



<p>Creating backups is a basic necessity for anyone who stores data. With the help of a dedicated server, the Linux operating system and the rsync software, you can securely and efficiently retrieve data from any computer via an SSH connection and store it in a backup. It doesn’t matter if there is another Linux server, a Mac or a Windows computer on the other side. But as soon as you have more than a few text files, you have to control the process precisely.</p>



<h2>A core script to start with</h2>



<p>The basic script comes from wiki.ubuntuusers.de page.</p>



<h3>The original script</h3>



<ol><li>It distinguishes between TOSSH and FROMSSH, i.e. whether the server fetches something or whether you push something to the backup server (TOSSH). In case of FROMSSH there are no access data on the computer to be backed up. Connection credentials to the backup are always the first target of encryption trojans, so it is better that the backup server fetches the data itself, i.e. it is the one that connects to the computer to be backed up -&gt; FROMSSH</li><li>It distinguishes between overwriting the folders with the day number every month or creating new folders with the full date as the name -&gt; MONTHROTATE</li><li>It can check if a volume to be backed up is connected to the computer via USB -&gt; MOUNTPOINT (I’m not using this.)</li><li>It can initiate the sending of a mail with the log of the backup process.</li><li>It can read from multiple sources/directories -&gt; array SOURCES</li><li>It can delete files that no longer exist in the source also in the backup.</li></ol>



<h3>How it works</h3>



<p>With a stored key (Use SSH keys and not passwords!) the backup server dials up the computer to be backed up via SSH (FROMSSH). There it compares the files on the volume to be backed up with what it has in the folder pointed to by the symlink with the name „last“. A new folder is then created from the number of the day (e.g. „02“) and all new or changed files are stored in it. On the already existing files a hardlink is created in the new folder, so that these are all „present“ in the new folder. Deleted files do not get a hardlink. If everything is ready, the symlink „last“ is now directed to the new folder. In the next month then simply the old folder with the same day number is overwritten with the current folder (MONTHROTATE).</p>



<h3>Disadvantages</h3>



<ol><li>If a rsync process takes longer than 24 h then the processes overlap and accumulate (the old one is not ready when a new one starts), block each other and nothing works anymore.</li><li>In large volumes with many files, the log files become so long that they no longer fit into an email and the email is then no longer sent.</li><li>If an error occurs then a symlink to the newly created folder with the current tag as name is created anyway. This leads to the fact that with the next backup the complete backup is transferred again. With several terabytes this can take a month of data transfer over the internet.</li><li>The backup server is only needed for a short time, but runs the whole day.</li></ol>



<h4><strong>Necessary enhancements</strong></h4>



<ol><li><strong>A code block that monitors the rsync traffic.</strong></li><li><strong>To keep track, a file that stores all log entries, one after the other, with only a few lines per entry -&gt; all-log</strong></li><li><strong>Ensuring that the new symlink is only set if the backup was successful</strong></li></ol>







<figure><a href="https://blog.zazu.berlin/wp-content/uploads/2022/02/backup-server-zazu-berlin-detail-cooler.jpg"><img loading="lazy" width="1024" height="512" src="https://blog.zazu.berlin/wp-content/uploads/2022/02/backup-server-zazu-berlin-detail-cooler-1024x512.jpg" alt="" srcset="https://blog.zazu.berlin/wp-content/uploads/2022/02/backup-server-zazu-berlin-detail-cooler-1024x512.jpg 1024w, https://blog.zazu.berlin/wp-content/uploads/2022/02/backup-server-zazu-berlin-detail-cooler-300x150.jpg 300w, https://blog.zazu.berlin/wp-content/uploads/2022/02/backup-server-zazu-berlin-detail-cooler-768x384.jpg 768w, https://blog.zazu.berlin/wp-content/uploads/2022/02/backup-server-zazu-berlin-detail-cooler-1536x768.jpg 1536w, https://blog.zazu.berlin/wp-content/uploads/2022/02/backup-server-zazu-berlin-detail-cooler.jpg 1920w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>big heat sink, less fans – zazu.berlin environmentally friendly backup server</figcaption></figure>







<h2>The complete advanced script with detailed explanation</h2>







<h3>Part 1</h3>



<pre><code>#!/bin/bash

# avoidng collisions with other rsync processes

# the minutes passed to the script 
# 21h*60min = 1260 minutes
minutes=1260

# Make sure no one else is using rsync
pro_on=$(ps aux | grep -c rsync)

# if someone is using rsync
# grep is also producing one entry so -gt 1

while [ $pro_on -gt 1 ]
  do
  sleep 60
  minutes=$(($minutes - 1))

# we are close to the next day no need to start
  if [ $minutes -lt 60 ] ; then
    exit 0
  fi

  pro_on=$(ps aux | grep -c rsync)
done</code></pre>



<p>This is the block to check if other rsync processes are running.</p>



<p><a href="https://distrowatch.com/weekly.php?issue=20120903">https://distrowatch.com/weekly.php?issue=20120903</a></p>



<p>This will also be used later to shut down the server during idle hours.<br/></p>



<ul><li>With the first line you say that the „bash“ should be entrusted with the execution.</li><li>„minutes=1260“ means that the postponement of a start of this script should be maximum 21 hours. After that the script will not be executed, because the cron process will start already the next round of backup.</li><li>„pro_on=$(ps aux | grep -c rsync)“, processes that are running, here „rsync“, the grep command itself also produces a process on the server itself, which is why you have to work with „-gt 1“ i.e. „greater than 1“.</li><li>After that it goes into a while loop which sleeps with „sleep 60“ for one minute each round and then checks if there is still more than one grep-rsync process running. The minutes are then always counted down by 1 and if one gets under 60 minutes until the 21 hours are over, then it is no longer worth running the script and „exit 0“ aborts. After that cron will try again at the regular time on the next day. This case occurs when another rsync process needs more than 20 hours.</li></ul>



<h3>Part 2</h3>



<pre><code># Simple backup with rsync
# local-mode, tossh-mode, fromssh-mode

SOURCES=(/Volumes/my_volume/ )
TARGET=&#34;/srv/backup_volume&#34;

# edit or comment with &#34;#&#34;
MONTHROTATE=monthrotate # use DD instead of YYMMDD
RSYNCCONF=(--delete 
--exclude=/Volumes/Raid/.DocumentRevisions-V100
--exclude=/Volumes/Raid/.TemporaryItems --exclude=/Volumes/Raid/.Trashes 
--exclude=/Volumes/Raid/.apdisc)

MAILREC=&#34;my_home_mail@something.de&#34;

SSHUSER=&#34;linux_backupuser&#34;
FROMSSH=&#34;linux_backupuser@999.888.777.666&#34;
#TOSSH=&#34;tossh-server&#34;
SSHPORT=22222

MOUNT=&#34;/bin/mount&#34;; FGREP=&#34;/bin/fgrep&#34;; SSH=&#34;/usr/bin/ssh&#34;
LN=&#34;/bin/ln&#34;; ECHO=&#34;/bin/echo&#34;; DATE=&#34;/bin/date&#34;; RM=&#34;/bin/rm&#34;
DPKG=&#34;/usr/bin/dpkg&#34;; AWK=&#34;/usr/bin/awk&#34;; MAIL=&#34;/usr/bin/mail&#34;
CUT=&#34;/usr/bin/cut&#34;; TR=&#34;/usr/bin/tr&#34;; RSYNC=&#34;/usr/bin/rsync&#34;
LAST=&#34;last&#34;; INC=&#34;--link-dest=$TARGET/$LAST&#34;; LS=&#34;/bin/ls&#34;</code></pre>



<p>This block is mostly taken from the original.</p>



<p>SOURCES is an array and can contain multiple sources, separated by a space.</p>



<p>Here is an example:</p>



<p>subpart of part 2:</p>



<pre><code>SOURCES=(/srv/smb/source1/ /srv/smb/source2/ )
TARGET=&#34;/srv/my_backup&#34;</code></pre>



<p>SOURCES</p>



<p>SOURCES is an array which will be accessed later with ${SOURCES[@]}. Multiple sources can be specified separated by spaces. There is then separate output in the log, because a „do-loop“ is processed for each SOURCE.</p>



<p>TARGET</p>



<h3>subpart of part 2:</h3>



<pre><code>RSYNCCONF=(--delete 
--exclude=/Volumes/Raid/.DocumentRevisions-V100
--exclude=/Volumes/Raid/.TemporaryItems --exclude=/Volumes/Raid/.Trashes 
--exclude=/Volumes/Raid/.apdisc)</code></pre>



<p>„-delete“ means that files that are deleted in the source are also deleted on the target. Some point-files (.file) sometimes make reading problems from the source so that it is best to exclude them. The problem is that they change between the reading of the files to be copied and the copying process. This leads to an error.</p>



<h3>subpart of part 2:</h3>



<pre><code>MONTHROTATE=monthrotate                 
# use DD instead of YYMMDD</code></pre>



<p>Since in a month always the day is specified as folder, the respective folder with the day number e.g. „04“ is overwritten again on the 4th of the next month. If this should not apply, then one can take long dates for the folder with the full date. You will get a new folder every day and you should then delete old ones from time to time.</p>



<h3>The deletion and 30<sup>th</sup> or 31<sup>st</sup> of the month – MONTHROTATE</h3>



<p>Deleting does not seem to delete the files that are still needed as they are hardlinks. These can be multiple links to a file and as long as a hardlink still exists (from another day-folder) the file is not deleted. New backups will then produce another NEW hardlink to the file.</p>



<p>To track the sequence I added an „all-log“ file to the script, see below.</p>



<p>There is then the symbolic link of „last“ to the last backup folder in each case. The linked folder with „last“ is used for the comparison of old and new files. Only new files are copied to the backup.</p>



<h3>subpart of part 2:</h3>



<pre><code>MAILREC=&#34;my_home_mail@something.de&#34;

SSHUSER=&#34;linux_backupuser&#34;
FROMSSH=&#34;linux_backupuser@999.888.777.666&#34;
#TOSSH=&#34;tossh-server&#34;
SSHPORT=22222</code></pre>



<p>Change the values according to your settings.</p>



<p>(Bash variables do not have to be capitalized, this is just a style of the author here).</p>



<p>Via MAILREC a destination address for the log mails is specified. Attention the mails contain in the original script the complete lister of the saved files. This can be a few hundred MB, which then get stuck in the mail server. That’s why I later included only ERRORS in the log file (at least for the big backup). See below.</p>



<p>FROMSSH or TOSSH, we are backing up from a source here, hence FROMSSH. The argument expects the server connection. FROMSSH is important because then there is no access data to the backup on the server being backed up. This is extremely important for encryption trojans, because they look for exactly that and then encrypt the backup first.</p>



<h3>subpart of part 2:</h3>



<pre><code>MOUNT=&#34;/bin/mount&#34;; FGREP=&#34;/bin/fgrep&#34;; 
SSH=&#34;/usr/bin/ssh&#34;;
LN=&#34;/bin/ln&#34;; ECHO=&#34;/bin/echo&#34;; DATE=&#34;/bin/date&#34;; RM=&#34;/bin/rm&#34;;
DPKG=&#34;/usr/bin/dpkg&#34;; AWK=&#34;/usr/bin/awk&#34;; 
MAIL=&#34;/usr/bin/mail&#34;;
CUT=&#34;/usr/bin/cut&#34;; 
TR=&#34;/usr/bin/tr&#34;; RSYNC=&#34;/usr/bin/rsync&#34;;
LAST=&#34;last&#34;; INC=&#34;--link-dest=$TARGET/$LAST&#34;; LS=&#34;/bin/ls&#34;</code></pre>



<p>The individual programs are stored in variables, this is an interesting approach to call in the script programs and make sure that they are found even without being listed in the path variable.</p>



<p>LAST specifies the name of the sym link folder. „last“ is then the sym link to the last backup.</p>



<p>„–link-dest“ is an rsync setting which then points to LAST.</p>



<p>Because I need the „ls“ list-command later I also put it with the full path into a variable. But „ls“ is not only available in bin but also in sbin, here I get it from bin.</p>



<h3>Part 3</h3>



<pre><code>#zazu log all days in one file
all_logprint() {
    echo -e &#34;\n $*&#34; &gt;&gt; all-days-${0}.log
}</code></pre>



<p>The log file is sent by email after each backup and then overwritten again. You are left with only the collected emails in your email  programme, except there were not too many files and the emails were not sent due to the size.</p>



<h3>Part 4</h3>



<pre><code>LOG=$0.log
$DATE &gt; $LOG</code></pre>



<p>„$0“ contains the name of the script at this point, so the log file is named like the script plus „.log“ (example: backup_script.sh.log).</p>



<h3>Part 5</h3>



<pre><code>if [ &#34;${TARGET:${#TARGET}-1:1}&#34; != &#34;/&#34; ]; then
  TARGET=$TARGET/
fi</code></pre>



<p>Since other folders are attached to the destination folder, it needs a slash at the end.</p>



<h3>Part 6</h3>



<pre><code># zazu check whether today is the same number as the 
# symlink &#34;last&#34; to the numbered folder
# also no 2 backups on one day - gives an ERROR
HEUTE=$($DATE +%d)
cd $TARGET
LAST_SYMLINK=$($LS -l | grep ^l | grep -o &#34;[0-9][0-9]$&#34;)
cd /home/sicherung/bin</code></pre>



<p>First the day number of the month is written into the variable „TODAY“: 01 or 02 etc..</p>



<h3>Part 7</h3>



<pre><code>if [ $HEUTE -ne $LAST_SYMLINK ]; then

… code parts 7a to 7e are here …

else
  $ECHO &#34;Since one month no backup or only with ERROR 
         (todays day of the month and day of last backup 
         have the same number), kept the last backup 
         from day ${TODAY}, didn&#39;t overwirte the folder. 
         No backup today, next backup is tomorrow.&#34; 
    &gt;&gt; $LOG
    ERROR=1
fi</code></pre>



<p><strong>Long „if bracket“:</strong></p>



<p><strong>Therefore:</strong></p>











<h3>Part 7a</h3>



<pre><code>if [ -z &#34;$MONTHROTATE&#34; ]; then
  TODAY=$($DATE +%y%m%d)
else
  TODAY=$($DATE +%d)
fi</code></pre>



<p>If – „z“ zero MOUNTPOINT, thus variable text is empty, make with „-z“ zero MONTHROTATE from TODAY the full date otherwise only the month number of the day „$Date +%d“. The whole thing is again in a bracket with $ sign, so that first the bracket content is evaluated and then the new info can be passed to the variable „TODAY“, which is also formed here.</p>



<h3>Part 7b</h3>



<pre><code>if [ &#34;$SSHUSER&#34; ] &amp;&amp; [ &#34;$SSHPORT&#34; ]; then
    S=&#34;$SSH -p $SSHPORT -l $SSHUSER&#34;;
fi</code></pre>



<p>Here the SSH access part, which is later in the rsync command, is written into the variable „S“, which is also created with this command.</p>



<h3>Part 7c</h3>



<pre><code>for SOURCE in &#34;${SOURCES[@]}&#34;
  do

#FROMSSH – this I use here

    if [ &#34;$S&#34; ] &amp;&amp; [ &#34;$FROMSSH&#34; ] &amp;&amp; [ -z &#34;$TOSSH&#34; ]; 
    then
      $ECHO &#34;$RSYNC -e \&#34;$S\&#34; -avR \&#34;$FROMSSH:$SOURCE\&#34;  
      ${RSYNCCONF[@]} $TARGET$TODAY $INC&#34; &gt;&gt; $LOG

# log only errors &#34;2&gt;&gt; $LOG&#34; since logging all files 
# backuped will crash the mailer, original &#34;&gt;&gt; $LOG 
# 2&gt;&amp;1&#34;

      $RSYNC -e &#34;$S&#34; -avR &#34;$FROMSSH:\&#34;$SOURCE\&#34;&#34; &#34;$
      {RSYNCCONF[@]}&#34; &#34;$TARGET&#34;$TODAY $INC 2&gt;&gt; $LOG
      if [ $? -ne 0 ]; then
        ERROR=1
      fi
   fi

#TOSSH – I&#39;m not using here

   if [ &#34;$S&#34; ] &amp;&amp; [ &#34;$TOSSH&#34; ] &amp;&amp; [ -z &#34;$FROMSSH&#34; ]; 
   then
     $ECHO &#34;$RSYNC -e \&#34;$S\&#34; -avR \&#34;$SOURCE\&#34; $
     {RSYNCCONF[@]} \&#34;$TOSSH:$TARGET$TODAY\&#34; $INC &#34; 
     &gt;&gt; $LOG

     $RSYNC -e &#34;$S&#34; -avR &#34;$SOURCE&#34; &#34;${RSYNCCONF[@]}&#34; 
     &#34;$TOSSH:\&#34;$TARGET\&#34;$TODAY&#34; $INC &gt;&gt; $LOG 2&gt;&amp;1
        if [ $? -ne 0 ]; then
          ERROR=1
        fi
    fi

#Local Backup – I&#39;m not using here

   if [ -z &#34;$S&#34; ]; then
      $ECHO &#34;$RSYNC -avR \&#34;$SOURCE\&#34; ${RSYNCCONF[@]} 
      $TARGET$TODAY $INC&#34; &gt;&gt; $LOG

      $RSYNC -avR &#34;$SOURCE&#34; &#34;${RSYNCCONF[@]}&#34;  
      &#34;$TARGET&#34;$TODAY $INC &gt;&gt; $LOG 2&gt;&amp;1
         if [ $? -ne 0 ]; then
           ERROR=1
        fi
     fi

done</code></pre>



<p>Now here comes the actual rsyn command loop (for – in – do).</p>







<p>The first block just writes the complete rsync command to the log file, so you can see what was executed.</p>



<p>The second block then actually executes rsync and writes what rsync reports to „stdout“ (standard out) and „stderr“ (standard error) to the log file:</p>



<p>If the exit status of the last operation was not successful ($? -ne 0), so „-ne“ not equal 0 = success, then the variable ERROR = 1.</p>



<p>The actual command of rsync:</p>



<ul><li>$RSYNC contains the program name with path.</li><li>„-e“ stands for remote and you have to specify a protocol, here SSH.</li><li>„$S“ contains the SSH connection data as specified above.</li><li>„-avR“ are the flags for rsync a=achive, v=verbose, R=relative pathnames</li><li>„FROMSSH“ contains user@ip-address</li><li>\“$SOURCE\““ is the respective SOURCE over which the do loop will process.</li><li>„${RSYNCCONF[@]}“ the array with the rsync flags (e.g. –delete)</li><li>„$TARGET“$TODAY target is taken as text, the date Today is evaluated</li><li>$INC the link destination, sym link on last is still specified at the end –link-dest=last</li></ul>



<h3>Bash basics</h3>



<p><strong>It is interesting what is escaped „\“ in the script and what is in „quotes“.</strong></p>



<p>Quoting single ‚x‘ and double „y“ means that a command should be interpreted contiguously.</p>



<p>For variables, “ “ double quotes mean that the contents of the variable should be here, whereas single ‚$variable‘ quotes around a variable only print the variable name = variable</p>



<p>`Backticks are commands whose output becomes or is intended to be a string.</p>



<p><a href="https://wiki.ubuntuusers.de/Shell/Bash-Skripting-Guide_für_Anfänger/">https://wiki.ubuntuusers.de/Shell/Bash-Skripting-Guide_für_Anfänger/</a></p>







<h3>Part 7d</h3>



<pre><code>if [ &#34;$S&#34; ] &amp;&amp; [ &#34;$TOSSH&#34; ] &amp;&amp; [ -z &#34;$FROMSSH&#34; ]; then
  $ECHO &#34;$SSH -p $SSHPORT -l $SSHUSER $TOSSH $LN -nsf 
  $TARGET$TODAY $TARGET$LAST&#34; &gt;&gt; $LOG
  $SSH -p $SSHPORT -l $SSHUSER $TOSSH &#34;$LN -nsf
  \&#34;$TARGET\&#34;$TODAY \&#34;$TARGET\&#34;$LAST&#34; &gt;&gt; $LOG 2&gt;&amp;1
    if [ $? -ne 0 ]; then
      ERROR=1
    fi
fi</code></pre>



<p>In the case of TOSSH, the symlink is set here at the end. Does not apply to me.</p>







<h3>Part 7e</h3>



<pre><code>## zazu added [ -z &#34;$ERROR&#34; ], no symlink if error

  if ( [ &#34;$S&#34; ] &amp;&amp; [ &#34;$FROMSSH&#34; ] &amp;&amp; [ -z &#34;$TOSSH&#34; ] &amp;&amp; 
  [ -z &#34;$ERROR&#34; ] ) || ( [ -z &#34;$S&#34; ] ); then

    $ECHO &#34;$LN -nsf $TARGET$TODAY $TARGET$LAST&#34; &gt;&gt; $LOG

    $LN -nsf &#34;$TARGET&#34;$TODAY &#34;$TARGET&#34;$LAST &gt;&gt; $LOG 2&gt;&amp;1
      if [ $? -ne 0 ]; then
        ERROR=1
      fi
  fi</code></pre>







<p>Here the symlink is set in the case of FROMSSH.</p>



<p>Added by me -z „$ERROR“:</p>



<h4>subpart of part 7e</h4>



<pre><code>if ( [ &#34;$S&#34; ] &amp;&amp; [ &#34;$FROMSSH&#34; ] &amp;&amp; [ -z &#34;$TOSSH&#34; ] &amp;&amp; [ -z &#34;$ERROR&#34; ] ) || ( [ -z &#34;$S&#34; ] );  then</code></pre>



<p>No symlink is written if an error took place, that is „last“ will still point to the old complete backup. Otherwise the server makes the complete backup from the beginning in case of an error, which can mean a month transfer time with a big volume to backup.</p>



<h3>subpart of part 7 – the closing of the if -else loop</h3>



<pre><code>else
  
  $ECHO &#34;Since one month no backup or only with ERROR 
  (todays day of the month and day of last backup have 
   the same number), kept the last backup from day 
   ${TODAY}, didn&#39;t overwirte the folder. No backup 
   today, next backup is tomorrow.&#34; &gt;&gt; $LOG

  ERROR=1
  fi</code></pre>



<p><strong>Attention:</strong></p>



<p>If the symlink is not updated there is a larger explanatory error message.</p>



<h3>Part 8</h3>



<pre><code>$DATE &gt;&gt; $LOG</code></pre>



<p>At the end of the actual process, the full date/time is written to the log again, so you can see how long the backup took and when it finished.</p>



<h3>Part 9 – mail a report</h3>



<pre><code>if [ -n &#34;$MAILREC&#34; ]; then
  if [ $ERROR ];then
    $MAIL -s &#34;Error Backup $LOG&#34; $MAILREC &lt; $LOG
# zazu all log
   all_logprint &#34;ERROR _ _ _ _ _ _ _ _ _ _ _ \n&#34; 
   &#34;$(&lt; $LOG)&#34;

  else

     $MAIL -s &#34;Backup $LOG&#34; $MAILREC &lt; $LOG
#zazu all log
    all_logprint &#34;$(&lt; $LOG)&#34;
  fi
fi</code></pre>



<p>If MAILREC is not null (-n),</p>



<p>Below this I start the function „all_logprint“ defined at the beginning of the script. Then pass to the echo command of the function the parameters „Error_ _ _\n“ plus an end of line „\n“. The underscores are just so you can see the ERROR text better.</p>



<p>Here again the function from the beginning of the script:</p>



<p>supart of part 3</p>



<pre><code>all_logprint() {
    echo -e &#34;\n $*&#34; &gt;&gt; all-days-${0}.log
}</code></pre>



<p>The file „all-days-bu-script-name.sh.log“ is then next to the „bu-script-name.sh.log“.</p>



<p>In the „all-days“ the single backups are listed, only with the errors and the information about runtime start, runtime end, executed commands and possibly outputs via stdout.</p>



<p><strong>With this the script is finished.</strong></p>







<figure><a href="https://blog.zazu.berlin/wp-content/uploads/2022/02/zazu-server-big-cooler.jpg"><img loading="lazy" width="1024" height="683" src="https://blog.zazu.berlin/wp-content/uploads/2022/02/zazu-server-big-cooler-1024x683.jpg" alt="" srcset="https://blog.zazu.berlin/wp-content/uploads/2022/02/zazu-server-big-cooler-1024x683.jpg 1024w, https://blog.zazu.berlin/wp-content/uploads/2022/02/zazu-server-big-cooler-300x200.jpg 300w, https://blog.zazu.berlin/wp-content/uploads/2022/02/zazu-server-big-cooler-768x512.jpg 768w, https://blog.zazu.berlin/wp-content/uploads/2022/02/zazu-server-big-cooler-1536x1024.jpg 1536w, https://blog.zazu.berlin/wp-content/uploads/2022/02/zazu-server-big-cooler.jpg 1920w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>size matters – oversized coolers for less power consumption and less noise</figcaption></figure>







<h2>Make the script executable</h2>



<p>If you want to execute the script it must have execute rights:</p>



<pre><code>chmod u+x $HOME/bin/bu-script-name.sh</code></pre>



<p>„u“ stands for the user, „g“ for group and „a“ for all.</p>



<p>Now you can run the script directly in the folder with the following command:</p>



<pre><code>./bu-script-name.sh</code></pre>



<h2>Run the script every day with cron</h2>



<p>To run the script every day you need to make an entry into crontab of the linux backup-user that is hosting the script and should not have any sudo-rights.</p>



<pre><code>crontab -e</code></pre>



<p>Run the script every day at 23:00 h. The script is located in a bin folder of the backupuser inside his home directory.</p>



<pre><code>#zazu backup
0 23 * * * /home/backupuser/bin/bu-script-name.sh</code></pre>



<h2>The output structure of „monthrotate“</h2>



<pre><code>drwxrwxr-x 25 backupuser backupuser 2343 Sep 20 23:10 20
drwxrwxr-x 44 backupuser backupuser 2555 Sep 21 23:10 21
drwxrwxr-x 32 backupuser backupuser 5678 Sep 22 23:10 22
drwxrwxr-x 56 backupuser backupuser 4567 Sep 23 23:10 23
drwxrwxr-x 66 backupuser backupuser 7564 Sep 24 23:10 24
drwxrwxr-x 43 backupuser backupuser 4567 Sep 25 23:10 25
lrwxrwxrwx 78 backupuser backupuser 7564 Sep 25 23:10 last -&gt; /srv/backup_folder/25</code></pre>



<p>The last successful backup was completed at 25<sup>th</sup> September with the folder named „25“, a symlink was produced to this folder „25“ with the name „last“.</p>



<h2>The log output in the folder of the script</h2>



<p>/home/backupuser/bin/</p>



<pre><code>bu-script-name.sh
bu-script-name.sh.log
all-days-bu-script-name.sh.log</code></pre>



<h2>Why only a „almost perfect“ script?</h2>



<p>There is alway space for improvements. Any improvements and comments are wellcome.</p>



<h2>Interested in hardware?</h2>



<p><a href="https://blog.zazu.berlin/hardware/aesthetic-and-very-quiet-240-tb-backup-server.html" data-type="URL" data-id="https://blog.zazu.berlin/hardware/aesthetic-and-very-quiet-240-tb-backup-server.html">How to build a very quiet and environmental friendly 240 TB backup server -&gt;</a></p>



<p><a href="https://blog.zazu.berlin/hardware/schneller-linux-fileserver-datenserver-im-eigenbau-teil-1-hardware.html">How to build a very quiet and environmental fr</a><a href="https://blog.zazu.berlin/hardware/schneller-linux-fileserver-datenserver-im-eigenbau-teil-1-hardware.html" data-type="URL" data-id="https://blog.zazu.berlin/hardware/schneller-linux-fileserver-datenserver-im-eigenbau-teil-1-hardware.html">iendly office server (German) -&gt;</a></p>







<p><strong>Author:</strong> – Version 1.0</p>



<h2>Finally the complete script</h2>



<pre><code>#!/bin/bash

# avoidng collisions with other rsync processes

#the minutes passed to the script 21h*60min = 1260 Minuten
minutes=1260

# Make sure no one else is using rsync
pro_on=$(ps aux | grep -c rsync)

# if someone is using rsync
# grep is also producing one entry so -gt 1

while [ $pro_on -gt 1 ]
do
  sleep 60
  minutes=$(($minutes - 1))

  # we are close to the next day no need to start
  if [ $minutes -lt 60 ] ; then
    exit 0
  fi

  pro_on=$(ps aux | grep -c rsync)
done


# Simple backup with rsync
# local-mode, tossh-mode, fromssh-mode

SOURCES=(/Volumes/raid/ )
TARGET=&#34;/srv/backup&#34;

# edit or comment with &#34;#&#34;
MONTHROTATE=monthrotate                 # use DD instead of YYMMDD
RSYNCCONF=(--delete --exclude=/Volumes/raid/.DocumentRevisions-V100 --exclude=/Volumes/raid/.TemporaryItems --exclude=/Volumes/raid/.Trashes --exclude=/Volumes/raid/.apdisc)
MAILREC=&#34;webmaster@zazu.berlin.please.change&#34;

SSHUSER=&#34;backupuser&#34;
FROMSSH=&#34;backupuser@999.888.77.66&#34;
#TOSSH=&#34;tossh-server&#34;
SSHPORT=2222

### a lot of zazu edits ###

MOUNT=&#34;/bin/mount&#34;; FGREP=&#34;/bin/fgrep&#34;; SSH=&#34;/usr/bin/ssh&#34;
LN=&#34;/bin/ln&#34;; ECHO=&#34;/bin/echo&#34;; DATE=&#34;/bin/date&#34;; RM=&#34;/bin/rm&#34;
DPKG=&#34;/usr/bin/dpkg&#34;; AWK=&#34;/usr/bin/awk&#34;; MAIL=&#34;/usr/bin/mail&#34;
CUT=&#34;/usr/bin/cut&#34;; TR=&#34;/usr/bin/tr&#34;; RSYNC=&#34;/usr/bin/rsync&#34;
LAST=&#34;last&#34;; INC=&#34;--link-dest=$TARGET/$LAST&#34;; LS=&#34;/bin/ls&#34;

#zazu log all days in one file
all_logprint() {
    echo -e &#34;\n $*&#34; &gt;&gt; all-days-${0}.log
}

LOG=$0.log
$DATE &gt; $LOG

if [ &#34;${TARGET:${#TARGET}-1:1}&#34; != &#34;/&#34; ]; then
  TARGET=$TARGET/
fi

#zazu check whether today is the same number as the symlink &#34;last&#34; to the numbered folder
#also no 2 backups on one day - gives an ERROR
HEUTE=$($DATE +%d)
cd $TARGET
LAST_SYMLINK=$($LS -l | grep ^l | grep -o &#34;[0-9][0-9]$&#34;)
cd /home/sicherung/bin

if [ $HEUTE -ne $LAST_SYMLINK ]; then

  if [ -z &#34;$MONTHROTATE&#34; ]; then
    TODAY=$($DATE +%y%m%d)
  else
    TODAY=$($DATE +%d)
  fi

  if [ &#34;$SSHUSER&#34; ] &amp;&amp; [ &#34;$SSHPORT&#34; ]; then
    S=&#34;$SSH -p $SSHPORT -l $SSHUSER&#34;;
  fi

  for SOURCE in &#34;${SOURCES[@]}&#34;
    do
      if [ &#34;$S&#34; ] &amp;&amp; [ &#34;$FROMSSH&#34; ] &amp;&amp; [ -z &#34;$TOSSH&#34; ]; then
        $ECHO &#34;$RSYNC -e \&#34;$S\&#34; -avR \&#34;$FROMSSH:$SOURCE\&#34; ${RSYNCCONF[@]} $TARGET$TODAY $INC&#34;  &gt;&gt; $LOG
        #log only errors &#34;2&gt;&gt; $LOG&#34; since logging all files backuped will crash the mailer, original &#34;&gt;&gt; $LOG 2&gt;&amp;1&#34;
        $RSYNC -e &#34;$S&#34; -avR &#34;$FROMSSH:\&#34;$SOURCE\&#34;&#34; &#34;${RSYNCCONF[@]}&#34; &#34;$TARGET&#34;$TODAY $INC 2&gt;&gt; $LOG
        if [ $? -ne 0 ]; then
          ERROR=1
        fi
      fi
      if [ &#34;$S&#34; ]  &amp;&amp; [ &#34;$TOSSH&#34; ] &amp;&amp; [ -z &#34;$FROMSSH&#34; ]; then
        $ECHO &#34;$RSYNC -e \&#34;$S\&#34; -avR \&#34;$SOURCE\&#34; ${RSYNCCONF[@]} \&#34;$TOSSH:$TARGET$TODAY\&#34; $INC &#34; &gt;&gt; $LOG
        $RSYNC -e &#34;$S&#34; -avR &#34;$SOURCE&#34; &#34;${RSYNCCONF[@]}&#34; &#34;$TOSSH:\&#34;$TARGET\&#34;$TODAY&#34; $INC &gt;&gt; $LOG 2&gt;&amp;1
        if [ $? -ne 0 ]; then
          ERROR=1
        fi
      fi
      if [ -z &#34;$S&#34; ]; then
        $ECHO &#34;$RSYNC -avR \&#34;$SOURCE\&#34; ${RSYNCCONF[@]} $TARGET$TODAY $INC&#34;  &gt;&gt; $LOG
        $RSYNC -avR &#34;$SOURCE&#34; &#34;${RSYNCCONF[@]}&#34; &#34;$TARGET&#34;$TODAY $INC  &gt;&gt; $LOG 2&gt;&amp;1
        if [ $? -ne 0 ]; then
          ERROR=1
        fi
      fi
  done

  if [ &#34;$S&#34; ] &amp;&amp; [ &#34;$TOSSH&#34; ] &amp;&amp; [ -z &#34;$FROMSSH&#34; ]; then
    $ECHO &#34;$SSH -p $SSHPORT -l $SSHUSER $TOSSH $LN -nsf $TARGET$TODAY $TARGET$LAST&#34; &gt;&gt; $LOG
    $SSH -p $SSHPORT -l $SSHUSER $TOSSH &#34;$LN -nsf \&#34;$TARGET\&#34;$TODAY \&#34;$TARGET\&#34;$LAST&#34; &gt;&gt; $LOG 2&gt;&amp;1
    if [ $? -ne 0 ]; then
      ERROR=1
    fi
  fi

  ## zazu added [ -z &#34;$ERROR&#34; ], no symlink if error

  if ( [ &#34;$S&#34; ] &amp;&amp; [ &#34;$FROMSSH&#34; ] &amp;&amp; [ -z &#34;$TOSSH&#34; ] &amp;&amp; [ -z &#34;$ERROR&#34; ] ) || ( [ -z &#34;$S&#34; ] );  then
    $ECHO &#34;$LN -nsf $TARGET$TODAY $TARGET$LAST&#34; &gt;&gt; $LOG
    $LN -nsf &#34;$TARGET&#34;$TODAY &#34;$TARGET&#34;$LAST  &gt;&gt; $LOG 2&gt;&amp;1
    if [ $? -ne 0 ]; then
      ERROR=1
    fi
  fi

else
  $ECHO &#34;Since one month no backup or only with ERROR (todays day of the month and day of last backup have the same number), kept the last backup from day ${TODAY}, didn&#39;t overwirte the folder. No backup today, next backup is tomorrow.&#34; &gt;&gt; $LOG
  ERROR=1
fi

$DATE &gt;&gt; $LOG

if [ -n &#34;$MAILREC&#34; ]; then
  if [ $ERROR ];then
    $MAIL -s &#34;Error Backup $LOG&#34; $MAILREC &lt; $LOG
    #zazu all log
    all_logprint &#34;ERROR _ _ _ _ _ _ _ _ _ _ _ \n&#34; &#34;$(&lt; $LOG)&#34;
  else
    $MAIL -s &#34;Backup $LOG&#34; $MAILREC &lt; $LOG
    #zazu all log
    all_logprint &#34;$(&lt; $LOG)&#34;
  fi
fi</code></pre>
							
		</div></div>
  </body>
</html>
