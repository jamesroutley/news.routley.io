<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/RC31/">Original</a>
    <h1>RC31. Assembler Bugs and List Mutation in Python</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-06-27T00:00:00-07:00">June 27, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        <p>Yesterday and today I worked on my n2t assembler. It ended up being about 300 lines of Python, but may well have been the largest and project I‚Äôve tackled thus far at RC since my focus has been on smaller things.</p>

<p>I took a two-phase approach. Phase 1: Just parse the assembly without dealing with symbols and labels. Phase 2: Deal with symbols and labels.</p>

<p>Phase 1 went fine ‚Äì mostly just a matter of converting components of various assembly commands into their bitstring equivalents using lookup tables.</p>

<p>Phase 2? Well, Phase 2 turned out to have two phases. Phase 1 of Phase 2 consisted of dealing with symbols, which in my case meant creating a SymbolsTable class to manage a dictionary of symbols and and handle insertions of new symbols at the next available addresses in memory, etc. If in assembly one writes <code>@my_var</code> (thus loading address <code>my_var</code> into the A register), my assembler would need to 1) figure out that we were looking at a symbol; 2) check to see if <code>my_var</code> existed in the SymbolsTable table, in which case it would return the address associated with the <code>my_var</code> key; and 3) if the symbols table <em>didn‚Äôt</em> already include <code>my_var</code>, insert it at the next available address, and then return <em>that</em>. Excellent!</p>

<p>I thought I was done with Phase 2, but Phase 2 was not done with me. I forgot about labels! A label is something like <code>(loop)</code> or <code>(reset)</code> ‚Äì a line of pseudocode that marks a particular location in the program so that the program can jump back to that point later using a jump command.</p>

<p>This required a bit of thought, since it was seeming like I‚Äôd need to do a first pass over the assembly code to 1) identify labels; 2) add the labels to the SymbolsTable lookup table with the number of the next line of the program as their values; and 3) remove this line from the code entirely, so that on the next pass, we wouldn‚Äôt have to deal with these lines again.</p>

<p>My first approach looked something liked this:</p>

<div><div><pre><code><span>for</span> <span>line_num</span><span>,</span> <span>line</span> <span>in</span> <span>enumerate</span><span>(</span><span>program</span><span>):</span>
    <span>if</span> <span>command_type</span><span>(</span><span>program</span><span>)</span> <span>==</span> <span>commands</span><span>.</span><span>L_COMMAND</span><span>:</span>
        <span>label</span> <span>=</span> <span>parse_label</span><span>(</span><span>line</span><span>)</span>
        <span>add_symbol</span><span>(</span><span>label</span><span>,</span> <span>line_num</span><span>)</span>
        <span>program</span><span>.</span><span>pop</span><span>(</span><span>line_num</span><span>)</span>
</code></pre></div></div>

<p>I looped through <code>program</code> (a list of assembly commands), which I enumerated so that I had access to both the index (<code>line_num</code>) and the the command (<code>line</code>) of this list. If a given command was identified as an L-command (meaning it was a label), then I needed to:</p>
<ul>
  <li>parse the <code>line</code> (in this case just get rid of the parentheses, so that <code>(loop)</code> -&gt; <code>loop</code>)</li>
  <li>add that parsed label to the SymbolTable dictionary</li>
  <li>and then pop that list item off the <code>program</code> list</li>
</ul>

<p>This last part I thought was a particularly clever solution to the main problem I was facing: get rid of loop commands once you‚Äôve seen them, and ensure that loop commands are added to the SymbolTable with a value representing the program line to which they should point, which needed to shift according to the deletions of all the labels. I figured that popping off label lines as we went would (magically) affect the list enumeration in the correct way, so that <code>line_num</code> would effectively refer to the index of the <em>mutated</em> <code>program</code> list at any given moment. The solution wasn‚Äôt too helplessly naive, I don‚Äôt think, but did result in some unexpected behavior.</p>

<p>Before continuing, let me make clear what I mean with an example.</p>

<p>Here‚Äôs one of the sample nt2 assembly programs our assembler is tasked with asssembling:</p>

<div><div><pre><code>   @R0
   D=M              // D = first number
   @R1
   D=D-M            // D = first number - second number
   @OUTPUT_FIRST
   D;JGT            // if D&gt;0 (first is greater) goto output_first
   @R1
   D=M              // D = second number
   @OUTPUT_D
   0;JMP            // goto output_d
(OUTPUT_FIRST)
   @R0
   D=M              // D = first number
(OUTPUT_D)
   @R2
   M=D              // M[2] = D (greatest number)
(INFINITE_LOOP)
   @INFINITE_LOOP
   0;JMP            // infinite loop
</code></pre></div></div>

<p>This program returns the max of the values in at address <code>@R0</code> and <code>@R1</code>. How it does that is unimportant. My main interest here are the three labels: <code>(OUTPUT_FIRST)</code>, <code>(OUTPUT_D)</code>, and <code>(INFINITE_LOOP)</code>. <code>(OUTPUT_FIRST)</code> is at line 11, which is where we‚Äôd want to jump if, at line 6, <code>D &gt; 0</code>. But once the l-command <code>(OUTPUT_FIRST)</code> is removed from the code, <code>(OUTPUT_D)</code> (which is at line 14) would need to point to line 13. And <code>(INFINITE_LOOP)</code>, at line 17, would then need to point to line 15.</p>

<p>Let‚Äôs say, then, that we have the above program in the list format we‚Äôre expecting by this point.</p>

<div><div><pre><code><span>for</span> <span>i</span><span>,</span> <span>line</span> <span>in</span> <span>enumerate</span><span>(</span><span>program</span><span>):</span>
    <span>print</span><span>(</span><span>&#34;{:&lt;3}:{}&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span> <span>+</span> <span>1</span><span>,</span> <span>line</span><span>))</span>
</code></pre></div></div>

<div><div><pre><code>1  :R0
2  :D=M
3  :@R1
4  :D=D-M
5  :@OUTPUT_FIRST
6  :D;JGT
7  :@R1
8  :D=M
9  :@OUTPUT_D
10 :0;JMP
11 :(OUTPUT_FIRST)
12 :@R0
13 :D=M
14 :(OUTPUT_D)
15 :@R2
16 :M=D
17 :(INFINITE_LOOP)
18 :@INFINITE_LOOP
19 :0;JMP
</code></pre></div></div>

<p>There‚Äôs our program pretty-printed with 1-indexed line numbers.</p>

<p>Now let‚Äôs do the thing we were talking about in an even more simplified form:</p>

<div><div><pre><code><span>labels</span> <span>=</span> <span>{}</span>

<span>for</span> <span>line_num</span><span>,</span> <span>line</span> <span>in</span> <span>enumerate</span><span>(</span><span>program</span><span>):</span>
    <span>if</span> <span>line</span><span>.</span><span>startswith</span><span>(</span><span>&#39;(&#39;</span><span>):</span>
    <span>labels</span><span>[</span><span>line</span><span>[</span><span>1</span><span>:</span><span>-</span><span>1</span><span>]]</span> <span>=</span> <span>line_num</span> <span>+</span> <span>1</span>
    <span>program</span><span>.</span><span>pop</span><span>(</span><span>line_nume</span><span>)</span>

<span># print labels dict
</span><span>print</span><span>(</span><span>labels</span><span>)</span>

<span># pretty print mutated list
</span><span>for</span> <span>i</span><span>,</span> <span>line</span> <span>in</span> <span>enumerate</span><span>(</span><span>program</span><span>):</span>
    <span>print</span><span>(</span><span>&#34;{:&lt;3}:{}&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span> <span>+</span> <span>1</span><span>,</span> <span>line</span><span>))</span>
</code></pre></div></div>

<div><div><pre><code>{&#39;OUTPUT_FIRST&#39;: 11, &#39;OUTPUT_D&#39;: 13, &#39;INFINITE_LOOP&#39;: 15}

1  :R0
2  :D=M
3  :@R1
4  :D=D-M
5  :@OUTPUT_FIRST
6  :D;JGT
7  :@R1
8  :D=M
9  :@OUTPUT_D
10 :0;JMP
11 :@R0
12 :D=M
13 :@R2
14 :M=D
15 :@INFINITE_LOOP
16 :0;JMP
</code></pre></div></div>

<p>And hey! That‚Äôs actually . . . what I was hoping for? Each time we pop off a bad line, the <code>program</code> list shifts by one, which means that the next index enumerated is . . . where we want it to be. I mean, it seems to work, doesn‚Äôt it?</p>

<p>That‚Äôs what I thought until it came time to assemble a 27,000-line test program, and at that point it became clear (after some debugging) that there were some label-related hijinks.</p>

<p>I ended up pairing with a more experienced recurser, who immediately zero‚Äôed in on this weird list mutation part of the code, since trying to mutate lists in place I guess can have funky consequences, which in retrospect makes sense. Here‚Äôs a test we devised to see what‚Äôs happening:</p>

<div><div><pre><code><span>x</span> <span>=</span> <span>[</span><span>&#39;a&#39;</span><span>,</span> <span>&#39;b&#39;</span><span>,</span> <span>&#39;c&#39;</span><span>,</span> <span>&#39;d&#39;</span><span>,</span> <span>&#39;e&#39;</span><span>,</span> <span>&#39;f&#39;</span><span>]</span>

<span>for</span> <span>i</span><span>,</span> <span>v</span> <span>in</span> <span>enumerate</span><span>(</span><span>x</span><span>):</span>
    <span>print</span><span>(</span><span>&#34;Loop # {}&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span> <span>+</span> <span>1</span><span>))</span>
    <span>print</span><span>(</span><span>&#34;i = {}, v = {}&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span><span>,</span> <span>v</span><span>))</span>
    <span>print</span><span>(</span><span>x</span><span>)</span>
    <span>print</span><span>(</span><span>&#34;Popping index {}&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span><span>))</span>
    <span>x</span><span>.</span><span>pop</span><span>(</span><span>i</span><span>)</span>
    <span>print</span><span>()</span>

<span>print</span><span>(</span><span>&#34;Final list&#34;</span><span>)</span>
<span>print</span><span>(</span><span>x</span><span>)</span>

</code></pre></div></div>

<div><div><pre><code>Loop # 1
i = 0, v = a
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
Popping index 0

Loop # 2
i = 1, v = c
[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
Popping index 1

Loop # 3
i = 2, v = e
[&#39;b&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
Popping index 2

Final list
[&#39;b&#39;, &#39;d&#39;, &#39;f&#39;]
</code></pre></div></div>

<p>Now, this was not what I expected at first, but it does make sense. We can see that our index value is marching on as expected ‚Äì it starts at 0, then 1, then 2. But something funny happens, since the list is shrinking at the same time that the <code>i</code> indexer is incrementing. After our third loop, <code>i</code> should be 3, but at this point our mutated list ‚Äì currently <code>[&#39;b&#39;, &#39;d&#39;, &#39;f&#39;]</code> ‚Äì only has three elements in it, and <code>x[3]</code> is out of range. So weirdly we end up iterating through the entire list (in the senes that <code>i</code> exceeds the list‚Äôs length), but we‚Äôve done so without having actually seen everything.</p>

<p>In the case of the assembler, though, there‚Äôs a bigger issue, which is that back-to-back labels (which can occur) will not both be removed. (Also, the last item of the list will never be seen, although that shouldn‚Äôt be a problem in this case, since labels would never occur on the last line of an assembly program.)</p>

<p>Here‚Äôs a short example of the unexpected behavior:</p>

<div><div><pre><code><span>program</span> <span>=</span> <span>[</span><span>&#39;a&#39;</span><span>,</span> <span>&#39;(b)&#39;</span><span>,</span> <span>&#39;(c)&#39;</span><span>,</span> <span>&#39;d&#39;</span><span>,</span> <span>&#39;e&#39;</span><span>,</span> <span>&#39;(f)&#39;</span><span>,</span> <span>&#39;g&#39;</span><span>,</span> <span>&#39;(h)&#39;</span><span>,</span> <span>&#39;i&#39;</span><span>]</span>

<span>for</span> <span>i</span><span>,</span> <span>v</span> <span>in</span> <span>enumerate</span><span>(</span><span>program</span><span>):</span>
    <span>print</span><span>(</span><span>&#34;Loop # {}&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span> <span>+</span> <span>1</span><span>))</span>
    <span>print</span><span>(</span><span>program</span><span>)</span>
    <span>print</span><span>(</span><span>&#34;i = {}, v = {}&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span><span>,</span> <span>v</span><span>))</span>
    <span>if</span> <span>v</span><span>.</span><span>startswith</span><span>(</span><span>&#39;(&#39;</span><span>):</span>
        <span>print</span><span>(</span><span>&#34;Popping index {}&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span><span>))</span>
        <span>program</span><span>.</span><span>pop</span><span>(</span><span>i</span><span>)</span>

    <span>print</span><span>()</span>

<span>print</span><span>(</span><span>program</span><span>)</span>
</code></pre></div></div>

<div><div><pre><code>Loop # 1
[&#39;a&#39;, &#39;(b)&#39;, &#39;(c)&#39;, &#39;d&#39;, &#39;e&#39;, &#39;(f)&#39;, &#39;g&#39;, &#39;(h)&#39;, &#39;i&#39;]
i = 0, v = a

Loop # 2
[&#39;a&#39;, &#39;(b)&#39;, &#39;(c)&#39;, &#39;d&#39;, &#39;e&#39;, &#39;(f)&#39;, &#39;g&#39;, &#39;(h)&#39;, &#39;i&#39;]
i = 1, v = (b)
Popping index 1

Loop # 3
[&#39;a&#39;, &#39;(c)&#39;, &#39;d&#39;, &#39;e&#39;, &#39;(f)&#39;, &#39;g&#39;, &#39;(h)&#39;, &#39;i&#39;]
i = 2, v = d

Loop # 4
[&#39;a&#39;, &#39;(c)&#39;, &#39;d&#39;, &#39;e&#39;, &#39;(f)&#39;, &#39;g&#39;, &#39;(h)&#39;, &#39;i&#39;]
i = 3, v = e

Loop # 5
[&#39;a&#39;, &#39;(c)&#39;, &#39;d&#39;, &#39;e&#39;, &#39;(f)&#39;, &#39;g&#39;, &#39;(h)&#39;, &#39;i&#39;]
i = 4, v = (f)
Popping index 4

Loop # 6
[&#39;a&#39;, &#39;(c)&#39;, &#39;d&#39;, &#39;e&#39;, &#39;g&#39;, &#39;(h)&#39;, &#39;i&#39;]
i = 5, v = (h)
Popping index 5

[&#39;a&#39;, &#39;(c)&#39;, &#39;d&#39;, &#39;e&#39;, &#39;g&#39;, &#39;i&#39;]
</code></pre></div></div>

<p>Here our label <code>(c)</code> was skipped.</p>

<p>Perhaps my solution would have worked if back-to-back labeling was invalid, but as my pairing bud pointed out, it‚Äôs probably not best practice to mutate a list while you‚Äôre iterating through it because of weird, non-intuitive behaviour like this.</p>

<p>So instead of trying to pop l-commands off, I created a list <code>no_labels</code> and appended non-l-commands to it while processing the original program. This required a separate line-counter that incremented only on non-l-command lines so that we could associate the correct line number with the label.</p>

<div><div><pre><code><span>lc</span> <span>=</span> <span>0</span>
<span>no_labels</span> <span>=</span> <span>[]</span>

<span>for</span> <span>line</span> <span>in</span> <span>program</span><span>:</span>
    <span>if</span> <span>command_type</span><span>(</span><span>program</span><span>)</span> <span>==</span> <span>commands</span><span>.</span><span>L_COMMAND</span><span>:</span>
        <span>label</span> <span>=</span> <span>parse_label</span><span>(</span><span>line</span><span>)</span>
        <span>add_symbol</span><span>(</span><span>label</span><span>,</span> <span>lc</span><span>)</span>
    <span>else</span><span>:</span>
        <span>no_labels</span><span>.</span><span>append</span><span>(</span><span>line</span><span>)</span>
        <span>lc</span> <span>+=</span> <span>1</span>     <span># only increment on non-l-command lines
</span></code></pre></div></div>


<p>A slumpy week thus far with Spring 2 batch folk around less. Plus tackling larger, more intimidating projects (like the the assembler) has been a rough reality check. Plus SICP got really hard all of a sudden.</p>

<p>But also feeling like I‚Äôm turning it around today thanks to other recursers‚Äô generosity and enthusiasm.</p>

<ul>
  <li>Made it to checkins this AM, which was a great reminder that there are plenty of familiar faces around in addition to the new RCers I‚Äôm excited to meet</li>
  <li>Made it through Part 2 of #üßë‚Äçüíª current batches &gt; implement dns in a weekend with the DNS crew</li>
  <li>Finished assembler</li>
  <li>Met with a recurser and got a Django group going ‚Äì starting to pivot towards some sort of web app project in the second half of batch.</li>
  <li>Met with another recurser who walked me through some git and GitHub workflow stuff</li>
  <li>Started the slow process of translating the DNS implementation to C</li>
</ul>



          

        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
