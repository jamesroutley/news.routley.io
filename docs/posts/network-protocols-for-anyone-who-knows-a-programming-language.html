<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.destroyallsoftware.com/compendium/network-protocols?share_key=97d3ba4c24d21147">Original</a>
    <h1>Network Protocols for Anyone Who Knows a Programming Language</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<div>
  <div>
    <div>
  <a href="https://www.destroyallsoftware.com/compendium/network-protocols">
      
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8%2BCiA8L3JkZjpSREY%2BCjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8%2BGkqr6gAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc%2FM0PECKEsLCYNKyNGTWyUkVCTpjHKYDPz5peaH6%2F3ZpJsle0UJTZ%2BLfgL2CprpYiULKysiQ3Tc96Mmknm3M49n%2Fu995zuPReswZSS1uuGIJ3JaYFpr2MxtORoeMFKD114aA8rujrh9%2FuoaZ%2F3WMx46zJr1T73rzVHY7oClkbhcUXVcsIzwr61nGryjnCnkgxHhc%2BEBzS5oPCdqUfK%2FGpyoszfJmvBwCRY24QdiSqOVLGS1NLC8nKc6VRe%2Bb2P%2BRJ7LLMwL7FXvAedANN4cTDLFJPSk2HGZPbgws2grKiRP1TKnyMruYrMKutorJIgSY4BUfNSPSYxLnpMRop1s%2F9%2F%2B6rHR9zl6nYv1D8bxnsfNGxDsWAYX0eGUTwG2xNcZir52UMY%2FRC9UNGcB9C6CedXFS2yCxdb0P2ohrVwSbKJW%2BNxeDuFlhB03EDTcrlnv%2FucPEBwQ77qGvb2oV%2FOt678AHuMZ%2B%2FPgSnPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFVElEQVRogb2Za6hVRRTHf%2Fd4s4f2OD2sq5Ww8lFmGRSZpsT9kIKGhj2IXqII%2BSUyM62gzCA%2FVJJCkBGhSYqEopAhJaXckhAFyzIft%2F5d7KGGdK1MTLPbh9k7527Pnr3PPuf4hwN79lqz5r%2FOzKxZa3YTZxhmdg7QCtwF3Ay0AJcDR4H9QAewAfhA0vdZ9poaxjQBM%2BsNzIx%2BF%2Bbs1gY8J2lzmsIZccDMJgGLgcsKmlgLTJF0OCloqANm1gS8CDxfh7HagQmSdvsvG%2BaAmZWAd4GH62j2MDBS0q74RUMciMgvAx5qgPl24NZ4OZXqbb3B5AEGAkviRl1noAD5TmA7sAO4FBdWB5Pvjx0laXNzEaKVUCX5Y8BcYIGkkwk7g3B757YMG%2FOBO%2BoyA1WS3wtMTEaThL0eEcHZGbYG9MjNMoByubwEeCSH6l6gVdIPIaXOzs6ucrn8KTAWuDKgqpo3sZnNASbnUI3J%2F5LHrqR%2FgWnAyYDamJqWkJmNAdaTvemqIp8YYzduY1fCzsIzYGbNwBs0kHyEHQFZSy1LaAouJodQK3mAgwFZr1rC6MwM%2BXd45M3sXOABYJ%2BkT6oY56aA7EChPWBmA3H%2FbhpOAiMkbY30e%2BP2yqhIvhCYlTwDKozTjMt%2FeqWobCm6hMZlyBcEyAPMAFZF8T6E2aSTB9hW1IEhGfJF3vNrdCcf427g5TQDZjYUd1qHsC7TATMbbGbnJ163BLoc9NZ9P%2BCxgO4cM7uvwph9gdVAz0Df34FNqQ6YWQ8zWwrsBr42s7M98SUBw3u852sCejEWRHWyj%2FeBQVn9JB2r6EC0Npdx6oTtD9zuqZxW2nnwSX%2BB%2BwNCuAqY7o19HtmJ3K%2FA61DhEPLIP5gQDfOe9weM9zOzPgCSTgB3AjszCM2Iyk%2BAE4TThy5guqQjkHDAKwOT5KF7PN5TQe5jWvwg6Sdc%2FD8R0O9PFBgip3cFdOdJWhM3kjMwl%2FSU2J%2BB9YEBAOaa2fVxQ9I3wEsZfcZ7z1%2Bl6LyXtPO%2FA2Z2D%2FBCYIAhZtbTI9QR0O0JrIyiUIy3A%2FrQfdNWcmA5MFlSl%2F%2ByBBCFycUZA5SAs7z2ojTFCEOBDdFpiqSDQCgnusJ73p6QLQcejVLs00gBPImrSUPYIukvr%2F0m8GNGn%2BuAEV47dFV4sfe8mVMzvJQU8gClKMl6KoNIO3C%2F%2F0LS32QndF24pC6%2B5Lo2oHvIs30cuAEYLGlKGnlwM9AKXBAwfByYJOnnpEDSKuCVQN%2B3JMUhty%2Fhq8VuoVnSEUmhhBFwDozP0JkXbdo0PAusqfC%2BDZjltZ%2FIGCcUOlNRAm4JyI8Cr4YMRNN7L9HJGKENGBfvGTMbTvYyXZfJtgKazGwf7jivhM8ljc5rzMxagauBldEeiRO6NsACXfdICu2PVDTjPi6k4ctqjEna6Lcj8hsJkweXchdCCbdM0tCnqGGPfFbd3I4LlYVQIpyY3VjEaBXku4DHJf1TZBxwDnQE5IP8nCYPqiAP8Iykj6qxn0QJ%2BDhD%2Fk6O2hWomvwyMiJcHpSADzN0hgPz45wmDWY2hPzkVwBTk4lZETRFg39G5cLbxxZcNtitFogcexr3LSxUw8ZYgcttglcqeRE7MBoXq7PQhbsP2obLXYbhCp2Lco5XV%2FLgfaExs7XAxHoZroC6k4fuFdlUwuluLWgIefAckPQbMAF331JPxMVI3clDoiaW9C0wkiiHrwPm0UDykPKV0szKuE%2BZRffEIdzVx%2BqixPIieDttZqNwH9vyZqR%2F4BKzhZL%2BrJFbLuS6XjezAbjCZyzuDqcFd2t8IPptxeXzmyQdawzVyvgPNrS8HLK7HfoAAAAASUVORK5CYII%3D"/>
</a>  <p>The network stack does several seemingly-impossible things.
It does reliable transmission over our unreliable networks, usually without any detectable hiccups.
It adapts smoothly to network congestion.
It provides addressing to billions of active nodes.
It routes packets around damaged network infrastructure, reassembling them in the correct order on the other side even if they arrived out of order.
It accommodates esoteric analog hardware needs, like balancing the charge on the two ends of an Ethernet cable.
This all works so well that users never hear of it, and even most programmers don&#39;t know how it works.</p>
</div>

  <div>
  <a href="https://www.destroyallsoftware.com/compendium/network-routing">
      
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8%2BCiA8L3JkZjpSREY%2BCjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8%2BGkqr6gAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc%2FM0PECKEsLCYNKyNGTWyUkVCTpjHKYDPz5peaH6%2F3ZpJsle0UJTZ%2BLfgL2CprpYiULKysiQ3Tc96Mmknm3M49n%2Fu995zuPReswZSS1uuGIJ3JaYFpr2MxtORoeMFKD114aA8rujrh9%2FuoaZ%2F3WMx46zJr1T73rzVHY7oClkbhcUXVcsIzwr61nGryjnCnkgxHhc%2BEBzS5oPCdqUfK%2FGpyoszfJmvBwCRY24QdiSqOVLGS1NLC8nKc6VRe%2Bb2P%2BRJ7LLMwL7FXvAedANN4cTDLFJPSk2HGZPbgws2grKiRP1TKnyMruYrMKutorJIgSY4BUfNSPSYxLnpMRop1s%2F9%2F%2B6rHR9zl6nYv1D8bxnsfNGxDsWAYX0eGUTwG2xNcZir52UMY%2FRC9UNGcB9C6CedXFS2yCxdb0P2ohrVwSbKJW%2BNxeDuFlhB03EDTcrlnv%2FucPEBwQ77qGvb2oV%2FOt678AHuMZ%2B%2FPgSnPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFVElEQVRogb2Za6hVRRTHf%2Fd4s4f2OD2sq5Ww8lFmGRSZpsT9kIKGhj2IXqII%2BSUyM62gzCA%2FVJJCkBGhSYqEopAhJaXckhAFyzIft%2F5d7KGGdK1MTLPbh9k7527Pnr3PPuf4hwN79lqz5r%2FOzKxZa3YTZxhmdg7QCtwF3Ay0AJcDR4H9QAewAfhA0vdZ9poaxjQBM%2BsNzIx%2BF%2Bbs1gY8J2lzmsIZccDMJgGLgcsKmlgLTJF0OCloqANm1gS8CDxfh7HagQmSdvsvG%2BaAmZWAd4GH62j2MDBS0q74RUMciMgvAx5qgPl24NZ4OZXqbb3B5AEGAkviRl1noAD5TmA7sAO4FBdWB5Pvjx0laXNzEaKVUCX5Y8BcYIGkkwk7g3B757YMG%2FOBO%2BoyA1WS3wtMTEaThL0eEcHZGbYG9MjNMoByubwEeCSH6l6gVdIPIaXOzs6ucrn8KTAWuDKgqpo3sZnNASbnUI3J%2F5LHrqR%2FgWnAyYDamJqWkJmNAdaTvemqIp8YYzduY1fCzsIzYGbNwBs0kHyEHQFZSy1LaAouJodQK3mAgwFZr1rC6MwM%2BXd45M3sXOABYJ%2BkT6oY56aA7EChPWBmA3H%2FbhpOAiMkbY30e%2BP2yqhIvhCYlTwDKozTjMt%2FeqWobCm6hMZlyBcEyAPMAFZF8T6E2aSTB9hW1IEhGfJF3vNrdCcf427g5TQDZjYUd1qHsC7TATMbbGbnJ163BLoc9NZ9P%2BCxgO4cM7uvwph9gdVAz0Df34FNqQ6YWQ8zWwrsBr42s7M98SUBw3u852sCejEWRHWyj%2FeBQVn9JB2r6EC0Npdx6oTtD9zuqZxW2nnwSX%2BB%2BwNCuAqY7o19HtmJ3K%2FA61DhEPLIP5gQDfOe9weM9zOzPgCSTgB3AjszCM2Iyk%2BAE4TThy5guqQjkHDAKwOT5KF7PN5TQe5jWvwg6Sdc%2FD8R0O9PFBgip3cFdOdJWhM3kjMwl%2FSU2J%2BB9YEBAOaa2fVxQ9I3wEsZfcZ7z1%2Bl6LyXtPO%2FA2Z2D%2FBCYIAhZtbTI9QR0O0JrIyiUIy3A%2FrQfdNWcmA5MFlSl%2F%2ByBBCFycUZA5SAs7z2ojTFCEOBDdFpiqSDQCgnusJ73p6QLQcejVLs00gBPImrSUPYIukvr%2F0m8GNGn%2BuAEV47dFV4sfe8mVMzvJQU8gClKMl6KoNIO3C%2F%2F0LS32QndF24pC6%2B5Lo2oHvIs30cuAEYLGlKGnlwM9AKXBAwfByYJOnnpEDSKuCVQN%2B3JMUhty%2Fhq8VuoVnSEUmhhBFwDozP0JkXbdo0PAusqfC%2BDZjltZ%2FIGCcUOlNRAm4JyI8Cr4YMRNN7L9HJGKENGBfvGTMbTvYyXZfJtgKazGwf7jivhM8ljc5rzMxagauBldEeiRO6NsACXfdICu2PVDTjPi6k4ctqjEna6Lcj8hsJkweXchdCCbdM0tCnqGGPfFbd3I4LlYVQIpyY3VjEaBXku4DHJf1TZBxwDnQE5IP8nCYPqiAP8Iykj6qxn0QJ%2BDhD%2Fk6O2hWomvwyMiJcHpSADzN0hgPz45wmDWY2hPzkVwBTk4lZETRFg39G5cLbxxZcNtitFogcexr3LSxUw8ZYgcttglcqeRE7MBoXq7PQhbsP2obLXYbhCp2Lco5XV%2FLgfaExs7XAxHoZroC6k4fuFdlUwuluLWgIefAckPQbMAF331JPxMVI3clDoiaW9C0wkiiHrwPm0UDykPKV0szKuE%2BZRffEIdzVx%2BqixPIieDttZqNwH9vyZqR%2F4BKzhZL%2BrJFbLuS6XjezAbjCZyzuDqcFd2t8IPptxeXzmyQdawzVyvgPNrS8HLK7HfoAAAAASUVORK5CYII%3D"/>
</a>  <div>
    <p>In the old days of analog telephones, making a phone call meant a continuous electrical connection from your phone to your friend&#39;s.
It was as if a wire were run directly from you to them.
There was no such wire, of course – the connection was made through complex switching systems – but it was electrically equivalent to a single wire.</p>
<p>There are too many Internet nodes for it to work in this way.
We can&#39;t provide a direct, uninterruptible path from each machine to each other machine it wants to talk to.</p>
<p>Instead, data is bucket-brigaded – handed off from one router to the next, in a chain, each one bringing it closer to its destination.
Each router between my laptop and google.com is connected to a number of other routers, maintaining a crude routing table showing which routers are closer to which parts of the Internet.
When a packet arrives destined for google.com, a quick lookup in the routing table tells the router where the packet should go next to bring it closer to Google.
The packets are small, so each router in the chain ties up the next router for only a tiny fraction of a second.</p>
<p>Routing breaks down into two sub-problems.
First, addressing: what is the data&#39;s destination?
This is handled by <a href="https://en.wikipedia.org/wiki/Internet_Protocol">IP, the Internet Protocol</a>, whence IP addresses.
IPv4, still the most common version of IP, provides only 32 bits of address space.
It&#39;s <a href="https://blogs.igalia.com/dpino/2017/05/25/ipv4-exhaustion/">now fully allocated</a>, so adding a node to the public Internet requires reusing an existing IP address.
IPv6 allows 2<sup>128</sup> addresses (about 10<sup>38</sup>), but only has about 20% adoption as of 2017.</p>
<p>Now that we have addresses, we need to know how to route a packet through the Internet toward its destination.
Routing happens fast, so there&#39;s no time to query remote databases for routing information.
As an example, <a href="http://www.cisco.com/c/en/us/products/routers/asr-9922-router/index.html">Cisco ASR 9922</a> routers have a maximum capacity of 160 terabits per second.
Assuming full 1,500 byte packets (12,000 bits), that&#39;s 13,333,333,333 packets per second in a single 19 inch rack!</p>
<p>To route quickly, routers maintain <em>routing tables</em> indicating the paths to various groups of IP addresses.
When a new packet arrives, the router looks it up in the table, telling it which peer is closest to the destination.
It sends the packet to that peer and moves on to the next.
<a href="https://en.wikipedia.org/wiki/Border_Gateway_Protocol">BGP</a>&#39;s job is to communicate this routing table information between different routers, ensuring up-to-date route tables.</p>
<p>IP and BGP together don&#39;t make a useful Internet, unfortunately, because they provide no way to transfer data reliably.
If a router becomes overloaded and drops a packet, we need a way to detect the loss and request retransmission.</p>
  </div>
</div>


  <div>
  <a href="https://www.destroyallsoftware.com/compendium/packet-switching">
      
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8%2BCiA8L3JkZjpSREY%2BCjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8%2BGkqr6gAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc%2FM0PECKEsLCYNKyNGTWyUkVCTpjHKYDPz5peaH6%2F3ZpJsle0UJTZ%2BLfgL2CprpYiULKysiQ3Tc96Mmknm3M49n%2Fu995zuPReswZSS1uuGIJ3JaYFpr2MxtORoeMFKD114aA8rujrh9%2FuoaZ%2F3WMx46zJr1T73rzVHY7oClkbhcUXVcsIzwr61nGryjnCnkgxHhc%2BEBzS5oPCdqUfK%2FGpyoszfJmvBwCRY24QdiSqOVLGS1NLC8nKc6VRe%2Bb2P%2BRJ7LLMwL7FXvAedANN4cTDLFJPSk2HGZPbgws2grKiRP1TKnyMruYrMKutorJIgSY4BUfNSPSYxLnpMRop1s%2F9%2F%2B6rHR9zl6nYv1D8bxnsfNGxDsWAYX0eGUTwG2xNcZir52UMY%2FRC9UNGcB9C6CedXFS2yCxdb0P2ohrVwSbKJW%2BNxeDuFlhB03EDTcrlnv%2FucPEBwQ77qGvb2oV%2FOt678AHuMZ%2B%2FPgSnPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFVElEQVRogb2Za6hVRRTHf%2Fd4s4f2OD2sq5Ww8lFmGRSZpsT9kIKGhj2IXqII%2BSUyM62gzCA%2FVJJCkBGhSYqEopAhJaXckhAFyzIft%2F5d7KGGdK1MTLPbh9k7527Pnr3PPuf4hwN79lqz5r%2FOzKxZa3YTZxhmdg7QCtwF3Ay0AJcDR4H9QAewAfhA0vdZ9poaxjQBM%2BsNzIx%2BF%2Bbs1gY8J2lzmsIZccDMJgGLgcsKmlgLTJF0OCloqANm1gS8CDxfh7HagQmSdvsvG%2BaAmZWAd4GH62j2MDBS0q74RUMciMgvAx5qgPl24NZ4OZXqbb3B5AEGAkviRl1noAD5TmA7sAO4FBdWB5Pvjx0laXNzEaKVUCX5Y8BcYIGkkwk7g3B757YMG%2FOBO%2BoyA1WS3wtMTEaThL0eEcHZGbYG9MjNMoByubwEeCSH6l6gVdIPIaXOzs6ucrn8KTAWuDKgqpo3sZnNASbnUI3J%2F5LHrqR%2FgWnAyYDamJqWkJmNAdaTvemqIp8YYzduY1fCzsIzYGbNwBs0kHyEHQFZSy1LaAouJodQK3mAgwFZr1rC6MwM%2BXd45M3sXOABYJ%2BkT6oY56aA7EChPWBmA3H%2FbhpOAiMkbY30e%2BP2yqhIvhCYlTwDKozTjMt%2FeqWobCm6hMZlyBcEyAPMAFZF8T6E2aSTB9hW1IEhGfJF3vNrdCcf427g5TQDZjYUd1qHsC7TATMbbGbnJ163BLoc9NZ9P%2BCxgO4cM7uvwph9gdVAz0Df34FNqQ6YWQ8zWwrsBr42s7M98SUBw3u852sCejEWRHWyj%2FeBQVn9JB2r6EC0Npdx6oTtD9zuqZxW2nnwSX%2BB%2BwNCuAqY7o19HtmJ3K%2FA61DhEPLIP5gQDfOe9weM9zOzPgCSTgB3AjszCM2Iyk%2BAE4TThy5guqQjkHDAKwOT5KF7PN5TQe5jWvwg6Sdc%2FD8R0O9PFBgip3cFdOdJWhM3kjMwl%2FSU2J%2BB9YEBAOaa2fVxQ9I3wEsZfcZ7z1%2Bl6LyXtPO%2FA2Z2D%2FBCYIAhZtbTI9QR0O0JrIyiUIy3A%2FrQfdNWcmA5MFlSl%2F%2ByBBCFycUZA5SAs7z2ojTFCEOBDdFpiqSDQCgnusJ73p6QLQcejVLs00gBPImrSUPYIukvr%2F0m8GNGn%2BuAEV47dFV4sfe8mVMzvJQU8gClKMl6KoNIO3C%2F%2F0LS32QndF24pC6%2B5Lo2oHvIs30cuAEYLGlKGnlwM9AKXBAwfByYJOnnpEDSKuCVQN%2B3JMUhty%2Fhq8VuoVnSEUmhhBFwDozP0JkXbdo0PAusqfC%2BDZjltZ%2FIGCcUOlNRAm4JyI8Cr4YMRNN7L9HJGKENGBfvGTMbTvYyXZfJtgKazGwf7jivhM8ljc5rzMxagauBldEeiRO6NsACXfdICu2PVDTjPi6k4ctqjEna6Lcj8hsJkweXchdCCbdM0tCnqGGPfFbd3I4LlYVQIpyY3VjEaBXku4DHJf1TZBxwDnQE5IP8nCYPqiAP8Iykj6qxn0QJ%2BDhD%2Fk6O2hWomvwyMiJcHpSADzN0hgPz45wmDWY2hPzkVwBTk4lZETRFg39G5cLbxxZcNtitFogcexr3LSxUw8ZYgcttglcqeRE7MBoXq7PQhbsP2obLXYbhCp2Lco5XV%2FLgfaExs7XAxHoZroC6k4fuFdlUwuluLWgIefAckPQbMAF331JPxMVI3clDoiaW9C0wkiiHrwPm0UDykPKV0szKuE%2BZRffEIdzVx%2BqixPIieDttZqNwH9vyZqR%2F4BKzhZL%2BrJFbLuS6XjezAbjCZyzuDqcFd2t8IPptxeXzmyQdawzVyvgPNrS8HLK7HfoAAAAASUVORK5CYII%3D"/>
</a>  <div>
    <p>If the Internet works by routers handing data to each other down the line, what happens when the data is large?
What if we request the 88.5 MB video of <a href="https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript">The Birth &amp; Death of JavaScript</a>?</p>
<p>We could try to design a network where the 88.5 MB document is sent from the web server to the first router, then to the second, and so on.
Unfortunately, that network wouldn&#39;t work at Internet scale, or even at intranet scale.</p>
<p>First, computers are finite machines with finite amounts of storage.
If a given router has only 88.4 MB of buffer memory available, it simply can&#39;t store the 88.5 MB video file.
The data will be dropped on the floor and, worse, I&#39;ll get no indication.
If a router is so busy that it&#39;s dropping data, it can&#39;t take the time to tell me about dropped data.</p>
<p>Second, computers are unreliable.
Sometimes, routing nodes fail.
Sometimes, ships&#39; anchors accidentally damage underwater fiber-optic cables, <a href="https://en.wikipedia.org/wiki/2008_submarine_cable_disruption">taking out large portions of the Internet</a>.</p>
<p>For these reasons and more, we don&#39;t send 88.5 MB messages across the Internet.
Instead, we break them down into packets, usually in the neighborhood of 1,400 bytes each.
Our video file will be broken into 63,214 or so separate packets for transmission.</p>
  </div>
</div>


  <div>
  <a href="https://www.destroyallsoftware.com/compendium/out-of-order-packets">
      
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8%2BCiA8L3JkZjpSREY%2BCjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8%2BGkqr6gAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc%2FM0PECKEsLCYNKyNGTWyUkVCTpjHKYDPz5peaH6%2F3ZpJsle0UJTZ%2BLfgL2CprpYiULKysiQ3Tc96Mmknm3M49n%2Fu995zuPReswZSS1uuGIJ3JaYFpr2MxtORoeMFKD114aA8rujrh9%2FuoaZ%2F3WMx46zJr1T73rzVHY7oClkbhcUXVcsIzwr61nGryjnCnkgxHhc%2BEBzS5oPCdqUfK%2FGpyoszfJmvBwCRY24QdiSqOVLGS1NLC8nKc6VRe%2Bb2P%2BRJ7LLMwL7FXvAedANN4cTDLFJPSk2HGZPbgws2grKiRP1TKnyMruYrMKutorJIgSY4BUfNSPSYxLnpMRop1s%2F9%2F%2B6rHR9zl6nYv1D8bxnsfNGxDsWAYX0eGUTwG2xNcZir52UMY%2FRC9UNGcB9C6CedXFS2yCxdb0P2ohrVwSbKJW%2BNxeDuFlhB03EDTcrlnv%2FucPEBwQ77qGvb2oV%2FOt678AHuMZ%2B%2FPgSnPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFVElEQVRogb2Za6hVRRTHf%2Fd4s4f2OD2sq5Ww8lFmGRSZpsT9kIKGhj2IXqII%2BSUyM62gzCA%2FVJJCkBGhSYqEopAhJaXckhAFyzIft%2F5d7KGGdK1MTLPbh9k7527Pnr3PPuf4hwN79lqz5r%2FOzKxZa3YTZxhmdg7QCtwF3Ay0AJcDR4H9QAewAfhA0vdZ9poaxjQBM%2BsNzIx%2BF%2Bbs1gY8J2lzmsIZccDMJgGLgcsKmlgLTJF0OCloqANm1gS8CDxfh7HagQmSdvsvG%2BaAmZWAd4GH62j2MDBS0q74RUMciMgvAx5qgPl24NZ4OZXqbb3B5AEGAkviRl1noAD5TmA7sAO4FBdWB5Pvjx0laXNzEaKVUCX5Y8BcYIGkkwk7g3B757YMG%2FOBO%2BoyA1WS3wtMTEaThL0eEcHZGbYG9MjNMoByubwEeCSH6l6gVdIPIaXOzs6ucrn8KTAWuDKgqpo3sZnNASbnUI3J%2F5LHrqR%2FgWnAyYDamJqWkJmNAdaTvemqIp8YYzduY1fCzsIzYGbNwBs0kHyEHQFZSy1LaAouJodQK3mAgwFZr1rC6MwM%2BXd45M3sXOABYJ%2BkT6oY56aA7EChPWBmA3H%2FbhpOAiMkbY30e%2BP2yqhIvhCYlTwDKozTjMt%2FeqWobCm6hMZlyBcEyAPMAFZF8T6E2aSTB9hW1IEhGfJF3vNrdCcf427g5TQDZjYUd1qHsC7TATMbbGbnJ163BLoc9NZ9P%2BCxgO4cM7uvwph9gdVAz0Df34FNqQ6YWQ8zWwrsBr42s7M98SUBw3u852sCejEWRHWyj%2FeBQVn9JB2r6EC0Npdx6oTtD9zuqZxW2nnwSX%2BB%2BwNCuAqY7o19HtmJ3K%2FA61DhEPLIP5gQDfOe9weM9zOzPgCSTgB3AjszCM2Iyk%2BAE4TThy5guqQjkHDAKwOT5KF7PN5TQe5jWvwg6Sdc%2FD8R0O9PFBgip3cFdOdJWhM3kjMwl%2FSU2J%2BB9YEBAOaa2fVxQ9I3wEsZfcZ7z1%2Bl6LyXtPO%2FA2Z2D%2FBCYIAhZtbTI9QR0O0JrIyiUIy3A%2FrQfdNWcmA5MFlSl%2F%2ByBBCFycUZA5SAs7z2ojTFCEOBDdFpiqSDQCgnusJ73p6QLQcejVLs00gBPImrSUPYIukvr%2F0m8GNGn%2BuAEV47dFV4sfe8mVMzvJQU8gClKMl6KoNIO3C%2F%2F0LS32QndF24pC6%2B5Lo2oHvIs30cuAEYLGlKGnlwM9AKXBAwfByYJOnnpEDSKuCVQN%2B3JMUhty%2Fhq8VuoVnSEUmhhBFwDozP0JkXbdo0PAusqfC%2BDZjltZ%2FIGCcUOlNRAm4JyI8Cr4YMRNN7L9HJGKENGBfvGTMbTvYyXZfJtgKazGwf7jivhM8ljc5rzMxagauBldEeiRO6NsACXfdICu2PVDTjPi6k4ctqjEna6Lcj8hsJkweXchdCCbdM0tCnqGGPfFbd3I4LlYVQIpyY3VjEaBXku4DHJf1TZBxwDnQE5IP8nCYPqiAP8Iykj6qxn0QJ%2BDhD%2Fk6O2hWomvwyMiJcHpSADzN0hgPz45wmDWY2hPzkVwBTk4lZETRFg39G5cLbxxZcNtitFogcexr3LSxUw8ZYgcttglcqeRE7MBoXq7PQhbsP2obLXYbhCp2Lco5XV%2FLgfaExs7XAxHoZroC6k4fuFdlUwuluLWgIefAckPQbMAF331JPxMVI3clDoiaW9C0wkiiHrwPm0UDykPKV0szKuE%2BZRffEIdzVx%2BqixPIieDttZqNwH9vyZqR%2F4BKzhZL%2BrJFbLuS6XjezAbjCZyzuDqcFd2t8IPptxeXzmyQdawzVyvgPNrS8HLK7HfoAAAAASUVORK5CYII%3D"/>
</a>  <div>
    <p>Measuring an actual transfer of <a href="https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript">The Birth &amp; Death of JavaScript</a> with the packet capture tool <a href="https://www.wireshark.org/">Wireshark</a>, I see a total of 61,807 packets received, each 1,432 bytes.
Multiplying those two, we get 88.5 megabytes, which is the size of the video.
(This doesn&#39;t include the overhead added by various protocols; if it did, we&#39;d see a slightly higher number.)</p>
<p>The transfer was done over HTTP, a protocol layered over <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP, the Transmission Control Protocol</a>.
It only took 14 seconds, so the packets arrived at an average rate of about 4,400 per second, or about 250 microseconds per packet.
In 14 seconds, my machine received all 61,807 of those packets, possibly out-of-order, reassembling them into the full file as they came in.</p>
<p>TCP packet reassembly is done using the simplest imaginable mechanism: a counter.
Each packet is assigned a <em>sequence number</em> when it&#39;s sent.
On the receiving side, the packets are put in order by sequence number.
Once they&#39;re all in order, with no gaps, we know the whole file is present.</p>
<p>(Actual TCP sequence numbers tend not to be integers simply increasing by 1 each time, but that detail isn&#39;t important here.)</p>
<p>How do we know when the file is finished, though?
TCP doesn&#39;t say anything about that; it&#39;s the job of higher-level protocols.
For example, HTTP responses contain a &#34;Content-Length&#34; header specifying the response length in bytes.
The client reads the Content-Length, then keeps reading TCP packets, assembling them back into their original order, until it has all of the bytes specified by Content-Length.
This is one reason that HTTP headers (and most other protocols&#39; headers) come before the response payload: otherwise, we wouldn&#39;t know the payload&#39;s size.</p>
<p>When we say &#34;the client&#34; here, we&#39;re really talking about the entire receiving computer.
TCP reassembly happens inside the kernel, so applications like web browsers and curl and wget don&#39;t have to manually reassemble TCP packets.
But the kernel doesn&#39;t handle HTTP, so applications do have to understand the Content-Length header and know how many bytes to read.</p>
<p>With sequence numbers and packet reordering, we can transmit large sequences of bytes even if the packets arrive out-of-order.
But what if a packet is lost in transit, leaving a hole in the HTTP response?</p>
  </div>
</div>


  <div>
  <a href="https://www.destroyallsoftware.com/compendium/transmission-windows-and-slow-start">
      
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8%2BCiA8L3JkZjpSREY%2BCjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8%2BGkqr6gAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc%2FM0PECKEsLCYNKyNGTWyUkVCTpjHKYDPz5peaH6%2F3ZpJsle0UJTZ%2BLfgL2CprpYiULKysiQ3Tc96Mmknm3M49n%2Fu995zuPReswZSS1uuGIJ3JaYFpr2MxtORoeMFKD114aA8rujrh9%2FuoaZ%2F3WMx46zJr1T73rzVHY7oClkbhcUXVcsIzwr61nGryjnCnkgxHhc%2BEBzS5oPCdqUfK%2FGpyoszfJmvBwCRY24QdiSqOVLGS1NLC8nKc6VRe%2Bb2P%2BRJ7LLMwL7FXvAedANN4cTDLFJPSk2HGZPbgws2grKiRP1TKnyMruYrMKutorJIgSY4BUfNSPSYxLnpMRop1s%2F9%2F%2B6rHR9zl6nYv1D8bxnsfNGxDsWAYX0eGUTwG2xNcZir52UMY%2FRC9UNGcB9C6CedXFS2yCxdb0P2ohrVwSbKJW%2BNxeDuFlhB03EDTcrlnv%2FucPEBwQ77qGvb2oV%2FOt678AHuMZ%2B%2FPgSnPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFVElEQVRogb2Za6hVRRTHf%2Fd4s4f2OD2sq5Ww8lFmGRSZpsT9kIKGhj2IXqII%2BSUyM62gzCA%2FVJJCkBGhSYqEopAhJaXckhAFyzIft%2F5d7KGGdK1MTLPbh9k7527Pnr3PPuf4hwN79lqz5r%2FOzKxZa3YTZxhmdg7QCtwF3Ay0AJcDR4H9QAewAfhA0vdZ9poaxjQBM%2BsNzIx%2BF%2Bbs1gY8J2lzmsIZccDMJgGLgcsKmlgLTJF0OCloqANm1gS8CDxfh7HagQmSdvsvG%2BaAmZWAd4GH62j2MDBS0q74RUMciMgvAx5qgPl24NZ4OZXqbb3B5AEGAkviRl1noAD5TmA7sAO4FBdWB5Pvjx0laXNzEaKVUCX5Y8BcYIGkkwk7g3B757YMG%2FOBO%2BoyA1WS3wtMTEaThL0eEcHZGbYG9MjNMoByubwEeCSH6l6gVdIPIaXOzs6ucrn8KTAWuDKgqpo3sZnNASbnUI3J%2F5LHrqR%2FgWnAyYDamJqWkJmNAdaTvemqIp8YYzduY1fCzsIzYGbNwBs0kHyEHQFZSy1LaAouJodQK3mAgwFZr1rC6MwM%2BXd45M3sXOABYJ%2BkT6oY56aA7EChPWBmA3H%2FbhpOAiMkbY30e%2BP2yqhIvhCYlTwDKozTjMt%2FeqWobCm6hMZlyBcEyAPMAFZF8T6E2aSTB9hW1IEhGfJF3vNrdCcf427g5TQDZjYUd1qHsC7TATMbbGbnJ163BLoc9NZ9P%2BCxgO4cM7uvwph9gdVAz0Df34FNqQ6YWQ8zWwrsBr42s7M98SUBw3u852sCejEWRHWyj%2FeBQVn9JB2r6EC0Npdx6oTtD9zuqZxW2nnwSX%2BB%2BwNCuAqY7o19HtmJ3K%2FA61DhEPLIP5gQDfOe9weM9zOzPgCSTgB3AjszCM2Iyk%2BAE4TThy5guqQjkHDAKwOT5KF7PN5TQe5jWvwg6Sdc%2FD8R0O9PFBgip3cFdOdJWhM3kjMwl%2FSU2J%2BB9YEBAOaa2fVxQ9I3wEsZfcZ7z1%2Bl6LyXtPO%2FA2Z2D%2FBCYIAhZtbTI9QR0O0JrIyiUIy3A%2FrQfdNWcmA5MFlSl%2F%2ByBBCFycUZA5SAs7z2ojTFCEOBDdFpiqSDQCgnusJ73p6QLQcejVLs00gBPImrSUPYIukvr%2F0m8GNGn%2BuAEV47dFV4sfe8mVMzvJQU8gClKMl6KoNIO3C%2F%2F0LS32QndF24pC6%2B5Lo2oHvIs30cuAEYLGlKGnlwM9AKXBAwfByYJOnnpEDSKuCVQN%2B3JMUhty%2Fhq8VuoVnSEUmhhBFwDozP0JkXbdo0PAusqfC%2BDZjltZ%2FIGCcUOlNRAm4JyI8Cr4YMRNN7L9HJGKENGBfvGTMbTvYyXZfJtgKazGwf7jivhM8ljc5rzMxagauBldEeiRO6NsACXfdICu2PVDTjPi6k4ctqjEna6Lcj8hsJkweXchdCCbdM0tCnqGGPfFbd3I4LlYVQIpyY3VjEaBXku4DHJf1TZBxwDnQE5IP8nCYPqiAP8Iykj6qxn0QJ%2BDhD%2Fk6O2hWomvwyMiJcHpSADzN0hgPz45wmDWY2hPzkVwBTk4lZETRFg39G5cLbxxZcNtitFogcexr3LSxUw8ZYgcttglcqeRE7MBoXq7PQhbsP2obLXYbhCp2Lco5XV%2FLgfaExs7XAxHoZroC6k4fuFdlUwuluLWgIefAckPQbMAF331JPxMVI3clDoiaW9C0wkiiHrwPm0UDykPKV0szKuE%2BZRffEIdzVx%2BqixPIieDttZqNwH9vyZqR%2F4BKzhZL%2BrJFbLuS6XjezAbjCZyzuDqcFd2t8IPptxeXzmyQdawzVyvgPNrS8HLK7HfoAAAAASUVORK5CYII%3D"/>
</a>  <div>
    <p>I did a normal download of <a href="https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript">The Birth &amp; Death of JavaScript</a> with <a href="https://www.wireshark.org/">Wireshark</a> turned on.
Scrolling through the capture, I see packet after packet being received successfully.</p>
<p>For example, a packet with sequence number 563,321 arrived.
Like all TCP packets, it had a &#34;next sequence number&#34;, which is the number used for the following packet.
This packet&#39;s &#34;next sequence number&#34; was 564,753.
The next packet did, in fact, have sequence number 564,753, so everything was good.
This happens thousands of times per second once the connection gets up to speed.</p>
<p>Occasionally, my computer sends a message to the server saying, for example, &#34;I&#39;ve received all packets up to and including packet number 564,753.&#34;
That&#39;s an ACK, for <em>acknowledgement</em>: my computer acknowledges receipt of the server&#39;s packets.
On a new connection, the Linux kernel sends an ACK after every ten packets.
This is controlled by the <code>TCP_INIT_CWND</code> constant, which we can see <a href="http://elixir.free-electrons.com/linux/v4.5/source/include/net/tcp.h#L220">defined</a> in the Linux kernel&#39;s source code.</p>
<p>(The <code>CWND</code> in <code>TCP_INIT_CWND</code> stands for <em>congestion window</em>: the amount of data allowed in flight at once.
If the network becomes <em>congested</em> – overloaded – then the window size will be reduced, slowing packet transmission.)</p>
<p>Ten packets is about 14 KB, so we&#39;re limited to 14 KB of data in flight at a time.
This is part of <em>TCP slow start</em>: connections begin with small congestion windows.
If no packets are lost, the receiver will continually increase the congestion window, allowing more packets in flight at once.</p>
<p>Eventually, a packet will be lost, so the receive window will be decreased, slowing transmission.
By automatically adjusting the congestion window, as well as some other parameters, the sender and receiver keep data moving as quickly as the network will allow, but no quicker.</p>
<p>This happens on both sides of the connection: each side ACKs the other side&#39;s messages, and each side maintains its own congestion window.
Asymmetric windows allow the protocol to take full advantage of network connections with asymmetric upstream and downstream bandwidth, like most residential and mobile Internet connections.</p>
  </div>
</div>


  <div>
  <a href="https://www.destroyallsoftware.com/compendium/reliable-transmission">
      
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8%2BCiA8L3JkZjpSREY%2BCjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8%2BGkqr6gAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc%2FM0PECKEsLCYNKyNGTWyUkVCTpjHKYDPz5peaH6%2F3ZpJsle0UJTZ%2BLfgL2CprpYiULKysiQ3Tc96Mmknm3M49n%2Fu995zuPReswZSS1uuGIJ3JaYFpr2MxtORoeMFKD114aA8rujrh9%2FuoaZ%2F3WMx46zJr1T73rzVHY7oClkbhcUXVcsIzwr61nGryjnCnkgxHhc%2BEBzS5oPCdqUfK%2FGpyoszfJmvBwCRY24QdiSqOVLGS1NLC8nKc6VRe%2Bb2P%2BRJ7LLMwL7FXvAedANN4cTDLFJPSk2HGZPbgws2grKiRP1TKnyMruYrMKutorJIgSY4BUfNSPSYxLnpMRop1s%2F9%2F%2B6rHR9zl6nYv1D8bxnsfNGxDsWAYX0eGUTwG2xNcZir52UMY%2FRC9UNGcB9C6CedXFS2yCxdb0P2ohrVwSbKJW%2BNxeDuFlhB03EDTcrlnv%2FucPEBwQ77qGvb2oV%2FOt678AHuMZ%2B%2FPgSnPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFVElEQVRogb2Za6hVRRTHf%2Fd4s4f2OD2sq5Ww8lFmGRSZpsT9kIKGhj2IXqII%2BSUyM62gzCA%2FVJJCkBGhSYqEopAhJaXckhAFyzIft%2F5d7KGGdK1MTLPbh9k7527Pnr3PPuf4hwN79lqz5r%2FOzKxZa3YTZxhmdg7QCtwF3Ay0AJcDR4H9QAewAfhA0vdZ9poaxjQBM%2BsNzIx%2BF%2Bbs1gY8J2lzmsIZccDMJgGLgcsKmlgLTJF0OCloqANm1gS8CDxfh7HagQmSdvsvG%2BaAmZWAd4GH62j2MDBS0q74RUMciMgvAx5qgPl24NZ4OZXqbb3B5AEGAkviRl1noAD5TmA7sAO4FBdWB5Pvjx0laXNzEaKVUCX5Y8BcYIGkkwk7g3B757YMG%2FOBO%2BoyA1WS3wtMTEaThL0eEcHZGbYG9MjNMoByubwEeCSH6l6gVdIPIaXOzs6ucrn8KTAWuDKgqpo3sZnNASbnUI3J%2F5LHrqR%2FgWnAyYDamJqWkJmNAdaTvemqIp8YYzduY1fCzsIzYGbNwBs0kHyEHQFZSy1LaAouJodQK3mAgwFZr1rC6MwM%2BXd45M3sXOABYJ%2BkT6oY56aA7EChPWBmA3H%2FbhpOAiMkbY30e%2BP2yqhIvhCYlTwDKozTjMt%2FeqWobCm6hMZlyBcEyAPMAFZF8T6E2aSTB9hW1IEhGfJF3vNrdCcf427g5TQDZjYUd1qHsC7TATMbbGbnJ163BLoc9NZ9P%2BCxgO4cM7uvwph9gdVAz0Df34FNqQ6YWQ8zWwrsBr42s7M98SUBw3u852sCejEWRHWyj%2FeBQVn9JB2r6EC0Npdx6oTtD9zuqZxW2nnwSX%2BB%2BwNCuAqY7o19HtmJ3K%2FA61DhEPLIP5gQDfOe9weM9zOzPgCSTgB3AjszCM2Iyk%2BAE4TThy5guqQjkHDAKwOT5KF7PN5TQe5jWvwg6Sdc%2FD8R0O9PFBgip3cFdOdJWhM3kjMwl%2FSU2J%2BB9YEBAOaa2fVxQ9I3wEsZfcZ7z1%2Bl6LyXtPO%2FA2Z2D%2FBCYIAhZtbTI9QR0O0JrIyiUIy3A%2FrQfdNWcmA5MFlSl%2F%2ByBBCFycUZA5SAs7z2ojTFCEOBDdFpiqSDQCgnusJ73p6QLQcejVLs00gBPImrSUPYIukvr%2F0m8GNGn%2BuAEV47dFV4sfe8mVMzvJQU8gClKMl6KoNIO3C%2F%2F0LS32QndF24pC6%2B5Lo2oHvIs30cuAEYLGlKGnlwM9AKXBAwfByYJOnnpEDSKuCVQN%2B3JMUhty%2Fhq8VuoVnSEUmhhBFwDozP0JkXbdo0PAusqfC%2BDZjltZ%2FIGCcUOlNRAm4JyI8Cr4YMRNN7L9HJGKENGBfvGTMbTvYyXZfJtgKazGwf7jivhM8ljc5rzMxagauBldEeiRO6NsACXfdICu2PVDTjPi6k4ctqjEna6Lcj8hsJkweXchdCCbdM0tCnqGGPfFbd3I4LlYVQIpyY3VjEaBXku4DHJf1TZBxwDnQE5IP8nCYPqiAP8Iykj6qxn0QJ%2BDhD%2Fk6O2hWomvwyMiJcHpSADzN0hgPz45wmDWY2hPzkVwBTk4lZETRFg39G5cLbxxZcNtitFogcexr3LSxUw8ZYgcttglcqeRE7MBoXq7PQhbsP2obLXYbhCp2Lco5XV%2FLgfaExs7XAxHoZroC6k4fuFdlUwuluLWgIefAckPQbMAF331JPxMVI3clDoiaW9C0wkiiHrwPm0UDykPKV0szKuE%2BZRffEIdzVx%2BqixPIieDttZqNwH9vyZqR%2F4BKzhZL%2BrJFbLuS6XjezAbjCZyzuDqcFd2t8IPptxeXzmyQdawzVyvgPNrS8HLK7HfoAAAAASUVORK5CYII%3D"/>
</a>  <div>
    <p>Computers are unreliable; networks made of computers are extra unreliable.
On a large-scale network like the Internet, failure is a normal part of operation and must be accommodated.
In a packet network, this means <em>retransmission</em>: if the client receives packets number 1 and 3, but doesn&#39;t receive 2, then it needs to ask the server to re-send the missing packet.</p>
<p>When receiving thousands of packets per second, as in our 88.5 MB video download, mistakes are almost guaranteed.
To demonstrate that, let&#39;s return to my Wireshark capture of the download.
For thousands of packets, everything goes normally.
Each packet specifies a &#34;next sequence number&#34;, followed by another packet with that number.</p>
<p>Suddenly, something goes wrong.
The 6,269th packet has a &#34;next sequence number&#34; of 7,208,745, but that packet never comes.
Instead, a packet with sequence number 7,211,609 arrives.
This is an out-of-order packet: something is missing.</p>
<p>We can&#39;t tell exactly what went wrong here.
Maybe one of the intermediate routers on the Internet was overloaded.
Maybe my local router was overloaded.
Maybe someone turned a microwave on, introducing electromagnetic interference and slowing my wireless connection.
In any case, the packet was lost and the only indication is the unexpected packet.</p>
<p>TCP has no special &#34;I lost a packet!&#34; message.
Instead, ACKs are cleverly reused to indicate loss.
Any out-of-order packet causes the receiver to re-ACK the last &#34;good&#34; packet – the last one in the correct order.
In effect, the receiver is saying &#34;I received packet 5, which I&#39;m ACKing. I also received something after that, but I know it wasn&#39;t packet 6 because it didn&#39;t match the next sequence number in packet 5.&#34;</p>
<p>If two packets simply got switched in transit, this will result in a single extra ACK and everything will continue normally after the out-of-order packet is received.
But if the packet was truly lost, unexpected packets will continue to arrive and the receiver will continue to send duplicate ACKs of the last good packet.
This can result in hundreds of duplicate ACKs.</p>
<p>When the sender sees three duplicate ACKs in a row, it assumes that the following packet was lost and retransmits it.
This is called <em>TCP fast retransmit</em> because it&#39;s faster than the older, timeout-based approach.
It&#39;s interesting to note that the protocol itself doesn&#39;t have any explicit way to say &#34;please retransmit this immediately!&#34;
Instead, multiple ACKs arising naturally from the protocol serve as the trigger.</p>
<p>(An interesting thought experiment: what happens if some of the duplicate ACKs are lost, never reaching the sender?)</p>
<p>Retransmission is common even in networks working normally.
In a capture of our 88.5 MB video download, I saw this:</p>
<ul>
<li>The congestion window quickly increases to about a megabyte due to continuing successful transmission.</li>
<li>A few thousand packets show up in order; everything is normal.</li>
<li>One packet comes out of order.</li>
<li>Data continues pouring in at megabytes per second, but the packet is still missing.</li>
<li>My machine sends dozens of duplicate ACKs of the last known-good packet, but the kernel also stores the pending out-of-order packets for later reassembly.</li>
<li>The server receives the duplicate ACKs and resends the missing packet.</li>
<li>My client ACKs both the previously-missing packet and the later ones that were already received due to out-of-order transmission.
This is done by simply ACKing the most recent packet, which implicitly ACKs all earlier ones as well.</li>
<li>The transfer continues, but with a reduced congestion window due to the lost packet.</li>
</ul>
<p>This is normal; it&#39;s happened in every capture of the full download that I&#39;ve done.
TCP is so successful at its job that we don&#39;t even think of networks as being unreliable in our daily use, even though they fail routinely under normal conditions.</p>
  </div>
</div>


  <div>
  <a href="https://www.destroyallsoftware.com/compendium/physical-networking">
      
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8%2BCiA8L3JkZjpSREY%2BCjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8%2BGkqr6gAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc%2FM0PECKEsLCYNKyNGTWyUkVCTpjHKYDPz5peaH6%2F3ZpJsle0UJTZ%2BLfgL2CprpYiULKysiQ3Tc96Mmknm3M49n%2Fu995zuPReswZSS1uuGIJ3JaYFpr2MxtORoeMFKD114aA8rujrh9%2FuoaZ%2F3WMx46zJr1T73rzVHY7oClkbhcUXVcsIzwr61nGryjnCnkgxHhc%2BEBzS5oPCdqUfK%2FGpyoszfJmvBwCRY24QdiSqOVLGS1NLC8nKc6VRe%2Bb2P%2BRJ7LLMwL7FXvAedANN4cTDLFJPSk2HGZPbgws2grKiRP1TKnyMruYrMKutorJIgSY4BUfNSPSYxLnpMRop1s%2F9%2F%2B6rHR9zl6nYv1D8bxnsfNGxDsWAYX0eGUTwG2xNcZir52UMY%2FRC9UNGcB9C6CedXFS2yCxdb0P2ohrVwSbKJW%2BNxeDuFlhB03EDTcrlnv%2FucPEBwQ77qGvb2oV%2FOt678AHuMZ%2B%2FPgSnPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFVElEQVRogb2Za6hVRRTHf%2Fd4s4f2OD2sq5Ww8lFmGRSZpsT9kIKGhj2IXqII%2BSUyM62gzCA%2FVJJCkBGhSYqEopAhJaXckhAFyzIft%2F5d7KGGdK1MTLPbh9k7527Pnr3PPuf4hwN79lqz5r%2FOzKxZa3YTZxhmdg7QCtwF3Ay0AJcDR4H9QAewAfhA0vdZ9poaxjQBM%2BsNzIx%2BF%2Bbs1gY8J2lzmsIZccDMJgGLgcsKmlgLTJF0OCloqANm1gS8CDxfh7HagQmSdvsvG%2BaAmZWAd4GH62j2MDBS0q74RUMciMgvAx5qgPl24NZ4OZXqbb3B5AEGAkviRl1noAD5TmA7sAO4FBdWB5Pvjx0laXNzEaKVUCX5Y8BcYIGkkwk7g3B757YMG%2FOBO%2BoyA1WS3wtMTEaThL0eEcHZGbYG9MjNMoByubwEeCSH6l6gVdIPIaXOzs6ucrn8KTAWuDKgqpo3sZnNASbnUI3J%2F5LHrqR%2FgWnAyYDamJqWkJmNAdaTvemqIp8YYzduY1fCzsIzYGbNwBs0kHyEHQFZSy1LaAouJodQK3mAgwFZr1rC6MwM%2BXd45M3sXOABYJ%2BkT6oY56aA7EChPWBmA3H%2FbhpOAiMkbY30e%2BP2yqhIvhCYlTwDKozTjMt%2FeqWobCm6hMZlyBcEyAPMAFZF8T6E2aSTB9hW1IEhGfJF3vNrdCcf427g5TQDZjYUd1qHsC7TATMbbGbnJ163BLoc9NZ9P%2BCxgO4cM7uvwph9gdVAz0Df34FNqQ6YWQ8zWwrsBr42s7M98SUBw3u852sCejEWRHWyj%2FeBQVn9JB2r6EC0Npdx6oTtD9zuqZxW2nnwSX%2BB%2BwNCuAqY7o19HtmJ3K%2FA61DhEPLIP5gQDfOe9weM9zOzPgCSTgB3AjszCM2Iyk%2BAE4TThy5guqQjkHDAKwOT5KF7PN5TQe5jWvwg6Sdc%2FD8R0O9PFBgip3cFdOdJWhM3kjMwl%2FSU2J%2BB9YEBAOaa2fVxQ9I3wEsZfcZ7z1%2Bl6LyXtPO%2FA2Z2D%2FBCYIAhZtbTI9QR0O0JrIyiUIy3A%2FrQfdNWcmA5MFlSl%2F%2ByBBCFycUZA5SAs7z2ojTFCEOBDdFpiqSDQCgnusJ73p6QLQcejVLs00gBPImrSUPYIukvr%2F0m8GNGn%2BuAEV47dFV4sfe8mVMzvJQU8gClKMl6KoNIO3C%2F%2F0LS32QndF24pC6%2B5Lo2oHvIs30cuAEYLGlKGnlwM9AKXBAwfByYJOnnpEDSKuCVQN%2B3JMUhty%2Fhq8VuoVnSEUmhhBFwDozP0JkXbdo0PAusqfC%2BDZjltZ%2FIGCcUOlNRAm4JyI8Cr4YMRNN7L9HJGKENGBfvGTMbTvYyXZfJtgKazGwf7jivhM8ljc5rzMxagauBldEeiRO6NsACXfdICu2PVDTjPi6k4ctqjEna6Lcj8hsJkweXchdCCbdM0tCnqGGPfFbd3I4LlYVQIpyY3VjEaBXku4DHJf1TZBxwDnQE5IP8nCYPqiAP8Iykj6qxn0QJ%2BDhD%2Fk6O2hWomvwyMiJcHpSADzN0hgPz45wmDWY2hPzkVwBTk4lZETRFg39G5cLbxxZcNtitFogcexr3LSxUw8ZYgcttglcqeRE7MBoXq7PQhbsP2obLXYbhCp2Lco5XV%2FLgfaExs7XAxHoZroC6k4fuFdlUwuluLWgIefAckPQbMAF331JPxMVI3clDoiaW9C0wkiiHrwPm0UDykPKV0szKuE%2BZRffEIdzVx%2BqixPIieDttZqNwH9vyZqR%2F4BKzhZL%2BrJFbLuS6XjezAbjCZyzuDqcFd2t8IPptxeXzmyQdawzVyvgPNrS8HLK7HfoAAAAASUVORK5CYII%3D"/>
</a>  <div>
    <p>All of this network data has to be transferred over physical media like copper, fiber optics, and wireless radio.
Of the physical layer protocols, Ethernet is the most well known.
Its popularity in the early days of the Internet led us to design other protocols to accommodate its limitations.</p>
<p>First, let&#39;s get the physical details out of the way.
Ethernet is most closely associated with RJ45 connectors, which look like bigger eight-pin versions of older four-pin phone jacks.
It&#39;s also associated with cat5 (or cat5e, or cat6, or cat7) cable, which contains eight total wires twisted into four pairs.
Other media exist, but these are the ones we&#39;re most likely to encounter at home: eight wires wrapped in a sheath connected to an eight-pin jack.</p>
<p>Ethernet is a <em>physical layer protocol</em>: it describes how the bits turn into electrical signals in a cable.
It&#39;s also a <em>link layer protocol</em>: it describes the direct connection of one node to another.
However, it&#39;s purely point-to-point and says nothing about how data is routed on a network.
There&#39;s no concept of a connection in the sense of a TCP connection, or of reassignable addresses in the sense of an IP address.</p>
<p>As a protocol, ethernet has two primary jobs.
First, each device needs to notice that it&#39;s connected to something, and some parameters like connection speed need to be negotiated.</p>
<p>Second, once link is established, Ethernet needs to carry data.
Like the higher-level protocols TCP and IP, Ethernet data is broken into packets.
The core of a packet is a <em>frame</em>, which has a 1,500 byte payload, plus another 22 bytes for header information like source and destination MAC address, payload length, and checksum.
These fields are familiar: programmers often deal with addresses and lengths and checksums, and we can imagine why they&#39;re necessary.</p>
<p>The frame is then wrapped in yet another layer of headers to form the full packet.
These headers are... weird.
They start to bump up against the underlying reality of analog electrical systems, so they look like nothing we would ever put in a software protocol.
A full Ethernet packet contains:</p>
<ul>
<li>The preamble, which is 56 bits (7 bytes) of alternating 1s and 0s.
The devices use this to synchronize their clocks, sort of like when people count off &#34;1-2-3-GO!&#34;
Computers can&#39;t count past 1, so they synchronize by saying &#34;10101010101010101010101010101010101010101010101010101010&#34;.</li>
<li>An 8-bit (1 byte) start frame delimiter, which is the number 171 (10101011 in binary).
This marks the end of the preamble. Notice that it&#39;s &#34;10&#34; repeated again, until the end where there&#39;s a &#34;11&#34;.</li>
<li>The frame itself, which contains the source and destination addresses, the payload, etc., as described above.</li>
<li>An interpacket gap of 96 bits (12 bytes) where the line is left idle.
Presumably, this is to let the devices rest because they are tired.</li>
</ul>
<p>Putting this all together: what we want is to transmit our 1,500 bytes of data.
We add 22 bytes to create a frame, which indicates the source, destination, size, and checksum.
We add another 20 bytes of extra data accommodating the hardware&#39;s needs, creating a full Ethernet packet.</p>
<p>You might think this is the bottom of the stack.
It&#39;s not, but things do get weirder because the analog world pokes through even more.</p>
  </div>
</div>


  <div>
  <a href="https://www.destroyallsoftware.com/compendium/networking-meets-the-real-world">
      
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8%2BCiA8L3JkZjpSREY%2BCjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8%2BGkqr6gAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc%2FM0PECKEsLCYNKyNGTWyUkVCTpjHKYDPz5peaH6%2F3ZpJsle0UJTZ%2BLfgL2CprpYiULKysiQ3Tc96Mmknm3M49n%2Fu995zuPReswZSS1uuGIJ3JaYFpr2MxtORoeMFKD114aA8rujrh9%2FuoaZ%2F3WMx46zJr1T73rzVHY7oClkbhcUXVcsIzwr61nGryjnCnkgxHhc%2BEBzS5oPCdqUfK%2FGpyoszfJmvBwCRY24QdiSqOVLGS1NLC8nKc6VRe%2Bb2P%2BRJ7LLMwL7FXvAedANN4cTDLFJPSk2HGZPbgws2grKiRP1TKnyMruYrMKutorJIgSY4BUfNSPSYxLnpMRop1s%2F9%2F%2B6rHR9zl6nYv1D8bxnsfNGxDsWAYX0eGUTwG2xNcZir52UMY%2FRC9UNGcB9C6CedXFS2yCxdb0P2ohrVwSbKJW%2BNxeDuFlhB03EDTcrlnv%2FucPEBwQ77qGvb2oV%2FOt678AHuMZ%2B%2FPgSnPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFVElEQVRogb2Za6hVRRTHf%2Fd4s4f2OD2sq5Ww8lFmGRSZpsT9kIKGhj2IXqII%2BSUyM62gzCA%2FVJJCkBGhSYqEopAhJaXckhAFyzIft%2F5d7KGGdK1MTLPbh9k7527Pnr3PPuf4hwN79lqz5r%2FOzKxZa3YTZxhmdg7QCtwF3Ay0AJcDR4H9QAewAfhA0vdZ9poaxjQBM%2BsNzIx%2BF%2Bbs1gY8J2lzmsIZccDMJgGLgcsKmlgLTJF0OCloqANm1gS8CDxfh7HagQmSdvsvG%2BaAmZWAd4GH62j2MDBS0q74RUMciMgvAx5qgPl24NZ4OZXqbb3B5AEGAkviRl1noAD5TmA7sAO4FBdWB5Pvjx0laXNzEaKVUCX5Y8BcYIGkkwk7g3B757YMG%2FOBO%2BoyA1WS3wtMTEaThL0eEcHZGbYG9MjNMoByubwEeCSH6l6gVdIPIaXOzs6ucrn8KTAWuDKgqpo3sZnNASbnUI3J%2F5LHrqR%2FgWnAyYDamJqWkJmNAdaTvemqIp8YYzduY1fCzsIzYGbNwBs0kHyEHQFZSy1LaAouJodQK3mAgwFZr1rC6MwM%2BXd45M3sXOABYJ%2BkT6oY56aA7EChPWBmA3H%2FbhpOAiMkbY30e%2BP2yqhIvhCYlTwDKozTjMt%2FeqWobCm6hMZlyBcEyAPMAFZF8T6E2aSTB9hW1IEhGfJF3vNrdCcf427g5TQDZjYUd1qHsC7TATMbbGbnJ163BLoc9NZ9P%2BCxgO4cM7uvwph9gdVAz0Df34FNqQ6YWQ8zWwrsBr42s7M98SUBw3u852sCejEWRHWyj%2FeBQVn9JB2r6EC0Npdx6oTtD9zuqZxW2nnwSX%2BB%2BwNCuAqY7o19HtmJ3K%2FA61DhEPLIP5gQDfOe9weM9zOzPgCSTgB3AjszCM2Iyk%2BAE4TThy5guqQjkHDAKwOT5KF7PN5TQe5jWvwg6Sdc%2FD8R0O9PFBgip3cFdOdJWhM3kjMwl%2FSU2J%2BB9YEBAOaa2fVxQ9I3wEsZfcZ7z1%2Bl6LyXtPO%2FA2Z2D%2FBCYIAhZtbTI9QR0O0JrIyiUIy3A%2FrQfdNWcmA5MFlSl%2F%2ByBBCFycUZA5SAs7z2ojTFCEOBDdFpiqSDQCgnusJ73p6QLQcejVLs00gBPImrSUPYIukvr%2F0m8GNGn%2BuAEV47dFV4sfe8mVMzvJQU8gClKMl6KoNIO3C%2F%2F0LS32QndF24pC6%2B5Lo2oHvIs30cuAEYLGlKGnlwM9AKXBAwfByYJOnnpEDSKuCVQN%2B3JMUhty%2Fhq8VuoVnSEUmhhBFwDozP0JkXbdo0PAusqfC%2BDZjltZ%2FIGCcUOlNRAm4JyI8Cr4YMRNN7L9HJGKENGBfvGTMbTvYyXZfJtgKazGwf7jivhM8ljc5rzMxagauBldEeiRO6NsACXfdICu2PVDTjPi6k4ctqjEna6Lcj8hsJkweXchdCCbdM0tCnqGGPfFbd3I4LlYVQIpyY3VjEaBXku4DHJf1TZBxwDnQE5IP8nCYPqiAP8Iykj6qxn0QJ%2BDhD%2Fk6O2hWomvwyMiJcHpSADzN0hgPz45wmDWY2hPzkVwBTk4lZETRFg39G5cLbxxZcNtitFogcexr3LSxUw8ZYgcttglcqeRE7MBoXq7PQhbsP2obLXYbhCp2Lco5XV%2FLgfaExs7XAxHoZroC6k4fuFdlUwuluLWgIefAckPQbMAF331JPxMVI3clDoiaW9C0wkiiHrwPm0UDykPKV0szKuE%2BZRffEIdzVx%2BqixPIieDttZqNwH9vyZqR%2F4BKzhZL%2BrJFbLuS6XjezAbjCZyzuDqcFd2t8IPptxeXzmyQdawzVyvgPNrS8HLK7HfoAAAAASUVORK5CYII%3D"/>
</a>  <div>
    <p>Digital systems don&#39;t exist; everything is analog.</p>
<p>Suppose we have a 5-volt CMOS system.
(CMOS is a type of digital system; don&#39;t worry about it if you&#39;re not familiar.)
This means that a fully-on signal will be 5 volts, and a fully-off signal will be 0.
But nothing is ever fully on or fully off; the physical world doesn&#39;t work like that.
In reality, our 5-volt CMOS system will consider anything above 1.67 volts to be a 1, and anything below 1.67 to be 0.</p>
<p>(1.67 is 1/3 of 5. Let&#39;s not worry about why the threshold is 1/3.
If you want to dig, there&#39;s a <a href="https://en.wikipedia.org/wiki/Logic_level">wikipedia article</a>, of course!
Also, Ethernet isn&#39;t CMOS or even related to CMOS, but CMOS and its 1/3 cutoff make for a simple illustration.)</p>
<p>Our Ethernet packets have to go over a physical wire, which means changing the voltage across the wire.
Ethernet is a 5-volt system, so we naively expect each 1 bit in the Ethernet protocol to be 5 volts and each 0 bit to be 0 volts.
But there are two wrinkles: first, the voltage range is -2.5 V to +2.5 V.
Second, and more strangely, each set of 8 bits gets expanded into 10 bits before hitting the wire.</p>
<p>There are 256 possible 8-bit values and 1024 possible 10-bit values, so imagine this as a table mapping them.
Each 8-bit byte can be mapped to any of four different 10-bit patterns, each of which will be turned back into the same 8-bit byte on the receiving end.
For example, the 10-bit value 00.0000.0000 might map to the 8-bit value 0000.0000.
But maybe the 10-bit value 10.1010.1010 also maps to 0000.0000.
When an Ethernet device sees either 00.0000.0000 or 10.1010.1010, they&#39;ll be understood as the byte 0 (binary 0000.0000).</p>
<p>(Warning: there are going to be some electronics words now.)</p>
<p>This exists to serve an extremely analog need: balancing the voltage in the devices.
Suppose this 8-bit-to-10-bit encoding doesn&#39;t exist, and we send some data that happens to be all 1s.
Ethernet&#39;s voltage range is -2.5 to +2.5 volts, so we&#39;re holding the Ethernet cable&#39;s voltage at +2.5 V, continually pulling electrons from the other side.</p>
<p>Why do we care about one side pulling more electrons than the other?
Because the analog world is a mess and it will cause all kinds of undesirable effects.
To take one: it can charge the capacitors used in low-pass filters, creating an offset in the signal level itself, eventually causing bit errors.
Those errors would take time to accumulate, but we don&#39;t want our network devices to suddenly corrupt data after two years of uptime simply because we happened to send more binary 1s than 0s.</p>
<p>(Electronics words end here.)</p>
<p>By using an <a href="https://en.wikipedia.org/wiki/8b/10b_encoding">8b/10b encoding</a>, Ethernet can balance the number of 0s and 1s sent over the wire, even if we send data that&#39;s mostly 1s or mostly 0s.
The hardware tracks the ratio of 0s to 1s, mapping outgoing 8-bit bytes to different options from the 10-bit table to achieve electrical balance.
(Newer Ethernet standards, like 10 GB Ethernet, use different and more complex encoding systems.)</p>
<p>We&#39;ll stop here, because we&#39;re already beyond the scope of what can be considered programming, but there are many more protocol issues to accommodate the physical layer.
In many cases, the solutions to hardware problems lie in the software itself, as in the case of the 8b/10b coding used to correct DC offset.
This is perhaps a bit disconcerting to us as programmers: we like to pretend that our software lives in a perfect Platonic world, devoid of the vulgar imperfections of physicality.
In reality, everything is analog, and accommodating that complexity is everyone&#39;s job, including the software&#39;s.</p>
  </div>
</div>


  <div>
  <a href="https://www.destroyallsoftware.com/compendium/the-interconnected-network-stack">
      
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8%2BCiA8L3JkZjpSREY%2BCjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8%2BGkqr6gAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc%2FM0PECKEsLCYNKyNGTWyUkVCTpjHKYDPz5peaH6%2F3ZpJsle0UJTZ%2BLfgL2CprpYiULKysiQ3Tc96Mmknm3M49n%2Fu995zuPReswZSS1uuGIJ3JaYFpr2MxtORoeMFKD114aA8rujrh9%2FuoaZ%2F3WMx46zJr1T73rzVHY7oClkbhcUXVcsIzwr61nGryjnCnkgxHhc%2BEBzS5oPCdqUfK%2FGpyoszfJmvBwCRY24QdiSqOVLGS1NLC8nKc6VRe%2Bb2P%2BRJ7LLMwL7FXvAedANN4cTDLFJPSk2HGZPbgws2grKiRP1TKnyMruYrMKutorJIgSY4BUfNSPSYxLnpMRop1s%2F9%2F%2B6rHR9zl6nYv1D8bxnsfNGxDsWAYX0eGUTwG2xNcZir52UMY%2FRC9UNGcB9C6CedXFS2yCxdb0P2ohrVwSbKJW%2BNxeDuFlhB03EDTcrlnv%2FucPEBwQ77qGvb2oV%2FOt678AHuMZ%2B%2FPgSnPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFVElEQVRogb2Za6hVRRTHf%2Fd4s4f2OD2sq5Ww8lFmGRSZpsT9kIKGhj2IXqII%2BSUyM62gzCA%2FVJJCkBGhSYqEopAhJaXckhAFyzIft%2F5d7KGGdK1MTLPbh9k7527Pnr3PPuf4hwN79lqz5r%2FOzKxZa3YTZxhmdg7QCtwF3Ay0AJcDR4H9QAewAfhA0vdZ9poaxjQBM%2BsNzIx%2BF%2Bbs1gY8J2lzmsIZccDMJgGLgcsKmlgLTJF0OCloqANm1gS8CDxfh7HagQmSdvsvG%2BaAmZWAd4GH62j2MDBS0q74RUMciMgvAx5qgPl24NZ4OZXqbb3B5AEGAkviRl1noAD5TmA7sAO4FBdWB5Pvjx0laXNzEaKVUCX5Y8BcYIGkkwk7g3B757YMG%2FOBO%2BoyA1WS3wtMTEaThL0eEcHZGbYG9MjNMoByubwEeCSH6l6gVdIPIaXOzs6ucrn8KTAWuDKgqpo3sZnNASbnUI3J%2F5LHrqR%2FgWnAyYDamJqWkJmNAdaTvemqIp8YYzduY1fCzsIzYGbNwBs0kHyEHQFZSy1LaAouJodQK3mAgwFZr1rC6MwM%2BXd45M3sXOABYJ%2BkT6oY56aA7EChPWBmA3H%2FbhpOAiMkbY30e%2BP2yqhIvhCYlTwDKozTjMt%2FeqWobCm6hMZlyBcEyAPMAFZF8T6E2aSTB9hW1IEhGfJF3vNrdCcf427g5TQDZjYUd1qHsC7TATMbbGbnJ163BLoc9NZ9P%2BCxgO4cM7uvwph9gdVAz0Df34FNqQ6YWQ8zWwrsBr42s7M98SUBw3u852sCejEWRHWyj%2FeBQVn9JB2r6EC0Npdx6oTtD9zuqZxW2nnwSX%2BB%2BwNCuAqY7o19HtmJ3K%2FA61DhEPLIP5gQDfOe9weM9zOzPgCSTgB3AjszCM2Iyk%2BAE4TThy5guqQjkHDAKwOT5KF7PN5TQe5jWvwg6Sdc%2FD8R0O9PFBgip3cFdOdJWhM3kjMwl%2FSU2J%2BB9YEBAOaa2fVxQ9I3wEsZfcZ7z1%2Bl6LyXtPO%2FA2Z2D%2FBCYIAhZtbTI9QR0O0JrIyiUIy3A%2FrQfdNWcmA5MFlSl%2F%2ByBBCFycUZA5SAs7z2ojTFCEOBDdFpiqSDQCgnusJ73p6QLQcejVLs00gBPImrSUPYIukvr%2F0m8GNGn%2BuAEV47dFV4sfe8mVMzvJQU8gClKMl6KoNIO3C%2F%2F0LS32QndF24pC6%2B5Lo2oHvIs30cuAEYLGlKGnlwM9AKXBAwfByYJOnnpEDSKuCVQN%2B3JMUhty%2Fhq8VuoVnSEUmhhBFwDozP0JkXbdo0PAusqfC%2BDZjltZ%2FIGCcUOlNRAm4JyI8Cr4YMRNN7L9HJGKENGBfvGTMbTvYyXZfJtgKazGwf7jivhM8ljc5rzMxagauBldEeiRO6NsACXfdICu2PVDTjPi6k4ctqjEna6Lcj8hsJkweXchdCCbdM0tCnqGGPfFbd3I4LlYVQIpyY3VjEaBXku4DHJf1TZBxwDnQE5IP8nCYPqiAP8Iykj6qxn0QJ%2BDhD%2Fk6O2hWomvwyMiJcHpSADzN0hgPz45wmDWY2hPzkVwBTk4lZETRFg39G5cLbxxZcNtitFogcexr3LSxUw8ZYgcttglcqeRE7MBoXq7PQhbsP2obLXYbhCp2Lco5XV%2FLgfaExs7XAxHoZroC6k4fuFdlUwuluLWgIefAckPQbMAF331JPxMVI3clDoiaW9C0wkiiHrwPm0UDykPKV0szKuE%2BZRffEIdzVx%2BqixPIieDttZqNwH9vyZqR%2F4BKzhZL%2BrJFbLuS6XjezAbjCZyzuDqcFd2t8IPptxeXzmyQdawzVyvgPNrS8HLK7HfoAAAAASUVORK5CYII%3D"/>
</a>  <div>
    <p>Internet protocols are best thought of as a stack of layers.
Ethernet provides physical data transfer and link between two point-to-point devices.
IP provides a layer of addressing, allowing routers and large-scale networks to exist, but it&#39;s connectionless.
Packets are fired into the ether, with no indication of whether they arrived or not.
TCP adds a layer of reliable transmission by using sequence numbers, acknowledgement, and retransmission.</p>
<p>Finally, application-level protocols like HTTP are layered on top of TCP.
At this level, we already have addressing and the illusion of reliable transmission and persistent connections.
IP and TCP save application developers from constantly reimplementing packet retransmission and addressing and so on.</p>
<p>The independence of these layers is important.
For example, when packets were lost during my 88.5 MB video transfer, the Internet&#39;s backbone routers didn&#39;t know; only my machine and the web server knew.
Dozens of duplicate ACKs from my computer were all dutifully routed over the same routing infrastructure that lost the original packet.
It&#39;s possible that the router responsible for dropping the lost packet was also the router carrying its replacement milliseconds later.
This is an important point for understanding the Internet: the routing infrastructure doesn&#39;t know about TCP; it only routes.
(There are exceptions to this, as always, but it&#39;s generally true.)</p>
<p>Layers of the protocol stack operate independently, but they weren&#39;t designed independently.
Higher-level protocols tend to be built on lower-level ones: HTTP is built on TCP is built on IP is built on Ethernet.
Design decisions in lower levels often influence decisions in higher levels, even decades later.</p>
<p>Ethernet is old and concerns the physical layer, so its needs set the base parameters.
An Ethernet payload is at most 1,500 bytes.</p>
<p>The IP packet needs to fit within an Ethernet frame.
IP has a minimum header size of 20 bytes, so the maximum payload of an IP packet is 1,500 - 20 = 1,480 bytes.</p>
<p>Likewise, the TCP packet needs to fit within the IP packet.
TCP also has a minimum header size of 20 bytes, leaving a maximum TCP payload of 1,480 - 20 = 1,460 bytes.
In practice, other headers and protocols can cause further reductions. 1,400 is a conservative TCP payload size.</p>
<p>The 1,400 byte limit influences modern protocols&#39; designs.
For example, HTTP requests are generally small.
If we fit them into one packet instead of two, we reduce the probability of losing part of the request, with a correspondingly reduced likelihood of TCP retransmissions.
To squeeze every byte out of small requests, <a href="http://httpwg.org/specs/rfc7540.html">HTTP/2</a> specifies compression for headers, which are usually small.
Without context from TCP, IP, and Ethernet, this seems silly: why add compression to a protocol&#39;s headers to save only a few bytes?
Because, as the HTTP/2 spec says in the introduction to section 2, compression allows &#34;many requests to be compressed into one packet&#34;.</p>
<p>HTTP/2 does header compression to meet the constraints of TCP, which come from constraints in IP, which come from constraints in Ethernet, which was developed in the 1970s, introduced commercially in 1980, and standardized in 1983.</p>
<p>One final question: why is the Ethernet payload size set at 1,500 bytes?
There&#39;s no deep reason; it&#39;s just a nice trade-off point.
There are 42 bytes of non-payload data needed for each frame.
If the payload maximum were only 100 bytes, only 70% (100/142) of time would be spent sending payload.
A payload of 1,500 bytes means about 97% (1500/1542) of time is spent sending payload, which is a nice level of efficiency.
Pushing the packet size higher would require larger buffers in the devices, which we can&#39;t justify simply to get another percent or two of efficiency.
In short: HTTP/2 has header compression because of the RAM limitations of networking devices in the late 1970s.</p>
  </div>
</div>



  </div>

  
</div>


    
  </div></div>
  </body>
</html>
