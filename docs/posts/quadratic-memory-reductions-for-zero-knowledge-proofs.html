<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/logannye/space-efficient-zero-knowledge-proofs">Original</a>
    <h1>Quadratic memory reductions for Zero-knowledge Proofs</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A reference implementation of the <strong>sublinear-space ZKP</strong> prover/Verifier described in our whitepaper: &#34;Zero-knowledge Proofs in Sublinear Space&#34; (<a href="https://arxiv.org/abs/2509.05326" rel="nofollow">https://arxiv.org/abs/2509.05326</a>).
It realizes a <strong>streaming prover that uses only <em>O(âˆšT)</em> memory</strong> over a trace of length <em>T</em>, while producing standard <strong>KZG commitments</strong> (BN254) for wires, the permutation accumulator <code>Z</code>, and the quotient <code>Q</code>. The design keeps <strong>aggregate-only Fiatâ€“Shamir</strong> and never materializes whole polynomials.</p>
<hr/>

<p dir="auto">Traditional zk proving pipelines routinely buffer whole polynomials, forcing <em>O(T)</em> memory and large intermediate states. This repository demonstrates a practical alternative:</p>
<ul dir="auto">
<li><strong>Sublinear space:</strong> the active working set stays <strong>O(âˆšT)</strong> using <em>blocked IFFTs</em> and streaming accumulators.</li>
<li><strong>Production-style commitments:</strong> standard <strong>KZG</strong> commitments/openings (pairing-checked) over <strong>BN254</strong>.</li>
<li><strong>No full-poly buffers:</strong> wires, <code>Z</code>, and <code>Q</code> are built and opened <strong>without</strong> holding entire vectors.</li>
<li><strong>Deterministic dev SRS:</strong> easy to run locally; switch to trusted SRS files for production.</li>
</ul>
<p dir="auto">If youâ€™re building scalable zk systems, this repo shows how to restructure your pipeline around <strong>streaming</strong> and <strong>aggregate-only FS</strong> without giving up familiar cryptographic backends.</p>
<hr/>

<ul dir="auto">
<li><strong>PCS:</strong> KZG over BN254 with a <strong>linear</strong> interface and a streaming <strong>Aggregator</strong>.</li>
<li><strong>Two commitment bases:</strong> commit from <strong>evaluation</strong> (domain-aligned) or <strong>coefficient</strong> slices.</li>
<li><strong>Openings:</strong> real KZG openings for wires/<code>Z</code>/<strong><code>Q</code></strong>, with consistent witness construction.</li>
<li><strong>Domain &amp; transforms:</strong> radix-2 blocked IFFT/NTT, <strong>barycentric</strong> eval for streaming points.</li>
<li><strong>AIR &amp; residuals:</strong> small fixed-column AIR and permutation-coupled residual stream.</li>
<li><strong>Scheduler:</strong> five-phase Aâ†’E pipeline, aggregate-only Fiatâ€“Shamir, strictly increasing time order.</li>
<li><strong>CLI tools:</strong> <code>prover</code> and <code>verifier</code> plus an end-to-end script.</li>
<li><strong>Space profile:</strong> peak memory <strong>â‰ˆ O(b_blk)</strong> with <code>b_blk â‰ˆ âˆšT</code>.</li>
</ul>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">How it works (one-screen version)</h2><a id="user-content-how-it-works-one-screen-version" aria-label="Permalink: How it works (one-screen version)" href="#how-it-works-one-screen-version"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ol dir="auto">
<li><strong>Phase A:</strong> (Optional) commit selectors/fixed columns.</li>
<li><strong>Phase B:</strong> <strong>Wires</strong> â€” stream a registerâ€™s evaluations block-by-block â†’ <strong>blocked IFFT</strong> â†’ feed <strong>coeff tiles (lowâ†’high)</strong> into PCS Aggregator.</li>
<li><strong>Phase C:</strong> <strong>Permutation accumulator <code>Z</code></strong> â€” stream locals, update <code>Z</code> on the fly and <strong>emit the <code>Z</code> column in time order</strong>, then commit via the same blocked IFFT path.</li>
<li><strong>Phase D:</strong> <strong>Quotient <code>Q</code></strong> â€” stream residual <code>R(Ï‰^i)</code> and convert to <code>Q</code> coefficients online using <code>Z_H(X)=X^Nâˆ’c</code> (<strong>no full-poly buffers</strong>).</li>
<li><strong>Phase E:</strong> <strong>Openings</strong> â€” produce <strong>real KZG</strong> openings for wires, <code>Z</code>, and <code>Q</code> (witness <code>W = (fâˆ’f(Î¶))/(Xâˆ’Î¶)</code>) and verify via pairings.</li>
</ol>
<p dir="auto">All Fiatâ€“Shamir challenges are replayed by the verifier; pairing checks are always enforced. In dev builds, SRS is deterministic; in production, provide trusted SRS files.</p>
<hr/>


<ul dir="auto">
<li>Rust (stable toolchain)</li>
<li>No external SRS required for dev runs (deterministic in-crate SRS)</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="# Clone, then:
cargo build --quiet --bins --features dev-srs

# End-to-end script runs three scenarios + a tamper test
scripts/test_sszkp.sh"><pre><span><span>#</span> Clone, then:</span>
cargo build --quiet --bins --features dev-srs

<span><span>#</span> End-to-end script runs three scenarios + a tamper test</span>
scripts/test_sszkp.sh</pre></div>
<p dir="auto">Expected output (abridged):</p>
<div data-snippet-clipboard-copy-content="âœ” build succeeded
âœ” verification OK for eval-basis wires, b_blk=128, rows=1024
âœ” tampered proof correctly rejected
âœ” verification OK for coeff-basis wires, b_blk=64, rows=1536
âœ” verification OK for eval-basis wires, b_blk=256, rows=2048
==&gt; All tests passed ðŸŽ‰"><pre><code>âœ” build succeeded
âœ” verification OK for eval-basis wires, b_blk=128, rows=1024
âœ” tampered proof correctly rejected
âœ” verification OK for coeff-basis wires, b_blk=64, rows=1536
âœ” verification OK for eval-basis wires, b_blk=256, rows=2048
==&gt; All tests passed ðŸŽ‰
</code></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="cargo run --features dev-srs --bin prover -- \
  --rows 1024 --b-blk 128 --k 3 --basis eval
# writes proof.bin"><pre>cargo run --features dev-srs --bin prover -- \
  --rows 1024 --b-blk 128 --k 3 --basis <span>eval</span>
<span><span>#</span> writes proof.bin</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Run the verifier manually</h3><a id="user-content-run-the-verifier-manually" aria-label="Permalink: Run the verifier manually" href="#run-the-verifier-manually"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="cargo run --features dev-srs --bin verifier -- --rows 1024 --basis eval
# reads proof.bin and verifies"><pre>cargo run --features dev-srs --bin verifier -- --rows 1024 --basis <span>eval</span>
<span><span>#</span> reads proof.bin and verifies</span></pre></div>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">Production SRS (trusted, non-dev)</h2><a id="user-content-production-srs-trusted-non-dev" aria-label="Permalink: Production SRS (trusted, non-dev)" href="#production-srs-trusted-non-dev"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">In non-dev builds you must provide both <strong>G1</strong> and <strong>G2</strong> SRS files.</p>
<p dir="auto">Prover:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cargo run --bin prover -- \
  --rows 1024 --b-blk 128 --k 3 --basis eval \
  --srs-g1 srs_g1.bin --srs-g2 srs_g2.bin"><pre>cargo run --bin prover -- \
  --rows 1024 --b-blk 128 --k 3 --basis <span>eval</span> \
  --srs-g1 srs_g1.bin --srs-g2 srs_g2.bin</pre></div>
<p dir="auto">Verifier:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cargo run --bin verifier -- --rows 1024 --basis eval \
  --srs-g1 srs_g1.bin --srs-g2 srs_g2.bin"><pre>cargo run --bin verifier -- --rows 1024 --basis <span>eval</span> \
  --srs-g1 srs_g1.bin --srs-g2 srs_g2.bin</pre></div>
<blockquote>
<p dir="auto"><strong>Format:</strong> the SRS files are Arkworks-serialized vectors of affine powers.
<strong>G1:</strong> <code>[Ï„^0]G1 â€¦ [Ï„^d]G1</code> (we use the degree bound you load).
<strong>G2:</strong> a vector containing at least <code>[Ï„]G2</code> (we read element 1 or 0).</p>
</blockquote>
<hr/>

<ul dir="auto">
<li><code>--rows &lt;T&gt;</code>: total rows in the trace (domain size rounds up to power of two).</li>
<li><code>--b-blk &lt;B&gt;</code>: block size; pick <strong>â‰ˆ âˆšT</strong> to achieve the sublinear memory bound.</li>
<li><code>--k &lt;K&gt;</code>: number of registers (columns) in the AIR.</li>
<li><code>--basis &lt;eval|coeff&gt;</code>: commitment basis for <strong>wires</strong> (Q is always <strong>coeff</strong>).</li>
<li><code>--selectors &lt;FILE&gt;</code>: optional selectors/fixed columns CSV (rows Ã— S).</li>
<li><code>--omega &lt;u64&gt;</code>: override Ï‰ (power-of-two order must hold).</li>
<li><code>--coset &lt;u64&gt;</code>: reserved; current domain uses subgroup (<code>Z_H(X)=X^Nâˆ’1</code>).</li>
</ul>
<hr/>

<ul dir="auto">
<li><code>src/pcs.rs</code> â€” KZG PCS (BN254), streaming <strong>Aggregator</strong>, real openings, pairings.</li>
<li><code>src/domain.rs</code> â€” domain <code>H</code>, barycentric weights, blocked NTT/IFFT.</li>
<li><code>src/air.rs</code> â€” tiny fixed-column AIR + residual stream + permutation coupling.</li>
<li><code>src/perm_lookup.rs</code> â€” permutation accumulator <code>Z</code> (lookups optional).</li>
<li><code>src/quotient.rs</code> â€” streaming quotient builder (<strong>Râ†’Q</strong> tilewise).</li>
<li><code>src/scheduler.rs</code> â€” 5-phase orchestrator (aggregate-only FS, O(âˆšT) space).</li>
<li><code>src/opening.rs</code> â€” streaming polynomial evaluation helpers (eval/coeff mode).</li>
<li><code>src/transcript.rs</code> â€” domain-separated FS transcript (BLAKE3â†’field).</li>
<li><code>src/stream.rs</code> â€” block partitioning + restreaming interfaces.</li>
<li><code>bin/prover.rs</code>, <code>bin/verifier.rs</code> â€” CLIs.</li>
<li><code>scripts/test_sszkp.sh</code> â€” end-to-end tests + tamper test.</li>
</ul>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">Using this in your own pipeline</h2><a id="user-content-using-this-in-your-own-pipeline" aria-label="Permalink: Using this in your own pipeline" href="#using-this-in-your-own-pipeline"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>Treat the <code>Restreamer</code> trait as the integration seam: implement it to feed rows from your own storage (disk, network, GPU), all while keeping <strong>O(b_blk)</strong> memory.</li>
<li>Keep your <strong>permutation/lookup</strong> logic time-ordered; the accumulator state must evolve monotonically in <code>t</code>.</li>
<li>When committing from <strong>evaluations</strong>, ensure your blocks align to the domain and use the provided <strong>blocked IFFT</strong> helpers to produce coeff tiles.</li>
<li>For openings, prefer the <strong>coeff-stream</strong> path; the code adapts eval-streams internally when needed.</li>
</ul>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">Correctness &amp; security notes</h2><a id="user-content-correctness--security-notes" aria-label="Permalink: Correctness &amp; security notes" href="#correctness--security-notes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>Pairing checks are always enforced; the verifier <strong>replays</strong> the FS transcript and checks KZG equalities for wires, <code>Z</code>, and <code>Q</code>.</li>
<li>The <strong>tamper test</strong> flips one byte in <code>proof.bin</code>â€”verification must fail.</li>
<li>Dev SRS exists only for convenience; do not use dev mode in production.</li>
<li>Algebraic identity at Î¶ (gate + perm coupling + boundary = <code>Z_H(Î¶)Â·Q(Î¶)</code>) is implemented; by default, selectors are optional and gates are minimal.</li>
</ul>
<hr/>

<ul dir="auto">
<li>AIR is a compact demo; plug in your real selector/table wiring as needed.</li>
<li>Lookup accumulator is feature-gated and intentionally minimal (demo path).</li>
<li>Only BN254/KZG is shipped; adding Pallas/BLS12-381 is straightforward in this architecture.</li>
</ul>
<hr/>

<ul dir="auto">
<li>File issues for bugs or suggestions.</li>
<li>PRs welcomeâ€”especially alternative domains, SRS loaders, or integration examples.</li>
</ul>
<hr/>

<p dir="auto">This codebase follows the <strong>aggregate-only Fiatâ€“Shamir</strong> and <strong>streaming</strong> discipline described in the whitepaper and demonstrates that <strong>production-style commitments and sublinear space can coexist</strong> in a practical Rust implementation.</p>
</article></div></div>
  </body>
</html>
