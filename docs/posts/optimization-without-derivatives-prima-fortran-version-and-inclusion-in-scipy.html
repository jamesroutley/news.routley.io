<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fortran-lang.discourse.group/t/optimization-without-using-derivatives-the-prima-package-its-fortran-implementation-and-its-inclusion-in-scipy/5798">Original</a>
    <h1>Optimization Without Derivatives: Prima Fortran Version and Inclusion in SciPy</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
              <p>As mentioned two weeks ago under the thread of <a href="https://lfortran.org/" rel="noopener nofollow ugc">LFortran</a>, I have been developing <a href="http://www.libprima.net" rel="noopener nofollow ugc">a package named PRIMA</a> for solving general nonlinear optimization problems without using derivatives. <a href="https://fortran-lang.discourse.group/u/certik">@certik</a> suggested that I should write about PRIMA, especially its inclusion in SciPy.</p>


<p>PRIMA is a package for <strong>solving general nonlinear optimization problems without using derivatives</strong>. It provides the reference implementation of Powell’s renowned derivative-free optimization methods, i.e., COBYLA, UOBYQA, NEWUOA, BOBYQA, and LINCOA. The “P” in the name stands for <a href="https://www.zhangzk.net/powell.html" rel="noopener nofollow ugc"><strong>P</strong>owell</a>, and “RIMA” is an acronym for “<strong>R</strong>eference <strong>I</strong>mplementation with <strong>M</strong>odernization and <strong>A</strong>melioration”.</p>
<p>PRIMA is a project that I have been working intensively on for the past three years. Almost all questions I posted on this forum come from PRIMA.</p>

<p><a href="https://en.wikipedia.org/wiki/Michael_J._D._Powell" rel="noopener nofollow ugc">Michael James David Powell FRS</a> was <a href="https://royalsocietypublishing.org/doi/full/10.1098/rsbm.2017.0023" rel="noopener nofollow ugc">“a British numerical analyst who was among the pioneers</a>. He was the inventor/early contributor of quasi-Newton method, trust region method, augmented Lagrangian method, and SQP method. Each of them is a <strong>pillar</strong> of modern numerical optimization. He also made significant contributions to <a href="https://www.cambridge.org/highereducation/books/approximation-theory-and-methods/66FD8CD6F18FE1ED499A8CA9A05F2A5A#overview" rel="noopener nofollow ugc">approximation theory and methods</a>, but I hesitate to mention more details as it is not my area.</p>

<p>Professor Powell carefully implemented his <strong>derivative-free optimization</strong> methods into publicly available solvers. They are widely used by engineers and scientists. For instance, see Section 1 of <a href="https://arxiv.org/pdf/2302.13246.pdf" rel="noopener nofollow ugc">a recent paper on Powell’s solvers</a> as well as the Google searches of <a href="https://www.google.com/search?q=cobyla" rel="noopener nofollow ugc">COBYLA</a> and <a href="https://www.google.com/search?q=bobyqa" rel="noopener nofollow ugc">BOBYQA</a>.</p>
<p>However, Professor Powell’s implementation was done in <a href="https://github.com/libprima/prima/tree/main/fortran/original" rel="noopener nofollow ugc">Fortran 77</a>. The code is nontrivial to understand or maintain, let alone extend. For many practitioners, this has become an obstacle to exploiting these solvers in their applications. More seriously, <a href="https://github.com/libprima/prima#bug-fixes" rel="noopener nofollow ugc">bugs</a> keep emerging, but few of them get really fixed — it is highly challenging/frustrating to debug a maze of 244 GOTOs in 7939 lines of classic-style Fortran 77 code, especially if you do not know the sophisticated algorithms behind the code, which are nontrivial to understand by themselves.</p>
<p>Before he passed, Professor Powell had asked me and <a href="https://www.numerical.rl.ac.uk/people/nimg" rel="noopener nofollow ugc">Professor Nick Gould</a> to maintain his solvers. This is an honorable mission. To make the solvers more accessible, I started PRIMA. It is a project somehow similar to the translation, interpretation, and annotation of Euclid’s <em>Elements</em>. It will make Powell’s solvers easily understandable to everyone, not only the experts. Few people remember <a href="https://en.wikipedia.org/wiki/Euclid%27s_Elements#Translations" rel="noopener nofollow ugc">who translated <em>Elements</em></a>, but it is a job that must be done.</p>

<p>PRIMA aims to provide the reference implementation of Powell’s methods in modern languages, first in  <a href="https://fortran-lang.org" rel="noopener nofollow ugc"><strong>modern</strong> Fortran</a> (F2008 or newer), and then in MATLAB, Python, C++, Julia, and R. It will be a faithful implementation, in the sense that the code will be mathematically equivalent to Powell’s, except for the <a href="https://github.com/libprima/prima#bug-fixes" rel="noopener nofollow ugc">bug fixes</a> and <a href="https://github.com/libprima/prima#improvements" rel="noopener nofollow ugc">improvements</a> made intentionally.</p>
<p>The focus is to implement these methods in a <strong>structured</strong> and <strong>modularized</strong> way so that they are <strong>understandable</strong>, <strong>maintainable</strong>, <strong>extendable</strong>, <strong>fault tolerant</strong>, and <strong>future proof</strong>. The code will <strong>have no GOTO</strong> (of course) and will <strong>use matrix-vector procedures instead of loops</strong> whenever possible. In doing so, PRIMA codes the algorithms <strong>in a way that we would present them on a blackboard</strong>.</p>
<p>(N.B.: There are plenty of discussions on whether we should use matrix-vector procedures or loops in Fortran. Here, the former is the correct one by all means, as long as we note one fact — in derivative-free optimization, the dominating cost comes from the function evaluations implemented by the users rather than the numerical linear algebra of the solver. Each function evaluation takes minutes or months to finish.)</p>

<h3>
<a name="modern-fortran-6" href="#modern-fortran-6"></a>Modern Fortran</h3>
<p>After almost <strong>three</strong> years of intensive coding, <strong>the <a href="https://github.com/libprima/prima/tree/main/fortran" rel="noopener nofollow ugc">modern Fortran version</a> of PRIMA has been finished by December 2022.</strong></p>
<h3>
<a name="matlab-7" href="#matlab-7"></a>MATLAB</h3>
<ul>
<li>An <a href="https://github.com/libprima/prima/blob/main/matlab/interfaces/prima.m" rel="noopener nofollow ugc">interface</a> is provided for <a href="https://github.com/libprima/prima/blob/main/README_mat.md" rel="noopener nofollow ugc">using the <strong>modern</strong> Fortran implementation in MATLAB</a>.</li>
<li>
<a name="newuoa_mat"></a>A <a href="https://github.com/libprima/prima/tree/main/matlab/interfaces/%2Bnewuoa_mat" rel="noopener nofollow ugc">pure MATLAB version of NEWUOA</a> is implemented. It was generated straightforwardly (indeed, <strong>automatically</strong>) from an earlier version of the <strong>modern</strong> Fortran code.</li>
</ul>
<h3>
<a name="python-8" href="#python-8"></a>Python</h3>
<ul>
<li>The inclusion of PRIMA into SciPy is <a href="https://github.com/scipy/scipy/issues/18118" rel="noopener nofollow ugc">under discussion</a>. It will replace the <a href="https://github.com/libprima/prima#bug-fixes" rel="noopener nofollow ugc">buggy</a> and unmaintained Fortran 77 version of <a href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-cobyla.html#optimize-minimize-cobyla" rel="noopener nofollow ugc">COBYLA underlying <code>scipy.optimize.minimize</code></a>, and make the other four solvers available to all SciPy users.</li>
<li>My ultimate objective is to have a native Python implementation of PRIMA <strong>independent of Fortran</strong>, similar to what we have done with NEWUOA in MATLAB as <a href="#newuoa_mat">mentioned above</a>.</li>
</ul>
<h3>
<a name="other-languages-9" href="#other-languages-9"></a>Other languages</h3>
<ul>
<li>Interfaces for using the modern Fortran implementation in other languages will be available later.</li>
<li>Given the <strong>modern</strong> Fortran version, <strong>native implementations</strong> in other languages become <strong>much easier</strong>, because we now have a structured and modularized implementation as a reference. My team will implement the methods in other languages in this way. I am exploring how LLMs like ChatGPT can accelerate our progress in this process.</li>
</ul>

<h3>
<a name="fortran-11" href="#fortran-11"></a>Fortran</h3>
<ul>
<li>Make PRIMA available with FPM.</li>
<li>Generating documentation using FORD or other tools.</li>
</ul>
<h3>
<a name="python-12" href="#python-12"></a>Python</h3>
<p>How to include PRIMA in SciPy as soon as possible? This is the question. The major Scipy maintainers are positive about the inclusion of PRIMA solvers in SciPy. See the <a href="https://github.com/scipy/scipy/issues/18118" rel="noopener nofollow ugc">discussions on GitHub</a> for details. However, I do not know Python at all. So <strong>community efforts are greatly needed here</strong>.</p>
<p>The first step should be replacing the <a href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-cobyla.html#optimize-minimize-cobyla" rel="noopener nofollow ugc">Fortran 77 implementation of COBYLA in SciPy</a> with the PRIMA version, respecting the current Python signature of COBYLA. The second step will be getting BOBYQA into SciPy, as this solver has been <a href="https://github.com/scipy/scipy/issues/1477" rel="noopener nofollow ugc">long requested by SciPy users</a>. The third step is to get the other three solvers included.</p>
<p>Previously, my former student Tom <a href="https://fortran-lang.discourse.group/u/ragonneau">@ragonneau</a> and I developed <a href="https://pypi.org/project/pdfo/" rel="noopener nofollow ugc">Python interfaces</a> for the Fortran 77 implementation of Powell’s solvers under the <a href="https://github.com/pdfo/pdfo" rel="noopener nofollow ugc">PDFO project</a>. They may provide a good starting point to begin with.</p>
<hr/>
<hr/>

<p>I do not think there is <a href="https://github.com/search?q=repo%3Ascipy%2Fscipy+module+lang%3Afortran&amp;type=code" rel="noopener nofollow ugc">any modern Fortran code with modules</a> in the SciPy code base, or even <a href="https://github.com/search?q=repo%3Ascipy%2Fscipy+path%3A*.f90&amp;type=Code&amp;ref=advsearch&amp;l=&amp;l=" rel="noopener nofollow ugc">any .f90 code</a>.</p>
            </div></div>
  </body>
</html>
