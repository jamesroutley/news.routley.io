<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hacks.mozilla.org/2024/08/puppeteer-support-for-firefox/">Original</a>
    <h1>Official Puppeteer Support for Firefox</h1>
    
    <div id="readability-page-1" class="page"><article role="article">
    
<p>We’re pleased to announce that, as of version 23, the <a href="https://pptr.dev/">Puppeteer</a> browser automation library now has first-class support for Firefox. This means that it’s now easy to write automation and perform end-to-end testing using Puppeteer, and run against both Chrome and Firefox.</p>
<h2>How to Use Puppeteer With Firefox</h2>
<p>To get started, simply set the product to “<code>firefox</code>” when starting Puppeteer:</p>
<pre><code>import puppeteer from &#34;puppeteer&#34;;

const browser = await puppeteer.launch({
  browser: &#34;firefox&#34;
});

const page = await browser.newPage();
// ...
await browser.close();</code></pre>
<p>As with Chrome, Puppeteer is able to download and launch the latest stable version of Firefox, so running against either browser should offer the same developer experience that Puppeteer users have come to expect.</p>
<p>Whilst the features offered by Puppeteer won’t be a surprise, bringing support to multiple browsers has been a significant undertaking. The Firefox support is not based on a Firefox-specific automation protocol, but on WebDriver BiDi, a cross browser protocol that’s undergoing standardization at the W3C, and currently has implementation in both Gecko and Chromium. This use of a cross-browser protocol should make it much easier to support many different browsers going forward.</p>
<p>Later in this post we’ll dive into some of the more technical background behind WebDriver BiDi. But first we’d like to call out how today’s announcement is a great demonstration of how productive collaboration can advance the state of the art on the web. Developing a new browser automation protocol is a lot of work, and great thanks goes to the Puppeteer team and the other members of the W3C Browser Testing and Tools Working Group, for all their efforts in getting us to this point.</p>
<p>You can also check out the Puppeteer team’s<a href="https://developer.chrome.com/blog/firefox-support-in-puppeteer-with-webdriver-bidi"> post</a> about making WebDriver BiDi production ready.</p>
<h2>Key Features</h2>
<p>For long-time Puppeteer users, the features available are familiar. However for people in other automation and testing ecosystems — particularly those that until recently relied entirely on HTTP-based WebDriver — this section outlines some of the new functionality that WebDriver BiDi makes possible to implement in a cross-browser manner.</p>
<h3>Capturing of Log Messages</h3>
<p>A common requirement when testing web apps is to ensure that there are no unexpected errors reported to the console. This is also a case where an event-based protocol shines, since it avoids the need to poll the browser for new log messages.</p>
<pre><code>import puppeteer from &#34;puppeteer&#34;;

const browser = await puppeteer.launch({
  browser: &#34;firefox&#34;
});

const page = await browser.newPage();
page.on(&#39;console&#39;, msg =&gt; {
  console.log(`[console] ${msg.type()}: ${msg.text()}`);
});

await page.evaluate(() =&gt; console.debug(&#39;Some Info&#39;));
await browser.close();</code></pre>
<p>Output:</p>
<pre>[console] debug: Some Info</pre>
<h3>Device Emulation</h3>
<p>Often when testing a reactive layout it’s useful to be able to ensure that the layout works well at multiple screen dimensions, and device pixel ratios. This can be done by using a real mobile browser, either on a device, or on an emulator. However for simplicity it can be useful to perform the testing on a desktop set up to mimic the viewport of a mobile device. The example below shows loading a page with Firefox configured to emulate the viewport size and device pixel ratio of a Pixel 5 phone.</p>
<pre><code>import puppeteer from &#34;puppeteer&#34;;

const device = puppeteer.KnownDevices[&#34;Pixel 5&#34;];

const browser = await puppeteer.launch({
  browser: &#34;firefox&#34;
});

const page = await browser.newPage();
await page.emulate(device);

const viewport = page.viewport();

console.log(
  `[emulate] Pixel 5: ${viewport.width}x${viewport.height}` +
  ` (dpr=${viewport.deviceScaleFactor}, mobile=${viewport.isMobile})`
);

await page.goto(&#34;https://www.mozilla.org&#34;);
await browser.close();
</code></pre>
<p>Output:</p>
<pre>[emulate] Pixel 5: 393x851 (dpr=3, mobile=true)</pre>
<h3>Network Interception</h3>
<p>A common requirement for testing is to be able to track and intercept network requests. Interception is especially useful for avoiding requests to third party services during tests, and providing mock response data. It can also be used to handle HTTP authentication dialogs, and override parts of the request and response, for example adding or removing headers. In the example below we use network request interception to block all requests to web fonts on a page, which might be useful to ensure that these fonts failing to load doesn’t break the site layout.</p>
<pre><code>import puppeteer from &#34;puppeteer&#34;;

const browser = await puppeteer.launch({
  browser: &#39;firefox&#39;
});

const page = await browser.newPage();
await page.setRequestInterception(true);

page.on(&#34;request&#34;, request =&gt; {
  if (request.url().includes(&#34;.woff2&#34;)) {
    // Block requests to custom user fonts.
    console.log(`[intercept] Request aborted: ${request.url()}`);
    request.abort();
  } else {
    request.continue();
  }
});

const response = await page.goto(&#34;https://support.mozilla.org&#34;);
console.log(
  `[navigate] status=${response.status()} url=${response.url()}`
);
await browser.close();</code></pre>
<p>Output:</p>
<pre>[intercept] Request aborted: https://assets-prod.sumo.prod.webservices.mozgcp.net/static/Inter-Bold.3717db0be15085ac.woff2
[navigate] status=200 url=https://support.mozilla.org/en-US/
</pre>
<h3>Preload Scripts</h3>
<p>Often automation tooling wants to provide custom functionality that can be implemented in JavaScript. Whilst WebDriver has always allowed injecting scripts, it wasn’t possible to ensure that an injected script was always run before the page started loading, making it impossible to avoid races between the page scripts and the injected script.</p>
<p>WebDriver BiDi provides “preload” scripts which can be run before a page is loaded. It also provides a means to emit custom events from scripts. This can be used, for example, to avoid polling for expected elements, but instead using a mutation observer that fires as soon as the element is available. In the example below we wait for the &lt;title&gt; element to appear on the page, and log its contents.</p>
<pre><code>import puppeteer from &#34;puppeteer&#34;;

const browser = await puppeteer.launch({
  browser: &#39;firefox&#39;,
});

const page = await browser.newPage();

const gotMessage = new Promise(resolve =&gt;
  page.exposeFunction(&#34;sendMessage&#34;, async message =&gt; {
    console.log(`[script] Message from pre-load script: ${message}`);
    resolve();
  })
);

await page.evaluateOnNewDocument(() =&gt; {
  const observer = new MutationObserver(mutationList =&gt; {
    for (const mutation of mutationList) {
      if (mutation.type === &#34;childList&#34;) {
        for (const node of mutation.addedNodes) {
          if (node.tagName === &#34;TITLE&#34;) {
            sendMessage(node.textContent);
          }
        }
      }
    };
  });

  observer.observe(document.documentElement, {
    subtree: true,
    childList: true,
  });
});

await page.goto(&#34;https://support.mozilla.org&#34;);
await gotMessage;
await browser.close();</code></pre>
<p>Output:</p>
<pre>[script] Message from pre-load script: Mozilla Support</pre>
<h2>Technical Background</h2>
<p>Until recently people wishing to automate browsers had two main choices:</p>
<ul>
<li aria-level="1">Use the W3C <a href="https://w3c.github.io/webdriver/">WebDriver</a> API, which was based on earlier work by the Selenium project.</li>
<li aria-level="1">Use a browser-specific API for talking to each supported browser such as <a href="https://chromedevtools.github.io/devtools-protocol/">Chrome DevTools Protocol</a> (CDP) for Chromium-based browsers, or Firefox’s <a href="https://firefox-source-docs.mozilla.org/devtools/backend/protocol.html">Remote Debugging Protocol</a> (RDP) for Gecko-based browsers.</li>
</ul>
<p>Unfortunately both of those options come with significant tradeoffs. The “classic” WebDriver API is HTTP-based, and its model involves automation sending a command to the browser and waiting for a response. That works well for automation scenarios where you load a page and then verify, for example, that some element is displayed, but the inability to get events ­— e.g. console logs — back from the browser, or run multiple commands concurrently, makes the API a poor fit for more advanced use cases.</p>
<p>By contrast, browser-specific APIs have generally been designed around supporting the complex use cases of in-browser devtools. This has given them a feature set far in advance of what’s possible using WebDriver, as they need to support use cases such as recording console logs, or network requests.</p>
<p>Therefore, browser automation clients have been forced to make the choice between supporting many browsers using a single protocol and providing a limited feature set, or providing a richer feature set but having to implement multiple protocols to provide functionality separately for each supported browser. This obviously increased the cost and complexity of creating great cross-browser automation, which isn’t a good situation, especially when developers <a href="https://mdn.dev/archives/insights/reports/mdn-web-testing-report-2021.html">commonly cite</a> cross-browser testing as one the main pain points in developing for the web.</p>
<p>Long time developers might notice the analogy here to the situation with editors before the development of <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> (LSP). At that time each text editor or IDE had to implement bespoke support for each different programming language. That made it hard to get support for a new language into all the tools that developers were using. The advent of LSP changed that by providing a common protocol that could be supported by any combination of editor and programming language. For a new programming language like TypeScript to be supported across all editors it no longer needs to get them to add support one-by-one; it only needs to provide an LSP server and it will automatically be supported across any LSP-supporting editor. The advent of this common protocol has also enabled things that were hard to imagine before. For example specific libraries like Tailwind getting their own <a href="https://www.npmjs.com/package/@tailwindcss/language-server">LSP implementation</a> to enable bespoke editor functionality.</p>
<p>So to improve cross-browser automation we’ve taken a similar approach: developing <a href="https://w3c.github.io/webdriver-bidi/">WebDriver BiDi</a>, which brings the automation featureset previously limited to browser-specific protocols to a standardized protocol that can be implemented by any browser and used by any automation tooling in any programming language.</p>
<p>At Mozilla we see this strategy of standardizing protocols in order to remove barriers to entry, allow a diverse ecosystem of interoperable implementations to flourish, and enable users to choose those best suited to their needs as a key part of our manifesto and <a href="https://www.mozilla.org/en-US/about/webvision/full/#openness">web vision</a>.</p>
<p>For more details about the design of WebDriver BiDi and how it relates to classic WebDriver, please see our <a href="https://hacks.mozilla.org/2020/12/cross-browser-testing-part-1-web-app-testing-today/">earlier</a> <a href="https://hacks.mozilla.org/2021/01/improving-cross-browser-testing-part-2-new-automation-features-in-firefox-nightly/">posts</a>.</p>
<h2>Removing experimental CDP support in Firefox</h2>
<p>As part of our early work on improving cross-browser testing, we shipped a partial implementation of CDP, limited to a few commands and events needed to support testing use cases. This was previously the basis of experimental support for Firefox in Puppeteer. However, once it became clear that this was not the way forward for cross-browser automation, effort on this was stopped. As a result it is unmaintained and doesn’t work with modern Firefox features such as site isolation. Therefore support is <a href="https://fxdx.dev/deprecating-cdp-support-in-firefox-embracing-the-future-with-webdriver-bidi/">scheduled to be removed</a> at the end of 2024.</p>
<p>If you are currently using CDP with Firefox, and don’t know how to transition to WebDriver BiDi, please reach out using one of the <a href="#contact-us">channels listed at the bottom of this post</a>, and we will discuss your requirements.</p>
<h2>What’s Next?</h2>
<p>Although Firefox is now officially supported in Puppeteer, and has enough functionality to cover many automation and testing scenarios, there are still some APIs that remain unsupported. These broadly fall into three categories (consult the <a href="https://pptr.dev/webdriver-bidi">Puppeteer documentation</a> for a full list):</p>
<ul>
<li aria-level="1">Highly CDP-specific APIs, notably those in the <a href="https://pptr.dev/api/puppeteer.cdpsession">CDPSession</a> module. These are unlikely to be supported directly, but specific use cases that currently require these APIs could be candidates for standardization.</li>
<li aria-level="1">APIs which require further standards work. For example <a href="https://pptr.dev/api/puppeteer.accessibility.snapshot">page.accessibility.snapshot</a> returns a dump of the Chromium accessibility tree. However because there’s currently no standardized description of what that tree should look like this is hard to make work in a cross-browser way. There are also cases which are much more straightforward, as they only require work on the WebDriver BiDi spec itself; for example <a href="https://pptr.dev/api/puppeteer.page.setgeolocation">page.setGeolocation</a>.</li>
<li aria-level="1">APIs which have a standard but are not yet implemented, for example the ability to execute scripts in workers required for commands like <a href="https://pptr.dev/api/puppeteer.webworker.evaluate">WebWorker.evaluate</a>.</li>
</ul>
<p>We expect to fill these gaps going forward. To help prioritize, we’re interested in your feedback: Please try running your Puppeteer tests in Firefox! If you’re unable to get them in Firefox because of a bug or missing feature, please let us know using one of the methods below so that we can take it into account when planning our future standards and implementation work:</p>

    <section>
                                
                      <p>Software engineer focused on maintaining a healthy open web. Web-platform-tests core team member.</p>
                                <p><a href="https://hacks.mozilla.org/author/jgrahammozilla-com/">More articles by James Graham…</a></p>
                  
                                <p><a href="https://hacks.mozilla.org/author/hskupinmozilla-com/">More articles by Henrik Skupin…</a></p>
                  
                                <p><a href="https://hacks.mozilla.org/author/jdescottesmozilla-com/">More articles by Julian Descottes…</a></p>
                  
                                <p><a href="https://hacks.mozilla.org/author/aborovovamozilla-com/">More articles by Alexandra Borovova…</a></p>
                  </section>
  </article></div>
  </body>
</html>
