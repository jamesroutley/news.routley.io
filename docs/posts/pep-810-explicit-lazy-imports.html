<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pep-previews--4622.org.readthedocs.build/pep-0810/">Original</a>
    <h1>PEP 810 – Explicit lazy imports</h1>
    
    <div id="readability-page-1" class="page"><section id="pep-content">

<dl>
<dt>Author<span>:</span></dt>
<dd>Pablo Galindo &lt;pablogsal at python.org&gt;,
Germán Méndez Bravo &lt;german.mb at gmail.com&gt;,
Thomas Wouters &lt;thomas at python.org&gt;,
Dino Viehland &lt;dinoviehland at gmail.com&gt;,
Brittany Reynoso &lt;brittanyrey at gmail.com&gt;,
Noah Kim &lt;noahbkim at gmail.com&gt;,
Tim Stumbaugh &lt;me at tjstum.com&gt;</dd>
<dt>Discussions-To<span>:</span></dt>
<dd><a href="https://discuss.python.org/t/104131">Discourse thread</a></dd>
<dt>Status<span>:</span></dt>
<dd><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt>Type<span>:</span></dt>
<dd><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt>Created<span>:</span></dt>
<dd>02-Oct-2025</dd>
<dt>Python-Version<span>:</span></dt>
<dd>3.15</dd>
<dt>Post-History<span>:</span></dt>
<dd><a href="https://discuss.python.org/t/104131" title="Discourse thread">03-Oct-2025</a></dd>
</dl>
<hr/>
<section id="contents">
<details><summary>Table of Contents</summary><ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#rationale">Rationale</a><ul>
<li><a href="#other-design-decisions">Other design decisions</a></li>
</ul>
</li>
<li><a href="#specification">Specification</a><ul>
<li><a href="#grammar">Grammar</a><ul>
<li><a href="#syntax-restrictions">Syntax restrictions</a></li>
</ul>
</li>
<li><a href="#semantics">Semantics</a></li>
<li><a href="#lazy-import-mechanism">Lazy import mechanism</a></li>
<li><a href="#reification">Reification</a></li>
</ul>
</li>
<li><a href="#reference-implementation">Reference Implementation</a><ul>
<li><a href="#bytecode-and-adaptive-specialization">Bytecode and adaptive specialization</a></li>
<li><a href="#lazy-imports-filter">Lazy imports filter</a></li>
<li><a href="#global-lazy-imports-control">Global lazy imports control</a></li>
</ul>
</li>
<li><a href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a href="#unchanged-semantics">Unchanged semantics</a></li>
<li><a href="#observable-behavioral-shifts-opt-in-only">Observable behavioral shifts (opt-in only)</a></li>
<li><a href="#thread-safety-and-reification">Thread-safety and reification</a></li>
<li><a href="#typing-and-tools">Typing and tools</a></li>
</ul>
</li>
<li><a href="#security-implications">Security Implications</a></li>
<li><a href="#how-to-teach-this">How to Teach This</a></li>
<li><a href="#faq">FAQ</a></li>
<li><a href="#alternate-implementation-ideas">Alternate Implementation Ideas</a><ul>
<li><a href="#leveraging-a-subclass-of-dict">Leveraging a subclass of dict</a></li>
<li><a href="#alternate-keyword-names">Alternate keyword names</a></li>
</ul>
</li>
<li><a href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a href="#modification-of-the-dict-object">Modification of the dict object</a></li>
<li><a href="#placing-the-lazy-keyword-in-the-middle-of-from-imports">Placing the <code><span>lazy</span></code> keyword in the middle of from imports</a></li>
<li><a href="#placing-the-lazy-keyword-at-the-end-of-import-statements">Placing the <code><span>lazy</span></code> keyword at the end of import statements</a></li>
<li><a href="#returning-a-proxy-dict-from-globals">Returning a proxy dict from <code><span>globals()</span></code></a></li>
<li><a href="#reifying-lazy-imports-when-globals-is-called">Reifying lazy imports when <code><span>globals()</span></code> is called</a></li>
</ul>
</li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#footnotes">Footnotes</a></li>
<li><a href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP introduces syntax for lazy imports as an explicit language feature:</p>
<div><div><pre><span></span><span>lazy</span> <span>import</span><span> </span><span>json</span>
<span>lazy</span> <span>from</span><span> </span><span>json</span><span> </span><span>import</span> <span>dumps</span>
</pre></div>
</div>
<p>Lazy imports defer the loading and execution of a module until the first time
the imported name is used, in contrast to ‘normal’ imports, which eagerly load
and execute a module at the point of the import statement.</p>
<p>By allowing developers to mark individual imports as lazy with explicit
syntax, Python programs can reduce startup time, memory usage, and unnecessary
work. This is particularly beneficial for command-line tools, test suites, and
applications with large dependency graphs.</p>
<p>This proposal preserves full backwards compatibility: normal import statements
remain unchanged, and lazy imports are enabled only where explicitly
requested.</p>
</section>
<section id="motivation">
<h2><a href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>The dominant convention in Python code is to place all imports at the module
level, typically at the beginning of the file. This avoids repetition, makes
import dependencies clear and minimizes runtime overhead by only evaluating an
import statement once per module.</p>
<p>A major drawback with this approach is that importing the first module for an
execution of Python (the “main” module) often triggers an immediate cascade of
imports, and optimistically loads many dependencies that may never be used.
The effect is especially costly for command-line tools with multiple
subcommands, where even running the command with <code><span>--help</span></code> can load dozens of
unnecessary modules and take several seconds. This basic example demonstrates
what must be loaded just to get helpful feedback to the user on how to run the
program at all. Inefficiently, the user incurs this overhead again when they
figure out the command they want and invoke the program “for real.”</p>
<p>A somewhat common way to delay imports is to move the imports into functions
(inline imports), but this practice requires more work to implement and
maintain, and can be subverted by a single inadvertent top-level import.
Additionally, it obfuscates the full set of dependencies for a module.
Analysis of the Python standard library shows that approximately 17% of all
imports outside tests (nearly 3500 total imports across 730 files) are already
placed inside functions or methods specifically to defer their execution. This
demonstrates that developers are already manually implementing lazy imports in
performance-sensitive code, but doing so requires scattering imports
throughout the codebase and makes the full dependency graph harder to
understand at a glance.</p>
<p>The standard library provides the <a href="https://docs.python.org/3/library/importlib.html#importlib.util.LazyLoader" title="(in Python v3.13)"><code><span>LazyLoader</span></code></a> class to
solve some of these inefficiency problems. It permits imports at the module
level to work <em>mostly</em> like inline imports do. Many scientific Python
libraries have adopted a similar pattern, formalized in
<a href="https://scientific-python.org/specs/spec-0001/">SPEC 1</a>.
There’s also the third-party <a href="https://pypi.org/project/lazy_loader/">lazy_loader</a> package, yet another
implementation of lazy imports. Imports used solely for static type checking
are another source of potentially unneeded imports, and there are similarly
disparate approaches to minimizing the overhead. The various approaches used
here to defer or remove eager imports do not cover all potential use-cases for
a general lazy import mechanism. There is no clear standard, and there are
several drawbacks including runtime overhead in unexpected places, or worse
runtime introspection.</p>
<p>This proposal introduces syntax for lazy imports with a design that is local,
explicit, controlled, and granular. Each of these qualities is essential to
making the feature predictable and safe to use in practice.</p>
<p>The behavior is <strong>local</strong>: laziness applies only to the specific import marked
with the <code><span>lazy</span></code> keyword, and it does not cascade recursively into other
imports. This ensures that developers can reason about the effect of laziness
by looking only at the line of code in front of them, without worrying about
whether imported modules will themselves behave differently. A <code><span>lazy</span> <span>import</span></code>
is an isolated decision each time it is used, not a global shift in semantics.</p>
<p>The semantics are <strong>explicit</strong>. When a name is imported lazily, the binding is
created in the importing module immediately, but the target module is not
loaded until the first time the name is accessed. After this point, the
binding is indistinguishable from one created by a normal import. This clarity
reduces surprises and makes the feature accessible to developers who may not
be deeply familiar with Python’s import machinery.</p>
<p>Lazy imports are <strong>controlled</strong>, in the sense that deferred loading is only
triggered by the importing code itself. In the general case, a library will
only experience lazy imports if its own authors choose to mark them as such.
This avoids shifting responsibility onto downstream users and prevents
accidental surprises in library behavior. Since library authors typically
manage their own import subgraphs, they retain predictable control over when
and how laziness is applied.</p>
<p>The mechanism is also <strong>granular</strong>. It is introduced through explicit syntax
on individual imports, rather than a global flag or implicit setting. This
allows developers to adopt it incrementally, starting with the most
performance-sensitive areas of a codebase. As this feature is introduced to
the community, we want to make the experience of onboarding optional,
progressive, and adaptable to the needs of each project.</p>
<p>Lazy imports provide several concrete advantages:</p>
<ul>
<li>Command-line tools are often invoked directly by a user, so latency – in
particular startup latency – is quite noticeable. These programs are also
typically short-lived processes (contrasted with, e.g., a web server). With
lazy imports, only the code paths actually reached will import a module.
This can reduce startup time by 50-70% in practice, providing a significant
improvement to a common user experience and improving Python’s
competitiveness in domains where fast startup matters most.</li>
<li>Type annotations frequently require imports that are never used at runtime.
The common workaround is to wrap them in <code><span>if</span> <span>TYPE_CHECKING:</span></code> blocks
<a href="#f1" id="id1">[1]</a>. With lazy imports, annotation-only imports impose no runtime
penalty, eliminating the need for such guards and making annotated codebases
cleaner.</li>
<li>Large applications often import thousands of modules, and each module
creates function and type objects, incurring memory costs. In long-lived
processes, this noticeably raises baseline memory usage. Lazy imports defer
these costs until a module is needed, keeping unused subsystems unloaded.
Memory savings of 30-40% have been observed in real workloads.</li>
</ul>
</section>
<section id="rationale">
<h2><a href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>The design of this proposal is centered on clarity, predictability, and ease
of adoption. Each decision was made to ensure that lazy imports provide
tangible benefits without introducing unnecessary complexity into the language
or its runtime.</p>
<p>It is also worth noting that while this PEP outlines one specific approach, we
list alternate implementation strategies for some of the core aspects and
semantics of the proposal. If the community expresses a strong preference for
a different technical path that still preserves the same core semantics or
there is fundamental disagreement over the specific option, we have included
the brainstorming we have already completed in preparation for this proposal
as reference.</p>
<p>The choice to introduce a new <code><span>lazy</span></code> keyword reflects the need for explicit
syntax. Import behavior is too fundamental to be left implicit or hidden
behind global flags or environment variables. By marking laziness directly at
the import site, the intent is immediately visible to both readers and tools.
This avoids surprises, reduces the cognitive burden of reasoning about
imports, and keeps lazy import semantics in line with Python’s tradition of
explicitness.</p>
<p>Another important decision is to represent lazy imports with proxy objects in
the module’s namespace, rather than by modifying dictionary lookup. Earlier
approaches experimented with embedding laziness into dictionaries, but this
blurred abstractions and risked affecting unrelated parts of the runtime. The
dictionary is a fundamental data structure in Python – literally every object
is built on top of dicts – and adding hooks to dictionaries would prevent
critical optimizations and complicate the entire runtime. The proxy approach
is simpler: it behaves like a placeholder until first use, at which point it
resolves the import and rebinds the name. From then on, the binding is
indistinguishable from a normal import. This makes the mechanism easy to
explain and keeps the rest of the interpreter unchanged.</p>
<p>Compatibility for library authors was also a key concern. Many maintainers
need a migration path that allows them to support both new and old versions of
Python at once. For this reason, the proposal includes the
<code><span>__lazy_modules__</span></code> global as a transitional mechanism. A module can
declare which imports should be treated as lazy (by listing the module names
as strings), and on Python 3.15 or later those imports will become lazy
automatically, as if they were imported with the <code><span>lazy</span></code> keyword. On earlier
versions the declaration is ignored, leaving imports eager. This gives authors
a practical bridge until they can rely on the keyword as the canonical syntax.</p>
<p>Finally, the feature is designed to be adopted incrementally. Nothing changes
unless a developer explicitly opts in, and adoption can begin with just a few
imports in performance-sensitive areas. This mirrors the experience of gradual
typing in Python: a mechanism that can be introduced progressively, without
forcing projects to commit globally from day one. Notably, the adoption can
also be done from the “outside in”, permitting CLI authors to introduce lazy
imports and speed up user-facing tools, without requiring changes to every
library the tool might use.</p>
<section id="other-design-decisions">
<h3><a href="#other-design-decisions" role="doc-backlink">Other design decisions</a></h3>
<ul>
<li>The scope of laziness is deliberately local and non-recursive. A lazy import
only affects the specific statement where it appears; it does not cascade
into other modules or submodules. This choice is crucial for predictability.
When developers read code, they can reason about import behavior line by
line, without worrying about hidden laziness deeper in the dependency graph.
The result is a feature that is powerful but still easy to understand in
context.</li>
<li>In addition, it is useful to provide a mechanism to activate or deactivate
lazy imports at a global level. While the primary design centers on explicit
syntax, there are scenarios – such as large applications, testing
environments, or frameworks – where enabling laziness consistently across
many modules provides the most benefit. A global switch makes it easy to
experiment with or enforce consistent behavior, while still working in
combination with the filtering API to respect exclusions or tool-specific
configuration. This ensures that global adoption can be practical without
reducing flexibility or control.</li>
</ul>
</section>
</section>
<section id="specification">
<h2><a href="#specification" role="doc-backlink">Specification</a></h2>
<section id="grammar">
<h3><a href="#grammar" role="doc-backlink">Grammar</a></h3>
<p>A new soft keyword <code><span>lazy</span></code> is added. A soft keyword is a context-sensitive
keyword that only has special meaning in specific grammatical contexts;
elsewhere it can be used as a regular identifier (e.g., as a variable name).
The <code><span>lazy</span></code> keyword only has special meaning when it appears before import
statements:</p>
<div><div><pre><span></span>import_name:
    | &#39;lazy&#39;? &#39;import&#39; dotted_as_names

import_from:
    | &#39;lazy&#39;? &#39;from&#39; (&#39;.&#39; | &#39;...&#39;)* dotted_name &#39;import&#39; import_from_targets
    | &#39;lazy&#39;? &#39;from&#39; (&#39;.&#39; | &#39;...&#39;)+ &#39;import&#39; import_from_targets
</pre></div>
</div>
<section id="syntax-restrictions">
<h4><a href="#syntax-restrictions" role="doc-backlink">Syntax restrictions</a></h4>
<p>The soft keyword is only allowed at the global (module) level, <strong>not</strong> inside
functions, class bodies, with <code><span>try</span></code>/<code><span>with</span></code> blocks, or <code><span>import</span> <span>*</span></code>. Import
statements that use the soft keyword are <em>potentially lazy</em>. Imports that
can’t be lazy are unaffected by the global lazy imports flag, and instead are
always eager.</p>
<p>Examples of syntax errors:</p>
<div><div><pre><span></span><span># SyntaxError: lazy import not allowed inside functions</span>
<span>def</span><span> </span><span>foo</span><span>():</span>
    <span>lazy</span> <span>import</span><span> </span><span>json</span>

<span># SyntaxError: lazy import not allowed inside classes</span>
<span>class</span><span> </span><span>Bar</span><span>:</span>
    <span>lazy</span> <span>import</span><span> </span><span>json</span>

<span># SyntaxError: lazy import not allowed inside try/except blocks</span>
<span>try</span><span>:</span>
    <span>lazy</span> <span>import</span><span> </span><span>json</span>
<span>except</span> <span>ImportError</span><span>:</span>
    <span>pass</span>

<span># SyntaxError: lazy import not allowed inside with blocks</span>
<span>with</span> <span>suppress</span><span>(</span><span>ImportError</span><span>):</span>
    <span>lazy</span> <span>import</span><span> </span><span>json</span>

<span># SyntaxError: lazy from ... import * is not allowed</span>
<span>lazy</span> <span>from</span><span> </span><span>json</span><span> </span><span>import</span> <span>*</span>
</pre></div>
</div>
</section>
</section>
<section id="semantics">
<h3><a href="#semantics" role="doc-backlink">Semantics</a></h3>
<p>When the <code><span>lazy</span></code> keyword is used, the import becomes <em>potentially lazy</em>.
Unless lazy imports are disabled or suppressed (see below), the module is not
loaded immediately at the import statement; instead, a lazy proxy object is
created and bound to the name. The actual module is loaded on first use of
that name.</p>
<p>Example:</p>
<div><div><pre><span></span><span>import</span><span> </span><span>sys</span>

<span>lazy</span> <span>import</span><span> </span><span>json</span>

<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># False - module not loaded yet</span>

<span># First use triggers loading</span>
<span>result</span> <span>=</span> <span>json</span><span>.</span><span>dumps</span><span>({</span><span>&#34;hello&#34;</span><span>:</span> <span>&#34;world&#34;</span><span>})</span>

<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># True - now loaded</span>
</pre></div>
</div>
<p>A module may contain a <code><span>__lazy_modules__</span></code> attribute, which is a
sequence of fully qualified module names (strings) to make <em>potentially lazy</em>
(as if the <code><span>lazy</span></code> keyword was used). This attribute is checked on each
<code><span>import</span></code> statement to determine whether the import should be made
<em>potentially lazy</em>. When a module is made lazy this way, from-imports using
that module are also lazy, but not necessarily imports of sub-modules.</p>
<p>The normal (non-lazy) import statement will check the global lazy imports
flag. If it is “enabled”, all imports are <em>potentially lazy</em> (except for
imports that can’t be lazy, as mentioned above.)</p>
<p>Example:</p>
<div><div><pre><span></span><span>__lazy_modules__</span> <span>=</span> <span>[</span><span>&#34;json&#34;</span><span>]</span>
<span>import</span><span> </span><span>json</span>
<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># False</span>
<span>result</span> <span>=</span> <span>json</span><span>.</span><span>dumps</span><span>({</span><span>&#34;hello&#34;</span><span>:</span> <span>&#34;world&#34;</span><span>})</span>
<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># True</span>
</pre></div>
</div>
<p>If the global lazy imports flag is set to “disabled”, no <em>potentially lazy</em>
import is ever imported lazily, and the behavior is equivalent to a regular
import statement: the import is <em>eager</em> (as if the lazy keyword was not used).</p>
<p>For a <em>potentially lazy</em> import, the lazy imports filter (if set) is called
with the name of the module doing the import, the name of the module being
imported, and (if applicable) the fromlist. If the lazy import filter returns
<code><span>True</span></code>, the <em>potentially lazy</em> import becomes a lazy import. Otherwise, the
import is <em>not</em> lazy, and the normal (eager) import continues.</p>
</section>
<section id="lazy-import-mechanism">
<h3><a href="#lazy-import-mechanism" role="doc-backlink">Lazy import mechanism</a></h3>
<p>When an import is lazy, <code><span>__lazy_import__</span></code> is called instead of
<code><span>__import__</span></code>. <code><span>__lazy_import__</span></code> has the same function signature as
<code><span>__import__</span></code>. It adds the module name to <code><span>sys.lazy_modules</span></code>, a set of
fully-qualified module names which have been lazily imported at some point
(primarily for diagnostics and introspection), and returns a “lazy module
object.”</p>
<p>The implementation of <code><span>from</span> <span>...</span> <span>import</span></code> (the <code><span>IMPORT_FROM</span></code> bytecode
implementation) checks if the module it’s fetching from is a lazy module
object, and if so, returns a lazy object for each name instead.</p>
<p>The end result of this process is that lazy imports (regardless of how they
are enabled) result in lazy objects being assigned to global variables.</p>
<p>Lazy module objects do not appear in <code><span>sys.modules</span></code>, they’re just listed in
the <code><span>sys.lazy_modules</span></code> set. Under normal operation lazy objects should only
end up stored in global variables, and the common ways to access those
variables (regular variable access, module attributes) will resolve lazy
imports (“reify”) and replace them when they’re accessed.</p>
<p>It is still possible to expose lazy objects through other means, like
debuggers. This is not considered a problem.</p>
</section>
<section id="reification">
<h3><a href="#reification" role="doc-backlink">Reification</a></h3>
<p>When a lazy object is first used, it needs to be reified. This means resolving
the import at that point in the program and replacing the lazy object with the
concrete one. Reification imports the module in the same way as it would have
been if it had been imported eagerly, barring intervening changes to the
import system (e.g. to <code><span>sys.path</span></code>, <code><span>sys.meta_path</span></code>, <code><span>sys.path_hooks</span></code> or
<code><span>__import__</span></code>).</p>
<p>Reification still calls <code><span>__import__</span></code> to resolve the import. When the module
is first reified, it’s removed from <code><span>sys.lazy_modules</span></code> (even if there are
still other unreified lazy references to it). When a package is reified and
submodules in the package were also previously lazily imported, those
submodules are <em>not</em> automatically reified but they <em>are</em> added to the reified
package’s globals (unless the package already assigned something else to the
name of the submodule).</p>
<p>If reification fails (e.g., due to an <code><span>ImportError</span></code>), the exception is
enhanced with chaining to show both where the lazy import was defined and
where it was first accessed (even though it propagates from the code that
triggered reification). This provides clear debugging information:</p>
<div><div><pre><span></span><span># app.py - has a typo in the import</span>
<span>lazy</span> <span>from</span><span> </span><span>json</span><span> </span><span>import</span> <span>dumsp</span>  <span># Typo: should be &#39;dumps&#39;</span>

<span>print</span><span>(</span><span>&#34;App started successfully&#34;</span><span>)</span>
<span>print</span><span>(</span><span>&#34;Processing data...&#34;</span><span>)</span>

<span># Error occurs here on first use</span>
<span>result</span> <span>=</span> <span>dumsp</span><span>({</span><span>&#34;key&#34;</span><span>:</span> <span>&#34;value&#34;</span><span>})</span>
</pre></div>
</div>
<p>The traceback shows both locations:</p>
<div><div><pre><span></span><span>App started successfully</span>
<span>Processing data...</span>
<span>Traceback (most recent call last):</span>
  File <span>&#34;app.py&#34;</span>, line <span>2</span>, in <span>&lt;module&gt;</span>
<span>    </span><span>lazy</span> <span>from</span><span> </span><span>json</span><span> </span><span>import</span> <span>dumsp</span>
<span>ImportError</span>: <span>deferred import of &#39;json.dumsp&#39; raised an exception during resolution</span>

<span>The above exception was the direct cause of the following exception:</span>

<span>Traceback (most recent call last):</span>
  File <span>&#34;app.py&#34;</span>, line <span>8</span>, in <span>&lt;module&gt;</span>
<span>    </span><span>result</span> <span>=</span> <span>dumsp</span><span>({</span><span>&#34;key&#34;</span><span>:</span> <span>&#34;value&#34;</span><span>})</span>
<span>             </span><span>^^^^^</span>
<span>ImportError</span>: <span>cannot import name &#39;dumsp&#39; from &#39;json&#39;. Did you mean: &#39;dump&#39;?</span>
</pre></div>
</div>
<p>This exception chaining clearly shows: (1) where the lazy import was defined,
(2) that it was deferred, and (3) where the actual access happened that
triggered the error.</p>
<p>Reification does <strong>not</strong> automatically occur when a module that was previously
lazily imported is subsequently eagerly imported. Reification does <strong>not</strong>
immediately resolve all lazy objects (e.g. <code><span>lazy</span> <span>from</span></code> statements) that
referenced the module. It <strong>only</strong> resolves the lazy object being accessed.</p>
<p>Accessing a lazy object (from a global variable or a module attribute) reifies
the object. Accessing a module’s <code><span>__dict__</span></code> reifies <strong>all</strong> lazy objects in
that module. Operations that indirectly access <code><span>__dict__</span></code> (such as
<a href="https://docs.python.org/3/library/functions.html#dir" title="(in Python v3.13)"><code><span>dir()</span></code></a>) also trigger this behavior.</p>
<p>Example using <code><span>__dict__</span></code> from external code:</p>
<div><div><pre><span></span><span># my_module.py</span>
<span>import</span><span> </span><span>sys</span>
<span>lazy</span> <span>import</span><span> </span><span>json</span>

<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># False - still lazy</span>

<span># main.py</span>
<span>import</span><span> </span><span>sys</span>
<span>import</span><span> </span><span>my_module</span>

<span># Accessing __dict__ from external code DOES reify all lazy imports</span>
<span>d</span> <span>=</span> <span>my_module</span><span>.</span><span>__dict__</span>

<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># True - reified by __dict__ access</span>
<span>print</span><span>(</span><span>type</span><span>(</span><span>d</span><span>[</span><span>&#39;json&#39;</span><span>]))</span>  <span># &lt;class &#39;module&#39;&gt;</span>
</pre></div>
</div>
<p>However, calling <code><span>globals()</span></code> does <strong>not</strong> trigger reification – it returns
the module’s dictionary, and accessing lazy objects through that dictionary
still returns lazy proxy objects that need to be manually reified upon use. A
lazy object can be resolved explicitly by calling the <code><span>get</span></code> method. Other,
more indirect ways of accessing arbitrary globals (e.g. inspecting
<code><span>frame.f_globals</span></code>) also do <strong>not</strong> reify all the objects.</p>
<p>Example using <code><span>globals()</span></code>:</p>
<div><div><pre><span></span><span>import</span><span> </span><span>sys</span>
<span>lazy</span> <span>import</span><span> </span><span>json</span>

<span># Calling globals() does NOT trigger reification</span>
<span>g</span> <span>=</span> <span>globals</span><span>()</span>

<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># False - still lazy</span>
<span>print</span><span>(</span><span>type</span><span>(</span><span>g</span><span>[</span><span>&#39;json&#39;</span><span>]))</span>  <span># &lt;class &#39;lazy_import&#39;&gt;</span>

<span># Explicitly reify using the get() method</span>
<span>resolved</span> <span>=</span> <span>g</span><span>[</span><span>&#39;json&#39;</span><span>]</span><span>.</span><span>get</span><span>()</span>

<span>print</span><span>(</span><span>type</span><span>(</span><span>resolved</span><span>))</span>  <span># &lt;class &#39;module&#39;&gt;</span>
<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># True - now loaded</span>
</pre></div>
</div>
</section>
</section>
<section id="reference-implementation">
<h2><a href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>A reference implementation is available at:
<a href="https://github.com/LazyImportsCabal/cpython/tree/lazy">https://github.com/LazyImportsCabal/cpython/tree/lazy</a></p>
<section id="bytecode-and-adaptive-specialization">
<h3><a href="#bytecode-and-adaptive-specialization" role="doc-backlink">Bytecode and adaptive specialization</a></h3>
<p>Lazy imports are implemented through modifications to four bytecode
instructions: <code><span>IMPORT_NAME</span></code>, <code><span>IMPORT_FROM</span></code>, <code><span>LOAD_GLOBAL</span></code>, and
<code><span>LOAD_NAME</span></code>.</p>
<p>The <code><span>lazy</span></code> syntax sets a flag in the <code><span>IMPORT_NAME</span></code> instruction’s oparg
(<code><span>oparg</span> <span>&amp;</span> <span>0x01</span></code>). The interpreter checks this flag and calls
<code><span>_PyEval_LazyImportName()</span></code> instead of <code><span>_PyEval_ImportName()</span></code>, creating a
lazy import object rather than executing the import immediately. The
<code><span>IMPORT_FROM</span></code> instruction checks whether its source is a lazy import
(<code><span>PyLazyImport_CheckExact()</span></code>) and creates a lazy object for the attribute
rather than accessing it immediately.</p>
<p>When a lazy object is accessed, it must be reified. The <code><span>LOAD_GLOBAL</span></code>
instruction (used in function scopes) and <code><span>LOAD_NAME</span></code> instruction (used at
module and class level) both check whether the object being loaded is a lazy
import. If so, they call <code><span>_PyImport_LoadLazyImportTstate()</span></code> to perform the
actual import and store the module in <code><span>sys.modules</span></code>.</p>
<p>This check incurs a very small cost on each access. However, Python’s adaptive
interpreter can specialize <code><span>LOAD_GLOBAL</span></code> after observing that a lazy import
has been reified. After several executions, <code><span>LOAD_GLOBAL</span></code> becomes
<code><span>LOAD_GLOBAL_MODULE</span></code>, which accesses the module dictionary directly without
checking for lazy imports.</p>
<p>Examples of the bytecode generated:</p>
<div><div><pre><span></span><span>lazy</span> <span>import</span><span> </span><span>json</span>  <span># IMPORT_NAME with flag set</span>
</pre></div>
</div>
<p>Generates:</p>
<div><div><pre><span></span>IMPORT_NAME              1 (json + lazy)
</pre></div>
</div>
<div><div><pre><span></span><span>lazy</span> <span>from</span><span> </span><span>json</span><span> </span><span>import</span> <span>dumps</span>  <span># IMPORT_NAME + IMPORT_FROM</span>
</pre></div>
</div>
<p>Generates:</p>
<div><div><pre><span></span>IMPORT_NAME              1 (json + lazy)
IMPORT_FROM              1 (dumps)
</pre></div>
</div>
<div><div><pre><span></span><span>lazy</span> <span>import</span><span> </span><span>json</span>
<span>x</span> <span>=</span> <span>json</span>  <span># Module-level access</span>
</pre></div>
</div>
<p>Generates:</p>
<div><div><pre><span></span>LOAD_NAME                0 (json)
</pre></div>
</div>
<div><div><pre><span></span><span>lazy</span> <span>import</span><span> </span><span>json</span>

<span>def</span><span> </span><span>use_json</span><span>():</span>
    <span>return</span> <span>json</span><span>.</span><span>dumps</span><span>({})</span>  <span># Function scope</span>
</pre></div>
</div>
<p>Before any calls:</p>
<div><div><pre><span></span>LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)
</pre></div>
</div>
<p>After several calls, <code><span>LOAD_GLOBAL</span></code> specializes to <code><span>LOAD_GLOBAL_MODULE</span></code>:</p>
<div><div><pre><span></span>LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
</pre></div>
</div>
</section>
<section id="lazy-imports-filter">
<h3><a href="#lazy-imports-filter" role="doc-backlink">Lazy imports filter</a></h3>
<p>This PEP adds two new functions to the <code><span>sys</span></code> module to manage the lazy
imports filter:</p>
<ul>
<li><code><span>sys.set_lazy_imports_filter(func)</span></code> - Sets the filter function. The
<code><span>func</span></code> parameter must have the signature: <code><span>func(importer:</span> <span>str,</span> <span>name:</span> <span>str,</span>
<span>fromlist:</span> <span>tuple[str,</span> <span>...]</span> <span>|</span> <span>None)</span> <span>-&gt;</span> <span>bool</span></code></li>
<li><code><span>sys.get_lazy_imports_filter()</span></code> - Returns the currently installed filter
function, or <code><span>None</span></code> if no filter is set.</li>
</ul>
<p>The filter function is called for every potentially lazy import, and must
return <code><span>True</span></code> if the import should be lazy. This allows for fine-grained
control over which imports should be lazy, useful for excluding modules with
known side-effect dependencies or registration patterns.</p>
<p>The filter mechanism serves as a foundation that tools, debuggers, linters,
and other ecosystem utilities can leverage to provide better lazy import
experiences. For example, static analysis tools could detect modules with side
effects and automatically configure appropriate filters. <strong>In the future</strong>
(out of scope for this PEP), this foundation may enable better ways to
declaratively specify which modules are safe for lazy importing, such as
package metadata, type stubs with lazy-safety annotations, or configuration
files. The current filter API is designed to be flexible enough to accommodate
such future enhancements without requiring changes to the core language
specification.</p>
<p>Example:</p>
<div><div><pre><span></span><span>import</span><span> </span><span>sys</span>

<span>def</span><span> </span><span>exclude_side_effect_modules</span><span>(</span><span>importer</span><span>,</span> <span>name</span><span>,</span> <span>fromlist</span><span>):</span>
<span>    </span><span>&#34;&#34;&#34;</span>
<span>    Filter function to exclude modules with import-time side effects.</span>

<span>    Args:</span>
<span>        importer: Name of the module doing the import</span>
<span>        name: Name of the module being imported</span>
<span>        fromlist: Tuple of names being imported (for &#39;from&#39; imports), or None</span>

<span>    Returns:</span>
<span>        True to allow lazy import, False to force eager import</span>
<span>    &#34;&#34;&#34;</span>
    <span># Modules known to have important import-time side effects</span>
    <span>side_effect_modules</span> <span>=</span> <span>{</span><span>&#39;legacy_plugin_system&#39;</span><span>,</span> <span>&#39;metrics_collector&#39;</span><span>}</span>

    <span>if</span> <span>name</span> <span>in</span> <span>side_effect_modules</span><span>:</span>
        <span>return</span> <span>False</span>  <span># Force eager import</span>

    <span>return</span> <span>True</span>  <span># Allow lazy import</span>

<span># Install the filter</span>
<span>sys</span><span>.</span><span>set_lazy_imports_filter</span><span>(</span><span>exclude_side_effect_modules</span><span>)</span>

<span># These imports are checked by the filter</span>
<span>lazy</span> <span>import</span><span> </span><span>data_processor</span>        <span># Filter returns True -&gt; stays lazy</span>
<span>lazy</span> <span>import</span><span> </span><span>legacy_plugin_system</span>  <span># Filter returns False -&gt; imported eagerly</span>

<span>print</span><span>(</span><span>&#39;data_processor&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>       <span># False - still lazy</span>
<span>print</span><span>(</span><span>&#39;legacy_plugin_system&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span> <span># True - loaded eagerly</span>

<span># First use of data_processor triggers loading</span>
<span>result</span> <span>=</span> <span>data_processor</span><span>.</span><span>transform</span><span>(</span><span>data</span><span>)</span>
<span>print</span><span>(</span><span>&#39;data_processor&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>       <span># True - now loaded</span>
</pre></div>
</div>
</section>
<section id="global-lazy-imports-control">
<h3><a href="#global-lazy-imports-control" role="doc-backlink">Global lazy imports control</a></h3>
<p>The global lazy imports flag can be controlled through:</p>
<ul>
<li>The <code><span>-X</span> <span>lazy_imports=&lt;mode&gt;</span></code> command-line option</li>
<li>The <code><span>PYTHON_LAZY_IMPORTS=&lt;mode&gt;</span></code> environment variable</li>
<li>The <code><span>sys.set_lazy_imports(mode)</span></code> function (primarily for testing)</li>
</ul>
<p>Where <code><span>&lt;mode&gt;</span></code> can be:</p>
<ul>
<li><code><span>&#34;default&#34;</span></code> (or unset): Only explicitly marked lazy imports are lazy</li>
<li><code><span>&#34;enabled&#34;</span></code>: All module-level imports (except in <code><span>try</span></code>  or <code><span>with</span></code>
blocks and <code><span>import</span> <span>*</span></code>) become <em>potentially lazy</em></li>
<li><code><span>&#34;disabled&#34;</span></code>: No imports are lazy, even those explicitly marked with
<code><span>lazy</span></code> keyword</li>
</ul>
<p>When the global flag is set to <code><span>&#34;enabled&#34;</span></code>, all imports at the global level
of all modules are <em>potentially lazy</em> <strong>except</strong> for those inside a <code><span>try</span></code> or
<code><span>with</span></code> block or any wild card (<code><span>from</span> <span>...</span> <span>import</span> <span>*</span></code>) import.</p>
<p>If the global lazy imports flag is set to <code><span>&#34;disabled&#34;</span></code>, no <em>potentially
lazy</em> import is ever imported lazily, the import filter is never called, and
the behavior is equivalent to a regular <code><span>import</span></code> statement: the import is
<em>eager</em> (as if the lazy keyword was not used).</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>Lazy imports are <strong>opt-in</strong>. Existing programs continue to run unchanged
unless a project explicitly enables laziness (via <code><span>lazy</span></code> syntax,
<code><span>__lazy_modules__</span></code>, or an interpreter-wide switch).</p>
<section id="unchanged-semantics">
<h3><a href="#unchanged-semantics" role="doc-backlink">Unchanged semantics</a></h3>
<ul>
<li>Regular <code><span>import</span></code> and <code><span>from</span> <span>...</span> <span>import</span> <span>...</span></code> statements remain eager
unless explicitly made <em>potentially lazy</em> by the local or global mechanisms
provided.</li>
<li>Dynamic import APIs remain eager and unchanged: <code><span>__import__()</span></code> and
<code><span>importlib.import_module()</span></code>.</li>
<li>Import hooks and loaders continue to run under the standard import protocol
when a lazy object is reified.</li>
</ul>
</section>
<section id="observable-behavioral-shifts-opt-in-only">
<h3><a href="#observable-behavioral-shifts-opt-in-only" role="doc-backlink">Observable behavioral shifts (opt-in only)</a></h3>
<p>These changes are limited to bindings explicitly made lazy:</p>
<ul>
<li><strong>Error timing.</strong> Exceptions that would have occurred during an eager import
(for example <code><span>ImportError</span></code> or <code><span>AttributeError</span></code> for a missing member) now
occur at the first <em>use</em> of the lazy name.<div><div><pre><span></span><span># With eager import - error at import statement</span>
<span>import</span><span> </span><span>broken_module</span>  <span># ImportError raised here</span>

<span># With lazy import - error deferred</span>
<span>lazy</span> <span>import</span><span> </span><span>broken_module</span>
<span>print</span><span>(</span><span>&#34;Import succeeded&#34;</span><span>)</span>
<span>broken_module</span><span>.</span><span>foo</span><span>()</span>  <span># ImportError raised here on first use</span>
</pre></div>
</div>
</li>
<li><strong>Side-effect timing.</strong> Import-time side effects in lazily imported modules
occur at first use of the binding, not at module import time.</li>
<li><strong>Import order.</strong> Because modules are imported on first use, the order in
which modules are imported may differ from how they appear in code.</li>
<li><strong>Presence in ``sys.modules``.</strong> A lazily imported module does not appear in
<code><span>sys.modules</span></code> until first use. After reification, it must appear in
<code><span>sys.modules</span></code>. If some other code eagerly imports the same module before
first use, the lazy binding resolves to that existing (lazy) module object
when it is first used.</li>
<li><strong>Proxy visibility.</strong> Before first use, the bound name refers to a lazy
proxy. Indirect introspection that touches the value may observe a proxy
lazy object representation. After first use, the name is rebound to the real
object and becomes indistinguishable from an eager import.</li>
</ul>
</section>
<section id="thread-safety-and-reification">
<h3><a href="#thread-safety-and-reification" role="doc-backlink">Thread-safety and reification</a></h3>
<p>First use of a lazy binding follows the existing import-lock discipline.
Exactly one thread performs the import and <strong>atomically rebinds</strong> the
importing module’s global to the resolved object. Concurrent readers
thereafter observe the real object.</p>
<p>Lazy imports are thread-safe and have no special considerations for
free-threading. A module that would normally be imported in the main thread
may be imported in a different thread if that thread triggers the first access
to the lazy import. This is not a problem: the import lock ensures thread
safety regardless of which thread performs the import.</p>
<p>Subinterpreters are supported. Each subinterpreter maintains its own
<code><span>sys.lazy_modules</span></code> and import state, so lazy imports in one subinterpreter
do not affect others.</p>
</section>
<section id="typing-and-tools">
<h3><a href="#typing-and-tools" role="doc-backlink">Typing and tools</a></h3>
<p>Type checkers and static analyzers may treat <code><span>lazy</span></code> imports as ordinary
imports for name resolution. At runtime, annotation-only imports can be marked
<code><span>lazy</span></code> to avoid startup overhead. IDEs and debuggers should be prepared to
display lazy proxies before first use and the real objects thereafter.</p>
</section>
</section>
<section id="security-implications">
<h2><a href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>There are no known security vulnerabilities introduced by lazy imports.</p>
</section>
<section id="how-to-teach-this">
<h2><a href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>The new <code><span>lazy</span></code> keyword will be documented as part of the language standard.</p>
<p>As this feature is opt-in, new Python users should be able to continue using
the language as they are used to. For experienced developers, we expect them
to leverage lazy imports for the variety of benefits listed above (decreased
latency, decreased memory usage, etc) on a case-by-case basis. Developers
interested in the performance of their Python binary will likely leverage
profiling to understand the import time overhead in their codebase and mark
the necessary imports as <code><span>lazy</span></code>. In addition, developers can mark imports
that will only be used for type annotations as <code><span>lazy</span></code>.</p>
<p>Below is guidance on how to best take advantage of lazy imports and how to
avoid incompatibilities:</p>
<ul>
<li>When adopting lazy imports, users should be aware that eliding an import
until it is used will result in side effects not being executed. In turn,
users should be wary of modules that rely on import time side effects.
Perhaps the most common reliance on import side effects is the registry
pattern, where population of some external registry happens implicitly
during the importing of modules, often via decorators but sometimes
implemented via metaclasses or <code><span>__init_subclass__</span></code>. Instead, registries of
objects should be constructed via explicit discovery processes (e.g. a
well-known function to call).<div><div><pre><span></span><span># Problematic: Plugin registers itself on import</span>
<span># my_plugin.py</span>
<span>from</span><span> </span><span>plugin_registry</span><span> </span><span>import</span> <span>register_plugin</span>

<span>@register_plugin</span><span>(</span><span>&#34;MyPlugin&#34;</span><span>)</span>
<span>class</span><span> </span><span>MyPlugin</span><span>:</span>
    <span>pass</span>

<span># In main code:</span>
<span>lazy</span> <span>import</span><span> </span><span>my_plugin</span>
<span># Plugin NOT registered yet - module not loaded!</span>

<span># Better: Explicit discovery</span>
<span># plugin_registry.py</span>
<span>def</span><span> </span><span>discover_plugins</span><span>():</span>
    <span>from</span><span> </span><span>my_plugin</span><span> </span><span>import</span> <span>MyPlugin</span>
    <span>register_plugin</span><span>(</span><span>MyPlugin</span><span>)</span>

<span># In main code:</span>
<span>plugin_registry</span><span>.</span><span>discover_plugins</span><span>()</span>  <span># Explicit loading</span>
</pre></div>
</div>
</li>
<li>Always import needed submodules explicitly. It is not enough to rely on a
different import to ensure a module has its submodules as attributes.
Plainly, unless there is an explicit <code><span>from</span> <span>.</span> <span>import</span> <span>bar</span></code> in
<code><span>foo/__init__.py</span></code>, always use <code><span>import</span> <span>foo.bar;</span> <span>foo.bar.Baz</span></code>, not
<code><span>import</span> <span>foo;</span> <span>foo.bar.Baz</span></code>. The latter only works (unreliably) because the
attribute <code><span>foo.bar</span></code> is added as a side effect of <code><span>foo.bar</span></code> being
imported somewhere else.</li>
<li>Users who are moving imports into functions to improve startup time, should
instead consider keeping them where they are but adding the <code><span>lazy</span></code>
keyword. This allows them to keep dependencies clear and avoid the overhead
of repeatedly re-resolving the import but will still speed up the program.<div><div><pre><span></span><span># Before: Inline import (repeated overhead)</span>
<span>def</span><span> </span><span>process_data</span><span>(</span><span>data</span><span>):</span>
    <span>import</span><span> </span><span>json</span>  <span># Re-resolved on every call</span>
    <span>return</span> <span>json</span><span>.</span><span>dumps</span><span>(</span><span>data</span><span>)</span>

<span># After: Lazy import at module level</span>
<span>lazy</span> <span>import</span><span> </span><span>json</span>

<span>def</span><span> </span><span>process_data</span><span>(</span><span>data</span><span>):</span>
    <span>return</span> <span>json</span><span>.</span><span>dumps</span><span>(</span><span>data</span><span>)</span>  <span># Loaded once on first call</span>
</pre></div>
</div>
</li>
<li>Avoid using wild card (star) imports, as those are always eager.</li>
</ul>
</section>
<section id="faq">
<h2><a href="#faq" role="doc-backlink">FAQ</a></h2>
<p><strong>Q: How does this differ from the rejected PEP 690?</strong></p>
<p>A: PEP 810 takes an explicit, opt-in approach instead of <a href="https://pep-previews--4622.org.readthedocs.build/pep-0690/" title="PEP 690 – Lazy Imports">PEP 690</a>’s implicit
global approach. The key differences are:</p>
<ul>
<li><strong>Explicit syntax</strong>: <code><span>lazy</span> <span>import</span> <span>foo</span></code> clearly marks which imports are
lazy.</li>
<li><strong>Local scope</strong>: Laziness only affects the specific import statement, not
cascading to dependencies.</li>
<li><strong>Simpler implementation</strong>: Uses proxy objects instead of modifying core
dictionary behavior.</li>
</ul>
<p><strong>Q: What happens when lazy imports encounter errors?</strong></p>
<p>A: Import errors (<code><span>ImportError</span></code>, <code><span>ModuleNotFoundError</span></code>, syntax errors) are
deferred until first use of the lazy name. This is similar to moving an import
into a function. The error will occur with a clear traceback pointing to the
first access of the lazy object.</p>
<p>The implementation provides enhanced error reporting through exception
chaining. When a lazy import fails during reification, the original exception
is preserved and chained, showing both where the import was defined and where
it was first used:</p>
<div><div><pre><span></span><span>Traceback (most recent call last):</span>
  File <span>&#34;test.py&#34;</span>, line <span>1</span>, in <span>&lt;module&gt;</span>
<span>    </span><span>lazy</span> <span>import</span><span> </span><span>broken_module</span>
<span>ImportError</span>: <span>deferred import of &#39;broken_module&#39; raised an exception during resolution</span>

<span>The above exception was the direct cause of the following exception:</span>

<span>Traceback (most recent call last):</span>
  File <span>&#34;test.py&#34;</span>, line <span>3</span>, in <span>&lt;module&gt;</span>
<span>    </span><span>broken_module</span><span>.</span><span>foo</span><span>()</span>
<span>    </span><span>^^^^^^^^^^^^^</span>
  File <span>&#34;broken_module.py&#34;</span>, line <span>2</span>, in <span>&lt;module&gt;</span>
<span>    </span><span>1</span><span>/</span><span>0</span>
<span>ZeroDivisionError</span>: <span>division by zero</span>
</pre></div>
</div>
<p><strong>Q: How do lazy imports affect modules with import-time side effects?</strong></p>
<p>A: Side effects are deferred until first use. This is generally desirable for
performance, but may require code changes for modules that rely on import-time
registration patterns. We recommend:</p>
<ul>
<li>Use explicit initialization functions instead of import-time side effects</li>
<li>Call initialization functions explicitly when needed</li>
<li>Avoid relying on import order for side effects</li>
</ul>
<p><strong>Q: Can I use lazy imports with</strong> <code><span>from</span> <span>...</span> <span>import</span> <span>...</span></code> <strong>statements?</strong></p>
<p>A: Yes, as long as you don’t use <code><span>from</span> <span>...</span> <span>import</span> <span>*</span></code>. Both <code><span>lazy</span> <span>import</span>
<span>foo</span></code> and <code><span>lazy</span> <span>from</span> <span>foo</span> <span>import</span> <span>bar</span></code> are supported. The <code><span>bar</span></code> name will be
bound to a lazy object that resolves to <code><span>foo.bar</span></code> on first use.</p>
<p><strong>Q: Does</strong> <code><span>lazy</span> <span>from</span> <span>module</span> <span>import</span> <span>Class</span></code> <strong>load the entire module or just
the class?</strong></p>
<p>A: It loads the <strong>entire module</strong>, not just the class. This is because
Python’s import system always executes the complete module file – there’s no
mechanism to execute only part of a <code><span>.py</span></code> file. When you first access
<code><span>Class</span></code>, Python:</p>
<ol>
<li>Loads and executes the entire <code><span>module.py</span></code> file</li>
<li>Extracts the <code><span>Class</span></code> attribute from the resulting module object</li>
<li>Binds <code><span>Class</span></code> to the name in your namespace</li>
</ol>
<p>This is identical to eager <code><span>from</span> <span>module</span> <span>import</span> <span>Class</span></code> behavior. The only
difference with lazy imports is that steps 1-3 happen on first use instead of
at the import statement.</p>
<div><div><pre><span></span><span># heavy_module.py</span>
<span>print</span><span>(</span><span>&#34;Loading heavy_module&#34;</span><span>)</span>  <span># This ALWAYS runs when module loads</span>

<span>class</span><span> </span><span>MyClass</span><span>:</span>
    <span>pass</span>

<span>class</span><span> </span><span>UnusedClass</span><span>:</span>
    <span>pass</span>  <span># Also gets defined, even though we don&#39;t import it</span>

<span># app.py</span>
<span>lazy</span> <span>from</span><span> </span><span>heavy_module</span><span> </span><span>import</span> <span>MyClass</span>

<span>print</span><span>(</span><span>&#34;Import statement done&#34;</span><span>)</span>  <span># heavy_module not loaded yet</span>
<span>obj</span> <span>=</span> <span>MyClass</span><span>()</span>                  <span># NOW &#34;Loading heavy_module&#34; prints</span>
                                 <span># (and UnusedClass gets defined too)</span>
</pre></div>
</div>
<p><strong>Key point</strong>: Lazy imports defer <em>when</em> a module loads, not <em>what</em> gets
loaded. You cannot selectively load only parts of a module – Python’s import
system doesn’t support partial module execution.</p>
<p><strong>Q: What about type annotations and</strong> <code><span>TYPE_CHECKING</span></code> <strong>imports?</strong></p>
<p>A: Lazy imports eliminate the common need for <code><span>TYPE_CHECKING</span></code> guards. You
can write:</p>
<div><div><pre><span></span><span>lazy</span> <span>from</span><span> </span><span>collections.abc</span><span> </span><span>import</span> <span>Sequence</span><span>,</span> <span>Mapping</span>  <span># No runtime cost</span>

<span>def</span><span> </span><span>process</span><span>(</span><span>items</span><span>:</span> <span>Sequence</span><span>[</span><span>str</span><span>])</span> <span>-&gt;</span> <span>Mapping</span><span>[</span><span>str</span><span>,</span> <span>int</span><span>]:</span>
    <span>...</span>
</pre></div>
</div>
<p>Instead of:</p>
<div><div><pre><span></span><span>from</span><span> </span><span>typing</span><span> </span><span>import</span> <span>TYPE_CHECKING</span>
<span>if</span> <span>TYPE_CHECKING</span><span>:</span>
    <span>from</span><span> </span><span>collections.abc</span><span> </span><span>import</span> <span>Sequence</span><span>,</span> <span>Mapping</span>

<span>def</span><span> </span><span>process</span><span>(</span><span>items</span><span>:</span> <span>Sequence</span><span>[</span><span>str</span><span>])</span> <span>-&gt;</span> <span>Mapping</span><span>[</span><span>str</span><span>,</span> <span>int</span><span>]:</span>
    <span>...</span>
</pre></div>
</div>
<p><strong>Q: What’s the performance overhead of lazy imports?</strong></p>
<p>A: The overhead is minimal:</p>
<ul>
<li>Zero overhead after first use thanks to the adaptive interpreter optimizing
the slow path away.</li>
<li>Small one-time cost to create the proxy object.</li>
<li>Reification (first use) has the same cost as a regular import.</li>
<li>No ongoing performance penalty unlike <code><span>importlib.util.LazyLoader</span></code>.</li>
</ul>
<p>Benchmarking with the <a href="https://github.com/facebookexperimental/free-threading-benchmarking/blob/main/results/bm-20250922-3.15.0a0-27836e5/bm-20250922-vultr-x86_64-DinoV-lazy_imports-3.15.0a0-27836e5-vs-base.svg">pyperformance suite</a> shows the implementation is
performance neutral when lazy imports are not used.</p>
<p><strong>Q: Can I mix lazy and eager imports of the same module?</strong></p>
<p>A: Yes. If module <code><span>foo</span></code> is imported both lazily and eagerly in the same
program, the eager import takes precedence and both bindings resolve to the
same module object.</p>
<p><strong>Q: How do I migrate existing code to use lazy imports?</strong></p>
<p>A: Migration is incremental:</p>
<ol>
<li>Identify slow-loading modules using profiling tools.</li>
<li>Add <code><span>lazy</span></code> keyword to imports that aren’t needed immediately.</li>
<li>Test that side-effect timing changes don’t break functionality.</li>
<li>Use <code><span>__lazy_modules__</span></code> for compatibility with older Python versions.</li>
</ol>
<p><strong>Q: What about star imports</strong> (<code><span>from</span> <span>module</span> <span>import</span> <span>*</span></code>)?</p>
<p>A: Wild card (star) imports cannot be lazy - they remain eager. This is
because the set of names being imported cannot be determined without loading
the module. Using the <code><span>lazy</span></code> keyword with star imports will be a syntax
error. If lazy imports are globally enabled, star imports will still be eager.</p>
<p><strong>Q: How do lazy imports interact with import hooks and custom loaders?</strong></p>
<p>A: Import hooks and loaders work normally. When a lazy object is first used,
the standard import protocol runs, including any custom hooks or loaders that
were in place at reification time.</p>
<p><strong>Q: What happens in multi-threaded environments?</strong></p>
<p>A: Lazy import reification is thread-safe. Only one thread will perform the
actual import, and the binding is atomically updated. Other threads will see
either the lazy proxy or the final resolved object.</p>
<p><strong>Q: Can I force reification of a lazy import without using it?</strong></p>
<p>A: Yes, accessing a module’s <code><span>__dict__</span></code> will reify all lazy objects in that
module. Individual lazy objects can be resolved by calling their <code><span>get()</span></code>
method.</p>
<p><strong>Q: What’s the difference between</strong> <code><span>globals()</span></code> <strong>and</strong> <code><span>mod.__dict__</span></code> <strong>for lazy imports?</strong></p>
<p>A: Calling <code><span>globals()</span></code> returns the module’s dictionary without reifying lazy
imports – you’ll see lazy proxy objects when accessing them through the
returned dictionary. However, accessing <code><span>mod.__dict__</span></code> from external code
reifies all lazy imports in that module first. This design ensures:</p>
<div><div><pre><span></span><span># In your module:</span>
<span>lazy</span> <span>import</span><span> </span><span>json</span>

<span>g</span> <span>=</span> <span>globals</span><span>()</span>
<span>print</span><span>(</span><span>type</span><span>(</span><span>g</span><span>[</span><span>&#39;json&#39;</span><span>]))</span>  <span># &lt;class &#39;lazy_import&#39;&gt; - your problem</span>

<span># From external code:</span>
<span>import</span><span> </span><span>sys</span>
<span>mod</span> <span>=</span> <span>sys</span><span>.</span><span>modules</span><span>[</span><span>&#39;your_module&#39;</span><span>]</span>
<span>d</span> <span>=</span> <span>mod</span><span>.</span><span>__dict__</span>
<span>print</span><span>(</span><span>type</span><span>(</span><span>d</span><span>[</span><span>&#39;json&#39;</span><span>]))</span>  <span># &lt;class &#39;module&#39;&gt; - reified for external access</span>
</pre></div>
</div>
<p>This distinction means adding lazy imports and calling <code><span>globals()</span></code> is your
responsibility to manage, while external code accessing <code><span>mod.__dict__</span></code>
always sees fully loaded modules.</p>
<p><strong>Q: Why not use</strong> <code><span>importlib.util.LazyLoader</span></code> <strong>instead?</strong></p>
<p>A: <code><span>LazyLoader</span></code> has significant limitations:</p>
<ul>
<li>Requires verbose setup code for each lazy import.</li>
<li>Has ongoing performance overhead on every attribute access.</li>
<li>Doesn’t work well with <code><span>from</span> <span>...</span> <span>import</span></code> statements.</li>
<li>Less clear and standard than dedicated syntax.</li>
</ul>
<p><strong>Q: Will this break tools like</strong> <code><span>isort</span></code> <strong>or</strong> <code><span>black</span></code>?</p>
<p>A: Tools will need updates to recognize the <code><span>lazy</span></code> keyword, but the changes
should be minimal since the import structure remains the same. The keyword
appears at the beginning, making it easy to parse.</p>
<p><strong>Q: How do I know if a library is compatible with lazy imports?</strong></p>
<p>A: Most libraries should work fine with lazy imports. Libraries that might
have issues:</p>
<ul>
<li>Those with essential import-time side effects (registration,
monkey-patching).</li>
<li>Those that expect specific import ordering.</li>
<li>Those that modify global state during import.</li>
</ul>
<p>When in doubt, test lazy imports with your specific use cases.</p>
<p><strong>Q: What happens if I globally enable lazy imports mode and a library doesn’t
work correctly?</strong></p>
<p>A: <em>Note: This is an advanced feature.</em> You can use the lazy imports filter to
exclude specific modules that are known to have problematic side effects:</p>
<div><div><pre><span></span><span>import</span><span> </span><span>sys</span>

<span>def</span><span> </span><span>my_filter</span><span>(</span><span>importer</span><span>,</span> <span>name</span><span>,</span> <span>fromlist</span><span>):</span>
    <span># Don&#39;t lazily import modules known to have side effects</span>
    <span>if</span> <span>name</span> <span>in</span> <span>{</span><span>&#39;problematic_module&#39;</span><span>,</span> <span>&#39;another_module&#39;</span><span>}:</span>
        <span>return</span> <span>False</span>  <span># Import eagerly</span>
    <span>return</span> <span>True</span>  <span># Allow lazy import</span>

<span>sys</span><span>.</span><span>set_lazy_imports_filter</span><span>(</span><span>my_filter</span><span>)</span>
</pre></div>
</div>
<p>The filter function receives the importer module name, the module being
imported, and the fromlist (if using <code><span>from</span> <span>...</span> <span>import</span></code>). Returning <code><span>False</span></code>
forces an eager import.</p>
<p>Alternatively, set the global mode to <code><span>&#34;disabled&#34;</span></code> via <code><span>-X</span>
<span>lazy_imports=disabled</span></code> to turn off all lazy imports for debugging.</p>
<p><strong>Q: Can I use lazy imports inside functions?</strong></p>
<p>A: No, the <code><span>lazy</span></code> keyword is only allowed at module level. For
function-level lazy loading, use traditional inline imports or move the import
to module level with <code><span>lazy</span></code>.</p>
<p><strong>Q: What about forwards compatibility with older Python versions?</strong></p>
<p>A: Use the <code><span>__lazy_modules__</span></code> global for compatibility:</p>
<div><div><pre><span></span><span># Works on Python 3.15+ as lazy, eager on older versions</span>
<span>__lazy_modules__</span> <span>=</span> <span>[</span><span>&#39;expensive_module&#39;</span><span>,</span> <span>&#39;expensive_module_2&#39;</span><span>]</span>
<span>import</span><span> </span><span>expensive_module</span>
<span>from</span><span> </span><span>expensive_module_2</span><span> </span><span>import</span> <span>MyClass</span>
</pre></div>
</div>
<p>The <code><span>__lazy_modules__</span></code> attribute is a list of module name strings. When
an import statement is executed, Python checks if the module name being
imported appears in <code><span>__lazy_modules__</span></code>. If it does, the import is
treated as if it had the <code><span>lazy</span></code> keyword (becoming <em>potentially lazy</em>). On
Python versions before 3.15 that don’t support lazy imports, the
<code><span>__lazy_modules__</span></code> attribute is simply ignored and imports proceed
eagerly as normal.</p>
<p>This provides a migration path until you can rely on the <code><span>lazy</span></code> keyword. For
maximum predictability, it’s recommended to define <code><span>__lazy_modules__</span></code>
once, before any imports. But as it is checked on each import, it can be
modified between <code><span>import</span></code> statements.</p>
<p><strong>Q: How do explicit lazy imports interact with PEP-649/PEP-749</strong></p>
<p>A: If an annotation is not stringified, it is an expression that is evaluated
at a later time. It will only be resolved if the annotation is accessed. In
the example below, the <code><span>fake_typing</span></code> module is only loaded when the user
inspects the <code><span>__annotations__</span></code> dictionary. The <code><span>fake_typing</span></code> module would
also be loaded if the user uses <code><span>annotationlib.get_annotations()</span></code> or
<code><span>getattr</span></code> to access the annotations.</p>
<div><div><pre><span></span><span>lazy</span> <span>from</span><span> </span><span>fake_typing</span><span> </span><span>import</span> <span>MyFakeType</span>
<span>def</span><span> </span><span>foo</span><span>(</span><span>x</span><span>:</span> <span>MyFakeType</span><span>):</span>
  <span>pass</span>
<span>print</span><span>(</span><span>foo</span><span>.</span><span>__annotations__</span><span>)</span>  <span># Triggers loading the fake_typing module</span>
</pre></div>
</div>
<p><strong>Q: How do lazy imports interact with</strong> <code><span>dir()</span></code>, <code><span>getattr()</span></code>, <strong>and
module introspection?</strong></p>
<p>A: Accessing lazy imports through normal attribute access or <code><span>getattr()</span></code>
will trigger reification. Calling <code><span>dir()</span></code> on a module will reify all lazy
imports in that module to ensure the directory listing is complete. This is
similar to accessing <code><span>mod.__dict__</span></code>.</p>
<div><div><pre><span></span><span>lazy</span> <span>import</span><span> </span><span>json</span>

<span># Before any access</span>
<span># json not in sys.modules</span>

<span># Any of these trigger reification:</span>
<span>dumps_func</span> <span>=</span> <span>json</span><span>.</span><span>dumps</span>
<span>dumps_func</span> <span>=</span> <span>getattr</span><span>(</span><span>json</span><span>,</span> <span>&#39;dumps&#39;</span><span>)</span>
<span>dir</span><span>(</span><span>json</span><span>)</span>
<span># Now json is in sys.modules</span>
</pre></div>
</div>
<p><strong>Q: Do lazy imports work with circular imports?</strong></p>
<p>A: Lazy imports don’t automatically solve circular import problems. If two
modules have a circular dependency, making the imports lazy might help <strong>only
if</strong> the circular reference isn’t accessed during module initialization.
However, if either module accesses the other during import time, you’ll still
get an error.</p>
<p><strong>Example that works</strong> (deferred access in functions):</p>
<div><div><pre><span></span><span># user_model.py</span>
<span>lazy</span> <span>import</span><span> </span><span>post_model</span>

<span>class</span><span> </span><span>User</span><span>:</span>
    <span>def</span><span> </span><span>get_posts</span><span>(</span><span>self</span><span>):</span>
        <span># OK - post_model accessed inside function, not during import</span>
        <span>return</span> <span>post_model</span><span>.</span><span>Post</span><span>.</span><span>get_by_user</span><span>(</span><span>self</span><span>.</span><span>name</span><span>)</span>

<span># post_model.py</span>
<span>lazy</span> <span>import</span><span> </span><span>user_model</span>

<span>class</span><span> </span><span>Post</span><span>:</span>
    <span>@staticmethod</span>
    <span>def</span><span> </span><span>get_by_user</span><span>(</span><span>username</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;Posts by </span><span>{</span><span>username</span><span>}</span><span>&#34;</span>
</pre></div>
</div>
<p>This works because neither module accesses the other at module level – the
access happens later when <code><span>get_posts()</span></code> is called.</p>
<p><strong>Example that fails</strong> (access during import):</p>
<div><div><pre><span></span><span># module_a.py</span>
<span>lazy</span> <span>import</span><span> </span><span>module_b</span>

<span>result</span> <span>=</span> <span>module_b</span><span>.</span><span>get_value</span><span>()</span>  <span># Error! Accessing during import</span>

<span>def</span><span> </span><span>func</span><span>():</span>
    <span>return</span> <span>&#34;A&#34;</span>

<span># module_b.py</span>
<span>lazy</span> <span>import</span><span> </span><span>module_a</span>

<span>result</span> <span>=</span> <span>module_a</span><span>.</span><span>func</span><span>()</span>  <span># Circular dependency error here</span>

<span>def</span><span> </span><span>get_value</span><span>():</span>
    <span>return</span> <span>&#34;B&#34;</span>
</pre></div>
</div>
<p>This fails because <code><span>module_a</span></code> tries to access <code><span>module_b</span></code> at import time,
which then tries to access <code><span>module_a</span></code> before it’s fully initialized.</p>
<p>The best practice is still to avoid circular imports in your code design.</p>
<p><strong>Q: Will lazy imports affect the performance of my hot paths?</strong></p>
<p>A: After first use, lazy imports have <strong>zero overhead</strong> thanks to the adaptive
interpreter. The interpreter specializes the bytecode (e.g., <code><span>LOAD_GLOBAL</span></code>
becomes <code><span>LOAD_GLOBAL_MODULE</span></code>) which eliminates the lazy check on subsequent
accesses. This means once a lazy import is reified, accessing it is just as
fast as a normal import.</p>
<div><div><pre><span></span><span>lazy</span> <span>import</span><span> </span><span>json</span>

<span>def</span><span> </span><span>use_json</span><span>():</span>
    <span>return</span> <span>json</span><span>.</span><span>dumps</span><span>({</span><span>&#34;test&#34;</span><span>:</span> <span>1</span><span>})</span>

<span># First call triggers reification</span>
<span>use_json</span><span>()</span>

<span># After 2-3 calls, bytecode is specialized</span>
<span>use_json</span><span>()</span>
<span>use_json</span><span>()</span>
</pre></div>
</div>
<p>You can observe the specialization using <code><span>dis.dis(use_json,</span> <span>adaptive=True)</span></code>:</p>
<div><div><pre><span></span>=== Before specialization ===
LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)

=== After 3 calls (specialized) ===
LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
</pre></div>
</div>
<p>The specialized <code><span>LOAD_GLOBAL_MODULE</span></code> and <code><span>LOAD_ATTR_MODULE</span></code> instructions
are optimized fast paths with no overhead for checking lazy imports.</p>
<p><strong>Q: What about</strong> <code><span>sys.modules</span></code>? <strong>When does a lazy import appear there?</strong></p>
<p>A: A lazily imported module does <strong>not</strong> appear in <code><span>sys.modules</span></code> until it’s
reified (first used). Once reified, it appears in <code><span>sys.modules</span></code> just like
any eager import.</p>
<div><div><pre><span></span><span>import</span><span> </span><span>sys</span>
<span>lazy</span> <span>import</span><span> </span><span>json</span>

<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># False</span>

<span>result</span> <span>=</span> <span>json</span><span>.</span><span>dumps</span><span>({</span><span>&#34;key&#34;</span><span>:</span> <span>&#34;value&#34;</span><span>})</span>  <span># First use</span>

<span>print</span><span>(</span><span>&#39;json&#39;</span> <span>in</span> <span>sys</span><span>.</span><span>modules</span><span>)</span>  <span># True</span>
</pre></div>
</div>
<p><strong>Q: Why you chose ``lazy`` as the keyword name?</strong></p>
<p>A: Not “why”… memorize! :)</p>
</section>
<section id="alternate-implementation-ideas">
<h2><a href="#alternate-implementation-ideas" role="doc-backlink">Alternate Implementation Ideas</a></h2>
<p>Here are some alternative design decisions that were considered during the
development of this PEP. While the current proposal represents what we believe
to be the best balance of simplicity, performance, and maintainability, these
alternatives offer different trade-offs that may be valuable for implementers
to consider or for future refinements.</p>
<section id="leveraging-a-subclass-of-dict">
<h3><a href="#leveraging-a-subclass-of-dict" role="doc-backlink">Leveraging a subclass of dict</a></h3>
<p>Instead of updating the internal dict object to directly add the fields needed
to support lazy imports, we could create a subclass of the dict object to be
used specifically for Lazy Import enablement. This would still be a leaky
abstraction though - methods can be called directly such as
<code><span>dict.__getitem__</span></code> and it would impact the performance of globals lookup in
the interpreter.</p>
</section>
<section id="alternate-keyword-names">
<h3><a href="#alternate-keyword-names" role="doc-backlink">Alternate keyword names</a></h3>
<p>For this PEP, we decided to propose <code><span>lazy</span></code> for the explicit keyword as it
felt the most familar to those already focused on optimizing import overhead.
We also considered a variety of other options to support explicit lazy
imports. The most compelling alternates were <code><span>defer</span></code> and <code><span>delay</span></code>.</p>
</section>
</section>
<section id="rejected-ideas">
<h2><a href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="modification-of-the-dict-object">
<h3><a href="#modification-of-the-dict-object" role="doc-backlink">Modification of the dict object</a></h3>
<p>The initial PEP for lazy imports (PEP 690) relied heavily on the modification
of the internal dict object to support lazy imports. We recognize that this
data structure is highly tuned, heavily used across the codebase, and very
performance sensitive. Because of the importance of this data structure and
the desire to keep the implementation of lazy imports encapsulated from users
who may have no interest in the feature, we’ve decided to invest in an
alternate approach.</p>
<p>The dictionary is the foundational data structure in Python. Every object’s
attributes are stored in a dict, and dicts are used throughout the runtime for
namespaces, keyword arguments, and more. Adding any kind of hook or special
behavior to dicts to support lazy imports would:</p>
<ol>
<li>Prevent critical interpreter optimizations including future JIT
compilation.</li>
<li>Add complexity to a data structure that must remain simple and fast.</li>
<li>Affect every part of Python, not just import behavior.</li>
<li>Violate separation of concerns – the hash table shouldn’t know about the
import system.</li>
</ol>
<p>Past decisions that violated this principle of keeping core abstractions clean
have caused significant pain in the CPython ecosystem, making optimization
difficult and introducing subtle bugs.</p>
</section>
<section id="placing-the-lazy-keyword-in-the-middle-of-from-imports">
<h3><a href="#placing-the-lazy-keyword-in-the-middle-of-from-imports" role="doc-backlink">Placing the <code><span>lazy</span></code> keyword in the middle of from imports</a></h3>
<p>While we found <code><span>from</span> <span>foo</span> <span>lazy</span> <span>import</span> <span>bar</span></code> to be a really intuitive placement
for the new explicit syntax, we quickly learned that placing the <code><span>lazy</span></code>
keyword here is already syntactically allowed in Python. This is because
<code><span>from</span> <span>.</span> <span>lazy</span> <span>import</span> <span>bar</span></code> is legal syntax (because whitespace does not
matter.)</p>
</section>
<section id="placing-the-lazy-keyword-at-the-end-of-import-statements">
<h3><a href="#placing-the-lazy-keyword-at-the-end-of-import-statements" role="doc-backlink">Placing the <code><span>lazy</span></code> keyword at the end of import statements</a></h3>
<p>We discussed appending lazy to the end of import statements like such <code><span>import</span>
<span>foo</span> <span>lazy</span></code> or <code><span>from</span> <span>foo</span> <span>import</span> <span>bar,</span> <span>baz</span> <span>lazy</span></code> but ultimately decided that
this approach provided less clarity. For example, if multiple modules are
imported in a single statement, it is unclear if the lazy binding applies to
all of the imported objects or just a subset of the items.</p>
</section>
<section id="returning-a-proxy-dict-from-globals">
<h3><a href="#returning-a-proxy-dict-from-globals" role="doc-backlink">Returning a proxy dict from <code><span>globals()</span></code></a></h3>
<p>An alternative to reifying on <code><span>globals()</span></code> or exposing lazy objects would be
to return a proxy dictionary that automatically reifies lazy objects when
they’re accessed through the proxy. This would seemingly give the best of both
worlds: <code><span>globals()</span></code> returns immediately without reification cost, but
accessing items through the result would automatically resolve lazy imports.</p>
<p>However, this approach is fundamentally incompatible with how <code><span>globals()</span></code> is
used in practice. Many standard library functions and built-ins expect
<code><span>globals()</span></code> to return a real <code><span>dict</span></code> object, not a proxy:</p>
<ul>
<li><code><span>exec(code,</span> <span>globals())</span></code> requires a real dict.</li>
<li><code><span>eval(expr,</span> <span>globals())</span></code> requires a real dict.</li>
<li>Functions that check <code><span>type(globals())</span> <span>is</span> <span>dict</span></code> would break.</li>
<li>Dictionary methods like <code><span>.update()</span></code> would need special handling.</li>
<li>Performance would suffer from the indirection on every access.</li>
</ul>
<p>The proxy would need to be so transparent that it would be indistinguishable
from a real dict in almost all cases, which is extremely difficult to achieve
correctly. Any deviation from true dict behavior would be a source of subtle
bugs.</p>
</section>
<section id="reifying-lazy-imports-when-globals-is-called">
<h3><a href="#reifying-lazy-imports-when-globals-is-called" role="doc-backlink">Reifying lazy imports when <code><span>globals()</span></code> is called</a></h3>
<p>Calling <code><span>globals()</span></code> returns the module’s namespace dictionary without
triggering reification of lazy imports. Accessing lazy objects through the
returned dictionary yields the lazy proxy objects themselves. This is an
intentional design decision for several reasons:</p>
<p><strong>The key distinction</strong>: Adding a lazy import and calling <code><span>globals()</span></code> is the
module author’s concern and under their control. However, accessing
<code><span>mod.__dict__</span></code> from external code is a different scenario – it crosses
module boundaries and affects someone else’s code. Therefore, <code><span>mod.__dict__</span></code>
access reifies all lazy imports to ensure external code sees fully realized
modules, while <code><span>globals()</span></code> preserves lazy objects for the module’s own
introspection needs.</p>
<p><strong>Technical challenges</strong>: It is impossible to safely reify on-demand when
<code><span>globals()</span></code> is called because we cannot return a proxy dictionary – this
would break common usages like passing the result to <code><span>exec()</span></code> or other
built-ins that expect a real dictionary. The only alternative would be to
eagerly reify all lazy imports whenever <code><span>globals()</span></code> is called, but this
behavior would be surprising and potentially expensive.</p>
<p><strong>Performance concerns</strong>: It is impractical to cache whether a reification
scan has been performed with just the globals dictionary reference, whereas
module attribute access (the primary use case) can efficiently cache
reification state in the module object itself.</p>
<p><strong>Use case rationale</strong>: The chosen design makes sense precisely because of
this distinction: adding a lazy import and calling <code><span>globals()</span></code> is your
problem to manage, while having lazy imports visible in <code><span>mod.__dict__</span></code>
becomes someone else’s problem. By reifying on <code><span>__dict__</span></code> access but not on
<code><span>globals()</span></code>, we ensure external code always sees fully loaded modules while
giving module authors control over their own introspection.</p>
<p>Note that three options were considered:</p>
<ol>
<li>Calling <code><span>globals()</span></code> or <code><span>mod.__dict__</span></code> traverses and resolves all lazy
objects before returning.</li>
<li>Calling <code><span>globals()</span></code> or <code><span>mod.__dict__</span></code> returns the dictionary with lazy
objects present.</li>
<li>Calling <code><span>globals()</span></code> returns the dictionary with lazy objects, but
<code><span>mod.__dict__</span></code> reifies everything.</li>
</ol>
<p>We chose the third option because it properly delineates responsibility: if
you add lazy imports to your module and call <code><span>globals()</span></code>, you’re responsible
for handling the lazy objects. But external code accessing your module’s
<code><span>__dict__</span></code> shouldn’t need to know about your lazy imports – it gets fully
resolved modules.</p>
</section>
</section>
<section id="acknowledgements">
<h2><a href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>We would like to thank Paul Ganssle, Yury Selivanov, Łukasz Langa, Lysandros
Nikolaou, Pradyun Gedam, Mark Shannon, Hana Joo and the Python Google team,
the Python team(s) @ Meta, the Python @ HRT team, the Bloomberg Python team,
the Scientific Python community, everyone who participated in the initial
discussion of <a href="https://pep-previews--4622.org.readthedocs.build/pep-0690/" title="PEP 690 – Lazy Imports">PEP 690</a>, and many others who provided valuable feedback and
insights that helped shape this PEP.</p>
</section>
<section id="footnotes">
<h2><a href="#footnotes" role="doc-backlink">Footnotes</a></h2>

</section>
<section id="copyright">
<h2><a href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section></div>
  </body>
</html>
