<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://funcall.blogspot.com/2025/01/fold-and-monoids.html">Original</a>
    <h1>Fold-... and Monoids</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1326275503265836222" itemprop="description articleBody">
<p>Suppose you satisfy these axioms:</p>
<ul><li>you have a binary function • and a set that • is closed
  over (<i>i.e.</i> for all <i>x</i>, <i>y</i> in the
set, <i>x</i>•<i>y</i> is in the set)</li>
<li>• is associative, ((a • b) • c) = (a • (b • c))</li>
<li>There is an an identity element I: a • I = I • a =
  a</li></ul>

<p>Then • is called a semigroup or “monoid”.</p>

<p>Monoids come from abstract algebra, but they are ubiquitous in
  computer science.  Here are some monoids:  string-append over
  strings, addition over integers, state transition over machine
  states, compose over unary functions.</p>

<p>Alternatively, we can define a monoid as a binary function • that
  is closed under folds <code>fold-left</code> or <code>fold-right</code>.
  That is, <code>(fold-left #’• I list-of-set-elements)</code> is an
  element of the set.  Folds abstract the processing lists of set
  elements.  The walk through the list, the end test, and the
  accumulation of the result are all taken care of by the
  implementation of fold.  You get to focus on the monoid that acts
  on each element.</p>

<p>Folds come in two flavors: <code>fold-left</code>
  and <code>fold-right</code>.  <code>fold-left</code> has an obvious
  iterative implementation, but the result is accumulated left to
  right, which can come out backwards.  <code>fold-right</code> has an
  obvious recursive implementation which accumulates right to left,
  The result comes out in the right order, but the recursion can
  cause problems if the stack space is limited.</p>

<p>Here are some stupid tricks you can do with folds and monoids.</p>

<h3>Create n-ary functions</h3>

<p>If we curry the call to fold, we extend the binary function of two
  arguments to an n-ary function of a list of arguments.  For example,
  n-ary addition is just a fold over binary
  addition.  <code>(fold-left #’+ 0 list-of-integers)</code>.
  Likewise, n-ary <code>compose</code> is just a fold over
  binary <code>compose</code>.</p>

<h3><code>Fold-…</code> is self documenting</h3>

<p>If I haven’t used <code>fold-left</code> or <code>fold-right</code>
  in a while, I sometimes forget which one computes what.
  But <code>fold-left</code> and <code>fold-right</code> can document
  themselves:  use a combining function that returns the list <code>(F a
    b)</code> to indicate a call to <code>F</code>:</p>

<pre>&gt; (fold-left (lambda (a b) (list ’F a b)) ’|...| ’(c b a))
(F (F (F |...| C) B) A)

&gt; (fold-right (lambda (a b) (list ’F a b)) ’(a b c) ’|...|)
(F A (F B (F C |...|)))</pre>

<p>You can see the structure of the recursion by
  using <code>list</code> as the combining function:</p>

<pre>&gt; (fold-left #’list ’|...| ’(c b a))
(((|...| C) B) A)

&gt; (fold-right #’list ’(a b c) ’|...|)
(A (B (C |...|)))</pre>

<h3><code>fold-…</code> works on groups</h3>

<p>A group is a special case of a monoid where the combining function
  is also invertible.  <code>fold-…</code> can be used on a
  group as well.  For example, <code>fold-left</code> can be used on
  linear fractional transformations, which are a group under function
  composition.</p> 

<h3><code>fold-…</code> as an accumulator</h3>

<p>The combining function in <code>fold-left</code> must be at least
  semi-closed:  the output type is the same as the type of the left
  input. (In <code>fold-right</code>, the output type is the same as
  the type of the right input.)  This is so we can use the output of
  the prior call as the input to the next call.  In effect, we set up
  a feedback loop between the output to one of the inputs of the
  binary function.  This feedback loop has a curious property:  it
  behaves as if it has state.  This is happens even
  though both <code>fold-…</code> and the combining functions are pure
  functions.  The state appears to arise from the feedback loop.</p>

<p>We can use <code>fold-…</code> to accumulate a value.
  For <code>fold-left</code>, at each iteration, the accumulator is
  passed as the first (left) argument to the combining function while
  the next element of the list is the second (right) argument.  The combining function returns a new
  value for the accumulator (it can return the old value if nothing is to be
  accumulated on this step).  The result of the <code>fold-left</code>
  is the final value of the accumulator.</p>

<p>Note that because the accumulated value is passed as the first
  argument, you cannot use <code>cons</code> as the combining function
  to accumulate a list.  This is unfortunate because it seems obvious
  to write <code>(fold-left #’cons ’() ...)</code> to accumulate a
  list, but that isn’t how it works.  However, if you swap the
  arguments to <code>cons</code> you’ll accumulate a list:</p>

<pre>(defun xcons (cdr car) (cons car cdr))

(defun revappend (elements base)
  (fold-left #’xcons base elements))</pre>

<h3><code>fold-…</code> as a state machine</h3>

<p>Although <code>fold-left</code> is commonly used to accumulate
  results, it is more general than that.  We can
  use <code>fold-left</code> as a driver for a state machine.  The second
  argument to <code>fold-left</code> is the initial state, and the
  combining function is the state transition function.  The list
  argument provides a single input to the state machine on each state
  transition.</p>

<p>For example, suppose you have a data structure that is a made out
  of nested plists.  You want to navigate down through the plists to
  reach a final leaf value.  We set up a state machine where the
  state is the location in the nested plists and the state transition
  is navigation to a deeper plist.</p>

<pre>(defun getf* (nested-plists path)
  (fold-left #’getf nested-plists path))</pre>

<p>Alternatively, we could drive a state machine by
  calling <code>fold-left</code> with an initial state and list of
  state transtion functions:</p>
<pre>(defun run-state-machine (initial-state transitions)
  (fold-left (lambda (state transition)
               (funcall transition state))
             initial-state
             transitions))</pre>

<h3>Visualizing <code>fold-left</code></h3>

<p>If we unroll the recursion in <code>fold-left</code>, and introduce
  a temp variable to hold the intermediate result, we see the
  following:</p>
<pre>(fold-left F init ’(c b a))

temp ← init
temp ← F(temp, c)
temp ← F(temp, b)  
temp ← F(temp, a)</pre>

<p>I often find it easier to write the combining function in
  a <code>fold-…</code> by visualizing a chain of combining
  functions wired together like this.</p>

<h3>Generating pipelines</h3>

<p>Now let’s partially apply F to its right argument.  We do this by
  currying F and immediately supplying an argument:</p>
<pre>(defun curry-left (f)
  (lambda (l)
    (lambda (r)
      (funcall f l r))))

(defun curry-right (f)
  (lambda (r)
    (lambda (l)
      (funcall f l r))))

(defun partially-apply-left (f l)
  (funcall (curry-left f) l))

(defun partially-apply-right (f r)
  (funcall (curry-right f) r))
</pre>

<p>We can partially apply the combining function to the elements in
  the list.  This gives us a list of one argument functions.  In fact,
  for each set element in the set associated with our monoid, we can
  associate a one-argument function.  We can draw from this set of
  one-argument functions to create pipelines through function
  composition.  So our visualization</p>

<pre>temp ← init
temp ← F(temp, c)
temp ← F(temp, b)  
temp ← F(temp, a)</pre>

<p>becomes</p>

<pre>temp ← init
temp ← F<sub>c</sub>(temp)
temp ← F<sub>b</sub>(temp)  
temp ← F<sub>a</sub>(temp)</pre>

<p>We can write this pipeline this way:</p>
<pre>result ← F<sub>a</sub> ← F<sub>b</sub> ← F<sub>c</sub> ← init</pre>

<p>or this way:</p>
<pre>result ← (compose F<sub>a</sub> F<sub>b</sub> F<sub>c</sub>) ← init</pre>

<p>We can pretend that the elements of the set associated with monoid
  are pipeline stages.  We can treat lists of set elements as
  though they are pipelines.</p>

<p>Notice how we never write a loop.  We don’t have the
  typical list loop boilerplate</p>
<pre>(if (null list)
         ... base case ...
  (let ((element (car list))
        (tail (cdr list)))
    ... ad hoc per element code ...
    (iter tail)))</pre>

<p>Instead, we have a function that processes one element at a time
  and we “lift” that function up to process lists of
  elements.</p>

<p>Pipelines are easier to reason about than loops.  <code>fold-…</code> converts loops into pipelines.</p>

<p>It takes a little practice to use <code>fold-…</code> in the less obvious ways.
  Once you get used to it, you’ll see them everywhere.  You can eliminate many loops by replacing them with <code>fold-…</code>.
  
</p><h4>Monoids vs. Monads</h4>
<p>A <dfn>monad</dfn> is a monoid over a set of curried functions.  You use a variant of <code>compose</code> to combine the curried functions.  Monads force sequential processing because you set up a pipeline and the earlier stages of the pipeline naturally must run first.  That is why monads are used in lazy languages to embed imperative subroutines.</p>


</div></div>
  </body>
</html>
