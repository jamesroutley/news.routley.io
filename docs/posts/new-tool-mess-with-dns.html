<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2021/12/15/mess-with-dns/">Original</a>
    <h1>New tool: Mess with DNS!</h1>
    
    

<p>Hello! I&rsquo;ve been thinking about how to explain DNS a bunch <a href="https://jvns.ca/blog/2021/02/24/a-little-tool-to-make-dns-queries/">in</a> <a href="https://jvns.ca/blog/2021/03/31/dnspeep-tool/">the</a> <a href="https://jvns.ca/blog/2021/11/04/how-do-you-tell-if-a-problem-is-caused-by-dns/">last</a> <a href="https://jvns.ca/blog/2021/12/06/dns-doesn-t-propagate/">year</a>.</p>

<p>I like to learn in a very hands-on way. And so when I write a zine, I often
close the zine by saying something like &ldquo;&hellip; and the best way to learn more
about this is to play around and experiment!&ldquo;.</p>

<p>So I built a site where you can do experiments with DNS called <a href="https://messwithdns.net">Mess With DNS</a>. It has examples of experiments you can try, and
you&rsquo;ve very encouraged to come up with your own experiments.</p>

<p>In this post I&rsquo;ll talk about why I made this, how it works, and give you
probably more details than you want to know about how I built it (design, testing,
security, writing an authoritative nameserver, live streaming updates, etc)</p>

<h3 id="a-screencast">a screencast</h3>

<p>Here&rsquo;s a GIF screencast of what it looks like to use it:</p>

<p><img src="https://jvns.ca/images/messwithdns-recording.gif"></p>

<h3 id="it-s-a-real-dns-server">it&rsquo;s a real DNS server</h3>

<p>First: Mess With DNS gives you a real subdomain, and it&rsquo;s running a real DNS
server (the address is <code>mess-with-dns1.wizardzines.com</code>).  The interesting thing about DNS
is that it&rsquo;s a global system with many different computers interacting, and so
I wanted people to be able to actually see that system in action.</p>

<h3 id="problems-with-experimenting-with-dns">problems with experimenting with DNS</h3>

<p>So, what makes it hard to experiment with DNS?</p>

<ol>
<li>You <strong>might not be comfortable creating test DNS records</strong> on your domain (or you might not even have a domain!)</li>
<li>A lot of the <strong>DNS queries happening behind the scenes are invisible to you</strong>. This makes it harder to understand what&rsquo;s going on.</li>
<li>You might not know <strong>which experiments to</strong> do to get interesting/surprising results</li>
</ol>

<p>Mess With DNS:</p>

<ol>
<li>Gives you a free subdomain you can use do to DNS experiments (like <code>ocean7.messwithdns.com</code>)</li>
<li>Shows you a live stream of all DNS queries coming in for records on your subdomain (a &ldquo;behind the scenes&rdquo; view)</li>
<li>Has a list of experiments to try (but you can and should do any experiment you want :) )</li>
</ol>

<p>There are three kinds of experiments you can try in Mess With DNS: &ldquo;weird&rdquo; experiments, &ldquo;useful&rdquo; experiments, and &ldquo;tutorial&rdquo; experiments.</p>

<h3 id="the-weird-experiments">the &ldquo;weird&rdquo; experiments</h3>

<p>When I experiment, I like to break things. I learn a lot more from seeing what
happens when things go wrong than from things going right.</p>

<p>So when thinking about experiments, I thought about things that have gone wrong for me with DNS, like:</p>

<ul>
<li>negative DNS caching making me wait an HOUR for my website to work just because I visited the page by accident</li>
<li>having to wait a long time for cached record expire</li>
<li>different resolvers having different cached records, which meant I got different results</li>
<li>pointing at the correct IP address, but having the server not recognize the <code>Host</code> header</li>
</ul>

<p>Instead of viewing these as frustrating, I thought &ndash; I&rsquo;ll make these into an
interesting experiment with no consequences, that people can learn from! So we
built a section of &ldquo;Weird Experiments&rdquo; where you can intentionally cause some
of these problems and see how they play out.</p>

<h3 id="the-useful-and-tutorial-experiments">the &ldquo;useful&rdquo; and &ldquo;tutorial&rdquo; experiments</h3>

<p>The &ldquo;weird&rdquo; experiments are the ones we spent the most time on, but there are
also:</p>

<ul>
<li>&ldquo;tutorial&rdquo; experiments that walk you through setting some basic DNS records,
if you&rsquo;re newer to DNS or just to help you see how the site works</li>
<li>&ldquo;useful&rdquo; experiments that let actual realistic DNS tasks (like setting up a website or email)</li>
</ul>

<p>I think I&rsquo;ll add more examples of &ldquo;useful&rdquo; experiments later.</p>

<h3 id="the-experiments-have-different-results-for-different-people">the experiments have different results for different people</h3>

<p>One thing we noticed in playtesting was that the &ldquo;weird&rdquo; experiments don&rsquo;t have
the same results for everyone, mostly because different people are using
different DNS resolvers. For example, there&rsquo;s a negative caching experiment
called &ldquo;Visit a domain before creating its DNS record&rdquo;. And when I test that
experiment, it works as described. But my friend who was using Cloudflare
(1.1.1.1) as a DNS resolver got totally different results when he tried it!</p>

<p>I was stressed out by this at first &ndash; it would for sure be simpler for me if I
knew that everyone has a consistent experience! But, thinking about it more,
one of the basic facts about DNS is that people <em>don&rsquo;t</em> have a consistent
experience of it. So I think it&rsquo;s better to just be honest about that reality.</p>

<h3 id="giving-behind-the-scenes-explanations">giving &ldquo;behind the scenes&rdquo; explanations</h3>

<p>For some of the experiments, it&rsquo;s not really obvious what&rsquo;s happening behind
the scenes and I wanted to provide explanations at the end.</p>

<p>I often make comic to show how different computers interact. But I didn&rsquo;t feel
like drawing a bunch of comics (it takes a long time, and they&rsquo;re hard to
edit).</p>

<p>So we came up with this format for showing how the different characters interact,
using icons to identify each character. It looks like this:</p>

<p><img src="https://jvns.ca/images/explanation.png"></p>

<p>Honestly I think this could probably be made clearer and I don&rsquo;t love the
design of the icons, but maybe I&rsquo;ll improve it later :)</p>

<p>Okay, that&rsquo;s everything I have to say about the experiments.</p>

<h3 id="design-is-hard">design is hard</h3>

<p>Next, I want to talk about is the website&rsquo;s design, which was a challenge for me.</p>

<p>I built this project with <a href="https://marieflanagan.com/">Marie Claire LeBlanc Flanagan</a>, a friend of mine who&rsquo;s a game designer
and who thinks a lot about learning. We pair programmed on writing all the
experiments, the design and the CSS.</p>

<p>I used to think that design is about how things <strong>look</strong> &ndash; that websites
should look nice. But every time I talk to someone who&rsquo;s better at design than
me, the first question they always ask instead is &ldquo;okay, how should this
<strong>work</strong>?&ldquo;. It&rsquo;s all about functionality and clarity.</p>

<p>Of course, the site isn&rsquo;t perfect &ndash; it could probably be more clear! But we
definitely improved it along the way. So I want to talk about how we
made the website more clear by doing user testing.</p>

<h3 id="user-testing-is-incredibly-helpful">user testing is incredibly helpful</h3>

<p>The way we did user testing was to observe a few people using the website
and get them to narrate their thoughts out loud and see what&rsquo;s confusing to
them.</p>

<p>We did 5 of these tests (thanks so much to Kamal, Aaron, Ari, Anton, and Tom!).
We came out of each test with like 50 bullet points of notes and possible things to change, and then we needed to distill them into actual changes to make.
Here are 3 things we improved because of the user testing:</p>

<p><strong>1. the sidebar</strong></p>

<p>One thing we noticed was &ndash; we had this sidebar with experiments people could
try. It looked like this, and I originally thought it was okay.</p>

<p><img src="https://jvns.ca/images/sidebar-old.gif" style="max-width: 300px"></p>

<p>But in the user testing, we saw that people kept getting confused and lost in
the sidebar. I really didn&rsquo;t know how to improve it, but luckily Marie is
better at this than me and we came up with a different design that
better isolates the information about each experiment. Here&rsquo;s a gif:</p>

<p><img src="https://jvns.ca/images/sidebar-new.gif" style="max-width: 300px"></p>

<p>Also, everything in that gif implemented in pure CSS with a <code>&lt;details&gt;</code> tag which I
thought was  cool. (here&rsquo;s <a href="https://codepen.io/NielsVoogt/pen/XWjPdjO">the codepen I learned this from</a>)</p>

<p><strong>2. the terminology</strong></p>

<p>Another thing we learned in user experience testing was that a lot of people
were confused about the DNS terms we were using like &ldquo;A record&rdquo; or &ldquo;resolver&rdquo;.
So we wrote <a href="https://messwithdns.net/dictionary.html">a short DNS dictionary</a> to try to help with that a bit.</p>

<p><strong>3. the instructions</strong></p>

<p>Originally, in the instructions I&rsquo;d written something like</p>

<blockquote>
<p>Create a CNAME record that points visit-after.fox3.messwithdns.com at orange.jvns.ca with a TTL of 3600</p>
</blockquote>

<p>In the playtesting, we noticed that people took a long time to parse that
sentence and translate it into which fields they needed to fill in. So we
changed the instructions to look like this instead:</p>

<p><img src="https://jvns.ca/images/cname-mess.png" style="margin-left: 2em; border: 1px solid #ccc;"></p>

<p>That feels a lot clearer to me.</p>

<p>That&rsquo;s all I&rsquo;ll say about the design, let&rsquo;s move on to the implementation.</p>

<h3 id="frontend-test-automation-is-amazing">frontend test automation is amazing</h3>

<p>Even though it&rsquo;s pretty small, this is a bigger Javascript project than I&rsquo;ve
done previously. Usually my testing strategy for Javascript is &ldquo;write a bunch
of terrible untested code, manually test it, hope for the best&rdquo;.</p>

<p>But when taking that approach this time, I kept breaking the site and I got
a familiar feeling of &ldquo;JULIA, you need to write TESTS, come on, this is
ridiculous&rdquo;.</p>

<p>I know about frontend test automation frameworks like Selenium, but I hadn&rsquo;t
used them for ages. I asked <a href="https://ballingt.com/">Tom</a> what I should use, he suggested <a href="https://playwright.dev/">Playwright</a>, so I used that and it worked great.</p>

<p>All of the Playwright tests are integration tests which is really helpful &ndash;
even though it&rsquo;s a frontend testing framework, the integration tests have
helped me find a bunch of bugs on the backend too.</p>

<p>Here&rsquo;s an example of one of my tests, that makes sure that when I make a DNS
request to the backend it appears in the frontend. (This one broke just the
other day when I was refactoring the backend!)</p>

<pre><code>test('empty dns request gets streamed', async ({ page }) =&gt; {
    await page.goto('http://localhost:8080')
    await page.click('#start-experimenting');
    const subdomain = await getSubdomain(page);
    const fullName = 'asdf.' + subdomain + '.messwithdns.com.'
    await getIp(fullName);
    await expect(page.locator('.request-name')).toHaveText(fullName);
    await expect(page.locator('.request-host')).toHaveText('localhost.lan.');
    await expect(page.locator('.request-response')).toContainText('Code: NXDOMAIN');
});
</code></pre>

<p>I won&rsquo;t really explain the details but hopefully that gives you a basic idea.
These tests are still a little flaky for reasons I don&rsquo;t quite understand, but
I think maybe that&rsquo;s normal with frontend automation? I&rsquo;ve found them pretty easy
to write, pretty reliable, and super useful.</p>

<p>Okay, now let&rsquo;s move to talking about the backend, which was more in my comfort
zone. This was fun to build and there were a bunch of things I thought were interesting.</p>

<p>I&rsquo;ve put a <a href="https://github.com/jvns/mess-with-dns-backend/">snapshot of the backend&rsquo;s code on GitHub</a> if you want to read it.</p>

<h3 id="the-authoritative-dns-server">the authoritative DNS server</h3>

<p>I needed to write an authoritative DNS server, and I took my usual approach
when trying to do something I haven&rsquo;t done before:</p>

<ol>
<li>start with an empty program that does almost nothing (copied from <a href="https://jameshfisher.com/2017/08/04/golang-dns-server/">How to write a DNS server in Go</a>)</li>
<li>read 0 documentation and just start implementing stuff</li>
<li>see what breaks</li>
<li>Begrudgingly read a little bit of documentation to fix things that break</li>
</ol>

<p>I used this wonderful DNS library
<a href="https://github.com/miekg/dns">https://github.com/miekg/dns</a> which I used previously for the backend of
<a href="https://dns-lookup.jvns.ca/">https://dns-lookup.jvns.ca/</a>.</p>

<p>Here&rsquo;s what my main <a href="https://github.com/jvns/mess-with-dns-backend/blob/main/main.go#L284-L304"><code>ServeDNS</code> function</a> looks like, with some error handling and logging removed:</p>

<pre><code>func (handle *handler) ServeDNS(w dns.ResponseWriter, request *dns.Msg) {
    // look up records in the database
	msg := dnsResponse(handle.db, request)
	w.WriteMsg(msg)
    
    // Save the request to the database and send it to any clients who have a websocket open
	remote_addr := w.RemoteAddr().(*net.UDPAddr).IP
	LogRequest(handle.db, r, msg, remote_addr, lookupHost(handle.ipRanges, remote_addr))
}
</code></pre>

<h3 id="following-the-dns-rfcs-not-exactly">following the DNS RFCs? not exactly</h3>

<p>I think I&rsquo;m doing a pretty bad of following the DNS RFCs. Basically my algorithm for which records to return is:</p>

<p>for which DNS response code to return:</p>

<ol>
<li>return <code>NXDOMAIN</code> if I don&rsquo;t have any records for a name, and <code>NOERROR</code> if I do have a record</li>
<li>return a <code>REFUSED</code> error if someone requests a name that doesn&rsquo;t end with <code>.messwithdns.com.</code></li>
<li>return <code>SERVFAIL</code> if I run into some kind of error like not being able to</li>
</ol>

<p>for which queries to return:</p>

<ol>
<li>if I have a <code>CNAME</code> record for a name, then return it no matter what query type is requested</li>
<li>if I get a <code>HTTPS</code> query, return any A/AAAA records I have. (I&rsquo;m doing
this because it&rsquo;s what Cloudflare seems to do and I get a lot of HTTPS DNS
queries, I spent a few minutes trying to read the IETF draft about what
HTTPS queries are and I couldn&rsquo;t really understand it so I gave up)</li>
<li>otherwise just return any records that match the requested type</li>
</ol>

<p>Hopefully that&rsquo;s close enough that it won&rsquo;t cause any major problems. I think
there are some rules I&rsquo;m not following, like if there&rsquo;s already an <code>A</code> record
for a name I&rsquo;m not supposed to let people set a <code>CNAME</code> record. But I&rsquo;m lazy so
I did not implement that.</p>

<p>I did find <a href="https://github.com/dnsimple/dnstest/blob/main/src/dnstest_definitions.erl">this test suite for an authoritative DNS server</a> which I might spend more time looking through later.</p>

<h3 id="live-streaming-the-requests-with-websockets-and-go-channels">live streaming the requests with websockets and Go channels</h3>

<p>I wanted people to be able to livestream all requests coming in for their
domain. When I was first thinking about how this works, I started googling
things like &ldquo;firebase&rdquo; and &ldquo;google pubsub&rdquo; and &ldquo;redis&rdquo; and other pub/sub or
streaming systems. I started implementing it this way but then I was having
trouble getting it to work and I thought&hellip; wait&hellip; I don&rsquo;t want to deal with a
separate service!</p>

<p>So instead I wrote
60ish lines of code using Go channels (<a href="https://github.com/jvns/mess-with-dns-backend/blob/7e5ef139a99bfe08683e80bf220b4bf35edb292f/stream.go">stream.go</a>).
Basically every time someone opens a websocket, I <a href="https://github.com/jvns/mess-with-dns-backend/blob/main/main.go#L120">create a Go channel</a>
and store it in a map. Then whenever a DNS request comes in, I can just send it
to all the channels that are waiting for requests.</p>

<p>This seems to work great. Originally I was using SSE (server side events)
instead of websockets, but for some reason it wasn&rsquo;t working on one friend&rsquo;s
computer so I switched to websockets and that seems more reliable.</p>

<h3 id="tradeoff-no-distributed-systems-but-slower-response-times">tradeoff: no distributed systems, but slower response times</h3>

<p>Implementing my pub/sub system with Go channels means that both the DNS server
and the HTTP server need to live in a single process, and so I can&rsquo;t run
multiple DNS servers.</p>

<p>Right now the single process is in Virginia, so that means the HTTP API and DNS
responses are going to be slower if you&rsquo;re in Tokyo or something. I decided
this was okay because it&rsquo;s an educational site &ndash; it&rsquo;s ok if it&rsquo;s a little
slow!</p>

<p>And this means I don&rsquo;t need to deal with any distributed systems, which is
amazing. Distributed systems are very annoying.</p>

<p>The static files for the frontend are distributed though: I put the site behind a CDN which should help
make everything feel faster.</p>

<h3 id="finding-out-who-owns-ip-addresses-with-an-asn-database">finding out who owns IP addresses with an ASN database</h3>

<p>When a DNS requests comes in, it comes from an IP address. I wanted to tell
users who owns that IP address (Google? Cloudflare? their ISP?). The obvious way is to do a reverse DNS lookup.
But what if that doesn&rsquo;t work?</p>

<p>I started out by using an API to look up the owner of an IP. This
worked great, but then, similarly to with the pub/sub question, I thoought &ndash;
why rely on an external service? I bet I can do this myself without taking a
dependency on an API that might go down.</p>

<p>So I googled &ldquo;asn database download&rdquo;, and I found this free <a href="https://iptoasn.com/">IP to ASN database</a> which lists every IP address and who it belongs to.</p>

<p>Then I just needed to <a href="https://github.com/jvns/mess-with-dns-backend/blob/main/ip2asn.go#L57-L73">implement a binary search</a>
(well, technically it was mostly Github Copilot that implemented a binary search, I just fixed the bugs), and I could look up
the owner of any IP super quickly.</p>

<p>So the IP address lookup code <a href="https://github.com/jvns/mess-with-dns-backend/blob/main/main.go#L315-L326">does a reverse DNS lookup and then falls back to the ASN database</a>.</p>

<h3 id="some-notes-on-picking-a-database">some notes on picking a database</h3>

<p>I started out using <a href="https://planetscale.com/">planetscale</a> because they have a free tier and I love free tiers.</p>

<p>But then I realized that my application is very write-heavy (I do a database
write every time a DNS request comes in!!), and their free tier only allows 10
million writes per month. Which seemed like a lot initially, but I&rsquo;d already
gotten 100,000 DNS queries while it was only me using the service, and suddenly
10 million really wasn&rsquo;t feeling like that much.</p>

<p>So I switched to using a small Postgres instance with a 10GB volume. I think
that should be a reasonable amount of disk space because even though I store a
lot of requests, I don&rsquo;t actually need to store the requests for that <em>long</em> &ndash;
I could easily clear out old requests every hour and it probably wouldn&rsquo;t make
a difference.</p>

<p>The data volume is attached to a <a href="https://fly.io/docs/reference/postgres/">stateless machine running Postgres</a> that I can easily upgrade to
give it more CPU/RAM if I need to.</p>

<p>I&rsquo;m also excited about using Postgres because my partner Kamal has a lot more
experience using Postgres than me so I can ask him questions.</p>

<h3 id="let-s-talk-about-security">let&rsquo;s talk about security</h3>

<p>Like with the <a href="https://jvns.ca/blog/2021/09/24/new-tool--an-nginx-playground/">nginx playground</a>, I
had some security concerns. When I started building the project, I set it up so
that anybody could set any DNS record on any subdomain of <code>messwithdns.com</code>.
This felt a little scary to me, though I couldn&rsquo;t put my finger on exactly why
initially.</p>

<p>Then I implemented Github OAuth, but that felt kind of bad too &ndash; logging in adds
friction! Not everyone has a GitHub account!</p>

<p>Eventually I chatted with Kamal about it and we decided I was concerned about 3 things:</p>

<ol>
<li>Accidental collisions where 2 people get assigned the same subdomain and get confused</li>
<li>People trying to create phishing subdomains</li>
<li>I wnated people to get short, easy-to-type in domains</li>
</ol>

<p>So I wrote a simple <a href="https://github.com/jvns/mess-with-dns-backend/blob/7e5ef139a99bfe08683e80bf220b4bf35edb292f/users.go#L108-L117">login function</a> that:</p>

<ol>
<li>Generates a random subdomain like <code>ocean8</code> that&rsquo;s never been used before</li>
<li>Saves <code>ocean8</code> to a database table so nobody else can take it</li>
<li>Sends a secure cookie to the client (using <code>gorilla/securecookie</code>)</li>
<li>Then the user (you!) can make any changes you want to <code>ocean8.messwithdns.com</code>.</li>
</ol>

<p>Also the website&rsquo;s domain (<a href="https://messwithdns.net">https://messwithdns.net</a>)
is hosted on a different domain entirely than the domain where users can set
records (which is <a href="https://messwithdns.com">https://messwithdns.com</a>). So that means that if someone somehow does set a record on <code>messwithdns.com</code> at least it won&rsquo;t take the site down.</p>

<h3 id="some-static-ip-addresses">some static IP addresses</h3>

<p>One more quick note about the experiments: I wanted to have some IP addresses people could use in their experiment if they
wanted. So I set up two static IPv4 addresses: <a href="http://orange.jvns.ca">orange.jvns.ca</a>
and <a href="http://purple.jvns.ca">purple.jvns.ca</a>. They show a picture of an orange and some
grapes respectively, so you can easily see which is which.</p>

<p>It&rsquo;s important that each one has a dedicated IP address because they&rsquo;ll be
accessed using a bunch of different domains, so I couldn&rsquo;t use the domain name
to decide how to route the request.</p>

<h3 id="that-s-all">that&rsquo;s all</h3>

<p>I hope this project helps some of you understand DNS better, and I&rsquo;d love to
hear about any problems you run into. Again, the site is at
<a href="https://messwithdns.net">https://messwithdns.net</a> and you can report problems <a href="https://github.com/jvns/mess-with-dns-backend/issues">on GitHub</a>.</p>

  </body>
</html>
