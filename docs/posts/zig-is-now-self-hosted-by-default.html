<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ziglang/zig/wiki/Self-Hosted-Compiler-Upgrade-Guide">Original</a>
    <h1>Zig is now selfâ€“hosted by default</h1>
    
    <div id="readability-page-1" class="page"><div data-view-component="true">          <div id="wiki-body">
              <div>
                <p>This guide is to help you modify your project so that it builds &amp; runs correctly again after the merge of <a href="https://github.com/ziglang/zig/pull/12368">#12368</a>.</p>
<h2>
<a id="user-content-is-it-time-to-upgrade" href="#is-it-time-to-upgrade" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Is it time to upgrade?</h2>
<p>One option you have is to simply wait for 0.10.0, or even 0.10.1, before attempting an upgrade. This gives you the smoothest experience, letting other, more brave souls, help with quality assurance before you get your hands dirty. There&#39;s no shame in this, do what works for you.</p>
<p>If anything goes wrong in the upgrade, you can always start using <code>-fstage1</code> to get the old compiler, or put the equivalent in your build.zig file, so that your users can continue using <code>zig build</code> as usual.</p>

<p>The new compiler, sometimes called &#34;stage2&#34; or &#34;stage3&#34;, is in many ways better than the old compiler (also called &#34;stage1&#34;), however it is not yet strictly better.</p>
<p>All 0.10.x releases will have the <code>-fstage1</code> option; the upgrade only will become mandatory starting with 0.11.0.
For some users, sticking with stage1 for the duration of the 0.10.x release will be the best move; for others, upgrading to self-hosted earlier will be right for them. This guide should help you decide which category you fall into.</p>
<p>In between now and 0.10.0, the Zig team will do our best to address real world bugs and get as many third party projects supported by the new compiler as possible. Some projects may not get there; these should continue to use <code>-fstage1</code> until Zig project fixes enough bugs. There will also be a 0.10.1.</p>
<h3>
<a id="user-content-improvements-over-stage1" href="#improvements-over-stage1" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Improvements Over Stage1</h3>
<ul>
<li>Many bugs are fixed, which could never be fixed in stage1 due to fundamental design flaws.</li>
<li>Performance is noticeably improved. For Zig, we observe 1.5x speed in building itself.</li>
<li>Memory usage is improved by a factor of about 3x. For Zig, building itself went from using 9.1 GiB to 2.7 GiB.</li>
<li>The LLVM code generated is better. LLVM has an easier time optimizing. You likely will have small improvements in perf of your project.</li>
<li>Many compile errors are more helpful.</li>
<li>The core design is fundamentally different so that
<a href="https://www.youtube.com/watch?v=AqDdWEiSwMM" rel="nofollow">game-changing performance enhancements become possible</a>
</li>
</ul>
<h3>
<a id="user-content-falling-short-of-stage1" href="#falling-short-of-stage1" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Falling Short of Stage1</h3>
<p>Although we fully intend to make self-hosted a strict improvement, that is not the case yet.</p>
<ul>
<li>There are some fresh bugs.</li>
<li>async/await is not done yet (<a href="https://github.com/ziglang/zig/issues/6025">#6025</a>). Users of async/await cannot upgrade until a few more months when this feature is complete.</li>
<li>Some compile errors are still missing.</li>
<li>Some compile errors are less helpful.</li>
</ul>
<h2>
<a id="user-content-how-to-upgrade" href="#how-to-upgrade" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How to Upgrade</h2>
<p>Assuming that you have decided the time is nigh, here are some tips.</p>
<p>Although most of the language is the same between stage1 and self-hosted, there are some incompatibilities. There are two strategies to deal with this:</p>
<ol>
<li>Have a different branch for when using Zig self-hosted. Once you decide to commit to the upgrade, merge that branch into your main branch.</li>
<li>Make the codebase support both stage1 and self-hosted at the same time using conditional compilation based on <code>@import(&#34;builtin&#34;).zig_backend</code>.</li>
</ol>
<h2>
<a id="user-content-function-pointers" href="#function-pointers" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Function Pointers</h2>
<p>In stage1, the type <code>fn () void</code> is a function pointer and acts like a pointer. However, the language spec, which is not written yet, will have this type be a &#34;function body&#34; type. It must be compile-time known, and in order to get a function pointer, <code>*const fn () void</code> must be used.</p>
<p>Self-hosted implements this correctly, which means your project will likely break everywhere that you use a function pointer.</p>
<p>Here is the problem most people will run into:</p>
<div data-snippet-clipboard-copy-content="test &#34;function pointer&#34; {
    const s = foo();
    s.fnPtr();
}

const S = struct {
    fnPtr: fn () void,
};

fn bar() void {}
fn baz() void {}

var runtime: bool = true;

fn foo() S {
    if (runtime) {
        return .{
            .fnPtr = bar,
        };
    } else {
        return .{
            .fnPtr = baz,
        };
    }
}"><pre><span>test</span> <span>&#34;function pointer&#34;</span> {
    <span>const</span> <span>s</span> <span>=</span> <span>foo</span>();
    <span>s</span>.<span>fnPtr</span>();
}

<span>const</span> <span>S</span> <span>=</span> <span>struct</span> {
    <span>fnPtr</span>: <span>fn</span> () <span>void</span>,
};

<span>fn</span> <span>bar</span>() <span>void</span> {}
<span>fn</span> <span>baz</span>() <span>void</span> {}

<span>var</span> <span>runtime</span>: <span>bool</span> <span>=</span> <span>true</span>;

<span>fn</span> <span>foo</span>() <span>S</span> {
    <span>if</span> (<span>runtime</span>) {
        <span>return</span> .{
            .<span>fnPtr</span> <span>=</span> <span>bar</span>,
        };
    } <span>else</span> {
        <span>return</span> .{
            .<span>fnPtr</span> <span>=</span> <span>baz</span>,
        };
    }
}</pre></div>
<p>With self-hosted, this produces:</p>
<div data-snippet-clipboard-copy-content="test.zig:16:9: error: cannot load runtime value in comptime block
    if (runtime) {
        ^~~~~~~
test.zig:2:18: note: called from here
    const s = foo();
              ~~~^~"><pre><code>test.zig:16:9: error: cannot load runtime value in comptime block
    if (runtime) {
        ^~~~~~~
test.zig:2:18: note: called from here
    const s = foo();
              ~~~^~
</code></pre></div>
<p>This happens because:</p>
<ul>
<li>
<code>fn () void</code> is a <strong>function body</strong> type, not a function pointer type.</li>
<li>Function body types are comptime-only, while function pointers may be runtime-known.</li>
<li>The struct <code>S</code> is a comptime-only type due to its comptime-only field.</li>
<li>The function <code>foo</code> is a comptime-only function due to its comptime-only return type.</li>
<li>Therefore, <code>foo()</code> is called at comptime, however it tries to read a global variable, which is runtime-known.</li>
</ul>
<p>The solution is to make the function into a function pointer:</p>
<div data-snippet-clipboard-copy-content="-    fnPtr: fn () void,
+    fnPtr: *const fn () void,"><pre><span><span>-</span>    fnPtr: fn () void,</span>
<span><span>+</span>    fnPtr: *const fn () void,</span></pre></div>
<p>Ideally, the compile error for this will be enhanced to make the solution more obvious, however, that enhancement will come later.</p>
<h2>
<a id="user-content--vs-" href="#-vs-" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>{}</code> vs <code>.{}</code>
</h2>
<p>This one is pretty simple:</p>
<div data-snippet-clipboard-copy-content="test {
    var x: void = .{};
    _ = x;
}"><pre><span>test</span> {
    <span>var</span> <span>x</span>: <span>void</span> <span>=</span> .{};
    <span>_</span> <span>=</span> <span>x</span>;
}</pre></div>
<div data-snippet-clipboard-copy-content="test.zig:2:20: error: expected type &#39;void&#39;, found &#39;@TypeOf(.{})&#39;
    var x: void = .{};
                  ~^~"><pre><code>test.zig:2:20: error: expected type &#39;void&#39;, found &#39;@TypeOf(.{})&#39;
    var x: void = .{};
                  ~^~
</code></pre></div>
<p><code>.{}</code> is a struct literal; <code>{}</code> is a void value. It has always been a bug that stage1 accepts this code. Just change <code>.{}</code> to <code>{}</code>.</p>
<div data-snippet-clipboard-copy-content="-    var x: void = .{};
+    var x: void = {};"><pre><span><span>-</span>    var x: void = .{};</span>
<span><span>+</span>    var x: void = {};</span></pre></div>
<h2>
<a id="user-content-address-of-temporaries-now-produces-const-pointers" href="#address-of-temporaries-now-produces-const-pointers" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Address-of Temporaries Now Produces Const Pointers</h2>
<p>stage1 allowed this code:</p>
<div data-snippet-clipboard-copy-content="const std = @import(&#34;std&#34;);

test {
    const arena = std.heap.ArenaAllocator.init(std.heap.page_allocator).allocator();

    const ptr = try arena.create(i32);
    ptr.* = 1234;
}"><pre><span>const</span> <span>std</span> <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);

<span>test</span> {
    <span>const</span> <span>arena</span> <span>=</span> <span>std</span>.<span>heap</span>.<span>ArenaAllocator</span>.<span>init</span>(<span>std</span>.<span>heap</span>.<span>page_allocator</span>).<span>allocator</span>();

    <span>const</span> <span>ptr</span> <span>=</span> <span>try</span> <span>arena</span>.<span>create</span>(<span>i32</span>);
    <span>ptr</span><span>.*</span> <span>=</span> <span>1234</span>;
}</pre></div>
<div data-snippet-clipboard-copy-content="test.zig:4:72: error: expected type &#39;*heap.arena_allocator.ArenaAllocator&#39;, found &#39;*const heap.arena_allocator.ArenaAllocator&#39;
    const arena = std.heap.ArenaAllocator.init(std.heap.page_allocator).allocator();
                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~
test.zig:4:72: note: cast discards const qualifier"><pre><code>test.zig:4:72: error: expected type &#39;*heap.arena_allocator.ArenaAllocator&#39;, found &#39;*const heap.arena_allocator.ArenaAllocator&#39;
    const arena = std.heap.ArenaAllocator.init(std.heap.page_allocator).allocator();
                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~
test.zig:4:72: note: cast discards const qualifier
</code></pre></div>
<p>The lang spec will not allow this. Address of temporaries produces constant pointers for safety reasons. To fix this code, extract the temporary into an explicit <code>var</code>. This makes the mutable temporary more obvious, which is safer.</p>
<div data-snippet-clipboard-copy-content="-    const arena = std.heap.ArenaAllocator.init(std.heap.page_allocator).allocator();
+    var arena_state = std.heap.ArenaAllocator.init(std.heap.page_allocator);
+    const arena = arena_state.allocator();"><pre><span><span>-</span>    const arena = std.heap.ArenaAllocator.init(std.heap.page_allocator).allocator();</span>
<span><span>+</span>    var arena_state = std.heap.ArenaAllocator.init(std.heap.page_allocator);</span>
<span><span>+</span>    const arena = arena_state.allocator();</span></pre></div>
<h2>
<a id="user-content-pointers-to-zero-bit-types-are-no-longer-themselves-zero-bit-types" href="#pointers-to-zero-bit-types-are-no-longer-themselves-zero-bit-types" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Pointers to Zero-Bit Types are No Longer Themselves Zero-Bit Types</h2>
<p>This assertion does not pass with stage1 but it does with self-hosted:</p>
<div data-snippet-clipboard-copy-content="const std = @import(&#34;std&#34;);
const assert = std.debug.assert;

comptime {
    assert(@sizeOf(*u0) == @sizeOf(*u8));
}"><pre><span>const</span> <span>std</span> <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);
<span>const</span> <span>assert</span> <span>=</span> <span>std</span>.<span>debug</span>.<span>assert</span>;

<span>comptime</span> {
    <span>assert</span>(<span>@sizeOf</span>(<span>*</span><span>u0</span>) <span>==</span> <span>@sizeOf</span>(<span>*</span><span>u8</span>));
}</pre></div>
<p>However, pointers to comptime-only types are still zero bit types, such as <code>*comptime_int</code>.</p>
<h2>
<a id="user-content-escaped-pointer-to-parameter" href="#escaped-pointer-to-parameter" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Escaped Pointer to Parameter</h2>
<div data-snippet-clipboard-copy-content="const std = @import(&#34;std&#34;);
const expect = std.testing.expect;

test &#34;escaped pointer to parameter&#34; {
    var s: S = .{ .field = 1234 };
    const value = s.foo();
    try expect(value == &amp;s.field);
}

const S = struct {
    field: i32,

    fn foo(s: S) *const i32 {
        return &amp;s.field; // XXX: escaped pointer to parameter
    }
};"><pre><span>const</span> <span>std</span> <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);
<span>const</span> <span>expect</span> <span>=</span> <span>std</span>.<span>testing</span>.<span>expect</span>;

<span>test</span> <span>&#34;escaped pointer to parameter&#34;</span> {
    <span>var</span> <span>s</span>: <span>S</span> <span>=</span> .{ .<span>field</span> <span>=</span> <span>1234</span> };
    <span>const</span> <span>value</span> <span>=</span> <span>s</span>.<span>foo</span>();
    <span>try</span> <span>expect</span>(<span>value</span> <span>==</span> <span>&amp;</span><span>s</span>.<span>field</span>);
}

<span>const</span> <span>S</span> <span>=</span> <span>struct</span> {
    <span>field</span>: <span>i32</span>,

    <span>fn</span> <span>foo</span>(<span>s</span>: <span>S</span>) <span>*</span><span>const</span> <span>i32</span> {
        <span>return</span> <span>&amp;</span><span>s</span>.<span>field</span>; <span>// XXX: escaped pointer to parameter</span>
    }
};</pre></div>
<p>This test passes with stage1 despite having a critical bug: a temporary is created by taking the address of the the <a href="https://ziglang.org/documentation/master/#Pass-by-value-Parameters" rel="nofollow">pass-by-value parameter</a> which is then returned from the function.</p>
<p>Stage1 is naive, always passing structs by pointer in code such as this. Meanwhile, the self-hosted compiler efficiently takes advantage of smaller arguments such as this, passing them truly by value, revealing the bug.</p>
<p>Hopefully in the future Zig will have <a href="https://github.com/ziglang/zig/issues/3180">runtime safety for this</a>, however, currently this will manifest as a use-after-free. So if you find a pointer to bogus data, double check that the pointer was not created this way.</p>
<p>Once the problem has been identified, the fix is simple:</p>
<div data-snippet-clipboard-copy-content="-    fn foo(s: S) *const i32 {
+    fn foo(s: *const S) *const i32 {"><pre><span><span>-</span>    fn foo(s: S) *const i32 {</span>
<span><span>+</span>    fn foo(s: *const S) *const i32 {</span></pre></div>
<h2>
<a id="user-content-runtime-slice-concatenation--multiplication" href="#runtime-slice-concatenation--multiplication" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Runtime Slice Concatenation &amp; Multiplication</h2>
<p>Slice concatenation in stage 2 now works on <a href="https://github.com/ziglang/zig/issues/11773">any two slices with comptime-known length</a>. This <a href="https://github.com/ziglang/zig/issues/11773#issuecomment-1144110692">stops the arguments from being implicitly comptime</a>, which means that function calls within a slice-concatenation expression now need to be explicitly called at comptime.</p>
<p>This can prevent the following example from compiling in stage 2 where it previously did in stage 1:</p>
<div data-snippet-clipboard-copy-content="const std = @import(&#34;std&#34;);

test {
    const a = foo() ++ &#34;bb&#34;;
    try std.testing.expect(a.len == 5);
}

fn foo() []const u8 {
    return &#34;aaa&#34;;
}"><pre><span>const</span> <span>std</span> <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);

<span>test</span> {
    <span>const</span> <span>a</span> <span>=</span> <span>foo</span>() <span>++</span> <span>&#34;bb&#34;</span>;
    <span>try</span> <span>std</span>.<span>testing</span>.<span>expect</span>(<span>a</span>.<span>len</span> <span>==</span> <span>5</span>);
}

<span>fn</span> <span>foo</span>() []<span>const</span> <span>u8</span> {
    <span>return</span> <span>&#34;aaa&#34;</span>;
}</pre></div>
<p>This fix here is simple:</p>
<div data-snippet-clipboard-copy-content="-    const a = foo() ++ &#34;bb&#34;;
+    const a = comptime foo() ++ &#34;bb&#34;;"><pre><span><span>-</span>    const a = foo() ++ &#34;bb&#34;;</span>
<span><span>+</span>    const a = comptime foo() ++ &#34;bb&#34;;</span></pre></div>
<h2>
<a id="user-content-using-builtinzig_backend" href="#using-builtinzig_backend" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using <code>builtin.zig_backend</code>
</h2>
<p>There is a new declaration available in <code>@import(&#34;builtin&#34;).zig_backend</code>. Contents reproduced here:</p>
<div data-snippet-clipboard-copy-content="/// This enum is set by the compiler and communicates which compiler backend is
/// used to produce machine code.
/// Think carefully before deciding to observe this value. Nearly all code should
/// be agnostic to the backend that implements the language. The use case
/// to use this value is to **work around problems with compiler implementations.**
///
/// Avoid failing the compilation if the compiler backend does not match a
/// whitelist of backends; rather one should detect that a known problem would
/// occur in a blacklist of backends.
///
/// The enum is nonexhaustive so that alternate Zig language implementations may
/// choose a number as their tag (please use a random number generator rather
/// than a &#34;cute&#34; number) and codebases can interact with these values even if
/// this upstream enum does not have a name for the number. Of course, upstream
/// is happy to accept pull requests to add Zig implementations to this enum.
///
/// This data structure is part of the Zig language specification.
pub const CompilerBackend = enum(u64) {
    /// It is allowed for a compiler implementation to not reveal its identity,
    /// in which case this value is appropriate. Be cool and make sure your
    /// code supports `other` Zig compilers!
    other = 0,
    /// The original Zig compiler created in 2015 by Andrew Kelley.
    /// Implemented in C++. Uses LLVM.
    stage1 = 1,
    /// The reference implementation self-hosted compiler of Zig, using the
    /// LLVM backend.
    stage2_llvm = 2,
    /// The reference implementation self-hosted compiler of Zig, using the
    /// backend that generates C source code.
    /// Note that one can observe whether the compilation will output C code
    /// directly with `object_format` value rather than the `compiler_backend` value.
    stage2_c = 3,
    /// The reference implementation self-hosted compiler of Zig, using the
    /// WebAssembly backend.
    stage2_wasm = 4,
    /// The reference implementation self-hosted compiler of Zig, using the
    /// arm backend.
    stage2_arm = 5,
    /// The reference implementation self-hosted compiler of Zig, using the
    /// x86_64 backend.
    stage2_x86_64 = 6,
    /// The reference implementation self-hosted compiler of Zig, using the
    /// aarch64 backend.
    stage2_aarch64 = 7,
    /// The reference implementation self-hosted compiler of Zig, using the
    /// x86 backend.
    stage2_x86 = 8,
    /// The reference implementation self-hosted compiler of Zig, using the
    /// riscv64 backend.
    stage2_riscv64 = 9,
    /// The reference implementation self-hosted compiler of Zig, using the
    /// sparc64 backend.
    stage2_sparc64 = 10,

    _,
};"><pre><span>/// This enum is set by the compiler and communicates which compiler backend is</span>
<span>/// used to produce machine code.</span>
<span>/// Think carefully before deciding to observe this value. Nearly all code should</span>
<span>/// be agnostic to the backend that implements the language. The use case</span>
<span>/// to use this value is to **work around problems with compiler implementations.**</span>
<span>///</span>
<span>/// Avoid failing the compilation if the compiler backend does not match a</span>
<span>/// whitelist of backends; rather one should detect that a known problem would</span>
<span>/// occur in a blacklist of backends.</span>
<span>///</span>
<span>/// The enum is nonexhaustive so that alternate Zig language implementations may</span>
<span>/// choose a number as their tag (please use a random number generator rather</span>
<span>/// than a &#34;cute&#34; number) and codebases can interact with these values even if</span>
<span>/// this upstream enum does not have a name for the number. Of course, upstream</span>
<span>/// is happy to accept pull requests to add Zig implementations to this enum.</span>
<span>///</span>
<span>/// This data structure is part of the Zig language specification.</span>
<span>pub</span> <span>const</span> <span>CompilerBackend</span> <span>=</span> <span>enum</span>(<span>u64</span>) {
    <span>/// It is allowed for a compiler implementation to not reveal its identity,</span>
    <span>/// in which case this value is appropriate. Be cool and make sure your</span>
    <span>/// code supports `other` Zig compilers!</span>
    <span>other</span> <span>=</span> <span>0</span>,
    <span>/// The original Zig compiler created in 2015 by Andrew Kelley.</span>
    <span>/// Implemented in C++. Uses LLVM.</span>
    <span>stage1</span> <span>=</span> <span>1</span>,
    <span>/// The reference implementation self-hosted compiler of Zig, using the</span>
    <span>/// LLVM backend.</span>
    <span>stage2_llvm</span> <span>=</span> <span>2</span>,
    <span>/// The reference implementation self-hosted compiler of Zig, using the</span>
    <span>/// backend that generates C source code.</span>
    <span>/// Note that one can observe whether the compilation will output C code</span>
    <span>/// directly with `object_format` value rather than the `compiler_backend` value.</span>
    <span>stage2_c</span> <span>=</span> <span>3</span>,
    <span>/// The reference implementation self-hosted compiler of Zig, using the</span>
    <span>/// WebAssembly backend.</span>
    <span>stage2_wasm</span> <span>=</span> <span>4</span>,
    <span>/// The reference implementation self-hosted compiler of Zig, using the</span>
    <span>/// arm backend.</span>
    <span>stage2_arm</span> <span>=</span> <span>5</span>,
    <span>/// The reference implementation self-hosted compiler of Zig, using the</span>
    <span>/// x86_64 backend.</span>
    <span>stage2_x86_64</span> <span>=</span> <span>6</span>,
    <span>/// The reference implementation self-hosted compiler of Zig, using the</span>
    <span>/// aarch64 backend.</span>
    <span>stage2_aarch64</span> <span>=</span> <span>7</span>,
    <span>/// The reference implementation self-hosted compiler of Zig, using the</span>
    <span>/// x86 backend.</span>
    <span>stage2_x86</span> <span>=</span> <span>8</span>,
    <span>/// The reference implementation self-hosted compiler of Zig, using the</span>
    <span>/// riscv64 backend.</span>
    <span>stage2_riscv64</span> <span>=</span> <span>9</span>,
    <span>/// The reference implementation self-hosted compiler of Zig, using the</span>
    <span>/// sparc64 backend.</span>
    <span>stage2_sparc64</span> <span>=</span> <span>10</span>,

    <span>_</span>,
};</pre></div>
<p>Please read the doc comments carefully before using this value. In summary, you can work around compiler issues by doing something like this:</p>
<div data-snippet-clipboard-copy-content="const FnPtr = switch (builtin.zig_backend) {
    .stage1 =&gt; fn()void,
    else =&gt; *const fn()void,
};"><pre><span>const</span> <span>FnPtr</span> <span>=</span> <span>switch</span> (<span>builtin</span>.<span>zig_backend</span>) {
    <span>.stage1</span> <span>=</span><span>&gt;</span> <span>fn</span>()<span>void</span>,
    <span>else</span> <span>=</span><span>&gt;</span> <span>*</span><span>const</span> <span>fn</span>()<span>void</span>,
};</pre></div>

              </div>

          </div>
</div></div>
  </body>
</html>
