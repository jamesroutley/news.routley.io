<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mort.coffee/home/fast-interpreters/">Original</a>
    <h1>Faster virtual machines: Speeding up programming language execution</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>Date: 2023-01-15 </p>
<p>In this post, I hope to explore how interpreters are often implemented,
what a &#34;virtual machine&#34; means in this context, and how to make them faster.</p>
<blockquote>
<p><strong>Note:</strong> This post will contain a lot of C source code.
Most of it is fairly simple C which should be easy to follow,
but some familiarity with the C language is suggested.</p>
</blockquote>
<h2>What is a (virtual) machine?</h2>
<p>For our purposes, a &#34;machine&#34; is anything which can read some sequence of instructions
(&#34;code&#34;) and act upon them.
A <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a>
reads instructions from the cells of a tape and changes its state accordingly.
Your CPU is a machine which reads instructions in the form of binary data representing x86
or ARM machine code and modifies its state accordingly.
A <a href="https://en.wikipedia.org/wiki/Lisp_machine">LISP machine</a>
reads instructions in the form of LISP code and modifies its state accordingly.</p>
<p>Your computer&#39;s CPU is a physical machine, with all the logic required to read and execute
its native machine code implemented as circuitry in hardware.
But we can also implement a &#34;machine&#34; to read and execute instructions in software.
A software implementation of a machine is what we call a virtual machine.
<a href="https://www.qemu.org/">QEMU</a> is an example of a project which implements common CPU instruction
sets in software, so we can take native machine code for ARM64 and run it in a
virtual ARM64 machine regardless of what architecture our physical CPU implements.</p>
<p>But we don&#39;t have to limit ourselves to virtual machines which emulate real CPU architectures.
In the world of programming languages, a &#34;virtual machine&#34; is usually used to mean something which
takes some language-specific code and executes it.</p>
<h2>What is bytecode?</h2>
<p>Many programming languages are separated into roughly two parts:
the front-end, which parses your textual source code and emits some form of machine-readable code,
and the virtual machine, which executes the instructions in this machine-readable code.
This machine-readable code that&#39;s inteneded to be executed by a virtual machine is usually called
&#34;bytecode&#34;.</p>
<p>You&#39;re probably familiar with this from Java, where the Java compiler produces .class files
containing Java bytecode, and the Java Virtual Machine (JVM) executes these .class files.
(You may be more familiar with .jar files, which are essentially zip files with a bunch of
.class files.)</p>
<p>Python is also an example of a programming language with these two parts.
The only difference between Python&#39;s approach and Java&#39;s approach is that the Python compiler
and the Python virtual machine are part of the same executable, and you&#39;re not meant to distribute
the Python bytecode. But Python also generates bytecode files; the <code>__pycache__</code> directories and
<code>.pyc</code> files Python generates contains Python bytecode. This lets Python avoid compiling your
source code to bytecode every time you run a Python script, speeding up startup times.</p>
<p>So how does this &#34;bytecode&#34; look like? Well, it usually has a concept of an &#34;operation&#34;
(represented by some numeric &#34;op-code&#34;) and &#34;operands&#34; (some fixed numeric argument which somehow
modifies the behavior of the instruction).
But other than that, it varies wildly between languages.</p>
<blockquote>
<p><strong>Note:</strong> Sometimes &#34;bytecode&#34; is used interchangeably with any form of code intended to be
executed by a virtual machine.
Other times, it&#39;s used to mean specifically code where an instruction is always encoded
using exactly one byte for an &#34;op-code&#34;.</p>
</blockquote>
<h2>Our own bytecode</h2>
<p>In this post, we will invent our own bytecode with these characteristics:</p>
<ul>
<li>Each operation is a 1-byte &#34;op-code&#34;, sometimes followed by a 4-byte operand that&#39;s interpreted
as a 32-bit signed integer (little endian).</li>
<li>The machine has a stack, where each value on the stack is a 32-bit signed integer.</li>
<li>In the machine&#39;s model of the stack, <code>stackptr[0]</code> represents the value at the top of the stack,
<code>stackptr[1]</code> the one before that, etc.</li>
</ul>
<p>This is the set of instructions our bytecode language will have:</p>
<pre><code>00000000: CONSTANT c:
Push &#39;c&#39; onto the stack.
&gt; push(c);

00000001: ADD:
Pop two values from the stack, push their
sum onto the stack.
&gt; b = pop();
&gt; a = pop();
&gt; push(a + b);

00000010: PRINT:
Pop a value from the stack and print it.
&gt; print(pop());

00000011: INPUT:
Read a value from some external input,
and push it onto the stack.
&gt; push(input())

00000100: DISCARD:
Pop a value from the stack and discard it.
&gt; pop();

00000101: GET offset:
Find the value at the &#39;offset&#39; from the
top of the stack and push it onto the stack.
&gt; val = stackptr[offset];
&gt; push(val);

0000110: SET offset:
Pop a value from the stack, replace the value
at the &#39;offset&#39; with the popped value.
&gt; val = pop();
&gt; stackptr[offset] = val;

00000110: CMP:
Compare two values on the stack, push -1 if
the first is smaller than the second, 1 if the
first is bigger than the second, and 0 otherwise.
&gt; b = pop();
&gt; a = pop();
&gt; if (a &gt; b) push(1);
&gt; else if (a &lt; b) push(-1);
&gt; else push(0);

00000111: JGT offset:
Pop the stack, jump relative to the given &#39;offset&#39;
if the popped value is positive.
&gt; val = pop();
&gt; if (val &gt; 0) instrptr += offset;

00001000: HALT:
Stop execution
</code></pre>
<blockquote>
<p>I&#39;m sure you can imagine expanding this instruction set with more instructions.
Maybe a <code>SUB</code> instruction, maybe more jump instructions, maybe more I/O.
If you want, you can play along with this post and expand my code
to implement your own custom instructions!</p>
</blockquote>
<p>Throughout this blog post, I will be using an example program which multiplies two numbers together.
Here&#39;s the program in pseudocode:</p>
<pre><code>A = input()
B = input()

Accumulator = 0
do {
	Accumulator = Accumulator + A
	B = B - 1
} while (B &gt; 0)

print(Accumulator)
</code></pre>
<p>(This program assumes B is greater than 0 for simplicity.)</p>
<p>Here&#39;s that program implemented in our bytecode language:</p>

<pre><code>INPUT // A = input()
INPUT // B = input()

CONSTANT 0 // Accumulator = 0

// Loop body:

// Accumulator + A
GET 0
GET 3
ADD
// Accumulator = &lt;result&gt;
SET 0

// B - 1
GET 1
CONSTANT -1
ADD
// B = &lt;result&gt;
SET 1

// B CMP 0
GET 1
CONSTANT 0
CMP
// Jump to start of loop body if &lt;result&gt; &gt; 0
// We get the value -43 by counting the bytes from
// the first instruction in the loop body.
// Operations are 1 byte, operands are 4 bytes.
JGT -43

// Accumulator
GET 0
// print(&lt;result&gt;)
PRINT

HALT
</code></pre>
<blockquote>
<p><strong>Note:</strong> If you&#39;re viewing this in a browser with JavaScript enabled,
the above code should be interactive!
Press the Step or Run buttons to execute it.
The bar on the right represents the stack.
The <span>yellow</span> box indicates the current stack pointer,
a blinking <span>green</span> box means a value is being read,
a blinking <span>red</span> box means a value is being written.
The <span>blue</span> rectangle in the code area shows the instruction pointer.
You can also edit the code; try your hand at writing your own program!</p>
<p><a href="https://mort.coffee/home/fast-interpreters/#interactive-vm">Here&#39;s a link which takes you directly to the interactive virtual machine.</a></p>
</blockquote>
<p>You should take some moments to convince yourself that the bytecode truly reflects the pseudocode.
Maybe you can even imagine how you could write a compiler which takes a syntax tree reflecting
the source code and produces bytecode?
(Hint: Every expression and sub-expression leaves exactly one thing on the stack.)</p>
<h2>Implementing a bytecode interpreter</h2>
<p>A bytecode interpreter can be basically just a loop with a switch statement.
Here&#39;s my shot at implementing one in C for the bytecode language we invented:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

enum op {
	OP_CONSTANT, OP_ADD, OP_PRINT, OP_INPUT, OP_DISCARD,
	OP_GET, OP_SET, OP_CMP, OP_JGT, OP_HALT,
};

void interpret(unsigned char *bytecode, int32_t *input) {
	// Create a &#34;stack&#34; of 128 integers,
	// and a &#34;stack pointer&#34; which always points to the first free stack slot.
	// That means the value at the top of the stack is always &#39;stackptr[-1]&#39;.
	int32_t stack[128];
	int32_t *stackptr = stack;

	// Create an instruction pointer which keeps track of where in the bytecode we are.
	unsigned char *instrptr = bytecode;

	// Some utility macros, to pop a value from the stack, push a value to the stack,
	// peek into the stack at an offset, and interpret the next 4 bytes as a 32-bit
	// signed integer to read an instruction&#39;s operand.
	#define POP() (*(--stackptr))
	#define PUSH(val) (*(stackptr++) = (val))
	#define STACK(offset) (*(stackptr - 1 - offset))
	#define OPERAND() ( \
		((int32_t)instrptr[1] &lt;&lt; 0) | \
		((int32_t)instrptr[2] &lt;&lt; 8) | \
		((int32_t)instrptr[3] &lt;&lt; 16) | \
		((int32_t)instrptr[4] &lt;&lt; 24))

	int32_t a, b;

	// This is where we just run one instruction at a time, using a switch statement
	// to figure out what to do in response to each op-code.
	while (1) {
		enum op op = (enum op)*instrptr;
		switch (op) {
		case OP_CONSTANT:
			PUSH(OPERAND());
			// We move past 5 bytes, 1 for the op-code, 4 for the 32-bit operand
			instrptr += 5; break;
		case OP_ADD:
			b = POP();
			a = POP();
			PUSH(a + b);
			// This instruction doesn&#39;t have an operand, so we move only 1 byte
			instrptr += 1; break;
		case OP_PRINT:
			a = POP();
			printf(&#34;%i\n&#34;, (int)a);
			instrptr += 1; break;
		case OP_INPUT:
			PUSH(*(input++));
			instrptr += 1; break;
		case OP_DISCARD:
			POP();
			instrptr += 1; break;
		case OP_GET:
			a = STACK(OPERAND());
			PUSH(a);
			instrptr += 5; break;
		case OP_SET:
			a = POP();
			STACK(OPERAND()) = a;
			instrptr += 5; break;
		case OP_CMP:
			b = POP();
			a = POP();
			if (a &gt; b) PUSH(1);
			else if (a &lt; b) PUSH(-1);
			else PUSH(0);
			instrptr += 1; break;
		case OP_JGT:
			a = POP();
			if (a &gt; 0) instrptr += OPERAND();
			else instrptr += 5;
			break;
		case OP_HALT:
			return;
		}
	}
}
</code></pre>
<p>That&#39;s it. That&#39;s a complete virtual machine for our little bytecode language.
Let&#39;s give it a spin! Here&#39;s a main function which exercises it:</p>
<pre><code>int main(int argc, char **argv) {
	unsigned char program[] = {
		OP_INPUT, OP_INPUT,
		OP_CONSTANT, 0, 0, 0, 0,

		OP_GET, 0, 0, 0, 0,
		OP_GET, 3, 0, 0, 0,
		OP_ADD,
		OP_SET, 0, 0, 0, 0,

		OP_GET, 1, 0, 0, 0,
		OP_CONSTANT, 0xff, 0xff, 0xff, 0xff, // -1 32-bit little-endian (two&#39;s complement)
		OP_ADD,
		OP_SET, 1, 0, 0, 0,

		OP_GET, 1, 0, 0, 0,
		OP_CONSTANT, 0, 0, 0, 0,
		OP_CMP,
		OP_JGT, 0xd5, 0xff, 0xff, 0xff, // -43 in 32-bit little-endian (two&#39;s complement)

		OP_GET, 0, 0, 0, 0,
		OP_PRINT,

		OP_HALT,
	};
	int32_t input[] = {atoi(argv[1]), atoi(argv[2])};
	interpret(program, input);
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> We use <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a>
to represent negative numbers, because that&#39;s what the CPU does.
A 32-bit number can represent the numbers between 0 and 4&#39;294&#39;967&#39;295.
Two&#39;s complement is a convention where the numbers between 0 and 2&#39;147&#39;483&#39;647
are treated normally, and the numbers between 2&#39;147&#39;483&#39;648 and 4&#39;294&#39;967&#39;295
represent the numbers between -2&#39;147&#39;483&#39;648 and -1.</p>
<p>Little-endian just means that order of the bytes are &#34;swapped&#34; compared to what you&#39;d expect.
For example, to express the number 35799 (<code>10001011&#39;11010111</code> in binary) as 2 bytes in
little-endian, we put the last 8 bits first and the first 8 bits last:
<code>unsigned char bytes[] = {0b11010111, 0b10001011}</code>.
It&#39;s a bit counter-intuitive, but it&#39;s how most CPU architectures these days represent numbers
larger than one byte.</p>
</blockquote>
<p>When I compile and run the full C program with the inputs <code>3</code> and <code>5</code>, it prints 15. Success!</p>
<p>If I instead ask it to calculate 1 * 100&#39;000&#39;000,
my laptop (Apple M1 Pro, Apple Clang 14.0.0 with -O3) runs the program in 1.4 seconds.
My desktop (AMD R9 5950x, GCC 12.2.0 with -O3) runs the same program in 1.1 seconds.
The loop contains 12 instructions, and there are 6 instructions outside of the loop,
so a complete run executes 100&#39;000&#39;000*12+6=1&#39;200&#39;000&#39;006 instructions.
That means my laptop runs 856 million bytecode instructions per second (&#34;IPS&#34;) on average,
and my desktop runs 1.1 billion instructions per second.</p>

<blockquote>
<p><strong>Note:</strong> The actual benchmarked code defines the <code>program</code> variable in a separate
translation unit from the <code>main</code> function and <code>interpret</code> function,
and link-time optimization is disabled.
This prevents the compiler from optimizing based on the knowledge of the bytecode program.</p>
</blockquote>
<p>Not bad, but can we do better?</p>
<h2>Managing our own jump table</h2>
<p>Looking at <a href="https://godbolt.org/z/6v7MYoc6s">Godbolt</a>, the assembly generated for our
loop + switch is roughly like this:</p>
<pre><code>loop:
	jmp jmp_table[*instrptr]

jmp_table:
	.quad case_op_constant
	.quad case_op_add
	.quad case_op_print
	.quad case_op_discard
	.quad case_op_get
	.quad case_op_set
	.quad case_op_cmp
	.quad case_op_jgt
	.quad case_op_halt

case_op_constant:
	; (code...)
	add instrptr, 5
	jmp loop

case_op_add:
	; (code...)
	add instrptr, 1
	jmp loop

; etc
</code></pre>
<blockquote>
<p><strong>Note:</strong> This isn&#39;t real x86 or ARM assembly, but it gives an idea of what&#39;s going on
without getting into the weeds of assembly syntax.</p>
</blockquote>
<p>We can see that the compiler generated a jump table; a table of memory addresses to jump to.
At the beginning of each iteration of the loop, it looks up the target address in the jump table
based on the opcode at the instruction pointer, then jumps to it.
And at the end of executing each switch case, it jumps back to the beginning of the loop.
This is fine, but it&#39;s a bit unnecessary to jump to the start of the loop just to immediately
jump again based on the next op-code. We could just replace the <code>jmp loop</code> with
<code>jmp jmp_table[*instrptr]</code> like this:</p>
<pre><code>	jmp jmp_table[*instrptr]

jmp_table:
	.quad case_op_constant
	.quad case_op_add
	.quad case_op_print
	.quad case_op_discard
	.quad case_op_get
	.quad case_op_set
	.quad case_op_cmp
	.quad case_op_jgt
	.quad case_op_halt

case_op_constant:
	; code
	add instrptr, 5
	jmp jmp_table[*instrptr]

case_op_add:
	; code
	add instrptr, 1
	jmp jmp_table[*instrptr]

; etc
</code></pre>
<p>This has the advantage of using one less instruction per iteration, but that&#39;s negligible;
completely predictable jumps such as our <code>jmp loop</code> are essentially free.
However, there&#39;s a much bigger advantage: the CPU can exploit the inherent predictability of
our bytecode instruction stream to improve its branch prediction.
For example, a <code>CMP</code> instruction is usually going to be followed
by the <code>JGE</code> instruction, so the CPU can start
<a href="https://en.wikipedia.org/wiki/Speculative_execution">speculatively executing</a> the <code>JGE</code> instruction
before it&#39;s even done executing the <code>CMP</code> instruction.
(At least that&#39;s what I believe is happeneing; figuring out why something is as fast or slow
as it is, at an instruction-by-instruction level, is incredibly difficult on modern CPUs.)</p>
<p>Sadly, standard C doesn&#39;t let us express this style of jump table.
But GNU C does! With
<a href="https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html">GNU&#39;s Labels as Values extension</a>,
we can create our own jump table and indirect goto:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

enum op {
	OP_CONSTANT, OP_ADD, OP_PRINT, OP_INPUT, OP_DISCARD,
	OP_GET, OP_SET, OP_CMP, OP_JGT, OP_HALT,
};

void interpret(unsigned char *bytecode, int32_t *input) {
	int32_t stack[128];
	int32_t *stackptr = stack;
	unsigned char *instrptr = bytecode;

	#define POP() (*(--stackptr))
	#define PUSH(val) (*(stackptr++) = (val))
	#define STACK(offset) (*(stackptr - 1 - offset))
	#define OPERAND() ( \
		((int32_t)instrptr[1] &lt;&lt; 0) | \
		((int32_t)instrptr[2] &lt;&lt; 8) | \
		((int32_t)instrptr[3] &lt;&lt; 16) | \
		((int32_t)instrptr[4] &lt;&lt; 24))

	// Note: This jump table must be synchronized with the &#39;enum op&#39;,
	// so that `jmptable[op]` represents the label with the code for the instruction &#39;op&#39;
	void *jmptable[] = {
		&amp;&amp;case_constant, &amp;&amp;case_add, &amp;&amp;case_print, &amp;&amp;case_input, &amp;&amp;case_discard,
		&amp;&amp;case_get, &amp;&amp;case_set, &amp;&amp;case_cmp, &amp;&amp;case_jgt, &amp;&amp;case_halt,
	};

	int32_t a, b;
	goto *jmptable[*instrptr];

case_constant:
	PUSH(OPERAND());
	instrptr += 5; goto *jmptable[*instrptr];
case_add:
	b = POP();
	a = POP();
	PUSH(a + b);
	instrptr += 1; goto *jmptable[*instrptr];
case_print:
	a = POP();
	printf(&#34;%i\n&#34;, (int)a);
	instrptr += 1; goto *jmptable[*instrptr];
case_input:
	PUSH(*(input++));
	instrptr += 1; goto *jmptable[*instrptr];
case_discard:
	POP();
	instrptr += 1; goto *jmptable[*instrptr];
case_get:
	a = STACK(OPERAND());
	PUSH(a);
	instrptr += 5; goto *jmptable[*instrptr];
case_set:
	a = POP();
	STACK(OPERAND()) = a;
	instrptr += 5; goto *jmptable[*instrptr];
case_cmp:
	b = POP();
	a = POP();
	if (a &gt; b) PUSH(1);
	else if (a &lt; b) PUSH(-1);
	else PUSH(0);
	instrptr += 1; goto *jmptable[*instrptr];
case_jgt:
	a = POP();
	if (a &gt; 0) instrptr += OPERAND();
	else instrptr += 5;
	goto *jmptable[*instrptr];
case_halt:
	return;
}
</code></pre>
<p>With this interpreter loop, my laptop calculates 1 * 100&#39;000&#39;000 in 898ms,
while my desktop does it in 1 second.
It&#39;s interesting that Clang + M1 is significantly slower than GCC + AMD with the basic interpreter
but significantly faster for this custom jump table approach.
At least it&#39;s a speed-up in both cases.</p>

<h2>Getting rid of the switch entirely with tail calls</h2>
<p>Both of the implementations so far have essentially been of the form, &#34;Look at the current instruction,
and decide what code to run with some kind of jump table&#34;. But we don&#39;t actually need that.
Instead of doing the jump table look-up every time, we could do the look-up once for every instruction
before starting execution.
Instead of an array of op codes, we could have an array of pointers to some machine code.</p>
<p>The easiest and most standard way to do this would be to have each instruction as its own function,
and let that function tail-call the next function. Here&#39;s an implementation of that:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

union instr {
	void (*fn)(union instr *instrs, int32_t *stackptr, int32_t *input);
	int32_t operand;
};

#define POP() (*(--stackptr))
#define PUSH(val) (*(stackptr++) = (val))
#define STACK(offset) (*(stackptr - 1 - offset))
#define OPERAND() (instrs[1].operand)

static void op_constant(union instr *instrs, int32_t *stackptr, int32_t *input) {
	PUSH(OPERAND());
	instrs[2].fn(&amp;instrs[2], stackptr, input);
}

static void op_add(union instr *instrs, int32_t *stackptr, int32_t *input) {
	int32_t b = POP();
	int32_t a = POP();
	PUSH(a + b);
	instrs[1].fn(&amp;instrs[1], stackptr, input);
}

static void op_print(union instr *instrs, int32_t *stackptr, int32_t *input) {
	int32_t a = POP();
	printf(&#34;%i\n&#34;, (int)a);
	instrs[1].fn(&amp;instrs[1], stackptr, input);
}

static void op_input(union instr *instrs, int32_t *stackptr, int32_t *input) {
	PUSH(*(input++));
	instrs[1].fn(&amp;instrs[1], stackptr, input);
}

static void op_discard(union instr *instrs, int32_t *stackptr, int32_t *input) {
	POP();
	instrs[1].fn(&amp;instrs[1], stackptr, input);
}

static void op_get(union instr *instrs, int32_t *stackptr, int32_t *input) {
	int32_t a = STACK(OPERAND());
	PUSH(a);
	instrs[2].fn(&amp;instrs[2], stackptr, input);
}

static void op_set(union instr *instrs, int32_t *stackptr, int32_t *input) {
	int32_t a = POP();
	STACK(OPERAND()) = a;
	instrs[2].fn(&amp;instrs[2], stackptr, input);
}

static void op_cmp(union instr *instrs, int32_t *stackptr, int32_t *input) {
	int32_t b = POP();
	int32_t a = POP();
	if (a &gt; b) PUSH(1);
	else if (a &lt; b) PUSH(-1);
	else PUSH(0);
	instrs[1].fn(&amp;instrs[1], stackptr, input);
}

static void op_jgt(union instr *instrs, int32_t *stackptr, int32_t *input) {
	int32_t a = POP();
	if (a &gt; 0) instrs += instrs[1].operand;
	else instrs += 2;
	instrs[0].fn(&amp;instrs[0], stackptr, input);
}

static void op_halt(union instr *instrs, int32_t *stackptr, int32_t *input) {
	return;
}
</code></pre>
<p>This time, we can&#39;t just feed our interpreter an array of bytes as the bytecode,
since there isn&#39;t really &#34;an interpreter&#34;, there&#39;s just a collection of functions.
We can manually create a program containing function pointers like this:</p>
<pre><code>int main(int argc, char **argv) {
	union instr program[] = {
		{.fn = op_input}, {.fn = op_input},

		{.fn = op_constant}, {.operand = 0},

		{.fn = op_get}, {.operand = 0},
		{.fn = op_get}, {.operand = 3},
		{.fn = op_add},
		{.fn = op_set}, {.operand = 0},

		{.fn = op_get}, {.operand = 1},
		{.fn = op_constant}, {.operand = -1},
		{.fn = op_add},
		{.fn = op_set}, {.operand = 1},

		{.fn = op_get}, {.operand = 1},
		{.fn = op_constant}, {.operand = 0},
		{.fn = op_cmp},
		{.fn = op_jgt}, {.operand = -19},

		{.fn = op_get}, {.operand = 0},
		{.fn = op_print},

		{.fn = op_halt},
	};

	int32_t input[] = {atoi(argv[1]), atoi(argv[2])};
	int32_t stack[128];
	program[0].fn(program, stack, input);
}
</code></pre>
<p>And that works.</p>
<p>In a real use-case, you would probably want to have some code to automatically generate
such an array of <code>union instr</code> based on bytecode, but we&#39;ll ignore that for now.</p>
<p>With this approach, my laptop calculates 1 * 100&#39;000&#39;000 in 841ms,
while my desktop does it in only 553ms.
It&#39;s not a huge improvement for the Clang + M1 case, but it&#39;s almost twice as fast with GCC + AMD!
And compared to the previous approach, it&#39;s written in completely standard ISO C99,
with the caveat that the compiler must perform <a href="https://wiki.c2.com/?TailCallOptimization">tail call elimination</a>.
(Most compilers will do this at higher optimization levels, and most compilers
let us specify per-function optimization levels with pragmas, so that&#39;s not a big issue in practice.)</p>

<blockquote>
<p><strong>Note:</strong> The timings from the benchmark includes the time it takes to convert the bytecode
into this function pointer array form.</p>
</blockquote>
<h2>Final step: A compiler</h2>
<p>All approaches so far have relied on finding ever faster ways to select which source code snippet
to run next.
As it turns out, the fastest way to do that is to simply put the right source code snippets
after each other!</p>
<p>If we have the following bytecode:</p>
<pre><code>CONSTANT 5
INPUT
ADD
PRINT
</code></pre>
<p>We can just generate C source code to do what we want:</p>
<pre><code>PUSH(5);

PUSH(INPUT());

b = POP();
a = POP();
PUSH(a + b);

printf(&#34;%i\n&#34;, (int)POP());
</code></pre>
<p>We can then either shell out to GCC/Clang, or link with libclang to compile the generated C code.
This also lets us take advantage of those projects&#39;s excellent optimizers.</p>
<blockquote>
<p><strong>Note:</strong> At this point, we don&#39;t have a &#34;virtual machine&#34; anymore.</p>
</blockquote>
<p>One challenge is how to deal with jumps.
The easiest solution from a code generation perspective is probably to wrap all the code
in a switch statement in a loop:</p>
<pre><code>int32_t index = 0;
while (1) {
	switch (index) {
	case 0:
		PUSH(5);

	case 5:
		PUSH(INPUT());

	case 6:
		a = POP();
		b = POP();
		PUSH(a + b);

	case 7:
		printf(&#34;%i\n&#34;, (int)POP());
	}
}
</code></pre>
<p>With this approach, a jump to instruction N becomes <code>index = N; break;</code>.</p>
<blockquote>
<p><strong>Note:</strong> Remember that in C, switch statement cases fall through to the next case
unless you explicitly jump to the end with a <code>break</code>.
So once the code for instruction 5 is done, we just fall through to instruction 6.</p>
</blockquote>
<p>Here&#39;s my implementation:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

enum op {
	OP_CONSTANT, OP_ADD, OP_PRINT, OP_INPUT, OP_DISCARD,
	OP_GET, OP_SET, OP_CMP, OP_JGT, OP_HALT,
};

void write_operand(unsigned char *i32le, FILE *out) {
	fprintf(out, &#34;    operand = %i;\n&#34;,
		(int)i32le[0] | (int)i32le[1] &lt;&lt; 8 | (int)i32le[2] &lt;&lt; 16 | (int)i32le[3] &lt;&lt; 24);
}

void compile(unsigned char *bytecode, size_t size, FILE *out) {
	fputs(
		&#34;#include &lt;stdio.h&gt;\n&#34;
		&#34;#include &lt;stdint.h&gt;\n&#34;
		&#34;#include &lt;stdlib.h&gt;\n&#34;
		&#34;\n&#34;
		&#34;int main(int argc, char **argv) {\n&#34;
		&#34;  int32_t stack[128];\n&#34;
		&#34;  int32_t *stackptr = stack;\n&#34;
		&#34;  char **inputptr = &amp;argv[1];\n&#34;
		&#34;\n&#34;
		&#34;#define POP() (*(--stackptr))\n&#34;
		&#34;#define PUSH(val) (*(stackptr++) = (val))\n&#34;
		&#34;#define STACK(offset) (*(stackptr - 1 - offset))\n&#34;
		&#34;\n&#34;
		&#34;  int32_t a, b, operand;\n&#34;
		&#34;  int32_t index = 0;\n&#34;
		&#34;  while (1) switch (index) {\n&#34;,
		out);

	for (size_t i = 0; i &lt; size;) {
		fprintf(out, &#34;  case %zi:\n&#34;, i);

		enum op op = (enum op)bytecode[i];
		switch (op) {
		case OP_CONSTANT:
			write_operand(&amp;bytecode[i + 1], out);
			fputs(&#34;    PUSH(operand);\n&#34;, out);
			i += 5; break;

		case OP_ADD:
			fputs(
				&#34;    b = POP();\n&#34;
				&#34;    a = POP();\n&#34;
				&#34;    PUSH(a + b);\n&#34;,
				out);
			i += 1; break;

		case OP_PRINT:
			fputs(
				&#34;    a = POP();\n&#34;
				&#34;    printf(\&#34;%i\\n\&#34;, (int)a);\n&#34;,
				out);
			i += 1; break;

		case OP_INPUT:
			fputs(&#34;    PUSH(atoi(*(inputptr++)));\n&#34;, out);
			i += 1; break;

		case OP_DISCARD:
			fputs(&#34;    POP();\n&#34;, out);
			i += 1; break;

		case OP_GET:
			write_operand(&amp;bytecode[i + 1], out);
			fputs(
				&#34;    a = STACK(operand);\n&#34;
				&#34;    PUSH(a);\n&#34;,
				out);
			i += 5; break;

		case OP_SET:
			write_operand(&amp;bytecode[i + 1], out);
			fputs(
				&#34;    a = POP();\n&#34;
				&#34;    STACK(operand) = a;\n&#34;,
				out);
			i += 5; break;

		case OP_CMP:
			fputs(
				&#34;    b = POP();\n&#34;
				&#34;    a = POP();\n&#34;
				&#34;    if (a &gt; b) PUSH(1);\n&#34;
				&#34;    else if (a &lt; b) PUSH(-1);\n&#34;
				&#34;    else PUSH(0);\n&#34;,
				out);
			i += 1; break;

		case OP_JGT:
			write_operand(&amp;bytecode[i + 1], out);
			fprintf(out,
				&#34;    a = POP();\n&#34;
				&#34;    if (a &gt; 0) { index = %zi + operand; break; }\n&#34;,
				i);
			i += 5; break;

		case OP_HALT:
			fputs(&#34;    return 0;\n&#34;, out);
			i += 1; break;
		}
	}

	fputs(
		&#34;  }\n&#34;
		&#34;\n&#34;
		&#34;  abort(); // If we get here, there&#39;s a missing HALT\n&#34;
		&#34;}&#34;,
		out);
}
</code></pre>
<p>If we run our compiler on the bytecode for our multiplication program, it outputs this C code:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv) {
  int32_t stack[128];
  int32_t *stackptr = stack;
  char **inputptr = &amp;argv[1];

  #define POP() (*(--stackptr))
  #define PUSH(val) (*(stackptr++) = (val))
  #define STACK(offset) (*(stackptr - 1 - offset))

  int32_t a, b, operand;
  int32_t index = 0;
  while (1) switch (index) {
  case 0:
    PUSH(atoi(*(inputptr++)));
  case 1:
    PUSH(atoi(*(inputptr++)));
  case 2:
    operand = 0;
    PUSH(operand);
  case 7:
    operand = 0;
    a = STACK(operand);
    PUSH(a);

  /* ... */

  case 49:
    b = POP();
    a = POP();
    if (a &gt; b) PUSH(1);
    else if (a &lt; b) PUSH(-1);
    else PUSH(0);
  case 50:
    operand = -43;
    a = POP();
    if (a &gt; 0) { index = 50 + operand; break; }
  case 55:
    operand = 0;
    a = STACK(operand);
    PUSH(a);
  case 60:
    a = POP();
    printf(&#34;%i\n&#34;, (int)a);
  case 61:
    return 0;
  }

  abort(); // If we get here, there&#39;s a missing HALT
}
</code></pre>
<p>If we compile the generated C code with -O3, my laptop runs the 1 * 100&#39;000&#39;000 calculation in 204ms!
That&#39;s over 4 times faster than the fastest interpreter we&#39;ve had so far.
That also means we&#39;re executing our 1&#39;200&#39;000&#39;006 bytecode instructions at 5&#39;882 million
instructions per second! Its CPU only runs at 3&#39;220 million CPU clock cycles per second, meaning
it&#39;s spending significantly less than a clock cycle per bytecode instruction on average.
My desktop with GCC is doing even better, executing all the code in 47ms, which means a whopping
25.7 billion instructions per second!</p>
<p>Note that in this particular case, the compiler is able to see that some instructions <em>always</em>
happen after each other, which means it can optimize across bytecode instructions.
For example, the bytecode contains a sequence <code>GET 1; CONSTANT -1; ADD;</code>, which the compiler
is able to prove you won&#39;t ever jump into the middle of, so it optimizes out all the implied
stack manipulation code; it&#39;s optimized into a <em>single</em> sub instruction which subtracts the
constant <code>1</code> from one register and writes the result to another.</p>
<p>This is kind of an important point. The compiler can generate amazing code, <em>if</em> it can figure out
which instructions (i.e switch cases) are potential jump targets.
This is information you <em>probably</em> have access to in the source code,
so it&#39;s worth thinking about how you can design your bytecode such that GCC or Clang can figure it out
when looking at your compiler output.
One approach could be to add &#34;label&#34; bytecode instructions, and only permit jumping to such a label.
With our bytecode, the only jump instruction we have jumps to a known location, since the jump
offset is an immediate operand to the instruction.
If we added an instruction which reads the jump target from the stack instead,
we might quickly get into situations where GCC/Clang has lost track of which instructions
can be jump targets, and must therefore make sure not to optimize across instruction boundaries.</p>
<p>We can preventing the compiler from optimizing across instruction boundaries
by inserting this code after the <code>case 61:</code> (the code for the <code>HALT</code> instruction):</p>
<pre><code>if (argc &gt; 100) { PUSH(argc); index = argc % 61; break; }
</code></pre>
<p>With this modification, every single instruction might be a branch target,
so every instruction must make sense in its own right regardless of which instruction
was executed before or how the stack looks.</p>
<p>This time, the 1 * 100&#39;000&#39;000 calculation happens in 550ms on my laptop with Clang,
which is still not bad. It means we&#39;re executing 2&#39;181 million bytecode instructions per second.
My desktop is doing even better, at 168ms.</p>
<p>At this point, I got curious about whether it&#39;s the CPU or the compiler making the difference,
so the next table contains all the benchmarks for both compilers on both systems.</p>

<p>I have no intelligent commentary on those numbers. They&#39;re all over the place.
In the basic interpreter case for example, GCC is much faster than Clang on the AMD CPU,
but Clang is much faster than GCC on the Apple CPU.
It&#39;s the opposite in the custom jump table case, where GCC is much master than Clang on the Apple CPU,
but Clang is much faster than GCC on the AMD CPU.
The overall pattern we&#39;ve been looking at holds though, for the most part:
for any given CPU + compiler combination, every implementation I&#39;ve introduced is faster than
the one before it.
The big exception is the tail call version, where the binary compiled by GCC performs horribly on
the Apple CPU (even though it performs excellently on the AMD CPU!).</p>
<p>If anything though, this mess of numbers indicates the value of knowing about all the different
possible approaches and choosing the right one for the situation.
Which takes us to...</p>
<h2>Bringing it all together</h2>
<p>We have 4 different implementations of the same bytecode , all with different advantages
and drawbacks.
And even though every instruction does the same thing in every implementation,
we have written 4 separate implementations of every instruction.</p>
<p>That seems unnecessary. After all, we know that <code>ADD</code>, in every implementation,
will do some variant of this:</p>
<pre><code>b = POP();
a = POP();
PUSH(a + b);
GO_TO_NEXT_INSTRUCTION();
</code></pre>
<p>What <em>exactly</em> it means to POP or to PUSH or to go to the next instruction
might depend on the implementation,
but the core functionality is the same for all of them.
We can utilize that regularity to specify the instructions only once
in a way that&#39;s re-usable across implementations using so-called
<a href="https://en.wikipedia.org/wiki/X_Macro">X macros</a>.</p>
<p>We create a file <code>instructions.x</code> which contains code to define all our instructions:</p>
<pre><code>X(CONSTANT, 1, {
	PUSH(OPERAND());
	NEXT();
})

X(ADD, 0, {
	b = POP();
	a = POP();
	PUSH(a + b);
	NEXT();
})

// etc...
</code></pre>
<p>Let&#39;s say we want to create an <code>instructions.h</code> which contains an <code>enum op</code> with all the operation
types and a <code>const char *op_names[]</code> which maps enum values to strings.
We can implement that by doing something like this:</p>
<pre><code>#ifndef INSTRUCTIONS_H
#define INSTRUCTIONS_H

enum op {
#define X(name, has_operand, code...) OP_ ## name,
#include &#34;instructions.x&#34;
#undef X
};

static const char *op_names[] = {
#define X(name, has_operand, code...) [OP_ ## name] = &#34;OP_&#34; #name,
#include &#34;instructions.x&#34;
#undef X
};

#endif
</code></pre>
<p>This code might look a bit confusing at first glance, but it makes sense:
we have generic descriptions of instructions in the <code>instructions.x</code> file,
and then we define a macro called <code>X</code> to extract information from those descriptions.
It&#39;s basically a weird preprocessor-based application of the
<a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a>.
In the above example, we use the instruction definitions twice: once to define the <code>enum op</code>,
and once to define the <code>const char *op_names[]</code>.
If we run the code through the preprocessor, we get something rouhly like this:</p>
<pre><code>enum op {
OP_CONSTANT,
OP_ADD,
};

const char *op_names[] = {
[OP_CONSTANT] = &#34;OP_CONSTANT&#34;,
[OP_ADD] = &#34;OP_ADD&#34;,
};
</code></pre>
<p>Now let&#39;s say we want to write a function which executes an instruction.
We could write that function like this:</p>
<pre><code>void execute(enum op op) {
	switch (op) {
#define X(name, has_operand, code...) case OP_ ## name: code break;
#include &#34;instructions.x&#34;
#undef X
	}
}
</code></pre>
<p>Which expands to:</p>
<pre><code>void execute(enum op op) {
	switch (op)
	case OP_CONSTANT:
		{
			PUSH(OPERAND());
			NEXT();
		} break;
	case OP_ADD:
		{
			b = POP();
			a = POP();
			PUSH(a + b);
			NEXT();
		} break;
	}
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> We use a variadic argument for the code block because the C preprocessor has
annoying splitting rules. Code such as <code>X(FOO, 1, {int32_t a, b;})</code> would call the macro
<code>X</code> with 4 arguments: <code>FOO</code>, <code>1</code>, <code>{int32_t a</code>, and <code>b;}</code>.
Using a variadic argument &#34;fixes&#34; this, because when we expand <code>code</code> in the macro body,
the preprocessor will insert a comma between the arguments.
You can read about more stupid preprocessor hacks here:
<a href="https://mort.coffee/home/obscure-c-features/">https://mort.coffee/home/obscure-c-features/</a></p>
</blockquote>
<p>This is starting to look reasonable, but it doesn&#39;t quite work.
We haven&#39;t defined those <code>PUSH</code>/<code>OPERAND</code>/<code>NEXT</code>/<code>POP</code> macros, nor the <code>a</code> and <code>b</code> variables.
We need to be a bit more rigorous about what exactly is expected by the instruction,
and what&#39;s expected by the environment which the instruction&#39;s code is expanded into.
So let&#39;s design a sort of &#34;contract&#34; between the instruction and the execution environment.</p>
<p>The environment must:</p>
<ul>
<li>Provide a <code>POP()</code> macro which pops the stack and evaluates to the result.</li>
<li>Provide a <code>PUSH(val)</code> macro which push the value to the stack.</li>
<li>Provide a <code>STACK(offset)</code> macro which evaluates to an
<a href="https://en.cppreference.com/w/c/language/value_category#Lvalue_expressions">lvalue</a>
for the stack value at <code>offset</code>.</li>
<li>Provide an <code>OPERAND()</code> macro which evaluates to the current instruction&#39;s operand as a int32_t.</li>
<li>Provide an <code>INPUT()</code> macro which reads external input and evaluates to the result.</li>
<li>Provide a <code>PRINT(val)</code> macro which outputs the value somehow (such as by printing to stdout).</li>
<li>Provide a <code>GOTO_RELATIVE(offset)</code> macro which jumps to <code>currentInstruction + offset</code></li>
<li>Provide a <code>NEXT()</code> macro which goes to the next instruction</li>
<li>Provide a <code>HALT()</code> macro which halts execution.</li>
<li>Provide the variables <code>int32_t a</code> and <code>int32_t b</code> as general-purpose variables.
(This turns out to significantly speed up execution in some cases compared to
defining the variables locally within the scope.)</li>
</ul>
<p>As for the instruction:</p>
<ul>
<li>It must call <code>X(name, has_operand, code...)</code> with an identifier for <code>name</code>, a <code>0</code> or <code>1</code> for
<code>has_operand</code>, and a brace-enclosed code block for <code>code...</code>.</li>
<li>The code block may only invoke <code>OPERAND()</code> if it has set <code>has_operand</code> to <code>1</code>.</li>
<li>The code block must only contain standard C code and calls to the macros we defined earlier.</li>
<li>The code block must not try to directly access any other variables which may exist
in the context in which it is expanded.</li>
<li>The code block can assume that the following C headers are included: <code>&lt;stdio.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>,
<code>&lt;stdint.h&gt;</code>.</li>
<li>The code must not change the stack pointer and dereference it in the same expression
(essentially, no <code>PUSH(STACK(1))</code>, since there&#39;s no
<a href="https://en.wikipedia.org/wiki/Sequence_point">sequence point</a> between the dereference and
the increment).</li>
</ul>
<p>With this, we can re-implement our basic bytecode interpreter:</p>
<pre><code>#include &#34;instructions.h&#34;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

void interpret(unsigned char *bytecode, int32_t *input) {
	int32_t stack[128];
	int32_t *stackptr = stack;
	unsigned char *instrptr = bytecode;

	int instrsize; // Will be initialized later

	#define POP() (*(--stackptr))
	#define PUSH(val) (*(stackptr++) = (val))
	#define STACK(offset) (*(stackptr - 1 - offset))
	#define OPERAND() ( \
		((int32_t)instrptr[1] &lt;&lt; 0) | \
		((int32_t)instrptr[2] &lt;&lt; 8) | \
		((int32_t)instrptr[3] &lt;&lt; 16) | \
		((int32_t)instrptr[4] &lt;&lt; 24))
	#define INPUT() (*(input++))
	#define PRINT(val) (printf(&#34;%i\n&#34;, (int)(val)))
	#define GOTO_RELATIVE(offset) (instrptr += (offset))
	#define NEXT() (instrptr += instrsize)
	#define HALT() return

	int32_t a, b;
	while (1) {
		switch ((enum op)*instrptr) {
#define X(name, has_operand, code...) \
		case OP_ ## name: \
			instrsize = has_operand ? 5 : 1; \
			code \
			break;
#include &#34;instructions.x&#34;
#undef X
		}
	}
}
</code></pre>
<p>And that&#39;s it! That&#39;s our whole generic basic bytecode interpreter, defined using the
instruction definitions in <code>instructions.x</code>.
And any time we add more bytecode instructions to <code>instructions.x</code>,
the instructions are automatically added to the <code>enum op</code> and <code>const char *op_names[]</code> in
<code>instructions.h</code>, and they&#39;re automatically supported by this new basic interpreter.</p>
<p>I won&#39;t deny that this style of code is a bit harder to follow than straight C code.
However, I&#39;ve seen VM with their own custom domain-specific languages and code generators
to define instructions, and I find that much harder to follow than this preprocessor-based approach.
Even though the C preprocessor is flawed in many ways, it has the huge advantage that C programmers
already understand how it works for the most part, and they&#39;re used to following code which
uses macros and includes.
With decent comments in strategic places, I don&#39;t think this sort of &#34;abuse&#34; of the C preprocessor
is wholly unreasonable.
Your mileage may differ though, and my threshold for &#34;too much preprocessor magic&#34;
might be set too high.</p>
<p>For completeness, let&#39;s amend <code>instructions.x</code> with all the instructions in the bytecode language
I defined at the start of this post:</p>
<pre><code>X(CONSTANT, 1, {
	PUSH(OPERAND());
	NEXT();
})

X(ADD, 0, {
	b = POP();
	a = POP();
	PUSH(a + b);
	NEXT();
})

X(PRINT, 0, {
	PRINT(POP());
	NEXT();
})

X(INPUT, 0, {
	PUSH(INPUT());
	NEXT();
})

X(DISCARD, 0, {
	(void)POP();
	NEXT();
})

X(GET, 1, {
	a = STACK(OPERAND());
	PUSH(a);
	NEXT();
})

X(SET, 1, {
	a = POP();
	STACK(OPERAND()) = a;
	NEXT();
})

X(CMP, 0, {
	b = POP();
	a = POP();
	if (a &gt; b) PUSH(1);
	else if (a &lt; b) PUSH(-1);
	else PUSH(0);
	NEXT();
})

X(JGT, 1, {
	a = POP();
	if (a &gt; 0) { GOTO_RELATIVE(OPERAND()); }
	else { NEXT(); }
})

X(HALT, 0, {
	HALT();
})
</code></pre>
<p>Implementing the custom jump table variant and the tail-call variant using this X-macro system
is left as an exercise to the reader.
However, just to show that it&#39;s possible, here&#39;s the compiler variant implemented generically:</p>
<pre><code>#include &#34;instructions.h&#34;

#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

void compile(unsigned char *bytecode, size_t size, FILE *out) {
	fputs(
		&#34;#include &lt;stdio.h&gt;\n&#34;
		&#34;#include &lt;stdint.h&gt;\n&#34;
		&#34;#include &lt;stdlib.h&gt;\n&#34;
		&#34;\n&#34;
		&#34;int main(int argc, char **argv) {\n&#34;
		&#34;  int32_t stack[128];\n&#34;
		&#34;  int32_t *stackptr = stack;\n&#34;
		&#34;  char **inputptr = &amp;argv[1];\n&#34;
		&#34;\n&#34;
		&#34;#define POP() (*(--stackptr))\n&#34;
		&#34;#define PUSH(val) (*(stackptr++) = (val))\n&#34;
		&#34;#define STACK(offset) (*(stackptr - 1 - offset))\n&#34;
		&#34;#define OPERAND() operand\n&#34;
		&#34;#define INPUT() (atoi(*(inputptr++)))\n&#34;
		&#34;#define PRINT(val) printf(\&#34;%i\\n\&#34;, (int)(val))\n&#34;
		&#34;#define GOTO_RELATIVE(offset) index += offset; break\n&#34;
		&#34;#define NEXT()\n&#34;
		&#34;#define HALT() return 0\n&#34;
		&#34;\n&#34;
		&#34;  int32_t a, b, operand;\n&#34;
		&#34;  int32_t index = 0;\n&#34;
		&#34;  while (1) switch (index) {\n&#34;,
		out);

	for (size_t i = 0; i &lt; size;) {
		fprintf(out, &#34;  case %zi:\n&#34;, i);

		enum op op = (enum op)bytecode[i];
		switch (op) {
#define X(name, has_operand, code...) \
		case OP_ ## name: \
			fprintf(out, &#34;    index = %zi;\n&#34;, i); \
			i += 1; \
			if (has_operand) { \
				fprintf(out, &#34;    operand = %i;\n&#34;, (int)( \
					((int32_t)bytecode[i + 0] &lt;&lt; 0) | ((int32_t)bytecode[i + 1] &lt;&lt; 8) | \
					((int32_t)bytecode[i + 2] &lt;&lt; 16) | ((int32_t)bytecode[i + 3] &lt;&lt; 24))); \
				i += 4; \
			} \
			fputs(&#34;    &#34; #code &#34;\n&#34;, out); \
			break;
#include &#34;instructions.x&#34;
#undef X
		}
	}

	fputs(
		&#34;  }\n&#34;
		&#34;\n&#34;
		&#34;  abort(); // If we get here, there&#39;s a missing HALT\n&#34;
		&#34;}&#34;,
		out);
}
</code></pre>
<h2>A word on real-world performance</h2>
<p>I thought I should mention that the techniques described in this post won&#39;t magically make any
interpreted language much faster.
The main source of the performance differences we have explored here is due to the overhead
involved in selecting which instruction to execute next; the code which runs between
the instructions.
By reducing this overhead, we&#39;re able to make our simple bytecode execute blazing fast.
But that&#39;s really only because all our instructions are extremely simple.</p>
<p>In the case of something like Python, each instruction might be much more complex to execute.
The <code>BINARY_ADD</code> operation, for example, pops two values from the stack, adds them together,
and pushes the result onto the stack, much like how our bytecode&#39;s <code>ADD</code> operation does.
However, our <code>ADD</code> operation knows that the two popped values are 32-bit signed integers.
In Python, the popped values may be strings, they may be arrays, they may be numbers, they may be
objects with a custom <code>__add__</code> method, etc.
This means that the time it takes to actually execute instructions in Python will dominate
to the point that speeding up instruction dispatch is likely insignificant.
Optimizing highly dynamic languages like Python kind of requires some form of
<a href="https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation">tracing JIT</a>
to stamp out specialized functions which make assumptions about what types their arguments are,
which is outside the scope of this post.</p>
<p>But that doesn&#39;t mean the speed-up I have shown here is unrealistic.
If you&#39;re making a language with static types, you can have dedicated fast instructions
for adding i32s, adding doubles, etc.
And at that point, the optimizations shown in this post will give drastic speed-ups.</p>
<h2>Further reading</h2>
<ul>
<li>I watched this video about a year ago ago:
<a href="https://www.youtube.com/watch?v=V8dnIw3amLA">Cheaply writing a fast interpreter - Neil Mitchell</a>.
I can&#39;t directly cite anything specific,
but some ideas such as converting the instruction stream to an array of function pointers
comes from that talk.</li>
<li>Here&#39;s a discussion on how to do the custom jump table optimization in Zig:
<a href="https://github.com/ziglang/zig/issues/8220">https://github.com/ziglang/zig/issues/8220</a>
<ul>
<li>That thread links to this paper, which is also relevant:
<a href="http://www.cs.toronto.edu/%7Ematz/dissertation/matzDissertation-latex2html/node6.html">http://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html</a></li>
</ul>
</li>
</ul>
<hr/>
<p>So those are my thoughts on speeding up virtual machine execution.
If you want, you may check out my programming languages
<a href="https://github.com/mortie/gilia">Gilia</a> and <a href="https://github.com/mortie/osyris">osyris</a>.
Neither makes use of any of the techniques discussed in this post,
but playing with Gilia&#39;s VM is what got me started down this path of exploring different techniques.
If I ever get around to implementing these ideas into Gilia&#39;s VM,
I&#39;ll add a link to the relevant parts of the source code here.</p>
<!--RSS_END-->

	</div></div>
  </body>
</html>
