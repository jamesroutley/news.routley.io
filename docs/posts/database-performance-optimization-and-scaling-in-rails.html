<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2022/12/07/database-performance-optimization-and-scaling-in-rails.html">Original</a>
    <h1>Database Performance Optimization and Scaling in Rails</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Web applications usually rely heavily on databases, for the most part. And as applications grow, databases grow too. We keep scaling web servers and background workers to keep up with the heavy load. But eventually, the database needs to keep up with all the new connections from these processes.</p>
<p>One way to tackle this is to grow a database with an app using vertical scaling. This means adding more CPU power and memory to the database server. But this is usually slow. You might have to copy all your data to the new server and then put the application down to change the database servers that it communicates with.</p>
<p>This is also usually a one-way operation. You can&#39;t keep adding/removing CPU power or memory from the database server based on your load.</p>
<p>This post will cover some alternative methods to fine-tune and scale a database under heavy load and improve the performance of your Rails app. We will focus on:</p>
<ul>
<li>Splitting schema and data between multiple databases</li>
<li>Using read-only replica databases</li>
</ul>
<p>Let&#39;s get going!</p>
<h2 id="disclaimer-scaling-isnt-always-needed">Disclaimer: Scaling Isn&#39;t Always Needed</h2>
<p>As always, with any post about performance optimization and scaling, I would like to put up a standard disclaimer: <strong>make sure you have an issue before trying to solve it</strong>.</p>
<p>For example, on one of our apps in production, we tackled scaling and optimization only when we started processing more than 3 million background jobs a day.</p>
<p>This will, of course, be different for different apps. But usually, a good indicator of whether you need to optimize is if your database is always running at high CPU or memory usage.</p>
<h2 id="a-separate-database-for-your-rails-application">A Separate Database for Your Rails Application</h2>
<p>Sometimes, simply using a separate database server for a part of your app is a good solution. For example, your app might do two different things that don’t have a big overlap. Alternatively, maybe there&#39;s one very database-heavy feature, but it is only used rarely or by a small section of users. You should go for a separate database server if — and only if — there is a clear distinction between the parts of your app that will use different databases.</p>
<p>For example, a separate database is useful when you&#39;re audit logging in a high-frequency app (or have other very high-volume data that isn&#39;t necessarily accessed frequently). Let&#39;s see how we can set this up.</p>
<p>First, set up the <code>database.yml</code> to configure the second database. Let’s call the second database <code>log</code>. We&#39;ll add a <code>log_default</code> entry for the secondary database with a common configuration across all environments:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="yaml" data-theme="default"><code data-language="yaml" data-theme="default"><span><span>log_default</span><span>: </span><span>&amp;</span><span>log_default</span></span>
<span><span>  </span><span>host</span><span>: </span><span>localhost</span></span>
<span><span>  </span><span>port</span><span>: </span><span>&lt;%= ENV[&#34;DB_PORT&#34;] || 5432 %&gt;</span></span>
<span><span>  </span><span>adapter</span><span>: </span><span>postgresql</span></span>
<span><span>  </span><span>encoding</span><span>: </span><span>unicode</span></span>
<span><span>  </span><span>user</span><span>: </span><span>&lt;%= ENV[&#34;DB_USER&#34;] || &#34;postgres&#34; %&gt;</span></span>
<span><span>  </span><span>password</span><span>: </span><span>&lt;%= ENV[&#34;DB_PASSWORD&#34;] || &#34;postgres&#34; %&gt;</span></span>
<span><span>  </span><span>migrations_paths</span><span>: </span><span>db/log_migrate</span></span></code></pre></div>
<p>The important bit here is the <code>migrations_paths</code> option that tells Rails where to find migrations related to this database.</p>
<p>Then, update <code>database.yml</code> to configure access to the log database for <code>development</code>, <code>test</code>, and <code>production</code> environments:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="yaml" data-theme="default"><code data-language="yaml" data-theme="default"><span><span>development</span><span>:</span></span>
<span><span>  </span><span>primary</span><span>:</span></span>
<span><span>    </span><span>&lt;&lt;</span><span>: </span><span>*</span><span>default</span></span>
<span><span>    </span><span>database</span><span>: </span><span>&lt;%= ENV[&#34;DB_NAME&#34;] %&gt;</span></span>
<span><span>  </span><span>log</span><span>:</span></span>
<span><span>    </span><span>&lt;&lt;</span><span>: </span><span>*</span><span>log_default</span></span>
<span><span>    </span><span>database</span><span>: </span><span>&lt;%= ENV[&#34;LOG_DB_NAME&#34;] %&gt;</span></span>
<span> </span>
<span><span>test</span><span>:</span></span>
<span><span>  </span><span>primary</span><span>:</span></span>
<span><span>    </span><span>&lt;&lt;</span><span>: </span><span>*</span><span>default</span></span>
<span><span>    </span><span>database</span><span>: </span><span>my_app_test</span></span>
<span><span>  </span><span>log</span><span>:</span></span>
<span><span>    </span><span>&lt;&lt;</span><span>: </span><span>*</span><span>log_default</span></span>
<span><span>    </span><span>database</span><span>: </span><span>my_app_log_test</span></span>
<span> </span>
<span><span>production</span><span>:</span></span>
<span><span>  </span><span>primary</span><span>:</span></span>
<span><span>    </span><span>adapter</span><span>: </span><span>postgresql</span></span>
<span><span>    </span><span>encoding</span><span>: </span><span>unicode</span></span>
<span><span>    </span><span>url</span><span>: </span><span>&lt;%= ENV[&#34;DATABASE_URL&#34;] %&gt;</span></span>
<span><span>  </span><span>log</span><span>:</span></span>
<span><span>    </span><span>adapter</span><span>: </span><span>postgresql</span></span>
<span><span>    </span><span>encoding</span><span>: </span><span>unicode</span></span>
<span><span>    </span><span>migrations_paths</span><span>: </span><span>db/log_migrate</span></span>
<span><span>    </span><span>url</span><span>: </span><span>&lt;%= ENV[&#34;DATABASE_LOG_URL&#34;] %&gt;</span></span></code></pre></div>
<p>As you can see, we move the configuration for each environment one level deeper. The configuration for our primary database lives inside the <code>primary</code> key for each environment. The second database&#39;s configuration (that we call <code>log</code>) lives inside the <code>log</code> key. <code>primary</code> is a special keyword that tells Rails to use this database as the default.</p>
<p>The next step is to set up <code>ActiveRecord</code> to use this new database. We first create a base class that establishes a connection to this database (instead of a primary one) using <code>establish_connection</code>:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ruby" data-theme="default"><code data-language="ruby" data-theme="default"><span><span>class</span><span> </span><span>LogRecord</span><span> </span><span>&lt;</span><span> </span><span>ActiveRecord::Base</span></span>
<span><span>  </span><span>self</span><span>.abstract_class </span><span>=</span><span> </span><span>true</span></span>
<span><span>  establish_connection </span><span>:log</span></span>
<span><span>end</span></span></code></pre></div>
<p>And then, we inherit from <code>LogRecord</code> instead of <code>ApplicationRecord</code> for all the records that should access the <code>log</code> DB:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ruby" data-theme="default"><code data-language="ruby" data-theme="default"><span><span>class</span><span> </span><span>AuditLog</span><span> </span><span>&lt;</span><span> </span><span>LogRecord</span></span>
<span><span>end</span></span></code></pre></div>
<p>Note that you keep using the rails generators for generating models and migrations by appending the <code>--database log</code> option to target the second database. The migration task now automatically migrates both databases, but if you need to only migrate one, you can use <code>db:migrate:primary</code> or <code>db:migrate:log</code> tasks.</p>
<p>This works great if there is a clear distinction between two parts of the app. But what if you don’t have a clear idea of the database that&#39;s creating issues? There are still a couple of options left. Let&#39;s check them out.</p>
<h2 id="using-read-only-replicas-for-rails">Using Read-Only Replicas for Rails</h2>
<p>Our second scaling option is to access data from read-only replicas while still writing to the primary database. This can improve performance for users who only browse parts of the app without performing any writing operations. Depending on your app&#39;s use case, this can be 80% of your users or 10% of them. So, evaluate the behavior of your users or your application use case before going down this route.</p>
<p>For an app with a majority of read-only users (like Twitter, for example), you can gain huge improvements in performance. New read-only replicas can be added/removed at will without affecting the primary database, which opens up options for auto-scalability.</p>
<p>Let&#39;s see how to set this up.</p>
<h3 id="setting-up-a-read-only-replica">Setting up a Read-Only Replica</h3>
<p>As usual, we will start with modifications to the <code>database.yml</code> config to include the replica:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="yaml" data-theme="default"><code data-language="yaml" data-theme="default"><span><span>production</span><span>:</span></span>
<span><span>  </span><span>primary</span><span>:</span></span>
<span><span>    </span><span>adapter</span><span>: </span><span>postgresql</span></span>
<span><span>    </span><span>encoding</span><span>: </span><span>unicode</span></span>
<span><span>    </span><span>url</span><span>: </span><span>&lt;%= ENV[&#34;DATABASE_URL&#34;] %&gt;</span></span>
<span><span>  </span><span>primary_replica</span><span>:</span></span>
<span><span>    </span><span>adapter</span><span>: </span><span>postgresql</span></span>
<span><span>    </span><span>encoding</span><span>: </span><span>unicode</span></span>
<span><span>    </span><span>url</span><span>: </span><span>&lt;%= ENV[&#34;DATABASE_REPLICA_URL&#34;] %&gt;</span></span></code></pre></div>
<p>Again, the <code>primary</code> key is a special key indicating that this database is the default. We can use any other key for the replica database configuration. Let’s choose <code>primary_replica</code> for sanity.</p>
<p>Then update the <code>ApplicationRecord</code> to configure a connection to multiple databases:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ruby" data-theme="default"><code data-language="ruby" data-theme="default"><span><span>class</span><span> </span><span>ApplicationRecord</span><span> </span><span>&lt;</span><span> </span><span>ActiveRecord::Base</span></span>
<span><span>  </span><span>self</span><span>.abstract_class </span><span>=</span><span> </span><span>true</span></span>
<span> </span>
<span><span>  connects_to </span><span>database:</span><span> { </span><span>writing:</span><span> </span><span>:primary</span><span>, </span><span>reading:</span><span> </span><span>:primary_replica</span><span> } </span><span>if</span><span> </span><span>Rails</span><span>.env.production?</span></span>
<span><span>end</span></span></code></pre></div>
<p>Note that we add configuration for a <code>production</code> environment only in the above example. If you want to, you can set it up for all environments, after modifying your development setup to support replicas.</p>
<p>Finally, to use the read-only replica, you need to tell Rails when to use the primary database and when to use the replica. Rails provides a basic implementation for automatic role-switching based on the HTTP verb of the request out of the box. To enable it, add the following to your <code>production.rb</code>:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ruby" data-theme="default"><code data-language="ruby" data-theme="default"><span><span># Use Read-Only Databases on GET requests</span></span>
<span><span>config.active_record.database_selector </span><span>=</span><span> { </span><span>delay:</span><span> </span><span>2</span><span>.seconds }</span></span>
<span><span>config.active_record.database_resolver </span><span>=</span><span> </span><span>ActiveRecord</span><span>::</span><span>Middleware</span><span>::</span><span>DatabaseSelector</span><span>::</span><span>Resolver</span></span>
<span><span>config.active_record.database_resolver_context </span><span>=</span><span> </span><span>ActiveRecord</span><span>::</span><span>Middleware</span><span>::</span><span>DatabaseSelector</span><span>::</span><span>Resolver</span><span>::</span><span>Session</span></span></code></pre></div>
<p>This tells Rails to use the replica for all <code>GET</code> or <code>HEAD</code> requests and the primary one otherwise. Notice the option that sets the delay to two seconds? That tells Rails to keep using the primary database for <code>GET</code> and <code>HEAD</code> requests if it is within two seconds of a write request in the same session.</p>
<h3 id="gotchas">Gotchas</h3>
<p>Does all of this sound too simple? Well, we aren’t done yet. Depending on how your application is structured, you need to keep a few points in mind.</p>
<p>Firstly, ensure you do not write anything in a read-only action like <code>index</code> or <code>show</code>. If there are legitimate reasons for writing during those operations, you can manually switch the connection:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ruby" data-theme="default"><code data-language="ruby" data-theme="default"><span><span>ActiveRecord</span><span>::</span><span>Base</span><span>.connected_to(</span><span>role:</span><span> </span><span>:writing</span><span>) </span><span>do</span></span>
<span><span>  </span><span># Your code here</span></span>
<span><span>end</span></span></code></pre></div>
<p>A good example where this can be useful is if you are managing sessions in a database. If you do that, make sure you use the <code>writing</code> role. For example, you can override the <code>save_record</code> method in your session with <code>authlogic</code>:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ruby" data-theme="default"><code data-language="ruby" data-theme="default"><span><span>class</span><span> </span><span>UserSession</span><span> </span><span>&lt;</span><span> </span><span>Authlogic::Session::Base</span></span>
<span><span>  </span><span># Your session configuration</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>save_record</span><span>(alternate_record </span><span>=</span><span> </span><span>nil</span><span>)</span></span>
<span><span>    </span><span>ActiveRecord</span><span>::</span><span>Base</span><span>.connected_to(</span><span>role:</span><span> </span><span>:writing</span><span>) </span><span>do</span></span>
<span><span>      </span><span>super</span></span>
<span><span>    </span><span>end</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div>
<p>Another use case for automatic role-switching is when an app exposes a GraphQL API. All operations on a GraphQL API are <code>POST</code>, but conventionally, all <code>queries</code> are read-only, and <code>mutations</code> are read-write. In this case, to allow Rails to select the correct database, we can use a custom tracer in the schema.</p>
<p>First, create a tracer that switches roles based on the GraphQL document:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ruby" data-theme="default"><code data-language="ruby" data-theme="default"><span><span>module</span><span> </span><span>Tracers</span></span>
<span><span>  </span><span>class</span><span> </span><span>DatabaseRoleTracer</span></span>
<span><span>    </span><span>EVENT_NAME</span><span> </span><span>=</span><span> </span><span>&#34;execute_multiplex&#34;</span></span>
<span> </span>
<span><span>    </span><span># Execute on read only database if the operation has only queries.</span></span>
<span><span>    </span><span>def</span><span> </span><span>trace</span><span>(event, data)</span></span>
<span><span>      </span><span>return</span><span> </span><span>yield</span><span> </span><span>unless</span><span> </span><span>Rails</span><span>.env.production?</span></span>
<span><span>      </span><span>return</span><span> </span><span>yield</span><span> </span><span>unless</span><span> event </span><span>==</span><span> </span><span>EVENT_NAME</span></span>
<span> </span>
<span><span>      multiplex </span><span>=</span><span> data[</span><span>:multiplex</span><span>]</span></span>
<span><span>      </span><span>ActiveRecord</span><span>::</span><span>Base</span><span>.connected_to(</span><span>role:</span><span> role(multiplex)) </span><span>do</span></span>
<span><span>        </span><span>yield</span></span>
<span><span>      </span><span>end</span></span>
<span><span>    </span><span>end</span></span>
<span> </span>
<span><span>    </span><span>private</span></span>
<span> </span>
<span><span>    </span><span>def</span><span> </span><span>role</span><span>(multiplex)</span></span>
<span><span>      </span><span>if</span><span> multiplex.queries.all?(</span><span>&amp;</span><span>:query?</span><span>)</span></span>
<span><span>        </span><span>ActiveRecord</span><span>::</span><span>Base</span><span>.reading_role</span></span>
<span><span>      </span><span>else</span></span>
<span><span>        </span><span>ActiveRecord</span><span>::</span><span>Base</span><span>.writing_role</span></span>
<span><span>      </span><span>end</span></span>
<span><span>    </span><span>end</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div>
<p>And then use the <code>tracer</code> in your GraphQL Schema:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ruby" data-theme="default"><code data-language="ruby" data-theme="default"><span><span>class</span><span> </span><span>MyAppSchema</span><span> </span><span>&lt;</span><span> </span><span>GraphQL::Schema</span></span>
<span><span>  tracer </span><span>Tracers</span><span>::</span><span>DatabaseRoleTracer</span><span>.</span><span>new</span></span>
<span> </span>
<span><span>  </span><span># Your code here</span></span>
<span><span>end</span></span></code></pre></div>
<p>Let’s get to the final alternative. What can you do if your application still has a huge load on your primary database? The answer: database sharding.</p>
<h2 id="database-sharding-in-your-rails-application">Database Sharding in Your Rails Application</h2>
<p>This is the most complex of all the methods for scaling databases discussed in this post. So reach for it only if you need it. It will add considerable complexity to your application and needs to be done right to provide any real benefit.</p>
<p>There are two strategies to shard your database:</p>
<ol>
<li>Distribute different tables on different nodes (vertical sharding).</li>
<li>Have the same schema across all nodes, but distribute data depending on certain parameters (horizontal sharding).</li>
</ol>
<p>Vertical sharding is similar to our “multiple databases” strategy in terms of setup and pros and cons, so we will not discuss it again.</p>
<p>Let&#39;s discuss horizontal sharding and where it could be helpful.</p>
<p>One example is when you have a SaaS platform where a lot of data is associated with each user, but there is no overlap between the data of two users. In this case, splitting the data across nodes based on the user&#39;s id is the most logical way to go. Every signed-in user will have to access only a single database, so we won&#39;t have to reach out to multiple databases at the same time.</p>
<h3 id="setting-up-horizontal-sharding">Setting up Horizontal Sharding</h3>
<p>Let’s start with the configuration inside <code>database.yml</code> again:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="yaml" data-theme="default"><code data-language="yaml" data-theme="default"><span><span>production</span><span>:</span></span>
<span><span>  </span><span>primary</span><span>:</span></span>
<span><span>    </span><span>adapter</span><span>: </span><span>postgresql</span></span>
<span><span>    </span><span>encoding</span><span>: </span><span>unicode</span></span>
<span><span>    </span><span>url</span><span>: </span><span>&lt;%= ENV[&#34;DATABASE_URL&#34;] %&gt;</span></span>
<span><span>  </span><span>primary_replica</span><span>:</span></span>
<span><span>    </span><span>adapter</span><span>: </span><span>postgresql</span></span>
<span><span>    </span><span>encoding</span><span>: </span><span>unicode</span></span>
<span><span>    </span><span>url</span><span>: </span><span>&lt;%= ENV[&#34;DATABASE_REPLICA_URL&#34;] %&gt;</span></span>
<span><span>  </span><span>primary_shard_one</span><span>:</span></span>
<span><span>    </span><span>adapter</span><span>: </span><span>postgresql</span></span>
<span><span>    </span><span>encoding</span><span>: </span><span>unicode</span></span>
<span><span>    </span><span>url</span><span>: </span><span>&lt;%= ENV[&#34;DATABASE_SHARD_ONE_URL&#34;] %&gt;</span></span>
<span><span>	</span><span>primary_shard_one_replica</span><span>:</span></span>
<span><span>    </span><span>adapter</span><span>: </span><span>postgresql</span></span>
<span><span>    </span><span>encoding</span><span>: </span><span>unicode</span></span>
<span><span>    </span><span>url</span><span>: </span><span>&lt;%= ENV[&#34;DATABASE_SHARD_ONE_REPLICA_URL&#34;] %&gt;</span></span></code></pre></div>
<p>Then modify the <code>ApplicationRecord</code> to connect to different shards:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="yaml" data-theme="default"><code data-language="yaml" data-theme="default"><span><span>class ApplicationRecord &lt; ActiveRecord::Base</span></span>
<span><span>  </span><span>self.abstract_class = true</span></span>
<span> </span>
<span><span>  </span><span>connects_to shards</span><span>: {</span></span>
<span><span>    </span><span>default</span><span>: { </span><span>writing</span><span>: </span><span>:primary</span><span>, </span><span>reading</span><span>: </span><span>:primary_replica</span><span> },</span></span>
<span><span>    </span><span>shard_one</span><span>: { </span><span>writing</span><span>: </span><span>:primary_shard_one</span><span>, </span><span>reading</span><span>: </span><span>:primary_shard_one_replica</span><span> }</span></span>
<span><span>  }</span></span>
<span><span>end</span></span></code></pre></div>
<p>Now we can use the <code>shard</code> option with <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionHandling.html#method-i-connected_to"><code>ActiveRecord::Base.connected_to</code></a> to switch shards. Like the automatic database role selector, Rails also provides an automatic shard switcher that can be activated inside <code>production.rb</code> like this:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ruby" data-theme="default"><code data-language="ruby" data-theme="default"><span><span>Rails</span><span>.application.configure </span><span>do</span></span>
<span><span>  config.active_record.shard_selector </span><span>=</span><span> { </span><span>lock:</span><span> </span><span>true</span><span> }</span></span>
<span><span>  config.active_record.shard_resolver </span><span>=</span><span> </span><span>-&gt;</span><span>(request) { </span><span>Tenant</span><span>.find_by!(</span><span>host:</span><span> request.host).shard }</span></span>
<span><span>end</span></span></code></pre></div>
<p>The <code>shard_resolver</code> lambda is the most interesting part. The above implementation relies on the assumption that our application is accessed from different domains/subdomains and distinguishes between the shards. Modify it to fit your application needs (you might need to access cookies to identify a user before switching the shard).</p>
<p>As with vertical scaling, this strategy is usually a one-way street. Once you shard a database, it is very hard to “un-shard” it (since several databases could have the same ids for different objects). But this lays down the foundation to really scale your app to millions or billions of users when fitting everything on the same server is not an option.</p>
<p>If you want to read more about database sharding, see this <a href="https://www.linode.com/docs/guides/sharded-database/">write-up by Linode</a>.</p>
<h2 id="measure-your-rails-database-performance-with-appsignal">Measure Your Rails Database Performance with AppSignal</h2>
<p>It can be tricky to keep an eye on the performance of your database without any other tools. Using AppSignal, you can easily track how your databases perform. See our <a href="https://www.appsignal.com/ruby">AppSignal for Ruby page</a> for more information.</p>
<p>You can also check out our post <a href="https://blog.appsignal.com/2022/01/26/test-and-optimize-your-ruby-on-rails-database-performance.html">Test and Optimize Your Ruby on Rails Database Performance</a> for more information on the metrics you can measure in AppSignal and how a dashboard might look.</p>
<h2 id="wrap-up">Wrap Up</h2>
<p>In this post, we discussed three major strategies to scale your database servers horizontally:</p>
<ul>
<li>Splitting schema between multiple databases</li>
<li>Using read-only replica databases</li>
<li>Splitting data between multiple databases</li>
</ul>
<p>All strategies have their pros and cons depending on your application use case and scale.</p>
<p>Rails has really upped its database game in its last few releases. This post has shown how easy it is to set up a Rails app to use multiple databases.</p>
<p>As always, if your application allows it, I suggest starting small with optimizations. The easiest optimization to start with is a read-only replica, then only move on when you need more scale.</p>
<p>Happy scaling!</p>
<p><strong>P.S. If you&#39;d like to read Ruby Magic posts as soon as they get off the press, <a href="https://blog.appsignal.com/ruby-magic">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p></div></div></div>
  </body>
</html>
