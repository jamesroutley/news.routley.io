<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jacco.ompf2.com/2022/06/15/how-to-build-a-bvh-part-9b-massive/">Original</a>
    <h1>GPU ray tracing tutorial – 10 articles</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<p>In this series we explore the wonderful world of the <em>bounding volume hierarchy:</em> the mysterious data structure that enables real-time ray tracing on recent GPUs, in complex, animated scenes. Despite the broad adoption of ray tracing in games, in-depth understanding of the underlying technology seems to be reserved to a select few. In this article we show how a proper BVH is implemented without support from DXR / RTX / OptiX / Vulkan, in easy-to-read ‘sane C++’. Whether this is actually useful for you, or just interesting as background information, depends on your needs, obviously.</p>



<p>This series consist of ten articles. For each article, full source code is <a href="https://github.com/jbikker/bvh_article">available on Github</a>, in easy-to-read ‘Sane C++’. Contents:</p>



<ol><li><a href="https://jacco.ompf2.com/2022/04/13/how-to-build-a-bvh-part-1-basics/">Basics: data structure, simple construction and ray traversal</a>.</li><li><a href="https://jacco.ompf2.com/2022/04/18/how-to-build-a-bvh-part-2-faster-rays/">Faster rays: the Surface Area Heuristic and ordered traversal</a>.</li><li><a href="https://jacco.ompf2.com/2022/04/21/how-to-build-a-bvh-part-3-quick-builds/">Faster construction: binned BVH building</a>.</li><li><a href="https://jacco.ompf2.com/2022/04/26/how-to-build-a-bvh-part-4-animation/">BVHs for animated models: refitting and rebuilding</a>.</li><li><a href="https://jacco.ompf2.com/2022/05/07/how-to-build-a-bvh-part-5-tlas-blas/">BVHs for animated scenes: the top-level BVH</a>.</li><li><a href="https://jacco.ompf2.com/2022/05/13/how-to-build-a-bvh-part-6-all-together-now/">TLAS &amp; BLAS part 2 – all together now</a>.</li><li><a href="https://jacco.ompf2.com/2022/05/20/how-to-build-a-bvh-part-7-consolidate/">Consolidating, part 1: ray tracing textured and shaded meshes</a>.</li><li><a href="https://jacco.ompf2.com/2022/05/27/how-to-build-a-bvh-part-8-whitted-style/">Consolidating, part 2: Whitted-style ray tracing</a>.</li><li><a href="https://jacco.ompf2.com/2022/06/03/how-to-build-a-bvh-part-9a-to-the-gpu/">OpenCL: GPU ray tracing, part 1</a>.</li><li><strong>OpenCL: GPU ray tracing, part 2 (SERIES FINAL, this article).</strong></li></ol>



<p id="block-0335045c-892a-4222-aee1-ff87a91ce61a">This is the end. Last time we ported the ray tracing code to the GPU, or at least: BLAS traversal and basic visualization. All that is left to do is some cleaning up, and TLAS traversal. With that in place, we will have the same power on CPU and GPU, in terms of animation: we will be able to specify a transform (rotate, translate, scale) for each instance, on top of the capability to rebuild or refit meshes on-the-fly.</p>



<p>In this final article we implement TLAS traversal and the recursive Whitted-style ray tracer on the GPU. For that a few details need to be sorted out. The final product deserves a fitting final demo, for which I will take some inspiration from the <a href="https://www.youtube.com/watch?v=J513nnZyh5o">work of two of my students</a> at Utrecht University.</p>



<div><figure><img loading="lazy" width="1024" height="374" src="https://jacco.ompf2.com/wp-content/uploads/2022/06/logsof-1024x374.jpg" alt="" srcset="https://jacco.ompf2.com/wp-content/uploads/2022/06/logsof-1024x374.jpg 1024w, https://jacco.ompf2.com/wp-content/uploads/2022/06/logsof-300x109.jpg 300w, https://jacco.ompf2.com/wp-content/uploads/2022/06/logsof-768x280.jpg 768w, https://jacco.ompf2.com/wp-content/uploads/2022/06/logsof-1536x561.jpg 1536w, https://jacco.ompf2.com/wp-content/uploads/2022/06/logsof-1222x446.jpg 1222w, https://jacco.ompf2.com/wp-content/uploads/2022/06/logsof-897x327.jpg 897w, https://jacco.ompf2.com/wp-content/uploads/2022/06/logsof-360x131.jpg 360w, https://jacco.ompf2.com/wp-content/uploads/2022/06/logsof.jpg 1748w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Dragons. Lots of dragons.</figcaption></figure></div>



<h2>Preparations</h2>



<p>To keep the <a href="https://jacco.ompf2.com/2022/06/03/how-to-build-a-bvh-part-9a-to-the-gpu/">article 9a</a> code intact we start with a new file, titled <code>raytracer.cl</code>, which is initially a copy of <code>kernels.cl</code>. The new file will be loaded from <code>::Init()</code> on the CPU side:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f833049835707" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>    </span><span>tracer</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Kernel</span><span>(</span><span> </span><span>&#34;cl/raytracer.cl&#34;</span><span>,</span><span> </span><span>&#34;render&#34;</span><span> </span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>The OpenCL source file currently includes <code>template/common.h</code>. We add <code>cl/tools.h</code>, which currently just contains some functions for generating random numbers.</p>







<p>We can now move most of the code from raytracer.cl to tools.h. I propose to move the various structs (<code>Intersection</code>, <code>Ray</code>, <code>Tri</code>, <code>TriEx</code>, <code>BVHNode</code>, <code>TLASNode</code> and <code>BVHInstance</code>), as well as the color format conversion function <code>RGB32FtoRGB8</code> and the intersection functions <code>IntersectTri</code> and <code>IntersectAABB</code>. And finally, also <code>BVHIntersect</code>, for BLAS traversal. All that remains in <code>raytracer.cl</code> is then:</p>



<ul><li><code>float3 Trace(...)</code>, which will replicate the functionality of the Trace function we used on the CPU, and</li><li><code>__kernel void render(...)</code>, the OpenCL kernel, which we call from the C++ code.</li></ul>



<p>The reorganized code lets us deal with high-level things in <code>raytracer.cl</code>, while the low-level details are hidden away in <code>tools.h</code>.</p>



<p>To match the theme of the article, a new mesh has been added to the assets folder: <code>dragon.obj</code>. </p>



<div><figure><img loading="lazy" src="https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonmesh.jpg" alt="" width="494" height="294" srcset="https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonmesh.jpg 987w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonmesh-300x179.jpg 300w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonmesh-768x458.jpg 768w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonmesh-897x534.jpg 897w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonmesh-360x214.jpg 360w" sizes="(max-width: 494px) 100vw, 494px"/></figure></div>



<p>This version of the <a href="https://graphics.stanford.edu/data/3Dscanrep/">Stanford Dragon</a> consists of 19332 triangles, and it replaces the 1024 triangle <a href="https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206">Utah teapot</a>. Some changes to the <code>Mesh</code> class are needed to accommodate the larger number of polygons:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f83a696565048" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>class</span><span> </span><span>Mesh</span></p><p><span>{</span></p><p><span>public</span><span>:</span></p><p><span>    </span><span>Mesh</span><span>(</span><span>)</span><span> </span><span>=</span><span> </span><span>default</span><span>;</span></p><p><span>    </span><span>Mesh</span><span>(</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>objFile</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>texFile</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>Tri </span><span>tri</span><span>[</span><span>19500</span><span>]</span><span>;</span><span>		</span><span>// triangle data for intersection</span></p><p><span>    </span><span>TriEx </span><span>triEx</span><span>[</span><span>19500</span><span>]</span><span>;</span><span>		</span><span>// triangle data for shading</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p><p><span>}</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
</div>



<p>Similar changes are needed in the implementation of the <code>Mesh</code> constructor.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f83c055706897" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>Mesh</span><span>::</span><span>Mesh</span><span>(</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>objFile</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>texFile</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>// bare-bones obj file loader; only supports very basic meshes</span></p><p><span>    </span><span>texture</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Surface</span><span>(</span><span> </span><span>texFile</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>float2*</span><span> </span><span>UV</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>float2</span><span>[</span><span>11050</span><span>]</span><span>;</span><span> </span><span>// enough for dragon.obj</span></p><p><span>    </span><span>float3*</span><span> </span><span>N</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>float3</span><span>[</span><span>11050</span><span>]</span><span>,</span><span> </span><span>*</span><span>P</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>float3</span><span>[</span><span>19500</span><span>]</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>Here, 11050 is approximately the number of vertices in the dragon mesh.</p>



<p>With these changes, the code still works, but there is a small issue:</p>



<div><figure><img loading="lazy" src="https://jacco.ompf2.com/wp-content/uploads/2022/06/small-1-1024x572.jpg" alt="" width="512" height="286" srcset="https://jacco.ompf2.com/wp-content/uploads/2022/06/small-1-1024x572.jpg 1024w, https://jacco.ompf2.com/wp-content/uploads/2022/06/small-1-300x168.jpg 300w, https://jacco.ompf2.com/wp-content/uploads/2022/06/small-1-768x429.jpg 768w, https://jacco.ompf2.com/wp-content/uploads/2022/06/small-1-1222x682.jpg 1222w, https://jacco.ompf2.com/wp-content/uploads/2022/06/small-1-897x501.jpg 897w, https://jacco.ompf2.com/wp-content/uploads/2022/06/small-1-360x201.jpg 360w, https://jacco.ompf2.com/wp-content/uploads/2022/06/small-1.jpg 1268w" sizes="(max-width: 512px) 100vw, 512px"/><figcaption>“Small” may be a poorly chosen word.</figcaption></figure></div>



<p>The white shape that obscures the sky is a massive dragon. In the CPU code we would resolve this by assigning a scaling matrix to the instance of the dragon mesh. Or rather: we would apply the inverse of this matrix to the rays that intersects the dragon.</p>



<p>Time to add TLAS traversal.</p>



<h2>GPU TLAS</h2>



<p>The concept of the TLAS (a.k.a. <em>top level BVH</em>) was introduced in <a href="https://jacco.ompf2.com/2022/05/07/how-to-build-a-bvh-part-5-tlas-blas/">article 5</a> and <a href="https://jacco.ompf2.com/2022/05/13/how-to-build-a-bvh-part-6-all-together-now/">article 6</a>. The idea is to build and traverse a BVH over BVHs, where each of those BVHs can have a 4×4 matrix transform, for translation, rotation, and scaling. Using the same BVH multiple times but with a different matrix enables instancing.</p>



<p>We already have the necessary data on the GPU. There is the <code>TLASNode</code> struct:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f83d145167129" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>struct</span><span> </span><span>TLASNode</span></p><p><span>{</span></p><p><span>    </span><span>float</span><span> </span><span>minx</span><span>,</span><span> </span><span>miny</span><span>,</span><span> </span><span>minz</span><span>;</span></p><p><span>    </span><span>uint </span><span>leftRight</span><span>;</span><span> </span><span>// 2x16 bits</span></p><p><span>    </span><span>float</span><span> </span><span>maxx</span><span>,</span><span> </span><span>maxy</span><span>,</span><span> </span><span>maxz</span><span>;</span></p><p><span>    </span><span>uint </span><span>BLAS</span><span>;</span></p><p><span>}</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>And an array of <code>BVHInstance</code> objects, indexed by the <code>BLAS</code> field of the <code>TLASNode</code>:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f83e195939034" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>struct</span><span> </span><span>BVHInstance</span></p><p><span>{</span></p><p><span>    </span><span>uint </span><span>dummy1</span><span>,</span><span> </span><span>dummy2</span><span>;</span></p><p><span>    </span><span>uint </span><span>idx</span><span>;</span></p><p><span>    </span><span>float16 </span><span>transform</span><span>;</span></p><p><span>    </span><span>float16 </span><span>invTransform</span><span>;</span><span> </span><span>// inverse transform</span></p><p><span>    </span><span>uint </span><span>dummy</span><span>[</span><span>6</span><span>]</span><span>;</span></p><p><span>}</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>The strange <code>dummy</code> array at the end is there to ensure that the size and layout of the OpenCL struct matches the CPU struct, at least to the extend that fields <code>transform</code> and <code>invTransform</code> are in the correct location. More on that in a second, because I made some serious mistakes here that need fixing…</p>



<p>We can now port the <code>TLAS::Intersect(...)</code> method. The process is similar to porting the <code>BVH::Intersect</code> method, so I paste the result here without going over every step in detail.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f840712440708" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>TLASIntersect</span><span>(</span><span> </span><span>struct</span><span> </span><span>Ray</span><span>*</span><span> </span><span>ray</span><span>,</span><span> </span><span>struct</span><span> </span><span>Tri</span><span>*</span><span> </span><span>tri</span><span>,</span><span> </span></p><p><span>    </span><span>struct</span><span> </span><span>BVHInstance</span><span>*</span><span> </span><span>bvhInstance</span><span>,</span><span> </span><span>struct</span><span> </span><span>TLASNode</span><span>*</span><span> </span><span>tlasNode</span><span>,</span><span> </span></p><p><span>    </span><span>struct</span><span> </span><span>BVHNode</span><span>*</span><span> </span><span>bvhNode</span><span>,</span><span> </span><span>uint</span><span>*</span><span> </span><span>triIdx</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>// initialize reciprocals for TLAS traversal</span></p><p><span>    </span><span>ray</span><span>-&gt;</span><span>rD</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span>1.0f</span><span> </span><span>/</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span>.</span><span>x</span><span>,</span><span> </span><span>1.0f</span><span> </span><span>/</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span>.</span><span>y</span><span>,</span><span> </span><span>1.0f</span><span> </span><span>/</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span>.</span><span>z</span><span>)</span><span>;</span></p><p><span>    </span><span>// use a local stack instead of a recursive function</span></p><p><span>    </span><span>struct</span><span> </span><span>TLASNode</span><span>*</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>&amp;tlasNode</span><span>[</span><span>0</span><span>]</span><span>,</span><span> </span><span>*</span><span>stack</span><span>[</span><span>32</span><span>]</span><span>;</span></p><p><span>    </span><span>uint </span><span>stackPtr</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>    </span><span>// traversl loop; terminates when the stack is empty</span></p><p><span>    </span><span>while</span><span> </span><span>(</span><span>1</span><span>)</span></p><p><span>    </span><span>{</span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>node</span><span>-&gt;</span><span>leftRight</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>// isLeaf()</span></p><p><span>        </span><span>{</span></p><p><span>            </span><span>// current node is a leaf: intersect instance</span></p><p><span>            </span><span>InstanceIntersect</span><span>(</span><span> </span><span>ray</span><span>,</span><span> </span><span>&amp;bvhInstance</span><span>[</span><span>node</span><span>-&gt;</span><span>BLAS</span><span>]</span><span>,</span><span> </span><span>node</span><span>-&gt;</span><span>BLAS</span><span>,</span><span> </span><span>tri</span><span>,</span><span> </span><span>bvhNode</span><span>,</span><span> </span><span>triIdx</span><span> </span><span>)</span><span>;</span></p><p><span>            </span><span>// pop a node from the stack; terminate if none left</span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>stackPtr</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>break</span><span>;</span><span> </span><span>else</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>stack</span><span>[</span><span>--</span><span>stackPtr</span><span>]</span><span>;</span></p><p><span>            </span><span>continue</span><span>;</span></p><p><span>        </span><span>}</span></p><p><span>        </span><span>// current node is an interior node: visit child nodes, ordered</span></p><p><span>        </span><span>struct</span><span> </span><span>TLASNode</span><span>*</span><span> </span><span>child1</span><span> </span><span>=</span><span> </span><span>&amp;tlasNode</span><span>[</span><span>node</span><span>-&gt;</span><span>leftRight</span><span> </span><span>&amp;</span><span> </span><span>0xffff</span><span>]</span><span>;</span></p><p><span>        </span><span>struct</span><span> </span><span>TLASNode</span><span>*</span><span> </span><span>child2</span><span> </span><span>=</span><span> </span><span>&amp;tlasNode</span><span>[</span><span>node</span><span>-&gt;</span><span>leftRight</span><span> </span><span>&gt;&gt;</span><span> </span><span>16</span><span>]</span><span>;</span></p><p><span>        </span><span>float</span><span> </span><span>dist1</span><span> </span><span>=</span><span> </span><span>IntersectAABB</span><span>(</span><span> </span><span>ray</span><span>,</span><span> </span><span>child1</span><span> </span><span>)</span><span>;</span></p><p><span>        </span><span>float</span><span> </span><span>dist2</span><span> </span><span>=</span><span> </span><span>IntersectAABB</span><span>(</span><span> </span><span>ray</span><span>,</span><span> </span><span>child2</span><span> </span><span>)</span><span>;</span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>dist1</span><span> </span><span>&gt;</span><span> </span><span>dist2</span><span>)</span><span> </span></p><p><span>        </span><span>{</span><span> </span></p><p><span>            </span><span>float</span><span> </span><span>d</span><span> </span><span>=</span><span> </span><span>dist1</span><span>;</span><span> </span><span>dist1</span><span> </span><span>=</span><span> </span><span>dist2</span><span>;</span><span> </span><span>dist2</span><span> </span><span>=</span><span> </span><span>d</span><span>;</span></p><p><span>            </span><span>struct</span><span> </span><span>TLASNode</span><span>*</span><span> </span><span>c</span><span> </span><span>=</span><span> </span><span>child1</span><span>;</span><span> </span><span>child1</span><span> </span><span>=</span><span> </span><span>child2</span><span>;</span><span> </span><span>child2</span><span> </span><span>=</span><span> </span><span>c</span><span>;</span></p><p><span>        </span><span>}</span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>dist1</span><span> </span><span>==</span><span> </span><span>1e30f</span><span>)</span></p><p><span>        </span><span>{</span></p><p><span>            </span><span>// missed both child nodes; pop a node from the stack</span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>stackPtr</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>break</span><span>;</span><span> </span><span>else</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>stack</span><span>[</span><span>--</span><span>stackPtr</span><span>]</span><span>;</span></p><p><span>        </span><span>}</span></p><p><span>        </span><span>else</span></p><p><span>        </span><span>{</span></p><p><span>            </span><span>// visit near node; push the far node if the ray intersects it</span></p><p><span>            </span><span>node</span><span> </span><span>=</span><span> </span><span>child1</span><span>;</span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>dist2</span><span> </span><span>!=</span><span> </span><span>1e30f</span><span>)</span><span> </span><span>stack</span><span>[</span><span>stackPtr</span><span>++</span><span>]</span><span> </span><span>=</span><span> </span><span>child2</span><span>;</span></p><p><span>        </span><span>}</span></p><p><span>    </span><span>}</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0028 seconds] -->
</div>



<p>We call two functions from <code>TLASIntersect</code> that we have not defined yet.</p>



<p>The first one is particularly interesting: We call <code>IntersectAABB</code>, with a <code>TLASNode*</code> rather than a <code>BVHNode*</code>. To my surprise, this <em>just works</em>. The <code>TLASNode</code> struct has, for the purpose of AABB intersection, the same layout as a <code>BVHNode</code>. And OpenCL doesn’t complain about the pointer type mismatch… Great, for now, but definitely something to keep in mind: Next time this ‘flexibility’ may not be what we expect.</p>



<p>The second function requires more work. Here is the code for <code>InstanceIntersect</code>, based on <code>BVHInstance::Intersect</code> from the CPU code:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f841439366234" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>void</span><span> </span><span>InstanceIntersect</span><span>(</span><span> </span><span>struct</span><span> </span><span>Ray</span><span>*</span><span> </span><span>ray</span><span>,</span><span> </span><span>struct</span><span> </span><span>BVHInstance</span><span>*</span><span> </span><span>bvhInstance</span><span>,</span></p><p><span>    </span><span>int</span><span> </span><span>blasIdx</span><span>,</span><span> </span><span>struct</span><span> </span><span>Tri</span><span>*</span><span> </span><span>tri</span><span>,</span><span> </span><span>struct</span><span> </span><span>BVHNode</span><span>*</span><span> </span><span>bvhNode</span><span>,</span><span> </span><span>uint</span><span>*</span><span> </span><span>triIdx</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>// backup and transform ray using instance transform</span></p><p><span>    </span><span>struct</span><span> </span><span>Ray </span><span>backup</span><span> </span><span>=</span><span> </span><span>*</span><span>ray</span><span>;</span></p><p><span>    </span><span>TransformRay</span><span>(</span><span> </span><span>ray</span><span>,</span><span> </span><span>&amp;bvhInstance</span><span>-&gt;</span><span>invTransform</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>// traverse the BLAS</span></p><p><span>    </span><span>BVHIntersect</span><span>(</span><span> </span><span>ray</span><span>,</span><span> </span><span>blasIdx</span><span>,</span><span> </span><span>tri</span><span>,</span><span> </span><span>bvhNode</span><span>,</span><span> </span><span>triIdx</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>// restore ray without overwriting intersection record</span></p><p><span>    </span><span>backup</span><span>.</span><span>hit</span><span> </span><span>=</span><span> </span><span>ray</span><span>-&gt;</span><span>hit</span><span>;</span></p><p><span>    </span><span>*</span><span>ray</span><span> </span><span>=</span><span> </span><span>backup</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
</div>



<p>This function in turn calls <code>TransformRay</code>, which is defined as follows:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f843121186052" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>void</span><span> </span><span>TransformRay</span><span>(</span><span> </span><span>struct</span><span> </span><span>Ray</span><span>*</span><span> </span><span>ray</span><span>,</span><span> </span><span>float16</span><span>*</span><span> </span><span>invTransform</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>// do the transform</span></p><p><span>    </span><span>ray</span><span>-&gt;</span><span>D</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span></p><p><span>        </span><span>dot</span><span>(</span><span> </span><span>invTransform</span><span>-&gt;</span><span>s012</span><span>,</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span> </span><span>)</span><span>,</span></p><p><span>        </span><span>dot</span><span>(</span><span> </span><span>invTransform</span><span>-&gt;</span><span>s456</span><span>,</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span> </span><span>)</span><span>,</span></p><p><span>        </span><span>dot</span><span>(</span><span> </span><span>invTransform</span><span>-&gt;</span><span>s89A</span><span>,</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span> </span><span>)</span></p><p><span>    </span><span>)</span><span>;</span><span> </span><span>// see TransformVector in template.cpp</span></p><p><span>    </span><span>ray</span><span>-&gt;</span><span>O</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span></p><p><span>        </span><span>dot</span><span>(</span><span> </span><span>invTransform</span><span>-&gt;</span><span>s012</span><span>,</span><span> </span><span>ray</span><span>-&gt;</span><span>O</span><span> </span><span>)</span><span> </span><span>+</span><span> </span><span>invTransform</span><span>-&gt;</span><span>s3</span><span>,</span></p><p><span>        </span><span>dot</span><span>(</span><span> </span><span>invTransform</span><span>-&gt;</span><span>s456</span><span>,</span><span> </span><span>ray</span><span>-&gt;</span><span>O</span><span> </span><span>)</span><span> </span><span>+</span><span> </span><span>invTransform</span><span>-&gt;</span><span>s7</span><span>,</span></p><p><span>        </span><span>dot</span><span>(</span><span> </span><span>invTransform</span><span>-&gt;</span><span>s89A</span><span>,</span><span> </span><span>ray</span><span>-&gt;</span><span>O</span><span> </span><span>)</span><span> </span><span>+</span><span> </span><span>invTransform</span><span>-&gt;</span><span>sB</span></p><p><span>    </span><span>)</span><span>;</span><span> </span><span>// see TransformPosition in template.cpp</span></p><p><span>    </span><span>// update ray direction reciprocals</span></p><p><span>    </span><span>ray</span><span>-&gt;</span><span>rD</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span>1.0f</span><span> </span><span>/</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span>.</span><span>x</span><span>,</span><span> </span><span>1.0f</span><span> </span><span>/</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span>.</span><span>y</span><span>,</span><span> </span><span>1.0f</span><span> </span><span>/</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span>.</span><span>z</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0013 seconds] -->
</div>



<p>This implements the <code>TransformVector</code> and <code>TransformPosition</code> matrix functions we used in the CPU code: In OpenCL, we have to implement these ourselves. </p>



<p>Note how the <code>float16</code> data is addressed here: To make a <code>float3</code> out of cells 0, 1 and 2, we write <code>invTransform-&gt;s012</code>. A same technique is available for all OpenCL vector types. For instance, to access <code>x</code> of <code>ray-&gt;D</code> we can simply write <code>ray-&gt;D.x</code>, but we can also get a <code>float2</code> based on the fields: e.g., <code>ray-&gt;D.xy</code>, but also: <code>ray-&gt;D.xx</code>, which would duplicate the first field, or <code>ray-&gt;D.zyx</code>, which would flip the three available fields and yields a <code>float3</code>. Any combination of x, y and z works. The technique is called <em>swizzling</em>. For a float16, x, y and z are obviously insufficient. In this case the fields are labeled 0..9 and A..F (or a..f, if you prefer that): this is the hexadecimal index of the 16 matrix cells.</p>



<h2>Debugging</h2>



<p>There is a problem with all this new code: <em>it doesn’t work.</em> When that happens, we debug, of course. But in OpenCL that is easier said than done: Breakpoints do not exist, and would be somewhat pointless anyway, considering that the code runs on (potentially) thousands of GPU threads. We do have some tools however. We can for example use <code>printf</code> from a kernel:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f844353769809" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>void</span><span> </span><span>TLASIntersect</span><span>(</span><span> </span><span>struct</span><span> </span><span>Ray</span><span>*</span><span> </span><span>ray</span><span>,</span><span> </span><span>struct</span><span> </span><span>Tri</span><span>*</span><span> </span><span>tri</span><span>,</span><span> </span></p><p><span>    </span><span>struct</span><span> </span><span>BVHInstance</span><span>*</span><span> </span><span>bvhInstance</span><span>,</span><span> </span><span>struct</span><span> </span><span>TLASNode</span><span>*</span><span> </span><span>tlasNode</span><span>,</span><span> </span></p><p><span>    </span><span>struct</span><span> </span><span>BVHNode</span><span>*</span><span> </span><span>bvhNode</span><span>,</span><span> </span><span>uint</span><span>*</span><span> </span><span>triIdx</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>printf</span><span>(</span><span> </span><span>&#34;hello\n&#34;</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
</div>



<p>Besides that, we can visualize assumptions. For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f845149121870" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>float3 </span><span>Trace</span><span>(</span><span> </span><span>struct</span><span> </span><span>Ray</span><span>*</span><span> </span><span>ray</span><span>,</span><span> </span><span>float</span><span>*</span><span> </span><span>skyPixels</span><span>,</span><span> </span><span>struct</span><span> </span><span>Tri</span><span>*</span><span> </span><span>triData</span><span>,</span><span> </span><span>struct</span><span> </span><span>BVHNode</span><span>*</span><span> </span><span>bvhNodeData</span><span>,</span><span> </span><span>uint</span><span>*</span><span> </span><span>idxData</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>// check incoming data</span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>skyPixels</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>||</span><span> </span><span>triData</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>return</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span>1</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>In the latter case, <code>Trace</code> will return a red pixel if we passed it an non-existent <code>skyPixels</code> or <code>triData</code> buffer. Other colors can be used to return information on different problems. Since the visualization is per-pixel, this can yield more detailed information than the <code>printf</code>.</p>



<p>With these limited tools I found several issues. The first is in struct <code>TLASNode</code>, which is very similar to <code>BVHNode</code>, and should thus be ‘just fine’:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f846792935744" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>struct</span><span> </span><span>TLASNode</span></p><p><span>{</span></p><p><span>    </span><span>float</span><span> </span><span>minx</span><span>,</span><span> </span><span>miny</span><span>,</span><span> </span><span>minz</span><span>;</span></p><p><span>    </span><span>uint </span><span>leftRight</span><span>;</span><span> </span><span>// 2x16 bits</span></p><p><span>    </span><span>float</span><span> </span><span>maxx</span><span>,</span><span> </span><span>maxy</span><span>,</span><span> </span><span>maxz</span><span>;</span></p><p><span>    </span><span>uint </span><span>BLAS</span><span>;</span></p><p><span>}</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>If this has you scratching your head: look no further, because the problem is not here, it is in the CPU version of this struct.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f847833054691" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>// top-level BVH node</span></p><p><span>struct</span><span> </span><span>TLASNode</span></p><p><span>{</span></p><p><span>    </span><span>float3 </span><span>aabbMin</span><span>;</span></p><p><span>    </span><span>uint </span><span>leftRight</span><span>;</span></p><p><span>    </span><span>float3 </span><span>aabbMax</span><span>;</span></p><p><span>    </span><span>uint </span><span>BLAS</span><span>;</span></p><p><span>    </span><span>bool</span><span> </span><span>isLeaf</span><span>(</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>leftRight</span><span> </span><span>==</span><span> </span><span>0</span><span>;</span><span> </span><span>}</span></p><p><span>}</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>Now, one would assume that the two structs have the same size. Sadly, they don’t. The <code>float3</code> type takes 16 bytes in OpenCL, and therefore, the CPU-side version mimics this, to ensure data compatibility. We thus have a CPU TLASNode that is substantially larger than 32 bytes.</p>



<p>The problem is quickly resolved by changing the CPU-side struct:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f849909689768" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>// top-level BVH node</span></p><p><span>struct</span><span> </span><span>TLASNode</span></p><p><span>{</span></p><p><span>    </span><span>union</span><span> </span><span>{</span><span> </span><span>struct</span><span> </span><span>{</span><span> </span><span>float</span><span> </span><span>dummy1</span><span>[</span><span>3</span><span>]</span><span>;</span><span> </span><span>uint </span><span>leftRight</span><span>;</span><span> </span><span>}</span><span>;</span><span> </span><span>float3 </span><span>aabbMin</span><span>;</span><span> </span><span>}</span><span>;</span></p><p><span>    </span><span>union</span><span> </span><span>{</span><span> </span><span>struct</span><span> </span><span>{</span><span> </span><span>float</span><span> </span><span>dummy2</span><span>[</span><span>3</span><span>]</span><span>;</span><span> </span><span>uint </span><span>BLAS</span><span>;</span><span> </span><span>}</span><span>;</span><span> </span><span>float3 </span><span>aabbMax</span><span>;</span><span> </span><span>}</span><span>;</span></p><p><span>    </span><span>bool</span><span> </span><span>isLeaf</span><span>(</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>leftRight</span><span> </span><span>==</span><span> </span><span>0</span><span>;</span><span> </span><span>}</span></p><p><span>}</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>That is very ugly, but: Now the two 16-byte structs overlap the <code>float3</code> fields in memory, which causes fields <code>leftRight</code> and <code>BLAS</code> to be exactly in the right location.</p>



<p>After this fix, we still get no useful results out of <code>TLASIntersect</code>. It turns out that there is <em>another </em>problematic struct; this time it is <code>BVHInstance</code>. The struct contains two float16 <code>fields</code>, which have the same size as a <code>mat4</code> in the CPU code. The problem is: OpenCL dictates that any field must be positioned in a struct such that its offset is a multiple of its size. In this case, the size of a <code>float16</code> is 64 bytes; we have only 12 bytes before the first <code>float16</code> and therefore OpenCL will inject 52 unused bytes between field <code>idx</code> and the first transform…</p>



<p>Fixing this is again easier on the CPU side. We modify the <code>BVHInstance</code> struct to:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f84a650912255" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>class</span><span> </span><span>BVHInstance</span></p><p><span>{</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p><p><span>    </span><span>mat4 </span><span>transform</span><span>;</span></p><p><span>    </span><span>mat4 </span><span>invTransform</span><span>;</span><span> </span><span>// inverse transform</span></p><p><span>    </span><span>aabb </span><span>bounds</span><span>;</span><span> </span><span>// in world space</span></p><p><span>    </span><span>BVH</span><span>*</span><span> </span><span>bvh</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>    </span><span>uint </span><span>idx</span><span>;</span></p><p><span>    </span><span>int</span><span> </span><span>dummy</span><span>[</span><span>7</span><span>]</span><span>;</span></p><p><span>}</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>In the new layout, <code>transform</code> and <code>invTransform</code> are properly aligned: <code>transform</code> now has an offset of 0, and <code>invTransform</code> is at offset 64. The array of dummy integers at the end ensures that the size of the whole struct is now a multiple of 64 bytes: This way, in an array of <code>BVHInstances</code> object other than the first also have proper offsets for the <code>float16</code> fields.</p>



<p>With these fixes, we finally have the full TLAS &amp; BLAS functionality on the GPU, albeit without any fancy shading:</p>



<div><figure><img loading="lazy" src="https://jacco.ompf2.com/wp-content/uploads/2022/06/gputlas-1024x516.jpg" alt="" width="768" height="387" srcset="https://jacco.ompf2.com/wp-content/uploads/2022/06/gputlas-1024x516.jpg 1024w, https://jacco.ompf2.com/wp-content/uploads/2022/06/gputlas-300x151.jpg 300w, https://jacco.ompf2.com/wp-content/uploads/2022/06/gputlas-768x387.jpg 768w, https://jacco.ompf2.com/wp-content/uploads/2022/06/gputlas-1222x616.jpg 1222w, https://jacco.ompf2.com/wp-content/uploads/2022/06/gputlas-897x452.jpg 897w, https://jacco.ompf2.com/wp-content/uploads/2022/06/gputlas-360x181.jpg 360w, https://jacco.ompf2.com/wp-content/uploads/2022/06/gputlas.jpg 1256w" sizes="(max-width: 768px) 100vw, 768px"/></figure></div>



<h2>Restoring Light</h2>



<p>The hard part is now done. Adding some shading is a matter of porting the body of the <code>Trace</code> function. This should not have too many surprises:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f84b591072339" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p></div>
				</td>
						<td><div><p><span>float3 </span><span>Trace</span><span>(</span><span> </span><span>struct</span><span> </span><span>Ray</span><span>*</span><span> </span><span>ray</span><span>,</span><span> </span><span>float</span><span>*</span><span> </span><span>skyPixels</span><span>,</span><span> </span></p><p><span>    </span><span>struct</span><span> </span><span>BVHInstance</span><span>*</span><span> </span><span>instData</span><span>,</span><span> </span><span>struct</span><span> </span><span>TLASNode</span><span>*</span><span> </span><span>tlasData</span><span>,</span></p><p><span>    </span><span>uint</span><span>*</span><span> </span><span>texData</span><span>,</span><span> </span><span>struct</span><span> </span><span>Tri</span><span>*</span><span> </span><span>triData</span><span>,</span><span> </span><span>struct</span><span> </span><span>TriEx</span><span>*</span><span> </span><span>triExData</span><span>,</span></p><p><span>    </span><span>struct</span><span> </span><span>BVHNode</span><span>*</span><span> </span><span>bvhNodeData</span><span>,</span><span> </span><span>uint</span><span>*</span><span> </span><span>idxData</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>TLASIntersect</span><span>(</span><span> </span><span>ray</span><span>,</span><span> </span><span>triData</span><span>,</span><span> </span><span>instData</span><span>,</span><span> </span><span>tlasData</span><span>,</span><span> </span><span>bvhNodeData</span><span>,</span><span> </span><span>idxData</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>struct</span><span> </span><span>Intersection</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>ray</span><span>-&gt;</span><span>hit</span><span>;</span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>i</span><span>.</span><span>t</span><span> </span><span>==</span><span> </span><span>1e30f</span><span>)</span></p><p><span>    </span><span>{</span></p><p><span>        </span><span>// sample sky</span></p><p><span>        </span><span>.</span><span>.</span><span>.</span></p><p><span>    </span><span>}</span></p><p><span>    </span><span>// calculate texture uv based on barycentrics</span></p><p><span>    </span><span>uint </span><span>triIdx</span><span> </span><span>=</span><span> </span><span>i</span><span>.</span><span>instPrim</span><span> </span><span>&amp;</span><span> </span><span>0xfffff</span><span>;</span></p><p><span>    </span><span>uint </span><span>instIdx</span><span> </span><span>=</span><span> </span><span>i</span><span>.</span><span>instPrim</span><span> </span><span>&gt;&gt;</span><span> </span><span>20</span><span>;</span></p><p><span>    </span><span>struct</span><span> </span><span>TriEx</span><span>*</span><span> </span><span>tri</span><span> </span><span>=</span><span> </span><span>triExData</span><span> </span><span>+</span><span> </span><span>triIdx</span><span>;</span></p><p><span>    </span><span>float2 </span><span>uv</span><span> </span><span>=</span><span> </span><span>i</span><span>.</span><span>u</span><span> </span><span>*</span><span> </span><span>tri</span><span>-&gt;</span><span>uv1</span><span> </span><span>+</span><span> </span><span>i</span><span>.</span><span>v</span><span> </span><span>*</span><span> </span><span>tri</span><span>-&gt;</span><span>uv2</span><span> </span><span>+</span><span> </span><span>(</span><span>1</span><span> </span><span>-</span><span> </span><span>(</span><span>i</span><span>.</span><span>u</span><span> </span><span>+</span><span> </span><span>i</span><span>.</span><span>v</span><span>)</span><span>)</span><span> </span><span>*</span><span> </span><span>tri</span><span>-&gt;</span><span>uv0</span><span>;</span></p><p><span>    </span><span>int</span><span> </span><span>iu</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>(</span><span>uv</span><span>.</span><span>x</span><span> </span><span>*</span><span> </span><span>1024</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>1023</span><span>;</span></p><p><span>    </span><span>int</span><span> </span><span>iv</span><span> </span><span>=</span><span> </span><span>(</span><span>int</span><span>)</span><span>(</span><span>uv</span><span>.</span><span>y</span><span> </span><span>*</span><span> </span><span>1024</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>1023</span><span>;</span></p><p><span>    </span><span>uint </span><span>texel</span><span> </span><span>=</span><span> </span><span>texData</span><span>[</span><span>iu</span><span> </span><span>+</span><span> </span><span>(</span><span>iv</span><span> </span><span>&lt;&lt;</span><span> </span><span>10</span><span>)</span><span>]</span><span>;</span></p><p><span>    </span><span>float3 </span><span>albedo</span><span> </span><span>=</span><span> </span><span>RGB8toRGB32F</span><span>(</span><span> </span><span>texel</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>// calculate the normal for the intersection</span></p><p><span>    </span><span>float3 </span><span>N0</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span> </span><span>tri</span><span>-&gt;</span><span>N0x</span><span>,</span><span> </span><span>tri</span><span>-&gt;</span><span>N0y</span><span>,</span><span> </span><span>tri</span><span>-&gt;</span><span>N0z</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>float3 </span><span>N1</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span> </span><span>tri</span><span>-&gt;</span><span>N1x</span><span>,</span><span> </span><span>tri</span><span>-&gt;</span><span>N1y</span><span>,</span><span> </span><span>tri</span><span>-&gt;</span><span>N1z</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>float3 </span><span>N2</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span> </span><span>tri</span><span>-&gt;</span><span>N2x</span><span>,</span><span> </span><span>tri</span><span>-&gt;</span><span>N2y</span><span>,</span><span> </span><span>tri</span><span>-&gt;</span><span>N2z</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>float3</span><span> </span><span>N</span><span> </span><span>=</span><span> </span><span>i</span><span>.</span><span>u</span><span> </span><span>*</span><span> </span><span>N1</span><span> </span><span>+</span><span> </span><span>i</span><span>.</span><span>v</span><span> </span><span>*</span><span> </span><span>N2</span><span> </span><span>+</span><span> </span><span>(</span><span>1</span><span> </span><span>-</span><span> </span><span>(</span><span>i</span><span>.</span><span>u</span><span> </span><span>+</span><span> </span><span>i</span><span>.</span><span>v</span><span>)</span><span>)</span><span> </span><span>*</span><span> </span><span>N0</span><span>;</span></p><p><span>    </span><span>N</span><span> </span><span>=</span><span> </span><span>normalize</span><span>(</span><span> </span><span>TransformVector</span><span>(</span><span> </span><span>&amp;N</span><span>,</span><span> </span><span>&amp;instData</span><span>[</span><span>instIdx</span><span>]</span><span>.</span><span>transform</span><span> </span><span>)</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>float3</span><span> </span><span>I</span><span> </span><span>=</span><span> </span><span>ray</span><span>-&gt;</span><span>O</span><span> </span><span>+</span><span> </span><span>i</span><span>.</span><span>t</span><span> </span><span>*</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span>;</span></p><p><span>    </span><span>// calculate the diffuse reflection in the intersection point</span></p><p><span>    </span><span>float3</span><span> </span><span>L</span><span> </span><span>=</span><span> </span><span>lightPos</span><span> </span><span>-</span><span> </span><span>I</span><span>;</span></p><p><span>    </span><span>float</span><span> </span><span>dist</span><span> </span><span>=</span><span> </span><span>length</span><span>(</span><span> </span><span>L</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>L</span><span> </span><span>*=</span><span> </span><span>1.0f</span><span> </span><span>/</span><span> </span><span>dist</span><span>;</span></p><p><span>    </span><span>return</span><span> </span><span>albedo</span><span> </span><span>*</span><span> </span><span>(</span><span>ambient</span><span> </span><span>+</span><span> </span><span>max</span><span>(</span><span> </span><span>0.0f</span><span>,</span><span> </span><span>dot</span><span>(</span><span> </span><span>N</span><span>,</span><span> </span><span>L</span><span> </span><span>)</span><span> </span><span>)</span><span> </span><span>*</span><span> </span><span>lightColor</span><span> </span><span>*</span><span> </span><span>(</span><span>1.0f</span><span> </span><span>/</span><span> </span><span>(</span><span>dist</span><span> </span><span>*</span><span> </span><span>dist</span><span>)</span><span>)</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0036 seconds] -->
</div>



<p>Note that the size of the brick texture is now hardcoded. We’ll want to change that at a later stage, to make the renderer more versatile. The light source is also still very much hardcoded, as it was in the CPU version. The three constants for the light source can be defined at global scope, somewhere above the <code>Trace</code> function:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f84d539874187" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>__constant </span><span>float3 </span><span>lightPos</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span>3</span><span>,</span><span> </span><span>10</span><span>,</span><span> </span><span>2</span><span>)</span><span>;</span></p><p><span>__constant </span><span>float3 </span><span>lightColor</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span>150</span><span>,</span><span> </span><span>150</span><span>,</span><span> </span><span>120</span><span>)</span><span>;</span></p><p><span>__constant </span><span>float3 </span><span>ambient</span><span> </span><span>=</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span>0.2f</span><span>,</span><span> </span><span>0.2f</span><span>,</span><span> </span><span>0.4f</span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
</div>



<p>To convert pixels read from the texture to float3 we also need a port of the <code>RGB8toRGB32F</code> function. It’s straightforward, and should go to <code>tools.cl</code>:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f84e526792481" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>float3 </span><span>RGB8toRGB32F</span><span>(</span><span> </span><span>uint</span><span> </span><span>c</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>float</span><span> </span><span>s</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>/</span><span> </span><span>256.0f</span><span>;</span></p><p><span>    </span><span>int</span><span> </span><span>r</span><span> </span><span>=</span><span> </span><span>(</span><span>c</span><span> </span><span>&gt;&gt;</span><span> </span><span>16</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>255</span><span>;</span></p><p><span>    </span><span>int</span><span> </span><span>g</span><span> </span><span>=</span><span> </span><span>(</span><span>c</span><span> </span><span>&gt;&gt;</span><span> </span><span>8</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>255</span><span>;</span></p><p><span>    </span><span>int</span><span> </span><span>b</span><span> </span><span>=</span><span> </span><span>c</span><span> </span><span>&amp;</span><span> </span><span>255</span><span>;</span></p><p><span>    </span><span>return</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span>r</span><span> </span><span>*</span><span> </span><span>s</span><span>,</span><span> </span><span>g</span><span> </span><span>*</span><span> </span><span>s</span><span>,</span><span> </span><span>b</span><span> </span><span>*</span><span> </span><span>s</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
</div>



<p>And finally, transforming the normal vector using the matrix for the intersected instance now uses a new function <code>TransformVector</code>, which in hindsight would come in handy in the <code>TransformRay</code> function as well. It is defined as:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f84f780748983" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>float3 </span><span>TransformVector</span><span>(</span><span> </span><span>float3</span><span>*</span><span> </span><span>V</span><span>,</span><span> </span><span>float16</span><span>*</span><span> </span><span>T</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>return</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span> </span><span>dot</span><span>(</span><span> </span><span>T</span><span>-&gt;</span><span>s012</span><span>,</span><span> </span><span>*</span><span>V</span><span> </span><span>)</span><span>,</span><span> </span><span>dot</span><span>(</span><span> </span><span>T</span><span>-&gt;</span><span>s456</span><span>,</span><span> </span><span>*</span><span>V</span><span> </span><span>)</span><span>,</span><span> </span><span>dot</span><span>(</span><span> </span><span>T</span><span>-&gt;</span><span>s89A</span><span>,</span><span> </span><span>*</span><span>V</span><span> </span><span>)</span><span> </span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
</div>



<p>And with that we have properly textured and illuminated dragons.</p>



<div><figure><img loading="lazy" src="https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonslit-1024x540.jpg" alt="" width="768" height="405" srcset="https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonslit-1024x540.jpg 1024w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonslit-300x158.jpg 300w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonslit-768x405.jpg 768w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonslit-1222x645.jpg 1222w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonslit-897x473.jpg 897w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonslit-360x190.jpg 360w, https://jacco.ompf2.com/wp-content/uploads/2022/06/dragonslit.jpg 1258w" sizes="(max-width: 768px) 100vw, 768px"/></figure></div>



<h2>Mirror Mirror</h2>



<p>The next challenge for the OpenCL port of the recursive ray tracer is: Recursion, which we need for mirrors, as well as glass and water (<em>dielectrics</em>). There is however a problem with recursion in OpenCL: <em>It is forbidden</em>. Yet, in the original <code>::Trace</code> function on the CPU, it was rather instrumental to our needs:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f850028012403" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p></div>
				</td>
						<td><div><p><span>float3 </span><span>WhittedApp</span><span>::</span><span>Trace</span><span>(</span><span> </span><span>Ray</span><span>&amp;</span><span> </span><span>ray</span><span>,</span><span> </span><span>int</span><span> </span><span>rayDepth</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>mirror</span><span>)</span></p><p><span>    </span><span>{</span><span>	</span></p><p><span>        </span><span>// calculate the specular reflection in the intersection point</span></p><p><span>        </span><span>Ray </span><span>secondary</span><span>;</span></p><p><span>        </span><span>secondary</span><span>.</span><span>D</span><span> </span><span>=</span><span> </span><span>ray</span><span>.</span><span>D</span><span> </span><span>-</span><span> </span><span>2</span><span> </span><span>*</span><span> </span><span>N</span><span> </span><span>*</span><span> </span><span>dot</span><span>(</span><span> </span><span>N</span><span>,</span><span> </span><span>ray</span><span>.</span><span>D</span><span> </span><span>)</span><span>;</span></p><p><span>        </span><span>secondary</span><span>.</span><span>O</span><span> </span><span>=</span><span> </span><span>I</span><span> </span><span>+</span><span> </span><span>secondary</span><span>.</span><span>D</span><span> </span><span>*</span><span> </span><span>0.001f</span><span>;</span></p><p><span>        </span><span>secondary</span><span>.</span><span>hit</span><span>.</span><span>t</span><span> </span><span>=</span><span> </span><span>1e30f</span><span>;</span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>rayDepth</span><span> </span><span>&gt;=</span><span> </span><span>10</span><span>)</span><span> </span><span>return</span><span> </span><span>float3</span><span>(</span><span> </span><span>0</span><span> </span><span>)</span><span>;</span></p><p><span>        </span><span>return</span><span> </span><span>Trace</span><span>(</span><span> </span><span>secondary</span><span>,</span><span> </span><span>rayDepth</span><span> </span><span>+</span><span> </span><span>1</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>}</span></p><p><span>    </span><span>else</span></p><p><span>    </span><span>{</span></p><p><span>        </span><span>// calculate the diffuse reflection in the intersection point</span></p><p><span>        </span><span>.</span><span>.</span><span>.</span></p><p><span>    </span><span>}</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0019 seconds] -->
</div>



<p>The highlighted line (line 12) calls the <code>Trace</code> function itself with a just constructed <em>secondary ray</em>, which starts at the intersection point, and extends into the direction calculated using the specular reflection formula on line 8.</p>



<p>Luckily, we have ways to bypass recursion. We already did this to traverse the BVH: Instead of calling <code>BVHIntersect</code> for the left and right child nodes, we switch processing to the nearest child node, while we push the far node on a stack. And, whenever we would normally return, we now pop work from the stack, until the stack is empty.</p>



<p>We can deploy the same scheme here. Except, it will be simpler: Until we add glass or water, the path of a ray does not split up. It ends whenever we hit the skydome, but also when we hit a diffuse object. Only when we hit a reflective dragon we bounce, but in that case we can just restart the Trace function after replacing the original ray by a reflected ray. Like this:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f851088188170" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p></div>
				</td>
						<td><div><p><span>float3 </span><span>Trace</span><span>(</span><span> </span><span>.</span><span>.</span><span>.</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>int</span><span> </span><span>rayDepth</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>    </span><span>// bounce until we hit the sky or a diffuse surface</span></p><p><span>    </span><span>while</span><span> </span><span>(</span><span>rayDepth</span><span> </span><span>&lt;</span><span> </span><span>10</span><span>)</span></p><p><span>    </span><span>{</span></p><p><span>        </span><span>TLASIntersect</span><span>(</span><span> </span><span>ray</span><span>,</span><span> </span><span>.</span><span>.</span><span>.</span><span> </span><span>)</span><span>;</span></p><p><span>        </span><span>struct</span><span> </span><span>Intersection</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>ray</span><span>-&gt;</span><span>hit</span><span>;</span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>i</span><span>.</span><span>t</span><span> </span><span>==</span><span> </span><span>1e30f</span><span>)</span></p><p><span>        </span><span>{</span></p><p><span>            </span><span>// sample sky</span></p><p><span>            </span><span>.</span><span>.</span><span>.</span></p><p><span>            </span><span>return</span><span> </span><span>.</span><span>.</span><span>.</span><span> </span><span>;</span></p><p><span>        </span><span>}</span></p><p><span>        </span><span>.</span><span>.</span><span>.</span><span>           </span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>mirror</span><span>)</span></p><p><span>        </span><span>{</span></p><p><span>            </span><span>// calculate the specular reflection in the intersection point</span></p><p><span>            </span><span>ray</span><span>-&gt;</span><span>D</span><span> </span><span>=</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span> </span><span>-</span><span> </span><span>2</span><span> </span><span>*</span><span> </span><span>N</span><span> </span><span>*</span><span> </span><span>dot</span><span>(</span><span> </span><span>N</span><span>,</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span> </span><span>)</span><span>;</span></p><p><span>            </span><span>ray</span><span>-&gt;</span><span>O</span><span> </span><span>=</span><span> </span><span>I</span><span> </span><span>+</span><span> </span><span>ray</span><span>-&gt;</span><span>D</span><span> </span><span>*</span><span> </span><span>0.001f</span><span>;</span></p><p><span>            </span><span>ray</span><span>-&gt;</span><span>hit</span><span>.</span><span>t</span><span> </span><span>=</span><span> </span><span>1e30f</span><span>;</span></p><p><span>            </span><span>rayDepth</span><span>++</span><span>;</span></p><p><span>        </span><span>}</span></p><p><span>        </span><span>else</span></p><p><span>        </span><span>{</span></p><p><span>            </span><span>// calculate the diffuse reflection in the intersection point</span></p><p><span>            </span><span>return</span><span> </span><span>.</span><span>.</span><span>.</span><span> </span><span>;</span></p><p><span>        </span><span>}</span></p><p><span>    </span><span>}</span></p><p><span>    </span><span>return</span><span> </span><span>(</span><span>float3</span><span>)</span><span>(</span><span> </span><span>1</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>1</span><span> </span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0014 seconds] -->
</div>



<p>Basically, this loop makes a ray bounce around, until it does <em>not </em>hit a mirror. Of course we need to be careful with infinite ‘recursion’ (in this case: an infinite loop). So, we keep track of the ‘bounce depth’ and once it exceeds a certain value, we terminate the loop. In that case the last surface we hit must have been a mirror; we thus return white, i.e. <code>(float3)(1, 1, 1)</code>, which is probably better than any other color.</p>



<p>The scheme is quite effective, and brings back the shiny dragons:</p>



<div><figure><img loading="lazy" src="https://jacco.ompf2.com/wp-content/uploads/2022/06/shiny-1024x486.jpg" alt="" width="768" height="365" srcset="https://jacco.ompf2.com/wp-content/uploads/2022/06/shiny-1024x486.jpg 1024w, https://jacco.ompf2.com/wp-content/uploads/2022/06/shiny-300x142.jpg 300w, https://jacco.ompf2.com/wp-content/uploads/2022/06/shiny-768x364.jpg 768w, https://jacco.ompf2.com/wp-content/uploads/2022/06/shiny-1222x580.jpg 1222w, https://jacco.ompf2.com/wp-content/uploads/2022/06/shiny-897x426.jpg 897w, https://jacco.ompf2.com/wp-content/uploads/2022/06/shiny-360x171.jpg 360w, https://jacco.ompf2.com/wp-content/uploads/2022/06/shiny.jpg 1260w" sizes="(max-width: 768px) 100vw, 768px"/></figure></div>



<h2>MASSIVE</h2>



<p>One advantage of ray tracing is how it handles massive scenes. For simple scenes, traditional rasterization is typically a lot faster, but at some point, the tables turn. This has everything to do with the BVH: once build (that’s a rather important condition!), a BVH over <span data-display="false">N</span> triangles requires on average <span data-display="false">log_2 N</span> steps to get from the root of the tree to a leaf node. For 1,000 triangles we get to a single leaf in 10 steps; for 1,000,000 we get there in 20 steps: Twice the cost, for a thousand times the complexity. Even a <em>billion</em> triangles is doable; this only take three times more work than one thousand.</p>



<p>To put that to the test we will create a scene, in which every vertex of the dragon model is replaced by a dragon. The dragon has 11,042 vertices, and 19,332 polygons; the scene thus will have a bit more than 213 million triangles. You’ll have to believe me when I say that adding another zero to that number will hardly matter.</p>



<p>The scene is constructed in the <code>::Init()</code> function:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f853919213617" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>MassiveApp</span><span>::</span><span>Init</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>mesh</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Mesh</span><span>(</span><span> </span><span>&#34;assets/dragon.obj&#34;</span><span>,</span><span> </span><span>&#34;assets/bricks.png&#34;</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>// load HDR sky</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p><p><span>    </span><span>// dragons in the shape of a dragon</span></p><p><span>    </span><span>bvhInstance</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>BVHInstance</span><span>[</span><span>11042</span><span>]</span><span>;</span></p><p><span>    </span><span>for</span><span>(</span><span> </span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>11042</span><span>;</span><span> </span><span>i</span><span>++</span><span> </span><span>)</span></p><p><span>    </span><span>{</span></p><p><span>        </span><span>bvhInstance</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>BVHInstance</span><span>(</span><span> </span><span>mesh</span><span>-&gt;</span><span>bvh</span><span>,</span><span> </span><span>i</span><span> </span><span>)</span><span>;</span></p><p><span>        </span><span>bvhInstance</span><span>[</span><span>i</span><span>]</span><span>.</span><span>SetTransform</span><span>(</span><span> </span></p><p><span>            </span><span>mat4</span><span>::</span><span>Translate</span><span>(</span><span> </span><span>mesh</span><span>-&gt;</span><span>P</span><span>[</span><span>i</span><span>]</span><span> </span><span>*</span><span> </span><span>0.2f</span><span> </span><span>)</span><span> </span><span>*</span><span> </span></p><p><span>            </span><span>mat4</span><span>::</span><span>Scale</span><span>(</span><span> </span><span>0.0025f</span><span>  </span><span>)</span><span> </span><span>*</span></p><p><span>            </span><span>mat4</span><span>::</span><span>Rotate</span><span>(</span><span> </span><span>mesh</span><span>-&gt;</span><span>N</span><span>[</span><span>i</span><span>]</span><span>,</span><span> </span><span>0</span><span> </span><span>)</span><span> </span><span>*</span></p><p><span>            </span><span>mat4</span><span>::</span><span>RotateX</span><span>(</span><span> </span><span>PI</span><span> </span><span>/</span><span> </span><span>2</span><span> </span><span>)</span></p><p><span>        </span><span>)</span><span>;</span></p><p><span>    </span><span>}</span></p><p><span>    </span><span>tlas</span><span> </span><span>=</span><span> </span><span>TLAS</span><span>(</span><span> </span><span>bvhInstance</span><span>,</span><span> </span><span>11042</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>tlas</span><span>.</span><span>Build</span><span>(</span><span>)</span><span>;</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0025 seconds] -->
</div>



<p>To make that work, the <code>BVHInstance</code> array in the application class definition in <code>massive.h</code> is changed to a pointer:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f854667625419" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>    </span><span>BVHInstance</span><span>*</span><span> </span><span>bvhInstance</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The <code>::Init()</code> function needs access to vertex positions and normals. These were stored in local arrays (<code>P</code> and <code>N</code>) in the <code>Mesh</code> constructor. We add pointers to this data to the <code>Mesh</code> class, and make a small change to the <code>Mesh</code> constructor:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f855188484170" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>Mesh</span><span>::</span><span>Mesh</span><span>(</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>objFile</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>texFile</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>// bare-bones obj file loader; only supports very basic meshes</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p><p><span>    </span><span>N</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>float3</span><span>[</span><span>11043</span><span>]</span><span>,</span><span> </span><span>P</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>float3</span><span>[</span><span>11043</span><span>]</span><span>;</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
</div>



<p>Tiny but important detail: Indices in obj files start at 1; we thus either make the arrays 1 element larger, or subtract 1 from every index that we use – hence the 11043 figure.</p>



<p>We are almost ready to show the scene: The scene is constructed, the (single) BLAS for the 11,042 dragon instances is built, and we have a TLAS – which constructs in about half a second on my machine. Half a second: That means the TLAS will have to be static, for now. We thus build it and copy it once to the GPU, in the <code>::Init()</code> function. The <code>tlasData-&gt;CopyToDevice()</code> and <code>instData-&gt;CopyToDevice()</code> commands can now also be moved to ::Init(); we will render a static scene.</p>



<p>If you typed along, you now have a ‘dragon of dragons’, and it runs at a respectable speed.</p>



<h2>Camera</h2>



<p>Such a scene deserves a proper view.</p>



<p>For that, we will move the camera along a smooth path. The <a href="https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html">Catmull-Rom spline</a> is ideal for this: it is smooth, and moves through a series of points.</p>



<div><figure><img loading="lazy" src="https://jacco.ompf2.com/wp-content/uploads/2022/06/Catmull-Rom_Spline.png" alt="" width="321" height="189" srcset="https://jacco.ompf2.com/wp-content/uploads/2022/06/Catmull-Rom_Spline.png 642w, https://jacco.ompf2.com/wp-content/uploads/2022/06/Catmull-Rom_Spline-300x177.png 300w, https://jacco.ompf2.com/wp-content/uploads/2022/06/Catmull-Rom_Spline-360x212.png 360w" sizes="(max-width: 321px) 100vw, 321px"/><figcaption>One segment of the Catmull-Rom spline, from <span data-display="false">P_1</span> to <span data-display="false">P_2</span>: we need <span data-display="false">P_0</span> and <span data-display="false">P_3</span> to define the direction at <span data-display="false">P_1</span> and <span data-display="false">P_2</span>.</figcaption></figure></div>



<p>Given <span data-display="false">P_0 .. P_3</span>, we can find a point on the segment <span data-display="false">P_1 .. P_2</span> with the following code:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f858245952391" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>float3 </span><span>CatmullRom</span><span>(</span><span> </span><span>float</span><span> </span><span>t</span><span>,</span><span> </span><span>float3</span><span>&amp;</span><span> </span><span>p0</span><span>,</span><span> </span><span>float3</span><span>&amp;</span><span> </span><span>p1</span><span>,</span><span> </span><span>float3</span><span>&amp;</span><span> </span><span>p2</span><span>,</span><span> </span><span>float3</span><span>&amp;</span><span> </span><span>p3</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>float3</span><span> </span><span>c</span><span> </span><span>=</span><span> </span><span>2</span><span> </span><span>*</span><span> </span><span>p0</span><span> </span><span>-</span><span> </span><span>5</span><span> </span><span>*</span><span> </span><span>p1</span><span> </span><span>+</span><span> </span><span>4</span><span> </span><span>*</span><span> </span><span>p2</span><span> </span><span>-</span><span> </span><span>p3</span><span>,</span><span> </span><span>d</span><span> </span><span>=</span><span> </span><span>3</span><span> </span><span>*</span><span> </span><span>(</span><span>p1</span><span> </span><span>-</span><span> </span><span>p2</span><span>)</span><span> </span><span>+</span><span> </span><span>p3</span><span> </span><span>-</span><span> </span><span>p0</span><span>;</span></p><p><span>    </span><span>return</span><span> </span><span>0.5f</span><span> </span><span>*</span><span> </span><span>(</span><span>2</span><span> </span><span>*</span><span> </span><span>p1</span><span> </span><span>+</span><span> </span><span>(</span><span>(</span><span>p2</span><span> </span><span>-</span><span> </span><span>p0</span><span>)</span><span> </span><span>*</span><span> </span><span>t</span><span>)</span><span> </span><span>+</span><span> </span><span>(</span><span>c</span><span> </span><span>*</span><span> </span><span>t</span><span> </span><span>*</span><span> </span><span>t</span><span>)</span><span> </span><span>+</span><span> </span><span>(</span><span>d</span><span> </span><span>*</span><span> </span><span>t</span><span> </span><span>*</span><span> </span><span>t</span><span> </span><span>*</span><span> </span><span>t</span><span>)</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0636 seconds] -->
</div>



<p>By varying <span data-display="false">t</span> from 0..1, this function allows us to smoothly travel the curve. Once we reach <span data-display="false">t=1</span> (or <span data-display="false">t=0</span>, if we move backwards), we simply select the next set of four points on the curve; this way, the smooth path can consist of any number of points.</p>



<p>Let’s take this one step further: If we move not just the camera over a smooth curve, but also a <em>point at which the camera is aimed</em>, we get a pretty versatile camera system. Consider the following set of points:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f859590031493" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p></div>
				</td>
						<td><div><p><span>float3 </span><span>spline</span><span>[</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>1.32</span><span>,</span><span> </span><span>11.35</span><span>,</span><span> </span><span>0.31</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>0.35</span><span>,</span><span> </span><span>11.56</span><span>,</span><span> </span><span>0.18</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>0.92</span><span>,</span><span> </span><span>11.35</span><span>,</span><span> </span><span>2.92</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>1.58</span><span>,</span><span> </span><span>11.55</span><span>,</span><span> </span><span>2.19</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>5.51</span><span>,</span><span> </span><span>13.43</span><span>,</span><span> </span><span>4.96</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>5.82</span><span>,</span><span> </span><span>13.63</span><span>,</span><span> </span><span>4.03</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>10.90</span><span>,</span><span> </span><span>13.48</span><span>,</span><span> </span><span>4.53</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>10.39</span><span>,</span><span> </span><span>13.68</span><span>,</span><span> </span><span>3.69</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>13.15</span><span>,</span><span> </span><span>15.33</span><span>,</span><span> </span><span>2.21</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>12.20</span><span>,</span><span> </span><span>15.52</span><span>,</span><span> </span><span>1.96</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>12.44</span><span>,</span><span> </span><span>15.33</span><span>,</span><span> </span><span>-</span><span>1.92</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>11.92</span><span>,</span><span> </span><span>15.51</span><span>,</span><span> </span><span>-</span><span>1.08</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>8.17</span><span>,</span><span> </span><span>15.48</span><span>,</span><span> </span><span>-</span><span>4.71</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>7.32</span><span>,</span><span> </span><span>15.38</span><span>,</span><span> </span><span>-</span><span>4.19</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>0.19</span><span>,</span><span> </span><span>13.22</span><span>,</span><span> </span><span>-</span><span>6.09</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>0.31</span><span>,</span><span> </span><span>12.72</span><span>,</span><span> </span><span>-</span><span>5.38</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>8.44</span><span>,</span><span> </span><span>8.37</span><span>,</span><span> </span><span>-</span><span>5.22</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>8.01</span><span>,</span><span> </span><span>7.81</span><span>,</span><span> </span><span>-</span><span>4.52</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>14.31</span><span>,</span><span> </span><span>4.71</span><span>,</span><span> </span><span>-</span><span>1.89</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>13.40</span><span>,</span><span> </span><span>4.46</span><span>,</span><span> </span><span>-</span><span>1.56</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>11.81</span><span>,</span><span> </span><span>4.97</span><span>,</span><span> </span><span>6.36</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>11.19</span><span>,</span><span> </span><span>4.65</span><span>,</span><span> </span><span>5.64</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>10.57</span><span>,</span><span> </span><span>4.58</span><span>,</span><span> </span><span>5.19</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>9.85</span><span>,</span><span> </span><span>4.39</span><span>,</span><span> </span><span>4.52</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>7.33</span><span>,</span><span> </span><span>4.66</span><span>,</span><span> </span><span>2.14</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>6.61</span><span>,</span><span> </span><span>4.59</span><span>,</span><span> </span><span>1.45</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>6.01</span><span>,</span><span> </span><span>4.77</span><span>,</span><span> </span><span>0.68</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>5.28</span><span>,</span><span> </span><span>4.70</span><span>,</span><span> </span><span>0</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>3.00</span><span>,</span><span> </span><span>4.48</span><span>,</span><span> </span><span>-</span><span>2.16</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>2.27</span><span>,</span><span> </span><span>4.42</span><span>,</span><span> </span><span>-</span><span>2.85</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>1.53</span><span>,</span><span> </span><span>4.27</span><span>,</span><span> </span><span>-</span><span>5.49</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>1.89</span><span>,</span><span> </span><span>4.21</span><span>,</span><span> </span><span>-</span><span>4.56</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>3.63</span><span>,</span><span> </span><span>4.12</span><span>,</span><span> </span><span>-</span><span>3.77</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>3.80</span><span>,</span><span> </span><span>4.06</span><span>,</span><span> </span><span>-</span><span>2.78</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>4.97</span><span>,</span><span> </span><span>3.97</span><span>,</span><span> </span><span>2.62</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>5.38</span><span>,</span><span> </span><span>3.98</span><span>,</span><span> </span><span>3.53</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>9.38</span><span>,</span><span> </span><span>3.97</span><span>,</span><span> </span><span>7.47</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>8.92</span><span>,</span><span> </span><span>3.98</span><span>,</span><span> </span><span>6.59</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>16.17</span><span>,</span><span> </span><span>5.36</span><span>,</span><span> </span><span>7.89</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>15.37</span><span>,</span><span> </span><span>5.37</span><span>,</span><span> </span><span>7.29</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>27.30</span><span>,</span><span> </span><span>10.08</span><span>,</span><span> </span><span>-</span><span>1.143</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>26.33</span><span>,</span><span> </span><span>10.00</span><span>,</span><span> </span><span>-</span><span>0.89</span><span> </span><span>)</span><span>,</span></p><p><span>    </span><span>float3</span><span>(</span><span> </span><span>-</span><span>30.81</span><span>,</span><span> </span><span>10.88</span><span>,</span><span> </span><span>-</span><span>13.78</span><span> </span><span>)</span><span>,</span><span> </span><span>float3</span><span>(</span><span> </span><span>-</span><span>29.94</span><span>,</span><span> </span><span>10.80</span><span>,</span><span> </span><span>-</span><span>13.30</span><span> </span><span>)</span></p><p><span>}</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0077 seconds] -->
</div>



<p>Each pair in this array contains one camera position (on the left) and a camera target (on the right). I obtained these points by manually navigating the scene, and recording 20 points to a file. The code for that is left in the program; feel free to replace the spline with a new path.</p>



<p>The camera can now be updated in the <code>::Tick()</code> function, with a little help from the new <code>SplineCam</code> function:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f85a235938628" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p></div>
				</td>
						<td><div><p><span>void</span><span> </span><span>SplineCam</span><span>(</span><span> </span><span>int</span><span> </span><span>seg</span><span>,</span><span> </span><span>float</span><span> </span><span>t</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>float3 </span><span>c0</span><span> </span><span>=</span><span> </span><span>spline</span><span>[</span><span>seg</span><span> </span><span>*</span><span> </span><span>2</span><span> </span><span>-</span><span> </span><span>2</span><span>]</span><span>,</span></p><p><span>           </span><span>c1</span><span> </span><span>=</span><span> </span><span>spline</span><span>[</span><span>seg</span><span> </span><span>*</span><span> </span><span>2</span><span>]</span><span>,</span></p><p><span>           </span><span>c2</span><span> </span><span>=</span><span> </span><span>spline</span><span>[</span><span>seg</span><span> </span><span>*</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>2</span><span>]</span><span>,</span><span> </span></p><p><span>           </span><span>c3</span><span> </span><span>=</span><span> </span><span>spline</span><span>[</span><span>seg</span><span> </span><span>*</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>4</span><span>]</span><span>;</span></p><p><span>    </span><span>float3 </span><span>t0</span><span> </span><span>=</span><span> </span><span>spline</span><span>[</span><span>seg</span><span> </span><span>*</span><span> </span><span>2</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span>,</span><span> </span></p><p><span>           </span><span>t1</span><span> </span><span>=</span><span> </span><span>spline</span><span>[</span><span>seg</span><span> </span><span>*</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>1</span><span>]</span><span>,</span><span> </span></p><p><span>           </span><span>t2</span><span> </span><span>=</span><span> </span><span>spline</span><span>[</span><span>seg</span><span> </span><span>*</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>3</span><span>]</span><span>,</span><span> </span></p><p><span>           </span><span>t3</span><span> </span><span>=</span><span> </span><span>spline</span><span>[</span><span>seg</span><span> </span><span>*</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>5</span><span>]</span><span>;</span></p><p><span>    </span><span>camPos</span><span> </span><span>=</span><span> </span><span>CatmullRom</span><span>(</span><span> </span><span>t</span><span>,</span><span> </span><span>c0</span><span>,</span><span> </span><span>c1</span><span>,</span><span> </span><span>c2</span><span>,</span><span> </span><span>c3</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>camTarget</span><span> </span><span>=</span><span> </span><span>CatmullRom</span><span>(</span><span> </span><span>t</span><span>,</span><span> </span><span>t0</span><span>,</span><span> </span><span>t1</span><span>,</span><span> </span><span>t2</span><span>,</span><span> </span><span>t3</span><span> </span><span>)</span><span>;</span></p><p><span>}</span></p><p><span>void</span><span> </span><span>MassiveApp</span><span>::</span><span>Tick</span><span>(</span><span> </span><span>float</span><span> </span><span>deltaTime</span><span> </span><span>)</span></p><p><span>{</span></p><p><span>    </span><span>// playback spline path</span></p><p><span>    </span><span>static</span><span> </span><span>int</span><span> </span><span>seg</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span></p><p><span>    </span><span>static</span><span> </span><span>float</span><span> </span><span>t</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>    </span><span>t</span><span> </span><span>+=</span><span> </span><span>deltaTime</span><span> </span><span>*</span><span> </span><span>0.0005f</span><span>;</span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>t</span><span> </span><span>&gt;</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span> </span><span>t</span><span> </span><span>-=</span><span> </span><span>1.0f</span><span>;</span><span> </span><span>if</span><span> </span><span>(</span><span>++</span><span>seg</span><span> </span><span>==</span><span> </span><span>20</span><span>)</span><span> </span><span>seg</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span> </span><span>}</span></p><p><span>    </span><span>SplineCam</span><span>(</span><span> </span><span>seg</span><span>,</span><span> </span><span>t</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>mat4</span><span> </span><span>M</span><span> </span><span>=</span><span> </span><span>mat4</span><span>::</span><span>LookAt</span><span>(</span><span> </span><span>camPos</span><span>,</span><span> </span><span>camTarget</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0923 seconds] -->
</div>



<p>And with that, we have reached our final destination.</p>



<figure><img loading="lazy" width="1024" height="1019" src="https://jacco.ompf2.com/wp-content/uploads/2022/06/collage-1024x1019.jpg" alt="" srcset="https://jacco.ompf2.com/wp-content/uploads/2022/06/collage-1024x1019.jpg 1024w, https://jacco.ompf2.com/wp-content/uploads/2022/06/collage-300x300.jpg 300w, https://jacco.ompf2.com/wp-content/uploads/2022/06/collage-150x150.jpg 150w, https://jacco.ompf2.com/wp-content/uploads/2022/06/collage-768x764.jpg 768w, https://jacco.ompf2.com/wp-content/uploads/2022/06/collage-1222x1216.jpg 1222w, https://jacco.ompf2.com/wp-content/uploads/2022/06/collage-897x893.jpg 897w, https://jacco.ompf2.com/wp-content/uploads/2022/06/collage-360x358.jpg 360w, https://jacco.ompf2.com/wp-content/uploads/2022/06/collage.jpg 1258w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h2>Bandwidth</h2>



<p>There’s one thing that is rather silly about the current demo, and it has to do with the template used. It is however a generic thing, so let me explain.</p>



<p>To render an image, the CPU code creates a buffer in VRAM. The OpenCL kernel fills this buffer with pixels. Next, we copy the buffer back to the CPU. And then what? Well, under hood the template maintains a single texture, the size of which matches the window size. The rendered pixels are copied to this texture once per frame, after <code>::Tick()</code> completes. OpenGL is then used to draw a screen filling quad using this texture. This is how a frame ends up on the monitor. We thus have:</p>



<ul><li>Pixels rendered on the GPU using OpenCL</li><li>Pixels transferred to CPU RAM</li><li>Pixels copied from CPU RAM to a texture <em>in VRAM</em></li></ul>



<p>That feels like a rather long route with unnecessary detours, and it is. Luckily, there is a shortcut, and the name of the shortcut is <em>GL/CL interop</em>. This is a technique where OpenGL makes a resource (in this case: a texture) available to OpenCL, so OpenCL can render directly to it. And this saves time, obviously.</p>



<p>To enable the shortcut, we replace one line in <code>::Init()</code>. The line that currently reads</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f873769924161" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>    </span><span>target</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Buffer</span><span>(</span><span> </span><span>SCRWIDTH *</span><span> </span><span>SCRHEIGHT *</span><span> </span><span>4</span><span> </span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>is to be replaced by</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f876248980720" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>    </span><span>target</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Buffer</span><span>(</span><span> </span><span>GetRenderTarget</span><span>(</span><span>)</span><span>-&gt;</span><span>ID</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>Buffer</span><span>::</span><span>TARGET</span><span> </span><span>)</span><span>;</span></p><p><span>    </span><span>screen</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>This is inevitably highly template-specific. The first line creates the buffer using an OpenGL texture identifier, obtained from the render target of the template. The second line is used to tell the template to stop sending frames to the OpenGL texture – we are using OpenCL for that now.</p>



<p>A few more changes are needed. In ::Tick(), we delete the two lines that ‘obtain the rendered result’. And, in the kernel code, the first argument is now different:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f877580741334" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>__kernel </span><span>void</span><span> </span><span>render</span><span>(</span><span> </span></p><p><span>    </span><span>write_only </span><span>image2d_t </span><span>target</span><span>,</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p><p><span>)</span></p><p><span>{</span></p><p><span>    </span><span>.</span><span>.</span><span>.</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>And finally, plotting to the target changes. We used a unsigned int array before, but now we have a floating point OpenGL texture to work with. We use the following line to write to it:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.27 -->

		<div id="urvanov-syntax-highlighter-62aa3e591f878039333159" data-settings=" no-popup minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>    </span><span>write_imagef</span><span>(</span><span> </span><span>target</span><span>,</span><span> </span><span>(</span><span>int2</span><span>)</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span>,</span><span> </span><span>(</span><span>float4</span><span>)</span><span>(</span><span> </span><span>color</span><span>,</span><span> </span><span>1</span><span> </span><span>)</span><span> </span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
</div>



<p>After this change the demo works again, this time without wasting time sending pixel data back and forth.</p>



<h2>Future Work</h2>



<p>Where do we go from here? Well, as a wise man once said, you can be “Ray Tracing – the Rest of Your Life”…</p>



<p><em><strong>Faster BVH building</strong></em> – The BVH for the dragon is constructed in just a few milliseconds, on a single core. For multiple meshes multiple cores can be used – until they run out. Take it further by optimizing the BVH builder: Some SIMD magic should bring down the time significantly, and beyond that, well, there’s ways to make it <em>very </em>fast. An important trick is to build your BVH <em>while the GPU is tracing rays</em>: the only thing that needs to happen between frames is sending the updated data. And even that isn’t strictly necessary.</p>



<p><em><strong>Faster traversal</strong></em> – We trace hundreds of millions of rays per second now on the GPU – without RTX. But, the code is far from optimal… There are BVH layouts that are better suited for the GPU, and there’s 4-wide and 8-wide BVHs, which further improve performance. On the CPU packet traversal makes a huge difference, especially for primary rays. By the way, we never implemented proper shadow rays, so that should be on the top of your list.</p>



<p><em><strong>Better rendering</strong></em> – A few reflecting dragons is nice, but what about more interesting materials, normal maps, depth of field, motion blur, soft shadows, indirect light? This is a field in which you can explore endlessly. Start with basic path tracing, and quickly your code will be too slow again, forcing you to look into filtering techniques and ReSTIR for efficiently sampling many lights. A life is not going to be enough, I’m afraid.</p>



<p><em><strong>Engine flexibility</strong></em> – The code of this tutorial is short and hopefully clear, but definitely not robust. Handling multiple meshes and textures and being able to delete them and add them at runtime will require a lot of administration – especially if you still want to render on the GPU. And while you’re at it: A fixed-size skydome is not how things should be, obviously. Do mind compile times, once you start cleaning things up: you may have noticed that the tutorial code compiles in a flash, and that’s not just a lucky accident.</p>



<p><em><strong>OptiX-CL</strong></em> – NVIDIA provides RTX support from CUDA in the form of a library called OptiX. It would be nice if the functionality of this library became available <em>outside of CUDA</em>, and thus for all devices of all vendors. If you see a challenge here: Let me know! Perhaps we can join forces. Especially the now obsolete OptiX Prime API would be very interesting (and relatively simple) to replicate.</p>



<p><em><strong>Lightouse 2</strong></em> – Speaking of OptiX: My Lighthouse 2 project uses OptiX to quickly render complex scenes on the GPU, but it is NVIDIA only, essentially. A proper render core using OpenCL or even using the CPU would be great to have. One day, perhaps.</p>



<div><figure><img loading="lazy" src="https://jacco.ompf2.com/wp-content/uploads/2020/02/shot4-1024x651.png" alt="" width="512" height="326" srcset="https://jacco.ompf2.com/wp-content/uploads/2020/02/shot4-1024x651.png 1024w, https://jacco.ompf2.com/wp-content/uploads/2020/02/shot4-300x191.png 300w, https://jacco.ompf2.com/wp-content/uploads/2020/02/shot4-768x489.png 768w, https://jacco.ompf2.com/wp-content/uploads/2020/02/shot4-400x254.png 400w, https://jacco.ompf2.com/wp-content/uploads/2020/02/shot4.png 1344w" sizes="(max-width: 512px) 100vw, 512px"/><figcaption>Frame from the Lighthouse 2 real-time path tracing benchmark.</figcaption></figure></div>



<p>That’s just my ideas though. Let me know what your plans are, but whatever you do, keep tracing.</p>



<p>And with that, allow me to sign off for once as if it’s 1999 on Flipcode:</p>



<p>Love you all,</p>



<p>Jacco Bikker, <em>a.k.a. “The Phantom”.</em></p>



<h2>Closing Remarks</h2>



<p>The complete code for this project, in ten convenient incremental stages, <a href="https://github.com/jbikker/bvh_article">can be found on GitHub</a> (for Windows / Visual Studio).</p>



<p>Enjoyed the article? Spotted an error?</p>



<p>Ping me on Twitter (<a href="https://twitter.com/j_bikker">@j_bikker</a>), comment on this article, or send an email to <a href="mailto:bikker.j@gmail.com">bikker.j@gmail.com</a>.</p>



<p>Or read some more articles: <a href="https://jacco.ompf2.com">https://jacco.ompf2.com</a>. Some favorites:</p>



<ul><li><a href="https://jacco.ompf2.com/2019/07/18/wavefront-path-tracing/">Wavefront path tracing</a></li><li>Probability Theory for Physically Based Rendering – <a href="https://jacco.ompf2.com/2019/12/11/probability-theory-for-physically-based-rendering/">part 1</a></li><li>Probability Theory for Physically Based Rendering – <a href="https://jacco.ompf2.com/2019/12/13/probability-theory-for-physically-based-rendering-part-2/">part 2</a></li><li><a href="https://jacco.ompf2.com/2020/05/12/opt3simd-part-1-of-2/">OPT#3: SIMD</a> (part 1 of 2) – <em>also check the other optimization blog posts!</em></li></ul>
    </div></div>
  </body>
</html>
