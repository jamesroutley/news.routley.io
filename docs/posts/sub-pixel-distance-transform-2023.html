<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://acko.net/blog/subpixel-distance-transform/">Original</a>
    <h1>Sub-pixel distance transform (2023)</h1>
    
    <div id="readability-page-1" class="page"><div><div>

<h2>SDFs</h2>

<p>The idea behind SDFs is quite simple. To draw a crisp, anti-aliased shape at any size, you start from a field or image that records the distance to the shape&#39;s edge at every point, as a gradient. Lighter grays are inside, darker grays are outside. This can be a lower resolution than the target.</p>

</div></div><div><p>Then you increase the contrast until the gradient is exactly 1 pixel wide at the target size. You can sample it to get a perfectly anti-aliased opacity mask:</p></div><div><div>

<p>This works fine for text at typical sizes, and handles fractional shifts and scales perfectly with zero shimmering. It&#39;s also reasonably correct from a signal processing math point-of-view: it closely approximates averaging over a pixel-sized circular window, i.e. a low-pass convolution.</p>

<p>Crucially, it takes a rendered glyph as input, which means I can remain blissfully unaware of TrueType font specifics, and bezier rasterization, and just offload that to an existing library.</p>

<p>To generate an SDF, I started with MapBox&#39;s <a href="https://github.com/mapbox/tiny-sdf" target="_blank">TinySDF</a> library. Except, what comes out of it is wrong:</p>

</div></div><div><div>

<p>The contours are noticeably wobbly and pixelated. The only reason the glyph itself looks okay is because the errors around the zero-level are symmetrical and cancel out. If you try to dilate or contract the outline, which is supposed to be one of SDF&#39;s killer features, you get ugly gunk.</p>

<p>Compare to:</p>

</div></div><div><div>

<p>The original <a href="https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf" target="_blank">Valve paper</a> glosses over this aspect and uses high resolution inputs (4k) for a highly downscaled result (64). That is not an option for me because it&#39;s too slow. But I did get it to work. As a result Use.GPU has a novel subpixel-accurate distance transform (ESDT), which even does emoji. It&#39;s a combination CPU/GPU approach, with the CPU generating SDFs and the GPU rendering them, including all the debug viz.</p>


<h2>The Classic EDT</h2>

<p>The common solution is a <a href="https://cs.brown.edu/~pff/papers/dt-final.pdf">Euclidean Distance Transform</a>. Given a binary mask, it will produce an <em>unsigned</em> distance field. This holds the squared distance <code>d²</code> for either the inside or outside area, which you can <code>sqrt</code>.</p>

</div></div><div><div>

<p>Like a Fourier Transform, you can apply it to 2D images by applying it horizontally on each row X, then vertically on each column Y (or vice versa). To make a <em>signed</em> distance field, you do this for both the inside and outside separately, and then combine the two as <code>inside – outside</code> or vice versa.</p>

<p>The algorithm is one of those clever bits of 80s-style C code which is <code>O(N)</code>, has lots of 1-letter variable names, and is very CPU cache friendly. Often copy/pasted, but rarely understood. In TypeScript it looks like this, where <code>array</code> is modified in-place and <code>f</code>, <code>v</code> and <code>z</code> are temporary buffers up to 1 row/column long. The arguments <code>offset</code> and <code>stride</code> allow the code to be used in either the X or Y direction in a flattened 2D array.</p>

<pre><code>for (let q = 1, k = 0, s = 0; q &lt; length; q++) {
  f[q] = array[offset + q * stride];

  do {
    let r = v[k];
    s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;
  } while (s &lt;= z[k] &amp;&amp; --k &gt; -1);

  k++;
  v[k] = q;
  z[k] = s;
  z[k + 1] = INF;
}

for (let q = 0, k = 0; q &lt; length; q++) {
  while (z[k + 1] &lt; q) k++;
  let r = v[k];
  let d = q - r;
  array[offset + q * stride] = f[r] + d * d;
}
</code></pre>


<p>To explain what this code does, let&#39;s start with a naive version instead.</p>

</div></div><div><div>

<p>Given a 1D input array of zeroes (filled), with an area masked out with infinity (empty):</p>

<pre><code>O = [·, ·, ·, 0, 0, 0, 0, 0, ·, 0, 0, 0, ·, ·, ·]</code></pre>


<p>Make a matching sequence <code>… 3 2 1 0 1 2 3 …</code> for each element, centering the 0 at each index:</p>

<pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14] + ∞
[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13] + ∞
[2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12] + ∞
[3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11] + 0
[4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10] + 0
[5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] + 0
[6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8] + 0
[7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7] + 0
[8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6] + ∞
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5] + 0
[10,9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4] + 0
[11,10,9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3] + 0
[12,11,10,9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2] + ∞
[13,12,11,10,9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1] + ∞
[14,13,12,11,10,9, 8, 7, 6, 5, 4, 3, 2, 1, 0] + ∞
</code></pre>


<p>You then add the value from the array to each element in the row:</p>

<pre><code>[∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞]
[∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞]
[∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞]
[3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11]
[4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10]
[5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8]
[7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7]
[∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞]
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5]
[10,9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4]
[11,10,9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3]
[∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞]
[∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞]
[∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞]
</code></pre>


<p>And then take the minimum of each column:</p>

<pre><code>P = [3, 2, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 2, 3]</code></pre>


<p>This sequence counts up inside the masked out area, away from the zeroes. This is the positive distance field P.</p>

<p>You can do the same for the inverted mask:</p>

<pre><code>I = [0, 0, 0, ·, ·, ·, ·, ·, 0, ·, ·, ·, 0, 0, 0]</code></pre>


<p>to get the complementary area, i.e. the negative distance field N:</p>

<pre><code>N = [0, 0, 0, 1, 2, 3, 2, 1, 0, 1, 2, 1, 0, 0, 0]</code></pre>


<p>That&#39;s what the EDT does, except it uses square distance <code>… 9 4 1 0 1 4 9 …</code>:</p>

</div></div><div><div>

<p>When you apply it a second time in the second dimension, these outputs are the new input, i.e. values other than <code>0</code> or <code>∞</code>. It still works because of Pythagoras&#39; rule: <code>d² = x² + y²</code>. This wouldn&#39;t be true if it used linear distance instead. The net effect is that you end up intersecting a series of parabolas, somewhat like a 1D slice of a Voronoi diagram:</p>

<pre><code>I&#39; = [0, 0, 1, 4, 9, 4, 4, 4, 1, 1, 4, 9, 4, 9, 9]</code></pre>


</div></div><div><p>Each parabola sitting above zero is the &#39;shadow&#39; of a zero-level paraboloid located some distance in a perpendicular dimension:</p></div><div><div>

<p>The code is just a more clever way to do that, without generating the entire <code>N²</code> grid per row/column. It instead scans through the array left to right, building up a list <code>v[k]</code> of significant minima, with thresholds <code>s[k]</code> where two parabolas intersect. It adds them as candidates (<code>k++</code>) and discards them (<code>--k</code>) if they are eclipsed by a newer value. This is the first <code>for</code>/<code>while</code> loop:</p>

<pre><code>for (let q = 1, k = 0, s = 0; q &lt; length; q++) {
  f[q] = array[offset + q * stride];

  do {
    let r = v[k];
    s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;
  } while (s &lt;= z[k] &amp;&amp; --k &gt; -1);

  k++;
  v[k] = q;
  z[k] = s;
  z[k + 1] = INF;
}
</code></pre>


<p>Then it goes left to right again (<code>for</code>), and fills out the values, skipping ahead to the right minimum (<code>k++</code>). This is the squared distance from the current index <code>q</code> to the nearest minimum <code>r</code>, plus the minimum&#39;s value <code>f[r]</code> itself. The <a href="https://cs.brown.edu/~pff/papers/dt-final.pdf" target="_blank">paper</a> has more details:</p>

<pre><code>for (let q = 0, k = 0; q &lt; length; q++) {
  while (z[k + 1] &lt; q) k++;
  let r = v[k];
  let d = q - r;
  array[offset + q * stride] = f[r] + d * d;
}
</code></pre>



<h2>The Broken EDT</h2>

<p>So what&#39;s the catch? The above assumes a binary mask.</p>

</div></div><div><div>

<p>As it happens, if you try to subtract a binary N from P, you have an off-by-one error:</p>

<pre><code>    O = [·, ·, ·, 0, 0, 0, 0, 0, ·, 0, 0, 0, ·, ·, ·]
    I = [0, 0, 0, ·, ·, ·, ·, ·, 0, ·, ·, ·, 0, 0, 0]

    P = [3, 2, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 2, 3]
    N = [0, 0, 0, 1, 2, 3, 2, 1, 0, 1, 2, 1, 0, 0, 0]

P - N = [3, 2, 1,-1,-2,-3,-2,-1, 1,-1,-2,-1, 1, 2, 3]
</code></pre>


<p>It goes directly from <code>1</code> to <code>-1</code> and back. You could add +/- 0.5 to fix that.</p>

</div></div><div><div>

<p>But if there is a gray pixel in between each white and black, which we classify as both inside (<code>0</code>) and outside (<code>0</code>), it seems to work out just fine:</p>

<pre><code>    O = [·, ·, ·, 0, 0, 0, 0, 0, ·, 0, 0, 0, ·, ·, ·]
    I = [0, 0, 0, 0, ·, ·, ·, 0, 0, 0, ·, 0, 0, 0, 0]

    P = [3, 2, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 2, 3]
    N = [0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0]

P - N = [3, 2, 1, 0,-1,-2,-1, 0, 1, 0,-1, 0, 1, 2, 3]
</code></pre>


<p>This is a realization that somebody must&#39;ve had, and they <a href="https://github.com/mapbox/tiny-sdf/blob/main/index.js#L90" target="_blank">reasoned on</a>: &#34;<em>The above is correct for a 50% opaque pixel, where the edge between inside and outside falls exactly in the middle of a pixel.&#34;</em></p>

<p><em>&#34;Lighter grays are more inside, and darker grays are more outside. So all we need to do is treat <code>l = level - 0.5</code> as a signed distance, and use <code>l²</code> for the initial inside or outside value for gray pixels. This will cause either the positive or negative distance field to shift by a subpixel amount <code>l</code>. And then the EDT will propagate this in both X and Y directions.&#34;</em></p>

<p>The initial idea is correct, because this is just running SDF rendering in reverse. A gray pixel in an opacity mask is what you get when you contrast adjust an SDF and do not blow it out into pure black or white. The information inside the gray pixels is &#34;correct&#34;, up to rounding.</p>

<p>But there are two mistakes here.</p>

<p>The first is that even in an anti-aliased image, you can have white pixels right next to black ones. Especially with fonts, which are pixel-hinted. So the SDF is wrong there, because it goes directly from <code>-1</code> to <code>1</code>. This causes the contours to double up, e.g. around this bottom edge:</p>

</div></div><div><div>

<p>To solve this, you can eliminate the crisp case by deliberately making those edges very dark or light gray.</p>

<p>But the second mistake is more subtle. The EDT works in 2D because you can feed the <em>output</em> of X in as the <em>input</em> of Y. But that means that any non-zero <em>input</em> to X represents another dimension Z, separate from X and Y. The resulting squared distance will be <code>x² + y² + z²</code>. This is a 3D distance, not 2D.</p>

<p>If an edge is shifted by 0.5 pixels in X, you would expect a 1D SDF like:</p>

<pre><code>  […, 0.5, 1.5, 2.5, 3.5, …]
= […, 0.5, 1 + 0.5, 2 + 0.5, 3 + 0.5, …]
</code></pre>


<p>Instead, because of the squaring + square root, you will get:</p>

<pre><code>  […, 0.5, 1.12, 2.06, 3.04, …]
= […, sqrt(0.25), sqrt(1 + 0.25), sqrt(4 + 0.25), sqrt(9 + 0.25), …]
</code></pre>


<p>The effect of <code>l² = 0.25</code> rapidly diminishes as you get away from the edge, and is significantly wrong even just one pixel over.</p>

<p>The correct shift would need to be folded into <code>(x + …)² + (y + …)²</code> and depends on the direction. e.g. If an edge is shifted horizontally, it ought to be <code>(x + l)² + y²</code>, which means there is a term of <code>2*x*l</code> missing. If the shift is vertical, it&#39;s <code>2*y*l</code> instead. This is also a <em>signed</em> value, not positive/unsigned.</p>

<p>Given all this, it&#39;s a miracle this worked at all. The only reason this isn&#39;t more visible in the final glyph is because the positive and negative fields contains the same but opposite errors around their respective gray pixels.</p>

<h2>The Not-Subpixel EDT</h2>

<p>As mentioned before, the EDT algorithm is essentially making a 1D Voronoi diagram every time. It finds the distance to the nearest minimum for every array index. But there is no reason for those minima themselves to lie at integer offsets, because the second <code>for</code> loop effectively <em>resamples</em> the data.</p>

<p>So you can take an input mask, and tag each index with a horizontal offset <code>Δ</code>:</p>

<pre><code>O = [·, ·, ·, 0, 0, 0, 0, 0, ·, ·, ·]
Δ = [A, B, C, D, E, F, G, H, I, J, K]
</code></pre>


<p>As long as the offsets are small, no two indices will swap order, and the code still works. You then build the Voronoi diagram out of the shifted parabolas, but sample the result at unshifted indices.</p>

</div></div><div><div>

<h3>Problem 1 - Opposing Shifts</h3>

<p>This lead me down the first rabbit hole, which was an attempt to make the EDT subpixel capable without losing its appealing simplicity. I started by investigating the nuances of subpixel EDT in 1D. This was a bit of a mirage, because most real problems only pop up in 2D. Though there was one important insight here.</p>

<pre><code>O = [·, ·, ·, 0, 0, 0, 0, 0, ·, ·, ·]
Δ = [·, ·, ·, A, ·, ·, ·, B, ·, ·, ·]
</code></pre>


<p>Given a mask of zeroes and infinities, you can only shift the first and last point of each segment. Infinities don&#39;t do anything, while middle zeroes should remain zero.</p>

</div></div><div><div>

<p>Using an offset <code>A</code> works sort of as expected: this will increase or decrease the values filled in by a fractional pixel, calculating a squared distance <code>(d + A)²</code> where <code>A</code> can be positive or negative. But the value at the shifted index itself is always <code>(0 + A)²</code> (positive). This means it is always outside, regardless of whether it is moving left or right.</p>

<p>If <code>A</code> is moving left (–), the point is inside, and the (unsigned) distance should be <code>0</code>. At <code>B</code> the situation is reversed: the distance should be <code>0</code> if <code>B</code> is moving right (+). It might seem like this is annoying but fixable, because the zeroes can be filled in by the opposite signed field. But this is only looking at the binary 1D case, where there are only zeroes and infinities.</p>

<p>In 2D, a second pass has non-zero distances, so every index can be shifted:</p>

<pre><code>O = [a, b, c, d, e, f, g, h, i, j, k]
Δ = [A, B, C, D, E, F, G, H, I, J, K]
</code></pre>


<p>Now, resolving every subpixel unambiguously is harder than you might think:</p>

</div></div><div><div>

<p>It&#39;s important to notice that the function being sampled by an EDT is not actually smooth: it is the minimum of a discrete set of parabolas, which cross at an angle. The square root of the output only produces a smooth linear gradient because it samples each parabola at integer offsets. Each center only shifts upward by the square of an integer in every pass, so the crossings are predictable. You never sample the &#39;wrong&#39; side of <code>(d + ...)²</code>. A subpixel EDT does not have this luxury.</p>

<p>Subpixel EDTs are not irreparably broken though. Rather, they are only valid if they cause the unsigned distance field to increase, i.e. if they dilate the empty space. This is a problem: any shift that dilates the positive field contracts the negative, and vice versa.</p>

<p>To fix this, you need to get out of the handwaving stage and actually understand P and N as continuous 2D fields.</p>

<h3>Problem 2 - Diagonals</h3>

<p>Consider an aliased, sloped edge. To understand how the classic EDT resolves it, we can turn it into a voronoi diagram for all the white pixel centers:</p>

</div></div><div><p>Near the bottom, the field is dominated by the white pixels on the corners: they form diagonal sections downwards. Near the edge itself, the field runs perfectly vertical inside a roughly triangular section. In both cases, an arrow pointing back towards the cell center is only vaguely perpendicular to the true diagonal edge.</p></div><div><div>

<p>Near perfect diagonals, the edge distances are just wrong. The distance of edge pixels goes up or right (<code>1</code>), rather than the more logical diagonal <code>0.707…</code>. The true closest point on the edge is not part of the grid.</p>

<p>These fields don&#39;t really resolve properly until 6-7 pixels out. You could hide these flaws with e.g. an 8x downscale, but that&#39;s 64x more pixels. Either way, you shouldn&#39;t expect perfect numerical accuracy from an EDT. Just because it&#39;s mathematically separable doesn&#39;t mean it&#39;s particularly good.</p>

<p>In fact, it&#39;s only separable because it isn&#39;t very good at all.</p>


<h3>Problem 3 - Gradients</h3>

<p>In 2D, there is also only one correct answer to the gray case. Consider a diagonal edge, anti-aliased:</p>

</div></div><div><p>Thresholding it into black, grey or white, you get:</p></div><div><p>If you now classify the grays as both inside and outside, then the highlighted pixels will be part of both masks. Both the positive and negative field will be exactly zero there, and so will the SDF <code>(P - N)</code>:</p></div><div><div>

<p>This creates a phantom vertical edge that pushes apart P and N, and causes the average slope to be less than 45º. The field simply has the wrong shape, because gray pixels can be surrounded by other gray pixels.</p>

<p>This also explains why TinySDF magically seemed to work despite being so pixelized. The <code>l²</code> gray correction fills in exactly the gaps in the bad <code>(P - N)</code> field where it is zero, and it interpolates towards a symmetrically wrong P and N field on each side.</p>

<p>If we instead classify grays as neither inside nor outside, then <code>P</code> and <code>N</code> overlap in the boundary, and it is possible to resolve them into a coherent SDF with a clean 45 degree slope, if you do it right:</p>

</div></div><div><div>

<p>What seemed like an off-by-one error is actually the right approach in 2D or higher. The subpixel SDF will then be a modified version of this field, where the P and N sides are changed in lock-step to remain mutually consistent.</p>

<p>Though we will get there in a roundabout way.</p>

<h3>Problem 4 - Commuting</h3>

<p>It&#39;s worth pointing out: a subpixel EDT simply <em>cannot</em> commute in 2D.</p>

<p>First, consider the data flow of an ordinary EDT:</p>

</div></div><div><div>

<p>Information from a corner pixel can flow through empty space both when doing X-then-Y <em>and</em> Y-then-X. But information from the horizontal edge pixels can only flow vertically <em>then</em> horizontally. This is okay because the separating lines between adjacent pixels are purely vertical too: the red arrows never &#39;win&#39;.</p>

<p>But if you introduce subpixel shifts, the separating lines can turn:</p>

</div></div><div><div>

<p>The data flow is still limited to the original EDT pattern, so the edge pixels at the top can only propagate by starting downward. They can only influence adjacent columns if the order is <em>Y-then-X</em>. For vertical edges it&#39;s the opposite.</p>

<p>That said, this is only a problem on shallow concave curves, where there aren&#39;t any corner pixels nearby. The error is that it &#39;snaps&#39; to the wrong edge point, but only when it is already several pixels away from the edge. In that case, the smaller <code>x²</code> term is dwarfed by the much larger <code>y²</code> term, so the absolute error is small after <code>sqrt</code>.</p>

<h2>The ESDT</h2>

<p>Knowing all this, here&#39;s how I assembled a &#34;true&#34; Euclidean Subpixel Distance Transform.</p>

<h3>Subpixel offsets</h3>

<p>To start we need to determine the subpixel offsets. We can still treat <code>level - 0.5</code> as the signed distance for any gray pixel, and ignore all white and black for now.</p>

<p>The tricky part is determining the exact direction of that distance. As an approximation, we can examine the 3x3 neighborhood around each gray pixel and do a least-squares fit of a plane. As long as there is at least one white and one black pixel in this neighborhood, we get a vector pointing towards where the actual edge is. In practice I apply some horizontal/vertical smoothing here using a simple <code>[1 2 1]</code> kernel.</p>

<p>The result is numerically very stable, because the originally rasterized image is visually consistent.</p>

</div></div><div><p>This logic is disabled for thin creases and spikes, where it doesn&#39;t work. Such points are treated as fully masked out, so that neighboring distances propagate there instead. This is needed e.g. for the pointy negative space of a <code>W</code> to come out right.</p></div><div><p>I also implemented a relaxation step that will smooth neighboring vectors if they point in similar directions. However, the effect is quite minimal, and it rounds very sharp corners, so I ended up disabling it by default.</p></div><div><div>

<p>The goal is then to do an ESDT that uses these shifted positions for the minima, to get a subpixel accurate distance field.</p>

<h3>P and N junction</h3>

<p>We saw earlier that only <em>non-masked</em> pixels can have offsets that influence the output (#1). We only have offsets for gray pixels, yet we concluded that gray pixels should be <em>masked out</em>, to form a connected SDF with the right shape (#3). This can&#39;t work.</p>

<p>SDFs are both the problem and the solution here. Dilating and contracting SDFs is easy: add or subtract a constant. So you can expand both P and N fields ahead of time geometrically, and then undo it numerically. This is done by pushing their respective gray pixel centers in opposite directions, by half a pixel, on top of the originally calculated offset:</p>

</div></div><div><div>

<p>This way, they can remain masked <em>in</em> in both fields, but are always pushed between 0 and 1 pixel inwards. The distance between the P and N gray pixel offsets is always exactly 1, so the non-zero overlap between P and N is guaranteed to be exactly 1 pixel wide everywhere. It&#39;s a perfect join anywhere we sample it, because the line between the two ends crosses through a pixel center.</p>

<p>When we then calculate the final SDF, we do the opposite, shifting each by half a pixel and trimming it off with a <code>max</code>:</p>

<pre><code>SDF = max(0, P - 0.5) - max(0, N - 0.5)
</code></pre>


<p>Only one of P or N will be &gt; 0.5 at a time, so this is exact.</p>

<p>To deal with pure black/white edges, I treat any black neighbor of a white pixel (horizontal or vertical only) as gray with a 0.5 pixel offset (before P/N dilation). No actual blurring needs to happen, and the result is numerically exact minus epsilon, which is nice.</p>

<h3>ESDT state</h3>

<p>The state for the ESDT then consists of remembering a signed X and Y offset for every pixel, rather than the squared distance. These are factored into the distance and threshold calculations, separated into its proper parallel and orthogonal components, i.e. X/Y or Y/X. Unlike an EDT, each X or Y pass has to be aware of both axes. But the algorithm is mostly unchanged otherwise, here <em>X-then-Y</em>.</p>

<p>The X pass:</p>

</div></div><div><div>

<p>At the start, only gray pixels have offsets and they are all in the range <code>-1…1</code> (exclusive). With each pass of ESDT, a winning minima&#39;s offsets propagate to its affecting range, tracking the total distance <code>(Δx, Δy)</code> (&gt; 1). At the end, each pixel&#39;s offset points to the nearest edge, so the squared distance can be derived as <code>Δx² + Δy²</code>.</p>

<p>The Y pass:</p>

</div></div><div><div>

<p>You can see that the vertical distances in the top-left are practically vertical, and not oriented perpendicular to the contour on average: they have not had a chance to propagate horizontally. But they do factor in the vertical subpixel offset, and this is the dominant component. So even without correction it still creates a smooth SDF with a surprisingly small error.</p>


<h3>Fix ups</h3>

<p>The commutativity errors are all biased positively, meaning we get an upper bound of the true distance field.</p>

<p>You could take the <code>min</code> of <code>X then Y</code> and <code>Y then X</code>. This would re-use all the same prep and would restore rotation-independence at the cost of 2x as many ESDTs. You could try <code>X then Y then X</code> at 1.5x cost with some hacks. But neither would improve diagonal areas, which were still busted in the original EDT.</p>

<p>Instead I implemented an additional relaxation pass. It visits every pixel&#39;s target, and double checks whether one of the 4 immediate neighbors (with subpixel offset) isn&#39;t a better solution:</p>

</div></div><div><p>It&#39;s a good heuristic because if the target is &gt;1px off there is either a viable commutative propagation path, or you&#39;re so far away the error is negligible. It fixes up the diagonals, creating tidy lines when the resolution allows for it:</p></div><div><div>

<p>You could take this even further, given that you know the offsets are supposed to be perpendicular to the glyph contour. You could add reprojection with a few dot products here, but getting it to not misfire on edge cases would be tricky.</p>
  
<p>While you can tell the unrelaxed offsets are wrong when visualized, and the fixed ones are better, the visual difference in the output glyphs is tiny. You need to blow glyphs up to enormous size to see the difference side by side. So it too is disabled by default. The diagonals in the original EDT were wrong too and you could barely tell.</p>

<h3>Emoji</h3>

<p>An emoji is generally stored as a full color transparent PNG or SVG. The ESDT can be applied directly to its opacity mask to get an SDF, so no problem there.</p>

</div></div><div><div>

<p>There are an extremely rare handful of emoji with semi-transparent areas, but you can get away with making those solid. For this I just use a filter that detects &#39;+&#39; shaped arrangements of pixels that have (almost) the same transparency level. Then I dilate those by 3x3 to get the average transparency level in each area. Then I divide by it to only keep the anti-aliased edges transparent.</p>

<p>The real issue is blending the colors at the edges, when the emoji is being rendered and scaled. The RGB color of transparent pixels is undefined, so whatever values are there will blend into the surrounding pixels, e.g. creating a subtle black halo:</p>

</div></div><div><div>

<p>A common solution is <em>premultiplied alpha</em>. The opacity is baked into the RGB channels as <code>(R * A, G * A, B * A, A)</code>, and transparent areas must be fully transparent black. This allows you to use a premultiplied blend mode where the RGB channels are added directly without further scaling, to cancel out the error.</p>

<p>But the alpha channel of an SDF glyph is dynamic, and is independent of the colors, so it cannot be premultiplied. We need valid color values even for the fully transparent areas, so that up- or downscaling is still clean.</p>

<p>Luckily the ESDT calculates X and Y offsets which point from each pixel directly to the nearest edge. We can use them to propagate the colors outward in a single pass, filling in the entire background. It doesn&#39;t need to be very accurate, so no filtering is required.</p>

</div></div><div><p>The result looks pretty great. At normal sizes, the crisp edge hides the fact that the interior is somewhat blurry. Emoji fonts are supported via the underlying <code>ab_glyph</code> library, but are too big for the web (10MB+). So you can just load .PNGs on demand instead, at whatever resolution you need. Hooking it up to the 2D canvas to render native system emoji is left as an exercise for the reader.</p></div><div><div>

<p>Use.GPU does not support complex Unicode scripts or RTL text yet—both are a can of worms I wish to offload too—but it does support composite emoji like &#34;pirate flag&#34; (white flag + skull and crossbones) or &#34;male astronaut&#34; (astronaut + man) when formatted using the usual Zero-Width Joiners (U+200D) or modifiers.</p>

<h2>Shading</h2>

<p>Finally, a note on how to actually render with SDFs, which is more nuanced than you might think.</p>

</div></div><div><div>

<p>I pack all the SDF glyphs into an atlas on-demand, the same I use elsewhere in Use.GPU. This has a custom layout algorithm that doesn&#39;t backtrack, optimized for filling out a layout at run-time with pieces of a similar size. Glyphs are rasterized at 1.5x their normal font size, after rounding up to the nearest power of two. The extra 50% ensures small fonts on low-DPI displays still use a higher quality SDF, while high-DPI displays just upscale that SDF without noticeable quality loss. The rounding ensures similar font sizes reuse the same SDFs. You can also override the detail independent of font size.</p>

<p>To determine the contrast factor to draw an SDF, you generally use screen-space derivatives. There are good and bad ways of doing this. Your goal is to get a ratio of SDF pixels to screen pixels, so the best thing to do is give the GPU the coordinates of the <em>SDF texture pixels</em>, and ask it to calculate the difference for that between neighboring <em>screen pixels</em>. This works for surfaces in 3D at an angle too. Bad ways of doing this will instead work off relative texture coordinates, and introduce additional scaling factors based on the view or atlas size, when they are all just supposed to cancel out.</p>

<p>As you then adjust the contrast of an SDF to render it, it&#39;s important to do so around the zero-level. The glyph&#39;s ideal vector shape should not expand or contract as you scale it. Like TinySDF, I use 75% gray as the zero level, so that more SDF range is allocated to the outside than the inside, as dilating glyphs is much more common than contraction.</p>

</div></div><div><div>

<p>At the same time, a pixel whose center sits exactly <em>on</em> the zero level edge is actually half inside, half outside, i.e. 50% opaque. So, after scaling the SDF, you need to add 0.5 to the value to get the correct opacity for a blend. This gives you a <em>mathematically accurate</em> font rendering that approximates convolution with a pixel-sized circle or box.</p>

<p>But I go further. Fonts were not invented for screens, they were designed for paper, with ink that bleeds. Certain renderers, e.g. MacOS, replicate this effect. The physical bleed distance is relatively constant, so the larger the font, the smaller the effect of the bleed proportionally. I got the best results with a 0.25 pixel bleed at 32px or more. For smaller sizes, it tapers off linearly. When you zoom out blocks of text, they get subtly fatter instead of thinning out, and this is actually a great effect when viewing document thumbnails, where lines of text become a solid mass at the point where the SDF resolution fails anyway.</p>

</div></div><div><div>

<p>In Use.GPU I prefer to use gamma correct, linear RGB color, even for 2D. What surprised me the most is just how unquestionably superior this looks. Text looks rock solid and readable even at small sizes on low-DPI. Because the SDF scales, there is no true font hinting, but it really doesn&#39;t need it, it would just be a nice extra.</p>

<p>Presumably you could track hinted points or edges inside SDF glyphs and then do a dynamic distortion somehow, but this is an order of magnitude more complex than what it is doing now, which is splat a contrasted texture on screen. It does have snapping you can turn on, which avoids jiggling of individual letters. But if you turn it off, you get smooth subpixel everything:</p>

</div></div><div><div>

<p>I was always a big fan of the 3x1 subpixel rendering used on color LCDs (i.e. <em>ClearType</em> and the like), and I was sad when it was phased out due to the popularity of high-DPI displays. But it turns out the 3x res only offered marginal benefits... the real improvement was always that it had a custom gamma correct blend mode, which is a thing a lot of people still get wrong. Even without RGB subpixels, gamma correct AA looks great. Converting the entire desktop to Linear RGB is also not going to happen in our lifetime, but I really want it more now.</p>

<p>The &#34;blurry text&#34; that some people associate with anti-aliasing is usually just text blended with the wrong gamma curve, and without an appropriate bleed for the font in question.</p>

<p>* * *</p>

<p>If you want to make SDFs from existing input data, subpixel accuracy is crucial. Without it, fully crisp strokes actually become uneven, diagonals can look bumpy, and you cannot make clean dilated outlines or shadows. If you use an EDT, you have to start from a high resolution source and then downscale away all the errors near the edges. But if you use an ESDT, you can upscale even emoji PNGs with decent results.</p>

<p>It might seem pretty obvious in hindsight, but there is a massive difference between getting it sort of working, and actually getting all the details right. There were many false starts and dead ends, because subpixel accuracy also means one bad pixel ruins it.</p>

<p>In some circles, SDF text is an old party trick by now... but a solid and reliable implementation is still a fair amount of work, with very little to go off for the harder parts.</p>

<p>By the way, I did see if I could use voronoi techniques directly, but in terms of computation it is much more involved. Pretty tho:</p>

</div></div></div>
  </body>
</html>
