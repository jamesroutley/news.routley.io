<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/dotnet/announcing-dotnet-7-preview-3/">Original</a>
    <h1>.NET 7 introduces Native AOT</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            April 13th, 2022</p><!-- .entry-meta -->
        
<p>Today, we are glad to release .NET 7 Preview 3. The third preview of .NET 7 includes enhancements to observability, startup times, codegen, GC regions, native AOT compilation, and more. The bits are available for you to grab <em>right now</em> and start experimenting with new features like:</p>
<ul>
<li>Native AOT</li>
<li>Default GC regions</li>
<li>ASP.NET Core startup time improvements</li>
</ul>
<p>You can <a href="https://dotnet.microsoft.com/download/dotnet/7.0">download .NET 7 Preview 3</a>, for Windows, macOS, and Linux.</p>
<ul>
<li><a href="https://dotnet.microsoft.com/download/dotnet/7.0">Installers and binaries</a></li>
<li><a href="https://hub.docker.com/_/microsoft-dotnet">Container images</a></li>
<li><a href="https://github.com/dotnet/core/blob/master/release-notes/7.0/">Linux packages</a></li>
<li><a href="https://github.com/dotnet/core/tree/master/release-notes/7.0">Release notes</a></li>
<li><a href="https://github.com/dotnet/core/blob/main/release-notes/7.0/known-issues.md">Known issues</a></li>
<li><a href="https://github.com/dotnet/core/issues">GitHub issue tracker</a></li>
</ul>
<p>.NET 7 Preview 3 has been tested with Visual Studio 17.2 Preview 3. We recommend you use the <a href="https://visualstudio.com/preview">preview channel builds</a> if you want to try .NET 7 with Visual Studio family products. Visual Studio for Mac support for .NET 7 previews isn’t available yet but is coming soon. Now, let’s get into some of the latest updates in this release.</p>
<h3 id="faster-lighter-apps-with-native-aot">Faster, Lighter Apps with Native AOT</h3>
<p>In the <a href="https://devblogs.microsoft.com/dotnet/announcing-dotnet-7-preview-2/#nativeaot-update">.NET 7 Preview 2 blog post</a>, we announced that the Native AOT project has been moved out of experimental status and into mainline development in .NET 7 in the dotnet/runtime repo. We know that many of you have been eagerly awaiting updates from the team on what’s coming for Native AOT, and we have a couple of new updates for you for Preview 3.</p>
<p>If you want details about Native AOT, or to jump in and get started with it, the <a href="https://github.com/dotnet/runtime/blob/main/src/coreclr/nativeaot/docs/compiling.md">repo docs</a> are the best place for that.</p>
<p>We also recognize that some of you might not be familiar with what Native AOT is, so we wanted to share a quick overview of it with you.</p>
<h4 id="what-is-native-aot">What is Native AOT?</h4>
<p>Ahead-of-time (AOT) compilation refers to an umbrella of technologies which generate code at application build time, instead of run-time. AOT is not new to .NET. Today we ship <a href="https://docs.microsoft.com/dotnet/core/deploying/ready-to-run">ReadyToRun</a> for client and server scenarios, and Mono AOT for mobile and WASM. Native AOT brings full native pre-compilation to .NET desktop client and server scenarios. Native AOT is not replacing these existing technologies, rather it’s offering a new set of capabilities that unlocks new form factors.</p>
<p>Existing AOT-compiled .NET assemblies contain platform-specific data structures and native code to frontload work typically done at runtime. Precompiling these artifacts saves time at startup (e.g. ReadyToRun), and enables access to no-JIT platforms (e.g. iOS). If precompiled artifacts are not present, .NET either falls back to JIT or interpretation (depending on the platform).</p>
<p>Native AOT is similar to .NET’s existing AOT technologies, but it produces only native artifacts. In fact, the Native AOT runtime does not know how to read the .NET assembly file formats – everything is platform-native. The executable file format parsing is fully handled by the underlying operating system.</p>
<p>The main advantage of Native AOT is in startup time, memory usage, accessing to restricted platforms (no JIT allowed), and smaller size on disk. Applications start running the moment the operating system pages in them into memory. The data structures are optimized for running AOT generated code, not for compiling new code at runtime. This is similar to how languages like Go, Swift, and Rust compile. Native AOT is best suited for environments where startup time matters the most. Targeting Native AOT has stricter requirements than general .NET Core/5+ applications and libraries. Native AOT forbids emitting new code at runtime (e.g. Reflection.Emit), and loading new .NET assemblies at runtime (eg. plug-in models).</p>
<h4 id="prepare-your-apps-for-native-aot">Prepare your apps for Native AOT</h4>
<p>For .NET 7 we are targeting console apps and <a href="https://github.com/dotnet/samples/blob/main/core/nativeaot/NativeLibrary/README.md">native libraries</a> as the primary scenario for Native AOT. Application developers and library authors can now take advantage of Native AOT by ensuring that their applications are trimmable. Since trimming is a requirement for Native AOT compilation, <a href="https://docs.microsoft.com/dotnet/core/deploying/trimming/trim-self-contained">preparing your applications and libraries</a> now for trimming will help them get ready for Native AOT as well. If you are an author of any .NET libraries, following the <a href="https://docs.microsoft.com/dotnet/core/deploying/trimming/prepare-libraries-for-trimming">“Trimming libraries” instructions</a> specifically will help you prepare your libraries for trimming and Native AOT.</p>
<p>One of the apps that we’re planning to ship in .NET 7 compiled with Native AOT is the crossgen tool. Crossgen is part of the .NET SDK. It’s the CoreCLR AOT compiler that produces ReadyToRun executables. Crossgen is written in C# and we currently ship it compiled with itself as a ReadyToRun app (it’s turtles all the way down!). We’re already seeing some very promising numbers in terms of compilation speed and size. Crossgen benefits heavily from Native AOT because it’s a short-lived process and the startup overhead dominates the overall execution time:</p>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>ReadyToRun</th>
<th>NativeAOT</th>
</tr>
</thead>
<tbody>
<tr>
<td>Compile CoreLib</td>
<td>4182 ms</td>
<td>3512 ms</td>
</tr>
<tr>
<td>Compile HelloWorld</td>
<td>185 ms</td>
<td>49 ms</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Configuration</th>
<th>Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReadyToRun</td>
<td>34.8 MB</td>
</tr>
<tr>
<td>NativeAOT</td>
<td>17.6 MB</td>
</tr>
</tbody>
</table>
<p>Looking ahead, Native AOT compatibility will be improved over the next few versions of .NET, however there will always be reasons to prefer JIT for many scenarios. We will also add first-class support in the dotnet SDK for publishing projects with Native AOT.</p>
<h3 id="observability">Observability</h3>
<p>.NET 7 continues to evolve support for the cloud native OpenTelemetry specification. Preview 3 adds support for specification updates <a href="https://github.com/open-telemetry/opentelemetry-specification/pull/988">#988</a> and <a href="https://github.com/open-telemetry/opentelemetry-dotnet/issues/1708">#1708</a> that make the trace state mutable for samplers.</p>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/65530">Allow Trace Samplers to Modify the Activity Trace State</a></li>
</ul>
<pre><code>    //  ActivityListener Sampling callback
    listener.Sample = (ref ActivityCreationOptions&lt;ActivityContext&gt; activityOptions) =&gt;
    {
        activityOptions = activityOptions with { TraceState = &#34;rojo=00f067aa0ba902b7&#34; };
        return ActivitySamplingResult.AllDataAndRecorded;
    };</code></pre>
<h3 id="system-composition-hosting">System.Composition.Hosting</h3>
<p>The latest Managed Extensibility Framework gets a slight update to align with the previous version APIs. The new APIs allow adding a single object instance to the <a href="https://docs.microsoft.com/dotnet/api/system.composition.hosting.containerconfiguration?view=dotnet-plat-ext-6.0">System.Composition.Hosting container</a>. Similar to the functionality provided in the legacy interfaces <a href="https://docs.microsoft.com/dotnet/api/system.componentmodel.composition.hosting?view=dotnet-plat-ext-6.0">System.ComponentModel.Composition.Hosting</a> with the API <a href="https://docs.microsoft.com/dotnet/api/system.componentmodel.composition.attributedmodelservices.composeexportedvalue?view=dotnet-plat-ext-6.0#system-componentmodel-composition-attributedmodelservices-composeexportedvalue-1(system-componentmodel-composition-hosting-compositioncontainer-0)">ComposeExportedValue(CompositionContainer, T)</a></p>
<p><a href="https://github.com/dotnet/runtime/issues/29400">Proposal: Inject existing object into MEF2</a></p>
<pre><code>namespace System.Composition.Hosting
{
    public class ContainerConfiguration
    {
        public ContainerConfiguration WithExport&lt;TExport&gt;(TExport exportedInstance);
        public ContainerConfiguration WithExport&lt;TExport&gt;(TExport exportedInstance, string contractName = null, IDictionary&lt;string, object&gt; metadata = null);

        public ContainerConfiguration WithExport(Type contractType, object exportedInstance);
        public ContainerConfiguration WithExport(Type contractType, object exportedInstance, string contractName = null, IDictionary&lt;string, object&gt; metadata = null);
    }
}</code></pre>
<h3 id="startup-time-improvements-with-write-xor-execute-enabled">Startup time improvements with Write-Xor-Execute enabled</h3>
<p>Performance continues to be a major focus for .NET 7. The <a href="https://github.com/dotnet/runtime/pull/65738">dotnet/runtime#65738 PR</a> reimplemented the precode and call counting stubs (tiered compilation helper stubs) to significantly reduce number of post-creation modifications of executable code in the runtime. This resulted in 10-15% startup time improvements.</p>
<p>As a bonus, this change also resulted in steady state performance improvements (upto 8%) in some microbenchmarks and some ASPNet Benchmarks even without Write-Xor-Execute enabled.</p>
<p>However, there are few regressions resulting from that change too (without Write-Xor-Execute enabled) that will be addressed in the upcoming preview releases. These were observed in the Orchard and Fortunes benchmarks on Intel processors only.</p>
<h3 id="codegen">CodeGen</h3>
<p>Thanks in a large part to community contributors, Preview 3 features several optimizations and bug fixes to code generation and just-in time (JIT) compilation. Here’s an overview of the changes that are available today.</p>

<p>These pull requests were all initiated by community contributors.</p>
<h5 id="from-clamp03">From @clamp03</h5>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/66282">Enable Fast Tail Call Optimization for ARM32</a></li>
</ul>
<h5 id="from-skifod">From @SkiFoD</h5>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/62818">Optimize “X &amp; 1 == 1” to “X &amp; 1” (#61412)</a></li>
</ul>
<h5 id="from-sandreenko">From @sandreenko</h5>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/65682">[crossgen2] Promote single byref aot</a></li>
</ul>
<h5 id="from-singleaccretion">From @SingleAccretion</h5>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/64805">Fix missing zero-offset sequences and add checking</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/64846">Handle direct addresses for statics in IsFieldAddr</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/64898">Do not number partial definitions and ARGPLACE nodes</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65250">Use SSA def descriptors in copy propagation</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65257">ZeroObj assertions</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65302">Deduplicate some HWI codegen code</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65387">Use push for 8/12 byte struct args on x86</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65709">Do not set GLOB_REF for invariant indirections</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65902">Do not value number locals on the LHS</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65919">Keep the volatility of CLS_VARs in rationalization</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65920">Slightly more aggressive ASG reversal</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66070">Fix copy propagation</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66135">Count OBJ/BLK as memory uses</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66204">Delete compUnsafeCastUsed</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66247">Fix a couple issues with GTF_GLOB_REF setting</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66270">Do not create small constants while morphing cascading addition</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66291">Do not propagate RHS flags in block morphing</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66298">Stop generating CLS_VAR for 64 bit targets</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66335">A better fix for #66242</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66385">Do not assume containment</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66582">Some small copy propagation changes</a></li>
</ul>
<h5 id="from-trympet">From @trympet</h5>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/64951">Treat TZCNT/POPCNT/LZCNT as never negative</a></li>
</ul>
<h5 id="from-wraith2">From @Wraith2</h5>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/66193">Add xarch blsi</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66736">Add flags checks to BMI1 intrinsic lowering</a></li>
</ul>
<h3 id="dynamic-pgo">Dynamic PGO</h3>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/65460">PGO: Profile isinst/castclass in order to optimize them in Tier 1</a></li>
</ul>
<h3 id="arm64">Arm64</h3>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/63821">Morph Vector.Create(0) to Vector.Zero</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65028">Allow constant propagation of Vector.Zero.</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/64783">Optimize Arm64 comparison instructions: cmle, cmlt, fcmle, fcmlt</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65468">Better addressing mode for floating point on arm64</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65535">Optimize a % b</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65632">JIT: Faster vector == Vector128.Zero on arm64</a></li>
</ul>
<h3 id="loop-optimizations">Loop Optimizations</h3>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/66257">Loop Cloning</a> improved the duration of single invocation by 21% for System.Collections.Tests.Perf_BitArray.BitArrayLeftShift(Size: 512):
<img src="https://user-images.githubusercontent.com/63486087/161346652-4964b4f8-7bb1-4c7f-acec-abd70d1dde43.png" alt="image"/></li>
</ul>
<h3 id="general-optimizations">General Optimizations</h3>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/64130">Eliminate extra copy of struct from a callee that was returned in Hidden Buffer</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/65288">Unroll String.Equals and str.StartsWith for constant strings</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66095">Extend Equals/StartsWith auto-vectorization for OrdinalIgnoreCase</a></li>
<li><a href="https://github.com/dotnet/runtime/pull/66245">movzx optimization after setcc shows 0.03 ~ 0.16 % code size reduction</a></li>
</ul>
<h3 id="gc-regions-enabled-by-default">GC Regions Enabled by default</h3>
<p>With Preview 3, regions functionality which should help with memory utilization for high throughput applications has been enabled by default. The functionality is now enabled for all Platforms except MacOS and NativeAOT (which would be enabled in the future). More details are available in this issue: https://github.com/dotnet/runtime/issues/43844</p>
<p>We expect some working set increases for smaller applications due to how regions are initially allocated. If you notice any functional or performance differences please create an issue within the runtime repo.</p>
<h3 id="cryptography-generating-x-500-names-more-robustly">Cryptography: Generating X.500 names more robustly</h3>
<p>This change simplifies working with certificates by introducing a class that provides more clarity for parsing X.500 names.</p>
<p><a href="https://github.com/dotnet/runtime/issues/44738">Make it safer and easier to build an X500DistinguishedName</a></p>
<p>Classically, anyone wanting to build a X.500 name (such as for creating test certificates with the <code>CertificateRequest</code> class did so with string manipulation, either via a simple literal or with string formatting, e.g.</p>
<pre><code>request = new CertificateRequest($&#34;CN={subjectName},OU=Test,O=&#34;&#34;Fabrikam, Inc.&#34;&#34;&#34;, ...);</code></pre>
<p>This is generally fine, except for when <code>subjectName</code> contains a comma, quote, or anything else that has an influence on the parser. To address that, we added the <code>X500DistinguishedNameBuilder</code> class. Because every method only operates on a single relative distinguished name (RDN), there’s no ambiguity in parsing. As a bonus, since the RDN identifiers are expanded, you no longer have to guess what “CN” stands for (“Common Name”).</p>
<pre><code>X500DistinguishedNameBuilder nameBuilder = new();
nameBuilder.AddCommonName(subjectName);
nameBuilder.AddOrganizationalUnitName(&#34;Test&#34;);
nameBuilder.AddOrganizationName(&#34;Fabrikam, Inc.&#34;);

request = new CertificateRequest(nameBuilder.Build(), ...);</code></pre>
<h2 id="targeting-net-7">Targeting .NET 7</h2>
<p>To target .NET 7, you need to use a .NET 7 Target Framework Moniker (TFM) in your project file. For example:</p>
<pre><code>&lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;</code></pre>
<p>The full set of .NET 7 TFMs, including operating-specific ones follows.</p>
<ul>
<li><code>net7.0</code></li>
<li><code>net7.0-android</code></li>
<li><code>net7.0-ios</code></li>
<li><code>net7.0-maccatalyst</code></li>
<li><code>net7.0-macos</code></li>
<li><code>net7.0-tvos</code></li>
<li><code>net7.0-windows</code></li>
</ul>
<p>We expect that upgrading from .NET 6 to .NET 7 should be straightforward. Please report any breaking changes that you discover in the process of testing existing apps with .NET 7.</p>
<h2 id="support">Support</h2>
<p>.NET 7 is a <strong>Current</strong> release, meaning it will receive free support and patches for 18 months from the release date. It’s important to note that the quality of all releases is the same. The only difference is the length of support. For more about .NET support policies, see the <a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core">.NET and .NET Core official support policy</a>.</p>
<h2 id="breaking-changes">Breaking changes</h2>
<p>You can find the most recent list of breaking changes in .NET 7 by reading the <a href="https://docs.microsoft.com/dotnet/core/compatibility/7.0">Breaking changes in .NET 7</a> document. It lists breaking changes by area and release with links to detailed explanations.</p>
<p>To see what breaking changes are proposed but still under review, follow the <a href="https://github.com/dotnet/core/issues/7131">Proposed .NET Breaking Changes GitHub issue</a>.</p>
<h2 id="roadmaps">Roadmaps</h2>
<p>Releases of .NET include products, libraries, runtime, and tooling, and represent a collaboration across multiple teams inside and outside Microsoft. You can learn more about these areas by reading the product roadmaps:</p>
<ul>
<li><a href="https://github.com/dotnet/aspnetcore/issues/39504">ASP.NET Core 7 and Blazor Roadmap</a></li>
<li><a href="https://docs.microsoft.com/ef/core/what-is-new/ef-core-7.0/plan">EF 7 Roadmap</a></li>
<li><a href="https://github.com/dotnet/machinelearning/blob/main/ROADMAP.md">ML.NET</a></li>
<li><a href="https://github.com/dotnet/maui/wiki/Roadmap">.NET MAUI</a></li>
<li><a href="https://github.com/dotnet/winforms/blob/main/docs/roadmap.md">WinForms</a></li>
<li><a href="https://github.com/dotnet/wpf/blob/main/roadmap.md">WPF</a></li>
<li><a href="https://github.com/NuGet/Home/issues/11571">NuGet</a></li>
<li><a href="https://github.com/dotnet/roslyn/blob/main/docs/Language%20Feature%20Status.md">Roslyn</a></li>
<li><a href="https://github.com/dotnet/core/blob/main/roadmap.md">Runtime</a></li>
</ul>
<h2 id="closing">Closing</h2>
<p>We appreciate and <a href="https://dotnet.microsoft.com/thanks">thank you</a> for your all your support and contributions to .NET. Please <a href="https://dotnet.microsoft.com/download/dotnet/7.0">give .NET 7 Preview 3 a try</a> and tell us what you think!</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
