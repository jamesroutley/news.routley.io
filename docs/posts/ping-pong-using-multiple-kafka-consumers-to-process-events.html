<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://otee.dev/2023/06/19/ping-pong.html">Original</a>
    <h1>Ping-pong: Using multiple Kafka consumers to process events</h1>
    
    <div id="readability-page-1" class="page"><div>
        <article>
            
<p><small>June 19, 2023</small></p>

<p>In this post, I write about ping-pong - a project that aims at simulating how messages in a live chatroom (with multiple concurrent users) may get processed, using a Kafka messaging system.</p>

<p>This project makes use of a Kafka producer to push user messages to a topic and uses two independent Kafka consumers to process them. Here’s the github repository for this project: <a href="https://github.com/oitee/ping-pong">https://github.com/oitee/ping-pong</a></p>

<ul id="markdown-toc">
  <li><a href="#system-components" id="markdown-toc-system-components">System Components</a></li>
  <li><a href="#demo" id="markdown-toc-demo">Demo</a></li>
  <li><a href="#generating-user-messages" id="markdown-toc-generating-user-messages">Generating user-messages</a></li>
  <li><a href="#processing-user-messages" id="markdown-toc-processing-user-messages">Processing User Messages</a>    <ul>
      <li><a href="#messages-consumer" id="markdown-toc-messages-consumer">Messages Consumer</a></li>
      <li><a href="#active-users-consumer" id="markdown-toc-active-users-consumer">Active Users Consumer</a></li>
      <li><a href="#tracking-active-users" id="markdown-toc-tracking-active-users">Tracking Active users</a></li>
    </ul>
  </li>
  <li><a href="#importance-of-passing-event-timestamp" id="markdown-toc-importance-of-passing-event-timestamp">Importance of passing event timestamp</a></li>
</ul>

<h2 id="system-components">System Components</h2>

<p>Largely, the system relies on a Kafka producer to push each new user message and on two independent Kafka consumers to process each new message:</p>

<ul>
  <li><strong>Kafka producer:</strong> It pushes new user-generated messages to a common Kafka topic. These messages are meant to be consumed by different consumers.</li>
  <li><strong>Messages consumer:</strong> This consumer reads each event (<em>containing user-generated messages</em>) from the Kafka topic and prints out the contents of each user message</li>
  <li><strong>Active users consumer:</strong> This consumer consumes each Kafka event and periodically publishes a list of all active users.</li>
  <li><strong>Redis:</strong> The active users consumer stores each active user, in a Redis store, and periodically fetches the list of all active users from this store.</li>
</ul>

<p>The interaction of the above components are demonstrated in the following sequence diagram:</p>

<p><a href="https://otee.dev/assets/images/ping_pong_sequence.png">
    <img src="https://otee.dev/assets/images/ping_pong_sequence.png" width="100%"/>
</a></p>

<h2 id="demo">Demo</h2>

<p>Before going ahead with further details, here is a demo of the system:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/2VD-P0W7UXU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<h2 id="generating-user-messages">Generating user-messages</h2>

<p>User-messages have to be generated before pushing them to the Kafka producer. To simulate a chat-room:</p>

<ul>
  <li>A list of users is hard-coded in the project (present in <code>ping-pong.utils</code> name-space). As an avid fan of The Office (US), the users are all the characters of <a href="https://en.wikipedia.org/wiki/List_of_The_Office_(American_TV_series)_characters">The Office(US)</a>
    <ul>
      <li><img src="https://media.tenor.com/mKfeCtD5EukAAAAC/the-office-the.gif" width="20%"/></li>
    </ul>
  </li>
  <li>
    <p>Using the list of user-names, a one-time list of emails for each user is generated by randomly using a list of common email domains and the user-names of each user. Each user entity, thus, is represented as follows:</p>

    <div><div><pre><code><span>  </span><span>{</span><span>:user</span><span> </span><span>&#34;Micheal Scott&#34;</span><span>
   </span><span>:email</span><span> </span><span>&#34;micheal.scott@gmail.com&#34;</span><span>}</span><span>
</span></code></pre></div>    </div>
  </li>
  <li>The list of user-entities is stored in an atom called <code>users</code> in the <code>ping-pong.users</code> namespace. This namespace exposes a function called <code>get-user</code> that randomly returns a user-object from this atom.</li>
  <li>The <code>ping-pong.producer</code> periodically fetches a user-entity from this function and sends two types of Kafka events:
    <ul>
      <li>
        <p><strong>Messages</strong>: Every second, after fetching a user entity, it makes a HTTP get request to an <a href="https://favqs.com/api/qotd">open API</a> which returns random quotes. This forms the message body of the respective user. Finally, it sends the Kafka event. Here’s a snapshot of how this is done (the entire namespace can be found <a href="https://github.com/oitee/ping-pong/blob/master/src/ping_pong/producer.clj">here</a>):</p>

        <div><div><pre><code><span>  </span><span>(</span><span>def</span><span> </span><span>quotes-url</span><span> </span><span>&#34;https://favqs.com/api/qotd&#34;</span><span>)</span><span>
        
  </span><span>(</span><span>defn</span><span> </span><span>get-user-message</span><span>
    </span><span>[]</span><span>
    </span><span>(</span><span>let</span><span> </span><span>[</span><span>response</span><span> </span><span>(</span><span>clj-http.client/get</span><span> </span><span>quotes-url</span><span>)]</span><span>
      </span><span>(</span><span>if</span><span> </span><span>(</span><span>=</span><span> </span><span>(</span><span>:status</span><span> </span><span>response</span><span>)</span><span> </span><span>200</span><span>)</span><span>
        </span><span>(</span><span>-&gt;</span><span> </span><span>response</span><span>
            </span><span>:body</span><span>
            </span><span>cheshire.core/parse-string</span><span>
            </span><span>clojure.walk/keywordize-keys</span><span>
            </span><span>(</span><span>get-in</span><span> </span><span>[</span><span>:quote</span><span> </span><span>:body</span><span>]))</span><span>
        </span><span>&#34;&#34;</span><span>)))</span><span>
        
  </span><span>(</span><span>defn</span><span> </span><span>create-and-send-messages</span><span>
    </span><span>[</span><span>interval</span><span>]</span><span>
    </span><span>(</span><span>while</span><span> </span><span>@</span><span>continue?</span><span>
      </span><span>(</span><span>let</span><span> </span><span>[</span><span>current-ts</span><span> </span><span>(</span><span>System/currentTimeMillis</span><span>)</span><span>
            </span><span>{</span><span>:keys</span><span> </span><span>[</span><span>name</span><span> </span><span>email</span><span>]}</span><span> </span><span>(</span><span>ping-pong.users/get-user</span><span>)</span><span>
            </span><span>user-message</span><span> </span><span>(</span><span>get-user-message</span><span>)</span><span>
            </span><span>activity</span><span> </span><span>(</span><span>:send-message</span><span> </span><span>ping-pong.utils/allowed-activities</span><span>)]</span><span>
        </span><span>(</span><span>send-message</span><span> </span><span>(</span><span>cheshire.core/generate-string</span><span> </span><span>{</span><span>:user</span><span> </span><span>name</span><span>
                                                      </span><span>:email</span><span> </span><span>email</span><span>
                                                      </span><span>:activity</span><span> </span><span>activity</span><span>
                                                      </span><span>:message</span><span> </span><span>user-message</span><span>
                                                      </span><span>:ts</span><span> </span><span>current-ts</span><span>})))</span><span>
      </span><span>(</span><span>Thread/sleep</span><span> </span><span>interval</span><span>)))</span><span>
</span></code></pre></div>        </div>
      </li>
      <li>
        <p><strong>Hearbeats</strong>: These events are sent at random intervals (between 1 and 7 seconds) and are meant to represent a user is active, even though they are not typing a new message. Unlike a message event, a heartbeat event does not contain any <code>message</code> key in the payload(the entire namespace can be found <a href="https://github.com/oitee/ping-pong/blob/master/src/ping_pong/producer.clj">here</a>):</p>
      </li>
    </ul>

    <div><div><pre><code><span>  </span><span>(</span><span>defn</span><span> </span><span>send-heartbeats</span><span>
    </span><span>[]</span><span>
    </span><span>(</span><span>while</span><span> </span><span>@</span><span>continue?</span><span>
      </span><span>(</span><span>let</span><span> </span><span>[</span><span>current-ts</span><span> </span><span>(</span><span>System/currentTimeMillis</span><span>)</span><span>
            </span><span>{</span><span>:keys</span><span> </span><span>[</span><span>name</span><span> </span><span>email</span><span>]}</span><span> </span><span>(</span><span>ping-pong.users/get-user</span><span>)</span><span>
            </span><span>min-interval</span><span> </span><span>1000</span><span>
            </span><span>rand-interval</span><span> </span><span>(</span><span>+</span><span> </span><span>min-interval</span><span> </span><span>(</span><span>rand-int</span><span> </span><span>7000</span><span>))</span><span>
            </span><span>activity</span><span> </span><span>(</span><span>:heart-beat</span><span> </span><span>ping-pong.utils/allowed-activities</span><span>)]</span><span>
        </span><span>(</span><span>send-message</span><span> </span><span>(</span><span>cheshire.core/generate-string</span><span> </span><span>{</span><span>:user</span><span> </span><span>name</span><span>
                                                      </span><span>:email</span><span> </span><span>email</span><span>
                                                      </span><span>:activity</span><span> </span><span>activity</span><span>
                                                      </span><span>:ts</span><span> </span><span>current-ts</span><span>}))</span><span>
        </span><span>(</span><span>Thread/sleep</span><span> </span><span>rand-interval</span><span>))))</span><span>
</span></code></pre></div>    </div>

    <p>Here’s a sequence diagram representing how the producer generates kafka events:</p>

    <p><a href="https://otee.dev/assets/images/kafka_producer.png">
      <img src="https://otee.dev/assets/images/kafka_producer.png" width="100%"/>
  </a></p>
  </li>
</ul>

<h2 id="processing-user-messages">Processing User Messages</h2>

<p>This project uses two different Kafka consumers to process each Kafka event:</p>

<ul>
  <li><strong>Messages Consumer:</strong> This consumer consumes each Kafka event and prints out the message payload</li>
  <li><strong>Active Users Consumer:</strong> This consumer consumes each Kafka event and stores each user in a Redis store. Every three seconds, it prints out the current list of active users by querying the Redis store.</li>
</ul>

<h3 id="messages-consumer">Messages Consumer</h3>

<p>This consumer does three things:</p>

<ul>
  <li>Consumes each event</li>
  <li>Checks if the <code>activity</code> key to determine if it is a <code>send-message</code> event.</li>
  <li>If yes, it prints out the message along with the user name.</li>
</ul>

<p>Here’s a code-snapshot of this (the entire code can be found <a href="https://github.com/oitee/ping-pong/blob/master/src/ping_pong/messages_consumer.clj">here</a>):</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>print-message</span><span>
  </span><span>[</span><span>user</span><span> </span><span>m</span><span>]</span><span>
  </span><span>(</span><span>println</span><span> </span><span>(</span><span>format</span><span> </span><span>&#34;%s: %s&#34;</span><span>
                   </span><span>user</span><span>
                   </span><span>m</span><span>)))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>start-print-messages-consumer</span><span>
  </span><span>[]</span><span>
  </span><span>(</span><span>let</span><span> </span><span>[</span><span>continue-fn</span><span> </span><span>(</span><span>fn</span><span> </span><span>[</span><span>_</span><span>]</span><span> </span><span>@</span><span>continue?</span><span>)</span><span>
        </span><span>consuming-fn</span><span> </span><span>(</span><span>fn</span><span>
                       </span><span>[</span><span>value</span><span>]</span><span>
                       </span><span>(</span><span>let</span><span> </span><span>[{</span><span>:keys</span><span> </span><span>[</span><span>user</span><span> </span><span>message</span><span> </span><span>activity</span><span>]}</span><span> </span><span>(</span><span>ping-pong.utils/keywordise-payload</span><span> </span><span>value</span><span>)]</span><span>
                         </span><span>(</span><span>when</span><span> </span><span>(</span><span>=</span><span> </span><span>activity</span><span> </span><span>(</span><span>:send-message</span><span> </span><span>ping-pong.utils/allowed-activities</span><span>))</span><span>
                           </span><span>(</span><span>print-message</span><span> </span><span>user</span><span> </span><span>message</span><span>))))]</span><span>
    </span><span>(</span><span>utils/start-consuming</span><span> </span><span>consumer-config</span><span>
                           </span><span>utils/topic</span><span>
                           </span><span>continue-fn</span><span>
                           </span><span>consuming-fn</span><span>)))</span><span> 
</span></code></pre></div></div>

<p>Here’s a sequence diagram of the above:</p>

<p><a href="https://otee.dev/assets/images/kafka_messages_consumer.png">
    <img src="https://otee.dev/assets/images/kafka_messages_consumer.png" width="100%"/>
</a></p>

<h3 id="active-users-consumer">Active Users Consumer</h3>

<p>Broadly, this consumer consumes each Kafka event, and stores the user in the Redis store along with the timestamp mentioned in the event payload. The Redis store keeps a timestamp-to-user mapping inside a sorted set.</p>

<p>Every three seconds, the Redis store is queried for fetching the current set of active users. An active user is defined as a user who is seen at least once in the past 30 seconds.</p>

<p>Here’s a snapshot of how this is done (the entire code can be found <a href="https://github.com/oitee/ping-pong/blob/master/src/ping_pong/active_users_consumer.clj">here</a>)</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>start-active-users-consumer</span><span>
  </span><span>[</span><span>sys</span><span>]</span><span>
  </span><span>(</span><span>let</span><span> </span><span>[</span><span>continue-fn</span><span> </span><span>(</span><span>fn</span><span> </span><span>[</span><span>_</span><span>]</span><span> </span><span>@</span><span>continue?</span><span>)</span><span>
        </span><span>consuming-fn</span><span> </span><span>(</span><span>fn</span><span>
                       </span><span>[</span><span>value</span><span>]</span><span>
                       </span><span>(</span><span>let</span><span> </span><span>[{</span><span>:keys</span><span> </span><span>[</span><span>ts</span><span> </span><span>user</span><span> </span><span>email</span><span>]}</span><span> </span><span>(</span><span>utils/keywordise-payload</span><span> </span><span>value</span><span>)]</span><span>
                         </span><span>(</span><span>add-user</span><span> </span><span>sys</span><span> </span><span>user</span><span> </span><span>email</span><span> </span><span>ts</span><span>)))]</span><span>
    </span><span>(</span><span>ping-pong.utils/start-consuming</span><span> </span><span>consumer-config</span><span>
                                     </span><span>utils/topic</span><span>
                                     </span><span>continue-fn</span><span>
                                     </span><span>consuming-fn</span><span>)))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>print-active-users</span><span>
  </span><span>[]</span><span>
  </span><span>(</span><span>while</span><span> </span><span>@</span><span>continue?</span><span>
    </span><span>(</span><span>let</span><span> </span><span>[</span><span>active-users</span><span> </span><span>(</span><span>get-active-users</span><span>)]</span><span>
      </span><span>(</span><span>if</span><span> </span><span>(</span><span>empty?</span><span> </span><span>active-users</span><span>)</span><span>
        </span><span>(</span><span>println</span><span> </span><span>&#34;No Active Users...&#34;</span><span>)</span><span>
        </span><span>(</span><span>do</span><span> </span><span>(</span><span>println</span><span> </span><span>&#34;Active Users:&#34;</span><span>)</span><span>
            </span><span>(</span><span>run!</span><span> </span><span>#</span><span>(</span><span>print</span><span> </span><span>(</span><span>str</span><span> </span><span>%</span><span> </span><span>&#34;, &#34;</span><span>))</span><span> </span><span>active-users</span><span>)</span><span>
            </span><span>(</span><span>println</span><span> </span><span>&#34;\n---&#34;</span><span>))))</span><span>
    </span><span>(</span><span>Thread/sleep</span><span> </span><span>3000</span><span>))</span><span>
  </span><span>(</span><span>println</span><span> </span><span>&#34;----xx---&#34;</span><span>))</span><span>
</span></code></pre></div></div>

<p>Here’s a sequence diagram of the above:</p>

<p><a href="https://otee.dev/assets/images/kafka_active_users_consumer.png">
    <img src="https://otee.dev/assets/images/kafka_active_users_consumer.png" width="100%"/>
</a></p>

<h3 id="tracking-active-users">Tracking Active users</h3>

<p>The system relies on Redis to store active users. Specifically, a sorted set is used for storing users. In a sorted set, entities are sorted on the basis of their respective scores. In the present case case, the event time-stamp is the score.</p>

<div><div><pre><code><span>(</span><span>def</span><span> </span><span>store</span><span> </span><span>&#34;sorted:users&#34;</span><span>)</span><span>
</span><span>(</span><span>def</span><span> </span><span>jedis</span><span> </span><span>(</span><span>JedisPooled.</span><span> </span><span>&#34;localhost&#34;</span><span> </span><span>6379</span><span>))</span><span>

</span><span>(</span><span>defn</span><span> </span><span>add-user</span><span>
  </span><span>[</span><span>username</span><span> </span><span>email</span><span> </span><span>score</span><span>]</span><span>
  </span><span>(</span><span>let</span><span> </span><span>[</span><span>user</span><span> </span><span>(</span><span>format</span><span> </span><span>&#34;%s::%s&#34;</span><span> </span><span>username</span><span> </span><span>email</span><span>)]</span><span>
    </span><span>(</span><span>.zadd</span><span> </span><span>jedis</span><span> </span><span>store</span><span> </span><span>(</span><span>double</span><span> </span><span>score</span><span>)</span><span> </span><span>user</span><span>)))</span><span>
</span></code></pre></div></div>

<p>Thus, every time we need to fetch active users, we can query the sorted set in Redis, by using <code>zrangeByScore</code> where the <code>min</code> score is the cutoff timestamp (i.e., 30 seconds prior to the current time-stamp) and the <code>max</code> score is the current timestamp.</p>

<p>Importantly, while fetching the list of active users, it is important to clean up redundant data, i.e., all users with a score less than the cutoff timestamp.</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>get-active-users</span><span>
  </span><span>[]</span><span>
  </span><span>(</span><span>let</span><span> </span><span>[</span><span>curr-ts</span><span> </span><span>(</span><span>double</span><span> </span><span>(</span><span>System/currentTimeMillis</span><span>))</span><span>
        </span><span>cutoff-ts</span><span> </span><span>(</span><span>double</span><span> </span><span>(</span><span>-</span><span> </span><span>curr-ts</span><span> </span><span>30000</span><span>))</span><span>
        </span><span>active-users</span><span> </span><span>(</span><span>.zrangeByScore</span><span> </span><span>jedis</span><span> </span><span>store</span><span> </span><span>cutoff-ts</span><span> </span><span>curr-ts</span><span>)]</span><span>
    </span><span>;; Remove users who were active before the cutoff time-stamp</span><span>
    </span><span>(</span><span>.zremrangeByScore</span><span> </span><span>jedis</span><span> </span><span>store</span><span> </span><span>Double/NEGATIVE_INFINITY</span><span> </span><span>(</span><span>dec</span><span> </span><span>cutoff-ts</span><span>))</span><span>
    </span><span>(</span><span>map</span><span> </span><span>#</span><span>(</span><span>first</span><span> </span><span>(</span><span>cs/split</span><span> </span><span>%</span><span> </span><span>#</span><span>&#34;::&#34;</span><span>))</span><span> </span><span>active-users</span><span>)))</span><span>
</span></code></pre></div></div>

<h2 id="importance-of-passing-event-timestamp">Importance of passing event timestamp</h2>

<p>Notably, we are using the time-stamp value recorded in the Kafka event (i.e. <strong>event timestamp</strong>), while pushing a user in the redis store. This may seem redundant: we can use the current time-stamp at the time of consuming the events to do this (i.e. <strong>processing timestamp</strong>). This will reduce the payload of the kafka event.</p>

<p>However, relying on processing timestamp may lead to inconsistencies if the consumer dies in the middle of consuming events. In such an event, there will be a gap before consumption can resume. When the consumer resumes comsumption, it will start with consuming the pending events. Many of these events would be stale events. Without the event timestamp recorded in the event payload, all these events will be considered as “new” events. However, by relying on the event time-stamp, the consumer can easily detect stale events and reject them as inactive.</p>



        </article>
    </div></div>
  </body>
</html>
