<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nadrieril.github.io/blog/2025/12/21/the-algebra-of-loans-in-rust.html">Original</a>
    <h1>The Algebra of Loans in Rust</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>The heart of Rust borrow-checking is this: when a borrow is taken, and until it expires, access to
the borrowed place is restricted. For example you may not read from a place while it is mutably
borrowed.</p>

<p>Over the recent months, lively discussions have been happening around teaching the borrow-checker
to understand more things than just “shared borrow”/”mutable borrow”.
We’re starting to have a few ideas floating around, so I thought I put them all down in a table so
we can see how they interact.
I’ll start with the tables and explain the new reference types after.</p>

<p>To clarify the vocabulary I’ll be using:</p>
<ul>
  <li>A “place” is a memory location, represented by an expression like <code>x</code>, <code>*x</code>, <code>x.field</code> etc<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">1</a></sup>;</li>
  <li>“Taking a borrow” is the action of evaluating <code>&amp;place</code>, <code>&amp;mut place</code>, <code>&amp;own place</code> etc to a value;</li>
  <li>A “loan” happens when we take a borrow of a place. The loan remembers the place that was borrowed
and the kind of reference used to borrow it. When we take that borrow, the resulting reference
type gets a fresh lifetime; as long as that lifetime is present in the type of a value somewhere,
the loan is considered “live”;</li>
  <li>While a loan is live, further operations on the borrowed place are restricted;</li>
  <li>After the loan expires, operations on the borrowed place may be restricted too.</li>
</ul>

<p>Note: These tables are not enough to understand everything about these new references. E.g. after
you write to a <code>&amp;uninit</code> you can reborrow it as <code>&amp;own</code>, and vice-versa; this is not reflected in the
tables. Another example: dropping the contents of a place removes any pinning restriction placed on
it.</p>

<h4 id="table-1-given-a-reference-what-actions-are-possible-with-it">Table 1: Given a reference, what actions are possible with it</h4>

<p>How to read this table: the reference I have gives me the column, the action I want to do with it
gives me the row (the reference types mean that the action is a reborrow with that type).</p>

<p>For example, if I have a <code>&amp;own T</code> I can reborrow it into a <code>&amp;mut T</code> but not a <code>&amp;pin own T</code>. If
I have a <code>&amp;mut T</code> I may write a new value to it but not drop its contents.</p>

<p>“Move out” means “move the value out without putting a new one in”. “Drop” means “run the drop code
in-place”.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>&amp;</th>
      <th>&amp;mut</th>
      <th>&amp;own</th>
      <th>&amp;pin</th>
      <th>&amp;pin mut</th>
      <th>&amp;pin own</th>
      <th>&amp;uninit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>&amp;</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;mut</strong></td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;own</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;pin</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;pin mut</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;pin own</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;uninit</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>Read</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>Write</strong></td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>Move out</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>Drop</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>

<h4 id="table-2-if-a-loan-was-taken-and-is-live-what-can-i-still-do-to-the-place">Table 2: If a loan was taken and is live, what can I still do to the place</h4>

<p>How to read this table: a borrow of place <code>p</code> was taken and is still live; the kind of borrow gives
me the column. The operations I may still do on the place (without going through that borrow) give
me the row.</p>

<p>For example, if a <code>&amp;</code>-borrow was taken and is live, I may still read the place.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>&amp;</th>
      <th>&amp;mut</th>
      <th>&amp;own</th>
      <th>&amp;pin</th>
      <th>&amp;pin mut</th>
      <th>&amp;pin own</th>
      <th>&amp;uninit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>&amp;</strong></td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;mut</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;own</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;pin</strong></td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;pin mut</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;pin own</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;uninit</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>Read</strong></td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>Write</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>Move out</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>Drop</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>

<p>Unsurprisingly, most of the time we can’t do anything else to the place, because the borrow is
exclusive.</p>

<h4 id="table-3-if-a-loan-was-taken-and-expired-what-can-i-now-do-to-the-place">Table 3: If a loan was taken and expired, what can I now do to the place</h4>

<p>How to read this table: a borrow of place <code>p</code> was taken and has expired; the kind of borrow gives me
the column. The operations I may now do on the place give me the row.</p>

<p>For example, if a <code>&amp;</code>-borrow was taken and expired, I may no longer read the place.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>&amp;</th>
      <th>&amp;mut</th>
      <th>&amp;own</th>
      <th>&amp;pin</th>
      <th>&amp;pin mut</th>
      <th>&amp;pin own</th>
      <th>&amp;uninit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>&amp;</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;mut</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;own</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;pin</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;pin mut</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;pin own</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>&amp;uninit</strong></td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>Read</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>Write</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>Move out</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td><strong>Drop</strong></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>

<p><code>&amp;own</code> and <code>&amp;uninit</code> both have the property that when they expire the place is considered to have
been uninitialized. So we the only actions available are those that work on uninitialized places:
writing and <code>&amp;uninit</code> borrows.</p>

<p>The other point to note are the pinning loans: after a pinning loan expires, non-pinning mutable
loans can’t be taken of that same place until the value is dropped.</p>

<h2 id="whats-with-all-these-new-reference-types">What’s with all these new reference types?</h2>

<p>All of these are speculative ideas, but at this point they’ve been circulating a bunch so should be
pretty robust.</p>

<h3 id="the-owning-reference-own-t">The owning reference <code>&amp;own T</code></h3>

<p><code>&amp;own T</code><sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">2</a></sup> (which has also been called <code>&amp;move T</code>) is a reference that says “I have full ownership over
this value, in particular I am responsible for dropping it”. It feels like <code>Box</code> except that we
don’t control the allocation the value resides in. In particular, we can move the <code>T</code> out of a <code>&amp;own
T</code>.</p>

<p>Like <code>Box</code>, <code>&amp;own T</code> drops the contained value when it is dropped.</p>

<p>When I owning-borrow <code>&amp;own x</code> a place, I have given up full ownership of the value, and thus must
assume that the place is uninitialized when the borrow expires.</p>

<p>It makes for some interesting APIs:</p>
<div><div><pre><code><span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>Vec</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>// Pop the last value and return a reference to it (instead of moving it out directly).</span>
    <span>fn</span> <span>pop_own</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;&amp;</span><span>own</span> <span>T</span><span>&gt;</span> <span>{</span> <span>..</span> <span>}</span>
    <span>// Iterate over the contained values, emptying the Vec as we go.</span>
    <span>fn</span> <span>drain_own</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>impl</span> <span>Iterator</span><span>&lt;</span><span>Item</span> <span>=</span> <span>&amp;</span><span>own</span> <span>T</span><span>&gt;</span> <span>{</span> <span>..</span> <span>}</span>
<span>}</span>
</code></pre></div></div>

<h3 id="the-uninitialized-reference-uninit-t">The uninitialized reference <code>&amp;uninit T</code></h3>

<p><code>&amp;uninit T</code><sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">3</a></sup> (which has also been called <code>&amp;out T</code>) is a reference to an allocated but
not-yet-initialized location. Much like when we do <code>let x;</code>, the only thing one can do with that
reference is write to it. Once written to, it can be reborrowed into everything we want.</p>

<div><div><pre><code><span>// Typical usage is to initialize a value:</span>
<span>impl</span> <span>MyType</span> <span>{</span>
    <span>fn</span> <span>init</span><span>(</span><span>&amp;</span><span>uninit</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>own</span> <span>Self</span> <span>{</span>
        <span>*</span><span>self</span> <span>=</span> <span>new_value</span><span>();</span>
        <span>&amp;</span><span>own</span> <span>*</span><span>self</span>
    <span>}</span>
<span>}</span>
<span>let</span> <span>x</span><span>:</span> <span>MyType</span><span>;</span>
<span>let</span> <span>ptr</span><span>:</span> <span>&amp;</span><span>own</span> <span>MyType</span> <span>=</span> <span>MyType</span><span>::</span><span>init</span><span>(</span><span>&amp;</span><span>uninit</span> <span>x</span><span>);</span>
<span>// `ptr` can be used much like a `Box` would. It cannot be returned from the</span>
<span>// current function though.</span>
</code></pre></div></div>

<p>It has a nice synergy with <code>&amp;own T</code>: we can get from <code>&amp;uninit T</code> to <code>&amp;own T</code> by writing a value into
the reference, and get from <code>&amp;own T</code> to <code>&amp;uninit T</code> by moving the value out of the reference.</p>

<p>Both have the property that when they expire, the original place is considered uninitialized<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">4</a></sup>.</p>

<h3 id="the-pinning-references-pin-tpin-mut-tpin-own-t">The pinning references <code>&amp;pin T</code>/<code>&amp;pin mut T</code>/<code>&amp;pin own T</code></h3>

<blockquote>
  <p>Pinning is a notoriously subtle notion, if you’re not familiar with it I recommand <a href="https://doc.rust-lang.org/std/pin/index.html">the std docs
on the topic</a>. If you are familiar with it you may
instead enjoy <a href="https://nadrieril.github.io/blog/2025/11/12/pinning-is-a-kind-of-static-borrow.html">this blog post of
mine</a> that
shines an original light on the notion.</p>
</blockquote>

<p>Pinning references are variants of the existing reference types that also add a “pinning
requirement” to the borrowed place. This requirement forbids moving the value out or deallocating
the place without running <code>Drop</code> on the value first. This applies even after the pinning borrow has
expired.</p>

<p><code>&amp;pin mut T</code><sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">5</a></sup> is the most common of these, it exists in today’s Rust as <code>Pin&lt;&amp;mut T&gt;</code> and is crucial
to our async story. <code>&amp;pin T</code> would be <code>Pin&lt;&amp;T&gt;</code>; it’s less clear how useful it is but I can imagine
usecases.</p>

<p><code>&amp;pin own T</code> finally would be the owning variant. This one has the tricky requirement that it must
not be passed to <code>mem::forget</code> as that would break the drop invariant. This isn’t possible in
today’s Rust, but there have been proposals over the years as such non-forgettable types are needed
for other things.</p>

<p>One funky aspect of <code>&amp;pin own T</code> is that I think it’s ok to reborrow a <code>&amp;own T</code> into a <code>&amp;pin own T</code>:
since the only way for the borrow to expire entails dropping the pointed-to value, there’s no way to
break the pin guarantee so it doesn’t matter how we got that reference.</p>

<p>You’ll notice I didn’t list <code>&amp;pin uninit T</code>. That’s because pinning is a property of a value, and
<code>&amp;pin uninit T</code> doesn’t point to a value. To pin-initialize a value, one can just write the value to
a <code>&amp;uninit T</code> then reborrow <code>&amp;uninit T -&gt; &amp;own T -&gt; &amp;pin own T</code>.</p>



  </div>

  

</article>

      </div>
    </div></div>
  </body>
</html>
