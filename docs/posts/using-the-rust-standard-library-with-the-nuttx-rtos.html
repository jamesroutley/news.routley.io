<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lupyuen.org/articles/rust7.html">Original</a>
    <h1>Using the Rust standard library with the NuttX RTOS</h1>
    
    <div id="readability-page-1" class="page">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    
    <nav id="rustdoc"><ul>
<li><a href="#compile-our-rust-hello-app" title="Compile our Rust Hello App">1 Compile our Rust Hello App</a><ul></ul></li>
<li><a href="#json-with-serde" title="JSON with Serde">2 JSON with Serde</a><ul></ul></li>
<li><a href="#async-functions-with-tokio" title="Async Functions with Tokio">3 Async Functions with Tokio</a><ul></ul></li>
<li><a href="#led-blinky-with-nix" title="LED Blinky with Nix">4 LED Blinky with Nix</a><ul></ul></li>
<li><a href="#owned-file-descriptors" title="Owned File Descriptors">5 Owned File Descriptors</a><ul></ul></li>
<li><a href="#nix-vs-rustix" title="Nix vs Rustix">6 Nix vs Rustix</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-rust-standard-library" title="Appendix: Build NuttX for Rust Standard Library">8 Appendix: Build NuttX for Rust Standard Library</a><ul></ul></li>
<li><a href="#appendix-tokio-async-threading" title="Appendix: Tokio Async Threading">9 Appendix: Tokio Async Threading</a><ul></ul></li>
<li><a href="#appendix-porting-nix-to-nuttx" title="Appendix: Porting Nix to NuttX">10 Appendix: Porting Nix to NuttX</a><ul></ul></li>
<li><a href="#appendix-porting-rustix-to-nuttx" title="Appendix: Porting Rustix to NuttX">11 Appendix: Porting Rustix to NuttX</a><ul></ul></li>
<li><a href="#appendix-snooping-tokio-on-nuttx" title="Appendix: Snooping Tokio on NuttX">12 Appendix: Snooping Tokio on NuttX</a><ul></ul></li></ul></nav><p>üìù <em>26 Jan 2025</em></p>
<p><img src="https://lupyuen.org/images/rust7-title.png" alt="LED Blinky with Rust Standard Library on Apache NuttX RTOS (RustRover IDE)"/></p>
<p><strong>Freshly Baked:</strong> Here‚Äôs how we <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs"><strong>Blink the LED</strong></a> with <strong>Rust Standard Library</strong> on <a href="https://nuttx.apache.org/docs/latest/index.html"><strong>Apache NuttX RTOS</strong></a>‚Ä¶</p>

<div><pre><code><span>let </span>fd = open(      <span>&#34;/dev/userleds&#34;</span>,  OFlag::O_WRONLY,  Mode::empty()     ).unwrap();         <span>const </span>ULEDIOC_SETALL: i32 = <span>0x1d03</span>;  <span>ioctl_write_int_bad!</span>(  led_set_all,         ULEDIOC_SETALL       );

<span>unsafe </span>{             led_set_all(       fd.as_raw_fd(),  <span>1                </span>).unwrap();        }  <span>unsafe </span>{ led_set_all(fd.as_raw_fd(), <span>0</span>).unwrap(); }</code></pre></div>
<p>Which requires the <strong><code>nix</code> Rust Crate</strong> / Library‚Ä¶</p>
<div><pre><code>## Add the `nix` Rust Crate
## To our NuttX Rust App
$ cd apps/examples/rust/hello
$ cargo add nix --features fs,ioctl

Updating crates.io index
Adding nix v0.29.0 to dependencies
Features: + fs + ioctl</code></pre></div>
<p><em>(OK it‚Äôs more complicated. Stay tuned)</em></p>
<p>All this is now possible, thanks to the awesome work by <a href="https://github.com/apache/nuttx-apps/pull/2487"><strong>Huang Qi</strong></a>! üéâ</p>
<p>In today‚Äôs article, we explain‚Ä¶</p>
<ul>
<li>
<p>How to build <strong>NuttX + Rust Standard Library</strong></p>
</li>
<li>
<p><strong>Handling JSON</strong> with the Serde Crate</p>
</li>
<li>
<p><strong>Async Functions</strong> with the Tokio Crate</p>
</li>
<li>
<p><strong>Blinking LEDs</strong> with the Nix Crate</p>
</li>
<li>
<p>How we ported <strong>Nix to NuttX</strong></p>
</li>
<li>
<p>Why Nix? <strong>Rustix</strong> might be better</p>
</li>
<li>
<p>Why <strong>File Descriptors are ‚ÄúOwned‚Äù</strong> in Rust</p>
</li>
</ul>

<p><em>How to build NuttX + Rust Standard Library?</em></p>
<p>Follow the instructions here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.org/articles/rust7#appendix-build-nuttx-for-rust-standard-library"><strong>‚ÄúBuild NuttX for Rust Standard Library‚Äù</strong></a></li>
</ul>
<p>Then run the (thoroughly revamped) <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs"><strong>Rust Hello App</strong></a> with <strong>QEMU RISC-V Emulator</strong>‚Ä¶</p>
<div><pre><code>## Start NuttX on QEMU RISC-V 64-bit
$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

## Run the Rust Hello App
NuttShell (NSH) NuttX-12.8.0
nsh&gt; hello_rust_cargo

{&#34;name&#34;:&#34;John&#34;,&#34;age&#34;:30}
{&#34;name&#34;:&#34;Jane&#34;,&#34;age&#34;:25}
Deserialized: Alice is 28 years old

Pretty JSON:
{
  &#34;name&#34;: &#34;Alice&#34;,
  &#34;age&#34;: 28
}

Hello world from tokio!</code></pre></div>
<p>Some bits are <a href="https://lupyuen.org/articles/rust7#appendix-build-nuttx-for-rust-standard-library"><strong>a little wonky</strong></a> (but will get better)</p>
<ul>
<li>
<p>Supports <a href="https://nuttx.apache.org/docs/latest/guides/rust.html"><strong>Arm and RISC-V</strong></a> architectures <em>(32-bit and 64-bit)</em></p>
</li>
<li>
<p>Works on <strong>Rust Nightly Toolchain</strong> <em>(not Rust Stable)</em></p>
</li>
<li>
<p>Needs a tiny patch to <strong>Local Toolchain</strong> <em>(pal/unix/fs.rs)</em></p>
</li>
<li>
<p>Sorry no <strong>RISC-V Floating Point</strong> and no <strong>Kernel Build</strong></p>
</li>
</ul>
<p>What‚Äôs inside the brand new Rust Hello App? We dive in‚Ä¶</p>
<p><img src="https://lupyuen.org/images/rust7-json2.png" alt="JSON with Serde on Apache NuttX RTOS (Neovim IDE)"/></p>

<p><em>What‚Äôs this Serde?</em></p>
<p>Think <em>‚ÄúSerialize-Deserialize‚Äù</em>. <a href="https://crates.io/crates/serde"><strong>Serde</strong></a> is a Rust Crate / Library for Serializing and Deserializing our Data Structures. Works with <a href="https://serde.rs/#data-formats"><strong>JSON, CBOR, MessagePack, ‚Ä¶</strong></a></p>
<p>This is how we <strong>Serialize to JSON</strong> in our Hello Rust App: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs#L1-L32">nuttx-apps/lib.rs</a></p>

<div><pre><code><span>#[derive(Serialize, Deserialize)]
</span><span>struct </span>Person {
  name: String,  age:  u8,      }  <span>#[no_mangle]
</span><span>pub extern </span><span>&#34;C&#34; </span><span>fn </span>hello_rust_cargo_main() {

  <span>let </span>john = Person {
    name: <span>&#34;John&#34;</span>.to_string(),
    age:  <span>30</span>,
  };

  <span>let </span>json_str = serde_json ::to_string(<span>&amp;</span>john)  .unwrap();          <span>println!</span>(<span>&#34;{}&#34;</span>, json_str);</code></pre></div>
<p>Which will print‚Ä¶</p>
<div><pre><code>NuttShell (NSH) NuttX-12.8.0
nsh&gt; hello_rust_cargo
{&#34;name&#34;:&#34;John&#34;,&#34;age&#34;:30}</code></pre></div>
<p>Now we <strong>Deserialize from JSON</strong>: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs#L32-L41">lib.rs</a></p>

<div><pre><code><span>let </span>json_data = <span>r#&#34;
  {
    &#34;name&#34;: &#34;Alice&#34;,
    &#34;age&#34;: 28
  }&#34;#</span>;

<span>let </span>alice: Person = serde_json ::from_str(json_data)  .unwrap();             <span>println!</span>(<span>&#34;Deserialized: {} is {} years old&#34;</span>,
  alice.name, alice.age);</code></pre></div>
<p>And we‚Äôll see‚Ä¶</p>
<div><pre><code>Deserialized: Alice is 28 years old</code></pre></div>
<p>Serde will also do <strong>JSON Formatting</strong>: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs#L41-L44">lib.rs</a></p>

<div><pre><code><span>let </span>pretty_json_str = serde_json ::to_string_pretty(<span>&amp;</span>alice)     .unwrap();                     <span>println!</span>(<span>&#34;Pretty JSON:\n{}&#34;</span>, pretty_json_str);</code></pre></div>
<p>Looks much neater‚Ä¶</p>
<div><pre><code>Pretty JSON:
{
  &#34;name&#34;: &#34;Alice&#34;,
  &#34;age&#34;: 28
}</code></pre></div>
<p><a href="https://bitboom.github.io/2020-10-22/serde-no-std">(Serde runs on <strong>Rust Core Library</strong>, though super messy)</a></p>
<p><img src="https://lupyuen.org/images/rust7-tokio.png" alt="Async Functions with Tokio (Helix Editor + Zellij Workspace)"/></p>

<p><em>What‚Äôs this Tokio? Sounds like a city?</em></p>
<p>Indeed, ‚ÄúTokio‚Äù is inspired by Tokyo (and <a href="https://crates.io/crates/mio"><strong>Metal I/O</strong></a>)</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Tokio_(software)"><strong>Tokio</strong></a> ‚Ä¶ provides a runtime and functions that enable the use of <strong>Asynchronous I/O</strong>, allowing for Concurrency in regards to Task Completion</p>
</blockquote>
<p>Inside our <strong>Rust Hello App</strong>, here‚Äôs how we run <strong>Async Functions</strong> with Tokio: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs#L44-L56">nuttx-apps/lib.rs</a></p>

<div><pre><code>tokio::runtime::Builder
  ::new_current_thread()  .enable_all()  .build()   .unwrap()  .block_on( <span>async </span>{  <span>println!</span>(<span>&#34;Hello world from tokio!&#34;</span>);
  });

<span>println!</span>(<span>&#34;Looping Forever...&#34;</span>);
<span>loop </span>{}</code></pre></div>
<p>We‚Äôll see‚Ä¶</p>
<div><pre><code>nsh&gt; hello_rust_cargo
Hello world from tokio!
Looping Forever...</code></pre></div>
<p><a href="https://tokio.rs/tokio/topics/bridging">(Derived from <strong>tokio::main</strong>)</a></p>
<p><em>Yawn. Tokio looks underwhelming?</em></p>
<p>Ah we haven‚Äôt seen the full power of <strong>Tokio Multi-Threaded Async Functions</strong> on NuttX‚Ä¶</p>
<div><pre><code>nsh&gt; hello_rust_cargo
pthread_create
nx_pthread_create

Task 0 sleeping for 1000 ms
Task 1 sleeping for  950 ms
Task 2 sleeping for  900 ms
Task 3 sleeping for  850 ms

Finished time-consuming task
Task 3 stopping
Task 2 stopping
Task 1 stopping
Task 0 stopping</code></pre></div>
<p>Check this link for the <strong>Tokio Async Demo</strong>. And it works beautifully on NuttX! (Pic below)</p>
<ul>
<li><a href="https://lupyuen.org/articles/rust7#appendix-tokio-async-threading"><strong>‚ÄúTokio Async Threading‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.org/images/rust7-vscode2.png" alt="Tokio Async Demo"/></p>
<p><em>NuttX has POSIX Threads. Why use Async Functions?</em></p>
<p>Think <a href="https://en.wikipedia.org/wiki/Node.js#Threading"><strong>Node.js</strong></a> and its <em>Single-Thread Event Loop</em>, making <em>Non-Blocking I/O Calls</em>. Supporting tens of thousands of concurrent connections. <em>(Without costly Thread Context Switching)</em></p>
<p>Today we can (probably) do the same with <strong>NuttX and Async Rust</strong>. Assuming <a href="https://nuttx.apache.org/docs/12.5.0/components/filesystem/aio.html"><strong>POSIX Async I/O</strong></a> works OK with <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/io/bsd/poll_aio.rs"><strong>Tokio</strong></a>.</p>
<p>(Tokio calls them <em>‚ÄúAsync Tasks‚Äù</em>, sorry we won‚Äôt. Because a <a href="https://cwiki.apache.org/confluence/display/NUTTX/Tasks+vs.+Threads+FAQ"><strong>Task in NuttX</strong></a> means something else)</p>
<p><em>How will we use Tokio?</em></p>
<blockquote>
<p><a href="https://tokio.rs/tokio/tutorial"><strong>Tokio</strong></a> is designed for <strong>I/O-Bound Applications</strong> where each individual task spends most of its time waiting for I/O.</p>
</blockquote>
<p>Which means it‚Äôs great for <a href="https://tokio.rs/tokio/tutorial/io"><strong>Network Servers</strong></a>. Instead of spawning many <strong>POSIX Threads</strong>, we spawn a few threads and call <strong>Async Functions</strong>.</p>
<p>(Check out <a href="https://tokio.rs/tokio/tutorial/select"><strong>Tokio Select</strong></a> and <a href="https://tokio.rs/tokio/tutorial/streams"><strong>Tokio Streams</strong></a>)</p>
<p><img src="https://lupyuen.org/images/rust7-title.png" alt="LED Blinky with Rust Standard Library on Apache NuttX RTOS (RustRover IDE)"/></p>

<p><em>We‚Äôre running nix on NuttX?</em></p>
<p>Oh that‚Äôs <a href="https://crates.io/crates/nix"><strong><code>nix</code> Crate</strong></a> that provides <strong>Safer Rust Bindings</strong> for POSIX / Unix / Linux. (It‚Äôs not NixOS)</p>
<p>This is how we add the library to our <strong>Rust Hello App</strong>‚Ä¶</p>
<div><pre><code>$ cd ../apps/examples/rust/hello
$ cargo add nix \
  --features fs,ioctl \
  --git https://github.com/lupyuen/nix.git \
  --branch nuttx

Updating git repository `https://github.com/lupyuen/nix.git`
Adding nix (git) to dependencies
Features: + fs + ioctl
34 deactivated features</code></pre></div>
<p><em>URL looks sus?</em></p>
<p>Yep it‚Äôs our Bespoke <strong><code>nix</code></strong> Crate. That‚Äôs because the Official <strong><code>nix</code></strong> Crate doesn‚Äôt support NuttX yet. We made <a href="https://github.com/lupyuen/nix/pull/1/files"><strong>a few tweaks</strong></a> to compile on NuttX. <a href="https://lupyuen.org/articles/rust7#appendix-porting-nix-to-nuttx">(Explained in the <strong>Appendix</strong>)</a></p>
<p><em>Why call nix?</em></p>
<p>We‚Äôre <strong>Blinking the LED</strong> on NuttX. We could call the <a href="https://crates.io/crates/libc"><strong>POSIX API</strong></a> direcly from Rust‚Ä¶</p>

<div><pre><code><span>let </span>fd = <span>unsafe </span>{ libc::open(<span>&#34;/dev/userleds&#34;</span>, ...) };
<span>unsafe </span>{ libc::ioctl(fd, ULEDIOC_SETALL, <span>1</span>); }
<span>unsafe </span>{ libc::close(fd); }</code></pre></div>
<p>Though it doesn‚Äôt look very‚Ä¶ Safe. That‚Äôs why we call the <strong>Safer POSIX Bindings</strong> provided by <strong><code>nix</code></strong>. Like so: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs#L6-L39">wip-nuttx-apps/lib.rs</a></p>

<div><pre><code><span>let </span>fd = open(      <span>&#34;/dev/userleds&#34;</span>,  OFlag::O_WRONLY,  Mode::empty()     ).unwrap();         <span>const </span>ULEDIOC_SETALL: i32 = <span>0x1d03</span>;  <span>ioctl_write_int_bad!</span>(  led_set_all,         ULEDIOC_SETALL       );</code></pre></div>
<p>The code above opens the <strong>LED Device</strong>, returning an <strong>Owned File Descriptor</strong> (explained below). It defines a function <strong>led_set_all</strong>, that will call <em>ioctl()</em> to flip the LED.</p>
<p>Here‚Äôs how we call <strong>led_set_all</strong> to flip the LED: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs#L39-L47">lib.rs</a></p>

<div><pre><code><span>unsafe </span>{             led_set_all(       fd.as_raw_fd(),  <span>1                </span>).unwrap();        }  </code></pre></div>
<p>We wait Two Seconds, then flip the <strong>LED to Off</strong>: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs#L47-L53">lib.rs</a></p>

<div><pre><code>sleep(<span>2</span>);

<span>unsafe </span>{ led_set_all(fd.as_raw_fd(), <span>0</span>).unwrap(); }</code></pre></div>
<p><em>ULEDIOC_SETALL looks familiar?</em></p>
<p>We spoke about <em>ULEDIOC_SETALL</em> in <a href="https://lupyuen.org/articles/rust6#blink-the-led"><strong>an earlier article</strong></a>. And the Rust Code above mirrors the <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/nim/examples/hello/hello_main.c#L40-L85"><strong>C Version</strong></a> of our Blinky App.</p>
<p><em>How to run the Rust Blinky App?</em></p>
<ol>
<li>
<p>Copy the <strong>Rust Blinky Files</strong> from here‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx-apps/tree/rust-std/examples/rust/hello"><em>lupyuen2/wip-nuttx-apps/examples/rust/hello</em></a></p>
<p>Specifically: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/Cargo.toml"><strong>Cargo.toml</strong></a> and <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs"><strong>src/lib.rs</strong></a></p>
</li>
<li>
<p>Overwrite our <strong>Rust Hello App</strong>‚Ä¶</p>
<p><em>apps/examples/rust/hello</em></p>
</li>
<li>
<p><a href="https://lupyuen.org/articles/rust7#appendix-build-nuttx-for-rust-standard-library">Rebuild our <strong>NuttX Project</strong></a></p>
</li>
<li>
<p>Then run it with <strong>QEMU RISC-V Emulator</strong></p>
<div><pre><code>$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

NuttShell (NSH) NuttX-12.8.0
nsh&gt; hello_rust_cargo

board_userled: LED 1 set to 1
board_userled: LED 1 set to 0</code></pre></div>
<p>NuttX blinks the <strong>Emulated LED</strong> on QEMU Emulator!</p>
<p><a href="https://gist.github.com/lupyuen/4321601a962589b531bf83b0032a94af#file-hello_rust_cargo-log-L496-L533">(See the <strong>Complete Log</strong>)</a></p>
</li>
</ol>
<p><em>How to code Rust Apps for NuttX?</em></p>
<p>We could open the <strong><code>apps</code></strong> folder in VSCode, but <strong>Rust Analyzer</strong> won‚Äôt work.</p>
<p>Do this instead: <em>VSCode &gt; File &gt; Open Folder &gt; apps/examples/rust/hello</em>. Then Rust Analyzer <a href="https://lupyuen.org/images/rust7-vscode2.png"><strong>will work perfectly</strong></a>.</p>
<p><strong>cargo build</strong> seems to work, <strong>cargo run</strong> won‚Äôt. Remember to run <a href="https://doc.rust-lang.org/clippy/index.html"><strong>cargo clippy</strong></a>‚Ä¶</p>
<div><pre><code>$ cargo clippy
Checking hello v0.1.0 (apps/examples/rust/hello)
Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s</code></pre></div>
<p>Let‚Äôs talk about Owned File Descriptors vs Raw File Descriptors‚Ä¶</p>
<p><img src="https://lupyuen.org/images/rust7-fd2.jpg" alt="Owned File Descriptors vs Raw File Descriptors"/></p>

<p><strong>Safety Quiz:</strong> Why will this run OK‚Ä¶</p>

<div><pre><code><span>let </span>owned_fd =
  open(<span>&#34;/dev/userleds&#34;</span>, ...)
  .unwrap();  led_set_all(
  owned_fd.as_raw_fd(),  <span>1                      </span>).unwrap();              </code></pre></div>
<p>But <strong>Not This</strong>? (Pic above)</p>

<div><pre><code><span>let </span>raw_fd =
  open(<span>&#34;/dev/userleds&#34;</span>, ...)  .unwrap()      .as_raw_fd();  led_set_all(
  raw_fd,    <span>1          </span>).unwrap();  </code></pre></div>
<p>The Second Snippet will fail with <strong>EBADF Error</strong>‚Ä¶</p>
<div><pre><code>nsh&gt; hello_rust_cargo
thread &#39;&lt;unnamed&gt;&#39; panicked at src/lib.rs:32:33:
called `Result::unwrap()` on an `Err` value: EBADF
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</code></pre></div>
<p>There‚Äôs something odd about <strong>Raw File Descriptors</strong> vs <strong>Owned File Descriptors</strong>‚Ä¶ Fetching the Raw One too early might cause <strong>EBADF Errors</strong>. Here‚Äôs why‚Ä¶</p>
<p><em>What‚Äôs a Raw File Descriptor?</em></p>
<p>In NuttX and POSIX: <a href="https://github.com/apache/nuttx/blob/master/include/stdio.h#L65-L71"><strong>Raw File Descriptor</strong></a> is a <strong>Plain Integer</strong> that specifies an I/O Stream‚Ä¶</p>
<div><table><thead><tr><th>File Descriptor</th><th>I/O Stream</th></tr></thead><tbody>
<tr><td>0</td><td>Standard Input</td></tr>
<tr><td>1</td><td>Standard Output</td></tr>
<tr><td>2</td><td>Standard Error</td></tr>
<tr><td>3</td><td>/dev/userleds </td></tr>
</tbody></table>
</div>
<p><em>What about Owned File Descriptor?</em></p>
<p>In Rust: <a href="https://doc.rust-lang.org/std/os/fd/struct.OwnedFd.html"><strong>Owned File Descriptor</strong></a> is a <strong>Rust Object</strong>, wrapped around a Raw File Descriptor.</p>
<p>And Rust Objects shall be <strong>Automatically Dropped</strong>, when they go out of scope. (Unlike Integers)</p>
<p><em>Causing the Second Snippet to fail?</em></p>
<p>Exactly! <em>open()</em> returns an <strong>Owned File Descriptor</strong>‚Ä¶</p>

<div><pre><code><span>let </span>raw_fd =
  open(<span>&#34;/dev/userleds&#34;</span>, ...)  .unwrap()      .as_raw_fd();  </code></pre></div>
<p>And we turned it into <strong>Raw File Descriptor</strong>. (The Plain Integer, not the Rust Object)</p>
<p>Oops! Our Owned File Descriptor goes <strong>Out Of Scope</strong> and gets dropped by Rust‚Ä¶</p>
<p><img src="https://lupyuen.org/images/rust7-fd.jpg" alt="Our Owned File Descriptor goes Out Of Scope and gets dropped by Rust"/></p>
<p>Thus Rust will helpfully close <em>/dev/userleds</em>. Since it‚Äôs closed, our Raw File Descriptor <strong>becomes invalid</strong>‚Ä¶</p>

<div><pre><code>led_set_all(
  raw_fd,    <span>1          </span>).unwrap();  </code></pre></div>
<p>Resulting in the <a href="https://man.freebsd.org/cgi/man.cgi?errno(2)"><strong>EBADF Error</strong></a>. <em>ioctl()</em> failed because <em>/dev/userleds</em> is already closed!</p>
<p><strong>Lesson Learnt:</strong> Be careful with Owned File Descriptors. They‚Äôre super helpful for Auto-Closing our files. But might have strange consequences.</p>
<p>Rustix is another popular POSIX Wrapper. We take a peek‚Ä¶</p>
<p><img src="https://lupyuen.org/images/rust7-compare.png" alt="Nix vs Rustix"/></p>

<p><em>Is there a Safer Way to call ioctl()?</em></p>
<p>Calling <em>ioctl()</em> from Rust will surely get messy: It‚Äôs an <strong>Unsafe Call</strong> that might cause bad writes into the NuttX Kernel! <em>(If we‚Äôre not careful)</em></p>
<p>At the top of the article, we saw <strong><code>nix</code></strong> crate calling <em>ioctl()</em>. Now we look at <a href="https://crates.io/crates/rustix"><strong>Rustix</strong></a> calling <em>ioctl()</em>: <a href="https://github.com/bytecodealliance/rustix/blob/main/src/fs/ioctl.rs#L16-L32">rustix/fs/ioctl.rs</a></p>

<div><pre><code><span>unsafe </span>{
  <span>let </span>ctl = ioctl::Getter::&lt;  ioctl::BadOpcode&lt;  { c::BLKSSZGET } &gt;,
    c::c_uint  &gt;::new();    ioctl::ioctl(
    fd,  ctl  ) }</code></pre></div>
<p><a href="https://docs.rs/rustix/latest/rustix/ioctl/index.html">(Based on <strong>Rustix Docs</strong>)</a></p>
<p><a href="https://docs.rs/rustix/latest/rustix/ioctl/fn.ioctl.html">(Rustix Ioctl passes a <strong>Borrowed File Descriptor</strong>, safer than Raw)</a></p>
<p><em>Nix vs Rustix: They feel quite similar?</em></p>
<p>Actually Nix was previously a lot simpler, supporting only <strong>Raw File Descriptors</strong>. <em>(Instead of Owned File Descriptors)</em></p>
<p>Today, Nix is moving to <strong>Owned File Descriptors</strong> due to <strong>I/O Safety</strong>. Bummer it means Nix is becoming more <a href="https://crates.io/crates/rustix"><strong>Rustix-like</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/nix-rust/nix/issues/1750"><strong>Nix: Implement I/O Safety</strong></a></p>
</li>
<li>
<p><a href="https://rust-lang.github.io/rfcs/3128-io-safety.html"><strong>Rust: I/O Safety</strong></a> <em>(used in Rustix and New Nix)</em></p>
</li>
</ul>
<p><em>What‚Äôs our preference: Nix or Rustix?</em></p>
<p>Hmmm we‚Äôre still pondering. <strong>Rustix is newer</strong> (pic above), but it‚Äôs also <strong>more complex</strong> (based on Lines of Code). It might hinder our porting to NuttX.</p>
<p>Which would you choose? Lemme know! üôè</p>
<p><img src="https://lupyuen.org/images/rust7-loc.png" alt="Nix vs Rustix: Lines of Code"/></p>
<p><a href="https://lupyuen.org/articles/rust7#appendix-porting-rustix-to-nuttx">(<strong>Rustix on NuttX:</strong> Will it run? Nope not yet)</a></p>
<p><a href="https://github.com/no1wudi/nuttx-rs">(<strong>no1wudi/nuttx-rs</strong> shows potential)</a></p>
<p><a href="https://lupyuen.org/articles/rust6#appendix-nuttx-vs-rust-embedded-hal">(<strong>Rust Embedded HAL</strong> might be a bad fit)</a></p>

<p><img src="https://lupyuen.org/images/rust7-slint.jpg" alt="Upcoming: Slint Rust GUI for NuttX üéâ"/></p>
<p><a href="https://github.com/apache/nuttx-apps/pull/2967"><strong>Upcoming:</strong> Slint Rust GUI for NuttX üéâ</a></p>
<p><em>What platforms are supported for NuttX + Rust Standard Library? How about SBCs?</em></p>
<p>Arm and RISC-V (32-bit and 64-bit). <a href="https://nuttx.apache.org/docs/latest/guides/rust.html"><strong>Check this doc</strong></a> for updates.</p>
<p>Sorry 64-bit <strong>RISC-V Kernel Build</strong> is <a href="https://github.com/apache/nuttx-apps/pull/2487#issuecomment-2601488835"><strong>not supported yet</strong></a>. So it <strong>won‚Äôt run on RISC-V SBCs</strong> like Ox64 BL808 and Oz64 SG2000.</p>
<p><em>Sounds like we need plenty of Rust Testing? For every NuttX Platform?</em></p>
<p>Yeah maybe we need <a href="https://lupyuen.org/articles/rust6#appendix-daily-test-of-nuttx-qemu-risc-v"><strong>Daily Automated Testing</strong></a> of NuttX + Rust Standard Library on <a href="https://lupyuen.org/articles/ci4"><strong>NuttX Build Farm</strong></a>?</p>
<p>With <a href="https://lupyuen.org/articles/rust6#appendix-daily-test-of-nuttx-qemu-risc-v"><strong>QEMU Emulator</strong></a> or a <a href="https://lupyuen.org/articles/sg2000a"><strong>Real Device</strong></a>?</p>
<p>And when the Daily Test fails: How to <a href="https://lupyuen.org/articles/ci6"><strong>Auto-Rewind the Build</strong></a> and discover the Breaking Commit? Hmmm‚Ä¶</p>
<hr/>
<p>Many Thanks to the awesome <strong>NuttX Admins</strong> and <strong>NuttX Devs</strong>! And <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a>, for sticking with me all these years.</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=42825198"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/rust7.md"><strong>lupyuen.org/src/rust7.md</strong></a></p>
<p><img src="https://lupyuen.org/images/rust7-vscode.png" alt="NuttX with Rust Standard Library"/></p>

<p>Follow these steps to build <strong>NuttX bundled with Rust Standard Library</strong>‚Ä¶</p>
<p><a href="https://nuttx.apache.org/docs/latest/guides/rust.html">(Based on the <strong>Official Doc</strong>)</a></p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/qemu-rv/boards/rv-virt/index.html">(Remember to install <strong>RISC-V Toolchain</strong> and <strong>RISC-V QEMU</strong>)</a></p>
<div><pre><code>## Install Rust: https://rustup.rs/
## Select &#34;Standard Installation&#34;
curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh
. &#34;$HOME/.cargo/env&#34;

## Switch to the Nightly Toolchain
rustup update
rustup toolchain install nightly
rustup default nightly

## Should show `rustc 1.86.0-nightly` or later
rustc --version

## Install the Nightly Toolchain
rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
## For macOS: rustup component add rust-src --toolchain nightly-aarch64-apple-darwin

## Download the NuttX Kernel and Apps
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx

## Configure NuttX for RISC-V 64-bit QEMU with LEDs
## (Alternatively: rv-virt:nsh64 or rv-virt:nsh or rv-virt:leds)
tools/configure.sh rv-virt:leds64

## Disable Floating Point: CONFIG_ARCH_FPU
kconfig-tweak --disable CONFIG_ARCH_FPU

## Enable CONFIG_SYSTEM_TIME64 / CONFIG_FS_LARGEFILE / CONFIG_DEV_URANDOM / CONFIG_TLS_NELEM = 16
kconfig-tweak --enable CONFIG_SYSTEM_TIME64
kconfig-tweak --enable CONFIG_FS_LARGEFILE
kconfig-tweak --enable CONFIG_DEV_URANDOM
kconfig-tweak --set-val CONFIG_TLS_NELEM 16

## Enable the Hello Rust Cargo App
## Increase the App Stack Size from 2 KB to 16 KB (especially for 64-bit platforms)
kconfig-tweak --enable CONFIG_EXAMPLES_HELLO_RUST_CARGO
kconfig-tweak --set-val CONFIG_EXAMPLES_HELLO_RUST_CARGO_STACKSIZE 16384

## Update the Kconfig Dependencies
make olddefconfig

## Build NuttX
make -j

## If it fails with &#34;Mismatched Types&#34;:
## Patch the file `fs.rs` (see below)

## Start NuttX on QEMU RISC-V 64-bit
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

## Inside QEMU: Run our Hello Rust App
hello_rust_cargo</code></pre></div>
<p>We‚Äôll see this in <strong>QEMU RISC-V Emulator</strong>‚Ä¶</p>
<div><pre><code>NuttShell (NSH) NuttX-12.8.0
nsh&gt; hello_rust_cargo

{&#34;name&#34;:&#34;John&#34;,&#34;age&#34;:30}
{&#34;name&#34;:&#34;Jane&#34;,&#34;age&#34;:25}
Deserialized: Alice is 28 years old
Pretty JSON:
{
  &#34;name&#34;: &#34;Alice&#34;,
  &#34;age&#34;: 28
}
Hello world from tokio!</code></pre></div>
<p><strong>To Quit QEMU:</strong> Press <strong><code>Ctrl-a</code></strong> then <strong><code>x</code></strong></p>
<p><a href="https://gist.github.com/lupyuen/6985933271f140db0dc6172ebba9bff5">(See the <strong>Ubuntu Build Log</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/a2b91b5cc15824a31c287fbb6cda5fa2">(See the <strong>macOS Build Log</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/ccfae733657b864f2f9a24ce41808144">(Also works for 32-bit <strong>rv-virt:leds</strong>)</a></p>
<hr/>
<p><strong>Troubleshooting The Rust Build</strong></p>
<ul>
<li>
<p>If NuttX Build fails with <strong>‚ÄúMismatched Types‚Äù</strong>‚Ä¶</p>
<span>
<div><pre><code>Compiling std v0.0.0 (.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std)
error[E0308]: mismatched types
    --&gt; .rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs:1037:33
1037 |         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }
     |                  -------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `*const u8`, found `*const i8`
     |                  |
     |                  arguments to this function are incorrect
     = note: expected raw pointer `*const u8`
                found raw pointer `*const i8`
note: associated function defined here
    --&gt; .rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ffi/c_str.rs:264:25
264  |     pub const unsafe fn from_ptr&lt;&#39;a&gt;(ptr: *const c_char) -&gt; &amp;&#39;a CStr {
     |                         ^^^^^^^^</code></pre></div></span>
<p>Then edit this file‚Ä¶</p>
<span>
<div><pre><code>## For Ubuntu
$HOME/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs

## For macOS
$HOME/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs</code></pre></div></span>
<p>Change the <strong>name_cstr</strong> function at <strong>Line 1036</strong>‚Ä¶</p>
<span>

<div><pre><code>    <span>fn </span>name_cstr(<span>&amp;</span><span>self</span>) -&gt; <span>&amp;</span>CStr {
        <span>unsafe </span>{ CStr::from_ptr(<span>self</span>.entry.d_name.as_ptr()) }
    }</code></pre></div>
</span>
<p>To this‚Ä¶</p>
<span>

<div><pre><code>    <span>fn </span>name_cstr(<span>&amp;</span><span>self</span>) -&gt; <span>&amp;</span>CStr {
        <span>unsafe </span>{ CStr::from_ptr(<span>self</span>.entry.d_name.as_ptr() <span>as </span><span>*const </span>u8) }
    }</code></pre></div>
</span>
<p>And verify the change‚Ä¶</p>
<span>
<div><pre><code>## For Ubuntu
head -n 1049 $HOME/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs \
  | tail -n 17

## For macOS
head -n 1049 $HOME/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs \
  | tail -n 17

## We should see
## fn name_cstr(&amp;self) -&gt; &amp;CStr {
##   unsafe { CStr::from_ptr(self.entry.d_name.as_ptr() as *const u8) }</code></pre></div></span>
<p>Finally rebuild with <code>make -j</code></p>
<p><a href="https://github.com/rust-lang/libc/pull/4222">(Will be fixed in <strong>Rust Toolchain</strong>)</a></p>
</li>
<li>
<p>If the build fails with <strong>‚Äú-Z‚Äù Error</strong>‚Ä¶</p>
<div><pre><code>error: the `-Z` flag is only accepted on the nightly channel of Cargo
but this is the `stable` channel</code></pre></div>
<p>Then switch to the Nightly Toolchain‚Ä¶</p>
<div><pre><code>## Switch to the Nightly Toolchain
rustup update
rustup toolchain install nightly
rustup default nightly

## Should show `rustc 1.86.0-nightly` or later
rustc --version</code></pre></div></li>
<li>
<p>If the build fails with <strong>‚ÄúUnable to build with the Standard Library‚Äù</strong>‚Ä¶</p>
<div><pre><code>error: &#34;.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/Cargo.lock&#34; does not exist, unable to build with the standard library
try: rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu</code></pre></div>
<p>Then install the Nightly Toolchain‚Ä¶</p>
<div><pre><code>## Install the Nightly Toolchain
rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
## For macOS: rustup component add rust-src --toolchain nightly-aarch64-apple-darwin</code></pre></div></li>
<li>
<p>If the build fails with <strong>‚ÄúError Loading Target‚Äù</strong>‚Ä¶</p>
<div><pre><code>error: Error loading target specification:
Could not find specification for target &#34;riscv64imafdc-unknown-nuttx-elf&#34;</code></pre></div>
<p>Then disable Floating Point‚Ä¶</p>
<div><pre><code>## Disable Floating Point: CONFIG_ARCH_FPU
kconfig-tweak --disable CONFIG_ARCH_FPU

## Update the Kconfig Dependencies
make olddefconfig
make -j</code></pre></div></li>
<li>
<p><em>What if we‚Äôre using Rust already? And we don‚Äôt wish to change the Default Toolchain?</em></p>
<p>Use <strong>rustup override</strong> to <strong>Override the Folder Toolchain</strong>. Do it in the <strong>Parent Folder</strong> of <strong><code>nuttx</code></strong> and <strong><code>apps</code></strong>‚Ä¶</p>
<div><pre><code>## Set Rust to Nightly Build
## Apply this to the Parent Folder
## So it will work for `nuttx` and `apps`
pushd ..
rustup override list
rustup override set nightly
rustup override list
popd</code></pre></div></li>
<li>
<p><em>Rust App crashes in QEMU?</em></p>
<p>We might see a Stack Dump that <strong>Loops Forever</strong>. Or we might see <strong>100% Full</strong> for the App Stack‚Ä¶</p>
<span>
<div><pre><code>PID GROUP PRI POLICY   TYPE    NPX STATE   EVENT      SIGMASK          STACKBASE  STACKSIZE      USED   FILLED    COMMAND
  3     3 100 RR       Task    -   Running            0000000000000000 0x80071420      1856      1856   100.0%!   hello_rust_cargo</code></pre></div></span>
<p>Then increase the App Stack Size‚Ä¶</p>
<div><pre><code>## Increase the App Stack Size to 64 KB
kconfig-tweak --set-val \
  CONFIG_EXAMPLES_HELLO_RUST_CARGO_STACKSIZE \
  65536

## Update the Kconfig Dependencies and rebuild
make olddefconfig
make -j</code></pre></div></li>
<li>
<p><em>Rust Build seems to break sometimes?</em></p>
<p>We might need to clean up the <strong>Rust Target Files</strong>, if the Rust Build goes wonky‚Ä¶</p>
<div><pre><code>## Erase the Rust Build and rebuild
pushd ../apps/examples/rust/hello
cargo clean
popd
make -j</code></pre></div></li>
<li>
<p><em>How to code Rust Apps for NuttX?</em></p>
<p>We could open the <strong><code>apps</code></strong> folder in VSCode, but <strong>Rust Analyzer</strong> won‚Äôt work.</p>
<p>Do this instead: <em>VSCode &gt; File &gt; Open Folder &gt; apps/examples/rust/hello</em>. Then Rust Analyzer will work perfectly. (Pic below)</p>
<p><strong>cargo build</strong> seems to work, <strong>cargo run</strong> won‚Äôt. Remember to run <a href="https://doc.rust-lang.org/clippy/index.html"><strong>cargo clippy</strong></a>‚Ä¶</p>
<div><pre><code>$ cargo clippy
Checking hello v0.1.0 (apps/examples/rust/hello)
Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s</code></pre></div></li>
</ul>
<p>How did we port Rust Standard Library to NuttX? Details here‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx-apps/pull/2487"><strong>examples: New app to build Rust with Cargo</strong></a></p>
</li>
<li>
<p><a href="https://github.com/rust-lang/rust/pull/127755"><strong>Rust: Add NuttX based targets for RISC-V and ARM</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.org/images/rust7-vscode2.png" alt="Tokio Async Threading"/></p>

<p>Earlier we saw Tokio‚Äôs <strong>Single-Threaded Scheduler</strong>, running on the <strong>Current Thread</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.org/articles/rust7#async-functions-with-tokio"><strong>‚ÄúAsync Functions with Tokio‚Äù</strong></a></li>
</ul>

<div><pre><code>tokio::runtime::Builder
  ::new_current_thread()  .enable_all()  .build()   .unwrap()  .block_on( <span>async </span>{  <span>println!</span>(<span>&#34;Hello world from tokio!&#34;</span>);
  });

<span>println!</span>(<span>&#34;Looping Forever...&#34;</span>);
<span>loop </span>{}</code></pre></div>
<p>And it ain‚Äôt terribly exciting‚Ä¶</p>
<div><pre><code>nsh&gt; hello_rust_cargo
Hello world from tokio!
Looping Forever...</code></pre></div>
<p>Now we try Tokio‚Äôs <strong>Multi-Threaded Scheduler</strong>. And we create <strong>One New POSIX Thread</strong> for the Scheduler: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs#L86-L140">wip-nuttx-apps/lib.rs</a></p>

<div><pre><code><span>fn </span>test_async() {

  <span>let </span>runtime = tokio::runtime::Builder
    ::new_multi_thread() .worker_threads(<span>1</span>)   .enable_all() .build()      .unwrap();    <span>let </span><span>mut </span>handles = Vec::with_capacity(<span>4</span>);
  <span>for </span>i <span>in </span><span>0</span>..<span>4 </span>{
    handles.push(        runtime.spawn(     my_bg_task(i))); }

  std::thread::sleep(
    tokio::time::Duration::from_millis(<span>750</span>));
  <span>println!</span>(<span>&#34;Finished time-consuming task.&#34;</span>);

  <span>for </span>handle <span>in </span>handles {
    runtime
      .block_on(handle)  .unwrap();
  }
}

<span>async fn </span>my_bg_task(i: u64) {
  <span>let </span>millis = <span>1000 </span>- <span>50 </span>* i;
  <span>println!</span>(<span>&#34;Task {} sleeping for {} ms.&#34;</span>, i, millis);
  tokio::time::sleep(
    tokio::time::Duration::from_millis(millis)
  ).<span>await</span>;  <span>println!</span>(<span>&#34;Task {} stopping.&#34;</span>, i);
}

<span>#[no_mangle]
</span><span>pub extern </span><span>&#34;C&#34; </span><span>fn </span>pthread_set_name_np() {}</code></pre></div>
<p><em>How to run the Tokio Demo?</em></p>
<ol>
<li>
<p>Copy the <strong>Tokio Demo Files</strong> from here‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx-apps/tree/rust-std/examples/rust/hello"><em>lupyuen2/wip-nuttx-apps/examples/rust/hello</em></a></p>
<p>Specifically: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/Cargo.toml"><strong>Cargo.toml</strong></a> and <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs"><strong>src/lib.rs</strong></a></p>
</li>
<li>
<p>Overwrite our <strong>Rust Hello App</strong>‚Ä¶</p>
<p><em>apps/examples/rust/hello</em></p>
</li>
<li>
<p><a href="https://lupyuen.org/articles/rust7#appendix-build-nuttx-for-rust-standard-library">Rebuild our <strong>NuttX Project</strong></a></p>
</li>
<li>
<p>Then run it with <strong>QEMU RISC-V Emulator</strong></p>
<div><pre><code>$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

NuttShell (NSH) NuttX-12.8.0
nsh&gt; hello_rust_cargo
</code></pre></div></li>
<li>
<p>We‚Äôll see <strong>Four Async Functions</strong>, running on <strong>One New POSIX Thread</strong>‚Ä¶</p>
<div><pre><code>nsh&gt; hello_rust_cargo
pthread_create
nx_pthread_create

Task 0 sleeping for 1000 ms
Task 1 sleeping for  950 ms
Task 2 sleeping for  900 ms
Task 3 sleeping for  850 ms

Finished time-consuming task
Task 3 stopping
Task 2 stopping
Task 1 stopping
Task 0 stopping</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/46db6d1baee0e589774cc43dd690da07#file-gistfile1-txt-L497-L535">(See the <strong>Complete Log</strong>)</a></p>
<p><a href="https://tokio.rs/tokio/topics/bridging">(Explained in <strong>Tokio Docs</strong>)</a></p>
</li>
<li>
<p>See the call to <a href="https://github.com/apache/nuttx/blob/master/libs/libc/pthread/pthread_create.c#L88"><strong>pthread_create</strong></a>, which calls <a href="https://github.com/apache/nuttx/blob/master/sched/pthread/pthread_create.c#L179"><strong>nx_pthread_create</strong></a>? It means that Tokio is actually calling NuttX to create One POSIX Thread! (For the Multi-Threaded Scheduler)</p>
</li>
<li>
<p>Yep it‚Äôs consistent with our <strong>Reverse Engineering of Tokio</strong>‚Ä¶</p>
<p><a href="https://lupyuen.org/articles/rust7#appendix-snooping-tokio-on-nuttx"><strong>‚ÄúSnooping Tokio on NuttX‚Äù</strong></a></p>
</li>
</ol>
<p><em>What if we increase the Worker Threads? From 1 to 2?</em></p>

<div><pre><code><span>let </span>runtime = tokio::runtime::Builder
  ::new_multi_thread() .worker_threads(<span>2</span>)   </code></pre></div>
<p>The output looks exactly the same‚Ä¶</p>
<div><pre><code>nsh&gt; hello_rust_cargo
pthread_create
nx_pthread_create
pthread_create
nx_pthread_create

Task 0 sleeping for 1000 ms
Task 1 sleeping for  950 ms
Task 2 sleeping for  900 ms
Task 3 sleeping for  850 ms

Finished time-consuming task
Task 3 stopping
Task 2 stopping
Task 1 stopping
Task 0 stopping</code></pre></div>
<p>Except that we see <strong>Two Calls</strong> to <a href="https://github.com/apache/nuttx/blob/master/libs/libc/pthread/pthread_create.c#L88"><strong>pthread_create</strong></a> and <a href="https://github.com/apache/nuttx/blob/master/sched/pthread/pthread_create.c#L179"><strong>nx_pthread_create</strong></a>. Tokio called NuttX to create Two POSIX Threads. (For the Multi-Threaded Scheduler)</p>
<p><em>How did we log pthread_create?</em></p>
<p>Inside NuttX Kernel: We added Debug Code to
<a href="https://github.com/apache/nuttx/blob/master/libs/libc/pthread/pthread_create.c#L88"><strong>pthread_create</strong></a> and <a href="https://github.com/apache/nuttx/blob/master/sched/pthread/pthread_create.c#L179"><strong>nx_pthread_create</strong></a></p>
<span>
<div><pre><code>// At https://github.com/apache/nuttx/blob/master/libs/libc/pthread/pthread_create.c#L88
#include &lt;debug.h&gt;
int pthread_create(...) {
  _info(&#34;pthread_entry=%p, arg=%p&#34;, pthread_entry, arg);

// At https://github.com/apache/nuttx/blob/master/sched/pthread/pthread_create.c#L179
#include &lt;debug.h&gt;
int nx_pthread_create(...) {
  _info(&#34;entry=%p, arg=%p&#34;, entry, arg);</code></pre></div></span>
<p><img src="https://lupyuen.org/images/rust7-title.png" alt="LED Blinky with Rust Standard Library on Apache NuttX RTOS (RustRover IDE)"/></p>

<p><em>What happens when we call nix crate as-is on NuttX?</em></p>
<p>Earlier we said that we <a href="https://lupyuen.org/articles/rust7#led-blinky-with-nix"><strong>Customised the <code>nix</code> Crate</strong></a> to run on NuttX.</p>
<p>Why? Let‚Äôs build our Rust Blinky App with the Original <strong><code>nix</code></strong> Crate‚Ä¶</p>
<span>
<div><pre><code>$ pushd ../apps/examples/rust/hello
$ cargo add nix --features fs,ioctl

Adding nix v0.29.0 to dependencies
Features: + fs + ioctl
33 deactivated features

$ popd
$ make -j

error[E0432]: unresolved import `self::const`
  --&gt;   errno.rs:19:15
19 | pub use self::consts::*;
   |               ^^^^^^ could not find `consts` in `self`

error[E0432]: unresolved import `self::Errno`
   --&gt;  errno.rs:198:15
198 |     use self::Errno::*;
    |               ^^^^^ could not find `Errno` in `self`

error[E0432]: unresolved import `crate::errno::Errno`
 --&gt;  fcntl.rs:2:5
2 | use crate::errno::Errno;
  |     ^^^^^^^^^^^^^^-----
  |     no `Errno` in `errno`</code></pre></div></span>
<p>Plus many errors. That‚Äôs why we <a href="https://github.com/lupyuen/nix/tree/nuttx"><strong>Customised the <code>nix</code> Crate</strong></a> for NuttX‚Ä¶</p>
<div><pre><code>$ cd ../apps/examples/rust/hello
$ cargo add nix \
  --features fs,ioctl \
  --git https://github.com/lupyuen/nix.git \
  --branch nuttx

Updating git repository `https://github.com/lupyuen/nix.git`
Adding nix (git) to dependencies
Features: + fs + ioctl
34 deactivated features</code></pre></div>
<p>Here‚Äôs how‚Ä¶</p>
<ol>
<li>
<p><strong>For Easier Porting:</strong> We cloned <strong><code>nix</code></strong> locally‚Ä¶</p>
<div><pre><code>git clone \
  https://github.com/lupyuen/nix \
  --branch nuttx
cd ../apps/examples/rust/hello
cargo add nix \
  --features fs,ioctl \
  --path $HOME/nix</code></pre></div></li>
<li>
<p>We extended <a href="https://github.com/lupyuen/nix/pull/1/files#diff-c64965cf18ab089e705398a750edb9b349ff3e0509454d801d6a150db7ff9b5e"><strong>errno.rs</strong></a>, copying the <strong>FreeBSD Section</strong> <em>[cfg(target_os = ‚Äúfreebsd‚Äù)]</em> to <strong>NuttX Section</strong> <em>[cfg(target_os = ‚Äúnuttx‚Äù)]</em>.</p>
<p>(We removed the bits that don‚Äôt exist on NuttX)</p>
</li>
<li>
<p>NuttX seems to have a similar POSIX Profile to <strong>Redox OS</strong>? We changed plenty of code to look like this: <a href="https://github.com/lupyuen/nix/pull/1/files#diff-7f322738311de78991dc089e6bcd3a89bcebc6d39b1a17508cf6c94bb170c9b0"><strong>sys/time.rs</strong></a></p>

<div><pre><code><span>#[cfg(not(any(target_os = <span>&#34;redox&#34;</span>,
              target_os = <span>&#34;nuttx&#34;</span>)))]
</span><span>pub const </span>UTIME_OMIT: TimeSpec = ...</code></pre></div>
</li>
<li>
<p><strong>For NuttX ioctl():</strong> It works more like BSD <em>(second parameter is <strong><code>int</code></strong>)</em> than Linux <em>(second parameter is <strong><code>long</code></strong>)</em>: <a href="https://github.com/lupyuen/nix/pull/1/files#diff-96785c020c81b7d3962a7ea3c4ec2f2b1388617a412c92b4d1f0437447f42af4">sys/ioctl/mod.rs</a></p>

<div><pre><code><span>#[cfg(any(bsd,
          solarish,
          target_os = <span>&#34;haiku&#34;</span>,
          target_os = <span>&#34;nuttx&#34;</span>))]
#[macro_use]
</span><span>mod </span>bsd;

<span>#[cfg(any(linux_android,
          target_os = <span>&#34;fuchsia&#34;</span>,
          target_os = <span>&#34;redox&#34;</span>))]
#[macro_use]
</span><span>mod </span>linux;</code></pre></div>
</li>
<li>
<p>Here are the files we modified for NuttX‚Ä¶</p>
<p>(Supporting <strong><code>fs</code></strong> and <strong><code>ioctl</code></strong> features only)</p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files"><strong>All Modified Files</strong></a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-c64965cf18ab089e705398a750edb9b349ff3e0509454d801d6a150db7ff9b5e"><strong>errno.rs</strong></a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-234e7e6580542ac96403821955043ffefa4cef1e0659216a9ee170cad6315c7d"><strong>fcntl.rs</strong></a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-0223913fb22a7da0dcb64a51b192e5c049b4b276351c83bbaeb0cee0dbbd8a04"><strong>unistd.rs</strong></a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-5c119a000c85b1959421747235c671cc2f43b4f5fd2628daf1276f684a100ad8"><strong>sys/stat.rs</strong></a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-ed80a57034c9c336fb4516644f86cbd9ef75296fa76bdf9c7ca9adf251be0421"><strong>sys/statvfs.rs</strong></a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-db4000d9e8bf29c6719984245eeefdf7e0a9b4e525f37ac8c5d6a918d4dc3005"><strong>sys/mod.rs</strong></a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-7f322738311de78991dc089e6bcd3a89bcebc6d39b1a17508cf6c94bb170c9b0"><strong>sys/time.rs</strong></a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-48ef2619f99fe3916c145e82b718b5f2975d58992113203c51fb4315d8e3155b"><strong>sys/ioctl/bsd.rs</strong></a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-96785c020c81b7d3962a7ea3c4ec2f2b1388617a412c92b4d1f0437447f42af4"><strong>sys/ioctl/mod.rs</strong></a></p>
</li>
</ol>
<hr/>
<p><strong>Troubleshooting nix ioctl() on NuttX</strong></p>
<p>To figure out if <strong><code>nix</code></strong> passes ioctl() parameters correctly to NuttX: We insert <strong>Ioctl Debug Code</strong> into NuttX Kernel‚Ä¶</p>
<div><pre><code>// At https://github.com/apache/nuttx/blob/master/fs/vfs/fs_ioctl.c#L261
#include &lt;debug.h&gt;
int ioctl(int fd, int req, ...) {
  _info(&#34;fd=0x%x, req=0x%x&#34;, fd, req);</code></pre></div>
<p>Which <a href="https://docs.rs/nix/latest/nix/sys/ioctl/"><strong>Ioctl Macro</strong></a> shall we call in <strong><code>nix</code></strong>? We tried <strong>ioctl_none</strong>‚Ä¶</p>

<div><pre><code><span>const </span>ULEDIOC_SETALL: i32 = <span>0x1d03</span>;
<span>ioctl_none!</span>(led_on, ULEDIOC_SETALL, <span>1</span>);
<span>unsafe </span>{ led_on(fd).unwrap(); }</code></pre></div>
<p>But the <strong>Ioctl Command Code</strong> got mangled up (<code>0x201d0301</code> should be <code>0x1d03</code>)</p>
<div><pre><code>NuttShell (NSH) NuttX-12.8.0
nsh&gt; hello_rust_cargo
fd=3
ioctl: fd=0x3, req=0x201d0301

thread &#39;&lt;unnamed&gt;&#39; panicked at src/lib.rs:31:25:
called `Result::unwrap()` on an `Err` value: ENOTTY
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</code></pre></div>
<p>Then we tried <strong>ioctl_write_int</strong>‚Ä¶</p>

<div><pre><code><span>const </span>ULEDIOC_SETALL: i32 = <span>0x1d03</span>;
<span>ioctl_write_int!</span>(led_on, ULEDIOC_SETALL, <span>1</span>);
<span>unsafe </span>{ led_on(fd, <span>1</span>).unwrap(); }</code></pre></div>
<p>Nope the <strong>Ioctl Command Code</strong> is still mangled (<code>0x801d0301</code> should be <code>0x1d03</code>)</p>
<div><pre><code>nsh&gt; hello_rust_cargo
ioctl: fd=0x3, req=0x801d0301
thread &#39;&lt;unnamed&gt;&#39; panicked at src/lib.rs:30:28:
called `Result::unwrap()` on an `Err` value: ENOTTY</code></pre></div>
<p>Finally this works: <strong>ioctl_write_int_bad</strong>‚Ä¶</p>

<div><pre><code><span>const </span>ULEDIOC_SETALL: i32 = <span>0x1d03</span>;
<span>ioctl_write_int_bad!</span>(led_set_all, ULEDIOC_SETALL);

<span>unsafe </span>{ led_set_all(fd, <span>1</span>).unwrap(); }

<span>unsafe </span>{ led_set_all(fd, <span>0</span>).unwrap(); }</code></pre></div>
<p><strong>Ioctl Command Code</strong> <code>0x1d03</code> is hunky dory yay!</p>
<div><pre><code>NuttShell (NSH) NuttX-12.8.0
nsh&gt; hello_rust_cargo
fd=3
ioctl: fd=0x3, req=0x1d03
board_userled: LED 1 set to 1
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0

ioctl: fd=0x3, req=0x1d03
board_userled: LED 1 set to 0
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0</code></pre></div>
<p><img src="https://lupyuen.org/images/rust7-compare.png" alt="Nix vs Rustix"/></p>

<p><em>Will Rustix run on NuttX?</em></p>
<p>Nope not yet‚Ä¶</p>
<div><pre><code>$ cd ../apps/examples/rust/hello
$ cargo add rustix \
  --features fs \
  --git https://github.com/lupyuen/rustix.git \
  --branch nuttx

Updating git repository `https://github.com/lupyuen/rustix.git`
Adding rustix (git) to dependencies
Features: + alloc + fs + std + use-libc-auxv
29 deactivated features</code></pre></div>
<p>We tried compiling this code‚Ä¶</p>

<div><pre><code><span>#[no_mangle]
</span><span>pub extern </span><span>&#34;C&#34; </span><span>fn </span>hello_rust_cargo_main() {
  <span>use </span>rustix::fs::{Mode, OFlags};
  <span>let </span>file = rustix::fs::open(
    <span>&#34;/dev/userleds&#34;</span>,
    OFlags::WRONLY,
    Mode::empty(),
  )
  .unwrap();
  <span>println!</span>(<span>&#34;file={file:?}&#34;</span>);
}</code></pre></div>
<p>But it fails‚Ä¶</p>
<div><pre><code>error[E0432]: unresolved import `libc::strerror_r`
  --&gt; .cargo/registry/src/index.crates.io-1949cf8c6b5b557f/errno-0.3.10/src/unix.rs:16:33
   |
16 | use libc::{self, c_int, size_t, strerror_r, strlen};
   |                                 ^^^^^^^^^^
   |                                 |
   |                                 no `strerror_r` in the root
   |                                 help: a similar name exists in the module: `strerror`</code></pre></div>
<p>Seems we need to fix <strong>libc::strerror_r</strong> for NuttX? Or maybe the <strong>errno</strong> crate.</p>
<p><img src="https://lupyuen.org/images/rust7-tokio.png" alt="Async Functions with Tokio (Helix Editor + Zellij Workspace)"/></p>

<p>In this section, we discover how <strong>Tokio works under the hood</strong>. Does it really call <strong>POSIX Functions in NuttX</strong>?</p>
<p>First we obtain the <strong>RISC-V Disassembly</strong> of our NuttX Image, bundled with the Hello Rust App. We trace the NuttX Build: <strong><code>make V=1</code></strong></p>
<div><pre><code>make distclean
tools/configure.sh rv-virt:leds64

## Disable CONFIG_ARCH_FPU
kconfig-tweak --disable CONFIG_ARCH_FPU

## Enable CONFIG_SYSTEM_TIME64 / CONFIG_FS_LARGEFILE / CONFIG_DEV_URANDOM / CONFIG_TLS_NELEM = 16
kconfig-tweak --enable CONFIG_SYSTEM_TIME64
kconfig-tweak --enable CONFIG_FS_LARGEFILE
kconfig-tweak --enable CONFIG_DEV_URANDOM
kconfig-tweak --set-val CONFIG_TLS_NELEM 16

## Enable Hello Rust Cargo App, increase the Stack Size
kconfig-tweak --enable CONFIG_EXAMPLES_HELLO_RUST_CARGO
kconfig-tweak --set-val CONFIG_EXAMPLES_HELLO_RUST_CARGO_STACKSIZE 16384

## Update the Kconfig Dependencies
make olddefconfig

## Build NuttX with Tracing Enabled
make V=1</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b8f051c25e872fb8a444559c3dbf6374">(See the <strong>Build Log</strong>)</a></p>
<p>According to the Make Trace: <strong>NuttX Build</strong> does this‚Ä¶</p>
<span>
<div><pre><code>## Discard the Rust Debug Symbols
cd apps/examples/rust/hello
cargo build \
  --release \
  -Zbuild-std=std,panic_abort \
  --manifest-path apps/examples/rust/hello/Cargo.toml \
  --target riscv64imac-unknown-nuttx-elf

## Generate the Linker Script
riscv-none-elf-gcc \
  -E \
  -P \
  -x c \
  -isystem nuttx/include \
  -D__NuttX__ \
  -DNDEBUG \
  -D__KERNEL__  \
  -I nuttx/arch/risc-v/src/chip \
  -I nuttx/arch/risc-v/src/common \
  -I nuttx/sched \
  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script \
  -o  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp

## Link Rust App into NuttX
riscv-none-elf-ld \
  --entry=__start \
  -melf64lriscv \
  --gc-sections \
  -nostdlib \
  --cref \
  -Map=nuttx/nuttx.map \
  --print-memory-usage \
  -Tnuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp  \
  -L nuttx/staging \
  -L nuttx/arch/risc-v/src/board  \
  -o nuttx/nuttx   \
  --start-group \
  -lsched \
  -ldrivers \
  -lboards \
  -lc \
  -lmm \
  -larch \
  -lm \
  -lapps \
  -lfs \
  -lbinfmt \
  -lboard xpack-riscv-none-elf-gcc-13.2.0-2/lib/gcc/riscv-none-elf/13.2.0/rv64imac/lp64/libgcc.a apps/examples/rust/hello/target/riscv64imac-unknown-nuttx-elf/release/libhello.a \
  --end-group</code></pre></div></span>
<p>Ah NuttX Build calls <strong>cargo build <code>--</code>release</strong>, stripping the Debug Symbols. We change it to <strong>cargo build</strong> and dump the RISC-V Disassembly‚Ä¶</p>
<span>
<div><pre><code>## Preserve the Rust Debug Symbols
pushd ../apps/examples/rust/hello
cargo build \
  -Zbuild-std=std,panic_abort \
  --manifest-path apps/examples/rust/hello/Cargo.toml \
  --target riscv64imac-unknown-nuttx-elf
popd

## Generate the Linker Script
riscv-none-elf-gcc \
  -E \
  -P \
  -x c \
  -isystem nuttx/include \
  -D__NuttX__ \
  -DNDEBUG \
  -D__KERNEL__  \
  -I nuttx/arch/risc-v/src/chip \
  -I nuttx/arch/risc-v/src/common \
  -I nuttx/sched \
  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script \
  -o  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp

## Link Rust App into NuttX
riscv-none-elf-ld \
  --entry=__start \
  -melf64lriscv \
  --gc-sections \
  -nostdlib \
  --cref \
  -Map=nuttx/nuttx.map \
  --print-memory-usage \
  -Tnuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp  \
  -L nuttx/staging \
  -L nuttx/arch/risc-v/src/board  \
  -o nuttx/nuttx   \
  --start-group \
  -lsched \
  -ldrivers \
  -lboards \
  -lc \
  -lmm \
  -larch \
  -lm \
  -lapps \
  -lfs \
  -lbinfmt \
  -lboard xpack-riscv-none-elf-gcc-13.2.0-2/lib/gcc/riscv-none-elf/13.2.0/rv64imac/lp64/libgcc.a apps/examples/rust/hello/target/riscv64imac-unknown-nuttx-elf/debug/libhello.a \
  --end-group

## Dump the disassembly to nuttx.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;leds64-debug-nuttx.S \
  2&gt;&amp;1</code></pre></div></span>
<p><a href="https://gist.github.com/lupyuen/7b52d54725aaa831cb3dddc0b68bb41f">(See the <strong>Build Log</strong>)</a></p>
<p>Which produces the <strong>Complete NuttX Disassembly</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/rust-std-1/leds64-debug-nuttx.S"><strong>leds64-debug-nuttx.S</strong></a></p>
<p>Whoa the Complete NuttX Disassembly is too huge to inspect!</p>
<p>Let‚Äôs dump the RISC-V Disassembly of the <strong>Rust Part</strong> only: <strong>libhello.a</strong></p>
<div><pre><code>## Dump the libhello.a disassembly to libhello.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  apps/examples/rust/hello/target/riscv64imac-unknown-nuttx-elf/debug/libhello.a \
  &gt;libhello.S \
  2&gt;&amp;1</code></pre></div>
<p>Which produces the (much smaller) <strong>Rust Disassembly</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/rust-std-1/libhello.S"><strong>libhello.S</strong></a></p>
<p>Is Tokio calling NuttX to create POSIX Threads? We search <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/rust-std-1/libhello.S"><strong>libhello.S</strong></a> for <strong>pthread_create</strong>‚Ä¶</p>
<span>
<div><pre><code>.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/thread.rs:85

let ret = libc::pthread_create(&amp;mut native, &amp;attr, thread_start, p as *mut _);

auipc a0, 0x0 122: R_RISCV_PCREL_HI20 std::sys::pal::unix::thread::Thread::new::thread_start
mv    a2, a0 126: R_RISCV_PCREL_LO12_I .Lpcrel_hi254
add   a0, sp, 132
add   a1, sp, 136
sd    a1, 48(sp)
auipc ra, 0x0 130: R_RISCV_CALL_PLT pthread_create</code></pre></div></span>
<p>OK that‚Äôs the <a href="https://doc.rust-lang.org/src/std/sys/pal/unix/thread.rs.html#84"><strong>Rust Standard Library</strong></a> calling <strong>pthread_create</strong> to create a new Rust Thread.</p>
<p>How are <strong>Rust Threads</strong> created in Rust Standard Library? Like this: <a href="https://github.com/rust-lang/rust/blob/master/library/std/src/thread/mod.rs#L502">std/thread/mod.rs</a></p>

<div><pre><code><span>unsafe fn </span>spawn_unchecked_&lt;<span>&#39;scope</span>, F, T&gt;(
  <span>let </span>my_thread = Thread::new(id, name);</code></pre></div>
<p>And <strong>spawn_unchecked</strong> is called by Tokio, according to our Rust Disassembly‚Ä¶</p>
<span>
<div><pre><code>&lt;core::ptr::drop_in_place&lt;std::thread::Builder::spawn_unchecked_::MaybeDangling&lt;tokio::runtime::blocking::pool::Spawner::spawn_thread::{{closure}}&gt;&gt;&gt;:

.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:523

add   sp, sp, -16
sd    ra, 8(sp)
sd    a0, 0(sp)
auipc ra, 0x0 6: R_RISCV_CALL_PLT &lt;std::thread::Builder::spawn_unchecked_::MaybeDangling&lt;T&gt; as core::ops::drop::Drop&gt;::drop</code></pre></div></span>
<p>Yep it checks out: Tokio calls Rust Standard Library, which calls NuttX to create POSIX Threads!</p>
<p><em>Are we sure that Tokio creates a POSIX Thread? Not a NuttX Task?</em></p>
<p>We run <strong><code>hello_rust_cargo &amp;</code></strong> to put it in the background‚Ä¶</p>
<span>
<div><pre><code>nsh&gt; hello_rust_cargo &amp;
Hello world from tokio!

nsh&gt; ps
  PID GROUP PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK            STACK    USED FILLED COMMAND
    0     0   0 FIFO     Kthread   - Ready              0000000000000000 0001904 0000712  37.3%  Idle_Task
    2     2 100 RR       Task      - Running            0000000000000000 0002888 0002472  85.5%! nsh_main
    4     4 100 RR       Task      - Ready              0000000000000000 0007992 0006904  86.3%! hello_rust_cargo</code></pre></div></span>
<p><strong><code>ps</code></strong> says that there‚Äôs only One Single NuttX Task <strong><code>hello_rust_cargo</code></strong>. And no other NuttX Tasks.</p>
<p><a href="https://gist.github.com/lupyuen/0377d9e015fee1d6a833c22e1b118961">(See the <strong>Complete Log</strong>)</a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    
    
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    


</div>
  </body>
</html>
