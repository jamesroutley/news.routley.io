<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cceckman.com/writing/ct-dot-sh/">Original</a>
    <h1>ct.sh: the smallest CT/CD system</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>I started working on a small-as-a-goal <abbr>CT</abbr>/<abbr>CD</abbr> system, just for fun.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> Of course, while it’s a work-in-progress, it doesn’t actually do the “continuous test” or “continuous release”; so what do I do?</p>
<p>I wrote a couple shell scripts, <a href="https://cceckman.com/writing/ct-dot-sh/test.sh"><code>test.sh</code></a> and <a href="https://cceckman.com/writing/ct-dot-sh/deploy.sh"><code>deploy.sh</code></a>, that act as a bare-bones test-and-deploy system. These assume the repository operator trusts everyone who can push, so be careful in your use! For self-hosters and personal projects, I hope this article helps you automate a little bit of your process.</p>
<h2 id="webhooks-git-hooks"><del>Webhooks</del> Git hooks</h2>
<p><dfn id="ct-" title="forge">Forges</dfn> implement CI via <a href="https://docs.github.com/en/webhooks/about-webhooks" rel="external" target="_blank">webhooks</a>. When webhooks are configured, the forge will send HTTP POST requests when certain events occur; for instance, if a branch is updated, or someone makes a comment. The request includes a description of the event: the repository, commit, branch, user, etc. as applicable.</p>
<p>The webhook receiver can do whatever it wants with this information. Often, it kicks off a test run, and the webhook receiver eventually posts the test results back to the forge.</p>
<p>Look at the term again: “web” hooks <a href="https://knowyourmeme.com/memes/antonymic-misinterpretation-x-implies-the-existence-of-y" rel="external" target="_blank">imply the existence of</a> “non-web” hooks! And yes, webhooks are based on Git <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" rel="external" target="_blank">hooks</a>. By putting programs (or links) in a repository’s <code>.git/hooks/</code> directory, you tell Git to run the programs when certain events occur.</p>
<p>Note that “repository” here means “a particular copy of the repository on disk”, not “the abstract set of data that gets shared between machines”. <code>.git</code> files are not themselves subject to source control: if you set up hooks, those are local to that copy of the repository.</p>
<h2 id="where-were-going-we-dont-need-forges">Where we’re going, we don’t need forges</h2>
<p>I have various projects hosted on <a href="https://github.com/cceckman/" rel="external" target="_blank">GitHub</a> and <a href="https://codeberg.org/cceckman/" rel="external" target="_blank">Codeberg</a>, but for a single-committer personal project like this, the forges aren’t super valuable. I trust the committer<del>s</del>, so I don’t really need access control; I’m not taking contributions, so I don’t need pull requests; I don’t need to coordinate with others, so I don’t really need an issue tracker.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<p><a href="https://silly.business/blog/all-you-need-is-ssh-to-self-host-git/" rel="external" target="_blank">All you need is SSH to self host Git</a>! You can “just” set up a repository on another machine. It doesn’t even have to be a powerful/expensive machine! <sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> For this project, I have a <a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Getting-Git-on-a-Server.html#_bare_repo" rel="external" target="_blank">bare</a> repository on a VM; the VM also hosts the “test” deployment of the CT/CD server.</p>
<p>I have this repository configured with an <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks#update" rel="external" target="_blank"><code>update</code> Git hook</a>. The <code>update</code> hook runs during the update of a ref (tag or branch), after all data has been received, but before the ref is actually updated. For instance, if I push commit <code>a1b2c3feed</code> to the <code>main</code> branch, the hook will run when commit <code>a1b2c3feed</code> is available, but when <code>main</code> still points to the older commit. This way, if the <code>update</code> hook fails, the ref is unchanged: a commit that fails tests will not update the <code>main</code> branch.</p>
<h2 id="smol-test-and-deploy">Smol test and deploy</h2>
<p>What’s in the <code>update</code> hook? It’s a symlink to one of two scripts, <code>test.sh</code> or <code>deploy.sh</code>, depending on whether you want testing or testing+deployment.</p>
<p>They mostly work the same way:</p>
<ol>
<li>Create a new copy of the repository, with <code>HEAD</code> pointing at the “new” commit</li>
<li>In that copy, point the updated ref to the “new” commit (i.e. do the update but only in the new copy)</li>
<li>Run a <code>make</code> target: <code>make test-ci</code> or <code>make install-cd</code>. Any logic for the repository should come from the repository’s Makefile; of course, the <code>make</code> target can invoke whatever other tools are needed.</li>
</ol>
<p>The <code>deploy.sh</code> script has a step before these: it invokes <code>test.sh</code>, so it can be used as a drop-in replacement that <em>adds</em> deployment. Also, <code>deploy.sh</code> will only do the “deploy” part if it’s invoked for the <code>main</code> branch; for any other ref, it only runs tests.</p>
<p>That’s it! No YAML, Groovy, or JSON needed. You can read the scripts here: <a href="https://cceckman.com/writing/ct-dot-sh/test.sh"><code>test.sh</code></a> and <a href="https://cceckman.com/writing/ct-dot-sh/deploy.sh"><code>deploy.sh</code></a>. Feel free to use them, though any issues are on your own head.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p>
<h2 id="why-why-not">Why? Why not?</h2>
<h3 id="testing-on-push">Testing on push</h3>
<p>Some folks use client-side Git hooks, like <code>pre-commit</code>, to run tests. That doesn’t work well <em>for me</em> for a few reasons.</p>
<p>First, I’m mostly writing Rust nowadays, where the build times are relatively long (seconds). And I often shuffle stacks of commits around with <a href="https://github.com/arxanas/git-branchless" rel="external" target="_blank">git-branchless</a> and <a href="https://github.com/jesseduffield/lazygit" rel="external" target="_blank">lazygit</a>. Running a test cycle on every commit update would slow down a rebase, for little to no benefit.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></p>
<p>Second, I don’t want to require myself to have every <em>transient</em> commit be test-clean. Sometimes I have a work-in-progress that I want to checkpoint; I don’t want to stop myself from “saving” because the tests are in an intermediate state.<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> When operating in <a href="https://cceckman.com/writing/test-game/">test-driven development</a> mode, I’ll want to commit <em>failing tests</em> before starting work on the feature.</p>
<p>In short, I make a lot of local commits which are never seen elsewhere. The point at which I care about enforcing tests is <em>integration</em>: when I consider the unit of work “complete”, or (in a collaborative project) ready to merge. In the workflows I’m using, that corresponds with a push, not a commit.</p>
<h3 id="testing-remotely">Testing remotely</h3>
<p>I like to test on a different machine than my dev environment to avoid “it works on my machine”. I often forget to <code>git add</code> a file, or to mark that I installed a dependency. Running the tests in a separate context gives me a second start at reproducing the results.</p>
<p>There are ways to get “a separate context” locally: a separate checkout (as the test script does) and a Docker container, for instance. I can imagine an alternative to my setup that uses e.g. the <code>pre-push</code> hook to do a similar flow locally. Let me know if you try that out!</p>
<p>Running the testing on a server also gives me an extra <em>physical</em> copy, in case my development machine dies. Since that server is the same one used for the deployment, bam, continuous deployment.</p>
<h3 id="trusting-myself">Trusting myself</h3>
<p>Note that this setup runs the tests on the Git host… without any isolation, without any resource limits, etc. etc.</p>
<p>That’s usually a bad idea! I wouldn’t use this if I were accepting pushes from strangers on the Internet, or even in a <a href="https://en.wikipedia.org/wiki/Insider_threat" rel="external" target="_blank">mostly-trusted professional context</a>; that’s where the branch protection / access control rules of forge software adds value. Or where “a local hook” makes more sense.</p>
<p>In my particular case, I’m pushing to a VM I own, logging in as myself, and I’ve written all the code in the repository. It won’t do anything I wouldn’t couldn’t do by developing on the VM itself. Having the scripts and hooks gets me that little bit of extra confidence that I can pick up the project later and it will Mostly Work.</p>
<h2 id="try-it-out">Try it out!</h2>
<p>Let me know if you try these scripts, and if they do or don’t work well for you!</p>


<h3 id="terms-as-used">Terms as used</h3>
<dl>
<dt>CT</dt>
<dd>Continuous Testing: the practice of running tests automatically during development. Ideally, tests always pass on <a href="https://martinfowler.com/articles/branching-patterns.html#mainline" rel="external" target="_blank">the main branch</a>, and this is enforced by automation.</dd>
<dt>CI</dt>
<dd>Continuous Integration: the practice of regularly merging in-progress work into the main branch. Doing so makes merge conflicts or behavior conflicts visible sooner rather than later. Martin Fowler suggests a heuristic, <a href="https://martinfowler.com/articles/branching-patterns.html#continuous-integration" rel="external" target="_blank">“you should never have more tha a day’s work unintegrated”</a>; I’d say “you should merge each portion of work that can be reviewed on its own,” as in my experience building a reasonably independent PR may take more than a day, and may require you to know about the future direction.</dd>
<dt>CD</dt>
<dd>Continuous Deployment: automatically and frequently producing release builds and rolling them out to the production environment. In the limit, every commit on the main branch gets deployed. More often in my professional experience, the release process takes longer than the average commit rate, so releases are frequent but not per-commit.</dd>
<dt>forge</dt>
<dd>A server for hosting source code and providing affiliated services, such as access control, review/merge flows, issue tracking, and automation. I suspect the term comes from SourceForge, an early forge. GitHub is probably the most popular. Gitea and Forgejo are two self-hostable forges; <a href="https://codeberg.org" rel="external" target="_blank">Codeberg</a> is an instance of Forgejo. I now mostly host my projects on <a href="https://codeberg.org/cceckman" rel="external" target="_blank">Codeberg</a>.</dd>
</dl>



</div></div>
  </body>
</html>
