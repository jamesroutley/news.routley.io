<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chromium.googlesource.com/chromium/src/&#43;/main/styleguide/c&#43;&#43;/c&#43;&#43;-features.md">Original</a>
    <h1>Banned C&#43;&#43; features in Chromium</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><em>This document is part of the more general <a href="https://chromium.googlesource.com/chromium/src/+/main/styleguide/c++/c++.md">Chromium C++ style guide</a>. It summarizes the supported state of new and updated language and library features in recent C++ standards and the <a href="https://abseil.io/about/">Abseil</a> library. This guide applies to both Chromium and its subprojects, though subprojects can choose to be more restrictive if necessary for toolchain support.</em></p><p>The C++ language has in recent years received an updated standard every three years (C++11, C++14, etc.). <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/process/c++_version_upgrades.md">For various reasons</a>, Chromium does not immediately allow new features on the publication of such a standard. Instead, once Chromium supports the toolchain to a certain extent (e.g., build support is ready), a standard is declared “<em>initially supported</em>”, with new language/library features banned pending discussion but not yet allowed.</p><p>You can propose changing the status of a feature by sending an email to <a href="https://groups.google.com/a/chromium.org/forum/#!forum/cxx">cxx@chromium.org</a>. Include a short blurb on what the feature is and why you think it should or should not be allowed, along with links to any relevant previous discussion. If the list arrives at some consensus, send a codereview to change this file accordingly, linking to your discussion thread.</p><p>If an item remains on the TBD list two years after initial support is added, style arbiters should explicitly move it to an appropriate allowlist or blocklist, allowing it if there are no obvious reasons to ban.</p><p>The current status of existing standards and Abseil features is:</p><ul><li><strong>C++11:</strong> <em>Default allowed; see banned features below</em></li><li><strong>C++14:</strong> <em>Default allowed</em></li><li><strong>C++17:</strong> <em>Default allowed; see banned features below</em></li><li><strong>C++20:</strong> <em>Initially supported November 13, 2023; see allowed/banned/TBD features below</em></li><li><strong>C++23:</strong> <em>Initially supported January 2026; see allowed/banned/TBD features below</em></li><li><strong>C++26:</strong> <em>Not yet supported</em></li><li><strong>Abseil:</strong> <em>Default allowed; see banned/TBD features below. The following dates represent the start of the two-year TBD periods for certain parts of Abseil:</em><ul><li>absl::linked_hash_set &amp; map: Initially added to third_party Dec 30, 2025</li></ul></li></ul><h2><a name="Banned-features-and-third_party-code" href="#Banned-features-and-third_party-code"><span></span></a><a name="banned-features-and-third_party-code" href="#banned-features-and-third_party-code"><span></span></a>Banned features and third-party code</h2><p>Third-party libraries may generally use banned features internally, although features with poor compiler support or poor security properties may make the library unsuitable to use with Chromium.</p><p>Chromium code that calls functions exported from a third-party library may use banned library types that are required by the interface, as long as:</p><ul><li>The disallowed type is used only at the interface, and converted to and from an equivalent allowed type as soon as practical on the Chromium side.</li><li>The feature is not banned due to security issues or lack of compiler support. If it is, discuss with <a href="https://groups.google.com/a/chromium.org/forum/#!forum/cxx">cxx@chromium.org</a> to find a workaround.</li></ul><div role="navigation"><h2>Contents</h2><div><ul><li><a href="#Banned-features-and-third_party-code">Banned features and third-party code</a></li><li><a href="#core-blocklist-11">C++11 Banned Language Features</a></li><ul><li><a href="#Inline-Namespaces-banned">Inline Namespaces [banned]</a></li><li><a href="#long-long-Type-banned">long long Type [banned]</a></li><li><a href="#User_Defined-Literals-banned">User-Defined Literals [banned]</a></li></ul><li><a href="#library-blocklist-11">C++11 Banned Library Features</a></li><ul><li><a href="#cctype_ctype_h_cwctype_wctype_h_banned">&lt;cctype&gt;, &lt;ctype.h&gt;, &lt;cwctype&gt;, &lt;wctype.h&gt; [banned]</a></li><li><a href="#cfenv_fenv_h_banned">&lt;cfenv&gt;, &lt;fenv.h&gt; [banned]</a></li><li><a href="#chrono_banned">&lt;chrono&gt; [banned]</a></li><li><a href="#exception_banned">&lt;exception&gt; [banned]</a></li><li><a href="#Engines-And-Generators-From-random_banned">Engines And Generators From &lt;random&gt; [banned]</a></li><li><a href="#ratio_banned">&lt;ratio&gt; [banned]</a></li><li><a href="#regex_banned">&lt;regex&gt; [banned]</a></li><li><a href="#std_aligned_storage_union_banned">std::aligned_{storage,union} [banned]</a></li><li><a href="#std_bind-banned">std::bind [banned]</a></li><li><a href="#std_function-banned">std::function [banned]</a></li><li><a href="#std_shared_ptr-banned">std::shared_ptr [banned]</a></li><li><a href="#std_sto_i_l_ul_ll_ull_f_d_ld_to_string_banned">std::{sto{i,l,ul,ll,ull,f,d,ld},to_string} [banned]</a></li><li><a href="#std_weak_ptr-banned">std::weak_ptr [banned]</a></li><li><a href="#Thread-Support-Library-banned">Thread Support Library [banned]</a></li></ul><li><a href="#core-blocklist-17">C++17 Banned Language Features</a></li><ul><li><a href="#UTF_8-character-literals-banned">UTF-8 character literals [banned]</a></li></ul><li><a href="#library-blocklist-17">C++17 Banned Library Features</a></li><ul><li><a href="#Mathematical-special-functions-banned">Mathematical special functions [banned]</a></li><li><a href="#Parallel-algorithms-banned">Parallel algorithms [banned]</a></li><li><a href="#std_aligned_alloc-banned">std::aligned_alloc [banned]</a></li><li><a href="#std_any-banned">std::any [banned]</a></li><li><a href="#std_byte-banned">std::byte [banned]</a></li><li><a href="#std_filesystem-banned">std::filesystem [banned]</a></li><li><a href="#std_from_to_chars-banned">std::{from,to}_chars [banned]</a></li><li><a href="#std_pmr_memory_resource_polymorphic_allocator_banned">std::{pmr::memory_resource,polymorphic_allocator} [banned]</a></li><li><a href="#std_timespec_get-banned">std::timespec_get [banned]</a></li><li><a href="#std_uncaught_exceptions-banned">std::uncaught_exceptions [banned]</a></li><li><a href="#Transparent-std_owner_less-banned">Transparent std::owner_less [banned]</a></li><li><a href="#weak_from_this-banned">weak_from_this [banned]</a></li></ul><li><a href="#core-allowlist-20">C++20 Allowed Language Features</a></li><ul><li><a href="#Abbreviated-function-templates-allowed">Abbreviated function templates [allowed]</a></li><li><a href="#consteval-allowed">consteval [allowed]</a></li><li><a href="#Constraints-and-concepts-allowed">Constraints and concepts [allowed]</a></li><li><a href="#Default-comparisons-allowed">Default comparisons [allowed]</a></li><li><a href="#Designated-initializers-allowed">Designated initializers [allowed]</a></li><li><a href="#has_cpp_attribute-allowed">__has_cpp_attribute [allowed]</a></li><li><a href="#constinit-allowed">constinit [allowed]</a></li><li><a href="#Initializers-for-bit_field-members-allowed">Initializers for bit-field members [allowed]</a></li><li><a href="#Lambda-captures-with-initializers-that-are-pack-expansions-allowed">Lambda captures with initializers that are pack expansions [allowed]</a></li><li><a href="#Language-feature_test-macros-allowed">Language feature-test macros [allowed]</a></li><li><a href="#likely_unlikely_allowed">[[likely]], [[unlikely]] [allowed]</a></li><li><a href="#Range_for-statements-with-initializer-allowed">Range-for statements with initializer [allowed]</a></li><li><a href="#Three_way-comparison-spaceship_operator-allowed">Three-way comparison (spaceship) operator [allowed]</a></li><li><a href="#using-enum-declarations-allowed">using enum declarations [allowed]</a></li></ul><li><a href="#library-allowlist-20">C++20 Allowed Library Features</a></li><ul><li><a href="#bit_allowed">&lt;bit&gt; [allowed]</a></li><li><a href="#compare_allowed">&lt;compare&gt; [allowed]</a></li><li><a href="#concepts_allowed">&lt;concepts&gt; [allowed]</a></li><li><a href="#Range-algorithms-allowed">Range algorithms [allowed]</a></li><li><a href="#Range-access_range-primitives_dangling-iterator-handling_and-range-concepts-allowed">Range access, range primitives, dangling iterator handling, and range concepts [allowed]</a></li><li><a href="#Library-feature_test-macros-and-version_allowed">Library feature-test macros and &lt;version&gt; [allowed]</a></li><li><a href="#numbers_allowed">&lt;numbers&gt; [allowed]</a></li><li><a href="#std_assume_aligned-allowed">std::assume_aligned [allowed]</a></li><li><a href="#std_erase_if_for-containers-allowed">std::erase[_if] for containers [allowed]</a></li><li><a href="#std_hardware_con_de_structive_interference_size-allowed">std::hardware_{con,de}structive_interference_size [allowed]</a></li><li><a href="#std_is_un_bounded_array-allowed">std::is_[un]bounded_array [allowed]</a></li><li><a href="#std_lerp-allowed">std::lerp [allowed]</a></li><li><a href="#std_make_obj_using_allocator-etc_allowed">std::make_obj_using_allocator etc. [allowed]</a></li><li><a href="#std_make_unique_for_overwrite-allowed">std::make_unique_for_overwrite [allowed]</a></li><li><a href="#std_midpoint-allowed">std::midpoint [allowed]</a></li><li><a href="#std_ranges_subrange-allowed">std::ranges::subrange [allowed]</a></li><li><a href="#std_remove_cvref_t_allowed">std::remove_cvref[_t] [allowed]</a></li><li><a href="#std_ssize-allowed">std::ssize [allowed]</a></li><li><a href="#std_string_starts_ends_with-allowed">std::string::(starts,ends)_with [allowed]</a></li></ul><li><a href="#core-blocklist-20">C++20 Banned Language Features</a></li><ul><li><a href="#char8_t-banned">char8_t [banned]</a></li><li><a href="#Modules-banned">Modules [banned]</a></li><li><a href="#no_unique_address_banned">[[no_unique_address]] [banned]</a></li></ul><li><a href="#library-blocklist-20">C++20 Banned Library Features</a></li><ul><li><a href="#std_bind_front-banned">std::bind_front [banned]</a></li><li><a href="#std_bit_cast-banned">std::bit_cast [banned]</a></li><li><a href="#std_c8rtomb_mbrtoc8_banned">std::{c8rtomb,mbrtoc8} [banned]</a></li><li><a href="#Range-factories-and-range-adaptors-banned">Range factories and range adaptors [banned]</a></li><li><a href="#std_ranges_view_interface-banned">std::ranges::view_interface [banned]</a></li><li><a href="#span_banned">&lt;span&gt; [banned]</a></li><li><a href="#std_to_address-banned">std::to_address [banned]</a></li><li><a href="#syncstream_banned">&lt;syncstream&gt; [banned]</a></li></ul><li><a href="#core-review-20">C++20 TBD Language Features</a></li><ul><li><a href="#Aggregate-initialization-using-parentheses-tbd">Aggregate initialization using parentheses [tbd]</a></li><li><a href="#Coroutines-tbd">Coroutines [tbd]</a></li></ul><li><a href="#library-review-20">C++20 TBD Library Features</a></li><ul><li><a href="#coroutine_tbd">&lt;coroutine&gt; [tbd]</a></li><li><a href="#format_tbd">&lt;format&gt; [tbd]</a></li><li><a href="#source_location_tbd">&lt;source_location&gt; [tbd]</a></li><li><a href="#std_u8string-tbd">std::u8string [tbd]</a></li></ul><li><a href="#core-allowlist-23">C++23 Allowed Language Features</a></li><ul><li><a href="#elifdef_elifndef-allowed">#elifdef, #elifndef [allowed]</a></li><li><a href="#if-consteval-allowed">if consteval [allowed]</a></li><li><a href="#Static-operators-and-allowed">Static operators () and [] [allowed]</a></li></ul><li><a href="#library-allowlist-23">C++23 Allowed Library Features</a></li><ul><li><a href="#std_basic_string_contains-allowed">std::basic_string::contains [allowed]</a></li><li><a href="#std_byteswap-allowed">std::byteswap [allowed]</a></li><li><a href="#Various-new-ranges-algorithms-allowed">Various new ranges algorithms [allowed]</a></li><li><a href="#std_to_underlying-allowed">std::to_underlying [allowed]</a></li></ul><li><a href="#core-review-23">C++23 TBD Language Features</a></li><ul><li><a href="#Explicit-object-parameter-tbd">Explicit object parameter [tbd]</a></li><li><a href="#Multidimensional-subscript-operator-tbd">Multidimensional subscript operator [tbd]</a></li><li><a href="#auto_x_auto_x_tbd">auto(x), auto{x} [tbd]</a></li><li><a href="#assume_tbd">[[assume]] [tbd]</a></li><li><a href="#warning-tbd">#warning [tbd]</a></li><li><a href="#Literal-suffix-for-size_t-tbd">Literal suffix for size_t [tbd]</a></li><li><a href="#Named-character-escapes-tbd">Named character escapes [tbd]</a></li></ul><li><a href="#library-review-23">C++23 TBD Library Features</a></li><ul><li><a href="#Constructing-containers-with-std_from_range-tbd">Constructing containers with std::from_range [tbd]</a></li><li><a href="#Monadic-operations-for-std_optional-tbd">Monadic operations for std::optional [tbd]</a></li><li><a href="#std_expected-tbd">std::expected [tbd]</a></li><li><a href="#std_flat_map_std_flat_multimap_std_flat_set_std_flat_multiset-tbd">std::flat_map, std::flat_multimap, std::flat_set, std::flat_multiset [tbd]</a></li><li><a href="#std_out_ptr_std_inout_ptr-tbd">std::out_ptr, std::inout_ptr [tbd]</a></li><li><a href="#std_mdspan-tbd">std::mdspan [tbd]</a></li><li><a href="#std_ranges_to-tbd">std::ranges::to [tbd]</a></li><li><a href="#Range-Formatting-tbd">Range Formatting [tbd]</a></li><li><a href="#std_print-tbd">std::print [tbd]</a></li><li><a href="#std_generator-tbd">std::generator [tbd]</a></li><li><a href="#std_stacktrace-tbd">std::stacktrace [tbd]</a></li><li><a href="#std_move_only_function-tbd">std::move_only_function [tbd]</a></li><li><a href="#std_unreachable-tbd">std::unreachable [tbd]</a></li><li><a href="#std_spanstream-tbd">std::spanstream [tbd]</a></li><li><a href="#Fixed-width-floating_point-types-tbd">Fixed width floating-point types [tbd]</a></li><li><a href="#std_start_lifetime_as-tbd">std::start_lifetime_as [tbd]</a></li></ul><li><a href="#absl-blocklist">Abseil Banned Library Features</a></li><ul><li><a href="#Any-banned">Any [banned]</a></li><li><a href="#AnyInvocable-banned">AnyInvocable [banned]</a></li><li><a href="#Attributes-banned">Attributes [banned]</a></li><li><a href="#btree_containers-banned">btree_* containers [banned]</a></li><li><a href="#bind_front-banned">bind_front [banned]</a></li><li><a href="#Command-line-flags-banned">Command line flags [banned]</a></li><li><a href="#Container-utilities-banned">Container utilities [banned]</a></li><li><a href="#FixedArray-banned">FixedArray [banned]</a></li><li><a href="#FunctionRef-banned">FunctionRef [banned]</a></li><li><a href="#Log-macros-and-related-classes-banned">Log macros and related classes [banned]</a></li><li><a href="#NoDestructor-banned">NoDestructor [banned]</a></li><li><a href="#Nullability-annotations-banned">Nullability annotations [banned]</a></li><li><a href="#Optional-banned">Optional [banned]</a></li><li><a href="#Random-banned">Random [banned]</a></li><li><a href="#Span-banned">Span [banned]</a></li><li><a href="#StatusOr-banned">StatusOr [banned]</a></li><li><a href="#string_view-banned">string_view [banned]</a></li><li><a href="#Strings-Library-banned">Strings Library [banned]</a></li><li><a href="#Synchronization-banned">Synchronization [banned]</a></li><li><a href="#Time-library-banned">Time library [banned]</a></li><li><a href="#Variant-banned">Variant [banned]</a></li><li><a href="#Utility-library-banned">Utility library [banned]</a></li></ul><li><a href="#absl-review">Abseil TBD Features</a></li><ul><li><a href="#absl_linked_hash_set_absl_linked_hash_map-tbd">absl::linked_hash_set, absl::linked_hash_map [tbd]</a></li></ul></ul></div></div><h2><a name="core-blocklist-11" href="#core-blocklist-11"><span></span></a>C++11 Banned Language Features</h2><p>The following C++11 language features are not allowed in the Chromium codebase.</p><h3><a name="Inline-Namespaces-banned" href="#Inline-Namespaces-banned"><span></span></a><a name="inline-namespaces-banned" href="#inline-namespaces-banned"><span></span></a>Inline Namespaces [banned]</h3><pre><span>inline</span><span> </span><span>namespace</span><span> foo </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Allows better versioning of namespaces.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/namespace#Inline_namespaces">Inline namespaces</a></p><p><strong>Notes:</strong></p><p>Banned in the <a href="https://google.github.io/styleguide/cppguide.html#Namespaces">Google Style Guide</a>. Unclear how it will work with components.</p><h3><a name="long-long-Type-banned" href="#long-long-Type-banned"><span></span></a><a name="long-long-type-banned" href="#long-long-type-banned"><span></span></a>long long Type [banned]</h3><pre><span>long</span><span> </span><span>long</span><span> </span><span>var</span><span> </span><span>=</span><span> value</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> An integer of at least 64 bits.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/types">Fundamental types</a></p><p><strong>Notes:</strong></p><h3><a name="User_Defined-Literals-banned" href="#User_Defined-Literals-banned"><span></span></a><a name="user_defined-literals-banned" href="#user_defined-literals-banned"><span></span></a>User-Defined Literals [banned]</h3><pre><span>DistanceType</span><span> </span><span>var</span><span> </span><span>=</span><span> </span><span>12</span><span>_km</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Allows user-defined literal expressions.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/user_literal">User-defined literals</a></p><p><strong>Notes:</strong></p><h2><a name="library-blocklist-11" href="#library-blocklist-11"><span></span></a>C++11 Banned Library Features</h2><p>The following C++11 library features are not allowed in the Chromium codebase.</p><h3><a name="cctype_ctype_h_cwctype_wctype_h_banned" href="#cctype_ctype_h_cwctype_wctype_h_banned"><span></span></a>&lt;cctype&gt;, &lt;ctype.h&gt;, &lt;cwctype&gt;, &lt;wctype.h&gt; [banned]</h3><pre><span>#include</span><span> </span><span>&lt;cctype&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;cwctype&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;ctype.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;wctype.h&gt;</span><span>
</span></pre><p><strong>Description:</strong> Provides utilities for ASCII characters.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/cctype">Standard library header <code>&lt;cctype&gt;</code></a>, <a href="https://en.cppreference.com/w/cpp/header/cwctype">Standard library header <code>&lt;cwctype&gt;</code></a></p><p><strong>Notes:</strong></p><p>Banned due to dependence on the C locale as well as UB when arguments don&#39;t fit in an <code>unsigned char</code>/<code>wchar_t</code>. Use similarly-named replacements in <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/strings/ascii.h">third_party/abseil-cpp/absl/strings/ascii.h</a> instead.</p><h3><a name="cfenv_fenv_h_banned" href="#cfenv_fenv_h_banned"><span></span></a>&lt;cfenv&gt;, &lt;fenv.h&gt; [banned]</h3><pre><span>#include</span><span> </span><span>&lt;cfenv&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;fenv.h&gt;</span><span>
</span></pre><p><strong>Description:</strong> Provides floating point status flags and control modes for C-compatible code.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/cfenv">Standard library header <code>&lt;cfenv&gt;</code></a></p><p><strong>Notes:</strong></p><h3><a name="chrono_banned" href="#chrono_banned"><span></span></a>&lt;chrono&gt; [banned]</h3><pre><span>#include</span><span> </span><span>&lt;chrono&gt;</span><span>
</span></pre><p><strong>Description:</strong> A standard date and time library.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/chrono">Date and time utilities</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base/time</code>.</p><h3><a name="exception_banned" href="#exception_banned"><span></span></a>&lt;exception&gt; [banned]</h3><pre><span>#include</span><span> </span><span>&lt;exception&gt;</span><span>
</span></pre><p><strong>Description:</strong> Exception throwing and handling.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/exception">Standard library header <code>&lt;exception&gt;</code></a></p><p><strong>Notes:</strong></p><h3><a name="Engines-And-Generators-From-random_banned" href="#Engines-And-Generators-From-random_banned"><span></span></a><a name="engines-and-generators-from-random_banned" href="#engines-and-generators-from-random_banned"><span></span></a>Engines And Generators From &lt;random&gt; [banned]</h3><pre><span>std</span><span>::</span><span>mt19937 generator</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Methods of generating random numbers.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/numeric/random">Pseudo-random number generation</a></p><p><strong>Notes:</strong></p><h3><a name="ratio_banned" href="#ratio_banned"><span></span></a>&lt;ratio&gt; [banned]</h3><pre><span>#include</span><span> </span><span>&lt;ratio&gt;</span><span>
</span></pre><p><strong>Description:</strong> Provides compile-time rational numbers.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/numeric/ratio/ratio"><code>std::ratio</code></a></p><p><strong>Notes:</strong></p><p>Banned by the <a href="https://google.github.io/styleguide/cppguide.html#C++11">Google Style Guide</a> due to concerns that this is tied to a more template-heavy interface style.</p><h3><a name="regex_banned" href="#regex_banned"><span></span></a>&lt;regex&gt; [banned]</h3><pre><span>#include</span><span> </span><span>&lt;regex&gt;</span><span>
</span></pre><p><strong>Description:</strong> A standard regular expressions library.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/regex">Regular expressions library</a></p><p><strong>Notes:</strong></p><p>Overlaps with many regular expression libraries in Chromium. When in doubt, use <code>third_party/re2</code>.</p><h3><a name="std_aligned_storage_union_banned" href="#std_aligned_storage_union_banned"><span></span></a>std::aligned_{storage,union} [banned]</h3><pre><span>std</span><span>::</span><span>aligned_storage</span><span>&lt;</span><span>sizeof</span><span>(</span><span>T</span><span>),</span><span> </span><span>alignof</span><span>&lt;</span><span>T</span><span>&gt;&gt;::</span><span>type buf</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Creates aligned, uninitialized storage to later hold one or more objects.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/types/aligned_storage"><code>std::aligned_storage</code></a></p><p><strong>Notes:</strong></p><p>Deprecated in C++23. Generally, use <code>alignas(T) char buf[sizeof(T)];</code>. Aligned unions can be handled similarly, using the max alignment and size of the union members, either passed via a pack or computed inline.</p><h3><a name="std_bind-banned" href="#std_bind-banned"><span></span></a>std::bind [banned]</h3><pre><span>auto</span><span> x </span><span>=</span><span> std</span><span>::</span><span>bind</span><span>(</span><span>function</span><span>,</span><span> args</span><span>,</span><span> </span><span>...);</span><span>
</span></pre><p><strong>Description:</strong> Declares a function object bound to certain arguments.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/functional/bind"><code>std::bind</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_function-banned" href="#std_function-banned"><span></span></a>std::function [banned]</h3><pre><span>std</span><span>::</span><span>function</span><span> x </span><span>=</span><span> </span><span>[]</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>10</span><span>;</span><span> </span><span>};</span><span>
std</span><span>::</span><span>function</span><span> y </span><span>=</span><span> std</span><span>::</span><span>bind</span><span>(</span><span>foo</span><span>,</span><span> args</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Wraps a standard polymorphic function.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_shared_ptr-banned" href="#std_shared_ptr-banned"><span></span></a>std::shared_ptr [banned]</h3><pre><span>std</span><span>::</span><span>shared_ptr</span><span>&lt;int&gt;</span><span> x </span><span>=</span><span> std</span><span>::</span><span>make_shared</span><span>&lt;int&gt;</span><span>(</span><span>10</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Allows shared ownership of a pointer through reference counts.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_sto_i_l_ul_ll_ull_f_d_ld_to_string_banned" href="#std_sto_i_l_ul_ll_ull_f_d_ld_to_string_banned"><span></span></a>std::{sto{i,l,ul,ll,ull,f,d,ld},to_string} [banned]</h3><pre><span>int</span><span> x </span><span>=</span><span> std</span><span>::</span><span>stoi</span><span>(</span><span>&#34;10&#34;</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Converts strings to/from numbers.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/string/basic_string/stol"><code>std::stoi</code>, <code>std::stol</code>, <code>std::stoll</code></a>, <a href="https://en.cppreference.com/w/cpp/string/basic_string/stoul"><code>std::stoul</code>, <code>std::stoull</code></a>, <a href="https://en.cppreference.com/w/cpp/string/basic_string/stof"><code>std::stof</code>, <code>std::stod</code>, <code>std::stold</code></a>, <a href="https://en.cppreference.com/w/cpp/string/basic_string/to_string"><code>std::to_string</code></a></p><p><strong>Notes:</strong></p><p>The string-to-number conversions rely on exceptions to communicate failure, while the number-to-string conversions have performance concerns and depend on the locale. Use <code>base/strings/string_number_conversions.h</code> instead.</p><h3><a name="std_weak_ptr-banned" href="#std_weak_ptr-banned"><span></span></a>std::weak_ptr [banned]</h3><pre><span>std</span><span>::</span><span>weak_ptr</span><span>&lt;int&gt;</span><span> x </span><span>=</span><span> my_shared_x</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Allows a weak reference to a <code>std::shared_ptr</code>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr</code></a></p><p><strong>Notes:</strong></p><p>Banned because <code>std::shared_ptr</code> is banned.  Use <code>base::WeakPtr</code> instead.</p><h3><a name="Thread-Support-Library-banned" href="#Thread-Support-Library-banned"><span></span></a><a name="thread-support-library-banned" href="#thread-support-library-banned"><span></span></a>Thread Support Library [banned]</h3><pre><span>#include</span><span> </span><span>&lt;barrier&gt;</span><span>             </span><span>// C++20</span><span>
</span><span>#include</span><span> </span><span>&lt;condition_variable&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;future&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;latch&gt;</span><span>               </span><span>// C++20</span><span>
</span><span>#include</span><span> </span><span>&lt;mutex&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;semaphore&gt;</span><span>           </span><span>// C++20</span><span>
</span><span>#include</span><span> </span><span>&lt;stop_token&gt;</span><span>          </span><span>// C++20</span><span>
</span><span>#include</span><span> </span><span>&lt;thread&gt;</span><span>
</span></pre><p><strong>Description:</strong> Provides a standard multithreading library using <code>std::thread</code> and associates</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/thread">Thread support library</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base/synchronization</code>. <code>base::Thread</code> is tightly coupled to <code>base::MessageLoop</code> which would make it hard to replace. We should investigate using standard mutexes, or <code>std::unique_lock</code>, etc. to replace our locking/synchronization classes.</p><h2><a name="core-blocklist-17" href="#core-blocklist-17"><span></span></a>C++17 Banned Language Features</h2><p>The following C++17 language features are not allowed in the Chromium codebase.</p><h3><a name="UTF_8-character-literals-banned" href="#UTF_8-character-literals-banned"><span></span></a><a name="utf_8-character-literals-banned" href="#utf_8-character-literals-banned"><span></span></a>UTF-8 character literals [banned]</h3><pre><span>char</span><span> x </span><span>=</span><span> u8</span><span>&#39;x&#39;</span><span>;</span><span>     </span><span>// C++17</span><span>
</span><span>char8_t</span><span> x </span><span>=</span><span> u8</span><span>&#39;x&#39;</span><span>;</span><span>  </span><span>// C++20</span><span>
</span></pre><p><strong>Description:</strong> A character literal that begins with <code>u8</code> is a character literal of type <code>char</code> (C++17) or <code>char8_t</code> (C++20). The value of a UTF-8 character literal is equal to its ISO 10646 code point value.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/character_literal">Character literal</a></p><p><strong>Notes:</strong></p><p>Banned because <code>char8_t</code> is banned. Use an unprefixed character or string literal; it should be encoded in the binary as UTF-8 on all supported platforms.</p><h2><a name="library-blocklist-17" href="#library-blocklist-17"><span></span></a>C++17 Banned Library Features</h2><p>The following C++17 library features are not allowed in the Chromium codebase.</p><h3><a name="Mathematical-special-functions-banned" href="#Mathematical-special-functions-banned"><span></span></a><a name="mathematical-special-functions-banned" href="#mathematical-special-functions-banned"><span></span></a>Mathematical special functions [banned]</h3><pre><span>std</span><span>::</span><span>assoc_laguerre</span><span>()</span><span>
std</span><span>::</span><span>assoc_legendre</span><span>()</span><span>
std</span><span>::</span><span>beta</span><span>()</span><span>
std</span><span>::</span><span>comp_ellint_1</span><span>()</span><span>
std</span><span>::</span><span>comp_ellint_2</span><span>()</span><span>
std</span><span>::</span><span>comp_ellint_3</span><span>()</span><span>
std</span><span>::</span><span>cyl_bessel_i</span><span>()</span><span>
std</span><span>::</span><span>cyl_bessel_j</span><span>()</span><span>
std</span><span>::</span><span>cyl_bessel_k</span><span>()</span><span>
std</span><span>::</span><span>cyl_neumann</span><span>()</span><span>
std</span><span>::</span><span>ellint_1</span><span>()</span><span>
std</span><span>::</span><span>ellint_2</span><span>()</span><span>
std</span><span>::</span><span>ellint_3</span><span>()</span><span>
std</span><span>::</span><span>expint</span><span>()</span><span>
std</span><span>::</span><span>hermite</span><span>()</span><span>
std</span><span>::</span><span>legendre</span><span>()</span><span>
std</span><span>::</span><span>laguerre</span><span>()</span><span>
std</span><span>::</span><span>riemann_zeta</span><span>()</span><span>
std</span><span>::</span><span>sph_bessel</span><span>()</span><span>
std</span><span>::</span><span>sph_legendre</span><span>()</span><span>
std</span><span>::</span><span>sph_neumann</span><span>()</span><span>
</span></pre><p><strong>Description:</strong> A variety of mathematical functions.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/numeric/special_functions">Mathematical special functions</a></p><p><strong>Notes:</strong></p><h3><a name="Parallel-algorithms-banned" href="#Parallel-algorithms-banned"><span></span></a><a name="parallel-algorithms-banned" href="#parallel-algorithms-banned"><span></span></a>Parallel algorithms [banned]</h3><pre><span>auto</span><span> it </span><span>=</span><span> std</span><span>::</span><span>find</span><span>(</span><span>std</span><span>::</span><span>execution</span><span>::</span><span>par</span><span>,</span><span> std</span><span>::</span><span>begin</span><span>(</span><span>vec</span><span>),</span><span> std</span><span>::</span><span>end</span><span>(</span><span>vec</span><span>),</span><span> </span><span>2</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Many of the STL algorithms, such as the <code>copy</code>, <code>find</code> and <code>sort</code> methods, now support the parallel execution policies: <code>seq</code>, <code>par</code>, and <code>par_unseq</code> which translate to “sequentially”, “parallel” and “parallel unsequenced”.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"><code>std::execution::sequenced_policy</code>, <code>std::execution::parallel_policy</code>, <code>std::execution::parallel_unsequenced_policy</code>, <code>std::execution::unsequenced_policy</code></a></p><p><strong>Notes:</strong></p><p>Banned because <a href="https://libcxx.llvm.org/Status/PSTL.html">libc++ support is incomplete</a> and the interaction of its threading implementation with Chrome‘s is unclear. Prefer to explicitly parallelize long-running algorithms using Chrome’s threading APIs, so the same scheduler controls, shutdown policies, tracing, etc. apply as in any other multithreaded code.</p><h3><a name="std_aligned_alloc-banned" href="#std_aligned_alloc-banned"><span></span></a>std::aligned_alloc [banned]</h3><pre><span>int</span><span>*</span><span> p2 </span><span>=</span><span> </span><span>static_cast</span><span>&lt;</span><span>int</span><span>*&gt;(</span><span>std</span><span>::</span><span>aligned_alloc</span><span>(</span><span>1024</span><span>,</span><span> </span><span>1024</span><span>));</span><span>
</span></pre><p><strong>Description:</strong> Allocates uninitialized storage with the specified alignment.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/c/aligned_alloc"><code>std::aligned_alloc</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_any-banned" href="#std_any-banned"><span></span></a>std::any [banned]</h3><pre><span>std</span><span>::</span><span>any x </span><span>=</span><span> </span><span>5</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> A type-safe container for single values of any type.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_byte-banned" href="#std_byte-banned"><span></span></a>std::byte [banned]</h3><pre><span>std</span><span>::</span><span>byte</span><span> b </span><span>=</span><span> </span><span>0xFF</span><span>;</span><span>
</span><span>int</span><span> i </span><span>=</span><span> std</span><span>::</span><span>to_integer</span><span>&lt;int&gt;</span><span>(</span><span>b</span><span>);</span><span>  </span><span>// 0xFF</span><span>
</span></pre><p><strong>Description:</strong> The contents of a single memory unit. <code>std::byte</code> has the same size and aliasing rules as <code>unsigned char</code>, but does not semantically represent a character or arithmetic value, and does not expose operators other than bitwise ops.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/types/byte"><code>std::byte</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_filesystem-banned" href="#std_filesystem-banned"><span></span></a>std::filesystem [banned]</h3><pre><span>#include</span><span> </span><span>&lt;filesystem&gt;</span><span>
</span></pre><p><strong>Description:</strong> A standard way to manipulate files, directories, and paths in a filesystem.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/filesystem">Filesystem library</a></p><p><strong>Notes:</strong></p><h3><a name="std_from_to_chars-banned" href="#std_from_to_chars-banned"><span></span></a>std::{from,to}_chars [banned]</h3><pre><span>std</span><span>::</span><span>from_chars</span><span>(</span><span>str</span><span>.</span><span>data</span><span>(),</span><span> str</span><span>.</span><span>data</span><span>()</span><span> </span><span>+</span><span> str</span><span>.</span><span>size</span><span>(),</span><span> result</span><span>);</span><span>
std</span><span>::</span><span>to_chars</span><span>(</span><span>str</span><span>.</span><span>data</span><span>(),</span><span> str</span><span>.</span><span>data</span><span>()</span><span> </span><span>+</span><span> str</span><span>.</span><span>size</span><span>(),</span><span> </span><span>42</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Locale-independent, non-allocating, non-throwing functions to convert values from/to character strings, designed for use in high-throughput contexts.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/from_chars"><code>std::from_chars</code></a> <a href="https://en.cppreference.com/w/cpp/utility/to_chars"><code>std::to_chars</code></a>,</p><p><strong>Notes:</strong></p><p>Overlaps with utilities in <code>base/strings/string_number_conversions.h</code>, which are easier to use correctly.</p><h3><a name="std_pmr_memory_resource_polymorphic_allocator_banned" href="#std_pmr_memory_resource_polymorphic_allocator_banned"><span></span></a>std::{pmr::memory_resource,polymorphic_allocator} [banned]</h3><pre><span>#include</span><span> </span><span>&lt;memory_resource&gt;</span><span>
</span></pre><p><strong>Description:</strong> Manages memory allocations using runtime polymorphism.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/memory_resource"><code>std::pmr::memory_resource</code></a>, <a href="https://en.cppreference.com/w/cpp/memory/polymorphic_allocator"><code>std::pmr::polymorphic_allocator</code></a></p><p><strong>Notes:</strong></p><p>Banned because Chromium does not customize allocators (<a href="https://chromium.googlesource.com/chromium/src/+/main/base/allocator/partition_allocator/PartitionAlloc.md">PartitionAlloc</a> is used globally).</p><h3><a name="std_timespec_get-banned" href="#std_timespec_get-banned"><span></span></a>std::timespec_get [banned]</h3><pre><span>std</span><span>::</span><span>timespec ts</span><span>;</span><span>
std</span><span>::</span><span>timespec_get</span><span>(&amp;</span><span>ts</span><span>,</span><span> TIME_UTC</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Gets the current calendar time in the given time base.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/chrono/c/timespec_get"><code>std::timespec_get</code></a></p><p><strong>Notes:</strong></p><p>Banned due to unclear, implementation-defined behavior. On POSIX, use <code>base::TimeDelta::ToTimeSpec()</code>; this could be supported on other platforms if desirable.</p><h3><a name="std_uncaught_exceptions-banned" href="#std_uncaught_exceptions-banned"><span></span></a>std::uncaught_exceptions [banned]</h3><pre><span>int</span><span> count </span><span>=</span><span> std</span><span>::</span><span>uncaught_exceptions</span><span>();</span><span>
</span></pre><p><strong>Description:</strong> Determines whether there are live exception objects.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/error/uncaught_exception"><code>std::uncaught_exceptions</code></a></p><p><strong>Notes:</strong></p><p>Banned because exceptions are banned.</p><h3><a name="Transparent-std_owner_less-banned" href="#Transparent-std_owner_less-banned"><span></span></a><a name="transparent-std_owner_less-banned" href="#transparent-std_owner_less-banned"><span></span></a>Transparent std::owner_less [banned]</h3><pre><span>std</span><span>::</span><span>map</span><span>&lt;</span><span>std</span><span>::</span><span>weak_ptr</span><span>&lt;</span><span>T</span><span>&gt;,</span><span> U</span><span>,</span><span> std</span><span>::</span><span>owner_less</span><span>&lt;&gt;&gt;</span><span>
</span></pre><p><strong>Description:</strong> Function object providing mixed-type owner-based ordering of shared and weak pointers, regardless of the type of the pointee.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/owner_less"><code>std::owner_less</code></a></p><p><strong>Notes:</strong></p><p>Banned since <code>std::shared_ptr</code> and <code>std::weak_ptr</code> are banned.</p><h3><a name="weak_from_this-banned" href="#weak_from_this-banned"><span></span></a>weak_from_this [banned]</h3><pre><span>auto</span><span> weak_ptr </span><span>=</span><span> weak_from_this</span><span>();</span><span>
</span></pre><p><strong>Description:</strong> Returns a <code>std::weak_ptr&lt;T&gt;</code> that tracks ownership of <code>*this</code> by all existing <code>std::shared_ptr</code>s that refer to <code>*this</code>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this/weak_from_this"><code>std::enable_shared_from_this&lt;T&gt;::weak_from_this</code></a></p><p><strong>Notes:</strong></p><p>Banned since <code>std::shared_ptr</code> and <code>std::weak_ptr</code> are banned.</p><h2><a name="core-allowlist-20" href="#core-allowlist-20"><span></span></a>C++20 Allowed Language Features</h2><p>The following C++20 language features are allowed in the Chromium codebase.</p><h3><a name="Abbreviated-function-templates-allowed" href="#Abbreviated-function-templates-allowed"><span></span></a><a name="abbreviated-function-templates-allowed" href="#abbreviated-function-templates-allowed"><span></span></a>Abbreviated function templates [allowed]</h3><pre><span>// template &lt;typename T&gt;</span><span>
</span><span>// void f1(T x);</span><span>
</span><span>void</span><span> f1</span><span>(</span><span>auto</span><span> x</span><span>);</span><span>

</span><span>// template &lt;C T&gt;  // `C` is a concept</span><span>
</span><span>// void f2(T x);</span><span>
</span><span>void</span><span> f2</span><span>(</span><span>C </span><span>auto</span><span> x</span><span>);</span><span>

</span><span>// template &lt;typename T, C U&gt;  // `C` is a concept</span><span>
</span><span>// void f3(T x, U y);</span><span>
</span><span>template</span><span> </span><span>&lt;</span><span>typename</span><span> T</span><span>&gt;</span><span>
</span><span>void</span><span> f3</span><span>(</span><span>T x</span><span>,</span><span> C </span><span>auto</span><span> y</span><span>);</span><span>

</span><span>// template&lt;typename... Ts&gt;</span><span>
</span><span>// void f4(Ts... xs);</span><span>
</span><span>void</span><span> f4</span><span>(</span><span>auto</span><span>...</span><span> xs</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Function params of type <code>auto</code> become syntactic sugar for declaring a template type for each such parameter.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/function_template#Abbreviated_function_template">Abbreviated function template</a></p><p><strong>Notes:</strong></p><h3><a name="consteval-allowed" href="#consteval-allowed"><span></span></a>consteval [allowed]</h3><pre><span>consteval </span><span>int</span><span> sqr</span><span>(</span><span>int</span><span> n</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> n </span><span>*</span><span> n</span><span>;</span><span> </span><span>}</span><span>
</span><span>constexpr</span><span> </span><span>int</span><span> kHundred </span><span>=</span><span> sqr</span><span>(</span><span>10</span><span>);</span><span>                  </span><span>// OK</span><span>
</span><span>constexpr</span><span> </span><span>int</span><span> quad</span><span>(</span><span>int</span><span> n</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> sqr</span><span>(</span><span>sqr</span><span>(</span><span>n</span><span>));</span><span> </span><span>}</span><span>  </span><span>// ERROR, might be runtime</span><span>
</span></pre><p><strong>Description:</strong> Specified that a function may only be used in a compile-time context.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/consteval"><code>consteval</code> specifier</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="Constraints-and-concepts-allowed" href="#Constraints-and-concepts-allowed"><span></span></a><a name="constraints-and-concepts-allowed" href="#constraints-and-concepts-allowed"><span></span></a>Constraints and concepts [allowed]</h3><pre><span>// `Hashable` is a concept satisfied by any type `T` for which the expression</span><span>
</span><span>// `std::hash&lt;T&gt;{}(a)` compiles and produces a value convertible to `size_t`.</span><span>
</span><span>template</span><span>&lt;</span><span>typename</span><span> T</span><span>&gt;</span><span>
</span><span>concept</span><span> </span><span>Hashable</span><span> </span><span>=</span><span> requires</span><span>(</span><span>T a</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>{</span><span> std</span><span>::</span><span>hash</span><span>&lt;</span><span>T</span><span>&gt;{}(</span><span>a</span><span>)</span><span> </span><span>}</span><span> </span><span>-&gt;</span><span> std</span><span>::</span><span>convertible_to</span><span>&lt;size_t&gt;</span><span>;</span><span>
</span><span>};</span><span>
</span><span>template</span><span> </span><span>&lt;</span><span>Hashable</span><span> T</span><span>&gt;</span><span>  </span><span>// Only instantiable for `T`s that satisfy `Hashable`.</span><span>
</span><span>void</span><span> f</span><span>(</span><span>T</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Allows bundling sets of requirements together as named concepts, then enforcing them on template arguments.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/constraints">Constraints and concepts</a></p><p><strong>Notes:</strong></p><h3><a name="Default-comparisons-allowed" href="#Default-comparisons-allowed"><span></span></a><a name="default-comparisons-allowed" href="#default-comparisons-allowed"><span></span></a>Default comparisons [allowed]</h3><pre><span>class</span><span> S </span><span>:</span><span> </span><span>public</span><span> T </span><span>{</span><span>
  </span><span>// Non-member equality operator with access to private members.</span><span>
  </span><span>// Compares `T` bases, then `x`, then `y`, short-circuiting when</span><span>
  </span><span>// it finds inequality.</span><span>
  </span><span>friend</span><span> </span><span>bool</span><span> </span><span>operator</span><span>==(</span><span>const</span><span> S</span><span>&amp;,</span><span> </span><span>const</span><span> S</span><span>&amp;)</span><span> </span><span>=</span><span> </span><span>default</span><span>;</span><span>

  </span><span>// Non-member ordering operator with access to private members.</span><span>
  </span><span>// Compares `T` bases, then `x`, then `y`, short-circuiting when</span><span>
  </span><span>// it finds an ordering difference.</span><span>
  </span><span>friend</span><span> </span><span>auto</span><span> </span><span>operator</span><span>&lt;=&gt;(</span><span>const</span><span> S</span><span>&amp;,</span><span> </span><span>const</span><span> S</span><span>&amp;)</span><span> </span><span>=</span><span> </span><span>default</span><span>;</span><span>

  </span><span>int</span><span> x</span><span>;</span><span>
  </span><span>bool</span><span> y</span><span>;</span><span>
</span><span>};</span><span>
</span></pre><p><strong>Description:</strong> Requests that the compiler generate the implementation of any comparison operator, including <code>&lt;=&gt;</code>. Prefer non-member comparison operators. When defaulting <code>&lt;=&gt;</code>, also explicitly default <code>==</code>. Together these are sufficient to allow any comparison as long as callers do not need to take the address of any non-declared operator.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/default_comparisons">Default comparisons</a></p><p><strong>Notes:</strong></p><h3><a name="Designated-initializers-allowed" href="#Designated-initializers-allowed"><span></span></a><a name="designated-initializers-allowed" href="#designated-initializers-allowed"><span></span></a>Designated initializers [allowed]</h3><pre><span>struct</span><span> S </span><span>{</span><span> </span><span>int</span><span> x </span><span>=</span><span> </span><span>1</span><span>;</span><span> </span><span>int</span><span> y </span><span>=</span><span> </span><span>2</span><span>;</span><span> </span><span>}</span><span>
S s</span><span>{</span><span> </span><span>.</span><span>y </span><span>=</span><span> </span><span>3</span><span> </span><span>};</span><span>  </span><span>// OK, s.x == 1, s.y == 3</span><span>
</span></pre><p><strong>Description:</strong> Allows explicit initialization of subsets of aggregate members at construction.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization#Designated_initializers">Designated initializers</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="has_cpp_attribute-allowed" href="#has_cpp_attribute-allowed"><span></span></a>__has_cpp_attribute [allowed]</h3><pre><span>#if __has_cpp_attribute(assume)  // Toolchain supports C++23 `[[assume]]`.</span><span>
</span><span>...</span><span>
</span><span>#endif</span><span>
</span></pre><p><strong>Description:</strong> Checks whether the toolchain supports a particular standard attribute.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/feature_test">Feature testing</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="constinit-allowed" href="#constinit-allowed"><span></span></a>constinit [allowed]</h3><pre><span>constinit </span><span>int</span><span> x </span><span>=</span><span> </span><span>3</span><span>;</span><span>
</span><span>void</span><span> foo</span><span>()</span><span> </span><span>{</span><span>
  </span><span>++</span><span>x</span><span>;</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Ensures that a variable can be compile-time initialized. This is like a milder form of <code>constexpr</code> that does not force variables to be const or have constant destruction.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/constinit"><code>constinit</code> specifier</a></p><p><strong>Notes:</strong></p><h3><a name="Initializers-for-bit_field-members-allowed" href="#Initializers-for-bit_field-members-allowed"><span></span></a><a name="initializers-for-bit_field-members-allowed" href="#initializers-for-bit_field-members-allowed"><span></span></a>Initializers for bit-field members [allowed]</h3><pre><span>struct</span><span> S </span><span>{</span><span>
  </span><span>uint32_t</span><span> x </span><span>:</span><span> </span><span>27</span><span> </span><span>=</span><span> </span><span>2</span><span>;</span><span>
</span><span>};</span><span>
</span></pre><p><strong>Description:</strong> Allows specifying the default initial value of a bit-field member, as can already be done for other member types.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/bit_field">Bit-field</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="Lambda-captures-with-initializers-that-are-pack-expansions-allowed" href="#Lambda-captures-with-initializers-that-are-pack-expansions-allowed"><span></span></a><a name="lambda-captures-with-initializers-that-are-pack-expansions-allowed" href="#lambda-captures-with-initializers-that-are-pack-expansions-allowed"><span></span></a>Lambda captures with initializers that are pack expansions [allowed]</h3><pre><span>template</span><span> </span><span>&lt;</span><span>typename</span><span>...</span><span> </span><span>Args</span><span>&gt;</span><span>
</span><span>void</span><span> foo</span><span>(</span><span>Args</span><span>...</span><span> args</span><span>)</span><span> </span><span>{</span><span>
  </span><span>const</span><span> </span><span>auto</span><span> l </span><span>=</span><span> </span><span>[...</span><span>n </span><span>=</span><span> args</span><span>]</span><span> </span><span>{</span><span> </span><span>(</span><span>x</span><span>(</span><span>n</span><span>),</span><span> </span><span>...);</span><span> </span><span>};</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Allows initializing a capture with a pack expansion.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/lambda#Lambda_capture">Lambda capture</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="Language-feature_test-macros-allowed" href="#Language-feature_test-macros-allowed"><span></span></a><a name="language-feature_test-macros-allowed" href="#language-feature_test-macros-allowed"><span></span></a>Language feature-test macros [allowed]</h3><pre><span>#if !defined(__cpp_modules) || (__cpp_modules &lt; 201907L)</span><span>
</span><span>...</span><span>  </span><span>// Toolchain does not support modules</span><span>
</span><span>#endif</span><span>
</span></pre><p><strong>Description:</strong> Provides a standardized way to test the toolchain&#39;s implementation of a particular language feature.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/feature_test">Feature testing</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="likely_unlikely_allowed" href="#likely_unlikely_allowed"><span></span></a>[[likely]], [[unlikely]] [allowed]</h3><pre><span>if</span><span> </span><span>(</span><span>n </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>[[</span><span>likely</span><span>]]</span><span> </span><span>{</span><span>
  </span><span>return</span><span> </span><span>1</span><span>;</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Tells the optimizer that a particular codepath is more or less likely than an alternative.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/attributes/likely">C++ attribute: <code>likely</code>, <code>unlikely</code></a></p><p><strong>Notes:</strong></p><h3><a name="Range_for-statements-with-initializer-allowed" href="#Range_for-statements-with-initializer-allowed"><span></span></a><a name="range_for-statements-with-initializer-allowed" href="#range_for-statements-with-initializer-allowed"><span></span></a>Range-for statements with initializer [allowed]</h3><pre><span>T foo</span><span>();</span><span>
</span><span>...</span><span>
</span><span>for</span><span> </span><span>(</span><span>auto</span><span>&amp;</span><span> x </span><span>:</span><span> foo</span><span>().</span><span>items</span><span>())</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>                   </span><span>// UAF before C++23!</span><span>
</span><span>for</span><span> </span><span>(</span><span>T thing </span><span>=</span><span> foo</span><span>();</span><span> </span><span>auto</span><span>&amp;</span><span> x </span><span>:</span><span> thing</span><span>.</span><span>items</span><span>())</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>  </span><span>// OK</span><span>
</span></pre><p><strong>Description:</strong> Like C++17&#39;s selection statements with initializer. Particularly useful before C++23, since temporaries inside range-expressions are not lifetime-extended until the end of the loop before C++23.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/range-for">Range-based <code>for</code> loop</a></p><p><strong>Notes:</strong></p><h3><a name="Three_way-comparison-spaceship_operator-allowed" href="#Three_way-comparison-spaceship_operator-allowed"><span></span></a><a name="three_way-comparison-spaceship_operator-allowed" href="#three_way-comparison-spaceship_operator-allowed"><span></span></a>Three-way comparison (“spaceship”) operator [allowed]</h3><pre><span>// `ordering` is an instance of `std::strong_odering` or `std::partial_ordering`</span><span>
</span><span>// that describes how `a` and `b` are related.</span><span>
</span><span>const</span><span> </span><span>auto</span><span> ordering </span><span>=</span><span> a </span><span>&lt;=&gt;</span><span> b</span><span>;</span><span>
</span><span>if</span><span> </span><span>(</span><span>ordering </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>       </span><span>// `a` &lt; `b`</span><span>
</span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>ordering </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>  </span><span>// `a` &gt; `b`</span><span>
</span><span>else</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>                    </span><span>// `a` == `b`</span><span>
</span></pre><p><strong>Description:</strong> Compares two objects in a fashion similar to <code>strcmp</code>. Perhaps most useful when defined as an overload in a class, in which case it can replace definitions of other inequalities. See also “Default comparisons”.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison">Three-way comparison</a></p><p><strong>Notes:</strong></p><h3><a name="using-enum-declarations-allowed" href="#using-enum-declarations-allowed"><span></span></a>using enum declarations [allowed]</h3><pre><span>enum</span><span> </span><span>class</span><span> E </span><span>{</span><span> kA </span><span>=</span><span> </span><span>1</span><span> </span><span>};</span><span>
</span><span>void</span><span> f</span><span>()</span><span> </span><span>{</span><span>
  </span><span>using</span><span> </span><span>enum</span><span> E</span><span>;</span><span>
  </span><span>auto</span><span> a </span><span>=</span><span> kA</span><span>;</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Introduces enumerator element names into the current scope.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/enum#using_enum_declaration"><code>using enum</code> declaration</a></p><p><strong>Notes:</strong></p><h2><a name="library-allowlist-20" href="#library-allowlist-20"><span></span></a>C++20 Allowed Library Features</h2><p>The following C++20 library features are allowed in the Chromium codebase.</p><h3><a name="bit_allowed" href="#bit_allowed"><span></span></a>&lt;bit&gt; [allowed]</h3><pre><span>#include</span><span> </span><span>&lt;bit&gt;</span><span>
</span></pre><p><strong>Description:</strong> Provides various byte- and bit-twiddling functions, e.g. counting leading zeros.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/bit">Standard library header <code>&lt;bit&gt;</code></a></p><p><strong>Notes:</strong></p><h3><a name="compare_allowed" href="#compare_allowed"><span></span></a>&lt;compare&gt; [allowed]</h3><pre><span>#include</span><span> </span><span>&lt;compare&gt;</span><span>
</span></pre><p><strong>Description:</strong> Concepts and classes used to implement three-way comparison (“spaceship”, <code>&lt;=&gt;</code>) support.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/compare">Standard library header <code>&lt;compare&gt;</code></a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="concepts_allowed" href="#concepts_allowed"><span></span></a>&lt;concepts&gt; [allowed]</h3><pre><span>#include</span><span> </span><span>&lt;concepts&gt;</span><span>
</span></pre><p><strong>Description:</strong> Various useful concepts, many of which replace pre-concept machinery in <code>&lt;type_traits&gt;</code>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/concepts">Standard library header <code>&lt;concepts&gt;</code></a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="Range-algorithms-allowed" href="#Range-algorithms-allowed"><span></span></a><a name="range-algorithms-allowed" href="#range-algorithms-allowed"><span></span></a>Range algorithms [allowed]</h3><pre><span>constexpr</span><span> </span><span>int</span><span> kArr</span><span>[]</span><span> </span><span>=</span><span> </span><span>{</span><span>2</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>6</span><span>,</span><span> </span><span>8</span><span>,</span><span> </span><span>10</span><span>,</span><span> </span><span>12</span><span>};</span><span>
</span><span>constexpr</span><span> </span><span>auto</span><span> is_even </span><span>=</span><span> </span><span>[]</span><span> </span><span>(</span><span>auto</span><span> x</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> x </span><span>%</span><span> </span><span>2</span><span> </span><span>==</span><span> </span><span>0</span><span>;</span><span> </span><span>};</span><span>
</span><span>static_assert</span><span>(</span><span>std</span><span>::</span><span>ranges</span><span>::</span><span>all_of</span><span>(</span><span>kArr</span><span>,</span><span> is_even</span><span>));</span><span>
</span></pre><p><strong>Description:</strong> Provides versions of most algorithms that accept either an iterator-sentinel pair or a single range argument.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/algorithm/ranges">Ranges algorithms</a></p><p><strong>Notes:</strong></p><h3><a name="Range-access_range-primitives_dangling-iterator-handling_and-range-concepts-allowed" href="#Range-access_range-primitives_dangling-iterator-handling_and-range-concepts-allowed"><span></span></a><a name="range-access_range-primitives_dangling-iterator-handling_and-range-concepts-allowed" href="#range-access_range-primitives_dangling-iterator-handling_and-range-concepts-allowed"><span></span></a>Range access, range primitives, dangling iterator handling, and range concepts [allowed]</h3><pre><span>// Range access:</span><span>
</span><span>constexpr</span><span> </span><span>int</span><span> kArr</span><span>[]</span><span> </span><span>=</span><span> </span><span>{</span><span>2</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>6</span><span>,</span><span> </span><span>8</span><span>,</span><span> </span><span>10</span><span>,</span><span> </span><span>12</span><span>};</span><span>
</span><span>static_assert</span><span>(</span><span>std</span><span>::</span><span>ranges</span><span>::</span><span>size</span><span>(</span><span>kArr</span><span>)</span><span> </span><span>==</span><span> </span><span>6</span><span>);</span><span>

</span><span>// Range primitives:</span><span>
</span><span>static_assert</span><span>(</span><span>
    std</span><span>::</span><span>same_as</span><span>&lt;</span><span>std</span><span>::</span><span>ranges</span><span>::</span><span>iterator_t</span><span>&lt;</span><span>decltype</span><span>(</span><span>kArr</span><span>)&gt;,</span><span> </span><span>const</span><span> </span><span>int</span><span>*&gt;);</span><span>

</span><span>// Range concepts:</span><span>
</span><span>static_assert</span><span>(</span><span>std</span><span>::</span><span>ranges</span><span>::</span><span>contiguous_range</span><span>&lt;</span><span>decltype</span><span>(</span><span>kArr</span><span>)&gt;);</span><span>
</span></pre><p><strong>Description:</strong> Various helper functions and types for working with ranges.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/ranges">Ranges library</a></p><p><strong>Notes:</strong></p><h3><a name="Library-feature_test-macros-and-version_allowed" href="#Library-feature_test-macros-and-version_allowed"><span></span></a><a name="library-feature_test-macros-and-version_allowed" href="#library-feature_test-macros-and-version_allowed"><span></span></a>Library feature-test macros and &lt;version&gt; [allowed]</h3><pre><span>#if !defined(__cpp_lib_atomic_value_initialization) || \</span><span>
    </span><span>(</span><span>__cpp_lib_atomic_value_initialization </span><span>&lt;</span><span> </span><span>201911L</span><span>)</span><span>
</span><span>...</span><span>  </span><span>// `std::atomic` is not value-initialized by default.</span><span>
</span><span>#endif</span><span>
</span></pre><p><strong>Description:</strong> Provides a standardized way to test the toolchain&#39;s implementation of a particular library feature.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/feature_test">Feature testing</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="numbers_allowed" href="#numbers_allowed"><span></span></a>&lt;numbers&gt; [allowed]</h3><pre><span>#include</span><span> </span><span>&lt;numbers&gt;</span><span>
</span></pre><p><strong>Description:</strong> Provides compile-time constants for many common mathematical values, e.g. pi and e.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/numeric/constants">Mathematical constants</a></p><p><strong>Notes:</strong></p><h3><a name="std_assume_aligned-allowed" href="#std_assume_aligned-allowed"><span></span></a>std::assume_aligned [allowed]</h3><pre><span>void</span><span> f</span><span>(</span><span>int</span><span>*</span><span> p</span><span>)</span><span> </span><span>{</span><span>
  </span><span>int</span><span>*</span><span> aligned </span><span>=</span><span> std</span><span>::</span><span>assume_aligned</span><span>&lt;</span><span>256</span><span>&gt;(</span><span>p</span><span>);</span><span>
  </span><span>...</span><span>
</span></pre><p><strong>Description:</strong> Informs the compiler that a pointer points to an address aligned to at least some particular power of 2.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/assume_aligned"><code>std::assume_aligned</code></a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="std_erase_if_for-containers-allowed" href="#std_erase_if_for-containers-allowed"><span></span></a>std::erase[_if] for containers [allowed]</h3><pre><span>std</span><span>::</span><span>vector</span><span>&lt;int&gt;</span><span> numbers </span><span>=</span><span> </span><span>...;</span><span>
std</span><span>::</span><span>erase_if</span><span>(</span><span>numbers</span><span>,</span><span> </span><span>[](</span><span>int</span><span> x</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> x </span><span>%</span><span> </span><span>2</span><span> </span><span>==</span><span> </span><span>0</span><span>;</span><span> </span><span>});</span><span>
</span></pre><p><strong>Description:</strong> Erases from a container by value comparison or predicate, avoiding the need to use the <code>erase(remove(...</code> paradigm.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/container/vector/erase2"><code>std::erase</code>, <code>std::erase_if</code> (<code>std::vector</code>)</a></p><p><strong>Notes:</strong></p><h3><a name="std_hardware_con_de_structive_interference_size-allowed" href="#std_hardware_con_de_structive_interference_size-allowed"><span></span></a>std::hardware_{con,de}structive_interference_size [allowed]</h3><pre><span>struct</span><span> </span><span>SharedData</span><span> </span><span>{</span><span>
  </span><span>ReadOnlyFrequentlyUsed</span><span> data</span><span>;</span><span>
  alignas</span><span>(</span><span>std</span><span>::</span><span>hardware_destructive_interference_size</span><span>)</span><span> std</span><span>::</span><span>atomic</span><span>&lt;size_t&gt;</span><span> counter</span><span>;</span><span>
</span><span>};</span><span>
</span></pre><p><strong>Description:</strong> The <code>std::hardware_destructive_interference_size</code> constant is useful to avoid false sharing (destructive interference) between variables that would otherwise occupy the same cacheline. In contrast, <code>std::hardware_constructive_interference_size</code> is helpful to promote true sharing (constructive interference), e.g. to support better locality for non-contended data.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size"><code>std::hardware_destructive_interference_size</code></a>, <a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size"><code>std::hardware_constructive_interference_size</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_is_un_bounded_array-allowed" href="#std_is_un_bounded_array-allowed"><span></span></a>std::is_[un]bounded_array [allowed]</h3><pre><span>template</span><span> </span><span>&lt;</span><span>typename</span><span> T</span><span>&gt;</span><span>
</span><span>static</span><span> </span><span>constexpr</span><span> </span><span>bool</span><span> kBoundedArray </span><span>=</span><span> std</span><span>::</span><span>is_bounded_array_v</span><span>&lt;</span><span>T</span><span>&gt;;</span><span>
</span></pre><p><strong>Description:</strong> Checks if a type is an array type with a known or unknown bound.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/types/is_bounded_array"><code>std::is_bounded_array</code></a>, <a href="https://en.cppreference.com/w/cpp/types/is_unbounded_array"><code>std::is_unbounded_array</code></a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="std_lerp-allowed" href="#std_lerp-allowed"><span></span></a>std::lerp [allowed]</h3><pre><span>double</span><span> val </span><span>=</span><span> std</span><span>::</span><span>lerp</span><span>(</span><span>start</span><span>,</span><span> </span><span>end</span><span>,</span><span> t</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Linearly interpolates (or extrapolates) between two values.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/numeric/lerp"><code>std::lerp</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_make_obj_using_allocator-etc_allowed" href="#std_make_obj_using_allocator-etc_allowed"><span></span></a>std::make_obj_using_allocator etc. [allowed]</h3><pre><span>auto</span><span> obj </span><span>=</span><span> std</span><span>::</span><span>make_obj_using_allocator</span><span>&lt;</span><span>Obj</span><span>&gt;(</span><span>alloc</span><span>,</span><span> </span><span>...);</span><span>
</span></pre><p><strong>Description:</strong> Constructs an object using <a href="https://en.cppreference.com/w/cpp/memory/uses_allocator">uses-allocator construction</a>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/make_obj_using_allocator"><code>std::make_obj_using_allocator</code></a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="std_make_unique_for_overwrite-allowed" href="#std_make_unique_for_overwrite-allowed"><span></span></a>std::make_unique_for_overwrite [allowed]</h3><pre><span>auto</span><span> ptr </span><span>=</span><span> std</span><span>::</span><span>make_unique_for_overwrite</span><span>&lt;int&gt;</span><span>();</span><span>  </span><span>// `*ptr` is uninitialized</span><span>
</span></pre><p><strong>Description:</strong> Like calling <code>std::unique_ptr&lt;T&gt;(new T)</code> instead of the more typical <code>std::unique_ptr&lt;T&gt;(new T(...))</code>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique"><code>std::make_unique</code>, <code>std::make_unique_for_overwrite</code></a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="std_midpoint-allowed" href="#std_midpoint-allowed"><span></span></a>std::midpoint [allowed]</h3><pre><span>int</span><span> center </span><span>=</span><span> std</span><span>::</span><span>midpoint</span><span>(</span><span>top</span><span>,</span><span> bottom</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Finds the midpoint between its two arguments, avoiding any possible overflow. For integral inputs, rounds towards the first argument.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/numeric/midpoint"><code>std::midpoint</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_ranges_subrange-allowed" href="#std_ranges_subrange-allowed"><span></span></a>std::ranges::subrange [allowed]</h3><pre><span>void</span><span> transform</span><span>(</span><span>const</span><span> std</span><span>::</span><span>multimap</span><span>&lt;</span><span>int</span><span>,</span><span> </span><span>char</span><span>&gt;&amp;</span><span> map</span><span>,</span><span> </span><span>int</span><span> key</span><span>)</span><span> </span><span>{</span><span>
  </span><span>auto</span><span> </span><span>[</span><span>first</span><span>,</span><span> </span><span>last</span><span>]</span><span> </span><span>=</span><span> map</span><span>.</span><span>equal_range</span><span>(</span><span>key</span><span>);</span><span>
  </span><span>for</span><span> </span><span>(</span><span>const</span><span> </span><span>auto</span><span>&amp;</span><span> </span><span>[</span><span>_</span><span>,</span><span> value</span><span>]</span><span> </span><span>:</span><span> std</span><span>::</span><span>ranges</span><span>::</span><span>subrange</span><span>(</span><span>first</span><span>,</span><span> </span><span>last</span><span>))</span><span> </span><span>{</span><span>
    </span><span>...</span><span>
</span></pre><p><strong>Description:</strong> Creates a view from an iterator and a sentinel. Useful for treating non-contiguous storage (e.g. a <code>std::map</code>) as a range.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/ranges/subrange"><code>std::ranges::subrange</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_remove_cvref_t_allowed" href="#std_remove_cvref_t_allowed"><span></span></a>std::remove_cvref[_t] [allowed]</h3><pre><span>template</span><span> </span><span>&lt;</span><span>typename</span><span> T</span><span>&gt;</span><span>
  requires </span><span>(</span><span>std</span><span>::</span><span>is_same_v</span><span>&lt;</span><span>std</span><span>::</span><span>remove_cvref_t</span><span>&lt;</span><span>T</span><span>&gt;,</span><span> </span><span>int</span><span>&gt;)</span><span>
</span><span>void</span><span> foo</span><span>(</span><span>T t</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Provides a way to remove const, volatile, and reference qualifiers from a type.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/types/remove_cvref"><code>std::remove_cvref</code></a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="std_ssize-allowed" href="#std_ssize-allowed"><span></span></a>std::ssize [allowed]</h3><pre><span>str</span><span>.</span><span>replace</span><span>(</span><span>it</span><span>,</span><span> it </span><span>+</span><span> std</span><span>::</span><span>ssize</span><span>(</span><span>substr</span><span>),</span><span> </span><span>1</span><span>,</span><span> </span><span>&#39;x&#39;</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Returns the size of an object as a signed type.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/iterator/size"><code>std::size</code>, <code>std::ssize</code></a></p><p><strong>Notes:</strong></p><h3><a name="std_string_starts_ends_with-allowed" href="#std_string_starts_ends_with-allowed"><span></span></a>std::string::(starts,ends)_with [allowed]</h3><pre><span>const</span><span> std</span><span>::</span><span>string</span><span> str </span><span>=</span><span> </span><span>&#34;Foo bar&#34;</span><span>;</span><span>
</span><span>const</span><span> </span><span>bool</span><span> is_true </span><span>=</span><span> str</span><span>.</span><span>ends_with</span><span>(</span><span>&#34;bar&#34;</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Tests whether a string starts or ends with a particular character or string.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/string/basic_string/starts_with"><code>std::basic_string&lt;CharT,Traits,Allocator&gt;::starts_with</code></a>, <a href="https://en.cppreference.com/w/cpp/string/basic_string/ends_with"><code>std::basic_string&lt;CharT,Traits,Allocator&gt;::ends_with</code></a></p><p><strong>Notes:</strong></p><h2><a name="core-blocklist-20" href="#core-blocklist-20"><span></span></a>C++20 Banned Language Features</h2><p>The following C++20 language features are not allowed in the Chromium codebase.</p><h3><a name="char8_t-banned" href="#char8_t-banned"><span></span></a>char8_t [banned]</h3><pre><span>char8_t</span><span> c </span><span>=</span><span> u8</span><span>&#39;x&#39;</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> A single UTF-8 code unit. Similar to <code>unsigned char</code>, but considered a distinct type.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/types#char8_t">Fundamental types</a></p><p><strong>Notes:</strong></p><p>Use <code>char</code> and unprefixed character literals. Non-UTF-8 encodings are rare enough in Chromium that the value of distinguishing them at the type level is low, and <code>char8_t*</code> is not interconvertible with <code>char*</code> (what ~all Chromium, STL, and platform-specific APIs use), so using <code>u8</code> prefixes would obligate us to insert casts everywhere. If you want to declare at a type level that a block of data is string-like and not an arbitrary binary blob, prefer <code>std::string[_view]</code> over <code>char*</code>.</p><h3><a name="Modules-banned" href="#Modules-banned"><span></span></a><a name="modules-banned" href="#modules-banned"><span></span></a>Modules [banned]</h3><pre><span>export</span><span> </span><span>module</span><span> helloworld</span><span>;</span><span> </span><span>// module declaration</span><span>

</span><span>import</span><span> </span><span>&lt;iostream&gt;</span><span>;</span><span>        </span><span>// import declaration</span><span>

</span><span>export</span><span> </span><span>void</span><span> hello</span><span>()</span><span> </span><span>{</span><span>     </span><span>// export declaration</span><span>
  std</span><span>::</span><span>cout </span><span>&lt;&lt;</span><span> </span><span>&#34;Hello world!\n&#34;</span><span>;</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Modules provide an alternative to many uses of headers which allows for faster compilation, better tooling support, and reduction of problems like “include what you use”.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/modules">Modules</a></p><p><strong>Notes:</strong></p><p>Not yet sufficiently supported in Clang and GN. Re-evaluate when support improves.</p><h3><a name="no_unique_address_banned" href="#no_unique_address_banned"><span></span></a>[[no_unique_address]] [banned]</h3><pre><span>struct</span><span> </span><span>Empty</span><span> </span><span>{};</span><span>
</span><span>struct</span><span> X </span><span>{</span><span>
  </span><span>int</span><span> i</span><span>;</span><span>
  </span><span>[[</span><span>no_unique_address</span><span>]]</span><span> </span><span>Empty</span><span> e</span><span>;</span><span>
</span><span>};</span><span>
</span></pre><p><strong>Description:</strong> Allows a data member to be overlapped with other members.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/attributes/no_unique_address">C++ attribute: <code>no_unique_address</code></a></p><p><strong>Notes:</strong></p><p>Has no effect on Windows, for compatibility with Microsoft&#39;s ABI. Use <code>NO_UNIQUE_ADDRESS</code> from <code>base/compiler_specific.h</code> instead. Do not use (either form) on members of unions due to <a href="https://github.com/llvm/llvm-project/issues/60711">potential memory safety problems</a>.</p><h2><a name="library-blocklist-20" href="#library-blocklist-20"><span></span></a>C++20 Banned Library Features</h2><p>The following C++20 library features are not allowed in the Chromium codebase.</p><h3><a name="std_bind_front-banned" href="#std_bind_front-banned"><span></span></a>std::bind_front [banned]</h3><pre><span>int</span><span> minus</span><span>(</span><span>int</span><span> a</span><span>,</span><span> </span><span>int</span><span> b</span><span>);</span><span>
</span><span>auto</span><span> fifty_minus_x </span><span>=</span><span> std</span><span>::</span><span>bind_front</span><span>(</span><span>minus</span><span>,</span><span> </span><span>50</span><span>);</span><span>
</span><span>int</span><span> forty </span><span>=</span><span> fifty_minus_x</span><span>(</span><span>10</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> An updated version of <code>std::bind</code> with fewer gotchas, similar to <code>absl::bind_front</code>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/functional/bind_front"><code>std::bind_front</code>, <code>std::bind_back</code></a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base::Bind</code>.</p><h3><a name="std_bit_cast-banned" href="#std_bit_cast-banned"><span></span></a>std::bit_cast [banned]</h3><pre><span>float</span><span> quake_rsqrt</span><span>(</span><span>float</span><span> number</span><span>)</span><span> </span><span>{</span><span>
  </span><span>long</span><span> i </span><span>=</span><span> std</span><span>::</span><span>bit_cast</span><span>&lt;long&gt;</span><span>(</span><span>number</span><span>);</span><span>
  i </span><span>=</span><span> </span><span>0x5f3759df</span><span> </span><span>-</span><span> </span><span>(</span><span>i </span><span>&gt;&gt;</span><span> </span><span>1</span><span>);</span><span>  </span><span>// wtf?</span><span>
  </span><span>float</span><span> y </span><span>=</span><span> std</span><span>::</span><span>bit_cast</span><span>&lt;float&gt;</span><span>(</span><span>i</span><span>);</span><span>
  </span><span>return</span><span> y </span><span>*</span><span> </span><span>(</span><span>1.5f</span><span> </span><span>-</span><span> </span><span>(</span><span>0.5f</span><span> </span><span>*</span><span> number </span><span>*</span><span> y </span><span>*</span><span> y</span><span>));</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Returns an value constructed with the same bits as an value of a different type.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/numeric/bit_cast"><code>std::bit_cast</code></a></p><p><strong>Notes:</strong></p><p>The <code>std::</code> version of <code>bit_cast</code> allows casting of pointer and reference types, which is both useless in that it doesn&#39;t avoid UB, and dangerous in that it allows arbitrary casting away of modifiers like <code>const</code>. Instead of using <code>bit_cast</code> on pointers, use standard C++ casts. For use on values, use <code>base::bit_cast</code> which does not allow this unwanted usage.</p><h3><a name="std_c8rtomb_mbrtoc8_banned" href="#std_c8rtomb_mbrtoc8_banned"><span></span></a>std::{c8rtomb,mbrtoc8} [banned]</h3><pre><span>std</span><span>::</span><span>u8string_view strv </span><span>=</span><span> u8</span><span>&#34;zß水🍌&#34;</span><span>;</span><span>
std</span><span>::</span><span>mbstate_t</span><span> state</span><span>;</span><span>
</span><span>char</span><span> </span><span>out</span><span>[</span><span>MB_LEN_MAX</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span>0</span><span>};</span><span>
</span><span>for</span><span> </span><span>(</span><span>char8_t</span><span> c </span><span>:</span><span> strv</span><span>)</span><span> </span><span>{</span><span>
  </span><span>size_t</span><span> rc </span><span>=</span><span> std</span><span>::</span><span>c8rtomb</span><span>(</span><span>out</span><span>,</span><span> c</span><span>,</span><span> </span><span>&amp;</span><span>state</span><span>);</span><span>
  </span><span>...</span><span>
</span></pre><p><strong>Description:</strong> Converts a code point between UTF-8 and a multibyte character encoded using the current C locale.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/string/multibyte/c8rtomb"><code>std::c8rtomb</code></a>, <a href="https://en.cppreference.com/w/cpp/string/multibyte/mbrtoc8"><code>std::mbrtoc8</code></a></p><p><strong>Notes:</strong></p><p>Chromium functionality should not vary with the C locale.</p><h3><a name="Range-factories-and-range-adaptors-banned" href="#Range-factories-and-range-adaptors-banned"><span></span></a><a name="range-factories-and-range-adaptors-banned" href="#range-factories-and-range-adaptors-banned"><span></span></a>Range factories and range adaptors [banned]</h3><pre><span>// Prints 1, 2, 3, 4, 5, 6.</span><span>
</span><span>for</span><span> </span><span>(</span><span>auto</span><span> i </span><span>:</span><span> std</span><span>::</span><span>ranges</span><span>::</span><span>iota_view</span><span>(</span><span>1</span><span>,</span><span> </span><span>7</span><span>))</span><span> </span><span>{</span><span>
  std</span><span>::</span><span>cout </span><span>&lt;&lt;</span><span> i </span><span>&lt;&lt;</span><span> </span><span>&#39;\n&#39;</span><span>;</span><span>
</span><span>}</span><span>

</span><span>constexpr</span><span> </span><span>int</span><span> kArr</span><span>[]</span><span> </span><span>=</span><span> </span><span>{</span><span>6</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>8</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>2</span><span>};</span><span>
</span><span>constexpr</span><span> </span><span>auto</span><span> plus_one </span><span>=</span><span> std</span><span>::</span><span>views</span><span>::</span><span>transform</span><span>([](</span><span>int</span><span> n</span><span>){</span><span> </span><span>return</span><span> n </span><span>+</span><span> </span><span>1</span><span>;</span><span> </span><span>});</span><span>
</span><span>static_assert</span><span>(</span><span>std</span><span>::</span><span>ranges</span><span>::</span><span>equal</span><span>(</span><span>kArr </span><span>|</span><span> plus_one</span><span>,</span><span> </span><span>{</span><span>7</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>9</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>3</span><span>}));</span><span>
</span></pre><p><strong>Description:</strong> Lightweight objects that represent iterable sequences. Provides facilities for lazy operations on ranges, along with composition into pipelines.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/ranges">Ranges library</a></p><p><strong>Notes:</strong></p><h3><a name="std_ranges_view_interface-banned" href="#std_ranges_view_interface-banned"><span></span></a>std::ranges::view_interface [banned]</h3><pre><span>class</span><span> </span><span>MyView</span><span> </span><span>:</span><span> </span><span>public</span><span> std</span><span>::</span><span>ranges</span><span>::</span><span>view_interface</span><span>&lt;</span><span>MyView</span><span>&gt;</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>};</span><span>
</span></pre><p><strong>Description:</strong> CRTP base class for implementing custom view objects.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/ranges/view_interface"><code>std::ranges::view_interface</code></a></p><p><strong>Notes:</strong></p><h3><a name="span_banned" href="#span_banned"><span></span></a>&lt;span&gt; [banned]</h3><pre><span>#include</span><span> </span><span>&lt;span&gt;</span><span>
</span></pre><p><strong>Description:</strong> Utilities for non-owning views over a sequence of objects.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/span"></a></p><p><strong>Notes:</strong></p><p>Superseded by <code>base::span</code>, which has a richer functionality set.</p><h3><a name="std_to_address-banned" href="#std_to_address-banned"><span></span></a>std::to_address [banned]</h3><pre><span>std</span><span>::</span><span>vector</span><span>&lt;int&gt;</span><span> numbers</span><span>;</span><span>
</span><span>int</span><span>*</span><span> i </span><span>=</span><span> std</span><span>::</span><span>to_address</span><span>(</span><span>numbers</span><span>.</span><span>begin</span><span>());</span><span>
</span></pre><p><strong>Description:</strong> Converts a pointer-like object to a pointer, even if the pointer does not refer to a constructed object (in which case an expression like <code>&amp;*p</code> is UB).</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/to_address"><code>std::to_address</code></a></p><p><strong>Notes:</strong></p><p>Banned because it is not guaranteed to be SFINAE-compatible. Use base::to_address, which does guarantee this.</p><h3><a name="syncstream_banned" href="#syncstream_banned"><span></span></a>&lt;syncstream&gt; [banned]</h3><pre><span>#include</span><span> </span><span>&lt;syncstream&gt;</span><span>
</span></pre><p><strong>Description:</strong> Facilities for multithreaded access to streams.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/syncstream">Standard library header <code>&lt;syncstream&gt;</code></a></p><p><strong>Notes:</strong></p><h2><a name="core-review-20" href="#core-review-20"><span></span></a>C++20 TBD Language Features</h2><p>The following C++20 language features are not allowed in the Chromium codebase. See the top of this page on how to propose moving a feature from this list into the allowed or banned sections.</p><h3><a name="Aggregate-initialization-using-parentheses-tbd" href="#Aggregate-initialization-using-parentheses-tbd"><span></span></a><a name="aggregate-initialization-using-parentheses-tbd" href="#aggregate-initialization-using-parentheses-tbd"><span></span></a>Aggregate initialization using parentheses [tbd]</h3><pre><span>struct</span><span> B </span><span>{</span><span>
  </span><span>int</span><span> a</span><span>;</span><span>
  </span><span>int</span><span>&amp;&amp;</span><span> r</span><span>;</span><span>
</span><span>}</span><span> b2</span><span>(</span><span>1</span><span>,</span><span> </span><span>1</span><span>);</span><span>  </span><span>// Warning: dangling reference</span><span>
</span></pre><p><strong>Description:</strong> Allows initialization of aggregates using parentheses, not just braces.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregate initialization</a>, <a href="https://en.cppreference.com/w/cpp/language/direct_initialization">Direct initialization</a></p><p><strong>Notes:</strong></p><p>There are subtle but important differences between brace- and paren-init of aggregates. The parenthesis style appears to have more pitfalls (allowing narrowing conversions, not extending lifetimes of temporaries bound to references).</p><h3><a name="Coroutines-tbd" href="#Coroutines-tbd"><span></span></a><a name="coroutines-tbd" href="#coroutines-tbd"><span></span></a>Coroutines [tbd]</h3><pre><span>co_return </span><span>1</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Allows writing functions that logically block while physically returning control to a caller. This enables writing some kinds of async code in simple, straight-line ways without storing state in members or binding callbacks.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/coroutines">Coroutines</a></p><p><strong>Notes:</strong></p><p>Requires significant support code and planning around API and migration.</p><h2><a name="library-review-20" href="#library-review-20"><span></span></a>C++20 TBD Library Features</h2><p>The following C++20 library features are not allowed in the Chromium codebase. See the top of this page on how to propose moving a feature from this list into the allowed or banned sections.</p><h3><a name="coroutine_tbd" href="#coroutine_tbd"><span></span></a>&lt;coroutine&gt; [tbd]</h3><pre><span>#include</span><span> </span><span>&lt;coroutine&gt;</span><span>
</span></pre><p><strong>Description:</strong> Header which defines various core coroutine types.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/coroutine">Coroutine support</a></p><p><strong>Notes:</strong></p><p>See notes on “Coroutines” above.</p><h3><a name="format_tbd" href="#format_tbd"><span></span></a>&lt;format&gt; [tbd]</h3><pre><span>std</span><span>::</span><span>cout </span><span>&lt;&lt;</span><span> std</span><span>::</span><span>format</span><span>(</span><span>&#34;Hello {}!\n&#34;</span><span>,</span><span> </span><span>&#34;world&#34;</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Utilities for producing formatted strings.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/format">Formatting library</a></p><p><strong>Notes:</strong></p><p>Has both pros and cons compared to <code>absl::StrFormat</code> (which we don&#39;t yet use). Migration would be nontrivial.</p><h3><a name="source_location_tbd" href="#source_location_tbd"><span></span></a>&lt;source_location&gt; [tbd]</h3><pre><span>#include</span><span> </span><span>&lt;source_location&gt;</span><span>
</span></pre><p><strong>Description:</strong> Provides a class that can hold source code details such as filenames, function names, and line numbers.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/source_location">Standard library header <code>&lt;source_location&gt;</code></a></p><p><strong>Notes:</strong></p><p>Seems to regress code size vs. <code>base::Location</code>.</p><h3><a name="std_u8string-tbd" href="#std_u8string-tbd"><span></span></a>std::u8string [tbd]</h3><pre><span>std</span><span>::</span><span>u8string str </span><span>=</span><span> u8</span><span>&#34;Foo&#34;</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> A string whose character type is <code>char8_t</code>, intended to hold UTF-8-encoded text.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::basic_string</code></a></p><p><strong>Notes:</strong></p><p>See notes on <code>char8_t</code> above.</p><h2><a name="core-allowlist-23" href="#core-allowlist-23"><span></span></a>C++23 Allowed Language Features</h2><p>The following C++23 language features are allowed in the Chromium codebase.</p><h3><a name="elifdef_elifndef-allowed" href="#elifdef_elifndef-allowed"><span></span></a>#elifdef, #elifndef [allowed]</h3><pre><span>#ifdef</span><span> FOO
</span><span>...</span><span>
</span><span>#elifdef BAR  // New.</span><span>
</span><span>...</span><span>
</span><span>#elifndef BAZ  // New.</span><span>
</span><span>...</span><span>
</span><span>#endif</span><span>
</span></pre><p><strong>Description:</strong> New conditional inclusion preprocessor directives.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/preprocessor/conditional.html">Conditional inclusion</a></p><p><strong>Notes:</strong></p><h2><a name="library-allowlist-23" href="#library-allowlist-23"><span></span></a>C++23 Allowed Library Features</h2><p>The following C++23 library features are allowed in the Chromium codebase.</p><h3><a name="std_basic_string_contains-allowed" href="#std_basic_string_contains-allowed"><span></span></a>std::basic_string::contains [allowed]</h3><pre><span>if</span><span> </span><span>(</span><span>str</span><span>.</span><span>contains</span><span>(</span><span>&#34;foo&#34;</span><span>))</span><span> </span><span>...</span><span>
</span></pre><p><strong>Description:</strong> More concise substring check.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/string/basic_string/contains">std::basic_string::contains</a></p><p><strong>Notes:</strong></p><h3><a name="std_byteswap-allowed" href="#std_byteswap-allowed"><span></span></a>std::byteswap [allowed]</h3><pre><span>auto</span><span> x </span><span>=</span><span> std</span><span>::</span><span>byteswap</span><span>(</span><span>y</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Reverses the bytes of an integer.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/numeric/byteswap">std::byteswap</a></p><p><strong>Notes:</strong></p><h3><a name="std_to_underlying-allowed" href="#std_to_underlying-allowed"><span></span></a>std::to_underlying [allowed]</h3><pre><span>auto</span><span> x </span><span>=</span><span> std</span><span>::</span><span>to_underlying</span><span>(</span><span>enum_val</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Converts an enumeration to its underlying type.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/to_underlying">std::to_underlying</a></p><p><strong>Notes:</strong></p><h2><a name="core-review-23" href="#core-review-23"><span></span></a>C++23 TBD Language Features</h2><p>The following C++23 language features are not allowed in the Chromium codebase. See the top of this page on how to propose moving a feature from this list into the allowed or banned sections.</p><h3><a name="Explicit-object-parameter-tbd" href="#Explicit-object-parameter-tbd"><span></span></a><a name="explicit-object-parameter-tbd" href="#explicit-object-parameter-tbd"><span></span></a>Explicit object parameter [tbd]</h3><pre><span>struct</span><span> S </span><span>{</span><span>
  </span><span>void</span><span> f</span><span>(</span><span>this</span><span> S</span><span>&amp;</span><span> </span><span>self</span><span>);</span><span>
</span><span>};</span><span>
</span></pre><p><strong>Description:</strong> Allows explicit specification of the object parameter (deducing <code>this</code>) in member functions.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/member_functions#Explicit_object_parameter">Explicit object parameter</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="Multidimensional-subscript-operator-tbd" href="#Multidimensional-subscript-operator-tbd"><span></span></a><a name="multidimensional-subscript-operator-tbd" href="#multidimensional-subscript-operator-tbd"><span></span></a>Multidimensional subscript operator [tbd]</h3><pre><span>struct</span><span> S </span><span>{</span><span>
  </span><span>int</span><span> </span><span>operator</span><span>[](</span><span>int</span><span> i</span><span>,</span><span> </span><span>int</span><span> j</span><span>);</span><span>
</span><span>};</span><span>
</span></pre><p><strong>Description:</strong> Allows multiple arguments in the subscript operator.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/operators#Array_subscript_operator">Operator overloading</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="auto_x_auto_x_tbd" href="#auto_x_auto_x_tbd"><span></span></a>auto(x), auto{x} [tbd]</h3><pre><span>void</span><span> f</span><span>(</span><span>const</span><span> </span><span>int</span><span>&amp;</span><span> i</span><span>)</span><span> </span><span>{</span><span>
  </span><span>auto</span><span> copy </span><span>=</span><span> </span><span>auto</span><span>(</span><span>i</span><span>);</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Prvalue copy (decay-copy).</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/explicit_cast">Functional cast</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="assume_tbd" href="#assume_tbd"><span></span></a>[[assume]] [tbd]</h3><pre><span>[[</span><span>assume</span><span>(</span><span>n </span><span>&gt;</span><span> </span><span>0</span><span>)]];</span><span>
</span></pre><p><strong>Description:</strong> Provides a hint to the optimizer.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/attributes/assume">dcl.attr.assume</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="warning-tbd" href="#warning-tbd"><span></span></a>#warning [tbd]</h3><pre><span>#warning</span><span> </span><span>&#34;This is a warning&#34;</span><span>
</span></pre><p><strong>Description:</strong> Standardized preprocessor warning directive.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/preprocessor/warning">#warning</a></p><p><strong>Notes:</strong></p><p>This was standardized in C++23, but was already supported by clang. From thakis@: #warning doesn&#39;t honor -Werror, and we want things to either be errors, or silent.</p><h3><a name="Literal-suffix-for-size_t-tbd" href="#Literal-suffix-for-size_t-tbd"><span></span></a><a name="literal-suffix-for-size_t-tbd" href="#literal-suffix-for-size_t-tbd"><span></span></a>Literal suffix for size_t [tbd]</h3><pre><span>auto</span><span> s </span><span>=</span><span> </span><span>10uz</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Literal suffix <code>z</code> or <code>uz</code> for <code>std::size_t</code>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/integer_literal">Integer literal</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="Named-character-escapes-tbd" href="#Named-character-escapes-tbd"><span></span></a><a name="named-character-escapes-tbd" href="#named-character-escapes-tbd"><span></span></a>Named character escapes [tbd]</h3><pre><span>auto</span><span> c </span><span>=</span><span> </span><span>&#34;\N{LATIN CAPITAL LETTER A}&#34;</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Universal character names using <code>\N{...}</code>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/language/escape">Escape sequences</a></p><p><strong>Notes:</strong></p><p>None</p><h2><a name="library-review-23" href="#library-review-23"><span></span></a>C++23 TBD Library Features</h2><p>The following C++23 library features are not allowed in the Chromium codebase. See the top of this page on how to propose moving a feature from this list into the allowed or banned sections.</p><h3><a name="Constructing-containers-with-std_from_range-tbd" href="#Constructing-containers-with-std_from_range-tbd"><span></span></a><a name="constructing-containers-with-std_from_range-tbd" href="#constructing-containers-with-std_from_range-tbd"><span></span></a>Constructing containers with std::from_range [tbd]</h3><pre><span>std</span><span>::</span><span>set</span><span>&lt;int&gt;</span><span> a_very_long_container_name </span><span>=</span><span> </span><span>{</span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>};</span><span>
std</span><span>::</span><span>vector</span><span>&lt;int&gt;</span><span> old_way</span><span>(</span><span>
  a_very_long_container_name</span><span>.</span><span>begin</span><span>(),</span><span> a_very_long_container_name</span><span>.</span><span>end</span><span>());</span><span>
std</span><span>::</span><span>vector</span><span>&lt;int&gt;</span><span> new_way</span><span>(</span><span>std</span><span>::</span><span>from_range</span><span>,</span><span> a_very_long_container_name</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> More concise conversion from one container type to another.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/ranges/from_range.html">std::from_range</a></p><p><strong>Notes:</strong></p><p>See also std::ranges::to which offers something similar.</p><h3><a name="Monadic-operations-for-std_optional-tbd" href="#Monadic-operations-for-std_optional-tbd"><span></span></a><a name="monadic-operations-for-std_optional-tbd" href="#monadic-operations-for-std_optional-tbd"><span></span></a>Monadic operations for std::optional [tbd]</h3><pre><span>opt</span><span>.</span><span>and_then</span><span>(</span><span>f</span><span>).</span><span>transform</span><span>(</span><span>g</span><span>).</span><span>or_else</span><span>(</span><span>h</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> <code>and_then</code>, <code>transform</code>, <code>or_else</code> member functions.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="std_expected-tbd" href="#std_expected-tbd"><span></span></a>std::expected [tbd]</h3><pre><span>std</span><span>::</span><span>expected</span><span>&lt;</span><span>int</span><span>,</span><span> std</span><span>::</span><span>string</span><span>&gt;</span><span> e</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> A vocabulary type that contains an expected value or an error.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/expected">std::expected</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base::expected</code>.</p><h3><a name="std_flat_map_std_flat_multimap_std_flat_set_std_flat_multiset-tbd" href="#std_flat_map_std_flat_multimap_std_flat_set_std_flat_multiset-tbd"><span></span></a>std::flat_map, std::flat_multimap, std::flat_set, std::flat_multiset [tbd]</h3><pre><span>std</span><span>::</span><span>flat_map</span><span>&lt;</span><span>int</span><span>,</span><span> std</span><span>::</span><span>string</span><span>&gt;</span><span> map</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Container adaptors that provide the functionality of associative containers using sorted vectors.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/container/flat_map">std::flat_map</a> <a href="https://en.cppreference.com/w/cpp/container/flat_multimap">std::flat_multimap</a> <a href="https://en.cppreference.com/w/cpp/container/flat_set">std::flat_set</a> <a href="https://en.cppreference.com/w/cpp/container/flat_multiset">std::flat_multiset</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base::flat_map</code> and <code>base::flat_set</code>.</p><h3><a name="std_out_ptr_std_inout_ptr-tbd" href="#std_out_ptr_std_inout_ptr-tbd"><span></span></a>std::out_ptr, std::inout_ptr [tbd]</h3><pre><span>std</span><span>::</span><span>unique_ptr</span><span>&lt;</span><span>T</span><span>&gt;</span><span> p</span><span>;</span><span>
</span><span>void</span><span> </span><span>GetT</span><span>(</span><span>T</span><span>**</span><span> </span><span>out</span><span>);</span><span>
</span><span>GetT</span><span>(</span><span>std</span><span>::</span><span>out_ptr</span><span>(</span><span>p</span><span>));</span><span>
</span></pre><p><strong>Description:</strong> Smart pointer adapters for functions that take raw pointers as out-parameters.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/out_ptr_t/out_ptr">std::out_ptr</a>, <a href="https://en.cppreference.com/w/cpp/memory/inout_ptr_t/inout_ptr">std::inout_ptr</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="std_mdspan-tbd" href="#std_mdspan-tbd"><span></span></a>std::mdspan [tbd]</h3><pre><span>std</span><span>::</span><span>mdspan m</span><span>(</span><span>ptr</span><span>,</span><span> </span><span>10</span><span>,</span><span> </span><span>10</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Multidimensional array view.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/container/mdspan">std::mdspan</a></p><p><strong>Notes:</strong></p><p>We ban std::span in favor of base::span, which has better safety guarantees. If we want to support this, maybe we should implement base::mdspan.</p><h3><a name="std_ranges_to-tbd" href="#std_ranges_to-tbd"><span></span></a>std::ranges::to [tbd]</h3><pre><span>std</span><span>::</span><span>set</span><span>&lt;int&gt;</span><span> s </span><span>=</span><span> </span><span>{</span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>};</span><span>
</span><span>auto</span><span> u </span><span>=</span><span> std</span><span>::</span><span>ranges</span><span>::</span><span>to</span><span>&lt;</span><span>std</span><span>::</span><span>vector</span><span>&gt;(</span><span>s</span><span>);</span><span>
</span><span>auto</span><span> v </span><span>=</span><span> s </span><span>|</span><span> std</span><span>::</span><span>ranges</span><span>::</span><span>to</span><span>&lt;</span><span>std</span><span>::</span><span>vector</span><span>&gt;();</span><span>
</span></pre><p><strong>Description:</strong> Converts a range to a container.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/ranges/to">std::ranges::to</a></p><p><strong>Notes:</strong></p><p>We should ban the 2nd case in the snippet (use as an adaptor), but might want to allow the 1st case (simple container conversion). Note there&#39;s also std::from_range for use cases like the 1st one.</p><h3><a name="Range-Formatting-tbd" href="#Range-Formatting-tbd"><span></span></a><a name="range-formatting-tbd" href="#range-formatting-tbd"><span></span></a>Range Formatting [tbd]</h3><pre><span>LOG</span><span>(</span><span>INFO</span><span>)</span><span> </span><span>&lt;&lt;</span><span> std</span><span>::</span><span>format</span><span>(</span><span>&#34;Values: {}&#34;</span><span>,</span><span> my_vector</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Extends <code>&lt;format&gt;</code> to support printing containers and ranges.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/format/format.html"><code>&lt;format&gt;</code></a></p><p><strong>Notes:</strong></p><p>As of 01/2026, <code>&lt;format&gt;</code> is still a TBD feature from C++20.</p><h3><a name="std_print-tbd" href="#std_print-tbd"><span></span></a>std::print [tbd]</h3><pre><span>std</span><span>::</span><span>print</span><span>(</span><span>&#34;Hello {}&#34;</span><span>,</span><span> </span><span>&#34;world&#34;</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Formatted output.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/io/print">Print functions</a></p><p><strong>Notes:</strong></p><p>Overlaps with LOG() and friends.</p><h3><a name="std_generator-tbd" href="#std_generator-tbd"><span></span></a>std::generator [tbd]</h3><pre><span>std</span><span>::</span><span>generator</span><span>&lt;int&gt;</span><span> gen</span><span>()</span><span> </span><span>{</span><span> co_yield </span><span>1</span><span>;</span><span> </span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Coroutine generator.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/coroutine/generator">std::generator</a></p><p><strong>Notes:</strong></p><p>As of 01/2026, coroutine support in Chromium is still TBD.</p><h3><a name="std_stacktrace-tbd" href="#std_stacktrace-tbd"><span></span></a>std::stacktrace [tbd]</h3><pre><span>auto</span><span> trace </span><span>=</span><span> std</span><span>::</span><span>stacktrace</span><span>::</span><span>current</span><span>();</span><span>
</span></pre><p><strong>Description:</strong> Captures a stack trace.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/stacktrace">std::stacktrace</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base::debug::StackTrace</code>.</p><h3><a name="std_move_only_function-tbd" href="#std_move_only_function-tbd"><span></span></a>std::move_only_function [tbd]</h3><pre><span>std</span><span>::</span><span>move_only_function</span><span>&lt;</span><span>void</span><span>()&gt;</span><span> f </span><span>=</span><span> </span><span>[</span><span>x </span><span>=</span><span> std</span><span>::</span><span>make_unique</span><span>&lt;int&gt;</span><span>(</span><span>1</span><span>)]</span><span> </span><span>{};</span><span>
</span></pre><p><strong>Description:</strong> Function wrapper for move-only objects.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/functional/move_only_function">std::move_only_function</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base::OnceCallback</code>.</p><h3><a name="std_unreachable-tbd" href="#std_unreachable-tbd"><span></span></a>std::unreachable [tbd]</h3><pre><span>std</span><span>::</span><span>unreachable</span><span>();</span><span>
</span></pre><p><strong>Description:</strong> Indicates a codepath that is unreachable and invokes undefined behavior if executed.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/unreachable">std::unreachable</a></p><p><strong>Notes:</strong></p><p>Standard version of <code>__builtin_unreachable()</code>. Unlike <code>NOTREACHED()</code>, which cleanly aborts, this hints the compiler to optimize assuming this point is unreachable, with no bounds on how the program behaves if the annotation was wrong. This and <code>__builtin_unreachable()</code> should only be used in rare circumstances.</p><h3><a name="std_spanstream-tbd" href="#std_spanstream-tbd"><span></span></a>std::spanstream [tbd]</h3><pre><span>std</span><span>::</span><span>spanstream s</span><span>(</span><span>buffer</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Input/output stream using a span as buffer.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/header/spanstream.html">std::spanstream</a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="Fixed-width-floating_point-types-tbd" href="#Fixed-width-floating_point-types-tbd"><span></span></a><a name="fixed-width-floating_point-types-tbd" href="#fixed-width-floating_point-types-tbd"><span></span></a>Fixed width floating-point types [tbd]</h3><pre><span>#include</span><span> </span><span>&lt;stdfloat&gt;</span><span>

</span><span>int</span><span> main</span><span>()</span><span>
</span><span>{</span><span>
    std</span><span>::</span><span>float64_t</span><span> f </span><span>=</span><span> </span><span>0.1f64</span><span>;</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Similar to int32_t and friends but for floats.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/types/floating-point.html#Fixed_width_floating-point_types"></a></p><p><strong>Notes:</strong></p><p>None</p><h3><a name="std_start_lifetime_as-tbd" href="#std_start_lifetime_as-tbd"><span></span></a>std::start_lifetime_as [tbd]</h3><pre><span>void</span><span>*</span><span> storage </span><span>=</span><span> std</span><span>::</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>T</span><span>));</span><span>
T</span><span>*</span><span> p </span><span>=</span><span> std</span><span>::</span><span>start_lifetime_as</span><span>&lt;</span><span>T</span><span>&gt;(</span><span>storage</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Explicitly starts the lifetime of an object of type T in the given storage.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/memory/start_lifetime_as">std::start_lifetime_as</a></p><p><strong>Notes:</strong></p><p>None</p><h2><a name="absl-blocklist" href="#absl-blocklist"><span></span></a>Abseil Banned Library Features</h2><p>The following Abseil library features are not allowed in the Chromium codebase.</p><h3><a name="Any-banned" href="#Any-banned"><span></span></a><a name="any-banned" href="#any-banned"><span></span></a>Any [banned]</h3><pre><span>absl</span><span>::</span><span>any a </span><span>=</span><span> </span><span>int</span><span>{</span><span>5</span><span>};</span><span>
EXPECT_THAT</span><span>(</span><span>absl</span><span>::</span><span>any_cast</span><span>&lt;int&gt;</span><span>(&amp;</span><span>a</span><span>),</span><span> </span><span>Pointee</span><span>(</span><span>5</span><span>));</span><span>
EXPECT_EQ</span><span>(</span><span>absl</span><span>::</span><span>any_cast</span><span>&lt;size_t&gt;</span><span>(&amp;</span><span>a</span><span>),</span><span> </span><span>nullptr</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Early adaptation of C++17 <code>std::any</code>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/any">std::any</a></p><p><strong>Notes:</strong></p><h3><a name="AnyInvocable-banned" href="#AnyInvocable-banned"><span></span></a><a name="anyinvocable-banned" href="#anyinvocable-banned"><span></span></a>AnyInvocable [banned]</h3><pre><span>absl</span><span>::</span><span>AnyInvocable</span><span>
</span></pre><p><strong>Description:</strong> An equivalent of the C++23 std::move_only_function.</p><p><strong>Documentation:</strong></p><ul><li><a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/functional/any_invocable.h">any_invocable.h</a></li><li><a href="https://en.cppreference.com/w/cpp/utility/functional/move_only_function/move_only_function">std::move_only_function</a></li></ul><p><strong>Notes:</strong></p><p>Banned due to overlap with <code>base::RepeatingCallback</code>, <code>base::OnceCallback</code>.</p><h3><a name="Attributes-banned" href="#Attributes-banned"><span></span></a><a name="attributes-banned" href="#attributes-banned"><span></span></a>Attributes [banned]</h3><pre><span>T</span><span>*</span><span> data</span><span>()</span><span> ABSL_ATTRIBUTE_LIFETIME_BOUND </span><span>{</span><span> </span><span>return</span><span> data_</span><span>;</span><span> </span><span>}</span><span>
ABSL_ATTRIBUTE_NO_TAIL_CALL </span><span>ReturnType</span><span> </span><span>Loop</span><span>();</span><span>
</span><span>struct</span><span> S </span><span>{</span><span> </span><span>bool</span><span> b</span><span>;</span><span> </span><span>int32_t</span><span> i</span><span>;</span><span> </span><span>}</span><span> ABSL_ATTRIBUTE_PACKED</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Cross-platform macros to expose compiler-specific functionality.</p><p><strong>Documentation:</strong> <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/base/attributes.h">attributes.h</a></p><p><strong>Notes:</strong></p><h3><a name="btree_containers-banned" href="#btree_containers-banned"><span></span></a>btree_* containers [banned]</h3><pre><span>absl</span><span>::</span><span>btree_map
absl</span><span>::</span><span>btree_set
absl</span><span>::</span><span>btree_multimap
absl</span><span>::</span><span>btree_multiset
</span></pre><p><strong>Description:</strong> Alternatives to the tree-based standard library containers designed to be more efficient in the general case.</p><p><strong>Documentation:</strong> <a href="https://abseil.io/docs/cpp/guides/container">Containers</a></p><p><strong>Notes:</strong></p><p>In theory these should be superior alternatives that could replace most uses of <code>std::map</code> and company. In practice they have been found to introduce a substantial code size increase. Until this problem can be resolved the use of these containers is banned. Use the standard library containers instead.</p><h3><a name="bind_front-banned" href="#bind_front-banned"><span></span></a>bind_front [banned]</h3><pre><span>absl</span><span>::</span><span>bind_front
</span></pre><p><strong>Description:</strong> Binds the first N arguments of an invocable object and stores them by value.</p><p><strong>Documentation:</strong></p><ul><li><a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/functional/bind_front.h">bind_front.h</a></li><li><a href="https://abseil.io/tips/108">Avoid std::bind</a></li></ul><p><strong>Notes:</strong></p><p>Banned due to overlap with <code>base::Bind</code>.</p><h3><a name="Command-line-flags-banned" href="#Command-line-flags-banned"><span></span></a><a name="command-line-flags-banned" href="#command-line-flags-banned"><span></span></a>Command line flags [banned]</h3><pre><span>ABSL_FLAG</span><span>(</span><span>bool</span><span>,</span><span> logs</span><span>,</span><span> </span><span>false</span><span>,</span><span> </span><span>&#34;print logs to stderr&#34;</span><span>);</span><span>
app </span><span>--</span><span>logs</span><span>=</span><span>true</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Allows programmatic access to flag values passed on the command-line to binaries.</p><p><strong>Documentation:</strong> <a href="https://abseil.io/docs/cpp/guides/flags">Flags Library</a></p><p><strong>Notes:</strong></p><h3><a name="Container-utilities-banned" href="#Container-utilities-banned"><span></span></a><a name="container-utilities-banned" href="#container-utilities-banned"><span></span></a>Container utilities [banned]</h3><pre><span>auto</span><span> it </span><span>=</span><span> absl</span><span>::</span><span>c_find</span><span>(</span><span>container</span><span>,</span><span> value</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Container-based versions of algorithmic functions within C++ standard library.</p><p><strong>Documentation:</strong> <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/algorithm/container.h">container.h</a></p><p><strong>Notes:</strong></p><p>Superseded by algorithms in <code>std::ranges::</code>.</p><h3><a name="FixedArray-banned" href="#FixedArray-banned"><span></span></a><a name="fixedarray-banned" href="#fixedarray-banned"><span></span></a>FixedArray [banned]</h3><pre><span>absl</span><span>::</span><span>FixedArray</span><span>&lt;</span><span>MyObj</span><span>&gt;</span><span> objs_</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> A fixed size array like <code>std::array</code>, but with size determined at runtime instead of compile time.</p><p><strong>Documentation:</strong> <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/container/fixed_array.h">fixed_array.h</a></p><p><strong>Notes:</strong></p><p>Direct construction is banned due to the risk of UB with uninitialized trivially-default-constructible types. Instead use <code>base/types/fixed_array.h</code>, which is a light-weight wrapper that deletes the problematic constructor.</p><h3><a name="FunctionRef-banned" href="#FunctionRef-banned"><span></span></a><a name="functionref-banned" href="#functionref-banned"><span></span></a>FunctionRef [banned]</h3><pre><span>absl</span><span>::</span><span>FunctionRef</span><span>
</span></pre><p><strong>Description:</strong> Type for holding a non-owning reference to an object of any invocable type.</p><p><strong>Documentation:</strong> <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/functional/function_ref.h">function_ref.h</a></p><p><strong>Notes:</strong></p><h3><a name="Log-macros-and-related-classes-banned" href="#Log-macros-and-related-classes-banned"><span></span></a><a name="log-macros-and-related-classes-banned" href="#log-macros-and-related-classes-banned"><span></span></a>Log macros and related classes [banned]</h3><pre><span>LOG</span><span>(</span><span>INFO</span><span>)</span><span> </span><span>&lt;&lt;</span><span> message</span><span>;</span><span>
CHECK</span><span>(</span><span>condition</span><span>);</span><span>
absl</span><span>::</span><span>AddLogSink</span><span>(&amp;</span><span>custom_sink_to_capture_absl_logs</span><span>);</span><span>
</span></pre><p><strong>Description:</strong> Macros and related classes to perform debug loggings</p><p><strong>Documentation:</strong> <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/log/log.h">log.h</a> <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/log/check.h">check.h</a></p><p><strong>Notes:</strong></p><p>Banned due to overlap with <code>base/logging.h</code>. We‘d like to drop Chromium’s version and replace with the Abseil one, but no one has looked into how to migrate and what impacts (e.g. build time) we‘d incur. If you’d like to do this work, please contact cxx@.</p><h3><a name="NoDestructor-banned" href="#NoDestructor-banned"><span></span></a><a name="nodestructor-banned" href="#nodestructor-banned"><span></span></a>NoDestructor [banned]</h3><pre><span>// Global or namespace scope.</span><span>
ABSL_CONST_INIT absl</span><span>::</span><span>NoDestructor</span><span>&lt;</span><span>MyRegistry</span><span>&gt;</span><span> reg</span><span>{</span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>&#34;bar&#34;</span><span>,</span><span> </span><span>8008</span><span>};</span><span>

</span><span>// Function scope.</span><span>
</span><span>const</span><span> std</span><span>::</span><span>string</span><span>&amp;</span><span> </span><span>MyString</span><span>()</span><span> </span><span>{</span><span>
  </span><span>static</span><span> </span><span>const</span><span> absl</span><span>::</span><span>NoDestructor</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>&gt;</span><span> x</span><span>(</span><span>&#34;foo&#34;</span><span>);</span><span>
  </span><span>return</span><span> </span><span>*</span><span>x</span><span>;</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> <code>absl::NoDestructor&lt;T&gt;</code> is a wrapper around an object of type T that behaves as an object of type T but never calls T&#39;s destructor.</p><p><strong>Documentation:</strong> <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/base/no_destructor.h">no_destructor.h</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base::NoDestructor</code>. Banned pending rewriting friending of that class into a form usable with this (see <a href="https://crbug.com/392931072">crbug.com/392931072</a>); at that point we can allow this and migrate to it.</p><h3><a name="Nullability-annotations-banned" href="#Nullability-annotations-banned"><span></span></a><a name="nullability-annotations-banned" href="#nullability-annotations-banned"><span></span></a>Nullability annotations [banned]</h3><pre><span>void</span><span> </span><span>PaySalary</span><span>(</span><span>Employee</span><span>*</span><span> absl_nonnull employee</span><span>)</span><span> </span><span>{</span><span>
  pay</span><span>(*</span><span>employee</span><span>);</span><span>  </span><span>// OK to dereference</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Annotations to more clearly specify contracts</p><p><strong>Documentation:</strong> <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/base/nullability.h">nullability.h</a></p><p><strong>Notes:</strong></p><p>Banned due to no feasible path to codebase-wide use and little mechanism for enforcement.</p><h3><a name="Optional-banned" href="#Optional-banned"><span></span></a><a name="optional-banned" href="#optional-banned"><span></span></a>Optional [banned]</h3><pre><span>absl</span><span>::</span><span>optional</span><span>&lt;int&gt;</span><span> </span><span>Func</span><span>(</span><span>bool</span><span> b</span><span>)</span><span> </span><span>{</span><span>
  </span><span>return</span><span> b </span><span>?</span><span> absl</span><span>::</span><span>make_optional</span><span>(</span><span>1</span><span>)</span><span> </span><span>:</span><span> absl</span><span>::</span><span>nullopt</span><span>;</span><span>
</span><span>}</span><span>
</span></pre><p><strong>Description:</strong> Early adaptation of C++17 <code>std::optional</code>.</p><p><strong>Documentation:</strong> <a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a></p><p><strong>Notes:</strong></p><p>Superseded by <code>std::optional</code>. Use <code>std::optional</code> instead.</p><h3><a name="Random-banned" href="#Random-banned"><span></span></a><a name="random-banned" href="#random-banned"><span></span></a>Random [banned]</h3><pre><span>absl</span><span>::</span><span>BitGen</span><span> bitgen</span><span>;</span><span>
</span><span>size_t</span><span> index </span><span>=</span><span> absl</span><span>::</span><span>Uniform</span><span>(</span><span>bitgen</span><span>,</span><span> </span><span>0u</span><span>,</span><span> elems</span><span>.</span><span>size</span><span>());</span><span>
</span></pre><p><strong>Description:</strong> Functions and utilities for generating pseudorandom data.</p><p><strong>Documentation:</strong> <a href="https://abseil.io/docs/cpp/guides/random">Random library</a></p><p><strong>Notes:</strong></p><p>Banned because most uses of random values in Chromium should be using a cryptographically secure generator. Use <code>base/rand_util.h</code> instead.</p><h3><a name="Span-banned" href="#Span-banned"><span></span></a><a name="span-banned" href="#span-banned"><span></span></a>Span [banned]</h3><pre><span>absl</span><span>::</span><span>Span</span><span>
</span></pre><p><strong>Description:</strong> Early adaptation of C++20 <code>std::span</code>.</p><p><strong>Documentation:</strong> <a href="https://abseil.io/tips/93">Using absl::Span</a></p><p><strong>Notes:</strong></p><p>Banned due to being less std::-compliant than <code>base::span</code>. Keep using <code>base::span</code>.</p><h3><a name="StatusOr-banned" href="#StatusOr-banned"><span></span></a><a name="statusor-banned" href="#statusor-banned"><span></span></a>StatusOr [banned]</h3><pre><span>absl</span><span>::</span><span>StatusOr</span><span>&lt;</span><span>T</span><span>&gt;</span><span>
</span></pre><p><strong>Description:</strong> An object that is either a usable value, or an error Status explaining why such a value is not present.</p><p><strong>Documentation:</strong> <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/status/statusor.h">statusor.h</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base::expected</code>.</p><h3><a name="string_view-banned" href="#string_view-banned"><span></span></a>string_view [banned]</h3><pre><span>absl</span><span>::</span><span>string_view
</span></pre><p><strong>Description:</strong> Early adaptation of C++17 <code>std::string_view</code>.</p><p><strong>Documentation:</strong> <a href="https://abseil.io/tips/1">absl::string_view</a></p><p><strong>Notes:</strong></p><p>Originally banned due to only working with 8-bit characters. Now it is unnecessary because it is the same type as <code>std::string_view</code>. Please use <code>std::string_view</code> instead.</p><h3><a name="Strings-Library-banned" href="#Strings-Library-banned"><span></span></a><a name="strings-library-banned" href="#strings-library-banned"><span></span></a>Strings Library [banned]</h3><pre><span>absl</span><span>::</span><span>StrSplit</span><span>
absl</span><span>::</span><span>StrJoin</span><span>
absl</span><span>::</span><span>StrCat</span><span>
absl</span><span>::</span><span>StrAppend</span><span>
absl</span><span>::</span><span>Substitute</span><span>
absl</span><span>::</span><span>StrContains</span><span>
</span></pre><p><strong>Description:</strong> Classes and utility functions for manipulating and comparing strings.</p><p><strong>Documentation:</strong> <a href="https://abseil.io/docs/cpp/guides/strings">String Utilities</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base/strings</code>. We <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1371966">should re-evalute</a> when we&#39;ve <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=691162">migrated</a> from <code>base::StringPiece</code> to <code>std::string_view</code>. Also note that <code>absl::StrFormat()</code> is not considered part of this group, and is explicitly allowed.</p><h3><a name="Synchronization-banned" href="#Synchronization-banned"><span></span></a><a name="synchronization-banned" href="#synchronization-banned"><span></span></a>Synchronization [banned]</h3><pre><span>absl</span><span>::</span><span>Mutex</span><span>
</span></pre><p><strong>Description:</strong> Primitives for managing tasks across different threads.</p><p><strong>Documentation:</strong> <a href="https://abseil.io/docs/cpp/guides/synchronization">Synchronization</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base/synchronization/</code>. We would love <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1371969">more testing</a> on whether there are compelling reasons to prefer base, absl, or std synchronization primitives; for now, use <code>base/synchronization/</code>.</p><h3><a name="Time-library-banned" href="#Time-library-banned"><span></span></a><a name="time-library-banned" href="#time-library-banned"><span></span></a>Time library [banned]</h3><pre><span>absl</span><span>::</span><span>Duration</span><span>
absl</span><span>::</span><span>Time</span><span>
absl</span><span>::</span><span>TimeZone</span><span>
absl</span><span>::</span><span>CivilDay</span><span>
</span></pre><p><strong>Description:</strong> Abstractions for holding time values, both in terms of absolute time and civil time.</p><p><strong>Documentation:</strong> <a href="https://abseil.io/docs/cpp/guides/time">Time</a></p><p><strong>Notes:</strong></p><p>Overlaps with <code>base/time/</code>.</p><h3><a name="Variant-banned" href="#Variant-banned"><span></span></a><a name="variant-banned" href="#variant-banned"><span></span></a>Variant [banned]</h3><pre><span>absl</span><span>::</span><span>bad_variant_access</span><span>;</span><span>
absl</span><span>::</span><span>get</span><span>;</span><span>
absl</span><span>::</span><span>get_if</span><span>;</span><span>
absl</span><span>::</span><span>holds_alternative</span><span>;</span><span>
absl</span><span>::</span><span>monostate</span><span>;</span><span>
absl</span><span>::</span><span>variant</span><span>;</span><span>
absl</span><span>::</span><span>variant_alternative</span><span>;</span><span>
absl</span><span>::</span><span>variant_alternative_t</span><span>;</span><span>
absl</span><span>::</span><span>variant_npos</span><span>;</span><span>
absl</span><span>::</span><span>variant_size</span><span>;</span><span>
absl</span><span>::</span><span>variant_size_v</span><span>;</span><span>
absl</span><span>::</span><span>visit</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> A backport of C++17&#39;s std::variant type-safe union and related utilities.</p><p><strong>Notes:</strong></p><p>These are just aliases to the std counterparts these days. Use std instead.</p><h3><a name="Utility-library-banned" href="#Utility-library-banned"><span></span></a><a name="utility-library-banned" href="#utility-library-banned"><span></span></a>Utility library [banned]</h3><pre><span>absl</span><span>::</span><span>apply</span><span>;</span><span>
absl</span><span>::</span><span>exchange</span><span>;</span><span>
absl</span><span>::</span><span>forward</span><span>;</span><span>
absl</span><span>::</span><span>in_place</span><span>;</span><span>
absl</span><span>::</span><span>in_place_index</span><span>;</span><span>
absl</span><span>::</span><span>in_place_index_t</span><span>;</span><span>
absl</span><span>::</span><span>in_place_t</span><span>;</span><span>
absl</span><span>::</span><span>in_place_type</span><span>;</span><span>
absl</span><span>::</span><span>in_place_type_t</span><span>;</span><span>
absl</span><span>::</span><span>index_sequence</span><span>;</span><span>
absl</span><span>::</span><span>index_sequence_for</span><span>;</span><span>
absl</span><span>::</span><span>integer_sequence</span><span>;</span><span>
absl</span><span>::</span><span>make_from_tuple</span><span>;</span><span>
absl</span><span>::</span><span>make_index_sequence</span><span>;</span><span>
absl</span><span>::</span><span>make_integer_sequence</span><span>;</span><span>
absl</span><span>::</span><span>move</span><span>;</span><span>
</span></pre><p><strong>Description:</strong> Backports of various C++17 template utilities.</p><p><strong>Notes:</strong></p><p>These are just aliases to the std counterparts these days. Use std instead.</p><h2><a name="absl-review" href="#absl-review"><span></span></a>Abseil TBD Features</h2><p>The following Abseil library features are not allowed in the Chromium codebase. See the top of this page on how to propose moving a feature from this list into the allowed or banned sections.</p><h3><a name="absl_linked_hash_set_absl_linked_hash_map-tbd" href="#absl_linked_hash_set_absl_linked_hash_map-tbd"><span></span></a>absl::linked_hash_set, absl::linked_hash_map [tbd]</h3><pre><span>absl</span><span>::</span><span>linked_hash_set</span><span>&lt;int&gt;</span><span> m</span><span>;</span><span>
m</span><span>.</span><span>insert</span><span>(</span><span>2</span><span>);</span><span>
m</span><span>.</span><span>insert</span><span>(</span><span>1</span><span>);</span><span>
m</span><span>.</span><span>insert</span><span>(</span><span>3</span><span>);</span><span>
EXPECT_THAT</span><span>(</span><span>m</span><span>,</span><span> </span><span>ElementsAre</span><span>(</span><span>2</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>3</span><span>));</span><span>
</span></pre><p><strong>Description:</strong> A simple insertion-ordered set or map. It provides O(1) amortized insertions and lookups, as well as iteration in the insertion order.</p><p><strong>Documentation:</strong></p><ul><li><a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/container/linked_hash_set.h">linked_hash_set.h</a></li><li><a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/abseil-cpp/absl/container/linked_hash_map.h">linked_hash_map.h</a></li></ul></div></div></div></div>
  </body>
</html>
