<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://effectivetypescript.com/2024/02/27/type-guards/">Original</a>
    <h1>The Hidden Side of Type Predicates</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>For the past two months I&#39;ve been participating in a batch at the <a target="_blank" rel="noopener" href="https://www.recurse.com/" onclick="return trackOutboundLink(&#39;the hidden side of type predicates&#39;, &#39;https://www.recurse.com/&#39;, event);">Recurse Center</a> in Brooklyn, a &#34;writer&#39;s retreat for programmers.&#34; I&#39;ve been having lots of fun learning about <a target="_blank" rel="noopener" href="https://github.com/danvk/gravlax" onclick="return trackOutboundLink(&#39;the hidden side of type predicates&#39;, &#39;https://github.com/danvk/gravlax&#39;, event);">Interpreters</a>, <a target="_blank" rel="noopener" href="https://github.com/danvk/Stanford-CS-242-Programming-Languages" onclick="return trackOutboundLink(&#39;the hidden side of type predicates&#39;, &#39;https://github.com/danvk/Stanford-CS-242-Programming-Languages&#39;, event);">Programming Languages</a> and <a target="_blank" rel="noopener" href="https://github.com/karpathy/nn-zero-to-hero" onclick="return trackOutboundLink(&#39;the hidden side of type predicates&#39;, &#39;https://github.com/karpathy/nn-zero-to-hero&#39;, event);">Neural Nets</a>, but you apply to RC with a <em>project</em> in mind, and mine was to contribute to the TypeScript open source project. I&#39;ve used TypeScript and written about it for years, but I&#39;ve never contributed code to it. Time to change that!</p>
<p>The result is <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465" onclick="return trackOutboundLink(&#39;the hidden side of type predicates&#39;, &#39;https://github.com/microsoft/TypeScript/pull/57465&#39;, event);">PR #57465</a>, which adds a feature I&#39;ve always wanted in TypeScript: inference of <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" onclick="return trackOutboundLink(&#39;the hidden side of type predicates&#39;, &#39;https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates&#39;, event);">type predicates</a>. I&#39;ll have more to say about that PR in a future post. But for now I&#39;d like to share some of what I&#39;ve learned about type predicates while implementing it.</p>
<h2 id="What-are-type-predicates"><a href="#What-are-type-predicates" title="What are type predicates?"></a>What are type predicates?</h2><p>What is a type predicate? Whenever a function in TypeScript returns a <code>boolean</code>, you can change it to return a &#34;type predicate&#34; instead:</p>
<figure><div><pre><code><span><span>function</span> <span>isNumber</span>(<span>x: unknown</span>): <span>x</span> <span>is</span> <span>number</span> </span>{</code></pre></div></figure>

<p>Here <code>x is number</code> is the type predicate. Any function that returns a type predicate is a &#34;user-defined type guard.&#34;</p>
<p>Here&#39;s how you use a type guard:</p>
<figure><div><pre><code><span>let</span> strOrNum = <span>Math</span>.random() &lt; <span>0.5</span> ? <span>123</span> : <span>&#39;abc&#39;</span>;</code></pre></div></figure>

<p>In this case there&#39;s little advantage over doing the <code>typeof</code> check directly in the <code>if</code> statement. But type guards really shine in two specific circumstances:</p>
<ol>
<li>When TypeScript can&#39;t infer the type you want on its own.</li>
<li>When you pass the type guard as a callback.</li>
</ol>
<p>The former often comes up with input validation:</p>
<figure><div><pre><code><span><span>function</span> <span>isProductReview</span>(<span>input: unknown</span>): <span>input</span> <span>is</span> <span>ProductReview</span> </span>{</code></pre></div></figure>

<p>But in this post we&#39;re more interested in the latter. Here&#39;s the motivating scenario:</p>
<figure><div><pre><code><span>const</span> strsAndNums = [<span>123</span>, <span>&#39;abc&#39;</span>, <span>456</span>, <span>&#39;def&#39;</span>];</code></pre></div></figure>

<p>We&#39;ve filtered the array of strings and numbers down to just the numbers, but TypeScript hasn&#39;t been able to follow along. The result is a spurious type error.</p>
<p>Changing from an arrow function to the type guard fixes the problem:</p>
<figure><div><pre><code><span>const</span> strsAndNums = [<span>123</span>, <span>&#39;abc&#39;</span>, <span>456</span>, <span>&#39;def&#39;</span>];</code></pre></div></figure>

<p>This works because the declaration of <code>Array.prototype.filter</code> <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/blob/8f531ff3ba221344a93a63312326f9decfdcf458/src/lib/es5.d.ts#L1255-L1260" onclick="return trackOutboundLink(&#39;what are type predicates&#39;, &#39;https://github.com/microsoft/TypeScript/blob/8f531ff3ba221344a93a63312326f9decfdcf458/src/lib/es5.d.ts#L1255-L1260&#39;, event);">has been overloaded</a> to work with type predicates. Several built-in <code>Array</code> methods work this way, including <code>find</code> and <code>every</code>:</p>
<figure><div><pre><code><span>const</span> num = strsAndNums.find(isNumber);</code></pre></div></figure>

<h2 id="What-if-you-return-false"><a href="#What-if-you-return-false" title="What if you return false?"></a>What if you return false?</h2><p>If a function returns <code>x is T</code>, then it&#39;s clear what it means when it returns <code>true</code>: <code>x</code> is a <code>T</code>! But what does it mean if it returns <code>false</code>?</p>
<p>TypeScript&#39;s expectation is that type guards return <code>true</code> <em>if and only if</em> the predicate is true. To spell it out:</p>
<ul>
<li>If the type guard returns <code>true</code> then <code>x</code> is <code>T</code>.</li>
<li>If the type guard returns <code>false</code> then <code>x</code> is not <code>T</code>.</li>
</ul>
<p>This often works so intuitively that you don&#39;t even think about it. Using our <code>isNumber</code> type guard, for example:</p>
<figure><div><pre><code><span>let</span> strOrNum = <span>Math</span>.random() &lt; <span>0.5</span> ? <span>123</span> : <span>&#39;abc&#39;</span>;</code></pre></div></figure>

<p>But it can definitely go wrong! What about this type guard?</p>
<figure><div><pre><code><span><span>function</span> <span>isSmallNumber</span>(<span>x: <span>string</span> | <span>number</span></span>): <span>x</span> <span>is</span> <span>number</span> </span>{</code></pre></div></figure>

<p>If this returns <code>true</code> then <code>x</code> is definitely a <code>number</code>. But if it returns <code>false</code>, then <code>x</code> could be either a <code>string</code> or a large <code>number</code>. This is not an &#34;if and only if&#34; relationship. This sort of incorrect type predicate can lead to <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">unsoundness</a>:</p>
<figure><div><pre><code><span>if</span> (isSmallNumber(strOrNum)) {</code></pre></div></figure>

<p>This passes the type checker but blows up at runtime:</p>
<figure><div><pre><code>  console.log(strOrNum.toUpperCase());</code></pre></div></figure>

<p>This highlights two important facts about type guards:</p>
<ol>
<li>TypeScript does very little to check that they&#39;re valid.</li>
<li>There are expectations around the <code>false</code> case, and getting it right matters!</li>
</ol>
<p>Generally functions that combine checks with <code>&amp;&amp;</code> should not be type guards because the type will come out incorrectly for the <code>false</code> case.</p>
<p>Many functions only care about the <code>true</code> case. If you&#39;re just passing your type guard to <code>filter</code> or <code>find</code>, then you won&#39;t get into trouble. But if you pass it to a function like lodash&#39;s <a target="_blank" rel="noopener" href="https://lodash.com/docs/4.17.15#partition" onclick="return trackOutboundLink(&#39;what if you return false&#39;, &#39;https://lodash.com/docs/4.17.15#partition&#39;, event);"><code>_.partition</code></a> then you will:</p>
<figure><div><pre><code><span>import</span> _ <span>from</span> <span>&#39;lodash&#39;</span>;</code></pre></div></figure>

<p>This is an unsound type and it will lead to trouble. It&#39;s interesting to compare this with inlining the check into an <code>if</code> statement:</p>
<figure><div><pre><code><span>if</span> (<span>typeof</span> strOrNum === <span>&#39;number&#39;</span> &amp;&amp; <span>Math</span>.abs(strOrNum) &lt; <span>10</span>) {</code></pre></div></figure>

<p>Left to its own devices, TypeScript gets this right. The only reason it went wrong before was because we fed it bad information: <code>isSmallNumber</code> should not have been a type predicate!</p>
<p>Because of the strict rules around what <code>false</code> means, a type guard cannot, in general, replace an <code>if</code> statement. There&#39;s a <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/15048" onclick="return trackOutboundLink(&#39;what if you return false&#39;, &#39;https://github.com/microsoft/TypeScript/issues/15048&#39;, event);">proposal</a> to fix this by adding &#34;one-sided&#34; or &#34;fine-grained&#34; type guards. If it were adopted, you&#39;d be able to declare something like this:</p>
<figure><div><pre><code><span><span>function</span> <span>isSmallNumber</span>(<span>x: <span>string</span> | <span>number</span></span>): <span>x</span> <span>is</span> <span>number</span> <span>else</span> (<span><span>string</span>|<span>number</span></span>)</span>;<br/></code></pre></div></figure>

<h2 id="A-test-for-valid-type-predicates"><a href="#A-test-for-valid-type-predicates" title="A test for valid type predicates"></a>A test for valid type predicates</h2><p>In the last example, we could tell that the type predicate was invalid because inlining it into an <code>if</code> statement produced different types in the <code>else</code> block than calling the type guard did.</p>
<p>This feels like a good test for type guards! Does it work?</p>
<p>As it turns out, no! There&#39;s a subtlety around subtyping that hadn&#39;t occurred to me until the <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465/commits/e2684f128975dac725f4af4f9e6f03d4e765cfbe" onclick="return trackOutboundLink(&#39;a test for valid type predicates&#39;, &#39;https://github.com/microsoft/TypeScript/pull/57465/commits/e2684f128975dac725f4af4f9e6f03d4e765cfbe&#39;, event);">tests failed</a> on my PR branch. The details and solution are a little too in the weeds for this post. But when I write a post about the making of this PR, we&#39;ll cover it in depth. There <em>is</em> a test. Check out the PR if you&#39;re curious.</p>
<p>In the meantime, though, we can talk about a few heuristics. If a condition fails the &#34;inlining&#34; test, then it&#39;s definitely not a valid type predicate.</p>
<h2 id="Non-Nullishness-not-Truthiness"><a href="#Non-Nullishness-not-Truthiness" title="Non-Nullishness, not Truthiness"></a>Non-Nullishness, not Truthiness</h2><p>JavaScript and TypeScript make a distinction between &#34;truthiness&#34; and &#34;non-nullishness&#34;:</p>
<figure><div><pre><code><span>const</span> isTruthy&lt;T&gt;<span>(<span>x: T</span>) =&gt;</span> !!x;</code></pre></div></figure>

<p>This is important for types like <code>number</code> and <code>string</code>. Here&#39;s why:</p>
<figure><div><pre><code><span>declare</span> <span>let</span> numOrNull: <span>number</span> | <span>null</span>;</code></pre></div></figure>

<p>The interesting part is the <code>number</code> in the <code>else</code> block. The number <code>0</code> is falsy, so <code>numOrNull</code> can be a <code>number</code> in the false case. (In theory TypeScript could narrow it to <code>0 | null</code>, but the TS team has decided this is <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/45329" onclick="return trackOutboundLink(&#39;nonnullishness not truthiness&#39;, &#39;https://github.com/microsoft/TypeScript/issues/45329&#39;, event);">not worth it</a>.)</p>
<p>This means that if you make <code>isTruthy</code> return a type predicate, functions like <code>partition</code> will produce unsound types:</p>
<figure><div><pre><code><span>const</span> numsAndNulls = [<span>1</span>, <span>2</span>, <span>null</span>, <span>4</span>, <span>null</span>, <span>5</span>];</code></pre></div></figure>

<p>TypeScript thinks that <code>nulls</code> is an array of <code>null</code> values, but it could actually contain numbers (specifically zeroes). This is an <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">unsound type</a>. It&#39;s also likely to be a logic error: do you really mean to filter out the zeroes? If you&#39;re calculating an average, this will give you an incorrect result.</p>
<p>Better to use <code>isNonNullish</code> or the equivalent. This is safe:</p>
<figure><div><pre><code><span>const</span> [nums, nulls] = _.partition(numsAndNulls, (x): x is <span>number</span> =&gt; x !== <span>null</span>);</code></pre></div></figure>

<p>You can make the generic <code>isNonNullish</code> into a type predicate, too:</p>
<figure><div><pre><code><span><span>function</span> <span>isNonNullish</span>&lt;<span>T</span>&gt;(<span>x: T</span>): <span>x</span> <span>is</span> <span>T</span> &amp; </span>{} {</code></pre></div></figure>

<p>This relies on the <code>{}</code> type, which is TypeScript for &#34;all values except <code>null</code> and <code>undefined</code>.&#34; This is one of the few good uses of this very broad type!</p>
<h2 id="Composing-predicates"><a href="#Composing-predicates" title="Composing predicates"></a>Composing predicates</h2><p>In general you can compose type predicates with &#34;or&#34;:</p>
<figure><div><pre><code><span><span>function</span> <span>isFooOrBar</span>(<span>x: unknown</span>): <span>x</span> <span>is</span> <span>Foo</span> | <span>Bar</span> </span>{</code></pre></div></figure>

<p>Similarly, you can compose predicates with &#34;and&#34; if their types intersect:</p>
<figure><div><pre><code><span><span>function</span> <span>isFooAndBar</span>(<span>x: unknown</span>): <span>x</span> <span>is</span> <span>Foo</span> &amp; <span>Bar</span> </span>{</code></pre></div></figure>

<p>This could happen if you have a big discriminated union and you have helpers that match different subsets of it.</p>
<p>Be careful about composing conditions that can&#39;t be fully represented in the type system, however. You can&#39;t define a TypeScript type for &#34;numbers less than 10&#34; or &#34;strings less than ten characters long&#34; or &#34;numbers other than zero.&#34; So conditions like these generally don&#39;t belong in a type guard:</p>
<figure><div><pre><code></code></pre></div></figure>

<h2 id="Conclusions"><a href="#Conclusions" title="Conclusions"></a>Conclusions</h2><p>When you write a user-defined type guard, it&#39;s easy to only think about the <code>true</code> case: if you write <code>x is string</code> and you know that <code>x</code> must be a <code>string</code> when the function returns <code>true</code>, then surely you&#39;re good to go, right?</p>
<p>As this post has explained, that&#39;s only half the battle. In order for a type guard to be completely safe, it&#39;s also important to know what the type of the parameter is when it returns <code>false</code>. This is the hidden side of type predicates. It&#39;s easy to get wrong, and this can lead to unsound types.</p>
<p>Because it might be used in an <code>if</code> / <code>else</code> statement or with functions like <code>_.partition</code>, you want your type guard to be bulletproof! Make sure you provide the &#34;if and only if&#34; semantics that TypeScript expects.</p>

          </div></div>
  </body>
</html>
