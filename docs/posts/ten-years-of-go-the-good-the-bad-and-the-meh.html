<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.carlmjohnson.net/post/2023/ten-years-of-go-good-bad-meh/">Original</a>
    <h1>Ten years of “Go: The good, the bad, and the meh”</h1>
    
    <div id="readability-page-1" class="page"><div><div><main><article><header><time datetime="2023-07-18T00:00:00Z">Tuesday, July 18, 2023</time></header><section><p>Ten years ago, I wrote <a href="https://blog.carlmjohnson.net/post/google-go-the-good-the-bad-and-the-meh/">Go: The Good, the Bad, and the Meh</a>. Way back in 2013, it made it to the front page of <a href="https://news.ycombinator.com/item?id=5200916">Hacker News</a> and got over 400 comments on <a href="https://www.reddit.com/r/programming/comments/18b0qb/google_go_the_good_the_bad_and_the_meh/">/r/programming</a>. I don’t have analytics from back then, but I suspect it’s one of my more discussed pieces of writing, and it was definitely one of my first experiences of getting a lot of feedback for my writing. (Then again, I don’t have any evidence of whether <a href="https://twitter.com/ID_AA_Carmack/status/1293311943995002881">John Carmack read it</a>, so maybe it’s not the one for my obituary.)</p><p>Anyway, it’s been a decade, and in that time I’ve gone from playing around with Go as an amateur to being a professional programmer and using Go as one of my core languages. So, I thought it would be fun to look back at what I got right, what’s changed since I wrote it, what I missed, and what I got wrong. Feel free to read or re-read <a href="https://blog.carlmjohnson.net/post/google-go-the-good-the-bad-and-the-meh/">the original post</a>, or just stick to my reflections here without digging back into it. Just know that as its title suggests, I wrote it with three sections for what I thought was “good”, “bad”, and “meh” about Go at that time.</p><hr/><h2 id="what-i-got-right">What I got right</h2><p>I still agree with almost everything I listed in the “good” section from before. All of these things are still good:</p><ul><li>That Go was designed for working on large projects in a team with a modern version control system</li><li>Using capitalization for the public/private distinction in functions, methods, variables, and fields</li><li>Using the directory as the fundamental unit of packaging</li><li>Having a single binary for deployment</li><li>That the go tool is fast and has built in <code>go fmt</code>, <code>go doc</code>, and <code>go test</code></li><li>Using type last style (<code>var x int</code>) rather than type first style (<code>int x</code>)</li><li>Having explicit variable declaration (vs. Python’s implicit declaration by using <code>=</code>)</li><li><a href="https://go.dev/play/">The Go Playground</a></li><li>Logical type names (int64, float32, etc. vs. long and double)</li><li>Having the three basic data types of string, variable length array, and hash map</li><li>Interfaces as compile time duck typing</li><li>Not providing inheritance</li></ul><p>The other sections, well, we’ll come back to them.</p><h2 id="whats-changed">What’s changed</h2><p>The biggest change to Go the language in the last ten years has obviously been the addition of generics.</p><p>In the original post, I listed lack of generics under the “bad” section:</p><blockquote><p>Idiomatic Go code has a couple of different tricks for using interfaces so that you don’t need generics… but sometimes you just have to bite the bullet and copy-and-paste a function three times so you have three differently typed versions of it. If you’re trying to make your own data structure, you can just use <code>interface {}</code> as a universal object type, but then you lose compile time type safety. If you want to make a universal <code>sum</code> function, on the other hand, there’s no really good way to do it.</p></blockquote><p>Generics were added to Go in <a href="https://blog.carlmjohnson.net/post/2021/golang-118-minor-features/">version 1.18</a> in February 2022. It has basically solved this complaint. A generic <code>sum</code> looks <a href="https://go.dev/play/p/R-QDDqcp3w9">like this</a>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>Numeric</span> <span>interface</span> <span>{</span>
</span></span><span><span>    <span>~</span><span>int</span> <span>|</span> <span>~</span><span>int8</span> <span>|</span> <span>~</span><span>int16</span> <span>|</span> <span>~</span><span>int32</span> <span>|</span> <span>~</span><span>int64</span> <span>|</span>
</span></span><span><span>        <span>~</span><span>uint</span> <span>|</span> <span>~</span><span>uint8</span> <span>|</span> <span>~</span><span>uint16</span> <span>|</span> <span>~</span><span>uint32</span> <span>|</span> <span>~</span><span>uint64</span> <span>|</span> <span>~</span><span>uintptr</span> <span>|</span>
</span></span><span><span>        <span>~</span><span>float64</span> <span>|</span> <span>~</span><span>float32</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>sum</span><span>[</span><span>N</span> <span>Numeric</span><span>](</span><span>vals</span> <span>...</span><span>N</span><span>)</span> <span>N</span> <span>{</span>
</span></span><span><span>    <span>var</span> <span>total</span> <span>N</span> <span>=</span> <span>0</span>
</span></span><span><span>    <span>for</span> <span>_</span><span>,</span> <span>val</span> <span>:=</span> <span>range</span> <span>vals</span> <span>{</span>
</span></span><span><span>        <span>total</span> <span>+=</span> <span>val</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>return</span> <span>total</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>So far, generics have been a change for the better.</p><p>The other major change from the Go of 2013 is the addition of Go modules. I listed the <code>GOPATH</code> system of that time under the “good” section:</p><blockquote><p>[If] you run <code>go get github.com/userA/project/</code> it will use git to download the project from github.com and put it into the right place. Even better, if that project contains the line <code>import &#34;bitbucket.com/userB/library&#34;</code>, the go tool can also download and install <em>that</em> library in the right place. So, in one stroke, Go has its own elegant solution to packaging and a modern, decentralized version of CPAN or PyPI: the VCS you were already using!</p></blockquote><p>Go modules took this existing system and added the ability to specify version requirements for the imported packages and even Go itself. There were some bumps and hurt feelings in the transition from <code>GOPATH</code> to Go modules, but overall, it was very smooth and day-to-day, I can’t say that I’ve run into many problems with them. It just works, and you mostly don’t think about it.</p><p>I said at the time that I was “meh” about the fact that the Go compiler has no warnings, only errors, but the way that this has evolved over the last decade is that warnings with a low false positive rate have become <code>go vet</code> errors, and other warnings just end up in miscellaneous linters. So, it’s still technically true about the compiler that there are no warnings, but the Go ecosystem certainly has lots of avenues for warnings in practice, so it’s only an interesting distinction when you want to complain about Go.</p><h2 id="what-i-missed">What I missed</h2><p>Rereading the post now, what jumps out to me is that there was no mention of unions, sum types, or optional values. I think this just goes to show how much the state of the industry has changed in the last decade. Back then, sum types and optional values were still considered academic features. You saw them in ML derived languages like Haskell, but not in mainstream C-influence languages. Swift wouldn’t come out until 2014, and Rust until 2015, but languages since then have all been judged by whether they have a solution to <a href="https://en.wikipedia.org/wiki/Null_pointer#History">the billion dollar mistake</a>.</p><p>Unfortunately, I don’t think there’s any chance that <code>nil</code> could be removed from Go now. Too much code has been written with it to ever really move on to optional types, at least in Go as we know it. However, there is a proposal to <a href="https://github.com/golang/go/issues/57644">add sum types by restricting interface values</a>, and I think that has a good chance of happening in one form or another.</p><p>Again, it shows how things have changed that I praised Go’s type inference as an advance in the state of the art, but now the Hacker News crowd considers Go’s type inference to be very limited compared to other languages. <a href="https://www.stroustrup.com/quotes.html">You either die a language nobody uses or live long enough to be one people complain about</a>.</p><p>The other thing that stands out as an omission in the original post in retrospect is that there is no mention of <a href="https://go.dev/doc/go1compat">the Go 1 guarantee</a>. When Go 1.0 was released, the Go team promised not to break source compatibility. Of course, there have always been caveats, bugs, and exceptions, but by most reckonings, they have kept their word to a remarkable degree. To be fair to myself, at the time, <a href="https://go.dev/doc/devel/release#go1">Go 1.0.3 was the current version</a>, so it was impossible for me to know that the Go 1 guarantee would last for a decade plus, but I think that it really was critical in the development of Go into the language it is today. Before Go 1, it was common for the Go team to issue changes to the language or the standard library that needed <code>go fix</code> to be run over a codebase to get it caught up to the new standard. Since then however, if you write a Go program, use the standard library, and don’t rely on unsafe features or security holes, your code should just keep on working indefinitely.</p><p>It’s a real breath of fresh air compared to other ecosystems, and it’s one of my favorite things as a developer. With other languages, upgrading to a new version (<a href="https://github.com/alpinejs/alpine/issues/580">even a minor version</a>) is fraught with worry that something, somewhere will break unexpectedly. Even when the breakage is declared in advance with deprecation warnings, it’s still churn that you have to make time to fix as part of the upgrade process. With Go, I just don’t worry about that. Yes, there can be bugs, but nothing is going to break on purpose just because it made life easier for someone else. It feels like the language team is working for me instead of against me.</p><h2 id="what-i-got-wrong">What I got wrong</h2><p>I would say that on the whole, the old post holds up pretty well and nothing in it was egregiously wrong. However, there are a few things where at the time I felt one way, but now I have a slightly more nuanced view without totally disagreeing with myself.</p><p>In the “good” section specifically, there was nothing that was actually bad exactly, but in hindsight, I do see more of the tradeoffs to concurrency.</p><p>I wrote at the time,</p><blockquote><p>It works like you thought concurrency should work before you learned about concurrency. It’s nice. You don’t have to think about it too much. If you want to run a function concurrently, just do <code>go function(arguments)</code>. If you want to communicate with the function, you can use channels, which are synchronous by default, meaning they pause execution until both sides are ready.</p></blockquote><p>This is still true, and I still think working with concurrency in Go is very easy compared to something like Python. (Incidentally, I was writing before <code>Promise</code> and <code>await</code> were added to JavaScript to give context.) On the other hand, nothing in the type system prevents you from creating a data race, so you have to use the race detector religiously in testing, and using channels directly without following <a href="https://blog.carlmjohnson.net/post/share-memory-by-communicating/">a well known pattern</a> for creating <a href="https://github.com/carlmjohnson/flowmatic">structured concurrency</a> is <a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">a surefire recipe for spaghetti code</a>. It’s a tradeoff in that Go gives you just enough rope to hang yourself, but most of the time when you’re just writing a web server or something, you can get most of the benefits of concurrency without the drawbacks.</p><p>On the other hand, most of the things I listed in the “bad” section have mostly been non-problems for me in practice. I’m not sure why I was worried about the string type not having methods. The lack of a <code>#!</code> starting line for scripts turned out <a href="https://github.com/carlmjohnson/go-run">not to matter in practice</a>. That Go isn’t <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a> is more of a <em>tradeoff</em> than “bad” per se.</p><p>The lack of generics was an occasional problem, but there were usually pretty obvious workarounds for it, like falling back on dynamic typing, using reflection, or writing a code generator. I’m happy to have generics now, but it’s true that when we didn’t have it, it only occasionally presented a real problem. I am excited to watch how generics impact the future of Go, especially as the Go team work on iterators, but I do worry a bit about “useless uses of generics” where people try to shoehorn in generics where regular interfaces would work just fine. We’ll see how it goes.</p><p>The things I listed in the “meh” section also mostly continue to be tradeoffs, but in retrospect, I think Go took the better side of the tradeoff for the design space it occupies. Not having exceptions is a tradeoff, and while I might wish that Go had something like Zig’s <code>try</code> and <code>errdefer</code>, in practice, it’s fine. Using <code>if err != nil</code> is the worst system except all the other systems that have been tried from time to time, and it turns out to allow <a href="https://blog.carlmjohnson.net/post/2020/working-with-errors-as/">useful evolutions in user code</a>.</p><p><a href="https://matklad.github.io">Matklad</a> put it well <a href="https://lobste.rs/s/aocv9o/trouble_with_checked_exceptions_2003#c_bsxqyu">in a recent comment</a>,</p><blockquote><p>It seems we are roughly converging on the error handling. Midori, Go, Rust, Swift, Zig follow similarlish design, which isn’t quite checked exceptions, but is surprisingly close.</p><ul><li>there’s a way to mark functions which can fail. Often, this is a property of the return type, rather than a property of the function (Result in Rust, error pair in Go, <code>!</code> types in Zig, and bare throws decl in Midori and Swift)</li><li>we’ve cranked-up annotation burden and we mark not only throwing function declarations, but call-sites as well (<code>try</code> in Midori, Swift, Zig, <code>?</code> in Rust, <code>if err != nil</code> in Go).</li><li>Default is existentially-typed <code>AnyError</code> (<code>error</code> in Go, <code>Error</code> in Swift, <code>anyhow</code> in Rust, <code>anyerror</code> in Zig). In general, the value is shifted to distinguishing between zero and one error, rather than exhaustively specifying the set of errors.</li></ul></blockquote><p>That seems right to me. Go’s error handling is more verbose than those other languages, but structurally, there’s a lot of commonality under the surface.</p><p>I listed that Go doesn’t have operator overloading, function/method overloading, or keyword arguments as being “meh” features, but I’m pretty happy about them now. The only case where I wish Go had operator overloading is for <a href="https://pkg.go.dev/math/big#Int">big.Int</a>, and I’m hopeful that maybe someday those will be <a href="https://github.com/golang/go/issues/19624">added to the language itself</a>. Keyword arguments might be nice to have, but in practice, structs work just fine, and there’s always <a href="https://blog.carlmjohnson.net/post/2021/requests-golang-http-client/">builders with method chaining</a> for really hairy cases.</p><h2 id="takeaways">Takeaways</h2><p>Before I wrote <a href="https://blog.carlmjohnson.net/post/google-go-the-good-the-bad-and-the-meh/">the post</a>, I naively thought people would talk about how I had a section that dismissed object oriented programming out of hand. Instead people latched onto my misuse of the word “idiot” to describe people who debate the color of the bikeshed around public/private fields.</p><p>Go’s use of interfaces and lack of inheritance were probably the biggest questions to me when I wrote the article. I thought it was a good idea, but I was prepared to be surprised by experience and run into strong arguments against it. Hynek Schlawack wrote <a href="https://hynek.me/articles/python-subclassing-redux/">a great post in 2021</a> explaining why having interfaces and not having inheritance was a good design choice for Go. Basically, inheritance only makes sense when a subclass is a true specialization of the superclass, in which case Go’s type embedding works fine. So, I got the discussion I wanted, but it took about eight more years.</p><p>It would take until 2019 for Dan Abramov to write <a href="https://overreacted.io/name-it-and-they-will-come/">the definitive explanation of the experience of writing for Hacker News</a>:</p><blockquote><p>Congratulations!</p><p>Your project hit the front page of a popular news aggregator. Somebody visible in the community tweeted about it too. What are they saying?</p><p>Your heart sinks.</p><p>It’s not that people <em>didn’t like</em> the project. You know it has tradeoffs and expected people to talk about them. But that’s not what happened.</p><p><strong>Instead, the comments are largely <em>irrelevant</em> to your idea.</strong></p><p>The top comment thread picks on the coding style in a README example. It turns into an argument about indentation with over a hundred replies and a brief history of how different programming languages approached formatting. There are obligatory mentions of gofmt and Python. Have you tried Prettier?</p></blockquote><p>…</p><blockquote><p><strong>Confused, you close the tab.</strong></p><p>What happened?</p><p>It might be that your idea is simply not as interesting as you thought. That happens. It might also be that you poorly explained it for a casual visitor.</p><p>However, there might be another reason why you didn’t get relevant feedback.</p><p><strong>We tend to discuss things that are easy to talk about.</strong></p></blockquote><p>I’ve come to accept that people on discussion boards (myself included) talk about whatever they were already thinking about when we see the title of a post, and not whatever the article itself proposes. It is what it is, and it’s not going to change any time soon.</p><p>I think Rachel’s <a href="https://rachelbythebay.com/w/2021/05/26/irc/">Run XOR Use rule</a> about running an IRC chat or message board also applies to writing XOR discussing a blog post. If you write the post, you have to be prepared for the discussion to go to something you yourself weren’t even thinking about.</p><p>In terms of Go, I’m about as happy with the language as I’ve ever been. It’s not as fast as Rust, but it already well outpaces my scaling needs, and without too much boilerplate or too much temptation to abstraction. I think the language team has good instincts, and they tend to move at a measured pace in the right direction. I’m excited to see what happens next.</p><p>It’s hard to make predictions, especially about the future. Will I still be using Go in a decade? I don’t know. A decade feels like a longer time in prospect than in retrospect. Maybe we will all just be spot checking the output of code generated by AI by then, <a href="https://blog.carlmjohnson.net/post/2016-04-09-alphago-and-our-dystopian-ai-future/">as grim as that sounds</a>. But for now at least, I’m happy to use it as my core language.</p><p>Here’s the original conclusion to <a href="https://blog.carlmjohnson.net/post/google-go-the-good-the-bad-and-the-meh/">the post</a> with my 2023 updates:</p><blockquote><p>Go is rad. <del>It’s not</del> [edit: <ins>It is</ins>] my everyday language (<del>that’s still</del> [edit: <ins>it used to be</ins>] Python), <del>but</del> [edit: <ins>and</ins>] it’s definitely a fun language to use, and one that would be great for doing big projects in. If you’re interested in learning about Go, I recommend <a href="http://tour.golang.org/">doing the tour</a> then <a href="http://golang.org/ref/spec">reading the spec</a> while you put test programs into the <a href="http://play.golang.org/">Playground</a>. The spec is very short and quite readable, so it’s a great way to learn Go.</p></blockquote><p>See you in 2033 for “Ten Years of ‘Ten Years of “Go” ’ ”.</p></section></article></main></div></div></div>
  </body>
</html>
