<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/7mind/sick">Original</a>
    <h1>Sick: Indexed deduplicated binary storage for JSON-like data structures</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a href="https://github.com/7mind/sick/actions/workflows/build.yml"><img src="https://github.com/7mind/sick/workflows/Build/badge.svg" alt="Build"/></a>
<a href="https://github.com/7mind/sick/releases"><img src="https://camo.githubusercontent.com/5546d428d85ef4836d3d3f18a211f48f59e80ef7d90821b7ccdb301ae8a2f48d/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f7461672f376d696e642f7369636b2e737667" alt="Latest Release" data-canonical-src="https://img.shields.io/github/tag/7mind/sick.svg"/></a>
<a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22io.7mind.sick%22" rel="nofollow"><img src="https://camo.githubusercontent.com/39ed4a48dff76f39cc7dd34fd29b4d18e1b7064efd8f0d68a93e4fc761579565/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f696f2e376d696e642e7369636b2f7369636b5f322e31332e737667" alt="Maven Central" data-canonical-src="https://img.shields.io/maven-central/v/io.7mind.sick/sick_2.13.svg"/></a>
<a href="https://index.scala-lang.org/7mind/sick" rel="nofollow"><img src="https://camo.githubusercontent.com/4a42af947d604924c3484f38678932fa9a4d59a61edbeb3675dc74f2113a3d6b/68747470733a2f2f696e6465782e7363616c612d6c616e672e6f72672f376d696e642f7369636b2f6c61746573742e7376673f636f6c6f723d6f72616e6765" alt="Latest version" data-canonical-src="https://index.scala-lang.org/7mind/sick/latest.svg?color=orange"/></a></p>

<p dir="auto"><code>SICK</code> is an approach to handle <code>JSON</code>-like structures and various libraries implementing it.</p>
<p dir="auto"><code>SICK</code> as a library allows you to achieve the following:</p>
<ol dir="auto">
<li>Store <code>JSON</code>-like data in efficient indexed binary form</li>
<li>Avoid reading and parsing whole <code>JSON</code> files and access only the data you need just in time</li>
<li>Store multiple <code>JSON</code>-like structures in one deduplicating storage</li>
</ol>
<p dir="auto"><code>SICK</code> as a concept would also allow you:</p>
<ol dir="auto">
<li>Implement perfect streaming parsers for <code>JSON</code>-like data</li>
<li>Efficiently stream updates for <code>JSON</code>-like data</li>
</ol>
<p dir="auto">The tradeoff for these benefits is somehow more complicated and less efficient encoder.</p>

<p dir="auto"><code>JSON</code> has a <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy#Type-2_grammars" rel="nofollow">Type-2</a> grammar and requires a <a href="https://en.wikipedia.org/wiki/Pushdown_automaton" rel="nofollow">pushdown automaton</a> to parse it. So, it&#39;s not possible to implement efficient streaming parser for <code>JSON</code>. Just imagine a huge hierarchy of nested <code>JSON</code> objects: you won&#39;t be able to finish parsing the top-level object until you process the whole file.</p>
<p dir="auto"><code>JSON</code> is frequently used to store and transfer large amounts of data and these transfers tend to <a href="https://nee.lv/2021/02/28/How-I-cut-GTA-Online-loading-times-by-70/" rel="nofollow">grow over time</a>. Just imagine a typical <code>JSON</code> config file for a large enterprise product.</p>
<p dir="auto">The non-streaming nature of almost all the JSON parsers requires a lot of work to be done every time you need to deserialize a huge chunk of <code>JSON</code> data: you need to read it from disk, parse it in memory into an AST representation, and, usually, map raw <code>JSON</code> tree to object instances. Even if you use token streams and know the type of your object ahead of time you still have to deal with the Type-2 grammar.</p>
<p dir="auto">This may be very inefficient and causes unnecessary delays, pauses, CPU activity and memory consumption spikes.</p>

<p dir="auto">Let&#39;s assume that we have a small <code>JSON</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[
    {&#34;some key&#34;: &#34;some value&#34;},
    {&#34;some key&#34;: &#34;some value&#34;},
    {&#34;some value&#34;: &#34;some key&#34;},
]"><pre>[
    {<span>&#34;some key&#34;</span>: <span><span>&#34;</span>some value<span>&#34;</span></span>},
    {<span>&#34;some key&#34;</span>: <span><span>&#34;</span>some value<span>&#34;</span></span>},
    {<span>&#34;some value&#34;</span>: <span><span>&#34;</span>some key<span>&#34;</span></span>},
]</pre></div>
<p dir="auto">Let&#39;s build a table for every unique value in our <code>JSON</code> :</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Type</th>
<th>index</th>
<th>Value</th>
<th>Is Root</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>0</td>
<td>&#34;some key&#34;</td>
<td>No</td>
</tr>
<tr>
<td>string</td>
<td>1</td>
<td>&#34;some value&#34;</td>
<td>No</td>
</tr>
<tr>
<td>object</td>
<td>0</td>
<td>[string:0, string:1]</td>
<td>No</td>
</tr>
<tr>
<td>object</td>
<td>1</td>
<td>[string:1, string:0]</td>
<td>No</td>
</tr>
<tr>
<td>array</td>
<td>0</td>
<td>[object:0, object:0, object:1]</td>
<td>Yes (file.json)</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">We just built a flattened and deduplicated version of our initial <code>JSON</code> structure.</p>

<p dir="auto">Such representation allows us to do many different things, for example we may stream our table:</p>
<div data-snippet-clipboard-copy-content="string:0 = &#34;some key&#34;
string:1 = &#34;some value&#34;

object:0.size = 2
object:0[string:0] = string:1
object:1[string:1] = string:0

array:0.size = 2
array:0[0] = object:0
array:0[1] = object:1

string:2 = &#34;file.json&#34;

root:0=array:0,string:2"><pre><code>string:0 = &#34;some key&#34;
string:1 = &#34;some value&#34;

object:0.size = 2
object:0[string:0] = string:1
object:1[string:1] = string:0

array:0.size = 2
array:0[0] = object:0
array:0[1] = object:1

string:2 = &#34;file.json&#34;

root:0=array:0,string:2
</code></pre></div>
<p dir="auto">This particular encoding is inefficient but it&#39;s streamable and, moreover, we can add removal message into it thus supporting arbitrary updates:</p>
<div data-snippet-clipboard-copy-content="array:0[0] = object:1
array:0[1] = remove"><pre><code>array:0[0] = object:1
array:0[1] = remove
</code></pre></div>
<p dir="auto">There is an interesting observation: when a stream does not contain removal entries it can be safely reordered.</p>
<p dir="auto">Also this representation eliminates many cases where full accumulation is required. Obviously, not all of them, the receiver still may need to accumulate the entries in a buffer until it can sort them out.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Binary format: EBA (Efficient Binary Aggregate)</h3><a id="user-content-binary-format-eba-efficient-binary-aggregate" aria-label="Permalink: Binary format: EBA (Efficient Binary Aggregate)" href="#binary-format-eba-efficient-binary-aggregate"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We may note that the only complex data structures in our &#34;Value&#34; column are lists and <code>(type, index)</code> pairs. Let&#39;s call such pairs &#34;references&#34;.</p>
<p dir="auto">A reference can be represented as a pair of integers, so it would have a fixed byte length.</p>
<p dir="auto">A list of references can be represented as an integer storing list length followed by all the references in their binary form. Let&#39;s note that such binary structure is indexed, once we know the index of an element we want to access we can do it immediately.</p>
<p dir="auto">A list of any fixed-size scalar values can be represented the same way.</p>
<p dir="auto">A list of variable-size values (e.g. a list of strings) can be represented the following way:</p>
<div data-snippet-clipboard-copy-content="  {strings count}{list of string offsets}{all the strings concatenated}"><pre><code>  {strings count}{list of string offsets}{all the strings concatenated}
</code></pre></div>
<p dir="auto">So, <code>[&#34;a&#34;, &#34;bb&#34;, &#34;ccc&#34;]</code> would become something like <code>3 0 2 3 a b bb ccc</code> without spaces.</p>
<p dir="auto">An important fact is that this encoding is indexed too and it can be reused to store any lists of variable-length data.</p>

<p dir="auto">TODO: explain the overall EBA structure format, including tables, etc</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Additional capabilities over <code>JSON</code></h3><a id="user-content-additional-capabilities-over-json" aria-label="Permalink: Additional capabilities over JSON" href="#additional-capabilities-over-json"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>SICK</code> encoding follows compositional principles of <code>JSON</code> (a set primitive types plus lists and dictionaries), though it is more powerful: it has &#34;reference&#34; type and allows you to encode custom types.</p>
<p dir="auto">(1) It&#39;s easy to note that our table may store circular references, something <code>JSON</code> can&#39;t do natively:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Type</th>
<th>index</th>
<th>Value</th>
<th>Is Root</th>
</tr>
</thead>
<tbody>
<tr>
<td>object</td>
<td>0</td>
<td>[string:0, object:1]</td>
<td>No</td>
</tr>
<tr>
<td>object</td>
<td>1</td>
<td>[string:1, object:0]</td>
<td>No</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">This may be convenient in some complex cases.</p>
<p dir="auto">(2) Also we may note, that we may happily store multiple json files in one table and have full deduplication over their content. We just need to introduce a separate attribute (<code>is root</code>) storing either nothing or the name of our &#34;root entry&#34; (<code>JSON</code> file).</p>
<p dir="auto">In real implementation it&#39;s more convenient to just create a separate &#34;root&#34; type, the value of a root type should always be a reference to its name and a reference to the actual <code>JSON</code> value we encoded:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Type</th>
<th>index</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>0</td>
<td>&#34;some key&#34;</td>
</tr>
<tr>
<td>string</td>
<td>1</td>
<td>&#34;some value&#34;</td>
</tr>
<tr>
<td>string</td>
<td>2</td>
<td>&#34;some value&#34;</td>
</tr>
<tr>
<td>object</td>
<td>0</td>
<td>[string:0, string,1]</td>
</tr>
<tr>
<td>object</td>
<td>1</td>
<td>[string:1, string:0]</td>
</tr>
<tr>
<td>array</td>
<td>0</td>
<td>[object:0, object:0, object:1]</td>
</tr>
<tr>
<td>root</td>
<td>0</td>
<td>[string:2, array:0]</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">(3) We may encode custom scalar data types (e.g. timestamps) natively just by introducing new type tags.</p>
<p dir="auto">(4) We may even store polymorphic types by introducing new type tags or even new type references.</p>

<p dir="auto">Currently we provide C# and Scala implementations of SICK indexed binary JSON storage. Currently the code in this repository has no streaming capabilities. That may change in the future. It&#39;s not a hard problem to add streaming support, your contributions are welcome. It&#39;s harder to create a streaming abstraction which would cover enough usecases to be useful for broad audience.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Feature üîß</th>
<th>Scala üü£</th>
<th>C# üîµ</th>
<th>JS (ScalaJS) üü°</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binary Storage Encoder üíæ</td>
<td>‚úÖ</td>
<td>‚úÖ</td>
<td>‚úÖ</td>
</tr>
<tr>
<td>Binary Storage Decoder üì•</td>
<td>‚úÖ</td>
<td>‚úÖ</td>
<td>‚úÖ</td>
</tr>
<tr>
<td>Cursors üß≠</td>
<td>‚úÖ</td>
<td>‚úÖ</td>
<td>‚ùå</td>
</tr>
<tr>
<td>Stream Encoder üåä</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>‚ùå</td>
</tr>
<tr>
<td>Stream Decoder üåÄ</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>‚ùå</td>
</tr>
<tr>
<td>Encoder AST üå≥</td>
<td>Circe</td>
<td>JSON.Net</td>
<td>JS Objects/Json</td>
</tr>
<tr>
<td>Decoder AST üåø</td>
<td>Circe</td>
<td>Custom</td>
<td>JS Objects/Json</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">A type marker is represented as a single-byte unsigned integer. The possible values are:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Marker</th>
<th>Name</th>
<th>Comment</th>
<th>Value Length (bytes)</th>
<th>C# mapping</th>
<th>Scala Mapping</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>TNul</td>
<td>Equivalent to <code>null</code> in JSON</td>
<td>4, stored in the marker</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>TBit</td>
<td>Boolean</td>
<td>4, stored in the marker</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>TByte</td>
<td>Byte,</td>
<td>4, stored in the marker</td>
<td>byte (unsigned)</td>
<td>Byte (signed)</td>
</tr>
<tr>
<td>3</td>
<td>TShort</td>
<td>Signed 16-bit integer</td>
<td>4, stored in the marker</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>TInt</td>
<td>Signed 32-bit integer</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>TLng</td>
<td>Signed 64-bit integer</td>
<td>8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>TBigInt</td>
<td></td>
<td>Variable, prefixed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>TDbl</td>
<td></td>
<td>8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>TFlt</td>
<td></td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>TBigDec</td>
<td></td>
<td>Variable, prefixed</td>
<td>Custom: scale/precision/signum/unscaled quadruple in C#</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>TStr</td>
<td>UTF-8 String</td>
<td>Variable, prefixed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>TArr</td>
<td>List of array entries</td>
<td>Variable, prefixed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>TObj</td>
<td>List of object entries</td>
<td>Variable, prefixed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>TRoot</td>
<td>Index of the name string (4 bytes) + reference (4+1=5 bytes)</td>
<td>9</td>
<td></td>
<td></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">TODO</p>

<p dir="auto">TODO</p>

<p dir="auto">Array entries are just references.</p>

<p dir="auto">TODO</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Object entry skip list and KHash</h4><a id="user-content-object-entry-skip-list-and-khash" aria-label="Permalink: Object entry skip list and KHash" href="#object-entry-skip-list-and-khash"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">TODO</p>

<p dir="auto">TODO</p>

<p dir="auto">Current implementation has the following limitations:</p>
<ol dir="auto">
<li>Maximum object size: <code>65534</code> keys</li>
<li>The order of object keys is not preserved</li>
<li>Maximum amount of array elements: <code>2^32</code></li>
<li>Maximum amount of unique values of the same type: <code>2^32</code></li>
</ol>
<p dir="auto">These limitations may be lifted by using more bytes to store offset pointers and counts on binary level.
Though it&#39;s hard to imagine a real application which would need that, a large structure can always be split into smaller chunks at client side.</p>

<ol dir="auto">
<li>SICK is battle-tested and covered by &#34;good enough&#34; test suite which includes cross-implementation correctness tests (C#&lt;-&gt;Scala).</li>
<li>SICK powers several proprietary applications running on mobile devices and in the browser, some of which have large userbases (hundreds of thousands DAU).</li>
<li>No known open source users as of Oct/2025.</li>
<li>More implementations for various platforms are needed, 3rd party implementations are very welcome.</li>
</ol>
</article></div></div>
  </body>
</html>
