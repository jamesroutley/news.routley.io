<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jepsen.io/analyses/datomic-pro-1.0.7075">Original</a>
    <h1>Jepsen: Datomic Pro 1.0.7075</h1>
    
    <div id="readability-page-1" class="page"><p><a href="https://datomic.com">Datomic</a> is a temporal Entity-Attribute-Value OLTP database which supports non-interactive transactions on top of pluggable storage engines. It offers a variety of query mechanisms across thick and thin clients, including Datalog, graph traversal, and an ODM-style API. We evaluated Datomic Pro 1.0.7075 and found its inter-transaction safety properties appear stronger than claimed. Not only was every history Serializable, but sessions bound to a single peer appear Strong Session Serializable, and histories restricted to write transactions and reads using <code>d/sync</code> appear Strong Serializable. However, inside of a transaction Datomic behaves as if operations were evaluated concurrently. Depending on how one interprets those operations, this might violate three of the most widely accepted formalizations of Serializability, each of which specify serial intra-transaction semantics. It also creates the potential for invariant violations when composing transaction functions. Datomic has published a <a href="https://blog.datomic.com/2024/05/Jepsen-tests-Datomic.html">companion blog post</a> alongside this report. This work was funded by <a href="https://nubank.com.br/en/">Nubank</a> (Nu Pagamentos S.A), and conducted in accordance with the <a href="https://jepsen.io/ethics">Jepsen ethics policy</a>.</p><article>
  <div>

<p><a href="https://datomic.com">Datomic</a> is a general-purpose database intended for systems of record. In many ways, Datomic is unusual. At any instant in time, the state of the database is represented by a set of <code>[entity, attribute, value]</code> (<a href="https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model">EAV</a>) triples, known as <em>datoms</em>. Each datom declares that some <em>entity</em> (like a person) has a particular <em>attribute</em> (like a name) with a specific <em>value</em> (like “Vidrun”). The types and cardinality of attributes are controlled by a <a href="https://docs.datomic.com/pro/schema/schema.html">schema</a>.</p>
<p>Datomic is also a <a href="https://en.wikipedia.org/wiki/Temporal_database">temporal database</a>: it models time explicitly. Every transaction is identified by a <a href="https://docs.datomic.com/pro/glossary.html#t">strictly monotonic logical timestamp</a> <code>t</code>, as well as a wall-clock time <code>txInstant</code>. Transactions can <a href="https://docs.datomic.com/pro/glossary.html#assertion"><em>assert</em></a> a datom, adding it to the database, or they can <a href="https://docs.datomic.com/pro/glossary.html#retraction"><em>retract</em></a> a datom, removing it from the database. Every datom also retains a reference to the transaction that asserted or retracted it. A full datom is therefore a five-tuple of <code>[entity, attribute, value, transaction, asserted-or-retracted?]</code>. The database is an ever-growing set of these tuples.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Users can request a snapshot state of the database <a href="https://docs.datomic.com/pro/tutorial/history.html#asof-query">at any logical or wall-clock time</a>—right now or years in the past. They can also obtain a full <a href="https://docs.datomic.com/pro/tutorial/history.html#history-query">view of the database’s history</a>, allowing users to ask questions like “was there ever a time when Janelle Monáe and Cindi Mayweather were recorded in the same room together?”</p>
<p>Given a state of the database, users may query it via a <a href="https://docs.datomic.com/pro/query/query.html">Datalog-style API</a>, a <a href="https://docs.datomic.com/pro/query/pull.html">declarative graph traversal API</a>, or an <a href="https://docs.datomic.com/pro/overview/entities.html">ODM-style <code>Entity</code> datatype</a> which allows lazy access to an entity’s associated values, including other entities.</p>
<p>Datomic comes in two flavors. In this report we discuss <a href="https://www.datomic.com/index.html">Datomic Pro</a>, which anyone can run on their own computers. <a href="https://www.datomic.com/details.html">Datomic Cloud</a> runs in AWS and uses a <a href="https://docs.datomic.com/cloud/whatis/architecture.html">somewhat different architecture</a>.</p>
<h2 data-number="1.1" id="architecture"> Architecture</h2>
<p>Datomic Pro comprises several <a href="https://docs.datomic.com/pro/overview/architecture.html">co-operating services</a>. <em>Transactors</em> execute write transactions, maintain indices, and write data to storage. <em>Peers</em> are thick clients: they embed a JVM library which submits transactions to transactors, executes read queries against storage, and caches results. For applications written in other languages, Datomic also has a traditional client-server model. <em>Clients</em> are thin clients which forward transactions and queries to a <em>peer server</em>: a peer which runs a small network API.</p>
<p>Internally, Datomic <a href="https://docs.datomic.com/pro/transactions/acid.html#how-it-works">appends each transaction</a> to the <a href="https://docs.datomic.com/pro/query/indexes.html#log"><em>log</em></a>: a time-ordered set of transactions. From the log Datomic maintains <a href="https://docs.datomic.com/pro/query/indexes.html">four indices</a> sorted by different permutations of entity, attribute, value, and time. These indices allow efficient queries like “which entities were modified yesterday,” or “who run the world?”<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>Both log and indices are stored as persistent, immutable trees in a data store like <a href="https://docs.datomic.com/pro/overview/storage.html">Cassandra or DynamoDB</a>. Because tree nodes are immutable, their backing storage only needs to guarantee eventual consistency. A small pointer to the roots of these trees provides a consistent, immutable snapshot of the database’s state. To commit a transaction, a transactor saves new immutable tree nodes to storage, then executes a compare-and-set (CaS) operation to advance the root pointer. This CaS operation must execute under <a href="https://jepsen.io/consistency/models/sequential">Sequential</a> consistency.</p>
<p>Using a Sequential CaS operation ensures a global order of transactions, and limits Datomic’s write throughput to the speed of a single transactor. To reduce contention, Datomic tries to have a <a href="https://docs.datomic.com/pro/operation/ha.html">single active transactor</a> at all times. Operators typically deploy multiple transactors for fault tolerance.</p>
<p>Peers connect directly to storage, and also to transactors. Transactions are forwarded to an active transactor, which executes them. Each peer also maintains a local, monotonically-advancing copy of the root pointer, which allows the peer to read tree nodes from storage. Since tree nodes are immutable, they can be trivially cached. There may be any number of peers, allowing near-linear read scalability.</p>
<h2 data-number="1.2" id="transaction-model"> Transaction Model</h2>
<p>Datomic has an unusual transaction model. Most OLTP databases offer interactive transactions: one begins a transaction, submits an operation, receives results from that operation, submits another, and so on before finally committing. Some databases, like <a href="https://docs.voltdb.com/UsingVoltDB/DesignProcAnatomy.php">VoltDB</a>, use stored procedures: an operator writes a small program which is installed in the database. Clients invoke that program by name, which mutates database state and returns values to the client. Other databases like <a href="https://fauna.com/fql">FaunaDB</a> allow clients to directly submit miniature programs as text or an abstract syntax tree. Like stored procedures, these programs perform arbitrary reads and writes, mutate state, and return data to the user.</p>
<p>Datomic does something rather different. It enforces a strict separation between read and write paths. There are no interactive transactions. It has stored procedures, but they cannot return values to the caller.</p>
<p>A read obtains an immutable state of the entire database. For instance, the <a href="https://docs.datomic.com/pro/clojure/index.html#datomic.api/db"><code>db</code></a> function returns the most recent database state<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> the peer is aware of. To obtain the most recent state across all peers, or a state later than a given time, one calls <a href="https://docs.datomic.com/pro/clojure/index.html#datomic.api/sync"><code>d/sync</code></a>. To obtain a state from a past time (seconds or years ago), one calls <a href="https://docs.datomic.com/pro/tutorial/history.html#asof-query">d/as-of</a>. These states are cheap, highly cacheable, and never block other writers or readers.</p>
<p>Given a database state, one can run any number of queries using (e.g.) <a href="https://docs.datomic.com/pro/clojure/index.html#datomic.api/q"><code>q</code></a> or <a href="https://docs.datomic.com/pro/clojure/index.html#datomic.api/pull"><code>pull</code></a>. Queries lazily fetch datoms from cache or storage. Since database states are immutable, any number of queries run against the same state occur at the exact same logical time. In this sense, all queries run on the same state take place in a single atomic transaction—even two queries executed on different machines, months apart.</p>
<p>Write transactions<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> are represented as an ordered list of <a href="https://web.archive.org/web/20240129122139/https://docs.datomic.com/pro/transactions/transactions.html#transaction-structure">operations</a>.<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<blockquote>
<p>A transaction is simply a list of lists and/or maps, each of which is a statement in the transaction.</p>
</blockquote>
<p>For example, here is a transaction of three operations, all involving entity <code>123</code>:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>[[<span>:db/add</span> <span>123</span> <span>:person/name</span> <span>&#34;N. K. Jemisin&#34;</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a> [<span>:db/cas</span> <span>123</span> <span>:author/hugo-count</span> <span>2</span> <span>3</span>]]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a> [<span>:author/add-book</span> <span>123</span> <span>&#34;The Stone Sky&#34;</span>]]</span></code></pre></div>
<p>Those operations may be simple assertions (<code>:db/add</code>) or retractions <code>(:db/retract)</code> of datoms, or they may be calls to <a href="https://docs.datomic.com/pro/transactions/transaction-functions.html">transaction functions</a>: either built-in or user-defined. In this example, the built-in <a href="https://docs.datomic.com/pro/transactions/transaction-functions.html#dbfn-cas"><code>db/cas</code></a> function performs a CaS operation, asserting the number of Hugo awards for this author is 3 if and only if that number is currently 2. One can also <a href="https://docs.datomic.com/pro/reference/database-functions.html#using-transaction-functions">store a function</a> (represented as a Clojure AST or <a href="https://docs.datomic.com/pro/clojure/index.html#datomic.api/function">Java string</a>) in the database just like any other value. Alternatively, one may write a function in any JVM language, and provide it in a <code>jar</code> file on the transactor’s <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/classpath.html">classpath</a>. Once a function has been installed, any transaction may invoke it by providing the function’s name and arguments. Here, the <code>author/add-book</code> function receives the state of the database as of the start of the transaction, as well as any arguments from the transaction. It can perform arbitrary (pure) computation, including running queries against the database state. It then returns a new set of operations for the transaction—for instance, assertions, retractions, or calls to other functions. Function calls are recursively expanded until only assertions and retractions remain.</p>
<p>While transaction functions can make decisions based on the results of reads they perform internally, there is no channel to return those reads (or other information) to the caller of <code>transact</code>. Transactions <em>only</em> return effects. This means there is no direct analogue for an arbitrary read-write transaction in Datomic! For example, you can write a function which performs a conditional write,<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a> but you can’t inform the caller whether the write took place or not. This constraint nudges Datomic users towards pulling reads out of the write transaction path—a key factor in obtaining good performance from a system which can logically execute only one write transaction at a time.</p>
<p>Instead of offering arbitrary return values from transactions, every call to <code>transact</code> returns the database state just before the transaction, the database state the transaction produced, and the set of datoms the transaction expanded to. This allows callers to execute read-write transactions by splitting them in twain: they submit a transaction which performs some writes, then use the pre-state of the database to determine what data that transaction would have read. Peers can also examine the post-state and set of datoms produced by the transaction to (e.g.) determine whether a conditional write took place.</p>
<p>From the perspective of traditional database systems, this sounds absurd. Mixed read-write transactions are a staple of OLTP workloads—how could you get anything done without them? Datomic offers a view of an alternate universe: one where database snapshots are cheap, efficient, and can be passed from node to node with just a timestamp. From this point of view, other databases feel impoverished. What do you mean, Postgres can’t give you the state of the entire database a transaction observed? The lack of a return channel for transaction functions may be annoying, but Datomic’s other strengths generally allow it to solve the same kinds of problems as a traditional, interactive transaction system. For example, NuBank (Datomic’s current developers) offers financial services to nearly 94 million users, processing an average of 2.3 billion user transactions per day. Almost all of their products use Datomic as a system of record.</p>
<h2 data-number="1.3" id="consistency"> Consistency</h2>
<p>Datomic advertises <a href="https://docs.datomic.com/pro/transactions/transactions.html">ACID transactions</a> and means it: their <a href="https://docs.datomic.com/pro/transactions/acid.html">ACID documentation</a> makes detailed, specific promises with respect to consistency models and durability guarantees. Transactions are “written to storage in a single atomic write,” which precludes intermediate read anomalies. Every peer “sees completed transactions as of a particular point in time,” and observes <em>all</em> transactions, totally ordered, up to that time. Transactions are always flushed to durable storage before client acknowledgement.</p>
<p>When our analysis began in early January 2024, Datomic’s documentation <a href="https://web.archive.org/web/20231208204951/docs.datomic.com/pro/transactions/acid.html#isolation">informally claimed</a> write transactions were <a href="https://jepsen.io/consistency/models/serializable">Serializable</a>:</p>
<blockquote>
<p>The Isolation property ensures that concurrent transactions result in the same system state that would result if the transactions were executed serially.</p>
</blockquote>
<p>Since write transactions are Serializable and execute atomically, and since read-only queries execute against committed snapshots, it seems plausible that histories of both read and write transactions should also be Serializable.<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>Serializability does not impose <a href="https://jepsen.io/consistency/models/strict-serializable">real-time</a> or <a href="https://cs.uwaterloo.ca/~kmsalem/pubs/DaudjeeICDE04.pdf">session</a> ordering constraints: in a Serializable system, it is legal for a client to execute a transaction which inserts object <span><em>x</em></span>, then execute a second transaction which fails to observe <span><em>x</em></span>. While Datomic’s documentation does not make this claim, it seems plausible that Datomic’s transactor design might provide <a href="https://jepsen.io/consistency/models/strict-serializable">Strong Serializability</a> over write transactions, preventing real-time anomalies.</p>
<p>Since <code>d/db</code> returns an asynchronously updated <a href="https://docs.datomic.com/pro/transactions/client-synchronization.html">copy of the database</a>, we expect peers to observe stale reads. Indeed, Datomic is explicit that peer reads may not observe some recently committed transactions. However, it would be straightforward for peers to ensure that their time basis advances monotonically; if we say that every session is bound to a single peer node, we would expect to observe <a href="https://dbmsmusings.blogspot.com/2019/06/correctness-anomalies-under.html">Strong Session Serializable</a> histories.</p>
<p>In addition to these possible realtime and session constraints, Datomic has multiple synchronization mechanisms. Clients can <a href="https://docs.datomic.com/pro/transactions/client-synchronization.html">block until they observe</a> a value of the database at or later than some time <code>t</code>. This enables clients to ensure consistency when threading state through side channels. Calling <a href="https://docs.datomic.com/pro/clojure/index.html#datomic.api/sync"><code>d/sync</code></a> forces the client to synchronize with the transactor, preventing stale reads. We expect histories which always use <code>d/sync</code> to be Strict Serializable as well.</p>
<p>Datomic’s documentation also described it as a “<a href="https://web.archive.org/web/20231208204951/https://docs.datomic.com/pro/transactions/acid.html#isolation">single-writer</a>” system:</p>
<blockquote>
<p>A single thread in a single process is responsible for writing transactions. The Isolation property follows automatically from this, because there are no concurrent transactions. Transactions are always executed serially.</p>
</blockquote>
<p>This is wrong in two senses. First, Datomic is fault-tolerant: one can and should run several transactor nodes on different computers. Typically one transactor is active and the others are in standby. When a transactor’s <a href="https://docs.datomic.com/pro/operation/ha.html#enabling">failure detector</a> believes there is no active transactor, it will attempt to promote itself to active. However, <a href="https://www.cs.utexas.edu/~lorenzo/corsi/cs380d/papers/p225-chandra.pdf">perfect failure detectors are impossible</a> in asynchronous networks. There may be times when a standby transactor believes it should take over, but another active transactor is still running. This means transactions may actually execute concurrently. During this window Datomic is not a single-writer system, but a multi-writer one!</p>
<p>Second, even if there were a perfect failure detector which ensured a single Datomic transactor at a time, its messages to storage could be arbitrarily delayed by the network and arrive interleaved with messages from other transactors. Thankfully this doesn’t matter: Datomic’s safety property follows directly from the Sequential consistency of the storage system’s <a href="https://docs.datomic.com/pro/transactions/acid.html#implications">CaS operation</a>. Any number of concurrent transactors ought to be safe.</p>

<p>We designed a <a href="https://github.com/jepsen-io/datomic/tree/7997e678a1925d2c3a576a728a63bc29a1b1812c">test suite for Datomic</a> using the <a href="https://github.com/jepsen-io/jepsen">Jepsen testing library</a>. Our test <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/db.clj#L54-L69">installed Datomic Pro</a> 1.0.7075 on a cluster of Debian Bookworm nodes. For storage, it provisioned a <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/db/storage.clj#L40-L43">DynamoDB table</a> in AWS. Two of the test nodes ran transactors, and the remaining nodes ran peers.</p>
<p>Our peers were <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer.clj">small Clojure programs</a> which used the <a href="https://docs.datomic.com/pro/peer/peer-introduction.html">Datomic peer library</a>. They connected to storage and transactors and exposed a <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer.clj#L96-L114">small HTTP API</a> for performing test suite operations. For each operation the test <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/client.clj#L44-L66">used an HTTP client</a> to submit that operation to some peer. The peer executed that operation using the peer library, and returned a result to the client. We ran our workloads both using <code>d/db</code>, which may yield stale reads, and also with <code>d/sync</code>, which blocks but guarantees recency.</p>
<p>Our test harness <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/nemesis.clj">injected faults</a> into both transactors and peers, including process pauses, crashes, and clock errors. We created network partitions between nodes (including both transactors and peers) and between nodes and the storage system. We also requested Datomic perform garbage collection.</p>
<p>Datomic transactors kill themselves when they cannot maintain a stable connection to storage. When we ran transactors with the default 5-second timeout settings on nodes outside AWS, transactors routinely killed themselves every few minutes due to normal network fluctuations. With a 1-second timeout, even transactors running in our EC2 test environment would kill themselves roughly every 10–20 minutes. To work around this, Datomic advises that operators run their own supervisor daemons to restart transactors. We used a <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/resources/transactor.service">systemd service</a> with <code>Restart=on-failure</code>.</p>
<p>Our test suite included four workloads.</p>
<h2 data-number="2.1" id="list-append"> List Append</h2>
<p>We designed an <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/workload/append.clj#L31-L42">append workload</a> for use with the <a href="https://github.com/jepsen-io/elle">Elle transaction checker</a>. Logically, this workload operates over lists of integer elements, with each list identified by an integer primary key. Clients perform transactions comprising random operations. Each operation may read the current value of a list, or append a unique element to the end of a list. Elle then performs a broad array of checks on the history of transactions. It looks for aborted and intermediate reads, violations of internal consistency, and inconsistent orders of elements across different reads of a list. From the element orders, it infers write-write, write-read, and read-write dependencies between transactions. From the order of transactions on each logical process, and the global order of transactions, it infers per-process and real-time orders, respectively. Elle then searches for cycles in the resulting dependency graphs. Various cycles correspond to violations of different consistency models, like Strict Serializability.</p>
<p>We encoded our lists in Datomic <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L9-L18">as follows</a>. Each list was represented by a single entity with two attributes. One, <code>append/key</code>, served as the primary key. The other, <code>append/elements</code>, was a many-valued attribute which stored all the integer elements in a given list.</p>
<p>Performing the writes in a transaction was straightforward: given a write, we emitted <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L85-L88">a single operation</a> for the transaction stating that the given key now had that element: <code>{:append/key k, :append/elements element}</code>. To perform a read of <code>k</code>, we <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L85-L88">read a local cache of <code>k</code>’s elements</a>. We populated that cache with an <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L68-L72">initial series of read queries</a>, then used a <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L77-L90">small state machine</a> to simulate internal reads.</p>
<p>Note that multi-valued attributes represent an unordered <em>set</em>, not an ordered list. Elle’s inference uses the order of list elements to infer the serialization order of transactions. To obtain this order, we took advantage of the fact that Datomic is a temporal database: every datom includes a reference to the transaction which wrote it. When we read the elements for a given key, we also <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L24-L31">included their corresponding transactions</a>. We then <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L37">sorted the elements</a> by transaction times, which provides exactly the order Elle needs.</p>
<p>Elle’s list-append workload is designed for databases which offer mixed read-write transactions, but Datomic doesn’t have this concept. As previously mentioned, any read-write transaction can be expressed in Datomic by running the writes in a transaction function, then using the returned database state to determine what the transaction’s reads would have been. We used this technique in our workload: a <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L40">single function</a> executes the transaction, simulates internal reads, and produces side effects (for the write transaction) and completed reads (to be returned to the client). We execute this function twice: <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L139">once using a stored procedure via <code>transact</code></a>, then a second time on the peer to <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append.clj#L144">fill in reads</a>, using the pre-state of the database <code>transact</code> returned.</p>
<h2 data-number="2.2" id="list-append-with-cas"> List Append with CaS</h2>
<p>Many Datomic users use the built-in compare-and-set function <a href="https://docs.datomic.com/pro/transactions/transaction-functions.html#dbfn-cas"><code>db/cas</code></a> to control concurrent updates to an attribute of an entity outside a transaction. For example, they might read the current DB state using <code>d/db</code>, read the value of a counter as <code>4</code>, then increment the counter’s value using <code>[:db/cas 123 :counter/value 4 5]</code>. The CaS function asserts the new value 5 if and only if the current value is 4.</p>
<p>Datomic guarantees transactions are always Serializable, but a user might want to express a logical “user transaction” consisting of a read followed by a separate write transaction. Since Datomic database states are always complete snapshots, and transactions are Serializable, using <code>db/cas</code> for every write<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a> allows users to build an ad hoc <a href="https://jepsen.io/consistency/models/snapshot-isolation">Snapshot Isolation</a> over these user transactions.</p>
<p>Our <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/workload/append_cas.clj">append-cas</a> workload provides the same logical API as the list-append workload, but uses this CaS pattern to ensure Snapshot Isolation. Instead of multi-valued elements, we encoded each list <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append_cas.clj#L12-L21">as a single-valued, comma-separated string</a>. We <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append_cas.clj#L142-L143">performed a read</a> at the start of each transaction, <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append_cas.clj#L102-L122">applied reads and writes locally</a>, maintaining a buffer of written values, then <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/append_cas.clj#L81-L95">constructed a transaction</a> of CaS operations which ensured that any values we wrote had not been modified since they were read.</p>
<h2 data-number="2.3" id="internal"> Internal</h2>
<p>Our two list-append workloads measured safety between transactions, but because they simulated the results of internal reads, they did not measure Datomics intra-transaction semantics. We designed an <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/workload/internal.clj">internal</a> workload which measures internal consistency with a <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/workload/internal.clj#L129-L270">suite of hand-crafted transactions</a>. For instance, we assert that the value for some attribute of an entity is 1, then 2. We assert and retract a fact in the same transaction. We assert a value, then try to CaS it to something else. We perform multiple CaS operations—trying to change 1 to 2, then 2 to 3. We create an entity, then modify it using a <a href="https://docs.datomic.com/pro/schema/identity.html#lookup-refs">lookup ref</a>. Using a transaction function, we attempt to increment a value twice, and so on.</p>
<h2 data-number="2.4" id="grant"> Grant</h2>
<p>To ensure that transaction functions preserved function invariants, we designed a <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/workload/grant.clj#">grant</a> workload which simulates a simple state machine using transaction functions. Grants are first created, then can either be approved or denied. We <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/grant.clj#L11-L23">encode a grant</a> as a single entity with three attributes: <code>created-at</code>, <code>approved-at</code>, and <code>denied-at</code>.</p>
<p>No grant should be <em>both</em> approved and denied. We ensure this invariant by writing a <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/grant.clj#L89-L99">pair of transaction functions</a> <code>approve</code> and <code>deny</code>. Each first checks that the grant under consideration has not been approved or denied already, aborting the transaction if necessary. If the grant hasn’t been approved or denied yet, <code>approve</code> adds the grant’s <code>approved-at</code> date. Our <code>deny</code> function works the same way.</p>
<p>Our grant workload creates a new grant in one transaction. In subsequent transactions it tries to approve and/or deny the grant. We repeat this process, exploring <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/workload/grant.clj#L109-L112">different combinations</a> of functions and transaction boundaries. We check to make sure that no grant is <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/src/jepsen/datomic/workload/grant.clj#L84-L104">both approved and denied</a>.</p>

<p>We found no behavior which violated Datomic’s core safety claims. Transactions appeared to execute as if they had been applied in a total order, and that order was consistent with the local order of operations on each peer. Histories restricted to just those transactions performing writes, and histories in which reads used <code>(d/sync conn)</code> to obtain a current copy of the database, were consistent with real-time order.</p>
<p>However, we did observe unusual behavior within transactions. This intra-transaction behavior is generally consistent with Datomic’s documentation, but it represents a significant departure both from typical database behavior and the major formalisms used to model transactional isolation. We discuss those divergences here.</p>
<h2 data-number="3.1" id="internal-consistency"> Internal Consistency</h2>
<p>Virtually all databases and formalisms Jepsen is familiar with provide serial execution semantics within a transaction. For example, a transaction like <code>set x = 1; read x;</code> would print <code>1</code>, rather than the value of <code>x</code> when the transaction started.</p>
<p>Although Datomic transactions are <a href="https://docs.datomic.com/pro/transactions/transactions.html#transaction-structure">ordered lists of operations</a>, Datomic does not preserve this order in execution. Instead, all operations within a transaction (adds, retracts, and transaction functions) are executed as if they were concurrent with one another. Transaction functions always observe the state of the database at the beginning of the transaction. They do not observe prior assertions, retractions, or transaction functions. For example, consider <a href="https://s3.amazonaws.com/jepsen.io/analyses/datomic-pro-1.0.7075/internal.zip">these results</a> from our internal workload. Imagine entity <code>123</code> currently has an <code>:internal/value</code> of <code>0</code>, and we execute the following transaction:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>[[<span>:db/cas</span> <span>123</span> <span>:internal/value</span> <span>0</span> <span>1</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a> [<span>:db/cas</span> <span>123</span> <span>:internal/value</span> <span>0</span> <span>1</span>]]</span></code></pre></div>
<p>In a serial execution model, this transaction would fail: the first CaS would alter the value of key <code>123</code> from <code>0</code> to <code>1</code>, and the second CaS would fail, since the current value was <code>1</code> and not <code>0</code>. In Datomic, both CaS operations observe the initial state <code>0</code>, and both succeed. They produce a pair of redundant assertions <code>[:db/add 123 :interval/value 1]</code>, and the value of entity <code>123</code> becomes <code>1</code>.</p>
<p>This means that state transitions may not compose as one expects. For instance, here is a transaction function that <a href="https://github.com/jepsen-io/datomic/blob/7997e678a1925d2c3a576a728a63bc29a1b1812c/peer/src/jepsen/datomic/peer/internal.clj#L33-L37">increments the value</a> of the entity with key <code>k</code>:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>(<span>defn</span><span> increment</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  [db k]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  (<span>let</span> [{<span>:keys</span> [id value]} (<span>read</span> db k)]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    [[<span>:db/add</span> id <span>:internal/value</span> (<span>inc</span> value)]]))</span></code></pre></div>
<p>What value does the following transaction produce, given an entity with key <code>&#34;x&#34;</code> and value <code>0</code>?</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>[[<span>&#39;internal/increment</span> <span>&#34;x&#34;</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a> [<span>&#39;internal/increment</span> <span>&#34;x&#34;</span>]]</span></code></pre></div>
<p>In a serial model, the result of two increments would be <code>2</code>. In Datomic, it’s <code>1</code>: both <code>increment</code> functions receive the database state from the start of the transaction. Similarly, transaction functions do not observe lexically prior assertions or retractions.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>[[<span>:db/add</span> id-of-x <span>:internal/value</span> <span>1</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a> [<span>&#39;internal/increment</span> <span>&#34;x&#34;</span>]]</span></code></pre></div>
<p>This produces a final value of <code>1</code>, not <code>2</code>.</p>
<p>Likewise, <a href="https://docs.datomic.com/pro/schema/identity.html#lookup-refs">lookup refs</a> use the state of the database as of the start of the transaction. This means a transaction which adds an entity cannot use a lookup ref to refer to it later in that same transaction. The following transaction aborts with an <code>Unable to resolve entity</code> message:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>[<span>; Create an entity with key &#34;x&#34;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a> [<span>:db/add</span> <span>&#34;x&#34;</span> <span>:internal/key</span> <span>&#34;x&#34;</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a> <span>; And set the value of the entity with key x</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a> <span>; to 0:</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a> [<span>:db/add</span> [<span>:internal/key</span> <span>&#34;x&#34;</span>] <span>:internal/value</span> <span>0</span>]]</span></code></pre></div>
<p>Many of the above transactions included multiple assertion requests with the same entity, attribute, and value. What happens if the values conflict? Imagine this transaction executes on a state where <code>x</code>’s value is <code>0</code>.</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>[[<span>:db/add</span> id-of-x <span>:internal/value</span> <span>2</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a> [<span>&#39;internal/increment</span> <span>&#34;x&#34;</span>]]</span></code></pre></div>
<p>In a database with serial intra-transaction semantics, this would produce the value <code>3</code>. In Datomic, the increment observes the start-of-transaction value <code>0</code>. It completes successfully, and the transaction expands to the following:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>[[<span>:db/add</span> id-of-x <span>:internal/value</span> <span>2</span>]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a> [<span>:db/add</span> id-of-x <span>:internal/value</span> <span>1</span>]]</span></code></pre></div>
<p>If this were executed by a serial database, it would produce the value <code>1</code>. But Datomic’s order-free semantics have another rule we have not yet discussed. If two assertions in the same transaction have different values for the same single-cardinality attribute of the same entity, the transaction aborts with <code>:db.error/datoms-conflict</code>. This transaction aborts!</p>
<p>This in-transaction conflict detection mechanism likely rules out many cases where the use of transaction functions would produce surprising results. A pair of increments will silently produce a single increment, but this is only possible because they all expand to compatible <code>[entity, attribute, value]</code> triples. Since there are an infinite number of incompatible values, and a single compatible choice for any <code>[entity, attribute]</code> pair, it seems likely that users who accidentally compose transaction functions incorrectly will find their transactions fail due to conflicts, and recognize their mistake.</p>
<p>This behavior may be surprising, but it is generally consistent with Datomic’s documentation. Nubank does not intend to alter this behavior, and we do not consider it a bug.</p>
<h2 data-number="3.2" id="pseudo-write-skew"> Pseudo Write Skew</h2>
<p>The fact that transactions appear to execute in serial, but the operations <em>within</em> a transaction appear to execute concurrently, creates an apparent paradox. A set of transaction functions might be correct when executed in separate transactions, but <em>incorrect</em> when executed in the same transaction! While Datomic’s in-transaction conflict checker prevents conflicts on a (single-cardinality) <code>[entity, attribute]</code> pair, it does nothing to control concurrency of functions which produce disjoint <code>[entity, attribute]</code> pairs.</p>
<p>We designed the grant workload to illustrate this scenario. Following the <a href="https://web.archive.org/web/20231208204951/https://docs.datomic.com/pro/reference/database-functions.html#uses-for-transaction-functions">documentation’s advice</a> that transaction functions “can atomically analyze and transform database values,” and can be used to “ensure atomic read-modify-update processing, and integrity constraints,” we wrote a pair of transaction functions <code>approve</code> and <code>deny</code>. These functions encode the two legal state transitions for a single grant.</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>(<span>defn</span><span> approved?</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  <span>&#34;Has a grant been approved?&#34;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  [db id]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  (<span>-&gt;</span> &#39;{<span>:find</span>  [?t]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>        <span>:in</span>    [$ ?id]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>        <span>:where</span> [[?id <span>:grant/approved-at</span> ?t]]}</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>      (d/q db id)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>      <span>count</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>      <span>pos?</span>))</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>(<span>defn</span><span> ensure-fresh</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  <span>&#34;Throws if the given grant ID</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a><span>  is approved or denied.&#34;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  [db id]</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>  (<span>when</span> (approved? db id)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>    (throw+ {<span>:type</span> <span>:already-approved</span>}))</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>  (<span>when</span> (denied? db id)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>    (throw+ {<span>:type</span> <span>:already-denied</span>})))</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a>(<span>defn</span><span> approve</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a>  <span>&#34;Approves a grant by ID. Ensures the</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a><span>  grant has not been approved or denied.&#34;</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true"></a>  [db id]</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true"></a>  (ensure-fresh db id)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true"></a>  [[<span>:db/add</span> id <span>:grant/approved-at</span> (Date.)]])</span></code></pre></div>
<p>The <code>denied?</code> and <code>deny</code> functions are identical to <code>approved?</code> and <code>approve</code>, except they use the <code>denied-at</code> attribute; we omit them for brevity.</p>
<p>By ensuring that the given grant ID is fresh (i.e. neither approved nor denied), these functions ensure an important invariant: no sequence of <code>approve</code> and/or <code>deny</code> calls can produce a grant which is both approved and denied. And indeed, Datomic’s Serializable transactions guarantee this invariant holds—so long as calls to <code>approve</code> and <code>deny</code> only ever take place in <em>different</em> transactions.</p>
<p>However, if a single transaction happens to call both <code>approve</code> and <code>deny</code>, <a href="https://s3.amazonaws.com/jepsen.io/analyses/datomic-pro-1.0.7075/grant.zip">something very interesting occurs</a>:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>[[<span>&#39;grant/approve</span> id]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a> [<span>&#39;grant/deny</span> id]]</span></code></pre></div>
<p>This transaction produces a grant with the following state:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>{<span>:db/id</span>             <span>17592186045426</span>,</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a> <span>:grant/created-at</span>  #inst <span>&#34;2024-02-01...&#34;</span>,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a> <span>:grant/denied-at</span>   #inst <span>&#34;2024-02-01...&#34;</span>,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a> <span>:grant/approved-at</span> #inst <span>&#34;2024-02-01...&#34;</span>}</span></code></pre></div>
<p>This grant is both approved and denied at the same time. Our invariant has been violated! Datomic’s in-transaction conflict checker did not prevent this behavior because the <code>approve</code> and <code>deny</code> functions returned assertion requests for disjoint <code>[entity, attribute]</code> pairs.</p>

<p>If we were to draw a data dependency graph between these two functions using the language of <a href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Adya’s formalism</a>, we’d see something like the following:</p>

<p>The <code>approve</code> function wrote a new version of the grant’s <code>approved-at</code> attribute, but when <code>deny</code> read that attribute, it observed the previous (unborn) version from the start-of-transaction database state. This is analogous to a read-write (<code>rw</code>) anti-dependency edge in Adya’s Direct Serialization Graph. Symmetrically, <code>deny</code> wrote a new version of the grant’s <code>denied-at</code> attribute, but <code>approve</code> saw the previous unborn version of <code>denied-at</code>. This gives rise to a dependency cycle: each transaction function failed to observe the other’s effects.</p>
<p>If these <code>approve</code> and <code>deny</code> boxes were transactions, we’d call this cycle G2-item: an isolation anomaly proscribed by <a href="https://jepsen.io/consistency/models/repeatable-read">Repeatable Read</a> and Serializability. Indeed, this phenomenon is analogous to a concurrency anomaly <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">Berenson et al called</a> called Write Skew:</p>
<blockquote>
<p>Suppose <code>T1</code> reads x and y, which are consistent with C(), and then a <code>T2</code> reads x and y, writes x, and commits. Then <code>T1</code> writes y. If there were a constraint between x and y, it might be violated.</p>
</blockquote>
<p>There are some similarities between the inter-transaction concurrency control of Berenson et al’s Snapshot Isolation and the intra-transaction concurrency control of Datomic’s end-of-transaction conflict checker. When the write sets (assertion requests) of two transactions (transaction functions) intersect on some object (an entity and cardinality-one attribute), the first-committer-wins principle (conflict checker) prevents concurrent execution by forcing an abort. When their write sets are disjoint, invariants preserved by two transaction functions individually may be violated by the transaction as a whole.</p>
<p>Like the internal consistency findings above, this behavior may be surprising, but it is broadly consistent with Datomic’s documentation. Nubank intends to preserve Datomic’s concurrent intra-transaction semantics. We consider this expected behavior for Datomic, rather than a bug.</p>
<h2 data-number="3.3" id="entity-predicates"> Entity Predicates</h2>
<p>From Datomic’s point of view, the grant workload’s invariant violation is a matter of user error. Transaction functions do not execute atomically in sequence. Checking that a precondition holds in a transaction function is unsafe when some other operation in the transaction could invalidate that precondition!</p>
<p>However, Datomic offers a <a href="https://docs.datomic.com/pro/transactions/transaction-functions.html#when-to-use">suite</a> of constraints for enforcing database invariants, including type, uniqueness, and arbitrary predicates on specific attributes. One of the most general constraints is an <a href="https://docs.datomic.com/pro/schema/schema.html#entity-predicates">entity predicate</a>.</p>
<p>Entity predicates are functions which receive a candidate state of the database with all transaction effects applied, the ID of an entity, and return <code>true</code> if the transaction should be allowed to commit that state. “Entity” is something of a misnomer: these predicates have access to the <em>entire</em> state of the database, and can therefore enforce arbitrary global constraints, not just those scoped to a particular entity.</p>
<p>We can use entity predicates to ensure grants are never approved and denied. To start, we write an entity predicate function <code>valid-grant?</code>.</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>(<span>defn</span><span> valid-grant?</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  [db eid]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  (<span>let</span> [{<span>:grant/keys</span> [approved-at denied-at]}</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>        (d/pull db &#39;[<span>:grant/approved-at</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>                     <span>:grant/denied-at</span>]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>                   eid)]</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>   (<span>not</span> (<span>and</span> approved-at denied-at))))</span></code></pre></div>
<p>Then we add an <a href="https://docs.datomic.com/pro/schema/schema.html#entity-specs">entity spec</a> to the schema which references that function.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>(<span>def</span><span> schema</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a> [...</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  {<span>:db/ident</span>        <span>:grant/valid</span>?</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>   <span>:db.entity/preds</span> [<span>&#39;grant/valid-grant?</span>]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>   <span>:db/doc</span>          <span>&#34;Ensures the given grant</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span>                     is not approved *and*</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span>                     denied&#34;</span>}])</span></code></pre></div>
<p>Unlike other schema constraints, which are enforced for every transaction, entity specs (and their associated entity predicates) are only enforced when transactions explicitly ask for them. Datomic believes that whether or not to enforce an entity spec is a domain decision, and that this approach is more flexible than making entity specs mandatory. Therefore our transition functions assert the grant’s <code>approved-at</code> or <code>denied-at</code> attribute, then <a href="https://github.com/jepsen-io/datomic/blob/0af5c0d5a2e9fdb5baee54378f64c1cc0f496ac0/peer/src/jepsen/datomic/peer/grant.clj#L99-L115">request the entity spec be enforced</a> by adding a special request for a <em>virtual datom</em>, binding the attribute <code>:db/ensure</code> to our entity spec.</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>(<span>defn</span><span> approve</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  [db id]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  [[<span>:db/add</span> id <span>:grant/approved-at</span> (Date.)]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>   [<span>:db/add</span> id <span>:db/ensure</span> <span>:grant/valid</span>?]])</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>(<span>defn</span><span> deny</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>  [db id]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>  [[<span>:db/add</span> id <span>:grant/denied-at</span> (Date.)]</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>   [<span>:db/add</span> id <span>:db/ensure</span> <span>:grant/valid</span>?]])</span></code></pre></div>
<p>Using this entity spec, attempts to approve and deny a grant within the same transaction <a href="https://s3.amazonaws.com/jepsen.io/analyses/datomic-pro-1.0.7075/grant-entity-pred.zip">throw an error</a>, preserving our intended invariant.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>{<span>:cognitect.anomalies/category</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a> <span>:cognitect.anomalies/incorrect</span>,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a> <span>:cognitect.anomalies/message</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a> <span>&#34;Entity 17592186045427 failed pred</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span>  #&#39;jepsen.datomic.peer.grant/valid-grant?</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a><span>  of spec :grant/valid?&#34;</span>,</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  <span>:db.error/pred-return</span> <span>false</span>,</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>  <span>:db/error</span> <span>:db.error/entity-pred</span>}</span></code></pre></div>

<p>In our testing, Datomic’s inter-transaction semantics were consistent with Strong Session Serializability. Intra-transaction semantics appeared strictly concurrent: the operations within a transaction seemed to be executed simultaneously, and the resulting effects merged via set union. This combination satisfies a common high-level definition of Serializability: “equivalence to a serial execution of transactions.” However, it does seem to violate the definitions of Serializability in the most broadly-adopted academic formalisms for transactional isolation. Datomic argues—and Jepsen is willing to entertain—that these formalisms should not be applied to Datomic; they are fundamentally different kinds of databases.</p>
<p>While some details of the documentation were inaccurate or misleading, Datomic’s inter- and intra-transaction behavior appeared consistent with its core safety claims. Indeed, we believe Datomic’s inter-transaction safety properties are stronger than promised.</p>
<p>As always, we caution that Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. We also note that correctness errors in the storage system underlying Datomic could cause violations of Datomic’s guarantees; Datomic atop DynamoDB is only as safe as DynamoDB’s compare-and-set operation.</p>
<h2 data-number="4.1" id="inter-transaction-semantics"> Inter-Transaction Semantics</h2>
<p>If one considers a session as being bound to a single peer, Datomic appears to guarantee Strong Session Serializability. Histories of transactions appear indistinguishable from one in which those transactions had executed in some total order, and that order is consistent with the order observed on each peer.</p>
<p>Histories restricted to write transactions (i.e. calls to <code>d/transact</code>) appear Strict Serializable. So too do histories where readers use <code>d/sync</code> to obtain an up-to-date state of the database rather than <code>d/db</code>, which could be stale.</p>
<h2 data-number="4.2" id="intra-transaction-semantics"> Intra-Transaction Semantics</h2>
<p>Most transactional systems provide serial semantics within a single transaction.<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a> Each operation—writes, reads, procedure calls, etc.—within a transaction appears to take place after the previous operation in that same transaction. This property is explicitly encoded in the major formalisms for transactional isolation. <a href="https://pmg.csail.mit.edu/papers/icde00.pdf">Adya, Liskov, and O’Neil</a> begin their database model by defining transactions as ordered, and explicitly specify later operations observe earlier ones:</p>
<blockquote>
<p>Each transaction reads and writes objects and indicates a total order in which these operations occur….</p>
<p>If an event <span><em>w</em><sub><em>i</em></sub>(<em>x</em><sub><em>i</em>.<em>m</em></sub>)</span> is followed by <span><em>r</em><sub><em>i</em></sub>(<em>x</em><sub><em>j</em></sub>)</span> without an intervening event <span><em>w</em><sub><em>i</em></sub>(<em>x</em><sub><em>i</em>.<em>n</em></sub>)</span> in <span><em>E</em></span>, <span><em>x</em><sub><em>j</em></sub></span> must be <span><em>x</em><sub><em>i</em>.<em>m</em></sub></span>. This condition ensures that if a transaction modiﬁes object <span><em>x</em></span> and later reads <span><em>x</em></span>, it will observe its last update to <span><em>x</em></span>.</p>
</blockquote>
<p>Similarly, the <a href="https://software.imdea.org/~andrea.cerone/works/Framework.pdf">abstract execution formalism</a> of Cerone, Bernardi, and Gotsman defines an <em>internal consistency axiom</em> preserved by all consistency models from Read Atomic through Serializable:</p>
<blockquote>
<p>The internal consistency axiom  ensures that, within a transaction, the database provides sequential semantics: a read from an object returns the same value as the last write to or read from this object in the transaction. In particular,  guarantees that, if a transaction writes to an object and then reads the object, then it will observe its last write.</p>
</blockquote>
<p>Crooks, Alvisi, Pu, and Clement’s <a href="https://www.cs.cornell.edu/lorenzo/papers/Crooks17Seeing.pdf">client-centric formalism</a> similarly specifies transactions include a total order, and uses that order to ensure reads observe the most recent write to that object within the current transaction:</p>
<blockquote>
<p>Further, once an operation in <span><em>T</em></span> writes <span><em>v</em></span> to <span><em>k</em></span>, we require all subsequent operations in <span><em>T</em></span> that read <span><em>k</em></span> to return <span><em>v</em></span>.</p>
</blockquote>
<p>Even as far back as 1979, <a href="https://www.eecs.harvard.edu/~htk/publication/1979-sigmod-kung-papadimitriou.pdf">Kung and Papadimitriou</a> defined transactions as a finite sequence of <em>transaction steps</em>. “Thus, our transactions are straight-line programs,” they explain.</p>
<p>In all of these models, a Serializable system behaves equivalently to one which begins with an initial database state <span><em>d</em><em>b</em><sub>0</sub></span>, picks some transaction <span><em>T</em></span>, applies the first operation in <span><em>T</em></span> producing an intermediate database state <span><em>d</em><em>b</em><sub>0</sub>′</span>, applies the second operation in <span><em>T</em></span> to <span><em>d</em><em>b</em><sub>0</sub>′</span> producing <span><em>d</em><em>b</em><sub>0</sub>″</span>, and so on until the transaction has completed, producing a committed database state <span><em>d</em><em>b</em><sub>1</sub></span>. Then it moves to a second transaction, and the process continues.</p>
<p>Datomic’s semantics are quite different. As previously discussed, the operations within a transaction (assertions, retractions, transaction functions, etc.) are evaluated logically concurrent with one another. Every transaction function in a transaction <span><em>T</em></span> observes the state of the database when <span><em>T</em></span> began, and produces a new set of operations. They do not observe the other assertions, retractions, or functions in <span><em>T</em></span>. These operations are recursively evaluated until only assertions and retractions remain. Those assertions and retractions are merged with set union, checked for conflicts (e.g. contradictory assertions about the value of a single-cardinality attribute on some entity), and then applied to the database state to produce a new, committed version of the database.</p>

<p>This behavior may be surprising to users familiar with other databases, but it is (to some extent) documented. The <a href="https://docs.datomic.com/pro/schema/identity.html#lookup-refs">lookup ref documentation</a> explains that refs use the before-transaction database state. The <a href="https://docs.datomic.com/pro/reference/database-functions.html#processing-transaction-functions">database functions documentation</a> says the transaction processor calls transactions “in turn”, which hints at ordered execution, but explicitly notes that functions are passed “the value of the db (currently, as of the beginning of the transaction).” On the other hand, that same documentation goes on to say that “[t]ransaction functions are serialized by design,” which is true <em>between</em> transactions, but not <em>within</em> them.</p>
<p>Datomic’s concurrent semantics yield advantages and drawbacks. For one, a common axiom of database systems is that committed database state is always <em>consistent</em>, in the business-rules sense. <a href="https://jepsen.io/consistency/models/read-committed">Read Committed</a> and above proscribe phenomenon G1b (<em>intermediate read</em>) in which one transaction sees intermediate state from another transaction. Datomic goes one step further: it is impossible to observe your <em>own</em> transaction’s intermediate state. One can never<a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a> produce or observe an inconsistent view of the system—full stop! In some sense, the concept of intermediate state is inherently confusing; Datomic does away with it altogether. This choice also simplifies Datomic’s model of time: everything in a transaction happens “at once”, and every datom is <em>always</em> associated with a single, totally-ordered time.</p>
<p>On the other hand, Datomic’s model reintroduces one of the problems Serializability has long been used to prevent. As Papadimitriou’s 1979 paper <a href="https://www.cs.purdue.edu/homes/bb/cs542-06Spr-bb/SCDU-Papa-79.pdf">The Serializability of Concurrent Database Updates</a><a href="#fn11" id="fnref11" role="doc-noteref"><sup>11</sup></a> concisely argues:</p>
<blockquote>
<p>Another way of viewing serializability is as a tool for ensuring system correctness. If each user transaction is correct—i.e., when run by itself, it is guaranteed to map consistent states of the database to consistent states—and transactions are guaranteed to be intermingled in a serializable way, then the overall system is also correct.</p>
</blockquote>
<p>It seems plausible that users would want to write transaction functions that transform data while preserving some kind of correctness invariant. Datomic’s <a href="https://web.archive.org/web/20231208204951/https://docs.datomic.com/pro/reference/database-functions.html#uses-for-transaction-functions">transaction functions documentation</a> originally suggested as much:</p>
<blockquote>
<p>Transaction functions run on the transactor inside of transactions, and thus can atomically analyze and transform database values. You can use them to ensure atomic read-modify-update processing, and integrity constraints… A transaction function can issue queries on the db value it is passed, and can perform arbitrary logic in the programming language.</p>
</blockquote>
<p>If one writes a set of transaction functions which independently preserve some invariant—say, that a grant must never be both approved and also denied, or that the circuits in a home never exceed the capacity of the main panel—one would like to say (analogous to Serializable transactions) that any composition of these functions also preserves that invariant. But as we’ve demonstrated, within a single Datomic transaction this is not true! A transaction which calls multiple transaction functions might produce an outcome incompatible with the atomic application of those functions. It might violate integrity constraints. Paradoxically, combining two transactions into one can actually make the system <em>less</em> safe.</p>
<p>It seems likely that Datomic’s behavior violates the major modern transaction formalisms: Cerone et al’s internal consistency axiom, Adya’s program order, Crooks et al’s in-transaction order, etc. It may be possible to contort Datomic’s model into alignment with these formalisms: say, by defining Datomic as containing only one object (the entire database), or through a non-local translation of Datomic operations to the formalism’s sequence of reads and writes, in which reads are reordered to the beginning of the transaction, and writes to the end. However, these approaches strain intuition. Datomic databases obviously contain independently addressable entities and attributes. Datomic transactions are clearly made up of individual parts, those parts are written in order, and this looks very much like how other databases would express a transaction with serial semantics. Convincing users to ignore that intuition seems a challenging lift.</p>
<p>An easier path might be to abandon these formalisms altogether: they are clearly not designed to apply to Datomic’s concurrent intra-transaction semantics. Instead, we could follow the classic informal definition of Serializability. The internal structure of transactions is completely opaque; all that matters is that the history of transactions is equivalent to one which executed in a serial order. Under this interpretation, Datomic does ensure Serializability, Strong Session Serializability, and so on—just with different intra-transaction rules. To avoid confusion, we carefully distinguish between inter- and intra-transaction consistency throughout this report.</p>
<h2 data-number="4.3" id="recommendations"> Recommendations</h2>
<p>We found no evidence of safety bugs in Datomic, or serious divergence between documentation and system behavior. Datomic’s concurrency architecture is refreshingly straightforward, and its transactional correctness easy to argue. Jepsen believes users can rely on Datomic’s inter-transaction Serializability.</p>
<p>However, Datomic users should be aware of the concurrent execution semantics within transactions. These are specified in the documentation, but remain an unusual choice which creates the potential for subtle invariant violations. Users should be careful when calling multiple transaction functions in the same transaction. In particular, watch out for intersecting read sets and disjoint write sets. Also be aware of the possibility that multiple updates (e.g. increments) to a single value might quietly collapse to a single update.</p>
<p>In practice, we believe several factors protect Datomic users against encountering anomalies. First, users often try to create a schema and use it in the same transaction, or try to use a lookup ref to refer to an entity created in the same transaction. Both of these scenarios fail, which guides users towards re-reading the documentation and internalizing Datomic’s model. Second, the in-transaction conflict checker likely prevents many of the anomalies that could arise from logically-concurrent transaction functions: if two transaction functions produce different values for a single-cardinality attribute of an entity, the transaction aborts.</p>
<p>In addition, users can use <a href="https://docs.datomic.com/pro/schema/schema.html#attribute-predicates">attribute predicates</a> to constrain individual values, and <a href="https://docs.datomic.com/pro/schema/schema.html#entity-specs">entity specs</a> (which must be requested on each transaction) to constrain all attributes of a single entity, or even an entire database. However, users must take care to explicitly request the appropriate entity specs within every transaction that might require them.</p>
<p>Another potential surprise: Datomic goes to great pains to ensure every database state is business-rules consistent: there are no intermediate states, every state is the product of a committed transaction, and so on. However, not all schema constraints apply to extant data. In particular, attribute predicates are only enforced on newly-added datoms, not on existing datoms.</p>
<p>A small operational note: Datomic transactors kill themselves after a few minutes of not being able to talk to storage. We recommended Datomic add a retry loop to make transactors robust to network fluctuations.</p>
<h2 data-number="4.4" id="documentation-changes"> Documentation Changes</h2>
<p>Following our collaboration, Datomic has made extensive revisions to their documentation.</p>
<p>First, we worked together to rewrite Datomic’s <a href="https://docs.datomic.com/pro/transactions/acid.html">transaction safety documentation</a>. It now reflects the stronger safety properties we believe Datomic actually offers: Serializability globally, monotonicity on each peer, and Strict Serializability when restricted to writes, or reads which use <code>sync</code>. Datomic also removed the “single-writer” argument from their safety documentation.</p>
<p>Datomic’s docs now include a <a href="https://docs.datomic.com/pro/transactions/transactions.html">comprehensive explanation</a> of transaction syntax and semantics. It covers the structure of transaction requests, the rules for expanding map forms and transaction functions, and the process of applying a transaction. Expanded documentation for <a href="https://docs.datomic.com/pro/transactions/transaction-functions.html">transaction functions</a> explains Datomic’s various mechanisms for ensuring consistency, how to create and invoke functions, and the behavior of built-in functions. The transaction function documentation no longer says they can be used to “atomically analyze and transform database values”, nor does it claim transaction functions can “ensure atomic read-modify-write processing”.</p>
<p>Datomic <a href="https://web.archive.org/web/20240129122139/https://docs.datomic.com/pro/transactions/transactions.html#transaction-structure">used to refer</a> to the data structure passed to <code>d/transact</code> as a “transaction”, and to its elements as “statements” or “operations”. Going forward, Datomic intends to refer to this structure as a “transaction request”, and to its elements as “data”. The <code>[:db/add ...]</code> and <code>[:db/retract ...]</code> forms are “assertion requests” and “retraction requests,” respectively. This helps distinguish between assertion <em>datoms</em>, which are <code>[entity, attribute, value, transaction, added-or-removed?]</code> tuples, and the incomplete <code>[entity, attribute, value]</code> assertion <em>request</em> in a transaction request.</p>
<p>Datomic has also added documentation <a href="https://docs.datomic.com/pro/tech-notes/comparison-with-updating-transactions.html">arguing for a difference</a> between Datomic transactions and SQL-style “updating transactions.” There is also a new <a href="https://docs.datomic.com/pro/tech-notes/composing-transactions-by-example.html">tech note</a> which discusses the differences between transaction functions and entity predicates when composing transactions.</p>
<h2 data-number="4.5" id="future-work"> Future Work</h2>
<p>Our tests did not evaluate excision or historical queries. Nor did we investigate the Datomic client library—though we believe its behavior is likely similar to the peers we designed in this test. We also limited ourselves to a single storage engine: DynamoDB. Datomic runs atop a variety of storage systems; testing others might be of interest. Finally, we have not evaluated Datomic Cloud, which uses a slightly different architecture.</p>
<p>Jepsen is aware of few systems or formalisms which provide inter-transaction Serializability but intra-transaction concurrent semantics. Datomic’s behavior suggests fascinating research questions.</p>
<p>First, what <em>are</em> Datomic transactions? Is there a sense in which they are a <em>dual</em> to typical database transactions? Rather than happening entirely in series, everything happens all at once. What are the advantages and drawbacks of such a “co-transaction” model? Can the drawbacks be mitigated through static analysis, runtime checks, or API extensions? And does this actually matter in practice, or are users unlikely to write transactions which could violate invariants?</p>
<p>Second, are there other databases with concurrent intra-transaction semantics? Conversely, what about other temporal databases with serial intra-transaction semantics? How does Datomic’s model fit into this landscape?</p>
<p><a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-173.pdf">Alvaro’s Dedalus</a>, a research project exploring temporal Datalog, comes to mind. Like Datomic, its transactions happen “all at once.” As in Datomic, this creates the apparent paradox that breaking up operations into multiple transactions can actually make them safer. Consider also <a href="https://docs.fauna.com/fauna/current/cookbook/basics/update_document">Fauna</a>, a temporal database supporting up to Strong Serializability. Like Datomic, Fauna transactions are small programs that the database evaluates, rather than an interactive session driven by a client. Unlike Datomic, Fauna’s transactions provide (what appears to be) serial execution with incremental side effects within each transaction. Are Fauna’s in-transaction temporal semantics sound? How do their models compare?</p>
<p>The similarity between Datomic’s end-of-transaction conflict checker and Snapshot Isolation’s first-committer-wins rule suggests new research opportunities. How close is the relationship between Snapshot Isolation and Datomic’s in-transaction semantics, and what parts of the existing literature on Snapshot Isolation could we apply to Datomic? Can we show that within a Datomic transaction, cycles between transaction functions must always involve a pair of adjacent read-write anti-dependency edges. Clearly Datomic does not prevent the intra-transaction analogue of lost update, since it collapses multiple increments. What about Fractured Read? Does it allow something like the read-only transaction anomaly described by <a href="https://www.cs.umb.edu/~poneil/ROAnom.pdf">Fekete, O’Neil, and O’Neil</a>? Or <a href="https://www.news.cs.nyu.edu/~jinyang/pub/walter-sosp11.pdf">Long Fork</a>? Are there analogues to other G2-item and G2 cycles, perhaps involving predicates?</p>
<p>Finally, one wonders whether there might be a connection to <a href="https://arxiv.org/pdf/1901.01930.pdf">Hellerstein &amp; Alvaro’s CALM theorem</a>. Could we show, for instance, that transaction functions which are logically monotonic are safe to combine in a single Datomic transaction? Datalog programs without negation are logically monotonic. Can we show that those programs are also safe under this execution model? Jepsen encourages future research.</p>
<p><em>Jepsen wishes to thank the entire Datomic team at Nubank, and in particular Dan De Aguiar, Guilherme Baptista, Adrian Cockcroft, Stuart Halloway, Keith Harper, and Chris Redinger. Peter Alvaro offered key insights into concurrent semantics. <a href="https://www.irenekannyo.com/">Irene Kannyo</a> provided invaluable editorial support. This work was funded by <a href="https://nubank.com.br/en/">Nubank</a> (Nu Pagamentos S.A), and conducted in accordance with the <a href="https://jepsen.io/ethics">Jepsen ethics policy</a>.</em></p>

  </div>
</article></div>
  </body>
</html>
