<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://michael.stapelberg.ch/posts/2025-05-10-grobi-x11-monitor-autoconfig/">Original</a>
    <h1>In praise of grobi for auto-configuring X11 monitors</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
  
  <details>
    <summary>Table of contents</summary>
    <nav>
  <ul>
    <li><a href="#automatic-monitor-configuration-with-grobi">Automatic monitor configuration with grobi</a></li>
    <li><a href="#why-not-autorandr">Why not autorandr?</a></li>
    <li><a href="#does-grobi-work-on-wayland">Does grobi work on Wayland?</a></li>
    <li><a href="#zleep">Bonus: my Suspend-to-RAM setup</a></li>
  </ul>
</nav>
  </details>
  <p>I have recently started using the <a href="https://github.com/fd0/grobi/"><code>grobi</code> program by Alexander
Neumann</a> again and was delighted to discover that
it makes using my fiddly (but wonderful) <a href="https://michael.stapelberg.ch/posts/2017-12-11-dell-up3218k/">Dell 32-inch 8K monitor
(UP3218K)</a> monitor much more convenient — I get
a signal more quickly than with my previous, sleep-based approach.</p>
<p>Previously, when my PC woke up from suspend-to-RAM, there were two scenarios:</p>
<ol>
<li>The monitor was connected. My <a href="#zleep">sleep program</a> would power on the
monitor (if needed), sleep a little while and then run <a href="https://manpages.debian.org/xrandr.1"><code>xrandr(1)</code></a>
 to (hopefully) configure the monitor correctly.</li>
<li>The monitor was not connected, for example because it was still connected to
my work PC.</li>
</ol>
<p>In scenario ②, or if the one-shot configuration attempt in scenario ① fails, I
would need to SSH in from a different computer and run <code>xrandr</code> manually so that
the monitor would show a signal:</p>
<pre tabindex="0"><code>% DISPLAY=:0 xrandr \
  --output DP-4 --mode 3840x4320 --panning 0x0+0+0 \
  --output DP-2 --right-of DP-4 --mode 3840x4320 --panning 0x0+3840+0
</code></pre><h2 id="automatic-monitor-configuration-with-grobi">Automatic monitor configuration with grobi</h2>
<p>I have now completely solved this problem by creating the following
<code>~/.config/grobi.conf</code> file:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>rules</span>:<span>
</span></span></span><span><span><span>  </span>- <span>name</span>:<span> </span>UP3218K<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>outputs_connected</span>:<span> </span>[DP-2, DP-4]<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>	</span><span># DP-4 is left, DP-2 is right</span><span>
</span></span></span><span><span><span>    </span><span>configure_row</span>:<span>
</span></span></span><span><span><span>        </span>- DP-4@3840x4320<span>
</span></span></span><span><span><span>        </span>- DP-2@3840x4320<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span># atomic instructs grobi to only call xrandr once and configure all the</span><span>
</span></span></span><span><span><span>    </span><span># outputs. This does not always work with all graphic cards, but is</span><span>
</span></span></span><span><span><span>	</span><span># needed to successfully configure the UP3218K monitor.</span><span>
</span></span></span><span><span><span>    </span><span>atomic</span>:<span> </span><span>true</span><span>
</span></span></span></code></pre></div><p>…and installing / enabling <code>grobi</code> (on Arch Linux) using:</p>
<pre tabindex="0"><code>% sudo pacman -S grobi
% systemctl --user enable --now grobi
</code></pre><p>Whenever <code>grobi</code> detects that my monitor is connected (it listens for <a href="https://cgit.freedesktop.org/xorg/proto/randrproto/tree/randrproto.txt">X11
RandR</a>
output change events), it will run <a href="https://manpages.debian.org/xrandr.1"><code>xrandr(1)</code></a>
 to
configure the monitor resolution and positioning.</p>
<p>To check what <code>grobi</code> is seeing/doing, you can use:</p>
<pre tabindex="0"><code>% systemctl --user status grobi
% journalctl --user -u grob
</code></pre><p>For example, on my system, I see:</p>
<pre tabindex="0"><code>grobi: 18:31:48.823765 outputs: [HDMI-0 (primary) DP-0 DP-1 DP-2 (connected) 3840x2160+ [DEL-16711-808727372-DELL UP3218K-D2HP805I043L] DP-3 DP-4 (connected) 3840x21&gt;
grobi: 18:31:48.823783 new rule found: UP3218K
grobi: 18:31:48.823785 enable outputs: [DP-4@3840x4320 DP-2@3840x4320]
grobi: 18:31:48.823789 using one atomic call to xrandr
grobi: 18:31:48.823806 running command /usr/bin/xrandr xrandr --output DP-4 --mode 3840x4320 --output DP-2 --mode 3840x4320 --right-of DP-4
grobi: 18:31:49.285944 new RANDR change event received
</code></pre><p>Notably, the instructions for getting out of a bad state (no signal) are now to
power off the monitor and power it back on again. This will result in RandR
output change events, which will trigger <code>grobi</code>, which will run <code>xrandr</code>, which
configures the monitor. Nice!</p>
<h2 id="why-not-autorandr">Why not autorandr?</h2>
<p>No particular reason. I knew <code>grobi</code>.</p>
<p>If nothing else, <code>grobi</code> is written in Go, so it’s likely to keep working
smoothly over the years.</p>
<h2 id="does-grobi-work-on-wayland">Does grobi work on Wayland?</h2>
<p>Probably not. There is no mention of Wayland over on the <a href="https://github.com/fd0/grobi/">grobi
repository</a>.</p>
<h2 id="zleep">Bonus: my Suspend-to-RAM setup</h2>
<p>As a bonus, this section describes the other half of my monitor-related
automation.</p>
<p>When I suspend my PC to RAM, I either want to wake it up manually later, for
example by pressing a key on the keyboard or by sending a Wake-on-LAN packet, or
I want it to wake up automatically each morning at 6:50 — that way, daily cron
jobs have some time to run before I start using the computer.</p>
<p>To accomplish this, I use <code>zleep</code>, a wrapper program around <a href="https://manpages.debian.org/rtcwake.8"><code>rtcwake(8)</code></a>
 and <code>systemctl suspend</code> that integrates with the
myStrom switch smart plug to turn off power to the monitor entirely. This is
worthwhile because the monitor draws 30W even in standby!</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> main
</span></span><span><span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;context&#34;</span>
</span></span><span><span>	<span>&#34;flag&#34;</span>
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>	<span>&#34;log&#34;</span>
</span></span><span><span>	<span>&#34;net/http&#34;</span>
</span></span><span><span>	<span>&#34;net/url&#34;</span>
</span></span><span><span>	<span>&#34;os&#34;</span>
</span></span><span><span>	<span>&#34;os/exec&#34;</span>
</span></span><span><span>	<span>&#34;time&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>var</span> (
</span></span><span><span>	resume = flag.<span>Bool</span>(<span>&#34;resume&#34;</span>,
</span></span><span><span>		<span>false</span>,
</span></span><span><span>		<span>&#34;run resume behavior only (turn on monitor via smart plug)&#34;</span>)
</span></span><span><span>
</span></span><span><span>	noMonitor = flag.<span>Bool</span>(<span>&#34;no_monitor&#34;</span>,
</span></span><span><span>		<span>false</span>,
</span></span><span><span>		<span>&#34;disable turning off/on monitor&#34;</span>)
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>monitorPower</span>(ctx context.Context, method, cmnd <span>string</span>) <span>error</span> {
</span></span><span><span>	<span>if</span> <span>*</span>noMonitor {
</span></span><span><span>		log.<span>Printf</span>(<span>&#34;[monitor power] skipping because -no_monitor flag is set&#34;</span>)
</span></span><span><span>		<span>return</span> <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>	log.<span>Printf</span>(<span>&#34;[monitor power] command: %v&#34;</span>, cmnd)
</span></span><span><span>	u, err <span>:=</span> url.<span>Parse</span>(<span>&#34;http://myStrom-Switch-A46FD0/&#34;</span> <span>+</span> cmnd)
</span></span><span><span>	<span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> err
</span></span><span><span>	}
</span></span><span><span>	<span>for</span> {
</span></span><span><span>		<span>if</span> err <span>:=</span> ctx.<span>Err</span>(); err <span>!=</span> <span>nil</span> {
</span></span><span><span>			<span>return</span> err
</span></span><span><span>		}
</span></span><span><span>		req, err <span>:=</span> http.<span>NewRequest</span>(method, u.<span>String</span>(), <span>nil</span>)
</span></span><span><span>		<span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>			<span>return</span> err
</span></span><span><span>		}
</span></span><span><span>		ctx, canc <span>:=</span> context.<span>WithTimeout</span>(ctx, <span>5</span><span>*</span>time.Second)
</span></span><span><span>		<span>defer</span> <span>canc</span>()
</span></span><span><span>		req = req.<span>WithContext</span>(ctx)
</span></span><span><span>		resp, err <span>:=</span> http.DefaultClient.<span>Do</span>(req)
</span></span><span><span>		<span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>			log.<span>Print</span>(err)
</span></span><span><span>			time.<span>Sleep</span>(<span>1</span> <span>*</span> time.Second)
</span></span><span><span>			<span>continue</span>
</span></span><span><span>		}
</span></span><span><span>		<span>if</span> resp.StatusCode <span>!=</span> http.StatusOK {
</span></span><span><span>			log.<span>Printf</span>(<span>&#34;unexpected HTTP status code: got %v, want %v&#34;</span>, resp.Status, http.StatusOK)
</span></span><span><span>			time.<span>Sleep</span>(<span>1</span> <span>*</span> time.Second)
</span></span><span><span>			<span>continue</span>
</span></span><span><span>		}
</span></span><span><span>		log.<span>Printf</span>(<span>&#34;[monitor power] request succeeded&#34;</span>)
</span></span><span><span>		<span>return</span> <span>nil</span>
</span></span><span><span>	}
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>nextWakeup</span>(now time.Time) time.Time {
</span></span><span><span>	midnight <span>:=</span> time.<span>Date</span>(now.<span>Year</span>(), now.<span>Month</span>(), now.<span>Day</span>(), <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, time.Local)
</span></span><span><span>	<span>if</span> now.<span>Hour</span>() &lt; <span>6</span> {
</span></span><span><span>		<span>// wake up today
</span></span></span><span><span><span></span>		<span>return</span> midnight.<span>Add</span>(<span>6</span><span>*</span>time.Hour <span>+</span> <span>50</span><span>*</span>time.Minute)
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>// wake up tomorrow
</span></span></span><span><span><span></span>	<span>return</span> midnight.<span>Add</span>(<span>24</span> <span>*</span> time.Hour).<span>Add</span>(<span>6</span><span>*</span>time.Hour <span>+</span> <span>50</span><span>*</span>time.Minute)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>runResume</span>() <span>error</span> {
</span></span><span><span>	<span>// Retry for up to one minute to give the network some time to come up
</span></span></span><span><span><span></span>	ctx, canc <span>:=</span> context.<span>WithTimeout</span>(context.<span>Background</span>(), <span>1</span><span>*</span>time.Minute)
</span></span><span><span>	<span>defer</span> <span>canc</span>()
</span></span><span><span>	<span>if</span> err <span>:=</span> <span>monitorPower</span>(ctx, <span>&#34;GET&#34;</span>, <span>&#34;relay?state=1&#34;</span>); err <span>!=</span> <span>nil</span> {
</span></span><span><span>		log.<span>Print</span>(err)
</span></span><span><span>	}
</span></span><span><span>	<span>return</span> <span>nil</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>zleep</span>() <span>error</span> {
</span></span><span><span>	ctx <span>:=</span> context.<span>Background</span>()
</span></span><span><span>
</span></span><span><span>	now <span>:=</span> time.<span>Now</span>().<span>Truncate</span>(<span>1</span> <span>*</span> time.Second)
</span></span><span><span>	wakeup <span>:=</span> <span>nextWakeup</span>(now)
</span></span><span><span>	log.<span>Printf</span>(<span>&#34;now   : %v&#34;</span>, now)
</span></span><span><span>	log.<span>Printf</span>(<span>&#34;wakeup: %v&#34;</span>, wakeup)
</span></span><span><span>	log.<span>Printf</span>(<span>&#34;wakeup: %v (timestamp)&#34;</span>, wakeup.<span>Unix</span>())
</span></span><span><span>
</span></span><span><span>	<span>// assumes hwclock is running in UTC (see timedatectl | grep local)
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>// Power the monitor off in 15 seconds.
</span></span></span><span><span><span></span>	<span>// mode=on is intentional: https://api.mystrom.ch/#e532f952-36ea-40fb-a180-a57b835f550e
</span></span></span><span><span><span></span>	<span>// - the switch will be turned on (already on, so this is a no-op)
</span></span></span><span><span><span></span>	<span>// - the switch will wait for 15 seconds
</span></span></span><span><span><span></span>	<span>// - the switch will be turned off
</span></span></span><span><span><span></span>	<span>if</span> err <span>:=</span> <span>monitorPower</span>(ctx, <span>&#34;POST&#34;</span>, <span>&#34;timer?mode=on&amp;time=15&#34;</span>); err <span>!=</span> <span>nil</span> {
</span></span><span><span>		log.<span>Print</span>(err)
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	sleep <span>:=</span> exec.<span>Command</span>(<span>&#34;sh&#34;</span>, <span>&#34;-c&#34;</span>, fmt.<span>Sprintf</span>(<span>&#34;sudo rtcwake -m no --verbose --utc -t %v &amp;&amp; sudo systemctl suspend&#34;</span>, wakeup.<span>Unix</span>()))
</span></span><span><span>	sleep.Stdout = os.Stdout
</span></span><span><span>	sleep.Stderr = os.Stderr
</span></span><span><span>	fmt.<span>Printf</span>(<span>&#34;running %v\n&#34;</span>, sleep.Args)
</span></span><span><span>	<span>if</span> err <span>:=</span> sleep.<span>Run</span>(); err <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> fmt.<span>Errorf</span>(<span>&#34;%v: %v&#34;</span>, sleep.Args, err)
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>nil</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	flag.<span>Parse</span>()
</span></span><span><span>	<span>if</span> <span>*</span>resume {
</span></span><span><span>		<span>if</span> err <span>:=</span> <span>runResume</span>(); err <span>!=</span> <span>nil</span> {
</span></span><span><span>			log.<span>Fatal</span>(err)
</span></span><span><span>		}
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>if</span> err <span>:=</span> <span>zsleep</span>(); err <span>!=</span> <span>nil</span> {
</span></span><span><span>			log.<span>Fatal</span>(err)
</span></span><span><span>		}
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>To turn power to the monitor on after resuming, I placed the following shell
script in <code>/lib/systemd/system-sleep/zleep.sh</code>:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/bin/sh
</span></span></span><span><span><span></span>
</span></span><span><span><span>case</span> <span>&#34;</span><span>$1</span><span>&#34;</span> in
</span></span><span><span>	pre<span>)</span>	<span>exit</span> <span>0</span>
</span></span><span><span>		;;
</span></span><span><span>	post<span>)</span>	/usr/local/bin/zleep -resume
</span></span><span><span>		<span>exit</span> <span>0</span>
</span></span><span><span>		;;
</span></span><span><span> 	*<span>)</span>	<span>exit</span> <span>1</span>
</span></span><span><span>		;;
</span></span><span><span><span>esac</span>
</span></span></code></pre></div><p>Once power is on, grobi will detect and configure the monitor.</p>
<p>Here is the program in action:</p>
<pre tabindex="0"><code>2025/05/06 21:58:32 now   : 2025-05-06 21:58:32 +0200 CEST
2025/05/06 21:58:32 wakeup: 2025-05-07 06:50:00 +0200 CEST
2025/05/06 21:58:32 wakeup: 1746593400 (timestamp)
2025/05/06 21:58:32 [monitor power] command: timer?mode=on&amp;time=15
2025/05/06 21:58:32 [monitor power] request succeeded
running [sh -c sudo rtcwake -m no --verbose --utc -t 1746593400 &amp;&amp; sudo systemctl suspend]
Using UTC time.
	delta   = 0
	tzone   = 0
	tzname  = UTC
	systime = 1746561512, (UTC) Tue May  6 19:58:32 2025
	rtctime = 1746561512, (UTC) Tue May  6 19:58:32 2025
alarm 1746593400, sys_time 1746561512, rtc_time 1746561512, seconds 0
rtcwake: wakeup using /dev/rtc0 at Wed May  7 04:50:00 2025
suspend mode: no; leaving
</code></pre><div id="bmc">
  <p>
    I run a blog since 2005, spreading knowledge and experience for over 20 years! :)
  </p>
  <p>
    If you want to support my work, you
    can <a href="https://www.buymeacoffee.com/stapelberg">buy me a coffee</a>.
  </p>
  <p>
    Thank you for your support! ❤️
  </p>
</div>

</div></div>
  </body>
</html>
