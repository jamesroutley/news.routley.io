<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.joshwcomeau.com/javascript/terminal-for-js-devs/">Original</a>
    <h1>The Front-End Developer&#39;s Guide to the Terminal</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><p>Modern front-end frameworks like React, Angular, and Vue rely heavily on the terminal. If you&#39;re not comfortable with command line interfaces, you&#39;ll struggle to run a local development server or build your application!</p><p>There&#39;s something deeply ironic about this. Our whole job is to build <em>graphical user interfaces</em>, but the tools we use in our development are mostly command-line based!</p><p>Unless you have a Computer Science background, or grew up using a computer in the 80s, you probably won&#39;t have very much terminal experience. And yet, most online resources assume that you&#39;re already proficient!</p><p>It takes years of practice to become a terminal guru, <strong>but here&#39;s the good news:</strong> we can take a shortcut. We don&#39;t really need to know 98% of the stuff you can do with a terminal. If we focus on the most-important critical fundamentals, we should be able to become comfortable with the command line in a remarkably short amount of time. ‚ú®</p><p><strong>That&#39;s what this blog post is all about.</strong> It&#39;s the missing manual of terminal fundamentals needed to work with modern JS frameworks like React, so you can move onto the fun stuff: building user interfaces!</p><p>I&#39;ll also share all of my favourite <em>tips and tricks</em> for getting the most out of the terminal, the stuff I wish someone had shown me when I was first getting started.</p><p>Alright, so there&#39;s two things we need to do before anything else.</p><p>First, we need some terminal software. This is the application that runs the command-line environment.</p><p>Just about every operating system will come with a built-in terminal, like MacOS&#39; Terminal.app, or Windows&#39; Command Prompt. These applications work, but they&#39;re pretty underwhelming. Most developers opt to use something else.</p><p>The choice of terminal application isn&#39;t <em>super</em> important, as long as you&#39;re using something modern. That said, I have two main recommendations:</p><ol><li><p><a href="https://hyper.is/" rel="noopener noreferrer" target="_blank">Hyper</a>. Hyper is a modern, multi-platform terminal application. It&#39;s beautiful, and comes with some handy modern features, like the ability to split into multiple panes.</p></li><li><p>If you use VS Code as your code editor, VS Code comes with a powerful, modern terminal built in. This is nice, since it means your code and terminal can run side-by-side in the same application. You can pop open the terminal in VS Code by selecting View ‚Üí Terminal.</p></li></ol><p>I&#39;ll be using Hyper for all the examples in this blog post.</p><p>Now, the terminal application is only half of the equation. We also need to make sure we&#39;re running the right <em>shell language</em>.</p><p>When we type a command into the terminal and press ‚Äúenter‚Äù, that command will be interpreted by the shell language. It&#39;s essentially the environment running within the terminal application.</p><p>The most popular shell language is <strong>Bash</strong>. When you see command-line instructions online, it&#39;s likely that the instructions are assuming Bash. This is the default shell language used by most Linux distributions.</p><p>Modern MacOS versions ship with <strong>Zsh</strong> instead of Bash, but Zsh is very similar: it&#39;s part of the same &#34;family&#34;, and shares almost all of the same commands. For our purposes, they can be used interchangeably.</p><p>If you&#39;re using either Linux or MacOS, you&#39;re good to go. Your computer is already using an &#34;industry standard&#34; shell language. If you&#39;re using Windows, however, we have a bit of work to do.</p><p>Alright, first, let me preface this by emphatically admitting that I am <em>not</em> an expert when it comes to Windows development. Please take everything I&#39;m about to say with a grain of salt. üòÖ</p><p>Bash is a Linux-based shell language, and it won&#39;t run natively in Windows. Fortunately, newer versions of Windows come with the ability to install and run Linux as if it were any other application. This is known as <em>Windows Subsystem for Linux</em>, commonly abbreviated to WSL.</p><p>Here&#39;s a tutorial that runs through the steps required: <a href="https://candid.technology/zsh-windows-10/" rel="noopener noreferrer" target="_blank">How to install and use Zsh in Windows 10</a>.</p><p>I ran through these steps myself, and while it&#39;s definitely a bit tedious, it does the job!</p><p>Once it&#39;s set up, you&#39;ll be able to configure your terminal application to use Bash or Zsh. Here are some instructions for <a href="https://hashnode.com/post/customize-hyper-terminal-in-windows-using-oh-my-zsh-and-powerline-fonts-ckggfmcwc00brrls1f8va9jfl#install-hyper-terminal" rel="noopener noreferrer" target="_blank">configuring Hyper to use Zsh</a>.</p><p>If you have trouble with any of these steps, there are other solutions you can try. A popular method is <a href="https://www.atlassian.com/git/tutorials/git-bash" rel="noopener noreferrer" target="_blank">Git Bash</a>, which allows you to run Bash within Windows using emulation.</p><p>Ultimately, it doesn&#39;t matter how you get there. The important thing is for you to be able to use either Bash or Zsh within Windows.</p><p>When you first open the terminal application, you&#39;re met with this rather unhelpful interface:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="A terminal application showing a default prompt" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>Your terminal will likely look a bit different, based on your operating system / terminal application / shell language. Ultimately, however, you&#39;ll probably be looking at a single line of text, and a bunch of empty space.</p><p>The single line of text is known as a <em>prompt</em>. It&#39;s called a ‚Äúprompt‚Äù because it&#39;s waiting for you to provide some sort of instruction.</p><p>For our first command, enter the text <code>echo &#34;hello world&#34;</code> and press enter:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running the &#39;echo&#39; command, repeating a short string" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>The syntax is a bit different, but you can think of commands like built-in JavaScript functions. The <code>echo</code> command is very similar to the <code>console.log</code> function in JavaScript.</p><p>Like functions, commands take arguments. In this case, <code>echo</code> takes a single argument, the string to output.</p><p>When we press ‚Äúenter‚Äù, the command is immediately executed, and our value is logged. A fresh prompt is rendered below, to let us know that it&#39;s ready to receive the next instruction.</p><p>And just like that, you&#39;ve run your first terminal command!</p><p>The main purpose of a terminal is to enable you to move around the file system and open/run things. It&#39;s essentially a text-based version of the GUI file explorers we use every day (eg. Finder, Windows Explorer).</p><p>To help us navigate around, there are lots of terminal commands we can use. Let&#39;s explore some of them.</p><p>The <code>pwd</code> command stands for ‚ÄúPrint Working Directory‚Äù, and it&#39;s sorta like the &#34;You are here&#34; arrow on shopping mall directories. It tells you where you are right now:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running the &#39;pwd&#39; command, which shows the current path (/Users/joshu)" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>When you open the terminal application, you&#39;re generally tossed into the &#34;home&#34; directory, the one that contains the Documents and Desktop directories. On my particular machine, this directory is located at <code>/Users/joshu</code>.</p><p>You can see the contents of the current directory using the <code>ls</code> command (short for ‚ÄúList‚Äù):</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running the &#39;ls&#39; command, showing a set of all files and folders in the current working directory" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>In my particular terminal, directories are bold and written in a light aqua color, while single files are regular weight and written in white.</p><p>We can move around the file system with the <code>cd</code> (‚ÄúChange Directory‚Äù) command:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running the &#39;cd&#39; command, to enter one of the directories shown in the previous &#39;ls&#39;. Afterwards, &#39;pwd&#39; is run to confirm the new location" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>This is equivalent to double-clicking the ‚Äústuff‚Äù directory in a GUI file explorer.</p><p>What if I want to go up one level, back to the home directory? I can use the <code>cd</code> command for this as well, with two dots (<code>..</code>).</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running &#39;cd ..&#39;, which takes the user back up to the previous directory." src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>The dot character (<code>.</code>) has a special meaning in most shell languages:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>A single dot (<code>.</code>) refers to the <em>current directory</em>.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>Two dots (<code>..</code>) refer to the <em>parent directory</em>.</p></li></ul><p>If you&#39;ve worked with module systems in JavaScript, you&#39;re probably already familiar with this convention. It uses the same notation, using two dots to refer to the parent directory:</p><pre></pre><p>One important thing to know about <code>cd</code> is that it can take complex paths. Terminal beginners will often go one step at a time, like they would in a GUI file explorer:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Using &#39;cd&#39; to step down through 4 different directories" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>This works, but it&#39;s a lot of extra work. We can make the same jump in a single step like this:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running the &#39;cd&#39; command to make the same transition as before, but doing it in 1 single step: &#39;cd things/some-project/src/components&#39;" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>One of the most intimidating things about the terminal is that it doesn&#39;t give you any clues or hints. With a GUI file explorer, you can see a full list of files and folders, to refresh your memory and help you find what you&#39;re looking for.</p><p>If you want to use <code>cd</code> as I propose, leaping from 1 spot to another in a single bound, it might seem like you&#39;d need a photographic memory. You can&#39;t do it unless you remember the exact name of every directory in the chain, right?</p><p>Fortunately, an incredibly-handy trick makes this much easier: <em>tab autocompletion</em>.</p><p>It&#39;ll be easier for me to show you how this works in a short video:</p><p>The Tab key is critically important when it comes to using the terminal effectively. In addition to the navigation tricks shown here, we can also use Tab to auto-complete Git branches, or fill in the rest of a command.</p><p>Try pressing Tab in different circumstances, and see what happens!</p><p>Earlier, I said that commands in Bash/Zsh are like functions in JavaScript. The analogy breaks down a bit when it comes to <em>flags</em>.</p><p>Flags are modifiers that tweak the behaviour of commands in predefined ways.</p><p>For example, let&#39;s look at the <code>rm</code> command. This command allows us to delete individual files:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running &#39;rm theme-song.mp3&#39;, and then running &#39;ls&#39; to show that the file was deleted." src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>We don&#39;t get any sort of confirmation, but if we check, the <code>theme-song.mp3</code> file has indeed been deleted.<span></span></p><p>If you try and use the <code>rm</code> command on a directory, you&#39;ll get an error:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running the &#39;rm&#39; command on a directory, and getting an error" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>By default, <code>rm</code> can only remove individual files, but we can change this rule with the <code>r</code> flag:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running the &#39;rm&#39; command with the &#39;r&#39; flag, and successfully deleting the directory" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>The <code>r</code> flag stands for ‚Äúrecursive‚Äù. It will delete everything inside the <code>stuff</code> directory, anything inside the directories inside the <code>stuff</code> directory, anything inside directories inside the directories inside the <code>stuff</code> directory, and so on.<span></span></p><p>You might also run into some file permission issues. For that reason, the <code>f</code> flag (Force) is commonly used as well. We can group multiple flags with a single dash, like this:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running the &#39;rm&#39; command with the &#39;r&#39; and &#39;f&#39; flags" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>Flags take many shapes and sizes. By convention, it&#39;s common for flags to have a short form (eg. <code>-f</code>) and a long form (<code>--force</code>). The long form typically uses two dashes, and uses whole words instead of individual letters.</p><p>Let&#39;s look at one more example. the <code>ls</code> command we saw earlier is commonly called with two flags:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>The <code>l</code> flag, ‚Äúlong‚Äù, which prints the directory contents in a detailed list with metadata.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>The <code>a</code> flag, &#34;all&#34;, which&#39;ll include hidden files and directories.</p></li></ul><p>This changes the output considerably:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running &#39;ls -la&#39;. A detailed list is shown, along with hidden files and folders." src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>There&#39;s a lot of noise here, including the ridiculously-obfuscated permission glyphs. But some of the metadata, like the dates that show when a file was last updated, can be useful!</p><div><h2><a name="interrupting-commands" id="interrupting-commands" href="#interrupting-commands"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Interrupting commands</h2></div><p>Some processes are long-running, and will need to be interrupted.</p><p>For example, open your terminal application and try running the following command: <code>ping 8.8.8.8</code>.</p><p>The <code>ping</code> command will check the latency against a given IP address. It&#39;s useful for checking whether a given server is online or not. <code>8.8.8.8</code> is the IP address for Google&#39;s DNS server.</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running &#39;ping 8.8.8.8&#39;. The terminal fills up with results, showing that the pings come back after 30-45 milliseconds." src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>Unlike the commands we&#39;ve seen so far, <code>ping</code> is a long-running process. It never stops; by default, it&#39;ll keep pinging Google&#39;s DNS server until the end of time.</p><p>When we&#39;re satisfied with the results, we can interrupt it by holding <code>ctrl</code> and pressing <code>c</code>. Even on MacOS, where most shortcuts use the <code>‚åò</code> modifier, we use <code>ctrl</code>.</p><p>Another helpful command is <code>ctrl</code> + <code>d</code>. This will end the current session. If <code>ctrl</code> + <code>c</code> isn&#39;t working for some reason, <code>ctrl</code> + <code>d</code> may work instead.</p><p>Finally, if all else fails, you can close the current tab/window. The shortcut depends on the OS and terminal application. Using Hyper on MacOS, this is done with <code>‚åò</code> + <code>w</code>.</p><div><h2><a name="common-development-tasks" id="common-development-tasks" href="#common-development-tasks"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Common development tasks</h2></div><p>So far, we&#39;ve seen lots of general-computing examples of how to do stuff with the terminal. Let&#39;s look at how we&#39;d accomplish some typical development tasks!</p><p>These examples assume that you have Node.js installed. If you haven&#39;t installed it yet, you can <a href="https://nodejs.org/en/" rel="noopener noreferrer" target="_blank">download a copy from the Node homepage</a>.</p><div><h3><a name="managing-dependencies" id="managing-dependencies" href="#managing-dependencies"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Managing dependencies</h3></div><p>Let&#39;s imagine it&#39;s your first day on the job. The team has given you access to the source code, and you&#39;ve downloaded it onto your machine. Now what?</p><p>Well, the first step is to download the project&#39;s third-party dependencies!</p><p>Here are the steps to follow:</p><pre></pre><p><code>npm</code> stands for Node Package Manager. It&#39;s installed automatically when you install Node.js.</p><p>Running this command will download all of the third-party code that the project depends on from the NPM repository. This code will live in a local <code>node_modules</code> directory.</p><p>Alright, so you&#39;ve got the third-party code downloaded. Now what?</p><p>If you check out the project&#39;s <code>package.json</code>, you&#39;ll likely see a section that looks like this:</p><pre></pre><p>These ‚Äúscripts‚Äù are tasks that can be run with the NPM utility. They can be executed by running <code>npm run [name]</code>. For example, to boot up a local development server, we&#39;d run:</p><pre></pre><p>Running this command starts a long-running process. It launches a Node server that allows us to work on our application, watching for changes to the files and re-bundling when we edit them.</p><p>When we&#39;re done, we can kill the server with <code>ctrl</code> + <code>c</code>.</p><p>The beautiful thing about NPM scripts is that they <em>standardize</em> things. <code>start</code>, <code>build</code>, and <code>test</code> are conventional names for these standard tasks. As a result, we don&#39;t have to memorize bespoke commands for each project, even if the projects use radically different tools.<span></span></p><p>(We can also create our own NPM scripts! This is something I do extensively in my projects. I&#39;ll be publishing a blog post all about this at some point, <a href="https://joshwcomeau.com/subscribe" rel="noopener noreferrer" target="_blank">subscribe</a> so you don&#39;t miss it!)</p><div><h3><a name="opening-the-project-in-your-ide" id="opening-the-project-in-your-ide" href="#opening-the-project-in-your-ide"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Opening the project in your IDE</h3></div><p>When I want to start working on a project, I start by navigating to the project&#39;s root directory in the terminal. Then I run the following command:</p><pre></pre><p>As discussed, <code>.</code> refers to the current working directory. <code>code</code> is a command added by my code editor, VS Code. Running this command opens the entire project in my code editor, making it easy for me to jump between files as-needed.</p><p>Note that the command will vary depending on your editor. And, for folks on MacOS who use VS Code, you&#39;ll need to <a href="https://code.visualstudio.com/docs/setup/mac" rel="noopener noreferrer" target="_blank">do a bit of work</a> to enable the <code>code</code> command.</p><div><h3><a name="reinstalling-dependencies" id="reinstalling-dependencies" href="#reinstalling-dependencies"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Reinstalling dependencies</h3></div><p>You know how the standard advice for <em>any</em> computer problem is to turn it off and on again?</p><p>The JavaScript version of that is to reinstall the NPM dependencies. Sometimes, they just need to be erased and re-downloaded. This is <em>especially</em> true if you occasionally pop into your <code>node_modules</code> and edit the files to help with debugging.<span></span></p><p>Here&#39;s how we can do this:</p><pre></pre><p>Once we&#39;re in the correct directory, we delete all third-party code with the <code>rm</code> command, and then re-install it with <code>npm install</code>.</p><p>While there <em>are</em> GUI applications for working with Git, many developers prefer to use the command line for Git-related tasks.</p><p>A full command-line Git tutorial is well beyond the scope of this blog post, but here&#39;s a quick cheat-sheet of the commands I use often:</p><pre></pre><p>Over the years, I&#39;ve picked up some nifty little terminal tips. They aren&#39;t <em>critical</em>, but they help improve the developer experience of using the terminal.</p><div><h3><a name="cycling-and-toggling-commands" id="cycling-and-toggling-commands" href="#cycling-and-toggling-commands"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Cycling and toggling commands</h3></div><p>Many terminal applications will keep a log of every command you&#39;ve run in a given session. You can cycle through previous commands using the &#34;up&#34; arrow.</p><p>If I know I&#39;ve run a command recently, it&#39;s usually faster to hit &#34;up&#34; a couple times rather than typing it out from scratch!</p><p>Here&#39;s one more <em>amazing</em> little trick I learned a while back: the <code>-</code> character.</p><p>Suppose we want to bounce back and forth between two directories with <code>cd</code>. We can do that by typing out the whole path, over and over and over:</p><div><h3><a name="clearing-the-terminal" id="clearing-the-terminal" href="#clearing-the-terminal"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Clearing the terminal</h3></div><p>Like a clear desk, a clear terminal can lead to a clear mind.</p><p>There are a few ways to accomplish this. There&#39;s a <code>clear</code> command, which will erase all previously-entered commands, and making it seem like you just started a new terminal session.</p><p>There&#39;s also a universal shortcut, <code>ctrl</code> + <code>L</code>. This has the same effect as the <code>clear</code> command. It should work across MacOS, Windows, and Linux.</p><p>This command/shortcut is implemented within Bash/Zsh. It&#39;s part of the shell environment. This means that it only works while the shell is idle, when you have a prompt waiting to receive instructions.</p><p>Certain terminal applications also implement their own shortcuts, and these shortcuts can work <strong>even while the shell is busy.</strong> Here are the list of shortcuts I&#39;m aware of:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>On MacOS, across just about any shell (Terminal.app, iTerm2, Hyper), the shortcut is <code>‚åò</code> + <code>k</code></p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>If you use Hyper on non-MacOS platforms, the shortcut is <code>ctrl</code> + <code>shift</code> + <code>k</code>.</p></li></ul><p><strong>These application-level shortcuts are way better.</strong> You can use them even when the shell is busy.</p><p>For example, let&#39;s say you&#39;re running a dev server. This is a long-running process, and so the <code>ctrl</code> + <code>L</code> shortcut won&#39;t work. As you work on the project, lots of messages will be logged in the terminal window. The application shortcuts allow you to clear away stale logs, as if archiving old emails. <strong>This is really helpful,</strong> and a great example of how modern terminal applications make our lives easier.</p><p>Thanks to <a href="https://twitter.com/hovhaDovah/status/1516444641960382466" rel="noopener noreferrer" target="_blank">Aleksandr</a> and Joseph Cagle for helping me understand how this works on non-MacOS platforms!</p><p>Every now and then, I&#39;ll find myself typing out the same command over and over. If this command is long or complex, it&#39;s annoying to have to type it out every time, and to remember it verbatim.</p><p>Bash and Zsh support <em>aliases</em>, a way of creating custom shortcuts. For example, I can set it up so that whenever I enter <code>hi</code>, it automatically runs <code>echo &#34;Hello World!&#34;</code>:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Running the &#39;alias&#39; command, to create an alias for the echo command" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>Setting up aliases is a bit beyond the scope of this tutorial, and the instructions are a bit different depending on your shell language. Here are some helpful tutorials that go into more depth:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span></li></ul><div><h3><a name="switching-to-a-gui-file-explorer" id="switching-to-a-gui-file-explorer" href="#switching-to-a-gui-file-explorer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Switching to a GUI file explorer</h3></div><p>Unless you&#39;ve reached black-belt status with the terminal, there will be times when you want to open the working directory in a GUI file explorer.</p><p>On MacOS, the <code>open .</code> command will do this:</p><p>The <code>open</code> command is generally used to open a file, the same way double-clicking a file opens it in a GUI file explorer.</p><p>When we try to open a <em>directory</em>, however, it&#39;ll choose to pop open a new Finder window, showing the contents of that directory.</p><p>And since the dot character (<code>.</code>) refers to the current directory, <code>open .</code> allows us to switch from the terminal to Finder, to continue our work outside of the terminal.</p><p>On Windows, you can use <code>explorer .</code> to accomplish the same goal! Thanks to <a href="https://twitter.com/luniestro/status/1516427957467852802" rel="noopener noreferrer" target="_blank">Lukas</a> and <a href="https://twitter.com/ZagglesZurek/status/1516447452726894596" rel="noopener noreferrer" target="_blank">Agata</a> for letting me know. üòÑ</p><p>On Linux, <code>xdg-open</code> can be used to open files, or the current directory, so long as the Linux distro implements the FreeDesktop standard. Thanks to <a href="https://twitter.com/thedaviddelta/status/1516417270343471113" rel="noopener noreferrer" target="_blank">David</a> for letting me know!</p><p>Whenever I clone a new project from Github, I generally want to do two things in a row:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p><code>npm install</code>, to fetch third-party dependencies</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p><code>npm run start</code>, to boot up a local development server</p></li></ul><p>The <code>npm install</code> command typically takes a few minutes. I don&#39;t have the attention span to sit and watch dependencies download, and so I&#39;ll often distract myself with Twitter. The next thing I know, 20 minutes have passed, and I totally forgot I was going to start a dev server. üò¨</p><p>We can solve this problem using <em>chaining</em>. Here&#39;s how it works:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSI4OTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Chaining two NPM commands with double ampersands" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>The <code>&amp;&amp;</code> operator allows us to chain multiple commands together. The first command will be executed, <code>npm install</code>. The moment it finishes, the second command will be run automatically.</p><p>This is a particularly neat trick because <code>npm run start</code> generally opens a browser window, capturing my attention and letting me know that everything&#39;s ready for me. <code>npm install</code>, by contrast, finishes silently.</p><p>Once I got the hang of chaining, I started using it everywhere. I&#39;ll often queue up a bunch of Git commands:</p><pre></pre><div><h3><a name="terminal-tiling-and-tabs" id="terminal-tiling-and-tabs" href="#terminal-tiling-and-tabs"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Terminal tiling and tabs</h3></div><p>Alright, so let&#39;s talk about how to keep our workspace organized.</p><p>Running a dev server with <code>npm run start</code> is a long-running process. I often have dev servers run uninterrupted for weeks at a time!</p><p>When a terminal session is busy on a task, it isn&#39;t able to accept additional commands. Remember, the prompt is used to show that the terminal is waiting for a command; if we don&#39;t see a prompt, we can&#39;t run anything in that given session!</p><p>Fortunately, modern terminal applications make it easy to run many terminal sessions in the same application.</p><p>In Hyper, we can split the window into multiple vertical panes by selecting Shell -&gt; Split down. On MacOS, the shortcut is <code>Shift</code> + <code>‚åò</code> + <code>d</code>. This creates two independent sessions:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM3MiIgaGVpZ2h0PSIxNDYyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg=="/></span><img alt="Two terminal sessions, one on top of the other" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>By splitting the window into multiple sessions, the top session can focus on running the dev server, and highlighting errors and other important information. The bottom session can be used to run shorter tasks.</p><p>Sometimes, projects will require multiple long-running tasks; maybe we have a dev server <em>and</em> a test watcher. In that case, we&#39;d split the window into 3 sessions.</p><p>In Hyper, we can also create <em>multiple tabs</em>. New tabs can be created with Shell -&gt; New Tab. On MacOS, the shortcut is the same as it is to create new tabs in a web browser: <code>‚åò</code> + <code>t</code>.</p><p><strong>When do we use tabs vs. tiles?</strong> I like to have 1 tab per project. Each tab can be split into as many sessions are required for that specific project.</p><div><h2><a name="the-journey-continues" id="the-journey-continues" href="#the-journey-continues"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>The journey continues</h2></div><p>Phew! We covered a lot of ground in this one. Hopefully, you aren&#39;t feeling too overwhelmed!</p><p>The terminal has a well-earned reputation for being intimidating and tricky for beginners. It&#39;s totally normal if you struggle with it!</p><p>Hopefully, though, this blog post has at least cut down the scope of what you need to learn. There is a lot you can do with the terminal, but we can get by just fine focusing on a (relatively) narrow sliver.</p><p>If you found this blog post helpful, please share it with someone!</p><p><em>Also:</em> I have a bunch of other blog posts planned, all about JavaScript and React. If you&#39;d like to follow along, the best way is to sign up for my newsletter! üòÑ</p><p>I&#39;ll let you know whenever I publish new content, about once or twice a month. I also send occasional subscriber-only goodies. üç¨</p><p><strong>I hate spam as much as you do.</strong> If you decide you don&#39;t want to receive my newsletter anymore, you can unsubscribe in a single click. üí®</p></article></div></div></div>
  </body>
</html>
