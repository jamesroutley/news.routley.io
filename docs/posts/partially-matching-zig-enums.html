<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2025/08/08/partially-matching-zig-enums.html">Original</a>
    <h1>Partially Matching Zig Enums</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        
        <p>
          A short post about a neat little Zig idiom. Consider your average {sum
          type, variant, tagged union, enum, alt}:
        </p>

        <figure>
          <pre><code><span><span>enum</span> <span>U</span> {</span>
<span>    <span>A</span>(<span>i32</span>),</span>
<span>    <span>B</span>(<span>i32</span>),</span>
<span>    C,</span>
<span>}</span></code></pre>
        </figure>
        <p>Usually, you handle it like this:</p>

        <figure>
          <pre><code><span><span>match</span> u {</span>
<span>    U::<span>A</span>(_) =&gt; <span>handle_a</span>(),</span>
<span>    U::<span>B</span>(_) =&gt; <span>handle_b</span>(),</span>
<span>    U::C =&gt; <span>handle_c</span>(),</span>
<span>}</span></code></pre>
        </figure>
        <p>
          But once in a while, there’s common handling code you want to run for
          several variants. The most straightforward way is to duplicate:
        </p>

        <figure>
          <pre><code><span><span>match</span> u {</span>
<span>    U::<span>A</span>(_) =&gt; {</span>
<span>        <span>handle_ab</span>();</span>
<span>        <span>handle_a</span>();</span>
<span>    }</span>
<span>    U::<span>B</span>(_) =&gt; {</span>
<span>        <span>handle_ab</span>();</span>
<span>        <span>handle_b</span>();</span>
<span>    }</span>
<span>    U::C =&gt; <span>handle_c</span>(),</span>
<span>}</span></code></pre>
        </figure>
        <p>
          But this gets awkward if common parts are not easily extractable into
          function. The “proper” way to do this is to refactor the enum:
        </p>

        <figure>
          <pre><code><span><span>enum</span> <span>U</span> {</span>
<span>    <span>AB</span>(AB),</span>
<span>    C</span>
<span>}</span>
<span></span>
<span><span>enum</span> <span>AB</span> {</span>
<span>    <span>A</span>(<span>i32</span>),</span>
<span>    <span>B</span>(<span>i32</span>),</span>
<span>}</span></code></pre>
        </figure>
        <p>
          This gets <em>very</em> awkward if there’s one hundred usages of <code>U</code>, 95 of them look better with flat structure, one needs
          common code for ab case, and the four remaining need common code for
          ac.
        </p>
        <p>
          The universal recipe for solving the AB problem relies on a runtime
          panic:
        </p>

        <figure>
          <pre><code><span><span>match</span> u {</span>
<span>    U::<span>A</span>(_) | U::<span>B</span>(_) =&gt; {</span>
<span>        <span>handle_ab</span>();</span>
<span>        <span>match</span> u {</span>
<span>            U::<span>A</span>(_) =&gt; <span>handle_a</span>(),</span>
<span>            U::<span>B</span>(_) =&gt; <span>handle_b</span>(),</span>
<span>            _ =&gt; <span>unreachable!</span>(),</span>
<span>        }</span>
<span>    }</span>
<span>    U::C =&gt; <span>handle_c</span>(),</span>
<span>}</span></code></pre>
        </figure>
        <p>
          And… this is fine, really! I wrote code of this shape many times, and
          it never failed at runtime due to a misapplied refactor later. Still,
          every time I write that <code>unreachable</code>, I die inside a
          little. Surely there should be some way to explain to the compiler
          that <code>c</code> is really unreachable there? Well, as I realized
          an hour ago, in Zig, you can!
        </p>
        <p>
          This is the awkward runtime-panicky and theoretically brittle version:
        </p>

        <figure>
          <pre><code><span><span>switch</span> (u) {</span>
<span>    .a, .b =&gt; <span>|</span>_, ab<span>|</span> {</span>
<span>        handle_ab();</span>
<span>        <span>switch</span> (ab) {</span>
<span>            .a =&gt; handle_a(),</span>
<span>            .b =&gt; handle_b(),</span>
<span>            <span>else</span> =&gt; <span>unreachable</span>,</span>
<span>        }</span>
<span>    },</span>
<span>    .c =&gt; handle_c(),</span>
<span>}</span></code></pre>
        </figure>
        <p>And here’s a bullet-proof compiler-checked one:</p>

        <figure>
          <pre><code><span><span>const</span> U = <span>union</span>(<span>enum</span>) {</span>
<span>    a: <span>i32</span>,</span>
<span>    b: <span>i32</span>,</span>
<span>    c,</span>
<span>};</span>
<span></span>
<span><span>fn</span><span> handle</span>(u: U) <span>void</span> {</span>
<span>    <span>switch</span> (u) {</span>
<span>        <span>inline</span> .a, .b =&gt; <span>|</span>_, ab<span>|</span> {</span>
<span>            handle_ab();</span>
<span>            <span>switch</span> (ab) {</span>
<span>                .a =&gt; handle_a(),</span>
<span>                .b =&gt; handle_b(),</span>
<span>                <span>else</span> =&gt; <span>comptime</span> <span>unreachable</span>,</span>
<span>            }</span>
<span>        },</span>
<span>        .c =&gt; handle_c(),</span>
<span>    }</span>
<span>}</span>
<span></span>
<span><span>fn</span><span> handle_ab</span>() <span>void</span> {}</span>
<span><span>fn</span><span> handle_a</span>() <span>void</span> {}</span>
<span><span>fn</span><span> handle_b</span>() <span>void</span> {}</span>
<span><span>fn</span><span> handle_c</span>() <span>void</span> {}</span>
<span></span>
<span><span>pub</span> <span>fn</span><span> main</span>() <span>void</span> { handle(.c); }</span></code></pre>
        </figure>
        <p>
          There are two tricks here. <code>inline .a, .b</code> forces the
          compiler to generate the program twice, where <code>ab</code>
          is bound to <em>comptime</em> value. The second trick is <code>comptime unreachable</code>, which instructs the compiler to fail if
          it gets to the else branch. But, because <code>ab</code> is known at
          comptime, compiler knows that <code>else</code> is in fact
          unreachable, and doesn’t hit the error.
        </p>
        <p>Adding a bug fails compilation, as intended:</p>

        <figure>
          <pre><code><span>    <span>switch</span> (u) {</span>
<span>        <span>inline</span> .a, .b, .c =&gt; <span>|</span>_, ab<span>|</span> {</span>
<span>            handle_ab();</span>
<span>            <span>switch</span> (ab) {</span>
<span>                .a =&gt; handle_a(),</span>
<span>                .b =&gt; handle_b(),</span>
<span>                <span>else</span> =&gt; <span>comptime</span> <span>unreachable</span>,</span>
<span>            }</span>
<span>        },</span>
<span>    }</span></code></pre>
        </figure>

        <figure>
          <pre><code><span><span>$</span> ./zig/zig build-exe partial-match.zig</span>
<span><span>partial-match.zig:14:34: error: reached unreachable code</span></span>
<span><span>                else =&gt; comptime unreachable,</span></span>
<span><span>                                 ^~~~~~~~~~~</span></span></code></pre>
        </figure>
      </article>
    </div></div>
  </body>
</html>
