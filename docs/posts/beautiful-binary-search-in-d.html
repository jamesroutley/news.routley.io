<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://muscar.eu/shar-binary-search-meta.html">Original</a>
    <h1>Beautiful Binary Search in D</h1>
    
    <div id="readability-page-1" class="page">


<p>Recently, while I was reading <a href="https://www.goodreads.com/book/show/128599.Writing_Efficient_Programs">“Writing
Efficient Programs”</a>, I came across a beautiful variation of binary
search and its implementation. In this post I’ll be using D’s
metaprogramming capabilities to implement a generic version of the
algorithm.</p>
<p>For the rest of the post I’m going to assume you’re familiar with
binary search, and its most common implementation–the bisection method
using two pointers.</p>
<h2 id="a-beautiful-algorithm">A beautiful algorithm</h2>
<p>There are many ways to implement a binary search. The most common is
probably using a “bisection search”, where we track the subintervals
using two pointers, one moving from left to right, the other from right
to left.</p>
<p>Another variant is the “uniform search”, where instead of using two
pointers, we use only a single pointer and a “rate of change”, i.e., the
start and the size of the subintervals. This is more subtle than
bisection search–which is not trivial by the way. In Knuth’s words:</p>
<blockquote>
<p>It is possible to do this, but only if extreme care is paid to the
details, […]. Simpler approaches are doomed to failure.</p>
</blockquote>
<p>On the other hand, uniform search has some advantages. One of them is
that the the rates of change can be precalculated, and stored in a side
table. If we get the rate of change calculation right–which is the
subtle part–the search algorithm is simpler than its cousin using two
pointers.</p>
<p>A variation of uniform search is Shar’s algorithm. It does away with
the side table, and uses power of two interval sizes.</p>
<p>It starts by comparing the the key we are looking for, <span><em>K</em></span>, with <span><em>K</em><sub><em>i</em></sub></span>, where <span><em>i</em> = 2<sup><em>k</em></sup></span>, <span><em>k</em> = ⌊<em>l</em><em>g</em><em>N</em>⌋</span>.
If <span><em>K</em> &lt; <em>K</em><sub><em>i</em></sub></span>,
the interval sizes are <span>2<sup><em>k</em> − 1</sup></span>, <span>2<sup><em>k</em> − 2</sup></span>, <span>…</span>, <span>1</span>, <span>0</span>. But if <span><em>K</em> &gt; <em>K</em><sub><em>i</em></sub></span>,
we set <span><em>i</em> = <em>N</em> − 2<sup><em>l</em></sup> + 1</span>,
where <span><em>l</em> = ⌈<em>l</em><em>g</em>(<em>N</em>−2<sup><em>k</em></sup>+1)⌉</span>,
adjust the interval pointer, and the interval sizes are <span>2<sup><em>l</em> − 1</sup></span>, <span>2<sup><em>l</em> − 2</sup></span>, <span>…</span>, <span>1</span>, <span>0</span>.</p>
<p>Shar’s algorithm determines the position of the entry with key <span><em>K</em></span> bit by bit. Each test adds one
more bit. We need one more test, after we’ve determined all the bits, to
see if the entry is actually in the table.</p>
<h2 id="a-beautiful-implementation">A beautiful implementation</h2>
<p>Bentley provides a beautiful version of Shar’s algorithm in his book.
The code works for tables with 1000 elements. The code in the book is
written in Pascal, but transliterated to D it looks like this:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>int</span> bsearch1000<span>(</span><span>int</span><span>[</span><span>1001</span><span>]</span> xs<span>,</span> <span>int</span> x<span>)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span>auto</span> i <span>=</span> <span>0</span><span>;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span><span>512</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>=</span> <span>1000</span> <span>-</span> <span>512</span> <span>+</span> <span>1</span><span>;</span> <span>}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i <span>+</span> <span>256</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>+=</span> <span>256</span><span>;</span> <span>}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i <span>+</span> <span>128</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>+=</span> <span>128</span><span>;</span> <span>}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i <span>+</span> <span>64</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>+=</span> <span>64</span><span>;</span> <span>}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i <span>+</span> <span>32</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>+=</span> <span>32</span><span>;</span> <span>}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i <span>+</span> <span>16</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>+=</span> <span>16</span><span>;</span> <span>}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i <span>+</span> <span>8</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>+=</span> <span>8</span><span>;</span> <span>}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i <span>+</span> <span>4</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>+=</span> <span>4</span><span>;</span> <span>}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i <span>+</span> <span>2</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>+=</span> <span>2</span><span>;</span> <span>}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>&lt;=</span> x<span>)</span> <span>{</span> i <span>+=</span> <span>1</span><span>;</span> <span>}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>i<span>]</span> <span>==</span> x<span>)</span> <span>return</span> i<span>;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span>else</span> <span>return</span> <span>0</span><span>;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>There’s a few things going on here. First, the odd array size, 1001.
Pascal arrays are one-based. D follows in C’s footsteps with zero-based
arrays. We just ignore <code>xs[0]</code> in this case. This is a bug by
the way. Bentley acknowledges it, but he doesn’t provide a fix since he
considers it would detract from the exposition. We can fix it by setting
<code>i</code> to <code>1</code> initially, and making the necessary
code adjustments. This would complicate the code somewhat. Another way
to fix it by explicitly checking if <code>i</code> is <code>0</code> in
the last test.</p>
<p>Second, the code fully unrolls the search loop. This is only possible
because we know the size of the table beforehand. The code can be
adjusted for other table sizes as needed.</p>
<p>What makes this code beautiful is that it’s about as efficient as it
could be. It’s also uniform, and relatively easy to understand if you
know about Shar’s algorithm. It’s an almost word for word rendition of
the algorithm tailored for this particular table size.</p>

<p>Beautiful as it is, Bentley’s code is somewhat tedious to adjust to
other table sizes, and it’s easy to make mistakes while calculating the
initial value of <code>i</code>. The code is very repetitive and
uniform. This is a strong hint that we can automate writing it.</p>
<p>This is where D’s powerful metaprogramming capabilities come in. If
we can determine the size of the table at compile time, we could in
principle generate the code for the unrolled loop automatically.</p>
<p>Let’s focus on the first of these problems: determining the size of
the table. If the table is implemented with a static array we can
determine its size at compile time, since the size is part of the
type.</p>
<p>Although I expected D’s standard library to have a utility for
exactly this case, I couldn’t find one. But, as it turns out, it’s quite
easy to write:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>template</span> StaticArraySize<span>(</span>T<span>)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>isStaticArray<span>!</span>T<span>)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span>static</span> <span>if</span> <span>(</span><span>is</span><span>(</span>T <span>==</span> E<span>[</span>n<span>],</span> E<span>,</span> <span>int</span> n<span>))</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span>enum</span> StaticArraySize <span>=</span> n<span>;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We can use the <code>is</code> expression to check if <code>T</code>
is a static array and extract its size. That is neat. The extra check
<code>isStaticArray!T</code> is not strictly necessary, but it improves
the error message if <code>StaticArraySize</code> is called with a type
that’s not a static array.</p>
<p>Like C++, the <code>static if</code> is evaluated at compile time.
Unlike C++, it doesn’t introduce a new scope. The <code>enum</code> is
going to be generated in the scope of the <code>template</code>. And
since the <code>enum</code> has the same name as the
<code>template</code>, the whole value of the <code>template</code> is
going to be <code>n</code>, a compile time value.</p>
<p>With the <code>StaticArraySize</code> out of the way, we can focus on
code generation. The algorithm has three parts:</p>
<ol type="1">
<li><p>The initial test, comparing the search key <span><em>K</em></span> with <span><em>K</em><sub><em>i</em></sub></span> for <span><em>i</em> = 2<sup><em>k</em></sup></span>, <span><em>k</em> = ⌊<em>l</em><em>g</em><em>N</em>⌋</span>;</p></li>
<li><p>Determining successive bits of the candidate position by
iterating over powers of two; and</p></li>
<li><p>Checking if the we found the element we are looking for.</p></li>
</ol>
<p>I’m going to show the function signature first, since it’s a bit
complicated, and I’m going to explain every bit of it after.</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>auto</span> bsearch<span>(</span>T<span>,</span> U <span>=</span> ArrayElementType<span>!</span>T<span>,</span> <span>int</span> n <span>=</span> StaticArraySize<span>!</span>T<span>,</span> <span>int</span> k <span>=</span> iflog2<span>(</span>n <span>-</span> <span>1</span><span>))(</span>T xs<span>,</span> U x<span>)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span></code></pre></div>
<p>While this looks complicated, it’s cleaner than what we’d get in C++.
Let’s take each template parameter in turn and see what it means.</p>
<p><code>T</code> is the table type. <code>U</code> is the element type.
<code>ArrayElementType</code> is a template very similar to
<code>StaticArraySize</code> that evaluates to the type of the elements
of an array–static or dynamic, it doesn’t matter. <code>n</code> is the
size of the array. Like C++, D can have both type and value template
parameters. We use <code>StaticArraySize</code> as the default value of
<code>n</code>–remember, <code>StaticArraySize</code> is a compile time
value. This allows us to pass the size of the array explicitly, but I’m
just using it as a compile time assignment in this case. Not that the
call to <code>StaticArraySize</code> also acts as a type guard on
<code>T</code>. Instantiating the template with a <code>T</code> that is
not a static array will fail. Then we determine <span><em>k</em></span>, the power of two where we start
the search. <code>iflog2</code> stands for <i>i</i>nteger <i>f</i>loor
<i>log</i>arithm in base <em>2</em>. This is a regular D function, but
it can be evaluated at compile time when called with a compile time
value, which is what we do here.</p>
<p>Phew, that was a lot. Compare to the template parameters, the regular
parameters are almost boring: the table <code>xs</code> and the key
<code>x</code> we are looking for.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>The initial test is just the code rendition of the test in Shar’s
algorithm:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span>auto</span> p <span>=</span> <span>0</span><span>;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>xs<span>[</span>pow<span>(</span><span>2</span><span>,</span> k<span>)]</span> <span>&lt;=</span> x<span>)</span> p <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>-</span> pow<span>(</span><span>2</span><span>,</span> k<span>)</span> <span>+</span> <span>1</span><span>;</span></span></code></pre></div>
<p>We track the position of the candidate element in <code>p</code>.</p>
<p>Now for the fun bit, generating the power of two tests:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span>static</span> <span>foreach_reverse</span> <span>(</span><span>int</span> i<span>;</span> <span>0</span> .. k<span>)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span>if</span> <span>(</span>xs<span>[</span>p <span>+</span> pow<span>(</span><span>2</span><span>,</span> i<span>)]</span> <span>&lt;=</span> x<span>)</span> p <span>+=</span> pow<span>(</span><span>2</span><span>,</span> i<span>);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span></code></pre></div>
<p>This code is remarkably short thanks to the problem’s regularity we
mentioned earlier, and to D’s powerful metaprogramming capabilities.
Like the <code>static if</code>, a <code>static foreach</code> doesn’t
introduce a new scope. The code inside is just “spliced” in the code of
the surrounding function. In effect, this snippet generates a series of
<code>if</code> statements equivalent to the one in
<code>bsearch1000</code>. We use <code>foreach_reverse</code> to iterate
over the the exponents <span><em>k</em></span> to
<span>1</span>–the range <code>0 .. k</code> is
open, and we’re iterating over it in reverse. The choice of
<code>foreach_reverse</code> as a keyword is somewhat unfortunate. There
may be a cleaner way of achieving the same result, but I don’t use D
regularly, so this is what I came up with :^).</p>
<p>Once we’ve determined all the bits of the candidate element position
<code>p</code> all that’s left to do is to check if the element we’re
looking for is at that position.</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>p <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> xs<span>[</span>p<span>]</span> <span>==</span> x<span>)</span> <span>return</span> p<span>;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>0</span><span>;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>And with this we’re done. If we check the code generated for
<code>bsearch1000</code> and <code>bsearchDI</code> on <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1AB9U%2BlJL6yAngGVG6AMKpaAVxYMQAJg2kHAGTwGTAA5dwAjTGIQADYY0gAHVAVCWwZnNw9vXySUmwFA4LCWSOi4i0wrfIYhAiZiAgz3Tx8KqrTa%2BoJC0Iio2PiFOoamrNahrp7i0oGASgtUV2Jkdg48FiSGgGoh9AA6fmIWJgIAUgBmACFTjQBBdc2CHYJ944IEPcxVJODBPDELtc7g8SE9dns3h9iIsGPgjICbvcNqDnvtiIZgJgEcDkdtwbtbNikY9UXsCOjCAoiYigk9wkp6sgEFwNKyILTTgBWS4sjRcLkAES2qgUpC2tOFs0RpwA7EDbjcAJxMVxEcVbC5CjTUjSKvBULYQEVcy6crheQUa86OTWSjVy9W23kaLYAWi2Zq8Gq8ly2/Ku9oF0t1%2BsNxu5eFOPq8nJilouNvOQtUs3tvrw3uuSa2MbjAdlQbuStDRqpEajPK8AA549bbSm046fU7q4DA8G9QbSybIz6YpJa4nk6nZenM7b%2B22Cx2S%2BHLr3LucLZyhQn6yOHRmK7al1OZYWFSGu3OF1w4yurUO7aOm1mhWe9wfi8ey/OKzWL2vsw2b1vm9ma3zfcZxfHsKwHT862/Dcx23bMByAp8jzDV8F2XVcoOHRs/zvHNHxAlCwJ9flIKvH9N3HbN/V9aci11Aju3LSCg2grZiEwAglgYcUdUVSolDYjiuK2bUrmlYC6NuAhMA2AxpK2W5iHRABPbB6DYQQABVlISTAIE0rYQC2TSTUFKUizlDsxH%2BBRjIUpSmFU9TGAIbTdOpCTDykmSEjkzAtk6GxkEUlShDwAAvPTNPMw9O0NPAFECvBgoc5SwDAaLxPlJUJiC8UuwS/SrRYoVsBNBhBTFbAxQlBhZhipUlUYdwArqIKQscsLIuKrYKrEiykPuQR8toVBgC8dlhrqrKO3YzjiG40QhkmghUyoUaSAgUbxogbj3S4eqPMGlU1XpTBGQQfSxTkHqOqcmSXLczB0s0mqpp6pKUtCiLnoyt6ngAax6/Vtomva/XqoqRWuyVES2eH8vixK2uSu6Xoayy6OVVVUC2BIetE7KsdnV8kgAdwgLwxQBqVSPXPGet2t0IeZ8nKepkcfT9HVYty5KtkOc6mWMdiADcogElaeIDF09j2LYaY7UcleQxjLnxis8dQCmqfFWmMLI1MNf/IU2d1vApX62LaK859DQ185sBE704y8GJhVJ2sSrtObhISXjfYWkSjuDW5RdQPB0C2Y4gggDGib1QQTV5EjkypK2lUOQ0TtxrcqLbPOr2dAvtx9Br6N1E8vfVAAqPCrYR8V3qdVlCZnYaHa1IlG87rYzou51SzFZ1LflRuyeIQhKgYXaxSjL1NQuJ357FBI568C18w3sU539ldR7hhHe/75ZLuhv1W4Pu5x8n6TaBnhh14XpMl%2B9XW17fqdt49k094FK%2BFSeQ4PMWgnBOS8E8BwLQpBUCcCFAoRYyx/JRnODwUgBBNDAPmADEAnJfCgI4JICBmCYGcF4AoEAvgMFQOAaQOAsAkBoA2HQKI5BKBMISCw6ItB0DIC4MYc4vgsCi2SpgAAangTAZMADyulIFoJoLQaSxAKEQHCCQ8IQR6jKU4GgzRzBiDKWkeEbQmBrC6N4EwjSBBpEMFoDomhpAsDHCMOIRx%2BB2LWDwOLChjivhmNVKsNBtJKgkNoHgcI6JDHOCwCQ8k6wLHzHWkwYACgJFSNkYwCxMhBAiDEOwKQOT5BKDUCQ3QXB9AYhAKYYw5hwn0ngPMVACRqi%2BNdNIrw5DKhmOqPYWEoxPAVICEEXoJR%2BgVNyKkAQAy9CTOqFMPo0QKmWB6R0YYjQXDND0CsrxAhOgNAWWMpZFh1kzOWesw5MwDoLCWCsCQICwHEMcbAjgWweHID9HsQRewXQQFwIQEg3pUGzF4NQrQ9VSA4LwfoTgRDSCQOgS88hlD0GYIhQQzp8KSFItRTQiF4sVFpBAJIIAA%3D%3D">the
compiler explorer</a>. we see that’s it’s virtually the same up. The D
compiler even inlined the compile time constants for us.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Shar’s algorithm is a beautiful variation of binary search. If we
know the table size in advance we can write an efficient binary search
algorithm using it.</p>
<p>Bentley’s implementation is also beautiful because it squeezes every
bit of performance from the code. The code does no more than it should,
and there is a Zen kind of beauty to it.</p>
<p>D’s metaprogramming capabilities allowed us to take Bentley’s
beautiful code, and make it more general. We can generate the code for
any table size if we know it at compile time.</p>
<p>While I didn’t show it here, we can use similar techniques to
determine if we’re dealing with a static or dynamic array at compile
time. If we have a static array we can use our version of binary search.
Otherwise we can fall back to a more general version. Andrei
Alexandrescu calls this technique “Design by Introspection”.</p>
<p>D is a fun language to program in. It shines for this kind of
problems, where you can make heavy use of metaprogramming. I haven’t
used any other language where this problem could be expressed as
cleanly, except maybe Common Lisp. I’d be curious to see a solution in
Rust (which has a strong macro system) and Zig (which I read has strong
support for metaprogramming as well).</p>



</div>
  </body>
</html>
