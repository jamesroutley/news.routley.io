<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://systemsapproach.org/2026/02/09/faster-than-dijkstra/">Original</a>
    <h1>Faster Than Dijkstra?</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Last year a couple of people forwarded to me the same article on a <a href="https://www.quantamagazine.org/new-method-is-the-fastest-way-to-find-the-best-routes-20250806/">new method of finding shortest paths in networks</a>. The <a href="https://arxiv.org/pdf/2504.17033">underlying research</a> claims to improve on the classic approach pioneered by <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Dijkstra</a> that is taught in most networking textbooks (including <a href="https://book.systemsapproach.org/internetworking/routing.html#link-state-ospf">ours</a>). I was initially a bit skeptical, much as I would be if I read that the <a href="https://en.wikipedia.org/wiki/Riemann_hypothesis">Riemann Hypothesis</a> had been proved. Dijkstra is a legend in computer science and his algorithm, which he published in 1959, predates packet switching by a few years. The <a href="https://datatracker.ietf.org/doc/html/rfc2328">specification for OSPF</a>, one of two dominant link-state routing protocols (IS-IS is the other), is unusually detailed in its guidance to implementors, and it basically tells them to use Dijkstra’s algorithm. And that is what most implementations have done for decades, with a few minor improvements through the years to speed up the implementation but no real change to the fundamentals. </p>



<p>The new algorithm is no minor tweak to Dijkstra’s but a significantly different approach. Its headline claim is that, whereas Dijkstra requires a sorting operation, and thus is only able to perform as well as the best sorting algorithm, this new approach “breaks the sorting barrier”. That is, it avoids the need for sorting, and is able to deliver better bounds on performance than Dijkstra.</p>



<p>While I don’t consider myself qualified to evaluate the paper that describes the new algorithm, it has passed peer-review at a top-tier conference (<a href="https://acm-stoc.org">ACM Symposium on the Theory of Computing</a>) and received enough scrutiny that I don’t doubt that the theory works. The question I want to discuss here is: does it matter?</p>



<p>Two main issues came immediately to mind when I tried to assess the implications of a theoretical improvement in algorithmic performance. The first is, what are the actual scaling limits that we need to address in a real routing system. For example, the running time of Dijkstra’s algorithm is on the order of (<em>n log n + m) </em>for a network of <em>n</em> vertices (routers) and <em>m</em> edges (links). The new approach claims order  (<em>m log</em><em><sup>2/3</sup></em><em> n)</em> which is clearly going to be less for large enough <em>n</em>. (I had to take a refresher course on log notation before I could even write that sentence with any confidence.) The problem with assessing the scaling properties of anything is you have to wonder how big <em>n</em> must get before it makes a difference. There are constant factors that might differ between the two approaches; at small <em>n,</em> a “less scalable” approach might actually display better performance. </p>



<h2>What scaling limit?</h2>



<p>One of my first jobs was part of the team building a <a href="https://ieeexplore.ieee.org/document/105175">scalable packet switch</a> based on arrays of small switching elements. (This is where I got to build the <a href="https://systemsapproach.org/2021/03/15/the-accidental-smartnic/">accidental SmartNIC</a>). We had papers to show that we could build switches with thousands of ports at 155 Mbps, in an era when shared Ethernet ran at 10 Mbps and had not yet been overtaken by switched Ethernet. While we at Bellcore were investing lots of time and money to put together a set of 32-port prototype switches, <a href="https://en.wikipedia.org/wiki/FORE_Systems">FORE systems</a> delivered commercially successful 16-port switches.  Almost certainly they were not as scalable as our design, but it turned out that <em>n</em>=16 was a pretty useful capacity for switches with 155 Mbps links in the 1990s. We felt quite sad that our research seemed to have been overtaken by commercial products. My takeaway was that scalability was a good thing to strive for but that sometimes you might achieve a good result with a less scalable solution. One of my favorite text books, “<a href="https://ocw.mit.edu/courses/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/pages/online-textbook/">Principles of Computer Systems Design</a>”, uses the example of stopping a <a href="https://en.wikipedia.org/wiki/Oil_tanker">supertanker</a> to demonstrate the scaling limits of a system. The fact that supertankers have a scaling limit doesn’t prevent them from being the backbone of oil shipping. You just need to avoid making them too big.</p>



<p>What’s a large value for <em>n</em> in SPF calculations? I checked in with a couple of colleagues to update my recollection of how many routers you might find in a big OSPF or IS-IS backbone. In my memory it was in the hundreds; for the largest service provider networks today it seems to be in the small number of thousands. So that’s not tiny but it’s small compared to, say, the number of prefixes carried in BGP.</p>



<p>And it doesn’t seem to be limited by the performance of the SPF calculation, as I will explain below.</p>



<h2>The many facets of performance</h2>



<p>Another memory I have from my time working for Big Router was an analysis of all the things that go into the performance of routing protocols. I was working on MPLS in its early days, and we were pretty excited about a technology called “fast reroute” (FRR) which uses MPLS to divert packets around a failed link without waiting for routing to converge after the failure. But at the same time, the people responsible for routing protocol development were hard at work improving routing convergence times. One of the most important things, it turns out, for both MPLS and standard routing, was simply <em>detecting failure faster</em>. For example, if you have to wait for tens of seconds of missing OSPF Hello packets before you declare a link down, it doesn’t really matter if you can calculate the shortest path in a fraction of a second. This was the reasoning behind the creation of <a href="https://www.rfc-editor.org/rfc/rfc5880">BFD (Bidirectional Forwarding Detection)</a>: a fast mechanism, independent of routing, by which link failures could be detected for any type of link.  </p>



<p>Beyond fast failure detection, other factors playing into routing convergence include: the time to send a new link state packet out a link and propagation delay across the network; time to receive such a packet and dispatch it to the right process in the operating system; SPF time; time to update the routing information base; time to calculate the impact on the forwarding table; time to push any forwarding table updates out to the line cards (on big routers that have such things); time to flood the link state packet out to neighbors. All of these steps have been analyzed and optimized over the years, to the point where sub-second routing convergence is now routine. As early as 2003 the improvements to all the steps above had enabled sub-second convergence, as <a href="https://archive.nanog.org/meetings/nanog29/presentations/filsfils.pdf">this NANOG presentation</a> shows. Yes, you couldn’t afford to spend 10 seconds doing an SPF calculation if you wanted fast convergence, but that was already a solved issue by then. Optimizing all the other parts was at least as important as improving the SPF calculation time.</p>



<p>Finally, I chatted with another colleague about this topic and he reminded me of a reason that Dijkstra’s algorithm remains the implementation method of choice: it can be understood by the people who have to write code. Dijkstra himself puts it well in a 2001 interview:</p>



<blockquote>
<p>The publication is still readable, it is, in fact, quite nice. One of the reasons that it is so nice was that I designed it without pencil and paper. I learned later that one of the advantages of designing without pencil and paper is that you are almost forced to avoid all avoidable complexities.</p>
</blockquote>



<p>In other words, <a href="https://book.systemsapproach.org/internetworking/routing.html#key-kiss">Keep It Simple, Stupid</a>. I would certainly rather point an engineer at the <a href="https://www.rfc-editor.org/info/rfc2328">OSPF spec</a> than send them off to understand the <a href="https://arxiv.org/pdf/2504.17033">hybrid Bellman-Ford/Dijkstra</a> approach that might shave a few milliseconds off the non-bottleneck part of routing convergence. Maybe one day someone will write the explanation of the novel SPF approach that is as clear as Dijkstra’s paper and the OSPF spec. And the hybrid algorithm might be great for large mapping applications. But I don’t see Dijkstra’s algorithm being replaced in production routers any time soon.</p>



<hr/>



<p>Following up on our <a href="https://systemsapproach.org/2026/01/12/in-memory-of-frank-gehry/" type="post" id="139611283">recent post on Frank Gehry</a>, the New York Review of Books has <a href="https://www.nybooks.com/online/2025/12/12/the-liberator-frank-gehry/?utm_source=nybooks&amp;utm_medium=email&amp;utm_campaign=email-share">a good article on him</a> from an actual architecture critic.</p>



<p><a href="https://taranis.ie/datacenters-in-space-are-a-terrible-horrible-no-good-idea/">Datacenters in space are a terrible idea</a> and you can <a href="https://docs.fcc.gov/public/attachments/DA-26-113A1.pdf">tell the FCC</a> if you’re motivated. </p>



<p><a href="https://wikiedu.org/?p=137628">Wiki Education has studied the AI slop</a> being submitted to Wikipedia and found that LLM-generated references are often plausible-looking but don’t contain the stated content. It’s almost like <a href="https://systemsapproach.org/2023/08/21/looking-inside-large-language-models/" type="post" id="136261051">LLMs don’t know what they are talking about</a>. <a href="https://en.wikipedia.org/wiki/Wikipedia:WikiProject_AI_Cleanup">There is a project</a> to clean up such articles. </p>



<p>Preview image by <a href="https://unsplash.com/@shioyang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Shio Yang</a> on <a href="https://unsplash.com/photos/aerial-view-of-city-during-night-time-b6i9pe16pAg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
</div></div>
  </body>
</html>
