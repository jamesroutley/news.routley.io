<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stackoverflow.blog/2022/04/06/use-git-tactically/">Original</a>
    <h1>Use Git tactically</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<p>In the movie <a href="https://en.wikipedia.org/wiki/Free_Solo">Free Solo</a> the rock climber <a href="https://en.wikipedia.org/wiki/Alex_Honnold">Alex Honnold</a> trains to perform a <a href="https://en.wikipedia.org/wiki/Free_solo_climbing">free solo climb</a> of <a href="https://en.wikipedia.org/wiki/El_Capitan">El Capitan</a>, a mountain in <a href="https://en.wikipedia.org/wiki/Yosemite_National_Park">Yosemite</a>.</p>



<figure><img src="https://lh6.googleusercontent.com/AyHGvbCgBksn0jbUyG0hthGUaRcYHpGu9gf_Z_9JRO3NmPeMg0qjus_6SbAFmR1c13559r2jVNyxDmijFxlhw8pc1Nb43chY8nUGGdIdDIyWHk5ZqE14cQwMNIYtv7z8li2DD6sk" alt=""/><figcaption>(El Capitan. <a href="https://commons.wikimedia.org/wiki/File:Yosemite_El_Capitan.jpg">Photo by Mike Murphy, 2005</a>.)</figcaption></figure>



<p>It’s a good movie, but if you haven’t seen it, <em>free solo climbing</em> is when you scale a rock face without ropes, harness, or safety equipment. If you lose your grip and fall, you’ll die. El Capitan, just to rub it in, is 914 meters of vertical rock. Free-climbing it is an incredible endeavor, but Honnold gets it done by <em>committing </em>to one move at a time (this article is about using Git, after all). </p>







<p>Honnold didn’t just free-climb El Capitan. He trained deliberately towards the goal of free climbing El Capitan.</p>



<p>The documentary shows how he repeatedly climbs El Capitan <em>with</em> safety equipment. He plans a route and climbs it several times. On each of the training ascensions, he’s using ropes, a harness, and various fasteners for the ropes. When he falls during training, he doesn’t fall far, because the rope, harness, and fasteners stop the fall at the last point of fixation.</p>



<p>It’s almost like a <a href="https://en.wikipedia.org/wiki/Saved_game">video game save point</a>.</p>



<p>In one memorable scene, Honnold considers a jump from one position to another. Hundreds of meters in the air, parallel to a vertical rock face. It’s a truly precarious maneuver. If he fails, he’ll die.</p>



<p>Or, that’s true for the free climb. At first, he rehearses the move using rope and harness. This enables him to perform a potentially fatal jump in relative safety. When it goes wrong, he’s back at where he fixed his rope, and he may try again.</p>



<p>When you’re making large code changes, even migrating to a new implementation, you can create save points to prevent catastrophes. Like Alex Honold, you can fix your code in place to give you a better chance to get to the next successful build.  </p>







<p>When you edit code, you go from one working state to another, but during the process, the code doesn’t always run or compile.</p>



<p>Consider an interface like this:</p>



<pre><code>public interface IReservationsRepository
{
    Task Create(Reservation reservation);
 
    Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; ReadReservations(
        DateTime dateTime);
 
    Task&lt;Reservation?&gt; ReadReservation(Guid id);
 
    Task Update(Reservation reservation);
 
    Task Delete(Guid id);
}
</code></pre>



<p>This, as most of the code in this article, is from my book <a href="https://blog.ploeh.dk/code-that-fits-in-your-head">Code That Fits in Your Head</a>. As I describe in the section on the <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">Strangler Fig pattern</a>, at one point I had to add a new method to the interface. The new method should be an overload of the <code>ReadReservations</code> method with this signature:</p>



<p><code>Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; ReadReservations(DateTime min, DateTime max);</code></p>



<p>Once you start typing that method definition, however, your code no longer works:</p>



<pre><code>Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; ReadReservations(
    DateTime dateTime);
 
T
 
Task&lt;<span>Reservation?</span>&gt; <span>ReadReservation</span>(Guid id);</code></pre>



<p>If you’re editing in Visual Studio, it’ll immediately light up with red squiggly underlines, indicating that the code doesn’t parse.</p>



<p>You have to type the entire method declaration before the red squiggly lines disappear, but even then, the code doesn’t compile. While the interface definition may be syntactically valid, adding the new method broke some other code. The code base contains classes that implement the <code>IReservationsRepository</code> interface, but none of them define the method you just added. The compiler knows this, and complains:</p>



<blockquote><p>Error CS0535 ‘SqlReservationsRepository’ does not implement interface member ‘IReservationsRepository.ReadReservations(DateTime, DateTime)’</p></blockquote>



<p id="h-there-s-nothing-wrong-with-that-i-m-just-trying-to-highlight-how-editing-code-involves-a-transition-between-two-working-states">There’s nothing wrong with that. I’m just trying to highlight how editing code involves a transition between two working states:</p>



<figure><img src="https://lh6.googleusercontent.com/MG3WYGF56Y9qGZ86meWq6VP3cRUR09mNsECttj_-J9kQw-0eNX3dZ3x5L8egVwrxfZbsiM5kbsMcnWaWOCu1SETDp2tKUDPTeF8XiT7QBXAVmKxfIGlz0_e8LoBJmYAhBlA9k-X1" alt=""/></figure>



<p>In <em>Free Solo</em> the entire climb is dangerous, but there’s a particularly perilous maneuver that Alex Honnold has to make because he can’t find a safer route. For most of the climb, he climbs using safer techniques, moving from position to position in small increments, never losing grip or footing as he shifts his center of gravity.</p>



<p>There’s a reason he favors climbing like that. It’s safer.</p>







<p>You can’t edit code without temporarily breaking it. What you can do, however, is move in small, deliberate steps. Every time you reach a point where the code compiles and all tests pass: commit the changes to Git.</p>



<p>Tim Ottinger calls this a <a href="https://www.industriallogic.com/blog/whats-this-about-micro-commits/">micro-commit</a>. Not only should you commit every time you have a green bar—you should deliberately move in such a way that the distance between two commits is as short as possible. If you can think of alternative ways to change the code, choose the pathway that promises the smallest steps.</p>



<p>Why make dangerous leaps when you can advance in small, controlled moves?</p>



<figure><img src="https://lh3.googleusercontent.com/B423apacO22lIXT2lPSfAJkpusgABGa0aqg6fSJZ5iFaCSvuZYFrzUH5CERwXqs25nWrSVznIvgoeNg9W3cxVXmzVW-cQfREPuVwwVi9zS7MLP1fFas8J3zMLa0iSCJfl_JtKFhI" alt=""/></figure>



<p>Git is a wonderful tool for maneuverability. Most people don’t think of it like that. They start programming, and hours later, they may commit to Git in order to push a branch out.</p>



<p>Tim Ottinger doesn’t do that, and neither do I. I use Git tactically.</p>



<p>I’ll walk you through an example.</p>







<p>As described above, I wanted to add a <code>ReadReservations</code> overload to the <code>IReservationsRepository</code> interface. The motivation for that is described in <a href="https://blog.ploeh.dk/code-that-fits-in-your-head">Code That Fits in Your Head</a>, but that’s not the point here. The point is to use Git to move in small increments.</p>



<p>When you add a new method to an existing interface, the code base fails to compile when you have existing classes that implement that interface. How do you deal with that situation?  Do you just forge ahead and implement the new method? Or are there alternatives?</p>



<p>Here’s an alternative path that moves in smaller increments.</p>



<p>First, <em>lean on the compiler</em> (as <a href="https://blog.ploeh.dk/ref/wewlc">Working Effectively with Legacy Code</a> puts it). The compiler errors tell you which classes lack the new method. In the example code base, it’s <code>SqlReservationsRepository</code> and <code>FakeDatabase</code>. Open one of those code files, but don’t do anything yet. Instead, copy the new <code>ReadReservations</code> method declaration to the clipboard. Then stash the changes:</p>



<p><code>$ git stash</code></p>



<p><code>Saved working directory and index state WIP on tactical-git: [...]</code></p>



<p>The code is now back in a working state. Now find a good place to add the new method to one of the classes that implement the interface.</p>







<p>I’ll start with the <code>SqlReservationsRepository</code> class. Once I’ve navigated to the line in the file where I want to add the new method, I paste in the method declaration:</p>



<pre><code><code>Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; ReadReservations(DateTime min, DateTime max);</code></code></pre>



<p>That doesn’t compile because the method ends with a semicolon and has no body.</p>



<p>So I make the method <code>public</code>, delete the semicolon, and add curly brackets:</p>



<pre><code>public Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; <span>ReadReservations</span>(DateTime min, DateTime max)
{

}
</code></pre>



<p>This still doesn’t compile, because the method declaration promises to return a value, but the body is empty.</p>



<p>What’s the shortest way to a working system?</p>



<pre><code>public Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; ReadReservations(DateTime min, DateTime max)
{
    throw new NotImplementedException();
}
</code></pre>



<p>You may not want to commit code that throws <code>NotImplementedException</code>, but this is in a brand-new method that <em>has no callers</em>. The code compiles and all tests pass—of course they do: no existing code changed.</p>



<p>Commit the changes:</p>



<pre><code>$ git add . &amp;&amp; git commit
[tactical-git 085e3ea] Add ReadReservations overload to SQL repo
 1 file changed, 5 insertions(+)</code></pre>



<p>This is a <em>save point</em>. Saving your progress enables you to back out of this work if something else comes up. You don’t have to push that commit anywhere. If you feel icky about that <code>NotImplementedException</code>, take comfort that it exists exclusively on your hard drive.</p>



<p>Moving from the old working state to the new working state took less than a minute.</p>



<p>The natural next step is to implement the new method. You may consider doing this incrementally as well, using TDD as you go, and committing after each <em>green</em> and <em>refactor</em> step (assuming you follow the <a href="https://blog.ploeh.dk/2019/10/21/a-red-green-refactor-checklist">red-green-refactor checklist</a>).</p>



<p>I’m not going to do that here because I try to keep <code>SqlReservationsRepository</code> a <a href="https://martinfowler.com/bliki/HumbleObject.html">Humble Object</a>. The implementation will turn out to have a <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a> of <em>2</em>. Weighed against how much trouble it is to write and maintain a database integration test, I consider that sufficiently low to forgo adding a test (but if you disagree, nothing prevents you from adding tests in this step).</p>



<pre><code>public async Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; ReadReservations(DateTime min, DateTime max)
{
    const string readByRangeSql = @&#34;
        SELECT [PublicId], [Date], [Name], [Email], [Quantity]
        FROM [dbo].[Reservations]
        WHERE @Min &lt;= [Date] AND [Date] &lt;= @Max&#34;;
 
    var result = new List&lt;Reservation&gt;();
 
    using var conn = new SqlConnection(ConnectionString);
    using var cmd = new SqlCommand(readByRangeSql, conn);
    cmd.Parameters.AddWithValue(&#34;@Min&#34;, min);
    cmd.Parameters.AddWithValue(&#34;@Max&#34;, max);
 
    await conn.OpenAsync().ConfigureAwait(false);
    using var rdr = await cmd.ExecuteReaderAsync().ConfigureAwait(false);
    while (await rdr.ReadAsync().ConfigureAwait(false))
        result.Add(
            new Reservation(
                (Guid)rdr[&#34;PublicId&#34;],
                (DateTime)rdr[&#34;Date&#34;],
                new Email((string)rdr[&#34;Email&#34;]),
                new Name((string)rdr[&#34;Name&#34;]),
                (int)rdr[&#34;Quantity&#34;]));
 
    return result.AsReadOnly();
}
</code></pre>



<p>Granted, this takes more than a minute to write, but if you’ve done this kind of thing before, it probably takes less than ten—particularly if you’ve already figured the <code>SELECT</code> statement out on beforehand, perhaps by experimenting with a query editor.</p>



<p>Once again, the code compiles and all tests pass. Commit:</p>



<pre><code>$ git add . &amp;&amp; git commit
[tactical-git 6f1e07e] Implement ReadReservations overload in SQL repo
 1 file changed, 25 insertions(+), 2 deletions(-)
</code></pre>



<p>Status so far: We’re two commits in, and all code works. The time spent coding between each commit has been short.</p>







<p>The other class that implements <code>IReservationsRepository</code> is called <code>FakeDatabase</code>. It’s a <a href="http://xunitpatterns.com/Fake%20Object.html">Fake Object</a> (a kind of <a href="https://en.wikipedia.org/wiki/Test_double">Test Double</a>) that exists only to support automated testing.</p>



<p>The process for implementing the new method is exactly the same as for <code>SqlReservationsRepository</code>. First, add the method:</p>



<pre><code>public Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; ReadReservations(DateTime min, DateTime max)
{
    throw new NotImplementedException();
}
</code></pre>



<p>The code compiles and all tests pass. Commit:</p>



<pre><code>$ git add . &amp;&amp; git commit
[tactical-git c5d3fba] Add ReadReservations overload to FakeDatabase
 1 file changed, 5 insertions(+)
</code></pre>



<p>Then add the implementation:</p>



<pre><code>public Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; ReadReservations(DateTime min, DateTime max)
{
    return Task.FromResult&lt;IReadOnlyCollection&lt;Reservation&gt;&gt;(
        this.Where(r =&gt; min &lt;= r.At &amp;&amp; r.At &lt;= max).ToList());
}
</code></pre>



<p>The code compiles and all tests pass. Commit:</p>



<pre><code>$ git add . &amp;&amp; git commit
[tactical-git e258575] Implement FakeDatabase.ReadReservations overload
 1 file changed, 2 insertions(+), 1 deletion(-)
</code></pre>



<p>Each of these commits represent only a few minutes of programming time; that’s the whole point. By committing often, you have granular save points you can retreat to if things start to go wrong.</p>







<p>Keep in mind that we’ve been adding the methods in anticipation that the <code>IReservationsRepository</code> interface will change. It hasn’t changed yet, remember. I stashed that edit.</p>



<p>The new method is now in place everywhere it needs to be in place: both on <code>SqlReservationsRepository</code> and <code>FakeDatabase</code>.</p>



<p>Now pop the stash:</p>



<pre><code>$ git stash pop
On branch tactical-git
Changes not staged for commit:
  (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)
  (use &#34;git restore &lt;file&gt;...&#34; to discard changes in working directory)
        modified:   Restaurant.RestApi/IReservationsRepository.cs

no changes added to commit (use &#34;git add&#34; and/or &#34;git commit -a&#34;)
Dropped refs/stash@{0} (4703ba9e2bca72aeafa11f859577b478ff406ff9)
</code></pre>



<p>This re-adds the <code>ReadReservations</code> method overload to the interface. When I first tried to do this, the code didn’t compile because the classes that implement the interface didn’t have that method.</p>



<p>Now, on the other hand, the code immediately compiles and all tests pass. Commit.</p>



<pre><code>$ git add . &amp;&amp; git commit
[tactical-git de440df] Add ReadReservations overload to repo interface
 1 file changed, 2 insertions(+)
</code></pre>



<p>We’re done. By a tactical application of <code>git stash</code>, it was possible to partition what looked like one long, unsafe maneuver into five smaller, safer steps.</p>







<p>Someone once, in passing, mentioned that one should never be more than five minutes away from a commit. That’s the same kind of idea. When you begin editing code, do yourself the favor of moving in such a way that you can get to a new working state in five minutes.</p>



<p>This doesn’t mean that you have to commit <em>every</em> five minutes. It’s okay to take time to think. Sometimes, I go for a run, or go grocery shopping, to allow my brain to chew on a problem. Sometimes, I just sit and look at the code without typing anything. And sometimes, I start editing the code without a good plan, and that’s okay, too… Often, by dawdling with the code, inspiration comes to me.</p>



<p>When that happens, the code may be in some inconsistent state. Perhaps it compiles; perhaps it doesn’t. It’s okay. I can always reset to my latest save point. Often, I reset by stashing the results of my half-baked experimentation. That way, I don’t throw anything away that may turn out to be valuable, but I still get to start with a clean slate.</p>



<p>git stash is probably the command I use the most for increased maneuverability. After that, being able to move between branches locally is also useful. Sometimes, I do a quick-and-dirty prototype in one branch. Once I feel that I understand the direction in which I must go, I commit to that branch, reset my work to a more proper commit, make a new branch and do the work again, but now with tests or other things that I skipped during the prototype.</p>



<p>Being able to stash changes is also great when you discover that the code you’re writing right now needs something else to be in place (e.g. a helper method that doesn’t yet exist). Stash the changes, add the thing you just learned about, commit that, and the pop the stash. Subsection <em>11.1.3 Separate Refactoring of Test and Production Code</em> in <a href="https://blog.ploeh.dk/code-that-fits-in-your-head">Code That Fits in Your Head</a> contains an example of that.</p>



<p>I also use <code>git rebase</code> a lot. While <a href="https://blog.ploeh.dk/2020/10/05/fortunately-i-dont-squash-my-commits">I’m no fan of squashing commits</a>, I’ve no compunction about reordering commits on my local Git branches. As long as I haven’t shared the commits with the world, rewriting history can be beneficial.</p>



<p>Git enables you to experiment, to try out one direction, and to back out if the direction begins to look like a dead end. Just stash or commit your changes, move back to a previous save point and try an alternative direction. Keep in mind that you can leave as many incomplete branches on your hard drive as you like. You don’t have to push them anywhere.</p>



<p>That’s what I consider <em>tactical use of Git</em>. It’s maneuvers you perform to be productive in the small. The artifacts of these moves remain on your local hard drive, unless you explicitly choose to share them with others.</p>







<p>Git is a tool with more potential than most people realize. Usually, programmers use it to synchronize their work with others. Thus, they use it only when they feel the need to do that. That’s <code>git push</code> and <code>git pull</code>.</p>



<p>While that’s a useful and essential feature of Git, if that’s all you do, you might as well use a centralized source control system.</p>



<p>The value of Git is the tactical advantage it also provides. You can use it to experiment, make mistakes, flail, and struggle on your local machine, and  at any time, you can just reset if things get too hard.</p>



<p>In this article, you saw an example of adding an interface method, only to realize that this involves more work than you may have initially thought. Instead of just pushing through on an ill-planned unsafe maneuver that has no clear end, just back out by stashing the changes so far. Then move deliberately in smaller steps and finally pop the stash.</p>



<p>Just like a rock climber like Alex Honnold trains with ropes and harness, Git enables you to proceed in small steps with fallback options. Use it to your advantage.</p><p>
    Tags: <a href="https://stackoverflow.blog/tag/git/" rel="tag">git</a>, <a href="https://stackoverflow.blog/tag/micro-commits/" rel="tag">micro-commits</a>, <a href="https://stackoverflow.blog/tag/strangler-fig-pattern/" rel="tag">strangler fig pattern</a>  </p></div></div>
  </body>
</html>
