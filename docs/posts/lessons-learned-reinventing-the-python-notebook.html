<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marimo.io/blog/lessons-learned">Original</a>
    <h1>Lessons learned reinventing the Python notebook</h1>
    
    <div id="readability-page-1" class="page"><div><blockquote>
<p>This blog is adapted from a talk at an <a href="https://www.youtube.com/@mlopslearners">MLOps Learners</a> demo day
(<a href="https://docs.google.com/presentation/d/1dzTuViK7sn4LKLod-7aR828FI3-hBEdxZLDNdL9L-rI/edit#slide=id.g2d05ea9da64_0_54">slides</a>, <a href="https://www.youtube.com/watch?v=3e9YAdOpihI&amp;t=1737s">video</a>).</p>
</blockquote>
<p>I worked on <a href="https://stanford.edu/~boyd/papers/min_dist_emb.html">vector
embeddings</a> during my PhD
at Stanford. I used Jupyter daily, because it paired code with visuals in an
iterative programming environment. But I realized early on that we needed a
Python notebook that was more than just a REPL. I spent a lot of time thinking
about this, perhaps because I had just finished a stint at Google as <a href="https://www.debugmind.com/2020/01/04/paths-to-the-future-a-year-at-google-brain/">an
engineer working at Google
Brain</a>,
where I thought a lot about computer systems and dataflow graphs.</p>
<p>A lot of important work happens in notebooks — research, large scale
experimentation, data engineering, and more. But this kind of work should be
treated as Python software, and it shouldn’t be done in error-prone JSON
scratchpads. By the end of my PhD, it became clear to me that we needed to
rethink what a notebook is, from the ground up and from first principles.</p>
<h2 id="desiderata"><a aria-label="Link to section" href="#desiderata"><span></span></a>Desiderata</h2>
<p>When setting out to build marimo, I had three desiderata for it:</p>
<ol>
<li><strong>Reproducible</strong>: well-specified execution order,
while still allowing for interactive execution of cells. Your code and
outputs should always be in sync, not unlike a spreadsheet.</li>
<li><strong>Maintainable</strong>: pure Python, so code is versionable and portable.</li>
<li><strong>Multi-purpose</strong>: not just a notebook — share as an interactive web
app, execute as a script or pipeline, without jumping through extra hoops.</li>
</ol>
<p>These desiderata build on each other: maintainable requires reproducible, and
multi-purpose requires maintainable and reproducible. In this blog post, I’ll
talk about how we designed for these desiderata and lessons we learned along
the way.</p>
<h2 id="reproducible"><a aria-label="Link to section" href="#reproducible"><span></span></a>Reproducible</h2>
<p>Every notebook should be <strong>computationally reproducible</strong>: the variables in
memory should be a function of code on the page, only,
so that your code and outputs are always consistent.</p>
<h3 id="hidden-state"><a aria-label="Link to section" href="#hidden-state"><span></span></a>Hidden state</h3>
<p>Computational reproducibility sounds straightforward — its how most regular
programs work. But it’s not how traditional notebooks, such as Jupyter with
IPyKernel, work. Traditional notebooks let developers execute cells one at a
time, in any order, with each cell modifying a mutable workspace (i.e., the
variables in memory). This creates <strong>hidden state</strong>: in traditional notebooks,
variable state is a function of code <em>and</em> the user’s execution history.</p>
<p>This hidden state is a huge problem for reproducibility. It’s why when you
receive a notebook from a colleague and try to run it from top to bottom,
the notebook just breaks or has different results from the outputs saved in
the notebook.</p>
<p>Here are two examples of hidden state. In the first example,
the cells were executed out of order, and now the page reports <code>x == 0</code>, even
though in fact <code>x == 1</code>.</p>
<p><img alt="hidden1" src="https://marimo.io/images/blog/6/blog-6-hidden-state-1.png"/></p>
<p>In this example, <code>x == 0</code> in memory, but <code>x</code> is not defined on the page! This
is because the author deleted the cell defining <code>x</code>, but the IPython kernel
kept <code>x</code> in memory. Restarting and running this notebook would yield a totally
different result.</p>
<p><img alt="hidden2" src="https://marimo.io/images/blog/6/blog-6-hidden-state-2.png"/></p>
<p>These are toy examples, but what happens in practice is that your
co-author or colleague gives you a notebook that does some real task: generates
plots for a paper, transforms some data, or runs an experiment, but when you
run it, the notebook just doesn’t work the way the author thinks it does.
A <a href="https://blog.jetbrains.com/datalore/2020/12/17/we-downloaded-10-000-000-jupyter-notebooks-from-github-this-is-what-we-learned/">study of 10 million notebooks</a> on GitHub found that 36% percent of them
were executed out of order in this way.</p>
<h3 id="eliminating-hidden-state-by-modeling-notebooks-as-dags"><a aria-label="Link to section" href="#eliminating-hidden-state-by-modeling-notebooks-as-dags"><span></span></a>Eliminating hidden state by modeling notebooks as DAGs</h3>
<p>To eliminate hidden state, we model every notebook as a directed acyclic graph
(DAG) on cells. We mark each cell with the variables it defines and the
variables it references. There’s an edge <code>(a, b)</code> if <code>b</code> references any of
the variables defined by <code>a</code>. We form this graph using static
analysis, reading your code without running it, so there’s no performance
overhead at runtime.</p>
<p>The DAG encodes dependencies across cells: it specifies how variables <em>flow</em>
from one cell to another. The semantics of the graph are that if <code>a</code> is a parent
of <code>b</code>, meaning that <code>b</code> reads a variable defined by <code>a</code>, then
<code>b</code> has to run after <code>a</code>.</p>
<p>This kind of graph is also known as a <em>dataflow graph</em>. If you’ve used
TensorFlow, TorchScript, JAX — or Excel — you’ve worked with dataflow graphs
before. The nice thing about a dataflow graph is that it imposes a well-defined
execution order on the notebook. If you run a cell that defines a variable <code>y = x + 1</code>, the notebook should:</p>
<ol>
<li>first, compute <code>x</code> if it was defined by another cell that hasn’t run;</li>
<li>then, compute <code>y = x + 1</code>, ie run the cell;</li>
<li>finally, either automatically run other cells that use <code>y</code>, or mark them as stale and invalidate their memory.</li>
</ol>
<p>Here is an example marimo notebook for you to play with that makes this concrete.</p>

<p>It has the following dependency graph:</p>
<p><img alt="graph" src="https://marimo.io/images/blog/6/blog-6-graph.png"/></p>
<h4 id="constraints"><a aria-label="Link to section" href="#constraints"><span></span></a>Constraints</h4>
<p>To make sure every notebook is a DAG, the user must accept some constraints:</p>
<ol>
<li>variables can’t be reassigned</li>
<li>cells can’t have cycles (<code>x = y</code>, <code>y = x</code>)</li>
<li>avoid mutating variables across cells (mutations are discouraged but allowed)</li>
</ol>
<p>These constraints have a learning curve but are easy to understand. And they
unlock a lot of new capabilities for the user: not only are DAG-based notebooks
reproducible, they can also support interactive UI elements that automatically
synchronize with Python:</p>

<h4 id="execution"><a aria-label="Link to section" href="#execution"><span></span></a>Execution</h4>
<p>By default, marimo automatically updates outputs, like a spreadsheet: when
a cell is run, its children are too. But this can be configured to be lazy,
so that children are only run when requested and instead marked as stale.</p>
<h4 id="alternatives-considered"><a aria-label="Link to section" href="#alternatives-considered"><span></span></a>Alternatives considered</h4>
<p>We considered a couple alternatives to modeling a notebook as a DAG:</p>
<ol>
<li>
<p><em>Only allow notebooks to be run top-to-bottom?</em> This works for things like
streamlit, but is too rigid for interactive computing.</p>
</li>
<li>
<p><em>Build a dependency graph at runtime</em>? This requires tracing the user code
and watching for variable reads/writes. The problem is that we’ll only catch an
unspecified subset of reads and writes, so the dependency graph
will be ill-defined and users won’t be able to understand the structure of
the problem. Plus, tracing adds a substantial performance overhead.</p>
</li>
<li>
<p><em>Just warn users if they execute things out-of-order?</em> This doesn’t solve the
problem and won’t enable the other desiderata, so a non-starter.</p>
</li>
</ol>
<h3 id="lesson-prefer-simplicity"><a aria-label="Link to section" href="#lesson-prefer-simplicity"><span></span></a>Lesson: prefer simplicity</h3>
<p>In choosing static inference, we chose a <strong>simple way</strong> to eliminate hidden
state. People are already familiar with dataflow graphs, even if they don’t
know it:</p>
<p><img alt="excel" src="https://marimo.io/images/blog/6/blog-6-excel-dag.png"/>
<em>The excel spreadsheet: the original DAG-powered notebook …</em></p>
<p>Yes, there are constraints. But people will happily accept constraints if they
are necessary and easily understood.</p>
<p>Other solutions like runtime tracing, or relaxing constraints,
were just too complicated for users to think about, let alone me as the
developer as it went down the path of solving an unsolvable problem (we learned
hard lessons about trying to solve impossible problems at TensorFlow).</p>
<p>My biggest takeaway here is that it’s important to design systems that are
easily explained, and constraints are okay. An easily understood system with
clear constraints is better than a inscrutable one without constraints.</p>
<h2 id="maintainable"><a aria-label="Link to section" href="#maintainable"><span></span></a>Maintainable</h2>
<p>We grounded maintainability in the file format. Instead of storing notebooks as
JSON, we insisted on storing notebooks as Python files (<code>.py</code>) with the
following properties:</p>
<ol>
<li>git-friendly: small code change =&gt; small diff</li>
<li>easy for both humans and computers to read</li>
<li>importable as a Python module</li>
<li>executable as a Python script</li>
<li>editable with a text editor</li>
</ol>
<p>After a <em>lot</em> of careful consideration, we landed on files that look like this:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="python" data-theme="github-dark"><code data-language="python" data-theme="github-dark"><span data-line=""><span>import</span><span> marimo</span></span>
<span data-line=""> </span>
<span data-line=""><span>__generated_with </span><span>=</span><span> &#34;0.4.12&#34;</span></span>
<span data-line=""><span>app </span><span>=</span><span> marimo.App()</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>@app.cell</span></span>
<span data-line=""><span>def</span><span> defines_x</span><span>():</span></span>
<span data-line=""><span>    x </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    return</span><span> x,</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>@app.cell</span></span>
<span data-line=""><span>def</span><span> defines_y</span><span>(x):</span></span>
<span data-line=""><span>    y </span><span>=</span><span> x </span><span>+</span><span> 1</span></span>
<span data-line=""><span>    y</span></span>
<span data-line=""><span>    return</span><span> y,</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>@app.cell</span></span>
<span data-line=""><span>def</span><span> computes_z</span><span>(x, y):</span></span>
<span data-line=""><span>    z </span><span>=</span><span> x </span><span>+</span><span> y </span><span>+</span><span> 1</span></span>
<span data-line=""><span>    z</span></span>
<span data-line=""><span>    return</span><span> z,</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>if</span><span> __name__</span><span> ==</span><span> &#34;__main__&#34;</span><span>:</span></span>
<span data-line=""><span>    app.run()</span></span></code></pre></figure>
<p>Cells are encoded as functions that read their variable references and return
their definitions, and are added to an <code>app</code> object that builds the graph. Users
can optionally name their cells, which become the names of the decorated
functions.</p>
<p>As an alternative, we considered storing files as flat Python scripts,
with comments demarcating cells (instead of putting them in functions). This is
simple and has precedent (VSCode notebooks, Pluto.jl), but it makes importing
notebooks as modules impractical — it either executes all the code on import,
or makes it inaccessible if stored under an <code>if __name__ == &#34;__main__&#34;</code> guard.</p>
<h3 id="lesson-learned-design-for-extensibility"><a aria-label="Link to section" href="#lesson-learned-design-for-extensibility"><span></span></a>Lesson learned: design for extensibility</h3>
<p>Our solution is more complicated than a flat script, but it enables composition
— use named cells as functions in other files. It also gives us a reserved
namespace for future APIs, on the <code>app</code> object. We didn’t know what those APIs
would be when we designed the file format, but we did know that we’d have some
APIs, and had to design for that in mind.</p>
<p>Designing for extensibility is <em>hard</em>. But when you’re
making something as delicate as a file format — where you want to be both
backward and forward compatible — it’s worth getting it right.
In our case, we wrote a <a href="https://github.com/marimo-team/meps/blob/main/mep-0001.md">2500 word design
doc</a> before
implementing a single line of code.</p>
<h3 id="multi-purpose"><a aria-label="Link to section" href="#multi-purpose"><span></span></a>Multi-purpose</h3>
<p>Our reproducible <span role="img" aria-label="white heavy check mark">✅</span> and maintainable <span role="img" aria-label="white heavy check mark">✅</span> notebook is naturally
<strong>multi-purpose</strong>, capable of being used as more than just a notebook.</p>
<h4 id="a-multi-purpose-notebook"><a aria-label="Link to section" href="#a-multi-purpose-notebook"><span></span></a>A multi-purpose notebook</h4>
<p><strong>Run as an app</strong>. The basis of modern web apps is reactivity: interact with a
UI element and the app automatically <em>reacts</em> to the change in its value. Because
each notebook is a DAG, and because we have support for UI elements — interact with
a slider, and it triggers execution of cells that reference it — we can
turn notebooks into apps by just hiding code, showing outputs,
and serving in a read-only mode.</p>
<p>Importantly, this requires <em>0</em> lines of code changes: just <code>marimo run notebook.py</code> at the CLI to run as a web app.</p>
<p><strong>Execute as a script.</strong> In the previous section, we saw that each notebook
ends with</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="python" data-theme="github-dark"><code data-language="python" data-theme="github-dark"><span data-line=""><span>if</span><span> __name__</span><span> ==</span><span> &#34;__main__&#34;</span><span>:</span></span>
<span data-line=""><span>    app.run()</span></span></code></pre></figure>
<p>The <code>app.run()</code> line executes the notebook in an order determined by the
DAG. This means you can type</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="python" data-theme="github-dark"><code data-language="python" data-theme="github-dark"><span data-line=""><span>python notebook.py</span></span></code></pre></figure>
<p>at the command-line to execute your notebook as a regular script. We have
built-in support for <a href="https://docs.marimo.io/api/cli_args.html#marimo.cli_args">command-line
arguments</a>, so you
can even parametrize notebooks without jumping through extra hoops.</p>
<p><strong>Map over batches of parameters</strong>. In principle, we could even re-use notebooks
in batch computing settings, by programmatically substituting a variable in the
notebook with a batch of variables and executing the DAG with
distributed compute. We haven’t built this yet, but it’s just one more example
of how modeling notebooks as DAGs unlocks interesting new capabilities.</p>
<h3 id="lesson-stay-true-to-your-projects-pillars"><a aria-label="Link to section" href="#lesson-stay-true-to-your-projects-pillars"><span></span></a>Lesson: Stay true to your project’s pillars</h3>
<p>This is the biggest lesson we’ve learned while working on marimo: <strong>stay true
to your project’s pillars</strong>. This requires figuring out what your pillars are
— the core of your project on which everything is built. This can be a
technology, a vision, or both.</p>
<p>You should <strong>reject feature requests that require you to compromise your
pillars</strong>, because trying to please everyone usually results in a worse system.
<strong>But embrace requests that reinforce or build on your pillars.</strong> And sometimes,
you can learn from the former requests and find a way to meet your users
halfway.</p>
<h4 id="examples"><a aria-label="Link to section" href="#examples"><span></span></a>Examples</h4>
<p>Here’s our main pillar: <strong>every notebook is a DAG on blocks of Python
code.</strong> This single pillar enables many things:</p>
<ol>
<li>notebook-style computation and visualization of data, in a reproducible setting;</li>
<li>running notebooks as interactive web apps;</li>
<li>executing notebooks as scripts;</li>
<li>experimenting with batch processing and distributed runtimes.</li>
</ol>
<p>Here’s a feature request we recently received that tested the strength of our
pillar. A user asked us to support Jupyter-style execution — to allow
multiple definitions of variables, cycles, and out-of-order execution, i.e., to
opt-out of the DAG. In doing so, our user argued that we’d make it easier for
Jupyter users to onboard to marimo.</p>
<p>Allowing users to opt-out of the DAG would indeed make marimo more accessible
to Jupyter users. But it would also break everything that marimo enables: it
would introduce hidden state, make it impossible to run notebooks as apps or
execute them as scripts with well-defined execution order, and severely limit
the runtimes we could experiment with. For this reason, we politely
<strong>rejected</strong> this feature request.</p>
<p>On the other hand, this user’s feedback stuck with me: they mentioned that
automatic execution of cells’ descendants was less than ideal for notebooks
with expensive cells. And I think really, this was the heart of their
complaint. So we <strong>embraced</strong> the spirit of their feedback, if not its letter,
and added support for a <a href="https://docs.marimo.io/guides/runtime_configuration.html">lazy runtime</a>
that marks descendants as stale instead of automatically executing them. In
this way, we made marimo better suited to running expensive computations, while
still retaining the guarantees provided by the underlying DAG.</p>
<p>Another pillar: <strong>marimo notebooks are pure Python</strong>. If you’ve
been paying close attention, you’ll have noticed that marimo is both a notebook
and a library (<code>import marimo as mo</code>). The library provides access to things
like UI elements, markdown, and other helpful utilities. marimo exists
as a library precisely because we want marimo notebooks to be <em>just Python</em>;
this puts them on the same footing as other Python programs and helps
make them multi-purpose.</p>
<p>That’s why we don’t have support for Jupyter magics. If a user asks for
a magic command, we typically just build the functionality directly
into the notebook (like we did for <a href="https://docs.marimo.io/guides/runtime_configuration.html">module reloading</a>),
or suggest a pure Python alternative (e.g., <code>subprocess.run</code> instead of <code>!</code> commands).</p>
<h2 id="conclusion"><a aria-label="Link to section" href="#conclusion"><span></span></a>Conclusion</h2>
<p>When I first started marimo, I didn’t imagine that it would be used by places
like Stanford, BlackRock, CZ Research, SLAC, LBNL, Sonos, Gridmatic, Sumble, and so many
others.</p>
<p>We have lots of work ahead of us, and many more lessons to learn. Still, I
think the lessons we’ve learned are durable, and I hope they’ll keep us
grounded as we grow.</p>
<ul>
<li>GitHub: <a href="https://github.com/marimo-team/marimo">https://github.com/marimo-team/marimo</a></li>
<li>Discord: <a href="https://discord.gg/JE7nhX6mD8">https://discord.gg/JE7nhX6mD8</a></li>
<li>Docs: <a href="https://docs.marimo.io">https://docs.marimo.io</a></li>
<li>Newsletter: <a href="https://marimo.io/newsletter">https://marimo.io/newsletter</a></li>
</ul></div></div>
  </body>
</html>
