<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/readme/featured/server-side-languages-for-front-end">Original</a>
    <h1>Back-end languages are coming to the front-end</h1>
    
    <div id="readability-page-1" class="page"><div>



      <p>In the early days of networked computing, mainframes did all the heavy lifting: users connected to massive machines with video terminals that could do little more than send and receive text. Then in the 1970s, personal computers came along and made it possible to do serious computing on the client-side as servers handled tasks like authentication and storage in many networks. The rise of the internet in the 1990s swung the pendulum back to the server, with web browsers taking on a role not unlike terminals in the mainframe era.</p>
<p>The client-side made a come back over the past decade as developers built “single-page applications” (SPAs) with <a href="https://github.com/topics/javascript">JavaScript</a>. But a <a href="https://github.com/dbohdan/liveviews">new crop of tools</a> is sending the pendulum swinging back towards the server.</p>
<p>At the vanguard of these tools is Phoenix, a framework for the programming language Elixir, and a feature called <a href="https://github.com/dbohdan/liveviews">LiveView</a>. Using LiveView and a bit of JavaScript, developers can create browser-based interfaces for real-time applications like chat rooms or Twitter-style status updates. All UI elements are rendered on the server first and sent to the browser, ready-to-display. The only JavaScript required is a small amount of code that opens a WebSockets connection that handles sending input from the browser and receiving refreshed HTML/CSS from the server.</p>
<p>Phoenix isn&#39;t the first platform to offer a way for back-end developers to create front-end interfaces—Microsoft&#39;s ASP.NET Web Forms for Microsoft .NET existed back in 2002—but it did inspire many new tools. <a href="https://github.com/calderajs/caldera-react">Caldara</a> for Node.js, <a href="https://github.com/livewire/livewire">Livewire</a> for the PHP framework <a href="https://github.com/laravel">Laravel</a>, and StimulusReflex for Ruby on Rails, to name a few. Microsoft, meanwhile, released a new .NET feature called <a href="https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor">Blazor Server</a> that modernizes the old Web Forms idea.</p>
<p>“My goal is not to get rid of single-page applications, but to obviate them for a large class of applications,” Phoenix creator Chris McCord says.</p>
<blockquote><p>My goal is not to get rid of single-page applications, but to obviate them for a large class of applications.</p></blockquote>
<h3><b>The (not so) good old days of web development</b></h3>
<p>Let&#39;s say it’s 1997, and you want to make a web-based calendar app. In these early days of the web, your app would live almost entirely on the server. The server would render a static page with your appointments for each day, organized in a table of 31 boxes. You wouldn’t be able to drag and drop appointments from day to day. Instead, you’d have to include a form at the bottom of the page to add a new appointment to the calendar. Clicking the “submit” button would send the data to a server, which would store it in a database and render a new version of the page to reflect the change. In short, updating one day would require the whole page to refresh.</p>
<p>Even on a fast connection this wouldn&#39;t be a particularly snappy experience. But as browsers and web technologies became more sophisticated, it became possible to update only small sections of a webpage. Using a bit of JavaScript, you can create a calendar app that will display your new appointment as soon as you click “Submit”. The script sends this information to the server asynchronously, and only updates the box for the day of your new appointment, instead of the entire page. You can drag and drop appointments or even build a calendar that works offline, in case you lose your internet connection, and then syncs changes when you have connectivity. </p>
<picture>
  <source srcset="//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=2400&amp;fm=avif 2400w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=1920&amp;fm=avif 1920w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=1440&amp;fm=avif 1440w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=1200&amp;fm=avif 1200w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=960&amp;fm=avif 960w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=480&amp;fm=avif 480w" sizes="(max-width: 1280px) 90vw, 1200px" type="image/avif"/>
  <source srcset="//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=2400&amp;fm=webp 2400w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=1920&amp;fm=webp 1920w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=1440&amp;fm=webp 1440w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=1200&amp;fm=webp 1200w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=960&amp;fm=webp 960w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=480&amp;fm=webp 480w" sizes="(max-width: 1280px) 90vw, 1200px" type="image/webp"/>
  <source srcset="//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=2400&amp;fm=jpg 2400w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=1920&amp;fm=jpg 1920w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=1440&amp;fm=jpg 1440w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=1200&amp;fm=jpg 1200w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=960&amp;fm=jpg 960w,//images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=480&amp;fm=jpg 480w" sizes="(max-width: 1280px) 90vw, 1200px" type="image/jpeg"/>
  <img width="2400" height="1600" loading="lazy" decoding="async" alt="Inline3_Liveview" src="https://images.ctfassets.net/s5uo95nf6njh/2wuvDjqaHt8jXQfhD52Hpo/f8ef49000d51819450add96847b098a8/soundtrap-6MCGoftskqc-unsplash.jpg?w=2400&amp;fm=jpg"/>
</picture>
<p>Over the years, open source JavaScript UI libraries like <a href="https://github.com/angular/angular.js">Angular.js</a>, <a href="https://github.com/reactjs">React</a>, and <a href="https://github.com/vuejs/vue">Vue.js</a> have made it possible to create increasingly sophisticated, desktop-like app experiences on the web. This approach has many advantages, including responsiveness and offline capabilities.</p>
<p>But there are tradeoffs. By offloading more compute to the browser, you place more of a burden on the client&#39;s CPU and battery life. The need for clients to download JavaScript application logic can increase file sizes and eat through bandwidth. And you&#39;ll often end up with two code bases: one for the client, written in JavaScript, and one for the back-end, often in a different language.</p>
<p>For many applications, those trade-offs are worth it—for example calendars that need offline support or games that require a lot of client-side application logic. But Phoenix creator Chris McCord argues that for applications that rely heavily on a network connection, it makes more sense to handle application logic and page rendering on the server side. </p>
<p>Take a browser-based chat application, for example. Traditionally, you might build your app using JavaScript to accept user input, send it to the server, fetch text from other users, and then redraw the page. With LiveView, the browser opens a WebSockets connection with the Phoenix server and passes text to it. The server gathers all the messages from other users in the chat room, renders the part of the page that changed, and sends it to the browser. Not only does this reduce the amount of processing the client has to do, but it reduces the payload the browser receives since the application logic isn&#39;t sent down the wire.</p>
<h3><b>Phoenix rises</b></h3>
<p>McCord originally wanted to create a similar experience for Ruby on Rails, so he created a library called <a href="https://github.com/chrismccord/render_sync">render-sync</a> that could re-render partials on the server and send them to the browser via WebSockets. But he wasn&#39;t happy with the performance of render-sync. He wanted something faster and more responsive than Rails, which wasn&#39;t designed for real-time applications. After evaluating several other programming platforms, he landed on the Elixir language for the Erlang platform.</p>
<p>Erlang was created by a team at Ericsson in 1986 to power telecommunications applications. “They were dealing with distributed systems very early,” McCord says. “They weren&#39;t worried about multi-core systems yet because they didn&#39;t exist, but the architecture they created was perfect for the future of computing.”</p>
<p>Crucially, Erlang was engineered around the need to support massive numbers of concurrent users. “Elixir will run millions of lightweight threads,” McCord says. But what really sets Erlang apart, for McCord, is its ability to preschedule processes so that the CPU doesn&#39;t get hung up on any single thread. That way, if one user starts some sort of particularly long, CPU-intensive process, other users don&#39;t have to wait for that process to finish before they can complete their own.</p>
<p>While it&#39;s possible to build this sort of fault tolerance into other platforms, McCord likes that Elixir makes it so easy to handle. “You don&#39;t have to write your code in a special way,” he says. Elixir gave McCord confidence that he could create a server-side rendering system to support real-time applications with long-lived WebSocket connections between the server and the browser—not unlike a telnet or SSH connection. This enables developers create stateful applications, rather than having to “hydrate” either the client or the server with application, as the old ASP.NET WebForms system did.</p>
<p>McCord started building the Phoenix framework for Elixir with an eye towards eventually adding the LiveView feature. “LiveView was always the end game, but I needed to do the plumbing first,” McCord says.</p>
<blockquote><p>&#34;LiveView was always the end game, but I needed to do the plumbing first.&#34;</p></blockquote>

<picture>
  <source srcset="//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=2400&amp;fm=avif 2400w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=1920&amp;fm=avif 1920w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=1440&amp;fm=avif 1440w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=1200&amp;fm=avif 1200w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=960&amp;fm=avif 960w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=480&amp;fm=avif 480w" sizes="(max-width: 543px) 90vw, (max-width: 1280px) 46vw, 588px" type="image/avif"/>
  <source srcset="//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=2400&amp;fm=webp 2400w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=1920&amp;fm=webp 1920w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=1440&amp;fm=webp 1440w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=1200&amp;fm=webp 1200w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=960&amp;fm=webp 960w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=480&amp;fm=webp 480w" sizes="(max-width: 543px) 90vw, (max-width: 1280px) 46vw, 588px" type="image/webp"/>
  <source srcset="//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=2400&amp;fm=jpg 2400w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=1920&amp;fm=jpg 1920w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=1440&amp;fm=jpg 1440w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=1200&amp;fm=jpg 1200w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=960&amp;fm=jpg 960w,//images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=480&amp;fm=jpg 480w" sizes="(max-width: 543px) 90vw, (max-width: 1280px) 46vw, 588px" type="image/jpeg"/>
  <img width="2400" height="3600" loading="lazy" decoding="async" alt="Inline2_Liveview" src="https://images.ctfassets.net/s5uo95nf6njh/5eeYXF9IbBQuVTMi4n2n15/17d639f0dafa1da394f4160f518baa92/procreator-ux-design-studio-VzJjPuk53sk-unsplash.jpg?w=2400&amp;fm=jpg"/>
</picture>
<h3><b>Beyond Elixir</b></h3>
<p>Though McCord opted to build LiveView on Elixir instead of Ruby, there are now a few different approaches to building real-time front-end interfaces in Ruby on Rails. One is <a href="https://github.com/stimulusreflex/stimulus_reflex">StimulusReflex</a>, created by <a href="https://github.com/hopsoft">Nate Hopkins</a>. Another is <a href="https://github.com/hotwired">Hotwire</a>, a set of tools for building real-time, WebSocket-based Rails applications, developed by Basecamp for its own <a href="https://www.hey.com/">Hey.com</a> email service.</p>
<p>Rails developers say this new crop of tools suits their needs. Matt E. Patterson, a developer at Atlas Obscura who worked with both StimulusReflex and Hotwire in a previous role, says that even though Rails has historically been able to scale to meet the demands of a wide variety of users. “I&#39;m not going to say Ruby is the fastest language, but most of the scalability issues people see in the real world are related to running too many badly written database queries and have nothing to do with Ruby or Rails,” he says. There are plenty of applications that don&#39;t need to support tens or hundreds of thousands of simultaneous users. In these cases it might not be worth it for developers to learn not only a new programming language but also an entirely new paradigm. That&#39;s a big part of why the core ideas behind LiveView are finding their way into so many different languages and platforms. When <a href="https://github.com/readme/stories/caleb-porzio">Caleb Porzio</a> saw McCord&#39;s LiveView demo in 2018, he was inspired to create a version for the PHP framework Laravel. “I had just left my job and I was supposed to take a break from work and coding,” he says. “But on the second day of my sabbatical, I watched Chris&#39;s presentation on LiveView. It really popped for me. I realized you could take Laravel to a whole new level.” He created the first prototype of what would eventually become Livewire for Laravel in a single day.</p>
<p>Porzio first tried to make Livewire work much like LiveView. “I had these long-lived processes running on the back-end using WebSockets,” Porzio says. “But PHP isn&#39;t really built for that.” He wanted something that would work well on existing PHP infrastructure without the need to create custom architectures. So he switched to using AJAX requests to pass state back and forth from browser to server. In other words, Livewire isn&#39;t technically “live” in the same way Phoenix LiveView is. “But we can fake it pretty well,” Porzio jokes.</p>
<p>Yes, this is slower than opening an always-on connection that maintains state. But Livewire does a few things to make this more efficient, like prefetching. And Livewire is able to avoid addressing certain pitfalls, like what to do if a user&#39;s connection breaks.</p>
<p>Livewire users say they&#39;re happy with those trade-offs. <a href="https://github.com/TinaHammar">Tina Hammar</a> is a full-stack developer in Stockholm, Sweden. She started out as a PHP developer. Then she branched out into building single-page applications using Laravel and the JavaScript framework Vue, which she used to build her software-as-a-service application BokaMarknad (Swedish for “book a market”) in 2019. But after Livewire was released in February 2020, she completely rebuilt BokaMarknad using Laravel and Livewire.</p>
<p>Previously, Hammar says she essentially had to maintain two codebases: one for the front-end, written in JavaScript, and one for the back-end, written in PHP. Livewire made it possible to consolidate the entire application into a single codebase, which makes the code more understandable. Keeping much of the application logic on the back-end also gives Hammar more confidence in the security of the application because there are fewer ways to expose credentials or other sensitive data to users.</p>
<p>And it lets her focus on using the language she knows best: PHP. “I love PHP and the Laravel community is great as well,” she says. “I don&#39;t mind writing JavaScript. But it&#39;s simpler to focus on PHP.”</p>
<p>Freelance full-stack developer <a href="https://github.com/joshhanley">Josh Hanley</a> had a similar experience migrating an application from using both Vue and Laravel to just Laravel with Livewire. He agrees that the issue isn&#39;t JavaScript per se, but the need to maintain two separate codebases. “I can do everything in my blade templates,” he says. “That&#39;s the main attraction.”</p>
<h3><b>The end of the pendulum?</b></h3>
<p>Of course, many applications that use tools like LiveView, StimulusReflex, or Livewire still use JavaScript. But the JavaScript is embedded into the templates used by the back-end platform, so there&#39;s only one codebase even if an application uses multiple languages.</p>
<p>Several JavaScript UI libraries—including React and Vue.js—already support server-side rendering, and have since before Phoenix LiveView hit the scene. These make it possible to consolidate the application into a single JavaScript-based codebase. The question is what makes most sense for any given application. </p>
<p>“If you find yourself writing your HTML templates in a JavaScript framework instead of Laravel, that would be a sign that you might be better off with a single-page application,” Hanley says. “At that point you need to question what you&#39;re trying to achieve and what sorts of technologies would best achieve those goals.”</p>
<p>Vue creator <a href="https://github.com/readme/stories/evan-you">Evan You</a> agrees. “I don&#39;t think either model is fundamentally superior to the other, they come with different trade-offs and it really depends on the type of app that is being built and what mental model/language the developers feel they are more productive with,” You says.</p>
<p>Meanwhile, the line between front-end and back-end frameworks is blurring. For example, a forthcoming feature called <a href="https://github.com/josephsavona/rfcs/blob/server-components/text/0000-server-components.md#credits-and-prior-art">React Server Components</a> gives React the ability to offload more computing to the server. Today, the library’s server-side rendering simply renders a set of UI elements and sends them to the browser. From then on, application logic runs in the browser. But with Server Components, some of a React application&#39;s logic will run on the server. Conceptually, it&#39;s similar to Phoenix LiveView, but differs in that state is maintained in the client rather than on the server. This makes sense for an application that runs most of its logic in the browser.</p>
<p>Perhaps what we&#39;re seeing is not so much a pendulum swing, but a state of equilibrium where computing happens on both client and server in equal measure depending on the needs of the user.</p>
    </div></div>
  </body>
</html>
