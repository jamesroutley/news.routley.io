<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2024/02/16/popular-git-config-options/">Original</a>
    <h1>Popular git config options</h1>
    
    

<p>Hello! I always wish that command line tools came with data about how popular their various options are, like:</p>

<ul>
<li>&ldquo;basically nobody uses this one&rdquo;</li>
<li>&ldquo;80% of people use this, probably take a look&rdquo;</li>
<li>&ldquo;this one has 6 possible values but people only really use these 2 in practice&rdquo;</li>
</ul>

<p>So I <a href="https://social.jvns.ca/@b0rk/111885363143321068">asked about people&rsquo;s favourite git config options on Mastodon</a>:</p>

<blockquote>
<p>what are your favourite git config options to set? Right now I only really
have <code>git config push.autosetupremote true</code> and <code>git config
init.defaultBranch main</code> set in my <code>~/.gitconfig</code>, curious about what other
people set</p>
</blockquote>

<p>As usual I got a TON of great answers and learned about a bunch of very popular
git config options that I&rsquo;d never heard of.</p>

<p>I&rsquo;m going to list the options, starting with (very roughly) the most popular
ones. Here&rsquo;s a table of contents:</p>

<ul>
<li><a href="#pull-ff-only-or-pull-rebase-true">pull.ff only or pull.rebase true</a></li>
<li><a href="#merge-conflictstyle-zdiff3">merge.conflictstyle zdiff3</a></li>
<li><a href="#rebase-autosquash-true">rebase.autosquash true</a></li>
<li><a href="#rebase-autostash-true">rebase.autostash true</a></li>
<li><a href="#push-default-simple-push-default-current">push.default simple, push.default current</a></li>
<li><a href="#init-defaultbranch-main">init.defaultBranch main</a></li>
<li><a href="#commit-verbose-true">commit.verbose true</a></li>
<li><a href="#rerere-enabled-true">rerere.enabled true</a></li>
<li><a href="#help-autocorrect-10">help.autocorrect 10</a></li>
<li><a href="#core-pager-delta">core.pager delta</a></li>
<li><a href="#diff-algorithm-histogram">diff.algorithm histogram</a></li>
<li><a href="#core-excludesfile-a-global-gitignore">core.excludesfile ~/.gitignore</a></li>
<li><a href="#includeif-separate-git-configs-for-personal-and-work">includeIf: separate git configs for personal and work</a></li>
<li><a href="#fsckobjects-avoid-data-corruption">fsckobjects: avoid data corruption</a></li>
<li><a href="#submodule-stuff">submodule stuff</a></li>
<li><a href="#and-more">and more</a></li>
<li><a href="#how-to-set-these">how to set these</a></li>
<li><a href="#changes-i-ve-made-after-writing-this-post">changes I&rsquo;ve made after writing this post</a></li>
</ul>

<p>All of the options are documented in <code>man git-config</code>, or <a href="https://git-scm.com/docs/git-config">this page</a>.</p>

<h3 id="pull-ff-only-or-pull-rebase-true"><code>pull.ff only</code> or <code>pull.rebase true</code></h3>

<p>These two were the most popular. These both have similar goals: to avoid accidentally creating a merge commit
when you run <code>git pull</code> on a branch where the upstream branch has diverged.</p>

<ul>
<li><code>pull.rebase true</code> is the equivalent of running <code>git pull --rebase</code> every time you <code>git pull</code></li>
<li><code>pull.ff only</code> is the equivalent of running <code>git pull --ff-only</code> every time you <code>git pull</code></li>
</ul>

<p>I&rsquo;m pretty sure it doesn&rsquo;t make sense to set both of them at once, since <code>--ff-only</code>
overrides <code>--rebase</code>.</p>

<p>Personally I don&rsquo;t use either of these since I prefer to decide how to handle
that situation every time, and now git&rsquo;s default behaviour when your branch has
diverged from the upstream is to just throw an error and ask you what to do
(very similar to what <code>git pull --ff-only</code> does).</p>

<h3 id="merge-conflictstyle-zdiff3"><code>merge.conflictstyle zdiff3</code></h3>

<p>Next: making merge conflicts more readable! <code>merge.conflictstyle zdiff3</code> and <code>merge.conflictstyle diff3</code> were both super popular (&ldquo;totally indispensable&rdquo;).</p>

<p>The main idea is
The consensus seemed to be &ldquo;diff3 is great, and zdiff3 (which is newer) is even better!&rdquo;.</p>

<p>So what&rsquo;s the deal with <code>diff3</code>. Well, by default in git, merge conflicts look like this:</p>

<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
def parse(input):
    return input.split(&quot;\n&quot;)
=======
def parse(text):
    return text.split(&quot;\n\n&quot;)
&gt;&gt;&gt;&gt;&gt;&gt;&gt; somebranch
</code></pre>

<p>I&rsquo;m supposed to decide whether <code>input.split(&quot;\n&quot;)</code> or <code>text.split(&quot;\n\n&quot;)</code> is
better. But how? What if I don&rsquo;t remember whether <code>\n</code> or <code>\n\n</code> is right? Enter diff3!</p>

<p>Here&rsquo;s what teh same merge conflict look like with <code>merge.conflictstyle diff3</code> set:</p>

<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
def parse(input):
    return input.split(&quot;\n&quot;)
||||||| b9447fc
def parse(input):
    return input.split(&quot;\n\n&quot;)
=======
def parse(text):
    return text.split(&quot;\n\n&quot;)
&gt;&gt;&gt;&gt;&gt;&gt;&gt; somebranch
</code></pre>

<p>This has <strong>extra information</strong>: now the original version of the code is in the middle! So we can see that:</p>

<ul>
<li>one side changed <code>\n\n</code> to <code>\n</code></li>
<li>the other side renamed <code>input</code> to <code>text</code></li>
</ul>

<p>So presumably the correct merge conflict resolution is <code>return
text.split(&quot;\n&quot;)</code>, since that combines the changes from both sides.</p>

<p>I haven&rsquo;t used zdiff3, but a lot of people seem to think it&rsquo;s better. The blog post <a href="https://ductile.systems/zdiff3/">Better Git Conflicts with zdiff3</a> talks more about it.</p>

<h3 id="rebase-autosquash-true"><code>rebase.autosquash true</code></h3>

<p>Autosquash was also a new feature to me. The goal is to make it easier to modify old commits.</p>

<p>Here&rsquo;s how it works:</p>

<ul>
<li>You have a commit that you would like to be combined with some commit that&rsquo;s 3 commits ago, say <code>add parsing code</code></li>
<li>You commit it with <code>git commit --fixup OLD_COMMIT_ID</code>, which gives the new commit the commit message <code>fixup! add parsing code</code></li>
<li>Now, when you run <code>git rebase --autosquash main</code>, it will automatically combine all the <code>fixup!</code> commits with their targets</li>
</ul>

<p><code>rebase.autosquash true</code> means that <code>--autosquash</code> always gets passed automatically to <code>git rebase</code>.</p>

<h3 id="rebase-autostash-true"><code>rebase.autostash true</code></h3>

<p>This automatically runs <code>git stash</code> before a git rebase and <code>git stash pop</code> after. It basically passes <code>--autostash</code> to <code>git rebase</code>.</p>

<p>Personally I&rsquo;m a little scared of this since it potentially can result in merge
conflicts after the rebase, but I guess that doesn&rsquo;t come up very often for
people since it seems like a really popular configuration option.</p>

<h3 id="push-default-simple-push-default-current"><code>push.default simple</code>, <code>push.default current</code></h3>

<p>These <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-pushdefault"><code>push.default</code></a> options tell <code>git push</code> to automatically push the current branch to a remote branch with the same name.</p>

<ul>
<li><code>push.default simple</code> is the default in Git. It only works if your branch is already tracking a remote branch</li>
<li><code>push.default current</code> is similar, but it&rsquo;ll always push the local branch to a remote branch with the same name.</li>
<li><code>push.autoSetupRemote</code> and <code>push.default simple</code> together seem to do basically the same thing as <code>push.default current</code></li>
</ul>

<p><code>current</code> seems like a good setting if you&rsquo;re confident that you&rsquo;re never going
to accidentally make a local branch with the same name as an unrelated remote
branch. Lots of people have branch naming conventions (like <code>julia/my-change</code>)
that make this kind of conflict very unlikely, or just have few enough
collaborators that branch name conflicts probably won&rsquo;t happen.</p>

<h3 id="init-defaultbranch-main"><code>init.defaultBranch main</code></h3>

<p>Create a <code>main</code> branch instead of a <code>master</code> branch when creating a new repo.</p>

<h3 id="commit-verbose-true"><code>commit.verbose true</code></h3>

<p>This adds the whole commit diff in the text editor where you&rsquo;re writing your
commit message, to help you remember what you were doing.</p>

<h3 id="rerere-enabled-true"><code>rerere.enabled true</code></h3>

<p>This enables <a href="https://git-scm.com/book/en/v2/Git-Tools-Rerere">rerere</a> (&rdquo;<strong>re</strong>use <strong>re</strong>covered <strong>re</strong>solution&rdquo;), which remembers how you resolved merge conflicts
during a <code>git rebase</code> and automatically resolves conflicts for you when it can.</p>

<h3 id="help-autocorrect-10"><code>help.autocorrect 10</code></h3>

<p>By default git&rsquo;s autocorrect try to check for typos (like <code>git ocmmit</code>), but won&rsquo;t actually run the corrected command.</p>

<p>If you want it to run the suggestion automatically, you can set
<a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-helpautoCorrect"><code>help.autocorrect</code></a>
to <code>1</code> (run after 0.1 seconds), <code>10</code> (run after 1 second), <code>immediate</code> (run
immediately), or <code>prompt</code> (run after prompting)</p>

<h3 id="core-pager-delta"><code>core.pager delta</code></h3>

<p>The &ldquo;pager&rdquo; is what git uses to display the output of <code>git diff</code>, <code>git log</code>, <code>git show</code>, etc. People set it to:</p>

<ul>
<li><a href="https://github.com/dandavison/delta"><code>delta</code></a> (a fancy diff viewing tool with syntax highlighting)</li>
<li><code>less -x5,9</code> (sets tabstops, which I guess helps if you have a lot of files with tabs in them?)</li>
<li><code>less -F -X</code> (not sure about this one, <code>-F</code> seems to disable the pager if everything fits on one screen if but my git seems to do that already anyway)</li>
<li><code>cat</code> (to disable paging altogether)</li>
</ul>

<p>I used to use <code>delta</code> but turned it off because somehow I messed up the colour
scheme in my terminal and couldn&rsquo;t figure out how to fix it. I think it&rsquo;s a
great tool though.</p>

<p>I believe delta also suggests that you set up <code>interactive.diffFilter  delta --color-only</code> to syntax highlight code when you run <code>git add -p</code>.</p>

<h3 id="diff-algorithm-histogram"><code>diff.algorithm histogram</code></h3>

<p>Git&rsquo;s default diff algorithm often handles functions being reordered badly. For example look at this diff:</p>

<pre><code>-.header {
+.footer {
     margin: 0;
 }

-.footer {
+.header {
     margin: 0;
+    color: green;
 }
</code></pre>

<p>I find it pretty confusing. But with <code>diff.algorithm histogram</code>, the diff looks like this instead, which I find much clearer:</p>

<pre><code>-.header {
-    margin: 0;
-}
-
 .footer {
     margin: 0;
 }

+.header {
+    margin: 0;
+    color: green;
+}
</code></pre>

<p>Some folks also use <code>patience</code>, but <code>histogram</code> seems to be more popular. <a href="https://luppeng.wordpress.com/2020/10/10/when-to-use-each-of-the-git-diff-algorithms/">When to Use Each of the Git Diff Algorithms</a> has more on this.</p>

<h3 id="core-excludesfile-a-global-gitignore"><code>core.excludesfile</code>: a global .gitignore</h3>

<p><code>core.excludeFiles = ~/.gitignore</code> lets you have a global gitignore file that
applies to all repositories, for things like <code>.idea</code> or <code>.DS_Store</code> that you
never want to commit to any repo.</p>

<h3 id="includeif-separate-git-configs-for-personal-and-work"><code>includeIf</code>: separate git configs for personal and work</h3>

<p>Lots of people said they use this to configure different email addresses for
personal and work repositories. You can set it up something like this:</p>

<pre><code>[includeIf &quot;gitdir:~/code/&lt;work&gt;/&quot;]
path = &quot;~/code/&lt;work&gt;/.gitconfig&quot;
</code></pre>

<h3 id="fsckobjects-avoid-data-corruption"><code>fsckobjects</code>: avoid data corruption</h3>

<p>A couple of people mentioned this one. Someone explained it as &ldquo;detect data
corruption eagerly. Rarely matters but has saved my entire team a couple
times&rdquo;.</p>

<pre><code>transfer.fsckobjects = true
fetch.fsckobjects = true
receive.fsckObjects = true
</code></pre>

<h3 id="submodule-stuff">submodule stuff</h3>

<p>I&rsquo;ve never understood anything about submodules but a couple of person said they like to set:</p>

<ul>
<li><code>status.submoduleSummary  true</code></li>
<li><code>diff.submodule  log</code></li>
<li><code>submodule.recurse  true</code></li>
</ul>

<p>I won&rsquo;t attempt to explain those but there&rsquo;s <a href="https://hachyderm.io/@unlambda/111942468084436716#.">an explanation on Mastodon by @unlambda here</a>.</p>

<h3 id="and-more">and more</h3>

<p>Here&rsquo;s everything else that was suggested by at least 2 people:</p>

<ul>
<li><code>branch.sort -committerdate</code>, makes <code>git branch</code> sort by most recently used branches instead of alphabetical, to make it easier to find branches. <code>tag.sort taggerdate</code> is similar for tags.</li>
<li><code>color.ui false</code>: to turn off colour</li>
<li><code>commit.cleanup scissors</code>: so that you can write <code>#include</code> in a commit message without the <code>#</code> being treated as a comment and removed</li>
<li><code>core.autocrlf false</code>: on Windows, to work well with folks using Unix</li>
<li><code>core.editor emacs</code>: to use emacs (or another editor) to edit commit messages</li>
<li><code>credential.helper osxkeychain</code>: use the Mac keychain for managing</li>
<li><code>diff.tool difftastic</code>: use <a href="https://difftastic.wilfred.me.uk/">difftastic</a> (or <code>meld</code> or <code>nvimdiffs</code>) to display diffs</li>
<li><code>diff.colorMoved default</code>: uses different colours to highlight lines in diffs that have been &ldquo;moved&rdquo;</li>
<li><code>diff.colorMovedWS allow-indentation-change</code>: with <code>diff.colorMoved</code> set, also ignores indentation changes</li>
<li><code>diff.context 10</code>: include more context in diffs</li>
<li><code>fetch.prune true</code> and <code>fetch.prunetags</code> - automatically delete remote tracking branches that have been deleted</li>
<li><code>gpg.format ssh</code>: allow you to sign commits with SSH keys</li>
<li><code>log.date iso</code>: display dates as <code>2023-05-25 13:54:51</code> instead of <code>Thu May 25 13:54:51 2023</code></li>
<li><code>merge.keepbackup false</code>, to get rid of the <code>.orig</code> files git creates during a merge conflict</li>
<li><code>merge.tool meld</code> (or <code>nvim</code>, or <code>nvimdiff</code>) so that you can use <code>git mergetool</code> to help resolve merge conflicts</li>
<li><code>push.followtags true</code>: push new tags along with commits being pushed</li>
<li><code>rebase.missingCommitsCheck error</code>: don&rsquo;t allow deleting commits during a rebase</li>
<li><code>rebase.updateRefs true</code>: makes it much easier to rebase multiple stacked branches at a time. <a href="https://andrewlock.net/working-with-stacked-branches-in-git-is-easier-with-update-refs/">Here&rsquo;s a blog post about it</a>.</li>
</ul>

<h3 id="how-to-set-these">how to set these</h3>

<p>I generally set git config options with <code>git config --global NAME VALUE</code>, for
example <code>git config --global diff.algorithm histogram</code>. I usually set all of my
options globally because it stresses me out to have different git behaviour in
different repositories.</p>

<p>If I want to delete an option I&rsquo;ll edit <code>~/.gitconfig</code> manually, where they look like this:</p>

<pre><code>[diff]
	algorithm = histogram
</code></pre>

<h3 id="config-changes-i-ve-made-after-writing-this-post">config changes I&rsquo;ve made after writing this post</h3>

<p>My git config is pretty minimal, I already had:</p>

<ul>
<li><code>init.defaultBranch main</code></li>
<li><code>push.autoSetupRemote true</code></li>
<li><code>merge.tool meld</code></li>
<li><code>diff.colorMoved default</code> (which actually doesn&rsquo;t even work for me for some reason but I haven&rsquo;t found the time to debug)</li>
</ul>

<p>and I added these 3 after writing this blog post:</p>

<ul>
<li><code>diff.algorithm histogram</code></li>
<li><code>branch.sort -committerdate</code></li>
<li><code>merge.conflictstyle zdiff3</code></li>
</ul>

<p>I&rsquo;d probably also set <code>rebase.autosquash</code> if making carefully crafted pull
requests with multiple commits were a bigger part of my life right now.</p>

<p>I&rsquo;ve learned to be cautious about setting new config options &ndash; it takes me a
long time to get used to the new behaviour and if I change too many things at
once I just get confused. <code>branch.sort -committerdate</code> is something I was
already using anyway (through an alias), and I&rsquo;m pretty sold that <code>diff.algorithm
histogram</code> will make my diffs easier to read when I reorder functions.</p>

<h3 id="that-s-all">that&rsquo;s all!</h3>

<p>I&rsquo;m always amazed by how useful to just ask a lot of people what stuff they like and
then list the most commonly mentioned ones, like with this <a href="https://jvns.ca/blog/2022/04/12/a-list-of-new-ish--command-line-tools/">list of new-ish command line tools</a>
I put together a couple of years ago.</p>

<p>It was a little confusing to summarize these because git&rsquo;s default
options have actually changed a lot of the years, so people occasionally have
options set that were important 8 years ago but today are the default. Also a
couple of the experimental options people were using have been removed and
replaced with a different version.</p>

<p>I did my best to explain things accurately as of how git works right now in
2024 but I&rsquo;ve definitely made mistakes in here somewhere, especially because I
don&rsquo;t use most of these options myself. Let me know on Mastodon if you see a
mistake and I&rsquo;ll try to fix it.</p>

<p>I might also ask people about aliases later, there were a bunch of great ones
that I left out because this was already getting long.</p>

  </body>
</html>
