<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ndrwnaguib/principia">Original</a>
    <h1>Show HN: Formalizing Principia Mathematica using Lean</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://jamiepalatnik.com/ndrwnaguib/principia/blob/main/images/principia-mathematica-book-cover.png"><img src="https://jamiepalatnik.com/ndrwnaguib/principia/raw/main/images/principia-mathematica-book-cover.png" alt="./images/principia-mathematica-book-cover.png"/></a></p>
<p dir="auto">This <a href="https://github.com/ndrwnaguib/principia">project</a> aims to formalize the first volume of Prof. Bertrand Russell’s
  Principia Mathematica using the Lean theorem prover. The goal is to ensure that
  the formalization aligns clearly with the corresponding theorems in the book to
  avoid confusion (See <a href="https://jamiepalatnik.com/ndrwnaguib/principia/blob/main/%2AMetaprogramming%20=Syll=">Metaprogramming =Syll=</a>)</p>

<p dir="auto"><a href="https://plato.stanford.edu/entries/principia-mathematica/" rel="nofollow">Principia Mathematica</a>’s notation (Peano-Russell notation) is exceptionally known
  for its sophistication that it <a href="https://plato.stanford.edu/entries/pm-notation/" rel="nofollow">has a separate entry on the Stanford Encyclopedia
  of Philosophy (SEP)</a>. Also, Prof. Landon Elkind’s <a href="https://muse.jhu.edu/pub/1/article/904086" rel="nofollow">Squaring the Circles: a
  Genealogy of Principia’s Dot Notation</a> explains the notation skillfully.</p>
<p dir="auto">I do not think there is a <b>need</b> to read them, I would like to believe that
  after reading a few examples of how some formulas were formalized and
  contrasting them against Prof. Russell’s notation should make it clear.</p>
<p dir="auto">Throughout the formalization, I tried to rigorously follow Prof. Russell’s
  proof, with no or little added statements from my side, which were only
  necessary for the formalization but not the logical argument. Should you notice
  any inaccuracy (even if it does not necessarily falsify the proof), please let
  me know as I would like to proceed with the same spirit of rigor as Prof.
  Russell.</p>
<p dir="auto">Before starting this project, I had already found <a href="https://www.principiarewrite.com/" rel="nofollow">Prof. Elkind’s formalization
  of the Principia using Coq</a>, which is much mature work than this one. However, I
  still thought it would be fun to do it using Lean4 (See <a href="https://jamiepalatnik.com/ndrwnaguib/principia/blob/main/*Remarks">Remarks</a>).</p>

<p dir="auto">I have included a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="fb2ac254536cdb07cd40331a4c58de49">$\LaTeX$</math-renderer> fragment with each theorem that represents Prof. Russell’s
  proof. If you use Emacs, I recommend enabling <code>org-preview-latex</code> in the Lean
  buffer. If you are using VSCode, perhaps a similar experience can be achieved by
  installing the <code>Better Comments</code> extension. This is how it looked like for me:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://jamiepalatnik.com/ndrwnaguib/principia/blob/main/images/editing-experience.png"><img src="https://jamiepalatnik.com/ndrwnaguib/principia/raw/main/images/editing-experience.png" alt="./images/editing-experience.png"/></a></p>


<p dir="auto">Prof. Russell repeatedly used *1.11 to indicate the inference of a proposition
  from another, for example <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="fb2ac254536cdb07cd40331a4c58de49">$[(3).(8).∗ 1⋅ 11]$</math-renderer> is the proposition deduced by chaining
  proposition (8) and (3). In Lean, this could be analogous to several tactics or
  atoms, e.g., <code>&lt;|</code>, <code>simp</code>, etc.</p>

<p dir="auto">The experience I planned for when reading the formalization is to have the
  corresponding text in the Principia included in the same file, only with Prof.
  Russell’s proofs replaced with their Lean formalization. For example, here is
  *2.16 along with a unique part in the formalization, that is <a href="https://leanprover-community.github.io/lean4-metaprogramming-book/main/09_tactics.html" rel="nofollow">metaprogramming a
  new tactic</a> to follow Prof. Russell’s notation for <code>Syll</code>:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://jamiepalatnik.com/ndrwnaguib/principia/blob/main/images/syll.png"><img src="https://jamiepalatnik.com/ndrwnaguib/principia/raw/main/images/syll.png" alt="./images/syll.png"/></a></p>
<pre lang="lean4">open Lean Meta Elab Tactic Term

structure ImpProof where
  (ant cons : Expr)
  (proof : Expr)
  deriving Inhabited

theorem compose {p q r : Prop} (a : p → q) (b : q → r) : p → r :=
  b ∘ a

/-- Compose two implication proofs using the `compose` theorem. -/
def ImpProof.compose (a : ImpProof) (b : ImpProof) : MetaM ImpProof := do
  unless ← isDefEq a.cons b.ant do
    throwError &#34;\
      Consequent{indentD a.cons}\n\
      is not definitionally equal to antecedent{indentD b.ant}&#34;
  let proof := mkApp5 (.const ``compose []) a.ant a.cons b.cons a.proof b.proof
  return { ant := a.ant, cons := b.cons, proof := proof }

/-- Create the proof of `p -&gt; p` using the `id` function. -/
def ImpProof.rfl (p : Expr) : ImpProof :=
  { ant := p, cons := p, proof := .app (.const ``id [.zero]) p}

syntax &#34;Syll&#34; (ppSpace &#34;[&#34; term,* &#34;]&#34;)? : tactic

elab_rules : tactic
  | `(tactic| Syll $[[$[$terms?],*]]?) =&gt; withMainContext do

    -- Elaborate all the supplied hypotheses, or use the entire local context if not provided.
    let hyps ←
      match terms? with
      | none =&gt; getLocalHyps
      | some terms =&gt; terms.mapM fun term =&gt; Tactic.elabTerm term none

    liftMetaTactic1 fun goal =&gt; do
      let goalType ← goal.getType

      -- A list of implications extracted from `hyps`.
      let mut chain : Array ImpProof := #[]

      let getImplication? (e : Expr) : MetaM (Option (Expr × Expr)) := do
        -- There may be metadata and metavariables, so do some unfolding if necessary:
        let ty ← instantiateMVars (← whnfR e)
        -- Check if it is a non-dependent forall:
        if ty.isArrow then
          return (ty.bindingDomain!, ty.bindingBody!)
        else
          return none

      for hyp in hyps do
        match ← getImplication? (← inferType hyp) with
        | some (p, q) =&gt; chain := chain.push {ant := p, cons := q, proof := hyp}
        | none =&gt; logInfo m!&#34;Expression {hyp} is not of the form `p → q`&#34;

      let some (p, q) ← getImplication? goalType
        | throwError &#34;Goal type is not of the form `p → q`&#34;

      if chain.isEmpty then
        throwError &#34;Local context has no implications&#34;

      unless ← isExprDefEq chain[0]!.ant p do
        throwError &#34;The first hypothesis does not match the goal&#39;s antecedent&#34;

      unless ← isExprDefEq chain[chain.size - 1]!.cons q do
        throwError &#34;The last hypothesis does not match the goal&#39;s consequent&#34;

      let comp ← chain.foldlM (init := ImpProof.rfl p) (fun pf1 pf2 =&gt; pf1.compose pf2)

      -- It&#39;s good to do one last check that the proof has the correct type before assignment.
      unless ← isDefEq (← inferType comp.proof) goalType do
        throwError &#34;Invalid proof of goal&#34;
      goal.assign comp.proof

      return none
</pre>
<p dir="auto">Consequently, I could write the following:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://jamiepalatnik.com/ndrwnaguib/principia/blob/main/images/syll-example.png"><img src="https://jamiepalatnik.com/ndrwnaguib/principia/raw/main/images/syll-example.png" alt="./images/syll-example.png"/></a></p>
<p dir="auto">It was only a result of my greed to write a tactic that handles a more general
  form of syllogism; I believe in the case of the Principia, I could have got away
  with one that accepts two hypotheses.</p>

<p dir="auto">I do not see a particular use for this project except for learning the
  thought-process of building mathematics from scratch. Although the Principia is
  thought to be “a monumental failure”, as said by Prof. Freeman Dyson, it was an
  enriching experience for me to read as well as to formalize-especially after
  observing how the latter, more complicated results, are obtained using simpler
  ones I personally formalized.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://jamiepalatnik.com/ndrwnaguib/principia/blob/main/images/building-from-constituents.png"><img src="https://jamiepalatnik.com/ndrwnaguib/principia/raw/main/images/building-from-constituents.png" alt="./images/building-from-constituents.png"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://jamiepalatnik.com/ndrwnaguib/principia/blob/main/images/logic-semantics-and-metamathematics-book-cover.png"><img src="https://jamiepalatnik.com/ndrwnaguib/principia/raw/main/images/logic-semantics-and-metamathematics-book-cover.png" alt="./images/logic-semantics-and-metamathematics-book-cover.png"/></a></p>
<p dir="auto">Perhaps a following project would be formalizing Alfred Tarski’s “Logic,
  Semantics, and Metamathematics.”</p>
</article></div></div>
  </body>
</html>
