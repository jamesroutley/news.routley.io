<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1024160/f18b880c8cd1eef1/">Original</a>
    <h1>Slowing the flow of core-dump-related CVEs</h1>
    
    <div id="readability-page-1" class="page"><p>

<h2>[LWN subscriber-only content]</h2>
</p><div>
<p>
The 6.16 kernel will include a number of changes to how the kernel handles
the processing of core dumps for crashed processes.  Christian Brauner <a href="https://mastodon.social/@brauner/114592290899392625">explained</a>
his reasons for doing this work as: &#34;<q>Because I&#39;m a clown and also I had
it with all the CVEs because we provide a **** API for userspace</q>&#34;.  The
handling of core dumps has indeed been a constant source of
vulnerabilities; with luck, the 6.16 work will result in rather fewer of
them in the future.
</p><h4>The problem with core dumps</h4>
<p>
A core dump is an image of a process&#39;s data areas â€” everything except the
executable text; it can be used to investigate the cause of a crash by
examining a process&#39;s state at the time things went wrong.  Once upon a
time, Unix systems would routinely place a core dump into a file called
<tt>core</tt> in the current working directory when a program crashed.  The
main effects of this practice were to inspire system administrators
worldwide to remove <tt>core</tt> files daily via <tt>cron</tt> jobs, and
to make it hazardous to use the name <tt>core</tt> for anything you wanted
to keep.  Linux systems can still create <tt>core</tt> files, but are
usually configured not to.
</p><p>
An alternative that <i>is</i> used on some systems is to have the kernel
launch a process to read the core dump from a crashing process and,
presumably, do something useful with it.  This behavior is configured by
writing an appropriate string to <a href="https://docs.kernel.org/admin-guide/sysctl/kernel.html#core-pattern">the
<tt>core_pattern</tt> sysctl knob</a>.  A number of distributors use this
mechanism to set up core-dump handlers that phone home to report crashes so
that the guilty programs can, hopefully, be fixed.
</p><blockquote>
The <a href="https://lwn.net/ksdb/">LWN kernel-source database</a> is the definitive source of information about kernel releases.  <a href="https://lwn.net/Promo/KSDB/claim">Try a one-month free trial subscription</a> for immediate access to LWN&#39;s kernel content and KSDB as well.
</blockquote>
<p>
This is the &#34;<q>**** API</q>&#34; referred to by Brauner; it indeed has a
number of problems.  For example, the core-dump handler is launched by the
kernel as a user-mode helper, meaning that it runs fully privileged in the
root namespace.  That, needless to say, makes it an attractive target for
attackers.  There are also a number of race conditions that emerge from this
design that have led to vulnerabilities of their own.
</p><p>
See, for example, <a href="https://lwn.net/ml/all/20250529171556.GA9260@localhost.localdomain">this recent
Qualys advisory</a> describing a vulnerability in Ubuntu&#39;s <a href="https://wiki.ubuntu.com/Apport"><tt>apport</tt></a> tool and the <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd-coredump.html"><tt>systemd-coredump</tt></a>
utility, both of which are designed to process core dumps.  In short, an
attacker starts by running a setuid binary, then forcing it to crash at an
opportune moment.  While the core-dump handler is being launched (a step
that the attacker can delay in various ways), the crashed process is killed
outright with a <tt>SIGKILL</tt> signal, then quickly replaced by another
process with the same process ID.  The core-dump handler will then begin to
examine the core dump from the crashed process, but with the information
from the replacement process.
</p><p>
That process is running in its own attacker-crafted namespace, with some
strategic environmental changes.  In this environment, the core-dump
handler&#39;s attempt to pass the core-dump socket to a helper can be
intercepted; that allows said process to gain access to the file descriptor
from which the core dump can be read.  That, in turn, gives the attacker
the ability to read the (original, privileged) process&#39;s memory, happily
pillaging any secrets found there.  The example given by Qualys obtains the
contents of <tt>/etc/shadow</tt>, which is normally unreadable, but it
seems that SSH servers (and the keys in their memory) are vulnerable to the
same sort of attack.
</p><p>
Interested readers should consult the advisory for a much more detailed
(and coherent) description of how this attack works, as well as information
on some previous vulnerabilities in this area.  The key takeaways,
though, are that core-dump handlers on a number of widely used distributions
are vulnerable to this attack, and that reusable integer IDs as a way to
identify processes are just as much of a problem as the pidfd developers
have been saying over the years.
</p><h4>Toward a better API</h4>
<p>
The solution to this kind of race condition is to give the core-dump
handler a way to know that the process it is investigating is, indeed, the
one that crashed.  The 6.16 kernel contains two separate changes toward
that goal.  The first is <a href="https://git.kernel.org/linus/b5325b2a270f">this patch from
Brauner</a> adding a new format specifier (&#34;<tt>%F</tt>&#34;) for the string
written to <tt>core_pattern</tt>.  This specifier will cause the core-dump
handler to be launched with a pidfd identifying the crashed process
installed as file descriptor number three.  Since it is a pidfd, it will
always refer to the intended process and cannot be fooled by process-ID
reuse.
</p><p>
This change makes it relatively easy to adapt core-dump handlers to avoid
the most recently identified vulnerabilities; it has already been
backported to <a href="https://lwn.net/Articles/1023794/">a recent set of stable
kernels</a>.  But it does not change the basic nature of the
<tt>core_pattern</tt> API, which still requires the launch of a new, fully
privileged process to handle each crash.  It is, instead, a workaround for
one of the worst problems with that API.
</p><p>
The longer-term fix is <a href="https://lwn.net/ml/all/20250507-work-coredump-socket-v4-0-af0ef317b2d0@kernel.org">this
series from Brauner</a>, which was also merged for 6.16.  It adds a new
syntax to <tt>core_pattern</tt> instructing the kernel to write core dumps
to an existing socket; a user-space handler can bind to that socket and
accept a new connection for each core dump that the kernel sends its way.
The handler must be privileged to bind to the socket, but it remains an
ordinary process rather than a kernel-created user-mode helper, and the
process that actually reads core dumps requires no special privileges at
all.  So the core-dump handler can bind to the socket, then drop its
privileges and sandbox itself, closing off a number of attack vectors.
</p><p>
Once a new connection has been made, the handler can obtain a pidfd for the
crashed process using the <tt>SO_PEERPIDFD</tt> request for <a href="https://man7.org/linux/man-pages/man2/setsockopt.2.html"><tt>getsockopt()</tt></a>.
Once again, the pidfd will refer to the actual crashed process, rather than
something an attacker might want the handler to treat like the crashed
process.  The handler can pass the new <tt>PIDFD_INFO_COREDUMP</tt> option
to the <a href="https://lwn.net/Articles/992991/"><tt>PIDFD_GET_INFO</tt> <tt>ioctl()</tt>
command</a> to learn more about the crashed process, including whether the
process is, indeed, having its core dumped.  There are, in other words, a
couple of layers of defense against the sort of substitution attack
demonstrated by Qualys.
</p><p>
The end result is a system for handling core dumps that is more efficient
(since there is no need to launch new helper processes each time) and which
should be far more resistant to many types of attacks.  It may take some
time to roll out to deployed systems, since this change seems unlikely to
be backported to the stable kernels (though distributors may well choose to
backport it to their own kernels).  But, eventually, this particular source
of CVEs should become rather less productive than it traditionally has
been.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Releases-6.16">Releases/6.16</a></td></tr>
            <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Security-Vulnerabilities">Security/Vulnerabilities</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
