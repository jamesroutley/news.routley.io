<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/postgres-foreign-data-wrappers-rust">Original</a>
    <h1>Supabase Wrappers: A framework for building Postgres foreign data wrappers</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>Today we&#39;re releasing <a href="https://github.com/supabase/wrappers">Supabase Wrappers</a>, a framework for building Postgres Foreign Data Wrappers (FDW) which connects Postgres to external systems.</p>
<p>Foreign Data Wrappers are a core feature of PostgreSQL. We&#39;ve extended this feature to query other databases or any other external system (including third-party APIs), using SQL.</p>
<p><span><span><img alt="FDW" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>We&#39;re releasing Wrappers today in Alpha, with support for <a href="https://supabase.github.io/wrappers/firebase/">Firebase</a> and <a href="https://supabase.github.io/wrappers/stripe/">Stripe</a>. Wrappers for Clickhouse, BigQuery, and Airtable are under development.</p>
<h2 id="example-with-stripe">Example with Stripe</h2>
<p>Let&#39;s step through a full example using the Stripe Wrapper.</p>
<p><span><span><img alt="FDW" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<h3 id="connecting-to-stripe">Connecting to Stripe</h3>
<p>First, let&#39;s give your Postgres database some authentication details to access your Stripe account:</p>

<h3 id="creating-a-foreign-table">Creating a Foreign Table</h3>
<p>Now we can map your Stripe data to Foreign Tables, which are just like normal tables except that the data exists <em>outside</em> of your database.</p>

<h3 id="accessing-remote-data">Accessing remote data</h3>
<p>After setting up your foreign table, you can query you Stripe products directly from your database:</p>

<p><span><span><img alt="Stripe Products" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>Or from your application, using one of our client libraries:</p>

<p><em>Note: we kept this example simple, however for API security and code organization, you should store your foreign data in a <a href="https://supabase.com/docs/reference/javascript/initializing#api-schemas">separate schema</a>.</em></p>
<h2 id="use-cases">Use cases</h2>
<p>Once we&#39;ve added more Wrappers, they enable various possibilities:</p>
<ul>
<li><strong>On-demand Big Data:</strong> Query your Data Warehouse on demand using Wrappers for Clickhouse, BigQuery, Snowflake, Oracle, and S3.</li>
<li><strong>Simplified Onboarding:</strong> Migrate to Postgres from systems like Firebase, MySQL, and Airtable.</li>
<li><strong>Simplified Development:</strong> Create a new Stripe customer object within a Postgres function.</li>
<li><strong>AI capabilities:</strong> Run AI queries from your database using OpenAI&#39;s API.</li>
<li><strong>Caching:</strong> use Postgres triggers to insert data into in-memory databases like Redis.</li>
<li><strong>SRE and DevOps:</strong> Query your infrastructure state, like AWS and DNS records.</li>
<li><strong>Web3 Apps:</strong> integrate with IPFS and blockchains like Ethereum.</li>
<li><strong>Financial Apps:</strong> Build Financial applications using wrappers around Finance APIs.</li>
<li><strong>Community analytics:</strong> Analyze your community engagement with GitHub, Slack, Discord, and Twitter wrappers.</li>
</ul>
<h2 id="on-demand-etl">On-demand ETL</h2>
<p>In their 2017 <a href="https://www.sciencedirect.com/science/article/abs/pii/S0169023X1730438X">paper</a>, researchers from the University of Bologna investigated an approach to on-demand ETL:</p>
<blockquote>
<p>In traditional OLAP systems, the ETL process loads all available data in the data warehouse before users start querying them. In some cases, this may be either inconvenient (because data are supplied from a provider for a fee) or unfeasible (because of their size); on the other hand, directly launching each analysis query on source data would not enable data reuse, leading to poor performance and high costs. The alternative investigated in this paper is that of fetching and storing data on-demand.</p>
</blockquote>
<p>Their paper outlines the foundation for QETL (pronounced &#34;kettle&#34;): Query, Extract, Transform, Load. This differs from a more traditional ETL/ELT approach, where data is moved from one place to another. In QETL, the ‚ÄúQuery‚Äù function allows data engineers to access data in a remote system even before moving it. This approach reduces the reliance on data engineering infrastructure, allowing teams to access operational insights faster.</p>
<h3 id="the-benefits-of-qetl">The benefits of QETL</h3>
<p>We&#39;ve built upon this concept using PostgreSQL&#39;s FDW system. This a new tool for developers and data engineers, with several benefits:</p>
<ol>
<li><strong>Simplicity:</strong> the Wrappers API is just SQL, so data engineers don&#39;t need to learn new tools and languages.</li>
<li><strong>On-demand:</strong> analytical data is available within your product without any additional infrastructure, and the time it takes to retrieve that data is close to executing a query on the source.</li>
<li><strong>Always in sync:</strong> data which isn&#39;t moved will always be in sync. Developers can set up local views which re-map remote data into clean local schemas.</li>
<li><strong>Integrated:</strong> large datasets are available within your application, and can be joined with your operational/transactional data.</li>
<li><strong>Save on bandwidth:</strong> only extract/load what you need.</li>
<li><strong>Save on time:</strong> avoid setting up additional data pipelines.</li>
<li><strong>Save on Data Engineering costs:</strong> less infrastructure to be managed.</li>
</ol>
<h3 id="qetl--postgres">QETL + Postgres</h3>
<p>How does this look in action? Assuming that all of your analytical data is stored in Snowflake, you could create a foreign table inside your Supabase database:</p>

<p>Now from your Supabase database you can query your Snowflake data directly:</p>

<p>You can even join remote data with your local tables to enrich existing operational data. For example, to figure out how many times a user has purchased something from your store:</p>

<p>We can either run these queries on demand or, for better query performance, we can run them in the background (using something like <a href="https://supabase.com/docs/guides/database/extensions/pgcron">pg_cron</a>), and materialize the data into a local table.</p>
<p><span><span><img alt="QETL" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>This gives us the basis of QETL:</p>
<ul>
<li>Query: run on-demand SQL queries, directly from your Postgres database.</li>
<li>Extract: run SQL <code>select</code> statements on external systems, either on demand or on a recurring basis.</li>
<li>Transform: use SQL aggregations and CTEs to transform the data.</li>
<li>Load: store transformed data into local tables for faster access.</li>
</ul>
<p>This is a two-way process. It&#39;s equally useful to offload large datasets from your Postgres database to your Data Warehouse. With FDWs, this can be as simple as:</p>

<p>On-demand ETL is a strong compliment for current ETL practices, and another tool in the toolbelt for Data Engineering and Developers that works with immediately with tools that interface with Postgres.</p>
<h2 id="postgres-the-everything-interface">Postgres, the everything interface</h2>
<p>In a recent Software Engineering <a href="https://podcasts.apple.com/us/podcast/software-engineering-daily/id1019576853?i=1000580384354">episode</a> Andy Pavlo (database Professor at Carnegie Mellon and Co-Founder of OtterTune), explored the future between ‚Äúbetter databases‚Äù and ‚Äúbetter interfaces‚Äù [00:37:18]:</p>
<figure><div><blockquote><p>Specialized engines are always going to outperform general-purpose ones. The question is whether
the specialized engine is going to have such a significant difference in performance that it can
overcome the limitations of a general purpose one.</p><p>...</p><p>The challenge oftentimes is this: is the benefit you&#39;re getting from a specialized engine
because the <em>Engine</em> is different or the <em>API</em> is different?.</p></blockquote><div><p><img src="https://supabase.com/images/blog/avatars/andy-pavlo.jpeg" alt="Andy Pavlo avatar"/></p><figcaption><p>Andy Pavlo</p></figcaption></div></div></figure>
<p>He goes on to explore the benefits of a Graph database vs a Relational database.</p>
<p>Our recent release of <a href="https://github.com/supabase/pg_graphql/">pg_graphql</a> closes the gap on the graph use-case by building a GraphQL API directly into Postgres as an extension. While a specialized graph database might provide performance benefits over Postgres, perhaps one of the largest benefits is simply the Graph API which makes it easier to reason about the data.</p>
<p>With the introduction of Wrappers, we&#39;re hoping to close the gap on even more of these type of workloads.</p>
<p>An exciting part of the FDW approach is that it provides a common interface to the world: SQL. While it has many shortcomings, SQL is the lingua franca of data. Postgres&#39; FDWs transform any API into a data set with a common interface. This ‚Äúinterface aggregator‚Äù is similar to the <a href="https://medium.com/vicetech/graphql-the-great-aggregator-bcf52fe390d9">promise</a> of GraphQL engines. The benefit of embedding this functionality in the database is that it exists at the <em>lowest level of the tech stack</em>. Everything that is built on top can leverage it. While Postgres cannot easily access the functionality of a GraphQL server, a GraphQL server can easily access the functionality of Postgres.</p>
<p>The FDW interface also future-proofs Postgres. Instead of keeping up with the latest technological advances, Postgres can instead act as an interface whenever they develop. The recent advance in AI and ML is a great example of this: AI technology is developing faster than the time it would take to build a new ‚ÄúAI database‚Äù. With a FDW, Postgres can become the interface to this technology and many other technological advances in the future.</p>
<h2 id="developing-wrappers">Developing Wrappers</h2>
<p>Postgres has a builtin ‚ÄúPostgres FDW‚Äù allows querying one Postgres database from another. We&#39;ve extended this functionality to support a variety of data sources, from Data Warehouses to APIs.
This release includes two initial wrappers: Stripe and Firebase</p>
<table><thead><tr><th>Integration</th><th>Platform</th><th>Self-hosted</th><th><span>select</span></th><th><span>insert</span></th><th><span>update</span></th><th><span>delete</span></th></tr></thead><tbody><tr><td>Firebase</td><td>üöß</td><td>‚úÖ</td><td>‚úÖ</td><td>üöß</td><td>üöß</td><td>üöß</td></tr><tr><td>Postgres</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td></tr><tr><td>Stripe</td><td>üöß</td><td>‚úÖ</td><td>‚úÖ</td><td>üöß</td><td>üöß</td><td>üöß</td></tr></tbody></table>
<p>With several more <a href="https://github.com/supabase/wrappers/tree/main/wrappers/src/fdw">under development</a>:</p>
<table><thead><tr><th>Integration</th><th><span>select</span></th><th><span>insert</span></th><th><span>update</span></th><th><span>delete</span></th></tr></thead><tbody><tr><td>Airtable</td><td>‚úÖ</td><td>üöß</td><td>üöß</td><td>üöß</td></tr><tr><td>BigQuery</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td></tr><tr><td>ClickHouse</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td></tr></tbody></table>
<p>Wrappers used <a href="https://github.com/tcdi/pgx">pgx</a>, extending it with FDW support. pgx is a Postgres extension framework written in Rust. Wrappers is very similar to <a href="https://steampipe.io/">Steampipe</a> or <a href="https://multicorn.org/">Multicorn</a>. We opted to develop our own framework for several reasons:</p>
<ul>
<li>The current state of FDWs is in disarray. It&#39;s hard to know which FDWs are supported and functional. We think there&#39;s a benefit to colocating all FDWs in a single repository using modern tooling. This makes contributing simpler and maintenance faster.</li>
<li>Wrappers has async support, which enables the development of RESTful API-based FDWs, like Stripe.</li>
<li>It&#39;s written in Rust, which provides reliable performance, strong typing, data security, and ‚Äúpush down‚Äù is supported through the framework.</li>
</ul>
<h2 id="supported-types-and-push-down">Supported types and Push Down</h2>
<p>Wrappers <a href="https://github.com/supabase/wrappers/blob/83887dcc2ddcf972ca1b1eec4a598cd7bff947de/supabase-wrappers/src/interface.rs#L11">supports</a> a variety of types, including:
<code>bool</code>, <code>i8</code>, <code>i16</code>, <code>f32</code>, <code>i32</code>, <code>f64</code>, <code>i64</code>, <code>String</code>, <code>Date</code>, <code>Timestamp</code>, and <code>JsonB</code>.</p>
<p>Foreign Data Wrappers have a concept of &#34;push down&#34;. This means that the FDW runs the query on <em>remote</em> data source. This is useful for performance reasons, as the remote data source can often perform the query more efficiently than Postgres. Push down is also useful for security reasons, as the remote data source can enforce access control. Limited push-down support has been added as a Proof of Concept, but this will be a key focus of Wrappers.</p>
<p>You can follow development off all Wrappers in the offiical <a href="https://github.com/supabase/wrappers">GitHub Repo</a>.</p>
<h2 id="next-steps">Next Steps</h2>
<p>We&#39;re not &#34;officially&#34; releasing Wrappers onto the platform yet, although the brave and curious might be able to figure out how to use it &#34;unofficially&#34;. Caveat emptor: there will be breaking changes.</p>
<p>We&#39;re excited to see what the community does with Wrappers. We&#39;re hoping that Wrappers will help to accelerate the adoption of Postgres as a data hub.
If you&#39;re interested in getting involved or building your own Wrapper, don&#39;t hesitage to jump into the code and start developing with us.</p>
<ul>
<li>Star &amp; Watch the GitHub repo: <a href="https://github.com/supabase/wrappers">thub.com/supabase/wrapper</a></li>
<li>View the documentation: <a href="https://supabase.github.io/wrappers/">supabase.github.io/wrappers</a></li>
<li>Supabase Launch Week: <a href="https://supabase.com/launch-week">supabase.com/launch-week</a></li>
</ul>
<iframe width="640" height="385" src="https://www.youtube-nocookie.com/embed/QA2qC5F-4OU" frameborder="1" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
<h2 id="more-launch-week-6">More Launch Week 6</h2>
<ul>
<li><a href="https://supabase.com/blog/new-supabase-docs-built-with-nextjs">Day 1: New Supabase Docs, built with Next.js</a></li>
<li><a href="https://supabase.com/blog/storage-image-resizing-smart-cdn">Day 2: Supabase Storage v2: Image resizing and Smart CDN</a></li>
<li><a href="https://supabase.com/blog/mfa-auth-via-rls">Day 3: Multi-factor Authentication via Row Level Security Enforcement</a></li>
<li><a href="https://supabase.com/blog/launch-week-6-hackathon">Launch Week 6 Hackathon</a></li>
<li><a href="https://supabase.com/blog/who-we-hire">Who We Hire at Supabase</a></li>
<li><a href="https://supabase.com/blog/postgres-crdt">pg_crdt - an experimental CRDT extension for Postgres</a></li>
</ul></div></article></div>
  </body>
</html>
