<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jeffquast.com/post/state-of-terminal-emulation-2025/">Original</a>
    <h1>State of Terminal Emulators in 2025: The Errant Champions</h1>
    
    <div id="readability-page-1" class="page"><p>
                    <h5>
                    <time datetime="" itemprop="datePublished">
                    2. November 2025
                    </time>
                    </h5>
                </p><div itemprop="articleBody">
                    <div>


<p>This is a follow-up to my previous article, <a href="https://www.jeffquast.com/post/ucs-detect-test-results/">Terminal Emulators Battle Royale –
Unicode Edition!</a> from 2023, in which I documented Unicode support across terminal
emulators. Since then, the <a href="https://ucs-detect.readthedocs.io/intro.html#ucs-detect">ucs-detect</a> tool and its supporting <a href="https://blessed.readthedocs.io/">blessed</a> library
have been extended to automatically detect support of <a href="https://blessed.readthedocs.io/en/latest/dec_modes.html">DEC Private Modes</a>, <a href="https://blessed.readthedocs.io/en/latest/sixel.html">sixel graphics</a>,
<a href="https://blessed.readthedocs.io/en/latest/sixel.html#window-dimensions">pixel size</a>, and <a href="https://blessed.readthedocs.io/en/latest/terminal.html#terminal-software-version">software version</a>.</p>
<p>The ucs-detect program tests terminal cursor positioning by sending visible
text followed by control sequences that request the cursor position. The
terminal responds by writing the cursor location as simulated keyboard input.
The ucs-detect program reads and compares these values against the <a href="https://wcwidth.readthedocs.io/en/latest/intro.html">Python wcwidth</a>
library result, logging any discrepancies.</p>
<div id="the-width-problem">
<h2>The Width Problem</h2>
<p>Terminal emulators face a fundamental challenge: mapping the vast breadth of
Unicode scripts into a fixed-width grid while maintaining legibility. A terminal
must predict whether each character occupies one cell or two, whether combining
marks overlay previous characters, and how emoji sequences collapse into single
glyphs.</p>
<p>These predictions fail routinely. Zero-width joiners, variation selectors, and
grapheme clustering compound in complexity. When terminals and CLI applications
guess wrong, text becomes unreadable - cursors misalign and corrupt output and
so then also corrupt the location of our input.</p>
<p>Our results share which terminals have the best &#34;Unicode support&#34; -- the least
likely to exhibit these kinds of problems.</p>
</div>
<div id="the-gentleman-errant">
<h2>The Gentleman Errant</h2>
<p>Before presenting the latest results, <a href="https://ghostty.org/">Ghostty</a> warrants particular attention,
not only because it scored the highest among all terminals tested, but that it
was publicly released only this year by Mitchell Hashimoto.  It is a significant
advancement. Developed from scratch in <a href="https://ziglang.org/">zig</a>, the Unicode support implementation
is thoroughly correct.</p>
<p>In 2023, Mitchell published <a href="https://mitchellh.com/writing/grapheme-clusters-in-terminals">Grapheme Clusters and Terminal Emulators</a>,
demonstrating a commitment to understanding and implementing the fundamentals.
His recent announcement of <a href="https://mitchellh.com/writing/libghostty-is-coming">libghostty</a> provides a welcome alternative to <a href="https://gitlab.gnome.org/GNOME/vte">libvte</a>,
potentially enabling a new generation of terminals on a foundation of strong
Unicode support.</p>
</div>
<div id="the-errant-champion">
<h2>The Errant Champion</h2>
<p>Kovid Goyal&#39;s <a href="https://sw.kovidgoyal.net/kitty/">Kitty</a> scored just as well, only outranked by the arbitrary
weights that are not necessarily fair.  More important than scoring is Kovid&#39;s
publication of a <a href="https://sw.kovidgoyal.net/kitty/text-sizing-protocol/#the-algorithm-for-splitting-text-into-cells">text-splitting algorithm description</a> that closely matches
the <a href="https://wcwidth.readthedocs.io/en/latest/specs.html">Python wcwidth specification</a>. This is unsurprising since both are
derived from careful interpretation of <a href="https://unicode.org/">Unicode.org</a> standards and that it scores
so highly in our test.</p>
<p><a href="https://sw.kovidgoyal.net/kitty/">Kitty</a> and <a href="https://ghostty.org/">Ghostty</a> are the only terminals that correctly support <a href="https://unicode.org/reports/tr51/#Emoji_Variation_Sequences">Variation
Selector 15</a>, I have not written much about it because it is not likely to see
any practical use, but, it will be added to a future release of Python
wcwidth now that there are multiple standards and reference implementations
in agreement.</p>
</div>
<div id="testing-results">
<h2>Testing Results</h2>
<p>The first table, <a href="https://ucs-detect.readthedocs.io/results.html#general-tabulated-summary">General Tabulated Summary</a> describes unicode features
of each terminal, then, a brief summary of DEC Private Modes, sixel support,
and testing time.</p>

<p>The second table, <a href="https://ucs-detect.readthedocs.io/results.html#dec-private-modes-support">DEC Private Modes Support</a> (not pictured), contains the
first feature capability matrix of <a href="https://blessed.readthedocs.io/en/latest/dec_modes.html">DEC Private Modes</a> for Terminals of any
length.  I hope this is useful most especially to developers of CLI libraries
and applications.</p>
</div>
<div id="the-long-road">
<h2>The Long Road</h2>
<p>The most notable finding relates to performance.  That many terminals perform so
slowly was surprising, so I have included the elapsed time in the results.</p>
<p><a href="https://iterm2.com/">iTerm2</a> and <a href="https://extraterm.org/">Extraterm</a> consume a majority of the CPU and perform so slowly that
the test parameters were reduced to finish within the hour what many other
terminals manage in a few minutes.</p>
<p><a href="https://help.gnome.org/users/gnome-terminal/stable/">GNOME Terminal</a> and its VTE-based derivatives also perform too slowly for a
full test, taking over 5 hours while consuming very little CPU.  Many
terminals exhibit stalls or inefficiencies in their event loops that result in
slow automatic responses, but we should be forgiving; nobody really considered
the need to handle hundreds of automatic sequence replies per second!</p>
<p>I expected Python wcwidth to consume the most CPU resources during testing, as
it is frequently called and always the &#34;highest-level&#34; language in the mix, but
it keeps up pretty well for most terminals.</p>
<p>Earlier this year, I dedicated effort to optimizing the Python wcwidth
implementation using techniques including bit vectors, bloom filters, and varying
sizes of <a href="https://en.wikipedia.org/wiki/Page_replacement_algorithm#Least_recently_used">LRU</a> caches. The results confirmed that the existing implementation
performed best: a <a href="https://github.com/jquast/wcwidth/blob/5ba540df3386255dcde94bf867665ddf1cab868f/wcwidth/wcwidth.py#L76-L145">binary search</a> with a <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">functools.lru_cache</a> decorator.</p>
<p>The LRU cache is effective because human languages typically use a small,
repetitive subset of Unicode. The ucs-detect tool tests hundreds of languages
from the <a href="https://ucs-detect.readthedocs.io/intro.html#udhr-data">UDHR dataset</a>, excluding only those without any interesting zero
or wide characters. This dataset provides an extreme but practical demonstration
of LRU cache benefits when processing Unicode.</p>
<p>I previously <a href="https://github.com/jquast/wcwidth/issues/103">considered distributing</a> a C module with Python wcwidth for
greater performance, but the existing Python implementation keeps up well enough
with the fastest terminals. When fully exhausted the text scroll speed is fast
enough to produce screen tearing artifacts.</p>
</div>
<div id="tilting-at-edges">
<h2>Tilting at Edges</h2>
<p><a href="https://www.enlightenment.org/about-terminology">Terminology</a> produces inconsistent results between executions. Our tests are
designed to be deterministic, so these kinds of results suggest possible state
corruption. Despite this issue, Terminology offers interesting visual effects
that would be a welcome feature in other terminals.</p>
<p><a href="https://iterm2.com/">iTerm2</a> reports &#34;supported, but disabled, and cannot be changed&#34; status for
all <a href="https://blessed.readthedocs.io/en/latest/dec_modes.html">DEC Private Modes</a> queried, including fictional modes like <tt>9876543</tt>.
For this reason, the summary of DEC Private Modes shows only those modes that
are changeable.</p>
<p><a href="https://apps.kde.org/konsole/">Konsole</a> does not reply to queries about <a href="https://blessed.readthedocs.io/en/latest/dec_modes.html">DEC Private modes</a>, but does support
several modes when they are enabled. For this reason, ucs-detect cannot
automatically infer which DEC Modes Konsole supports.</p>
<p>Similarly, ucs-detect reports &#34;No DEC Private Mode Support&#34; for <a href="https://contour-terminal.org/">Contour</a>. I
investigated this discrepancy because Contour&#39;s author also authored a <a href="https://github.com/contour-terminal/terminal-unicode-core/blob/master/spec/terminal-unicode-core.tex">Mode
2027</a> specification dependent on this functionality.  The issue was that
Contour responded with a different mode number than the one queried. While
developing <a href="https://github.com/contour-terminal/contour/pull/1797">a fix</a>, Contour&#39;s latest release from December 2024 presented an
additional complication: <a href="https://github.com/contour-terminal/contour/issues/1710">a bad escape key configuration</a>. Each instance of
being stuck in vi required typing <tt>CTRL + [</tt> as a workaround!</p>
<p>Terminals based on <a href="https://gitlab.gnome.org/GNOME/vte">libvte</a> with software version label <tt>VTE/7600</tt> continue to
show identical performance with low scores in our tests, unchanged from 2023.</p>
<p>My <a href="https://gitlab.gnome.org/GNOME/vte/-/issues/2580#note_1973274">attempt to discuss</a> improving Unicode support in libvte received substantial
criticism. However, recent libvte project issue <a href="https://gitlab.gnome.org/GNOME/vte/-/issues/2909">Support Emoji Sequences</a> is a
positive indicator for improved language and Emoji support in 2026.</p>
</div>
<div id="on-mode-2027">
<h2>On Mode 2027</h2>
<p>I included DEC Private <a href="https://github.com/contour-terminal/terminal-unicode-core/blob/master/spec/terminal-unicode-core.tex">Mode 2027</a> in the results to accompany Mitchell&#39;s table
from his article, <a href="https://mitchellh.com/writing/grapheme-clusters-in-terminals">Grapheme Clusters and Terminal Emulators</a>, and to verify for
myself that it has limited utility.</p>
<p>In theory, a CLI program can query this mode to classify a terminal as
&#34;reasonably supporting&#34; unicode, but not which specific features or version
level. Since other terminals with similar capabilities do not respond to Mode
2027 queries, this binary indicator has limited utility.</p>
<p>The only practical approach to determining Unicode support of a terminal is to
interactively test for specific features, codepoints, and at the Unicode version
levels of interest, as ucs-detect does.</p>
</div>
<div id="beyond-fixed-widths">
<h2>Beyond Fixed Widths</h2>
<p>Terminals cannot reproduce many of the world&#39;s languages legibly when constrained
to monospace cells. The measurements dictated by rapidly expanding Unicode standards
and varying implementation levels create inherent tension.</p>
<p>The <a href="https://sw.kovidgoyal.net/kitty/text-sizing-protocol/">text sizing protocol</a> published early this year represents a significant
development. Kovid Goyal describes the motivation <a href="https://www.youtube.com/watch?v=8PYLPC3dzWQ">in a recent interview</a>:</p>
<blockquote>
And then my next windmill that I&#39;m looking at is variable-sized text in the
terminal. So when I&#39;m catting a markdown file, I want to see the headings big.</blockquote>
<p>While this feature may enable more advanced typesetting-like capabilities in
terminal apps, it also promises to increase accessibility. Allowing text
to escape monospace constraints enables legible support of the diverse set of
the world&#39;s languages.</p>
<p>For example, using Contour with <tt><span>ucs-detect</span> <span>--stop-at-error=lang</span></tt>, stopping to
take a look at a result of the language <a href="https://en.wikipedia.org/wiki/Kh%C3%BCn_language">Khün</a>:</p>
<p><img alt="/images/contour-khun-example.png" src="https://www.jeffquast.com/images/contour-khun-example.png"/></p><p>In this case <a href="https://contour-terminal.org/">Contour</a> and Python wcwidth disagree on measurement, but more
important is the legibility. We can compare this given Khün text to the
<a href="https://kate-editor.org/">Kate</a> editor:</p>
<p><img alt="/images/kate-khun-example.png" src="https://www.jeffquast.com/images/kate-khun-example.png"/></p><p>They are clearly different. I regret I cannot study it more carefully, but I
suggest that terminals could more easily display complex scripts by switching
to a variable size text mode, allowing the font engine to drive the text without
careful processing of cell and cursor movement.</p>
<p>Although I have yet to experiment with it, I am encouraged to see some
resolution to this problem by the progressive changes suggested by the <a href="https://sw.kovidgoyal.net/kitty/text-sizing-protocol/">text
sizing protocol</a>.</p>
</div>
</div>
                </div></div>
  </body>
</html>
