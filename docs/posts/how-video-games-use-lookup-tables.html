<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/">Original</a>
    <h1>How video games use lookup tables</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://en.wikipedia.org/wiki/Lookup_table">Look-up-tables</a>, more commonly referred to as LUTs, are as old as Mathematics itself. The act of precalculating things into a row or table is nothing new. But in the realm of graphics programming, this simple act unlocks some incredibly creative techniques, which both artists and programmers found when faced with tough technical hurdles.</p><p>We’ll embark on a small journey, which will take us from simple things like turning grayscale footage into color, to creating limitless variations of blood-lusting zombies, with many interactive WebGL examples along the way, that you can try out with your own videos or webcam. Though this article uses <a href="https://en.wikipedia.org/wiki/WebGL">WebGL</a>, the techniques shown apply to any other graphics programming context, be it <a href="https://en.wikipedia.org/wiki/DirectX">DirectX</a>, <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a>, <a href="https://en.wikipedia.org/wiki/Vulkan">Vulkan</a>, game engines like <a href="https://en.wikipedia.org/wiki/Unity_(game_engine)">Unity</a>, or plain scientific data visualization.</p><figure><video controls="" height="480" width="1400" autoplay="" loop="" muted="" playsinline=""><source src="preview.mp4" type="video/mp4"/></video><figcaption>Cold ice cream and hot tea. Left: Panasonic GH6, Right: TESTO 890 + 15°x11° Lens</figcaption></figure><p>We’ll be creating and modifying the video above, though you may substitute the footage with your own at any point in the article. The video is a capture of two cameras, a <a href="https://www.dpreview.com/reviews/panasonic-lumix-dc-gh6-review">Panasonic GH6</a> and a <a href="https://www.testo.com/en/testo-890/p/0563-0890-X1">TESTO 890</a> thermal camera. I’m eating cold ice cream and drinking hot tea to stretch the temperatures on display.</p><h2 id="the-setup" tabindex="-1">The Setup <a href="#the-setup">#</a></h2><p>We’ll first start with the thermal camera footage. The output of the <a href="https://en.wikipedia.org/wiki/Thermographic_camera">thermal camera</a> is a grayscale video. Instead of this video, you may upload your own or activate the webcam, which even allows you to live stream from a thermal camera using <a href="https://obsproject.com/">OBS</a>’s virtual webcam output and various input methods.</p><blockquote><p>No data leaves your device, all processing happens on your GPU. Feel free to use videos exposing your most intimate secrets.</p><img src="https://blog.frost.kiwi/assets/kiwis/happy.svg"/></blockquote><blockquote><p>Don&#39;t pause the video, it&#39;s the live input for the WebGL examples below</p><img src="https://blog.frost.kiwi/assets/kiwis/speak.svg"/></blockquote><p>Next we upload this footage to the graphics card using WebGL and redisplay it using a <a href="https://learnopengl.com/Getting-started/Hello-Triangle">shader</a>, which leaves the footage untouched. Each frame is transferred as a 2D <a href="https://learnopengl.com/Getting-started/Textures">texture</a> to the GPU. Though we haven’t actually done anything visually yet, we have established a graphics pipeline, which allows us to manipulate the video data in realtime. From here on out, we are mainly interested in the “<a href="https://learnopengl.com/Getting-started/Hello-Triangle">Fragment Shader</a>”. This is the piece of code that runs per pixel of the video to determine its final color.</p><blockquote><p>I&#39;m hardcore simplifying here. Technically there are many shader stages, the fragment shader runs per <a href="https://www.khronos.org/opengl/wiki/Fragment">fragment</a> of the output resolution not per pixel of the input, etc.</p><img src="https://blog.frost.kiwi/assets/kiwis/think.svg"/></blockquote><blockquote><details><summary><a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_passthrough.jpg">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_passthrough.jpg" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec2</span> UVs<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    tex <span>=</span> UVs<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/video-simple.fs">video-simple.fs</a></summary><pre><code>

<span>precision</span> <span>mediump</span> <span>float</span><span>;</span>

<span>varying</span> <span>vec2</span> tex<span>;</span>

<span>uniform</span> <span>sampler2D</span> video<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	
	<span>vec3</span> videoColor <span>=</span> <span>texture2D</span><span>(</span>video<span>,</span> tex<span>)</span><span>.</span>rgb<span>;</span>
	
	gl_FragColor <span>=</span> <span>vec4</span><span>(</span>videoColor<span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>


<span>function</span> <span>createAndCompileShader</span><span>(</span><span>gl<span>,</span> type<span>,</span> source<span>,</span> canvas</span><span>)</span> <span>{</span>
	<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
	<span>const</span> element <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>;</span>
	<span>let</span> shaderSource<span>;</span>

	<span>if</span> <span>(</span>element<span>.</span>tagName <span>===</span> <span>&#39;SCRIPT&#39;</span><span>)</span>
		shaderSource <span>=</span> element<span>.</span>text<span>;</span>
	<span>else</span>
		shaderSource <span>=</span> ace<span>.</span><span>edit</span><span>(</span>source<span>)</span><span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>

	gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> shaderSource<span>)</span><span>;</span>
	gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
	<span>else</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> <span>&#34;&#34;</span><span>)</span><span>;</span>
	<span>return</span> shader<span>;</span>
<span>}</span>

<span>function</span> <span>displayErrorMessage</span><span>(</span><span>canvas<span>,</span> message</span><span>)</span> <span>{</span>
	<span>let</span> errorElement <span>=</span> canvas<span>.</span>nextSibling<span>;</span>
	<span>const</span> hasErrorElement <span>=</span> errorElement <span>&amp;&amp;</span> errorElement<span>.</span>tagName <span>===</span> <span>&#39;PRE&#39;</span><span>;</span>

	<span>if</span> <span>(</span>message<span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>hasErrorElement<span>)</span> <span>{</span>
			errorElement <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>&#39;pre&#39;</span><span>)</span><span>;</span>
			errorElement<span>.</span>style<span>.</span>color <span>=</span> <span>&#39;red&#39;</span><span>;</span>
			canvas<span>.</span>parentNode<span>.</span><span>insertBefore</span><span>(</span>errorElement<span>,</span> canvas<span>.</span>nextSibling<span>)</span><span>;</span>
		<span>}</span>
		errorElement<span>.</span>textContent <span>=</span> <span><span>`</span><span>Shader Compilation Error: </span><span><span>${</span>message<span>}</span></span><span>`</span></span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>if</span> <span>(</span>hasErrorElement<span>)</span>
			errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>function</span> <span>setupTexture</span><span>(</span><span>gl<span>,</span> target<span>,</span> source</span><span>)</span> <span>{</span>
	gl<span>.</span><span>deleteTexture</span><span>(</span>target<span>)</span><span>;</span>
	target <span>=</span> gl<span>.</span><span>createTexture</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> target<span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_S</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_T</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	
	gl<span>.</span><span>texImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> source<span>)</span><span>;</span>
	<span>return</span> target<span>;</span>
<span>}</span>

<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId<span>,</span> videoId<span>,</span> lut<span>,</span> lutselect<span>,</span> buttonId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>
	<span>const</span> lutImg <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lut<span>)</span><span>;</span>
	<span>let</span> lutTexture<span>,</span> videoTexture<span>,</span> shaderProgram<span>;</span>

	
	<span>function</span> <span>initializeShaders</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>,</span> canvas<span>)</span><span>;</span>
		<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>,</span> canvas<span>)</span><span>;</span>

		shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

		
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>fragmentShader<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	<span>}</span>

	<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> lutTextureLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;lut&#34;</span><span>)</span><span>;</span>

	<span>if</span> <span>(</span>buttonId<span>)</span> <span>{</span>
		<span>const</span> button <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>buttonId<span>)</span><span>;</span>
		button<span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span>shaderProgram<span>)</span>
				gl<span>.</span><span>deleteProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
			<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>

	<span>let</span> videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> lutTextureInitialized <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>updateTextures</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>video<span>)</span> <span>{</span>
			
			video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>video <span>&amp;&amp;</span> video<span>.</span>paused <span>&amp;&amp;</span> video<span>.</span>readyState <span>&gt;=</span> <span>4</span><span>)</span> <span>{</span>
			
			video<span>.</span>loop <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>muted <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>playsinline <span>=</span> <span>true</span><span>;</span>
			video<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>lut <span>&amp;&amp;</span> lutImg<span>.</span>naturalWidth <span>&amp;&amp;</span> <span>!</span>lutTextureInitialized<span>)</span> <span>{</span>
			lutTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> lutTexture<span>,</span> lutImg<span>)</span><span>;</span>
			lutTextureInitialized <span>=</span> <span>true</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>video<span>.</span>readyState <span>&gt;=</span> video<span>.</span><span>HAVE_CURRENT_DATA</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span><span>!</span>videoTextureInitialized <span>||</span> video<span>.</span>videoWidth <span>!==</span> canvas<span>.</span>width <span>||</span> video<span>.</span>videoHeight <span>!==</span> canvas<span>.</span>height<span>)</span> <span>{</span>
				videoTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> videoTexture<span>,</span> video<span>)</span><span>;</span>
				canvas<span>.</span>width <span>=</span> video<span>.</span>videoWidth<span>;</span>
				canvas<span>.</span>height <span>=</span> video<span>.</span>videoHeight<span>;</span>
				videoTextureInitialized <span>=</span> <span>true</span><span>;</span>
			<span>}</span>
			
			gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> videoTexture<span>)</span><span>;</span>
			gl<span>.</span><span>texSubImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> video<span>)</span><span>;</span>

			<span>if</span> <span>(</span>lut<span>)</span> <span>{</span>
				gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span>
				gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> lutTexture<span>)</span><span>;</span>
				gl<span>.</span><span>uniform1i</span><span>(</span>lutTextureLocation<span>,</span> <span>1</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>if</span> <span>(</span>lutselect<span>)</span> <span>{</span>
		<span>const</span> lutSelectElement <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lutselect<span>)</span><span>;</span>
		<span>if</span> <span>(</span>lutSelectElement<span>)</span> <span>{</span>
			lutSelectElement<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
				
				<span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;SELECT&#39;</span><span>)</span> <span>{</span>
					<span>const</span> newPath <span>=</span> lutSelectElement<span>.</span>value<span>;</span>
					lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
						lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
					<span>}</span><span>;</span>
					lutImg<span>.</span>src <span>=</span> newPath<span>;</span>
				<span>}</span>
				
				<span>else</span> <span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;INPUT&#39;</span> <span>&amp;&amp;</span> lutSelectElement<span>.</span>type <span>===</span> <span>&#39;file&#39;</span><span>)</span> <span>{</span>
					<span>const</span> file <span>=</span> lutSelectElement<span>.</span>files<span>[</span><span>0</span><span>]</span><span>;</span>
					<span>if</span> <span>(</span>file<span>)</span> <span>{</span>
						<span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
						reader<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
							lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
								lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
							<span>}</span><span>;</span>
							lutImg<span>.</span>src <span>=</span> e<span>.</span>target<span>.</span>result<span>;</span>
						<span>}</span><span>;</span>
						reader<span>.</span><span>readAsDataURL</span><span>(</span>file<span>)</span><span>;</span>
					<span>}</span>
				<span>}</span>
			<span>}</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>


	
	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span> <span>0.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>2.0</span><span>,</span> <span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>const</span> texCoord <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;UVs&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>texCoord<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>texCoord<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		<span>updateTextures</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>{</span>
					isRendering <span>=</span> <span>true</span><span>;</span>
					<span>renderLoop</span><span>(</span><span>)</span><span>;</span>
				<span>}</span>
			<span>}</span> <span>else</span> <span>{</span>
				isRendering <span>=</span> <span>false</span><span>;</span>
				videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
				gl<span>.</span><span>deleteTexture</span><span>(</span>videoTexture<span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><p>Both the video and its WebGL rendition should be identical and playing in sync.</p><blockquote><img src="https://blog.frost.kiwi/assets/kiwis/miffed.svg"/></blockquote><h2 id="tinting" tabindex="-1">Tinting <a href="#tinting">#</a></h2><p>Before we jump into how LUTs can help us, let’s take a look a how we can manipulate this footage. The Fragment Shader below colors the image orange by multiplying the image with the color orange in line <code>21</code>. Coloring a texture that way is referred to as “tinting”.</p><p><code>vec3 finalColor = videoColor * vec3(1.0, 0.5, 0.0);</code> is the line that performs this transformation. <code>vec3(1.0, 0.5, 0.0)</code> is the color orange in RGB. Try changing this line and clicking “<strong>Reload Shader</strong>” to get a feel for how this works. Also try out different operations, like addition <code>+</code>, division <code>/</code> etc.</p><pre id="tintingShader">/* In WebGL 1.0, having no #version implies #version 100 */
/* In WebGL we have to set the float precision. On some devices it doesn&#39;t
   change anything. For color manipulation, having mediump is ample. For
   precision trigonometry, bumping to highp is often needed. */
precision mediump float;
/* Our texture coordinates */
varying vec2 tex;
/* Our video texture */
uniform sampler2D video;

void main(void)
{
	/* The texture read, also called &#34;Texture Tap&#34; with the coordinate for
	   the current pixel. */
	vec3 videoColor = texture2D(video, tex).rgb;

	/* Here is where the tinting happens. We multiply with (1.0, 0.5, 0.0),
	   which is orange (100% Red, 50% Green, 0% Blue). White becomes Orange,
	   since muplitplying 1 with X gives you X. Black stays black, since 0
	   times X is 0. Try out different things! */
	vec3 finalColor = videoColor * vec3(1.0, 0.5, 0.0);

	/* Our final color. In WebGL 1.0 this output is always RGBA and always
	   named &#34;gl_FragColor&#34; */
	gl_FragColor = vec4(finalColor, 1.0);
}</pre><blockquote><details><summary><a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_orange.jpg">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_orange.jpg" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec2</span> UVs<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    tex <span>=</span> UVs<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>


<span>function</span> <span>createAndCompileShader</span><span>(</span><span>gl<span>,</span> type<span>,</span> source<span>,</span> canvas</span><span>)</span> <span>{</span>
	<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
	<span>const</span> element <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>;</span>
	<span>let</span> shaderSource<span>;</span>

	<span>if</span> <span>(</span>element<span>.</span>tagName <span>===</span> <span>&#39;SCRIPT&#39;</span><span>)</span>
		shaderSource <span>=</span> element<span>.</span>text<span>;</span>
	<span>else</span>
		shaderSource <span>=</span> ace<span>.</span><span>edit</span><span>(</span>source<span>)</span><span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>

	gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> shaderSource<span>)</span><span>;</span>
	gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
	<span>else</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> <span>&#34;&#34;</span><span>)</span><span>;</span>
	<span>return</span> shader<span>;</span>
<span>}</span>

<span>function</span> <span>displayErrorMessage</span><span>(</span><span>canvas<span>,</span> message</span><span>)</span> <span>{</span>
	<span>let</span> errorElement <span>=</span> canvas<span>.</span>nextSibling<span>;</span>
	<span>const</span> hasErrorElement <span>=</span> errorElement <span>&amp;&amp;</span> errorElement<span>.</span>tagName <span>===</span> <span>&#39;PRE&#39;</span><span>;</span>

	<span>if</span> <span>(</span>message<span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>hasErrorElement<span>)</span> <span>{</span>
			errorElement <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>&#39;pre&#39;</span><span>)</span><span>;</span>
			errorElement<span>.</span>style<span>.</span>color <span>=</span> <span>&#39;red&#39;</span><span>;</span>
			canvas<span>.</span>parentNode<span>.</span><span>insertBefore</span><span>(</span>errorElement<span>,</span> canvas<span>.</span>nextSibling<span>)</span><span>;</span>
		<span>}</span>
		errorElement<span>.</span>textContent <span>=</span> <span><span>`</span><span>Shader Compilation Error: </span><span><span>${</span>message<span>}</span></span><span>`</span></span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>if</span> <span>(</span>hasErrorElement<span>)</span>
			errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>function</span> <span>setupTexture</span><span>(</span><span>gl<span>,</span> target<span>,</span> source</span><span>)</span> <span>{</span>
	gl<span>.</span><span>deleteTexture</span><span>(</span>target<span>)</span><span>;</span>
	target <span>=</span> gl<span>.</span><span>createTexture</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> target<span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_S</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_T</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	
	gl<span>.</span><span>texImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> source<span>)</span><span>;</span>
	<span>return</span> target<span>;</span>
<span>}</span>

<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId<span>,</span> videoId<span>,</span> lut<span>,</span> lutselect<span>,</span> buttonId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>
	<span>const</span> lutImg <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lut<span>)</span><span>;</span>
	<span>let</span> lutTexture<span>,</span> videoTexture<span>,</span> shaderProgram<span>;</span>

	
	<span>function</span> <span>initializeShaders</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>,</span> canvas<span>)</span><span>;</span>
		<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>,</span> canvas<span>)</span><span>;</span>

		shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

		
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>fragmentShader<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	<span>}</span>

	<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> lutTextureLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;lut&#34;</span><span>)</span><span>;</span>

	<span>if</span> <span>(</span>buttonId<span>)</span> <span>{</span>
		<span>const</span> button <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>buttonId<span>)</span><span>;</span>
		button<span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span>shaderProgram<span>)</span>
				gl<span>.</span><span>deleteProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
			<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>

	<span>let</span> videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> lutTextureInitialized <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>updateTextures</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>video<span>)</span> <span>{</span>
			
			video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>video <span>&amp;&amp;</span> video<span>.</span>paused <span>&amp;&amp;</span> video<span>.</span>readyState <span>&gt;=</span> <span>4</span><span>)</span> <span>{</span>
			
			video<span>.</span>loop <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>muted <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>playsinline <span>=</span> <span>true</span><span>;</span>
			video<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>lut <span>&amp;&amp;</span> lutImg<span>.</span>naturalWidth <span>&amp;&amp;</span> <span>!</span>lutTextureInitialized<span>)</span> <span>{</span>
			lutTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> lutTexture<span>,</span> lutImg<span>)</span><span>;</span>
			lutTextureInitialized <span>=</span> <span>true</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>video<span>.</span>readyState <span>&gt;=</span> video<span>.</span><span>HAVE_CURRENT_DATA</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span><span>!</span>videoTextureInitialized <span>||</span> video<span>.</span>videoWidth <span>!==</span> canvas<span>.</span>width <span>||</span> video<span>.</span>videoHeight <span>!==</span> canvas<span>.</span>height<span>)</span> <span>{</span>
				videoTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> videoTexture<span>,</span> video<span>)</span><span>;</span>
				canvas<span>.</span>width <span>=</span> video<span>.</span>videoWidth<span>;</span>
				canvas<span>.</span>height <span>=</span> video<span>.</span>videoHeight<span>;</span>
				videoTextureInitialized <span>=</span> <span>true</span><span>;</span>
			<span>}</span>
			
			gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> videoTexture<span>)</span><span>;</span>
			gl<span>.</span><span>texSubImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> video<span>)</span><span>;</span>

			<span>if</span> <span>(</span>lut<span>)</span> <span>{</span>
				gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span>
				gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> lutTexture<span>)</span><span>;</span>
				gl<span>.</span><span>uniform1i</span><span>(</span>lutTextureLocation<span>,</span> <span>1</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>if</span> <span>(</span>lutselect<span>)</span> <span>{</span>
		<span>const</span> lutSelectElement <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lutselect<span>)</span><span>;</span>
		<span>if</span> <span>(</span>lutSelectElement<span>)</span> <span>{</span>
			lutSelectElement<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
				
				<span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;SELECT&#39;</span><span>)</span> <span>{</span>
					<span>const</span> newPath <span>=</span> lutSelectElement<span>.</span>value<span>;</span>
					lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
						lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
					<span>}</span><span>;</span>
					lutImg<span>.</span>src <span>=</span> newPath<span>;</span>
				<span>}</span>
				
				<span>else</span> <span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;INPUT&#39;</span> <span>&amp;&amp;</span> lutSelectElement<span>.</span>type <span>===</span> <span>&#39;file&#39;</span><span>)</span> <span>{</span>
					<span>const</span> file <span>=</span> lutSelectElement<span>.</span>files<span>[</span><span>0</span><span>]</span><span>;</span>
					<span>if</span> <span>(</span>file<span>)</span> <span>{</span>
						<span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
						reader<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
							lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
								lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
							<span>}</span><span>;</span>
							lutImg<span>.</span>src <span>=</span> e<span>.</span>target<span>.</span>result<span>;</span>
						<span>}</span><span>;</span>
						reader<span>.</span><span>readAsDataURL</span><span>(</span>file<span>)</span><span>;</span>
					<span>}</span>
				<span>}</span>
			<span>}</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>


	
	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span> <span>0.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>2.0</span><span>,</span> <span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>const</span> texCoord <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;UVs&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>texCoord<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>texCoord<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		<span>updateTextures</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>{</span>
					isRendering <span>=</span> <span>true</span><span>;</span>
					<span>renderLoop</span><span>(</span><span>)</span><span>;</span>
				<span>}</span>
			<span>}</span> <span>else</span> <span>{</span>
				isRendering <span>=</span> <span>false</span><span>;</span>
				videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
				gl<span>.</span><span>deleteTexture</span><span>(</span>videoTexture<span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><h3 id="performance-cost%3A-zero" tabindex="-1">Performance cost: Zero <a href="#performance-cost%3A-zero">#</a></h3><p><strong><em>Depending on the context</em></strong>, the multiplication introduced by the tinting has zero performance impact. On a theoretical level, the multiplication has a cost associated with it, since the chip has to perform this multiplication at some point. But you will probably not be able to measure it <em>in this context</em>, as the multiplication is affected by “<a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-143.pdf">latency hiding</a>”. The act, cost and latency of pushing the video though the graphics pipeline unlocks a lot of manipulations we get for free this way. We can rationalize this from multiple levels, but the main point goes like:</p><ul><li>Fetching the texture from memory takes way more time than a multiplication<ul><li>Even though the result depends on the texture tap, with multiple threads the multiplication is performed while waiting on the texture tap of another pixel</li></ul></li></ul><blockquote><p>This is about the difference tinting makes, not overall performance. Lot&#39;s left on the optimization table, like asynchronously loading the frames to a single-channel texture or processing on every frame, not display refresh</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"/></blockquote><p>In similar vein, it was also talked about in the <a href="https://rosenzweig.io/blog/conformant-gl46-on-the-m1.html">recent blog post</a> by <a href="https://rosenzweig.io">Alyssa Rosenzweig</a>, about her GPU reverse engineering project achieving proper standard conformant OpenGL Drivers on the Apple M1. Regarding performance implications of a specific additional operation she noted:</p><blockquote><p><strong>Alyssa Rosenzweig</strong>: The difference should be small percentage-wise, as arithmetic is faster than memory. With thousands of threads running in parallel, the arithmetic cost may even be hidden by the load’s latency.</p></blockquote><h3 id="valve-software%E2%80%99s-use-of-tinting" tabindex="-1">Valve Software’s use of tinting <a href="#valve-software%E2%80%99s-use-of-tinting">#</a></h3><p>Let’s take a look how this is used in the wild. As an example, we have <a href="https://www.valvesoftware.com/">Valve Software</a>’s <a href="https://en.wikipedia.org/wiki/Left_4_Dead">Left 4 Dead</a>. The in-game developer commentary feature unlocks much shared wisdom form artists and programmers alike. Here is the audio log of developer <a href="https://www.linkedin.com/in/tristan-reidford-b8474a2/">Tristan Reidford</a> explaining how they utilized tinting to create car variations. In particular they use one extra texture channel to determine extra tinting regions, allowing one to use 2 colors to tint certain regions of the 3D model in a different color.</p><blockquote><p><strong>Tristan Reidford:</strong> Usually each model in the game has its own unique texture maps painted specifically for that model, which give the object its surface colors and detail. To have a convincing variety of cars using this method would have required as many textures as varieties of car, plus multiple duplicates of the textures in different colors, which would have been far out of our allotted texture memory budget. So we had to find a more efficient way to bring about that same result. For example, the texture on this car is shared with 3 different car models distributed throughout the environment. In addition to this one color texture, there is also a ‘mask’ texture that allows each instance of the car’s painted surfaces to be tinted a different color, without having to author a separate texture. So for the cost of two textures you can get four different car models in an unlimited variety of colors.</p></blockquote><figure><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/Left4Dead.jpg" alt="Screenshot: Left 4 Dead and its use of tinting the same car to get achieve new looks."/><figcaption>Screenshot: Left 4 Dead and its use of tinting the same car to get achieve new looks.</figcaption></figure><p>Note, that it’s not just cars. Essentially everything in the <a href="https://en.wikipedia.org/wiki/Source_(game_engine)">Source Engine</a> can be tinted.</p><h2 id="the-lut---simple%2C-yet-powerful" tabindex="-1">The LUT - Simple, yet powerful <a href="#the-lut---simple%2C-yet-powerful">#</a></h2><p>Now that we have gotten an idea of how we can interact and manipulate color in a graphics programming context, let’s dive into how a LUT can elevate that. The core of the idea is this: Instead of defining how the colors are changed across their entire range, let’s define what color range changes in what way. If you have replaced the above thermal image with an RGB video of your own, then just the red channel will be used going forward.</p><p>The following examples make more sense in context of thermal camera footage, so you can click the following button to revert to it, if you wish.</p><h3 id="the-humble-1d-lut" tabindex="-1">The humble 1D LUT <a href="#the-humble-1d-lut">#</a></h3><p>A 1D LUT is a simple array of numbers. If the 1D LUT is an RGB image, then a 1D LUT is a 1D array of colors. According that array, we will color our gray video. In the context of graphics programming, this gets uploaded as a 1D-texture to the graphics card, where it is used to transform the single channel pixels into RGB.</p><img src="https://blog.frost.kiwi/assets/LUTs/PerceptuallyUniform/inferno.png" id="lut"/><blockquote><details><summary><a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_inferno.jpg">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_inferno.jpg" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec2</span> UVs<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    tex <span>=</span> UVs<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/video-lut.fs">video-lut.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>
<span>uniform</span> <span>sampler2D</span> video<span>;</span>
<span>uniform</span> <span>sampler2D</span> lut<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	
    <span>float</span> videoColor <span>=</span> <span>texture2D</span><span>(</span>video<span>,</span> tex<span>)</span><span>.</span>r<span>;</span>
    <span>vec4</span> finalColor <span>=</span> <span>texture2D</span><span>(</span>lut<span>,</span> <span>vec2</span><span>(</span>videoColor<span>,</span> <span>0.5</span><span>)</span><span>)</span><span>;</span>
    gl_FragColor <span>=</span> finalColor<span>;</span>
<span>}</span>
</code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>


<span>function</span> <span>createAndCompileShader</span><span>(</span><span>gl<span>,</span> type<span>,</span> source<span>,</span> canvas</span><span>)</span> <span>{</span>
	<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
	<span>const</span> element <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>;</span>
	<span>let</span> shaderSource<span>;</span>

	<span>if</span> <span>(</span>element<span>.</span>tagName <span>===</span> <span>&#39;SCRIPT&#39;</span><span>)</span>
		shaderSource <span>=</span> element<span>.</span>text<span>;</span>
	<span>else</span>
		shaderSource <span>=</span> ace<span>.</span><span>edit</span><span>(</span>source<span>)</span><span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>

	gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> shaderSource<span>)</span><span>;</span>
	gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
	<span>else</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> <span>&#34;&#34;</span><span>)</span><span>;</span>
	<span>return</span> shader<span>;</span>
<span>}</span>

<span>function</span> <span>displayErrorMessage</span><span>(</span><span>canvas<span>,</span> message</span><span>)</span> <span>{</span>
	<span>let</span> errorElement <span>=</span> canvas<span>.</span>nextSibling<span>;</span>
	<span>const</span> hasErrorElement <span>=</span> errorElement <span>&amp;&amp;</span> errorElement<span>.</span>tagName <span>===</span> <span>&#39;PRE&#39;</span><span>;</span>

	<span>if</span> <span>(</span>message<span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>hasErrorElement<span>)</span> <span>{</span>
			errorElement <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>&#39;pre&#39;</span><span>)</span><span>;</span>
			errorElement<span>.</span>style<span>.</span>color <span>=</span> <span>&#39;red&#39;</span><span>;</span>
			canvas<span>.</span>parentNode<span>.</span><span>insertBefore</span><span>(</span>errorElement<span>,</span> canvas<span>.</span>nextSibling<span>)</span><span>;</span>
		<span>}</span>
		errorElement<span>.</span>textContent <span>=</span> <span><span>`</span><span>Shader Compilation Error: </span><span><span>${</span>message<span>}</span></span><span>`</span></span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>if</span> <span>(</span>hasErrorElement<span>)</span>
			errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>function</span> <span>setupTexture</span><span>(</span><span>gl<span>,</span> target<span>,</span> source</span><span>)</span> <span>{</span>
	gl<span>.</span><span>deleteTexture</span><span>(</span>target<span>)</span><span>;</span>
	target <span>=</span> gl<span>.</span><span>createTexture</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> target<span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_S</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_T</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	
	gl<span>.</span><span>texImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> source<span>)</span><span>;</span>
	<span>return</span> target<span>;</span>
<span>}</span>

<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId<span>,</span> videoId<span>,</span> lut<span>,</span> lutselect<span>,</span> buttonId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>
	<span>const</span> lutImg <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lut<span>)</span><span>;</span>
	<span>let</span> lutTexture<span>,</span> videoTexture<span>,</span> shaderProgram<span>;</span>

	
	<span>function</span> <span>initializeShaders</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>,</span> canvas<span>)</span><span>;</span>
		<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>,</span> canvas<span>)</span><span>;</span>

		shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

		
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>fragmentShader<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	<span>}</span>

	<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> lutTextureLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;lut&#34;</span><span>)</span><span>;</span>

	<span>if</span> <span>(</span>buttonId<span>)</span> <span>{</span>
		<span>const</span> button <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>buttonId<span>)</span><span>;</span>
		button<span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span>shaderProgram<span>)</span>
				gl<span>.</span><span>deleteProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
			<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>

	<span>let</span> videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> lutTextureInitialized <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>updateTextures</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>video<span>)</span> <span>{</span>
			
			video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>video <span>&amp;&amp;</span> video<span>.</span>paused <span>&amp;&amp;</span> video<span>.</span>readyState <span>&gt;=</span> <span>4</span><span>)</span> <span>{</span>
			
			video<span>.</span>loop <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>muted <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>playsinline <span>=</span> <span>true</span><span>;</span>
			video<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>lut <span>&amp;&amp;</span> lutImg<span>.</span>naturalWidth <span>&amp;&amp;</span> <span>!</span>lutTextureInitialized<span>)</span> <span>{</span>
			lutTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> lutTexture<span>,</span> lutImg<span>)</span><span>;</span>
			lutTextureInitialized <span>=</span> <span>true</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>video<span>.</span>readyState <span>&gt;=</span> video<span>.</span><span>HAVE_CURRENT_DATA</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span><span>!</span>videoTextureInitialized <span>||</span> video<span>.</span>videoWidth <span>!==</span> canvas<span>.</span>width <span>||</span> video<span>.</span>videoHeight <span>!==</span> canvas<span>.</span>height<span>)</span> <span>{</span>
				videoTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> videoTexture<span>,</span> video<span>)</span><span>;</span>
				canvas<span>.</span>width <span>=</span> video<span>.</span>videoWidth<span>;</span>
				canvas<span>.</span>height <span>=</span> video<span>.</span>videoHeight<span>;</span>
				videoTextureInitialized <span>=</span> <span>true</span><span>;</span>
			<span>}</span>
			
			gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> videoTexture<span>)</span><span>;</span>
			gl<span>.</span><span>texSubImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> video<span>)</span><span>;</span>

			<span>if</span> <span>(</span>lut<span>)</span> <span>{</span>
				gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span>
				gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> lutTexture<span>)</span><span>;</span>
				gl<span>.</span><span>uniform1i</span><span>(</span>lutTextureLocation<span>,</span> <span>1</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>if</span> <span>(</span>lutselect<span>)</span> <span>{</span>
		<span>const</span> lutSelectElement <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lutselect<span>)</span><span>;</span>
		<span>if</span> <span>(</span>lutSelectElement<span>)</span> <span>{</span>
			lutSelectElement<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
				
				<span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;SELECT&#39;</span><span>)</span> <span>{</span>
					<span>const</span> newPath <span>=</span> lutSelectElement<span>.</span>value<span>;</span>
					lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
						lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
					<span>}</span><span>;</span>
					lutImg<span>.</span>src <span>=</span> newPath<span>;</span>
				<span>}</span>
				
				<span>else</span> <span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;INPUT&#39;</span> <span>&amp;&amp;</span> lutSelectElement<span>.</span>type <span>===</span> <span>&#39;file&#39;</span><span>)</span> <span>{</span>
					<span>const</span> file <span>=</span> lutSelectElement<span>.</span>files<span>[</span><span>0</span><span>]</span><span>;</span>
					<span>if</span> <span>(</span>file<span>)</span> <span>{</span>
						<span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
						reader<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
							lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
								lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
							<span>}</span><span>;</span>
							lutImg<span>.</span>src <span>=</span> e<span>.</span>target<span>.</span>result<span>;</span>
						<span>}</span><span>;</span>
						reader<span>.</span><span>readAsDataURL</span><span>(</span>file<span>)</span><span>;</span>
					<span>}</span>
				<span>}</span>
			<span>}</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>


	
	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span> <span>0.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>2.0</span><span>,</span> <span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>const</span> texCoord <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;UVs&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>texCoord<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>texCoord<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		<span>updateTextures</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>{</span>
					isRendering <span>=</span> <span>true</span><span>;</span>
					<span>renderLoop</span><span>(</span><span>)</span><span>;</span>
				<span>}</span>
			<span>}</span> <span>else</span> <span>{</span>
				isRendering <span>=</span> <span>false</span><span>;</span>
				videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
				gl<span>.</span><span>deleteTexture</span><span>(</span>videoTexture<span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><p>An here comes the neat part, looking at the fragment shader, we use the brightness of the video, which goes from <code>[0.0 - 1.0]</code> to index into the X-Axis of our 1D LUT, which also has texture coordinates corresponding to<code>[0.0 - 1.0]</code>, resulting in the expression <code>vec4 finalcolor = texture(lut, videoColor);</code>. In WebGL 1.0, we don’t have 1D-Textures, so we use a 2D-Texture of 1px height. <code>vec4 finalColor = texture2D(lut, vec2(videoColor, 0.5));</code> Thus the resulting code actually needs the Y coordinate as well, <a href="https://github.com/tuket/opengl_tex1d_benchmark">neither of which particularly matters</a>.</p><p>The <code>0.0</code> black in the video is mapped to the color on the left and <code>1.0</code> white in the video is mapped to the color on the right, with all colors in between being assigned to their corresponding values. <em><strong>1D vector in, 3D vector out.</strong></em></p><p>What makes this map so well to the GPU, is that on GPUs we get bilinear filtering for free when performing texture reads. So if our 8-bits per channel video has 256 distinct shades of grey, but our 1D-Lut is only 32 pixels wide, then the texture access in between two pixels gets linearly interpolated automatically. In the above selection box you can try setting the 1D Lut to different sizes and compare.</p><blockquote><p>Incredible how close the 256 pixel wide and very colorful gradient is reproduced, with only 8 pixels worth of information!</p><img src="https://blog.frost.kiwi/assets/kiwis/surprised.svg"/></blockquote><h4 id="so-many-colors" tabindex="-1">So many colors <a href="#so-many-colors">#</a></h4><p>Here is every single colormap that <a href="https://matplotlib.org/">matplotlib</a> supports, exported as a 1D LUT. Scroll through all of them and choose your favorite!</p><img src="https://blog.frost.kiwi/assets/LUTs/PerceptuallyUniform/viridis.png" id="viridis"/><blockquote><details><summary><a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_viridis.jpg">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_viridis.jpg" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec2</span> UVs<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    tex <span>=</span> UVs<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/video-lut.fs">video-lut.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>
<span>uniform</span> <span>sampler2D</span> video<span>;</span>
<span>uniform</span> <span>sampler2D</span> lut<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	
    <span>float</span> videoColor <span>=</span> <span>texture2D</span><span>(</span>video<span>,</span> tex<span>)</span><span>.</span>r<span>;</span>
    <span>vec4</span> finalColor <span>=</span> <span>texture2D</span><span>(</span>lut<span>,</span> <span>vec2</span><span>(</span>videoColor<span>,</span> <span>0.5</span><span>)</span><span>)</span><span>;</span>
    gl_FragColor <span>=</span> finalColor<span>;</span>
<span>}</span>
</code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>


<span>function</span> <span>createAndCompileShader</span><span>(</span><span>gl<span>,</span> type<span>,</span> source<span>,</span> canvas</span><span>)</span> <span>{</span>
	<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
	<span>const</span> element <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>;</span>
	<span>let</span> shaderSource<span>;</span>

	<span>if</span> <span>(</span>element<span>.</span>tagName <span>===</span> <span>&#39;SCRIPT&#39;</span><span>)</span>
		shaderSource <span>=</span> element<span>.</span>text<span>;</span>
	<span>else</span>
		shaderSource <span>=</span> ace<span>.</span><span>edit</span><span>(</span>source<span>)</span><span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>

	gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> shaderSource<span>)</span><span>;</span>
	gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
	<span>else</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> <span>&#34;&#34;</span><span>)</span><span>;</span>
	<span>return</span> shader<span>;</span>
<span>}</span>

<span>function</span> <span>displayErrorMessage</span><span>(</span><span>canvas<span>,</span> message</span><span>)</span> <span>{</span>
	<span>let</span> errorElement <span>=</span> canvas<span>.</span>nextSibling<span>;</span>
	<span>const</span> hasErrorElement <span>=</span> errorElement <span>&amp;&amp;</span> errorElement<span>.</span>tagName <span>===</span> <span>&#39;PRE&#39;</span><span>;</span>

	<span>if</span> <span>(</span>message<span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>hasErrorElement<span>)</span> <span>{</span>
			errorElement <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>&#39;pre&#39;</span><span>)</span><span>;</span>
			errorElement<span>.</span>style<span>.</span>color <span>=</span> <span>&#39;red&#39;</span><span>;</span>
			canvas<span>.</span>parentNode<span>.</span><span>insertBefore</span><span>(</span>errorElement<span>,</span> canvas<span>.</span>nextSibling<span>)</span><span>;</span>
		<span>}</span>
		errorElement<span>.</span>textContent <span>=</span> <span><span>`</span><span>Shader Compilation Error: </span><span><span>${</span>message<span>}</span></span><span>`</span></span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>if</span> <span>(</span>hasErrorElement<span>)</span>
			errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>function</span> <span>setupTexture</span><span>(</span><span>gl<span>,</span> target<span>,</span> source</span><span>)</span> <span>{</span>
	gl<span>.</span><span>deleteTexture</span><span>(</span>target<span>)</span><span>;</span>
	target <span>=</span> gl<span>.</span><span>createTexture</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> target<span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_S</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_T</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	
	gl<span>.</span><span>texImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> source<span>)</span><span>;</span>
	<span>return</span> target<span>;</span>
<span>}</span>

<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId<span>,</span> videoId<span>,</span> lut<span>,</span> lutselect<span>,</span> buttonId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>
	<span>const</span> lutImg <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lut<span>)</span><span>;</span>
	<span>let</span> lutTexture<span>,</span> videoTexture<span>,</span> shaderProgram<span>;</span>

	
	<span>function</span> <span>initializeShaders</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>,</span> canvas<span>)</span><span>;</span>
		<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>,</span> canvas<span>)</span><span>;</span>

		shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

		
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>fragmentShader<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	<span>}</span>

	<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> lutTextureLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;lut&#34;</span><span>)</span><span>;</span>

	<span>if</span> <span>(</span>buttonId<span>)</span> <span>{</span>
		<span>const</span> button <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>buttonId<span>)</span><span>;</span>
		button<span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span>shaderProgram<span>)</span>
				gl<span>.</span><span>deleteProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
			<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>

	<span>let</span> videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> lutTextureInitialized <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>updateTextures</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>video<span>)</span> <span>{</span>
			
			video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>video <span>&amp;&amp;</span> video<span>.</span>paused <span>&amp;&amp;</span> video<span>.</span>readyState <span>&gt;=</span> <span>4</span><span>)</span> <span>{</span>
			
			video<span>.</span>loop <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>muted <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>playsinline <span>=</span> <span>true</span><span>;</span>
			video<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>lut <span>&amp;&amp;</span> lutImg<span>.</span>naturalWidth <span>&amp;&amp;</span> <span>!</span>lutTextureInitialized<span>)</span> <span>{</span>
			lutTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> lutTexture<span>,</span> lutImg<span>)</span><span>;</span>
			lutTextureInitialized <span>=</span> <span>true</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>video<span>.</span>readyState <span>&gt;=</span> video<span>.</span><span>HAVE_CURRENT_DATA</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span><span>!</span>videoTextureInitialized <span>||</span> video<span>.</span>videoWidth <span>!==</span> canvas<span>.</span>width <span>||</span> video<span>.</span>videoHeight <span>!==</span> canvas<span>.</span>height<span>)</span> <span>{</span>
				videoTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> videoTexture<span>,</span> video<span>)</span><span>;</span>
				canvas<span>.</span>width <span>=</span> video<span>.</span>videoWidth<span>;</span>
				canvas<span>.</span>height <span>=</span> video<span>.</span>videoHeight<span>;</span>
				videoTextureInitialized <span>=</span> <span>true</span><span>;</span>
			<span>}</span>
			
			gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> videoTexture<span>)</span><span>;</span>
			gl<span>.</span><span>texSubImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> video<span>)</span><span>;</span>

			<span>if</span> <span>(</span>lut<span>)</span> <span>{</span>
				gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span>
				gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> lutTexture<span>)</span><span>;</span>
				gl<span>.</span><span>uniform1i</span><span>(</span>lutTextureLocation<span>,</span> <span>1</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>if</span> <span>(</span>lutselect<span>)</span> <span>{</span>
		<span>const</span> lutSelectElement <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lutselect<span>)</span><span>;</span>
		<span>if</span> <span>(</span>lutSelectElement<span>)</span> <span>{</span>
			lutSelectElement<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
				
				<span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;SELECT&#39;</span><span>)</span> <span>{</span>
					<span>const</span> newPath <span>=</span> lutSelectElement<span>.</span>value<span>;</span>
					lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
						lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
					<span>}</span><span>;</span>
					lutImg<span>.</span>src <span>=</span> newPath<span>;</span>
				<span>}</span>
				
				<span>else</span> <span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;INPUT&#39;</span> <span>&amp;&amp;</span> lutSelectElement<span>.</span>type <span>===</span> <span>&#39;file&#39;</span><span>)</span> <span>{</span>
					<span>const</span> file <span>=</span> lutSelectElement<span>.</span>files<span>[</span><span>0</span><span>]</span><span>;</span>
					<span>if</span> <span>(</span>file<span>)</span> <span>{</span>
						<span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
						reader<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
							lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
								lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
							<span>}</span><span>;</span>
							lutImg<span>.</span>src <span>=</span> e<span>.</span>target<span>.</span>result<span>;</span>
						<span>}</span><span>;</span>
						reader<span>.</span><span>readAsDataURL</span><span>(</span>file<span>)</span><span>;</span>
					<span>}</span>
				<span>}</span>
			<span>}</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>


	
	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span> <span>0.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>2.0</span><span>,</span> <span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>const</span> texCoord <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;UVs&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>texCoord<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>texCoord<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		<span>updateTextures</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>{</span>
					isRendering <span>=</span> <span>true</span><span>;</span>
					<span>renderLoop</span><span>(</span><span>)</span><span>;</span>
				<span>}</span>
			<span>}</span> <span>else</span> <span>{</span>
				isRendering <span>=</span> <span>false</span><span>;</span>
				videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
				gl<span>.</span><span>deleteTexture</span><span>(</span>videoTexture<span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><p>Sike! It’s a trick question. You don’t get to choose. You may think, that you should choose what ever looks best, but in matters of taste, the customer <em>isn’t</em> always right.</p><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/salty.jpg"/><p>Unless your data has specific structure, there is actually one colormap type that you should be using or basing your color settings on - “Perceptually Uniform”, like the <a href="https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html">viridis</a> family of colormaps. We won’t dive into such a deep topic here, but the main points are this:</p><ul><li>If you choose from the Perceptually Uniform ones, then printing your data in black and white will still have the “cold” parts dark and “hot” parts bright<ul><li>This is not a given with colorful options like jet, which modify mainly just the hue whilst ignoring perceived lightness</li></ul></li><li>People with color blindness will still be able to interpret your data correctly</li></ul><p>Reasons for this and why other colormaps are dangerous for judging critical information are presented by <a href="https://github.com/stefanv">Stefan van der Walt</a> and <a href="https://github.com/njsmith">Nathaniel J. Smith</a> in this talk.</p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed/xAoljeRJ3lU?si=vxcupZ7q-JhcCXFm&amp;start=50" title="YouTube video player" width="100%"></iframe><h4 id="still-performance-free%3F" tabindex="-1">Still performance free? <a href="#still-performance-free%3F">#</a></h4><p>We talked about tinting being essentially performance free. When talking about (small 1D) LUTs it gets complicated, though the answer is still probably yes. The main concern comes from us creating something called a “dependant texture read”. We are triggering one texture read based on the result of another. In graphics programming, a performance sin, as we eliminate a whole class of possible optimized paths, that graphics drivers consider.</p><p>GPUs have textures caches, which our LUT will have no problem fitting into and will probably make LUT texture reads very cheap. To measure performance this finely, how caches are hit and the like, we required advanced debugging tools, which are platform specific. There is <a href="https://developer.nvidia.com/blog/identifying-shader-limiters-with-the-shader-profiler-in-nvidia-nsight-graphics/">Nvidia NSight</a>, which allows you to break down the performance of each step in the shader, though OpenGL is unsupported for this. Either way, this is not the topic of this article. There <em>is</em> one more thing though…</p><p>You can perform polynomial approximations of a colormap and thus side-step the LUT texture read. The next WebGL fragment shader features a polynomial approximation of viridis. It was created by <a href="https://mzucker.github.io/">Matt Zucker</a>, available on <a href="https://www.shadertoy.com/view/WlfXRN">ShaderToy</a> including polynomials for other colormaps. Compare both the original colormap exported as a LUT and the approximation exported as a LUT in the following two stripes. Remarkably close.</p><img src="https://blog.frost.kiwi/assets/LUTs/PerceptuallyUniform/viridis.png"/> <img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/viridis_from_function.png"/><canvas height="480" id="canvas_9" width="684"></canvas><blockquote><details><summary><a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_viridis_polynomial.jpg">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_viridis_polynomial.jpg" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec2</span> UVs<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    tex <span>=</span> UVs<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/video-lut_viridis.fs">video-lut_viridis.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>
<span>uniform</span> <span>sampler2D</span> video<span>;</span>

<span>vec3</span> <span>viridis</span><span>(</span><span>float</span> t<span>)</span> <span>{</span>

    <span>const</span> <span>vec3</span> c0 <span>=</span> <span>vec3</span><span>(</span><span>0.2777273272234177</span><span>,</span> <span>0.005407344544966578</span><span>,</span> <span>0.3340998053353061</span><span>)</span><span>;</span>
    <span>const</span> <span>vec3</span> c1 <span>=</span> <span>vec3</span><span>(</span><span>0.1050930431085774</span><span>,</span> <span>1.404613529898575</span><span>,</span> <span>1.384590162594685</span><span>)</span><span>;</span>
    <span>const</span> <span>vec3</span> c2 <span>=</span> <span>vec3</span><span>(</span><span>-</span><span>0.3308618287255563</span><span>,</span> <span>0.214847559468213</span><span>,</span> <span>0.09509516302823659</span><span>)</span><span>;</span>
    <span>const</span> <span>vec3</span> c3 <span>=</span> <span>vec3</span><span>(</span><span>-</span><span>4.634230498983486</span><span>,</span> <span>-</span><span>5.799100973351585</span><span>,</span> <span>-</span><span>19.33244095627987</span><span>)</span><span>;</span>
    <span>const</span> <span>vec3</span> c4 <span>=</span> <span>vec3</span><span>(</span><span>6.228269936347081</span><span>,</span> <span>14.17993336680509</span><span>,</span> <span>56.69055260068105</span><span>)</span><span>;</span>
    <span>const</span> <span>vec3</span> c5 <span>=</span> <span>vec3</span><span>(</span><span>4.776384997670288</span><span>,</span> <span>-</span><span>13.74514537774601</span><span>,</span> <span>-</span><span>65.35303263337234</span><span>)</span><span>;</span>
    <span>const</span> <span>vec3</span> c6 <span>=</span> <span>vec3</span><span>(</span><span>-</span><span>5.435455855934631</span><span>,</span> <span>4.645852612178535</span><span>,</span> <span>26.3124352495832</span><span>)</span><span>;</span>

    <span>return</span> c0<span>+</span>t<span>*</span><span>(</span>c1<span>+</span>t<span>*</span><span>(</span>c2<span>+</span>t<span>*</span><span>(</span>c3<span>+</span>t<span>*</span><span>(</span>c4<span>+</span>t<span>*</span><span>(</span>c5<span>+</span>t<span>*</span>c6<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>

<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>float</span> videoColor <span>=</span> <span>texture2D</span><span>(</span>video<span>,</span> tex<span>)</span><span>.</span>r<span>;</span>
    gl_FragColor <span>=</span> <span>vec4</span><span>(</span><span>viridis</span><span>(</span>videoColor<span>)</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>


<span>function</span> <span>createAndCompileShader</span><span>(</span><span>gl<span>,</span> type<span>,</span> source<span>,</span> canvas</span><span>)</span> <span>{</span>
	<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
	<span>const</span> element <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>;</span>
	<span>let</span> shaderSource<span>;</span>

	<span>if</span> <span>(</span>element<span>.</span>tagName <span>===</span> <span>&#39;SCRIPT&#39;</span><span>)</span>
		shaderSource <span>=</span> element<span>.</span>text<span>;</span>
	<span>else</span>
		shaderSource <span>=</span> ace<span>.</span><span>edit</span><span>(</span>source<span>)</span><span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>

	gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> shaderSource<span>)</span><span>;</span>
	gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
	<span>else</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> <span>&#34;&#34;</span><span>)</span><span>;</span>
	<span>return</span> shader<span>;</span>
<span>}</span>

<span>function</span> <span>displayErrorMessage</span><span>(</span><span>canvas<span>,</span> message</span><span>)</span> <span>{</span>
	<span>let</span> errorElement <span>=</span> canvas<span>.</span>nextSibling<span>;</span>
	<span>const</span> hasErrorElement <span>=</span> errorElement <span>&amp;&amp;</span> errorElement<span>.</span>tagName <span>===</span> <span>&#39;PRE&#39;</span><span>;</span>

	<span>if</span> <span>(</span>message<span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>hasErrorElement<span>)</span> <span>{</span>
			errorElement <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>&#39;pre&#39;</span><span>)</span><span>;</span>
			errorElement<span>.</span>style<span>.</span>color <span>=</span> <span>&#39;red&#39;</span><span>;</span>
			canvas<span>.</span>parentNode<span>.</span><span>insertBefore</span><span>(</span>errorElement<span>,</span> canvas<span>.</span>nextSibling<span>)</span><span>;</span>
		<span>}</span>
		errorElement<span>.</span>textContent <span>=</span> <span><span>`</span><span>Shader Compilation Error: </span><span><span>${</span>message<span>}</span></span><span>`</span></span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>if</span> <span>(</span>hasErrorElement<span>)</span>
			errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>function</span> <span>setupTexture</span><span>(</span><span>gl<span>,</span> target<span>,</span> source</span><span>)</span> <span>{</span>
	gl<span>.</span><span>deleteTexture</span><span>(</span>target<span>)</span><span>;</span>
	target <span>=</span> gl<span>.</span><span>createTexture</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> target<span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_S</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_T</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	
	gl<span>.</span><span>texImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> source<span>)</span><span>;</span>
	<span>return</span> target<span>;</span>
<span>}</span>

<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId<span>,</span> videoId<span>,</span> lut<span>,</span> lutselect<span>,</span> buttonId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>
	<span>const</span> lutImg <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lut<span>)</span><span>;</span>
	<span>let</span> lutTexture<span>,</span> videoTexture<span>,</span> shaderProgram<span>;</span>

	
	<span>function</span> <span>initializeShaders</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>,</span> canvas<span>)</span><span>;</span>
		<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>,</span> canvas<span>)</span><span>;</span>

		shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

		
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>fragmentShader<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	<span>}</span>

	<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> lutTextureLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;lut&#34;</span><span>)</span><span>;</span>

	<span>if</span> <span>(</span>buttonId<span>)</span> <span>{</span>
		<span>const</span> button <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>buttonId<span>)</span><span>;</span>
		button<span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span>shaderProgram<span>)</span>
				gl<span>.</span><span>deleteProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
			<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>

	<span>let</span> videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> lutTextureInitialized <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>updateTextures</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>video<span>)</span> <span>{</span>
			
			video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>video <span>&amp;&amp;</span> video<span>.</span>paused <span>&amp;&amp;</span> video<span>.</span>readyState <span>&gt;=</span> <span>4</span><span>)</span> <span>{</span>
			
			video<span>.</span>loop <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>muted <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>playsinline <span>=</span> <span>true</span><span>;</span>
			video<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>lut <span>&amp;&amp;</span> lutImg<span>.</span>naturalWidth <span>&amp;&amp;</span> <span>!</span>lutTextureInitialized<span>)</span> <span>{</span>
			lutTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> lutTexture<span>,</span> lutImg<span>)</span><span>;</span>
			lutTextureInitialized <span>=</span> <span>true</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>video<span>.</span>readyState <span>&gt;=</span> video<span>.</span><span>HAVE_CURRENT_DATA</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span><span>!</span>videoTextureInitialized <span>||</span> video<span>.</span>videoWidth <span>!==</span> canvas<span>.</span>width <span>||</span> video<span>.</span>videoHeight <span>!==</span> canvas<span>.</span>height<span>)</span> <span>{</span>
				videoTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> videoTexture<span>,</span> video<span>)</span><span>;</span>
				canvas<span>.</span>width <span>=</span> video<span>.</span>videoWidth<span>;</span>
				canvas<span>.</span>height <span>=</span> video<span>.</span>videoHeight<span>;</span>
				videoTextureInitialized <span>=</span> <span>true</span><span>;</span>
			<span>}</span>
			
			gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> videoTexture<span>)</span><span>;</span>
			gl<span>.</span><span>texSubImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> video<span>)</span><span>;</span>

			<span>if</span> <span>(</span>lut<span>)</span> <span>{</span>
				gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span>
				gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> lutTexture<span>)</span><span>;</span>
				gl<span>.</span><span>uniform1i</span><span>(</span>lutTextureLocation<span>,</span> <span>1</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>if</span> <span>(</span>lutselect<span>)</span> <span>{</span>
		<span>const</span> lutSelectElement <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lutselect<span>)</span><span>;</span>
		<span>if</span> <span>(</span>lutSelectElement<span>)</span> <span>{</span>
			lutSelectElement<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
				
				<span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;SELECT&#39;</span><span>)</span> <span>{</span>
					<span>const</span> newPath <span>=</span> lutSelectElement<span>.</span>value<span>;</span>
					lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
						lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
					<span>}</span><span>;</span>
					lutImg<span>.</span>src <span>=</span> newPath<span>;</span>
				<span>}</span>
				
				<span>else</span> <span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;INPUT&#39;</span> <span>&amp;&amp;</span> lutSelectElement<span>.</span>type <span>===</span> <span>&#39;file&#39;</span><span>)</span> <span>{</span>
					<span>const</span> file <span>=</span> lutSelectElement<span>.</span>files<span>[</span><span>0</span><span>]</span><span>;</span>
					<span>if</span> <span>(</span>file<span>)</span> <span>{</span>
						<span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
						reader<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
							lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
								lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
							<span>}</span><span>;</span>
							lutImg<span>.</span>src <span>=</span> e<span>.</span>target<span>.</span>result<span>;</span>
						<span>}</span><span>;</span>
						reader<span>.</span><span>readAsDataURL</span><span>(</span>file<span>)</span><span>;</span>
					<span>}</span>
				<span>}</span>
			<span>}</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>


	
	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span> <span>0.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>2.0</span><span>,</span> <span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>const</span> texCoord <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;UVs&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>texCoord<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>texCoord<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		<span>updateTextures</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>{</span>
					isRendering <span>=</span> <span>true</span><span>;</span>
					<span>renderLoop</span><span>(</span><span>)</span><span>;</span>
				<span>}</span>
			<span>}</span> <span>else</span> <span>{</span>
				isRendering <span>=</span> <span>false</span><span>;</span>
				videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
				gl<span>.</span><span>deleteTexture</span><span>(</span>videoTexture<span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><p>The resulting shader contains the polynomial in <a href="https://en.wikipedia.org/wiki/Horner&#39;s_method">Horner’s method</a> and performs a bunch of Multiply-Adds <code>c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));</code> to get the color, instead of the texture lookup. This is a prime candidate for being optimized into a few <a href="https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation#Fused_multiply%E2%80%93add">Fused Multiply-Add (FMA)</a> instructions. Even considering <a href="https://en.wikipedia.org/wiki/Horner%27s_method#Parallel_evaluation">theoretical details</a>, this is as good as it gets. Whether or not this is actually faster than a LUT though, is difficult to judge without deep platform specific analysis.</p><blockquote><p>Saves you from handling the LUT texture, quite the time saver!</p><img src="https://blog.frost.kiwi/assets/kiwis/happy.svg"/></blockquote><h4 id="diversity-for-zombies" tabindex="-1">Diversity for Zombies <a href="#diversity-for-zombies">#</a></h4><p>Let’s take a look at how far this technique can be stretched. This time we are looking at the sequel <a href="https://en.wikipedia.org/wiki/Left_4_Dead_2">Left 4 Dead 2</a>. Here is <a href="http://www.bronwengrimes.com">Bronwen Grimes</a> explaining how Valve Software achieved different color variations of different zombie parts, which simple tinting couldn’t deliver well enough, with colors missing luminance variety.</p><figure><video controls="" height="540" width="960"><source src="left4dead_Gradients.mp4" type="video/mp4"/></video><figcaption>Video: Creating Zombie variation using gradient ramps</figcaption></figure><p>The resulting variations can be seen in the following screenshot. The most important feature being the ability to create both a bright &amp; dark shade of suit from one texture.</p><figure><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/mayaHLSL.jpg"/><figcaption>Left 4 Dead 2: 1D LUT shader displayed in <a href="https://en.wikipedia.org/wiki/Autodesk_Maya">Autodesk Maya</a>, creating color variations.</figcaption></figure><p>With just a couple of LUTs chosen at random for skin and clothes, the following color variations are achieved. Fitting colorramps were chosen by artists and included in the final game. This is the part I find so remarkable - How such a simple technique was leveled up to bring so much value to the visual experience. All at the cost of a simple texture read.</p><figure><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/l4dluts.jpg"/> <img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/zombievariation.jpg"/><figcaption>LUTs for skin and clothes chosen at random to create color variation</figcaption></figure><p>Checkout the <a href="https://www.gdcvault.com/play/1012264/Shading-a-Bigger-Better-Sequel">full talk</a> on the GDC page, if you are interested such techniques.</p><blockquote><div><p>The creativity of them using &#34;Exclusive Masking&#34; blew me away. First time I learned about it. Two textures in one channel, set to specific ranges</p></div><img src="https://blog.frost.kiwi/assets/kiwis/love.svg"/></blockquote><h4 id="precalculating-calculations" tabindex="-1">Precalculating calculations <a href="#precalculating-calculations">#</a></h4><p>One more use for 1D LUTs in graphics programming is to cache expensive calculations. One such example is <a href="https://en.wikipedia.org/wiki/Gamma_correction">Gamma correction</a>, especially if the standard conform <a href="https://www.colour-science.org/posts/srgb-eotf-pure-gamma-22-or-piece-wise-function/">sRGB piece-wise curve instead of the Gamma 2.2 approximation</a> is required.</p><p>Unless we talk about various approximations, gamma correction requires the use of the function <a href="https://docs.gl/sl4/pow">pow()</a>, which especially on older GPUs is a very expensive instruction. Add to that a branching path, if the piece-wise curve is needed. Or even worse, if you had to contend with the bananas level awful <a href="https://cdn.cloudflare.steamstatic.com/apps/valve/2008/GDC2008_PostProcessingInTheOrangeBox.pdf">4-segment piece-wise approximation the Xbox 360 uses</a>. Precalculating that into a 1D LUT skips such per-pixel calculations.</p><figure><img src="https://blog.frost.kiwi/assets/LUTs/Gamma/gamma2.2.png"/> <img src="https://blog.frost.kiwi/assets/LUTs/Gamma/gamma2.2inv.png"/><figcaption>Gamma 2.2 and its inverted counterpart baked into 1D LUTs</figcaption></figure><p>At the bottom of the LUT collection select box in chapter <a href="#so-many-colors">So many colors</a>, I included two gamma ramps for reference. Gamma 2.2 and inverse of Gamma 2.2. For this example: <em><strong>1D vector in, 1D vector out</strong></em>, but you can also output up to 4D vectors with a 1D LUT, as we have 4 color channels. Whether or not there is benefit from accelerating gamma transformations via 1D LUTs is a question only answerable via benchmarking, but you could imagine other calculations, that would definitely benefit.</p><p>An example of this in the wild is tinting the monitor orange during night time <a href="https://en.wikipedia.org/wiki/Biological_effects_of_high-energy_visible_light#Digital_filters">to prevent eye-strain</a>, performed by Software like <a href="http://jonls.dk/redshift/">Redshift</a>. This works by changing the Gamma Ramp, a 1D LUT each for the Red, Green and Blue channel <strong>of the monitor</strong>. To do so it precalculates the Kelvin Warmth -&gt; RGB and additional Gamma calculations by generating 3 1D LUTs, <a href="https://github.com/jonls/redshift/blob/490ba2aae9cfee097a88b6e2be98aeb1ce990050/src/colorramp.c#L289">as seen in Redshift’s source code</a>.</p><figure><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/nightlight.png" alt="Night Light feature in Android"/><figcaption>Night Light feature in Android</figcaption></figure><p>The approach of Redshift and similar pieces of software is pretty awesome with its truly zero performance impact, as the remapping is done by the monitor, not the graphics card. Though support for this hardware interface is pretty horrible across the board these days and more often than not broken or unimplemented, with graphics stacks like the one of the Raspberry Pi working backwards and <a href="https://github.com/raspberrypi/firmware/issues/1274">losing support with newer updates</a>. Microsoft even warns <a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdevicegammaramp">developers not to use that Gamma Hardware API</a> with a warning box longer than the API documentation itself.</p><blockquote><p>Quite the sad state for a solution this elegant. A sign of the times, with hardware support deemed too shaky and more features becoming software filters.</p><img src="https://blog.frost.kiwi/assets/kiwis/sad.svg"/></blockquote><h3 id="the-powerful-3d-lut" tabindex="-1">The powerful 3D LUT <a href="#the-powerful-3d-lut">#</a></h3><p>Let’s go 3D! The basic idea is that we represent the entire RGB space in one cube remapping all possible colors, loaded and sampled as a 3D texture. As before, by modifying the LUT, we modify the mapping of the colors. <em><strong>3D vector in, 3D vector out</strong></em></p><blockquote><p>You can change color balance with a 1D LUT for Red, Green and Blue. So what a 3D LUT can, that 3 1D LUTs cannot, isn&#39;t so obvious. 3D LUT cubes are needed for changes requiring a combination of RGB as input, like changes to saturation, hue, specific colors or to perform color isolation.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"/></blockquote><p>Again, the LUT can be any size, but typically a cube is used. Typically it is saved as a strip or square containing the cube, separated as planes for use in video games or as an <a href="https://drive.google.com/file/d/143Eh08ZYncCAMwJ1q4gWxVOqR_OSWYvs/view">“Iridas/Adobe” .cube file</a>, which video editors use. Here is the 32³px cube as a strip.</p><figure><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/3DLut.png"/><figcaption>3D LUT, in its 2D representation, 32³px cube as a 1024px x 32px strip</figcaption></figure><p>We can load these planes as a 32³px cube and display it in 3D as <a href="https://en.wikipedia.org/wiki/Voxel">voxels</a>.</p><figure><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/32cube.png" alt="The above 3D LUT, displayed in 3D without interpolation"/><figcaption>The above 3D LUT, displayed in 3D without interpolation</figcaption></figure><p>Since it’s in 3D, we only see the outer most voxels. We map the Red to X, Green to Y and Blue to Z, since this is identical to the mapping on graphics cards. You may have noticed the origin being in the top left. This is due to DirectX having the texture coordinate origin <a href="https://www.puredevsoftware.com/blog/2018/03/17/texture-coordinates-d3d-vs-opengl/">in the top left</a>, as opposed to OpenGL, which has <a href="https://learnopengl.com/Getting-started/Textures">its origin in the bottom left</a>. Generally the DirectX layout is the unofficial standard, though nothing prevents you from flipping it.</p><blockquote><p>This is the reason why screenshots from OpenGL are sometimes vertically flipped, when handled by tools expecting DirectX layout and vice versa. Many libraries <a href="https://github.com/nothings/stb/blob/ae721c50eaf761660b4f90cc590453cdb0c2acd0/stb_image_write.h#L53">have a switch to handle that</a>.</p><img src="https://blog.frost.kiwi/assets/kiwis/happy.svg"/></blockquote><h4 id="setup" tabindex="-1">Setup <a href="#setup">#</a></h4><p>We’ll be using this footage shot on the Panasonic GH6. It is shot in its <a href="https://www.panasonic.com/uk/consumer/cameras-camcorders/lumix-expert-advice-learn/technique-technology/what-is-v-log.html">Panasonic V-Log</a> color profile (what a horrible name, not to be confused with a <a href="https://en.wikipedia.org/wiki/Vlog">vlog</a>), a <a href="https://en.wikipedia.org/wiki/Log_profile">logarithmic profile</a> retaining more <a href="https://en.wikipedia.org/wiki/Dynamic_range">dynamic range</a> and most importantly, having a rigid definition of both Gamut and Gamma, compatible with conversions to other color profiles. Unprocessed, it looks very washed out and very boring.</p><p>You may substitute you own footage, though the examples don’t make much sense outside of V-Log color profile footage.</p><figure><figcaption>Panasonic GH6 with &#34;V-Log&#34; logarithmic profile</figcaption></figure><p>And now we load the footage again into WebGL and process it with a 3D LUT in its initial state, meaning visually there should be no changes.</p><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/3DLut.png" id="3dlut"/><blockquote><details><summary><a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_v_log.jpg">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_v_log.jpg" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec2</span> UVs<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    tex <span>=</span> UVs<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/video-3Dlut.fs">video-3Dlut.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>

<span>varying</span> <span>vec2</span> tex<span>;</span>
<span>uniform</span> <span>sampler2D</span> video<span>;</span>
<span>uniform</span> <span>sampler2D</span> lut<span>;</span>


<span>vec4</span> <span>sampleAs3DTexture</span><span>(</span><span>sampler2D</span> tex<span>,</span> <span>vec3</span> texCoord<span>,</span> <span>float</span> size<span>)</span>
<span>{</span>
	<span>float</span> sliceSize <span>=</span> <span>1.0</span> <span>/</span> size<span>;</span>			 
	<span>float</span> slicePixelSize <span>=</span> sliceSize <span>/</span> size<span>;</span> 
	<span>float</span> width <span>=</span> size <span>-</span> <span>1.0</span><span>;</span>
	<span>float</span> sliceInnerSize <span>=</span> slicePixelSize <span>*</span> width<span>;</span> 
	<span>float</span> zSlice0 <span>=</span> <span>floor</span><span>(</span>texCoord<span>.</span>z <span>*</span> width<span>)</span><span>;</span>
	<span>float</span> zSlice1 <span>=</span> <span>min</span><span>(</span>zSlice0 <span>+</span> <span>1.0</span><span>,</span> width<span>)</span><span>;</span>
	<span>float</span> xOffset <span>=</span> slicePixelSize <span>*</span> <span>0.5</span> <span>+</span> texCoord<span>.</span>x <span>*</span> sliceInnerSize<span>;</span>
	<span>float</span> yRange <span>=</span> <span>(</span>texCoord<span>.</span>y <span>*</span> width <span>+</span> <span>0.5</span><span>)</span> <span>/</span> size<span>;</span>
	<span>float</span> s0 <span>=</span> xOffset <span>+</span> <span>(</span>zSlice0 <span>*</span> sliceSize<span>)</span><span>;</span>
	<span>float</span> s1 <span>=</span> xOffset <span>+</span> <span>(</span>zSlice1 <span>*</span> sliceSize<span>)</span><span>;</span>
	<span>vec4</span> slice0Color <span>=</span> <span>texture2D</span><span>(</span>tex<span>,</span> <span>vec2</span><span>(</span>s0<span>,</span> yRange<span>)</span><span>)</span><span>;</span>
	<span>vec4</span> slice1Color <span>=</span> <span>texture2D</span><span>(</span>tex<span>,</span> <span>vec2</span><span>(</span>s1<span>,</span> yRange<span>)</span><span>)</span><span>;</span>
	<span>float</span> zOffset <span>=</span> <span>mod</span><span>(</span>texCoord<span>.</span>z <span>*</span> width<span>,</span> <span>1.0</span><span>)</span><span>;</span>
	<span>return</span> <span>mix</span><span>(</span>slice0Color<span>,</span> slice1Color<span>,</span> zOffset<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>vec3</span> videoColor <span>=</span> <span>texture2D</span><span>(</span>video<span>,</span> tex<span>)</span><span>.</span>rgb<span>;</span>
	<span>vec4</span> correctedColor <span>=</span> <span>sampleAs3DTexture</span><span>(</span>lut<span>,</span> videoColor<span>,</span> <span>32.0</span><span>)</span><span>;</span>

	gl_FragColor <span>=</span> correctedColor<span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>


<span>function</span> <span>createAndCompileShader</span><span>(</span><span>gl<span>,</span> type<span>,</span> source<span>,</span> canvas</span><span>)</span> <span>{</span>
	<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
	<span>const</span> element <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>;</span>
	<span>let</span> shaderSource<span>;</span>

	<span>if</span> <span>(</span>element<span>.</span>tagName <span>===</span> <span>&#39;SCRIPT&#39;</span><span>)</span>
		shaderSource <span>=</span> element<span>.</span>text<span>;</span>
	<span>else</span>
		shaderSource <span>=</span> ace<span>.</span><span>edit</span><span>(</span>source<span>)</span><span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>

	gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> shaderSource<span>)</span><span>;</span>
	gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
	<span>else</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> <span>&#34;&#34;</span><span>)</span><span>;</span>
	<span>return</span> shader<span>;</span>
<span>}</span>

<span>function</span> <span>displayErrorMessage</span><span>(</span><span>canvas<span>,</span> message</span><span>)</span> <span>{</span>
	<span>let</span> errorElement <span>=</span> canvas<span>.</span>nextSibling<span>;</span>
	<span>const</span> hasErrorElement <span>=</span> errorElement <span>&amp;&amp;</span> errorElement<span>.</span>tagName <span>===</span> <span>&#39;PRE&#39;</span><span>;</span>

	<span>if</span> <span>(</span>message<span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>hasErrorElement<span>)</span> <span>{</span>
			errorElement <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>&#39;pre&#39;</span><span>)</span><span>;</span>
			errorElement<span>.</span>style<span>.</span>color <span>=</span> <span>&#39;red&#39;</span><span>;</span>
			canvas<span>.</span>parentNode<span>.</span><span>insertBefore</span><span>(</span>errorElement<span>,</span> canvas<span>.</span>nextSibling<span>)</span><span>;</span>
		<span>}</span>
		errorElement<span>.</span>textContent <span>=</span> <span><span>`</span><span>Shader Compilation Error: </span><span><span>${</span>message<span>}</span></span><span>`</span></span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>if</span> <span>(</span>hasErrorElement<span>)</span>
			errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>function</span> <span>setupTexture</span><span>(</span><span>gl<span>,</span> target<span>,</span> source</span><span>)</span> <span>{</span>
	gl<span>.</span><span>deleteTexture</span><span>(</span>target<span>)</span><span>;</span>
	target <span>=</span> gl<span>.</span><span>createTexture</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> target<span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_S</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_T</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	
	gl<span>.</span><span>texImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> source<span>)</span><span>;</span>
	<span>return</span> target<span>;</span>
<span>}</span>

<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId<span>,</span> videoId<span>,</span> lut<span>,</span> lutselect<span>,</span> buttonId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>
	<span>const</span> lutImg <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lut<span>)</span><span>;</span>
	<span>let</span> lutTexture<span>,</span> videoTexture<span>,</span> shaderProgram<span>;</span>

	
	<span>function</span> <span>initializeShaders</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>,</span> canvas<span>)</span><span>;</span>
		<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>,</span> canvas<span>)</span><span>;</span>

		shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

		
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>fragmentShader<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	<span>}</span>

	<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> lutTextureLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;lut&#34;</span><span>)</span><span>;</span>

	<span>if</span> <span>(</span>buttonId<span>)</span> <span>{</span>
		<span>const</span> button <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>buttonId<span>)</span><span>;</span>
		button<span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span>shaderProgram<span>)</span>
				gl<span>.</span><span>deleteProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
			<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>

	<span>let</span> videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> lutTextureInitialized <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>updateTextures</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>video<span>)</span> <span>{</span>
			
			video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>video <span>&amp;&amp;</span> video<span>.</span>paused <span>&amp;&amp;</span> video<span>.</span>readyState <span>&gt;=</span> <span>4</span><span>)</span> <span>{</span>
			
			video<span>.</span>loop <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>muted <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>playsinline <span>=</span> <span>true</span><span>;</span>
			video<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>lut <span>&amp;&amp;</span> lutImg<span>.</span>naturalWidth <span>&amp;&amp;</span> <span>!</span>lutTextureInitialized<span>)</span> <span>{</span>
			lutTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> lutTexture<span>,</span> lutImg<span>)</span><span>;</span>
			lutTextureInitialized <span>=</span> <span>true</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>video<span>.</span>readyState <span>&gt;=</span> video<span>.</span><span>HAVE_CURRENT_DATA</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span><span>!</span>videoTextureInitialized <span>||</span> video<span>.</span>videoWidth <span>!==</span> canvas<span>.</span>width <span>||</span> video<span>.</span>videoHeight <span>!==</span> canvas<span>.</span>height<span>)</span> <span>{</span>
				videoTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> videoTexture<span>,</span> video<span>)</span><span>;</span>
				canvas<span>.</span>width <span>=</span> video<span>.</span>videoWidth<span>;</span>
				canvas<span>.</span>height <span>=</span> video<span>.</span>videoHeight<span>;</span>
				videoTextureInitialized <span>=</span> <span>true</span><span>;</span>
			<span>}</span>
			
			gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> videoTexture<span>)</span><span>;</span>
			gl<span>.</span><span>texSubImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> video<span>)</span><span>;</span>

			<span>if</span> <span>(</span>lut<span>)</span> <span>{</span>
				gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span>
				gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> lutTexture<span>)</span><span>;</span>
				gl<span>.</span><span>uniform1i</span><span>(</span>lutTextureLocation<span>,</span> <span>1</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>if</span> <span>(</span>lutselect<span>)</span> <span>{</span>
		<span>const</span> lutSelectElement <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lutselect<span>)</span><span>;</span>
		<span>if</span> <span>(</span>lutSelectElement<span>)</span> <span>{</span>
			lutSelectElement<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
				
				<span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;SELECT&#39;</span><span>)</span> <span>{</span>
					<span>const</span> newPath <span>=</span> lutSelectElement<span>.</span>value<span>;</span>
					lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
						lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
					<span>}</span><span>;</span>
					lutImg<span>.</span>src <span>=</span> newPath<span>;</span>
				<span>}</span>
				
				<span>else</span> <span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;INPUT&#39;</span> <span>&amp;&amp;</span> lutSelectElement<span>.</span>type <span>===</span> <span>&#39;file&#39;</span><span>)</span> <span>{</span>
					<span>const</span> file <span>=</span> lutSelectElement<span>.</span>files<span>[</span><span>0</span><span>]</span><span>;</span>
					<span>if</span> <span>(</span>file<span>)</span> <span>{</span>
						<span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
						reader<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
							lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
								lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
							<span>}</span><span>;</span>
							lutImg<span>.</span>src <span>=</span> e<span>.</span>target<span>.</span>result<span>;</span>
						<span>}</span><span>;</span>
						reader<span>.</span><span>readAsDataURL</span><span>(</span>file<span>)</span><span>;</span>
					<span>}</span>
				<span>}</span>
			<span>}</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>


	
	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span> <span>0.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>2.0</span><span>,</span> <span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>const</span> texCoord <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;UVs&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>texCoord<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>texCoord<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		<span>updateTextures</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>{</span>
					isRendering <span>=</span> <span>true</span><span>;</span>
					<span>renderLoop</span><span>(</span><span>)</span><span>;</span>
				<span>}</span>
			<span>}</span> <span>else</span> <span>{</span>
				isRendering <span>=</span> <span>false</span><span>;</span>
				videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
				gl<span>.</span><span>deleteTexture</span><span>(</span>videoTexture<span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><p>One technical detail is that for compatibility I’m using WebGL 1.0, so 3D Textures are not supported. We have to implement a 3D texture read, by performing two 2D texture reads and blending between them. This is a fairly well know problem with one typical solution and line by line explanation provided in <a href="https://www.youtube.com/watch?v=rfQ8rKGTVlg#t=26m00s">this Google I/O 2011 Talk by Gregg Tavares</a>, which <a href="https://webglfundamentals.org/webgl/lessons/webgl-qna-how-to-simulate-a-3d-texture-in-webgl.html">this article by webglfundamentals.org</a> is based on.</p><p>Unfortunately, that code contains a mistake around Z-Axis calculation of the cube, shifting the colors blue, a mistake <a href="https://github.com/WebGLSamples/WebGLSamples.github.io/commit/b07bf14b53c2666918ff8ae207a7588732012a2b">corrected in 2019</a>. So if you want to perform the same backwards compatibility to WebGL 1.0, OpenGLES 2 or OpenGL 2.1 without the <a href="https://registry.khronos.org/OpenGL/extensions/OES/OES_texture_3D.txt">OES_texture_3D</a> extension, make sure you copy the most recent version, as used here.</p><h4 id="simple-corrections" tabindex="-1">Simple corrections <a href="#simple-corrections">#</a></h4><p>As with the 1D LUT, any correction we apply to the LUT will be applied to the footage or graphics scene we use. In the following example I imported my footage and LUT into <a href="https://www.blackmagicdesign.com/products/davinciresolve">DaVinci Resolve</a>. I applied Panasonic’s “<a href="https://na.panasonic.com/us/resource-center/v-log-v-709-3d-lut">V-Log to V-709 3D-LUT</a>”, which transforms the footage into what Panasonic considers a pleasing standard look. Then a bit of contrast and white point correction to make white full-bright were applied. Afterwards the LUT was exported again. This LUT and its result are shown below.</p> <img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/3DLutDavinci.png" id="3dlutDavinci"/><blockquote><details><summary><a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_v709.jpg">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/WebGL-LUTS-made-simple/screenshot_v709.jpg" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.vs">fullscreen-tri.vs</a></summary><pre><code><span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec2</span> UVs<span>;</span>
<span>varying</span> <span>vec2</span> tex<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    tex <span>=</span> UVs<span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/video-3Dlut.fs">video-3Dlut.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>

<span>varying</span> <span>vec2</span> tex<span>;</span>
<span>uniform</span> <span>sampler2D</span> video<span>;</span>
<span>uniform</span> <span>sampler2D</span> lut<span>;</span>


<span>vec4</span> <span>sampleAs3DTexture</span><span>(</span><span>sampler2D</span> tex<span>,</span> <span>vec3</span> texCoord<span>,</span> <span>float</span> size<span>)</span>
<span>{</span>
	<span>float</span> sliceSize <span>=</span> <span>1.0</span> <span>/</span> size<span>;</span>			 
	<span>float</span> slicePixelSize <span>=</span> sliceSize <span>/</span> size<span>;</span> 
	<span>float</span> width <span>=</span> size <span>-</span> <span>1.0</span><span>;</span>
	<span>float</span> sliceInnerSize <span>=</span> slicePixelSize <span>*</span> width<span>;</span> 
	<span>float</span> zSlice0 <span>=</span> <span>floor</span><span>(</span>texCoord<span>.</span>z <span>*</span> width<span>)</span><span>;</span>
	<span>float</span> zSlice1 <span>=</span> <span>min</span><span>(</span>zSlice0 <span>+</span> <span>1.0</span><span>,</span> width<span>)</span><span>;</span>
	<span>float</span> xOffset <span>=</span> slicePixelSize <span>*</span> <span>0.5</span> <span>+</span> texCoord<span>.</span>x <span>*</span> sliceInnerSize<span>;</span>
	<span>float</span> yRange <span>=</span> <span>(</span>texCoord<span>.</span>y <span>*</span> width <span>+</span> <span>0.5</span><span>)</span> <span>/</span> size<span>;</span>
	<span>float</span> s0 <span>=</span> xOffset <span>+</span> <span>(</span>zSlice0 <span>*</span> sliceSize<span>)</span><span>;</span>
	<span>float</span> s1 <span>=</span> xOffset <span>+</span> <span>(</span>zSlice1 <span>*</span> sliceSize<span>)</span><span>;</span>
	<span>vec4</span> slice0Color <span>=</span> <span>texture2D</span><span>(</span>tex<span>,</span> <span>vec2</span><span>(</span>s0<span>,</span> yRange<span>)</span><span>)</span><span>;</span>
	<span>vec4</span> slice1Color <span>=</span> <span>texture2D</span><span>(</span>tex<span>,</span> <span>vec2</span><span>(</span>s1<span>,</span> yRange<span>)</span><span>)</span><span>;</span>
	<span>float</span> zOffset <span>=</span> <span>mod</span><span>(</span>texCoord<span>.</span>z <span>*</span> width<span>,</span> <span>1.0</span><span>)</span><span>;</span>
	<span>return</span> <span>mix</span><span>(</span>slice0Color<span>,</span> slice1Color<span>,</span> zOffset<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span>vec3</span> videoColor <span>=</span> <span>texture2D</span><span>(</span>video<span>,</span> tex<span>)</span><span>.</span>rgb<span>;</span>
	<span>vec4</span> correctedColor <span>=</span> <span>sampleAs3DTexture</span><span>(</span>lut<span>,</span> videoColor<span>,</span> <span>32.0</span><span>)</span><span>;</span>

	gl_FragColor <span>=</span> correctedColor<span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/fullscreen-tri.js">fullscreen-tri.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>


<span>function</span> <span>createAndCompileShader</span><span>(</span><span>gl<span>,</span> type<span>,</span> source<span>,</span> canvas</span><span>)</span> <span>{</span>
	<span>const</span> shader <span>=</span> gl<span>.</span><span>createShader</span><span>(</span>type<span>)</span><span>;</span>
	<span>const</span> element <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>source<span>)</span><span>;</span>
	<span>let</span> shaderSource<span>;</span>

	<span>if</span> <span>(</span>element<span>.</span>tagName <span>===</span> <span>&#39;SCRIPT&#39;</span><span>)</span>
		shaderSource <span>=</span> element<span>.</span>text<span>;</span>
	<span>else</span>
		shaderSource <span>=</span> ace<span>.</span><span>edit</span><span>(</span>source<span>)</span><span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>

	gl<span>.</span><span>shaderSource</span><span>(</span>shader<span>,</span> shaderSource<span>)</span><span>;</span>
	gl<span>.</span><span>compileShader</span><span>(</span>shader<span>)</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>gl<span>.</span><span>getShaderParameter</span><span>(</span>shader<span>,</span> gl<span>.</span><span>COMPILE_STATUS</span><span>)</span><span>)</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> gl<span>.</span><span>getShaderInfoLog</span><span>(</span>shader<span>)</span><span>)</span><span>;</span>
	<span>else</span>
		<span>displayErrorMessage</span><span>(</span>canvas<span>,</span> <span>&#34;&#34;</span><span>)</span><span>;</span>
	<span>return</span> shader<span>;</span>
<span>}</span>

<span>function</span> <span>displayErrorMessage</span><span>(</span><span>canvas<span>,</span> message</span><span>)</span> <span>{</span>
	<span>let</span> errorElement <span>=</span> canvas<span>.</span>nextSibling<span>;</span>
	<span>const</span> hasErrorElement <span>=</span> errorElement <span>&amp;&amp;</span> errorElement<span>.</span>tagName <span>===</span> <span>&#39;PRE&#39;</span><span>;</span>

	<span>if</span> <span>(</span>message<span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>hasErrorElement<span>)</span> <span>{</span>
			errorElement <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>&#39;pre&#39;</span><span>)</span><span>;</span>
			errorElement<span>.</span>style<span>.</span>color <span>=</span> <span>&#39;red&#39;</span><span>;</span>
			canvas<span>.</span>parentNode<span>.</span><span>insertBefore</span><span>(</span>errorElement<span>,</span> canvas<span>.</span>nextSibling<span>)</span><span>;</span>
		<span>}</span>
		errorElement<span>.</span>textContent <span>=</span> <span><span>`</span><span>Shader Compilation Error: </span><span><span>${</span>message<span>}</span></span><span>`</span></span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>if</span> <span>(</span>hasErrorElement<span>)</span>
			errorElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		canvas<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>function</span> <span>setupTexture</span><span>(</span><span>gl<span>,</span> target<span>,</span> source</span><span>)</span> <span>{</span>
	gl<span>.</span><span>deleteTexture</span><span>(</span>target<span>)</span><span>;</span>
	target <span>=</span> gl<span>.</span><span>createTexture</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> target<span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_S</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_T</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	
	gl<span>.</span><span>texImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> source<span>)</span><span>;</span>
	<span>return</span> target<span>;</span>
<span>}</span>

<span>function</span> <span>setupTri</span><span>(</span><span>canvasId<span>,</span> vertexId<span>,</span> fragmentId<span>,</span> videoId<span>,</span> lut<span>,</span> lutselect<span>,</span> buttonId</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>
	<span>const</span> lutImg <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lut<span>)</span><span>;</span>
	<span>let</span> lutTexture<span>,</span> videoTexture<span>,</span> shaderProgram<span>;</span>

	
	<span>function</span> <span>initializeShaders</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> vertexShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>VERTEX_SHADER</span><span>,</span> vertexId<span>,</span> canvas<span>)</span><span>;</span>
		<span>const</span> fragmentShader <span>=</span> <span>createAndCompileShader</span><span>(</span>gl<span>,</span> gl<span>.</span><span>FRAGMENT_SHADER</span><span>,</span> fragmentId<span>,</span> canvas<span>)</span><span>;</span>

		shaderProgram <span>=</span> gl<span>.</span><span>createProgram</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>attachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>linkProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>

		
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>detachShader</span><span>(</span>shaderProgram<span>,</span> fragmentShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>vertexShader<span>)</span><span>;</span>
		gl<span>.</span><span>deleteShader</span><span>(</span>fragmentShader<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
	<span>}</span>

	<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> lutTextureLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;lut&#34;</span><span>)</span><span>;</span>

	<span>if</span> <span>(</span>buttonId<span>)</span> <span>{</span>
		<span>const</span> button <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>buttonId<span>)</span><span>;</span>
		button<span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span>shaderProgram<span>)</span>
				gl<span>.</span><span>deleteProgram</span><span>(</span>shaderProgram<span>)</span><span>;</span>
			<span>initializeShaders</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>

	<span>let</span> videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> lutTextureInitialized <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>updateTextures</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>video<span>)</span> <span>{</span>
			
			video <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>videoId<span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>video <span>&amp;&amp;</span> video<span>.</span>paused <span>&amp;&amp;</span> video<span>.</span>readyState <span>&gt;=</span> <span>4</span><span>)</span> <span>{</span>
			
			video<span>.</span>loop <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>muted <span>=</span> <span>true</span><span>;</span>
			video<span>.</span>playsinline <span>=</span> <span>true</span><span>;</span>
			video<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>lut <span>&amp;&amp;</span> lutImg<span>.</span>naturalWidth <span>&amp;&amp;</span> <span>!</span>lutTextureInitialized<span>)</span> <span>{</span>
			lutTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> lutTexture<span>,</span> lutImg<span>)</span><span>;</span>
			lutTextureInitialized <span>=</span> <span>true</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>video<span>.</span>readyState <span>&gt;=</span> video<span>.</span><span>HAVE_CURRENT_DATA</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span><span>!</span>videoTextureInitialized <span>||</span> video<span>.</span>videoWidth <span>!==</span> canvas<span>.</span>width <span>||</span> video<span>.</span>videoHeight <span>!==</span> canvas<span>.</span>height<span>)</span> <span>{</span>
				videoTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> videoTexture<span>,</span> video<span>)</span><span>;</span>
				canvas<span>.</span>width <span>=</span> video<span>.</span>videoWidth<span>;</span>
				canvas<span>.</span>height <span>=</span> video<span>.</span>videoHeight<span>;</span>
				videoTextureInitialized <span>=</span> <span>true</span><span>;</span>
			<span>}</span>
			
			gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> videoTexture<span>)</span><span>;</span>
			gl<span>.</span><span>texSubImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> video<span>)</span><span>;</span>

			<span>if</span> <span>(</span>lut<span>)</span> <span>{</span>
				gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span>
				gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> lutTexture<span>)</span><span>;</span>
				gl<span>.</span><span>uniform1i</span><span>(</span>lutTextureLocation<span>,</span> <span>1</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>if</span> <span>(</span>lutselect<span>)</span> <span>{</span>
		<span>const</span> lutSelectElement <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>lutselect<span>)</span><span>;</span>
		<span>if</span> <span>(</span>lutSelectElement<span>)</span> <span>{</span>
			lutSelectElement<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
				
				<span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;SELECT&#39;</span><span>)</span> <span>{</span>
					<span>const</span> newPath <span>=</span> lutSelectElement<span>.</span>value<span>;</span>
					lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
						lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
					<span>}</span><span>;</span>
					lutImg<span>.</span>src <span>=</span> newPath<span>;</span>
				<span>}</span>
				
				<span>else</span> <span>if</span> <span>(</span>lutSelectElement<span>.</span>tagName <span>===</span> <span>&#39;INPUT&#39;</span> <span>&amp;&amp;</span> lutSelectElement<span>.</span>type <span>===</span> <span>&#39;file&#39;</span><span>)</span> <span>{</span>
					<span>const</span> file <span>=</span> lutSelectElement<span>.</span>files<span>[</span><span>0</span><span>]</span><span>;</span>
					<span>if</span> <span>(</span>file<span>)</span> <span>{</span>
						<span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
						reader<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
							lutImg<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
								lutTextureInitialized <span>=</span> <span>false</span><span>;</span>
							<span>}</span><span>;</span>
							lutImg<span>.</span>src <span>=</span> e<span>.</span>target<span>.</span>result<span>;</span>
						<span>}</span><span>;</span>
						reader<span>.</span><span>readAsDataURL</span><span>(</span>file<span>)</span><span>;</span>
					<span>}</span>
				<span>}</span>
			<span>}</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>


	
	
	<span>const</span> unitTri <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>3.0</span><span>,</span> <span>0.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>,</span>
		<span>3.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span> <span>2.0</span><span>,</span> <span>1.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> <span>new</span> <span>Float32Array</span><span>(</span>unitTri<span>)</span><span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>

	<span>const</span> vtx <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;vtx&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>vtx<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>vtx<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>

	<span>const</span> texCoord <span>=</span> gl<span>.</span><span>getAttribLocation</span><span>(</span>shaderProgram<span>,</span> <span>&#34;UVs&#34;</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span>texCoord<span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span>texCoord<span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>4</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		<span>updateTextures</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLES</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>{</span>
					isRendering <span>=</span> <span>true</span><span>;</span>
					<span>renderLoop</span><span>(</span><span>)</span><span>;</span>
				<span>}</span>
			<span>}</span> <span>else</span> <span>{</span>
				isRendering <span>=</span> <span>false</span><span>;</span>
				videoTextureInitialized <span>=</span> <span>false</span><span>;</span>
				gl<span>.</span><span>deleteTexture</span><span>(</span>videoTexture<span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></details></blockquote><p>With the above two buttons you can also download the clean LUT, screenshot the uncorrected footage in the “<a href="#setup">Setup chapter</a>” and apply your own corrections. The upload LUT button allows you to replace the LUT and see the result. Be aware, that the LUT has to maintain the exact same 1024px x 32px size and remain a 32³px cube.</p><blockquote><p>Just to clarify, the used video is still the original! DaVinci Resolve exported a LUT, not a video. The full color correction is happening right now.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"/></blockquote><h4 id="left-4-dead%E2%80%99s-use-of-3d-luts" tabindex="-1">Left 4 Dead’s use of 3D LUTs <a href="#left-4-dead%E2%80%99s-use-of-3d-luts">#</a></h4><p>Using 3D LUTs to style your game’s colors via outside tools is a very well known workflow and standard across the video game industry, as opposed to the previous and game specific 1D LUT use for introducing variation in skin and clothes. The way it works is:</p><ul><li>take a screenshot of the scene you want to color correct</li><li>open it and an initialized 3D LUT in Photoshop or similar photo editing software</li><li>Apply your color corrections, to both the screenshot and LUT at the same time</li><li>crop out and export the 3D LUT</li></ul><p>Continuing the use of Left 4 Dead as an example, Left 4 Dead does exactly the same. Here is a tutorial walking you through the process for Left 4 Dead 2 specifically.</p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed/xXVzJ_CfnfQ?si=4hMkpjkRX86xD2yT&amp;start=250" title="YouTube video player" width="100%"></iframe><p>You can use any color correction tool of Photoshop freely. The only limitation is that you may not use any filters influencing the relation of multiple pixels. So all <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)">convolutions</a> like blur, sharpen, emboss, etc., cannot be used. Or rather, they will lead to unexpected results by blurring the remapped colors.</p><h4 id="advanced-adventures" tabindex="-1">Advanced Adventures <a href="#advanced-adventures">#</a></h4><p>But we aren’t just limited to simple corrections. In-depth video editing and color grading suites like <a href="https://www.blackmagicdesign.com/products/davinciresolve">DaVinci Resolve</a> allow you to implement complicated color transforms and color grades and export those as 3D LUTs. This field is so incredibly complicated, that it’s far beyond practical to implement these yourself.</p><p>Here is a color grading node network applying the filmic look “Kodak 2383”, a LUT aimed at achieving a certain film print look. To do so, we need to transform our V-Log gamma footage into Cineon Film Log and the colors into <a href="https://en.wikipedia.org/wiki/Rec._709">Rec.709</a>, as mentioned in the Kodak 2383 LUT itself, see below. Afterwards we can apply the film emulation on top, which also transforms our gamma back into Rec.709. Finally we adjust the white point, so white is actually full bright.</p><details><summary>Rec709 Kodak 2383 D60.cube</summary><pre><code># Resolve Film Look LUT
#   Input: Cineon Log 
#        : floating point data (range 0.0 - 1.0)
#  Output: Kodak 2383 film stock &#39;look&#39; with D60 White Point
#        : floating point data (range 0.0 - 1.0)
# Display: ITU-Rec.709, Gamma 2.4

LUT_3D_SIZE 33
LUT_3D_INPUT_RANGE 0.0 1.0

0.026979 0.027936 0.031946
0.028308 0.028680 0.033007
0.029028 0.029349 0.034061
0.032303 0.030119 0.034824
0.038008 0.031120 0.035123
&lt; Cut-off for brevity &gt;
</code></pre></details></div></div>
  </body>
</html>
