<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jott.live/markdown/telnet_draw">Original</a>
    <h1>Show HN: Collaborative ASCII Drawing with Telnet</h1>
    
    <div id="readability-page-1" class="page">

<pre id="note-container"># Collaborative ASCII Drawing With Telnet
*by [@bwasti](https://twitter.com/bwasti)*
****

If the server isn&#39;t swamped, you can try it out (hold shift to erase, arrow keys to move):

```
telnet bram.town
```
If you&#39;re on a newer mac, you may need to `brew install telnet`.
It doesn&#39;t come by default these days...

![](https://i.imgur.com/QfIJWob.gif)

The full code listing can be found [here](https://github.com/bwasti/bram.town/blob/main/server.ts).
I run it with `bun server.ts`.

****

### User Input

For details, check out the xterm docs: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html

We can tell xterm terminals to start
sending mouse information by sending
connected users an ANSI sequence like this:

```
socket.write(&#34;\x1b[?1003;1006;1015h&#34;);
```
This concatenates 3 different parameters,
which we can find in the docs:

![](https://i.imgur.com/K1qmfPb.png)

I found the `EXT_MODE` parameters to be particularly important,
as they can cause the *client* to crash if not set correctly
(when using a macOS version at least).

This was a nightmare to debug, because the errors looked like this:

![](https://i.imgur.com/k5MH6vO.png)

and they only happened... sometimes!
When moving the cursor beyond ~90 or so characters
to the right, the client would crash but not disconnect.

But this wasn&#39;t consistent.
And that was because I was playing with a
really cool project for inspiration:

**mapscii.me!**

![](https://i.imgur.com/RbjbedX.gif)

and every time I used mapscii,
my terminal was correctly set to the extended mode.

Because terminals are state based and can be manipulated
by the characters they print.  Neat.

I guess we should clean up when people leave...

```
user.socket.write(&#34;\x1b[?1003;1006;1015l&#34;);
```

### Rendering Output

But just getting user input isn&#39;t enough,
we also need to &#34;render&#34; the output.

This happens to be a lot easier, and ChatGPT wrote that code for me:

First, move the cursor to the top left corner:
```
user.socket.write(&#34;\x1b[H&#34;);
```
Then, dump the correctly sized contents and hide the cursor:

```
user.socket.write(screenString + &#34;\x1b[?25l&#34;);
```

Done.

Although I didn&#39;t explain &#34;correctly sized contents&#34; at all.
This turns out to be another tricky mess of hard to understand control code sequences.
Luckily for me, ChatGPT actually *did* understand this stuff,
so I didn&#39;t have to write/debug that part of the code.

Getting the user window size is done with telnet&#39;s NAWS option.
NAWS stands for &#34;Negotiate About Window Size.&#34;
The server requests NAWS by outputting a series of telnet protocol bytes:

```
socket.write(Buffer.from([IAC, DO, NAWS]));
```

and the client will respond if it can handle such a request
as well as the data associated with it.
I assume it can and just read the data:

```
if (data.length &gt;= 5) {
  user.width = (data[0] &lt;&lt; 8) + data[1];
  user.height = (data[2] &lt;&lt; 8) + data[3];
  //scheduleRender(user);
}
```

You can read more about this stuff here: http://www.pcmicro.com/netfoss/telnet.html
****

### Features

Once I got this working I added some random features,
but I&#39;m hoping to add more.
Drawing and panning around a global canvas with multiple users
is kind of a litmus test for these things, so I just did that.

You can move around with WASD or arrow keys.

You can click and drag to draw pixels.
These can be &#34;layered&#34; by repeated drawing to get a typical &#34;ASCII art&#34; effect.
If you hold shift while dragging around, you erase pixels.

Your cursor is represented by a little circle and everyone can see it.

---

if you&#39;d like to follow me [@bwasti](https://twitter.com/bwasti) :^}
</pre>




</div>
  </body>
</html>
