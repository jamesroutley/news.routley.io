<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.theregister.com/2023/12/25/the_war_of_the_workstations/">Original</a>
    <h1>War of the workstations: How the lowest bidders shaped today&#39;s tech landscape</h1>
    
    <div id="readability-page-1" class="page"><div id="body">
<p><span>Feature</span> Digging into stories of 1980s OSes, a forgotten war for the future of computing emerges. It was won by the lowest bidders, and then the poor users and programmers forgot it ever happened.</p>
<p>Retrocomputing is a substantial, and still growing, interest for many techies and hobbyists, and has been for a decade or two now. There&#39;s only so much you can write about a game that&#39;s decades old, but operating systems and the different paths they&#39;ve taken still have rich veins to be explored.</p>
<p>Anyone who played with 1980s computers remembers the <a target="_blank" href="https://www.theregister.com/2015/07/24/amiga_turns_30/">Amiga versus the Atari ST</a> and other battles. But digging down past the stratum of cheap home computers and gaming reveals bigger, more profound differences. The winners of the battles got to write the histories, as they always do, and that means that what is now received wisdom, shared and understood by almost everyone, contains and conceals propaganda and dogma. Things that were once just marketing BS are now holy writ, and when you discover how the <em>other</em> side saw it, dogma is uncovered as just big fat lies.</p>
<h3>The biggest lie</h3>
<p>The first of the big lies is the biggest, but it&#39;s also one of the simplest, one that you&#39;ve probably never questioned.</p>
<p>It&#39;s this: <em>Computers today are better than they have ever been before.</em> Not just that they have thousands of times more storage and more speed, but that everything, the whole stack – hardware, operating systems, networking, programming languages and libraries and apps – are better than ever.</p>

    

<p>The myth is that early computers were simple, and they were replaced by better ones that could do more. Gradually, they evolved, getting more sophisticated and more capable, until now, we have multi-processor multi-gigabyte supercomputers in our pockets.</p>

        


        

<p>Which gives me an excuse to use my favorite German quote, generally attributed to physicist Wolfgang Pauli: &#34;Das ist nicht nur nicht richtig; es ist nicht einmal falsch!&#34; (That is not only not right, it is not even wrong!)</p>
<p>Though probably apocryphal, someone asked John Glenn, America&#39;s first person in space, what it felt like just before launch. Supposedly, he replied: &#34;I felt about as good as anybody would, sitting in a capsule above a rocket that were both built by the lowest bidder.&#34;</p>

        

<p>Well, that is where we are today.</p>
<p>The story about evolution is totally wrong. What really happened is that, time after time, each generation of computers developed until it was very capable and sophisticated, and then it was totally replaced by a new generation of relatively simple, stupid ones. Then those were improved, usually completely ignoring all the lessons learned in the previous generation, until the new generation gets replaced in turn by something smaller, cheaper, and far more stupid.</p>
<h3>Evolution</h3>
<p>The first computers, of course, were huge room-sized things that cost millions. They evolved into mainframes: very big, very expensive, but a whole company could share one, running batch jobs submitted on punched cards and stuff like that.</p>
<p>After a couple of decades, mainframes were replaced by minicomputers, shrunk to the size of filing cabinets, but cheap enough for a mere department to afford. They were also fast enough that multiple users could use them <em>at the same time</em>, using interactive terminals.</p>
<p>All the mainframes&#39; intelligent peripherals, networked to their CPUs, and their sophisticated, hypervisor-based, operating systems, with rich role-based security just thrown away.</p>

        

<p>Then, it gets more complicated. The conventional story, for those who have looked back to the 1970s, is that microcomputers came along, based on cheap single-chip microprocessors, and swept away minicomputers. Then they gradually evolved until they caught up.</p>
<p>But that&#39;s not really true.</p>
<p>First, and less visibly because they were so expensive, department-scale minicomputers shrank down to desk-sized, and then desk-side, and later desk-<strong>top</strong>, <em>workstations</em>. Instead of being shared by a department, these were single-user machines. Very powerful, very expensive, but just about affordable for one person – as long as they were someone important enough.</p>
<p>Unfortunately, though, in the course of being shrunk down to single-user boxes, most of their ancestors&#39; departmental-scale sophistication was thrown away. Rich file systems, with built-in version tracking, because hard disks cost as much as cars: gone. Clustering, enabling a handful of machines costing hundreds of thousands to work as a seamless whole? Not needed, gone. Rich built-in groupware, enabling teams to cooperate and work on shared documents? Forgotten. Plain-text email was enough.</p>
<p>Meanwhile, down at the budget end and at the same time as these tens-of-thousands-of-dollar single-user workstations, dumb terminals evolved into microcomputers. Every computer in the world today is, at heart, a &#34;micro.&#34;</p>
<p>At first, they were feeble. They could hardly do anything. So, this time around, we lost <em>tons</em> of stuff.</p>
<p>Hard disks? Too expensive. Dropped. Multitasking? Not enough memory. Removed. Choice of programming languages? Retained in the 1970s CP/M machines, then when they got cheaper still in the early &#39;80s, dropped: kids don&#39;t need that. Shove BASIC in a ROM, that will do. The machines mostly got used for playing games anyway.</p>
<p>Early micros could handle floppy disk drives and had a DOS, but over the longer run, even those got eliminated: too expensive. Instead, you got an audio cassette recorder.</p>
<h3>How we got here</h3>
<p>Those early-1980s micros, the weakest, feeblest, most pathetic computers since the first 1940s mainframes, the early eight-bit micros, <em>those</em> are the ancestors of the computers you use today.</p>
<p>In fact, of all the early 1980s computers, the one with the most boring, unoriginal design, the one with <em>no</em> graphics and <em>no</em> sound – that, with a couple of exceptions, is the ancestor of what you use today. <a target="_blank" href="https://www.theregister.com/2007/11/17/tob_ibm_personal_computer/">The IBM PC</a>, which got expanded and enhanced over and over again to catch up and eventually, over about 15 years, exceed the abilities of its cheaper but cleverer rivals.</p>
<p>It is <a target="_blank" href="https://en.wikipedia.org/wiki/Dollo%27s_law_of_irreversibility" rel="nofollow">a sort of law of nature</a> that when you try to replace features that you eliminated, the result is never as good as if you designed it in at the beginning.</p>
<p>We run the much-upgraded descendants of the simplest, stupidest, and most boring computer that anyone could get to market. They were the easiest to build and to get working. Easy means cheap, and cheap sells more and makes more profit. So they are the ones that won.</p>
<p>There&#39;s a proverb about choosing a product: &#34;You can have good, fast, and cheap. Choose any two!&#34;</p>
<p>We got &#34;fast&#34; and &#34;cheap.&#34; We lost &#34;good&#34;, replaced by &#34;reliable,&#34; which is definitely a virtue, but one that comes with an extremely high price.</p>
<h3>What we lost</h3>
<p>Like many a middle-aged geek, there was a time when I collected 1980s hardware, because what was inaccessible when it was new – because I couldn&#39;t afford it – was being given away for free. However, it got bulky and I gave most of it away, focusing on battery-powered portable kit instead, partly because it&#39;s interesting in its own way, and partly because it doesn&#39;t take up much room. You don&#39;t need to keep big screens and keyboards around.</p>
<p>That led me to an interesting machine: the <em>other</em> line of Apple computers, the ones that Steve Jobs had no hand in at all.</p>
<p>The machine that inspired Jobs, which led to the Lisa and then the Mac, was of course <a target="_blank" href="https://www.theregister.com/2023/03/16/the_xerox_alto_50_years/">the Xerox Alto</a>, a $30,000 deskside workstation. In Jobs&#39; own words, he saw three amazing technologies that day, but he was so dazzled by one of them that he missed the other two. He was so impressed by the GUI that he missed the object-oriented graphical programming language, Smalltalk, and the Alto&#39;s <a target="_blank" href="https://www.theregister.com/2023/06/30/ethernet_50th_birthday/">built-in ubiquitous networking, Ethernet</a>.</p>
<p>The Lisa had none of that. The Mac had less. Apple spent much of the next 20 years trying to put them back. In that time, Steve Jobs hired John Sculley from PepsiCo to run Apple, and in return, Sculley fired Jobs. What Apple came up with during Sculley&#39;s reign was <a target="_blank" href="https://www.theregister.com/2010/07/26/newton_messagepad_120/">the Newton</a>.</p>
<p>I have two Newtons, an Original MessagePad and a 2100. I love them. They&#39;re a vision of a different future. But I never used them much: <a target="_blank" href="https://www.theregister.com/2014/03/07/bugger_my_jetpack_wheres_my_21stcentury_psion/?page=2">I used Psions</a>, which had a far simpler and less ambitious design, meaning that they were cheaper but did the job. This should be an industry proverb.</p>
<p>The Newton that shipped was a pale shadow of the Newton that Apple originally planned. There are traces of that machine out there, though, and that&#39;s what led to me uncovering the great computing war.</p>
<p>The Newton was – indeed, still is – a radical machine. It&#39;s designed to live in your pocket, store and track your information and habits. It had an address book, a diary, a note-taking app, astonishing handwriting recognition, and a primitive AI assistant. You could write &#34;lunch with Alice&#34; on the screen, and it would work out what you wrote, analyze it, work out from your diary when you normally had lunch, from your call history where you took lunch most often and which Alice you contacted most often, book a time slot in your diary and send her a message to ask her if she&#39;d like to come.</p>
<p>It was something like Siri, but 20 years earlier, and in that time, Apple seems to have forgotten all this: It had to buy Siri in.</p>
<p>NewtonOS also had no file system. I don&#39;t mean it wasn&#39;t visible to the user; I mean there wasn&#39;t one. It had some non-volatile memory on board, expandable via memory cards – huge PCMCIA ones the size of half-centimetre-thick credit cards – and it kept stuff in a sort of OS-integrated object database, segregated by function. The stores were called &#34;soups&#34; and the OS kept track of what was stored where. No file names, no directories, nothing like that at all.</p>
<p>Apps, and some of the OS itself, were written in a language called NewtonScript, which is very distantly related to both AppleScript on modern macOS and JavaScript. But that was not the original plan. That was for a far more radical OS, in a more radical language, one that could be developed in an astounding graphical environment.</p>
<p>The language was called <a target="_blank" href="https://www.schneier.com/essays/archives/1992/09/dylan_a_new_language.html" rel="nofollow">Dylan</a>, which is short for Dynamic Language. It <a target="_blank" href="https://opendylan.org/" rel="nofollow">still exists</a> as a FOSS compiler. Apple seems to have forgotten about it too, because it reinvented that wheel, worse, with Swift.</p>
<p>Have a look. Dylan is amazing, and its <a target="_blank" href="https://opendylan.org/history/apple-dylan/eulogy.html" rel="nofollow">SK8 IDE</a> even more so (a few <a target="_blank" href="https://www.macintoshrepository.org/2625-apple-sk8" rel="nofollow">screenshots and downloads</a> are left). Dylan is very readable, very high-level, and before the commercial realities of time and money prevailed, Apple planned to write an OS, and the apps for that OS, in Dylan.</p>
<p>Now <em>that</em> is radical: Using the same, very high-level, language for both the OS and the apps. It was feasible because Dylan is built as a layer on top of one of the oldest programming languages that&#39;s still in active use, Lisp.</p>
<p>Both Smalltalk and Lisp are very much still around. For both, there are commercial and FOSS versions. Both can run on the .NET CLR and on the JVM. There&#39;s even a Smalltalk that <a target="_blank" href="https://amber-lang.net/" rel="nofollow">runs in your browser</a> on the JavaScript engine. The primary text editor of the Lisp environment is still widely used today, mostly by old-timers.</p>
<p>But these are only traces. They are faint memorials left after the war. Because once, these things were not just slightly weird languages that ran on commodity OSes.</p>
<h3>They were OSes in their own right</h3>
<p>I started digging into that, and that&#39;s when the ground crumbled away, and I found that, like some very impressive CGI special effects, I wasn&#39;t excavating a graveyard but a whole, hidden, ruined city.</p>
<p>Once, Lisp ran on the bare metal, on purpose-built computers that ran operating systems written in Lisp, ones with GUIs that could connect to the internet.</p>
<p>And if you find the people who used Lisp machines ... wow. They loved them, with a passion that makes Amiga owners look like, well, amateurs, hobbyists. This level of advocacy makes Vi versus Emacs look like a playground squabble.</p>
<p>Some of the references are easy to find. There&#39;s a wonderful book called <a target="_blank" href="https://web.mit.edu/~simsong/www/ugh.pdf" rel="nofollow">The Unix-Haters Handbook</a> [PDF] which I highly recommend. It&#39;s easy to read and genuinely funny. It&#39;s a digest of a long-running internet community from the time when universities were getting rid of Lisp machines and replacing them with cheaper, faster Unix workstations – Sun boxes and things like that.</p>
<p>Lisp machine users were not impressed. For them, Unix was a huge step <em>backwards</em>. The code was all compiled, whereas Lisp OSes ran a sort of giant shared dynamic environment (it&#39;s hard to explain something when the words for it have been lost). On a Unix machine, if you didn&#39;t like the way a program did something, you had to go find the source code, edit it, save it in a new file, compile that file, restart the program to try it ... and if it worked, find your existing binary, and replace it with the new one. Then you would probably find that you&#39;d made a mistake and it didn&#39;t work, and try again.</p>
<p>This is why, apart from the hardcore Gentoo users, we all outsource this stuff to OS vendors and Linux distributors.</p>
<p>On the Lisp machines, your code wasn&#39;t trapped inside frozen blocks. You could just edit the live running code and the changes would take effect immediately. You could inspect or even change the values of variables, as the code ran. Developer and blogger Steve Yegge called it &#34;<a target="_blank" href="https://steve-yegge.blogspot.com/2007/01/pinocchio-problem.html" rel="nofollow">living software</a>.&#34;</p>
<p>Lisp machines booted slowly, but that didn&#39;t matter much because you rarely cold booted them. At the end of the day, the OS wrote the values of all its objects and variables to disk – called &#34;saving a world&#34; – and then just stopped. When you turned it back on, it reread these values into memory, and resumed exactly where it was.</p>
<p>Most of this, incidentally, also applies to Smalltalk machines. That&#39;s why these two are sometimes called <a target="_blank" href="http://onsmalltalk.com/languages-of-the-gods" rel="nofollow">languages of the gods</a>.</p>
<p><em>This</em> is what Steve Jobs missed. He was distracted by the shiny. He brought the world the GUI, but he got his team to reimplement it on top of fairly conventional OSes, originally in a mixture of assembly and Pascal.</p>
<p>He left behind the amazing rich development environment, where it was objects all the way down.</p>
<h3>And we never got it back</h3>
<p>We got networking back, sure, but not this.</p>
<p>Now Lisp and Smalltalk are just niche languages – but once, both of them were whole other universes. Full-stack systems, all live, all dynamic, all editable on the fly.</p>
<p>The closest thing we have today is probably JavaScript apps running in web browsers, and they are crippled little things by comparison.</p>
<p>The difference, though, is where the biggest losses in the war came.</p>
<p>Smalltalk machines ran on relatively normal processors. Smalltalk is all about objects, and you can&#39;t really handle objects at hardware level.</p>
<p>(Well, you <em>can</em> – a very expensive Hi-Fi manufacturer called <a target="_blank" href="https://www.theregister.com/2023/07/10/jony_ive_linn_turntable/">Linn</a> tried with a machine called the Rekursiv, but it flopped badly. So did Intel&#39;s attempt to do a chip that implemented high-level stuff in hardware – not the Itanium, no, long before that, the iAPX 432.)</p>
<p>But <a target="_blank" href="https://www.lispmachine.net/" rel="nofollow">Lisp machines</a> ran on dedicated chips, and this is where stuff gets real. As in, the <em>stuff</em> that hits the fan.</p>
<p>There were several big vendors of Lisp machines. As <a target="_blank" href="https://www.theregister.com/2023/11/23/medley_interlisp_revival/">we covered recently</a>, Xerox sold them, and its Lisp OS is now FOSS.</p>
<p>But the bigger one, and the most influential, was <a target="_blank" href="https://www.ifis.uni-luebeck.de/~moeller/symbolics-info/index.html" rel="nofollow">Symbolics</a>. At risk of sounding like a hipster, &#34;you&#39;ve probably never heard of it.&#34; Forgotten as it is now, as an indication of how significant the company was, it owned <a target="_blank" href="https://www.theguardian.com/media/pda/2008/dec/22/internet-domains" rel="nofollow">the first ever dot-com domain</a> on the internet. It launched in 1980 with a commercial version of the <a target="_blank" href="https://www.theregister.com/2023/03/31/mit_cadr_software_recovered/">MIT CADR Lisp machine</a>, and made dedicated Lisp hardware until 1993.</p>
<ul>

<li><a href="https://www.theregister.com/2023/11/23/medley_interlisp_revival/">Revival of Medley/Interlisp: Elegant weapon for a more civilized age sharpened up again</a></li>

<li><a href="https://www.theregister.com/2023/03/31/mit_cadr_software_recovered/">Version 100 of the MIT Lisp Machine software recovered</a></li>

<li><a href="https://www.theregister.com/2023/02/16/bulletproof_linux/">The quest to make Linux bulletproof</a></li>

<li><a href="https://www.theregister.com/2022/09/16/rust_in_the_linux_kernel/">Linux luminaries discuss efforts to bring Rust to the kernel</a></li>
</ul>
<p>The company&#39;s dead, but the OS, OpenGenera, is still <a target="_blank" href="https://archive.org/details/OpenGenera" rel="nofollow">out there</a> and you can <a target="_blank" href="https://jaoswald.blogspot.com/2020/05/open-genera-vlm-on-linux.html" rel="nofollow">run it on an emulator</a> on Linux. It&#39;s the end result of several decades of totally separate evolution from the whole Mac/Windows/Unix world, so it&#39;s kind of arcane, but it&#39;s out there.</p>
<p>There are a lot of accounts of the power and the productivity possible in Lisp and on Lisp machines.</p>
<p>One of the more persuasive is from a man called Kalman Reti, the last working Symbolics engineer. So loved are these machines that people are still working on their 30-year-old hardware, and Reti maintains them. He&#39;s made some YouTube videos demonstrating OpenGenera on Linux.</p>
<p>He <a target="_blank" href="https://docs.google.com/file/d/0Bw4Wz8Ir0pl1cmNRaHYwdU1wdXM/" rel="nofollow">talks about</a> [video] the process of implementing the single-chip Lisp machine processors.</p>

<p>Now that is significant.</p>
<p>When different people tell you that they can achieve such a huge differential in productivity – one tenth of the people taking one tenth of the time to do the same job – you have to pay attention.</p>
<p>
  <a href="https://youtu.be/OBfB2MJw3qg?si=kLqyzm4v19TCYrdB" data-media="x-videoplayer">Youtube Video</a>
</p>
<h3>&#39;Better is the enemy of good&#39;</h3>
<p>I am <em>not</em> here to tell you that Lisp machines were some ultimate super workstation. An environment that is mostly semi-interpreted code, running in a single shared memory space, is not very stable ... and when it crashes, if you don&#39;t have a snapshot to go back to, you have pain in store.</p>
<p>The point here is not that this long-gone technology was better in every way. It wasn&#39;t. But it did have advantages, and it&#39;s instructive to look at some of these that were shared by both Lisp and Smalltalk machines.</p>
<p>They were written in one language, or mostly in one, all the way down. As original Smalltalk implementer Dan Ingalls put it: &#34;An operating system is a collection of things that don&#39;t fit inside a language; there shouldn&#39;t be one.&#34;</p>
<p>They had a pervasive model of data, all the way down the stack. In Smalltalk, everything is objects. In Lisp, everything is lists. What the Unix model offers by comparison is weak stuff: Everything is a file.</p>
<h3>More big lies</h3>
<p>The Unix model of computation was designed in response to Multics, the original all-singing, all-dancing 1960s OS. Unix was intended, in contrast, to be the ultimate in minimalism (although it very much is not anymore).</p>
<p>This shows up another of the big lies that everyone just takes as read, but this one has layers like a cabbage:</p>
<ul>
<li>For speed, you need a language that&#39;s close to the metal. That means it must be very simple. This has costs, but they&#39;re worth it: the programmer must manually manage their memory, meaning that they must be very, <em>very</em> careful.</li>

<li>But that&#39;s hard, so to keep life easier, you layer simpler languages on top. Early on, AWK and SED and so on; later, Perl and Python; then later still, runtimes such as the JVM and WASM, and languages on top of that, such as Clojure or Scala.</li>

<li>As the stack matures, it grows ever more layers. The higher layers are ever further from the metal.</li>

<li>Many of these languages are much easier but slower. In the old days, you needed to rewrite code in a lower-level language for speed, such as C++. So what if it&#39;s huge? You don&#39;t need all of it! So what if it&#39;s hard to read? It was hard to write!</li>

<li>Then, in time, computers keep getting faster, so you can retain the inefficient implementation and keep going.</li>
</ul>
<p>The result is a folk belief that there is a necessary, implicit contrast between &#34;readable&#34; and &#34;fast.&#34; This is one of the big assumptions behind both the Unix and Windows schools of OS design, that different languages are best for different jobs, and so you need a mixture of them. That means that the layers are sealed off from one another, because of different models of variable storage, of memory management, etc.</p>
<p>That&#39;s one big lie.</p>
<p>Firstly, because the layers are <em>not</em> sealed off: higher-level languages are usually implemented in lower-level ones, and vulnerabilities in those permeate the stack.</p>
<p>For instance, a common way of trying to make stuff safer is to wrap it in a runtime or VM, but that doesn&#39;t solve the problem, it creates new ones. Problem: The language eliminates whole types of error, but they persist in the VM. Problem: Now, your code is dependent on the performance of the VM. Problem: Try to fix either of these, you risk breaking the code. Problem: Because the VM isn&#39;t part of the OS, you end up with multiple VMs, all sharing these issues.</p>
<p>Secondly, there is the <a target="_blank" href="https://sites.millersville.edu/bikenaga/math-proof/existence-proofs/existence-proofs.html" rel="nofollow">existence proof</a> that multiple projects and products, successful in their time, show that if you pick the right language, you can built your entire stack all in one.</p>
<p>Lisp code is structured as lists, which is the data structure that Lisp is designed to manipulate. That is the reason for its <a target="_blank" href="https://toggl.com/blog/save-princess-8-programming-languages" rel="nofollow">legendary plethora of parentheses</a>. It also makes it very easy to write macros that manipulate program code, meaning programs can modify themselves. This sort of thing is why Neal Stephenson <a target="_blank" href="https://web.stanford.edu/class/cs81n/command.txt" rel="nofollow">referred to it</a> thus:</p>

<p>It is highly readable, and vastly powerful. Alan Kay, the designer of Smalltalk, <a target="_blank" href="https://queue.acm.org/detail.cfm?id=1039523" rel="nofollow">said of Lisp</a>:</p>

<p>These are powerful qualities – but possibly only to a certain type of mind.</p>
<p>Dylan, however, shows that it need not be like that. If you lose the list-based notation, yes, there is a price in efficiency and power, but the result is readable by mere mortals. Dylan was not the only attempt to do this. There are quite a few – <a target="_blank" href="http://users.rcn.com/david-moon/PLOT/" rel="nofollow">PLOT</a>, <a target="_blank" href="https://dspace.mit.edu/handle/1721.1/41951" rel="nofollow">CGOL</a>, <a target="_blank" href="https://readable.sourceforge.io/" rel="nofollow">sweet expressions</a>, the cancelled <a target="_blank" href="https://dl.acm.org/doi/abs/10.1145/1464291.1464362" rel="nofollow">Lisp 2 project</a>, and more.</p>
<p>The plan was that the Newton would be a Dylan-based Lisp machine in your pocket. The Newton was Sculley&#39;s baby. Jobs didn&#39;t invent it, so he didn&#39;t like it, derided it as a &#34;<a target="_blank" href="https://allthingsd.com/20120113/former-apple-ceo-says-newton-scribble-thing-was-15-years-ahead-of-its-time/" rel="nofollow">scribble thing</a>,&#34; and on his return to Apple he killed it <a target="_blank" href="http://www.loper-os.org/?p=568" rel="nofollow">along with Hypercard</a>.</p>
<p>In 1993, the Newton was Apple&#39;s first Arm-powered computer, a CPU architecture it returned to 17 years later. It was planned to be the a pocket Lisp workstation, and it launched the same year that Symbolics quit making Lisp processors and <a target="_blank" href="http://pt.withington.org/publications/VLM.pdf" rel="nofollow">moved to the DEC Alpha</a> [PDF] instead.</p>
<p>In the end, the big fight was between dedicated hardware, with custom processors running custom operating systems, versus a shared, lowest-common-denominator technology: UNIX, running at first on off-the-shelf chips such as the <a target="_blank" href="https://www.historyofinformation.com/detail.php?id=960" rel="nofollow">Sun-1&#39;s Motorola 68000</a> and later on RISC chips such as Sun&#39;s SPARC and the MIPS R2000, launched the same year as <a target="_blank" href="https://www.theregister.com/2022/06/21/risc_os_35/">Acorn&#39;s RISC OS 2 on its ARM chips</a>. A cross-platform OS, its development sponsored by Bell Labs and refined at the University of California, compiled from source written in a <a target="_blank" href="https://www.theregister.com/2020/05/15/algol_60_at_60/">cut-down form of BCPL</a>.</p>
<p>As is usually the way, the cheaper, simpler solution won. Commodity chips were replaced with faster RISC chips, broadly speaking designed to run compiled C code efficiently. Then, decades later, the PC caught up: 32-bit x86 processors became comparable in performance to the RISC chips, and we ended up with a few varieties of Unix on x86, plus Windows NT. Unix, of course, was originally developed on the DEC PDP-7, moved to the PDP-11, and later its 32-bit successor the VAX. Windows NT, meanwhile, was <a target="_blank" href="https://www.theregister.com/2023/10/30/arm_intel_comment/">designed by the chief architect</a> of the VAX&#39;s native OS, VMS. That&#39;s why it&#39;s so visibly influenced by it. Instead of DEC&#39;s BLISS language, NT is implemented in Unix&#39;s native language, C.</p>
<p>From the perspective of a Smalltalk or Lisp machine, they are siblings, almost twins, with deep roots in DEC. They are representatives of a school of design called the &#34;New Jersey approach&#34; by Lisp luminary Richard Gabriel in his essay &#34;<a target="_blank" href="https://www.dreamsongs.com/Files/LispGoodNewsBadNews.pdf" rel="nofollow">Lisp: Good News, Bad News, How to Win Big</a>&#34; [PDF]. He compares it to what he calls the &#34;MIT approach,&#34; and his summary of the New Jersey way is called &#34;<a target="_blank" href="https://www.dreamsongs.com/RiseOfWorseIsBetter.html" rel="nofollow">Worse is Better</a>.&#34;</p>
<p>It&#39;s well worth reading at least the summary, but the key points are this.</p>

<p>He continues:</p>

<p>The conclusion, though, is the stinger:</p>

<p>Time has certainly proved Dr Gabriel correct. Systems of the New Jersey school so dominate the modern computing industry that the <em>other</em> way of writing software is banished to a tiny niche.</p>
<p>Smalltalk evolved into Self, which begat JavaScript, which in the hands of a skilled Smalltalker <a target="_blank" href="https://www.theregister.com/2023/03/23/croquet_for_unity/">can do amazing things</a> – but only its visual design transformed the computer industry.</p>
<p>The Lisp text editor is now just one of the more arcane options on Linux boxes. Lisp itself is a fringe programming language, <a target="_blank" href="http://www.paulgraham.com/avg.html" rel="nofollow">beloved by some industry heroes</a> but ignored by most – even those who <a target="_blank" href="https://flownet.com/gat/jpl-lisp.html" rel="nofollow">need the very best tools</a>. As one famous Lisp programmer <a target="_blank" href="https://www.marktarver.com/bipolar.html" rel="nofollow">put it</a>:</p>

<p>If you want to become a billionaire from software, you don&#39;t want rockstar geniuses; you need <a target="_blank" href="http://www.loper-os.org/?p=69" rel="nofollow">fungible cogs</a>, interchangeable and inexpensive.</p>
<p>Software built with tweezers and glue is not robust, no matter how many layers you add. It&#39;s terribly fragile, and needs armies of workers constantly fixing its millions of cracks and holes.</p>
<p>There was once a better way, but it lost out to cold hard cash, and now, only a few historians even remember it existed. ®</p>
<h3>Bootnote</h3>
<p>For a look at a Lisp machine in action, as well as BTRON and IBM i, this talk from the Chaos Computer Congress entitled &#34;<a target="_blank" rel="nofollow" href="https://media.ccc.de/v/rc3-525180-what_have_we_lost#l=eng&amp;t=0">What have we lost?</a>&#34; is worth a watch.</p>                                
                    </div></div>
  </body>
</html>
