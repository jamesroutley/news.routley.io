<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/TheAppleTucker/backend-GPT">Original</a>
    <h1>GPT is all you need for the back end</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/TheAppleTucker/backend-GPT/blob/main/LLM-IS-BACKEND.jpeg"><img src="https://github.com/TheAppleTucker/backend-GPT/raw/main/LLM-IS-BACKEND.jpeg" alt="Galaxy brain meme (a) Writing a backend (b) hiring a backend engineer (c) Asking ChatGPT for a backend (d) The LLM is the backend"/></a></p>
<p dir="auto">People have been saying Github Copilot will replace programmers. We think that&#39;s wrong. We have all powerful models and we want to restrict them to writing code? All code has bugs!</p>
<p dir="auto">Code is not the ideal way to encode business logic. Code must be reviewed, and it does what you tell it, not what you want. The proper format for business logic is human intelligence.</p>
<p dir="auto">So we thought, who needs python and ec2s and biz logic and postgres?</p>
<p dir="auto">We&#39;ve built a entire Backend+Database powered by an LLM. It infers business logic based on the name of the API call and can persist a kilobyte of state!</p>
<p dir="auto">Here&#39;s the experience of the future:</p>
<ol dir="auto">
<li>Instruct the LLM on the purpose of the backend (i.e. &#34;This is a todo list app&#34;)</li>
<li>Write the initial json blob for the database state (i.e. {todo_items: [{title: &#34;eat breakfast&#34;, completed: true}, {title: &#34;go to school&#34;, completed: false}]}</li>
<li>Start making API calls! You now have infinite backend endpoints that will infer their own business logic and update the persistent state!</li>
</ol>
<h2 dir="auto"><a id="user-content-why" aria-hidden="true" href="#why"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why</h2>
<p dir="auto">This is the future we imagine</p>
<ol dir="auto">
<li>You can iterate on your frontend without knowing exactly what the backend needs to look like.</li>
<li>Backend gives you the wrong format? <code>https://backend-gpt.com/chess/get_board_state()</code> -&gt; <code>https://backend-gpt.com/chess/get_board_state_as_fen()</code></li>
<li>Mistype an API name? It doesn&#39;t matter!</li>
<li>Serverless w/o the cold start: The only difference between your server and someone elses is the 1KB of state and the LLM instructions, these can be swapped out in milliseconds</li>
</ol>
<h2 dir="auto"><a id="user-content-still-dont-get-it" aria-hidden="true" href="#still-dont-get-it"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Still don&#39;t get it?</h2>
<p dir="auto">Here&#39;s how it works in Parker&#39;s words</p>
<p dir="auto">We basically used GPT to handle all the backend logic for a todo-list app. We represented the state of the app as a json with some prepopulated entries which helped define the schema. Then we pass the prompt, the current state, and some user-inputted instruction/API call in and extract a response to the client + the new state. So the idea is that instead of writing backend routes, the LLM can handle all the basic CRUD logic for a simple app so instead of writing specific routes, you can input commands like add_five_housework_todos() or delete_last_two_todos() or sort_todos_alphabetically() . It tends to work better when the commands are expressed as functions/pseudo function calls but natural language instructions like delete last todos also work.</p>
</article>
          </div></div>
  </body>
</html>
