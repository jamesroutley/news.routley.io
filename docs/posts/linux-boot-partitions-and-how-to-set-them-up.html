<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0pointer.net/blog/linux-boot-partitions.html">Original</a>
    <h1>Linux boot partitions and how to set them up</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<p><em>Let’s have a look how traditional Linux distributions set up
<code>/boot/</code> and the ESP, and how this could be improved.</em></p>
<p>How Linux distributions traditionally have been setting up their
“boot” file systems has been varying to some degree, but the most
common choice has been to have a separate partition mounted to
<code>/boot/</code>. Usually the partition is formatted as a Linux file system
such as ext2/ext3/ext4. The partition contains the kernel images, the
initrd and various boot loader resources. Some distributions, like
Debian and Ubuntu, also store ancillary files associated with the
kernel here, such as <code>kconfig</code> or <code>System.map</code>. Such a traditional
boot partition is only defined within the context of the distribution,
and typically not immediately recognizable as such when looking just
at the partition table (i.e. it uses the generic Linux partition type
UUID).</p>
<p>With the arrival of UEFI a new partition relevant for boot appeared,
the <em>EFI System Partition</em> (ESP). This partition is defined by the
firmware environment, but typically accessed by Linux to install or
update boot loaders. The choice of file system is not up to Linux, but
effectively mandated by the UEFI specifications: vFAT. In theory it
could be formatted as other file systems too. However, this would
require the firmware to support file systems other than vFAT. This is
rare and firmware specific though, as vFAT is the only file system
mandated by the UEFI specification. In other words, vFAT is the only
file system which is guaranteed to be universally supported.</p>
<p>There’s a major overlap of the type of the data typically stored in
the ESP and in the traditional boot partition mentioned earlier: a
variety of boot loader resources as well as kernels/initrds.</p>
<p>Unlike the traditional boot partition, the ESP is easily recognizable
in the partition table via its GPT partition type UUID. The ESP is
also a <em>shared resource</em>: all OSes installed on the same disk will
share it and put their boot resources into them (as opposed to the
traditional boot partition, of which there is one per installed Linux
OS, and only that one will put resources there).</p>
<p>To summarize, the most common setup on typical Linux distributions is
something like this:</p>
<table>
  <tbody><tr>
   <th>Type</th>
   <th>Linux Mount Point</th>
   <th>File System Choice</th>
  </tr>
  <tr>
   <td>Linux “Boot” Partition</td>
   <td><code>/boot/</code></td>
   <td>Any Linux File System, typically ext2/ext3/ext4</td>
  </tr>
  <tr>
   <td>ESP</td>
   <td><code>/boot/efi/</code></td>
   <td>vFAT</td>
  </tr>
</tbody></table>

<p>As mentioned, not all distributions or local installations agree on
this. For example, it’s probably worth mentioning that some
distributions decided to put kernels onto the root file system of the
OS itself. For this setup to work the boot loader itself [sic!] must
implement a non-trivial part of the storage stack. This may have to
include RAID, storage drivers, networked storage, volume management,
disk encryption, and Linux file systems. Leaving aside the conceptual
argument that complex storage stacks don’t belong in boot loaders
there are very practical problems with this approach. Reimplementing
the Linux storage stack in all its combinations is a massive amount of
work. It took decades to implement what we have on Linux now, and it
will take a similar amount of work to catch up in the boot loader’s
reimplementation. Moreover, there’s a political complication: some
Linux file system communities made clear they have no interest in
supporting a second file system implementation that is not maintained
as part of the Linux kernel.</p>
<p>What’s interesting is that the <code>/boot/efi/</code> mount point is nested
below the <code>/boot/</code> mount point. This effectively means that to access
the ESP the Boot partition must exist and be mounted first. A system
with just an ESP and without a Boot partition hence doesn’t fit well
into the current model. The Boot partition will also have to carry an
empty “efi” directory that can be used as the inner mount point, and
serves no other purpose.</p>
<p>Given that the traditional boot partition and the ESP may carry
similar data (i.e. boot loader resources, kernels, initrds) one may
wonder why they are separate concepts. Historically, this was the
easiest way to make the pre-UEFI way how Linux systems were booted
compatible with UEFI: conceptually, the ESP can be seen as just a
minor addition to the status quo ante that way. Today, primarily two
reasons remained:</p>
<ul>
<li>
<p>Some distributions see a benefit in support for complex Linux file
  system concepts such as hardlinks, symlinks, SELinux labels/extended
  attributes and so on when storing boot loader resources. – I
  personally believe that making use of features in the boot file
  systems that the firmware environment cannot really make sense of is
  very clearly not advisable. The UEFI file system APIs know no
  symlinks, and what is SELinux to UEFI anyway? Moreover, putting more
  than the absolute minimum of simple data files into such file
  systems immediately raises questions about how to authenticate them
  comprehensively (including all fancy metadata) cryptographically on
  use (see below).</p>
</li>
<li>
<p>On real-life systems that ship with non-Linux OSes the ESP often
  comes pre-installed with a size too small to carry multiple Linux
  kernels and initrds. As growing the size of an existing ESP is
  problematic (for example, because there’s no space available
  immediately after the ESP, or because some low-quality firmware
  reacts badly to the ESP changing size) placing the kernel in a
  separate, secondary partition (i.e. the boot partition) circumvents
  these space issues.</p>
</li>
</ul>
<h2>File System Choices</h2>
<p>We already mentioned that the ESP effectively has to be vFAT, as that
is what UEFI (more or less) guarantees. The file system choice for the
boot partition is not quite as restricted, but using arbitrary Linux
file systems is not really an option either. The file system must be
accessible by both the boot loader and the Linux OS. Hence only file
systems that are available in both can be used. Note that such
secondary implementations of Linux file systems in the boot
environment – limited as they may be – are not typically welcomed
or supported by the maintainers of the canonical file system
implementation in the upstream Linux kernel. Modern file systems are
notoriously complicated and delicate and simply don’t belong in boot
loaders.</p>
<p>In a trusted boot world, the two file systems for the ESP and the
<code>/boot/</code> partition should be considered <em>untrusted</em>: any code or
essential data read from them must be authenticated cryptographically
before use. And even more, the file system structures themselves are
also untrusted. The file system driver reading them must be careful
not to be exploitable by a rogue file system image. Effectively this
means a simple file system (for which a driver can be more easily
validated and reviewed) is generally a better choice than a complex
file system (Linux file system communities made it pretty clear that
robustness against rogue file system images is outside of their scope
and not what is being tested for.).</p>
<p>Some approaches tried to address the fact that boot partitions are
untrusted territory by encrypting them via a mechanism compatible to
LUKS, and adding decryption capabilities to the boot loader so it can
access it. This misses the point though, as encryption does not imply
authentication, and only authentication is typically desired. The boot
loader and kernel code are typically Open Source anyway, and hence
there’s little value in attempting to keep secret what is already
public knowledge. Moreover, encryption implies the existence of an
encryption key. Physically typing in the decryption key on a keyboard
might still be acceptable on desktop systems with a single human user
in front, but outside of that scenario unlock via TPM, PKCS#11 or
network services are typically required. And even on the desktop FIDO2
unlocking is probably the future. Implementing all the technologies
these unlocking mechanisms require in the boot loader is not
realistic, unless the boot loader shall become a full OS on its own as
it would require subsystems for FIDO2, PKCS#11, USB, Bluetooth
network, smart card access, and so on.</p>
<h2>File System Access Patterns</h2>
<p>Note that traditionally both mentioned partitions were read-only
during most parts of the boot. Only later, once the OS is up, write
access was required to implement OS or boot loader updates. In today’s
world things have become a bit more complicated. A modern OS might
want to require some limited write access already in the boot loader,
to implement boot counting/boot assessment/automatic fallback (e.g.,
if the same kernel fails to boot 3 times, automatically revert to
older kernel), or to maintain an early storage-based random seed. This
means that even though the file system is <em>mostly read-only,</em> we need
limited write access after all.</p>
<p>vFAT cannot compete with modern Linux file systems such as <code>btrfs</code>
when it comes to data safety guarantees. It’s not a journaled file
system, does not use CoW or any form of checksumming. This means when
used for the system boot process we need to be particularly careful
when accessing it, and in particular when making changes to it (i.e.,
trying to keep changes local to single sectors). It is essential to
use write patterns that minimize the chance of file system
corruption. Checking the file system (“<code>fsck</code>”) before modification
(and probably also reading) is important, as is ensuring the file
system is put into a “clean” state as quickly as possible after each
modification.</p>
<p>Code quality of the firmware in typical systems is known to not always
be great. When relying on the file system driver included in the
firmware it’s hence a good idea to limit use to operations that have a
better chance to be correctly implemented. For example, when writing
from the UEFI environment it might be wise to avoid any operation that
requires allocation algorithms, but instead focus on access patterns
that only override already written data, and do not require allocation
of new space for the data.</p>
<p>Besides write access from the boot loader code (as described above)
these file systems will require write access from the OS, to
facilitate boot loader and kernel/initrd updates. These types of
accesses are generally not fully random accesses (i.e., never partial
file updates) but usually mean adding new files as whole, and removing
old files as a whole. Existing files are typically not modified once
created, though they might be replaced wholly by newer versions.</p>
<h2>Boot Loader Updates</h2>
<p>Note that the update cycle frequencies for boot loaders and for
kernels/initrds are probably similar these days. While kernels are
still vastly more complex than boot loaders, security issues are
regularly found in both. In particular, as boot loaders (through
“shim” and similar components) carry certificate/keyring and denylist
information, which typically require frequent updates. Update cycles
hence have to be expected regularly.</p>
<h2>Boot Partition Discovery</h2>
<p>The traditional boot partition was not recognizable by looking just at
the partition table. On MBR systems it was directly referenced from
the boot sector of the disk, and on EFI systems from information
stored in the ESP. This is less than ideal since by losing this
entrypoint information the system becomes unbootable. It’s typically a
better, more robust idea to make boot partitions recognizable as such
in the partition table directly. This is done for the ESP via the GPT
partition type UUID. For traditional boot partitions this was not done
though.</p>
<h2>Current Situation Summary</h2>
<p>Let’s try to summarize the above:</p>
<ul>
<li>
<p>Currently, typical deployments use <strong>two distinct boot partitions</strong>,
  often using two distinct file system implementations</p>
</li>
<li>
<p>Firmware effectively dictates existence of the ESP, and the use of
  <strong>vFAT</strong></p>
</li>
<li>
<p>In userspace view: the ESP <strong>mount is nested</strong> below the general
  Boot partition mount</p>
</li>
<li>
<p>Resources stored in both partitions are primarily kernel/initrd, and
  boot loader resources</p>
</li>
<li>
<p>The mandatory use of vFAT brings certain <strong>data safety challenges</strong>,
  as does quality of firmware file system driver code</p>
</li>
<li>
<p><strong>During boot limited write access</strong> is needed, during OS runtime
  more comprehensive write access is needed (though still not fully
  random).</p>
</li>
<li>
<p>Less restricted but still <strong>limited write patterns from OS
  environment</strong> (only full file additions/updates/removals, during
  OS/boot loader updates)</p>
</li>
<li>
<p>Boot loaders should not implement complex storage stacks.</p>
</li>
<li>
<p>ESP can be <strong>auto-discovered</strong> from the partition table, traditional
  boot partition cannot.</p>
</li>
<li>
<p>ESP and the traditional boot partition are not protected
  cryptographically neither in structure nor contents. It is expected
  that loaded files are individually authenticated after being read.</p>
</li>
<li>
<p>The ESP is a <strong>shared resource</strong> — the traditional boot partition a
  resource specific to each installed Linux OS on the same disk.</p>
</li>
</ul>
<h2>How to Do it Better</h2>
<p>Now that we have discussed many of the issues with the status quo ante, let’s see how we can do things better:</p>
<ul>
<li>
<p>Two partitions for essentially the same data is a bad idea. Given
  they carry data very similar or identical in nature, the common case
  should be to have only one (but see below).</p>
</li>
<li>
<p>Two file system implementations are worse than one. Given that vFAT
  is more or less mandated by UEFI and the only format universally
  understood by all players, and thus has to be used anyway, it might
  as well be the only file system that is used.</p>
</li>
<li>
<p>Data safety is unnecessarily bad so far: both ESP and boot partition
  are continuously mounted from the OS, even though access is pretty
  restricted: outside of update cycles access is typically not
  required.</p>
</li>
<li>
<p>All partitions should be auto-discoverable/self-descriptive</p>
</li>
<li>
<p>The two partitions should not be exposed as nested mounts to userspace</p>
</li>
</ul>
<p>To be more specific, here’s how I think a better way to set this all up would look like:</p>
<ul>
<li>
<p>Whenever possible, only have <strong>one boot partition</strong>, not two. On EFI
  systems, make it the ESP. On non-EFI systems use an XBOOTLDR
  partition instead (see below). Only have both in the case where a
  Linux OS is installed on a system that already contains an OS with
  an ESP that is too small to carry sufficient kernels/initrds. When a
  system contains a XBOOTLDR partition put kernels/initrd on that,
  otherwise the ESP.</p>
</li>
<li>
<p>Instead of the vaguely defined, traditional Linux “boot” partition
  use the <strong>XBOOTLDR</strong> partition type as defined by the <a href="https://uapi-group.org/specifications/specs/discoverable_partitions_specification/">Discoverable
  Partitions
  Specification</a>. This
  ensures the partition is discoverable, and can be automatically
  mounted by things like
  <a href="https://www.freedesktop.org/software/systemd/man/systemd-gpt-auto-generator.html"><code>systemd-gpt-auto-generator</code></a>. Use
  XBOOTLDR only if you have to, i.e., when dealing with systems that
  lack UEFI (and where the ESP hence has no value) or to address the
  mentioned size issues with the ESP. Note that unlike the traditional
  boot partition the XBOOTLDR partition is a shared resource, i.e.,
  shared between multiple parallel Linux OS installations on the same
  disk. Because of this it is typically wise to place a per-OS
  directory at the top of the XBOOTLDR file system to avoid conflicts.</p>
</li>
<li>
<p>Use <strong>vFAT</strong> for both partitions, it’s the only thing
  universally understood among relevant firmwares and Linux. It’s
  simple enough to be useful for untrusted storage. Or to say this
  differently: writing a file system driver that is not easily
  vulnerable to rogue disk images is much easier for vFAT than for
  let’s say btrfs. – But the choice of vFAT implies some care needs to
  be taken to address the data safety issues it brings, see below.</p>
</li>
<li>
<p>Mount the two partitions via the “<strong>automount</strong>”
  logic. For example, via systemd’s
  <a href="https://www.freedesktop.org/software/systemd/man/systemd.automount.html">automount</a>
  units, with a very short idle time-out (one second or so). This
  improves data safety immensely, as the file systems will remain
  mounted (and thus possibly in a “dirty” state) only for very short
  periods of time, when they are actually accessed – and all that
  while the fact that they are not mounted continuously is mostly not
  noticeable for applications as the file system paths remain
  continuously around. Given that the backing file system (vFAT) has
  poor data safety properties, it is essential to shorten the access
  for unclean file system state as much as possible. In fact, this is
  what the aforementioned <code>systemd-gpt-auto-generator</code>
  logic actually does by default.</p>
</li>
<li>
<p>Whenever mounting one of the two partitions, do a file system check
  (<strong>fsck</strong>; in fact this is also what
  <code>systemd-gpt-auto-generator</code>does by default, hooked into
  the automount logic, to run on first access). This ensures that even
  if the file system is in an unclean state it is restored to be clean
  when needed, i.e., on first access.</p>
</li>
<li>
<p>Do not mount the two partitions <strong>nested</strong>, i.e., no
  more <code>/boot/efi/</code>. First of all, as mentioned above, it
  should be possible (and is desirable) to only have one of the
  two. Hence it is simply a bad idea to require the other as well,
  just to be able to mount it. More importantly though, by nesting
  them, automounting is complicated, as it is necessary to trigger the
  first automount to establish the second automount, which defeats the
  point of automounting them in the first place. Use the two distinct
  mount points <code>/efi/</code> (for the ESP) and
  <code>/boot/</code> (for XBOOTLDR) instead. You might have guessed,
  but that too is what <code>systemd-gpt-auto-generator</code> does by
  default.</p>
</li>
<li>
<p>When making additions or updates to ESP/XBOOTLDR from the OS make
  sure to create a file and write it in full, then
  <code>syncfs()</code> the whole file system, then rename to give it
  its final name, and <code>syncfs()</code> again. Similar when
  removing files.</p>
</li>
<li>
<p>When writing from the boot loader environment/UEFI to ESP/XBOOTLDR,
  do not append to files or create new files. Instead overwrite
  already allocated file contents (for example to maintain a random
  seed file) or rename already allocated files to include information
  in the file name (and ideally do not increase the file name in
  length; for example to maintain boot counters).</p>
</li>
<li>
<p>Consider adopting
  <a href="https://0pointer.net/blog/brave-new-trusted-boot-world.html">UKIs</a>,
  which minimize the number of files that need to be updated on the
  ESP/XBOOTLDR during OS/kernel updates (ideally down to 1)</p>
</li>
<li>
<p>Consider adopting
  <a href="https://www.freedesktop.org/software/systemd/man/systemd-boot.html"><code>systemd-boot</code></a>,
  which minimizes the number of files that need to be updated on boot
  loader updates (ideally down to 1)</p>
</li>
<li>
<p>Consider removing any mention of ESP/XBOOTLDR from
  <code>/etc/fstab</code>, and just let
  <code>systemd-gpt-auto-generator</code> do its thing.</p>
</li>
<li>
<p>Stop implementing file systems, complex storage, disk encryption, …
  in your boot loader.</p>
</li>
</ul>
<p>Implementing things like that you gain:</p>
<ul>
<li>
<p><strong>Simplicity</strong>: only one file system implementation, typically only
  one partition and mount point</p>
</li>
<li>
<p><strong>Robust auto-discovery</strong> of all partitions, no need to even
  configure <code>/etc/fstab</code></p>
</li>
<li>
<p><strong>Data safety</strong> guarantees as good as possible, given the
  circumstances</p>
</li>
</ul>
<p>To summarize this in a table:</p>
<table>
  <tbody><tr>
   <th>Type</th>
   <th>Linux Mount Point</th>
   <th>File System Choice</th>
   <th>Automount</th>
  </tr>
  <tr>
   <td>ESP</td>
   <td><code>/efi/</code></td>
   <td>vFAT</td>
   <td>yes</td>
  </tr>
  <tr>
   <td>XBOOTLDR</td>
   <td><code>/boot/</code></td>
   <td>vFAT</td>
   <td>yes</td>
  </tr>
</tbody></table>

<p>A note regarding modern boot loaders that implement the <a href="https://uapi-group.org/specifications/specs/boot_loader_specification/">Boot Loader
Specification</a>:
both partitions are explicitly listed in the specification as sources
for both Type #1 and Type #2 boot menu entries. Hence, if you use such
a modern boot loader (e.g. systemd-boot) these two partitions are the
preferred location for boot loader resources, kernels and initrds
anyway.</p>

<p>You might wonder, what about RAID setups and the ESP? This comes up
regularly in discussions: how to set up the ESP so that (software)
RAID1 (mirroring) can be done on the ESP. Long story short: I’d
strongly advise against using RAID on the ESP. Firmware typically
doesn’t have native RAID support, and given that firmware and boot
loader can write to the file systems involved, any attempt to use
software RAID on them will mean that a boot cycle might corrupt the
RAID sync, and immediately requires a re-synchronization after
boot. If RAID1 backing for the ESP is really necessary, the only way
to implement that safely would be to implement this as a driver for
UEFI – but that creates certain bootstrapping issues (i.e., where to
place the driver if not the ESP, a file system the driver is supposed
to be used for), and also reimplements a considerable component of the
OS storage stack in firmware mode, which seems problematic.</p>
<p>So what to do instead? My recommendation would be to solve this via
userspace tooling. If redundant disk support shall be implemented for
the ESP, then create separate ESPs on all disks, and synchronize them
on the file system level instead of the block level. Or in other
words, the tools that install/update/manage kernels or boot loaders
should be taught to maintain multiple ESPs instead of one. Copy the
kernels/boot loader files to all of them, and remove them from all of
them. Under the assumption that the goal of RAID is a more reliable
system this should be the best way to achieve that, as it doesn’t
pretend the firmware could do things it actually cannot do. Moreover
it minimizes the complexity of the boot loader, shifting the syncing
logic to userspace, where it’s typically easier to get right.</p>

<p>The discussion above focuses on booting up from a local disk. When
thinking about networked boot I think two scenarios are particularly
relevant:</p>
<ol>
<li>
<p>PXE-style network booting. I think in this mode of operation focus
   should be on directly booting a single UKI image instead of a boot
   loader. This sidesteps the whole issue of maintaining any boot
   partition at all, and simplifies the boot process greatly. In
   scenarios where this is not sufficient, and an interactive boot
   menu or other boot loader features are desired, it might be a good
   idea to take inspiration from the UKI concept, and build a single
   boot loader EFI binary (such as systemd-boot), and include the UKIs
   for the boot menu items and other resources inside it via PE
   sections. Or in other words, build a single boot loader binary that
   is “supercharged” and contains all auxiliary resources in its own
   PE sections. (Note: this does not exist, it’s an idea I intend to
   explore with systemd-boot). Benefit: a single file has to be
   downloaded via PXE/TFTP, not more. Disadvantage: unused resources
   are downloaded unnecessarily. Either way: in this context there is
   no local storage, and the ESP/XBOOTLDR discussion above is without
   relevance.</p>
</li>
<li>
<p>Initrd-style network booting. In this scenario the boot loader and
   kernel/initrd (better: UKI) are available on a local disk. The
   initrd then configures the network and transitions to a network
   share or file system on a network block device for the root file
   system. In this case the discussion above applies, and in fact the
   ESP or XBOOTLDR partition would be the only partition available
   locally on disk.</p>
</li>
</ol>
<p>And this is all I have for today.</p>
  </div></div>
  </body>
</html>
