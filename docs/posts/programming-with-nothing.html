<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tomstu.art/programming-with-nothing">Original</a>
    <h1>Programming with Nothing</h1>
    
    <div id="readability-page-1" class="page"><article>
      <header>
        
      </header>

      

<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#ruining-ruby">Ruining Ruby</a></li>
  <li><a href="#thinking-procs">Thinking procs</a></li>
  <li><a href="#aiming-high">Aiming high</a></li>
  <li><a href="#numbers">Numbers</a></li>
  <li><a href="#booleans">Booleans</a></li>
  <li><a href="#predicates">Predicates</a></li>
  <li><a href="#numeric-operations">Numeric operations</a></li>
  <li><a href="#lists-briefly">Lists, briefly</a></li>
  <li><a href="#strings-briefly">Strings, briefly</a></li>
  <li><a href="#victory">Victory</a></li>
  <li><a href="#why">Why?</a></li>
  <li><a href="#epilogue">Epilogue</a></li>
</ul>

<h2 id="ruining-ruby">Ruining Ruby</h2>

<p>I love Ruby! I’ve used it every day for years and I’m not sick of it yet. It’s an easy language to love: it’s <a href="http://confreaks.net/videos/431-rubyconf2010-keynote-why-ruby">expressive, flexible and syntactically beautiful</a>; it has a unique combination of useful features like <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html#S2">mixins</a>, <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/classes.html#UB">metaclasses</a> and <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/intro.html#S6">blocks</a>; it comes with a useful <a href="http://ruby-doc.org/core">core library</a> and comprehensive <a href="http://ruby-doc.org/stdlib">standard library</a>; and it has an excellent ecosystem, with plenty of great <a href="http://rubygems.org/">third-party libraries</a> available.</p>

<p>In fact, you know what? I love Ruby so much that I want to <a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/DestructiveRomance">ruin it</a>. Let’s see how much it can do if we remove all of its features. Naturally that means no gems, no standard library, no <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html">modules</a>, <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/tut_methods.html">methods</a>, <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/classes.html">classes or objects</a>. But this is love, so let’s go all the way: no <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/intro.html#S4">control flow</a>, no <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/tut_expressions.html#S3">assignment</a>, no <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/tut_containers.html#UA">arrays</a>, <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/tut_stdtypes.html#S2">strings</a>, <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/tut_stdtypes.html#S1">numbers</a> or <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/tut_expressions.html#UF">booleans</a>.</p>

<p>(To clarify: this is just a game. It is not software engineering advice.)</p>

<p>Unfortunately we can’t remove absolutely <em>everything</em> and still have a language, so here are the Ruby features we’re going to keep:</p>

<ul>
  <li><a href="http://ruby-doc.org/docs/ProgrammingRuby/html/ref_c_proc.html#Proc.new">creating procs</a>; and</li>
  <li><a href="http://ruby-doc.org/docs/ProgrammingRuby/html/ref_c_proc.html#Proc.call">calling procs</a>.</li>
</ul>

<p>As a grudging concession to clarity, we should also allow ourselves to use <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/language.html#S4">constants</a> to abbreviate our code: if we create a complex proc, we may assign it to a constant to give it a short name that we can reuse later. But referring to the name is no different from retyping the original proc again — the name just makes the code more readable — so it’s not really using a language feature. We could always undo the abbreviations by replacing each constant with the proc it refers to.</p>

<h2 id="thinking-procs">Thinking procs</h2>

<p>Since we’re going to be building entire programs out of procs, let’s spend a minute looking at their properties.</p>

<ul>
  <li>

<p>Procs are plumbing for moving values around your program. Consider what happens when you call a proc:</p>

<pre><code>lambda { |x| x + 1 }.call(41)</code></pre>

<p>The value that’s provided as an argument to the call, in this case <code>41</code>, flows <em>into</em> the parameter of the block, in this case <code>x</code>, and then flows <em>out of</em> the parameter to all the places where that parameter is used, so Ruby ends up evaluating <code>41 + 1</code>. It’s the rest of the language that does the actual work; procs just connect parts of the program together and make values flow to where they’re needed.</p>

  </li>
  <li>

<p>Procs don’t need to take multiple arguments. If you’ve got a proc that takes multiple arguments…</p>

<pre><code>lambda { |x, y|
  x + y
}.call(3, 4)</code></pre>

<p>…you can always rewrite it as nested single-argument procs:</p>

<pre><code>lambda { |x|
  lambda { |y|
    x + y
  }
}.call(3).call(4)</code></pre>

<p>Here the outer proc takes one argument, <code>x</code>, and returns the inner proc, which also takes one argument, <code>y</code>. We can call the outer proc with a value for <code>x</code> and then call the inner proc with a value for <code>y</code>, and we get the same result as in the multi-argument case. (This is called “<a href="http://en.wikipedia.org/wiki/Currying">currying</a>”, incidentally, and in Ruby 1.9 you can use <code><a href="http://ruby-doc.org/core-1.9.3/Proc.html#method-i-curry">Proc#curry</a></code> to do this transformation.)</p>

<p>Since we’re trying to remove as many features of Ruby as possible, let’s restrict ourselves to creating and calling <em>single-argument</em> procs; it won’t make things much worse.</p>

  </li>
  <li id="extensionality">

<p>The only way to find out about the code inside a proc is to call it. This means that two procs can be considered equal if they behave identically when called, even if their internal code is different. (This idea is called <a href="http://en.wikipedia.org/wiki/Extensionality">extensionality</a>.)</p>

<p>For example, if you have a proc which takes an argument and then simply calls another proc <code>p</code> with that argument…</p>

<pre><code>lambda { |x| p.call(x) }</code></pre>

<p>…then the whole construction is indistinguishable from just <code>p</code>, because it does exactly the same thing. This is a refactoring opportunity: if you see this pattern in your program you may choose to eliminate it, and under certain circumstances (which we’ll see later) you might intentionally introduce it.</p>

  </li>
  <li>

<p>There are four ways to explicitly create a proc:

</p><pre><code>Proc.new { |x| x + 1 }
    proc { |x| x + 1 }
  lambda { |x| x + 1 }
        -&gt; x { x + 1 }</code></pre>

<p>You can use <code><a href="http://ruby-doc.org/core-1.9.3/Proc.html#method-c-new">Proc.new</a></code>, <code><a href="http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-proc">Kernel.proc</a></code> or <code><a href="http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-lambda">Kernel.lambda</a></code>, and in Ruby 1.9 you can use the “stabby lambda” syntax.</p>

<p>(These are all roughly equivalent. Procs created with <code>Proc.new</code> and <code>Kernel.proc</code> do <a href="http://blog.emson.co.uk/2010/05/what-is-the-difference-between-a-proc-and-a-lambda-in-ruby/">differ slightly</a> from those created with <code>Kernel.lambda</code> and <code>-&gt;</code> in how they handle multiple arguments and explicit <code>return</code>s, but we’re not using either of those language features.)</p>

<p>Similarly, there are four ways to call a proc:</p><pre><code>p.call(41)
p[41]
p === 41
p.(41)</code></pre>

<p>You can use <code><a href="http://ruby-doc.org/core-1.9.3/Proc.html#method-i-call">Proc#call</a></code> or <code><a href="http://ruby-doc.org/core-1.9.3/Proc.html#method-i-5B-5D">Proc#[]</a></code>, and in Ruby 1.9 you can use <code><a href="http://ruby-doc.org/core-1.9.3/Proc.html#method-i-3D-3D-3D">Proc#===</a></code> (in case you want to put your proc in a <code>case</code> statement) and <code>Proc#()</code>.</p>

<p>For this article I’m just going to choose a syntax and stick with it. Instead of saying…</p>

<pre><code>lambda { |x| x + 1 }.call(41)</code></pre>

<p>…I’m going to say…</p>

<pre><code>-&gt; x { x + 1 }[41]</code></pre>

<p>…which makes it easier to see the body and argument of the proc. This isn’t necessarily the best syntax for procs, it’s just the most convenient for what we’re going to do.</p>

  </li>
</ul>

<h2 id="aiming-high">Aiming high</h2>

<p>Our goal will be to write the well-known <a href="http://imranontech.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/">FizzBuzz program</a>:</p>

<blockquote cite="http://imranontech.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/">Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”.</blockquote>

<p>This is an ostensibly simple problem, designed to test whether an interview candidate is lying about being a programmer. Any competent programmer should be able to solve it within a minute.</p>

<p>Here’s an implementation of FizzBuzz in full-featured Ruby:</p>

<pre><code>(1..100).each do |n|
  if (n % 15).zero?
    puts &#39;FizzBuzz&#39;
  elsif (n % 3).zero?
    puts &#39;Fizz&#39;
  elsif (n % 5).zero?
    puts &#39;Buzz&#39;
  else
    puts n.to_s
  end
end</code></pre>

<p>(I am available for freelance programming work.)</p>

<p>This isn’t the cleverest implementation of FizzBuzz — there are plenty of <a href="http://www.reddit.com/r/programming/comments/10d7w/fizzbuzz_spoilers">clever ones</a> out there — but it’s the one I would write without thinking about it.</p>

<p>However, this program contains some <code>puts</code> statements, and we have no way to print text to the console using only procs, so I’m going to replace it with a roughly equivalent program which returns an array of strings rather than printing them:</p>

<pre><code>(1..100).<ins>map</ins> do |n|
  if (n % 15).zero?
    &#39;FizzBuzz&#39;
  elsif (n % 3).zero?
    &#39;Fizz&#39;
  elsif (n % 5).zero?
    &#39;Buzz&#39;
  else
    n.to_s
  end
end</code></pre>

<p>Hopefully you’ll agree that this is still a meaningful solution to the FizzBuzz problem, but now it’s one that we have a chance of implementing using only procs.</p>

<p>Despite its simplicity, this is quite an ambitious program if you don’t have any of the features of a programming language: it creates a range, maps over it, evaluates a big conditional, does some arithmetic with the modulo operator, uses the <code><a href="http://ruby-doc.org/core-1.9.3/Fixnum.html#method-i-zero-3F">Fixnum#zero?</a></code> predicate, uses some string literals, and turns numbers into strings with <code><a href="http://ruby-doc.org/core-1.9.3/Fixnum.html#method-i-to_s">Fixnum#to_s</a></code>. That’s a fair amount of built-in Ruby functionality, and we’re going to have to strip it all out and reimplement it with procs.</p>

<h2 id="numbers">Numbers</h2>

<p>I’m going to start by focusing on the numbers that appear in FizzBuzz. How can we possibly represent numbers without using <code>Fixnum</code>s or any of the other datatypes that Ruby provides?</p>

<p>If we’re going to try to implement numbers from scratch, we’d better have a solid understanding of what we’re implementing. But what is a <em>number</em>, anyway? It’s hard to come up with a concrete definition that doesn’t accidentally assume some aspect of what we’re trying to define; for example, “something that tells you how many…” is not very useful, because “how many” is really just another way of saying “number”.</p>

<p>To be more specific, what we want to implement here is the <a href="http://en.wikipedia.org/wiki/Natural_number">natural numbers</a> — whole, non-negative numbers — also known as the <em>counting numbers</em>: zero, one, two, three, and so on.</p>

<p>Here’s one way of characterising them: imagine you have a bag of apples and a bag of oranges; you take an apple out of one bag, an orange out of the other, and put them aside; then you keep taking out an apple and an orange together until at least one of the bags is empty.</p>

<p>If both bags become empty at the same time, you’ve learned something interesting: in spite of containing different things, those bags had some shared property that meant they became empty at the same time; at every point during the procedure of repeatedly removing an item from each bag, either both bags were non-empty or both bags were empty. This abstract property shared by the bags is what we can call a number (although we don’t know <em>which</em> number!), and you can compare these bags with any other bag in the world to see if it has the same “number” as these ones.</p>

<p>So one way to characterise numbers is by repetition (a.k.a. <a href="http://en.wikipedia.org/wiki/Iteration">iteration</a>) of some action, in this case taking an item from a bag. Each number corresponds to a unique way of repeating an action: the number one corresponds to just performing the action; the number two corresponds to performing it and then performing it again; and so on. The number zero, unsurprisingly, corresponds to not performing the action at all.

</p><p>Since making and calling procs are the only “actions” our program can perform, we can try implementing a number <var>n</var> with code that repeats the action of calling a proc <var>n</var> times.</p>

<p>For example, if we were allowed to define methods — which we’re not, but play along — then we could define <code>#one</code> as a method that takes a proc and some arbitrary second argument, and then calls the proc with that argument once:</p>

<pre><code>def one(proc, x)
  proc[x]
end</code></pre>

<p>We could also define <code>#two</code>, which calls the proc once and then calls it again with whatever the result of calling it the first time was (this is “<a href="http://en.wikipedia.org/wiki/Iterated_function">iterating the function</a>”):</p>

<pre><code>def two(proc, x)
  proc[proc[x]]
end</code></pre>

<p>And so on:</p>

<pre><code>def three(proc, x)
  proc[proc[proc[x]]]
end</code></pre>

<p>Following this pattern, it’s natural to define <code>#zero</code> as a method that takes a proc and some other argument, ignores the proc entirely (i.e. calls it zero times), and returns the second argument untouched:</p>

<pre><code>def zero(proc, x)
  x
end</code></pre>

<p>All of these implementations can be translated into methodless representations; for example, we can replace the method <code>#one</code> with a proc which takes two arguments and then calls the first argument with the second one. They look like this:</p>

<pre><code>ZERO  = -&gt; p { -&gt; x {       x    } }
ONE   = -&gt; p { -&gt; x {     p[x]   } }
TWO   = -&gt; p { -&gt; x {   p[p[x]]  } }
THREE = -&gt; p { -&gt; x { p[p[p[x]]] } }</code></pre>

<p>This avoids the “defining methods” functionality that we’re not allowed to use, and instead gives names to procs by assigning them to constants.</p>

<p>Now, although we’re eschewing Ruby’s features <em>inside</em> our program, it would be useful to be able to translate these foreign representations of numbers into native Ruby values once they’re <em>outside</em> our program — so that they can be usefully inspected on the console or asserted against in tests, or at least so that we can convince ourselves that they really do represent numbers in the first place.</p>

<p>Fortunately we can write a <code>#to_integer</code> method that performs this conversion:</p>

<pre><code>def to_integer(proc)
  proc[-&gt; n { n + 1 }][0]
end</code></pre>

<p>This method takes a proc that represents a number and calls it with another proc (one which just increments its argument) and the native Ruby number <code>0</code>. If we call <code>#to_integer</code> with <code>ZERO</code> then, because of <code>ZERO</code>’s definition, the incrementing proc doesn’t get called at all and we get an untouched Ruby <code>0</code> back:</p>

<pre><samp>&gt;&gt; <kbd>to_integer(ZERO)</kbd>
=&gt; 0</samp></pre>

<p>And if we call <code>#to_integer</code> with <code>THREE</code>, the incrementing proc gets called three times and we get a Ruby <code>3</code> back:</p>

<pre><samp>&gt;&gt; <kbd>to_integer(THREE)</kbd>
=&gt; 3</samp></pre>

<p>So these proc-based representations really do encode numbers, and we can convert them into a more practical representation whenever we want to.</p>

<p>For FizzBuzz we need the numbers five, fifteen and one hundred, which can all be implemented using the same technique:</p>

<pre><code>FIVE    = -&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }
FIFTEEN = -&gt; p { -&gt; x { p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[x]]]]]]]]]]]]]]] } }
HUNDRED = -&gt; p { -&gt; x { p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[x]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] } }</code></pre>

<p>These aren’t very compact definitions of those numbers, but they work, as we can confirm with <code>#to_integer</code>:</p>

<pre><samp>&gt;&gt; <kbd>to_integer(FIVE)</kbd>
=&gt; 5

&gt;&gt; <kbd>to_integer(FIFTEEN)</kbd>
=&gt; 15

&gt;&gt; <kbd>to_integer(HUNDRED)</kbd>
=&gt; 100</samp></pre>

<p>So, going back to the FizzBuzz program, all of the Ruby numbers can be replaced with their proc-based implementations:</p>

<pre><code>(<ins>ONE</ins>..<ins>HUNDRED</ins>).map do |n|
  if (n % <ins>FIFTEEN</ins>).zero?
    &#39;FizzBuzz&#39;
  elsif (n % <ins>THREE</ins>).zero?
    &#39;Fizz&#39;
  elsif (n % <ins>FIVE</ins>).zero?
    &#39;Buzz&#39;
  else
    n.to_s
  end
end</code></pre>

<p>(As promised, I’m writing <code>ONE</code> instead of <code>-&gt; p { -&gt; x { p[x] } }</code>, and so on, to make the code clearer.)</p>

<p>Unfortunately this program doesn’t work any more, because we’re now using operations like <code>..</code> and <code>%</code> on the proc-based implementations of numbers, and because Ruby doesn’t know how to treat these as numbers it’ll just blow up: “<samp>TypeError: can&#39;t iterate from Proc</samp>”, “<samp>NoMethodError: undefined method `%&#39; for #&lt;Proc (lambda)&gt;</samp>”, and so on. We need to replace all of the operations to work with these representations — and we can only use procs to do it.</p>

<p>Before we can reimplement any of the operations, though, we need implementations of <code>true</code> and <code>false</code>.</p>

<h2 id="booleans">Booleans</h2>

<p>How can we represent booleans using only procs? Well, booleans exist solely to be used in conditional statements, and in general a conditional says “if some boolean then <em>this</em> else <em>that</em>”, so the real job of a boolean is to allow you to choose between two options.</p>

<p>We can take advantage of this by representing a boolean with a proc that chooses one of two values. This cuts out the middleman: instead of thinking of a boolean as a lifeless piece of data that can be read by some future code to decide which of two options to choose, we can just implement it directly as a piece of code that, when called with two options, either chooses the first option or chooses the second option.</p>

<p>Implemented as methods, then, <code>#true</code> and <code>#false</code> could be:</p>

<pre><code>def true(x, y)
  x
end

def false(x, y)
  y
end</code></pre>

<p><code>#true</code> is a method that takes two arguments and returns the first one, and <code>#false</code> takes two arguments and returns the second. As before, it’s straightforward to translate them into procs:</p>

<pre><code>TRUE  = -&gt; x { -&gt; y { x } }
FALSE = -&gt; x { -&gt; y { y } }</code></pre>

<p>And just as we defined <code>#to_integer</code> as a sanity check, to make sure it was possible to convert proc-based numbers into Ruby numbers, so we can define a <code>#to_boolean</code> method that can turn this <code>TRUE</code> and <code>FALSE</code> into Ruby-native <code>true</code> and <code>false</code>:</p>

<pre><code>def to_boolean(proc)
  proc[true][false]
end</code></pre>

<p>This works by taking a proc that represents a boolean and calling it with Ruby <code>true</code> as the first argument and Ruby <code>false</code> as the second argument. Because <code>TRUE</code> just returns its first argument, <code>to_boolean(TRUE)</code> will therefore return <code>true</code>, and likewise for <code>FALSE</code>:</p>

<pre><samp>&gt;&gt; <kbd>to_boolean(TRUE)</kbd>
=&gt; true

&gt;&gt; <kbd>to_boolean(FALSE)</kbd>
=&gt; false</samp></pre>

<p>So representing booleans with procs is surprisingly easy, but for FizzBuzz we don’t just need booleans, we need a proc-only implementation of Ruby’s <code>if</code>-<code>elsif</code>-<code>else</code>. In fact, because of the way these boolean implementations work, it’s easy to write an <code>#if</code> method too:</p>

<pre><code>def if(proc, x, y)
  proc[x][y]
end</code></pre>

<p>And that’s easy to translate into a proc:</p>

<pre><code>IF =
  -&gt; b {
    -&gt; x {
      -&gt; y {
        b[x][y]
      }
    }
  }</code></pre>

<p>Clearly <code>IF</code> doesn’t need to do any useful work because the boolean itself picks the right argument — <code>IF</code> is just <a href="http://en.wikipedia.org/wiki/Syntactic_sugar">sugar</a> — but it looks more natural than calling the boolean directly:</p>

<pre><samp>&gt;&gt; <kbd>IF[TRUE][:foo][:bar]</kbd>
=&gt; :foo

&gt;&gt; <kbd>IF[FALSE][:foo][:bar]</kbd>
=&gt; :bar</samp></pre>

<p>Incidentally, this means we can revise the definition of <code>#to_boolean</code> to use <code>IF</code>:</p>

<pre><code>def to_boolean(proc)
  <ins>IF[</ins>proc<ins>]</ins>[true][false]
end</code></pre>

<p>While we’re refactoring, it’s worth noting that the implementation of <code>IF</code> can be cleaned up significantly because it contains some procs that are equivalent (or “extensionally equal”) to simpler ones, as discussed <a href="#extensionality">earlier</a>. For example, look at <code>IF</code>’s innermost proc:</p>

<pre><code>-&gt; y {
  b[x][y]
}</code></pre>

<p>Breaking the code down, it says:</p>

<ol>
  <li>“take an argument <code>y</code>”; then</li>
  <li>“call <code>b</code> with <code>x</code> to get a proc”; and finally</li>
  <li>“call that proc with <code>y</code>”.</li>
</ol>

<p>Steps 1 and 3 are dead wood: when you call this proc with an argument, it just calls another proc with that argument. So the whole thing is equivalent to just step 2, <code>b[x]</code>, and we can remove the dead wood in the implementation of <code>IF</code> to make it simpler:</p>

<pre><code>IF =
  -&gt; b {
    -&gt; x {
      b[x]
    }
  }</code></pre>

<p>You can see the same pattern again in what’s now the innermost proc:</p>

<pre><code>-&gt; x {
  b[x]
}</code></pre>

<p>For the same reason, this proc is the same as just <code>b</code>, so we can simplify <code>IF</code> even further:</p>

<pre><code>IF = -&gt; b { b }</code></pre>

<p>We’re not going to be able to simplify it any more than that.</p>

<p>Anyway, now that we have <code>IF</code>, we can go back to the FizzBuzz program and replace the Ruby <code>if</code>-<code>elsif</code>-<code>else</code> with nested calls to <code>IF</code>:</p>

<pre><code>(ONE..HUNDRED).map do |n|
  <ins>IF[</ins>(n % FIFTEEN).zero?<ins>][</ins>
    &#39;FizzBuzz&#39;
  <ins>][IF[</ins>(n % THREE).zero?<ins>][</ins>
    &#39;Fizz&#39;
  <ins>][IF[</ins>(n % FIVE).zero?<ins>][</ins>
    &#39;Buzz&#39;
  <ins>][</ins>
    n.to_s
  <ins>]]]</ins>
end</code></pre>

<h2 id="predicates">Predicates</h2>

<p>Our next job is to replace <code>Fixnum#zero?</code> with a proc-based implementation that will work with proc-based numbers. The underlying algorithm of <code>#zero?</code> for Ruby values is something like this:</p>

<pre><code>def zero?(n)
  if n == 0
    true
  else
    false
  end
end</code></pre>

<p>(This is more verbose than is necessary, but it’s explicit about what happens: compare the number with <code>0</code>, if it’s equal then return <code>true</code>, otherwise return <code>false</code>.)</p>

<p>How can we adapt this to handle procs instead of Ruby numbers? Look at our implementation of numbers again:</p>

<pre><code>ZERO  = -&gt; p { -&gt; x {       x    } }
ONE   = -&gt; p { -&gt; x {     p[x]   } }
TWO   = -&gt; p { -&gt; x {   p[p[x]]  } }
THREE = -&gt; p { -&gt; x { p[p[p[x]]] } }
...</code></pre>

<p>Notice that <code>ZERO</code> is the only number which doesn’t call <code>p</code> — it just returns <code>x</code> — whereas all of the other numbers call <code>p</code> at least once. We can take advantage of this: if we call an unknown number with <code>TRUE</code> as its second argument, it’ll return <code>TRUE</code> immediately if the number is <code>ZERO</code>. If it’s not <code>ZERO</code> then it’ll return whatever calling <code>p</code> returns, so if we make <code>p</code> a proc which always returns <code>FALSE</code>, we’ll get the behaviour we want:</p>

<pre><code>def zero?(proc)
  proc[-&gt; x { FALSE }][TRUE]
end</code></pre>

<p>Again it’s easy to rewrite this as a proc:</p>

<pre><code>IS_ZERO = -&gt; n { n[-&gt; x { FALSE }][TRUE] }</code></pre>

<p>We can use <code>#to_boolean</code> on the console to check that it works:</p>

<pre><samp>&gt;&gt; <kbd>to_boolean(IS_ZERO[ZERO])</kbd>
=&gt; true

&gt;&gt; <kbd>to_boolean(IS_ZERO[THREE])</kbd>
=&gt; false</samp></pre>

<p>That’s working fine, so in FizzBuzz we can replace all of the calls to <code>#zero?</code> with <code>IS_ZERO</code>:</p>

<pre><code>(ONE..HUNDRED).map do |n|
  IF[<ins>IS_ZERO[</ins>n % FIFTEEN<ins>]</ins>][
    &#39;FizzBuzz&#39;
  ][IF[<ins>IS_ZERO[</ins>n % THREE<ins>]</ins>][
    &#39;Fizz&#39;
  ][IF[<ins>IS_ZERO[</ins>n % FIVE<ins>]</ins>][
    &#39;Buzz&#39;
  ][
    n.to_s
  ]]]
end</code></pre>

<h2 id="numeric-operations">Numeric operations</h2>

<p>Now that we have numbers, booleans, conditionals and predicates, we’re ready to reimplement <code><a href="http://ruby-doc.org/core-1.9.3/Fixnum.html#method-i-25">Fixnum#%</a></code>. (Don’t despair: this is the last thing I’m going to show you in detail. Once we’ve done it I’ll skim the rest and get to the punchline as soon as possible.)</p>

<p>Before we can do anything as ambitious as taking the modulo of two numbers, we need fundamental operations like incrementing and decrementing. To keep things moving I’ll just recite their <a href="http://en.wikipedia.org/wiki/Lambda_calculus#Arithmetic_in_lambda_calculus">standard</a> <a href="http://en.wikipedia.org/wiki/Church_encoding#Computation_with_Church_numerals">implementations</a>:</p>

<pre><code>INCREMENT = -&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }
DECREMENT = -&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }]
                                  [-&gt; y { x }][-&gt; y { y }] } } }</code></pre>

<p><code>DECREMENT</code> is too complicated to explain succinctly, but look briefly at how <code>INCREMENT</code> works: call it with a proc-based number <code>n</code>, and it’ll return a new proc that takes some other proc <code>p</code> and some arbitrary second argument <code>x</code>, just like numbers do.</p>

<p>What does this new proc do when you call it? First it calls <code>n</code> with <code>p</code> and <code>x</code> — since <code>n</code> is a number, this means “call <code>p</code>, <code>n</code> times, on <code>x</code>”, just as the original number would have done — and then calls <code>p</code> one more time on the result. Overall, then, this is a proc whose first argument gets called <code>n + 1</code> times on its second argument, which is exactly how to represent the number <code>n + 1</code>.</p>

<p>Anyway, once we have <code>INCREMENT</code> and <code>DECREMENT</code>, it’s possible to implement numeric operations like addition, subtraction, multiplication and exponentiation:</p>

<pre><code>ADD      = -&gt; m { -&gt; n { n[INCREMENT][m] } }
SUBTRACT = -&gt; m { -&gt; n { n[DECREMENT][m] } }
MULTIPLY = -&gt; m { -&gt; n { n[ADD[m]][ZERO] } }
POWER    = -&gt; m { -&gt; n { n[MULTIPLY[m]][ONE] } }</code></pre>

<p>(These aren’t too hard to understand. For example, if you want to add <code>m</code> and <code>n</code>, that’s just “<code>n</code> times, <code>INCREMENT</code> <code>m</code>”, and likewise for subtraction; once you have <code>ADD</code>, you can multiply <code>m</code> and <code>n</code> by saying “<code>n</code> times, <code>ADD</code> <code>m</code> to <code>ZERO</code>”, and similarly for exponentiation with <code>MULTIPLY</code> and <code>ONE</code>.)</p>

<p>That should be enough arithmetic to get us started, but before we can implement <code>%</code> with procs we need to know an algorithm for computing the modulo of two numbers. Here’s one that works on Ruby’s numbers:</p>

<pre><code>def mod(m, n)
  if n &lt;= m
    mod(m - n, n)
  else
    m
  end
end</code></pre>

<p>For example, to calculate <code>17</code> modulo <code>5</code>:</p>

<ul>
  <li>if <code>5</code> is less than or equal to <code>17</code>, which it is, then subtract <code>5</code> from <code>17</code> and call <code>#mod</code> again with the result, i.e. try <code>12</code> modulo <code>5</code>;</li>
  <li><code>5</code> is less than or equal to <code>12</code>, so try <code>7</code> modulo <code>5</code>;</li>
  <li><code>5</code> is less than or equal to <code>7</code>, so try <code>2</code> modulo <code>5</code>;</li>
  <li><code>5</code> is <em>not</em> less than or equal to <code>2</code>, so return the result <code>2</code>.</li>
</ul>

<p>But we can’t implement <code>#mod</code> with procs yet because it uses another operator, <code>&lt;=</code>, for which we don’t yet have an implementation, so we need to digress briefly to implement <code>&lt;=</code> with procs.</p>

<p>We can begin with what looks like a pointlessly circular implementation of <code>#less_or_equal?</code> for Ruby numbers:</p>

<pre><code>def less_or_equal?(m, n)
  m - n &lt;= 0
end</code></pre>

<p>This isn’t very useful because it begs the question by relying on <code>&lt;=</code>, but it does at least recast the problem in terms of two other problems we’ve already looked at: subtraction and comparison with zero. Subtraction we’ve already dealt with, and we’ve done comparison for <em>equality</em> with zero, but how do we implement <em>less-than-or-equal-to</em> zero?</p>

<p>As it happens we don’t need to worry about it, because zero is already the smallest number we know how to implement — recall that our proc-based numbers are the natural numbers — so “less than zero” is a meaningless concept in our number system. If we use <code>SUBTRACT</code> to subtract a larger number from a smaller one, it’ll just return <code>ZERO</code>, because there’s no way for it to return a negative number and <code>ZERO</code> is the closest it can get:</p>

<pre><samp>&gt;&gt; <kbd>to_integer(SUBTRACT[FIVE][THREE])</kbd>
=&gt; 2

&gt;&gt; <kbd>to_integer(SUBTRACT[THREE][FIVE])</kbd>
=&gt; 0</samp></pre>

<p>(You might protest that <code>3 - 5 = 0</code> isn’t called “subtraction” where you come from, and you’d be right: the technical name for this operation is “<a href="http://en.wikipedia.org/wiki/Monus">monus</a>”, because the natural numbers under addition form a <a href="http://en.wikipedia.org/wiki/Monoid#Commutative_monoid">commutative monoid</a> instead of a proper <a href="http://en.wikipedia.org/wiki/Abelian_group">abelian group</a>.)</p>

<p>We’ve already written <code>IS_ZERO</code>, and since <code>SUBTRACT[m][n]</code> will return <code>ZERO</code> if <code>m</code> is less than or equal to <code>n</code> (i.e. if <code>n</code> is at least as large as <code>m</code>), we have enough to implement <code>#less_or_equal?</code> with procs:</p>

<pre><code>def less_or_equal?(m, n)
  IS_ZERO[SUBTRACT[m][n]]
end</code></pre>

<p>And let’s turn that method into a proc:</p>

<pre><code>IS_LESS_OR_EQUAL =
  -&gt; m { -&gt; n {
    IS_ZERO[SUBTRACT[m][n]]
  } }</code></pre>

<p>Does it work?</p>

<pre><samp>&gt;&gt; <kbd>to_boolean(IS_LESS_OR_EQUAL[ONE][TWO])</kbd>
=&gt; true

&gt;&gt; <kbd>to_boolean(IS_LESS_OR_EQUAL[TWO][TWO])</kbd>
=&gt; true

&gt;&gt; <kbd>to_boolean(IS_LESS_OR_EQUAL[THREE][TWO])</kbd>
=&gt; false</samp></pre>

<p>Looks good.</p>

<p>This gives us the missing piece for our implementation of <code>#mod</code>, so we can rewrite it with procs:</p>

<pre><code>def mod(m, n)
  IF[IS_LESS_OR_EQUAL[n][m]][
    mod(SUBTRACT[m][n], n)
  ][
    m
  ]
end</code></pre>

<p>And replace the method definition with a proc:</p>

<pre><code>MOD =
  -&gt; m { -&gt; n {
    IF[IS_LESS_OR_EQUAL[n][m]][
      MOD[SUBTRACT[m][n]][n]
    ][
      m
    ]
  } }</code></pre>

<p>Great! Does it work?</p>

<pre><samp>&gt;&gt; <kbd>to_integer(MOD[THREE][TWO])</kbd>
SystemStackError: stack level too deep</samp></pre>

<p>No.</p>

<p>Ruby dives off into an infinite recursive loop when we call <code>MOD</code>, because our translation of Ruby’s native functionality into procs has missed something important about the semantics of conditionals. In languages like Ruby, the <code>if</code>-<code>else</code> statement is <a href="http://en.wikipedia.org/wiki/Strict_function">non-strict</a> (a.k.a. “lazy”): you give it a condition and two blocks, and it evaluates the condition to decide which of the two blocks to evaluate and return — it never evaluates both.</p>

<p>The problem with our <code>IF</code> implementation is that we can’t take advantage of the lazy behaviour that’s built into Ruby <code>if</code>-<code>else</code>; we just say “call a proc, <code>IF</code>, with two other procs”, so Ruby charges ahead and evaluates both arguments before <code>IF</code> gets a chance to decide which one to return.</p>

<p>Look again at <code>MOD</code>:</p>

<pre><code>MOD =
  -&gt; m { -&gt; n {
    IF[IS_LESS_OR_EQUAL[n][m]][
      MOD[SUBTRACT[m][n]][n]
    ][
      m
    ]
  } }</code></pre>

<p>When we call <code>MOD</code> with values for <code>m</code> and <code>n</code>, and Ruby starts evaluating the body of the inner proc, it reaches the recursive call to <code>MOD[SUBTRACT[m][n]][n]</code> and immediately starts evaluating it as an argument to pass to <code>IF</code>, regardless of whether <code>IS_LESS_OR_EQUAL[n][m]</code> evaluated to <code>TRUE</code> or <code>FALSE</code>. This second call to <code>MOD</code> results in another unconditional recursive call, and so on, hence the infinite recursion.</p>

<p>To fix this we need a way of telling Ruby to defer evaluation of <code>IF</code>’s second argument until we’re sure we need it. Evaluation of any expression in Ruby can be deferred by wrapping it in a proc, but wrapping an arbitrary Ruby value in a proc will generally change its meaning (e.g. <code>41 + 1</code> does not equal <code>-&gt; { 41 + 1 }</code>) so we might need to be more clever.</p>

<p>Fortunately we don’t, because this is a special case: we know that the result of calling <code>MOD</code> will be a single-argument proc, because <em>all</em> of our values are single-argument procs, and we <a href="#extensionality">already know</a> that wrapping any proc <code>p</code> with another proc that takes the same arguments as <code>p</code> and immediately calls <code>p</code> with them will produce a value that is indistinguishable from just <code>p</code>, so we can use that trick here to defer the recursive call without affecting the meaning of the value being passed into <code>IF</code>:</p>

<pre><code>MOD =
  -&gt; m { -&gt; n {
    IF[IS_LESS_OR_EQUAL[n][m]][
      <ins>-&gt; x {</ins>
        MOD[SUBTRACT[m][n]][n]<ins>[x]</ins>
      <ins>}</ins>
    ][
      m
    ]
  } }</code></pre>

<p>This wraps the recursive <code>MOD</code> call in <code>-&gt; x { …[x] }</code> to defer it; Ruby now won’t try to evaluate the body of that proc when it calls <code>IF</code>, but if the proc gets chosen by <code>IF</code> and returned as the result, it can be called by its recipient to finally trigger the (now definitely required) recursive call to <code>MOD</code>.</p>

<p>Does <code>MOD</code> work <em>now</em>?</p>

<pre><samp>&gt;&gt; <kbd>to_integer(MOD[THREE][TWO])</kbd>
=&gt; 1

&gt;&gt; <kbd>to_integer(MOD[
     POWER[THREE][THREE]
   ][
     ADD[THREE][TWO]
   ])</kbd>
=&gt; 2</samp></pre>

<p>Yes! Hooray!</p>

<p>But don’t celebrate yet, because there’s another, more insidious problem: we are defining the constant <code>MOD</code> <em>in terms of the constant <code>MOD</code></em>, so this definition is <em>not</em> just an innocent abbreviation. This time we’re not merely assigning a complex proc to a constant in order to reuse it later; in fact, we’re relying on Ruby’s <a href="http://en.wikipedia.org/wiki/Assignment_(computer_science)#Semantics">assignment semantics</a> in order to assume that, even though <code>MOD</code> has obviously not yet been defined while we’re still defining it, we can nonetheless refer to it in <code>MOD</code>’s implementation and expect it to have <em>become</em> defined by the time we evaluate it later.</p>

<p>That’s cheating, because in principle we should be able to undo all of the abbreviations — “where I said <code>MOD</code>, what I actually meant was this long proc” — but that’s impossible as long as <code>MOD</code> is defined in terms of itself.</p>

<p>We can solve this problem with the <a href="http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator">Y combinator</a>, a famous piece of helper code designed for exactly this purpose: defining a recursive function without cheating. Here’s what it looks like:</p>

<pre><code>Y = -&gt; f { -&gt; x { f[x[x]] }
          [-&gt; x { f[x[x]] }] }</code></pre>

<p>The Y combinator is hard to explain accurately without lots of detail, but here’s a (technically inaccurate) sketch: when you call the Y combinator with a proc, it will call that proc <em>with the proc itself as the first argument</em>. So, if you write a proc that expects an argument and then call the Y combinator with that proc, then the proc will get itself as that argument and therefore can use that argument whenever it wants to call itself.</p>

<p>Sadly, for the same reason that <code>MOD</code> was looping forever, the Y combinator will loop forever in Ruby too, so we need a modified version. It’s the expression <code>x[x]</code> that causes the problem, and we can again fix the problem by wrapping the occurrences of that expression in impotent <code>-&gt; y { …[y] }</code> procs to defer their evaluation:</p>

<pre><code><ins>Z</ins> = -&gt; f { -&gt; x { f[<ins>-&gt; y {</ins> x[x]<ins>[y] }</ins>] }
          [-&gt; x { f[<ins>-&gt; y {</ins> x[x]<ins>[y] }</ins>] }] }</code></pre>

<p>This is the <a href="http://en.wikipedia.org/wiki/Fixed-point_combinator#Other_fixed-point_combinators">Z combinator</a>, which is just the Y combinator adapted for <a href="http://en.wikipedia.org/wiki/Evaluation_strategy#Strict_evaluation">strict</a> languages like Ruby. (The verbatim Y combinator only works in <abbr title="batshit"><a href="http://en.wikipedia.org/wiki/Evaluation_strategy#Non-strict_evaluation">non-strict</a></abbr> languages like <a href="http://haskell.org/">Haskell</a>.)</p>

<p>We can now finally make a satisfactory implementation of <code>MOD</code> by giving it an extra argument, <code>f</code>, wrapping a call to the Z combinator around it, and calling <code>f</code> where we used to call <code>MOD</code>:</p>

<pre><code>MOD =
  <ins>Z[-&gt; f {</ins> -&gt; m { -&gt; n {
    IF[IS_LESS_OR_EQUAL[n][m]][
      -&gt; x {
        <ins>f</ins>[SUBTRACT[m][n]][n][x]
      }
    ][
      m
    ]
  } } <ins>}]</ins></code></pre>

<p>Thankfully this non-cheating version of <code>MOD</code> still works:</p>

<pre><samp>&gt;&gt; <kbd>to_integer(MOD[THREE][TWO])</kbd>
=&gt; 1

&gt;&gt; <kbd>to_integer(MOD[
     POWER[THREE][THREE]
   ][
     ADD[THREE][TWO]
   ])</kbd>
=&gt; 2</samp></pre>

<p>Now we can replace all of the occurrences of <code>%</code> in the FizzBuzz program with calls to <code>MOD</code>:</p>

<pre><code>(ONE..HUNDRED).map do |n|
  IF[IS_ZERO[<ins>MOD[</ins>n<ins>][</ins>FIFTEEN<ins>]</ins>]][
    &#39;FizzBuzz&#39;
  ][IF[IS_ZERO[<ins>MOD[</ins>n<ins>][</ins>THREE<ins>]</ins>]][
    &#39;Fizz&#39;
  ][IF[IS_ZERO[<ins>MOD[</ins>n<ins>][</ins>FIVE<ins>]</ins>]][
    &#39;Buzz&#39;
  ][
    n.to_s
  ]]]
end</code></pre>

<h2 id="lists-briefly">Lists, briefly</h2>

<p>We only have a few Ruby features left to reimplement for FizzBuzz: the range, the <code>#map</code>, the string literals and the <code>Fixnum#to_s</code>. We’ve seen lots of detail for the other values and operations we’ve implemented, so I’ll go through the remaining ones quickly and in as little detail as possible. (Don’t worry about understanding everything; I’ll just be giving a flavour.)</p>

<p>To be able to implement ranges and <code>#map</code> we need an implementation of lists. The easiest way to build lists is to use <a href="http://en.wikipedia.org/wiki/Ordered_pair">pairs</a>, which are like two-element arrays. Pairs are quite easy to implement:</p>

<pre><code>PAIR  = -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }
LEFT  = -&gt; p { p[-&gt; x { -&gt; y { x } } ] }
RIGHT = -&gt; p { p[-&gt; x { -&gt; y { y } } ] }</code></pre>

<p>The purpose of a pair is to store two values and provide them again on request. To construct a pair we call <code>PAIR</code> with two values, an <code>x</code> and a <code>y</code>, and it returns its inner proc:</p>

<pre><code>-&gt; f { f[x][y] }</code></pre>

<p>This is a proc which, when called with another proc, will call it back with the earlier values of <code>x</code> and <code>y</code> as arguments. <code>LEFT</code> and <code>RIGHT</code> are the operations which pick out the left and the right element of a pair by calling it with a proc that returns its first or second argument respectively. It all works simply enough:</p>

<pre><samp>&gt;&gt; <kbd>my_pair = PAIR[THREE][FIVE]</kbd>
=&gt; #&lt;Proc (lambda)&gt;

&gt;&gt; <kbd>to_integer(LEFT[my_pair])</kbd>
=&gt; 3

&gt;&gt; <kbd>to_integer(RIGHT[my_pair])</kbd>
=&gt; 5</samp></pre>

<p>Once we have pairs, we can use them to implement lists. This implementation works like a <a href="http://en.wikipedia.org/wiki/Linked_list">linked list</a>, where each pair stores a value and a pointer to the next pair in the list; in this case we use nested pairs instead of pointers. The <a href="http://en.wikipedia.org/wiki/List_(abstract_data_type)#Operations">standard list operations</a> look like this:</p>

<pre><code>EMPTY     = PAIR[TRUE][TRUE]
UNSHIFT   = -&gt; l { -&gt; x {
              PAIR[FALSE][PAIR[x][l]]
            } }
IS_EMPTY  = LEFT
FIRST     = -&gt; l { LEFT[RIGHT[l]] }
REST      = -&gt; l { RIGHT[RIGHT[l]] }</code></pre>

<p>And they work like this:</p>

<pre><samp>&gt;&gt; <kbd>my_list =
     UNSHIFT[
       UNSHIFT[
         UNSHIFT[EMPTY][THREE]
       ][TWO]
     ][ONE]</kbd>
=&gt; #&lt;Proc (lambda)&gt;

&gt;&gt; <kbd>to_integer(FIRST[my_list])</kbd>
=&gt; 1

&gt;&gt; <kbd>to_integer(FIRST[REST[my_list]])</kbd>
=&gt; 2

&gt;&gt; <kbd>to_integer(FIRST[REST[REST[my_list]]])</kbd>
=&gt; 3

&gt;&gt; <kbd>to_boolean(IS_EMPTY[my_list])</kbd>
=&gt; false

&gt;&gt; <kbd>to_boolean(IS_EMPTY[EMPTY])</kbd>
=&gt; true</samp></pre>

<p>Using <code>FIRST</code> and <code>REST</code> to pull out individual elements of lists is quite clumsy, so as with numbers and booleans we can write a <code>#to_array</code> method to help us on the console:</p>

<pre><code>def to_array(proc)
  array = []

  until to_boolean(IS_EMPTY[proc])
    array.push(FIRST[proc])
    proc = REST[proc]
  end

  array
end</code></pre>

<p>This makes it easier to inspect lists:</p>

<pre><samp>&gt;&gt; <kbd>to_array(my_list)</kbd>
=&gt; [#&lt;Proc (lambda)&gt;, #&lt;Proc (lambda)&gt;, #&lt;Proc (lambda)&gt;]

&gt;&gt; <kbd>to_array(my_list).map { |p| to_integer(p) }</kbd>
=&gt; [1, 2, 3]</samp></pre>

<p>How can we implement ranges? In fact, instead of finding a way to explicitly represent ranges as procs, let’s just write a proc that can build a list of all the elements in a range. For native Ruby numbers and “lists” (i.e. arrays) we can write it like this:</p>

<pre><code>def range(m, n)
  if m &lt;= n
    range(m + 1, n).unshift(m)
  else
    []
  end
end</code></pre>

<p>This algorithm is slightly contrived in anticipation of the available list operations, but it makes sense: the list of all the numbers from <code>m</code> to <code>n</code> is the same as the list of all the numbers from <code>m + 1</code> to <code>n</code> with <code>m</code> unshifted onto the front; if <code>m</code> is greater than <code>n</code> then the list of numbers is empty.</p>

<p>Happily we already have everything we need to translate this method directly into procs:</p>

<pre><code>RANGE =
  Z[-&gt; f {
    -&gt; m { -&gt; n {
      IF[IS_LESS_OR_EQUAL[m][n]][
        -&gt; x {
          UNSHIFT[f[INCREMENT[m]][n]][m][x]
        }
      ][
        EMPTY
      ]
    } }
  }]</code></pre>

<p>(Note the use of the Z combinator for recursion, and a deferring <code>-&gt; x { …[x] }</code> proc around the <code>TRUE</code> branch of the conditional.)</p>

<p>Does this work?</p>

<pre><samp>&gt;&gt; <kbd>my_range = RANGE[ONE][FIVE]</kbd>
=&gt; #&lt;Proc (lambda)&gt;

&gt;&gt; <kbd>to_array(my_range).map { |p| to_integer(p) }</kbd>
=&gt; [1, 2, 3, 4, 5]</samp></pre>

<p>Yes, so let’s use it in FizzBuzz:</p>

<pre><code><ins>RANGE[</ins>ONE<ins>][</ins>HUNDRED<ins>]</ins>.map do |n|
  IF[IS_ZERO[MOD[n][FIFTEEN]]][
    &#39;FizzBuzz&#39;
  ][IF[IS_ZERO[MOD[n][THREE]]][
    &#39;Fizz&#39;
  ][IF[IS_ZERO[MOD[n][FIVE]]][
    &#39;Buzz&#39;
  ][
    n.to_s
  ]]]
end</code></pre>

<p>To implement <code>#map</code> we can use a helper called <code><a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">FOLD</a></code>, which is a bit like Ruby’s <code><a href="http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-inject">Enumerable#inject</a></code>:</p>

<pre><code>FOLD =
  Z[-&gt; f {
    -&gt; l { -&gt; x { -&gt; g {
      IF[IS_EMPTY[l]][
        x
      ][
        -&gt; y {
          g[f[REST[l]][x][g]][FIRST[l]][y]
        }
      ]
    } } }
  }]</code></pre>

<p><code>FOLD</code> makes it easier to write procs that process every item in a list:</p>

<pre><samp>&gt;&gt; <kbd>to_integer(FOLD[RANGE[ONE][FIVE]][ZERO][ADD])</kbd>
=&gt; 15

&gt;&gt; <kbd>to_integer(FOLD[RANGE[ONE][FIVE]][ONE][MULTIPLY])</kbd>
=&gt; 120</samp></pre>

<p>Once we have <code>FOLD</code>, we can write <code>MAP</code> concisely:</p>

<pre><code>MAP =
  -&gt; k { -&gt; f {
    FOLD[k][EMPTY][
      -&gt; l { -&gt; x { UNSHIFT[l][f[x]] } }
    ]
  } }</code></pre>

<p>Does <code>MAP</code> work?</p>

<pre><samp>&gt;&gt; <kbd>my_list = MAP[RANGE[ONE][FIVE]][INCREMENT]</kbd>
=&gt; #&lt;Proc (lambda)&gt;

&gt;&gt; <kbd>to_array(my_list).map { |p| to_integer(p) }</kbd>
=&gt; [2, 3, 4, 5, 6]</samp></pre>

<p>Yes. So we can replace <code>#map</code> in FizzBuzz:</p>

<pre><code><ins>MAP[</ins>RANGE[ONE][HUNDRED]<ins>][-&gt;</ins> n <ins>{</ins>
  IF[IS_ZERO[MOD[n][FIFTEEN]]][
    &#39;FizzBuzz&#39;
  ][IF[IS_ZERO[MOD[n][THREE]]][
    &#39;Fizz&#39;
  ][IF[IS_ZERO[MOD[n][FIVE]]][
    &#39;Buzz&#39;
  ][
    n.to_s
  ]]]
<ins>}]</ins></code></pre>

<p>Nearly finished! All that remains is to deal with the strings.</p>

<h2 id="strings-briefly">Strings, briefly</h2>

<p>Strings are easy to handle: we can just represent them as lists of numbers, as long as we agree on an <a href="http://en.wikipedia.org/wiki/Character_encoding">encoding</a> that determines which number represents which character.</p>

<p>We can choose any encoding we want, so instead of using a general-purpose one like <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>, let’s design a new one that’s more convenient for FizzBuzz. We only need to encode digits and the strings <code>&#39;FizzBuzz&#39;</code>, <code>&#39;Fizz&#39;</code> and <code>&#39;Buzz&#39;</code>, so we can use the numbers <code>0</code> to <code>9</code> to represent the characters <code>&#39;0&#39;</code> to <code>&#39;9&#39;</code>, and the numbers from <code>10</code> to <code>14</code> to encode the characters <code>&#39;B&#39;</code>, <code>&#39;F&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;u&#39;</code> and <code>&#39;z&#39;</code>.</p>

<p>This already gives us a way to represent the string literals we need (being careful not to <a href="http://en.wikipedia.org/wiki/Clobbering">clobber</a> the Z combinator):</p>

<pre><code>TEN = MULTIPLY[TWO][FIVE]
B   = TEN
F   = INCREMENT[B]
I   = INCREMENT[F]
U   = INCREMENT[I]
ZED = INCREMENT[U]

FIZZ     = UNSHIFT[UNSHIFT[UNSHIFT[UNSHIFT[EMPTY][ZED]][ZED]][I]][F]
BUZZ     = UNSHIFT[UNSHIFT[UNSHIFT[UNSHIFT[EMPTY][ZED]][ZED]][U]][B]
FIZZBUZZ = UNSHIFT[UNSHIFT[UNSHIFT[UNSHIFT[BUZZ][ZED]][ZED]][I]][F]</code></pre>

<p>To check that these work, we can write some external methods to convert them into Ruby strings:</p>

<pre><code>def to_char(c)
  &#39;0123456789BFiuz&#39;.slice(to_integer(c))
end

def to_string(s)
  to_array(s).map { |c| to_char(c) }.join
end</code></pre>

<p>Alright, do the strings work?</p>

<pre><samp>&gt;&gt; <kbd>to_char(ZED)</kbd>
=&gt; &#34;z&#34;

&gt;&gt; <kbd>to_string(FIZZBUZZ)</kbd>
=&gt; &#34;FizzBuzz&#34;</samp></pre>

<p>Great. So we can use them in FizzBuzz:</p>

<pre><code>MAP[RANGE[ONE][HUNDRED]][-&gt; n {
  IF[IS_ZERO[MOD[n][FIFTEEN]]][
    <ins>FIZZBUZZ</ins>
  ][IF[IS_ZERO[MOD[n][THREE]]][
    <ins>FIZZ</ins>
  ][IF[IS_ZERO[MOD[n][FIVE]]][
    <ins>BUZZ</ins>
  ][
    n.to_s
  ]]]
}]</code></pre>

<p>The very last thing to implement is <code>Fixnum#to_s</code>. For that we need to be able to split a number into its component digits, so here’s one way to do that in Ruby:</p>

<pre><code>def to_digits(n)
  previous_digits =
    if n &lt; 10
      []
    else
      to_digits(n / 10)
    end

  previous_digits.push(n % 10)
end</code></pre>

<p>We haven’t implemented <code>&lt;</code>, but we can dodge that problem by using <code>n &lt;= 9</code> instead of <code>n &lt; 10</code>. Unfortunately we can’t dodge implementing <code><a href="http://ruby-doc.org/core-1.9.3/Fixnum.html#method-i-2F">Fixnum#/</a></code> and <code><a href="http://ruby-doc.org/core-1.9.3/Array.html#method-i-push">Array#push</a></code>, so here they are:</p>

<pre><code>DIV =
  Z[-&gt; f { -&gt; m { -&gt; n {
    IF[IS_LESS_OR_EQUAL[n][m]][
      -&gt; x {
        INCREMENT[f[SUBTRACT[m][n]][n]][x]
      }
    ][
      ZERO
    ]
  } } }]

PUSH =
  -&gt; l {
    -&gt; x {
      FOLD[l][UNSHIFT[EMPTY][x]][UNSHIFT]
    }
  }</code></pre>

<p>Now we can translate <code>#to_digits</code> into a proc:</p>

<pre><code>TO_DIGITS =
  Z[-&gt; f { -&gt; n { PUSH[
    IF[IS_LESS_OR_EQUAL[n][DECREMENT[TEN]]][
      EMPTY
    ][
      -&gt; x {
        f[DIV[n][TEN]][x]
      }
    ]
  ][MOD[n][TEN]] } }]</code></pre>

<p>Does it work?</p>

<pre><samp>&gt;&gt; <kbd>to_array(TO_DIGITS[FIVE]).map { |p| to_integer(p) }</kbd>
=&gt; [5]

&gt;&gt; <kbd>to_array(TO_DIGITS[POWER[FIVE][THREE]]).map { |p| to_integer(p) }</kbd>
=&gt; [1, 2, 5]</samp></pre>

<p>Yes. And because we had the foresight to design a string encoding where <code>1</code> represents <code>&#39;1&#39;</code> and so on, the arrays produced by <code>TO_DIGITS</code> are already valid strings:</p>

<pre><samp>&gt;&gt; <kbd>to_string(TO_DIGITS[FIVE])</kbd>
=&gt; &#34;5&#34;

&gt;&gt; <kbd>to_string(TO_DIGITS[POWER[FIVE][THREE]])</kbd>
=&gt; &#34;125&#34;</samp></pre>

<p>So we can replace <code>#to_s</code> with <code>TO_DIGITS</code> in FizzBuzz:</p>

<pre><code>MAP[RANGE[ONE][HUNDRED]][-&gt; n {
  IF[IS_ZERO[MOD[n][FIFTEEN]]][
    FIZZBUZZ
  ][IF[IS_ZERO[MOD[n][THREE]]][
    FIZZ
  ][IF[IS_ZERO[MOD[n][FIVE]]][
    BUZZ
  ][
    <ins>TO_DIGITS[</ins>n<ins>]</ins>
  ]]]
}]</code></pre>

<h2 id="victory">Victory</h2>

<p>We’ve finally finished! (This would’ve been the longest, most awkward job interview ever.) Here is FizzBuzz, written entirely with procs:</p>

<pre><code>MAP[RANGE[ONE][HUNDRED]][-&gt; n {
  IF[IS_ZERO[MOD[n][FIFTEEN]]][
    FIZZBUZZ
  ][IF[IS_ZERO[MOD[n][THREE]]][
    FIZZ
  ][IF[IS_ZERO[MOD[n][FIVE]]][
    BUZZ
  ][
    TO_DIGITS[n]
  ]]]
}]</code></pre>

<p>But wait! We’ve gone to a lot of trouble to make sure that every constant is just an abbreviation of some longer expression, so we owe it to ourselves to replace each constant with its definition in order to reveal the full glorious program:</p>

<pre><code>-&gt; k { -&gt; f { -&gt; f { -&gt; x { f[-&gt; y { x[x][y] }] }[-&gt; x { f[-&gt; y { x[x][y] }] }] }[-&gt; f { -&gt; l { -&gt; x { -&gt; g { -&gt; b { b }[-&gt; p { p[-&gt; x { -&gt; y { x } } ] }[l]][x][-&gt; y { g[f[-&gt; l { -&gt; p { p[-&gt; x { -&gt; y { y } } ] }[-&gt; p { p[-&gt; x { -&gt; y { y } } ] }[l]] }[l]][x][g]][-&gt; l { -&gt; p { p[-&gt; x { -&gt; y { x } } ] }[-&gt; p { p[-&gt; x { -&gt; y { y } } ] }[l]] }[l]][y] }] } } } }][k][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { x } }][-&gt; x { -&gt; y { x } }]][-&gt; l { -&gt; x { -&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[l][f[x]] } }] } }[-&gt; f { -&gt; x { f[-&gt; y { x[x][y] }] }[-&gt; x { f[-&gt; y { x[x][y] }] }] }[-&gt; f { -&gt; m { -&gt; n { -&gt; b { b }[-&gt; m { -&gt; n { -&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]] } }[m][n]][-&gt; x { -&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[f[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[m]][n]][m][x] }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { x } }][-&gt; x { -&gt; y { x } }]] } } }][-&gt; p { -&gt; x { p[x] } }][-&gt; p { -&gt; x { p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[x]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] } }]][-&gt; n { -&gt; b { b }[-&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; f { -&gt; x { f[-&gt; y { x[x][y] }] }[-&gt; x { f[-&gt; y { x[x][y] }] }] }[-&gt; f { -&gt; m { -&gt; n { -&gt; b { b }[-&gt; m { -&gt; n { -&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]] } }[n][m]][-&gt; x { f[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]][n][x] } ][m] } } }][n][-&gt; p { -&gt; x { p[p[p[p[p[p[p[p[p[p[p[p[p[p[p[x]]]]]]]]]]]]]]] } }]]][-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { x } }][-&gt; x { -&gt; y { x } }]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]][-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]][-&gt; b { b }[-&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; f { -&gt; x { f[-&gt; y { x[x][y] }] }[-&gt; x { f[-&gt; y { x[x][y] }] }] }[-&gt; f { -&gt; m { -&gt; n { -&gt; b { b }[-&gt; m { -&gt; n { -&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]] } }[n][m]][-&gt; x { f[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]][n][x] }][m] } } }][n][-&gt; p { -&gt; x { p[p[p[x]]] } }]]][-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { x } }][-&gt; x { -&gt; y { x } }]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]][-&gt; b { b }[-&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; f { -&gt; x { f[-&gt; y { x[x][y] }] }[-&gt; x { f[-&gt; y { x[x][y] }] }] }[-&gt; f { -&gt; m { -&gt; n { -&gt; b { b }[-&gt; m { -&gt; n { -&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]] } }[n][m]][-&gt; x { f[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]][n][x] }][m] } } }][n][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]][-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { x } }][-&gt; x { -&gt; y { x } }]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]]][-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]]]][-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]][-&gt; f { -&gt; x { f[-&gt; y { x[x][y] }] }[-&gt; x { f[-&gt; y { x[x][y] }] }] }[-&gt; f { -&gt; n { -&gt; l { -&gt; x { -&gt; f { -&gt; x { f[-&gt; y { x[x][y] }] }[-&gt; x { f[-&gt; y { x[x][y] }] }] }[-&gt; f { -&gt; l { -&gt; x { -&gt; g { -&gt; b { b }[-&gt; p { p[-&gt; x { -&gt; y { x } }] }[l]][x][-&gt; y { g[f[-&gt; l { -&gt; p { p[-&gt; x { -&gt; y { y } }] }[-&gt; p { p[-&gt; x { -&gt; y { y } }] }[l]] }[l]][x][g]][-&gt; l { -&gt; p { p[-&gt; x { -&gt; y { x } }] }[-&gt; p { p[-&gt; x { -&gt; y { y } }] }[l]] }[l]][y] }] } } } }][l][-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }[-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { x } }][-&gt; x { -&gt; y { x } }]][x]][-&gt; l { -&gt; x { -&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { y } }][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[x][l]] } }] } }[-&gt; b { b }[-&gt; m { -&gt; n { -&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]] } }[n][-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }[-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]]][-&gt; x { -&gt; y { -&gt; f { f[x][y] } } }[-&gt; x { -&gt; y { x } }][-&gt; x { -&gt; y { x } }]][-&gt; x { f[-&gt; f { -&gt; x { f[-&gt; y { x[x][y] }] }[-&gt; x { f[-&gt; y { x[x][y] }] }] }[-&gt; f { -&gt; m { -&gt; n { -&gt; b { b }[-&gt; m { -&gt; n { -&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]] } }[n][m]][-&gt; x { -&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }[f[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]][n]][x] }][-&gt; p { -&gt; x { x } }] } } }][n][-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]][x] }]][-&gt; f { -&gt; x { f[-&gt; y { x[x][y] }] }[-&gt; x { f[-&gt; y { x[x][y] }] }] }[-&gt; f { -&gt; m { -&gt; n { -&gt; b { b }[-&gt; m { -&gt; n { -&gt; n { n[-&gt; x { -&gt; x { -&gt; y { y } } }][-&gt; x { -&gt; y { x } }] }[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]] } }[n][m]][-&gt; x { f[-&gt; m { -&gt; n { n[-&gt; n { -&gt; f { -&gt; x { n[-&gt; g { -&gt; h { h[g[f]] } }][-&gt; y { x }][-&gt; y { y }] } } }][m] } }[m][n]][n][x] }][m] } } }][n][-&gt; m { -&gt; n { n[-&gt; m { -&gt; n { n[-&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }][m] } }[m]][-&gt; p { -&gt; x { x } }] } }[-&gt; p { -&gt; x { p[p[x]] } }][-&gt; p { -&gt; x { p[p[p[p[p[x]]]]] } }]]] } }][n]]]] }]</code></pre>

<p><a href="https://gist.github.com/1466504">Beautiful</a>.</p>

<h2 id="why">Why?</h2>

<p>Being limited to <code>Proc.new</code> and <code>Proc#call</code> sounds impossibly restrictive, but I’ve tried to present enough evidence to convince you that we can still build <em>any</em> data structure and implement <em>any</em> algorithm.</p>

<p>In this alien world there is no data, only code. Data is an inert artefact for controlling the behaviour of the code that reads it, but you can always cut out the middleman by replacing a piece of data with the living code that does what the data-reading code would have done when it read that data.</p>

<p>We don’t know how to design a programming language, or even make a computer, that has more <a href="http://en.wikipedia.org/wiki/Computable_function">computational power</a> than this combination of <code>Proc.new</code> and <code>Proc#call</code>. I think this is an awe-inspiring fundamental fact — like knowing that every atom in your body that isn’t hydrogen, helium or lithium was either synthesised in the heart of a <a href="http://en.wikipedia.org/wiki/Stellar_nucleosynthesis">star</a> or in the subsequent <a href="http://en.wikipedia.org/wiki/Supernova_nucleosynthesis">supernova</a> that distributed its matter throughout the universe. It tells us what we, as programmers, are made of.</p>

<p>So why doesn’t everyone just use <code>Proc.new</code> and <code>Proc#call</code> if they’re so powerful? Why do we have more elaborate programming languages at all, and what differentiates them from each other if they’re all equivalently capable of computation?</p>

<p>The answers are obvious: programming languages have different degrees of expressiveness and aesthetic appeal; some of them are safe, some of them are flexible, and that’s a trade-off; some of them have better performance than others; different languages have different qualities of ecosystem.</p>

<p>In fact, every aspect of a programming language’s design is a trade-off — what is expressive for <em>your</em> work may not be expressive for someone else’s — but there is a particular sweet spot among those trade-offs for people who care about simplicity, flexibility and syntactic beauty; Ruby is in <em>our</em> sweet spot.</p>

<p>There are many languages like Ruby, but this one is ours.</p>

<hr/>

<h2 id="epilogue">Epilogue</h2>

<p>The simple programming language demonstrated in this article is the <a href="http://en.wikipedia.org/wiki/Lambda_calculus">untyped lambda calculus</a>, and the implementations of datatypes are <a href="http://en.wikipedia.org/wiki/Church_encoding">Church encodings</a>. The lambda calculus is powerful because it’s <a href="http://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a>.</p>

<p>If you’d like to play with these implementations, please download the <a href="https://github.com/tomstuart/nothing">supplementary code</a>, where you can find <a href="https://github.com/tomstuart/nothing/blob/story/spec/nothing_spec.rb">specs</a> for everything I’ve shown you.</p>

<p>If you’re feeling brave you can <a href="https://github.com/tomstuart/nothing/tree/challenge">start from scratch</a> and try to make all these specs pass with your own proc-based implementations; if you’re not feeling brave, there’s <a href="https://github.com/tomstuart/nothing/tree/story">another branch</a> which <a href="https://github.com/tomstuart/nothing/compare/challenge...story">walks you through</a> writing those implementations (e.g. <a href="https://github.com/tomstuart/nothing/commit/3bf39f9c9913ad568cbdae075966cc9c4dd25984">implementing <code>ADD</code>, <code>MULTIPLY</code> and <code>POWER</code></a>) as well as doing a bit of refactoring (e.g. <a href="https://github.com/tomstuart/nothing/commit/5e10048b4256085f554cafc7e379959cfbe5a71b">extracting a proc called <code>INJECT</code></a>).</p>

<p>Enjoy!</p>

      
    </article></div>
  </body>
</html>
