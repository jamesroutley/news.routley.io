<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/make/">Original</a>
    <h1>Using Landlock to Sandbox GNU Make</h1>
    
    <div id="readability-page-1" class="page">

<p>
Aug 7<sup>th</sup>, 2022 @ <a href="https://justine.lol/index.html">justine&#39;s web page</a>
</p>

<a href="https://justine.lol/make/openbsd.png"><img width="330" height="290" alt="[OpenBSD Blowfish Logo]" src="https://storage.googleapis.com/justine/pledge/openbsd.png"/></a>

<p>
I&#39;ve modified GNU Make to support strict dependency checking. This is
all thanks to the <a href="https://landlock.io/">Landlock LSM</a> system
calls which were introduced in Linux Kernel 5.13 twelve months ago. What
it means is that Make can now solve the cache invalidation problem
similar to <a href="https://bazel.build/">Bazel</a> except with 5x
better performance.

</p><h3 id="background">
  <a href="#background">
    Background
  </a>
</h3>

<p>
I blogged last month about our work
<a href="https://justine.lol/pledge/">porting OpenBSD pledge() and
unveil() to Linux</a> as part of
the <a href="https://github.com/jart/cosmopolitan">Cosmopolitan Libc</a>
project. The thought occurred to me that sandboxes aren&#39;t just good for
security: they have applications in build systems too. So I used
unveil() to patch GNU Make so it can function like a zero-configuration
sandbox, and I&#39;m making this work available to the community using
the <a href="https://justine.lol/ape.html">Actually Portable
Executable</a> format.

</p><h3 id="howitworks">
  <a href="#howitworks">
    How It Works
  </a>
</h3>

<p>
The basic idea is when Make runs a command, that command should only
have access to a limited number of files:

</p><ol>
<li>The resolved command executable (read/execute permission)
</li><li>The &#34;prerequisite&#34; or dependent files (read-only permission)
</li><li>The &#34;target&#34; output file (read/write/create permission)
</li></ol>

<p>
That way, if some rogue unit test accidentally tries to <code>rm -rf
/</code>, the kernel will simply reject it using an <code>EACCES</code>
error, because your root directory wasn&#39;t declared as a dependency in
your Makefile config.

</p><p>
For convenience, I&#39;ve also chosen to implicitly whitelist a few other
hard-coded paths. The following files are always unveiled by Make:

</p><ul>
<li><code>o/tmp</code> (<code>rwcx</code> perm) and <code>/tmp</code> (<code>rwc</code> perm) for temporary files
</li><li><code>o/third_party/gcc</code> (<code>rx</code> permission) for static toolchain binaries
</li><li><code>build/bootstrap</code> (<code>rx</code> permission) for chicken-and-egg build tools
</li><li><code>/dev/stdout</code>, <code>/dev/stderr</code>, and other harmless well-known paths
</li></ul>

<h3 id="configuration">
  <a href="#configuration">
    Configuration
  </a>
</h3>

<p>
Landlock Make is configured simply by writing a normal Makefile. For
example, you can read the
<a href="https://github.com/jart/landlock-make/blob/master/Makefile">landlock-make/Makefile</a>
template to get the basic idea. However there&#39;s sometimes cases where
you want to do something special. Special variables have been introduced
for this purpose, which can be specified on a per-target basis:

</p><ul>
<li><code>TARGET: .UNSANDBOXED = 1</code> to disable sandboxing on a build target
</li><li><code>TARGET: .UNVEIL = [rwcx:]PATH...</code> to unveil without using prerequisites
</li></ul>

<p>
The <code>.UNVEIL</code> for example works basically the same way as the
new <code>.EXTRA_PREREQS</code> variable that was added to GNU Make this
last year. You can specify as many paths as you want. The permission
defaults to read-only, but you can override that by putting the
approriate letters with a colon in from of the file path. The
permissions take effect recursively too.

</p><h3 id="performance">
  <a href="#performance">
    Performance
  </a>
</h3>

<p>
Landlock Make can build code five times faster than Bazel, while
offering the same advantages in terms of safety. In other words, you get
all the benefits of a big corporation build system, in a tiny
lightweight binary that any indie developer can love.

</p><p>
To demonstrate this, I&#39;ve
configured <a href="https://github.com/jart/landlock-make">this
repository</a> to compile 448 <code>.c</code> files which are linked
into 40 executables. Building 448 files in 448 different sandboxes
takes:

</p><ul>
<li>3.0 seconds with Make
</li><li>11.6 seconds with Bazel
</li></ul>

<p>
Landlock Make is the winner here and Bazel is wrekt. The benchmark was
performed on a 2 core Ubuntu 22.04 VM with 4gb of RAM running Linux
5.15. Landlock requires Linux 5.13+. If you don&#39;t have Landlock in your
kernel, then GNU Make will silently continue along without sandboxing.

</p><h2 class="page" id="download">
  <a href="#download">
    Try It Out
    Â 
    <img src="https://storage.googleapis.com/justine/redbean/linux.png" title="Linux" alt="[Linux]" width="28" height="32"/>
    <img src="https://storage.googleapis.com/justine/redbean/openbsd.png" title="OpenBSD" alt="[OpenBSD]" width="34" height="32"/>
    <img src="https://storage.googleapis.com/justine/redbean/macos.png" title="MacOS" alt="[MacOS]" width="17" height="20"/>
    <img src="https://storage.googleapis.com/justine/redbean/freebsd64.png" title="FreeBSD" alt="[FreeBSD]" width="20" height="20"/>
    <img src="https://storage.googleapis.com/justine/redbean/netbsd2.png" title="NetBSD" alt="[NetBSD]" width="20" height="20"/>
    <img src="https://storage.googleapis.com/justine/redbean/windows10.png" title="Windows" alt="[Windows]" width="20" height="20"/>
  </a>
</h2>

<p>
Here&#39;s a patched prebuilt binary of Landlock Make. This binary is
fully-featured on Linux and OpenBSD. On Mac, FreeBSD, and NetBSD it
should be a good GNU Make replacement that doesn&#39;t do sandboxing. On
Windows, it kind of works, but isn&#39;t recommended.

</p><p>
  <a href="https://justine.lol/make/make.com">make.com</a></p><p>
Here&#39;s a template project for getting started.
This <a href="https://github.com/jart/landlock-make">GitHub project</a>
explains how to write a prim and proper Makefile that rigorously defines
all its dependencies. It contains both a Makefile config and and Bazel
config so you can reproduce the benchmarks.

</p><pre>git clone <a href="https://github.com/jart/landlock-make">https://github.com/jart/landlock-make</a>
cd landlock-make
build/bootstrap/make.com
</pre>

<p>
You can build Landlock Make from source here:

</p><pre>git clone <a href="https://github.com/jart/cosmopolitan">https://github.com/jart/cosmopolitan</a>
cd cosmopolitan
make -j8 o//third_party/make/make.com
</pre>

<h2 class="page" id="source">
  <a href="#source">
    Source Code
  </a>
</h2>

<ul>
  <li><a href="https://github.com/jart/cosmopolitan/blob/13c1c45075cb2a12e0624d392da9382cca040e4b/third_party/make/job.c">cosmopolitan/third_party/make/job.c</a></li><li><a href="https://github.com/jart/cosmopolitan/blob/13c1c45075cb2a12e0624d392da9382cca040e4b/libc/calls/unveil.c">cosmopolitan/libc/calls/unveil.c</a></li><li><a href="https://github.com/jart/cosmopolitan/blob/13c1c45075cb2a12e0624d392da9382cca040e4b/test/libc/calls/unveil_test.c">cosmopolitan/test/libc/calls/unveil_test.c</a></li></ul>

<h2 class="page" id="why">
  <a href="#why">
    Why It Matters
  </a>
</h2>

<p>
GNU Make already has a file dependency graph. It&#39;s a rich data structure
you define when you write your Makefile. It&#39;s a no-brainer to leverage
that data to implement a zero-configuration sandbox. That&#39;s the only way
to automatically prove a build configuration is correct. This technique
is commonly known as strict dependency checking. What it means is that
each target must declare all its dependencies. This must happen, since
otherwise GNU Make can&#39;t solve the second hardest problem in computer
science, which is cache invalidation.

</p><p>
Without strict dependency checking, your Makefile is going to behave in
strange and mysterious ways. You&#39;ll be constantly frustrated and running
<code>make clean</code> whenever something goes wrong, which slows
things down by forcing everything to start over. In the traditional
world of Make, even if you take great care in writing your makefile,
there&#39;s simply no way prove it&#39;s correct without sandboxing. It&#39;s the
missing link we&#39;ve been wanting for decades. It&#39;s a surprise no one&#39;s
done it sooner.

</p><p>
Google came to a similar conclusion back in the 2000&#39;s. They solved this
by ditching GNU Make and inventing a new build system called Blaze. A
<a href="http://google-engtools.blogspot.com/2011/08/build-in-cloud-how-build-system-works.html">blog
post</a> was published back in 2011 announcing their work. Google said
strict dependency checking was the key motivator for reinventing things.
Blaze was then later open sourced to the public as Bazel in 2015, but it
wasn&#39;t until 2021 that it was able to do strict dependency checking.

</p><p>
Because Bazel was written a long time ago, it implements sandboxing in a
clumsy way. Bazel creates a giant hierarchy of symbolic links. Then it
mounts and unmounts a ton of folders to create a fake filesystem which
is how they limit access. Worst of all, it&#39;s all written in Java, which
isn&#39;t very popular in the open source community. Bazel does however
deserve credit for all the work they put into making Java as tiny as
possible. Bazel is shipped as a 40mb single-file binary that extracts
itself on the fly. That&#39;s pretty impressive by Java standards, but it&#39;s
still a monster compared to my slim and sexy 438kb make.com binary which
runs on six operating systems and doesn&#39;t require extraction. It&#39;s only
got a few microseconds of startup latency too.

</p><p>
Mega-corporations love Bazel because its safety benefits enable them to
scale their eng efforts into monolithic repositories with petabytes of
code. So naturally they don&#39;t care that much if Bazel is fifty megs. I
however refuse to believe that safety and professionalism go hand in
hand with bloat. Not at any scale. I believe we can have our cake and
eat it too. That&#39;s why I view Landlock as being such a game changer. It
lets us have 85% the benefits of Blaze, in a tiny lightweight package.
Due to the fact that all the complexity of sandboxing is now being
abstracted by the Linux Kernel, all that I needed to do was add about
200 lines of code to the GNU Make codebase. No root, no mounts, no
chroot, no cgroups, and especially no Docker required! All you have to
do is issue a system call that tells the kernel which paths should be
accessible.

</p><h2 class="page" id="troubleshooting">
  <a href="#troubleshooting">
    Troubleshooting
  </a>
</h2>

<p>
Here are some basic troubleshooting commands you can try, should you
encounter any problems:

</p><pre>./make.com --strace   <span># system call logging</span>
./make.com -pn        <span># dump build graph</span>
./make.com --ftrace   <span># very verbose!</span>
</pre>

<h2 class="page" id="caveats">
  <a href="#caveats">
    Caveats
  </a>
</h2>

<p>
Landlock Make offers the strongest sandboxing when you:

</p><ol>
<li>Use static executables
</li><li>Vendor all tools and dependencies
</li></ol>

<p>
If your build rule launches a dynamic or interpreted executable that
relies on distro-installed files which are outside your project folder
(e.g. /usr/bin/cc) then Make will react by unveiling a very broad list
of paths:

</p><ul>
<li><code>/bin</code> with <code>rx</code> permissions
</li><li><code>/lib</code> with <code>rx</code> permissions
</li><li><code>/lib64</code> with <code>rx</code> permissions
</li><li><code>/usr/bin</code> with <code>rx</code> permissions
</li><li><code>/usr/lib</code> with <code>rx</code> permissions
</li><li><code>/usr/lib64</code> with <code>rx</code> permissions
</li><li><code>/usr/local/lib</code> with <code>rx</code> permissions
</li><li><code>/usr/local/lib64</code> with <code>rx</code> permissions
</li><li><code>/etc/ld-musl-x86_64.path</code> with <code>r</code> permissions
</li><li><code>/etc/ld.so.conf</code> with <code>r</code> permissions
</li><li><code>/etc/ld.so.cache</code> with <code>r</code> permissions
</li><li><code>/etc/ld.so.conf.d</code> with <code>r</code> permissions
</li><li><code>/etc/ld.so.preload</code> with <code>r</code> permissions
</li><li><code>/usr/include</code> with <code>r</code> permissions
</li><li><code>/usr/share/locale</code> with <code>r</code> permissions
</li><li><code>/usr/share/locale-langpack</code> with <code>r</code> permissions
</li></ul>

<p>
So basically, depending on any system-provided functionality will schlep
in <em>nearly all</em> system-provided functionality. This isn&#39;t a great
situation to be in, since at that point, you&#39;re a hair&#39;s width away from
needing Docker. If you&#39;re not sure if you&#39;re being impacted, then you
can use <code>make.com --strace</code> to see what it does. The
landlock-make GitHub template repository takes a more conservative
approach, of vendoring a custom-built musl-cross-make gcc toolchain. It
only relies on the system for very trivial commands,
e.g. <code>mkdir</code>.

</p><p>
Yes,
the <a href="https://github.com/jart/landlock-make/blob/master/Makefile">Makefile
config</a> in the landlock-make GitHub template repo is very verbose.
Cosmopolitan Libc has tools for solving that. The
<a href="https://github.com/jart/cosmopolitan/blob/13c1c45075cb2a12e0624d392da9382cca040e4b/tool/build/mkdeps.c">mkdeps
program</a> is able to crawl 1.5 million lines of code in 100ms on my PC
to generate a 175,712 line <code>o/depend</code> file. It&#39;s so much
faster than using <code>gcc -M</code> and it totally automates the
arduous task of explicitly declaring header file dependencies. Give it a
try!

</p><p>
  <a href="https://justine.lol/make/mkdeps.com">mkdeps.com</a></p><p>
The mkdeps.com program is usually invoked as folllows:

</p><pre>./mkdeps.com -o o//depend -r o// @o//srcs.txt @o//hdrs.txt @o//incs.txt
</pre>

<p>
The @ symbol is useful for alternatively passing arguments in a file,
which is useful for situations where you have so many source files that
they&#39;d otherwise exceed <code>ARG_MAX</code>. Modern Make is really good
at quickly generating arguments files. For example, you might configure
mkdeps in your Makefile as follows:

</p><pre>uniq = $(<span>if</span> $1,$(<span>firstword</span> $1) $(<span>call</span> uniq,$(<span>filter-out</span> $(<span>firstword</span> $1),$1)))
o//srcs.txt: $(<span>call</span> uniq,$(<span>foreach</span> x,$(<span>SRCS</span>),$(dir $(x))))
	$(<span>file</span> &gt;$@,$(<span>SRCS</span>))
o//hdrs.txt: $(<span>call</span> uniq,$(<span>foreach</span> x,$(<span>HDRS</span>) $(<span>INCS</span>),$(dir $(x))))
	$(<span>file</span> &gt;$@,$(<span>HDRS</span>) $(<span>INCS</span>))
o//incs.txt: $(<span>call</span> uniq,$(<span>foreach</span> x,$(<span>INCS</span>) $(<span>INCS</span>),$(dir $(x))))
	$(<span>file</span> &gt;$@,$(<span>INCS</span>))
o//depend: o//srcs.txt o//hdrs.txt o//incs.txt $(<span>SRCS</span>) $(<span>HDRS</span>) $(<span>INCS</span>)
	./mkdeps.com -o $@ -r o// @o//srcs.txt @o//hdrs.txt @o//incs.txt
</pre>

<p>
Another thing to take into consideration, is it&#39;s best to refrain from
using shell script syntax in your build commands. If you don&#39;t use any
special characters, then GNU Make has an optimization where it&#39;ll pass
your command and arguments directly to execve(). That way Landlock will
know exactly which executable should be whitelisted. If you use special
shell syntax, then the files in your shell script might not be
whitelisted automatically, since we currently aren&#39;t parsing that.

</p><p>
Since Landlock is still very new, there&#39;s a few peculiar kinks about it
right now that some folks might find surprising. While we&#39;ve generally
been able to make it consistent on Linux with the OpenBSD behaviors,
there&#39;s still a few places where it differs slightly.

</p><p>
For example, unlike OpenBSD, Linux does nothing to conceal the existence
of paths. Even with an unveil() policy in place, it&#39;s still possible to
access the metadata of <em>all</em> files using functions
like <code>stat()</code> and <code>open(O_PATH)</code>, provided you
know the full path ahead of time. This means a sandboxed process can
always, for example, determine how many bytes of data are in
/etc/passwd, even through the contents of the file can&#39;t actually be
read. The good news is it&#39;s still not possible to use opendir() and go
fishing for paths which weren&#39;t previously known. So if you want to play
up your secrecy in addition to security, consider OpenBSD instead of
Linux.

</p><p>
Another truly weird behavior of Linux is that Landlock currently isn&#39;t
able to restrict file truncation. For example, did you know that opening
a file on Linux using <code>open(O_RDONLY | O_TRUNC)</code> will
actually delete the contents of the file? The same is also the case with
the <code>truncate()</code> system call, which is a blind spot with
Landlock. Right now Cosmopolitan Libc addresses this by blocking those
corner cases using the SECCOMP BPF security policies we&#39;ve programmed
into our pledge() polyfill. However we&#39;re not currently using pledge()
in make.com, since the emphasis is on preventing accidental missuse
rather than preventing malicious missuse. Please note, this may change
in the future, should we decide to beef up the security of make.com. If
this topic interests you, then please reach out and contact us, to let
us know what use cases and dreams you have in mind!

</p><p>
Finally please note that we haven&#39;t incorporated the GNU Make tests into
the Cosmopolitan Libc continuous integration system yet. Our C library
is still a relative newcomer that has gaps in terms of things like
locale support. The last time we checked the GNU Make test suite, our
port was 80% conformant. That hasn&#39;t stopped us from eating our own
dogfood though, since we use make.com every single day to maintain all
our repositories. If you encounter any issues with it, or are willing to
help us expand our C library implementation, then once again please
don&#39;t hesitate to reach out.

</p><h2 class="page" id="future">
  <a href="#future">
    Future Roadmap
  </a>
</h2>

<p>
Since my GNU Make fork is an Actually Portable Executable that runs on
six operating systems, it&#39;d be great to polyfill unveil() on other
operating systems too. The next fun project on my list will probably be
looking into FreeBSD jails, since I&#39;ve heard so many good things about
them on online forums.

</p><h2 class="page" id="thanks">
  <a href="#thanks">
    Special Thanks
  </a>
</h2>

<p>
I&#39;d like to thank <a href="https://twitter.com/l0kod">MickaÃ«l SalaÃ¼n</a>
for his work on bringing Landlock to the Linux Kernel, as well as being
a big help on Twitter.
<a href="https://github.com/The-King-of-Toasters">Stephen Gregoratto</a>
contributed the Linux unveil() implementation to Cosmopolitan Libc in
<a href="https://github.com/jart/cosmopolitan/pull/490">#490</a>. <a href="https://ahgamut.github.io/">Gautham
Venkatasubramanian</a> contributed the initial port
of <a href="https://github.com/jart/cosmopolitan/pull/305">GNU Make</a>
to Cosmopolitan Libc. I&#39;d also
thank <a href="https://www.unix-ag.uni-kl.de/~guenther/">GÃ¼nther
Noack</a> for offering superb code reviews and feedback.

</p><h2 class="page" id="funding">
  <a href="#funding">
    Funding
  </a>
</h2>

<p>
  <a href="https://justine.lol/lemuria.png">
    <picture>
      <source srcset="//storage.googleapis.com/justine/sectorlisp2/lemuria.webp" type="image/webp"/>
      <img src="https://storage.googleapis.com/justine/sectorlisp2/lemuria.png" width="850" height="360" alt="[United States of Lemuria - two dollar bill - all debts public and primate]"/>
    </picture>
  </a>

</p><p>
Funding for the development of this project was crowdsourced from
Justine Tunney&#39;s <a href="https://github.com/sponsors/jart">GitHub
sponsors</a> and <a href="https://www.patreon.com/jart">Patreon
subscribers</a>. Your support is what makes projects like Landlocked
Make possible. Thank you.

</p>
</div>
  </body>
</html>
