<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/automating-updates-to-a-digital-vigil/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Automating updates to a digital vigil</h1>
    
    <div id="readability-page-1" class="page"><div><p>November 20th each year is <a href="https://en.wikipedia.org/wiki/Transgender_Day_of_Remembrance">Transgender Day of Remembrance (TDoR)</a>.
It is a day when we memorialize those who&#39;ve been lost to transphobia, through violence or suicide.
And each year, I make the most difficult git commit of the year, updating the list of names in the <a href="https://tdor.xyz">digital vigil</a> that I made a few years ago.</p>
<p>I was late doing it this year, and I did it on November 20th last year.
Ideally, it would be done early.
I keep procrastinating it, because it&#39;s tough emotional work.
Next year, I want it to be <em>early</em>, so... how do I actually get myself to <em>do</em> that?</p>
<p>The solution is either more therapy or more automation.
So naturally, I decided on the automation!
(Don&#39;t worry, I have a therapist that I love.)</p>
<p>We&#39;ll need to solve two main problems: updating the lists of names, and deploying it on a schedule.</p>

<p>The digital vigil is a static site, and we need to know all the names when it&#39;s built.
All the names are stored in a couple of arrays of strings in a Rust file.
We&#39;ll want to update that file, which means we get to do codegen, baby!</p>
<p>Let&#39;s tackle <em>getting</em> the names first.</p>
<p>An authoritative source of names for TDoR vigils is the website <a href="https://tdor.translivesmatter.info">Trans Lives Matter</a>.
This is where I download the report from each year for manual updates.
It&#39;s a great source of data, and I&#39;m only using a fraction of what is there.</p>
<p>I decided to write a Python script to pull the data.
I got partway through the script using the same endpoint the human-consumable webpage offers for a download, when I realized it gives me a <em>zip file</em>.
After opening a few too many tabs, I remembered: there&#39;s an API for this!
Of course there&#39;s an API, and like all principal engineers working on their hobby projects, I didn&#39;t remember to check the obvious things first.
After switching to the API, I got JSON directly, and the data was super easy to retrieve.</p>
<p>Here&#39;s what that looks like.</p>
<pre data-lang="python"><code data-lang="python"><span>api_key </span><span>= </span><span>os.environ.get(</span><span>&#34;TDOR_API_KEY&#34;</span><span>)
</span><span>
</span><span>def </span><span>get_report</span><span>(</span><span>year</span><span>, </span><span>country</span><span>=</span><span>&#34;all&#34;</span><span>):
</span><span>    </span><span>&#34;&#34;&#34;Retrieves the data for a given year&#39;s vigil.
</span><span>
</span><span>    This will request the data from September 30 of the previous year through
</span><span>    October 1 of the requested year.
</span><span>
</span><span>    Params:
</span><span>        - year:     (int) what year&#39;s vigil the data is for
</span><span>        - country:  (str) scope of the data; default=&#34;all&#34;
</span><span>
</span><span>    &#34;&#34;&#34;
</span><span>
</span><span>    from_date </span><span>= </span><span>f</span><span>&#34;</span><span>{</span><span>year</span><span>-</span><span>1</span><span>}</span><span>-10-01&#34;
</span><span>    to_date </span><span>= </span><span>f</span><span>&#34;</span><span>{</span><span>year</span><span>}</span><span>-09-30&#34;
</span><span>
</span><span>    headers </span><span>= </span><span>{ </span><span>&#34;User-Agent&#34;</span><span>: </span><span>&#34;tdor-digital-vigil-bot&#34; </span><span>}
</span><span>    path </span><span>= </span><span>f</span><span>&#34;/api/v1/reports/?key=</span><span>{</span><span>api_key</span><span>}</span><span>&amp;from=</span><span>{</span><span>from_date</span><span>}</span><span>&amp;to=</span><span>{</span><span>to_date</span><span>}</span><span>&amp;country=</span><span>{</span><span>country</span><span>}</span><span>&amp;category=&amp;filter=&#34;
</span><span>
</span><span>    conn </span><span>= </span><span>http.client.HTTPSConnection(</span><span>&#34;tdor.translivesmatter.info&#34;</span><span>)
</span><span>    </span><span>conn.request(</span><span>&#34;GET&#34;</span><span>, path, </span><span>None</span><span>, headers)
</span><span>
</span><span>    resp </span><span>= </span><span>conn.getresponse()
</span><span>
</span><span>    </span><span>if </span><span>resp.status </span><span>!= </span><span>200</span><span>:
</span><span>        </span><span>print</span><span>(</span><span>f</span><span>&#34;Error: expected 200, got </span><span>{resp.status}</span><span> (</span><span>{resp.reason}</span><span>)&#34;</span><span>)
</span><span>        </span><span>exit(</span><span>1</span><span>)
</span><span>
</span><span>    body </span><span>= </span><span>resp.read()
</span><span>    data </span><span>= </span><span>json.loads(body)
</span><span>
</span><span>    </span><span>return </span><span>data
</span></code></pre>
<p>The next portion is fun and straightforward: turning this into some Rust code!
&#34;Codegen&#34; can make it sound fancy, but for a lot of problems like this, codegen can be really simple.</p>
<p>In this case, we just have a file that has two static arrays in it.
The code generation is really easy: iterate through our list of names, but bracket them with lines that start and end our declarations.</p>
<p>It looks like this.</p>
<pre data-lang="python"><code data-lang="python"><span>usa_data </span><span>= </span><span>get_report(</span><span>2025</span><span>, </span><span>&#34;usa&#34;</span><span>)
</span><span>all_data </span><span>= </span><span>get_report(</span><span>2025</span><span>, </span><span>&#34;all&#34;</span><span>)
</span><span>
</span><span>with </span><span>open</span><span>(</span><span>&#34;src/names.rs&#34;</span><span>, </span><span>&#34;w+&#34;</span><span>) </span><span>as </span><span>f:
</span><span>    all_names </span><span>= </span><span>[r[</span><span>&#34;name&#34;</span><span>] </span><span>for </span><span>r </span><span>in </span><span>all_data[</span><span>&#34;data&#34;</span><span>][</span><span>&#34;reports&#34;</span><span>]]
</span><span>    usa_names </span><span>= </span><span>[r[</span><span>&#34;name&#34;</span><span>] </span><span>for </span><span>r </span><span>in </span><span>usa_data[</span><span>&#34;data&#34;</span><span>][</span><span>&#34;reports&#34;</span><span>]]
</span><span>
</span><span>    </span><span>f.write(</span><span>f</span><span>&#34;pub const FULL_NAMES: [&amp;&#39;static str; </span><span>{</span><span>len</span><span>(all_names)}</span><span>] = [\n&#34;</span><span>)
</span><span>    </span><span>for </span><span>name </span><span>in </span><span>all_names:
</span><span>        </span><span>f.write(</span><span>f</span><span>&#34;    \&#34;</span><span>{name.replace(</span><span>&#34;\&#34;&#34;</span><span>, </span><span>&#34;\\\&#34;&#34;</span><span>)}</span><span>\&#34;,\n&#34;</span><span>)
</span><span>    </span><span>f.write(</span><span>&#34;];\n&#34;</span><span>)</span><span>;
</span><span>
</span><span>    </span><span>f.write(</span><span>&#34;\n&#34;</span><span>)
</span><span>
</span><span>    </span><span>f.write(</span><span>f</span><span>&#34;pub const US_NAMES: [&amp;&#39;static str; </span><span>{</span><span>len</span><span>(usa_names)}</span><span>] = [\n&#34;</span><span>)
</span><span>    </span><span>for </span><span>name </span><span>in </span><span>usa_names:
</span><span>        </span><span>f.write(</span><span>f</span><span>&#34;    \&#34;</span><span>{name.replace(</span><span>&#34;\&#34;&#34;</span><span>, </span><span>&#34;\\\&#34;&#34;</span><span>)}</span><span>\&#34;,\n&#34;</span><span>)
</span><span>    </span><span>f.write(</span><span>&#34;];\n&#34;</span><span>)</span><span>;
</span></code></pre>
<p>And generates a file like this.</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub const </span><span>FULL_NAMES</span><span>: [</span><span>&amp;</span><span>&#39;static str</span><span>; </span><span>367</span><span>] </span><span>= </span><span>[
</span><span>    </span><span>&#34;Name Withheld&#34;</span><span>,
</span><span>    </span><span>...
</span><span>];
</span><span>
</span><span>
</span><span>pub const </span><span>US_NAMES</span><span>: [</span><span>&amp;</span><span>&#39;static str</span><span>; </span><span>69</span><span>] </span><span>= </span><span>[
</span><span>    </span><span>...
</span><span>];
</span></code></pre>
<p>It worked the first time!
Definitely did <em>not</em> take me a few rounds of fixing silly bugs, no, definitely not.
Anyway!</p>
<p>We&#39;ve got that settled for this year.
Now we need to automate it.</p>

<p>The first thing I did here was turn to my favorite <em>simple</em> automation solutions: Jenkins and Kubernetes.
Of course, where&#39;s the fun in thinking about it ourselves?
Let&#39;s vibe code it.
I&#39;ll fire up Cursor using the latest Claude models and we can roll.</p>
<p>...</p>
<p>Ahahahaha no.</p>
<p>I&#39;m not going to vibe code a single thing, especially not on something so dear to me as this.
And we&#39;re not going to use Jenkins or Kubernetes here.
Not that I don&#39;t love them (I don&#39;t, but that&#39;s beside the point), there&#39;s just no reason to use them for this.</p>
<p>And here, we don&#39;t need much technology at all.
This could definitely be automated, to have deploys happen on a schedule without my involvement.
But... all those systems would be a little fragile, and if you run a deploy once a year, it&#39;s going to break.
Then you also need notifications for failures, and notifications for notification failures.</p>
<p>That&#39;s a lot of complexity for very little effort saved each year.
The problem I have isn&#39;t that the build is complicated.
I just run <code>make build</code> then <code>make deploy</code>.
The problem is that I <em>forget</em>.</p>
<p>And how do we solve forgetting?
Reminders.</p>
<p>I&#39;ll be reminded next year on October 15th to update the digital vigil.</p>
<p>* * *</p>
<p>Automation can be hard, but I think the <em>hardest</em> thing about it is knowing where to strike the balance.
What should you put in the effort for, and what should you just keep doing by hand?</p>
<p>For this problem, part of it benefited from automation code, and the other half from just setting myself reminders.
It is all about reducing friction.</p>
<p>Okay, now I&#39;ve made the hardest commit of the year, and I&#39;ve written about it.
I&#39;m steeped in some emotions right now, so I&#39;m going to go hug my wife and have some chocolate.
Take care of yourself, and remember that you are loved.</p>
<hr/>
</div><p>
  If you&#39;re looking to grow more effective as a software engineer, please consider my <a href="https://www.johndcook.com/coaching/">coaching services</a>.
  </p></div>
  </body>
</html>
