<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://raku-advent.blog/2021/12/11/unix_philosophy_without_leftpad_part2/">Original</a>
    <h1>Unix philosophy without left-pad, Part 2: Minimizing dependencies</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>In <a href="https://raku-advent.blog/2021/12/06/unix_philosophy_without_leftpad">my previous post</a>, I made the case that programming languages use a utility library to provide small-but-commonly-needed functions. Today I’m <a href="https://github.com/codesections/_">introducing a new module</a> that I hope will play this role for Raku.</p>
<p>In this post, I’ll introduce you to this new package as it exists today. Next, I’ll turn to plans for the future and how I’d like to see a Raku utility package grow over time. Then we’ll wrap up by taking a step back and discussing how all of this fits with the Unix philosophy.</p>

<h2><code>_</code></h2>
<h4 id="the_name">The name</h4>
<p>First of all, the name: <a href="https://github.com/codesections/_">the utility package I’ve released</a> is named <code>_</code> (pronounced/also known as <code>lowbar</code> just like <a href="https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references">in the HTML spec</a>). I recognize that most people will think that this name is a nod to JavaScript’s <a href="https://underscorejs.org/">underscore</a> and <a href="https://lodash.com/">lodash</a> libraries, but it’s not really meant as one. Lodash is a good library, but its goals/contents are different enough that I don’t feel any desire to reference Lodash with <code>_</code>’s name</p>
<p>Instead, the name <code>_</code> just falls naturally out of Raku’s topic variables: in Raku, if you want to refer to the current topic without giving it a specific name, you use the appropriate sigil followed by <code>_</code>: <a href="https://docs.raku.org/language/variables#The_$__variable"><code>$_</code></a> <a href="https://docs.raku.org/language/functions#Automatic_signatures"><code>@_</code></a>, or <a href="https://docs.raku.org/language/functions#Automatic_signatures"><code>%_</code></a>. So it’s only natural that a utilities package – which, by its nature, can’t have a particularly descriptive name – would use <code>_</code> (in this case without a sigil, since modules/packages don’t use sigils).</p>
<p>Besides, if it wasn’t named <code>_</code>, the other obvious name would be <code>util</code> – but that name is more-or-less occupied by a <a href="https://github.com/Util">fellow Rakoon</a>. And, finally, this name gives us the helpfully short use statement of <code>use _</code> – a nice feature for quick prototyping if <code>_</code> ends up being widely used. (For production use, you might want to qualify that use statement, as I’ll discuss later in this post. But starting with a short name is <em>also</em> helpful if our fully qualified use statement risks getting a bit long).</p>
<h4 id="the_goal">The goal</h4>
<p><code>_</code>’s purpose is to be a meta utility package that lets Raku programs avoid rewriting the same helper functions without embracing the excessive use of micro packages in the Raku ecosystem. When I say that <code>_</code> is a <em>meta</em> utility package, I mean something analogous to the idea of a Linux distro <a href="https://help.ubuntu.com/community/MetaPackages">metapackage</a>. Specifically, I mean that unlike many utility packages, <code>_</code> is comprised of individual sub-packages. Each sub-package has its own documentation/tests and is an independent unit. My intent is that you can read the README for a <code>_</code> sub-package and then use (and fully understand!) that sub-package without needing to know anything about any other <code>_</code> sub-package.</p>
<p>Additionally, every sub-package in<code>_</code> makes three promises:</p>
<ol>
<li>To have zero dependencies (with a grudging exception for <code>_</code> files or <a href="https://docs.raku.org/language/modules-core">Core modules</a>)</li>
<li>To have all its code in a single file (not counting tests/docs)</li>
<li>To keep that file to 70 or fewer lines</li>
</ol>
<p>If you have a package or script that meets those requirements and that you’d like to include, please feel free to open a PR. (Or even if it slightly exceeds the requirements; I’m willing to talk about how flexible <code>_</code> will be.)</p>
<h4 id="why_those_rules">Why those rules?</h4>
<p>These rules might strike some of you as a bit odd. In particular, why is <code>_</code> so focused on keeping the total code size down? I talked a bit about the value of reducing lines of code a bit in the previous post, but I know that <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/raau00/following_the_unix_philosophy_without_getting/hnhi5km/">not everyone was convinced</a>. And it <em>is</em> a reasonable question – if taken too far, writing concise code can <a href="https://code.golf/">reduce readability</a>, which is rather the opposite of our goal.</p>
<p>Here’s the answer: <code>_</code> packages are short so you can fully understand them. And, by understanding them, trust them.</p>
<p>My goal for <code>_</code> it that anyone fluent in Raku can open file for a <code>_</code> sub-package, read the code on their screen, and see 100% of the functionality that package implements. (That’s where the “70 lines” limit comes from – it’s my best guess for the number of lines that can fit on a typical screen.) Getting this global view will give you a very different level of confidence than we typically get from software – or at least that’s my hope.</p>
<p>I believe that <code>_</code> can provide this much-higher-than-normal level of confidence because the three rules above cut sub-packages off from something our profession is absolutely enamored with: <a href="https://en.wikipedia.org/wiki/Black_box">black box abstraction</a>. The idea of black box abstraction is that you can implement some complex functionality, box it up, and expose it to the outside world so carefully that the world can <em>totally ignore</em> the implementation details and can care only about the inputs and outputs.</p>
<figure>
<p><img src="https://codesections.com/photos/black_box.png" alt="An image depicting a function as a box that takes apples as input and produces bananas as output"/></p><figcaption>apples go in, bananas come out. You can’t explain that!</figcaption></figure>
<p>Now, don’t misunderstand me: I fully agree that it’s a <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/sicp/book/node13.html">phenomenally powerful tool</a>. Without black box abstraction, there’s simply no way that the vast majority of software in use today – including Raku – would be remotely possible.  Indeed, Raku makes great use of abstraction and I’m looking forward to the <a href="https://jnthn.net/papers/2020-cic-rakuast.pdf#page66R_mcid1">whole new set of abstractions</a> that Jonathan Worthington’s work on the Raku AST seems <a href="https://conf.raku.org/talk/147">poised to deliver</a> soon-ish.</p>
<p>As programmers <a href="https://stackoverflow.com/questions/2057503/does-anybody-know-from-where-the-layer-of-abstraction-layer-of-indirection-q">like to say</a>, there’s no problem that can’t be solved by adding another layer of abstraction – and, as a profession, we sure have solved a lot of problems. But we’ve also <em>created</em> a lot of problems.  And I think one reason we’ve created so many is that we often reach for black box abstraction too quickly, without putting enough consideration into the not-inconsiderable costs of additional abstraction.</p>
<p>In particular, whenever code depends on a black box, that means that the author of that code chose to rely on code that, <strong>by design</strong>, they didn’t need to understand. And they’re claiming that you <em>also</em> don’t need to understand that black-box code. But that means that you can never fully understand the code you’re currently reading either; the very best you can do is reach a partial understanding subject to the disclaimer “assuming both that I correctly understood the black box’s promises and that the black box keeps all its promises”.</p>
<p>The slight flaw is that <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">black boxes <strong>never</strong> keep all their promises</a>. Well, OK, that might be too strong; software <em>sometimes</em> works. But, at the least, you can never guarantee that any black box will keep any particular promise. As a result, anyone who relies on a black box will, sooner or later, need to open that box up and debug the tangled wires inside. And, as anyone who has ever followed a deep callstack can attest, that often means discovering all the various black boxes nested inside the first box and getting to play with your very own set of <a href="https://www.toolbox.com/tech/it-strategy/blogs/the-matryoshka-principle-and-software-design-101711/">software matryoshka dolls</a>.</p>
<p><a href="https://cheezburger.com/4767398656/theyre-total-egomatryoshkas-really"><img src="https://codesections.com/photos/nesting_dolls.png" alt="A meme-style image of a set of matryoshka dolls with the caption &#34;RUSSIAN DOLLS \n So full of themselves&#34;"/></a></p>
<p>In fact, you could say that the whole reason for <code>_</code> is that we can’t fully trust black box abstraction. If we had a way to guarantee that our black boxes would Just Work™, then having thousands of dependencies would hardly be a problem at all. But, since that’s one thing we can<strong>not</strong> guarantee, <code>_</code> is deeply committed to not adding additional abstraction. And thus, <code>_</code> packages follow the three rules above, and present their entire codebase – dependencies and all – for you to view at once, on a single screen.</p>
<p>When viewing a <code>_</code> sub-package, you can look at a single file and, without needing any  outside context or info, see whether the code in that file is correct.  After all, outside the fairly limited domain of <a href="https://web.mit.edu/16.35/www/lecturenotes/FormalMethods.pdf">formal methods</a>, pretty much no software is <em>provably </em>correct.  But, if we can make the code short and readable enough, maybe we can at least reach what mathematicians (jokingly) call “<a href="https://proofwiki.org/wiki/ProofWiki:Jokes#Proof_by_Inspection"><strong>proof by inspection</strong></a>“: something so simple, that we can tell that it’s correct just by looking at it.</p>
<p>Or at least that’s the theory.  But, as <a href="https://www-cs-faculty.stanford.edu/~knuth/faq.html">Knuth famously reminds us</a>, don’t trust code if you’ve only proved it true, not run it. I’m sure this advice covers proof-by-inspection at least as much as proof by any other method and, accordingly, <code>_</code>’s brevity hasn’t stopped me from adding significant numbers of unit tests.</p>
<p>Even with the tests, and even as simple as each sub-package is, I’m sure that <code>_</code> still contains plenty of bugs – probably far more than I’d like it to. But hopefully, the lack of abstraction in each of <code>_</code>’s sub-packages also means that we’ll all be able to more easily debug any issues that we encounter: doing so won’t require anyone to understand any code or systems outside of a single, short file. In other words, to <a href="https://sway.office.com/b1pRwmzuGjqB30On">borrow a phrase</a> from Aaron Hsu, <code>_</code> embraces “transparency over abstraction”.</p>

<h4 id="the_scope">The scope</h4>
<p>The rules we just talked about limit on what sub-packages <code>_</code> can include – but these rules don’t indicate what <code>_</code> <em>should</em> include. Let’s address that now.</p>
<p><code>_</code>’s scope is easy enough to state in broad terms: <code>_</code> should include a package if that package follows our rules and provides functionality that many Raku packages would get utility from.  (That’s what “utility package” means!) If the package’s scope is small enough that it can be implemented in 70 lines, then having it as an independent package would create a micro package; if that micro package would be useful in a bunch of Raku programs, then it would likely become a <em>widely used</em> micro package. Since <code>_</code>’s goal is to limit the number of widely depended-on micro-packages in the Raku ecosystem, any package that meets these two criteria is a good candidate for <code>_</code>.</p>
<p>But all that basically boils down to “<code>_</code> should include packages that are (1) small and (2) useful”. While I doubt that many of you will disagree, knowing what “useful” means in practice is the hard part.</p>
<p>And I’m not entirely sure what exact view of usefulness will be turn out to be the best fit for <code>_</code>. I do know that many utility libraries implement basic helper functions – <code>reverse</code>, <code>zipWith</code>, <code>sortBy</code>, etc – that wouldn’t have any utility in <code>_</code> because they’re either already built in to Raku or a trivial combination of Raku builtins. So <code>_</code> can and should include higher-level utilities; I guess that we’ll have to discover together what exactly that looks like. If you have ideas for <code>_</code> packages, please let me know – or, even better, submit a PR!</p>
<p>That said, I do have three general categories of packages that be good fit for <code>_</code>:</p>
<h6>Code that should be in Raku’s standard library (one day)</h6>
<p>In addition to reducing the pressure for micro packages,<code>_</code> can also help Rakoons to test out packages that might one day belong in Raku but that need a bit more user feedback/time to bake before Raku commits to adding them (and the <a href="https://github.com/rakudo/rakudo/blob/master/docs/language_versions.md#language-versioning">fairly strong backwards compatibility guarantee</a> entailed by inclusion in Raku itself). Raku’s <a href="https://docs.raku.org/language/code style=">use experimental</a> pragma already fills a part of this role , but <code>_</code> could provide a good home for packages that are a bit <em>too</em> experimental even for that pragma.</p>
<h6>Code that ought to stay out of Raku’s standard library</h6>
<p>There are some small packages that we can reasonably expect to be widely used but that, for one reason or another, aren’t a good fit for Raku’s standard library; <code>_</code> can provide a home for those. Just as the packages in the first category share a lot with packages behind the <code>use experimental</code> pragma, this category shares a lot with Raku’s <a href="https://docs.raku.org/language/modules-core">Core modules</a>. And, again, <code>_</code>’s role could be a testing ground of sorts for modules that might one day graduate to being added as a Core module. (Though of course most packages won’t and shouldn’t “graduate” in this sense: I don’t want to suggest that being a <code>_</code> sub-package is or should be a temporary status. The vast majority of <code>_</code> sub packages will stay <code>_</code> sub-packages, which is exactly as it should be.</p>
<h6>Code that is already in Raku(do)’s standard library but that we shouldn’t use</h6>
<p>Raku and Rakudo both quite correctly make <a href="https://6guts.wordpress.com/2016/02/09/a-few-words-on-perl-6-versioning-and-compatibility/">fairly</a> <a href="https://github.com/rakudo/rakudo/blob/master/docs/articles/2016-02%20Proposed%20Perl%206%20Versioning%20And%20Compatibility%20Guidelines.md">strong</a> <a href="https://marketing.raku.org/id/1541379592/any">guarantees</a> about not breaking spec’d code. But, in return, it asks us to <em>not</em> rely on code outside that guarantee – that is, not to rely on implementation details. Unfortunately Rakoons, <a href="https://www.hyrumslaw.com/">just like everybody else</a>, are fairly rubbish at keeping up our end of that bargain – it’s all too easy have thoughts like:</p>
<blockquote><p>well, this function is already installed and does <em>just</em> what I need. And it’s in Rakudo, so I know it’s decently well-written. So what if it’s marked with <code>is implementation-detail</code>, I’m sure it’ll be <em>fine.</em></p></blockquote>
<p>I’m not judging those thoughts too harshly – I’ve had them myself – but the fact is that it’s <strong>not</strong> fine. When we, as a community, ignore signposts like <code>is implementation-detail</code>, the <a href="https://github.com/Raku/6.d-prep/blob/master/d-docs/New-Features-Policy.md">inevitable negative result</a> is that we force Rakudo developers to chose between not changing the implementation detail or breaking user code. Even if they’re “allowed” to break that code under the terms of the agreement (the one that we users are ignoring by relying on the code!), none of the Rakudo devs enjoy breaking things.</p>
<p>If changing an <code>implementation-detail</code> makes <a href="https://perl6advent.wordpress.com/2018/12/23/day-23-blin-its-christmas-soon/#project-blin--toasting-reinvented">blin runs</a> start failing, then devs <em>will</em> think twice about that change – even if it’s a good change. What’s worse is that the (totally understandable!) desire to discourage users from depending on implementation details risks tempting Rakudo devs to <a href="https://github.com/Raku/problem-solving/issues/277">avoid fully documenting those details</a> – which creates/exacerbates the problem of tacit knowledge (sometimes called “<a href="https://en.wikipedia.org/wiki/Tribal_knowledge">tribal knowledge</a>“) – the knowledge possessed by many people in the community, but which isn’t written down or otherwise accessible to new people. Tacit knowledge, in turn, creates barriers to new developers looking to understand how to improve the Raku’s main language implementation, which hurts everyone. Accordingly, one additional goal for <code>_</code> is to head this problem off by providing alternatives to any of Rakudo’s <code>implementation-detail</code>s that developers might be tempted to depend on.</p>
<hr/>
<p>So, let’s see: a package is a good fit for <code>_</code> if it</p>
<ul>
<li>should be in the standard library but isn’t</li>
<li>shouldn’t be in the standard library</li>
<li>or is in the standard library but shouldn’t be used.</li>
</ul>
<p>I think that covers all possible packages except for those that are in the standard library and should be used, so I’m not sure we really managed to narrow it down!  But maybe taking a look at <code>_</code>’s initial packages will provide some examples of packages that, at least in my view, were worth including.</p>
<h2 id="current_status">Current status</h2>
<p>As of today (December 11, 2021), <code>_</code> includes 7 sub-packages and is beta software.  <code>_</code>’s source code and documentation <a href="https://github.com/codesections/_">are on GitHub</a> and <code>_</code> itself can be installed via Zef with the command:</p>
<p>During this beta period, <code>_</code> explicitly makes <strong>no</strong> guarantees about backwards compatibility. In particular, ensuring that <code>_</code> is strongly backwards compatible once promises to be may require breaking changes to <em>every</em> <code>_</code> when 1.0.0 version is released. Because backwards compatibility is very important for a package like <code>_</code>, my goal is to reach 1.0.0 as soon as possible, with an exact date depending in part on what approach <code>_</code> takes to compatibility (more on that below – and, as you’ll see, it’s pretty likely that <code>_</code>’s 1.0.0 version won’t actually be called “1.0.0”).</p>
<h4 id="sub_packages">sub-packages</h4>
<p>Currently <code>_</code> includes the following sub-packages. You can find more info and usage examples for each sub-package in its <code>README</code> file, linked from its name.</p>
<ul>
<li><strong><a href="https://github.com/codesections/_/tree/main/lib/Pattern/Match"><code>Pattern::Match</code></a></strong> – provides a <code>choose</code> function that enables pattern matching using Raku’s <a href="https://docs.raku.org/type/Signature#Destructuring_arguments">signature destructuring</a> as an alternative<a href="https://docs.raku.org/language/control#given"><code>given</code>/<code>when</code></a>. <code>choose</code> lets you bind variables to elements of the match, supports placeholders and literals, and can detect unreachable/shaddowed patterns. (Fun fact: <a href="https://www.codesections.com/blog/pattern-matching-2/">musing</a> about a function like <code>choose</code> but not wanting to create a micro package is what first started me on the trail towards <code>_</code>). [<a href="https://github.com/codesections/_/blob/main/lib/Pattern/Match/Match.rakumod">source code</a>]</li>
<li><code><a href="https://github.com/codesections/_/tree/main/lib/Print/Dbg"><strong>Print::Dbg</strong></a></code> – provides a <code>dbg</code> function designed to support more ergonomic print-debugging (compared to Rakudo’s <a href="https://docs.raku.org/programs/01-debugging#index-entry-dd">dd</a>). <code>dbg</code> accepts any number of arguments and return the same values (i.e., effectively a no-op). As a side effect, <code>dbg</code> prints (to stderr) the file and line on which it was invoked and a <code>.raku</code> representation of each argument; if any of those arguments are variables, <code>dbg</code> prints the variable name. Because <code>dbg</code> returns the values it was passed, you can use it to add debugging code without altering the behavior of the code being debugged. An example: <code>my $new-var = $old1 + dbg($old2) + $old2</code>. <code>dbg</code> was inspired by Rust’s <a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code></a> macro. Compare with guifa’s <a href="https://github.com/alabamenhu/DebugTransput"><code>Debug::Transput</code></a>, which provides similar functionality. [<a href="https://github.com/codesections/_/blob/main/lib/Print/Dbg/README.md">source code</a>]</li>
<li><code><a href="https://github.com/codesections/_/tree/main/lib/Self/Recursion"><strong>Self::Recursion</strong></a></code> – provides <code>&amp;_</code> as an alias for <a href="https://docs.raku.org/language/variables#index-entry-&amp;%3FROUTINE"><code>&amp;?ROUTINE</code></a> and thus provides a “topic function” that allows for convenient self-recursion. Compare with APL’s <a href="https://help.dyalog.com/14.0/Content/Language/Defined%20Functions%20and%20Operators/DynamicFunctions/Recursion.htm">∇ function</a>. [<a href="https://github.com/codesections/_/blob/main/lib/Self/Recursion/Recursion.rakumod">source code</a>]</li>
<li><code><a href="https://github.com/codesections/_/tree/main/lib/Text/Paragraphs"><strong>Text::Paragraphs</strong></a></code> – provides a <code>paragraphs</code> function analogous to Raku’s <a href="https://docs.raku.org/routine/lines"><code>lines</code></a>: that is, it splits a <code>Str</code> or the contents of a file into paragraphs. It can detect paragraphs that are separated by blank lines and/or paragraphs that are  marked by first-line indentation. It is also able to distinguish between the start of a new paragraph and the a bulleted or numbered list (which is <em>not</em> a new paragraph). [<a href="https://github.com/codesections/_/blob/main/lib/Text/Paragraphs/Paragraphs.rakumod">source code</a>]</li>
<li><code><a href="https://github.com/codesections/_/tree/main/lib/Text/Wrap"><strong>Text::Wrap</strong></a></code> – provides <code>wrap-words</code>, a replacement for the Rakudo <code>implementation-detail</code> method <code>Str.naive-word-wrapper</code>. <code>wrap-words</code> is slightly less naive because it provides basic support for wide Unicode (supporting character width without knowing the font is <a href="https://stackoverflow.com/questions/3634627">impossible in theory but works OK in practice</a>).  Additionallly, <code>wrap-words</code> respects the existing whitespace in between words so, unlike Rakudo’s version, it doesn’t need to have an opinion about how many spaces to put after a period (though, for the record, Rakudo’s view that periods should be followed by <a href="https://github.com/rakudo/rakudo/blob/master/src/core.c/Str.pm6#L3646">two spaces</a> is <a href="https://web.archive.org/web/20170926073154/http://bartlebysbackpack.com/2017/07/meta-contrarian-typography/">the correct one</a>). <code>wrap-words</code> uses the same greedy wrapping algorithm as Rakudo (if anyone is up for a challenge, I’d welcome a PR that implements the <a href="http://defoe.sourceforge.net/folio/knuth-plass.html">Knuth &amp; Plass line-breaking algorithm</a> … in under 70 lines of code – here’s a JS implementation in <a href="https://github.com/bramstein/typeset/blob/master/src/linebreak.js">only ~300 lines</a> to get you started)! [<a href="https://github.com/codesections/_/blob/main/lib/Text/Wrap/Wrap.rakumod">source code</a>]</li>
<li><code><a href="https://github.com/codesections/_/tree/main/lib/Test/Doctest/Markdown"><strong>Test::Doctest::Markdown</strong></a></code> – provides a <code>doctest</code> funtion that tests Raku code contained in a Markdown file with the goal of testing example code in a <code>README</code> or other documentation. (Nothing’s worse than broken examples!) <code>doctest</code> tests each code block as follows: If the code block has <code>OUTPUT: «…»</code> comments, <code>doctest</code> tests the code’s output against the expected output; if the code block doesn’t have <code>OUTPUT</code> comments, <code>doctest</code> tests whether the code can be <code>EVAL</code>ed ok. <code>doctest</code> also supports adding configuration info by preceding the code block with a <code>&lt;!-- doctest --&gt;</code> comment; currently, the only config option is to provide setup code that’s run as part of the test without being displayed in the Markdown file. Inspired by <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">Rust’s documentation tests</a>. [<a href="https://github.com/codesections/_/blob/main/lib/Test/Doctest/Markdown/Markdown.rakumod">source code</a>]</li>
<li><code><a href="https://github.com/codesections/_/tree/main/lib/Test/Fluent"><strong>Test::Fluent</strong></a></code> – provides a thin wrapper over Raku’s Core <a href="https://docs.raku.org/type/Test">Test</a> module that supports testing in a more fluent style as shown in the example below. Most notably, this style supports providing test descriptions in pod6 declarator comments. Inspired by the <a href="https://fluentassertions.com/">Fluent Assertions</a> (.NET’s) and <a href="https://www.chaijs.com/">Chai</a> (JS) packages. [<a href="https://github.com/codesections/_/blob/main/lib/Test/Fluent/Fluent.rakumod">source code</a>]</li>
</ul>
<pre><code><span># with Raku&#39;s Test:
</span><span>unlike escape-str(<span>$str</span>), /&lt;<span>invalid-chars</span>&gt;/, 
    <span>&#34;Escaped strings don&#39;t contain invalid characters&#34;</span>;
</span>
<span># with Test::Fluent:
</span><span>#| Escaped strings don&#39;t contain invalid characters
</span><span>escape-str(<span>$str</span>).is.not.like: /&lt;<span>invalid-chars</span>&gt;/;
</span></code></pre>
<h4 id="sub_package_selection">sub-package selection</h4>
<p>As I mentioned earlier, you can import all of <code>_</code>’s sub-packages with <code>use _</code>.  This imports all the non-test functions; to import the test functions, pass ‘Test’ as a named parameter: <code>use _ :Test</code> or import both test and non-test functions with <code>use _ :ALL</code>.  If you would like more control over the imports, you can pass a list of the specific functions you’d like. For example, to import only the two text-processing functions, you would write <code>use _ &lt;&amp;paragraphs &amp;wrap-words&gt;</code>.</p>
<h2 id="future_plans">Future plans/questions</h2>
<p>I have one medium-term goal for <code>_</code> that I’d like to take care of before a stable release.  I also have several questions I’m pondering (thoughts/ideas appreciated!).  And, of course, I’d like to keep building out the functionality and robustness (more tests!) of the existing sub-packages.</p>
<h4 id="versioning">Versioning</h4>
<p>The goal – and the largest blocker for a 1.0.0 release for <code>_</code> – is to figure out the best way for <code>_</code> to version sub-packages and to implement that a versioning system.</p>
<p>I’m still in the design phase for this part of <code>_</code>, but I’m optimistic.</p>
<p>Raku offers nearly unique opportunity to get versioning right. With the exception of the in-alpha-testing language <a href="https://www.unisonweb.org/docs/tour">Unison</a>, I’m not aware of any language that supports versioning as a first-class concept to the <a href="https://docs.raku.org/type/Version">degree that Raku does</a>; Raku goes so far as letting us set both <a href="https://docs.raku.org/type/Metamodel::Versioning"><code>version</code> and <code>api</code> info</a> for nearly every language construct. Even better, Raku’s strong support for <a href="https://docs.raku.org/language/functions#index-entry-declarator_multi-Multi-dispatch">multiple dispatch</a> lets us “grow” Raku functions without breaking them: when we define a new <code>multi</code> candidate with a narrower signature, we add something new without breaking any existing calls. (I’m using “grow” in the sense <a href="http://beppu.github.io/post/spec-ulation/">Rich Hickey introduced</a> – you grow a function by either requiring less from or providing more to that function’s callers).</p>
<p>Given all these advantages, I’m hoping that <code>_</code> 1.0.0 will manage versions in a way that gives users fine-grained control over which version of a <code>_</code> function they use – but where exercising that control is largely optional for most users because <a href="https://www.joelonsoftware.com/2004/06/13/how-microsoft-lost-the-api-war/">nothing ever breaks</a>.</p>
<p>But will that 1.0.0 release actually be a “1.0.0” release? I have always used <a href="https://semver.org/">semantic versioning</a> and think it’s a useful tool for communicating changes to users. That said, it’s also true that <a href="https://hynek.me/articles/semver-will-not-save-you/">semver has real problems</a>. In particular, it seems like <code>_</code> nature –  a collection of independent sub-packages, in which changes to one sub-package have no effect on any other – might not be a great fit for the binary nature of semver.</p>
<p>Consequently, I’m strongly considering <strong>calendar versioning</strong> (<a href="https://calver.org/">calver</a>) or some other non-semver versioning scheme.</p>
<p><img loading="lazy" data-attachment-id="1585" data-permalink="https://raku-advent.blog/2021/12/11/unix_philosophy_without_leftpad_part2/calver/" data-orig-file="https://rakuadventcalendar.files.wordpress.com/2021/12/calver.png" data-orig-size="649,195" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="calver" data-image-description="" data-image-caption="" data-medium-file="https://rakuadventcalendar.files.wordpress.com/2021/12/calver.png?w=300" data-large-file="https://rakuadventcalendar.files.wordpress.com/2021/12/calver.png?w=649" src="https://rakuadventcalendar.files.wordpress.com/2021/12/calver.png?w=487&amp;h=146" alt="Output from the terminal command &#39;cal -3&#39; showing calendars for three months" width="487" height="146" srcset="https://rakuadventcalendar.files.wordpress.com/2021/12/calver.png?w=487&amp;h=146 487w, https://rakuadventcalendar.files.wordpress.com/2021/12/calver.png?w=150&amp;h=45 150w, https://rakuadventcalendar.files.wordpress.com/2021/12/calver.png?w=300&amp;h=90 300w, https://rakuadventcalendar.files.wordpress.com/2021/12/calver.png 649w" sizes="(max-width: 487px) 100vw, 487px"/></p>
<p>At the very least, having periodic scheduled <code>_</code> releases would provide a natural way to bundle sub-package fixes. It might even make sense to track Raku’s version and backwards compatibility stance (which would mean not allowing any breaking (non-growing) changes except for when a new Raku language version is released).</p>
<p>I also want to put some thought into letting users select a version at the sub-package (or even function) level.  One of the advantages of a meta package like <code>_</code> is that it bundles administrative issues like upgrading, so I don’t want to set anything up that would add work for users.  At the same time, giving users more control would be a great feature.  There’s also the question of what version to provide when users <em>don’t</em> specify an exact version: I don’t want to reinvent the wheel or to be needlessly inconsistent with <a href="https://github.com/ugexe/zef">zef</a>, but the arguments for/against <a href="https://research.swtch.com/vgo-mvs">golang-style minimal version selection</a> have me intrigued (especially the ones <a href="https://www.youtube.com/watch?v=F8nrpe0XWRg">Russ Cox raised in this 2018 talk</a>).</p>
<p>Finally, <code>_</code> needs to have a decent <a href="https://en.wikipedia.org/wiki/Responsible_disclosure">responsible disclosure</a> process before it’s ready for a stable release (maybe that’s not technically a “versioning” issue, but it’s close enough; a security bug would certainly lead to a new version!). The inherent simplicity of <code>_</code> sub-packages <em>should</em> make security flaws much less likely – but that phrase has “famous last words” written all over it, so <code>_</code> will definitely err on the side of caution. I don’t think there’s a whole lot to decide here; it’s just a matter of setting it up.</p>
<p>So, lots to think about, several decisions to make, and some implementation code to write.</p>
<h4 id="packages_that_outgrow__">Packages that outgrow <code>_</code></h4>
<p>Another question I’m mulling over is how <code>_</code> should act when a package is removed from <code>_</code>. This seems like something that could happen because the package adds enough features that it can’t fit in 70 lines without sacrificing clarity – in which case it makes sense for the sub-package to spin off into a full package of its own.  Or a sub-package might leave  <code>_</code> because it “graduates” into Raku’s standard library/Core modules. (Or a package could be removed because it was a bad idea in the first place, but that’s hopefully rare and can be handled as a normal <a href="https://docs.raku.org/type/Attribute#index-entry-trait_is_DEPRECATED_(Attribute)-trait_is_DEPRECATED">deprecation</a>/breaking change).</p>
<p>If a sub-package is removed from <code>_</code> and a user tries to use one a function from that sub-package then, unless we handle that as a special case, the user would get an error.  So the question is if we want to add any special logic for removed packages.  If that sub-package still exists but just lives elsewhere, then <code>_</code> could import it as a dependency and re-export it as a sub-package.  This would prevent needlessly breaking user code but would mean that someone could <em>believe</em> that they were use a <code>_</code> sub-package but actually be using an external package – which risks drastically weakening <code>_</code>’s guarantees (and we’d no longer have 0 dependencies).</p>
<p>I suspect that the best answer here is to re-export the old packages but to throw an <code>is DEPRECATED</code> warning. But I’d put bit more thought into whether there’s an alternative that would avoid the dependency.</p>
<h4 id="existing_micro_packages">Micro packages already in the ecosystem</h4>
<p>Next, I’d like to put some thought into how (if at all) <code>_</code> should approach existing micro packages in the Raku ecosystem. For the initial packages in <code>_</code>, I focused entirely on preventing new micro packages from becoming widely used dependencies. In particular, I avoided knowingly duplicating any existing Raku packages (well, with the slight exception of guifa’s <a href="https://github.com/alabamenhu/DebugTransput">Debug::Transput</a>, but that, as that package notes in its README, Debug::Transput was based off an idea I mentioned to guifa on IRC).</p>
<p>But it might make sense for <code>_</code> to one day include the code from Raku packages (or slightly modified versions of them). To keep its guarantees, <code>_</code> would need to create a sub-package based on the package’s code, i.e. fork the package. I would want to be <em>very</em> careful about this – even though forking and re-distributing a free software package is entirely allowed by the license, it can sometimes come off as a bit rude. And I don’t want anyone to think of <code>_</code> as a package that’s interested in taking credit for other people’s work.</p>
<p>Despite those reservations, there’s one really compelling reason to consider forking packages: <code>_</code>’s purpose is to reduce the number of widely-used micro-package dependencies in the Raku ecosystem, and there’s no better way to do that than to find packages that are <em>already</em> widely used micro packages. (Or, said differently, to find packages that are furthest upstream in the <a href="http://neilb.org/2015/04/20/river-of-cpan.html">Raku River</a>.) And, fortunately, this sort of hard data for the Raku ecosystem is easy to get, either directly through <code>zef</code> or using the <a href="https://github.com/finanalyst/ModuleCitation">ModuleCitation</a> module to generate a visual/interactive display similar to the Raku <a href="https://finanalyst.github.io/ModuleCitation">Ecosystem Citation Index</a>:</p>
<p><img src="https://codesections.com/photos/top_deps.png" alt="A line chart with unlabeled lines depicting the most Raku modules with the most dependencies from January 2016 through January 2019.  The top line is at about 40%, and 6 others are above 20%" width="70%"/></p>
<p>This sort of info would let us find modules that are small and widely depended on; in short, ones that are perfect candidates for adding to <code>_</code>.</p>
<p>Given that we <strong>can</strong> do this, I’d like to put some thought into whether we should and, if so, how to best do so. I can see a few options: we could look for modules with a high citation index that are also good targets for re-writing (perhaps because they were written some time ago or with a different goal) and create sub-packages based on those (without forking them). Or we could look for packages that might be abandoned and, if so, fork them as sub-packages. Or try to work with package maintainers to have <em>them</em> add (a version of) the package to <code>_</code>. And I’m sure there are other approaches too; something else to ponder.</p>

<h4 id="making___trustworthy">Making <code>_</code> trustworthy</h4>
<p>Finally, I’ve been musing about how <code>_</code> can be as trustworthy as possible (even before the subject <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/raau00/following_the_unix_philosophy_without_getting/hnhi5km/">came up</a> last time). The goal, of course, is for <code>_</code> to be as close as possible to <a href="https://en.wikipedia.org/wiki/Zero_trust_security_model">zero trust</a>: because each sub-package is a single short, readable (I hope!) file with zero dependencies, you shouldn’t <em>need</em> to trust me – just read the code (and tests) and see for yourself.</p>
<p>That’s a fine theory, but in practice there’s still a big difference between “as close as possible to zero trust” and “actually zero trust”. And it’s true that at least some aspects of <code>_</code> depend on its maintainers (i.e., right now, me) being trustworthy. That’s great if you trust me – which I’m kind of stuck with anyway!  For the not-me people in the world, I hope earned the trust of many in the Raku community, but I can fully understand anyone who doesn’t share that trust, and I’d like to put some thought into the best ways to add some additional safeguards (both against malicious code and against insecure/buggy code).</p>
<p>In any event that’s definitely a someday-well-after-1.0.0 question – after all, maybe no one else will find <code>_</code> useful, and I’ll be its only user. If so, being trusted won’t be an issue at all.</p>
<h2 id="conclusion">Conclusion: <code>_</code> and the Unix philosophy</h2>
<p>I want to close with a few bigger picture thoughts about <code>_</code> and its relationship to the values that (imo) contribute to well-designed software. One <a href="https://lobste.rs/s/nu3xyw/following_unix_philosophy_without#c_wwvb3j">comment I got</a> on the first post in this series was “I’m all for left-pad-sized packages”. I think that was meant as a point of disagreement, but my immediate internal response was “me too!”</p>
<p>I love left-pad-sized packages; if I didn’t, I’d hardly have written a seven of them for <code>_</code>’s initial release. This post has said something about “reducing the number of micro packages” so often that it’d be easy to forget, so I want to be perfectly clear: <strong>I think micro packages are great and that we should have more of them.</strong> If you’re considering writing a micro package, please do!</p>
<p>What I don’t like is having hundreds or thousands of dependencies. I <em>especially</em> don’t like having a reasonable number of direct dependencies but <em>still</em> having hundreds of transitive dependencies many layers deep. My goal with <code>_</code> is to address that problem: I want to have my cake and eat it too.</p>
<p>I want each of my dependencies to be small <em>and also</em> to have as few transitive dependencies as possible. And I believe that <code>_</code> (if successful) can help us all to get both. For example, if three of my dependencies need to wrap text and each uses a different micro package, then I’ve just picked up three new dependencies; but if they all use <code>_</code>, then I’ve only picked up one (or even zero, if one of them already used<code>_</code>). This sort of thing – where different dependencies import similar-but-different packages to perform the same task – <a href="https://cpojer.net/posts/dependency-managers-dont-manage-your-dependencies#align-on-a-single-package-for-a-well-defined-purpose">happens all the time</a> in many language ecosystems and is a major contributor to dependency bloat.</p>
<p>In all these ways, I hope that <code>_</code> can flatten dependency trees and help us have <em>both</em> micro packages and fewer dependencies.</p>
<p>This dual goal of minimizing dependency <em>size</em> and dependency <em>number</em> also ties into a point that came up in <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/raau00/following_the_unix_philosophy_without_getting/hnh34a9/">an interesting and thoughtful set of reactions to my previous post</a>. Paraphrasing a bit, the overall critique was that I’d misunderstood the Unix philosophy and that a <em>correct</em> understanding of that philosophy wouldn’t lead to massive dependency graphs or any of the other problems that I described as coming from following the Unix philosophy too far.</p>
<p>In some ways, this is a semantic disagreement: by “Unix philosophy”, do we mean the <a href="https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html">nuanced but not fully consistent set of practices</a> that emerged in the <a href="http://harmful.cat-v.org/cat-v/unix_prog_design.pdf">early days of UNIX</a>? Or do we mean the <a href="https://hackaday.com/2018/09/10/doing-one-thing-well-the-unix-philosophy/">simplified</a> <a href="https://itzone.com.vn/en/article/focus-on-one-thing-and-do-it-well-the-unix-philosophy/">version</a> that <a href="https://tommcfarlin.com/do-one-thing-and-do-it-well/">most people</a> mean when they<a href="http://lebo.io/2015/06/22/the-unix-philosophy-and-elixir-as-an-alternative-to-go.html"> refer to “the Unix philosophy”</a> today? I’m not interested in debating the definitions of our terms but, to be clear, when I say that following “the Unix philosophy” leads to micro-package multiplicity, I’m using the phrase in its more contemporary, simplified sense – a.k.a., the way “many [people have] misapplied ‘The Unix Philosophy’ [as] justif[ying] ‘micro-packages’, when it really doesn’t”, according to at least one commenter (a friend and fellow Rakoon).</p>

<p>So it may well be that the True Unix Philosophy™ wouldn’t lead to programs with 1,000+ dependencies. I view <code>_</code> as striking a balance between the Unix philosophy’s push towards micro packages and my simultaneous desire to keep my code’s dependency count in the double digits. But it’s fine if view the Unix philosophy differently and say that (correctly understood) it doesn’t encourage micro packages in the first place.  From that point of view, <code>_</code> could be about correctly (albeit still partially) applying the Unix philosophy by encouraging shallower and narrower dependency trees.</p>
<p>I’m happy with either framing; either way is a path towards simpler, more reliable, and more composable software. I hope that, by reducing abstraction, having code that’s “correct by inspection”, and providing a coordination point for small-but-useful sub-packages, <code>_</code> can play its small part in making that happen in the Raku ecosystem.  And, regardless of how well <code>_</code> fares, I hope that other languages embrace the use of utility packages and the role they can play in reducing the depth and breadth of dependency trees.</p>
	</div></div>
  </body>
</html>
