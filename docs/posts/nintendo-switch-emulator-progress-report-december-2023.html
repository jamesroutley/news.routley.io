<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.ryujinx.org/progress-report-december-2023/">Original</a>
    <h1>Nintendo Switch Emulator: Progress Report December 2023</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        


        <div>
        <section>

            <ul>
                <li>
                    <a href="https://blog.ryujinx.org/author/mutantaura/">
                        <img src="https://blog.ryujinx.org/content/images/size/w100/2022/02/QNjmzto__400x400.jpg" alt="MutantAura"/>
                    </a>
                </li>
            </ul>

            <div>
                
                <p><time datetime="2024-01-16">Jan 16, 2024</time>
                        <span><span>•</span> 12 min read</span>
                </p>
            </div>

        </section>
        </div>

            <figure>
                <img srcset="/content/images/size/w300/2024/01/ryujinx_capture_2024-01-09_23-45-00-1--min.png 300w,
                            /content/images/size/w600/2024/01/ryujinx_capture_2024-01-09_23-45-00-1--min.png 600w,
                            /content/images/size/w1000/2024/01/ryujinx_capture_2024-01-09_23-45-00-1--min.png 1000w,
                            /content/images/size/w2000/2024/01/ryujinx_capture_2024-01-09_23-45-00-1--min.png 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://blog.ryujinx.org/content/images/size/w2000/2024/01/ryujinx_capture_2024-01-09_23-45-00-1--min.png" alt="Progress Report December 2023"/>
            </figure>

    </header>

    <section>
        <p>Happy New Year!</p><p>We’ll start out with a certified retro title in Monster Hunter Rise (MHR). Released in the antiquated year of 2021, the game has received several updates and DLC throughout its life, the newest of which has been a pain to emulate since its release. From the ‘Sunbreak’ DLC and updates onwards, MHR would crash on boot before reaching the title screen with an error that was <em>very</em> complicated to solve within the buffer cache.</p><p>The old implementation made the assumption that all the memory regions where buffers could be located are contiguous (they’re next to each other). In most cases this assumption is correct, but if you can guess a title where it isn’t, then you probably have average pattern recognition skills. To solve this, support was <a href="https://github.com/Ryujinx/Ryujinx/pull/5427">implemented for Vulkan’s spare mapping feature</a>, which allows multi-range buffers to be created from multiple physical buffers.</p><figure><img src="https://blog.ryujinx.org/content/images/2024/01/01-min.png" alt="" loading="lazy" width="1920" height="1080" srcset="https://blog.ryujinx.org/content/images/size/w600/2024/01/01-min.png 600w, https://blog.ryujinx.org/content/images/size/w1000/2024/01/01-min.png 1000w, https://blog.ryujinx.org/content/images/size/w1600/2024/01/01-min.png 1600w, https://blog.ryujinx.org/content/images/2024/01/01-min.png 1920w" sizes="(min-width: 720px) 720px"/></figure><p>Perhaps the obvious downside here is that the feature is limited to Vulkan. OpenGL does technically support sparse mappings, but doesn’t allow you to choose where it will be mapped, making it effectively useless for our use case. Metal on macOS is in the same boat as OpenGL; while supported, it does not provide enough control of the buffer mapping to be viable, with the limitation thus extending to MoltenVK too.</p><p><em>Fashion Designer</em>, a game which we’re sure will be topping Game of the Year charts across the globe, was exhibiting a particularly strange glitch.</p><figure><img src="https://lh7-us.googleusercontent.com/0Up8URFv1MPzsKsCubB3inZ31KAXkCRr-vCuoSuLedzXj9vKe2Pb8HSqbWQ2MzVmM1HiFhmQGLnFuTAYfVv1vjLftwXkSShra-OcZvLqzCjuwqfNbnwu7MV_gfQzq7dzlobkv_6619c30yUaGXA9DK4" alt="" loading="lazy" width="624" height="352"/></figure><p>While we’re all <em>huugggge</em> fans of socks (having received around 30 pairs at Christmas), this seems like a few too many. On closer inspection, there are a few too many of everything. </p><p>Our culprit resides within the texture cache, where everything has a specific lifespan before the texture is flushed. Certain flags on each texture get set when the texture is first accessed, and when it is finally swapped out for a new texture. <em>Fashion Designer</em> appeared to be rendering different objects to the same texture, and as such only the first use of the texture was correctly setting the cache flags. When the game went on to request more draws of different objects, the same object texture was being copied multiple times. By resolving this edge case, our full arrangement of clothing items can be viewed.</p><figure><img src="https://lh7-us.googleusercontent.com/w5iCJLyKoL080vnm6LwLfWUxe0eXYeZJWjBgOsQBRL23gYijQrYKdtcZzKUo44Rsakcsv1B4qe0p1-BBVnMMQB61ymE87yLyALQfMjDt-U4WHkfACNHRHcSsCg2NLIVcZbUonJryojvQTADKnwv5rII" alt="" loading="lazy" width="624" height="351"/></figure><p>Remaining on quirky uses of textures for the time being, when you catch a Cicada in Yo-Kai Watch 1, a nice 2D image of the bug is meant to take up a large part of the screen. Unfortunately, due to a questionable if statement silencing the one log warning that would have told us immediately where the issue was, it has taken a fair while to track down the… bug.</p><figure><img src="https://lh7-us.googleusercontent.com/6DRyYfKggario26roh4J2MiTDvBtaio2xOJnHZXuwM0mrn45gVRVNn8l02wK4bMwlZDQfTKY0sgf6ONpVhyTOjzYkDReWoid4c3zGzzvtNgA12dfI7TzArqkeDaMXFDBkJuMkz_jPA-jfMdhvUhAQa4" alt="" loading="lazy" width="624" height="351"/></figure><p>For whatever reason, the team developing Yo-Kai Watch 1 decided to perform an image store on a texture that is a quarter of the width of the base format, but stores four times the data per pixel as an RGBA32 texture. If this sounds pointless, it is, because what is done with that image straight away? It’s accessed as an RGBA8 image, which is an incompatible format conversion! </p><figure><img src="https://lh7-us.googleusercontent.com/5P9ohGy-wvP2pZyeMbpxwHYpQ-89X4PZJ982HwrVQsp_3b0NOGGHXK9JXdD3RxDC_--mZP6aR4sFTq9z1M22BwZZ7aia8vT5VbiVH5A-gByYER7a2HF-LiHzS7FwFmkaflj4_Krx480TQoF-mmDMtfg" alt="" loading="lazy" width="624" height="352"/></figure><p>This was also the cause of major graphical corruption in <em>Wet Steps</em>. The game still has a few other issues, but the difference is major.</p><!--kg-card-begin: html--><figure>
    
    <figcaption></figcaption>
</figure><!--kg-card-end: html--><p>Super Mario RPG had impressively few bugs when it released in late November, but our eagle-eyed users instantly noticed that Mario himself, and a few environmental objects, were slightly dull. While Mario is getting on in years and has probably lost the sparkle of his GameCube youth, it turned out that bindless elimination was not working correctly in a couple of cases. In the event that a shader handle is assigned twice via different paths, bindless elimination was unable to be extended, as it is unable to find the handle operation. However, even if different paths exist, the value is actually always the same, as any relevant data is unable to be modified once inside the shader pass. By <a href="https://github.com/Ryujinx/Ryujinx/pull/5957">fixing this to simply pick the first value if multiple routes exist</a>, Super Mario RPG renders correctly.</p><!--kg-card-begin: html--><figure>
    
    <figcaption></figcaption>
</figure><!--kg-card-end: html--><p>Another game that highlighted an unhandled edge case in bindless elimination was <em>Detective Pikachu Returns. </em>This one is more subtle, but <a href="https://github.com/Ryujinx/Ryujinx/pull/5958">extending through shuffle</a> resolves cubemap reflections throughout the game.</p><!--kg-card-begin: html--><figure>
    
    <figcaption></figcaption>
</figure><!--kg-card-end: html--><p>Let’s take a short interim to talk through some of the smaller, but perhaps interesting changes that have taken place over the last couple of months.</p><ul><li>When amiibos are first used (via AmiiboAPI), the API json will be <a href="https://github.com/Ryujinx/Ryujinx/pull/3681">stored locally</a> so that amiibos can be used offline.</li><li>Our minimum macOS version has been <a href="https://github.com/Ryujinx/Ryujinx/pull/5925">increased to macOS 12 Monterey</a>. We’re not sure why macOS 11 was chosen before, but it is wholly unsuitable for Switch emulation!</li><li><a href="https://github.com/Ryujinx/Ryujinx/pull/4956">Whole bunch of string, time and DateTime formatting change</a>s. Fixes sorting being backwards for play-time, file-size and last-played and most importantly, removes a load of log spam if games have never been played.</li><li>“Create Desktop Shortcut” actually <a href="https://github.com/Ryujinx/Ryujinx/pull/5852">works on macOS and also supports launching in fullscreen.</a></li></ul><p>Alright strap in, it’s time for the “Ryujinx blog teaches you computer science” segment.</p><p><strong><u><em>Sleeping</em></u></strong></p><p>When they’ve finished their tasks, they’d like nothing better than to pull up their duvet and tuck in for a solid 6ms nap before work the following nanosecond.</p><p>Ryujinx needs to operate on a <em>very </em>tight schedule and the best way to do this is actually <strong>not</strong> to sleep. No desktop kernel is truly “real time”, in the sense that it is impossible for us to sleep in one instant and wake whenever asked. There is always variability and delay to our requests (pretty graphs later).</p><p><strong><u><em>Alternatives to sleeping</em></u></strong></p><p><strong><u><em>The problem</em></u></strong></p><figure><img src="https://blog.ryujinx.org/content/images/2024/01/12.png" alt="" loading="lazy" width="1020" height="244" srcset="https://blog.ryujinx.org/content/images/size/w600/2024/01/12.png 600w, https://blog.ryujinx.org/content/images/size/w1000/2024/01/12.png 1000w, https://blog.ryujinx.org/content/images/2024/01/12.png 1020w" sizes="(min-width: 720px) 720px"/></figure><p>Pretty much all three major operating systems will allow us to sleep with 1ms granularity, and be able to wake at the right time. However, consider this same scenario but with 10 different wait events on the same thread, all out of sync with each other by 0.1ms.</p><figure><img src="https://blog.ryujinx.org/content/images/2024/01/13.png" alt="" loading="lazy" width="1026" height="421" srcset="https://blog.ryujinx.org/content/images/size/w600/2024/01/13.png 600w, https://blog.ryujinx.org/content/images/size/w1000/2024/01/13.png 1000w, https://blog.ryujinx.org/content/images/2024/01/13.png 1026w" sizes="(min-width: 720px) 720px"/></figure><p>Now we start to run into issues. The solution we used up until the end of 2023 was to simply spin through these waits, but as you can see, this means spinning <em>the entire time,</em> as we need to be awake to handle the thread that is about to wake every 0.1ms.</p><p>So how do we move forward? The CS nerds reading have been shouting “nanosleep!” at their screens for the last couple of minutes, and they’re half right.</p><p><u><em><strong>Linux/macOS</strong></em></u></p><figure><img src="https://blog.ryujinx.org/content/images/2024/01/14.png" alt="" loading="lazy" width="1555" height="486" srcset="https://blog.ryujinx.org/content/images/size/w600/2024/01/14.png 600w, https://blog.ryujinx.org/content/images/size/w1000/2024/01/14.png 1000w, https://blog.ryujinx.org/content/images/2024/01/14.png 1555w" sizes="(min-width: 720px) 720px"/></figure><p>Upon testing, we see that nanosleep is not quite as precise as its name claims. At very low nanosecond values we see very consistent (and small) wake error values, but once we reach the threshold of 0.5ms, a huge spike in error occurs, which eventually levels off at around 1.5ms.</p><figure><img src="https://blog.ryujinx.org/content/images/2024/01/15.png" alt="" loading="lazy" width="1204" height="746" srcset="https://blog.ryujinx.org/content/images/size/w600/2024/01/15.png 600w, https://blog.ryujinx.org/content/images/size/w1000/2024/01/15.png 1000w, https://blog.ryujinx.org/content/images/2024/01/15.png 1204w" sizes="(min-width: 720px) 720px"/></figure><p>macOS curiously again has different behavior. At tiny wait requests, the syscall is remarkably accurate with minimal error on sleep requests down to the nanosecond. Unfortunately the error is directly proportional to the wait time requested, and keeps climbing until we see almost 0.5ms of delay when asking for a 3ms sleep, and over 3ms delay when asking for 20ms of sleep.</p><p>While these sound bad, the use case we wanted was already for those smaller sleep times, so both macOS and Linux have an efficient and easy way out here via <em>nanosleep</em>.</p><p><strong><u>Windows</u></strong></p><p>The Windows NT kernel is, <em><u>by far</u></em>, the least “real time” of the three major options presented. It has no nanosleep equivalent, and as such is highly limited in how to deal with our sleep problem. By default you can sleep to an accuracy of <strong>1ms </strong>which, as we hope to have reiterated, is not good enough for as low as two concurrent waits (each 0.5ms apart) let alone 10. Is all hope lost then? Is 1ms really the best we can do? We’re pretty smart so the answer is: hell no.</p><p>On most x86_64 systems, you can perform a query to the clock resolution and discover that there is actually a 0.5ms resolution “base clock”, and that perhaps more interestingly, by default, any waits you perform will align to the nearest “base clock tick” automatically. If you sleep with no thought, this means your thread may wake late due to alignment with the next base tick. However, if you have this information, and make a very smart guess about when the next tick will occur, you can time your sleep to 0.5ms precision and nearly always wake right before it.</p><p>None of this solves our 10 concurrent 1ms wait issues though. If we detect that a wait event is base-clock aligned or very close to, we can allow the system spoken about to align the waits and wake just before the next clock tick. If the wait is not base-clock aligned (or extremely precise like 0.01ms), then there is unfortunately nothing that the NT kernel provides us to solve this, beyond continuing to use spinwaits where needed.</p><p>Class dismissed, let’s look at what all of this actually does. We said before this whole thing is about CPU usage and power draw, so some more graphs seem to be in order.</p><figure><img src="https://blog.ryujinx.org/content/images/2024/01/16.png" alt="" loading="lazy" width="1350" height="862" srcset="https://blog.ryujinx.org/content/images/size/w600/2024/01/16.png 600w, https://blog.ryujinx.org/content/images/size/w1000/2024/01/16.png 1000w, https://blog.ryujinx.org/content/images/2024/01/16.png 1350w" sizes="(min-width: 720px) 720px"/></figure><p>Apple and Linux devices will be seeing the largest benefit here, with some seriously impressive efficiency gains at equal frame rate and resolution. Tears of the Kingdom is being slashed by almost 40%, Red Dead Redemption and Breath of the Wild both see very healthy 15-20% shifts, and Pokémon Violet practically sheds everything with a 75% reduction. For perspective, that is an M2 MacBook Air emulating Pokémon Violet more efficiently than the Switch plays it natively.</p><p>Areas of games that don’t really do much like title screens, or when emulation is paused, see some wild reductions on devices like the Steam Deck.</p><!--kg-card-begin: html--><figure>
    
    <figcaption></figcaption>
</figure><!--kg-card-end: html--><p><a href="https://github.com/Ryujinx/Ryujinx/pull/5948">These changes</a> can result in additional hours of battery life while reducing the magnitude and frequency of thermal throttling, particularly in fanless devices such as the MacBook Air family. It also allows devices to reach and maintain their boost clocks during the times they’re actually needed, rather than being continually tricked into boosting on menus and when paused. If none of that sounds cool then we saved you some money on your next energy bill, take it or leave it!</p><p>Lastly, for those of you who find it interesting that we decided to write this thing in C#/.NET, we had a new and shiny .NET version to update to in November: .NET 8 (they grow up so fast…). Microsoft always provides an <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/">absolutely <em>huge</em> document</a> on all of the performance improvements they’ve brought to the table each year, but for us, they can usually be distilled into our patented Super Mario Odyssey pole benchmark.</p><!--kg-card-begin: html--><figure>
    
    <figcaption></figcaption>
</figure><!--kg-card-end: html--><p>This very blog also got a very cool mention during .NET conference 2023 as part of their excellent talk on Dynamic PGO. Check that out <a href="https://www.youtube.com/watch?v=WrpYcGic9b8">here</a>. </p><figure><img src="https://blog.ryujinx.org/content/images/2024/01/21-min.png" alt="" loading="lazy" width="1920" height="1080" srcset="https://blog.ryujinx.org/content/images/size/w600/2024/01/21-min.png 600w, https://blog.ryujinx.org/content/images/size/w1000/2024/01/21-min.png 1000w, https://blog.ryujinx.org/content/images/size/w1600/2024/01/21-min.png 1600w, https://blog.ryujinx.org/content/images/2024/01/21-min.png 1920w" sizes="(min-width: 720px) 720px"/><figcaption><strong>Look ma! We’re on TV!</strong></figcaption></figure><p><strong><u>2023 roundup!</u></strong></p><figure><img src="https://blog.ryujinx.org/content/images/2024/01/22.png" alt="" loading="lazy" width="1457" height="898" srcset="https://blog.ryujinx.org/content/images/size/w600/2024/01/22.png 600w, https://blog.ryujinx.org/content/images/size/w1000/2024/01/22.png 1000w, https://blog.ryujinx.org/content/images/2024/01/22.png 1457w" sizes="(min-width: 720px) 720px"/></figure><p>We added over <strong>700 </strong>games to our compatibility list during 2023 which brings the total for games tested (and reported) on Ryujinx to <strong>4255. </strong>Over 83% of those are reported as having no graphical, technical or stability issues <em>at all</em>, with a further 12% of titles having at least one problem. This category is mostly filled with titles that have minor graphical glitches or stability issues. In other systems of marking, they may be considered playable also. The remaining 4.5% of titles only progress as far as the menus, if at all.</p><p>As far as performance goes, we had a year on year average improvement of 36% in our own usual suite of games. As usual this is <em>highly</em> game and hardware-dependent.</p><figure><img src="https://blog.ryujinx.org/content/images/2024/01/23.png" alt="" loading="lazy" width="1388" height="862" srcset="https://blog.ryujinx.org/content/images/size/w600/2024/01/23.png 600w, https://blog.ryujinx.org/content/images/size/w1000/2024/01/23.png 1000w, https://blog.ryujinx.org/content/images/2024/01/23.png 1388w" sizes="(min-width: 720px) 720px"/></figure><p>We’re not quite sure what happened to Persona 5 and NieR, but both have seen a 61% and 89% improvement respectively. Our two Zelda games tested jumped by 20% and 35% (Tears of the Kingdom does indeed run on our January builds), and our classic benchmark of Super Mario Odyssey continues to keep climbing no matter what we do.</p><p>2023 sure had plenty of game releases so let’s jot up just how many Ryujinx was right in the action for, running on day 1!</p><ol><li>The Legend of Zelda: Tears of the Kingdom ✓</li><li>Super Mario Wonder ✓</li><li>Super Mario RPG ✓</li><li>Pikmin 4 ✓</li><li>Metroid Prime Remastered ✓</li><li>Sea of Stars ✓</li><li>Octopath Traveller II ✓</li><li>Fire Emblem Engage ✓</li><li>Kirby’s Return to Dreamland Deluxe ✓</li><li>Advance Wars 1+2: Re-boot Camp ✓</li></ol><p>A ridiculous list of titles, first party and otherwise being playable with no changes always fills us with pride. It would be wrong of us to omit that a couple of these games (Tears of the Kingdom among them) did need some additional love to reach our standards, but the majority of the year has gone without a hitch.</p><p><strong><u>Closing words</u></strong></p><p>Onto our scheduled sales pitch: if you would like to contribute to Ryujinx then there are many ways in which you can assist us. Knowledgeable in emulation, graphics development or even just use C#/.NET in your day job and want something cool to stat-pad your resume? We’re always looking for more folks to check out our <a href="https://github.com/Ryujinx/Ryujinx">GitHub</a>. Fix bugs, add features, or our personal favourite: stare blankly at Visual Studio while imposter syndrome slowly creeps over your shoulder.</p>
    </section>


</article>
</div></div>
  </body>
</html>
