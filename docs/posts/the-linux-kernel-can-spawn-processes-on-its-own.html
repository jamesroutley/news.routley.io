<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.uninformativ.de/blog/postings/2022-06-11/0/POSTING-en.html">Original</a>
    <h1>The Linux kernel can spawn processes on its own</h1>
    
    <div id="readability-page-1" class="page"><div id="blogpostcontent">

<p><a href="https://donnywinston.com/blog/">blog</a> · <a href="https://donnywinston.com/git/">git</a> · <a href="https://donnywinston.com/desktop/">desktop</a> · <a href="https://donnywinston.com/pics/stream.html">images</a> · <a href="https://donnywinston.com/contact.html">contact &amp; privacy</a> · <a href="gopher://uninformativ.de">gopher</a></p>
<hr/>

<p>2022-06-11</p>

<p>While investigating the aftermath of a potential security breach, I came
across a somewhat “odd” process looking like this:</p>
<pre><code>root@ubuntu2004:~# ls -al /proc/1026/exe
lrwxrwxrwx 1 root root 0 Jun 11 05:26 /proc/1026/exe -&gt; &#39;/ (deleted)&#39;
</code></pre>
<p>This virtual symlink normally points to the binary being run, for
example:</p>
<pre><code>root@ubuntu2004:~# ls -al /proc/self/exe
lrwxrwxrwx 1 root root 0 Jun 11 05:27 /proc/self/exe -&gt; /usr/bin/ls
</code></pre>
<p>A common pattern of malicious code is to start a binary and then delete
it from disk to avoid being picked up by simple antivirus software,
which leads to output like this:</p>
<pre><code>$ ls -al /proc/5194/exe
lrwxrwxrwx 1 void users 0 Jun 11 07:29 /proc/5194/exe -&gt; &#39;/tmp/tmp/bla (deleted)&#39;
</code></pre>
<p>So, what we often do is to search for processes whose <code>exe</code> symlink
points to something that no longer exists – or rather, something that
says “deleted”. As a result, the first process shown above (PID 1026)
turned up during my search.</p>
<p>It doesn’t really fit the pattern, though: <code>exe</code> points to a
<em>directory</em>. Was this some kind of trickery that I didn’t know about?</p>
<p>Long story short, the process in question was started directly by the
kernel itself – it was not <code>fork()</code>ed nor <code>posix_spawn()</code>ed by some
other existing process, thus breaking a bunch of assumptions in my mind.
Yes, it’s not a big surprise that “the kernel can spawn processes”, but
the vast majority of them are children of some other processes that
already ran.</p>
<p>What I saw, was <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bpfilter"><code>bpfilter_umh</code></a>.</p>
<p>The basic idea is that this kernel module creates a “usermode driver”,
i.e. an “ordinary” process, and then communicates with it via pipes.</p>
<p>If you dig a bit more, you’ll come across <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/usermode_driver.c"><code>usermode_driver.c</code></a>,
the history of that file leads you to <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/umh.c"><code>umh.c</code></a>, and that history
in turn leads you to <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/kernel/umh.c?id=235586939d7fe4833ada9e988f92af543ee6851f">this commit</a> which contains this
comment:</p>
<blockquote>
<p>The usermode helper has a provenance from the old usb code which first
required a usermode helper.</p>
</blockquote>
<p>And this part of the diff of <code>kmod.c</code>:</p>
<blockquote>
<p>Unblock all signals when we exec a usermode process.
Shuu Yamaguchi  December 2000</p>
<p><code>call_usermodehelper</code> wait flag, and remove <code>exec_usermodehelper</code>.
Rusty Russell  Jan 2003</p>
</blockquote>
<p>In other words, this mechanism (i.e., spawning new processes outside of
the normal process hierarchy) has been around for quite a while. It
predates the switch to Git and I was not motivated enough to go all the
way back to the beginning, but you can find mentions of usermode helpers
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/kernel/kmod.c">in the history of <code>kmod.c</code></a>.</p>
<p>Then again, <code>bpfilter_umh</code> introduces new concepts after all.</p>
<p>What has already existed in the past are “usermode helpers”. For some
tasks, the kernel can spawn a new usermode process (i.e., it’s not
<code>fork()</code>ed from something else). A prominent example appears to be
loading kernel modules (initiated by the kernel, not userspace), which
calls out to the normal <code>modprobe</code> utility (see <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/kmod.c?id=1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"><code>kmod.c</code> from
2005</a>). <a href="https://kernelnewbies.org/KernelProjects/usermode-helper-enhancements">This page in the KernelNewbies wiki</a> lists more
examples.</p>
<p><code>bpfilter_umh</code>, however, is a new “type” of kernel module which not only
contains a normal kernel module but also some other code which will then
be run as a userspace process – a “usermode driver”. This approach has
only been around since <a href="https://lwn.net/Articles/755919/">bpfilter in Linux 4.18</a>. The code
that is being run in the userspace process is <em>embedded in a kernel
module</em>. That’s quite a bit different than just calling the normal
<code>/sbin/modprobe</code> that sits around on your drive. This also explains why
the <code>exe</code> symlink cannot show something meaningful – there simply is no
corresponding binary in the file system. (The code blob is copied from
the kernel module to a file in an “anonymous” <code>tmpfs</code>, which doesn’t
show up in the output of <code>mount</code>.)</p>
<p>On a side note: When I see such a process with <code>exe</code> being marked as
<code>deleted</code>, I restore the binary by doing <code>cp /proc/$pid/exe foo.bin</code>.
You can then, for example, ask your distribution’s package manager if it
knows a file that has the same SHA256 sum. If it does, it increases the
chances of this process being legitimate. This approach isn’t possible
with usermode drivers like <code>bpfilter_umh</code>, since there is no single file
that contains just that code.</p>
<p>What I could not find (yet) is a way to determine whether a given
userspace process belongs to a kernel module or not. So far, I only know
of these clues:</p>
<ul>
<li><code>/proc/$pid/exe</code> points to <code>/ (deleted)</code> (a directory, not a file).</li>
<li>File descriptors 0 and 1 are pipes and no other running process
    holds a reference to them.</li>
<li>File descriptor 2 points to <code>/dev/kmsg</code>.</li>
<li>When you unload the kernel module (probably has the same name as the
    process, minus the <code>_umh</code> suffix), the process should quit.</li>
</ul>
<p>That’s a bit wonky, though. Ideally, I would have hoped that some magic
file in <code>/proc</code> or <code>/sys</code> holds the PID(s) of usermode drivers. That
would allow us to exclude certain PIDs when searching for processes
whose program binaries are marked as “deleted”.</p>
<p><em>– Update:</em> A <a href="https://news.ycombinator.com/item?id=31706671">reader</a> wondered which parent PID theses processes
have. Good idea! They appear to be children of <code>kthreadd</code>, just like
kernel threads:</p>
<pre><code>root@ubuntu2004:~# ps ax -o pid,ppid,cmd | grep -e bpfilter -e kthreadd
      2       0 [kthreadd]
   1025       2 bpfilter_umh
</code></pre>
<p>So this is probably the best thing to look out for. The PPID itself
doesn’t tell you <em>which</em> kernel module they belong to, but it’s a very
strong indicator that this is not an “ordinary” userspace process –
which means it’s probably safe to trust the process’s title and, well,
that says <code>bpfilter_umh</code>, so there you have it. (Just saying: Don’t
trust process titles in general. They’re easy to manipulate.)</p>
<p>(Fun fact: This effectively hides <code>bpfilter_umh</code> from the output of
<code>pstree</code>.)</p>


        </div></div>
  </body>
</html>
