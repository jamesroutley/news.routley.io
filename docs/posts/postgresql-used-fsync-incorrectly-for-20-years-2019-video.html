<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://archive.fosdem.org/2019/schedule/event/postgresql_fsync/">Original</a>
    <h1>PostgreSQL used fsync incorrectly for 20 years (2019) [video]</h1>
    
    <div id="readability-page-1" class="page"><div>


<main role="main">
  
<article itemscope="" itemtype="http://schema.org/BlogPosting">
  
  
  <section itemprop="articleBody">
    
<p>For my url shortening system I wanted no collisions in the shortened url.</p>
<p>For example:</p>
<p>if you pass in a url called <code>https://longurl.com</code>, the backend will send you a short url that should be unique, the structure of the url would look something like <code>https://shorturl.com/[slug]</code></p>
<p>The slug is our main component, it should always be unqiue. The blog is all about ensuring the uniqueness.</p>
<p>Some things to note:</p>
<ul>
<li>The length of the slug depends on how many entries will there be?</li>
<li>So for 5 digit alphanumeric slug (also called Base-62):
26 + 26 + 10 =&gt; 62
62^5 non-repeating values are possible.</li>
</ul>
<p>What choices do we have to ensure uniqueness of the slug?</p>
<ul>
<li>
<p>Random slug</p>
<p>-&gt; The problem here is that for a request, there <strong>can</strong> be two same random characters (collisions).</p>
</li>
<li>
<p>Using MD5</p>
<p>-&gt; Collisions are possible here as well (although very rare, but we want no collision guarantee).</p>
</li>
<li>
<p>Using a <u><strong>Counter</strong></u></p>
<p>-&gt; Counters are the only thing that can guarantee no collisions. This is true if we only use a single database, which is bad for scaling. For multiple distributed database, we again have a problem!</p>
</li>
</ul>

<p>For a no collision guarantee URL shortening system (single database), our unique id i.e our slug will be a counter.</p>
<p>For example:</p>
<ul>
<li>our first slug will be: 10000 =&gt; (2bI)<sub>base62</sub></li>
<li>second: 10001</li>
<li>third: 10002 and so on.</li>
</ul>
<p>Now the problem is when we want to horizaontally scale and talk with multiple databases.</p>
<p>The different approaches with multi database counter will look like:</p>
<ul>
<li>
<p>One counter for all databases</p>
<p>-&gt; This will ensure atomicity, but will slow down response time</p>
</li>
<li>
<p>Different counter for different databases</p>
<p>-&gt; This approach will be faster, but the problem is how will we ensure that there are no collisions between two different counters?</p>
</li>
</ul>
<h2 id="problem-with-counter-synchronization">Problem with counter synchronization</h2>
<p>The problem with counter synchronization is that there can be two counters with same value, this can be solved by using Apache zookeeper.</p>
<p>What zookeeper would do is assign different counter ranges to different databases or servers.</p>
<p>For example:</p>
<ul>
<li>DB<sub>1</sub> is assigned counter range from 10000 to 20000</li>
<li>DB<sub>2</sub> is assigned counter range from 20001 to 30000</li>
<li>DB<sub>3</sub> is assigned counter range from 30001 to 40000</li>
<li>DB<sub>4</sub> is assigned counter range from 40001 to 50000 and so on.</li>
</ul>
<p>And zookeeper will also keep track of the counter usage so that it if a database exceeds the range, it is assigned a new range.</p>
<p>In conclusion, for our distributed no collision guaranteed url shortening service, we can use counters to guarantee no collisions and use apache zookeeper to synchronize the counters across databases.</p>

  </section>
</article>

</main>

</div></div>
  </body>
</html>
