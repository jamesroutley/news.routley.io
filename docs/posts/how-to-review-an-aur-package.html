<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bertptrs.nl/2026/01/30/how-to-review-an-aur-package.html">Original</a>
    <h1>How to Review an AUR Package</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
        <p>On Friday, July 18th, 2025, the Arch Linux team was notified that three <abbr title="Arch User Repository">AUR</abbr> packages had been
uploaded that contained malware. A few maintainers including myself took care of deleting these
packages, removing all traces of the malicious code, and protecting against future malicious
uploads.</p>

<p>My fellow maintainer <a href="https://archlinux.org/people/package-maintainers/#mh4ckt3mh4ckt1c4s">Quentin Michaud</a> already did a nice <a href="https://www.mh4ckt3mh4ckt1c4s.xyz/blog/aur-chaos-malware-analysis/">write-up about how the malware
worked</a>, so I won’t go into detail too much about that. If you want to know more about
that, read his blog. Instead, I’d like to do a crash course on how these packaging scripts work, and
how you would review them yourself.</p>

<h2 id="what-is-the-aur">What is the <abbr title="Arch User Repository">AUR</abbr>?</h2>

<p>The Arch User Repository is a collection of packaging scripts, <a href="https://man.archlinux.org/man/PKGBUILD.5.en"><code>PKGBUILD</code></a> files,
created by users. Anyone who creates an account on <a href="https://aur.archlinux.org/">aur.archlinux.org</a>, can upload an Arch
Linux packaging script, granted one doesn’t already exist for the same name. There are of course
<a href="https://wiki.archlinux.org/title/AUR_submission_guidelines#Rules_of_submission">some rules</a> around what you can submit (e.g. don’t duplicate other official or
<abbr title="Arch User Repository">AUR</abbr> packages) but generally anything goes.</p>

<p>Each package has one primary maintainer, by default whoever uploaded the packaging script first, but
that can change over time, either by that maintainer transferring responsibility themselves, or by
moderators removing the maintainer for various reasons. This is not a democracy, or even a
meritocracy, but it works, and there is a lot of useful software on there.</p>

<p>Installing from <abbr title="Arch User Repository">AUR</abbr> packaging scripts is not quite as simple as installing from the main packaging
repos. You can run <a href="https://man.archlinux.org/man/makepkg.8"><code>makepkg</code></a> on a <code>PKGBUILD</code> and install the resulting package, but this
gets more difficult as those <code>PKGBUILD</code>s often depend on other packages only found in the <abbr title="Arch User Repository">AUR</abbr>. To
make this easier, people often use <abbr title="Arch User Repository">AUR</abbr>-helpers, which provide a <code>pacman</code>-like experience to manage
them. That does come with some drawbacks, however.</p>

<p>Anyone who wants to do so can upload their <code>PKGBUILD</code> to the <abbr title="Arch User Repository">AUR</abbr>. That is great to lower the barrier
to entry, and it is how I got my start contributing to Arch Linux. Unfortunately, not everyone has
the best intentions, and it has happened that people upload malware. Because of this, it is crucial
that you vet the <code>PKGBUILD</code>s that you install.</p>

<h2 id="what-do-pkgbuilds-look-like">What do <code>PKGBUILD</code>s look like?</h2>

<p>As mentioned before, the <abbr title="Arch User Repository">AUR</abbr> does not contain packages, but rather contains build scripts to create
packages. Arch Linux <code>PKGBUILD</code>s are simply bash scripts that follow a certain pattern. Take for
example the following example:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td><pre><span># Maintainer: John Doe &lt;john@example.org&gt;</span>
<span>pkgname</span><span>=</span>example
<span>pkgver</span><span>=</span>1.0
<span>pkgrel</span><span>=</span>1
<span>pkgdesc</span><span>=</span><span>&#34;An example package&#34;</span>
<span>arch</span><span>=(</span>x86_64<span>)</span>
<span>url</span><span>=</span><span>&#34;https://example.org/&#34;</span>
<span>license</span><span>=(</span><span>&#39;WTFPL&#39;</span><span>)</span>
<span>install</span><span>=</span><span>&#34;example.install&#34;</span>
<span>source</span><span>=(</span><span>&#34;https://example.org/</span><span>$pkgname</span><span>-</span><span>$pkgver</span><span>.tar.gz&#34;</span>
        <span>&#34;</span><span>$pkgname</span><span>-</span><span>$pkgver</span><span>.patch::https://git.example.org/example/pull/42.patch&#34;</span><span>)</span>
<span>sha256sums</span><span>=(</span><span>&#34;de4bba005e86b4fbf0399e2cb492b1e941099b951a45137212507c2cbc8fae63&#34;</span>
            <span>&#34;b6dc933311bc2357cc5fc636a4dbe41a01b7a33b583d043a7f870f3440697e27&#34;</span><span>)</span>

prepare<span>()</span> <span>{</span>
    <span>cd</span> <span>&#34;</span><span>$pkgname</span><span>-</span><span>$pkgver</span><span>&#34;</span>
    patch <span>-p1</span> <span>-i</span> <span>&#34;</span><span>$srcdir</span><span>/</span><span>$pkgname</span><span>-</span><span>$pkgver</span><span>.patch&#34;</span>
<span>}</span>

build<span>()</span> <span>{</span>
    <span>cd</span> <span>&#34;</span><span>$pkgname</span><span>-</span><span>$pkgver</span><span>&#34;</span>
    ./configure <span>--prefix</span><span>=</span>/usr
    make
<span>}</span>

check<span>()</span> <span>{</span>
    <span>cd</span> <span>&#34;</span><span>$pkgname</span><span>-</span><span>$pkgver</span><span>&#34;</span>
    make <span>-k</span> check
<span>}</span>

package<span>()</span> <span>{</span>
    <span>cd</span> <span>&#34;</span><span>$pkgname</span><span>-</span><span>$pkgver</span><span>&#34;</span>
    make <span>DESTDIR</span><span>=</span><span>&#34;</span><span>$pkgdir</span><span>/&#34;</span> <span>install</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It starts with a maintainer-line, which is not used programmatically but helps users of the software
contact the maintainer if something doesn’t work. It is good practice to also have the emails of
previous maintainers there, to recognise their contributions. Then we come to a few metadata
variables.</p>

<h3 id="metadata">Metadata</h3>

<dl>
  <dt><code>pkgname</code></dt>
  <dd>defines the package we are building at the moment.</dd>
  <dt><code>pkgver</code></dt>
  <dd>signifies which upstream release of the software is being built. This number should only ever
increase, as <code>pacman</code> will use this number to determine if an update is necessary.<sup id="fnref:versions"><a href="#fn:versions" rel="footnote" role="doc-noteref">1</a></sup></dd>
  <dt><code>pkgrel</code></dt>
  <dd>is the package release number. This release number is incremented every time an update is done to
the <code>PKGBUILD</code> without updating the <code>pkgver</code>, such as when the packaging options change. It resets
to <code>1</code> every time a new upstream release is done.</dd>
  <dt><code>pkgdesc</code></dt>
  <dd>is a short, human-readable description of the package. This is shown in package lists and is used
for searching, but doesn’t affect the built software otherwise.</dd>
  <dt><code>arch</code></dt>
  <dd>is a list of valid CPU architectures this package can be built for. It can also be the special
array <code>(&#39;any&#39;)</code>, which does not (only) denote that this package can be built for any architecture,
but rather that the resulting package does not contain any architecture-specific code. This is
common for packages written in languages such as Python.</dd>
  <dt><code>url</code></dt>
  <dd>is just link a package user might go for more information and does not otherwise affect the
package.</dd>
  <dt><code>license</code></dt>
  <dd>is the licence under which this package is distributed. This used to be an array of all applicable
licences for the project, but since the meaning of that is a bit ambiguous, these days the licence
array should hold a single item which is an <a href="https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/">SPDX license expression</a>.</dd>
  <dt><code>install</code></dt>
  <dd>is usually not present in a <code>PKGBUILD</code>. If present, it refers to the name of a script (included
alongside the package file) with specific bash functions that will get executed when the package
is installed, upgraded, or removed. It is run from <code>pacman</code>, and therefore as root.</dd>
  <dt><code>source</code></dt>
  <dd>is an array of sources. These can be either downloadable URLs, version control URLs such as git,
or simple file names, meaning the file in question in part of the package files.</dd>
  <dt><code>sha256sums</code></dt>
  <dd>is another array, of the same length as sources, specifying the expected <a href="https://en.wikipedia.org/wiki/SHA-2">SHA-256</a> checksums for
the package sources. There are other hashing algorithms available, from <code>crc32sums</code> to <code>b2sums</code>.
Multiple sets of digests may be specified but at least one should be. The magic value <code>SKIP</code> may be
used to skip verifying checksums for certain files, for example for external checksums, or PGP
signatures.</dd>
</dl>

<p>After all that metadata, we get to the actual code that does something: the packaging functions.</p>

<h3 id="build-functions">Build functions</h3>

<p>Building packages is done in 4 stages, each with their own bash function. It starts with
<code>prepare()</code>. This function is expected to make all the necessary changes to the source code, such as
applying patch files or editing out certain lines with <code>sed</code>. In certain ecosystems, such as Node.js
and Rust, it also downloads the dependencies. Ideally, all steps following <code>prepare()</code> no longer
need network access.</p>

<p>Then we get to <code>build()</code>, which, as the name suggests, builds the package. This is the place to call
configure scripts, compilers, and whatever else produces the binaries involved. This is, generally,
the part that takes time.</p>

<p>After packaging, there is usually a <code>check()</code> step. Here we want to check whether the package
functions as intended, within the Arch Linux packaging. What to do here varies, but most <code>PKGBUILD</code>s
try to run the package’s unit tests. Arch Linux generally has never versions of libraries than the
ones upstream projects test with, and such tests form a reasonable smoke test that things did not
break in unexpected ways.</p>

<p>Finally, the <code>package()</code> function is called. This is the only function that’s technically required,
all the others can be omitted. This function should move the files, generated in the <code>build()</code> step,
into their final positions relative to some <code>$pkgdir</code>. Many ecosystems provide (an equivalent of)
<code>make install</code> for this, which makes life easier, but often you will simply have to spell this out.</p>

<h2 id="what-to-look-out-for">What to look out for</h2>

<p>Now that we know what the different parts of a <code>PKGBUILD</code> mean, we can talk about reviewing its
contents. I want to go over a few of the items I find most important, but this is by no means an
exhaustive list. The fact I’m writing this will probably affect the strategies people use in some
way. Nevertheless, let’s fist…</p>

<h3 id="check-the-sources-array">Check the <code>sources</code> array</h3>

<p>Regardless of what the <code>PKGBUILD</code> itself says, if the sources it’s going to compile are malicious,
nothing else really matters. Make sure that you trust the upstream project, and that files are
downloaded from a reasonable place, such as tags in official git repositories, or source releases on
the official website. PGP signatures from the authors are generally even better, so you know who
created, or at least signed off on the sources.</p>

<p>The Arch Linux project has <a href="https://rfc.archlinux.page/0046-upstream-package-sources/">accepted an RFC on what sources should be used</a>, in order
to have the most trustworthy sources for packaging. While such rigour isn’t necessary or, in some
cases, even desirable for the <abbr title="Arch User Repository">AUR</abbr>, you can use it as inspiration.</p>

<p>Patches are also sources, and malware can hide in them. You should have a look at any patches being
applied to the source code, and, if possible where they come from. It’s not unusual to apply
merged-but-not-released changes from upstream to deal with newer versions of libraries, but make
sure it makes sense.</p>

<h3 id="check-if-the-build-steps-make-sense">Check if the build steps make sense</h3>

<p>The <code>prepare()</code>, <code>build()</code>, <code>check()</code>, and <code>package()</code> functions are inherently code that will be
executed on your machine when you build a package so if any</p>

<ul>
  <li>
    <p>No downloads should happen in <code>build()</code>, <code>check()</code>, or <code>package()</code>, and ideally not in
<code>prepare()</code>, though many ecosystems (Go, Node.js, Rust to name a few) require it.</p>
  </li>
  <li>
    <p>The commands run by the script should be obvious packaging commands, and any custom scripts should
come from the upstream repos. Often the packaging script matches the upstream “how to install” but
often it doesn’t, as package maintainers generally call the build tools directly rather than call
wrapper scripts.</p>
  </li>
  <li>
    <p>Build scripts should not run <code>sudo</code> or anything similar. If it does that anyway, it’s wrong. At
best, it’s a packaging error, as <code>sudo</code> shouldn’t be expected to work in a non-interactive
environment like a build chroot. Sometimes a packager mistakenly tries to move package files into
place instead of adding them to the package.</p>
  </li>
</ul>

<h3 id="scrutinise-install-scripts">Scrutinise install scripts</h3>

<p>Install scripts are, as mentioned above, rarely seen, but if when they are, they need to be
scrutinised as their contents will run, <em>as root</em>, when a package is installed, upgraded, or
removed. Most software doesn’t need this, as common use cases have safer alternatives.</p>

<p>Similarly, newly installed <code>pacman</code> hooks should also raise an eyebrow. Pacman hooks install to
<code>/usr/share/libalpm/hooks</code> (and sometimes to <code>/etc/pacman.d/hooks</code> though that’s incorrect) and can
run a command whenever its triggers are hit. The ones included in the main Arch repos are benign and
in fact reduce the need for <code>install</code> scripts, by automatically regenerating font- and icon caches
as needed, regenerating the <code>initramfs</code>, and many more. An arbitrary <code>PKGBUILD</code> adding one of their
own is unusual, and you should pay attention to what that hook is trying to do.</p>

<h3 id="if-you-dont-understand-it-dont-use-it">If you don’t understand it, don’t use it</h3>

<p>While we try to keep it clean, the <abbr title="Arch User Repository">AUR</abbr> is freely accessible to anyone who figures out how to get
past the CAPTCHA, and anyone can upload code to it. Even popular, well-intentioned code can have
bugs sometimes and <a href="https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/issues/123">do harm to your system</a>. The <abbr title="Arch User Repository">AUR</abbr> is, at the best of times,
maintained by volunteers, many of which are currently getting their feet wet for the first time
while packaging. Mistakes can and will happen, and that’s okay.</p>

<h2 id="when-something-might-be-malicious">When something might be malicious</h2>

<p>Now that we have a hunch as to what might be malicious, we can decide what to do with it. The
easiest way is to simply ask. The best place for that, in my opinion, is the <a href="irc://irc.libera.chat:+6697/archlinux-aur"><code>#archlinux-aur</code> IRC
channel</a> on <a href="https://libera.chat/">Libera</a>, which is the official venue for <abbr title="Arch User Repository">AUR</abbr> discussion.
<a href="https://bbs.archlinux.org/viewforum.php?id=38">The forums</a> are also a good place to ask. If all fails, there is also the <a href="https://lists.archlinux.org/mailman3/lists/aur-general.lists.archlinux.org/">mailing list</a>.</p>

<p>If the package is indeed malicious, one of the Package Maintainers can take it down and block the
offending user(s). Should they try to avoid their ban, the measures will also escalate. As a user,
that’s where your input ends.</p>

<h2 id="that-feels-too-simple">That feels too simple</h2>

<p>And it is. The <abbr title="Arch User Repository">AUR</abbr> was made for a different kind of internet. More cooperative, less hostile. It’s
based on trust that users will generally do sensible things.<sup id="fnref:sensible"><a href="#fn:sensible" rel="footnote" role="doc-noteref">2</a></sup> The <abbr title="Arch User Repository">AUR</abbr> is old software. It
started as “just some FTP server” where people could upload files. Such a system would not be
designed in 2026.</p>

<p>There are improvements to be had for sure. The moderation systems are somewhat archaic, the
contribution workflow is not what people expect. The licensing of <code>PKGBUILD</code> files, especially when
the original author is long gone, is tricky.<sup id="fnref:tricky"><a href="#fn:tricky" rel="footnote" role="doc-noteref">3</a></sup> A pull-request like system is often suggested.
I think that would be a real improvement. In general, the system needs more love. That’s what you
get with open source projects; if no one wants to work on it, it gets no work. And that’s okay.</p>

<p>Right now I believe there is no end in sight for the <abbr title="Arch User Repository">AUR</abbr>. We can keep going as-is for a while
longer. But if people were to step up to make things better, we can do a lot more.</p>

<hr/>





      </div></div>
  </body>
</html>
