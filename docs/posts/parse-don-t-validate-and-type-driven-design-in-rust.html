<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.harudagondi.space/blog/parse-dont-validate-and-type-driven-design-in-rust/">Original</a>
    <h1>Parse, Don&#39;t Validate and Type-Driven Design in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>  <article id="main-content">  <p><strong>Reading time:</strong> 17 min read</p> <span> <hr/> <h2>
Table of Contents
</h2> <p><a href="#dividing-by-zero">1.1</a> Dividing by zero</p><p><a href="#examples-in-the-wild">1.2</a> Examples in the wild</p><p><a href="#maxims-of-type-driven-design">1.3</a> Maxims of Type Driven Design</p><p><a href="#what-can-we-do">1.4</a> What can we do?</p><p><a href="#conclusion">1.5</a> Conclusion</p> <hr/> </span> <figure id="image-post">  <label for="a-gavel-photo-by-the-tingey-injury-law-firm" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/parse-dont-validate/tingey-injury-law-firm-veNb0DDegzE-unsplash.jpg" alt="A gavel. Photo by the Tingey Injury Law Firm." data-astro-cid-ascxwteo=""/> </label> <figcaption> <p>Photo by the <a href="https://unsplash.com/@tingeyinjurylawfirm">Tingley Injury Law Firm</a>.</p> </figcaption> </figure>
<p>In the Rust Programming Language Community Server, there’s tag named <code>-parse-dont-validate</code> which links to an <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">article</a> about the concept of avoiding validation functions and encoding invariants in the type level instead. I usually recommend it to beginners/intermediates to Rust who are struggling with designing APIs.</p>
<p>The only problem is that it uses Haskell to explain its concepts.</p>
<p>Yeah, it’s <em>fine</em>, but for beginners unfamiliar with the functional paradigm, it might not be so approachable. And so I wanted so write a blog post about this pattern but in a rather Rust-centric way. So let’s start!</p>
<section><h2 id="dividing-by-zero">Dividing by zero<a aria-hidden="true" tabindex="-1" href="#dividing-by-zero"> #</a></h2><p>One basic example I can give is a function that divides a number by another number.</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>divide</span><span>(</span><span>a</span><span>:</span><span> </span><span>i32</span><span>,</span><span> </span><span>b</span><span>:</span><span> </span><span>i32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>i32</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>a</span><span> </span><span>/</span><span> </span><span>b</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>This is fine, but unfortunately it can panic when <code>b</code> has the value of zero:</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>5</span><span>;</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>b</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p></div><div><p><span>  </span><span>dbg!</span><span>(</span><span>divide</span><span>(</span><span>a</span><span>,</span><span> </span><span>b</span><span>));</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>This gives an <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=06b95e79e3958fd10478f0a4bb75e8fb">error</a>:</p><div><figure><pre data-language="rust"><code><div><p><span>   </span><span>Compiling</span><span> </span><span>playground</span><span> </span><span>v0</span><span>.</span><span>0</span><span>.</span><span>1</span><span> </span><span>(</span><span>/</span><span>playground</span><span>)</span></p></div><div><p><span>    </span><span>Finished</span><span> `</span><span>dev</span><span>` </span><span>profile</span><span> </span><span>[</span><span>unoptimized</span><span> </span><span>+</span><span> </span><span>debuginfo</span><span>]</span><span> </span><span>target</span><span>(</span><span>s</span><span>)</span><span> </span><span>in</span><span> </span><span>1</span><span>.</span><span>28s</span></p></div><div><p><span>     </span><span>Running</span><span> `</span><span>target</span><span>/</span><span>debug</span><span>/</span><span>playground</span><span>`</span></p></div><div></div><div><p><span>thread</span><span> </span><span>&#39;</span><span>main</span><span>&#39;</span><span> </span><span>(</span><span>41</span><span>)</span><span> </span><span>panicked</span><span> </span><span>at</span><span> </span><span>src</span><span>/</span><span>main</span><span>.</span><span>rs</span><span>:</span><span>2</span><span>:</span><span>5</span><span>:</span></p></div><div><p><span>attempt</span><span> </span><span>to</span><span> </span><span>divide</span><span> </span><span>by</span><span> </span><span>zero</span></p></div><div><p><span>note</span><span>:</span><span> </span><span>run</span><span> </span><span>with</span><span> `</span><span>RUST_BACKTRACE=</span><span>1</span><span>` </span><span>environment</span><span> </span><span>variable</span><span> </span><span>to</span><span> </span><span>display</span><span> </span><span>a</span><span> </span><span>backtrace</span></p></div></code></pre></figure></div><p>That’s fine and dandy if we want erroneous values to fail loudly at runtime, but what if we want stronger guarantees? This is especially important when some operations don’t fail loudly, like the following:</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>divide_floats</span><span>(</span><span>a</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>b</span><span>:</span><span> </span><span>f32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>f32</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>a</span><span> </span><span>/</span><span> </span><span>b</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>5</span><span>.</span><span>0</span><span>;</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>b</span><span> </span><span>=</span><span> </span><span>0</span><span>.</span><span>0</span><span>;</span></p></div><div><p><span>  </span><span>dbg!</span><span>(</span><span>divide_floats</span><span>(</span><span>a</span><span>,</span><span> </span><span>b</span><span>));</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><div><figure><pre data-language="rust"><code><div><p><span>   </span><span>Compiling</span><span> </span><span>playground</span><span> </span><span>v0</span><span>.</span><span>0</span><span>.</span><span>1</span><span> </span><span>(</span><span>/</span><span>playground</span><span>)</span></p></div><div><p><span>    </span><span>Finished</span><span> `</span><span>dev</span><span>` </span><span>profile</span><span> </span><span>[</span><span>unoptimized</span><span> </span><span>+</span><span> </span><span>debuginfo</span><span>]</span><span> </span><span>target</span><span>(</span><span>s</span><span>)</span><span> </span><span>in</span><span> </span><span>0</span><span>.</span><span>62s</span></p></div><div><p><span>     </span><span>Running</span><span> `</span><span>target</span><span>/</span><span>debug</span><span>/</span><span>playground</span><span>`</span></p></div><div><p><span>[</span><span>src</span><span>/</span><span>main</span><span>.</span><span>rs</span><span>:</span><span>8</span><span>:</span><span>2</span><span>]</span><span> </span><span>divide_floats</span><span>(</span><span>a</span><span>,</span><span> </span><span>b</span><span>)</span><span> </span><span>=</span><span> </span><span>inf</span></p></div></code></pre></figure></div><p>There’s no error! But do we want that?</p><p>We could add an <code>assert!</code> in the <code>divide_floats</code> function to emulate typical integer division behavior.</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>divide_floats</span><span>(</span><span>a</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>b</span><span>:</span><span> </span><span>f32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>f32</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>assert_ne!</span><span>(</span><span>b</span><span>,</span><span> </span><span>0</span><span>.</span><span>0</span><span>,</span><span> </span><span>&#34;Division by zero is not allowed.&#34;</span><span>);</span></p></div><div><p><span>  </span><span>a</span><span> </span><span>/</span><span> </span><span>b</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><div><figure><pre data-language="rust"><code><div><p><span>   </span><span>Compiling</span><span> </span><span>playground</span><span> </span><span>v0</span><span>.</span><span>0</span><span>.</span><span>1</span><span> </span><span>(</span><span>/</span><span>playground</span><span>)</span></p></div><div><p><span>    </span><span>Finished</span><span> `</span><span>dev</span><span>` </span><span>profile</span><span> </span><span>[</span><span>unoptimized</span><span> </span><span>+</span><span> </span><span>debuginfo</span><span>]</span><span> </span><span>target</span><span>(</span><span>s</span><span>)</span><span> </span><span>in</span><span> </span><span>0</span><span>.</span><span>65s</span></p></div><div><p><span>     </span><span>Running</span><span> `</span><span>target</span><span>/</span><span>debug</span><span>/</span><span>playground</span><span>`</span></p></div><div></div><div><p><span>thread</span><span> </span><span>&#39;</span><span>main</span><span>&#39;</span><span> </span><span>(</span><span>32</span><span>)</span><span> </span><span>panicked</span><span> </span><span>at</span><span> </span><span>src</span><span>/</span><span>main</span><span>.</span><span>rs</span><span>:</span><span>2</span><span>:</span><span>5</span><span>:</span></p></div><div><p><span>assertion</span><span> `</span><span>left</span><span> </span><span>!=</span><span> </span><span>right</span><span>` </span><span>failed</span><span>:</span><span> </span><span>Division</span><span> </span><span>by</span><span> </span><span>zero</span><span> </span><span>is</span><span> </span><span>not</span><span> </span><span>allowed</span><span>.</span></p></div><div><p><span>  </span><span>left</span><span>:</span><span> </span><span>0</span><span>.</span><span>0</span></p></div><div><p><span> </span><span>right</span><span>:</span><span> </span><span>0</span><span>.</span><span>0</span></p></div></code></pre></figure></div><p>Cute! But there’s still a problem of running into panics only at runtime. My beef with Python (or any other dynamic language for that matter) is that a lot of errors only arises when you run the program. That’s why they’re adding typechecking to these languages: people want to bubble some mistakes to compile-time (or typecheck-time, whatever). We can use Rust’s rich type system to communicate these errors at build time.</p><p>One way, which I think is the more common way as people are more familiar with it is the idea of fallible functions, which return either an <code>Option</code> or a <code>Result</code>.</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>divide_floats</span><span>(</span><span>a</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>b</span><span>:</span><span> </span><span>f32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>f32</span><span>&gt;</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>if</span><span> </span><span>b</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>None</span><span>;</span></p></div><div><p><span>  </span><span>}</span></p></div><div><p><span>  </span><span>Some</span><span>(</span><span>a</span><span> </span><span>/</span><span> </span><span>b</span><span>)</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>This is a fine way to do things, as it communicates that (1) the function can fail, and (2) you can handle the failing case after. <sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> Of course, <code>catch_unwind</code> exists, but I’m pretending that it doesn’t.  </span>  To me, the function’s invariants (<code>b</code> must not be zero) is encoded after-the-fact, aka in the return type <code>Option&lt;T&gt;</code>. This implies to me that the invariants could be encoded before-the-fact, aka in the function parameters. But what would that look like?</p><p>Enter the newtype pattern.</p><p>Say, let’s have a type that is something like <code>f32</code>, but it’s guaranteed to never be zero. We’ll name it <code>NonZeroF32</code>:</p><p>This struct only contains a single field <code>f32</code>. The semantics of the type understood from the name is that it’s just like a normal <code>f32</code>, but does not allow the value of zero. How do we guarantee this? Since rust does encapsulation at the module level, we make this type public while have its field private.</p><div><figure><pre data-language="rust"><code><div><p><span>mod</span><span> </span><span>nonzero</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>pub</span><span> </span><span>struct</span><span> </span><span>NonZeroF32</span><span>(</span><span>f32</span><span>);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>Then, the only way to construct this type is via a fallible constructor function:</p><div><figure><pre data-language="rust"><code><div><p><span>impl</span><span> </span><span>NonZeroF32</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>fn</span><span> </span><span>new</span><span>(</span><span>n</span><span>:</span><span> </span><span>f32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>NonZeroF32</span><span>&gt;</span><span> </span><span>{</span></p></div><div><p><span>    </span><span>if</span><span> </span><span>n</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span></p></div><div><p><span>      </span><span>return</span><span> </span><span>None</span><span>;</span></p></div><div><p><span>    </span><span>}</span></p></div><div></div><div><p><span>    </span><span>Some</span><span>(</span><span>NonZeroF32</span><span>(</span><span>n</span><span>))</span></p></div><div><p><span>  </span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>Remember to add some convenience traits.</p><div><figure><pre data-language="rust"><code><div><p><span>impl</span><span> </span><span>Add</span><span> </span><span>for</span><span> </span><span>NonZeroF32</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span></p></div><div><p><span>impl</span><span> </span><span>Add</span><span>&lt;</span><span>f32</span><span>&gt;</span><span> </span><span>for</span><span> </span><span>NonZeroF32</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span></p></div><div><p><span>impl</span><span> </span><span>Add</span><span>&lt;</span><span>NonZeroF32</span><span>&gt;</span><span> </span><span>for</span><span> </span><span>f32</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span></p></div><div><p><span>//</span><span> and a bunch of other operators...</span></p></div></code></pre></figure></div><p>We can then use this in our <code>divide_floats</code> function.</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>divide_floats</span><span>(</span><span>a</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>b</span><span>:</span><span> </span><span>NonZeroF32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>f32</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>a</span><span> </span><span>/</span><span> </span><span>b</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>There is an interesting implication in this pattern.</p><p>In the second version of <code>divide_floats</code>, we changed the return type from <code>f32</code> to <code>Option&lt;f32&gt;</code> just to avoid the panics. As described in the original article by Alexis King, this is a <em>weakening</em> of the return type, and the function’s promise. We temper the caller’s expectation by saying that yes, this function can fail in some way, and you have to account for that. And that weakening is described in the type system via the <code>Option</code> enum.</p><p>In the third iteration of <code>divide_floats</code>, we change our perspective and ask ourselves “instead of weakening the return type, what if we <em>strengthen</em> the function parameters?” We communicated that via accepting a <code>NonZeroF32</code>. Instead of having the validation code in our functions, we instead push that responsibility to the caller. The validation now happens before the function execution.</p><p>To see the advantage of pushing the validation forward to the user, let’s say we have another function like so:</p><div><figure><pre data-language="rust"><code><div><p><span>//</span><span> The quadratic formula!</span></p></div><div><p><span>fn</span><span> </span><span>roots</span><span>(</span><span>a</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>b</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>c</span><span>:</span><span> </span><span>f32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>f32</span><span>;</span><span> </span><span>2</span><span>]</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>//</span><span> For the sake of demonstration we will be ignoring complex roots</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>discriminant</span><span> </span><span>=</span><span> </span><span>b</span><span> </span><span>*</span><span> </span><span>b</span><span> </span><span>-</span><span> </span><span>4</span><span> </span><span>*</span><span> </span><span>a</span><span> </span><span>*</span><span> </span><span>c</span><span>;</span></p></div><div><p><span>  </span><span>[</span></p></div><div><p><span>    </span><span>-</span><span>b</span><span> </span><span>+</span><span> </span><span>discriminant</span><span>.</span><span>sqrt</span><span>()</span><span> </span><span>/</span><span> </span><span>(</span><span>2</span><span> </span><span>*</span><span> </span><span>a</span><span>),</span></p></div><div><p><span>    </span><span>-</span><span>b</span><span> </span><span>-</span><span> </span><span>discriminant</span><span>.</span><span>sqrt</span><span>()</span><span> </span><span>/</span><span> </span><span>(</span><span>2</span><span> </span><span>*</span><span> </span><span>a</span><span>),</span></p></div><div><p><span>  </span><span>]</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>This function can fail if the discriminant is negative (which we will be ignoring in this contrived example), and if <code>a</code> is zero. The two ways of going about this can be written as follows:</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>try_roots</span><span>(</span><span>a</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>b</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>c</span><span>:</span><span> </span><span>f32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;[</span><span>f32</span><span>;</span><span> </span><span>2</span><span>]&gt;</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>if</span><span> </span><span>a</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>None</span><span>;</span><span> </span><span>}</span></p></div><div><p><span>  </span><span>//</span><span> ...</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>fn</span><span> </span><span>newtyped_roots</span><span>(</span><span>a</span><span>:</span><span> </span><span>NonZeroF32</span><span>,</span><span> </span><span>b</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>c</span><span>:</span><span> </span><span>f32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>f32</span><span>;</span><span> </span><span>2</span><span>]</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>//</span><span> unchanged</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>The <code>Option</code> version has me duplicating the conditional for at least two different functions, which might be icky if you are a DRY-hard. Also, not only the function has to validate if the float can be zero, the <em>caller</em> must then validate again by matching on the returned <code>Option</code>. That seems redundant. It would be ideal if we only need to check only once.</p><div><figure><pre data-language="rust"><code><div><p><span>let</span><span> </span><span>roots</span><span> </span><span>=</span><span> </span><span>try_roots</span><span>(</span><span>5</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>7</span><span>);</span><span> </span><span>//</span><span> `try_roots` does a validation check</span></p></div><div><p><span>//</span><span> and then we validate it again by matching on the result</span></p></div><div><p><span>match</span><span> </span><span>roots</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>Some</span><span>(</span><span>result</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>do_something</span><span>(),</span></p></div><div><p><span>  </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>handle_error</span><span>();</span><span> </span><span>return</span><span> </span><span>},</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>The <code>NonZeroF32</code> version can help with that as validation happens before, and happens once, instead of twice.</p><div><figure><pre data-language="rust"><code><div><p><span>//</span><span> Handle the special case once</span></p></div><div><p><span>let</span><span> </span><span>Some</span><span>(</span><span>a</span><span>)</span><span> </span><span>=</span><span> </span><span>NonZeroF32</span><span>::</span><span>new</span><span>(</span><span>5</span><span>)</span><span> </span><span>else</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>handle_error</span><span>();</span></p></div><div><p><span>  </span><span>return</span><span>;</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>//</span><span> `newtyped_roots` does not need to handle it again,</span></p></div><div><p><span>//</span><span> indicated by the function not needing to return</span></p></div><div><p><span>//</span><span> an `Option` and us handling the result.</span></p></div><div><p><span>let</span><span> </span><span>[</span><span>root1</span><span>,</span><span> </span><span>root2</span><span>]</span><span> </span><span>=</span><span> </span><span>newtyped_roots</span><span>(</span><span>a</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>7</span><span>);</span></p></div></code></pre></figure></div><p>Moving away from the <code>divide_floats</code>, let’s now use an example from the original blog post, converted to Rust:</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>get_cfg_dirs</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>PathBuf</span><span>&gt;,</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>Error</span><span>&gt;&gt;</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>cfg_dirs_string</span><span> </span><span>=</span><span> </span><span>std</span><span>::</span><span>env</span><span>::</span><span>var</span><span>(</span><span>&#34;CONFIG_DIRS&#34;</span><span>)</span><span>?</span><span>;</span></p></div><div></div><div><p><span>  </span><span>let</span><span> </span><span>cfg_dirs_list</span><span> </span><span>=</span><span> </span><span>cfg_dirs_string</span><span>.</span><span>split</span><span>(</span><span>&#39;</span><span>,</span><span>&#39;</span><span>)</span></p></div><div><p><span>    </span><span>.</span><span>map</span><span>(</span><span>PathBuf</span><span>::</span><span>from</span><span>)</span></p></div><div><p><span>    </span><span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>PathBuf</span><span>&gt;&gt;();</span></p></div><div></div><div><p><span>  </span><span>if</span><span> </span><span>cfg_dirs_list</span><span>.</span><span>is_empty</span><span>()</span><span> </span><span>{</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>Err</span><span>(</span><span>&#34;CONFIG_DIRS cannot be empty&#34;</span><span>.</span><span>into</span><span>());</span></p></div><div><p><span>  </span><span>}</span></p></div><div></div><div><p><span>  </span><span>Ok</span><span>(</span><span>cfg_dirs_list</span><span>)</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;(),</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>Error</span><span>&gt;&gt;</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>cfg_dirs</span><span> </span><span>=</span><span> </span><span>get_cfg_dirs</span><span>()</span><span>?</span><span>;</span></p></div><div><p><span>  </span><span>match</span><span> </span><span>cfg_dirs</span><span>.</span><span>first</span><span>()</span><span> </span><span>{</span></p></div><div><p><span>    </span><span>Some</span><span>(</span><span>cache_dir</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>init_cache</span><span>(</span><span>cache_dir</span><span>),</span></p></div><div><p><span>    </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>unreachable!</span><span>(</span><span>&#34;should never happen; already checked configDirs is non-empty&#34;</span><span>),</span></p></div><div><p><span>  </span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>Notice the following:</p><ol>
<li>We checked if <code>cfg_dirs_list</code> is empty in the <code>get_cfg_dirs</code> function. Then, we still had to “check” it again in the <code>main</code> function by matching on <code>cfg_dirs.first()</code>. The <code>Vec</code> was known to be nonempty, do we have to check it again? Consequently, doesn’t this have an impact on performance, especially if we have to check it again and again and again?</li>
<li>The original post raised a good point about resilience to refactors. If for some reason the <code>is_empty</code> gets refactored out for some reason, and the programmer forgot to update <code>main</code>, then the <code>unreachable!</code> branch might actually get reached and explode your computer or whatever.</li>
</ol><p>If we instead had a special <code>NonEmptyVec&lt;T&gt;</code> newtype (well, not exactly special) where its existence guarantees that the Vec is never empty, we could do</p><div><figure><pre data-language="rust"><code><div><p><span>struct</span><span> </span><span>NonEmptyVec</span><span>&lt;</span><span>T</span><span>&gt;(</span><span>T</span><span>,</span><span> </span><span>Vec</span><span>&lt;</span><span>T</span><span>&gt;);</span></p></div><div></div><div><p><span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>NonEmptyVec</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>//</span><span> Notice that we don&#39;t need to return an `Option`</span></p></div><div><p><span>  </span><span>fn</span><span> </span><span>first</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>&amp;</span><span>T</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>fn</span><span> </span><span>get_cfg_dirs</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>NonEmptyVec</span><span>&lt;</span><span>PathBuf</span><span>&gt;,</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>Error</span><span>&gt;&gt;</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>cfg_dirs_string</span><span> </span><span>=</span><span> </span><span>std</span><span>::</span><span>env</span><span>::</span><span>var</span><span>(</span><span>&#34;CONFIG_DIRS&#34;</span><span>)</span><span>?</span><span>;</span></p></div><div></div><div><p><span>  </span><span>let</span><span> </span><span>cfg_dirs_list</span><span> </span><span>=</span><span> </span><span>cfg_dirs_string</span><span>.</span><span>split</span><span>(</span><span>&#39;</span><span>,</span><span>&#39;</span><span>)</span></p></div><div><p><span>    </span><span>.</span><span>map</span><span>(</span><span>PathBuf</span><span>::</span><span>from</span><span>)</span></p></div><div><p><span>    </span><span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>PathBuf</span><span>&gt;&gt;();</span></p></div><div></div><div><p><span>  </span><span>//</span><span> We parse the `Vec` into a more structured type</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>cfg_dirs_list</span><span> </span><span>=</span><span> </span><span>NonEmptyVec</span><span>::</span><span>try_from</span><span>(</span><span>cfg_dirs_list</span><span>)</span><span>?</span><span>;</span></p></div><div></div><div><p><span>  </span><span>Ok</span><span>(</span><span>cfg_dirs_list</span><span>)</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;(),</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>Error</span><span>&gt;&gt;</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>cfg_dirs</span><span> </span><span>=</span><span> </span><span>get_cfg_dirs</span><span>()</span><span>?</span><span>;</span></p></div><div><p><span>  </span><span>//</span><span> Notice that we don&#39;t have to check again if the `Vec`</span></p></div><div><p><span>  </span><span>//</span><span> was empty, since we guarantee that via the `NonEmptyVec` type</span></p></div><div><p><span>  </span><span>init_cache</span><span>(</span><span>cfg_dirs</span><span>.</span><span>first</span><span>());</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>In this context, we can call <code>NonZeroF32::new</code> and <code>NonEmptyVec::try_from</code> <em>parsing</em> functions, since they validate and convert the less semantic type to a type with more meaning imbued into it. That is, nonzeroness of a float and nonemptiness of a <code>Vec</code> is now encoded into a type. You can just see the word <code>NonZeroF32</code> and therefore understand that going forward it is always be an <code>f32</code> that is never zero.</p><p>Validation and checking functions on the other hand, well, just validate the value and leave the type as that. If I have a <code>is_nonzero(f32) -&gt; bool</code> function, then there’s not really much of a readable difference between an <code>f32</code> that has <code>is_nonzero</code> called on it versus and an <code>f32</code> that hasn’t.</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>is_nonzero</span><span>(</span><span>n</span><span>:</span><span> </span><span>f32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>bool</span><span>;</span></p></div><div><p><span>fn</span><span> </span><span>to_nonzero</span><span>(</span><span>n</span><span>:</span><span> </span><span>f32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>NonZeroF32</span><span>&gt;;</span></p></div></code></pre></figure></div><p>By taking advantage of the existence of a nominative type system, we can communicate that this <code>f32</code> is not zero by <em>parsing</em> it to a new type, as opposed to just <em>validating</em> it. If you only validate it, then you still can’t tell if <code>f32</code> was nonzero unless you dig through the code. However, if you parsed it, you can say it’s always be nonzero if you see <code>NonZeroF32</code> in your code.</p></section>
<section><h2 id="examples-in-the-wild">Examples in the wild<a aria-hidden="true" tabindex="-1" href="#examples-in-the-wild"> #</a></h2><p>Of course, the above examples are very much contrived, but is there an instance where creating newtypes is helpful? Yes. In fact, most people have used it. It’s called a <code>String</code>.</p><p>If we dig into the internals, <a href="https://doc.rust-lang.org/src/alloc/string.rs.html#360"><code>String</code></a> is just a newtype over the <code>Vec&lt;u8&gt;</code> type:</p><div><figure><pre data-language="rust"><code><div><p><span>#[</span><span>derive</span><span>(</span><span>PartialEq</span><span>,</span><span> </span><span>PartialOrd</span><span>,</span><span> </span><span>Eq</span><span>,</span><span> </span><span>Ord</span><span>)]</span></p></div><div><p><span>#[</span><span>stable</span><span>(</span><span>feature </span><span>=</span><span> </span><span>&#34;rust1&#34;</span><span>,</span><span> since </span><span>=</span><span> </span><span>&#34;1.0.0&#34;</span><span>)]</span></p></div><div><p><span>#[</span><span>lang </span><span>=</span><span> </span><span>&#34;String&#34;</span><span>]</span></p></div><div><p><span>pub</span><span> </span><span>struct</span><span> </span><span>String</span><span> </span><span>{</span></p></div><div><p><span>    </span><span>vec</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;,</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>It’s parsing function is <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8"><code>String::from_utf8</code></a>, which contains the validation code for checking if the byte vector is valid UTF-8.</p><div><figure><pre data-language="rust"><code><div><p><span>    </span><span>#[</span><span>inline</span><span>]</span></p></div><div><p><span>    </span><span>#[</span><span>stable</span><span>(</span><span>feature </span><span>=</span><span> </span><span>&#34;rust1&#34;</span><span>,</span><span> since </span><span>=</span><span> </span><span>&#34;1.0.0&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>#[</span><span>rustc_diagnostic_item </span><span>=</span><span> </span><span>&#34;string_from_utf8&#34;</span><span>]</span></p></div><div><p><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>from_utf8</span><span>(</span><span>vec</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>String</span><span>,</span><span> </span><span>FromUtf8Error</span><span>&gt;</span><span> </span><span>{</span></p></div><div><p><span>        </span><span>match</span><span> </span><span>str</span><span>::</span><span>from_utf8</span><span>(</span><span>&amp;</span><span>vec</span><span>)</span><span> </span><span>{</span></p></div><div><p><span>            </span><span>Ok</span><span>(</span><span>..</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>Ok</span><span>(</span><span>String</span><span> </span><span>{</span><span> </span><span>vec</span><span> </span><span>}),</span></p></div><div><p><span>            </span><span>Err</span><span>(</span><span>e</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>Err</span><span>(</span><span>FromUtf8Error</span><span> </span><span>{</span><span> </span><span>bytes</span><span>:</span><span> </span><span>vec</span><span>,</span><span> </span><span>error</span><span>:</span><span> </span><span>e</span><span> </span><span>}),</span></p></div><div><p><span>        </span><span>}</span></p></div><div><p><span>    </span><span>}</span></p></div></code></pre></figure></div><p>So instead of passing around a <code>Vec&lt;u8&gt;</code> around and validating all over the place, just parse into a <code>String</code> and you can be assured with having a type-safe <code>String</code> with all the convenience functions you can get.</p><p>Another example is <code>serde_json</code>. In Python, <code>json.loads</code> simply give you a dictionary. This is fine, especially if the data is sufficiently arbitrary, but if you have a schema and a type system, it’s better to let the type system do the work of parsing <code>json</code>.</p><p>In our terminology, validation looks like this:</p><div><figure><pre data-language="rust"><code><div><p><span>use</span><span> </span><span>serde_json</span><span>::</span><span>{</span><span>from_str</span><span>,</span><span> </span><span>Value</span><span>};</span></p></div><div></div><div><p><span>const</span><span> </span><span>SAMPLE_JSON:</span><span> </span><span>&amp;</span><span>str</span><span> </span><span>=</span><span> </span><span>r#&#34;{ &#34;foo&#34;: 1, &#34;bar&#34;: [1, 2, 3] }&#34;#</span><span>;</span></p></div><div></div><div><p><span>let</span><span> </span><span>json</span><span> </span><span>=</span><span> </span><span>from_str</span><span>::</span><span>&lt;</span><span>Value</span><span>&gt;(</span><span>SAMPLE_JSON</span><span>)</span></p></div><div><p><span>  </span><span>.</span><span>unwrap</span><span>();</span></p></div><div></div><div><p><span>let</span><span> </span><span>first_elem</span><span> </span><span>=</span><span> </span><span>json</span><span>.</span><span>get</span><span>(</span><span>&#34;bar&#34;</span><span>)</span></p></div><div><p><span>  </span><span>.</span><span>and_then</span><span>(</span><span>|</span><span>bar</span><span>|</span><span> </span><span>bar</span><span>.</span><span>get</span><span>(</span><span>0</span><span>))</span></p></div><div><p><span>  </span><span>.</span><span>unwrap</span><span>();</span></p></div><div></div><div><p><span>//</span><span> do stuff with `first_elem`</span></p></div></code></pre></figure></div><p>That’s two <code>unwrap</code>s! One for checking if the string is valid json and the other is for checking if the <code>bar</code> field exists. Now consider this example where we use the parsing mechanic instead via types and the <code>Deserialize</code> derive macro.</p><div><figure><pre data-language="rust"><code><div><p><span>struct</span><span> </span><span>Sample</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>foo</span><span>:</span><span> </span><span>i32</span><span>,</span></p></div><div><p><span>  </span><span>bar</span><span>:</span><span> </span><span>[</span><span>i32</span><span>;</span><span> </span><span>3</span><span>]</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>impl</span><span> </span><span>Sample</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>fn</span><span> </span><span>first_elem</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>i32</span><span> </span><span>{</span></p></div><div><p><span>    </span><span>self</span><span>.</span><span>bar</span><span>[</span><span>0</span><span>]</span><span> </span><span>//</span><span> does not panic, by definition</span></p></div><div><p><span>  </span><span>}</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>let</span><span> </span><span>json</span><span> </span><span>=</span><span> </span><span>from_str</span><span>::</span><span>&lt;</span><span>Sample</span><span>&gt;(</span><span>SAMPLE_JSON</span><span>)</span><span>.</span><span>unwrap</span><span>();</span></p></div><div><p><span>let</span><span> </span><span>first_elem</span><span> </span><span>=</span><span> </span><span>json</span><span>.</span><span>first_elem</span><span>();</span></p></div><div></div><div><p><span>//</span><span> do stuff with `first_elem`</span></p></div></code></pre></figure></div><p>Since we deserialized the <code>json</code> file into an actual type, we can safely make these guarantees:</p><ol>
<li>The <code>foo</code> and <code>bar</code> always exist in the <code>json</code> string we parse.</li>
<li><code>foo</code> always has an integer value.</li>
<li><code>bar</code> is always an array of three integers.</li>
<li><code>first_elem</code> will never panic since all elements of an array is always initialized, and indexing into the first the element of a nonzero-length array will always be successful.</li>
</ol><p>The only point of failure here is pushed upfront, where the <code>from_str</code> happens. After that point, there’s not really much error handling to be done here, since the validation is now represented at the type level instead of at the function level.</p></section>
<section><h2 id="maxims-of-type-driven-design">Maxims of Type Driven Design<a aria-hidden="true" tabindex="-1" href="#maxims-of-type-driven-design"> #</a></h2><p>With that said, what lessons can we learn from here? Turns out, most functional language programmers already have learned several lessons, and Rust is not much different in terms of applying such FP concepts to the language.</p><p>First lesson we can learn is that <strong>we should make illegal states unrepresentable</strong>.</p><p>What do we mean by that?</p><p>To refer back to the <code>NonZeroF32</code> and <code>NonEmptyVec</code> examples, we say the state of being zero is illegal for <code>NonZeroF32</code> and the state of being empty is illegal for <code>NonEmptyVec</code>. And as illegal states, they cannot be represented in such types. That’s why the only constructors available for these types are fallible; the value either parsed successfully, or it failed and does not return the new types.</p><p>If we only do validation, like checking if <code>f32</code> is nonzero for example, then the illegal state can still be represented. There’s a small possible that the value is zero, especially after some refactors when the conditional checks are accidentally or intentionally removed in some places.</p><section>   <p>This reminds me of how other languages use integers as sentinel values. Given this code snippet from <a href="https://en.wikipedia.org/wiki/Sentinel_value">Wikipedia</a>:</p><div><figure><pre data-language="c"><code><div><p><span>int</span><span> </span><span>find</span><span>(</span><span>int</span><span> </span><span>arr</span><span>[]</span><span>,</span><span> </span><span>size_t</span><span> </span><span>len</span><span>,</span><span> </span><span>int</span><span> </span><span>val</span><span>)</span><span> </span><span>{</span></p></div><div><p><span>    </span><span>for</span><span> </span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> len</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span></p></div><div><p><span>        </span><span>if</span><span> </span><span>(</span><span>arr</span><span>[</span><span>i</span><span>]</span><span> </span><span>==</span><span> val</span><span>)</span><span> </span><span>{</span></p></div><div><p><span>            </span><span>return</span><span> i</span><span>;</span></p></div><div><p><span>        </span><span>}</span></p></div><div><p><span>    </span><span>}</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>-</span><span>1</span><span>;</span><span> </span><span>//</span><span> not found</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>The error is returned as <code>-1</code>, since indexing arrays is only valid for nonnegative integers. Seems weird as (1) the numbers -2 and below <em>can</em> exist, but not actually valid, and (2) treating certain values as special seems too error-prone, as in the future it could be that negative number can become semantically valid.</p> </section><p>Second lesson we can learn is that <strong>proving invariants should be done as early as possible</strong>.</p><p>There’s this concept called <a href="http://langsec.org/papers/langsec-cwes-secdev2016.pdf"><em>shotgun parsing</em></a> where the linked paper describes it as follows:</p><blockquote>
<p>Shotgun Parsing: Shotgun parsing is a programming antipattern whereby parsing and input-validating code is mixed with and spread across processing code—throwing a cloud of checks at the input, and hoping, without any systematic justification, that one or another would catch all the “bad” cases.</p>
</blockquote><p>Essentially, it describes the problem of usage of data without previous validation of its entirety of data. You could act on a part of the data that is validated beforehand, but discover that another part of the data is invalid.</p><p>The paper mentions <a href="https://nvd.nist.gov/vuln/detail/CVE-2016-0752">CVE-2016-0752</a>, which is a bug that allows attackers to read arbitrary files because you can use <code>..</code> in the input. The paper argues that treating validation as emergent and not deliberate can lead to security bugs like these.</p><p>If we treat validation as deliberate, then it should happen as early as possible and as comprehensive as possible. By parsing first, every invariant can be proven first before executing on said data.</p><section>   <p>I remember this <a href="https://youtu.be/ViPNHMSUcog">video</a> about lambda calculus. It concludes that types can be represented as propositions in logic, and terms as proofs. I recommend watching the video, as it is eye-opening to me and maybe it can help you realize some things too.</p><p>Fundamentally, if your program typechecks properly, then you can say that the proof is correct. Thank you Curry-Howard Correspondence. There are proof assistant programming languages that can help with this like <a href="https://lean-lang.org/">Lean</a> and <a href="https://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a>, but you can emulate this in Rust anyway. That’s how some weird libraries like the <a href="https://crates.io/crates/typenum">typenum</a> crate work.</p><div><figure><pre data-language="rust"><code><div><p><span>use</span><span> </span><span>std</span><span>::</span><span>ops</span><span>::</span><span>Add</span><span>;</span></p></div><div><p><span>use</span><span> </span><span>typenum</span><span>::*</span><span>;</span><span> </span><span>//</span><span> 1.19.0</span></p></div><div></div><div><p><span>type</span><span> </span><span>Lhs</span><span> </span><span>=</span><span> </span><span>&lt;</span><span>P3</span><span> </span><span>as</span><span> </span><span>Add</span><span>&lt;</span><span>P4</span><span>&gt;&gt;</span><span>::</span><span>Output</span><span>;</span></p></div><div><p><span>type</span><span> </span><span>Rhs</span><span> </span><span>=</span><span> </span><span>P8</span><span>;</span></p></div><div></div><div><p><span>type</span><span> </span><span>Result</span><span> </span><span>=</span><span> </span><span>&lt;</span><span>Lhs</span><span> </span><span>as</span><span> </span><span>Same</span><span>&lt;</span><span>Rhs</span><span>&gt;&gt;</span><span>::</span><span>Output</span><span>;</span></p></div><div></div><div><p><span>pub</span><span> </span><span>fn</span><span> </span><span>is_proof_correct</span><span>()</span></p></div><div><p><span>where</span></p></div><div><p><span>    </span><span>Result</span><span>:</span></p></div><div><p><span>{}</span></p></div></code></pre></figure></div><p>This is a simple <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=ed2a899a9bd9806f655df5623581ad97">program</a> in Rust where I check if <code>3 + 4</code> is equal to <code>8</code>. Obviously this is not correct, and so it will appropriately give you a compile error.</p><div><figure><pre data-language="rust"><code><div><p><span>   </span><span>Compiling</span><span> </span><span>playground</span><span> </span><span>v0</span><span>.</span><span>0</span><span>.</span><span>1</span><span> </span><span>(</span><span>/</span><span>playground</span><span>)</span></p></div><div><p><span>error</span><span>[</span><span>E0277</span><span>]</span><span>:</span><span> </span><span>the</span><span> </span><span>trait</span><span> </span><span>bound</span><span> `</span><span>PInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UTerm</span><span>,</span><span> </span><span>B1</span><span>&gt;,</span><span> </span><span>B1</span><span>&gt;,</span><span> </span><span>B1</span><span>&gt;&gt;</span><span>:</span><span> </span><span>Same</span><span>&lt;</span><span>PInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>...</span><span>,</span><span> </span><span>...</span><span>&gt;&gt;&gt;</span><span>` </span><span>is</span><span> </span><span>not</span><span> </span><span>satisfied</span></p></div><div><p><span>  </span><span>--&gt;</span><span> </span><span>src</span><span>/</span><span>lib</span><span>.</span><span>rs</span><span>:</span><span>11</span><span>:</span><span>5</span></p></div><div><p><span>   </span><span>|</span></p></div><div><p><span>11</span><span> </span><span>|</span><span>     </span><span>Result</span><span>:</span></p></div><div><p><span>   </span><span>|</span><span>     </span><span>^^^^^^</span><span> </span><span>unsatisfied</span><span> </span><span>trait</span><span> </span><span>bound</span></p></div><div><p><span>   </span><span>|</span></p></div><div><p><span>   </span><span>=</span><span> </span><span>help</span><span>:</span><span> </span><span>the</span><span> </span><span>trait</span><span> `</span><span>typenum</span><span>::</span><span>Same</span><span>&lt;</span><span>PInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UTerm</span><span>,</span><span> </span><span>B1</span><span>&gt;,</span><span> </span><span>B0</span><span>&gt;,</span><span> </span><span>B0</span><span>&gt;,</span><span> </span><span>B0</span><span>&gt;&gt;&gt;</span><span>` </span><span>is</span><span> </span><span>not</span><span> </span><span>implemented</span><span> </span><span>for</span><span> `</span><span>PInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UInt</span><span>&lt;</span><span>UTerm</span><span>,</span><span> </span><span>B1</span><span>&gt;,</span><span> </span><span>B1</span><span>&gt;,</span><span> </span><span>B1</span><span>&gt;&gt;</span><span>`</span></p></div><div><p><span>   </span><span>=</span><span> </span><span>note</span><span>:</span><span> </span><span>the</span><span> </span><span>full</span><span> </span><span>name</span><span> </span><span>for</span><span> </span><span>the</span><span> </span><span>type</span><span> </span><span>has</span><span> </span><span>been</span><span> </span><span>written</span><span> </span><span>to</span><span> </span><span>&#39;</span><span>/playground/target/debug/deps/playground-e4f34f6f1769e3b6.long-type-6323804316620900.txt</span><span>&#39;</span></p></div><div><p><span>   </span><span>=</span><span> </span><span>note</span><span>:</span><span> </span><span>consider</span><span> </span><span>using</span><span> `</span><span>--</span><span>verbose</span><span>` </span><span>to</span><span> </span><span>print</span><span> </span><span>the</span><span> </span><span>full</span><span> </span><span>type</span><span> </span><span>name</span><span> </span><span>to</span><span> </span><span>the</span><span> </span><span>console</span></p></div><div></div><div><p><span>For</span><span> </span><span>more</span><span> </span><span>information</span><span> </span><span>about</span><span> </span><span>this</span><span> </span><span>error</span><span>,</span><span> </span><span>try</span><span> `</span><span>rustc</span><span> </span><span>--</span><span>explain</span><span> </span><span>E0277</span><span>`</span><span>.</span></p></div><div><p><span>error</span><span>:</span><span> </span><span>could</span><span> </span><span>not</span><span> </span><span>compile</span><span> `</span><span>playground</span><span>` </span><span>(</span><span>lib</span><span>)</span><span> </span><span>due</span><span> </span><span>to</span><span> </span><span>1</span><span> </span><span>previous</span><span> </span><span>error</span></p></div></code></pre></figure></div><p>So sad that the error message is dogshit. Such is life.</p> </section></section>
<section><h2 id="what-can-we-do">What can we do?<a aria-hidden="true" tabindex="-1" href="#what-can-we-do"> #</a></h2><p>There are some recommendations I usually say to people on the RPLCS discord server, adapted from the original blog post.</p><p>First, just because a function accepts a type doesn’t mean you have to use it in your structs, nor have to perpetually represent it as that type. For example, let’s say we have a third party library function that looks like this.</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>set_lightbulb_state</span><span>(</span><span>is_on</span><span>:</span><span> </span><span>bool</span><span>)</span><span> </span><span>{}</span></p></div></code></pre></figure></div><p>You <em>don’t</em> have to store <code>bool</code> in your <code>App</code>/<code>Context</code> struct like <code>App { lightbulb_state: bool }</code>. That’s confusing. I’d rather have you define a separate enum with more semantics imbued into it, like:</p><div><figure><pre data-language="rust"><code><div><p><span>enum</span><span> </span><span>LightBulbState</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>Off</span><span>,</span></p></div><div><p><span>  </span><span>On</span><span>,</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>impl</span><span> </span><span>From</span><span>&lt;</span><span>LightBulbState</span><span>&gt;</span><span> </span><span>for</span><span> </span><span>bool</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span></p></div><div></div><div><p><span>struct</span><span> </span><span>App</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>lightbulb_state</span><span>:</span><span> </span><span>LightBulbState</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>//</span><span> ...</span></p></div><div></div><div><p><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span></p></div><div><p><span>  </span><span>let</span><span> </span><span>app</span><span> </span><span>=</span><span> </span><span>App</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span></p></div><div><p><span>  </span><span>set_lightbulb_state</span><span>(</span><span>app</span><span>.</span><span>lightbulb_state</span><span>.</span><span>into</span><span>());</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>Yeah, people can say it gets more verbose, but I rather care more about correctness instead. Sorry.</p><p>Second, I sometimes get suspicious about these kind of APIs:</p><div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>do_something_fallible</span><span>(</span><span>data</span><span>:</span><span> </span><span>&amp;</span><span>Thing</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;(),</span><span> </span><span>MyError</span><span>&gt;</span><span> </span><span>{}</span></p></div><div></div><div><p><span>//</span><span> or worse,</span></p></div><div></div><div><p><span>fn</span><span> </span><span>verify</span><span>(</span><span>data</span><span>:</span><span> </span><span>&amp;</span><span>Thing</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>bool</span><span> </span><span>{}</span></p></div></code></pre></figure></div><p>If I see the function body does not do anything side-effectful, then it’s probable that parsing can help here turning <code>Thing</code> into a more structured datatype. And even for side-effectful stuff, there are some types that better represent certain situations, like infinite loop function representing their return types as <code>Result&lt;!, MyError&gt;</code> or <code>Result&lt;Infallible, MyError&gt;</code>.</p></section>
<section><h2 id="conclusion">Conclusion<a aria-hidden="true" tabindex="-1" href="#conclusion"> #</a></h2><p>I love creating more types. Five million types for everyone please.</p><p>I think it’s interesting that there’s a lot of instances where types drive the design of Rust programs. Like how <code>Vec</code> has four layers of newtypes plus an additional field. <code>sqlx</code> generate anonymous structs in their <code>query!</code> macros. <code>bon</code> is a macro crate that converts functions into compile-time builders via types.</p><p>Of course, not everything is solvable via types. But personally I think pushing your verification code to types can help your code become clearer and more robust. Let the type system handle the validation for you. It exists, so might as well use it to its fullest extent.</p><p>I’d like to thank Alexis King for this <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">article</a> where I first encountered this idea. I’d love to follow up on this topic with an extension on this <a href="https://lexi-lambda.github.io/blog/2020/11/01/names-are-not-type-safety/">sequel</a>, and maybe recontextualizing in Rust via the <code>unsafe</code> keyword would be helpful.</p><p>Of course, newtyping is not the answer to all problems. Due to lack of ergonomic features to allow newtyping—like <a href="https://crates.io/crates/delegate">delegation</a>—many people are somewhat averse to using the pattern. Nevertheless, if someone made a good enough RFC I’d be happy to see it happen.</p><p>Using the type system as a compile-time checker because I want the compiler to help me write my programs is very nice. You should take advantage of the type system too, not many languages have it as good as Rust :)</p></section> <hr/>  <hr/> <h3>Liked this blog post and want some more? Consider donating to support the author!</h3>  <hr/>  </article>  </div></div>
  </body>
</html>
