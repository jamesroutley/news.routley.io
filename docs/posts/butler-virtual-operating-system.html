<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tristancacqueray.github.io/blog/introducing-butler">Original</a>
    <h1>Butler Virtual Operating System</h1>
    
    <div id="readability-page-1" class="page"><article>
  <!-- What goes in this file will appear on top of note body-->
  
    <p>
      This post introduces <a href="https://github.com/ButlerOS/haskell-butler" data-linkicon="external" target="_blank" rel="noopener">haskell-butler</a>, a virtual operating system that runs multi-players applications on the web. In two parts, I present:
    </p>
  
    <ul>
      
        <li>
          The project’s overview, and,
        </li>
      
        <li>
          A motivating use-case; a remote desktop that looks like this:
        </li>
      
    </ul>
  <img src="https://tristancacqueray.github.io/blog/static/butler-demo.png" alt="butler-demo"/><h2 id="hobby-project">Hobby Project</h2>
    <p>
      Before I begin, let me set the expectations. Butler is a hobby project inspired by the <a href="https://serenityos.org" data-linkicon="external" target="_blank" rel="noopener">SerenityOS</a> project. I am working on it on my free time as a challenge and learning experience. Moreover I am considering alternative runtimes and protocols. Therefore the implementation is subject to change.
    </p>
  
    <p>
      That being said, the project reached a point where it is now enjoyable, and I’m happy to share its current state with you.
    </p>
  <h2 id="modular-operating-system">Modular Operating System</h2>
    <p>
      Butler’s goal is to implement a virtual operating system with a strong focus on concurrency. Butler is not a computer hardware operating system. Instead, Butler is an application environment that runs on top of an existing system.
    </p>
  
    <p>
      Thus I created the following modules:
    </p>
  <p><img src="https://tristancacqueray.github.io/blog/static/butler-intro.svg" alt="butler-intro"/></p>
    <p>
      Starting with the <code>Core</code> layer, I designed low level interfaces for the host system:
    </p>
  
    <ul>
      
        <li>
          <code>Process</code> for thread management, powered by the <a href="https://hackage.haskell.org/package/ki" data-linkicon="external" target="_blank" rel="noopener">ki</a> library.
        </li>
      
        <li>
          <code>Pipe</code> for inter-process communication using <a href="https://hackage.haskell.org/package/stm" data-linkicon="external" target="_blank" rel="noopener">stm</a>.
        </li>
      
        <li>
          <code>File</code> for directory and file objects.
        </li>
      
        <li>
          <code>Network</code> to serve Web Application Interface <a href="https://hackage.haskell.org/package/wai" data-linkicon="external" target="_blank" rel="noopener">wai</a>.
        </li>
      
    </ul>
  
    <p>
      Then in the <code>Main</code> layer, I implemented higher level interfaces on top of the <code>Core</code> primitive:
    </p>
  
    <ul>
      
        <li>
          <code>Scheduler</code> for the process hierarchy and supervision.
        </li>
      
        <li>
          <code>Display</code> for graphical user interfaces.
        </li>
      
        <li>
          <code>Session</code> for users.
        </li>
      
        <li>
          <code>Frame</code> for the a data exchange format.
        </li>
      
    </ul>
  
    <p>
      Finally, the <code>App</code> layer provides the application environment:
    </p>
  
    <ul>
      
        <li>
          <code>Window</code> for app instance.
        </li>
      
        <li>
          <code>Cursor</code> for user pointer.
        </li>
      
        <li>
          <code>Sound</code> to produce and receive audio.
        </li>
      
        <li>
          <code>Agent</code> to forward local agent.
        </li>
      
    </ul>
  
    <p>
      I find it valuable to model these APIs after regular operating system constructs. They are available through a single top level <a href="https://butleros.github.io/haddock/Butler.html" data-linkicon="external" target="_blank" rel="noopener">Butler</a> module. The next section introduces the application environment.
    </p>
  <h2 id="application-actor">Application Actor</h2>
    <p>
      Butler applications are implemented as standalone processes that operate a <a href="https://butleros.github.io/haddock/Butler.html#t:AppEvent" data-linkicon="external" target="_blank" rel="noopener">AppEvent</a> pipe. Checkout the <a href="https://butleros.github.io/haddock/Butler.html#t:App" data-linkicon="external" target="_blank" rel="noopener">App</a> definition. Applications start with a <a href="https://butleros.github.io/haddock/Butler.html#t:AppContext" data-linkicon="external" target="_blank" rel="noopener">AppContext</a> provided by the display.
    </p>
  
    <p>
      In order to run multiple application concurrently, Butler features a data exchange format to share a single socket per client. Applications output:
    </p>
  
    <ul>
      
        <li>
          HTMX payload, by suffixing the application id. For example the UI are mounted on: <code>&lt;div id=&#34;w-$pid&#34;&gt;</code>.
        </li>
      
        <li>
          Binary payload, by encoding the application id at the beginning of the buffer: <code>| $pid | server-data |</code>
        </li>
      
    </ul>
  
    <p>
      Applications receive:
    </p>
  
    <ul>
      
        <li>
          HTMX trigger, by suffixing the trigger name with the application id: <code>{&#34;HEADERS&#34;: {&#34;HX-Trigger&#34;: &#34;$trigger-$pid&#34;}}</code>
        </li>
      
        <li>
          Binary payload, using the same application id encoding: <code>| $pid | client-data |</code>
        </li>
      
    </ul>
  
    <p>
      The key design is that clients are dumb terminals and the state is controlled server side. A good example is the text editor app named <a href="https://github.com/ButlerOS/haskell-butler/blob/main/src/Butler/App/Noter.hs" data-linkicon="external" target="_blank" rel="noopener">Noter</a>. This app leverages the whole application environment to implement an etherpad like text editor.
    </p>
  <h2 id="haskell-runtime-system">Haskell RunTime System</h2>
    <p>
      In this section I explain the choice of using <a href="https://haskell.org" data-linkicon="external" target="_blank" rel="noopener">Haskell</a>. Beyond the language’s common features, here are two reasons for using Haskell:
    </p>
  
    <ul>
      
        <li>
          The language lets you break down any problem into smaller chunks, using let or where bindings. I find this syntax and way of thinking very helpful for simplifying complex software.
        </li>
      
        <li>
          The REPL evaluates modification almost instantaneously. I run development code through <a href="https://github.com/ndmitchell/ghcid" data-linkicon="external" target="_blank" rel="noopener">ghcid</a>, and thanks to a simple client’s reconnect handler, the services are hot reloaded in milliseconds when the source changes.
        </li>
      
    </ul>
  
    <p>
      However, even though the Haskell ecosystem is quickly improving, it is not a mainstream language, and it can be rough around the edges. Here are a couple of alternative languages that I am also considering:
    </p>
  
    <ul>
      
        <li>
          <a href="https://www.rust-lang.org/" data-linkicon="external" target="_blank" rel="noopener">Rust</a>, because it is very similar to Haskell. Though it can be more complicated: for example, some expressions don’t seem to be decomposable into sub expressions without triggering the borrow checker. And the lack of REPL to evaluate the code interactively is frustrating.
        </li>
      
        <li>
          <a href="https://gleam.run/" data-linkicon="external" target="_blank" rel="noopener">Gleam</a>, because it leverages the BEAM virtual machine, which is a great fit for application actors.
        </li>
      
    </ul>
  
    <p>
      That being said, Haskell works great for Butler. So far I have only used its most basic features, and the project source is only 5k lines of code according to <a href="https://github.com/vmchale/polyglot" data-linkicon="external" target="_blank" rel="noopener">polyglot</a>.
    </p>
  <h2 id="html5-graphical-user-interface">HTML5 Graphical User Interface</h2>
    <p>
      In this section I explain the choice of using HTML5 for the GUI. I choose HTML5 because it is an ubiquitous standard and the <a href="https://developer.mozilla.org/en-US/docs/Web/API" data-linkicon="external" target="_blank" rel="noopener">Web API</a> offers a fully featured application environment. Thanks to the hypermedia paradigm enabled by <a href="https://htmx.org/" data-linkicon="external" target="_blank" rel="noopener">htmx</a>, it is a great fit for Butler.
    </p>
  
    <p>
      Though it would be interesting to investigate <a href="https://github.com/patrick-steele-idem/morphdom" data-linkicon="external" target="_blank" rel="noopener">morphdom</a> and rich client alternatives, such as <a href="https://www.w3.org/TR/webgpu/" data-linkicon="external" target="_blank" rel="noopener">Web GPU</a> or <a href="https://flutter.dev/" data-linkicon="external" target="_blank" rel="noopener">Flutter</a>.
    </p>
  <h2 id="application-demos">Application Demos</h2>
    <p>
      Here is a list of demos I am using to validate the core implementation:
    </p>
  
    <ul>
      
        <li>
          <a href="https://github.com/ButlerOS/haskell-butler/blob/main/src/Butler/App/Noter.hs" data-linkicon="external" target="_blank" rel="noopener">Butler.App.Noter</a>: a text editor.
        </li>
      
        <li>
          <a href="https://github.com/ButlerOS/haskell-butler/blob/main/src/Butler/App/FileManager.hs" data-linkicon="external" target="_blank" rel="noopener">Butler.App.FileManager</a>: a file manager.
        </li>
      
        <li>
          <a href="https://github.com/ButlerOS/haskell-butler/blob/main/src/Butler/App/Mumbler.hs" data-linkicon="external" target="_blank" rel="noopener">Butler.App.Mumbler</a>: a voice chat.
        </li>
      
        <li>
          <a href="https://github.com/ButlerOS/haskell-butler/blob/main/src/Butler/App/Tabletop.hs" data-linkicon="external" target="_blank" rel="noopener">Butler.App.Tabletop</a>: a free form tabletop simulator.
        </li>
      
        <li>
          <a href="https://github.com/ButlerOS/haskell-butler/blob/main/src/Butler/App/Terminal.hs" data-linkicon="external" target="_blank" rel="noopener">Butler.App.Terminal</a>: a legacy terminal.
        </li>
      
        <li>
          <a href="https://github.com/ButlerOS/haskell-butler/blob/main/src/Butler/App/NoVnc.hs" data-linkicon="external" target="_blank" rel="noopener">Butler.App.NoVnc</a>: a VNC client.
        </li>
      
        <li>
          And a few other system applications you can find in the <a href="https://github.com/ButlerOS/haskell-butler/tree/main/src/Butler/App" data-linkicon="external" target="_blank" rel="noopener">Butler.App</a> directory.
        </li>
      
    </ul>
  
    <p>
      I am mostly focusing on the desktop use-case, but I also helped my colleague fboucher use Butler to create a game named <a href="https://github.com/web-apps-lab/HazardHunter" data-linkicon="external" target="_blank" rel="noopener">HazardHunter</a>.
    </p>
  <h2 id="road-map">Road-map</h2>
    <p>
      A terminal and VNC client are already provided to access non Butler applications, and perhaps it is possible to re-implemented these legacy system as Butler native applications. For example, I am looking forward adding:
    </p>
  
    <ul>
      
        <li>
          Programming REPL.
        </li>
      
        <li>
          Media player named “Ampler”.
        </li>
      
        <li>
          IRC and Matrix client.
        </li>
      
        <li>
          Agenda and calendar.
        </li>
      
        <li>
          More video games.
        </li>
      
    </ul>
  
    <p>
      Moreover, I would like to develop the Butler APIs to include:
    </p>
  
    <ul>
      
        <li>
          Application testing framework, to simulate actor’s inputs and validate the outputs.
        </li>
      
        <li>
          User’s mailbox and notification system.
        </li>
      
        <li>
          Application debugging strace.
        </li>
      
        <li>
          External identity providers.
        </li>
      
        <li>
          Authorization system.
        </li>
      
    </ul>
  
    <p>
      Finally, it would be interesting to investigate if and how an app registry could be implemented. For example as a list of packages that could be dynamically loaded/unloaded into a running instance.
    </p>
  <h2 id="conclusion">Conclusion</h2>
    <p>
      The actor framework looks like a great solution for web applications, and I am quite happy with the Butler’s implementation. Moreover, I am excited about the community discussion for moving <a href="https://discourse.haskell.org/t/towards-an-actor-framework-for-haskell/5929" data-linkicon="external" target="_blank" rel="noopener">Towards an actor framework for Haskell</a>. My implementation is rather limited, and I would be happy to use a common library similar to the <a href="https://github.com/erlang/otp" data-linkicon="external" target="_blank" rel="noopener">erlang/otp</a>.
    </p>
  
    <p>
      Butler may sound like a crazy project, but I believe it is important to pursue fun goals that appear impossible. I would like to quote the author of <a href="https://serenityos.org" data-linkicon="external" target="_blank" rel="noopener">SerenityOS</a> <a href="https://twitter.com/awesomekling/status/1544026282161307648" data-linkicon="external" target="_blank" rel="noopener">Andreas Kling</a>: “Never underestimate the power of a bunch of nerds building something just for fun.”
    </p>
  
    <p>
      Finally I would like to thank <a href="https://notes.elmiko.dev/" data-linkicon="external" target="_blank" rel="noopener">elmiko</a> for his early feedback and encouragement.
    </p>
  
    <p>
      Cheers!
    </p>
  

  <!-- What goes in this file will appear below the note body-->
</article></div>
  </body>
</html>
