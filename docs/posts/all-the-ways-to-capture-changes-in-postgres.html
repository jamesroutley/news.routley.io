<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sequin.io/all-the-ways-to-capture-changes-in-postgres/">Original</a>
    <h1>All the ways to capture changes in Postgres</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
      <!--kg-card-begin: markdown--><p>Working with data at rest is where Postgres shines. But what about when you need data in motion? What about when you need to trigger a workflow based on changes to a table? Or you need to stream the data in Postgres to another data store, system, or service in real-time?</p>
<p>Fortunately, Postgres comes with a lot of options to make this happen. In this post, I’ll lay them all out. I’ll also give you an idea of which are easy to do, which are more robust, and how to make the right choice for you.</p>
<h2 id="listennotify">Listen/Notify</h2>
<p>Perhaps the simplest approach is to use Postgres&#39; interprocess communication feature, Listen/Notify. Listen/Notify is an implementation of the publish-subscribe pattern.</p>
<p>With Listen/Notify, a Postgres session (or connection) can &#34;listen&#34; to a particular channel for notifications. Activity in the database or other sessions can &#34;notify&#34; that channel. Whenever a notification is sent to a channel, all sessions listening to that channel receive the notification instantly.</p>
<p>You can see Listen/Notify for yourself by opening two <code>psql</code> sessions.</p>
<p>In session 1, you can setup your listener:</p>
<pre><code>&gt; listen my_channel;
LISTEN
</code></pre>
<p>And in session 2, you can publish to that channel with a message:</p>
<pre><code>&gt; notify my_channel, &#39;hey there!&#39;;
NOTIFY
&gt; notify my_channel, &#39;is this thing on?&#39;;
NOTIFY
</code></pre>
<p>While the listener process received the message right away, <code>psql</code> won&#39;t print the message automatically. To get it to print out the messages it&#39;s received so far, you just need to run any query. For example, you can just send an empty query like this:</p>
<pre><code>&gt; listen my_channel;
LISTEN
&gt; ;
Asynchronous notification &#34;my_channel&#34; with payload &#34;hey there!&#34; received from server process with PID 80019.
Asynchronous notification &#34;my_channel&#34; with payload &#34;is this thing on?&#34; received from server process with PID 80019.
</code></pre>
<p>(Naturally, this isn&#39;t how the Postgres client library in your preferred programming language will work. Libraries will deliver messages to your subscriber immediately without requiring a query.)</p>
<p>To use Listen/Notify to capture changes, you can set up a trigger. For example, here&#39;s an <code>after</code> trigger that sends along the payload of the record that changed as JSON via Notify:</p>
<pre><code>create or replace function notify_trigger() returns trigger as $$
declare
  payload json;
begin
  payload := json_build_object(&#39;table&#39;, TG_TABLE_NAME, &#39;id&#39;, NEW.id, &#39;action&#39;, TG_OP);
  perform pg_notify(&#39;table_changes&#39;, payload::text);
  return new;
end;
$$ language plpgsql;

create trigger my_trigger
after insert or update or delete on my_table
for each row execute function notify_trigger();
</code></pre>
<h3 id="downsides">Downsides</h3>
<p>Listen/Notify is simple and powerful, but has some notable downsides.</p>
<p>First, as a pub-sub mechanism, it has &#34;at most once&#34; delivery semantics. Notifications are transient; a listener needs to be listening to a channel when notifications are published. When a listener subscribes to a channel, it will only receive notifications from that moment forward. This also means that if there are network issues that cause a listening session to disconnect even briefly, it won&#39;t receive the notification.</p>
<p>Second, the payload size limit is 8000 bytes. If the message exceeds this size, the <code>notify</code> command will fail. </p>
<p>As such, Listen/Notify is solid for basic change detection needs, but you&#39;ll probably find it does not serve more sophisticated needs well. However, it can complement other strategies (like &#34;poll the table&#34;) nicely.</p>
<h2 id="poll-the-table">Poll the table</h2>
<p>The simplest <em>robust</em> way to capture changes is to poll the table directly. Here, you need each table to have an <code>updated_at</code> column or similar that updates whenever the row updates. (You can use a trigger for this.) A combination of <code>updated_at</code> <a href="https://blog.sequin.io/whats-changed-in-your-api/">and <code>id</code></a> serve as your cursor. In this setup, your application logic that polls the table handles storing and maintaining the cursor.</p>
<p>In addition to polling the table, you can use a Notify subscription to inform your application that a record has been inserted or modified. Postgres&#39; notifications are ephemeral, so this should only serve as an optimization on top of polling.</p>
<h3 id="downsides">Downsides</h3>
<p>This approach has two downsides.</p>
<p>The first is that you can&#39;t detect when a row is deleted. There&#39;s no way to &#34;see&#34; the missing row in the table.</p>
<p>One remediation is to have a Postgres trigger fire on deletes, and store the <code>id</code> (and whatever other columns you want) in a separate table: e.g. <code>deleted_contacts</code>. Then, your application can poll that table to discover deletes instead.</p>
<p>The second downside is that you don&#39;t get diffs. You know this record was updated since you last polled the table, but you don&#39;t know <em>what</em> was updated on the record.</p>
<p>Maybe deletes aren&#39;t a big deal for your use case or you don&#39;t care about diffs. If so, polling the table is a reasonable and simple solution for tracking changes.</p>
<h2 id="replication-wal">Replication (WAL)</h2>
<p>Postgres supports streaming replication to other Postgres databases. In streaming replication, Postgres sends the WAL stream over a network connection from the primary to a replica. The standby servers pull these WAL records and replay them to keep their database in sync with the primary database.</p>
<p>Streaming replication was built for streaming changes to other Postgres servers. But you can use it to capture changes for your application too.</p>
<p>You first create a replication slot, like this:</p>
<pre><code>select * from
pg_create_logical_replication_slot(&#39;&lt;your_slot_name&gt;&#39;, &#39;&lt;output_plugin&gt;&#39;);
</code></pre>
<p><code>output_plugin</code> is a parameter which specifies which plugin Postgres should use to decode WAL changes. Postgres comes with a few built-in plugins. <code>pgoutput</code> is the default. It formats the output in the binary expected by client servers. <code>test_decoding</code> is a simple output plugin that provides human-readable output of the changes to the WAL.</p>
<p>The most popular output plugin not built-in to Postgres is <code>wal2json</code>. It does what it says on the tin. JSON will be a lot easier for you to consume from an application than Postgres&#39; binary format.</p>
<p>After creating your replication slot, you can start it and consume from it. Working with replication slots uses a different part of the Postgres protocol than standard queries. But many client libraries have functions that help you work with replication slots.</p>
<p>For example, this is how you consume WAL messages in the <code>psycopg2</code> library:</p>
<pre><code>cursor.start_replication(slot_name=&#39;your_slot_name&#39;, decode=True)
cursor.consume_stream(lambda msg: acknowledge_to_server(cursor, msg))

def acknowledge_to_server(cursor, msg):
    # Process the message (msg) here
    # ...
    # Acknowledge the message
    cursor.send_feedback(flush_lsn=msg.wal_end)
</code></pre>
<p>Note that the client is responsible for ack&#39;ing WAL messages that it has received. So the replication slot behaves like event buses such as SQS.</p>
<p>Instead of consuming from the WAL directly, you can use tools like Debezium to do this for you. Debezium will consume the WAL from Postgres and stream those changes to a variety of sinks, including Kafka or NATS.</p>
<h3 id="downsides">Downsides</h3>
<p>Using Postgres&#39; replication facilities to capture changes is a robust solution. The biggest downside is complexity. Replication slots and the replication protocol are less familiar to most developers than the &#34;standard&#34; parts (i.e. tables and queries).</p>
<p>Along with this complexity is a decrease in clarity. If something with replication breaks or if there&#39;s a lag or things aren&#39;t working as expected, it can be a bit trickier to debug than the other solutions outlined here.</p>
<p>Another aspect worth mentioning is that replication slots may require tweaking <code>postgresql.conf</code>. For example, you may need to tweak parameters like <code>max_wal_senders</code> and <code>max_replication_slots</code>. So you&#39;ll need total access to the database to implement this solution.</p>
<h2 id="capture-changes-in-an-audit-table">Capture changes in an audit table</h2>
<p>In this approach, you set up a separate table for logging changes, e.g. <code>changelog</code>. That table contains column related to the record&#39;s modification, such as:</p>
<ul>
<li><code>action</code>: Was this an <code>insert</code>, <code>update</code>, or <code>delete</code>?</li>
<li><code>old</code>: A jsonb of the record before the mutation. Blank for inserts.</li>
<li><code>values</code>: A jsonb of the change fields. Blank for deletes.</li>
<li><code>inserted_at</code>: Time the change occurred.</li>
</ul>
<p>To set this up, you need to create a trigger function that inserts into this table every time a change occurs. Then, you need to create triggers on all the tables you care about to invoke that trigger function.</p>
<p>Here&#39;s an example of what that trigger function might look like:</p>
<pre><code>create or replace function changelog_trigger() returns trigger as $$
declare
  action text;
  table_name text;
  transaction_id bigint;
  timestamp timestamp;
  old_data jsonb;
  new_data jsonb;
begin
  action := lower(TG_OP::text);
  table_name := TG_TABLE_NAME::text;
  transaction_id := txid_current();
  timestamp := current_timestamp;

  if TG_OP = &#39;DELETE&#39; then
    old_data := to_jsonb(OLD.*);
  elseif TG_OP = &#39;INSERT&#39; then
    new_data := to_jsonb(NEW.*);
  elseif TG_OP = &#39;UPDATE&#39; then
    old_data := to_jsonb(OLD.*);
    new_data := to_jsonb(NEW.*);
  end if;

  insert into changelog (action, table_name, transaction_id, timestamp, old_data, new_data) 
  values (action, table_name, transaction_id, timestamp, old_data, new_data);

  return null;
end;
$$ language plpgsql;
</code></pre>
<p>After setting up a way to capture changes, you need to figure out how to consume them.</p>
<p>There&#39;s a lot of different ways you can do this. One way is to treat the <code>changelog</code> as a queue. Your application workers can pull changes from this table. You&#39;ll probably want to ensure that changes are processed ~exactly once. You can use the <code>for update skip locked</code> feature in Postgres to do this. For example, your workers can open a transaction and grab a chunk of <code>changelog</code> entries:</p>
<pre><code>begin;

select * 
from changelog 
order by timestamp 
limit 100 
for update skip locked;
</code></pre>
<p>Now, other workers running that query will not receive this &#34;locked&#34; block of rows. After your worker processes the records, it can delete them:</p>
<pre><code>delete from changelog 
where id in (list_of_processed_record_ids);

commit;
</code></pre>
<h3 id="downsides">Downsides</h3>
<p>This approach is similar to using a replication slot, but more manual. The trigger function and table design I&#39;ve outlined might work to start. But you&#39;d likely need to make tweaks before deploying at scale in production. </p>
<p>The advantage over replication slots is that it&#39;s all &#34;standard&#34; Postgres. Instead of an opaque replication slot, you have an easy to query Postgres table. And you don&#39;t need access to <code>postgresql.conf</code> to make this work.</p>
<h2 id="foreign-data-wrappers">Foreign data wrappers</h2>
<p>Foreign data wrappers (FDWs) are a Postgres feature that allow you to both read from and write to external data sources from your Postgres database.</p>
<p>The most notable and widely supported extension built on FDWs is <code>postgres_fdw</code>. With <code>postgres_fdw</code>, you can connect two Postgres databases and create something like a <a href="https://www.postgresql.org/docs/current/sql-createview.html?ref=blog.sequin.io">view</a> in one Postgres database that references a table in another Postgres database. Under the hood, you&#39;re turning one Postgres database into a client and the other into a server. When you make queries against foreign tables, the client database sends the queries to the server database via Postgres&#39; <a href="https://www.postgresql.org/docs/current/protocol-flow.html?ref=blog.sequin.io">wire protocol</a>.</p>
<p>Using FDWs to capture changes is an unusual strategy. I wouldn&#39;t recommend it outside very specific situations.</p>
<p>One situation where FDWs could make sense is if you&#39;re capturing changes in one Postgres database in order to write them to another Postgres database. Perhaps you use one database for accounting and another for your application. You can skip the intermediary change capture steps and use <code>postgres_fdw</code> to go from database to database.</p>
<p>Here&#39;s an example trigger that ensures the status for a given account (identified by <code>email</code>) is in-sync across two databases. This assumes the foreign table has already been declared as <code>foreign_app_database</code>:</p>
<pre><code>create or replace function cancel_subscription()
  returns trigger as $$
declare
  account_status text;
begin
  if (new.status = &#39;cancelled&#39; or new.status = &#39;suspended&#39;) then
    account_status := &#39;cancelled&#39;;

    update foreign_app_database.account
    set status = account_status
    where email = new.email;
  end if;

  return new;
end;
$$ language plpgsql;
</code></pre>
<p>In addition to <code>postgres_fdw</code>, you can create and load your own foreign data wrappers into your Postgres database.</p>
<p>That means you could create a foreign data wrapper that posts changes to an internal API. Unlike the other change detection strategies in this list, because you&#39;d write to the API inside your commit, your API would have the ability to reject the change and roll back the commit.</p>
<h3 id="downsides">Downsides</h3>
<p>Foreign data wrappers are a fun and powerful Postgres feature. But they&#39;ll rarely be your best option for capturing changes. You&#39;re probably not trying to replicate changes from one Postgres database to another. And while writing your own foreign data wrapper from scratch <a href="https://github.com/supabase/wrappers?ref=blog.sequin.io">has gotten easier</a>, writing your own FDW is probably the biggest lift in this list for capturing changes.</p>
<h2 id="conclusion">Conclusion</h2>
<p>There are lots of options for capturing changes in Postgres. Depending on your use case, some options are clearly better than others. In sum:</p>
<ul>
<li>Listen/Notify is great for non-critical event capture, prototyping, or optimizing polling.</li>
<li>Polling for changes is a fine, straightforward solution for simple use cases.</li>
<li>Replication is probably your best bet for a robust solution. If that’s too difficult or opaque, then perhaps the audit table is a good middle-ground.</li>
<li>Finally, foreign data wrappers solve a need you’re unlikely to have.</li>
</ul>
<p>We examined all of these options for our own change capture requirements, and unfortunately none of them met our complex (and niche) needs. So, we ended up needing to build a Postgres proxy 😅 You can <a href="https://blog.sequin.io/we-had-no-choice-but-to-build-a-postgres-proxy/">read more about that here</a>.</p>


<!--kg-card-end: markdown-->
    </div>

    <!-- The design of the summary of contents / table of contents is ready, and here. Yet, it still needs to import the headings
    <div class="absolute h-full top-2 -left-72">
      <div class="sticky top-28 p-4 rounded bg-gray-100 w-60 flex flex-col gap-2.5">
        <a class="p-4 bg-black dark:bg-gray-700 dark:hover:bg-gray-600 hover:bg-gray-800 hover:shadow-xl transition-all text-root text-white w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Introduction  
        </a>
        <a class="p-4  bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 1  
        </a>
            <a class="p-4 bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 2  
        </a>
            <a class="p-4 bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 3  
        </a>
      </div>
    </div>
    -->
    
  </div></div>
  </body>
</html>
