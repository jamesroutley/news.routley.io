<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.zannzen.com/blog/small_joys_with_odin_1/">Original</a>
    <h1>Small Joys with Odin</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>Update (2023-07-21): I was being a bit overly brief with liberal use of <code>...</code> to mean “unimportant” in the code examples. Ginger Bill (creator of Odin) noted it might be clearer to have more correct/explicit Odin and Zig code for the examples given people would be less familiar. Those has been updated</em></p>
<p>For the past few months I’ve been using the programming language <a href="http://odin-lang.org/">Odin</a> in my spare time regularly. I’ve been off and on with it for a year or so but after this past year’s Advent of Code I decided to stick with it. Briefly, Odin is a C-like language that is data-oriented and pragmatic. Or as the website says “The Data-Oriented Language for Sane Software Development”. In my mind, the reason I’ve enjoyed it so much is: it’s the systems programming language with the fewest “wtf&#34;s I’ve experienced so far<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. In fact one of Odin’s guiding principles is “The Joy of Programming” and after getting the basics down, I’ve found Odin to be pretty intuitive.</p>
<p>On that note, this post is a showcase of a couple features that brought me small moments of joy while using the language. I’m not going to do a full overview of Odin – if you want that the <a href="http://odin-lang.org/docs/overview/">overview</a>, <a href="https://github.com/odin-lang/Odin/blob/master/examples/demo/demo.odin">demo.odin</a>, and <a href="https://pkg.odin-lang.org/">package docs</a> have you covered – instead I’m going to explain some small pain points I’ve had with other languages and then explain how Odin removed those minor pains.</p>
<p>While there isn’t anything super technical in here, I’m probably assuming some knowledge and I do swap between three different languages to show examples (Odin, C++, and Zig). A general programming background might be helpful to see the structure over the details.</p>
<hr/>
<h2 id="overview">Overview</h2>
<p>Odin has a number of built-in quality of life features that enhances day to day coding: <a href="http://odin-lang.org/docs/overview/#bit-sets">bit_sets</a> for flags (which work when interop-ing with C!), or <a href="http://odin-lang.org/docs/overview/#array-programming">array programming</a> which makes anything graphics related very nice. The language doesn’t have everything – the big example being there’s no compile-time execution of functions – but the features it does have are well integrated. Below are just two smaller features that led to moments where I thought “that’s fantastic.”</p>
<h2 id="caller_locationhttpodin-langorgdocsoverviewcaller_location"><a href="http://odin-lang.org/docs/overview/#caller_location">#caller_location</a></h2>
<p>Odin has the compiler directive <code>#caller_location</code> which, as the name suggests, creates a struct containing the current file name, procedure name, line, and column of the caller of a procedure (proc). The type is <a href="https://pkg.odin-lang.org/core/runtime/#Source_Code_Location">Source_Code_Location</a> and, as with all of Odin’s built-in types, you can find its definition in the <a href="https://github.com/odin-lang/Odin/blob/master/core/runtime/core.odin#L291C1-L291C1">runtime</a> package. <code>#caller_location</code> isn’t just an afterthought: Odin’s core collection (what Odin calls its standard library) uses it in most allocations, asserts, or logging. It’s fairly well integrated.</p>
<p>For your own procs, you can capture caller information by assigning <code>#caller_location</code> to an argument like so:</p>
<div><pre tabindex="0"><code data-lang="odin"><span><span><span>// odin calls functions procedures
</span></span></span><span><span><span></span>some_procedure <span>::</span> <span>proc</span>(x, y<span>:</span> <span>int</span>, loc <span>:=</span> <span>#caller_location</span>) {}
</span></span></code></pre></div><p>You can then pass the location information on to downstream proc calls if you want.</p>
<p>For a while the directive sat resoundly in my “…neat” category. I could see how maybe it would be nice to have when you want it. But also I figured it’s essentially just <code>__LINE__</code> and the like from C… so I promptly ignored it.</p>
<p>Until I was writing some tests<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> while following along with <a href="https://interpreterbook.com/">Writing an Interpreter in Go</a></p>
<h3 id="small-annoyances-when-testing-in-c3">Small annoyances when testing in C++<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></h3>
<p>When writing tests in C++ (and other languages), often times you want to verify the state of some object multiple times in a test. Perhaps the type has many values or you’re trying to assert some invariant between the members. Maybe you just want your test framework to tell you which member had the incorrect value rather than the struct as a whole. When the combinations of values to check start getting large you might write a helper check function that asserts the validity. The following is a stripped down example<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> (i.e. don’t expect it to compile):</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// C++
</span></span></span><span><span><span></span><span>struct</span> <span>Quotes</span> {
</span></span><span><span>    <span>int32_t</span> bid_price;
</span></span><span><span>    <span>int32_t</span> bid_size;
</span></span><span><span>    <span>int32_t</span> ask_price;
</span></span><span><span>    <span>int32_t</span> ask_size;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>void</span> <span>assert_quotes_safe</span>(<span>const</span> Quotes <span>&amp;</span>quote, <span>const</span> Safeties <span>&amp;</span>safeties) {
</span></span><span><span>    <span>if</span> (quote.bid_price <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> quote.ask_price <span>&lt;</span> <span>0</span>) {
</span></span><span><span>        <span>// requires writing an `operator&lt;&lt;` overload for Quotes
</span></span></span><span><span><span></span>        <span>// this is apparently how you send error strings to the test framework for gtest
</span></span></span><span><span><span></span>        EXPECT_TRUE(false) <span>&lt;&lt;</span> <span>&#34;Quotes had negative prices: &#34;</span> <span>&lt;&lt;</span> quote;
</span></span><span><span>        ASSERT_TRUE(false); <span>// exits the test case immediately
</span></span></span><span><span><span></span>    }
</span></span><span><span>    
</span></span><span><span>    EXPECT_TRUE(quote.bid_price <span>&lt;=</span> quote.ask_price);
</span></span><span><span>    EXPECT_TRUE(quote.bid_price <span>*</span> quote.bid_size <span>&lt;=</span> safeties.max_dollars);
</span></span><span><span>    <span>// more checks
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span>TEST(TestSomeQuoteGeneration) {
</span></span><span><span>    <span>// setup
</span></span></span><span><span><span></span>    assert_quotes_safe(current_quotes, safeties);
</span></span><span><span>    <span>// trigger a quote gen
</span></span></span><span><span><span></span>    assert_quotes_safe(current_quotes, safeties);
</span></span><span><span>    <span>// do some follow up that may or may not gen new quote
</span></span></span><span><span><span></span>    assert_quotes_safe(current_quotes, safeties);
</span></span><span><span>}
</span></span></code></pre></div><p>When <code>TestSomeQuoteGeneration</code> fails, the test framework will print out something similar to:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>TestSomeQuoteGeneration - test.cpp:13:assert_quotes_safe Quotes had negative prices: bid_price <span>=</span> ....
</span></span></code></pre></div><p>That is it prints the line where the <code>EXPECT()</code> failed. The issue is every test now fails in the <code>assert_quotes_safe</code> function and you need to go figure out where exactly the failure came from. With C++ you can usually run the test in gdb and then just step up one frame when the test fails. Unless you’ve been compiling with undefined behavior sanitizer (ubsan) in which case your debug information is useless and you have to recompile the entire project (thankfully there’s ccache).</p>
<p>There are definitely solutions to this problem. You could have <code>assert_quotes_safe</code> return a bool or error enum and then have an additional <code>ASSERT_TRUE(assert_quotes_safe(...))</code> in the calling code. Again we aren’t discussing a massive issue here. It’s a small pain point you have to do a little more work for, plan for ahead of time, and/or add something at all locations you call <code>assert_quotes_safe</code>.</p>
<h3 id="a-small-joy-when-testing-in-odin">A small joy when testing in Odin</h3>
<p>Odin, like many modern languages, has built-in testing support. To add a test you use the attribute <code>@(test)</code> on any procedure. To make code organization slightly easier, Odin detects when a filename ends with <code>_test.odin</code> and will drop those files during a normal build. Odin also has a core package called <a href="https://pkg.odin-lang.org/core/testing/">testing</a> which contains a number of useful utilities.</p>
<p>If you’re familiar with Go, the code will look very familiar.</p>
<div><pre tabindex="0"><code data-lang="odin"><span><span><span>// Odin
</span></span></span><span><span><span></span><span>package</span> some_financial_thing
</span></span><span><span>
</span></span><span><span><span>import</span> <span>&#34;core:testing&#34;</span>
</span></span><span><span>
</span></span><span><span>Quotes <span>::</span> <span>struct</span> {
</span></span><span><span>    bid_price, bid_size, ask_price, ask_size<span>:</span> <span>i32</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// this code is even nicer after https://github.com/odin-lang/Odin/pull/2597
</span></span></span><span><span><span></span>assert_quotes_safe <span>::</span> <span>proc</span>(t<span>:</span> <span>^</span>testing.T, quotes<span>:</span> Quotes, safeties<span>:</span> Safeties, loc <span>:=</span> <span>#caller_location</span>) {
</span></span><span><span>    <span>if</span> quotes.ask_price <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> quotes.bid_price <span>&lt;</span> <span>0</span> {
</span></span><span><span>        testing.errorf(t, <span>&#34;quotes had negative prices: %#v&#34;</span>, quotes, loc <span>=</span> loc)
</span></span><span><span>        testing.fail_now(t, loc <span>=</span> loc) <span>// returns from test immediately
</span></span></span><span><span><span></span>    }
</span></span><span><span>    
</span></span><span><span>    testing.expect(t, quotes.bid_price <span>&lt;=</span> quotes.ask_price, loc <span>=</span> loc)
</span></span><span><span>    testing.expect(t, quotes.bid_price <span>*</span> quotes.bid_size <span>&lt;=</span> safeties.max_dollars, loc <span>=</span> loc)
</span></span><span><span>    <span>// more tests
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>@(test)</span>
</span></span><span><span>test_some_quote_genration <span>::</span> <span>proc</span>(t<span>:</span> <span>^</span>testing.T) {
</span></span><span><span>    <span>// setup
</span></span></span><span><span><span></span>    assert_quotes_safe(current_quotes, safeties);
</span></span><span><span>    <span>// send some trigger
</span></span></span><span><span><span></span>    assert_quotes_safe(current_quotes, safeties);
</span></span><span><span>    <span>// do some follow up that may or may not gen new quote
</span></span></span><span><span><span></span>    assert_quotes_safe(current_quotes, safeties);
</span></span><span><span>}
</span></span></code></pre></div><p>The procedures in the testing package such as <code>expect_value</code> or <code>errorf</code> all have a <code>loc := #caller_location</code> argument. By passing the location information we captured, we’ll get a more useful error message on failures such as:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>test.odin:<span>(</span>27:5<span>)</span> - quotes had negative prices: Quotes<span>{</span>bid_price <span>=</span> ...<span>}</span>
</span></span></code></pre></div><p>The line number is where we actually call <code>assert_quotes_safe</code>! So now we can just set our breakpoint before the second call to <code>assert_quotes_safe</code> rather than spending time figuring out which one it was.</p>
<p>Again, this isn’t massive. But given the amount I’ve had to trace back tests before it’s very welcome.</p>
<h2 id="disabled--conditionhttpsodin-langorgdocsoverviewdisabledboolean"><a href="https://odin-lang.org/docs/overview/#disabledboolean">@(disabled = &lt;condition&gt;)</a></h2>
<p>I’ve used a few C / C++ replacement languages that don’t have macros. I’m always pretty happy with the result. Even in C++ I try to avoid writing macros unless I actually have to (constexpr all the things!). <a href="https://ziglang.org/">Zig</a> was the first C replacement I tried and I immediately loved its <code>comptime</code> (compile time evaluation/execution). It was essentially everything I wanted from C++ and then some but in a simpler form<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>. The fact Zig can create an <a href="https://zig.news/kristoff/struct-of-arrays-soa-in-zig-easy-in-userland-40m0">SoA</a> type in userspace with comptime is amazing. If I were actively using Zig at work I’d be very happy<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>.</p>
<p>But there are certain things I’m used to from C++ that are a pain in most of these languages that don’t have macros. The immediate example that never really has a good solution is logging.</p>
<h3 id="a-brief-look-at-logging">A brief look at logging</h3>
<p>Just a brief talk on why logging is a prime example - logging is <em>expensive</em>. Even fast logging frameworks still require time to copy data onto some queue so another thread can do the formatting. On the other hand, having debug logs in your code is fantastic for debugging (shocker). To balance that, you want some system to enable or disable debug logging at build time. In C++ you’d do this with macros. Note I’m leaving a lot of the code as <code>...</code> for brevity and because it’s irrelevant to the point.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>enum</span> <span>class</span> <span>LogLevel</span> {
</span></span><span><span>    Debug,
</span></span><span><span>    Info
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>void</span> <span>log_something</span>(LogLevel level, ...);
</span></span><span><span>
</span></span><span><span><span>#ifndef LOG_LEVEL_DEBUG
</span></span></span><span><span><span>#define LOG_DEBUG(...)
</span></span></span><span><span><span>#else
</span></span></span><span><span><span>#define LOG_DEBUG(...) log_something(LogLevel::Debug, ...);
</span></span></span><span><span><span>#endif
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define LOG_INFO(...) log_something(LogLevel::Info, ...);
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>some_function</span>() {
</span></span><span><span>    <span>// do things
</span></span></span><span><span><span></span>    foo();
</span></span><span><span>    <span>// log some data
</span></span></span><span><span><span></span>    LOG_DEBUG(<span>&#34;some sort of verbose information: %s&#34;</span>, expensive_to_string(my_data_type));
</span></span><span><span>}
</span></span></code></pre></div><p>If you’re not familiar, the above <code>LOG_DEBUG</code> macro is essentially “If <code>LOG_LEVEL_DEBUG</code> is defined, replace <code>LOG_DEBUG</code> with a call to <code>log_something</code> and forward all arguments. If it’s not defined replace the whole thing with an empty string including the arguments.” It’s a pretty simple macro to use, you just call it like a function.</p>
<p>Zig doesn’t have a macro system though, so you might define your logging in a similar way using <code>comptime</code><sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>:</p>
<div><pre tabindex="0"><code data-lang="zig"><span><span><span>// probably use @import(&#34;root&#34;) in actual code
</span></span></span><span><span><span></span><span>const</span> LOG_LEVEL <span>=</span> LogLevel.debug;
</span></span><span><span>
</span></span><span><span><span>const</span> LogLevel <span>=</span> <span>enum</span> {
</span></span><span><span>    debug,
</span></span><span><span>    info,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> logSomething(<span>comptime</span> level<span>:</span> LogLevel, <span>comptime</span> format<span>:</span> []<span>const</span> <span>u8</span>, args<span>:</span> anytype) {
</span></span><span><span>    <span>if</span> level <span>&gt;=</span> LOG_LEVEL {
</span></span><span><span>        actuallyLogTheThing(level, format, args);
</span></span><span><span>    }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> logDebug(<span>comptime</span> format<span>:</span> []<span>const</span> <span>u8</span>, args<span>:</span> anytype) {
</span></span><span><span>    logSomething(LogLevel.debug, format, anytype);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> someFunction() {
</span></span><span><span>    <span>// do things
</span></span></span><span><span><span></span>    foo();
</span></span><span><span>    <span>// log some data
</span></span></span><span><span><span></span>    logDebug(<span>&#34;some sort of verbose information {s}&#34;</span>, .{expensiveToString(my_data_type)});
</span></span><span><span>}
</span></span></code></pre></div><p>Zig’s <code>comptime</code> is fantastic and the above is very similar to the C++. At compile time if you’ve defined <code>LOG_LEVEL</code> to be <code>info</code> then <code>logDebug</code> becomes a noop. No copies to a queue, no formatting. It seems essentially the same as the C++.</p>
<h3 id="a-minor-annoyance-with-macroless-languages">A minor annoyance with macroless languages</h3>
<p>It’s great that <code>logDebug</code> is a noop. It sounds like exactly what we want. However, what happens to the arguments you pass that noop? As the name implies <code>expensiveToString</code> is costly. In the C++ version the call is removed by the preprocessor, but what about the Zig version? Maybe the compiler notices they’re unused and optimizes them out in a release build. But what if your expensive used-for-debug-logging-only function has side effects like incrementing some debug metrics? What if the function is from a C library so it can’t be inlined at all? In a lot of code few extraneous calls might not be the end of the world as long as the log itself gets dropped downstream (what’s a few hundred nanos or a mic or two between friends?<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>), but sometimes it’s unnacceptable.</p>
<p>The solution in Zig is to wrap everything in a comptime if:</p>
<div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span> someFunction() {
</span></span><span><span>    <span>// do things
</span></span></span><span><span><span></span>    foo();
</span></span><span><span>    <span>// log some data
</span></span></span><span><span><span></span>    <span>if</span> (log_level <span>&lt;=</span> LogLevel.debug) {
</span></span><span><span>        <span>const</span> s <span>=</span> expensiveToString(my_data_type);
</span></span><span><span>        logDebug(<span>&#34;some verbose information: %s&#34;</span>, .{s})    
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>Which is fine, but you need to litter your code with the <code>if log_level &lt;= LogLevel.debug</code>. You also need to know at every call site either the value the logger uses to enable/disable debug logging, or you need to define your own aliases e.g. <code>LOG_LEVEL_DEBUG</code> and use those. For production level code this is, again, a minor annoyance at worst. But it’s just annoying enough that I don’t really enjoy it either for my personal projects (which are just for fun anyway).</p>
<h3 id="a-small-joy-with-an-odin-attribute">A small joy with an Odin attribute</h3>
<p>At first I thought I’d need to do the same thing in Odin. It <em>does</em> have <code>when</code> which does conditional compilation. I was somewhat resigned to wraping all debug logging in a <code>when LOG_LEVEL &lt;= .Debug {}</code> and calling it a day. However, one of the things that I like about Odin is it’s very pragmatic. It doesn’t necessarily try to solve every problem with the same hammer.</p>
<p>I figured I’d post my annoyance in <code>#beginners</code> on the Odin discord in case someone had a good solution, and that’s when I was told about <code>@disabled</code>. <code>@disabled</code> is an attribute that removes all uses of a procedure when true. It doesn’t just turn the proc into a noop, it specifically removes the usage at call sites including any arguments passed to the procedure. The end result is similar to C++’s string replacement macros without the macros. The above example can be solved in Odin with e.g.:</p>
<div><pre tabindex="0"><code data-lang="odin"><span><span>Log_Level <span>::</span> <span>enum</span> {
</span></span><span><span>    Debug,
</span></span><span><span>    Info,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>LOG_LEVEL <span>::</span> Log_Level.Debug
</span></span><span><span>
</span></span><span><span>log_something <span>::</span> <span>proc</span>(level<span>:</span> Log_Level, fmt<span>:</span> <span>string</span>, args<span>:</span> ..<span>any</span>, loc <span>:=</span> <span>#caller_location</span>) {}
</span></span><span><span>
</span></span><span><span><span>@(disabled = LOG_LEVEL &gt; .Debug)</span>
</span></span><span><span>log_debug <span>::</span> <span>proc</span>(fmt<span>:</span> <span>string</span>, args<span>:</span> ..<span>any</span>, loc <span>:=</span> <span>#caller_location</span>) { <span>// and a nice #caller_location
</span></span></span><span><span><span></span>    log_something(.Debug, fmt, ..args, loc <span>=</span> loc)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>some_function <span>::</span> <span>proc</span>() {
</span></span><span><span>    <span>// do things
</span></span></span><span><span><span></span>    foo()
</span></span><span><span>    <span>// log some data
</span></span></span><span><span><span></span>    log_debug(<span>&#34;some verbose information: %s&#34;</span>, expensive_to_string(my_data_type))
</span></span><span><span>}
</span></span></code></pre></div><p>In the above, any invocation of <code>log_debug</code> will be stripped out if <code>LOG_LEVEL</code> is <code>.Info</code>. That includes any arguments passed to the proc. That means any expensive or non-inlineable procedures (like <code>expensive_to_string</code>) also won’t be called. It doesn’t rely on <code>-o:speed</code> optimizations to figure out the call is unused. A debug build with <code>log_debug</code> disabled will have the same behavior. In addition, user code just has to call <code>log_debug</code> and not worry about how the logging procs determine if they are enabled or not.</p>
<p>This example in particular was maybe a little more than just a small joy. It was an exact solution to what I wanted. Even without <code>expensive_to_string</code>, it’s nice to just log without having to think about it. The logging procs I write will handle it properly. There are most likely other cases where you still need a <code>when</code> like the Zig solution but it’s at least an 80/20 solution that works well.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>To hammer the point again, nothing above is a game changer in programming. They’re just small, quality of life bonuses in Odin that sparked a tiny amount of joy for me personally.</p>
<p>If you are interested in Odin, I recommend reading over the main website to get a better idea if it’s something for you. If you decide it’s interesting then you should probably also join the <a href="https://discord.com/invite/sVBPHEv">discord</a>. There are dozens of us!</p>

</div></div>
  </body>
</html>
