<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mattsanetra.uk/blog/graph-build-proposal/">Original</a>
    <h1>Piper: A proposal for a graphy pipe-based build system</h1>
    
    <div id="readability-page-1" class="page"><div id="_main-content"><article><span><time datetime="2023-04-23T15:00:00.000Z">April 23, 2023</time></span><div><p>Yet <em><strong>another</strong></em> build system?</p><p><img alt="Alpaca" src="https://mattsanetra.uk/_astro/alpaca-intrigued.ab5b631e.svg"/></p></div><p>Hear me out! This one is simple!! No need to add separate support for different languages, we just write what commands we want to execute.</p><div><p>Isn’t that just Make?</p><p><img alt="Frog" src="https://mattsanetra.uk/_astro/frog-confused.5bf1b652.svg"/></p></div><p>Yep! But what if we add <strong>mappings</strong> and <strong>collections</strong>?</p><p>This post is just a proposal and some ideas that I brainstormed to make a build system that is easy to use for any language, without having to learn anything complicated.</p><p>The name I have in mind for this is <strong>Piper</strong>.</p><h2 id="motivation">Motivation</h2><p>I was recently experimenting with a tool that converted one file into another, and then that <em>new</em> file had to be aggregated with files of the same type in the arguments of yet another command.</p><p>It seems complicated, but it’s solved easily with a bash script:</p><pre><code><span><span>#!/bin/bash</span></span>
<span><span>shopt</span><span> -s nullglob  </span><span># Prevents awful globbing behaviour if no files match</span></span>
<span><span>for</span><span> file </span><span>in</span><span> </span><span>*</span><span>.ext</span><span>;</span><span> </span><span>do</span></span>
<span><span>  </span><span>echo</span><span> </span><span>&#34;Processing </span><span>$file</span><span>&#34;</span></span>
<span><span>  ./convert -o </span><span>&#34;</span><span>${file</span><span>%</span><span>.ext}</span><span>.new&#34;</span><span> </span><span>&#34;</span><span>$file</span><span>&#34;</span></span>
<span><span>done</span></span>
<span><span>echo</span><span> </span><span>&#34;Aggregating files&#34;</span></span>
<span><span>./final -o final </span><span>*</span><span>.new</span></span></code></pre><div><p>So why do we need something new?</p><p><img alt="Rabbit" src="https://mattsanetra.uk/_astro/rabbit-intrigued.e02e765f.svg"/></p></div><p>There are a few downsides of rawdogging it with bash:</p><ul><li>No parallelism unless you try <em>really really</em> hard. I’m not bothered to do it while writing this example.</li><li>You’d be insane to add incremental compilation.</li><li>No way to visualise the build graph.</li><li>It’s not cross-platform.</li><li>It’s hard to read.</li></ul><p>These are things that can be handled for you very easily with a syntax very similar to Make — <em>without</em> its pain-points.</p><h2 id="observations">Observations</h2><p>We can see that there are two types of transformations:</p><ul><li><strong>Mappings:</strong> 1-1 transformations, like converting a file to another file.</li><li><strong>Collections:</strong> N-1 transformations, like aggregating files into one.</li></ul><div><p>What about 1-N?</p><p><img alt="Alpaca" src="https://mattsanetra.uk/_astro/alpaca-excited.0a51b8d6.svg"/></p></div><p>While it is true that there can be a 1-N transformation in a single command, I’ve found that it isn’t very common and this can be a later addition. I’ll reserve something along the lines of <strong>Generators</strong> for these transformations.</p><p>Alas, let’s prototype some syntax!</p><h2 id="syntax">Syntax</h2><h3 id="commands">Commands</h3><p>Like Make, we will make <code>ident:</code> represent a runnable command. However, unlike Make, we will not be putting other commands in body. Instead, we will declare the series of mappings and collections to perform on groups of files.</p><p>E.g:</p><pre><code><span><span>build:</span></span>
<span><span>  .c --[CC]-&gt; .o --{AR}-&gt; lib.a</span></span></code></pre><p>Note:</p><ul><li>We use <code>[ident]</code> to represent a mapping and <code>{ident}</code> to represent a collection.</li><li>We use <code>.ext</code> as a shorthand for glob <code>*.ext</code>.</li></ul><p>It’s important to also provide a way for the user to specify custom glob patterns, but we’re in 2023 so lets do it with regexes. The above is equivalent to:</p><pre><code><span><span>build:</span></span>
<span><span>  r(.*\.c) --[CC]-&gt; r(.*\.o) --{AR}-&gt; lib.a</span></span></code></pre><p>Because <code>CC</code> is a mapping, it auto infers that the output filename is the same, just with a different extension. A full filename is required for the output of collections.</p><div><p>This has potential!</p><p><img alt="Rabbit" src="https://mattsanetra.uk/_astro/rabbit-excited.ff4af89b.svg"/></p></div><h3 id="mapping--collection-definitions">Mapping &amp; Collection Definitions</h3><p><code>[ident]:</code> and <code>{ident}:</code> respectively:</p><pre><code><span><span>[CC]:</span></span>
<span><span>  cc -o $_OUT $_IN</span></span>
<span><span></span></span>
<span><span>{AR}:</span></span>
<span><span>  ar rcs $_OUT $_IN</span></span></code></pre><p>Note:</p><ul><li>Variables begin with <code>$</code>, more on that in the next section.</li><li>Special <em>“inserted”</em> variables are prefixed with <code>$_</code>.</li></ul><p>These are the only inserted rules:</p><ul><li><code>$_OUT</code>: The output filename, including file extension.</li><li><code>$_IN</code>: The input filename(s), including file extension.<ul><li>For collections, this is a space separated list of filenames.</li></ul></li><li><code>$_{0..9999}</code>: Regex group matches, if the input is a regex.<ul><li><code>$_0</code> is the entire match, always equal to <code>$_IN</code>. You can think of this as because of the outer brackets in the regex expressions above.</li><li>In collections, each variable is a space separated list of the respective group.</li></ul></li></ul><h3 id="variables">Variables</h3><p>Variables begin with a <code>$</code>. They are defined as such:</p><pre><code><span><span>$A = this is a literal</span></span>
<span><span>$B = &#34;this is a literal&#34;</span></span></code></pre><div><p>What about variables that are the output of a command?</p><p><img alt="Alpaca" src="https://mattsanetra.uk/_astro/alpaca-confused.9b22b0d8.svg"/></p></div><p>We can use the <code>$(command)</code> syntax:</p><pre><code><span><span>$C = $(echo &#34;this is a literal&#34;)</span></span></code></pre><p><code>$A</code>, <code>$B</code> and <code>$C</code> are identical.</p><p><em><strong>Note</strong>:</em> Variables can only be substituted. In essence, they are lazily evaluated. If you reference <code>$C</code> twice, it will be executed twice.</p><p>Variables are scoped. If you define a variable in a command, it will only live for the duration of that command.</p><p>You can use variables to also define file types, e.g.</p><pre><code><span><span>$SRC = .c</span></span>
<span><span>$OBJ = r(.*\.o)</span></span></code></pre><p>I’m still debating internally if <code>$A</code> should be allowed as there can potentially be a conflict with <code>$SRC</code>.</p><h2 id="conclusion">Conclusion</h2><p>I believe this can be a very simple, but powerful, build description language.</p><ul><li>Parallel jobs can be easily determined by both the user and the tool.</li><li>Incremental compilation is trivial due to each mapping having a single input and output, with the output file name being known before it is generated.</li><li>It is intuitive, and easy to read.</li><li>It can most definitely be cross-platform<ul><li>Although, this is a bit of a moot point, it all depends on the build commands used. Only pointing this out because <code>bash</code> is not cross-platform.</li></ul></li><li>No need for a tool to generate a graph - it’s right there! Although the appropriate software can still be written.</li></ul><p>This is just a “proposal”, I haven’t written any software for this, and my opinions may change. I haven’t spent much time on this at all and I’m sure there are many things I’ve missed, and many things that could be improved. I’d love to hear your thoughts!</p><p><em>— Matthew</em></p><hr/><h2>Comments</h2></article></div></div>
  </body>
</html>
