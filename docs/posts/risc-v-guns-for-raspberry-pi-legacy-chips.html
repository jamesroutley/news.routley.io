<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spectrum.ieee.org/risc-v-raspberry-pi">Original</a>
    <h1>RISC-V Guns for Raspberry Pi, Legacy Chips</h1>
    
    <div id="readability-page-1" class="page"><div><template><p>
	The two of us, along with many other researchers involved in quantum computing, are trying to move definitively beyond these preliminary demos of QEC so that it can be employed to build useful, large-scale quantum computers. But before describing how we think such error correction can be made practical, we need to first review what makes a quantum computer tick.
</p><p><strong><a href="https://www.nature.com/articles/23376" target="_blank">Information is physical</a></strong>. This was the mantra of the distinguished <a href="https://research.ibm.com/labs/watson/" target="_blank">IBM</a> researcher <a href="http://www.nasonline.org/publications/biographical-memoirs/memoir-pdfs/landauer-rolf.pdf" target="_blank">Rolf Landauer</a>. Abstract though it may seem, information always involves a physical representation, and the physics matters.
</p><p>
	Conventional digital information consists of bits, zeros and ones, which can be represented by classical states of matter, that is, states well described by classical physics. Quantum information, by contrast, involves 
	<em>qubits</em>—quantum bits—whose properties follow the peculiar rules of quantum mechanics.
</p><p>
	A classical bit has only two possible values: 0 or 1. A qubit, however, can occupy a superposition of these two information states, taking on characteristics of both. Polarized light provides 
	<a href="https://www.scientificamerican.com/article/a-do-it-yourself-quantum/" target="_blank">intuitive examples</a> of superpositions. You could use horizontally polarized light to represent 0 and vertically polarized light to represent 1, but light can also be polarized on an angle and then has both horizontal and vertical components at once. Indeed, one way to represent a qubit is by the polarization of a single photon of light.
</p><p>
	These ideas generalize to groups of 
	<em>n</em> bits or qubits: <em>n</em> bits can represent any one of 2<sup><em>n</em></sup> possible values at any moment, while <em>n</em> qubits can include components corresponding to all 2<sup><em>n</em></sup> classical states simultaneously in superposition. These superpositions provide a vast range of possible states for a quantum computer to work with, albeit with limitations on how they can be manipulated and accessed. Superposition of information is a central resource used in quantum processing and, along with other quantum rules, enables powerful new ways to compute.
</p><p>
	Researchers are experimenting with many different physical systems to hold and process quantum information, including 
	<a href="https://spectrum.ieee.org/race-to-hundreds-of-photonic-qubits-xanadu-scalable-photon" target="_self">light</a>, trapped <a href="https://physics.aps.org/articles/v15/s55" target="_blank">atoms</a> and <a href="https://spectrum.ieee.org/ionq-new-quantum-computing-chip" target="_self">ions</a>, and <a href="https://physics.aps.org/articles/v12/s104" target="_blank">solid-state devices</a> based on <a href="https://spectrum.ieee.org/quantum-computing-milestone-researchers-compute-with-hot-silicon-qubits" target="_self">semiconductors</a> or <a href="https://spectrum.ieee.org/fault-tolerant-quantum-computing" target="_self">superconductors</a>. For the purpose of realizing qubits, all these systems follow the same underlying mathematical rules of quantum physics, and all of them are highly sensitive to environmental fluctuations that introduce errors. By contrast, the transistors that handle classical information in modern digital electronics can reliably perform a billion operations per second for decades with a vanishingly small chance of a hardware fault.
</p><p>
	Of particular concern is the fact that qubit states can roam over a continuous range of superpositions. Polarized light again provides a good analogy: The angle of linear polarization can take 
	<em>any</em> value from 0 to 180 degrees.
</p><p>
	Pictorially, a qubit’s state can be thought of as an arrow pointing to a location on the surface of a sphere. Known as a 
	<a href="https://en.wikipedia.org/wiki/Bloch_sphere" target="_blank">Bloch sphere</a>, its north and south poles represent the binary states 0 and 1, respectively, and all other locations on its surface represent possible quantum superpositions of those two states. Noise causes the Bloch arrow to drift around the sphere over time. A conventional computer represents 0 and 1 with physical quantities, such as capacitor voltages, that can be locked near the correct values to suppress this kind of continuous wandering and unwanted bit flips. There is no comparable way to lock the qubit’s “arrow” to its correct location on the Bloch sphere.
</p><p>
	Early in the 1990s, Landauer and others argued that this difficulty presented a fundamental obstacle to building useful quantum computers. The issue is known as scalability: Although a simple quantum processor performing a few operations on a handful of qubits might be possible, could you scale up the technology to systems that could run lengthy computations on large arrays of qubits? A type of classical computation called 
	<a href="https://en.wikipedia.org/wiki/Analog_computer" target="_blank">analog computing</a> also uses continuous quantities and is <a href="https://spectrum.ieee.org/not-your-fathers-analog-computer" target="_self">suitable for some tasks</a>, but the problem of continuous errors prevents the complexity of such systems from being scaled up. Continuous errors with qubits seemed to doom quantum computers to the same fate.
</p><p>
	We now know better. Theoreticians have successfully adapted the theory of error correction for classical digital data to quantum settings. QEC makes scalable quantum processing possible in a way that is impossible for analog computers. To get a sense of how it works, it’s worthwhile to review how error correction is performed in classical settings.
</p><p><strong>Simple schemes can</strong> deal with errors in classical information. For instance, in the 19th century, ships routinely carried <a href="https://en.wikipedia.org/wiki/Marine_chronometer" target="_blank">clocks</a> for determining the ship’s longitude during voyages. A good clock that could keep track of the time in Greenwich, in combination with the sun’s position in the sky, provided the necessary data. A mistimed clock could lead to dangerous navigational errors, though, so ships often carried at least three of them. Two clocks reading different times could detect when one was at fault, but three were needed to identify which timepiece was faulty and correct it through a majority vote.
</p><p>
	The use of multiple clocks is an example of a repetition code: Information is redundantly encoded in multiple physical devices such that a disturbance in one can be identified and corrected.
</p><p>
	As you might expect, quantum mechanics adds some major complications when dealing with errors. Two problems in particular might seem to dash any hopes of using a quantum repetition code. The first problem is that measurements fundamentally disturb quantum systems. So if you encoded information on three qubits, for instance, observing them directly to check for errors would ruin them. Like Schrödinger’s cat when its box is opened, their quantum states would be irrevocably changed, spoiling the very quantum features your computer was intended to exploit.
</p><p>
	The second issue is a fundamental result in quantum mechanics called the 
	<a href="https://physicstoday.scitation.org/doi/10.1063/1.3086114" target="_blank">no-cloning theorem</a>, which tells us it is impossible to make a perfect copy of an unknown quantum state. If you know the exact superposition state of your qubit, there is no problem producing any number of other qubits in the same state. But once a computation is running and you no longer know what state a qubit has evolved to, you cannot manufacture faithful copies of that qubit except by duplicating the entire process up to that point.
</p><p>
	Fortunately, you can sidestep both of these obstacles. We’ll first describe how to evade the measurement problem using the example of a classical three-bit repetition code. You don’t actually need to know the state of every individual code bit to identify which one, if any, has flipped. Instead, you ask two questions: “Are bits 1 and 2 the same?” and “Are bits 2 and 3 the same?” These are called parity-check questions because two identical bits are said to have even parity, and two unequal bits have odd parity.
</p><p>
	The two answers to those questions identify which single bit has flipped, and you can then counterflip that bit to correct the error. You can do all this without ever determining what value each code bit holds. A similar strategy works to correct errors in a quantum system.
</p><p>
	Learning the values of the parity checks still requires quantum measurement, but importantly, it does not reveal the underlying quantum information. Additional qubits can be used as disposable resources to obtain the parity values without revealing (and thus without disturbing) the encoded information itself.
</p><p>
	Like Schrödinger’s cat when its box is opened, the quantum states of the qubits you measured would be irrevocably changed, spoiling the very quantum features your computer was intended to exploit.
</p><p>
	What about no-cloning? It turns out it is possible to take a qubit whose state is unknown and encode that hidden state in a superposition across multiple qubits in a way that does not clone the original information. This process allows you to record what amounts to a single logical qubit of information across three physical qubits, and you can perform parity checks and corrective steps to protect the logical qubit against noise.
</p><p>
	Quantum errors consist of more than just bit-flip errors, though, making this simple three-qubit repetition code unsuitable for protecting against all possible quantum errors. True QEC requires something more. That came in the mid-1990s when 
	<a href="https://math.mit.edu/~shor/" target="_blank">Peter Shor</a> (then at <a href="http://www.bell-labs.com/about/locations/murray-hill-new-jersey-usa/" target="_blank">AT&amp;T Bell Laboratories</a>, in Murray Hill, N.J.) described <a href="https://physics.aps.org/articles/v9/65" target="_blank">an elegant scheme</a> to encode one logical qubit into nine physical qubits by embedding a repetition code inside another code. Shor’s scheme protects against an arbitrary quantum error on any one of the physical qubits.
</p><p>
	Since then, the QEC community has developed many improved encoding schemes, which use fewer physical qubits per logical qubit—the most compact use five—or enjoy other performance enhancements. Today, the workhorse of large-scale proposals for error correction in quantum computers is called the 
	<a href="https://arxiv.org/abs/quant-ph/0110143" target="_blank">surface code</a>, developed <a href="https://arxiv.org/abs/quant-ph/9707021" target="_blank">in the late 1990s</a> by borrowing exotic mathematics from topology and high-energy physics.
</p><p><strong>It is convenient</strong> to think of a quantum computer as being made up of logical qubits and logical gates that sit atop an underlying foundation of physical devices. These physical devices are subject to noise, which creates physical errors that accumulate over time. Periodically, generalized parity measurements (called syndrome measurements) identify the physical errors, and corrections remove them before they cause damage at the logical level.
</p><p>
	A quantum computation with QEC then consists of cycles of gates acting on qubits, syndrome measurements, error inference, and corrections. In terms more familiar to engineers, QEC is a form of feedback stabilization that uses indirect measurements to gain just the information needed to correct errors.
</p><p>
	QEC is not foolproof, of course. The three-bit repetition code, for example, fails if more than one bit has been flipped. What’s more, the resources and mechanisms that create the encoded quantum states and perform the syndrome measurements are themselves prone to errors. How, then, can a quantum computer perform QEC when all these processes are themselves faulty?
</p><p>
	Remarkably, the error-correction cycle can be designed to tolerate errors and faults that occur at every stage, whether in the physical qubits, the physical gates, or even in the very measurements used to infer the existence of errors! Called a fault-tolerant architecture, such a design permits, in principle, error-robust quantum processing even when all the component parts are unreliable.
</p><p><img alt="A block diagram showing a quantum error correction feedback loop and quantum control." data-rm-shortcode-id="1aa70101e84b6f94d82e99a17a4e0128" data-rm-shortcode-name="rebelmouse-image" data-runner-src="https://spectrum.ieee.org/media-library/a-block-diagram-showing-a-quantum-error-correction-feedback-loop-and-quantum-control.jpg?id=29986288&amp;width=980" height="1667" id="a1390" lazy-loadable="true" src="data:image/svg+xml,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; viewBox=&#39;0 0 4009 1667&#39;%3E%3C/svg%3E" width="4009"/><small placeholder="Add Photo Caption...">A long quantum computation will require many cycles of quantum error correction (QEC). Each cycle would consist of gates acting on encoded qubits (performing the computation), followed by syndrome measurements from which errors can be inferred, and corrections. The effectiveness of this QEC feedback loop can be greatly enhanced by including quantum-control techniques (represented by the thick blue outline) to stabilize and optimize   each of these processes.</small></p><p>
	Even in a fault-tolerant architecture, the additional complexity introduces new avenues for failure. The effect of errors is therefore reduced at the logical level only if the underlying physical error rate is not too high. The maximum physical error rate that a specific fault-tolerant architecture can reliably handle is known as its break-even error threshold. If error rates are lower than this threshold, the QEC process tends to suppress errors over the entire cycle. But if error rates exceed the threshold, the added machinery just makes things worse overall.
</p><p>
	The theory of fault-tolerant QEC is foundational to every effort to build useful quantum computers because it paves the way to building systems of any size. If QEC is implemented effectively on hardware exceeding certain performance requirements, the effect of errors can be reduced to arbitrarily low levels, enabling the execution of arbitrarily long computations.
</p><p>
	At this point, you may be wondering how QEC has evaded the problem of continuous errors, which is fatal for scaling up analog computers. The answer lies in the nature of quantum measurements.
</p><p>
	In a typical quantum measurement of a superposition, only a few discrete outcomes are possible, and the physical state changes to match the result that the measurement finds. With the parity-check measurements, this change helps.
</p><p>
	Imagine you have a code block of three physical qubits, and one of these qubit states has wandered a little from its ideal state. If you perform a parity measurement, just two results are possible: Most often, the measurement will report the parity state that corresponds to no error, and after the measurement, all three qubits will be in the correct state, whatever it is. Occasionally the measurement will instead indicate the odd parity state, which means an errant qubit is now fully flipped. If so, you can flip that qubit back to restore the desired encoded logical state.
</p><p>
	In other words, performing QEC transforms small, continuous errors into infrequent but discrete errors, similar to the errors that arise in digital computers.
</p><p><strong>Researchers have now</strong> demonstrated many of the principles of QEC in the laboratory—from the basics of <a href="https://arxiv.org/abs/quant-ph/9802018" target="_blank">the repetition code</a> through to <a href="https://www.nature.com/articles/s41586-021-03928-y" target="_blank">complex encodings</a>, <a href="https://www.nature.com/articles/s41586-022-04721-1" target="_blank">logical operations</a> on code words, and <a href="https://physics.aps.org/articles/v14/184" target="_blank">repeated cycles</a> of measurement and correction. Current estimates of the break-even threshold for quantum hardware place it at about 1 error in 1,000 operations. This level of performance hasn’t yet been achieved across all the constituent parts of a QEC scheme, but researchers are getting ever closer, achieving multiqubit logic with rates of fewer than about 5 errors per 1,000 operations. Even so, passing that critical milestone will be the beginning of the story, not the end.
</p><p>
	On a system with a physical error rate just below the threshold, QEC would require enormous redundancy to push the logical rate down very far. It becomes much less challenging with a physical rate further below the threshold. So just crossing the error threshold is not sufficient—we need to beat it by a wide margin. How can that be done?
</p><p>
	If we take a step back, we can see that the challenge of dealing with errors in quantum computers is one of stabilizing a dynamic system against external disturbances. Although the mathematical rules differ for the quantum system, this is a familiar problem in the discipline of control engineering. And just as control theory can help engineers build robots capable of righting themselves when they stumble, quantum-control engineering can suggest the best ways to implement abstract QEC codes on real physical hardware. Quantum control can minimize the effects of noise and make QEC practical.
</p><p>
	In essence, quantum control involves optimizing how you implement all the physical processes used in QEC—from individual logic operations to the way measurements are performed. For example, in a system based on superconducting qubits, a qubit is flipped by irradiating it with a microwave pulse. One approach uses a simple type of pulse to move the qubit’s state from one pole of the Bloch sphere, along the Greenwich meridian, to precisely the other pole. Errors arise if the pulse is distorted by noise. It turns out that a more complicated pulse, one that takes the qubit on a well-chosen meandering route from pole to pole, can result in less error in the qubit’s final state under the same noise conditions, even when the new pulse is imperfectly implemented.
</p><p>
	One facet of quantum-control engineering involves careful analysis and design of the best pulses for such tasks in a particular imperfect instance of a given system. It is a form of open-loop (measurement-free) control, which complements the closed-loop feedback control used in QEC.
</p><p>
	This kind of open-loop control can also change the statistics of the physical-layer errors to better comport with the assumptions of QEC. For example, QEC performance is limited by the worst-case error within a logical block, and individual devices can vary a lot. Reducing that variability is very beneficial. In 
	<a href="https://arxiv.org/abs/2010.08057" target="_blank">an experiment our team performed</a> using IBM’s publicly accessible machines, we showed that careful pulse optimization reduced the difference between the best-case and worst-case error in a small group of qubits by more than a factor of 10.
</p><p>
	Some error processes arise only while carrying out complex algorithms. For instance, crosstalk errors occur on qubits only when their neighbors are being manipulated. 
	<a href="https://q-ctrl.com/blog/firing-up-quantum-algorithms-boosting-performance-up-to-9000x/" target="_blank">Our team has shown</a> that embedding quantum-control techniques into an algorithm can improve its overall success by orders of magnitude. This technique makes QEC protocols much more likely to correctly identify an error in a physical qubit.
</p><p>
	For 25 years, QEC researchers have largely focused on mathematical strategies for encoding qubits and efficiently detecting errors in the encoded sets. Only recently have investigators begun to address the thorny question of how best to implement the full QEC feedback loop in real hardware. And while many areas of QEC technology are ripe for improvement, there is also growing awareness in the community that radical new approaches might be possible by marrying QEC and control theory. One way or another, this approach will turn quantum computing into a reality—and you can carve that in stone. 
	<span></span></p><p><em>This article appears in the July 2022 print issue as “Quantum Error Correction at the Threshold.”</em></p></template></div></div>
  </body>
</html>
