<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://twitter.com/atpCountry/status/1493103408462454787">Original</a>
    <h1>Facebook Messenger blocks messages containing “di.wang”</h1>
    
    <div id="readability-page-1" class="page"><div><p><time datetime="2022-02-12 12:07:03 -0500 EST">2022-02-12</time>
|
tags: [ <a href="https://aos.github.io/tags/nix">nix</a> <a href="https://aos.github.io/tags/rust">rust</a> <a href="https://aos.github.io/tags/embedded">embedded</a> ]</p></div><div><p>Over the last year, I’ve been learning Rust and diving into the ecosystem. I’ve
been exploring the Rust embedded development space and recently acquired a
<a href="https://microbit.org/">micro:bit board</a> with the intention of following the
<a href="https://docs.rust-embedded.org/discovery/">Rust Discovery Book</a>. And while I
have experience with embedded at my current job, especially with the STM32
series of boards, it’s all in C/C++.</p><p>One of the hardest parts of embedded I’ve found coming from a
background in web is getting a development environment up and running,
especially one that allows for quick iteration.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> There is a lot of promise
for this in Rust with tooling such as <a href="https://github.com/probe-rs/probe-rs"><code>probe-rs</code></a>.</p><p>At the same time, I wanted to explore <a href="https://nixos.org/">Nix</a> and see if I
can I can put together a <code>nix-shell</code> that covers all the requirements for the
Discovery book, making it simple to get up and running. Below you will
find my journey and thoughts. (If you’d just like the solution, skip down to
<a href="#using-overlays"># Using overlays</a>.)</p><h3 id="tool-requirements">Tool requirements</h3><p>The original tool requirements in the Discovery book are:</p><ul><li>Rust &gt;= 1.53.0</li><li><code>gdb-multiarch</code></li><li><code>cargo-binutils</code> &gt;= 0.3.3</li><li><code>cargo-embed</code> &gt;= 0.11.0</li><li><code>minicom</code> (but we’ll use <code>picocom</code> because of preference)</li></ul><p>Since we’ll be cross-compiling, we’ll just create the
<a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file"><code>rust-toolchain.toml</code></a>
file with the Rust version and additional components we need:</p><div><pre><code data-lang="toml"><span># rust-toolchain.toml</span>
[toolchain]
channel = <span>&#34;1.53&#34;</span>
components = [ <span>&#34;rust-src&#34;</span>, <span>&#34;llvm-tools-preview&#34;</span> ]
targets = [ <span>&#34;thumbv7em-none-eabihf&#34;</span> ]
</code></pre></div><p>Using these requirements, let’s go about creating an environment with <code>nix-shell</code>.</p><h3 id="first-pass">First pass</h3><p>My first thought was, I already have Rust, can I just bring in <code>gdb-multiarch</code>
and <code>picocom</code> to get this working? Our first pass at a <code>shell.nix</code>:</p><div><pre><code data-lang="nix"><span># shell.nix</span>
<span>let</span>
  pkgs = <span>import</span> <span>&lt;nixpkgs&gt;</span> {};
<span>in</span>
<span>with</span> pkgs;
mkShell {
  buildInputs = [
    gdb
    picocom
    udev pkg-config <span># this is needed by cargo-embed</span>
  ];
}
</code></pre></div><p>After manually installing <code>cargo-embed</code> and <code>cargo-binutils</code>, then pulling
in some additional packages because of installation errors, we should be in
business. Following the instructions, we’ll now flash the board:</p><div><pre><code data-lang="shell">$ cargo embed --features v2 --target thumbv7em-none-eabihf
</code></pre></div><p>And… we get this error:</p><pre><code>error: build failed
error: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.33&#39; not found (required by /home/vagrant/discovery/microbit/target/debug/deps/libcortex_m_rt_macros-7e316e67fc081064.so)
   --&gt; /home/vagrant/.cargo/registry/src/github.com-1ecc6299db9ec823/cortex-m-rt-0.7.1/src/lib.rs:431:1
    |
431 | extern crate cortex_m_rt_macros as macros;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error

       Error Failed to run cargo build: exit code = Some(101).
</code></pre><p>Hmm… it’s attempting to use the local version of <code>libc</code>. Checking the output
of <code>ldd</code>:</p><pre><code>$ ldd /home/vagrant/discovery/microbit/target/debug/deps/libcortex_m_rt_macros-7e316e67fc081064.so
        linux-vdso.so.1 (0x00007f29aeae6000)
        libgcc_s.so.1 =&gt; /nix/store/s9qbqh7gzacs7h68b2jfmn9l6q4jwfjz-glibc-2.33-59/lib/libgcc_s.so.1 (0x00007f29ae43f000)
        libpthread.so.0 =&gt; /nix/store/s9qbqh7gzacs7h68b2jfmn9l6q4jwfjz-glibc-2.33-59/lib/libpthread.so.0 (0x00007f29ae41f000)
        libdl.so.2 =&gt; /nix/store/s9qbqh7gzacs7h68b2jfmn9l6q4jwfjz-glibc-2.33-59/lib/libdl.so.2 (0x00007f29ae41a000)
        libc.so.6 =&gt; /nix/store/s9qbqh7gzacs7h68b2jfmn9l6q4jwfjz-glibc-2.33-59/lib/libc.so.6 (0x00007f29ae255000)
        /nix/store/s9qbqh7gzacs7h68b2jfmn9l6q4jwfjz-glibc-2.33-59/lib64/ld-linux-x86-64.so.2 (0x00007f29aeae8000)
</code></pre><p>It turns out <code>rustc</code> <a href="https://github.com/rust-lang/rust/blob/1597728ef5820d3ffcb9d3f0c890ef7802398751/compiler/rustc_target/src/lib.rs#L68-L74">hardcodes the search
path</a> where it expects libraries to be located. There is a mismatch with what <code>rustc</code>
expects versus what is actually linked.</p><p>After going down the rabbit hole, it looks like the <code>nixpkgs</code> version of Rust
fixes this problem by <a href="https://github.com/NixOS/nixpkgs/blob/ce77cbef67f6c9d218f99c37bf116389b35ebddd/pkgs/development/tools/rust/rustup/0001-dynamically-patchelf-binaries.patch">patching the location using
<code>patchelf</code></a>.</p><h3 id="second-pass">Second pass</h3><p>I’d rather not have to run <code>patchelf</code> manually on every build, so let’s just
bring in Rust through Nix. I suppose this is good for us anyway since it would
provide a more “packaged” solution, not requiring Rust be available ahead of time.</p><p>After reading the <a href="https://nixos.wiki/wiki/Rust">NixOS wiki</a>, I realized the
first solution of grabbing via <code>nixpkgs</code> won’t work for us since we’d like a
specific version and a non-standard compilation target. Doing more searching I
found <a href="https://github.com/nix-community/fenix">fenix</a>.</p><p>Taking a second pass at <code>shell.nix</code> using <code>fenix</code>:</p><div><pre><code data-lang="nix"><span>let</span>
  pkgs = <span>import</span> <span>&lt;nixpkgs&gt;</span> {};
  fenix = <span>import</span> (<span>fetchTarball</span> <span>&#34;https://github.com/nix-community/fenix/archive/main.tar.gz&#34;</span>) {};
<span>in</span>
<span>with</span> pkgs;
mkShell {
  buildInputs = [
    (fenix.fromToolchainFile {
      dir = <span>./.</span>;
    })
    gdb
    picocom
    udev pkg-config
  ];
}
</code></pre></div><p>Attempting to run this we get a cryptic error:</p><pre><code>error: value is null while a set was expected

       at /nix/store/jx6m33r5x2rsr5rs6qy0y6wdkz0i2p5q-source/default.nix:113:14:

          112|           (filter (component: toolchain ? ${component}) (unique
          113|             (toolchain.manifest.profiles.${t.profile or &#34;default&#34;}
             |              ^
          114|               ++ t.components or [ ])))
</code></pre><p>It turns out <code>fenix</code> doesn’t (yet?) support numbered versions of Rust, and the
way to fix that was to change the <code>channel</code> to <code>stable</code> in the toolchain file.
This is generally not a big deal, but I would definitely like more control over
the version of Rust I’m running, especially if I’m following a book.</p><p>Additionally, it looks like <code>fenix</code> only supports the <code>rust-std</code> component
for my particular target. But we also need <code>rust-src</code> to get <code>rust-analyzer</code>
up and running.</p><h3 id="using-overlays">Using overlays</h3><p>To get it working I had to use a different method to bring in Rust. This method
uses <a href="https://nixos.wiki/wiki/Overlays">overlays</a>. Essentially, an overlay
overrides and extends the default <code>nixpkgs</code>. This particular overlay extends
the supported Rust versions and toolchains by quite a bit. Here’s what our
<code>shell.nix</code> looks like now:</p><div><pre><code data-lang="nix"><span>let</span>
  rust_overlay = <span>import</span> (<span>builtins</span>.<span>fetchTarball</span> <span>&#34;https://github.com/oxalica/rust-overlay/archive/master.tar.gz&#34;</span>);
  pkgs = <span>import</span> <span>&lt;nixpkgs&gt;</span> { overlays = [ rust_overlay ]; };
<span>in</span>
<span>with</span> pkgs;
mkShell {
  buildInputs = [
    gdb
    picocom
    udev pkg-config
    (rust-bin.fromRustupToolchainFile <span>./rust-toolchain.toml</span>)
  ];
}
</code></pre></div><p>I am able to flash my board and get the example programs working. One thing
that is still manual is having to install <code>cargo-embed</code> and <code>cargo-binutils</code>
the first time the shell is instantiated. This can be automated with a
<code>shellHook</code> that idempotentally checks and installs them.</p><h3 id="final-thoughts">Final thoughts</h3><p>This turned out to be a fun dive into learning how to get a Rust
environment up and running for embedded development. Additionally, this was a
great introduction to Nix, I was able to use it in somewhat limited scope,
using only <code>nix-shell</code>. When I was wanting to learn it a few months back, I
didn’t have an idea of where to start, and going all-in installing NixOS seemed
daunting. Now I have a decent understanding of how it works, and I can start to
delve deeper.</p><section role="doc-endnotes"><hr/><ol><li id="fn:1" role="doc-endnote"><p>I suspect this may be one of the reasons why embedded is more “niche”
compared to web development. <a href="#fnref:1" role="doc-backlink">↩︎</a></p></li></ol></section></div></div>
  </body>
</html>
