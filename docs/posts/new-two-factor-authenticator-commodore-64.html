<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://oldvcr.blogspot.com/2022/11/meet-your-new-two-factor-authenticator.html">Original</a>
    <h1>New two-factor authenticator: Commodore 64</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-402980460084879897" itemprop="description articleBody"><p>
Multi-factor authentication is ripe for disruption. SMS 2FA is inherently defective. Phone authenticators get stolen. Security tokens get lost.
</p><p>
But just try misplacing <a href="https://reserialised.routley.io/2020/12/unboxing-best-gift-of-1983-commodore-sx.html">a Commodore SX-64</a>. And any thief who tries to grab it and run gets a free hernia truss from the prison infirmary:

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgI9SvKD7XJWrhN90i81Ddm2zkNMK2MbcsOfpDdrfoc9Nt6ak6R01Uznt536M_9nyK4UjN0Q9X3QGSyiT6d3ngEnDb9Q9GS7PJToXQ77B3EqV0WOoLbGp8sBGcTiiSUu8sQz8X0DeV1Y-ZOarxTgW97wdFShdVG3JogRNGRIJh5NZFRkfxAxmn1agK2/s4080/IMG_20221111_093812_HDR.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgI9SvKD7XJWrhN90i81Ddm2zkNMK2MbcsOfpDdrfoc9Nt6ak6R01Uznt536M_9nyK4UjN0Q9X3QGSyiT6d3ngEnDb9Q9GS7PJToXQ77B3EqV0WOoLbGp8sBGcTiiSUu8sQz8X0DeV1Y-ZOarxTgW97wdFShdVG3JogRNGRIJh5NZFRkfxAxmn1agK2/s320/IMG_20221111_093812_HDR.jpg" width="320"/></a></p><p>

Plus, I&#39;ve got a colour for every key!

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjaJCPbewvI5QePkbuRcePu2zEGAvcQ2w54Aku8C8NEmvHp9IOgjIgnoZ-wcctp3zthjjWUpkHxXzdjOyhnqqcLlVSFVtuuZOrPL_9xrnxtwhxee8U0J1m9NJfi9QAHrNMucyG7kUfbLb7BQbXp1R4M8WLmq1e2FS-AFlTws2TB3csytNuc5xneUKW1/s4080/IMG_20221111_094504_HDR.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjaJCPbewvI5QePkbuRcePu2zEGAvcQ2w54Aku8C8NEmvHp9IOgjIgnoZ-wcctp3zthjjWUpkHxXzdjOyhnqqcLlVSFVtuuZOrPL_9xrnxtwhxee8U0J1m9NJfi9QAHrNMucyG7kUfbLb7BQbXp1R4M8WLmq1e2FS-AFlTws2TB3csytNuc5xneUKW1/s320/IMG_20221111_094504_HDR.jpg" width="320"/></a></p><p>

And it actually works:

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjWoMKa_Z1muo_dzxKlxcQhdP25MOVyfwQi4Yva81mtIaX5nBcjJRofDhXnw-P923QhP6LCMf9twJmce47qoKKvjpzRXSWoweSHQj20ifC9WDTGQsF7buJRzmBkpaHsEPVo07AYtcqbIWpOSsa5KHvcf8dvIoF77eQSqZPyEdvxze4ROpSz9yJFmrJZ/s688/totp-c64.png"><img alt="" data-original-height="447" data-original-width="688" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjWoMKa_Z1muo_dzxKlxcQhdP25MOVyfwQi4Yva81mtIaX5nBcjJRofDhXnw-P923QhP6LCMf9twJmce47qoKKvjpzRXSWoweSHQj20ifC9WDTGQsF7buJRzmBkpaHsEPVo07AYtcqbIWpOSsa5KHvcf8dvIoF77eQSqZPyEdvxze4ROpSz9yJFmrJZ/s320/totp-c64.png" width="320"/></a></p><p>

The terminal window is showing a generated time-based one-time password for a full key, and the emulated 64 is showing the correct key, at the correct time, which was known and tested to be valid. Yes, <a href="https://crypto.stackexchange.com/questions/61501/could-a-6502-cpu-safely-compute-a-sha-1-hash-in-a-reasonable-length-of-time">you really can</a> use your Commodore 64 for multi-factor authentication to generate TOTP codes!
</p><p>
Keys can be entered manually in hexadecimal or loaded as binary files from disk (you specify the file, offset and length), and it can either use the real-time clock in CMD FD and HD devices or with <a href="http://commodore128.mirkosoft.sk/miscellaneous.html">devices implementing a compatible <tt>T-RA</tt> command</a> or you can just manually enter the time for demonstration.
</p><p>
Some of you are asking already if this idea is <em>totally</em> nuts or just mostly. But consider: the C64 has a very small attack surface and it can be made completely airgapped. Keys can be entered manually, or stored as binary files which you have to know the file, offset and length to correctly use (unless you make the entire file the key). Heck, you have to even know what <em>disk</em> (or cassette tape?) it&#39;s on. Plus, anything fun is always a satisfactory justification!
</p><p>
Additionally, this project poses some special technological challenges on a constrained system with an 8-bit ALU that doesn&#39;t have hardware multiply or divide, and this blog is all about conquering technological challenges on constrained hardware. Here&#39;s what we have to write to make this work, direct from <a href="https://www.rfc-editor.org/rfc/rfc6238">RFC 6238</a>:

</p><ul>
<li>A <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 hasher</a>
</li><li>An <a href="https://en.wikipedia.org/wiki/HMAC">HMAC generator</a> using that hasher (TOTP is HMAC-SHA-1 a la <a href="https://www.rfc-editor.org/rfc/rfc2104">RFC 2104</a>, which is still considered secure despite SHA-1&#39;s issues as a hash algorithm by itself because HMAC is substantially less affected by the risk of collision in the underlying hash)
</li><li>Conversion of a real-time clock source into Unix time, adjusting for local timezone
</li><li>Extraction of a target value from the resulting HMAC, especially its last six digits (basically computing <tt>mod 1000000</tt>)
</li></ul><p>

And we&#39;re gonna do all that on an MOS 6510 running at just over 1MHz! (Or, on PAL systems, even less!)
</p><p>
First, before we talk about it, try it out yourself in VICE or on a real Commodore 64 (or 128 in 64 mode) to convince yourself it works. A note about keys: keys should be provided in hexadecimal or as binary data, not base 40. If you have a base 40 key, you can convert it to hex with this short Perl program (pass your base 40 key on standard input; some test vectors are in the <tt>__DATA__</tt> section, but don&#39;t forget that last blank line if you want to use them):
</p><div><pre>#!/usr/bin/perl

@digots = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 2 3 4 5 6 7);
%digits = map { $_, $i++ } @digots;
while(&lt;&gt;) {
        chomp;
        s/\s+//g;
        exit if (!length || length($_) &amp; 1);

        s/\=+$//;
        if (length($_) &amp; 2) {
                # 2 base 32 characters equals 2.5 base 16 characters,
                # which we null-pad with A&#39;s. this works enough for totp.
                $_ .= &#34;AA&#34;;
        }

        $_ = uc($_);
        # 4 base 32 characters equal 5 base 16 characters.
        foreach $group (unpack(&#34;(A4)*&#34;, $_)) {
                $sum = 0;
                foreach $char (split(&#39;&#39;, $group)) {
                        exit if (!defined($digits{$char}));
                        $sum &lt;&lt;= 5;
                        $sum |= $digits{$char};
                }
                printf(&#34;%05x&#34;, $sum &amp; 0xfffff);
        }
        print &#34;\n&#34;;
}

__DATA__
GEZD GNBV GY3T QOJQ GEZD GNBV GY3T QOJQ
3132333435363738393031323334353637383930
3D4C QYE6 B5AF N6CS 4TE5 OVQF BGPU QPRA
d8f828609e0f4056f852e4c9d75605099f483e20
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
0000000000000000000000000000000000000000
7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
f800000000000000000000000000000000000000

</pre></div>
<p>
Continuing on with your key:

</p><ul>
<li>Optionally, create a key on a disk (the key must be binary data, not ASCII hexadecimal: a key of <tt>0102</tt> should consist of a file containing bytes <tt>0x01</tt> and <tt>0x02</tt>). You can pad it with data because you can provide the program with an offset and length of the actual key.
<p>
Parenthetically, I suppose you could put the key on a cassette tape and read it from a Datasette. I haven&#39;t tried this but I have tried very hard to stay out of areas the Kernal tape routines use, so hopefully it should work. You would need to modify the program to not check for the file&#39;s existence and query the error channel though.
</p></li><li>Optionally, if you&#39;re using VICE, you can emulate a CMD FD or HD to provide the real-time clock. VICE <a href="https://vice-emu.sourceforge.io/vice_4.html#SEC26">does not provide this ROM</a> by default. Once you have the appropriate ROM (I emulate an FD-2000), before loading TOTP-C64 create a blank disk image for it and make sure the image is loaded into the emulated drive, then reset the drive once. If you don&#39;t do this little dance when you fire up VICE, the RTC may not respond correctly. VICE syncs the clock to the host system time for you.
</li><li>Download it from <a href="https://github.com/classilla/totp-c64/releases">the Releases tab</a> of <a href="https://github.com/classilla/totp-c64">the Github project</a>. It&#39;s a single <tt>PRG</tt> you <tt>LOAD</tt> and <tt>RUN</tt> like a BASIC program — in fact, the menu actually <em>is</em> a BASIC program — so do that (e.g., <tt>LOAD&#34;TOTP&#34;,8</tt> and <tt>RUN</tt>, substituting filename and device). There will be a brief pause while it decompresses and unpacks its components.
</li><li>If you created an on-disk key, press L to load it, insert your disk or disk image if not already done, then specify the filename, device, filetype (anything but a RELative file), offset (can be zero) and length (if zero, loads the whole rest of the file or 64 bytes of it, whichever is less). If you didn&#39;t, press E to enter one, and type the hexadecimal key (lowercase, no spaces, maximum 128 characters). This key will not be saved to disk. You can just enter a couple random bytes if all you want to do is play with the program.
</li><li>After the key is loaded, you can press F1 if you messed up and want to redo, or press C to get time data from a CMD or compatible device that implements <tt>T-RA</tt>, or E to enter the time manually.
<ul>
<li>If you pressed C, it will ask you to enter the device to load the time from, which doesn&#39;t have to be the device you loaded your key from (if any). The menu will try to query it and display the response. If the response is garbage and you&#39;re trying to emulate a CMD drive in VICE, make sure an image is mounted and reset the drive once more, and try again (but if you get a syntax error from the device, then it doesn&#39;t support this feature and you should try something else). Once a valid response is received, enter your time zone relative to UTC, first hours (possibly negative), and then minutes at the prompt after. For example, Pacific standard time (PST) is -0800, so enter -8 hours and 0 minutes; Australian eastern daylight time (AEDT) is +1100, so enter 11 hours and 0 minutes; Australian central standard time (ACST) is +930, so enter 9 hours and then 30 minutes.
</li><li>If you pressed E, it will ask you for your timezone first (enter it the same way as in the part above), then the current month, day, and year (only 2000 and later are supported; 2 digit years will have 2000 added), then the current time as hours (in 24 hour notation: midnight = 0, 8am = 8, noon = 12, 8pm = 20), minutes and seconds. <em>Enter the time about 10 or 15 seconds ahead.</em> The program will then pause for a key. When the clock matches the time you&#39;ve entered, press any key other than F1, or press F1 if you did it wrong to re-enter the time. You could just enter a random time here if all you want to do is play with the program.
</li></ul>
</li><li>The TOTP display will appear with the current 6 digit code in the centre of the screen and a progress bar below it. This bar fills with a different colour every 30 second interval, after which a new code is generated. The display continues until you press F1 to stop. This will halt the display and run the program from the beginning starting with acquiring a key.  
</li></ul><p>

The TOTP display depends on the Time-of-Day clock in CIA #1. This is different from the Timer A jiffy clock accessible in BASIC as </p><tt>TI</tt><p> and </p><tt>TI$</tt><p>; the CIA TOD clock is a real clock that keeps time in BCD and uses either the 60Hz or 50Hz frequency from your wall mains. We use this clock because it is unaffected by interrupts. If the progress bar fails to advance, your CIA #1 is broken, and/or the 9V AC line from your power supply is defective, and/or the 2.7V Zener diode and/or glue chip (on breadbin 64s, a 74LS08 or similar, on 128s, a 74LS14) connected to the TOD pin of the CIAs have blown. If everything else with your system functions normally, then it&#39;s likely the latter two components since relatively few programs use the TOD clock but do use other CIA features. On a breadbox 64, check U27 and CR1. On a 128 or 128D(CR), check U16 and CR8; on the 128D(CR), CR8 is inconveniently under the power supply at the edge of the logic board, so you&#39;ll have to unscrew it from its standoff and the rear and side of the case to move it away. (I mention this because during testing it turned out my &#34;daily driver&#34; 128DCR has a faulty TOD clock. Fixing this will be a future blog entry. Fortunately both VICE and the SX-64 worked fine.)
</p><p>
<a href="https://github.com/classilla/totp-c64">The source code</a> is also on Github (released under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD 3-clause license</a>). There are two main parts to TOTP-C64, <a href="https://github.com/classilla/totp-c64/blob/main/main.bas">the BASIC section</a> that provides the menu to read and accept user settings (which provided the prompts you interacted with), and then the main assembly language portion which actually does the heavy computations and maintains the code display. This is divided into three modules, <a href="https://github.com/classilla/totp-c64/blob/main/sha1.xa">the SHA-1 hasher</a>, <a href="https://github.com/classilla/totp-c64/blob/main/time.xa">the time computer</a>, and <a href="https://github.com/classilla/totp-c64/blob/main/totp.xa">the actual main loop</a> that calls those modules for the time and computes the HMAC, displays the digits and maintains the clock until you stop it.
</p><p>
The code display is very simple, just a bar of reversed spaces with six big sprites for the digits and a padlock sprite for decoration. The 16x32 sprites are created by vertically stretching the number character glyphs from the built-in character ROM to double height (yielding an 8x16 digit) and then having the VIC-II&#39;s hardware double-size each digit sprite again in both dimensions. The colour that fills the progress bar is computed off the least-significant byte of the clock counter value. Those are all pretty straightforward.
</p><p>
The rest of it is where the meat is. When you&#39;re writing code for a constrained platform that requires heavyweight computation, what&#39;s at least as important as using good algorithms is <em>finding good shortcuts</em>. You simply want to do the minimum amount of work possible. Sometimes this is done by merely remembering old work steps; sometimes this requires putting steps out of order; sometimes this is done by changing an algorithm entirely. Particularly for the last two a compiler will only get you so far, which is why I wrote the critical sections entirely in 6502 assembly language.
</p><p>
The first part of the code that I wrote was the SHA-1 hash implementation, since without that (or without being able to do it quickly) there was no point in writing anything else. Perhaps unsurprisingly, there&#39;s some prior art here: a cursory Google search turned up several 6502-based cryptographic hash projects, such as this <a href="https://imapenguin.com/finding-hash-collisions/">Commodore 64 SHA-256 implementation</a>, also in 100% assembly, <a href="https://bumbershootsoft.wordpress.com/2019/04/24/implementing-sha-256-on-the-6502/">another one</a> in assembly, an actual <a href="https://csdb.dk/release/?id=132056">Commodore 64 SHA-256 file checksum</a> also presumably in assembly, and an <a href="https://github.com/hobnobber/cc65sha1">Atari SHA-1 file checksum</a> written in C, which strikes me as <a href="https://knowyourmeme.com/photos/1311608-arrested-development">light treason</a>. I should say officially for the record that I didn&#39;t look at the source code for any of these projects and didn&#39;t use any of their work in writing this one.
</p><p>
Fortunately, SHA-1 only requires adds, subtracts, bitwise logical operations and bitwise rotations and shifts. The two big tricks here are 1) everything is 32-bit, and 2) a single error in the implementation, even just one bad bit, can completely munge the hash because of the (desirable) <a href="https://en.wikipedia.org/wiki/Avalanche_effect">avalanche effect</a>. You don&#39;t want to be able to work the hash backwards because that means it wouldn&#39;t be opaque — but also that means it&#39;s going to be harder to debug it, too.
</p><p>
To help with this I wrote <a href="https://github.com/classilla/totp-c64/blob/main/model/simuhmac.pl">a Perl model</a> emulating the eight bit operations a 6502 would have to do to compute SHA-1 and later an HMAC, and pervasively instrumented it so I could see each computational step. The code wasn&#39;t a 1:1 correspondence with what I expected to write in the assembler but it was enough to make the translation to assembly language mostly direct.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgcMgLKNFwTIF5Vio5MuzijRQ9I2Df4nyuNzFIoAUcroQl0HYDNj3vHZnyvnh8Mb1ZCJaoUywm03Soec1_aht_avw-aS5aGY2lH293m35Zrx97F9nKuzJ0DlzVI7syjeuaBEcibbzj4uxUKFqJI8NsLlheLVPJN7F-UtAtVIt2N4saWvTEuwCEfZLHn/s4080/IMG_20221006_205823.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgcMgLKNFwTIF5Vio5MuzijRQ9I2Df4nyuNzFIoAUcroQl0HYDNj3vHZnyvnh8Mb1ZCJaoUywm03Soec1_aht_avw-aS5aGY2lH293m35Zrx97F9nKuzJ0DlzVI7syjeuaBEcibbzj4uxUKFqJI8NsLlheLVPJN7F-UtAtVIt2N4saWvTEuwCEfZLHn/s320/IMG_20221006_205823.jpg" width="320"/></a></p><p>

You can see the trace of the five SHA-1 </p><tt>h</tt><p> variables (</p><tt>h0</tt><p> through </p><tt>h4</tt><p>) on both the 64&#39;s screen and in the terminal session. Each step through is printed so I could identify almost the exact spot the assembly version diverged from the Perl model. Conveniently, displaying a 160-bit hash on the 64&#39;s screen is 40 hexadecimal digits, exactly the width of a screen line. 
</p><p>
There&#39;s no great magic to a 32-bit (or 16, 24, 48, 64, etc.) operation on an 8-bit CPU; you just do it one byte at a time. I wrote up <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/sha1.xa#L37">preprocessor macros</a> for this which generate the boilerplate code for me in the <a href="http://www.floodgap.com/retrotech/xa/"><tt>xa65</tt> cross assembler</a>. For adds and subtracts, the byte-by-byte math needs to be sequential from the LSB to the MSB so that carry is propagated through. In particular you need to load and store each byte in order, so these tend to be the slowest such operations in this module. This is also true for shifts and rotates since the moved-out bit also ends up as carry, but the 6502 has some memory-memory forms of these instructions which avoid an explicit load/store (another reason the 6502 isn&#39;t truly RISC, or at least not in the way RISC is currently conceived of), which can speed a few operations up and don&#39;t require a trip through the accumulator.
</p><p>
However, for bitwise logicals like AND, OR, XOR, etc., each byte of the 32-bit result can be handled independently, and there is no carry. This means that an AND followed by an XOR, for example, can be part of the same chain: we load from memory, do the AND, do the XOR, and write it back, and do this four times total for each byte. This saves loading and storing between each logical operation and we use this a lot in the main loop (<a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/sha1.xa#L259">here&#39;s an example</a>).
</p><p>
There are also some additional shortcuts to reduce CPU overhead further:
</p><ul>
<li>The first part of SHA-1 requires extending the sixteen 32-bit words (512 bits) to be hashed into eighty 32-bit words by exclusive-ORing four indexes with constant offsets into the original 16 words. We know where everything is in memory, so we can simply have <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/sha1.xa#L151">the assembler precalculate the necessary effective addresses</a> and maintain individual pointers in zero page for them. All the code has to do is load those words, <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/sha1.xa#L162">exclusive-OR them all together</a> (and since this is a string of bitwise logical operations, we only have to load, chain-XOR, rotate and store each byte once for four words, using the Y register as the index within each 32-bit word), and then advance the pointers by four each time through. Through some parsimonious programming we can keep the loop count in the X register the entire time.
</li><li>A rotate or shift by 8 is by definition equivalent with <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/sha1.xa#L59">rotating or shifting by an entire byte</a>, so we can just load and store whole bytes offset by 1 instead of doing eight labourious single-bit moves. We exploit this for a left rotate of 5 by turning it into <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/sha1.xa#L273">a left rotate of 8 (very fast) followed by a <em>right</em> rotate of 3</a> (slightly slower than left rotates because we have to recover the carry bit at the end, but we&#39;re only doing three).
</li><li>On a 32-bit quantity, a left rotate of 30 can alternatively be <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/sha1.xa#L297">a right rotate of 2</a>.
</li><li>Because we located <tt>h0</tt> through <tt>h4</tt> <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/sha1.xa#L75">contiguously in memory</a>, the full hash (from the view of an eight-bit CPU, at least) is automagically a 160-bit quantity because their bytes are sequential. We don&#39;t need to manually concatenate anything.
</li></ul>
<p>
I certainly don&#39;t claim this to be the fastest you can do SHA-1 on the 6502, but I think it&#39;s pretty performant, considering.
</p><p>
The next necessary part was computing the time. The message for HMAC-SHA-1 is a big-endian counter value (being derived from HOTP, TOTP&#39;s count-based predecessor) computed from the current Unix time in seconds minus the Unix epoch (zero) divided by a time interval, which is usually 30 seconds. We&#39;ll need the remainder, too, because this tells us how long to wait initially before generating the second code. The RFC requires that any compliant algorithm handle at least the Y2038 problem, which most modern systems have dealt with by using a full 64-bit <tt>time_t</tt>. Already this is bad, because we&#39;re now in the position of dividing at least 32 bits and probably more by 30 (eventually I adopted a 64-bit time value to be consistent with the RFC; see below). Division by anything that&#39;s not a power of two on a system without hardware integer divide is a huge pain!
</p><p>
But wait, it gets worse. The Commodore 64 has no built-in time source, and no real-time clock presently available for it gives you Unix time: they all give you local time in a human-parseable format by seconds, minutes, hours, days, months and year. This is convenient for almost all of the things people would want a real-time clock for and incredibly <em>in</em>convenient for us — effectively we&#39;re being forced to implement something like <a href="https://linux.die.net/man/3/timegm"><tt>timegm()</tt></a> from scratch. Look at what Perl&#39;s <tt>Time::Local</tt> has to do to just compute <a href="https://metacpan.org/dist/Time-Local/source/lib/Time/Local.pm#L85">days past the Unix epoch</a> from a date: <a href="https://metacpan.org/dist/Time-Local/source/lib/Time/Local.pm#L91">fiddle with the month and year</a>, multiply the fiddled year count by 365 to get the number of days, account for leap years (a divide by 100 and a divide by 400!) and then add in the month — multiplied by 306, adding 5 and dividing by 10 — and the current date. To get from that count of days to seconds requires multiplying by <em>86,400</em>. At that point &#34;merely&#34; multiplying by 3600 for hours to seconds and 60 for minutes to seconds (and adding it all together) seems trivial by comparison. Oh, and don&#39;t forget that when we&#39;re done we&#39;ll have to divide that whole honking number by 30 to get the current counter value, <em>and</em> we need to do all this within a second or so in real-time or the clock will be behind!
</p><p>
The CMD time-string template, depending on exact implementation, is more or less <tt>DOW. MM/DD/YY HH:MM:SS XM</tt> using a 12-hour time (e.g., <tt>SAT. 11/12/22 07:57:40 PM</tt>). There are variants to give us packed BCD and byte quantities but this PETSCII string form is apparently the most widely supported. The CMD drive (at least as emulated in VICE) actually generates a three-digit year for 2000 and later (<tt>11/12/122</tt>), though that doesn&#39;t seem to be part of the spec, so we handle both ways.
</p><p>
Immediately some potential shortcuts become apparent. Subtracting 48 away from the PETSCII values of the digits, we&#39;re effectively getting the date from the CMD device <em>in decimal</em> (technically unpacked BCD). In fact, we can exploit this by trivially <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/main.bas#L59">converting the manually entered time and date into unpacked BCD</a> as well and using the same code to process it. That means dividing by 10 and 100 is just a matter of extracting the right digits; in particular, since we expand the year out to a full four digits, dividing the year by 100 just means <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/time.xa#L201">taking the top two of them</a>. (Combining a two-byte decimal number into a single byte quantity is fast: multiply the tens byte by 10, i.e., shift it twice to multiply by 4, add the original value to make it times 5, shift again to make it times 10, and add the ones. <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/time.xa#L160">We have a macro for this</a>, naturally.) To divide by 400, we just divide the &#34;divide by 100&#34; quantity by 4, which is two bit shifts. As a practical matter this means we can&#39;t handle years past 9999, but this meets the requirements of the RFC, and I apologise to any far-future users of this program in advance. Finally, the code to fiddle with the month must only account for 12 months, which practically screams at us to use a lookup table (so is dividing that resulting figure by 10, so that&#39;s another lookup table, and so is <tt>int( ( ( $month * 306 ) + 5 ) / 10 ) )</tt>).
</p><p>
Two multiplys we can&#39;t avoid, but we can turn them into shifts and adds. To turn the year into a 16-bit quantity to multiply against it, we have to <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/time.xa#L230">multiply the upper two digits by 100</a>, which decomposes into the sum of multiplying them by 4, multiplying them by 32 and multiplying them by 64, which equal 100. We add that to the lower digits to get the year as a 16-bit short. That, in turn, must be <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/time.xa#L287">multiplied by 365</a>, which decomposes into the sum of times 256, times 64, times 32, times 8, times 4 and &#34;times 1.&#34; We already have a fast path for multiplying by 256: that&#39;s a left shift of 8, so we just shift the bytes up by one byte and add the other shifts to it. We&#39;ll be summing all of this into the 64-bit time value, so we have <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/time.xa#L258">macros for adding variously sized quantities</a>. (The first way I did this as a check was adding to itself 256 times, and then adding to itself 109 times — 256 plus 109 equals 365. Similarly, I did the multiply by 100 as a 100-add loop as a verifier. I&#39;ve left this code in for comparison but it&#39;s obviously much slower.)
</p><p>
After rebasing the total number of days by subtracting the equivalent figure for the Unix epoch (which we store as a constant), we now need to make it into seconds, which confronts us with computing the sum of days times 86,400, hours times 3,600, minutes times 60 and seconds, and then dividing that sum by 30 to generate the TOTP counter and noting the remainder. But things just got brighter in a hurry, because the improvement we can make here is massive and massively obvious: we can immediately divide all the <em>constants</em> by 30 <em>up front</em>, because they&#39;re themselves integer multiples of 30, and thus eliminate the division entirely. That means we multiply days by 2,880, a much more manageable number, hours times 120 (which can be a 24-item lookup table) and minutes by 2 (now trivially a single left shift). <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/time.xa#L382">The remainder-30 can be computed</a> easily off the seconds all by itself: if greater or equal than 30, take away 30 and add one to the total, and the residual is the remainder; otherwise, the seconds itself is the remainder (think for a second why this must be true). But wait, there&#39;s more! x2880 decomposes into the sum of x2048, x512, x256 and x64. Hey, there&#39;s a x256, so we can just do a byte shift! In addition, we know that the seconds divided by 30 (1 or 0) and minutes times two (0-118) summed are less than 256, so they will fit into a single byte. We thus start off the times-2880 with the x256 shifting the 64-bit quantity by one byte, but making the lowest byte the seconds plus minutes instead of just zero, doing <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/time.xa#L394">the add and first part of the full multiply all together</a>. We then add the sums of the other shifts and <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/time.xa#L439">add hours from a times-120 lookup table</a>.
</p><p>
That leaves adjusting for UTC from localtime (Unix time is always UTC), <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/time.xa#L470">which is now straightforward</a>: multiply the hours difference from UTC with the same times-120 table and the minutes by 2, and either add or subtract them from the total. We now have Unix time divided by 30 ready to serve as a counter, plus the remainder so that we can synchronise correctly on 30-second intervals. Whew!
</p><p>
Now for the HMAC and that <tt>mod 1000000</tt>. Our SHA-1 module proceeds in &#34;chunks&#34; of 512 bits/64 bytes; it expects whatever calls it to have the buffer set up correctly. An HMAC is computed by first computing the hash of the 64-byte key XOR-ed with a repeated inner padding &#34;ipad&#34; byte (<tt>0x36</tt>) concatenated with the big-endian 64-bit counter value, a grand total of 576 bits or 72 bytes. SHA-1 requires the payload to be terminated with a single one bit and then padded out with zero bits for a bit length congruent to −64 ≡ 448 (mod 512), followed by a 64-bit big-endian length of the entire message in bits. The 160-bit result of this first hash is then concatenated to the end of the 64-bit key XOR-ed this time with an outer padding &#34;opad&#34; byte (<tt>0x5c</tt>) for a total of 672 bits or 84 bytes, and hashed a final time for the result.
</p><p>
In practical terms, we thus run four chunks through the SHA-1 module, starting with resetting the hash variables to their initial state. <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L225">The first one</a> is the full 64-byte &#34;ipad&#34; (which we precompute). We don&#39;t reset the hash variables prior to <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L236">the second chunk</a>, which is the 64-bit counter concatenated with <tt>0x80</tt> (the terminating bit), followed by 53 nulls and <tt>0x2 0x40</tt> (576 bits). We run this chunk through, copy off the hash to use in the fourth chunk, and reset the hash variables for the new hash. <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L268">The third chunk</a> is the full 64-byte &#34;opad&#34; (which we also precompute); after processing it we again don&#39;t reset the hash variables and continue to <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L279">the fourth chunk</a>, which is the 160-bit/20-byte hash from the second chunk concatenated with <tt>0x80</tt>, 41 nulls, and <tt>0x2 0xa0</tt> (672 bits). The hash value after the fourth chunk is the HMAC result.
</p><p>
The last step is to turn the HMAC into the 6-digit TOTP code, which is described in <a href="https://www.rfc-editor.org/rfc/rfc4226">RFC 4226</a>, the RFC for HOTP. A 32-bit slice is taken out of the 160-bit result based on the third byte of <tt>h4</tt> ANDed with 15; this is the index to the first of the four bytes making up the 32-bit value. The value then has its most significant bit masked off, leaving a 31-bit value. <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#302">We can do this easily</a> from the contiguous hash variables in memory. The code is that 31-bit value mod 10<sup>digits</sup>; most implementations use 6, so we have to compute that value modulo 10<sup>6</sup>, or 1000000.
</p><p>
<a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L331">The first way I did this</a> was to figure out all of the decimal digits by labouriously dividing by powers of 10 (basically brute-force repeated subtraction) and then taking the lowest six. The maximum value of an unsigned 31-bit value is representable in 10 digits, so we start with the billions place and work our way down. As the exponent gets smaller we don&#39;t need to check all 32 bits, so smaller quantities get faster. The macros for this are somewhat tortured by the need for labels for each divide step.
</p><p>
Performance wasn&#39;t abysmal but while conceptually simple I didn&#39;t find my initial approach to be particularly elegant. A better algorithm turned up, however: leverage the 6502&#39;s <a href="http://www.6502.org/tutorials/decimal_mode.html">decimal mode</a> to <a href="http://www.6502.org/source/integers/hex2dec-more.htm">turn the value into BCD</a>, and take the lower six digits of that. Credit goes to Andrew Jacobs for writing this lookup-free version of <a href="http://www.6502.org/source/integers/hex2dec.htm">Garth Wilson&#39;s original</a> (a variation on the <a href="https://en.wikipedia.org/wiki/Double_dabble">double-dabble</a> or &#34;add three&#34; method), which <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L394">I expanded from 16 bits into 32</a> and flipped around to keep everything big-endian. It works by clocking out bits and adding them (via carry) to a value that doubles each time through the loop, effectively the BCD version of double-dabble, completing after a constant 32 loops with just one add per iteration for every two digits. Much quicker! (The old repeated-subtraction version is left in for comparison. Note that interrupts have to be off to have decimal mode set on the Commodore 64 because <a href="https://reserialised.routley.io/2021/09/the-incredible-kimplement-02b-kim-1.html">the Kernal Timer A IRQ doesn&#39;t properly handle this flag</a>.) We then take the lowest six digits (three bytes) of that <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L422">and unpack them</a>. I printed each digit and compared it to a real TOTP generator, and it matched!
</p><p>
At this point all that was left was the user interface, which is the fun part. I wrote the menu program first, which is straightforward BASIC, using my own tools to tokenize the source and link it in memory into a single runnable file with the assembled machine code. I also added <a href="https://github.com/classilla/totp-c64/blob/main/lock.spr">the padlock sprite</a> for decoration and wrote a little tool to turn that into <tt>.byt</tt> pseudo-ops or <tt>DATA</tt> statements (eventually I settled on the former), and wrote the code for the <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L47">big stretch number glyphs</a>. To ensure the clock was as accurate as possible and undisturbed by changes to interrupt status (remember we have to turn them off to convert the 31-bit hash extract to BCD), I used the CIA Time-of-Day clock as an interval timer, which <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L133">needs adjustment</a> for <a href="https://codebase64.org/doku.php?id=base:efficient_tod_initialisation">50Hz or 60Hz power</a>. The TOD clock itself tracks time in BCD, so <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L192">to load the initial value</a> we convert the remainder-30 we calculated way back when into BCD too (using the 8-bit version of Andrew&#39;s algorithm, since the remainder will never be greater than 29). The TOD clock then keeps time independently. <a href="https://github.com/classilla/totp-c64/blob/0.5-fixed-dammit/totp.xa#L466">As the seconds change</a> we advance the little colourful progress bar, computed off the LSB of the counter. When the TOD clock&#39;s seconds count reaches 30 (i.e., 48, the decimal version of 30 in BCD), we reset it to zero, increment the clock counter, compute a new 6-digit code and start a new colour in the progress bar, looping repeatedly until we&#39;re stopped by the user. And that&#39;s how it all works.
</p><p>
Although I&#39;m not accepting major refactors or tuneups or ports to other systems, I do intend to add more support for additional real-time clock devices and will consider pull requests related to that. (The one I&#39;m hoping to do is for the RTC in the Ultimate-II+, but mine is still on backorder.) Otherwise, please only report verifiably incorrect behaviour; I consider this project largely feature complete. Feel free to fork it and port it to your favourite system. If you want to build the source yourself, you&#39;ll need:

</p><ul>
<li>the <a href="http://www.floodgap.com/retrotech/xa/"><tt>xa65</tt> cross assembler</a>, which is highly portable and runs on many systems
</li><li>Perl 5.005 or better to run the tokenizer, linker and sprite builder scripts (included in <tt>tools/</tt>, you don&#39;t need to install them)
</li><li><a href="http://a1bert.kapsi.fi/Dev/pucrunch/"><tt>pucrunch</tt></a> to make a runnable compressed version of the resulting linked executable (reduces the size by about half). This is technically optional: if you don&#39;t have <tt>pucrunch</tt>, the build will err out at this point, leaving a <tt>totp.arc</tt> file in the current directory as the product from the linking step. That file is itself a runnable program and fully useable, just not compressed.
</li></ul><p>

Adjust </p><tt>OBJ</tt><p> in the </p><tt>Makefile</tt><p> to your desired target if necessary (it&#39;s set to </p><tt>../prgs/totp</tt><p> for my convenience with VICE) and then </p><tt>make</tt><p> to build all the pieces, link and crunch them. If you alter the assembly code, you may need to change the offsets in the BASIC portion or the menu will crash trying to initialize keys and/or run the TOTP display loop. These addresses are displayed as part of the build output and comments in the BASIC portion will tell you what needs to match up.
</p><p>
You can also use the time and SHA-1 modules in your own projects by building them as objects and linking them, or simply <tt>#include</tt>ing them in your assembly source. They have copious comments to explain their function and how to call them, and other than the pre-processor macros the meaty parts are encapsulated with <tt>xa</tt>&#39;s <tt>.( .)</tt> pseudo-ops to keep the labels from clashing with your own code&#39;s. Only &#34;exported&#34; labels are outwardly visible. 
</p><p>
Now, if you&#39;ll excuse me, I need to log in and do a few things. Just gotta wait for the 1541 to finish loading so I can enter the 2FA code. See you in a bit.
</p>
</div></div>
  </body>
</html>
