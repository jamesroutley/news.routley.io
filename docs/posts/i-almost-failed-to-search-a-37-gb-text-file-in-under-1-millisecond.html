<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://death.andgravity.com/pwned">Original</a>
    <h1>I almost failed to search a 37 GB text file in under 1 millisecond</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>

<p>So, there&#39;s this website, <a href="https://haveibeenpwned.com/">Have I Been Pwned</a>,
where you can check if your email address has appeared in a data breach.</p>
<p>There&#39;s also a <a href="https://haveibeenpwned.com/Passwords">Pwned Passwords</a> section for passwords
... but, typing your password on a random website
probably isn&#39;t such a great idea, right?</p>
<p>Of course, you could
read about <a href="https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/">how HIBP protects the privacy of searched passwords</a>,
and understand how <a href="https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/#cloudflareprivacyandkanonymity">k-Anonymity</a> works,
and check that the website uses the <a href="https://haveibeenpwned.com/API/v3#PwnedPasswords">k-Anonymity API</a>,
but that&#39;s waaay too much work.</p>
<p>Of course, you could use the API yourself,
but where&#39;s the fun in that?</p>
<p>Instead, we&#39;ll do it the hard way –
we&#39;ll check passwords <strong>offline</strong>.</p>
<p>And we&#39;re not stopping until it&#39;s <strong>fast</strong>.</p>
<section>
<ul>
<li><a href="#the-pwned-passwords-list">The Pwned Passwords list</a></li>
<li><a href="#a-minimal-plausible-solution">A minimal plausible solution</a></li>
<li><a href="#problem-it-s-slow">Problem: it&#39;s slow</a>
<ul>
<li><a href="#skipping">Skipping</a></li>
</ul>
</li>
<li><a href="#problem-it-needs-tuning-it-s-still-slow">Problem: it needs tuning, it&#39;s still slow</a>
<ul>
<li><a href="#binary-skipping">Binary skipping</a></li>
<li><a href="#better-timing">Better timing</a></li>
</ul>
</li>
<li><a href="#failing-to-get-to-under-1-millisecond">Failing to get to under 1 millisecond</a>
<ul>
<li><a href="#profile-before-optimizing-profile">Profile before optimizing</a></li>
<li><a href="#position-heuristic">Position heuristic</a></li>
<li><a href="#index-file">Index file</a></li>
<li><a href="#binary-file">Binary file</a></li>
</ul>
</li>
<li><a href="#getting-to-under-1-millisecond">Getting to under 1 millisecond</a>
<ul>
<li><a href="#generating-the-index">Generating the index</a></li>
<li><a href="#using-the-index">Using the index</a></li>
<li><a href="#i-heard-you-like-indexes-the-end">I heard you like indexes (the end)</a></li>
</ul>
</li>
<li><a href="#bonus-better-data-structures">Bonus: better data structures</a></li>
</ul>
</section>
<h2 id="the-pwned-passwords-list">The Pwned Passwords list</h2>
<p>OK, first we need the password list.</p>
<p>Go to <a href="https://haveibeenpwned.com/Passwords">Pwned Passwords</a>,
scroll to <em>Downloading the Pwned Passwords list</em>,
and download the SHA-1 ordered-by-hash file –
be nice and use the torrent, if you can.</p>
<section>
<p>Note</p>
<p>You can also use the <a href="https://www.troyhunt.com/downloading-pwned-passwords-hashes-with-the-hibp-downloader/">downloader</a> to get an updated version of the file,
 but that didn&#39;t exist when I started writing this.</p>
</section>
<p>The archive extracts to a 37 GB text file:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span><span>pushd</span> ~/Downloads
<span>$ </span>stat -f %z pwned-passwords-sha1-ordered-by-hash-v8.7z
<span>16257755606</span>
<span>$ </span>7zz e pwned-passwords-sha1-ordered-by-hash-v8.7z
<span>$ </span>stat -f %z pwned-passwords-sha1-ordered-by-hash-v8.txt
<span>37342268646</span>
<span>$ </span><span>popd</span>
</code></pre></div>
<p>... that looks like this:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>head -n5 ~/Downloads/pwned-passwords-sha1-ordered-by-hash-v8.txt
<span>000000005AD76BD555C1D6D771DE417A4B87E4B4:10</span>
<span>00000000A8DAE4228F821FB418F59826079BF368:4</span>
<span>00000000DD7F2A1C68A35673713783CA390C9E93:873</span>
<span>00000001E225B908BAC31C56DB04D892E47536E0:6</span>
<span>00000006BAB7FC3113AA73DE3589630FC08218E7:3</span>
</code></pre></div>
<p>Each line has the format:</p>
<pre><code>&lt;SHA-1 of the password&gt;:&lt;times it appeared in various breaches&gt;
</code></pre>
<section>
<p>Note</p>
<p>For more details:
 <a href="https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/#theyrestillsha1hashedbutwithsomejunkremoved">why hash the passwords</a>, and
 <a href="https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/#eachpasswordnowhasacountnexttoit">why include a count</a>.</p>
</section>
<p>To make commands shorter, we link the file in the current directory:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>ln -s ~/Downloads/pwned-passwords-sha1-ordered-by-hash-v8.txt pwned.txt
</code></pre></div>
<h2 id="a-minimal-plausible-solution">A minimal plausible solution</h2>
<p>We&#39;ll take an iterative, <a href="https://hintjens.gitbooks.io/scalable-c/content/chapter1.html#problem-what-do-we-do-next">problem-solution</a> approach to this.
But since right now we don&#39;t have <em>any</em> solution,
we start with <a href="https://wiki.c2.com/?DoTheSimplestThingThatCouldPossiblyWork">the simplest thing that could possibly work</a>.</p>
<!-- ## Imports -->
<p>First, we get the imports out of the way:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>import</span> <span>os</span>
<span>import</span> <span>sys</span>
<span>import</span> <span>time</span>
<span>import</span> <span>getpass</span>
<span>import</span> <span>hashlib</span>
</code></pre></div>
</td></tr></tbody></table>
<!-- ## File -->
<p>Then, we open the file:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>path</span> <span>=</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>]</span>
<span>file</span> <span>=</span> <span>open</span><span>(</span><span>path</span><span>,</span> <span>&#39;rb&#39;</span><span>)</span>
</code></pre></div>
</td></tr></tbody></table>
<p>Opening the file in binary mode makes searching a bit faster,
as it skips needless decoding.
By opening it early,
we get free error checking
– no point in reading the password if the file isn&#39;t there.</p>
<!-- ## Password -->
<p>Next, the password:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>try</span><span>:</span>
    <span>password</span> <span>=</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>2</span><span>]</span>
<span>except</span> <span>IndexError</span><span>:</span>
    <span>password</span> <span>=</span> <span>getpass</span><span>.</span><span>getpass</span><span>()</span>
<span>hexdigest</span> <span>=</span> <span>hashlib</span><span>.</span><span>sha1</span><span>(</span><span>password</span><span>.</span><span>encode</span><span>())</span><span>.</span><span>hexdigest</span><span>()</span>
<span>del</span> <span>password</span>

<span>print</span><span>(</span><span>&#34;looking for&#34;</span><span>,</span> <span>hexdigest</span><span>)</span>
</code></pre></div>
</td></tr></tbody></table>
<p>We either take the password as the second argument to the script,
or read it with <a href="https://docs.python.org/3/library/getpass.html#getpass.getpass">getpass()</a>,
so real passwords don&#39;t remain in the shell history.
After computing its hash, we delete it;
we don&#39;t go as far as to <a href="https://en.wikipedia.org/wiki/Zeroisation#Software">zero</a>‍ it,
but at least we avoid accidental printing.</p>
<p>Let&#39;s see if it works:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python pwned.py pwned.txt password
<span>looking for 5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8</span>
<span>$ </span>python pwned.py pwned.txt
<span>Password:</span>
<span>looking for 5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8</span>
</code></pre></div>
<p><code>sha1sum</code> seems to agree:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span><span>echo</span> -n password <span>|</span> sha1sum
<span>5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8  -</span>
</code></pre></div>
<!-- ## Finding the hash -->
<p>To find the hash, we go through the file line by line –
remember, simplest thing that could possibly work.</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>def</span> <span>find_line</span><span>(</span><span>lines</span><span>,</span> <span>prefix</span><span>):</span>
    <span>for</span> <span>line</span> <span>in</span> <span>lines</span><span>:</span>
        <span>if</span> <span>line</span><span>.</span><span>startswith</span><span>(</span><span>prefix</span><span>):</span>
            <span>return</span> <span>line</span>
        <span>if</span> <span>line</span> <span>&gt;</span> <span>prefix</span><span>:</span>
            <span>break</span>
    <span>return</span> <span>None</span>
</code></pre></div>
</td></tr></tbody></table>
<p>If a line was found, we print the count:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>line</span> <span>=</span> <span>find_line</span><span>(</span><span>file</span><span>,</span> <span>hexdigest</span><span>.</span><span>upper</span><span>()</span><span>.</span><span>encode</span><span>())</span>

<span>if</span> <span>line</span><span>:</span>
    <span>times</span> <span>=</span> <span>int</span><span>(</span><span>line</span><span>.</span><span>decode</span><span>()</span><span>.</span><span>rstrip</span><span>()</span><span>.</span><span>partition</span><span>(</span><span>&#39;:&#39;</span><span>)[</span><span>2</span><span>])</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;pwned! seen </span><span>{</span><span>times</span><span>:</span><span>,</span><span>}</span><span> times before&#34;</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;not found&#34;</span><span>)</span>
</code></pre></div>
</td></tr></tbody></table>
<!-- ## Timing stuff -->
<p>Finally, let&#39;s add some timing code:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>start</span> <span>=</span> <span>time</span><span>.</span><span>monotonic</span><span>()</span>
<span>line</span> <span>=</span> <span>find_line</span><span>(</span><span>file</span><span>,</span> <span>hexdigest</span><span>.</span><span>upper</span><span>()</span><span>.</span><span>encode</span><span>())</span>
<span>end</span> <span>=</span> <span>time</span><span>.</span><span>monotonic</span><span>()</span>
</code></pre></div>
</td></tr></tbody></table>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>print</span><span>(</span><span>f</span><span>&#34;in </span><span>{</span><span>end</span><span>-</span><span>start</span><span>:</span><span>.6f</span><span>}</span><span> seconds&#34;</span><span>)</span>
</code></pre></div>
</td></tr></tbody></table>
<p>And, it works:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python pwned.py pwned.txt blocking
<span>looking for 000085013a02852372159cb94101b99ccaec59e1</span>
<span>pwned! seen 587 times before</span>
<span>in 0.002070 seconds</span>
</code></pre></div>
<p><a href="https://death.andgravity.com/_file/pwned/00-linear.py">The code so far.</a></p>
<h2 id="problem-it-s-slow">Problem: it&#39;s slow</h2>
<p>You may have noticed I switched from <code>password</code> to <code>blocking</code>.
That&#39;s because I deliberately
chose a password whose hash is at the beginning of the file.</p>
<p>On my 2013 laptop, <code>password</code> actually takes <strong>86 seconds</strong>!</p>
<p>To put a lower bound on the time it takes to go through the file:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span><span>time</span> python -c <span>&#39;for line in open(&#34;pwned.txt&#34;, &#34;rb&#34;): pass&#39;</span>

<span>real	1m28.325s</span>
<span>user	1m10.049s</span>
<span>sys	0m15.577s</span>
<span>$ </span><span>time</span> wc -l pwned.txt
<span> 847223402 pwned.txt</span>

<span>real	0m51.729s</span>
<span>user	0m27.908s</span>
<span>sys	0m12.119s</span>
</code></pre></div>
<p><a href="https://www.youtube.com/watch?v=UANN2Eu6ZnM&amp;t=438s">There must be a better way.</a></p>
<h3 id="skipping">Skipping</h3>
<p>There&#39;s a hint in the file name: the hashes are ordered.</p>
<p>That means we don&#39;t <em>have</em> to check all the lines.
We can skip ahead repeatedly until we&#39;re past the hash,
go back one step, and only check each line from there.</p>
<p>Lines are different lengths,
so we can&#39;t skip exactly X lines without reading them.
But we don&#39;t need to,
any line that&#39;s a reasonable amount ahead will do.</p>
<table><tbody><tr><td><div><pre><code><span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span></code></pre></div></td><td><div><pre data-lang="Python"><span></span><code><span>def</span> <span>skip_to_before_line</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>offset</span><span>):</span>
    <span>old_position</span> <span>=</span> <span>file</span><span>.</span><span>tell</span><span>()</span>

    <span>while</span> <span>True</span><span>:</span>
        <span>file</span><span>.</span><span>seek</span><span>(</span><span>offset</span><span>,</span> <span>os</span><span>.</span><span>SEEK_CUR</span><span>)</span>

        <span>file</span><span>.</span><span>readline</span><span>()</span>
        <span>line</span> <span>=</span> <span>file</span><span>.</span><span>readline</span><span>()</span>
        <span># print(&#34;jumped to&#34;, (line or b&#39;&lt;eof&gt;&#39;).decode().rstrip())</span>

        <span>if</span> <span>not</span> <span>line</span> <span>or</span> <span>line</span> <span>&gt;=</span> <span>prefix</span><span>:</span>
            <span>file</span><span>.</span><span>seek</span><span>(</span><span>old_position</span><span>)</span>
            <span>break</span>

        <span>old_position</span> <span>=</span> <span>file</span><span>.</span><span>tell</span><span>()</span>
</code></pre></div>
</td></tr></tbody></table>
<p>So we just <a href="https://docs.python.org/3/library/io.html#io.IOBase.seek">seek()</a> ahead a set number of bytes.
Since that might not leave us at the start of a line,
we discard the incomplete line,
and use the next one.</p>
<!--
If we can still skip ahead,
we remember the [current position][tell],
so we can return to it if needed.
-->
<p>Finally, we wrap the original <code>find_line()</code> to do the skipping:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>def</span> <span>find_line</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>):</span>
    <span>skip_to_before_line</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>16</span> <span>*</span> <span>2</span><span>**</span><span>20</span><span>)</span>
    <span>return</span> <span>find_line_linear</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>)</span>


<span><span>def</span> <span>find_line_linear</span><span>(</span><span>lines</span><span>,</span> <span>prefix</span><span>):</span>
</span>    <span>for</span> <span>line</span> <span>in</span> <span>lines</span><span>:</span>
</code></pre></div>
</td></tr></tbody></table>
<p>It works:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python pwned.py pwned.txt password
<span>looking for 5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8</span>
<span>pwned! seen 9,545,824 times before</span>
<span>in 0.027203 seconds</span>
</code></pre></div>
<p>To find the magic 16M offset, I had to try a bunch values:</p>
<pre><code>offset (MiB)   time (s)
           1      0.05
           4      0.035
           8      0.030
          16      0.027  &lt;-- sweet spot
          32      0.14
</code></pre>
<p><a href="https://death.andgravity.com/_file/pwned/01-linear-skip.py">The code so far.</a></p>
<h2 id="problem-it-needs-tuning-it-s-still-slow">Problem: it needs tuning, it&#39;s still slow</h2>
<p>While three orders of magnitude faster, we still have a bunch of issues:</p>
<ol>
<li>The ideal offset depends on the computer you&#39;re running this on.</li>
<li>The run time still increases linearly with file size –
we haven&#39;t really solved the problem,
as much as made it smaller by a (large, but) constant factor.</li>
<li>The run time still increases linearly with where the hash is in the file.</li>
<li>It&#39;s still kinda slow. ¯\_(ツ)_/¯</li>
</ol>
<p><a href="https://www.youtube.com/watch?v=OSGv2VnC0go&amp;t=557s">There must be a better way.</a></p>
<h3 id="binary-skipping">Binary skipping</h3>
<p>To make the &#34;linear&#34; part painfully obvious,
uncomment the <code>jumped to</code> line.</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python pwned.py pwned.txt password <span>|</span> grep -o <span>&#39;jumped to .&#39;</span> <span>|</span> uniq -c
<span> 139 jumped to 0</span>
<span> 139 jumped to 1</span>
<span> 139 jumped to 2</span>
<span> 139 jumped to 3</span>
<span> 139 jumped to 4</span>
<span> 103 jumped to 5</span>
</code></pre></div>
<p>Surely, after we&#39;ve jumped to <code>0</code> once,
we don&#39;t <em>need</em> to do it 138 more times, right?</p>
<p>We could jump directly to a line in the middle of the file;
if there at all,
the hash will be in either of the halves.
We could then jump to the middle of that half,
and to the middle of <em>that</em> half,
and so on,
until we either find the hash
or there&#39;s nowhere left to jump.</p>
<section>
<p>Note</p>
<p>If that sounds a lot like <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>, that&#39;s because it is
 – it&#39;s just not wearing its regular array clothing.</p>
</section>
<p>And most of the work is already done:
we can jump to a line at most X bytes from where the hash should be,
we only need to do it repeatedly,
in smaller and smaller fractions of the file size:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>def</span> <span>skip_to_before_line</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>offset</span><span>):</span>
    <span>while</span> <span>offset</span> <span>&gt;</span> <span>2</span><span>**</span><span>8</span><span>:</span>
        <span>offset</span> <span>//=</span> <span>2</span>
        <span>skip_to_before_line_linear</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>offset</span><span>)</span>


<span><span>def</span> <span>skip_to_before_line_linear</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>offset</span><span>):</span>
</span>    <span>old_position</span> <span>=</span> <span>file</span><span>.</span><span>tell</span><span>()</span>
</code></pre></div>
</td></tr></tbody></table>
<p>The only thing left is to get the file size:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>def</span> <span>find_line</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>):</span>
    <span>file</span><span>.</span><span>seek</span><span>(</span><span>0</span><span>,</span> <span>os</span><span>.</span><span>SEEK_END</span><span>)</span>
    <span>size</span> <span>=</span> <span>file</span><span>.</span><span>tell</span><span>()</span>
    <span>file</span><span>.</span><span>seek</span><span>(</span><span>0</span><span>)</span>
    <span>skip_to_before_line</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>size</span><span>)</span>
    <span>return</span> <span>find_line_linear</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>)</span>
</code></pre></div>
</td></tr></tbody></table>
<!--

.. note:: Fun fact

    I initially used `os.stat(path).st_size` for this,
    and passing `file.fileno()` instead of the path would've worked too.

    But, the `seek(0, os.SEEK_END)` + `tell()` trick I discovered
    by trying to get [ChatGPT] to write the code for this article
    from a description of the problem alone
    (it got as far as the linear solution!).

    I swear everything else in this article was generated by a human.

    ...

    Written. Written by a human.

    [ChatGPT]: https://en.wikipedia.org/wiki/ChatGPT

-->
<p>It works:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python pwned.py pwned.txt password
<span>looking for 5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8</span>
<span>pwned! seen 9,545,824 times before</span>
<span>in 0.009559 seconds</span>
<span>$ </span>python pwned.py pwned.txt password
<span>looking for 5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8</span>
<span>pwned! seen 9,545,824 times before</span>
<span>in 0.000268 seconds</span>
</code></pre></div>
<p>The huge time difference is due to <a href="https://en.wikipedia.org/wiki/Page_cache">operating system and/or disk caches</a>
– on the second run, the same parts of the file are likely already in memory.</p>
<p>Anyway, look again at the <code>jumped to</code> output:
instead of jumping blindly through the whole file,
now we&#39;re jumping <em>around</em> the hash,
getting closer and closer to it.</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python pwned.py pwned.txt password <span>|</span> grep -o <span>&#39;jumped to .&#39;</span> <span>|</span> uniq -c
<span>   1 jumped to 7</span>
<span>   1 jumped to 3</span>
<span>   1 jumped to 7</span>
<span>   1 jumped to 5</span>
<span>   1 jumped to 4</span>
<span>  39 jumped to 5</span>
</code></pre></div>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python pwned.py pwned.txt password <span>|</span> grep -o <span>&#39;jumped to ..&#39;</span> <span>|</span> uniq -c
<span>   1 jumped to 7F</span>
<span>   1 jumped to 3F</span>
<span>   1 jumped to 7F</span>
<span>   1 jumped to 5F</span>
<span>   1 jumped to 4F</span>
<span>   1 jumped to 5F</span>
<span>   1 jumped to 57</span>
<span>   1 jumped to 5F</span>
<span>   1 jumped to 5B</span>
<span>   1 jumped to 59</span>
<span>   1 jumped to 5B</span>
<span>   1 jumped to 5A</span>
<span>  32 jumped to 5B</span>
</code></pre></div>
<p>Notice we land on the same <code>7F...</code> prefix twice;
this makes sense –
we skip ahead by half the file size,
then back,
then ahead two times by a quarter.
Caching allows us to not care about that.</p>
<p><a href="https://death.andgravity.com/_file/pwned/02-binary-search.py">The code so far.</a></p>
<h3 id="better-timing">Better timing</h3>
<p>Given the way caching muddies the waters,
how fast is it <em>really?</em></p>
<p>This function averages a hundred runs,
each with a different password:</p>
<div><pre data-lang="Bash"><span></span><code><span>function</span> average-many <span>{</span>
    <span>for</span> _ <span>in</span> <span>{</span><span>1</span>..100<span>}</span><span>;</span> <span>do</span>
        python <span>$@</span> <span>$(</span> python -c <span>&#39;import time; print(time.time())&#39;</span> <span>)</span>
    <span>done</span> <span>\</span>
    <span>|</span> grep seconds <span>\</span>
    <span>|</span> cut -d<span>&#39; &#39;</span> -f2 <span>\</span>
    <span>|</span> paste -sd+ - <span>\</span>
    <span>|</span> sed <span>&#39;s#^#scale=6;(#&#39;</span> <span>|</span> sed <span>&#39;s#$#)/100#&#39;</span> <span>\</span>
    <span>|</span> bc
<span>}</span>
</code></pre></div>

<details>
<summary>
After a few repeats, the average time settles around 3 ms.
</summary>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span><span>for</span> _ <span>in</span> <span>{</span><span>1</span>..20<span>}</span><span>;</span> <span>do</span> average-many pwned.py pwned.txt<span>;</span> <span>done</span>
<span>.004802</span>
<span>.003904</span>
<span>.004088</span>
<span>.003486</span>
<span>.003451</span>
<span>.003476</span>
<span>.003414</span>
<span>.003442</span>
<span>.003169</span>
<span>.003297</span>
<span>.002931</span>
<span>.003077</span>
<span>.003092</span>
<span>.003011</span>
<span>.002980</span>
<span>.003147</span>
<span>.003112</span>
<span>.002942</span>
<span>.002984</span>
<span>.002934</span>
</code></pre></div>
</details>
<p>Again, this is due to caching:
the more we run the script,
the more likely it is that
the pages at {half, quarters, eights, sixteenths, ...} of the file size
are already in memory
– and the path to any line starts with a subset of those.</p>
<hr/>
<p>And, we&#39;re done.</p>
<p><a href="https://qntm.org/destro">I wave my hands</a>, get a 2020 laptop, and a miracle happens.
It&#39;s far enough into the totally unpredictable future, now,
that you can search any password in under 1 millisecond.
You can do anything you want.</p>
<!--
I wave my hands, and a miracle happens.
It's far enough into the totally unpredictable future, now,
that you can completely destroy a rocky planet.
You can do anything you want.
-->
<p><a href="https://youtu.be/0twDETh6QaI?t=1787">So, there we go.</a>
Wasn&#39;t that an interesting story?
That&#39;s the end of the article.</p>
<p>Don&#39;t look at the scroll bar.
Don&#39;t worry about it.</p>
<p>If you came here to
check your password,
you can go.</p>
<!--
If you came here to
find a somewhat inconvenient way of checking if your password has been compromised,
you can go.
-->
<p>Subscribe on the way out if you&#39;d like, but take care :)</p>
<p>Go solve <a href="https://death.andgravity.com/conway-cubes">Advent of Code</a> or something.</p>
<p>I&#39;m just chilling out.</p>
<!--
I'll go chill out.
-->
<p>See ya.</p>

<h2 id="failing-to-get-to-under-1-millisecond">Failing to get to under 1 millisecond</h2>
<p>I swear this was supposed to be the end.
This really was supposed to be a short one.</p>
<p>Here&#39;s a quote from a friend of mine,
that chronologically should be way later into the article,
but makes a great summary for what follows:</p>
<blockquote>
<p>And now that you have arrived at this point,
spend a moment to ponder the arbitrary nature of 1 millisecond
given its dependency on the current year
and the choice of your particular hardware.</p>
<p>After that moment, continue celebrating.</p>
</blockquote>
<p>Nah, fuck it, it has to take less than 1 millisecond <strong>on the old laptop</strong>.</p>
<p>... so yeah, here&#39;s a bunch of stuff that didn&#39;t work.</p>




<h3 id="profile-before-optimizing-profile"><a href="http://wiki.c2.com/?ProfileBeforeOptimizing">Profile before optimizing</a></h3>
<p>With the obvious improvements out of the way,
it&#39;s probably a good time to stop and
<a href="https://death.andgravity.com/fast-conway-cubes#intro-to-profiling">find out where time is being spent</a>.</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python -m cProfile -s cumulative pwned.py pwned.txt <span>&#34;</span><span>$(</span> date <span>)</span><span>&#34;</span>
<span>looking for 3960626a8c59fe927d3cf2e991d67f4c505ae198</span>
<span>not found</span>
<span>in 0.004902 seconds</span>
<span>         1631 function calls (1614 primitive calls) in 0.010 seconds</span>

<span>   Ordered by: cumulative time</span>

<span>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span>
<span>      ...</span>
<span>        1    0.000    0.000    0.005    0.005 02-binary-search.py:8(find_line)</span>
<span>        1    0.000    0.000    0.005    0.005 02-binary-search.py:22(skip_to_before_line)</span>
<span>       28    0.000    0.000    0.005    0.000 02-binary-search.py:28(skip_to_before_line_linear)</span>
<span>       86    0.004    0.000    0.004    0.000 {method &#39;readline&#39; of &#39;_io.BufferedReader&#39; objects}</span>
<span>      ...</span>
<span>       71    0.000    0.000    0.000    0.000 {method &#39;seek&#39; of &#39;_io.BufferedReader&#39; objects}</span>
<span>      ...</span>
<span>       44    0.000    0.000    0.000    0.000 {method &#39;tell&#39; of &#39;_io.BufferedReader&#39; objects}</span>
<span>      ...</span>
</code></pre></div>
<p>From the output above, we learn that:</p>
<ul>
<li>Most of the time is spent in <a href="https://docs.python.org/3/library/io.html#io.IOBase.readline">readline()</a> calls.</li>
<li>Both <a href="https://docs.python.org/3/library/io.html#io.IOBase.seek">seek()</a> and <a href="https://docs.python.org/3/library/io.html#io.IOBase.tell">tell()</a> calls are basically free.</li>
</ul>
<p><a href="https://docs.python.org/3/library/io.html#io.IOBase.readline">readline()</a> is <a href="https://github.com/python/cpython/blob/3.10/Modules/_io/bufferedio.c#L1070-L1178">implemented in C</a>,
so there&#39;s not much we can change there.</p>
<p>What we <em>can</em> change, however, is how often we call it.</p>
<hr/>
<p>Another thing of interest is how much individual <a href="https://docs.python.org/3/library/io.html#io.IOBase.readline">readline()</a> calls take.</p>
<p>In <code>skip_to_before_line_linear()</code>:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code>        <span>start</span> <span>=</span> <span>time</span><span>.</span><span>monotonic</span><span>()</span>
        <span>file</span><span>.</span><span>readline</span><span>()</span>
        <span>line</span> <span>=</span> <span>file</span><span>.</span><span>readline</span><span>()</span>
        <span>end</span> <span>=</span> <span>time</span><span>.</span><span>monotonic</span><span>()</span>
        <span>print</span><span>(</span><span>&#34;jumped to&#34;</span><span>,</span> <span>(</span><span>line</span><span>[:</span><span>5</span><span>]</span> <span>or</span> <span>b</span><span>&#39;&lt;eof&gt;&#39;</span><span>)</span><span>.</span><span>decode</span><span>()</span><span>.</span><span>rstrip</span><span>(),</span>
              <span>f</span><span>&#34;in </span><span>{</span><span>(</span><span>end</span><span>-</span><span>start</span><span>)</span><span>*</span><span>1000000</span><span>:</span><span>4.0f</span><span>}</span><span> us&#34;</span><span>,</span>
              <span>f</span><span>&#34;at offset </span><span>{</span><span>file</span><span>.</span><span>tell</span><span>()</span><span>:</span><span>16,</span><span>}</span><span>&#34;</span><span>)</span>
</code></pre></div>
</td></tr></tbody></table><details>
<summary>
The output is pretty enlightening:
</summary>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python pwned.py pwned.txt asdf
<span>looking for 3da541559918a808c2402bba5012f6c60b27661c</span>
<span>jumped to 7FF9E in   10 us at offset   18,671,134,394  &lt;-- 1/2 file size</span>
<span>jumped to 3FF89 in    4 us at offset    9,335,567,234  &lt;-- 1/4 file size</span>
<span>jumped to 1FFBA in    3 us at offset    4,667,783,663  &lt;-- 1/8 file size</span>
<span>jumped to 3FF89 in    3 us at offset    9,335,567,322  &lt;-- 1/4 file size</span>
<span>jumped to 2FFA4 in    5 us at offset    7,001,675,508</span>
<span>jumped to 3FF89 in    4 us at offset    9,335,567,366  &lt;-- 1/4 file size</span>
<span>jumped to 37F98 in    4 us at offset    8,168,621,453</span>
<span>jumped to 3FF89 in    3 us at offset    9,335,567,410  &lt;-- 1/4 file size</span>
<span>jumped to 3BF94 in    3 us at offset    8,752,094,477</span>
<span>jumped to 3FF89 in    2 us at offset    9,335,567,498  &lt;-- 1/4 file size</span>
<span>jumped to 3DF8E in    3 us at offset    9,043,831,007</span>
<span>jumped to 3CF90 in    3 us at offset    8,897,962,782</span>
<span>jumped to 3DF8E in    2 us at offset    9,043,831,095</span>
<span>jumped to 3D790 in    3 us at offset    8,970,896,964</span>
<span>jumped to 3DF8E in    2 us at offset    9,043,831,139</span>
<span>jumped to 3DB90 in  253 us at offset    9,007,364,072</span>
<span>jumped to 3D990 in  206 us at offset    8,989,130,552</span>
<span>jumped to 3DB90 in    6 us at offset    9,007,364,160</span>
<span>jumped to 3DA8F in  270 us at offset    8,998,247,402  &lt;-- page 2,196,837</span>
<span>jumped to 3DA0F in  189 us at offset    8,993,689,007</span>
<span>jumped to 3DA8F in    5 us at offset    8,998,247,446  &lt;-- page 2,196,837</span>
<span>jumped to 3DA4F in  212 us at offset    8,995,968,274</span>
<span>jumped to 3DA8F in    5 us at offset    8,998,247,534  &lt;-- page 2,196,837</span>
<span>jumped to 3DA6F in  266 us at offset    8,997,107,921</span>
<span>jumped to 3DA5F in  203 us at offset    8,996,538,139</span>
<span>jumped to 3DA57 in  195 us at offset    8,996,253,241</span>
<span>jumped to 3DA53 in  197 us at offset    8,996,110,772</span>
<span>jumped to 3DA57 in    6 us at offset    8,996,253,285</span>
<span>jumped to 3DA55 in  193 us at offset    8,996,182,045</span>
<span>jumped to 3DA54 in  178 us at offset    8,996,146,471</span>
<span>jumped to 3DA54 in  189 us at offset    8,996,128,666</span>
<span>jumped to 3DA54 in  191 us at offset    8,996,119,760  &lt;-- page 2,196,318</span>
<span>jumped to 3DA54 in   32 us at offset    8,996,128,710</span>
<span>jumped to 3DA54 in    5 us at offset    8,996,124,259</span>
<span>jumped to 3DA54 in   10 us at offset    8,996,122,057  &lt;-- page 2,196,318</span>
<span>jumped to 3DA54 in    4 us at offset    8,996,120,955  &lt;-- page 2,196,318</span>
<span>jumped to 3DA54 in    4 us at offset    8,996,120,382  &lt;-- page 2,196,318</span>
<span>jumped to 3DA54 in    9 us at offset    8,996,120,112  &lt;-- page 2,196,318</span>
<span>jumped to 3DA54 in    1 us at offset    8,996,120,470  &lt;-- page 2,196,318</span>
<span>jumped to 3DA54 in    1 us at offset    8,996,120,338  &lt;-- page 2,196,318</span>
<span>pwned! seen 324,774 times before</span>
<span>in 0.003654 seconds</span>
</code></pre></div>
</details>
<p>Half the reads are pretty fast:</p>
<ul>
<li>In the beginning, because searches start with the same few pages.</li>
<li>At the end, because searches end on the same page.</li>
<li>All reads of any page, after the first.</li>
</ul>
<p>So, it&#39;s those reads in the middle that we need to get rid of.</p>
<h3 id="position-heuristic">Position heuristic</h3>
<p>In theory, the output of a good hash function
<a href="https://en.wikipedia.org/wiki/Hash_function#Uniformity">should be uniformly distributed</a>.</p>
<p>This means that with a bit of math,
we can estimate where a hash would be
–
a hash that&#39;s ~1/5 in the range of all possible hashes
should be at ~1/5 of the file.</p>
<p>Here&#39;s a tiny example:</p>
<div><pre data-lang="Python console session"><span></span><code><span>&gt;&gt;&gt; </span><span>digest</span> <span>=</span> <span>&#39;5b&#39;</span>  <span># 1-byte hash (2 hex digits)</span>
<span>&gt;&gt;&gt; </span><span>size</span> <span>=</span> <span>1000</span>    <span># 1000-byte long file</span>
<span>&gt;&gt;&gt; </span><span>int_digest</span> <span>=</span> <span>int</span><span>(</span><span>digest</span><span>,</span> <span>16</span><span>)</span>  <span># == 91</span>
<span>&gt;&gt;&gt; </span><span>int_end</span> <span>=</span> <span>16</span> <span>**</span> <span>len</span><span>(</span><span>digest</span><span>)</span>   <span># == 0xff + 1 == 256</span>
<span>&gt;&gt;&gt; </span><span>int</span><span>(</span><span>size</span> <span>*</span> <span>int_digest</span> <span>/</span> <span>int_end</span><span>)</span>
<span>355</span>
</code></pre></div>
<p>We can do this once,
and then binary search a safety interval around that position.
Alas,
this only gets rid of the fast jumps at the beginning of the binary search,
and for some reason,
it ends up being slightly slower than binary search alone.
(<a href="https://death.andgravity.com/_file/pwned/80-proportional-position-lite.py">code</a>)</p>
<p>We can also narrow down around the estimated position iteratively,
making the interval smaller by a constant factor each time.
This seems to work:
a factor of 1000 yields 1.7 ms,
and a factor of 8000 yields 1.2 ms,
both in 2 steps.
(<a href="https://death.andgravity.com/_file/pwned/80-proportional-position.py">code</a>)</p>
<p>However, it has deeper issues:</p>
<ul>
<li>Having arbitrary start/end offsets complicates the code quite a bit.</li>
<li>I don&#39;t know how to reliably determine the factor.</li>
<li>I don&#39;t know how to prove it&#39;s correct,
especially for smaller intervals,
where the hashes are less uniform.
To be honest, I don&#39;t think it <em>can</em> be 100% correct,
and I don&#39;t know how to estimate how correct it is.</li>
</ul>
<p>Anyway, <a href="https://peps.python.org/pep-0020/">if the implementation is hard to explain, it&#39;s a bad idea</a>.</p>
<h3 id="index-file">Index file</h3>
<p>An arbitrary self-imposed restriction I had was that
any solution should mostly use the original passwords list,
with little to no preparation.</p>
<p>By relaxing this a bit,
and going through the file once,
we can build an index like:</p>
<pre><code>&lt;SHA-1 of the password&gt;:&lt;offset in file&gt;
</code></pre>
<p>... that we can then search with <code>skip_to_before_line()</code>.</p>
<p>Of course, we won&#39;t include all the hashes
–
by including lines a few kilobytes apart from each other,
we can seek directly to within a few kilobytes in the big file.</p>
<p>The only thing left to figure out is how much &#34;a few kilobytes&#34; is.</p>
<p>After my endless harping about caching and pages,
the answer should be obvious: one page size (<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html#//apple_ref/doc/uid/20001880-99100-TPXREF113">4K</a>).
And this actually gets us <strong>0.8 ms</strong>!
But back when I wrote the code,
that hadn&#39;t really sunk in,
so after getting 1.2 ms with a 32K distance, I moved on.</p>
<p>Code: <a href="https://death.andgravity.com/_file/pwned/81-index.py">pwned.py</a>, <a href="https://death.andgravity.com/_file/pwned/81-generate-index.py">generate-index.py</a>.</p>
<h3 id="binary-file">Binary file</h3>
<p>Already on the additional file slippery slope,
I converted the list to binary,
mostly to make it smaller – smaller file, fewer reads.</p>
<p>I packed each line into 24 bytes:</p>
<pre><code>| binary hash (20 bytes) | count (4 bytes) |
</code></pre>
<p>This halved the file, but only lowered the runtime to a modest 2.6 ms.</p>
<p>More importantly, it made the code much, much simpler:
because items are fixed size,
you <em>can</em> know where the Nth item is,
so I was able to use <a href="https://docs.python.org/3/library/bisect.html">bisect</a> for the binary search.</p>
<p>Code: <a href="https://death.andgravity.com/_file/pwned/82-binary.py">pwned.py</a>, <a href="https://death.andgravity.com/_file/pwned/82-convert-to-binary.py">convert-to-binary.py</a>.</p>
<!-- TODO FIXME

## Aside: mmap

Mentioning this mainly because I'm not the only one that thought of it.

As a low hanging fruit, I though of [mmap()]-ing the file.
Sadly, this was roughly twice as slow as normal file,
both for the text and the binary file.

Another thing that might help is [fadvise()],
but that's not available on macOS.

[mmap()]: https://docs.python.org/3/library/mmap.html
[fadvise()]: https://linux.die.net/man/2/posix_fadvise

-->
<h2 id="getting-to-under-1-millisecond">Getting to under 1 millisecond</h2>
<p>OK, what now? This is what we have so far:</p>
<ul>
<li>The position heuristic kinda (maybe?) works,
but is hard to reason about.</li>
<li>The index file gets us there, but barely,
and the index is pretty big.</li>
<li>The binary file isn&#39;t much faster,
and it creates a huge file.
But, less code!</li>
</ul>
<p>I don&#39;t know what to do with the first one, but I think we can combine the last two.</p>
<h3 id="generating-the-index">Generating the index</h3>
<p>Let&#39;s start with the script I made for the text index:</p>
<table><tbody><tr><td><div><pre><code><span> 1</span>
<span> 2</span>
<span> 3</span>
<span> 4</span>
<span> 5</span>
<span> 6</span>
<span> 7</span>
<span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span></code></pre></div></td><td><div><pre data-lang="Python"><span></span><code><span>import</span> <span>os</span><span>,</span> <span>sys</span>

<span>file</span> <span>=</span> <span>sys</span><span>.</span><span>stdin</span><span>.</span><span>buffer</span>
<span>outf</span> <span>=</span> <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>buffer</span>

<span>while</span> <span>True</span><span>:</span>
    <span>pos</span> <span>=</span> <span>file</span><span>.</span><span>tell</span><span>()</span>
    <span>line</span> <span>=</span> <span>file</span><span>.</span><span>readline</span><span>()</span>
    <span>if</span> <span>not</span> <span>line</span><span>:</span>
        <span>break</span>

    <span>outf</span><span>.</span><span>write</span><span>(</span><span>line</span><span>.</span><span>partition</span><span>(</span><span>b</span><span>&#39;:&#39;</span><span>)[</span><span>0</span><span>]</span> <span>+</span> <span>b</span><span>&#39;:&#39;</span> <span>+</span> <span>str</span><span>(</span><span>pos</span><span>)</span><span>.</span><span>encode</span><span>()</span> <span>+</span> <span>b</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span>

    <span>file</span><span>.</span><span>seek</span><span>(</span><span>2</span><span>**</span><span>12</span><span>,</span> <span>os</span><span>.</span><span>SEEK_CUR</span><span>)</span>
    <span>file</span><span>.</span><span>readline</span><span>()</span>
</code></pre></div>
</td></tr></tbody></table>
<p>The output looks like this:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python generate-index.py &lt; pwned.txt <span>2</span>&gt;/dev/null <span>|</span> head -n5
<span>000000005AD76BD555C1D6D771DE417A4B87E4B4:0</span>
<span>00000099A4D3034E14DF60EF50799F695C27C0EC:4157</span>
<span>00000172E8E1D1BD54AC23B3F9AB4383F291CA17:8312</span>
<span>000002C8F808A7DB504BBC3C711BE8A8D508C0F9:12453</span>
<span>0000047139578F13D70DD96BADD425C372DB64A9:16637</span>
</code></pre></div>
<p>We need to pack that into bytes.</p>
<p>A hash takes 20 bytes.
But,
we only need slightly more than 3 bytes (6 hex digits)
to distinguish between the index lines:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>python generate-index.py &lt; pwned.txt <span>2</span>&gt;/dev/null <span>|</span> cut -c-6 <span>|</span> uniq -c <span>|</span> head
<span>   2 000000</span>
<span>   1 000001</span>
<span>   1 000002</span>
<span>   1 000004</span>
<span>   1 000005</span>
<span>   1 000007</span>
<span>   1 000008</span>
<span>   1 00000A</span>
<span>   1 00000B</span>
<span>   1 00000C</span>
</code></pre></div>
<p>To represent all the offsets in the file,
we need <code>log2(35G) / 8 = 4.39...</code> bytes,
which results in a total of 9 bytes
(maybe even 8, if we mess with individual bits).</p>
<p>Let&#39;s make it future-proof:
6 bytes for the hash buys at least 55 trillion lines
(2.4 petabyte files), and
6 bytes for the offset buys 0.28 petabyte files.</p>
<!--
>>> size = 37342268646
>>> lines = 847223402
>>> size/lines
44.0760589920532
>>> lines * 256**2
55523632873472
>>> f"{lines * 256**2:,}"
'55,523,632,873,472'
>>> f"{lines * 256**2 * (size/lines):,}"
'2,447,262,917,984,256.0'
>>> f"{ 256**6 :,}"
'281,474,976,710,656'
-->
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code>    <span>digest</span><span>,</span> <span>_</span><span>,</span> <span>_</span> <span>=</span> <span>line</span><span>.</span><span>partition</span><span>(</span><span>b</span><span>&#39;:&#39;</span><span>)</span>
    <span>outf</span><span>.</span><span>write</span><span>(</span><span>bytes</span><span>.</span><span>fromhex</span><span>(</span><span>digest</span><span>.</span><span>decode</span><span>())[:</span><span>6</span><span>])</span>
    <span>outf</span><span>.</span><span>write</span><span>(</span><span>pos</span><span>.</span><span>to_bytes</span><span>(</span><span>6</span><span>,</span> <span>&#39;big&#39;</span><span>))</span>
</code></pre></div>
</td></tr></tbody></table>
<p>If you look at the text index,
you&#39;ll notice the offsets are 4K + ~50 bytes apart;
this results in sometimes having to read 2 pages,
because not all pages have an index entry.
Let&#39;s fix that by reading the first whole line after a 4K boundary instead:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code>    <span>file</span><span>.</span><span>seek</span><span>((</span><span>pos</span> <span>//</span> <span>4096</span> <span>+</span> <span>1</span><span>)</span> <span>*</span> <span>4096</span><span>)</span>
    <span>file</span><span>.</span><span>readline</span><span>()</span>
</code></pre></div>
</td></tr></tbody></table>
<p>OK, we&#39;re done:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span><span>time</span> python generate-index.py &lt; pwned.txt &gt; index.bin

<span>real	1m2.729s</span>
<span>user	0m34.292s</span>
<span>sys	0m21.392s</span>
</code></pre></div>
<h3 id="using-the-index">Using the index</h3>
<p>We start with a skeleton that&#39;s functionally identical
to the <a href="#a-minimal-plausible-solution">naive</a> script.
The only difference is that I&#39;ve added stubs
for passing and using the index:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>def</span> <span>find_line</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>index</span><span>):</span>
    <span>skip_to_before_line_index</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>index</span><span>)</span>
    <span>return</span> <span>find_line_linear</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>)</span>
</code></pre></div>
</td></tr></tbody></table>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>def</span> <span>skip_to_before_line_index</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>index</span><span>):</span>
    <span>...</span>
</code></pre></div>
</td></tr></tbody></table>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>index_path</span> <span>=</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>2</span><span>]</span>
<span>index</span> <span>=</span> <span>...</span>
</code></pre></div>
</td></tr></tbody></table>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>line</span> <span>=</span> <span>find_line</span><span>(</span><span>file</span><span>,</span> <span>hexdigest</span><span>.</span><span>upper</span><span>()</span><span>.</span><span>encode</span><span>(),</span> <span>index</span><span>)</span>
</code></pre></div>
</td></tr></tbody></table>
<details>
<summary>
The whole skeleton, if you want to see it:
</summary>
<table><tbody><tr><td><div><pre><code><span> 1</span>
<span> 2</span>
<span> 3</span>
<span> 4</span>
<span> 5</span>
<span> 6</span>
<span> 7</span>
<span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span></code></pre></div></td><td><div><pre data-lang="Python"><span></span><code><span>import</span> <span>os</span>
<span>import</span> <span>sys</span>
<span>import</span> <span>time</span>
<span>import</span> <span>bisect</span>
<span>import</span> <span>getpass</span>
<span>import</span> <span>hashlib</span>


<span>def</span> <span>find_line</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>index</span><span>):</span>
    <span>skip_to_before_line_index</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>index</span><span>)</span>
    <span>return</span> <span>find_line_linear</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>)</span>


<span>def</span> <span>find_line_linear</span><span>(</span><span>lines</span><span>,</span> <span>prefix</span><span>):</span>
    <span>for</span> <span>line</span> <span>in</span> <span>lines</span><span>:</span>
        <span>if</span> <span>line</span><span>.</span><span>startswith</span><span>(</span><span>prefix</span><span>):</span>
            <span>return</span> <span>line</span>
        <span>if</span> <span>line</span> <span>&gt;</span> <span>prefix</span><span>:</span>
            <span>break</span>
    <span>return</span> <span>None</span>


<span>def</span> <span>skip_to_before_line_index</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>index</span><span>):</span>
    <span>...</span>


<span>path</span> <span>=</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>]</span>
<span>file</span> <span>=</span> <span>open</span><span>(</span><span>path</span><span>,</span> <span>&#39;rb&#39;</span><span>)</span>

<span>index_path</span> <span>=</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>2</span><span>]</span>
<span>index</span> <span>=</span> <span>...</span>

<span>try</span><span>:</span>
    <span>password</span> <span>=</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>3</span><span>]</span>
<span>except</span> <span>IndexError</span><span>:</span>
    <span>password</span> <span>=</span> <span>getpass</span><span>.</span><span>getpass</span><span>()</span>
<span>hexdigest</span> <span>=</span> <span>hashlib</span><span>.</span><span>sha1</span><span>(</span><span>password</span><span>.</span><span>encode</span><span>())</span><span>.</span><span>hexdigest</span><span>()</span>
<span>del</span> <span>password</span>

<span>print</span><span>(</span><span>&#34;looking for&#34;</span><span>,</span> <span>hexdigest</span><span>)</span>

<span>start</span> <span>=</span> <span>time</span><span>.</span><span>monotonic</span><span>()</span>
<span>line</span> <span>=</span> <span>find_line</span><span>(</span><span>file</span><span>,</span> <span>hexdigest</span><span>.</span><span>upper</span><span>()</span><span>.</span><span>encode</span><span>(),</span> <span>index</span><span>)</span>
<span>end</span> <span>=</span> <span>time</span><span>.</span><span>monotonic</span><span>()</span>

<span>if</span> <span>line</span><span>:</span>
    <span>times</span> <span>=</span> <span>int</span><span>(</span><span>line</span><span>.</span><span>decode</span><span>()</span><span>.</span><span>rstrip</span><span>()</span><span>.</span><span>partition</span><span>(</span><span>&#39;:&#39;</span><span>)[</span><span>2</span><span>])</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;pwned! seen </span><span>{</span><span>times</span><span>:</span><span>,</span><span>}</span><span> times before&#34;</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;not found&#34;</span><span>)</span>

<span>print</span><span>(</span><span>f</span><span>&#34;in </span><span>{</span><span>end</span><span>-</span><span>start</span><span>:</span><span>.6f</span><span>}</span><span> seconds&#34;</span><span>)</span>
</code></pre></div>
</td></tr></tbody></table>
</details>
<p>As mentioned before,
we&#39;ll use the standard library <a href="https://docs.python.org/3/library/bisect.html">bisect</a> module
to search the index.</p>
<p>We <em>could</em> read the entire index in memory,
as a list of 12-byte <a href="https://docs.python.org/3/library/stdtypes.html#bytes">bytes</a>.
But that would still be slow, even if outside the current timing code,
and memory usage would increase with the size of the file.</p>
<p>Fortunately,
<a href="https://docs.python.org/3/library/bisect.html">bisect</a> doesn&#39;t only work with lists,
it works with any <a href="https://docs.python.org/3/glossary.html#term-sequence">sequence</a>
– that is, any object that can pretend to be a list.
So we&#39;ll build our own,
by implementing the two required special methods.</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>class</span> <span>BytesArray</span><span>:</span>

    <span>item_size</span> <span>=</span> <span>12</span>

    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>file</span><span>):</span>
        <span>self</span><span>.</span><span>file</span> <span>=</span> <span>file</span>
</code></pre></div>
</td></tr></tbody></table>
<p>We can go ahead and plug it in:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code><span>index_path</span> <span>=</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>2</span><span>]</span>
<span>index</span> <span>=</span> <span>BytesArray</span><span>(</span><span>open</span><span>(</span><span>index_path</span><span>,</span> <span>&#39;rb&#39;</span><span>))</span>
</code></pre></div>
</td></tr></tbody></table>
<p>The first special method is <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__">__getitem__()</a>, for <code>a[i]</code>:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code>    <span>def</span> <span>__getitem__</span><span>(</span><span>self</span><span>,</span> <span>index</span><span>):</span>
        <span>self</span><span>.</span><span>file</span><span>.</span><span>seek</span><span>(</span><span>index</span> <span>*</span> <span>self</span><span>.</span><span>item_size</span><span>)</span>
        <span>buffer</span> <span>=</span> <span>self</span><span>.</span><span>file</span><span>.</span><span>read</span><span>(</span><span>self</span><span>.</span><span>item_size</span><span>)</span>
        <span>if</span> <span>len</span><span>(</span><span>buffer</span><span>)</span> <span>!=</span> <span>self</span><span>.</span><span>item_size</span><span>:</span>
            <span>raise</span> <span>IndexError</span><span>(</span><span>index</span><span>)</span>  <span># out of bounds</span>
        <span>return</span> <span>buffer</span>
</code></pre></div>
</td></tr></tbody></table>
<p>The second special method is <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__">__len__()</a>, for <code>len(a)</code>:</p>
<table><tbody><tr><td></td><td><div><pre data-lang="Python"><span></span><code>    <span>def</span> <span>__len__</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>file</span><span>.</span><span>seek</span><span>(</span><span>0</span><span>,</span> <span>os</span><span>.</span><span>SEEK_END</span><span>)</span>
        <span>size</span> <span>=</span> <span>self</span><span>.</span><span>file</span><span>.</span><span>tell</span><span>()</span>
        <span>return</span> <span>size</span> <span>//</span> <span>self</span><span>.</span><span>item_size</span>
</code></pre></div>
</td></tr></tbody></table>
<p>Using the index becomes straightforward:</p>
<table><tbody><tr><td><div><pre><code><span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span></code></pre></div></td><td><div><pre data-lang="Python"><span></span><code><span>def</span> <span>skip_to_before_line_index</span><span>(</span><span>file</span><span>,</span> <span>prefix</span><span>,</span> <span>index</span><span>):</span>
    <span>item_prefix</span> <span>=</span> <span>bytes</span><span>.</span><span>fromhex</span><span>(</span><span>prefix</span><span>.</span><span>decode</span><span>())[:</span><span>6</span><span>]</span>
    <span>item</span> <span>=</span> <span>find_lt</span><span>(</span><span>index</span><span>,</span> <span>item_prefix</span><span>)</span>
    <span>offset</span> <span>=</span> <span>int</span><span>.</span><span>from_bytes</span><span>(</span><span>item</span><span>[</span><span>6</span><span>:],</span> <span>&#39;big&#39;</span><span>)</span> <span>if</span> <span>item</span> <span>else</span> <span>0</span>
    <span>file</span><span>.</span><span>seek</span><span>(</span><span>offset</span><span>)</span>


<span>def</span> <span>find_lt</span><span>(</span><span>a</span><span>,</span> <span>x</span><span>):</span>
    <span>i</span> <span>=</span> <span>bisect</span><span>.</span><span>bisect_left</span><span>(</span><span>a</span><span>,</span> <span>x</span><span>)</span>
    <span>if</span> <span>i</span><span>:</span>
        <span>return</span> <span>a</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span>
    <span>return</span> <span>None</span>
</code></pre></div>
</td></tr></tbody></table>
<p>We get the first 6 bytes of the hash,
find the rightmost value less than that,
extract the offset from it,
and seek to there.
<code>find_lt()</code> comes from <a href="https://docs.python.org/3/library/bisect.html">bisect</a>&#39;s recipes for <a href="https://docs.python.org/3/library/bisect.html#searching-sorted-lists">searching sorted lists</a>.</p>
<p>And we&#39;re done:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>average-many pwned.py pwned.txt index.bin
<span>.002546</span>
</code></pre></div>
<p>Huh? ... that&#39;s unexpected...</p>
<p>Oh.</p>
<p>I said we won&#39;t read the index in memory.
But we <em>can</em> force it into the cache
by reading it a bunch of times:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span><span>for</span> _ <span>in</span> <span>{</span><span>1</span>..10<span>}</span><span>;</span> <span>do</span> cat index.bin &gt; /dev/null<span>;</span> <span>done</span>
</code></pre></div>
<p>Finally:</p>
<div><pre data-lang="Bash Session"><span></span><code><span>$ </span>average-many pwned.py pwned.txt index.bin
<span>.000421</span>
</code></pre></div>
<p>Code: <a href="https://death.andgravity.com/_file/pwned/11-binary-index.py">pwned.py</a>, <a href="https://death.andgravity.com/_file/pwned/10-generate-index.py">generate-index.py</a>.</p>
<h3 id="i-heard-you-like-indexes-the-end">I heard you like indexes (the end)</h3>
<p>Hmmm... isn&#39;t that cold start bugging you?
If we make an index for the big index,
we get 1.2 ms from a cold start.
Maybe another smaller index can take us to below 1 ms?</p>
<p>...</p>
<p>Just kidding, this is it, this really is the end.</p>
<p>And now, let&#39;s take that moment to ponder:</p>
<table>
<thead>
<tr>
  <th>method</th>
  <th>statements</th>
  <th>time (ms, order of magnitude)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>linear</td>
  <td>29</td>
  <td>100,000</td>
</tr>
<tr>
  <td>linear+skip</td>
  <td>42</td>
  <td>100</td>
</tr>
<tr>
  <td>binary search</td>
  <td>49</td>
  <td>10</td>
</tr>
<tr>
  <td>binary index</td>
  <td>59 (72)</td>
  <td>1</td>
</tr>
</tbody>
</table>
<p>For twice the code, it&#39;s 5 orders of magnitude faster!
I&#39;m deliberately not counting bisect or the OS cache here,
beacuse that&#39;s the point, they&#39;re basically free.</p>
<p>Turns out, you can get pretty far with just <em>a few</em> tricks.</p>
<hr/>
<p>That&#39;s it for now.</p>
<p><strong>Learned something new today?</strong> Share this with others, it really helps!</p>




<h2 id="bonus-better-data-structures">Bonus: better data structures</h2>
<p>As always, a specialized data structure can solve a problem better.</p>
<p>In <a href="https://scotthelme.co.uk/sketchy-pwned-passwords/">Sketchy Pwned Passwords</a>,
Scott Helme manages to &#34;pack&#34; the entire passwords list
into a 1.5G in-memory <a href="https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch">count-min sketch</a>,
which can then be queried in 1 microsecond.
And, if you don&#39;t care about the counts,
<a href="https://scotthelme.co.uk/when-pwned-passwords-bloom/">a plain Bloom filter</a> can even take you to 0.1 µs!
(There is a trade-off, and it&#39;s that it takes 11 hours to create either.)</p>

<!--

# Bonus: the k-Anonymity API

<!-- TODO: fix file to be api only

.. literalinclude:: 03-kanon.py
    :lines: 45-52

.. literalinclude:: 03-kanon.py
    :lines: 55-61
    :emphasize-lines: 2-4,7

.. literalinclude:: 03-kanon.py
    :lines: 72-74
    :emphasize-lines: 2

https://api.pwnedpasswords.com/range/5baa6

https://haveibeenpwned.com/API/v3#PwnedPasswords

-->









</div>
</div></div>
  </body>
</html>
