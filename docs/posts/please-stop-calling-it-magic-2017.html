<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zverok.space/blog/2017-10-22-stop-magic.html">Original</a>
    <h1>Please stop calling it “magic” (2017)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <blockquote>
  <p><strong><a href="https://techracho.bpsinc.jp/hachi8833/2017_11_08/47766">Japanese translation</a> of this post is available!</strong></p>
</blockquote>

<p>Recently I’ve read (informative and well-written) article called
<a href="https://blog.rubyroidlabs.com/2017/10/7-gems-rails-code/"><em>7 Gems Which Will Make Your Rails Code Look Awesome</em></a>,
and my eye was caught with this phrase in the description of <a href="https://github.com/hashrocket/decent_exposure">decent_exposure</a>
gem:</p>

<blockquote>
  <p>If you are not a big fan of using <strong>magic</strong> – this library is not for you. (emphasis is mine)</p>
</blockquote>

<p>This “m-word” was used to describe library that uses <em>metaprogramming</em>: adds <code>expose</code> method to
Rails controller class, that generates trivial <code>#index</code>/<code>#show</code>/<code>#new</code> methods for simple CRUD
situations.</p>

<p>I honestly don’t want to offend the article’s author, it is just a cause to say some important things.
Lately, it seems to be pretty spread in Ruby/Rails communities: to use “magic” and “metaprogramming”
as a kind of wicked synonyms. So, I just want to ask politely yet firmly:</p>

<p><strong>Please stop calling it “magic”</strong></p>

<p>Why? Read below.</p>

<blockquote>
  <p><strong>Disclaimer</strong>: for the sake of discussion, I am using made-up examples, not particularly based on
  any existing library. I just don’t want my points to be lost in “Oh, he is just blaming %libraryname%”,
  like it already <a href="http://zverok.github.io/blog/2016-10-09-minitest.html">happened in the past</a>.</p>
</blockquote>

<p>So…</p>

<h2 id="what-is-magic">What is magic?</h2>

<p>According to Wikipedia,</p>

<blockquote>
  <p><strong>Magic</strong> … is the use of rituals, symbols, actions, gestures, and language with the aim of
  utilizing <strong>supernatural</strong> forces.<a href="https://en.wikipedia.org/wiki/Magic_%28paranormal%29">→</a></p>
</blockquote>

<p>and</p>

<blockquote>
  <p>The <strong>supernatural</strong> … includes all that cannot be explained by the laws of nature.<a href="https://en.wikipedia.org/wiki/Supernatural">→</a></p>
</blockquote>

<p>Applying this to programming, we can formulate that:</p>

<blockquote>
  <p><strong>Magic</strong> in code is the situation when some behavior emerges, whose cause, even for experienced
  developer on target language is hard/impossible to trace.</p>
</blockquote>

<p>This is not a perfect definition, so let’s clarify it with some semi-theoretical examples.</p>

<div><div><pre><code><span>class</span> <span>LandCruiserJ200</span> <span>&lt;</span> <span>Car</span>
  <span>def</span> <span>type</span>
    <span>:suv</span>
  <span>end</span>

  <span>def</span> <span>engine</span>
    <span>&#39;4.5 L&#39;</span>
  <span>end</span>
<span>end</span>

<span>LandCruiserJ200</span><span>.</span><span>new</span><span>.</span><span>drive!</span> <span># &#34;wroom! wrrroooom!&#34;</span>
</code></pre></div></div>

<p>“Is it magic? I don’t see any <code>#drive!</code> method here, but it <em>magically</em> works???”</p>

<p>Any sane developer would laugh.</p>

<p>No, silly, it is just inheritance. We can guess that <code>#drive!</code> method
defined in parent <code>Car</code> class, and can easily find this class’ and method’s code (and/or its docs,
including the case when it is from some external gem).</p>

<p>OK, one more.</p>

<div><div><pre><code><span>class</span> <span>LandCruiserJ200</span>
  <span>include</span> <span>Drivable</span>

  <span>def</span> <span>type</span>
    <span>:suv</span>
  <span>end</span>

  <span>def</span> <span>engine</span>
    <span>&#39;4.5 L&#39;</span>
  <span>end</span>
<span>end</span>

<span>LandCruiserJ200</span><span>.</span><span>new</span><span>.</span><span>drive!</span> <span># &#34;wroom! wrrroooom!&#34;</span>
</code></pre></div></div>

<p>Oh, how weird! No inheritance here, where did <code>#drive!</code> method came from? Magic!</p>

<p>… Or just normal mixin, find <code>Drivable</code>’s docs and it probably will explain how and why it is used,
and what <code>#drive!</code> method does.</p>

<p>One more?</p>

<div><div><pre><code><span>class</span> <span>LandCruiserJ200</span>
  <span>drivable</span> <span>type: :suv</span><span>,</span> <span>engine: </span><span>&#39;4.5 L&#39;</span>
<span>end</span>

<span>LandCruiserJ200</span><span>.</span><span>new</span><span>.</span><span>drive!</span> <span># &#34;wroom! wrrroooom!&#34;</span>
</code></pre></div></div>

<p>Oh, that’s definitely a case of unexplainable forbidden witchcraft, mere human will never understand
that, right?..</p>

<p>… Or probably <code>drivable</code> is a method, defined for a <code>Class</code> directly or by extending with some
module (which is not the best practice possible, yet still pretty easy to guess for any non-junior
Rubyist), and you probably can:</p>

<div><div><pre><code><span>LandCruiserJ200</span><span>.</span><span>method</span><span>(</span><span>:drivable</span><span>)</span> <span># =&gt; #&lt;Method: Class(Drivable)#drivable&gt;</span>
<span>LandCruiserJ200</span><span>.</span><span>method</span><span>(</span><span>:drivable</span><span>).</span><span>source_location</span> <span># =&gt; /some/gem/drivable/lib/drivable.rb:123</span>
</code></pre></div></div>

<h3 id="so-what-is-magic">So, what is magic?</h3>

<p>I’ll show you:</p>

<div><div><pre><code><span>class</span> <span>LandCruiserJ200Car</span>
<span>end</span>

<span>car</span> <span>=</span> <span>LandCruiserJ200Car</span><span>.</span><span>new</span>
<span># =&gt; #&lt;Car model=&#34;Land Cruiser J200&#34;&gt;</span>
<span>car</span><span>.</span><span>drive!</span> <span># &#34;wroom! wrrroooom!&#34;</span>
</code></pre></div></div>

<p>Imagine the code above works. Why?</p>

<p>If I need to deal with the fact, OK, I can <em>guess</em> that probably
in current scope <em>something</em> provides a convention by which… hm… Everything named <code>...Car</code> is
treated specially? Or everything from folder <code>app/cars/</code>?.. Or, there is some YAML-config, where all
car classes are listed?</p>

<p>What exactly is responsible for attaching the behavior and where can I find
its docs, if I need them? How do I debug it, if it fails to behave the way I expect?..</p>

<p>That’s an example of “supernatural” behavior: e.g. when something happens not being obviously related
to <em>natural</em> forces of the language. …And is bad <em>exactly</em> because of this fact: your <em>natural</em>
tools and intuitions stop working, you need just to remember entire spellbook to deal with magical code.</p>

<h2 id="whats-not-magic">What’s not magic</h2>

<h3 id="what-junior-does-not-understand-is-not-magic">What junior does not understand, is not magic</h3>

<p>It is common to see nowadays statements like “this is too magical for less experienced developers to
understand”. As Matz says (reciting from memory), “Ruby is complex language to make developer’s life
simple”, not the other way round.</p>

<p>Your car’s engine and your computer’s processor are pretty complicated, too, but that doesn’t mean
that they are “magical”. Neither that you shouldn’t use them and stick to “less magical” solutions.</p>

<h3 id="monkey-patching-is-not-magic">Monkey-patching is not magic</h3>

<p>Yep, monkey-patching is questionable. Monkey-patching of core classes is considered deadly sin by some.
And so on.</p>

<p>But, when some people coming from another language, see <code>5.days</code> and call that “magic”, why
should we repeat their opinion?</p>

<p>It may be counter-intuitive for other language developers, but for
Rubyists it is pretty obvious what’s going on, and how to understand where method came from and look
for its docs/implementations.</p>

<blockquote>
  <p>And, as a side note, open classes (even core ones) is significant feature for Ruby evolution,
  allowing both experiment with new concepts and provide backward compatibility by demand, with
  gems like <a href="https://github.com/marcandre/backports">backports</a> and
  <a href="https://github.com/AaronLasseigne/polyfill">polyfill</a>.</p>
</blockquote>

<h3 id="metaprogramming-is-not-magic">Metaprogramming is not magic</h3>

<p>And now, back to the beginning of this article :)</p>

<p>“Metaprogramming”, e.g. generation of code objects during code execution, is one of the most powerful
Ruby features, and it is so because how natural it is for the language. And due to this naturality,
it is one of the first and the best guesses for code design in most cases.</p>

<p>Your class needs to have several math operators, just delegating to internal values? You do</p>

<div><div><pre><code><span>%i[+ - * /]</span><span>.</span><span>each</span> <span>{</span> <span>|</span><span>op</span><span>|</span> <span>define_method</span><span>(</span><span>op</span><span>)</span> <span>{</span> <span>...</span>
</code></pre></div></div>

<p>Several similar classes need some “settings” that declaratively define their behavior? You add simple
DSL of class methods. And so on.</p>

<p>Yes, later you may redecide this due to performance reasons, or for the sake of documentability (though
nowadays we have pretty decent tools for documenting metaprogrammed stuff), or because your homogenous
code objects became not that homogenous…</p>

<p>But metaprogramming is just one of the tools in your drawer and pretty useful one.</p>

<p>It <strong>does not become unnatural</strong> just because somebody has called it so 100 times.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Why am I writing this?</p>

<p>Because “m-word” is <em>harmful</em> for the community. It becomes a bad label that used
with too much freedom both from outside and inside the Ruby world, being attached randomly to
practices and features one just doesn’t like or doesn’t understand. This situation leads to decay
of ideas, when perfectly well-designed and natural libraries and language features become almost
“prohibited”.</p>

<p>So, simply put:</p>

<p><strong>Dear Rubyists! Please stop use “magic” as a synonym of “metaprogramming”!</strong></p>

  </div></div>
  </body>
</html>
