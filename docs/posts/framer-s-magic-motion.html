<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.nan.fyi/magic-motion">Original</a>
    <h1>Framer&#39;s Magic Motion</h1>
    
    <div id="readability-page-1" class="page"><article><header><p>November 22, 2022</p><p>A guide on recreating framer&#39;s magical layout animations.</p></header><p>My favourite part about Framer Motion by far is its magical layout animations—slap on the <code>layout</code> prop to any motion component, and watch as that component seamlessly transitions from one part of the page to the next:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="tsx" data-theme="light"><code data-language="tsx" data-theme="light"><span><span>&lt;</span><span>motion.div</span><span> </span><span>layout</span><span> /&gt;</span></span></code></pre><pre data-language="tsx" data-theme="dark"><code data-language="tsx" data-theme="dark"><span><span>&lt;</span><span>motion.div</span><span> </span><span>layout</span><span> /&gt;</span></span></code></pre></div>
<div><div><div><div><ul><p><li>function</li></p><p><li>hello</li></p></ul><ul><p><li>console</li></p><p><li>log</li></p><p><li>hello, world!</li></p></ul><ul></ul></div></div></div><figcaption><p>When you click on &#34;Hide types&#34;, the squares seamlessly move from one
position to the next.</p></figcaption></div>
<p>In this post, I want to dive deep into the techniques that allow these layout animations to happen. Specifically, we&#39;ll go over concepts like:</p>
<ol><li><p><strong>Layout changes</strong>, what they are and when they occur;</p></li><li><p><strong>CSS-based approaches</strong> and why they don&#39;t always work;</p></li><li><p><strong>FLIP</strong>, the technique in use by Framer Motion;</p></li></ol>
<p>Let&#39;s get started!</p>
<h2 id="layout-changes">Layout Changes</h2>
<p>A layout change happens when an element on the page changes position in a way that affects <em>other</em> elements on the page. For example, changing the <code>width</code> or <code>height</code> of an element is a layout change because any neighbouring element has to move to make room for the element&#39;s new size:</p>

<p>Similarly, changing the <code>justify-content</code> property of an element is also a layout change because it causes that element&#39;s <em>children</em> to change positions:</p>
<div><div><div><div><p>justify-content: <!-- -->flex-start</p></div></div></div></div>
<p>On the other hand, making the same change using something like <code>scale</code> is <em>not</em> a layout change because transforms don&#39;t affect other elements on the page at all:</p>

<h2 id="animating-with-css">Animating With CSS</h2>
<p>So how would we animate layout changes? One way is by animating the property directly using something like CSS transitions:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="css" data-theme="light"><code data-language="css" data-theme="light"><span><span>.square</span><span> {</span></span>
<span><span>  </span><span>transition</span><span>: width </span><span>0.2</span><span>s</span><span> </span><span>ease-out</span><span>;</span></span>
<span><span>}</span></span></code></pre><pre data-language="css" data-theme="dark"><code data-language="css" data-theme="dark"><span><span>.square</span><span> {</span></span>
<span><span>  </span><span>transition</span><span>: width </span><span>0.2</span><span>s</span><span> </span><span>ease-out</span><span>;</span></span>
<span><span>}</span></span></code></pre></div>
<p>Now when the square changes width, it&#39;ll seamlessly animate between its sizes:</p>
<div><div><div><div><div><div aria-describedby="enter-instructions-:R1ik8t4m:" aria-label="Code Editor for styles.css" role="group" tabindex="0" translate="no"><pre>.active <span>{</span>
  <span>border</span><span>:</span> <span>1</span><span>px</span> <span>solid</span> <span>hsl</span><span>(</span><span>208</span><span>,</span> <span>77.5</span><span>%</span><span>,</span> <span>76.9</span><span>%</span><span>)</span><span>;</span>
  <span>background</span><span>:</span> <span>hsl</span><span>(</span><span>209</span><span>,</span> <span>81.2</span><span>%</span><span>,</span> <span>84.5</span><span>%</span><span>)</span><span>;</span>
  <span>width</span><span>:</span> <span>120</span><span>px</span><span>;</span>
  <span>height</span><span>:</span> <span>120</span><span>px</span><span>;</span>
  <span>border-radius</span><span>:</span> <span>8</span><span>px</span><span>;</span>
  <span>transition</span><span>:</span> <span>width</span> <span>0.5</span><span>s</span> <span>ease-out</span><span>;</span>
<span>}</span>

.toggled <span>{</span>
  <span>width</span><span>:</span> <span>200</span><span>px</span><span>;</span>
<span>}</span></pre></div></div></div></div></div></div>
<p>To be honest, in many cases, we can end the post here!</p>
<p>But there are two main downsides with CSS animations that we should be aware of:</p>
<ol><li><p><strong>You can&#39;t animate everything</strong>. For example, you can&#39;t animate a change in <code>justify-content</code> because <code>justify-content</code> is <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties" target="_blank" rel="noreferrer">not an animatable property</a>.</p></li><li><p><strong>There <em>may</em> be a performance trade-off</strong>. CSS animations that involve layout changes are generally more expensive than transform-based animations, so you might find that your animations are not as smooth on lower-end devices.</p></li></ol>
<p>Let&#39;s talk about the performance problem for a second.</p>
<h3 id="performance">Performance</h3>
<blockquote>
<p><strong>Don&#39;t pre-optimize!</strong> If you&#39;re not noticing any performance issues on lower-end devices and CSS transitions work for you, then don&#39;t worry about it! Only optimize when you need to.</p>
</blockquote>
<p>CSS animations that involve layout changes are generally more expensive than other CSS animations because it affects other elements around it. This is because the browser has to recalculate the layout of the page <em>in every frame of the animation</em>—for a 60 FPS animation, that means 60 times every second!</p>
<p>Recall the animation from the previous section. Notice that the grey boxes also look like they&#39;re animating, even though we only transition the blue box:</p>

<p>This happens because the browser recalculates the position of the grey boxes every time the blue box changes size.</p>
<p>On the other hand, the browser can animate CSS properties like <code>transform</code> much faster because they don&#39;t affect layout:</p>

<p>Notice that as the blue box grows, the grey boxes stay put!</p>
<hr/>
<p>Hey, wait a second. If <code>transform</code> is much cheaper to animate, can we somehow animate layout changes using <code>transform</code> instead?</p>
<h2 id="introducing-flip">Introducing FLIP</h2>
<p>Yes, you can!</p>
<p>FLIP, which stands for <strong>F</strong>irst, <strong>L</strong>ast, <strong>I</strong>nverse, <strong>P</strong>lay, is a technique that lets you animate &#34;slow&#34; layout changes using &#34;fast&#34; CSS properties like <code>transform</code>. FLIP even lets you animate &#34;un-animatable&#34; properties like <code>justify-content</code> too! Framer Motion uses FLIP under the hood to implement its layout animations.</p>
<p>As its name suggests, FLIP is a four-step technique that works by inverting any layout changes done by the browser. Let&#39;s figure out how it works by animating this change in <code>justify-content</code> from <code>flex-start</code> to <code>flex-end</code>:</p>
<div><div><p>justify-content:<!-- --> <span>flex-start</span></p></div></div>
<h3 id="first">First</h3>
<p>In the <strong>First</strong> step, we measure the position of the element we&#39;re animating <em>before</em> any layout changes have happened:</p>

<p>One way to do this is to use the <code>.getBoundingClientRect()</code> method of the HTML element:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="tsx" data-theme="light"><code data-language="tsx" data-theme="light"><span><span>const</span><span> </span><span>Motion</span><span> </span><span>=</span><span> (</span><span>props</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  </span><span>const</span><span> </span><span>ref</span><span> </span><span>=</span><span> React.</span><span>useRef</span><span>();</span></span>
<span></span>
<span><span>  React.</span><span>useLayoutEffect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>    </span><span>const</span><span> { </span><span>x</span><span>, </span><span>y</span><span> } </span><span>=</span><span> ref.current.</span><span>getBoundingClientRect</span><span>();</span></span>
<span><span>  }, []);</span></span>
<span></span>
<span><span>  </span><span>return</span><span> &lt;</span><span>div</span><span> </span><span>ref</span><span>={</span><span>ref</span><span>}</span><span> </span><span>{...</span><span>props</span><span>}</span><span> /&gt;;</span></span>
<span><span>};</span></span></code></pre><pre data-language="tsx" data-theme="dark"><code data-language="tsx" data-theme="dark"><span><span>const</span><span> </span><span>Motion</span><span> </span><span>=</span><span> (</span><span>props</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  </span><span>const</span><span> </span><span>ref</span><span> </span><span>=</span><span> React.</span><span>useRef</span><span>();</span></span>
<span></span>
<span><span>  React.</span><span>useLayoutEffect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>    </span><span>const</span><span> { </span><span>x</span><span>, </span><span>y</span><span> } </span><span>=</span><span> ref.current.</span><span>getBoundingClientRect</span><span>();</span></span>
<span><span>  }, []);</span></span>
<span></span>
<span><span>  </span><span>return</span><span> &lt;</span><span>div</span><span> </span><span>ref</span><span>={</span><span>ref</span><span>}</span><span> </span><span>{...</span><span>props</span><span>}</span><span> /&gt;;</span></span>
<span><span>};</span></span></code></pre></div>
<details><summary>Why useLayoutEffect?</summary><p>We&#39;re using <code>useLayoutEffect</code> instead of <code>useEffect</code> because we want our code to run before the browser &#34;re-renders&#34; the screen. This way we don&#39;t get an awkward flash when we move the element around later on.</p><p>You can read more about <code>useLayoutEffect</code> in the <a href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" target="_blank" rel="noreferrer">React docs</a>.</p></details>
<h3 id="last">Last</h3>
<p>In the <strong>Last</strong> step, we measure the position of the element <em>after</em> the layout changes has happened:</p>
<div><div><p>justify-content:<!-- --> <span>flex-start</span></p></div></div>
<p>To get this working in code, we&#39;ll first assume that <strong>a layout change means the component just re-rendered</strong>. So let&#39;s start by removing the dependency array from the <code>useEffect</code> hook to make the hook run every render.</p>
<p>Try triggering the layout change a few times and check the console to see what <code>x</code> and <code>y</code> values show up:</p>
<div><div><div><div><div><div><div aria-describedby="enter-instructions-:R1ikot4m:" aria-label="Code Editor for Motion.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Motion</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>squareRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span>

  <span>React</span>.<span>useLayoutEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>box</span> = <span>squareRef</span>.<span>current</span>?.<span>getBoundingClientRect</span><span>(</span><span>)</span>
    <span>if</span> <span>(</span><span>box</span><span>)</span> <span>{</span> <span>console</span>.<span>log</span><span>(</span><span>box</span>.<span>x</span><span>,</span> <span>box</span>.<span>y</span><span>)</span> <span>}</span>
  <span>}</span><span>)</span>

  <span>return</span> <span>&lt;</span><span>div</span> <span>id</span>=<span>&#34;motion&#34;</span> <span>ref</span>=<span>{</span><span>squareRef</span><span>}</span> <span>/&gt;</span>
<span>}</span></pre></div></div></div></div></div></div></div>
<p>Pop quiz time!</p>
<div id="box-position" data-answered="false"><p><strong>After the layout change</strong>, is <code>box</code> in the snippet above referring to the
<strong>initial</strong> position or the <strong>final</strong> position of the square?</p></div>
<p>If you answered , you&#39;d be right!</p>
<p>This is because <strong>the <code>useEffect</code> hook runs after the component renders</strong>. So when we call <span data-rehype-pretty-code-fragment=""><code data-language="js" data-theme="light"><span><span>getBoundingClientRect</span><span>()</span></span></code><code data-language="js" data-theme="dark"><span><span>getBoundingClientRect</span><span>()</span></span></code></span> in the <code>useEffect</code> hook, we&#39;re actually getting the position of the square  the layout change.</p>
<p>So how do you get the  position?</p>
<p>One way is to create a ref (using <code>useRef</code>) and store the previous value there every time you measure the box:</p>
<div><div><div><div><div><div aria-describedby="enter-instructions-:R1iksd4m:" aria-label="Code Editor for Motion.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Motion</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>squareRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> <span>initialPositionRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span><span>;</span>

  <span>React</span>.<span>useLayoutEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>box</span> = <span>squareRef</span>.<span>current</span>?.<span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>box</span><span>)</span> <span>{</span>
      
      <span>console</span>.<span>log</span><span>(</span><span>box</span>.<span>x</span><span>,</span> <span>box</span>.<span>y</span><span>)</span>

      
      <span>console</span>.<span>log</span><span>(</span>
        <span>initialPositionRef</span>.<span>current</span>?.<span>x</span><span>,</span>
        <span>initialPositionRef</span>.<span>current</span>?.<span>y</span>
      <span>)</span><span>;</span>

      <span>initialPositionRef</span>.<span>current</span> = <span>box</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>
  
  <span>return</span> <span>&lt;</span><span>div</span> <span>id</span>=<span>&#34;motion&#34;</span> <span>ref</span>=<span>{</span><span>squareRef</span><span>}</span> <span>/&gt;</span><span>;</span>
<span>}</span></pre></div></div></div></div></div></div>
<h3 id="inverse">Inverse</h3>
<p>In the <strong>inverse</strong> phase, we modify the position of the square so that it <em>looks</em> like it didn&#39;t move at all. To do this, we compare the two measurements we made and calculate a transform that we then apply to the square:</p>
<div><div><p><svg width="100%" height="100%"><rect rx="6" x="32"></rect><text x="32" y="75">x: <!-- -->32</text><rect rx="6" x="-152"></rect><line x1="0" x2="0" y1="150" y2="150" style="transform:translateX(-92px)"></line>0<rect rx="6" x="-32"></rect><text x="-152" y="75">x: <!-- -->-152</text><g><text>translateX(0px)</text></g></svg></p></div></div>
<p>Here&#39;s a React implementation of the technique:</p>
<div><div><div><div><div><div><div aria-describedby="enter-instructions-:R1ikut4m:" aria-label="Code Editor for Motion.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Motion</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>squareRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> <span>initialPositionRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span><span>;</span>

  <span>React</span>.<span>useLayoutEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>box</span> = <span>squareRef</span>.<span>current</span>?.<span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>moved</span><span>(</span><span>initialPositionRef</span>.<span>current</span><span>,</span> <span>box</span><span>)</span><span>)</span> <span>{</span>
      
      <span>const</span> <span>deltaX</span> = <span>initialPositionRef</span>.<span>current</span>.<span>x</span> - <span>box</span>.<span>x</span><span>;</span>
      <span>const</span> <span>deltaY</span> = <span>initialPositionRef</span>.<span>current</span>.<span>y</span> - <span>box</span>.<span>y</span><span>;</span>
      <span>console</span>.<span>log</span><span>(</span><span>deltaX</span><span>,</span> <span>deltaY</span><span>)</span><span>;</span>

      
      <span>squareRef</span>.<span>current</span>.<span>style</span>.<span>transform</span> = <span>`translate(</span><span>${</span><span>deltaX</span><span>}</span><span>px, </span><span>${</span><span>deltaY</span><span>}</span><span>px)`</span><span>;</span>
    <span>}</span>
    <span>initialPositionRef</span>.<span>current</span> = <span>box</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
  
  <span>return</span> <span>&lt;</span><span>div</span> <span>id</span>=<span>&#34;motion&#34;</span> <span>ref</span>=<span>{</span><span>squareRef</span><span>}</span> <span>/&gt;</span><span>;</span>
<span>}</span>

<span>const</span> <span>moved</span> = <span>(</span><span>initialBox</span><span>,</span> <span>finalBox</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
  <span>if</span> <span>(</span>!<span>initialBox</span> || !<span>finalBox</span><span>)</span> <span>return</span> <span>false</span><span>;</span>

  <span>const</span> <span>xMoved</span> = <span>initialBox</span>.<span>x</span> !== <span>finalBox</span>.<span>x</span><span>;</span>
  <span>const</span> <span>yMoved</span> = <span>initialBox</span>.<span>y</span> !== <span>finalBox</span>.<span>y</span><span>;</span>

  <span>return</span> <span>xMoved</span> || <span>yMoved</span><span>;</span>
<span>}</span></pre></div></div></div></div></div></div></div>
<p>Notice that if you press toggle, nothing happens! This is because the square was transformed to look like it didn&#39;t move an inch.</p>
<h3 id="play">Play</h3>
<p>So far, we have a square that has a transform applied to it to make it look like it didn&#39;t move after toggle is pressed.</p>
<p>In the final step of FLIP, the <strong>Play</strong> step, we animate this transform down to zero to make the square animate to its final position.</p>
<div><div><p><svg width="100%" height="100%"><rect rx="6" x="32"></rect><text x="32" y="75">x: <!-- -->32</text><rect rx="6" x="-152"></rect><line x1="152" x2="0" y1="150" y2="150" style="transform:translateX(-92px)"></line>0<rect rx="6" x="-32"></rect><text x="-152" y="75">x: <!-- -->-152</text><g><text>translateX(<!-- -->184<!-- -->px)</text></g></svg></p></div></div>
<p>There are various ways that you can implement this animation; I personally opted to use the <code>animate</code> function from <a href="https://popmotion.io/#quick-start-animation-animate" target="_blank" rel="noreferrer">Popmotion</a>:</p>
<div><div><div><div><div><div><div aria-describedby="enter-instructions-:R1il2d4m:" aria-label="Code Editor for Motion.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span>
<span>import</span> <span>{</span> <span>animate</span> <span>}</span> <span>from</span> <span>&#39;popmotion&#39;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Motion</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>squareRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> <span>initialPositionRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span><span>;</span>

  <span>React</span>.<span>useLayoutEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>box</span> = <span>squareRef</span>.<span>current</span>?.<span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>moved</span><span>(</span><span>initialPositionRef</span>.<span>current</span><span>,</span> <span>box</span><span>)</span><span>)</span> <span>{</span>
      
      <span>const</span> <span>deltaX</span> = <span>initialPositionRef</span>.<span>current</span>.<span>x</span> - <span>box</span>.<span>x</span><span>;</span>
      <span>const</span> <span>deltaY</span> = <span>initialPositionRef</span>.<span>current</span>.<span>y</span> - <span>box</span>.<span>y</span><span>;</span>

      
      <span>squareRef</span>.<span>current</span>.<span>style</span>.<span>transform</span> = <span>`translate(</span><span>${</span><span>deltaX</span><span>}</span><span>px, </span><span>${</span><span>deltaY</span><span>}</span><span>px)`</span><span>;</span>

      
      <span>animate</span><span>(</span><span>{</span>
        <span>from</span><span>:</span> <span>1</span><span>,</span>
        <span>to</span><span>:</span> <span>0</span><span>,</span>
        <span>duration</span><span>:</span> <span>2000</span><span>,</span>
        <span>onUpdate</span><span>:</span> <span>progress</span> <span>=&gt;</span> <span>{</span>
          <span>squareRef</span>.<span>current</span>.<span>style</span>.<span>transform</span> = 
            <span>`translate(</span><span>${</span><span>deltaX</span> * <span>progress</span><span>}</span><span>px, </span><span>${</span><span>deltaY</span> * <span>progress</span><span>}</span><span>px)`</span><span>;</span>
        <span>}</span>
      <span>}</span><span>)</span>
    <span>}</span>
    <span>initialPositionRef</span>.<span>current</span> = <span>box</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
  
  <span>return</span> <span>&lt;</span><span>div</span> <span>id</span>=<span>&#34;motion&#34;</span> <span>ref</span>=<span>{</span><span>squareRef</span><span>}</span> <span>/&gt;</span><span>;</span>
<span>}</span>

<span>const</span> <span>moved</span> = <span>(</span><span>initialBox</span><span>,</span> <span>finalBox</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
  <span>if</span> <span>(</span>!<span>initialBox</span> || !<span>finalBox</span><span>)</span> <span>return</span> <span>false</span><span>;</span>

  <span>const</span> <span>xMoved</span> = <span>initialBox</span>.<span>x</span> !== <span>finalBox</span>.<span>x</span><span>;</span>
  <span>const</span> <span>yMoved</span> = <span>initialBox</span>.<span>y</span> !== <span>finalBox</span>.<span>y</span><span>;</span>

  <span>return</span> <span>xMoved</span> || <span>yMoved</span><span>;</span>
<span>}</span></pre></div></div></div></div></div></div></div>
<h3 id="putting-everything-together">Putting Everything Together</h3>
<p>By doing all of the steps together, we get...</p>

<p>Voila! Magical layout animations.</p>
<h2 id="animating-size">Animating Size</h2>
<p>So far we&#39;ve only used FLIP to animate a change in <em>position</em>. Can we do the same thing but for <em>size</em>? Let&#39;s try to replicate the following animation where the square stretches to fill the whole container:</p>

<p>We won&#39;t mix changes in position and size together for now; we&#39;ll get to that in a bit.</p>
<h3 id="measuring-size-changes">Measuring Size Changes</h3>
<p>We&#39;ll start off by measuring the size of the square before and after the layout change. Thankfully, the <code>.getBoundingClientRect()</code> method we used to measure the square also happens to return the <code>width</code> and <code>height</code> of the element:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ts" data-theme="light"><code data-language="ts" data-theme="light"><span><span>const</span><span> { </span><span>width</span><span>, </span><span>height</span><span> } </span><span>=</span><span> squareRef.current.</span><span>getBoundingClientRect</span><span>();</span></span></code></pre><pre data-language="ts" data-theme="dark"><code data-language="ts" data-theme="dark"><span><span>const</span><span> { </span><span>width</span><span>, </span><span>height</span><span> } </span><span>=</span><span> squareRef.current.</span><span>getBoundingClientRect</span><span>();</span></span></code></pre></div>

<h3 id="inverting-size-changes">Inverting Size Changes</h3>
<p>To invert the size change, we&#39;ll divide the final size with the initial size:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ts" data-theme="light"><code data-language="ts" data-theme="light"><span><span>const</span><span> </span><span>deltaWidth</span><span> </span><span>=</span><span> box.width </span><span>/</span><span> initialBoxRef.current.width;</span></span></code></pre><pre data-language="ts" data-theme="dark"><code data-language="ts" data-theme="dark"><span><span>const</span><span> </span><span>deltaWidth</span><span> </span><span>=</span><span> box.width </span><span>/</span><span> initialBoxRef.current.width;</span></span></code></pre></div>
<p>This gives us a number that we can pass to <code>scale</code>:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ts" data-theme="light"><code data-language="ts" data-theme="light"><span><span>squareRef.current.style.transform </span><span>=</span><span> </span><span>`scaleX(${</span><span>deltaWidth</span><span>})`</span><span>;</span></span></code></pre><pre data-language="ts" data-theme="dark"><code data-language="ts" data-theme="dark"><span><span>squareRef.current.style.transform </span><span>=</span><span> </span><span>`scaleX(${</span><span>deltaWidth</span><span>})`</span><span>;</span></span></code></pre></div>

<p>And instead of animating the scale to zero like we did with position, we&#39;ll animate the scale to one (if we animate to zero instead, the element will disappear altogether):</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ts" data-theme="light"><code data-language="ts" data-theme="light"><span><span>animate</span><span>({</span></span>
<span><span>  from: deltaWidth,</span></span>
<span><span>  to: </span><span>1</span><span>,</span></span>
<span><span>  </span><span>// ...</span></span>
<span><span>});</span></span></code></pre><pre data-language="ts" data-theme="dark"><code data-language="ts" data-theme="dark"><span><span>animate</span><span>({</span></span>
<span><span>  from: deltaWidth,</span></span>
<span><span>  to: </span><span>1</span><span>,</span></span>
<span><span>  </span><span>// ...</span></span>
<span><span>});</span></span></code></pre></div>

<h2 id="consolidating-size-with-position">Consolidating Size with Position</h2>
<p>Cool! So far we&#39;re able to use FLIP to animate changes in position and size. What happens when we try to animate both size <em>and</em> position?</p>

<p>Hmm, that looks a little off. What&#39;s going on here? If we pause the animation just before the play step, we can see that something went wrong in the inverse step - the square isn&#39;t quite lining up with its original position:</p>

<h3 id="fixing-transform-origins">Fixing Transform Origins</h3>
<p>Let&#39;s try to figure this out.</p>
<p>When we combine changes in position and size, we&#39;re performing two separate transformations in the inverse step — a translation and a scale. If we take a look at those transformations individually, we can see how the square ended up where it did:</p>
<p>Our algorithm first lines up the top left point of the final position with the top left point of the original position, and then it scales it down to the initial size.</p><p>The scale transform seems to be the culprit here - it&#39;s scaling from the <em>center</em> of the square, causing the square to end up in the wrong location. Now if we change the transform origin to the top left instead so that it lines up with the translation...</p><div data-rehype-pretty-code-fragment=""><pre data-language="ts" data-theme="light"><code data-language="ts" data-theme="light"><span><span>squareRef.current.style.transformOrigin </span><span>=</span><span> </span><span>&#34;top left&#34;</span><span>;</span></span></code></pre><pre data-language="ts" data-theme="dark"><code data-language="ts" data-theme="dark"><span><span>squareRef.current.style.transformOrigin </span><span>=</span><span> </span><span>&#34;top left&#34;</span><span>;</span></span></code></pre></div><p>Would you look at that; it works!</p><h3 id="what-if-transform-origins-change">What if Transform Origins Change?</h3><p>Of course, the big caveat with this solution is that we&#39;ve hard coded in the transform origin value. What if the user wants a different transform origin? The layout animation should still work in this case.</p><p>The trick, it turns out, is to make sure the inverse step compares the distance between the <em>transform origins</em> of the two squares. To put it another way, the bug is happening because of a discrepancy between the measured distance and the transform origins: <code>getBoundingClientRect()</code> returns the <em>top left</em> point of the element whereas the transform origin is at the <em>center</em> of the element by default.</p><p>The distance between the top left point and the distance between the centers are only equivalent when the two squares are the same size:</p><div><div><p><svg width="100%" height="100%"><rect rx="6" width="120" x="32" y="90"></rect><rect rx="6" width="120" height="120" x="-152" y="90"></rect><g style="transform:translateY(90px)"><g><line x1="32" x2="152" y1="0" y2="0"></line><circle cx="32" cy="0"></circle><circle cx="152" cy="0"></circle><g style="transform:translateX(92px)"><rect rx="4" x="-25" y="-12.5"></rect><text x="0" text-anchor="middle" dominant-baseline="middle">120.0</text></g></g></g><g style="transform:translateY(150px)"><g><line x1="32" x2="-152" y1="0" y2="0"></line><circle cx="32" cy="0"></circle><circle cx="-152" cy="0"></circle><g style="transform:translateX(-60px)"><rect rx="4" x="-30" y="-15"></rect><text x="0" text-anchor="middle" dominant-baseline="middle">-184.0</text></g></g></g><g style="transform:translateY(90px)"><g><circle cx="-152" cy="0"></circle><circle cx="-32" cy="0"></circle><g style="transform:translateX(-92px)"><rect rx="4" x="-25" y="-12.5"></rect><text x="0" text-anchor="middle" dominant-baseline="middle">120.0</text></g></g></g></svg></p><p><svg width="100%" height="100%"><rect rx="6" width="120" x="32" y="90"></rect><rect rx="6" width="120" height="120" x="-152" y="90"></rect><g style="transform:translateY(90px)"><g><line x1="32" x2="152" y1="0" y2="0"></line><circle cx="32" cy="0"></circle><circle cx="152" cy="0"></circle><g style="transform:translateX(92px)"><rect rx="4" x="-25" y="-12.5"></rect><text x="0" text-anchor="middle" dominant-baseline="middle">120.0</text></g></g></g><g style="transform:translateY(150px)"><g><line x1="92" x2="-92" y1="0" y2="0"></line><circle cx="92" cy="0"></circle><circle cx="-92" cy="0"></circle><g style="transform:translateX(0px)"><rect rx="4" x="-30" y="-15"></rect><text x="0" text-anchor="middle" dominant-baseline="middle">-184.0</text></g></g></g><g style="transform:translateY(90px)"><g><circle cx="-152" cy="0"></circle><circle cx="-32" cy="0"></circle><g style="transform:translateX(-92px)"><rect rx="4" x="-25" y="-12.5"></rect><text x="0" text-anchor="middle" dominant-baseline="middle">120.0</text></g></g></g></svg></p></div></div><p><em>I&#39;m only comparing the horizontal distance here for simplicity - the same concept applies if we take into account the vertical distance too.</em></p><p>When the final square is larger, the distance between the centers is <em>larger</em> than the distance between the top left points. Similarly, when the final square is smaller, the distance between the centers is <em>smaller</em> than the distance between the top left points.</p><p>With this insight, we can also solve the bug by using the distance between the centers instead of the top left points:</p>
<h2 id="correcting-child-distortions">Correcting Child Distortions</h2>
<p>Great! So far, we&#39;re able to make a layout animation that can seamlessly transition changes in size and position. Now let&#39;s add another test - what happens if our element has <strong>child elements</strong>?</p>

<p>Oh no! The text appears to be changing size. How do we fix this?</p>
<p>The culprit here is once again the inverse scale transform. When we&#39;re inverting to a smaller square, the text ends up smaller because the square is scaled down. Similarly, when we&#39;re inverting to a larger square, the text ends up larger because the square is scaled up.</p>
<p>This leads us to our problem:</p>

<h3 id="inverse-scale-formula">Inverse Scale Formula</h3>
<p>One way is to apply <em>another</em> transform on the child element that &#34;cancels out&#34; the parent&#39;s transform. One transform we can do is:</p>
<pre><code>childScale = 1 / parentScale
</code></pre>
<p>The idea is if the parent gets twice as large, then the child needs to halve its size for it to stay the same size. Try moving the slider below and notice how the text stays the same size regardless of the size of the square:</p>

<p>Great! Now how would we integrate this with our layout animations?</p>
<h3 id="first-attempt">First Attempt</h3>
<p>The first thing that I tried was to calculate the inverse scale <em>once</em>, just before the parent is about to animate, and then running a separate animation on the child:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ts" data-theme="light"><code data-language="ts" data-theme="light"><span><span>/* this runs in the child when the parent is about to animate */</span></span>
<span><span>const</span><span> </span><span>inverseTransform</span><span> </span><span>=</span><span> {</span></span>
<span><span>  scaleX: </span><span>1</span><span> </span><span>/</span><span> parentTransform.scaleX,</span></span>
<span><span>  scaleY: </span><span>1</span><span> </span><span>/</span><span> parentTransform.scaleY,</span></span>
<span><span>};</span></span>
<span><span>play</span><span>({</span></span>
<span><span>  from: inverseTransform,</span></span>
<span><span>  to: { scaleX: </span><span>1</span><span>, scaleY: </span><span>1</span><span> },</span></span>
<span><span>});</span></span></code></pre><pre data-language="ts" data-theme="dark"><code data-language="ts" data-theme="dark"><span><span>/* this runs in the child when the parent is about to animate */</span></span>
<span><span>const</span><span> </span><span>inverseTransform</span><span> </span><span>=</span><span> {</span></span>
<span><span>  scaleX: </span><span>1</span><span> </span><span>/</span><span> parentTransform.scaleX,</span></span>
<span><span>  scaleY: </span><span>1</span><span> </span><span>/</span><span> parentTransform.scaleY,</span></span>
<span><span>};</span></span>
<span><span>play</span><span>({</span></span>
<span><span>  from: inverseTransform,</span></span>
<span><span>  to: { scaleX: </span><span>1</span><span>, scaleY: </span><span>1</span><span> },</span></span>
<span><span>});</span></span></code></pre></div>
<p>For example, if the parent is animating from <code>scaleX: 2</code> to <code>scaleX: 1</code>, then the child will be animating from <code>scaleX: 1 / 2</code> to <code>scaleX: 1</code> using the same timing. My thinking was that as long as the timing of the scale correction is the same as the parent animation, this approach should work.</p>
<p>Except I was wrong, because this is what the approach produces:</p>

<p>Er, it&#39;s doing <em>something</em>, but the text is still clearly changing size throughout the animation.</p>
<h3 id="the-correct-scale-timing">The Correct Scale Timing</h3>
<p>The problem here lies in this assumption:</p>
<blockquote>
<p>As long as the timing of the scale correction is the same as the parent animation, this approach should work.</p>
</blockquote>
<p>In reality, the &#34;correct&#34; inverse scale does not change in the same manner as the parent animation. Instead it kinda does its own thing:</p>

<p>In the example above, the blue line shows the scale of the parent, while the yellow line shows the scale of the child. Notice that the blue line is a straight line whereas the yellow line is a bit of a curve. This tells us that the timing of the inverse scale is not the same as the parent scale!</p>
<p>To fix this, we can either:</p>
<ol><li><p>Calculate the correct timing ahead of time, or;</p></li><li><p>Calculate the inverse scale every time the parent scale changes.</p></li></ol>
<p>(2) happens to be drastically simpler than (1), and also allows us to handle all sorts of different timings on the parent. This also happens to be the approach that Framer Motion uses.</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="ts" data-theme="light"><code data-language="ts" data-theme="light"><span><span>animate</span><span>({</span></span>
<span><span>  from: inverseTransform,</span></span>
<span><span>  to: {</span></span>
<span><span>    x: </span><span>0</span><span>,</span></span>
<span><span>    y: </span><span>0</span><span>,</span></span>
<span><span>    scaleX: </span><span>1</span><span>,</span></span>
<span><span>    scaleY: </span><span>1</span><span>,</span></span>
<span><span>  },</span></span>
<span><span>  </span><span>onUpdate</span><span>: ({ </span><span>x</span><span>, </span><span>y</span><span>, </span><span>scaleX</span><span>, </span><span>scaleY</span><span> }) </span><span>=&gt;</span><span> {</span></span>
<span><span>    parentRef.style.transform </span><span>=</span><span> </span><span>`...`</span><span>;</span></span>
<span></span>
<span><span>    </span><span>const</span><span> </span><span>inverseScaleX</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>/</span><span> scaleX;</span></span>
<span><span>    </span><span>const</span><span> </span><span>inverseScaleY</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>/</span><span> scaleY;</span></span>
<span><span>    childRef.style.transform </span><span>=</span><span> </span><span>`scaleX(${</span><span>inverseScaleX</span><span>}) scaleY(${</span><span>inverseScaleY</span><span>}) ...`</span><span>;</span></span>
<span><span>  },</span></span>
<span><span>});</span></span></code></pre><pre data-language="ts" data-theme="dark"><code data-language="ts" data-theme="dark"><span><span>animate</span><span>({</span></span>
<span><span>  from: inverseTransform,</span></span>
<span><span>  to: {</span></span>
<span><span>    x: </span><span>0</span><span>,</span></span>
<span><span>    y: </span><span>0</span><span>,</span></span>
<span><span>    scaleX: </span><span>1</span><span>,</span></span>
<span><span>    scaleY: </span><span>1</span><span>,</span></span>
<span><span>  },</span></span>
<span><span>  </span><span>onUpdate</span><span>: ({ </span><span>x</span><span>, </span><span>y</span><span>, </span><span>scaleX</span><span>, </span><span>scaleY</span><span> }) </span><span>=&gt;</span><span> {</span></span>
<span><span>    parentRef.style.transform </span><span>=</span><span> </span><span>`...`</span><span>;</span></span>
<span></span>
<span><span>    </span><span>const</span><span> </span><span>inverseScaleX</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>/</span><span> scaleX;</span></span>
<span><span>    </span><span>const</span><span> </span><span>inverseScaleY</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>/</span><span> scaleY;</span></span>
<span><span>    childRef.style.transform </span><span>=</span><span> </span><span>`scaleX(${</span><span>inverseScaleX</span><span>}) scaleY(${</span><span>inverseScaleY</span><span>}) ...`</span><span>;</span></span>
<span><span>  },</span></span>
<span><span>});</span></span></code></pre></div>
<div><div><div><div><div><div><div aria-describedby="enter-instructions-:R1im0t4m:" aria-label="Code Editor for Motion.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span>
<span>import</span> <span>{</span> <span>animate</span> <span>}</span> <span>from</span> <span>&#39;popmotion&#39;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Motion</span><span>(</span><span>{</span> <span>toggled</span><span>,</span> <span>corrected</span><span>,</span> <span>children</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>squareRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> <span>childRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span><span>;</span>

  <span>const</span> <span>initialPositionRef</span> = <span>React</span>.<span>useRef</span><span>(</span><span>)</span><span>;</span>

  <span>React</span>.<span>useLayoutEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>box</span> = <span>squareRef</span>.<span>current</span>?.<span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>changed</span><span>(</span><span>initialPositionRef</span>.<span>current</span><span>,</span> <span>box</span><span>)</span><span>)</span> <span>{</span>
      <span>const</span> <span>transform</span> = <span>invert</span><span>(</span><span>squareRef</span>.<span>current</span><span>,</span> <span>box</span><span>,</span> <span>initialPositionRef</span>.<span>current</span><span>)</span>

      <span>animate</span><span>(</span><span>{</span>
        <span>from</span><span>:</span> <span>transform</span><span>,</span>
        <span>to</span><span>:</span> <span>{</span> <span>x</span><span>:</span> <span>0</span><span>,</span> <span>y</span><span>:</span> <span>0</span><span>,</span> <span>scaleX</span><span>:</span> <span>1</span><span>,</span> <span>scaleY</span><span>:</span> <span>1</span> <span>}</span><span>,</span>
        <span>duration</span><span>:</span> <span>1000</span><span>,</span>
        <span>onUpdate</span><span>:</span> <span>(</span><span>{</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>scaleX</span><span>,</span> <span>scaleY</span> <span>}</span><span>)</span> <span>=&gt;</span> <span>{</span>
          <span>squareRef</span>.<span>current</span>.<span>style</span>.<span>transform</span> = 
            <span>`translate(</span><span>${</span><span>x</span><span>}</span><span>px, </span><span>${</span><span>y</span><span>}</span><span>px) scaleX(</span><span>${</span><span>scaleX</span><span>}</span><span>) scaleY(</span><span>${</span><span>scaleY</span><span>}</span><span>)`</span><span>;</span>
          <span>if</span> <span>(</span><span>corrected</span><span>)</span> <span>{</span>
            <span>childRef</span>.<span>current</span>.<span>style</span>.<span>transform</span> = <span>`scaleX(</span><span>${</span><span>1</span> / <span>scaleX</span><span>}</span><span>) scaleY(</span><span>${</span><span>1</span> / <span>scaleY</span><span>}</span><span>)`</span><span>;</span>
          <span>}</span>
        <span>}</span>
      <span>}</span><span>)</span>
    <span>}</span>
    <span>initialPositionRef</span>.<span>current</span> = <span>box</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>div</span> 
      <span>id</span>=<span>&#34;motion&#34;</span>
      <span>ref</span>=<span>{</span><span>squareRef</span><span>}</span>
      <span>style</span>=<span>{</span><span>{</span>
        <span>width</span><span>:</span> <span>toggled</span> &amp;&amp; <span>&#39;100%&#39;</span><span>,</span>
        <span>aspectRatio</span><span>:</span> <span>&#39;initial&#39;</span><span>,</span>
        <span>height</span><span>:</span> <span>120</span>
      <span>}</span><span>}</span>
    <span>&gt;</span>
      <span>&lt;</span><span>div</span> <span>ref</span>=<span>{</span><span>childRef</span><span>}</span><span>&gt;</span><span>{</span><span>children</span><span>}</span><span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>changed</span> = <span>(</span><span>initialBox</span><span>,</span> <span>finalBox</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
  <span>if</span> <span>(</span>!<span>initialBox</span> || !<span>finalBox</span><span>)</span> <span>return</span> <span>false</span><span>;</span>

  
  <span>return</span> <span>JSON</span>.<span>stringify</span><span>(</span><span>initialBox</span><span>)</span> !== <span>JSON</span>.<span>stringify</span><span>(</span><span>finalBox</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>invert</span> = <span>(</span><span>el</span><span>,</span> <span>from</span><span>,</span> <span>to</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>{</span> <span>x</span><span>:</span> <span>fromX</span><span>,</span> <span>y</span><span>:</span> <span>fromY</span><span>,</span> <span>width</span><span>:</span> <span>fromWidth</span><span>,</span> <span>height</span><span>:</span> <span>fromHeight</span> <span>}</span> = <span>from</span><span>;</span>
  <span>const</span> <span>{</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>width</span><span>,</span> <span>height</span> <span>}</span> = <span>to</span><span>;</span>

  <span>const</span> <span>transform</span> = <span>{</span>
    <span>x</span><span>:</span> <span>x</span> - <span>fromX</span> - <span>(</span><span>fromWidth</span> - <span>width</span><span>)</span> / <span>2</span><span>,</span>
    <span>y</span><span>:</span> <span>y</span> - <span>fromY</span> - <span>(</span><span>fromHeight</span> - <span>height</span><span>)</span> / <span>2</span><span>,</span>
    <span>scaleX</span><span>:</span> <span>width</span> / <span>fromWidth</span><span>,</span>
    <span>scaleY</span><span>:</span> <span>height</span> / <span>fromHeight</span><span>,</span>
  <span>}</span><span>;</span>

  <span>el</span>.<span>style</span>.<span>transform</span> = <span>`translate(</span><span>${</span><span>transform</span>.<span>x</span><span>}</span><span>px, </span><span>${</span><span>transform</span>.<span>y</span><span>}</span><span>px) scaleX(</span><span>${</span><span>transform</span>.<span>scaleX</span><span>}</span><span>) scaleY(</span><span>${</span><span>transform</span>.<span>scaleY</span><span>}</span><span>)`</span><span>;</span>

  <span>return</span> <span>transform</span><span>;</span>
<span>}</span></pre></div></div></div></div></div></div></div>
<h3 id="that&#39;s-not-how-it-really-works,-right">That&#39;s Not How it Really Works, Right?</h3>
<p>The way that I made the scale correction work in this case is by wrapping the child element in a <code>&lt;div&gt;</code> and applying the scale correction to the <code>&lt;div&gt;</code>. This implies a few things:</p>
<ol><li><p>There are two elements in the DOM for one Motion component, which may be problematic from a UX perspective;</p></li><li><p>All child components are scale corrected — there&#39;s no way for one child to be corrected and another not;</p></li><li><p>There <em>may</em> be issues if the child component is also animating — I haven&#39;t tested this, but I assume the scale correction will cause issues because we&#39;re distorting the child&#39;s coordinate space.</p></li></ol>
<p>Framer Motion does things a bit differently; you have to <em>opt in</em> to scale correction by making your child component a layout component:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="tsx" data-theme="light"><code data-language="tsx" data-theme="light"><span><span>&lt;</span><span>motion.article</span><span> </span><span>layout</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>motion.h1</span><span> </span><span>layout</span><span>&gt;Hello!&lt;/</span><span>motion.h1</span><span>&gt; &lt;-- is scale corrected</span></span>
<span><span>  &lt;</span><span>p</span><span>&gt;World!&lt;/</span><span>p</span><span>&gt; &lt;-- is not scale corrected</span></span>
<span><span>&lt;/</span><span>motion.article</span><span>&gt;</span></span></code></pre><pre data-language="tsx" data-theme="dark"><code data-language="tsx" data-theme="dark"><span><span>&lt;</span><span>motion.article</span><span> </span><span>layout</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>motion.h1</span><span> </span><span>layout</span><span>&gt;Hello!&lt;/</span><span>motion.h1</span><span>&gt; &lt;-- is scale corrected</span></span>
<span><span>  &lt;</span><span>p</span><span>&gt;World!&lt;/</span><span>p</span><span>&gt; &lt;-- is not scale corrected</span></span>
<span><span>&lt;/</span><span>motion.article</span><span>&gt;</span></span></code></pre></div>
<p>This API implies that the child component needs to be able to &#34;hook in&#34; to the parent&#39;s animation, which makes the implementation a tad more complex.</p>
<p>I opted to not implement things this way because I didn&#39;t want to take away from the core scale correction concept. If you&#39;re interested though, <a href="https://github.com/framer/motion/blob/main/packages/framer-motion/src/projection/node/create-projection-node.ts" target="_blank" rel="noreferrer">this part of the Framer Motion source code</a> seems to be a good place to start — it looks like they maintain their own DOM-like tree of motion components using something called &#34;projection nodes&#34;.</p>
<h2 id="summary">Summary</h2>
<p>If you made it all the way here, thank you! Let&#39;s recap what we&#39;ve learned.</p>
<p>Ultimately, we wanted to figure out <strong>how to animate layout changes</strong>, that is, changes in an element that affect the position of itself and all surrounding elements.</p>
<p>We started off using CSS but then realized it fell short in a couple of ways:</p>
<ol><li><p>You can&#39;t use CSS to animate un-animatable properties like <code>justify-content</code>;</p></li><li><p>Animating layout properties can be slow in lower-end devices;</p></li></ol>
<p>In the process, we found out that animations using <code>transform</code> are fast and easy on the browser, so we turned our attention to FLIP - a technique used by Framer Motion that exploits this property.</p>
<p>While implementing FLIP with position changes was pretty straightforward, the same can&#39;t be said for changes in size. When we start considering changes in size, we find we have to start worrying about:</p>
<ol><li><p>How a change in size affects the distance the element traveled;</p></li><li><p>Correcting distortions in child elements caused by transforms in the parent element;</p></li></ol>
<p>Once we figured out both of these problems, we ended up with a pretty solid implementation of automatic layout animation!</p>
<p>That&#39;s all for today; thanks for reading!</p>
<h2 id="addendum">Addendum</h2>
<p><a href="https://twitter.com/mattgperry" target="_blank" rel="noreferrer">Matt Perry</a>, the mastermind behind Framer Motion, graciously offered to expand a bit on how Framer Motion works in his <a href="https://www.getrevue.co/profile/nowinmotion" target="_blank" rel="noreferrer">Now in Motion newsletter</a>:</p>
<blockquote>
<p>A straightforward FLIP implementation would be a “view” transition - the difference between how the viewport looks before and after a change.</p>
</blockquote>
<blockquote>
<p>Whereas Framer Motion is attempting to do “layout” transitions. As <a href="https://codesandbox.io/s/framer-motion-page-scroll-animation-forked-2585g2?utm_campaign=Now+in+Motion&amp;utm_medium=email&amp;utm_source=Revue+newsletter&amp;file=/src/App.tsx" target="_blank" rel="noreferrer">this sandbox demonstrates</a>, when a page scroll is thrown into play, we don’t want to animate this vertical change. It doesn’t look good when view transitions animate page scroll.</p>
</blockquote>
<blockquote>
<p>A further key difference between FLIP is that rather than animating this initial “inverted” delta down to 0, while we do this, once every frame we first convert this delta to a bounding box where we want the animating element to appear on screen every frame. We call this a “projection target”.</p>
</blockquote>
<blockquote>
<p>This is how we perform scale correction and shared element transitions. By getting this projection target as a box, once every frame we can apply all the transforms currently applied to this box by its ancestors. From there, we can calculate the transform actually required to get the element from its transformed and scrolled position on screen, to the projection target.</p>
</blockquote>
<blockquote>
<p>Performing shared element transitions becomes a matter of calculating a transform that gets a second element into this same projection target.</p>
</blockquote>
<p>Really appreciative of Matt here to chime in and provide more context!</p></article></div>
  </body>
</html>
