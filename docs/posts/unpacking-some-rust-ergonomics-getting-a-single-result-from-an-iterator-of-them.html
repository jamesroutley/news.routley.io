<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/rust-vec-of-result/">Original</a>
    <h1>Unpacking some Rust ergonomics: getting a single Result from an iterator of them</h1>
    
    <div id="readability-page-1" class="page"><div><p>Rust has a lot of nice things that make life easy.
One of the least discussed ones is also one of my favorites.
It&#39;s a little nugget in the standard library that makes handling possible failures a lot easier.
And it&#39;s not even baked inâ€”it just falls out from the type system.</p>

<p>When you do something that can fail, you get back a type that reflects that.
You&#39;ll get either a <code>Result&lt;T, E&gt;</code> or an <code>Option&lt;T&gt;</code>, depending on if it&#39;s something that could fail or could just not be present.
When you work in Rust, you end up getting <em>very</em> comfortable with these types, and there are a lot of ergonomics to help you.</p>
<p>One of those bits of ergonomics that I love is how you can collect an iterable of <code>Results</code> into a <code>Result</code> of a <code>Vec</code>, effectively flipping the result inside out: you would expect a <code>Vec&lt;Result&lt;T, E&gt;&gt;</code>, and you can get a <code>Result&lt;Vec&lt;T&gt;, E&gt;</code> instead!
The same thing applies for <code>Option</code>.
Let&#39;s see it in action.</p>
<p>Suppose you have a function which could fail, and you call it a number of times.
Something like this:</p>
<pre data-lang="rust"><code data-lang="rust">fn fetch_chunk(from: usize, to: usize) -&gt; Result&lt;Row, Error&gt; {
    // some implementation
}
</code></pre>
<p>When we call it, and if we collect directly, we get a bunch of <code>Result</code>s:</p>
<pre><code>let chunks: Vec&lt;Result&lt;Row, Error&gt;&gt; =
    indexes.iter().map(|i| fetch_chunk(i, i+1)).collect();
</code></pre>
<p>Now this is kind of ugly to deal with.
In a lot of cases, it <em>is</em> the type you want, because you can see which operations failed
.
But sometimes, you just want to know if <em>anything</em> failed, and in that case you can collect directly into a <code>Result</code>.</p>
<pre><code>let chunks: Result&lt;Vec&lt;Row&gt;, Error&gt; =
    indexes.iter().map(|i| fetch_chunk(i, i+1)).collect();
</code></pre>
<p>This is the same code with a different type signature, and it collects into a <em>different type</em>.
That&#39;s pretty darn cool, if you ask me.
Just by which type you ask for, you get that one back!</p>
<p>This pattern of pulling the Result from the inside to the outside is one that&#39;s present in functional programming languages.
I was trying to find a name for it, and the closest parallel we
 found was Haskell&#39;s <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Monad.html#v:sequence"><code>sequence</code></a>, which is somewhat unsatisfying in the end since it feels like there should be a name for the <em>concept</em> of this pulling the result type from the inside to the outside.</p>
<p>You can do other nice things in a similar way here.</p>

<p>Under the hood, there&#39;s no magic here.
This isn&#39;t built into Rust.
It&#39;s just part of the standard library, and you can implement things like that for your own types!</p>
<p><code>collect</code> is the method where the magic happens.
It&#39;s a very general method on <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterators</a>, with this type from <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">the docs</a>:</p>
<pre><code>fn collect&lt;B&gt;(self) -&gt; B
where
    B: FromIterator&lt;Self::Item&gt;,
    Self: Sized,
</code></pre>
<p>This is basically saying that for any type that implements <code>FromIterator</code> for the type that this iterator yields, you can collect it into that type.
An easy example is how an iterator with <code>Item = i32</code> can be used to collect into a <code>Vec&lt;i32&gt;</code>, since <code>Vec</code> implements <code>FromIterator</code> for all types.</p>
<p>And then the magic is these two impls:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#impl-FromIterator%3CResult%3CA,+E%3E%3E-for-Result%3CV,+E%3E"><code>FromIterator&lt;Result&lt;A, E&gt;&gt; for Result&lt;V, E&gt; where V: FromIterator&lt;A&gt;</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#impl-FromIterator%3COption%3CA%3E%3E-for-Option%3CV%3E"><code>FromIterator&lt;Option&lt;A&gt;&gt; for Option&lt;V&gt; where V: FromIterator&lt;A&gt;</code></a></li>
</ul>
<p>We know that that type <code>V</code> can be our Vec or whatever, so these implementations provide what we need to get the whole magical <code>collect</code> behavior to fall out.
The types are <em>scary</em>, though, especially if you&#39;re not very familiar with strongly typed FP languages.</p>

<p>Things like this are hard to discover on your own in Rust.
That&#39;s one of my laments with the language.</p>
<p>How I discovered it: initally, I think I saw it in the book or when pairing with other people.
Later on, I also saw it in the <code>collect</code> docs, which gave some very useful examples of how to use it for this use case.
It&#39;s also explained in <a href="https://doc.rust-lang.org/rust-by-example/error/iter_result.html">Rust By Example</a>
, along with a few other examples.</p>
<p>The type system here does get in the way of good discoverability, in my opinion, since it&#39;s not super clear what combinations of traits on which types will give you what you need.
I don&#39;t know how to improve it, other than talking gleefully about things that are fun like this and spreading the word.</p>
<p>What other cool Rust things should the world know about?</p>
</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, subscribe to the <a href="https://theconversation.com/newsletter">newsletter</a> or use the <a href="https://theconversation.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
