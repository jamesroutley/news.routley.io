<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://isamert.net/2022/01/04/dealing-with-apis-jsons-and-databases-in-org-mode.html">Original</a>
    <h1>Dealing with APIs, JSON and databases in org-mode</h1>
    
    <div id="readability-page-1" class="page"><div id="text-custom-executers-for-custom-modes">
<p>
Our executer function example is for <code>json-mode</code>, an already-existing major mode. You can also create arbitrary major modes, create executers for them and you can start using them in your org-mode documents right away. Here is another example case: We use Couchbase quite a lot at work and I have bunch of queries saved in org-mode documents. It would be good to have an <code>ob-n1ql</code> package (<a href="https://www.couchbase.com/products/n1ql">N1QL</a> is Couchbase&#39;s SQL-like language) that let&#39;s me run <a href="https://www.couchbase.com/">Couchbase</a> queries right inside org-mode. I looked it up found no N1QL mode for Emacs, let alone a package like <code>ob-n1ql</code> for org-mode. But it was quite easy to roll my own, see this:
</p>

<ul>
<li>First I created a derived major mode named <code>n1ql-mode</code>. N1QL is just like SQL, so I simply extended it. This way we get syntax highlighting and bunch of other stuff for free.</li>
</ul>
<div>
<pre>(define-derived-mode n1ql-mode sql-mode &#34;n1ql-mode&#34;)
</pre>
</div>

<ul>
<li>Then I created a function that executes given N1QL query using the <a href="https://docs.couchbase.com/server/current/tools/cbq-shell.html">cbq</a> command line tool that Couchbase provides:</li>
</ul>
<div>
<pre>(cl-defun isamert/cbq (query &amp;key host username password (select &#34;.&#34;))
&#34;Run a couchbase query and return the result.&#34;
(with-temp-buffer
  (insert query)
  (shell-command-on-region
   (point-min)
   (point-max)
   (format &#34;cbq -quiet -engine %s -credentials &#39;%s&#39;&#34;
           host
           (format &#34;%s:%s&#34; username password))
   nil t)
  ;; Do some cleaning up
  (replace-regexp-in-region &#34;^cbq&gt; &#34; &#34;&#34; (point-min) (point-max))
  ;; N1QL returns a JSON response, so it might be a good idea to
  ;; provide a way to filter the result with jq, like what ob-http
  ;; does with it :select parameter
  (shell-command-on-region (point-min) (point-max) (format &#34;jq -r %s&#34; select) nil t)
  (buffer-string)))
</pre>
</div>

<ul>
<li>And finally, an executer function for N1QL mode, so that we can run our queries right inside org-mode:</li>
</ul>
<div>
<pre>(defun org-babel-execute:n1ql (body params)
  (isamert/cbq
   body
   :host (alist-get :host params)
   :username (alist-get :username params)
   :password (alist-get :password params)
   :select (alist-get :select params)))
</pre>
</div>

<p>
â€¦and this is how you would use it:
</p>
<div>
<pre>#+begin_src n1ql :host DB_HOST :username DB_USERNAME :password DB_PASSWORD
  SELECT * FROM SomeTable LIMIT 10;
#+end_src
</pre>
</div>

<p>
You can turn any REPL/CLI tool into a language that can be executed right inside an org-mode document. This brings you the benefit of having interactive notes. Your learning environment and testing environment would be same and this let&#39;s you progress quicker. I even do production troubleshooting inside org-mode documents, so that at the end of the day I have a clear document that shows exact runnable steps to solve a problem.
</p>
</div></div>
  </body>
</html>
