<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pganalyze.com/blog/how-postgres-chooses-index">Original</a>
    <h1>How Postgres chooses which index to use for a query</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>
<span>
      <span></span>
  <img alt="Index usage of a Hash Join compared to a Nested Loop Join" title="Index usage of a Hash Join compared to a Nested Loop Join" src="http://harihareswara.net/static/d92dffc7749fada6f63b9488297dee5b/1d69c/nested_loop_vs_hash_join.png" srcset="/static/d92dffc7749fada6f63b9488297dee5b/4dcb9/nested_loop_vs_hash_join.png 188w, /static/d92dffc7749fada6f63b9488297dee5b/5ff7e/nested_loop_vs_hash_join.png 375w, /static/d92dffc7749fada6f63b9488297dee5b/1d69c/nested_loop_vs_hash_join.png 750w, /static/d92dffc7749fada6f63b9488297dee5b/eb2af/nested_loop_vs_hash_join.png 954w" sizes="(max-width: 750px) 100vw, 750px" loading="lazy" decoding="async"/>
    </span>
</p>
<p>Using Postgres sometimes feels like magic. But sometimes the magic is too much, such as when you are trying to understand the reason behind a seemingly bad Postgres query plan.</p>
<p>I&#39;ve often times found myself in a situation where I asked myself: <strong>&#34;Postgres, what are you thinking?&#34;</strong>. Staring at an EXPLAIN plan, seeing a <code>Sequential Scan</code>, and being puzzled as to why Postgres isn&#39;t doing what I am expecting.</p>
<p>This has lead me down the path of reading the Postgres source, in search for answers. Why is Postgres choosing a particular index over another one, or not choosing an index altogether?</p>
<p>In this blog post I aim to give an introduction to how the Postgres planner analyzes your query, and how it decides which indexes to use. Additionally, <strong>we’ll look at a puzzling situation</strong> where the join type can impact which indexes are being used.</p>
<p>We’ll look at a lot of Postgres source code, but if you are short on time, you might want to jump to <a href="#understanding-b-tree-index-cost-estimates">how B-tree index costing works</a>, and <a href="#parameterized-index-scans-or-why-nested-loop-are-sometimes-a-good-join-type">why Nested Loop Joins impact index usage</a>.</p>
<p>We’ll also talk about an <a href="#new-features-coming-soon-to-pganalyze">upcoming pganalyze feature</a> at the very end!</p>

<h2 id="a-tour-of-postgres-parse-analysis-and-early-stages-of-planning"><a href="#a-tour-of-postgres-parse-analysis-and-early-stages-of-planning" aria-label="a tour of postgres parse analysis and early stages of planning permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A tour of Postgres: Parse analysis and early stages of planning</h2>
<p>To start with, let’s look at a query’s lifecycle in Postgres. There are four important steps in how a query is handled:</p>
<ol>
<li>Parsing: Turning query text into an Abstract Syntax Tree (AST)</li>
<li>Parse analysis: Turning table names into actual references to table objects</li>
<li>Planning: Finding and creating the optimal query plan</li>
<li>Execution: Executing the query plan</li>
</ol>
<p>For understanding how the planner chooses which indexes to use, let’s first take a look at what parse analysis does.</p>
<p>Whilst there are multiple entry points into parse analysis, depending if you have query parameters or not, the core function in parse analysis is <code>transformStmt</code> (<a href="https://github.com/postgres/postgres/blob/d22646922d66012705e0e2948cfb5b4a07092a29/src/backend/parser/analyze.c#L313">source</a>):</p>
<div data-language="c"><pre><code>
Query <span>*</span>
<span>transformStmt</span><span>(</span>ParseState <span>*</span>pstate<span>,</span> Node <span>*</span>parseTree<span>)</span>
<span>{</span></code></pre></div>
<p>This takes the raw parse tree output (from the first step), and returns a Query struct. It has a lot of specific cases, as it handles both regular SELECTs as well as UPDATEs and other DML statements. Note that utility statements (DDL, etc) mostly get passed through to the execution phase.</p>
<p>Since we are interested in tables and indexes, let’s take a closer look at how parse analysis handles the FROM clause:</p>
<div data-language="c"><pre><code><span>void</span>
<span>transformFromClause</span><span>(</span>ParseState <span>*</span>pstate<span>,</span> List <span>*</span>frmList<span>)</span>
<span>{</span>
   ListCell   <span>*</span>fl<span>;</span>
 
   
   <span>foreach</span><span>(</span>fl<span>,</span> frmList<span>)</span>
   <span>{</span>
       …
 
       n <span>=</span> <span>transformFromClauseItem</span><span>(</span>pstate<span>,</span> n<span>,</span>
                                   <span>&amp;</span>nsitem<span>,</span>
                                   <span>&amp;</span>namespace<span>)</span><span>;</span>
 
…

<span>static</span> Node <span>*</span>
<span>transformFromClauseItem</span><span>(</span>ParseState <span>*</span>pstate<span>,</span> Node <span>*</span>n<span>,</span>
                       ParseNamespaceItem <span>*</span><span>*</span>top_nsitem<span>,</span>
                       List <span>*</span><span>*</span>namespace<span>)</span>
<span>{</span>
…</code></pre></div>
<p>Postgres already separates between the range table list (essentially a list of all the tables referenced by the query), and the joinlist. This distinction will also be visible at a later point in the planner.</p>
<p>Note that at this point Postgres has not yet made up its mind which indexes to use - it just decided that the FROM reference you called “foobar” is actually the table “foobar” in the “public” schema with OID 16424.</p>
<p>This information now gets stored in the Query struct, which is the result of the parse analysis phase. This Query struct is then passed into the planner, and that’s where it gets interesting.</p>
<h3 id="four-levels-of-planning-a-query"><a href="#four-levels-of-planning-a-query" aria-label="four levels of planning a query permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Four levels of planning a query</h3>
<p>Commonly we would start with the <code>standard_planner</code> (<a href="https://github.com/postgres/postgres/blob/db0d67db2401eb6238ccc04c6407a4fd4f985832/src/backend/optimizer/plan/planner.c#L282">source</a>) function as an entry point into the Postgres planner:</p>
<div data-language="c"><pre><code>PlannedStmt <span>*</span>
<span>standard_planner</span><span>(</span>Query <span>*</span>parse<span>,</span> <span>const</span> <span>char</span> <span>*</span>query_string<span>,</span> <span>int</span> cursorOptions<span>,</span>
                ParamListInfo boundParams<span>)</span>
<span>{</span></code></pre></div>
<p>This takes our <code>Query</code> struct, and ultimately returns a <code>PlannedStmt</code>. For reference, the <code>PlannedStmt</code> struct (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/include/nodes/plannodes.h#L43">source</a>) looks like this:</p>
<div data-language="c"><pre><code>
<span>typedef</span> <span>struct</span> <span>PlannedStmt</span>
<span>{</span>
   NodeTag     type<span>;</span>
 
   CmdType     commandType<span>;</span>    
 
…
 
   <span>struct</span> <span>Plan</span> <span>*</span>planTree<span>;</span>      
 
…</code></pre></div>
<p>The tree of plan nodes is what you would be familiar with if you’ve looked at an EXPLAIN output before - ultimately EXPLAIN is based on walking that plan tree and showing you a text/JSON/etc version of it.</p>
<p>The core function of the planner is best described in these lines of <code>standard_planner</code>:</p>
<div data-language="c"><pre><code>
root <span>=</span> <span>subquery_planner</span><span>(</span>glob<span>,</span> parse<span>,</span> <span>NULL</span><span>,</span>
                        false<span>,</span> tuple_fraction<span>)</span><span>;</span>


final_rel <span>=</span> <span>fetch_upper_rel</span><span>(</span>root<span>,</span> UPPERREL_FINAL<span>,</span> <span>NULL</span><span>)</span><span>;</span>
best_path <span>=</span> <span>get_cheapest_fractional_path</span><span>(</span>final_rel<span>,</span> tuple_fraction<span>)</span><span>;</span>

top_plan <span>=</span> <span>create_plan</span><span>(</span>root<span>,</span> best_path<span>)</span><span>;</span></code></pre></div>
<p>The planner first creates what are called “paths” using the <code>subquery_planner</code> (which may recursively call itself), and then the planner picks the best path. Best on this best path, the actual plan tree is constructed.</p>
<p>For understanding how the planner chose which indexes to use, we must therefore look at paths, not at plan nodes. Let’s see what <code>subquery_planner</code> (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/backend/optimizer/plan/planner.c#L596">source</a>) does:</p>
<div data-language="c"><pre><code>
PlannerInfo <span>*</span>
<span>subquery_planner</span><span>(</span>PlannerGlobal <span>*</span>glob<span>,</span> Query <span>*</span>parse<span>,</span>
                PlannerInfo <span>*</span>parent_root<span>,</span>
                bool hasRecursion<span>,</span> <span>double</span> tuple_fraction<span>)</span>
<span>{</span></code></pre></div>
<p>As described in the comment, this handles each sub-SELECT separately - but note that even if the original query contains a written sub-SELECT, the planner may optimize it away to pull it up into the parent planning process, if possible.</p>
<p>For the purposes of focusing on index choice, here are the two key parts of <code>subquery_planner</code>:</p>
<div data-language="c"><pre><code>
<span>if</span> <span>(</span>parse<span>-&gt;</span>resultRelation <span>&amp;&amp;</span>
    <span>rt_fetch</span><span>(</span>parse<span>-&gt;</span>resultRelation<span>,</span> parse<span>-&gt;</span>rtable<span>)</span><span>-&gt;</span>inh<span>)</span>
    <span>inheritance_planner</span><span>(</span>root<span>)</span><span>;</span>
<span>else</span>
    <span>grouping_planner</span><span>(</span>root<span>,</span> false<span>,</span> tuple_fraction<span>)</span><span>;</span>

…


<span>set_cheapest</span><span>(</span>final_rel<span>)</span><span>;</span></code></pre></div>
<p>This method also optimizes for the cheapest path - we’ll see more on that in a moment. But for now, let’s go deeper down the rabbit hole and look at <code>grouping_planner</code> (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/backend/optimizer/plan/planner.c#L1253">source</a>):</p>
<div data-language="c"><pre><code>
<span>static</span> <span>void</span>
<span>grouping_planner</span><span>(</span>PlannerInfo <span>*</span>root<span>,</span> bool inheritance_update<span>,</span>
                <span>double</span> tuple_fraction<span>)</span>
<span>{</span></code></pre></div>
<p>Reading through its code, turns out we’re still not there. It’s actually <code>query_planner</code> that we are looking for, as described in this comment:</p>
<div data-language="c"><pre><code>RelOptInfo <span>*</span>current_rel<span>;</span>
…

current_rel <span>=</span> <span>query_planner</span><span>(</span>root<span>,</span> standard_qp_callback<span>,</span> <span>&amp;</span>qp_extra<span>)</span><span>;</span></code></pre></div>
<p>Before we dive into the <code>query_planner</code> method, let’s pause for a moment and look at what the result of <code>query_planner</code> is, the <code>RelOptInfo</code> struct:</p>
<h3 id="breaking-down-a-query-into-tables-being-scanned-reloptinfo-and-restrictinfo-structs"><a href="#breaking-down-a-query-into-tables-being-scanned-reloptinfo-and-restrictinfo-structs" aria-label="breaking down a query into tables being scanned reloptinfo and restrictinfo structs permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Breaking down a query into tables being scanned (RelOptInfo and RestrictInfo structs)</h3>
<p>In the Postgres planner, <code>RelOptInfo</code> is best described as the internal representation of a particular table that is being scanned (with either a sequential scan, or an index scan).</p>
<p>When trying to understand how Postgres interprets your query, adding debug information that shows RelOptInfo would be the closest that you can get to seeing which tables Postgres is going to scan, and how it makes a decision between different scan methods, such as an Index Scan.</p>
<p>RelOptInfo (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/include/nodes/pathnodes.h#L674">source</a>) has many details to it, but the key parts for our focus on indexing are these:</p>
<div data-language="c"><pre><code>
<span>typedef</span> <span>struct</span> <span>RelOptInfo</span>
<span>{</span>
…
   List       <span>*</span>pathlist<span>;</span>       
…
   List       <span>*</span>baserestrictinfo<span>;</span>   
…
   List       <span>*</span>joininfo<span>;</span>       
…
<span>}</span></code></pre></div>
<p>Before we interpret this, let’s look at <code>RestrictInfo</code> (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/include/nodes/pathnodes.h#L2067">source</a>):</p>
<div data-language="c"><pre><code>
<span>typedef</span> <span>struct</span> <span>RestrictInfo</span>
<span>{</span>
   NodeTag     type<span>;</span>
   Expr       <span>*</span>clause<span>;</span>         
…
<span>}</span></code></pre></div>
<p>A note on terminology: This references “base relations”, which are relations (aka tables) that are looked at solely on their individual basis, as compared to in the context of a JOIN.</p>
<p>In the code sample, <code>RestrictInfo</code> is how our WHERE clause and JOIN conditions get represented. This is the part that is key to understanding how Postgres compares your query against the indexes that exist.</p>
<p>You can think about it this way - for each table that’s included in the query, Postgres generates two lists of “restriction” clauses:</p>
<ul>
<li><strong>Base restriction clauses</strong>: Typically part of your WHERE clause, and are expressions that involve only the table itself - for example <code>users.id = 123</code></li>
<li><strong>Join clauses</strong>: Typically part of your JOIN clause, and expressions that involve multiple tables - for example <code>users.id = comments.user_id</code></li>
</ul>
<p>Note the reason that Postgres calls these “restriction” clauses is because they restrict (or filter) the amount of data that is being returned from your table. <strong>And how can we effectively filter data from a table? By using an index!</strong></p>
<p>The base restriction clauses will typically be used to filter down the amount of data that is being returned from the table. But join clauses oftentimes will not, as they are only used as part of the matching of rows that happens during the JOIN operation.</p>
<p>The one exception to this are <a href="http://harihareswara.net/docs/explain/join-nodes/nested-loop">Nested Loop Joins</a> - but we’ll come back to that.</p>
<p>
<a href="http://harihareswara.net/ebooks/postgres-indexing">
<span>
      <span></span>
  <img alt="Effective Indexing eBook promotion banner" title="Effective Indexing eBook promotion banner" src="http://harihareswara.net/static/b24fdd95dbc38757fe354c86d9ad9aaa/acb04/promo_ebook.jpg" srcset="/static/b24fdd95dbc38757fe354c86d9ad9aaa/bc01b/promo_ebook.jpg 188w, /static/b24fdd95dbc38757fe354c86d9ad9aaa/bf173/promo_ebook.jpg 375w, /static/b24fdd95dbc38757fe354c86d9ad9aaa/acb04/promo_ebook.jpg 750w, /static/b24fdd95dbc38757fe354c86d9ad9aaa/ec605/promo_ebook.jpg 1125w, /static/b24fdd95dbc38757fe354c86d9ad9aaa/c58a3/promo_ebook.jpg 1500w" sizes="(max-width: 750px) 100vw, 750px" loading="lazy" decoding="async"/>
    </span>
</a>
</p>
<h3 id="choosing-different-paths-and-scan-methods"><a href="#choosing-different-paths-and-scan-methods" aria-label="choosing different paths and scan methods permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Choosing different paths and scan methods</h3>
<p>Let’s go back to <code>query_planner</code> (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/backend/optimizer/plan/planmain.c#L55">source</a>), and what it does:</p>
<div data-language="c"><pre><code>
RelOptInfo <span>*</span>
<span>query_planner</span><span>(</span>PlannerInfo <span>*</span>root<span>,</span>
             query_pathkeys_callback qp_callback<span>,</span> <span>void</span> <span>*</span>qp_extra<span>)</span>
<span>{</span>
…
   
   <span>add_base_rels_to_query</span><span>(</span>root<span>,</span> <span>(</span>Node <span>*</span><span>)</span> parse<span>-&gt;</span>jointree<span>)</span><span>;</span>
 
…
   
   final_rel <span>=</span> <span>make_one_rel</span><span>(</span>root<span>,</span> joinlist<span>)</span><span>;</span>
 
   <span>return</span> final_rel<span>;</span>
<span>}</span></code></pre></div>
<p>The main point of <code>query_planner</code> itself is to create a set of <code>RelOptInfo</code> nodes, do a bunch of processing involving them, and then passing them to <code>make_one_rel</code>. As that name says, it creates one “final rel”, which is also a <code>RelOptInfo</code> node, that is then used to create our final plan.</p>
<p>We’ve looked at a bunch of code already, but now it’s time to get to the exciting part!</p>
<p>The implementation of <code>make_one_rel</code> (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/backend/optimizer/path/allpaths.c#L153">source</a>) sits in a file with the important sounding name of <code>allpaths.c</code> - and as referenced earlier, when we talk about plan choices, we need to understand which path is chosen, as that is used to then create a plan node.</p>
<div data-language="c"><pre><code>
RelOptInfo <span>*</span>
<span>make_one_rel</span><span>(</span>PlannerInfo <span>*</span>root<span>,</span> List <span>*</span>joinlist<span>)</span>
<span>{</span>
…
   
   <span>set_base_rel_sizes</span><span>(</span>root<span>)</span><span>;</span>
 
…
 
   
   <span>set_base_rel_pathlists</span><span>(</span>root<span>)</span><span>;</span>
   
   rel <span>=</span> <span>make_rel_from_joinlist</span><span>(</span>root<span>,</span> joinlist<span>)</span><span>;</span>
 
   <span>return</span> rel<span>;</span>
<span>}</span></code></pre></div>
<p>Paths are chosen in three steps:</p>
<ol>
<li>Estimate the sizes of the involved tables</li>
<li>Find the best path for each base relation</li>
<li>Find the best path for the entire join tree</li>
</ol>
<p>The first step is mainly concerned with size estimates as they relate to the output of scanning the relation. This impacts the cost and rows numbers you are familiar with from EXPLAIN - and this may impact joins, but typically should not directly impact index usage.</p>
<p>Now step 2 is key to our goal here. And <code>set_base_rel_pathlists</code> ultimately calls <code>set_plain_rel_pathlist</code> (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/backend/optimizer/path/allpaths.c#L767">source</a>), which finally looks like what we are interested in:</p>
<div data-language="c"><pre><code>
<span>static</span> <span>void</span>
<span>set_plain_rel_pathlist</span><span>(</span>PlannerInfo <span>*</span>root<span>,</span> RelOptInfo <span>*</span>rel<span>,</span> RangeTblEntry <span>*</span>rte<span>)</span>
<span>{</span>
   …
 
   
   <span>add_path</span><span>(</span>rel<span>,</span> <span>create_seqscan_path</span><span>(</span>root<span>,</span> rel<span>,</span> required_outer<span>,</span> <span>0</span><span>)</span><span>)</span><span>;</span>
 
   
   <span>if</span> <span>(</span>rel<span>-&gt;</span>consider_parallel <span>&amp;&amp;</span> required_outer <span>==</span> <span>NULL</span><span>)</span>
       <span>create_plain_partial_paths</span><span>(</span>root<span>,</span> rel<span>)</span><span>;</span>
 
   
   <span>create_index_paths</span><span>(</span>root<span>,</span> rel<span>)</span><span>;</span>
 
   
   <span>create_tidscan_paths</span><span>(</span>root<span>,</span> rel<span>)</span><span>;</span>
<span>}</span></code></pre></div>
<h2 id="where-index-scans-are-made"><a href="#where-index-scans-are-made" aria-label="where index scans are made permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Where Index Scans are made</h2>
<h3 id="creating-the-two-types-of-index-scans-plain-vs-parameterized"><a href="#creating-the-two-types-of-index-scans-plain-vs-parameterized" aria-label="creating the two types of index scans plain vs parameterized permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating the two types of index scans: plain vs parameterized</h3>
<p>Let’s look at <code>create_index_paths</code> (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/backend/optimizer/path/indxpath.c#L235">source</a>), since we want to see how indexes are picked:</p>
<div data-language="c"><pre><code>
<span>void</span>
<span>create_index_paths</span><span>(</span>PlannerInfo <span>*</span>root<span>,</span> RelOptInfo <span>*</span>rel<span>)</span>
<span>{</span>
…
   
   <span>foreach</span><span>(</span>lc<span>,</span> rel<span>-&gt;</span>indexlist<span>)</span>
   <span>{</span>
       IndexOptInfo <span>*</span>index <span>=</span> <span>(</span>IndexOptInfo <span>*</span><span>)</span> <span>lfirst</span><span>(</span>lc<span>)</span><span>;</span>
 
       …
 
       
       <span>if</span> <span>(</span>index<span>-&gt;</span>indpred <span>!=</span> NIL <span>&amp;&amp;</span> <span>!</span>index<span>-&gt;</span>predOK<span>)</span>
           <span>continue</span><span>;</span>
 
       
       <span>match_restriction_clauses_to_index</span><span>(</span>root<span>,</span> index<span>,</span> <span>&amp;</span>rclauseset<span>)</span><span>;</span>
 
       
       <span>get_index_paths</span><span>(</span>root<span>,</span> rel<span>,</span> index<span>,</span> <span>&amp;</span>rclauseset<span>,</span>
                       <span>&amp;</span>bitindexpaths<span>)</span><span>;</span>
 
       
       <span>match_join_clauses_to_index</span><span>(</span>root<span>,</span> rel<span>,</span> index<span>,</span>
                                   <span>&amp;</span>jclauseset<span>,</span> <span>&amp;</span>joinorclauses<span>)</span><span>;</span>
…
       
       <span>if</span> <span>(</span>jclauseset<span>.</span>nonempty <span>||</span> eclauseset<span>.</span>nonempty<span>)</span>
           <span>consider_index_join_clauses</span><span>(</span>root<span>,</span> rel<span>,</span> index<span>,</span>
                                       <span>&amp;</span>rclauseset<span>,</span>
                                       <span>&amp;</span>jclauseset<span>,</span>
                                       <span>&amp;</span>eclauseset<span>,</span>
                                       <span>&amp;</span>bitjoinpaths<span>)</span><span>;</span>
   <span>}</span>
 
…
<span>}</span></code></pre></div>
<p>There are a lot of things to take in here - and we’ve already removed BitmapOr/BitmapAnd index scans from this code sample.</p>
<p>First of all, <strong>this builds two types of index scans</strong>:</p>
<ol>
<li><strong>Plain index scans</strong>, that only use the base restriction clauses</li>
<li><strong>Parameterized index scans</strong>, that use both base restriction clauses and join clauses</li>
</ol>
<p>We’ll talk more about the second case in a moment.</p>
<p>Other key aspects to understand:</p>
<ul>
<li>Partial indexes (i.e. those with an attached WHERE clause on the index definition) are matched against the set of restriction clauses and discarded here if they don’t match</li>
<li>Each index is both considered for an Index Scan and Index Only Scan (through the “build_index_paths” method), as well as for a Bitmap Heap Scan / Bitmap Index Scan</li>
<li>Each potential way of using an index gets a cost assigned - and this cost decides whether Postgres actually chooses the index (see earlier notion of the “best path”), or not</li>
</ul>
<p>For understanding how costing works, you can look at the <code>cost_index</code> function (<a href="https://github.com/postgres/postgres/blob/9f91344223aad903ff70301f40183691a89f6cd4/src/backend/optimizer/path/costsize.c#L492">source</a>), which gets called from <code>build_index_paths</code> through a few hoops.</p>
<div data-language="c"><pre><code>
<span>void</span>
<span>cost_index</span><span>(</span>IndexPath <span>*</span>path<span>,</span> PlannerInfo <span>*</span>root<span>,</span> <span>double</span> loop_count<span>,</span>
          bool partial_path<span>)</span>
<span>{</span>
…
   
   <span>amcostestimate</span><span>(</span>root<span>,</span> path<span>,</span> loop_count<span>,</span>
                  <span>&amp;</span>indexStartupCost<span>,</span> <span>&amp;</span>indexTotalCost<span>,</span>
                  <span>&amp;</span>indexSelectivity<span>,</span> <span>&amp;</span>indexCorrelation<span>,</span>
                  <span>&amp;</span>index_pages<span>)</span><span>;</span></code></pre></div>
<p>Whilst there are other factors in costing an index scan, the main responsibility falls to the <a href="https://www.postgresql.org/docs/current/indexam.html">Index Access Method</a>.</p>
<h3 id="understanding-b-tree-index-cost-estimates"><a href="#understanding-b-tree-index-cost-estimates" aria-label="understanding b tree index cost estimates permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Understanding B-tree index cost estimates</h3>
<p>The most common index access method (or index type) is B-tree, so let’s look at <code>btcostestimate</code>:</p>
<div data-language="c"><pre><code><span>void</span>
<span>btcostestimate</span><span>(</span>PlannerInfo <span>*</span>root<span>,</span> IndexPath <span>*</span>path<span>,</span> <span>double</span> loop_count<span>,</span>
              Cost <span>*</span>indexStartupCost<span>,</span> Cost <span>*</span>indexTotalCost<span>,</span>
              Selectivity <span>*</span>indexSelectivity<span>,</span> <span>double</span> <span>*</span>indexCorrelation<span>,</span>
              <span>double</span> <span>*</span>indexPages<span>)</span>
<span>{</span>
…
   
   indexBoundQuals <span>=</span> …
 
   
   selectivityQuals <span>=</span> <span>add_predicate_to_index_quals</span><span>(</span>index<span>,</span> indexBoundQuals<span>)</span><span>;</span>
 
   btreeSelectivity <span>=</span> <span>clauselist_selectivity</span><span>(</span>root<span>,</span> selectivityQuals<span>,</span>
                                             index<span>-&gt;</span>rel<span>-&gt;</span>relid<span>,</span>
                                             JOIN_INNER<span>,</span>
                                             <span>NULL</span><span>)</span><span>;</span>
   numIndexTuples <span>=</span> btreeSelectivity <span>*</span> index<span>-&gt;</span>rel<span>-&gt;</span>tuples<span>;</span>
…
   costs<span>.</span>numIndexTuples <span>=</span> numIndexTuples<span>;</span>
   <span>genericcostestimate</span><span>(</span>root<span>,</span> path<span>,</span> loop_count<span>,</span> <span>&amp;</span>costs<span>)</span><span>;</span>
…</code></pre></div>
<p>As you can see a lot revolves around determining how many index tuples will be matched by the scan - as that’s the main expensive portion of querying a B-tree index.</p>
<p>The first step is determining the boundaries of the index scan, as it relates to the data stored in the index. In particular this is relevant for multi-column B-tree indexes, where only a subset of the columns might match the query.</p>
<p>You may have heard before about the best practice of ordering B-tree columns so the columns that are queried by an equality comparison (“=” operator) are put first, followed by one optional inequality comparison (“&lt;&gt;” operator), followed by any other columns. This recommendation is based on the physical structure of the B-tree index, and the cost model also reflects this constraint.</p>
<p>Put differently: The more specific you are with matching equality comparisons, the less parts of the index have to be scanned. This is represented here by the calculation of “btreeSelectivity”. If this number is small, the cost of the index scan will be less, as determined by “genericcostestimate” based on the estimated number of index tuples being scanned.</p>
<p>We could go on and on about this, as there are many other factors involved. But the key is thi</p>
<p><strong>For creating the ideal B-tree index, you would:</strong></p>
<ul>
<li>Focus on indexing columns used in equality comparisons</li>
<li>Index the columns with the best selectivity (i.e. being most specific), so that only a small portion of the index has to be scanned</li>
<li>Involve a small number of columns (possibly only one), to keep the index size small - and thus reduce the total number of pages in the index</li>
</ul>
<p>If you follow these steps, you will create a B-tree index that has a low cost, and that Postgres should choose.</p>
<p>Now, there is one more thing we wanted to talk about, and that involves the notion of Parameterized Index Scans:</p>
<h3 id="parameterized-index-scans-or-why-nested-loop-are-sometimes-a-good-join-type"><a href="#parameterized-index-scans-or-why-nested-loop-are-sometimes-a-good-join-type" aria-label="parameterized index scans or why nested loop are sometimes a good join type permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parameterized Index Scans, or: Why Nested Loop are sometimes a good join type</h3>
<p>As noted earlier, when Postgres looks at the potential index scans, it creates both plain index scans, and parameterized index scans.</p>
<p>Plain index scans only involve parts of your query that involve the table itself, and would typically reference the clauses found in the WHERE clause.</p>
<p>Parameterized index scans on the other hand involve the part of your query that references two different tables. Oftentimes you would find these clauses in the JOIN clause.</p>
<p>Let’s take a look at a practical example. Assume the following schema and indexes:</p>
<div data-language="sql"><pre><code><span>CREATE</span> <span>TABLE</span> t1 <span>(</span>
  id <span>bigint</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
  field <span>text</span>
<span>)</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> t2 <span>(</span>
  id <span>bigint</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
  t1_id <span>bigint</span><span>,</span>
  other_field <span>text</span>
<span>)</span><span>;</span>
<span>CREATE</span> <span>INDEX</span> t1_field_idx <span>ON</span> t1<span>(</span>field<span>)</span><span>;</span>
<span>CREATE</span> <span>INDEX</span> t2_t1_id_idx <span>ON</span> t2<span>(</span>t1_id<span>)</span><span>;</span></code></pre></div>
<p>And this query:</p>
<div data-language="sql"><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> t1
<span>JOIN</span> t2 <span>ON</span> <span>(</span>t1<span>.</span>id <span>=</span> t2<span>.</span>t1_id<span>)</span>
<span>WHERE</span> t1<span>.</span>field <span>=</span> <span>&#39;123&#39;</span></code></pre></div>
<p>We have two tables to scan - t1 and t2.</p>
<p>For t1, we can utilize a plain index scan on the <code>t1_field_idx</code> index - and that will perform well, since we have a specific value that is present in the query, that ideally matches a small amount of rows.</p>
<p>When we run an EXPLAIN on the query, the simplest plan will look like this:</p>
<div data-language="sql"><pre><code><span>EXPLAIN</span> <span>SELECT</span> <span>*</span>
<span>FROM</span> t1
<span>JOIN</span> t2 <span>ON</span> <span>(</span>t1<span>.</span>id <span>=</span> t2<span>.</span>t1_id<span>)</span>
<span>WHERE</span> t1<span>.</span>field <span>=</span> <span>&#39;123&#39;</span><span>;</span></code></pre></div>
<div data-language="text"><pre><code>                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Hash Join  (cost=13.74..37.26 rows=5 width=88)
   Hash Cond: (t2.t1_id = t1.id)
   -&gt;  Seq Scan on t2  (cost=0.00..20.70 rows=1070 width=48)
   -&gt;  Hash  (cost=13.67..13.67 rows=6 width=40)
         -&gt;  Bitmap Heap Scan on t1  (cost=4.20..13.67 rows=6 width=40)
               Recheck Cond: (field = &#39;123&#39;::text)
               -&gt;  Bitmap Index Scan on t1_field_idx  (cost=0.00..4.20 rows=6 width=0)
                     Index Cond: (field = &#39;123&#39;::text)
(8 rows)</code></pre></div>
<p>Or put visually:</p>
<p>
<span>
      <span></span>
  <img alt="Index scans of an example Hash Join" title="Index scans of an example Hash Join" src="http://harihareswara.net/static/8889223c0f4a4b4b0c07c5f35bdf24eb/f8067/hash_join.png" srcset="/static/8889223c0f4a4b4b0c07c5f35bdf24eb/4dcb9/hash_join.png 188w, /static/8889223c0f4a4b4b0c07c5f35bdf24eb/5ff7e/hash_join.png 375w, /static/8889223c0f4a4b4b0c07c5f35bdf24eb/f8067/hash_join.png 726w" sizes="(max-width: 726px) 100vw, 726px" loading="lazy" decoding="async"/>
    </span>
</p>
<p>As we can see Postgres uses a Sequential Scan on t2. Let’s add some more data into the tables, to see if that changes the plan:</p>
<div data-language="sql"><pre><code><span>INSERT</span> <span>INTO</span> t1 <span>SELECT</span> val<span>,</span> val::<span>text</span> <span>FROM</span> generate_series<span>(</span><span>0</span><span>,</span> <span>1000</span><span>)</span> <span>AS</span> x<span>(</span>val<span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> t2 <span>SELECT</span> val<span>,</span> val<span>,</span> val::<span>text</span> <span>FROM</span> generate_series<span>(</span><span>0</span><span>,</span> <span>1000</span><span>)</span> <span>AS</span> x<span>(</span>val<span>)</span><span>;</span></code></pre></div>
<p>Note that we are effectively creating exactly one entry that matches the <code>t1.field = &#39;123&#39;</code> condition, and we are also creating exactly one t2 entry for each t1 entry.</p>
<p>If we re-run the EXPLAIN, we get the following plan:</p>
<div data-language="text"><pre><code>                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Nested Loop  (cost=0.55..16.60 rows=1 width=30)
   -&gt;  Index Scan using t1_field_idx on t1  (cost=0.28..8.29 rows=1 width=11)
         Index Cond: (field = &#39;123&#39;::text)
   -&gt;  Index Scan using t2_t1_id_idx on t2  (cost=0.28..8.29 rows=1 width=19)
         Index Cond: (t1_id = t1.id)
(5 rows)</code></pre></div>
<p>
<span>
      <span></span>
  <img alt="Index scans of an example Nested Loop Join" title="Index scans of an example Nested Loop Join" src="http://harihareswara.net/static/cfc4b253e446e331010d8a28b593864b/50383/nested_loop_join.png" srcset="/static/cfc4b253e446e331010d8a28b593864b/4dcb9/nested_loop_join.png 188w, /static/cfc4b253e446e331010d8a28b593864b/5ff7e/nested_loop_join.png 375w, /static/cfc4b253e446e331010d8a28b593864b/50383/nested_loop_join.png 740w" sizes="(max-width: 740px) 100vw, 740px" loading="lazy" decoding="async"/>
    </span>
</p>
<p>As you can see, we now get an index scan on <code>t2_t1_id_idx</code>. This shows a Parameterized Index Scan in action - this is only possible because the join chosen by Postgres is a Nested Loop - not a Hash Join or Merge Join.</p>
<p>A quick summary of how different join types impact index usage:</p>
<ul>
<li><strong>Merge Join:</strong> Needs sorted output from the scan node (thus can benefit from a sorted index like B-tree), but doesn&#39;t use the JOIN clause to restrict the data when scanning the table</li>
<li><strong>Hash Join:</strong> Doesn’t need sorted output, and doesn’t use the JOIN clause to restrict the data when scanning the table</li>
<li><strong>Nested Loop Join:</strong> Doesn’t need sorted output from the scan node, but <strong>for one of the two tables</strong> uses the JOIN clause to restrict the data when scanning the table</li>
</ul>
<p>Understanding what’s in your WHERE, your JOIN clause and your likely JOIN type is key, as all three will impact index usage.</p>
<p>If you see a surprising Sequential Scan, you might want to review whether all possible index scans were parameterized index scans, and how the plan changes when you add an additional WHERE clause.</p>
<h2 id="new-features-coming-soon-to-pganalyze"><a href="#new-features-coming-soon-to-pganalyze" aria-label="new features coming soon to pganalyze permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>New features coming soon to pganalyze</h2>
<p>If you find you’re having a hard time reasoning about all of this, you are not alone!</p>
<p>The reason we’ve spent a lot of time looking through these parts of the Postgres source code, is because they form the basis of a new upcoming version of the Index Advisor.</p>
<p>And as part of the new Index Advisor, we’ll show you additional information for all scans on a table, to help you assess how Postgres uses existing indexes, and what the best indexing strategy might be.</p>
<p>Here is a sneak peek from our current design iteration:</p>
<p><span>
      <span></span>
  <img alt="Upcoming pganalyze Scans UI" title="Upcoming pganalyze Scans UI" src="http://harihareswara.net/static/9dfa02d25d55a229d1fe898a27b1c2e7/1d69c/pganalyze_scans.png" srcset="/static/9dfa02d25d55a229d1fe898a27b1c2e7/4dcb9/pganalyze_scans.png 188w, /static/9dfa02d25d55a229d1fe898a27b1c2e7/5ff7e/pganalyze_scans.png 375w, /static/9dfa02d25d55a229d1fe898a27b1c2e7/1d69c/pganalyze_scans.png 750w, /static/9dfa02d25d55a229d1fe898a27b1c2e7/78797/pganalyze_scans.png 1125w, /static/9dfa02d25d55a229d1fe898a27b1c2e7/aa440/pganalyze_scans.png 1500w, /static/9dfa02d25d55a229d1fe898a27b1c2e7/1df5b/pganalyze_scans.png 1999w" sizes="(max-width: 750px) 100vw, 750px" loading="lazy" decoding="async"/>
    </span></p><p>The same WHERE clause and JOIN clause data from the Postgres planner is shown in the Scans list, to help you make an assessment of how Postgres builds Plain Index Scans and Parameterized Index Scans for your queries.</p>
<p>But more on this another day!</p>
<h2 id="conclusion"><a href="#conclusion" aria-label="conclusion permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>In this post we’ve gone down and chased through the Postgres source code until we’ve found the place where indexing decisions happen. We’ve looked at B-tree costing in particular, and looked at a puzzling case of how Nested Loops can affect index usage, by allowing the use of Parameterized Index Scans.</p>
<p>If you optimize your queries, it helps to understand which tables you are scanning, and what the involved WHERE and JOIN clauses are. Additionally, it’s important to understand the different join types, and that only Nested Loop joins can make use of indexes on columns in the JOIN clause.</p>
<p>Do you think your peers might be interested in this article? <a href="https://twitter.com/intent/tweet?text=%E2%80%9DHow%20%23Postgres%20Chooses%20Which%20Index%20To%20Use%20For%20A%20Query%E2%80%9D%20-%20In%20this%20article%2C%20%40pganalyze%20explain%20how%20the%20Postgres%20planner%20breaks%20down%20a%20query%20into%20scans%20and%20how%20this%20impacts%20indexing%20choices%3A%20https%3A%2F%2Fpganalyze.com%2Fblog%2Fhow-postgres-chooses-index">Share this on Twitter</a>.</p>
<h2 id="other--helpful-resources"><a href="#other--helpful-resources" aria-label="other  helpful resources permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other  helpful resources</h2>
<ul>
<li>
<p><a href="https://pganalyze.com/blog/postgres-create-index">Using Postgres CREATE INDEX: Understanding operator classes, index types &amp; more</a></p>
</li>
<li>
<p><a href="https://pganalyze.com/blog/gin-index">Understanding Postgres GIN Indexes: The Good and the Bad</a></p>
</li>
<li>
<p><a href="https://pganalyze.com/blog/deconstructing-the-postgres-planner">How we deconstructed the Postgres planner to find indexing opportunities</a></p>
</li>
<li>
<p><a href="https://pganalyze.com/blog/introducing-pganalyze-index-advisor">A better way to index your Postgres database: pganalyze Index Advisor</a></p>
</li>
<li>
<p><a href="https://pganalyze.com/ebooks/postgres-indexing">Effective Indexing in Postgres eBook</a></p>
</li>
<li>
<p><a href="https://pganalyze.com/ebooks/optimizing-postgres-query-performance">Best Practices for Optimizing Postgres Query Performance eBook</a></p>
</li>
<li>
<p><a href="https://pganalyze.com/blog/5mins-postgres-optimizing-postgres-text-search-trigrams-gist-indexes">5mins of Postgres E6: Optimizing Postgres Text Search with Trigrams and GiST indexes</a></p>
</li>
</ul></div></div><div><h3>Sign up for the pganalyze newsletter</h3><p>Receive infrequent emails about interesting Postgres content around the web, new pganalyze feature releases, and new pganalyze ebooks. No spam, we promise.</p></div></div>
  </body>
</html>
