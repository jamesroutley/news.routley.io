<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tavianator.com/2025/shlx.html">Original</a>
    <h1>The Alder Lake SHLX Anomaly</h1>
    
    <div id="readability-page-1" class="page">
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        

        <!-- Set the theme before any content is loaded, prevents flash -->
        

        

        <!-- Hide / unhide sidebar before it is displayed -->
        

        <nav id="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox></mdbook-sidebar-scrollbox>
            
            
        </nav>

        <div id="page-wrapper">

            <div class="page">
                
                

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                

                <div id="content">
                    <main>
                        

<p>At the end of 2024, Harold Aptroot posted this:</p>
<blockquote>
<p>Apparently shlx is a &#34;medium latency&#34; (3 cycles) instruction on Alder Lake. My disappointment is immeasurable, and my day is ruined.</p>
<p>— <a href="https://x.com/HaroldAptroot/status/1873461353203302819">Twitter</a> / <a href="https://bsky.app/profile/haroldaptroot.bsky.social/post/3leht4lp2dk2u">Bluesky</a> / <a href="https://mastodon.gamedev.place/@harold/113737900853968212">Mastodon</a></p>
</blockquote>
<p>I was immediately <a href="https://xkcd.com/356/">nerd sniped</a> because I am into low-level performance analysis, and I happen to own an Alder Lake laptop.</p>
<p>A bit of background: <a href="https://en.wikipedia.org/wiki/Alder_Lake"><em>Alder Lake</em></a> is the 12th generation of Intel Core processors.
It&#39;s the first generation with a &#34;hybrid architecture,&#34; containing both performance (P) and efficiency (E) cores.
<a href="https://www.felixcloutier.com/x86/sarx:shlx:shrx"><code>SHLX</code></a> is a left-shift instruction introduced in the <a href="https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set#BMI2_(Bit_Manipulation_Instruction_Set_2)">BMI2</a> instruction set.
The main difference with <a href="https://www.felixcloutier.com/x86/sal:sar:shl:shr"><code>SHL</code></a> is that <code>SHLX</code> doesn&#39;t affect the <a href="https://en.wikipedia.org/wiki/FLAGS_register">FLAGS</a> register.
It&#39;s also a 3-operand instruction:</p>
<pre><code>        SHL  RAX, CL       ; RAX = RAX &lt;&lt; CL
                           ; (only CL allowed as shift count)

        SHLX RAX, RBX, RDX ; RAX = RBX &lt;&lt; RDX
                           ; (any register allowed as shift count)
</code></pre>
<p>Left-shift is one of the simplest things to implement in hardware, so it&#39;s quite surprising that it should take 3 whole CPU cycles.
It&#39;s been 1 cycle on every other CPU I&#39;m aware of.
It&#39;s even 1 cycle on Alder Lake&#39;s <em>efficiency cores</em>!
Only the performance cores have this particular performance problem.</p>
<p>The 3-cycle figure Harold cited comes from <a href="https://uops.info/html-instr/SHLX_R64_R64_R64.html#ADL-P">uops.info</a>.
They even document the exact <a href="https://uops.info/html-lat/ADL-P/SHLX_R64_R64_R64-Measurements.html#lat2-%3E1">instruction sequence</a> used in their benchmark that measured the 3-cycle latency, with a sample <a href="https://github.com/andreas-abel/nanoBench">nanoBench</a> command to reproduce it.
Running that command on my laptop indeed measures 3 cycles of latency.</p>
<p>On the other hand, other sources (like <a href="https://www.intel.com/content/www/us/en/content-details/671488/intel-64-and-ia-32-architectures-optimization-reference-manual-volume-1.html">Intel</a> and <a href="http://users.atw.hu/instlatx64/GenuineIntel/GenuineIntel00906A4_AlderLakeP_00_BC_InstLatX64.txt">InstLatX64</a>) claim the latency is 1 cycle.
What gives?
I decided to write my own benchmark to try to understand the discrepancy.</p>
<pre><code>.intel_syntax noprefix
.globl main
main:
        MOV RDX, 10000     ; RDX = 10000
        XOR RAX, RAX       ; RAX = 0
.LOOP:
        MOV RCX, 1         ; RCX = 1
.rept 10000
        SHLX RAX, RAX, RCX ; RAX = RAX &lt;&lt; RCX
                           ; (repeated 10,000 times)
.endr
        DEC RDX
        JNZ .LOOP          ; (loop 10,000 times)
        XOR EAX, EAX
        RET                ; return 0
</code></pre>
<p>This code contains an outer loop with 10,000 iterations.
Inside the loop, we initialize <code>RCX</code> to 1, then run <code>SHLX RAX, RAX, RCX</code> 10,000 times.
In total, we run <code>SHLX</code> 10,000,000 times, so all the other instructions (including the ones before <code>main()</code> runs) are negligible.
I used <code>taskset -c 0</code> to pin it to a P core, and <code>perf</code> for measurement:</p>
<pre><code>$ gcc shlx.s -o shlx
$ taskset -c 0 perf stat --cputype=core -e &#39;cycles,instructions&#39; ./shlx

 Performance counter stats for &#39;./shlx&#39;:

       301,614,809      cpu_core/cycles:u/
       100,155,910      cpu_core/instructions:u/         #    0.33  insn per cycle
</code></pre>
<p>Here we see 0.33 instructions per cycle, a.k.a. 3-cycle latency.</p>
<p>Let&#39;s try initializing <code>RCX</code> differently:</p>
<pre><code> .LOOP:
-        MOV RCX, 1
+        MOV ECX, 1
</code></pre>
<p><code>ECX</code> is the 32-bit low half of the 64-bit <code>RCX</code> register.
On x86-64, writing a 32-bit register implicitly sets the upper half of the corresponding 64-bit register to zero.
So these two instructions should behave identically.
And yet:</p>
<pre><code> Performance counter stats for &#39;./shlx&#39;:

       100,321,870      cpu_core/cycles:u/
       100,155,867      cpu_core/instructions:u/         #    1.00  insn per cycle
</code></pre>
<p>It seems like <code>SHLX</code> performs differently depending on how the shift count register is initialized.
If you use a 64-bit instruction with an immediate, performance is slow.
This is also true for instructions like <code>INC</code> (which is similar to <code>ADD</code> with a 1 immediate).</p>
<pre><code> .LOOP:
-        MOV RCX, 1
+        XOR RCX, RCX
+        INC RCX
</code></pre>
<pre><code> Performance counter stats for &#39;./shlx&#39;:

       300,138,108      cpu_core/cycles:u/
       100,165,881      cpu_core/instructions:u/         #    0.33  insn per cycle
</code></pre>
<p>On the other hand, 32-bit instructions, and 64-bit instructions without immediates (even no-op ones), make it fast.
All of these ways to initialize RCX lead to 1-cycle latency:</p>
<pre><code>.LOOP:
        MOV ECX, 1
</code></pre>
<pre><code>.LOOP:
        XOR RCX, RCX
</code></pre>
<pre><code>.LOOP:
        MOV RCX, 1
        MOV RCX, RCX
</code></pre>
<pre><code>        MOV RCX, 1
.LOOP:
        PUSH RCX
        POP RCX
</code></pre>
<p>It is very strange to me that the <em>instruction used to set the shift count register</em> can make the <code>SHLX</code> instruction 3× slower.
The 32-bit vs. 64-bit operand size distinction is especially surprising to me as <code>SHLX</code> only looks at the bottom 6 bits of the shift count.</p>
<p>I do not have a good explanation for this yet, but I will update this page if I ever figure it out.</p>

                    </main>

                    
                </div>
            </div>

            

        </div>






        
        
        

        
        
        

        <!-- Custom JS scripts -->


    </div>
    

</div>
  </body>
</html>
