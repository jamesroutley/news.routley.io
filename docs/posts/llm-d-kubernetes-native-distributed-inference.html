<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://llm-d.ai/blog/llm-d-announce">Original</a>
    <h1>llm-d, Kubernetes native distributed inference</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container">
<p>llm-d is a Kubernetes-native high-performance distributed LLM inference framework<!-- --></p>
<p>With llm-d, users can operationalize gen AI deployments with a modular, high-performance, end-to-end serving solution that leverages the latest distributed inference optimizations like KV-cache aware routing and disaggregated serving, co-designed and integrated with the Kubernetes operational tooling in <a href="https://github.com/kubernetes-sigs/gateway-api-inference-extension?tab=readme-ov-file" target="_blank" rel="noopener noreferrer">Inference Gateway (IGW)</a>.</p>
<h3 id="llm-inference-goes-distributed">LLM Inference Goes Distributed<a href="#llm-inference-goes-distributed" aria-label="Direct link to LLM Inference Goes Distributed" title="Direct link to LLM Inference Goes Distributed">​</a></h3>
<h4 id="why-standard-scale-out-falls-short">Why Standard Scale Out Falls Short<a href="#why-standard-scale-out-falls-short" aria-label="Direct link to Why Standard Scale Out Falls Short" title="Direct link to Why Standard Scale Out Falls Short">​</a></h4>
<p>Kubernetes typically scales out application workloads with uniform replicas and round-robin load balancing.</p>
<p><img decoding="async" loading="lazy" alt="Figure 1: Deploying a service to multiple vLLM instances" src="https://llm-d.ai/assets/images/image5_46-77b3747418c1ebc4bab0a38f9543e824.png" width="1105" height="749"/></p>
<p>This simple pattern is very effective for most request patterns, which have the following characteristics:</p>
<ul>
<li>Requests are short-lived and generally uniform in resource utilization</li>
<li>Requests have generally uniform latency service level objectives (SLOs)</li>
<li>Each replica can process each request equally well</li>
<li>Specializing variants and coordinating replicas to process a single request is not useful</li>
</ul>
<h4 id="llm-serving-is-unique">LLM Serving Is Unique<a href="#llm-serving-is-unique" aria-label="Direct link to LLM Serving Is Unique" title="Direct link to LLM Serving Is Unique">​</a></h4>
<p>The LLM inference workload, however, is unique with slow, non-uniform, expensive requests. This means that typical scale-out and load-balancing patterns fall short of optimal performance.</p>
<p><img decoding="async" loading="lazy" alt="Figure 2: Comparison of modern HTTP requests" src="https://llm-d.ai/assets/images/image7_33-22569159e4120833431afcdb6f74a6c0.png" width="1768" height="726"/></p>
<p>Let’s take a look at each one step-by-step:</p>
<p><em>A. Requests are expensive with significant variance in resource utilization.</em></p>
<ul>
<li>Each LLM inference request has a different “shape” to it, as measured by the number of input tokens and output tokens. There is significant variance in these parameters across requests and workloads.<!-- -->
<ul>
<li>RAG has long inputs - prompt and retrieved docs - and short generated outputs</li>
<li>Reasoning has a short or medium inputs and long generated outputs</li>
</ul>
</li>
</ul>
<p><img decoding="async" loading="lazy" alt="Figure 3: Comparing the RAG pattern and Thinking/Reasoning pattern with prefill and decode stages" src="https://llm-d.ai/assets/images/image2_4-659d9ff985978b910ecfab7e29e8024b.jpg" width="1999" height="741"/></p>
<ul>
<li>These differences in request times can lead to significant imbalances across instances, which are compounded as loaded instances get overwhelmed. Overloads lead to longer ITL (Inter-Token Latency), which leads to more load, which leads to more ITL.</li>
</ul>
<p><em>B. Routing to specific replicas with cached prior computation can achieve orders of magnitude better latency.</em></p>
<ul>
<li>Many common LLM workloads have “multi-turn” request patterns, where the same prompt is sent iteratively to the same instance.<!-- -->
<ul>
<li>Agentic (tool calls are iterative request flow)</li>
<li>Code completion task (requests reuse current codebase as context)</li>
</ul>
</li>
</ul>
<p><img decoding="async" loading="lazy" alt="The agentic pattern sequence" src="https://llm-d.ai/assets/images/image8_0-58f2529f00c9948aeab638a3b0cef7e5.jpg" width="1999" height="722"/></p>
<ul>
<li>LLM inference servers like vLLM implement a method called “automatic prefix caching”, which enables “skipping” a significant amount of prefill computation when there is a cache hit. If requests are routed to vLLM replicas that have the data in the cache, we skip computation. Increasing the likelihood of prefix cache hits with a larger cache size can dramatically improve tail latencies.</li>
</ul>
<p><img decoding="async" loading="lazy" alt="The prefix aching method" src="https://llm-d.ai/assets/images/image3-3cd6d74c02dfdc443896dbd059d774cd.jpg" width="1999" height="1744"/></p>
<p><em>C. Specializing and coordinating replicas to process a single request can lead to more throughput per GPU.</em></p>
<ul>
<li>
<p>Inference is split into two phases – prefill and decode.  Prefill generates the first output token and runs in parallel over all the prompt tokens - this phase is compute bound.  Decode generates tokens one at a time by doing a full pass over the model, making this phase memory bandwidth-bound.</p>
</li>
<li>
<p>Standard LLM deployments perform the prefill and decode phases of inference within a single replica.Given that prefill and decode phases of inference have different resource requirements, co-locating these phases on the same replica leads to inefficient resource use, especially for long sequences.</p>
</li>
<li>
<p><strong>Disaggregation</strong> (e.g. <a href="https://arxiv.org/abs/2401.09670" target="_blank" rel="noopener noreferrer">Distserve</a>) separates prefill and decode phases onto different variants, enabling independent optimization and scaling of each phase.</p>
<ul>
<li>
<p>Google <a href="https://cloud.google.com/blog/products/compute/whats-new-with-ai-hypercomputer" target="_blank" rel="noopener noreferrer">leverages disaggregated serving on TPUs</a> to provide better first-token latency and simplify operational scaling.</p>
</li>
<li>
<p>DeepSeek released a <a href="https://github.com/deepseek-ai/open-infra-index/blob/main/202502OpenSourceWeek/day_6_one_more_thing_deepseekV3R1_inference_system_overview.md" target="_blank" rel="noopener noreferrer">discussion of the design of their inference system</a>, which leverages aggressive disaggregation to achieve remarkable performance at scale.</p>
</li>
</ul>
</li>
</ul>
<p><img decoding="async" loading="lazy" alt="Disaggregation separates the prefill and decode phases" src="https://llm-d.ai/assets/images/image4_57-2bd96d01f1faa556ac64ed77fe0867b7.png" width="1999" height="1144"/></p>
<p><em>D. Production deployments often have a range of quality of service (QoS) requirements.</em></p>
<ul>
<li>
<p>Use cases for a single LLM endpoint can have a wide variety of quality of service requirements. Consider the following examples:</p>
<ul>
<li>Latency is the most important factor: Code completion requests and search responses need to minimize latency to provide an “in the loop” experience. O(ms) latency tolerance.</li>
<li>Latency is important: Chat agent sessions and email drafting with interactive use cases. O(seconds) latency tolerance.</li>
<li>Latency tolerant: Video call and email summarization and “deep research” agents with daily or hourly usage patterns. O(minutes) latency tolerance.</li>
<li>Latency agnostic: Overnight batch processing workloads, meeting minute generation, and autonomous agents. O(hours) latency tolerance.</li>
</ul>
</li>
<li>
<p>Given the compute intensity (and, therefore, high costs) of LLMs, tight latency SLOs are substantially more expensive to achieve. This spectrum of latency requirements presents an opportunity to further optimize infrastructure efficiency – the more latency tolerant a workload is, the more we can optimize infrastructure efficiency amongst other workloads.</p>
</li>
</ul>
<h3 id="why-llm-d">Why llm-d?<a href="#why-llm-d" aria-label="Direct link to Why llm-d?" title="Direct link to Why llm-d?">​</a></h3>
<p>To exploit these characteristics and achieve optimal performance for LLM workloads, the inference serving landscape is rapidly transitioning towards distributed cluster-scale architectures. For instance, in its “Open Source Week”, the DeepSeek team published the design of its <a href="https://github.com/deepseek-ai/open-infra-index/blob/main/202502OpenSourceWeek/day_6_one_more_thing_deepseekV3R1_inference_system_overview.md" target="_blank" rel="noopener noreferrer">inference system</a>, which aggressively leverages disaggregation and KV caching to achieve remarkable performance per $ of compute.</p>
<p>However, for most GenAI innovators, ML platform teams, and IT operations groups, these benefits remain out of reach. Building and operating a complex, monolithic system is time-consuming and challenging, especially in the context of the rapid pace of innovation and enterprise deployments with tens or hundreds of models for divergent use cases. This complexity risks time to market, higher operational costs and sprawl, and difficulty adopting and experimenting.</p>
<h4 id="our-objective">Our Objective<a href="#our-objective" aria-label="Direct link to Our Objective" title="Direct link to Our Objective">​</a></h4>
<p>The objective of llm-d is to create a well-lit path for anyone to adopt the leading distributed inference optimizations <em>within their existing deployment framework</em> - Kubernetes.</p>
<p>To achieve this goal, we have the following design principles for the project:</p>
<ul>
<li><strong>Operationalizability:</strong> modular and resilient architecture with native integration into Kubernetes via Inference Gateway API</li>
<li><strong>Flexibility:</strong> cross-platform (active work to support NVIDIA, Google TPU, AMD, and Intel), with extensible implementations of key composable layers of the stack</li>
<li><strong>Performance</strong>: leverage distributed optimizations like disaggregation and prefix-aware routing to achieve the highest tok/$ while meeting SLOs</li>
</ul>
<h4 id="architecture">Architecture<a href="#architecture" aria-label="Direct link to Architecture" title="Direct link to Architecture">​</a></h4>
<p>To achieve this objective, we designed llm-d with a modular and layered architecture on top of industry-standard open-source technologies - vLLM, Kubernetes, and Inference Gateway.</p>
<ul>
<li>
<p><a href="https://docs.vllm.ai/en/latest/" target="_blank" rel="noopener noreferrer"><strong>vLLM</strong>. vLLM</a> is the leading open-source LLM inference engine, supporting a wide range of models (including Llama and DeepSeek) and hardware accelerators (including NVIDIA GPU, Google TPU, AMD ) with high performance.</p>
</li>
<li>
<p><a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener noreferrer"><strong>Kubernetes</strong></a> <strong>(K8s)</strong>. K8s is an open source container orchestration engine for automating deployment, scaling, and management of containerized applications. It is the industry standard for deploying and updating LLM inference engines across various hardware accelerators.</p>
</li>
<li>
<p><a href="https://gateway-api-inference-extension.sigs.k8s.io/" target="_blank" rel="noopener noreferrer"><strong>Inference Gateway</strong></a> <strong>(IGW)</strong>. IGW is an official Kubernetes project that extends the <a href="https://gateway-api.sigs.k8s.io/" target="_blank" rel="noopener noreferrer">Gateway API</a> (the next generation of Kubernetes Ingress and Load Balancing API) with inference-specific routing. IGW includes many important features like model routing, serving priority, and extensible scheduling logic for “smart” load balancing. IGW integrates with many different gateway implementations, such as Envoy, making it widely portable across Kubernetes clusters.</p>
</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://llm-d.ai/assets/images/llm-d-arch-simplified-d41875ab8b1fcf94a1a42df44940ceae.svg" width="859" height="474"/></p>
<p>And our key new contributions:</p>
<ul>
<li>
<p><strong>vLLM Optimized Inference Scheduler</strong> - IGW defines a pattern for customizable “smart” load-balancing via the <a href="https://github.com/kubernetes-sigs/gateway-api-inference-extension/tree/main/docs/proposals/004-endpoint-picker-protocol" target="_blank" rel="noopener noreferrer">Endpoint Picker Protocol (EPP)</a>. Leveraging enhanced operational telemetry exposed by vLLM, the inference scheduler implements the filtering and scoring algorithms necessary to make “smart” scheduling decisions around disaggregated serving, prefix-cache-awareness, and load-awareness, validated to be used out-of-the-box by llm-d users. Advanced teams can also tweak or implement their own scorers and filterers to further customize for their use cases, while still benefiting from upcoming operational features in the inference gateway, like flow control and latency-aware balancing.</p>
<ul>
<li>For more details, see our Northstar: <a href="https://docs.google.com/document/d/1kE1LY8OVjiOgKVD9-9Po96HODbTIbgHp4qgvw06BCOc/edit?tab=t.0" target="_blank" rel="noopener noreferrer">[PUBLIC] llm-d Scheduler Northstar</a></li>
</ul>
</li>
<li>
<p><strong>Disaggregated Serving with <a href="https://github.com/vllm-project/vllm" target="_blank" rel="noopener noreferrer">vLLM</a> -</strong> llm-d leverages vLLM’s recently enabled support for disaggregated serving via a pluggable KV Connector API to run prefill and decode on independent instances, using high-performance transport libraries like <a href="https://github.com/ai-dynamo/nixl" target="_blank" rel="noopener noreferrer">NVIDIA’s NIXL</a>.</p>
<p>In llm-d, we plan to support two “well-lit” paths for prefill/decode (P/D) disaggregation:</p>
<ul>
<li>Latency optimized implementation using fast interconnects (IB, RDMA, ICI)</li>
<li>Throughput optimized implementation using data center networking</li>
<li>For more details, see our Northstar:<a href="https://docs.google.com/document/d/1FNN5snmipaTxEA1FGEeSH7Z_kEqskouKD1XYhVyTHr8/edit?tab=t.0#heading=h.ycwld2oth1kj" target="_blank" rel="noopener noreferrer">[PUBLIC] llm-d Disaggregated Serving Northstar</a></li>
</ul>
</li>
<li>
<p><strong>Disaggregated Prefix Caching with vLLM</strong> -  llm-d uses the same vLLM KV connector API used in disaggregated serving to provide a pluggable cache for previous calculations, including offloading KVs to host, remote storage, and systems like <a href="https://github.com/LMCache/LMCache" target="_blank" rel="noopener noreferrer">LMCache</a>.</p>
<p>In llm-d, we plan to support two “well-lit” paths for KV cache disaggregation:</p>
<ul>
<li>Independent caching with basic offloading to host memory and disk, providing a zero operational cost mechanism that utilizes all system resources</li>
<li>Shared caching with KV transfer between instances and shared storage with global indexing, providing potential for higher performance at the cost of a more operationally complex system.</li>
<li>For more details, see our Northstar: <a href="https://docs.google.com/document/d/1d-jKVHpTJ_tkvy6Pfbl3q2FM59NpfnqPAh__Uz_bEZ8/edit?tab=t.0#heading=h.6qazyl873259" target="_blank" rel="noopener noreferrer">[PUBLIC] llm-d Prefix Caching Northstar</a></li>
</ul>
</li>
<li>
<p><strong>Variant Autoscaling over Hardware, Workload, and Traffic</strong> - Accelerator hardware varies dramatically in terms of compute, memory, and cost, workloads sharing the same models vary by their required quality of service, the distinct phases of LLM inference and large mixture-of-expert models vary on whether they are compute, memory, or network bound, and incoming traffic varies over time and by workload. Today, all of these decisions are made at deployment time, and almost all deployers struggle to enable autoscaling to reduce their costs safely.</p>
<p>Drawing on extensive experience from end users and OSS collaborators like AIBrix, we plan to implement a traffic- and hardware-aware autoscaler that:</p>
<ul>
<li>Measures the capacity of each model server instance</li>
<li>Derive a load function that takes into account different request shapes and QoS</li>
<li>Using the recent traffic mix - QPS (Queries Per Second), QoS, and shape distribution - calculate the optimal mix of instances to handle prefill, decode, and latency-tolerant requests, and label each instance with a grouping</li>
<li>Report load metrics per grouping that allows Kubernetes horizontal pod autoscaling to match hardware in use to hardware needed without violating SLOs</li>
<li>For more details, see our Northstar: <a href="https://docs.google.com/document/d/1inTneLEZTv3rDEBB9KLOB9K6oMq8c3jkogARJqdt_58/edit?tab=t.0" target="_blank" rel="noopener noreferrer">[PUBLIC] llm-d Autoscaling Northstar</a></li>
</ul>
</li>
</ul>
<h4 id="example-llm-d-features">Example llm-d Features<a href="#example-llm-d-features" aria-label="Direct link to Example llm-d Features" title="Direct link to Example llm-d Features">​</a></h4>
<p>llm-d integrates IGW and vLLM together, enabling a high performance distributed serving stack. Let’s discuss some of the example features enabled by llm-d.</p>
<p><strong>Prefix and KV cache-aware routing</strong></p>
<p>The first key collaboration between IGW and vLLM in llm-d was developing prefix-cache aware routing to complement the existing KV cache utilization aware load balancing in IGW.</p>
<p>We conducted a series of experiments to evaluate the performance of the <a href="https://github.com/llm-d/llm-d-inference-scheduler" target="_blank" rel="noopener noreferrer">llm-d-inference-scheduler</a> with prefix-aware routing on 2 NVIDIA 8xH100 nodes using the <a href="https://github.com/LMCache/LMBenchmark/tree/main/synthetic-multi-round-qa" target="_blank" rel="noopener noreferrer">LMbenchmark in a long-input/short-output configuration designed</a> to stress KV cache reuse and routing decision quality.</p>
<table><thead><tr><th></th><th>Model</th><th>Configuration</th><th>ISL</th><th>OSL</th><th>Latency SLO</th></tr></thead><tbody><tr><td><strong>S1</strong></td><td>LlaMA 4 Scout FP8</td><td>TP2, 2 replicas</td><td>20,000</td><td>100</td><td>None</td></tr><tr><td><strong>S2</strong></td><td>LlaMA 4 Scout FP8</td><td>TP2, 4 replicas</td><td>12,000</td><td>100</td><td>P95 TTFT &lt;= 2s</td></tr><tr><td><strong>S3</strong></td><td>Llama 3.1 70B FP16</td><td>TP2, 4 replicas</td><td>8,000</td><td>100</td><td>P95 TTFT &lt;= 2s</td></tr></tbody></table>

<p><strong>Key Observations:</strong></p>
<ul>
<li><strong>S1:</strong> At 4 QPS, llm-d achieves a mean TTFT approximately 3X lower than the baseline (lower is better).</li>
<li><strong>S2:</strong> llm-d delivers ~50% higher QPS than the baseline while meeting SLO requirements (higher is better).</li>
<li><strong>S3:</strong> llm-d sustains 2X the baseline QPS under SLO constraints (higher is better).</li>
</ul>
<p>These results show that llm-d’s cache- and prefix-aware scheduling effectively reduces TTFT and increases QPS compared to the baseline, while consistently meeting SLA requirements.</p>
<p>Try it out with the `base.yaml` config in our <a href="https://github.com/llm-d/llm-d-deployer/tree/main/quickstart" target="_blank" rel="noopener noreferrer">quickstart</a>. And as a customization example, see the  <a href="https://github.com/llm-d/llm-d-inference-scheduler/blob/main/docs/create_new_filter.md" target="_blank" rel="noopener noreferrer">template</a> for adding your own scheduler filter.</p>
<p><strong>P/D disaggregation</strong></p>
<p>We’ve completed an initial implementation of P/D disaggregation with vLLM and llm-d-inference-scheduler, which delivers promising speedups for prefill-heavy workloads (20:1 ISL | OSL). Our next focus is finalizing the implementation with heterogeneous TP and completing comprehensive benchmarks for disaggregated serving. Short-term priorities include enabling heterogeneous TP, scaling with high-performance P/D + EP&lt;&gt;DP for large scale MoEs, and DP-aware load balancing. We will follow up with a detailed performance blog in the coming weeks.</p>
<p>Try it out with the pd-nixl.yaml config in our <a href="https://github.com/llm-d/llm-d-deployer/tree/main/quickstart" target="_blank" rel="noopener noreferrer">quickstart</a>.</p>
<h3 id="get-started-with-llm-d">Get started with llm-d<a href="#get-started-with-llm-d" aria-label="Direct link to Get started with llm-d" title="Direct link to Get started with llm-d">​</a></h3>
<p>llm-d builds brings together the performance of vLLM with the operationalizability of Kuberentes, creating a modular architecture for distributed LLM inference, targeting high performance on the latest models and agentic architectures.</p>
<p>We welcome AI engineers and researchers to join the llm-d community and contribute:</p>
<ul>
<li>Check out our repository on Github: <a href="https://github.com/llm-d/llm-d" target="_blank" rel="noopener noreferrer">https://github.com/llm-d/llm-d</a></li>
<li>Join our developer slack: <a href="https://inviter.co/llm-d-slack" target="_blank" rel="noopener noreferrer">https://inviter.co/llm-d-slack</a></li>
<li>Try out our quick starts to deploy llm-d on your Kubernetes cluster: <a href="https://github.com/llm-d/llm-d-deployer/tree/main/quickstart" target="_blank" rel="noopener noreferrer">https://github.com/llm-d/llm-d-deployer/tree/main/quickstart</a></li>
</ul>
<p>Please join us. The future of AI is open.</p></div></div>
  </body>
</html>
