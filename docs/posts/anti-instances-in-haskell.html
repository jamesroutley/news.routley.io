<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://heneli.dev/blog/anti-instances">Original</a>
    <h1>Anti-Instances in Haskell</h1>
    
    <div id="readability-page-1" class="page"><div><details open=""><summary>Table of Contents</summary><div><ul><li><a href="#anti-instances-past-and-present">Anti-Instances: Past and Present</a></li><li><a href="#omitted-instances">Omitted Instances</a></li><li><a href="#using-typeerror">Using TypeError</a></li><li><a href="#introducing-unsatisfiable">Introducing Unsatisfiable</a></li><li><a href="#tips--tricks">Tips &amp; Tricks</a></li><li><a href="#escape-hatch">Escape Hatch</a></li><li><a href="#verified-counterexamples">Verified Counterexamples</a></li><li><a href="#further-reading">Further Reading</a></li><li><a href="#footnotes">Footnotes</a></li></ul></div></details> <div><p><u><strong>Prerequisites</strong></u>: You should be familiar with using basic typeclasses. If not, check out Serokell&#39;s <a target="_blank" rel="noopener noreferrer" href="https://serokell.io/blog/haskell-typeclasses"><em>Introduction to Haskell Typeclasses</em></a> or the <em>Typeclasses and Instances</em> section from Kowainik&#39;s <a target="_blank" rel="noopener noreferrer" href="https://kowainik.github.io/posts/deriving#typeclasses-and-instances"><em>Strategic Deriving</em></a>.</p></div><p>Typeclass instances are a powerful tool for specifying which overloaded operations are allowed on which types. But what about specifying which operations are <em>disallowed</em> on which types? With the arrival of <code>Unsatisfiable</code> in <a target="_blank" rel="noopener noreferrer" href="https://www.haskell.org/ghc/blog/2023-07-27-ghc-9.8.1-alpha1-released.html">GHC 9.8.1</a>, Haskell has better answers now than ever before.</p><h2 id="anti-instances-past-and-present"><a href="#anti-instances-past-and-present" aria-hidden="true" tabindex="-1"><span></span></a>Anti-Instances: Past and Present</h2><p>An anti-instance is the intentional rejection of a possible typeclass instance. Anti-instances can be defined implicitly by omission or explicitly by custom type error.</p><h3 id="omitted-instances"><a href="#omitted-instances" aria-hidden="true" tabindex="-1"><span></span></a>Omitted Instances</h3><p>The easiest and most common method for disallowing a typeclass operation on a given type is simply not providing the corresponding typeclass instance.</p><p>As an example, let&#39;s look at omitted instances on <a target="_blank" rel="noopener noreferrer" href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Semigroup.html#t:First"><code>Data.Semigroup.First</code></a>:</p><div><pre><code><span><span>newtype</span> <span>First</span> <span>a</span> <span>=</span> <span>First</span> <span>{</span> <span>getFirst</span> <span>::</span> <span>a</span> <span>}</span>
</span><span>
</span><span><span>instance</span> <span>Semigroup</span> <span>(</span><span>First</span> <span>a</span><span>)</span> <span>where</span>
</span><span>    <span>(</span><span>&lt;&gt;</span><span>)</span> <span>::</span> <span>First</span> <span>a</span> <span>-&gt;</span> <span>First</span> <span>a</span> <span>-&gt;</span> <span>First</span> <span>a</span>
</span><span>    <span>a</span> <span>&lt;&gt;</span> <span>_</span> <span>=</span> <span>a</span>
</span></code></pre></div><p><code>First</code> comes with a <code>Semigroup</code> instance as <a target="_blank" rel="noopener noreferrer" href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Semigroup.html#v:-60--62-"><code>(&lt;&gt;)</code></a>, an append operation obeying the associativity law<sup><a href="#user-content-fn-1" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-1">1</a></sup>, can be implemented for combining <code>First</code> values.</p><div><pre><code><span>λ<span>&gt;</span> <span>First</span> <span>99</span> <span>&lt;&gt;</span> <span>First</span> <span>12</span> <span>&lt;&gt;</span> <span>First</span> <span>30</span> <span>&lt;&gt;</span> <span>First</span> <span>7</span>
</span><span><span>First</span> <span>99</span>
</span><span>λ<span>&gt;</span> <span>(</span><span>(</span><span>First</span> <span>12</span> <span>&lt;&gt;</span> <span>First</span> <span>30</span><span>)</span> <span>&lt;&gt;</span> <span>First</span> <span>7</span><span>)</span> <span>&lt;&gt;</span> <span>First</span> <span>99</span>
</span><span><span>First</span> <span>12</span>
</span><span>λ<span>&gt;</span> <span>First</span> <span>12</span> <span>&lt;&gt;</span> <span>(</span><span>First</span> <span>30</span> <span>&lt;&gt;</span> <span>(</span><span>First</span> <span>7</span> <span>&lt;&gt;</span> <span>First</span> <span>99</span><span>)</span><span>)</span>
</span><span><span>First</span> <span>12</span>
</span></code></pre></div><p>Figure 1: Combines two values by selecting the first</p><p>On the other hand, there is no <code>Monoid</code> instance provided for <code>First</code>. No value can be supplied to <code>First</code> that, when combined with a distinct second value, would result in the second value. Therefore <a target="_blank" rel="noopener noreferrer" href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Monoid.html#v:mempty"><code>mempty</code></a>, an &#34;empty&#34; value satisfying the identity law<sup><a href="#user-content-fn-1" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-1-2">1</a></sup>, cannot be implemented for <code>First</code>.</p><p>Typeclass hierarchies help users quickly distinguish how different types behave by communicating the operations they implement and the laws they satisfy. Observing where different types fall within these hierarchies is an easy way to discover intentionally omitted instances.<sup><a href="#user-content-fn-2" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-2">2</a></sup></p><p width="100%"><img src="https://drive.google.com/static/images/blog/simple_haskell_hierarchy.png" alt="Standard Typeclass Hierarchy in Haskell" height="50%" width="50%"/>Figure 2: A typeclass hierarchy (<a target="_blank" rel="noopener noreferrer" href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a>)</p><h3 id="using-typeerror"><a href="#using-typeerror" aria-hidden="true" tabindex="-1"><span></span></a>Using <code>TypeError</code></h3><p>The 2016 release of GHC 8.0.1 introduced <a target="_blank" rel="noopener noreferrer" href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/type_errors.html"><code>TypeError</code></a> for custom compile-time errors. Unlike with omitted instances, <code>TypeError</code> enables explicit anti-instances:</p><div><pre><code><span>
</span><span>
</span><span><span><span>import</span> GHC<span>.</span>TypeError</span> <span>(</span><span>TypeError</span><span>,</span> <span>ErrorMessage</span> <span>(</span><span>Text</span><span>)</span><span>)</span>
</span><span>
</span><span><span>class</span> <span>ReflexiveEq</span> <span>a</span> <span>where</span>
</span><span>    <span>reflexiveEq</span> <span>::</span> <span>a</span> <span>-&gt;</span> <span>a</span> <span>-&gt;</span> <span>Bool</span>
</span><span>
</span><span><span>instance</span> <span>TypeError</span>
</span><span>  <span>(</span><span>Text</span> <span>&#34;Equality is not reflexive on Double: NaN /= NaN&#34;</span><span>)</span>
</span><span>  <span>=&gt;</span> <span>ReflexiveEq</span> <span>Double</span> <span>where</span>
</span><span>    <span>reflexiveEq</span> <span>_</span> <span>_</span> <span>=</span> <span>False</span>
</span></code></pre></div><p>Triggering a compilation error with the above anti-instance can be seen below:</p><div><pre><code><span>λ<span>&gt;</span> <span>reflexiveEq</span> <span>(</span><span>1</span> <span>::</span> <span>Double</span><span>)</span> <span>(</span><span>1</span> <span>::</span> <span>Double</span><span>)</span>
</span><span>
</span><span><span>&lt;</span><span>interactive</span><span>&gt;:</span><span>30</span><span>:</span><span>1</span><span>:</span> <span>error</span><span>:</span> <span>[</span><span>GHC</span><span>-</span><span>64725</span><span>]</span>
</span><span>    • <span>Equality</span> <span>is</span> <span>not</span> <span>reflexive</span> <span>on</span> <span>Double</span><span>:</span> <span>NaN</span> <span>/=</span> <span>NaN</span>
</span><span>    • <span>In</span> <span>the</span> <span>expression</span><span>:</span> <span>reflexiveEq</span> <span>(</span><span>1</span> <span>::</span> <span>Double</span><span>)</span> <span>(</span><span>1</span> <span>::</span> <span>Double</span><span>)</span>
</span></code></pre></div><p>Custom type errors enable user-defined error messages and provide concrete pointers for code documentation and reference in discussions. <code>TypeError</code> improves developer experience by enhancing library accessibility, IDE tooltips, and user interactions with the compiler.</p><p>One downside of <code>TypeError</code> is its implementation as a type-level function.<sup><a href="#user-content-fn-3" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-3">3</a></sup> This provides flexibility but makes it more difficult to understand <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0433-unsatisfiable.rst#motivation">when exactly a <code>TypeError</code> will be thrown</a>.</p><p>While <code>TypeError</code> usage has been minor within the Haskell ecosystem, there are some very cool examples of them appearing in several libraries.<sup><a href="#user-content-fn-4" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-4">4</a></sup></p><h3 id="introducing-unsatisfiable"><a href="#introducing-unsatisfiable" aria-hidden="true" tabindex="-1"><span></span></a>Introducing <code>Unsatisfiable</code></h3><p>The upcoming GHC 9.8.1 release will bring an improved version of <code>TypeError</code> called <code>Unsatisfiable</code>.</p><div><pre><code><span>
</span><span>
</span><span><span><span>import</span> GHC<span>.</span>TypeError</span> <span>(</span><span>Unsatisfiable</span><span>,</span> <span>ErrorMessage</span> <span>(</span><span>Text</span><span>)</span><span>)</span>
</span><span>
</span><span><span>instance</span> <span>Unsatisfiable</span>
</span><span>  <span>(</span><span>Text</span> <span>&#34;Halt! Functions cannot be compared for equality.&#34;</span><span>)</span>
</span><span>  <span>=&gt;</span> <span>Eq</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>b</span><span>)</span>
</span></code></pre></div><p>Triggering a compilation error with the above anti-instance can be seen below:</p><div><pre><code><span>λ<span>&gt;</span> <span>(</span><span>\</span><span>x</span> <span>-&gt;</span> <span>x</span><span>)</span> <span>==</span> <span>(</span><span>\</span><span>y</span> <span>-&gt;</span> <span>y</span><span>)</span>
</span><span>
</span><span><span>&lt;</span><span>interactive</span><span>&gt;:</span><span>18</span><span>:</span><span>11</span><span>:</span> <span>error</span><span>:</span> <span>[</span><span>GHC</span><span>-</span><span>22250</span><span>]</span>
</span><span>    • <span>Halt</span><span>!</span> <span>Functions</span> <span>cannot</span> <span>be</span> <span>compared</span> <span>for</span> <span>equality</span><span>.</span>
</span><span>    • <span>In</span> <span>the</span> <span>expression</span><span>:</span> <span>(</span><span>\</span> <span>x</span> <span>-&gt;</span> <span>x</span><span>)</span> <span>==</span> <span>(</span><span>\</span> <span>y</span> <span>-&gt;</span> <span>y</span><span>)</span>
</span></code></pre></div><p>Anti-instances defined with <code>Unsatisfiable</code> look nearly identical to those defined with <code>TypeError</code>, but have some additional benefits. Unlike <code>TypeError</code>, <code>Unsatisfiable</code> is a typeclass and thus produces types of kind <code>Constraint</code>.</p><div><pre><code><span>λ<span>&gt;</span> <span>:</span><span>kind</span> <span>TypeError</span>
</span><span><span>TypeError</span> <span>::</span> <span>ErrorMessage</span> <span>-&gt;</span> <span>b</span>
</span><span>λ<span>&gt;</span> <span>:</span><span>kind</span> <span>Unsatisfiable</span>
</span><span><span>Unsatisfiable</span> <span>::</span> <span>ErrorMessage</span> <span>-&gt;</span> <span>Constraint</span>
</span></code></pre></div><p>This results in more predictable error reporting and fixes buggy behavior seen when <code>TypeError</code> is used with <code>-fdefer-type-errors</code>. You can find more details on its advantages in the <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0433-unsatisfiable.rst"><code>Unsatisfiable</code> GHC Proposal</a>.</p><h2 id="tips--tricks"><a href="#tips--tricks" aria-hidden="true" tabindex="-1"><span></span></a>Tips &amp; Tricks</h2><h3 id="escape-hatch"><a href="#escape-hatch" aria-hidden="true" tabindex="-1"><span></span></a>Escape Hatch</h3><p>What if you <em>really need</em> an operation from an outlawed instance? Whether facing an implicit anti-instance by omission or an explicit anti-instance by custom type error, the solution is to use a newtype.</p><p>Newtypes overcome anti-instances by creating a wrapper type upon which fresh instances can be created without polluting the underlying type.</p><p>For example, we can implement a <code>Monoid</code> instance on <code>UnsafeFirst</code> without worrying about the <code>Monoid</code> anti-instance on <code>First</code>:</p><div><pre><code><span>
</span><span>
</span><span>
</span><span><span><span>import</span> Data<span>.</span>Semigroup</span> <span>(</span><span>First</span><span>)</span>
</span><span><span><span>import</span> GHC<span>.</span>TypeError</span> <span>(</span><span>Unsatisfiable</span><span>,</span> <span>ErrorMessage</span> <span>(</span><span>Text</span><span>)</span><span>)</span>
</span><span>
</span><span><span>instance</span> <span>Unsatisfiable</span> <span>(</span><span>Text</span> <span>&#34;First lacks an identity element&#34;</span><span>)</span>
</span><span>   <span>=&gt;</span> <span>Monoid</span> <span>(</span><span>First</span> <span>a</span><span>)</span>
</span><span>
</span><span>
</span><span><span>newtype</span> <span>UnsafeFirst</span> <span>a</span> <span>=</span> <span>UnsafeFirst</span>
</span><span>  <span>{</span> <span>getUnsafeFirst</span> <span>::</span> <span>First</span> <span>a</span> <span>}</span>
</span><span>  <span>deriving</span> <span>(</span><span>Show</span><span>,</span> <span>Semigroup</span><span>)</span>
</span><span>
</span><span><span>instance</span> <span>Monoid</span> <span>(</span><span>UnsafeFirst</span> <span>a</span><span>)</span> <span>where</span>
</span><span>  <span>mempty</span> <span>::</span> <span>UnsafeFirst</span> <span>a</span>
</span><span>  <span>mempty</span> <span>=</span> <span>error</span> <span>&#34;certified law breaker&#34;</span>
</span></code></pre></div><p>This &#34;works&#34;:</p><div><pre><code><span>λ<span>&gt;</span> <span>UnsafeFirst</span> <span>(</span><span>First</span> <span>1</span><span>)</span> <span>&lt;&gt;</span> <span>UnsafeFirst</span> <span>(</span><span>First</span> <span>3</span><span>)</span>
</span><span><span>UnsafeFirst</span> <span>{</span><span>getUnsafeFirst</span> <span>=</span> <span>First</span> <span>{</span><span>getFirst</span> <span>=</span> <span>1</span><span>}</span><span>}</span>
</span><span>λ<span>&gt;</span> <span>UnsafeFirst</span> <span>(</span><span>First</span> <span>1</span><span>)</span> <span>&lt;&gt;</span> <span>mempty</span>
</span><span><span>UnsafeFirst</span> <span>{</span><span>getUnsafeFirst</span> <span>=</span> <span>First</span> <span>{</span><span>getFirst</span> <span>=</span> <span>1</span><span>}</span><span>}</span>
</span></code></pre></div><p>...at least until there&#39;s a law-breaking <code>mempty</code> in the first position.</p><div><pre><code><span>λ<span>&gt;</span> <span>mempty</span> <span>&lt;&gt;</span> <span>UnsafeFirst</span> <span>(</span><span>First</span> <span>3</span><span>)</span>
</span><span><span>UnsafeFirst</span> <span>{</span><span>getUnsafeFirst</span> <span>=</span> <span>First</span>
</span><span>  <span>{</span><span>getFirst</span> <span>=</span> <span>***</span> <span>Exception</span><span>:</span> <span>certified</span> <span>law</span> <span>breaker</span>
</span><span><span>CallStack</span> <span>(</span><span>from</span> <span>HasCallStack</span><span>)</span><span>:</span>
</span><span>  <span>error</span><span>,</span> <span>called</span> <span>at</span> <span>&lt;</span><span>interactive</span><span>&gt;:</span><span>52</span><span>:</span><span>12</span> <span>in</span> <span>interactive</span><span>:</span><span>Ghci7</span>
</span></code></pre></div><p>Clearly, the above example is a bad idea. Carefully consider whether this workaround is a good idea and truly necessary in your case. There&#39;s likely a different representation of your data that can better achieve your goals.</p><p>For example, a different <code>First</code> datatype exists in <code>Data.Monoid</code> that wraps the <code>Maybe</code> datatype.</p><div><pre><code><span><span>newtype</span> <span>First</span> <span>a</span> <span>=</span> <span>First</span> <span>{</span> <span>getFirst</span> <span>::</span> <span>Maybe</span> <span>a</span> <span>}</span>
</span><span>
</span><span><span>instance</span> <span>Semigroup</span> <span>(</span><span>First</span> <span>a</span><span>)</span> <span>where</span>
</span><span>  <span>(</span><span>&lt;&gt;</span><span>)</span> <span>::</span> <span>First</span> <span>a</span> <span>-&gt;</span> <span>First</span> <span>a</span> <span>-&gt;</span> <span>First</span> <span>a</span>
</span><span>  <span>First</span> <span>Nothing</span> <span>&lt;&gt;</span> <span>b</span> <span>=</span> <span>b</span>
</span><span>  <span>a</span>             <span>&lt;&gt;</span> <span>_</span> <span>=</span> <span>a</span>
</span><span>
</span><span><span>instance</span> <span>Monoid</span> <span>(</span><span>First</span> <span>a</span><span>)</span> <span>where</span>
</span><span>  <span>mempty</span> <span>::</span> <span>First</span> <span>a</span>
</span><span>  <span>mempty</span> <span>=</span> <span>First</span> <span>Nothing</span>
</span></code></pre></div><p>Combining values under <code>Data.Semigroup.First</code> means selecting the first value, while combining values under <code>Data.Monoid.First</code> means selecting the first &#34;non-empty&#34; value.</p><div><pre><code><span>λ<span>&gt;</span> <span>First</span> <span>Nothing</span> <span>&lt;&gt;</span> <span>First</span> <span>Nothing</span> <span>&lt;&gt;</span> <span>First</span> <span>Nothing</span>
</span><span><span>First</span> <span>{</span><span>getFirst</span> <span>=</span> <span>Nothing</span><span>}</span>
</span><span>λ<span>&gt;</span> <span>(</span><span>(</span><span>First</span> <span>Nothing</span> <span>&lt;&gt;</span> <span>First</span> <span>(</span><span>Just</span> <span>99</span><span>)</span><span>)</span> <span>&lt;&gt;</span> <span>First</span> <span>Nothing</span><span>)</span> <span>&lt;&gt;</span> <span>First</span> <span>(</span><span>Just</span> <span>33</span><span>)</span>
</span><span><span>First</span> <span>{</span><span>getFirst</span> <span>=</span> <span>Just</span> <span>99</span><span>}</span>
</span><span>λ<span>&gt;</span> <span>First</span> <span>Nothing</span> <span>&lt;&gt;</span> <span>(</span><span>First</span> <span>(</span><span>Just</span> <span>99</span><span>)</span> <span>&lt;&gt;</span> <span>(</span><span>First</span> <span>Nothing</span> <span>&lt;&gt;</span> <span>First</span> <span>(</span><span>Just</span> <span>33</span><span>)</span><span>)</span><span>)</span>
</span><span><span>First</span> <span>{</span><span>getFirst</span> <span>=</span> <span>Just</span> <span>99</span><span>}</span>
</span></code></pre></div><h3 id="verified-counterexamples"><a href="#verified-counterexamples" aria-hidden="true" tabindex="-1"><span></span></a>Verified Counterexamples</h3><p>One of Haskell&#39;s strengths is its facility for making assumptions explicit.<sup><a href="#user-content-fn-5" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-5">5</a></sup> Rather than implicitly omitting impossible instances, Haskellers can communicate intent with anti-instances. Further, claims about why an anti-instance exists can be strengthened by incorporating machine-checked validations.</p><p>Using property-based testing with <a target="_blank" rel="noopener noreferrer" href="https://serokell.io/blog/doctests-in-haskell">doctests</a>, we can verify typeclass instances and anti-instances directly in our documentation. The presence of counterexamples from generated values makes it clear which anti-instances are legitimately law-breaking. Likewise, the absence of counterexamples from generated values makes it clear which typeclass instances are legitimately law-abiding.</p><p><img alt="Anti-instance Doctest" srcset="/_next/image?url=%2Fstatic%2Fimages%2Fblog%2Fanti-instance-doctest.png&amp;w=3840&amp;q=75 1x" src="https://drive.google.com/_next/image?url=%2Fstatic%2Fimages%2Fblog%2Fanti-instance-doctest.png&amp;w=3840&amp;q=75" width="2120" height="584" decoding="async" data-nimg="1" loading="lazy"/></p><p>Figure 3: Haddocks for Doctested Anti-Instance (<a target="_blank" rel="noopener noreferrer" href="https://gist.github.com/hkailahi/ccad605dcf79daf426305e58b4d92359">code</a>)<sup><a href="#user-content-fn-6" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-6">6</a></sup></p><h2 id="further-reading"><a href="#further-reading" aria-hidden="true" tabindex="-1"><span></span></a>Further Reading</h2><p>For more on this topic, I highly recommend reading the <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0433-unsatisfiable.rst"><code>Unsatisfiable</code> GHC Proposal</a> and <a target="_blank" rel="noopener noreferrer" href="https://chshersh.com/type-errors"><em>A story told by Type Errors</em></a>.</p><p>Additionally:</p><ul><li><details><summary>For learners looking to level up their typeclass knowledge...</summary><p>Advanced beginners and intermediate Haskellers looking to deepen their understanding of typeclasses and type-level techniques should check out <a target="_blank" rel="noopener noreferrer" href="https://thinkingwithtypes.com"><em>Thinking With Types</em></a> for a comprehensive tour. Other resources I&#39;ve found interesting and useful include:</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://youtu.be/GlUcCPmH8wI"><em>Code Reuse in PureScript: Fns, Classes, and Interpreters</em></a> (video)</li><li><a target="_blank" rel="noopener noreferrer" href="https://youtu.be/bmHd0MoCIiM"><em>Coherence of Type Class Resolution</em></a> (video)</li><li><a target="_blank" rel="noopener noreferrer" href="https://youtu.be/8o51sA12VfI"><em>All You Wanted to Know About Type Classes</em></a> (video)</li><li><a target="_blank" rel="noopener noreferrer" href="https://lexi-lambda.github.io/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/"><em>An introduction to typeclass metaprogramming</em></a></li></ul></details></li><li><details><summary>For more seasoned explorers...</summary><p>Those with further interest in this area:</p><ul><li>See related GHC proposals like the recently accepted <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0575-deprecated-instances.rst">Deprecated Instances</a> proposal and pending <a target="_blank" rel="noopener noreferrer" href="https://github.com/adamgundry/ghc-proposals/blob/custom-type-warnings/proposals/0000-custom-type-warnings.rst">Custom Type Warnings</a> proposal.</li><li>For why typeclass laws require manual verification, see <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Rice%27s_theorem">Rice&#39;s theorem</a> and this <a target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/questions/63523145/why-do-haskells-typeclass-laws-have-to-be-verified-manually">StackOverflow answer</a>. See the <a target="_blank" rel="noopener noreferrer" href="https://dl.acm.org/doi/10.1145/3428284"><em>Verifying replicated data types</em></a> and <a target="_blank" rel="noopener noreferrer" href="https://www.cs.nott.ac.uk/~pszgmh/quotient-haskell.pdf"><em>Quotient Haskell</em></a> papers for examples using Liquid Haskell to statically verify typeclass laws and encode laws directly onto datatypes, respectively.</li></ul></details></li></ul><p>If there&#39;s further interest, I may write more on this topic. I have some thoughts to flesh out around tradeoffs, related proposals, more ergonomic law-checking, and deriving anti-instances.</p><p>Thanks for reading!</p><p>✌️</p></div><div><div><p>Something incorrect? Addition to propose? Please file an</p><!-- --> <p><a target="_blank" rel="nofollow" href="https://github.com/hkailahi/heneli.dev/issues">issue</a>. Comment to add? Join the discussion below by authorizing Giscus or commenting directly on the</p><!-- --> <p><a target="_blank" rel="nofollow" href="https://github.com/hkailahi/heneli.dev/discussions">Github Discussion</a>. Off-topic remarks, unfunny jokes, weirdly overfamiliar internet-speak, and bootlicking will be moved</p><!-- --> <p><a target="_blank" rel="nofollow" href="https://news.ycombinator.com/">here</a>.</p></div></div></div>
  </body>
</html>
