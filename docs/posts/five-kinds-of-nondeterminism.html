<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/five-kinds-of-nondeterminism/">Original</a>
    <h1>Five Kinds of Nondeterminism</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                February 19, 2025
                
            </date>
            
            
            
            <h2>
                Or four kinds, or six kinds, I&#39;m not picky about how you count them
            </h2>
            

            

            
            
            <p>No newsletter next week, I&#39;m teaching a TLA+ workshop.</p>
<p>Speaking of which: I spend a lot of time thinking about formal methods (and TLA+ specifically) because it&#39;s where the source of almost all my revenue. But I don&#39;t share most of the details because 90% of my readers don&#39;t use FM and never will. I think it&#39;s more interesting to talk about ideas <em>from</em> FM that would be useful to people outside that field. For example, the idea of &#34;property strength&#34; translates to the <a href="https://buttondown.com/hillelwayne/archive/some-tests-are-stronger-than-others/" target="_blank">idea that some tests are stronger than others</a>. </p>
<p>Another possible export is how FM approaches nondeterminism. A <strong>nondeterministic</strong> algorithm is one that, from the same starting conditions, has multiple possible outputs. This is nondeterministic:</p>
<div><pre><span></span><code># Pseudocode

def f() {
    return rand()+1;
}
</code></pre></div>
<p>When specifying systems, I may not <em>encounter</em> nondeterminism more often than in real systems, but I am definitely more aware of its presence. Modeling nondeterminism is a core part of formal specification. I mentally categorize nondeterminism into five buckets. Caveat, this is specifically about nondeterminism from the perspective of <em>system modeling</em>, not computer science as a whole. If I tried to include stuff on NFAs and amb operations this would be twice as long.<sup id="fnref:nondeterminism"><a href="#fn:nondeterminism">1</a></sup></p>

<h2>1. True Randomness</h2>
<p>Programs that literally make calls to a <code>random</code> function and then use the results. This the simplest type of nondeterminism and one of the most ubiquitous. </p>
<p>Most of the time, <code>random</code> isn&#39;t <em>truly</em> nondeterministic. Most of the time computer randomness is actually <strong>pseudorandom</strong>, meaning we seed a deterministic algorithm that behaves &#34;randomly-enough&#34; for some use. You could &#34;lift&#34; a nondeterministic random function into a deterministic one by adding a fixed seed to the starting state.</p>
<div><pre><span></span><code><span># Python</span>

<span>from</span> <span>random</span> <span>import</span> <span>random</span><span>,</span> <span>seed</span>
<span>def</span> <span>f</span><span>(</span><span>x</span><span>):</span>
    <span>seed</span><span>(</span><span>x</span><span>)</span>
    <span>return</span> <span>random</span><span>()</span>

<span>&gt;&gt;&gt;</span> <span>f</span><span>(</span><span>3</span><span>)</span>
<span>0.23796462709189137</span>
<span>&gt;&gt;&gt;</span> <span>f</span><span>(</span><span>3</span><span>)</span>
<span>0.23796462709189137</span>
</code></pre></div>
<p>Often we don&#39;t do this because the <em>point</em> of randomness is to provide nondeterminism! We deliberately <em>abstract out</em> the starting state of the seed from our program, because it&#39;s easier to think about it as locally nondeterministic.</p>
<p>(There&#39;s also &#34;true&#34; randomness, like using <a href="https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html#inpage-nav-3-2" target="_blank">thermal noise</a> as an entropy source, which I think are mainly used for cryptography and seeding PRNGs.)</p>
<p>Most formal specification languages don&#39;t deal with randomness (though some deal with <a href="https://buttondown.com/hillelwayne/archive/i-formally-modeled-dreidel-for-no-good-reason/" target="_blank">probability more broadly</a>). Instead, we treat it as a nondeterministic choice:</p>
<div><pre><span></span><code># software
if rand &gt; 0.001 then return a else crash

# specification
either return a or crash
</code></pre></div>
<p>This is because we&#39;re looking at worst-case scenarios, so it doesn&#39;t matter if <code>crash</code> happens 50% of the time or 0.0001% of the time, it&#39;s still possible.  </p>
<h2>2. Concurrency</h2>
<div><pre><span></span><code># Pseudocode
global x = 1, y = 0;

def thread1() {
   x++;
   x++;
   x++;
}

def thread2() {
    y := x;
}
</code></pre></div>
<p>If <code>thread1()</code> and <code>thread2()</code> run sequentially, then (assuming the sequence is fixed) the final value of <code>y</code> is deterministic. If the two functions are started and run simultaneously, then depending on when <code>thread2</code> executes <code>y</code> can be 1, 2, 3, <em>or</em> 4. Both functions are locally sequential, but running them concurrently leads to global nondeterminism.</p>
<p>Concurrency is arguably the most <em>dramatic</em> source of nondeterminism. <a href="https://buttondown.com/hillelwayne/archive/what-makes-concurrency-so-hard/" target="_blank">Small amounts of concurrency lead to huge explosions in the state space</a>. We have words for the specific kinds of nondeterminism caused by concurrency, like &#34;race condition&#34; and &#34;dirty write&#34;. Often we think about it as a separate <em>topic</em> from nondeterminism. To some extent it &#34;overshadows&#34; the other kinds: I have a much easier time teaching students about concurrency in models than nondeterminism in models.</p>
<p>Many formal specification languages have special syntax/machinery for the concurrent aspects of a system, and generic syntax for other kinds of nondeterminism. In P that&#39;s <a href="https://p-org.github.io/P/manual/expressions/#choose" target="_blank">choose</a>. Others don&#39;t special-case concurrency, instead representing as it as nondeterministic choices by a global coordinator. This more flexible but also more inconvenient, as you have to implement process-local sequencing code yourself. </p>
<h2>3. User Input</h2>

<p>One of the most famous and influential programming books is <em>The C Programming Language</em> by Kernighan and Ritchie. The first example of a nondeterministic program appears on page 14:</p>
<p><img alt="Picture of the book page. Code reproduced below." src="https://assets.buttondown.email/images/94e6ad15-8d09-48df-b885-191318bfd179.jpg?w=960&amp;fit=max"/></p>
<p>For the newsletter readers who get text only emails,<sup id="fnref:text-only"><a href="#fn:text-only">2</a></sup> here&#39;s the program:</p>
<div><pre><span></span><code><span>#include</span><span> </span><span><stdio.h></stdio.h></span>
<span>/* copy input to output; 1st version */</span>
<span>main</span><span>()</span>
<span>{</span>
<span>    </span><span>int</span><span> </span><span>c</span><span>;</span>
<span>    </span><span>c</span><span> </span><span>=</span><span> </span><span>getchar</span><span>();</span>
<span>    </span><span>while</span><span> </span><span>(</span><span>c</span><span> </span><span>!=</span><span> </span><span>EOF</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>putchar</span><span>(</span><span>c</span><span>);</span>
<span>        </span><span>c</span><span> </span><span>=</span><span> </span><span>getchar</span><span>();</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>
<p>Yup, that&#39;s nondeterministic. Because the user can enter any string, any call of <code>main()</code> could have any output, meaning the number of possible outcomes is infinity.</p>
<p>Okay that seems a little cheap, and I think it&#39;s because we tend to think of determinism in terms of how the user <em>experiences</em> the program. Yes, <code>main()</code> has an infinite number of user inputs, but for each input the user will experience only one possible output. It starts to feel more nondeterministic when modeling a long-standing system that&#39;s <em>reacting</em> to user input, for example a server that runs a script whenever the user uploads a file. This can be modeled with nondeterminism and concurrency: We have one execution that&#39;s the system, and one nondeterministic execution that represents the effects of our user.</p>
<p>(One intrusive thought I sometimes have: any &#34;yes/no&#34; dialogue actually has <em>three</em> outcomes: yes, no, or the user getting up and walking away without picking a choice, permanently stalling the execution.)</p>
<h2>4. External forces</h2>
<p>The more general version of &#34;user input&#34;: anything where either 1) some part of the execution outcome depends on retrieving external information, or 2) the external world can change some state outside of your system. I call the distinction between internal and external components of the system <a href="https://www.hillelwayne.com/post/world-vs-machine/" target="_blank">the world and the machine</a>. Simple examples: code that at some point reads an external temperature sensor. Unrelated code running on a system which quits programs if it gets too hot. API requests to a third party vendor. Code processing files but users can delete files before the script gets to them.</p>
<p>Like with PRNGs, some of these cases don&#39;t <em>have</em> to be nondeterministic; we can argue that &#34;the temperature&#34; should be a virtual input into the function. Like with PRNGs, we treat it as nondeterministic because it&#39;s useful to think in that way. Also, what if the temperature changes between starting a function and reading it?</p>
<p>External forces are also a source of nondeterminism as <em>uncertainty</em>. Measurements in the real world often comes with errors, so repeating a measurement twice can give two different answers. Sometimes operations fail for no discernable reason, or for a non-programmatic reason (like something physically blocks the sensor).</p>
<p>All of these situations can be modeled in the same way as user input: a concurrent execution making nondeterministic choices.</p>
<h2>5. Abstraction</h2>
<p>This is where nondeterminism in system models and in &#34;real software&#34; differ the most. I said earlier that pseudorandomness is <em>arguably</em> deterministic, but we abstract it into nondeterminism. More generally, <strong>nondeterminism hides implementation details of deterministic processes</strong>.</p>
<p>In one consulting project, we had a machine that received a message, parsed a lot of data from the message, went into a complicated workflow, and then entered one of three states. The final state was totally deterministic on the content of the message, but the actual process of determining that final state took tons and tons of code. None of that mattered at the scope we were modeling, so we abstracted it all away: &#34;on receiving message, nondeterministically enter state A, B, or C.&#34;</p>
<p>Doing this makes the system easier to model. It also makes the model more sensitive to possible errors. What if the workflow is bugged and sends us to the wrong state? That&#39;s already covered by the nondeterministic choice! Nondeterministic abstraction gives us the potential to pick the worst-case scenario for our system, so we can prove it&#39;s robust even under those conditions.</p>
<p>I know I beat the &#34;nondeterminism as abstraction&#34; drum a whole lot but that&#39;s because it&#39;s the insight from formal methods I personally value the most, that nondeterminism is a powerful tool to <em>simplify reasoning about things</em>. You can see the same approach in how I approach modeling users and external forces: complex realities black-boxed and simplified into nondeterministic forces on the system.</p>
<hr/>
<p>Anyway, I hope this collection of ideas I got from formal methods are useful to my broader readership. Lemme know if it somehow helps you out!</p>

            
            

            
            
            <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
            
            

            




        </div></div>
  </body>
</html>
