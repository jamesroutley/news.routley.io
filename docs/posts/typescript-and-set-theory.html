<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ivov.dev/notes/typescript-and-set-theory">Original</a>
    <h1>TypeScript and Set Theory</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<h2 id="introduction">Introduction</h2>
<p>Set theory is a branch of math devoted to <strong>sets</strong>, i.e. collections of elements. We can define a set either by enumerating the elements it contains:</p>

<p>Or by stating a rule to determine which elements belong in the set:</p>

<p>This notation is read &#34;the set of all elements <span><mjx-container jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-3-TEX-I-1D465"></use></g></g></g></svg></mjx-container></span> belonging in set <span><mjx-container jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.459ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 645 727" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-4-TEX-I-1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D446" xlink:href="#MJX-4-TEX-I-1D446"></use></g></g></g></svg></mjx-container></span> such that <span><mjx-container jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.699ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 751 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-5-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D443" xlink:href="#MJX-5-TEX-I-1D443"></use></g></g></g></svg></mjx-container></span> of <span><mjx-container jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-6-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-6-TEX-I-1D465"></use></g></g></g></svg></mjx-container></span>&#34;. This <span><mjx-container jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.699ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 751 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-7-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D443" xlink:href="#MJX-7-TEX-I-1D443"></use></g></g></g></svg></mjx-container></span> function is called <strong>predicate</strong> and its purpose is to select which elements belong in the set. Think of the predicate as the callback to a <code>filter()</code> function: it returns <code>true</code> if an item in the input belongs in the set that we are creating. <span><mjx-container jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.699ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 751 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-8-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D443" xlink:href="#MJX-8-TEX-I-1D443"></use></g></g></g></svg></mjx-container></span> is the constraint that every element must fulfill in order to qualify as a member in the set.</p>
<p>Once we have defined a set, we can describe the relation of a given element to the set. An element may, or may not, be <strong>member</strong> of (i.e., belong in) a set:</p>


<p>We can also describe the relation of a set to another set. A set is a <strong>subset</strong> of (i.e., contained in) another set if, and only if, every element of the first set is also an element of the second set. In other words, when all the items in one set exist in the other set, then the first is a subset of the second. Further, if there is also at least one element in the second set that does <em>not</em> exist in the first set, then the first (smaller) set is a <strong>proper subset</strong> of the second (larger) set, which is a <strong>superset</strong> of the first.</p>



<p>By implication, a set that is a subset of another set without being a proper subset of it may only be equal to that other set. A set <strong>equals</strong> another set if, and only if, every element of the former is a member of the latter and every element of the latter is a member of the former. Sets disregard order and duplicates — two sets are equal if, and only if, they contain the same elements.</p>


<p>Graphically:</p>
<p><img src="http://thewebivore.com/posts/set-theory/proper-subset-and-equality.png" alt="Set of relations"/></p>
<p>By contrast, consider non-subsets. A set is <em>not</em> a subset of another set if there exists at least one element in the first set that is not a member of the second set — these are <strong>overlapping sets</strong>. And if no element in the first set is a member of the second set, then the sets are <strong>disjoint sets</strong>.</p>


<p>Graphically:</p>
<p><img src="http://thewebivore.com/posts/set-theory/overlapping-sets-and-disjoint-sets.png" alt="Set of relations"/></p>
<p>Finally, two special cases. The <strong>empty set</strong>, symbolized Ø, is the set that contains nothing, e.g. the set containing the elements in common between disjoint sets. To be precise, the empty set is not nothing — rather, it is a <em>container</em> of nothing.</p>
<p>And its opposite is the <strong>universal set</strong>, symbolized U, the set that every set is a subset of, and that every element is a member of. In math, the universal set delineates the boundary for discussion.</p>

<h2 id="types-as-sets">Types as sets</h2>
<p>Set theory offers a mental model for reasoning about types in TypeScript. Through the lens of set theory, we can view <strong>a type as a set of possible values</strong>, i.e. every value of a type can be thought of as an element in a set, which makes a type comparable to a collection whose elements belong to it based on the collection&#39;s definition.</p>
<p>Imagine...</p>
<ul>
<li>the <code>number</code> type as the infinite set of every possible number,</li>
<li>the <code>string</code> type as the infinite set of every possible character permutation, and</li>
<li>the <code>object</code> type as the infinite set of every possible shape that an object can take — in JavaScript, objects include functions, arrays, dates, regular expressions, etc.</li>
</ul>
<p><img src="http://thewebivore.com/posts/set-theory/types-as-infinite-sets.png" alt="Types as infinite sets"/></p>
<p>Not all types-as-sets are infinite. Consider the <code>undefined</code>, <code>null</code>, and <code>boolean</code> types, all of which are sets holding a limited number of elements.</p>
<p>Imagine...</p>
<ul>
<li>the <code>undefined</code> type as the finite set containing the single value <code>undefined</code>,</li>
<li>the <code>null</code> type as the finite set containing the single value <code>null</code>, and</li>
<li>the <code>boolean</code> type as the finite set containing the two values <code>true</code> and <code>false</code>.</li>
</ul>
<p><img src="http://thewebivore.com/posts/set-theory/types-as-finite-sets.png" alt="Types as finite sets"/></p>
<p>Other finite sets are the <strong>string literal type</strong> and the <strong>string literal union type</strong> — the first is a set that contains one user-specified string literal; the second is a set that contains a handful of user-specified string literals. Each of these sets is a proper subset of the set of all possible strings:</p>
<pre><code>
<span>type</span> W = <span>&#39;a&#39;</span> <span>extends</span> <span>string</span> ? <span>true</span> : <span>false</span>;
<span>type</span> X = <span>&#39;a&#39;</span> | <span>&#39;b&#39;</span> <span>extends</span> <span>string</span> ? <span>true</span> : <span>false</span>;


<span>type</span> Y = <span>&#39;a&#39;</span> <span>extends</span> <span>&#39;a&#39;</span> ? <span>true</span> : <span>false</span>;


<span>type</span> Z = <span>string</span> <span>extends</span> <span>string</span> ? <span>true</span> : <span>false</span>;
</code></pre>
<p>Notice how <code>extends</code> in a conditional type is TypeScript&#39;s equivalent for:</p>
<ul>
<li><span><mjx-container jax="SVG"><svg style="vertical-align: -0.09ex;" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.312ex" role="img" focusable="false" viewBox="0 -540 778 580" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-18-TEX-N-2282" d="M84 250Q84 372 166 450T360 539Q361 539 370 539T395 539T430 540T475 540T524 540H679Q694 532 694 520Q694 511 681 501L522 500H470H441Q366 500 338 496T266 472Q244 461 224 446T179 404T139 337T124 250V245Q124 157 185 89Q244 25 328 7Q348 2 366 2T522 0H681Q694 -10 694 -20Q694 -32 679 -40H526Q510 -40 480 -40T434 -41Q350 -41 289 -25T172 45Q84 127 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="2282" xlink:href="#MJX-18-TEX-N-2282"></use></g></g></g></svg></mjx-container></span> (proper subset, i.e. every element of A is in B, and B has extra elements).</li>
<li><span><mjx-container jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 778 774" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-19-TEX-N-2286" d="M84 346Q84 468 166 546T360 635Q361 635 370 635T395 635T430 636T475 636T524 636H679Q694 628 694 616Q694 607 681 597L522 596H470H441Q366 596 338 592T266 568Q244 557 224 542T179 500T139 433T124 346V341Q124 253 185 185Q244 121 328 103Q348 98 366 98T522 96H681Q694 86 694 76Q694 64 679 56H526Q510 56 480 56T434 55Q350 55 289 71T172 141Q84 223 84 346ZM104 -131T104 -118T118 -98H679Q694 -106 694 -118T679 -138H118Q104 -131 104 -118Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="2286" xlink:href="#MJX-19-TEX-N-2286"></use></g></g></g></svg></mjx-container></span> (subset, i.e. every element of A is in B, and B has <em>no</em> extra elements)</li>
</ul>
<p>This also holds true for <code>extends</code> in a generic constraint:</p>
<pre><code>
<span>declare</span> <span>function</span> myFunc&lt;T <span>extends</span> <span>string</span>&gt;(<span>arg</span>: T): T[];
</code></pre>
<p>And in interface declarations:</p>
<pre><code><span>interface</span> <span>Person</span> {
  <span>name</span>: <span>string</span>;
}

<span>interface</span> <span>Employee</span> <span>extends</span> <span>Person</span> {
  <span>salary</span>: <span>number</span>;
}


<span>type</span> Q = <span>Person</span> <span>extends</span> <span>object</span> ? <span>true</span> : <span>false</span>;


<span>type</span> R = <span>Employee</span> <span>extends</span> <span>Person</span> ? <span>true</span> : <span>false</span>;
</code></pre>
<p>Since <code>object</code> is the set of all possible object shapes, and since an interface is the set of all possible object shapes <em>whose properties match the interface</em>, any given interface is a proper subset of the <code>object</code> type.</p>
<p>And in turn, when a child interface <code>extends</code> a parent interface, the child interface is the set of all possible object shapes <em>whose properties match the parent interface</em>. A child interface is thus a proper subset of a parent interface, which is itself a proper subset of the <code>object</code> type.</p>
<p>Notice also that, if a type is a proper subset of another, their relation hints at their compatibility on assignment:</p>
<pre><code><span>let</span> <span>myString</span>: <span>string</span> = <span>&#39;myString&#39;</span>;
<span>let</span> <span>myStringLiteral</span>: <span>&#39;only&#39;</span> | <span>&#39;specific&#39;</span> | <span>&#39;strings&#39;</span> = <span>&#39;only&#39;</span>;


myString = <span>&#39;myNewString&#39;</span>;
myString = myStringLiteral;


myStringLiteral = myString;
</code></pre>
<p>These and other compiler behaviors are explained by set theory.</p>
<p>Thinking of types as sets can help us reason about:</p>
<ol>
<li>Type compatibility during assignments.</li>
<li>Type creation with type operators.</li>
<li>Conditional type resolution.</li>
</ol>
<h3 id="part-1-assignability">Part 1: Assignability</h3>
<p>An assignment stores a value in a specific memory location labeled with a variable. Both the value and the variable are typed, and so assignability (i.e., assignment compatibility) depends on two types: that of the value being assigned and that of the recipient variable.</p>
<p>When the two types are identical, the assignment succeeds:</p>
<pre><code><span>let</span> <span>a</span>: <span>number</span>;
a = <span>123</span>; 
</code></pre>
<p>But when the two types are <em>not</em> identical, for the assignment to succeed, a type transformation must occur. When we assign a value of a type to a variable of <em>different</em> type, we are <strong>type-casting</strong>, that is, we are causing the type of the value to become another type in the variable.</p>
<p>Type-casting often takes the form of <strong>upcasting</strong>: we <em>broaden</em> the type of the value into a more encompassing type in the variable, e.g. a string literal becomes a string.</p>
<pre><code><span>let</span> <span>myString</span>: <span>string</span> = <span>&#39;myString&#39;</span>;
<span>let</span> <span>myStringLiteral</span>: <span>&#39;only&#39;</span> | <span>&#39;specific&#39;</span> | <span>&#39;strings&#39;</span> = <span>&#39;only&#39;</span>;

myString = myStringLiteral; 
</code></pre>
<p>Upcasting transforms a subtype into a supertype, that is, a proper subset into a superset. TypeScript allows this transformation because it is type-safe: if a set is a proper subset of another, then any element in the smaller set is also a member in the larger set.</p>
<p>On the other hand, downcasting is normally disallowed. To ensure type safety, we cannot declare that a member of a larger set is also a member of a smaller set — we cannot know this for certain. And if both sets are equal, the two types are identical and so there is no need for type-casting.</p>
<p>Reversing the assignment above shows that downcasting a string into a string literal is disallowed:</p>
<pre><code><span>let</span> <span>myString</span>: <span>string</span> = <span>&#39;myString&#39;</span>;
<span>let</span> <span>myStringLiteral</span>: <span>&#39;only&#39;</span> | <span>&#39;specific&#39;</span> | <span>&#39;strings&#39;</span> = <span>&#39;only&#39;</span>;

myStringLiteral = myString; 
</code></pre>
<p>Following this logic, we can predict which type transformations will be allowed during assignments, except for two special cases.</p>
<p>Assignability-wise, <code>never</code> is special in that...</p>
<ul>
<li><code>never</code> is assignable to every other type, and</li>
<li>no type is assignable to <code>never</code>.</li>
</ul>
<p>This means that every type can be on the receiving end of <code>never</code>, and <code>never</code> itself cannot be on the receiving end of any other type. In other words, upcasting from <code>never</code> to any other type is possible (albeit see the boxed comment below), whereas downcasting from <code>never</code> to anything else is disallowed for type safety. <code>never</code> is thus called the <strong>bottom type</strong>, symbolized ⊥ in type theory.</p>
<p>In set theory terms, <code>never</code> is the set that no element can ever be a member of, and that no other set can ever be a subset of — <code>never</code> is the empty set, the set that refuses to contain anything.</p>
<pre><code><span>const</span> <span>a</span>: <span>never</span> = <span>1</span>; 
</code></pre>
<div><p><strong>No example for valid <code>never</code> assignment:</strong></p><p><code>never</code> can always be broadened to a more encompassing type, but in practice, no example can be provided for <code>never</code> being assigned to another type because, by definition, a value of type <code>never</code> cannot ever happen — no actual value of type <code>never</code> should ever be available for assignment.</p><p>But if in practice a <code>never</code> value is unavailable for assignment, what does it mean for <code>never</code> to be assignable to another type? Refer to <a href="https://stackoverflow.com/a/53748099">this answer</a>.</p></div>
<p>The opposite case is <code>unknown</code>, mostly used to type a value whose type is meant to be confirmed before usage, e.g. <code>JSON.parse()</code> should ideally return <code>unknown</code>. TypeScript forces us to find out what type every <code>unknown</code> value is before we may safely use it.</p>
<pre><code><span>let</span> <span>a</span>: <span>unknown</span>;

a.<span>toUpperCase</span>(); 

<span>if</span> (<span>typeof</span> a === <span>&#39;string&#39;</span>) {
  a.<span>toUpperCase</span>(); 
}
</code></pre>
<p>Assignability-wise, <code>unknown</code> is special in that...</p>
<ul>
<li>every type is assignable to <code>unknown</code>, and</li>
<li><code>unknown</code> is not assignable to any other type.</li>
</ul>
<p><code>unknown</code> can be on the receiving end of every type, and no type can be on the receiving end of <code>unknown</code>. In other words, upcasting from any other type to <code>unknown</code> is possible (albeit rarely useful, since <code>unknown</code> exists to require the caller to type-check the value), and downcasting from <code>unknown</code> is disallowed for type safety.</p>
<p>Since <code>unknown</code> is meant to be type-checked (&#34;refined&#34;) before use, <code>unknown</code> is potentially every type: every type is under the umbrella of <code>unknown</code>. Hence <code>unknown</code> is called the <strong>top type</strong>, symbolized ⊤ in type theory.</p>
<pre><code><span>let</span> <span>x</span>: <span>unknown</span> = <span>&#39;a&#39;</span>; 

<span>let</span> <span>a</span>: <span>unknown</span>;
<span>const</span> <span>b</span>: <span>string</span> = a; 
</code></pre>
<p>In set theory terms, <code>unknown</code> is a superset of all other types — it is the set that every element is a member of, and that every set is a subset of. <code>unknown</code> is therefore the universal set, the set that contains everything.</p>
<p>In sum, <code>never</code> and <code>unknown</code> resemble other types in that downcasting is disallowed, but differ from other types in that upcasting from <code>never</code>, and upcasting to <code>unknown</code>, are both possible but in practice rarely happen.</p>
<div><p><strong><code>any</code> as an escape hatch</strong></p><p>Oddly, <code>any</code> is a mixture of <code>never</code> and <code>unknown</code>. <code>any</code> is assignable to every type, just like <code>never</code>, and every type is assignable to <code>any</code>, just like <code>unknown</code>. As a blend of two opposites, <code>any</code> has no equivalent in set theory, and is best seen as an escape hatch to disable TypeScript&#39;s assignability rules.</p></div>
<h3 id="part-2-type-creation">Part 2: Type creation</h3>
<p>We can use <strong>set operators</strong> to combine existing sets into a new set:</p>
<ul>
<li>The <strong>union</strong> of A and B is the set of all elements that are in at least A or B.</li>
<li>The <strong>intersection</strong> of A and B is the set of all elements that are both in A and in B.</li>
<li>The <strong>difference</strong> of A minus B is the set of all elements that are in A and not in B.</li>
<li>The <strong>complement</strong> of A is the set of all elements in U that are not in A.</li>
</ul>

<p>Graphically:</p>
<p><img src="http://thewebivore.com/posts/set-theory/set-operations.png" alt="Set of relations"/></p>
<p>Out of these four set operators, TypeScript implements two as <strong>type operators</strong>:</p>
<ul>
<li><code>|</code> for union, and</li>
<li><code>&amp;</code> for intersection.</li>
</ul>
<p>Unionizing with <code>|</code> means creating a broader, more inclusive type made up of both input types, whereas intersecting with <code>&amp;</code> means creating a smaller, more restrictive type made up of only the elements shared by both input types.</p>
<p>As type operators, <code>|</code> and <code>&amp;</code> operate on types (sets), not on the elements (values) that belong in those sets. Think of type operators as functions that take in types as inputs, and return another type as the output.</p>
<p>When operating on primitives, <code>|</code> and <code>&amp;</code> behave predictably:</p>
<pre><code><span>type</span> <span>StringOrNumber</span> = <span>string</span> | <span>number</span>;


<span>type</span> <span>StringAndNumber</span> = <span>string</span> &amp; <span>number</span>;

</code></pre>
<p>But when operating on interfaces, <code>|</code> and <code>&amp;</code> seem to behave counter-intuitively.</p>
<p>Consider this example:</p>
<pre><code><span>interface</span> <span>ICat</span> {
  <span>eat</span>(): <span>void</span>;
  <span>meow</span>(): <span>void</span>;
}

<span>interface</span> <span>IDog</span> {
  <span>eat</span>(): <span>void</span>;
  <span>bark</span>(): <span>void</span>;
}

<span>declare</span> <span>function</span> <span>Pet</span>(<span></span>): <span>ICat</span> | <span>IDog</span> {};

<span>const</span> pet = <span>new</span> <span>Pet</span>();

pet.<span>eat</span>(); 
pet.<span>meow</span>(); 
pet.<span>bark</span>(); 
</code></pre>
<p>The <code>|</code> in a union type is usually taken to mean &#34;<em>either</em> A <em>or</em> B is admissible&#34;. This roughly matches up with the fact that the boolean operator <code>||</code> means <code>OR</code> in an expression. Thinking of unions of interfaces in terms of <code>OR</code>, however, can be misleading.</p>
<p>Parsing the output type <code>ICat | IDog</code> as allowing &#34;<em>either</em> the methods of <code>ICat</code> <em>or</em> the methods of <code>IDog</code>&#34; leads us to believe that the output type <code>ICat | IDog</code> will accept an object with <em>either</em> the methods of <code>ICat</code> <em>or</em> the methods of <code>IDog</code>, but that is not what the compiler allows, as shown above. On the contrary, the union <code>ICat | IDog</code> will have the methods of <em>both</em> input types. This is a new set made up of <em>both</em> input sets, where all the values in both input sets are admissible.</p>
<p>And the converse holds true for intersections: <code>&amp;</code> in an intersection type is usually taken to mean &#34;one <em>and</em> the other&#34;. This matches up with the fact that the boolean operator <code>&amp;&amp;</code> means <code>AND</code> in an expression. But thinking of intersections of interfaces in terms of <code>AND</code> can also be misleading.</p>
<p>Consider this example:</p>
<pre><code><span>interface</span> <span>ICat</span> {
  <span>eat</span>(): <span>void</span>;
  <span>meow</span>(): <span>void</span>;
}

<span>interface</span> <span>IDog</span> {
  <span>eat</span>(): <span>void</span>;
  <span>bark</span>(): <span>void</span>;
}

<span>declare</span> <span>function</span> <span>Pet</span>(<span></span>): <span>ICat</span> &amp; <span>IDog</span> {};

<span>const</span> pet = <span>new</span> <span>Pet</span>();

pet.<span>eat</span>(); 
pet.<span>meow</span>(); 
pet.<span>bark</span>(); 
</code></pre>
<p>Parsing the output type <code>ICat &amp; IDog</code> as allowing &#34;the methods of <code>ICat</code> <em>and</em> the methods of <code>IDog</code>&#34; leads us to believe that the output type <code>ICat &amp; IDog</code> will accept <em>both</em> an object with the methods of <code>ICat</code> <em>and</em> an object with the methods of <code>IDog</code>, but that is not what the compiler allows, as shown above. On the contrary, the intersection <code>ICat &amp; IDog</code> will have <em>only the methods that are shared between both input types</em>, that is, a new set made up of elements common to the input sets.</p>
<p>To sum up, when unionizing interfaces, thinking in terms of <code>OR</code> can cloud our interpretation, while visualizing a broader output set can help clarify it. And when intersecting interfaces, thinking in terms of <code>AND</code> can also cloud our interpretation, while visualizing a narrower output set can help clarify it.</p>
<p>But why are our expectations reversed when unionizing and intersecting interfaces?</p>
<p>The <code>object</code> type is the infinite set of all possible object shapes; an interface is the infinite set of all possible object shapes <em>that have specific properties</em>. An interface is then a subset of the <code>object</code> set. From the universe of all possible object shapes, those object shapes whose properties match the interface are assignable to it.</p>
<pre><code><span>let</span> <span>a</span>: <span>object</span>;
a = { <span>z</span>: <span>1</span> }; 
</code></pre>
<p>Since an interface describes the shape of an object, the more properties we add to the interface, the fewer object shapes will match, and so the smaller the set of possible values becomes. Adding properties to an interface shrinks the set that it stands for, and vice versa.</p>
<pre><code><span>interface</span> <span>Person</span> {
  <span>name</span>: <span>string</span>;
  <span>age</span>: <span>number</span>;
  <span>isMarried</span>: <span>boolean</span>;
}
</code></pre>
<p>When unionizing two interfaces, visualize two fully shaded sets that are <em>partly overlapping</em>. When we unionize, we are creating an output type that accepts types that match...</p>
<ul>
<li>one input type, or</li>
<li>the other input type, or</li>
<li><em>both</em>.</li>
</ul>
<p>From the universe of all possible object shapes, those three object shapes are assignable to the output type, which makes for an output type that is broader, more inclusive, than the two inputs by themselves. Thinking of unionizing interfaces with <code>OR</code> only makes sense when we remember to account for the overlap of both.</p>
<pre><code><span>interface</span> A {
  <span>a</span>: <span>1</span>;
}

<span>interface</span> B {
  <span>b</span>: <span>1</span>;
}

<span>const</span> <span>x</span>: A | B = { <span>a</span>: <span>1</span> }; 
<span>const</span> <span>y</span>: A | B = { <span>b</span>: <span>1</span> }; 
<span>const</span> <span>z</span>: A | B = { <span>a</span>: <span>1</span>, <span>b</span>: <span>1</span> }; 
</code></pre>
<p>A union of primitives like <code>string | number</code> also produces an overlap, but there is no primitive that is simultaneously of two types, so there is nothing that can be assigned to an overlap of primitives. Since we tend to overlook this case, we default to thinking that the boolean <code>OR</code> is a precise way of thinking about unions of all types, which can lead us astray when operating on non-primitives.</p>
<p>And conversely, when intersecting two interfaces, visualize two partly overlapping sets, shaded only in their overlap. When intersecting, we are creating an output type that accepts only types that match the overlap, that is, only the shared segment.</p>
<pre><code><span>interface</span> A {
  <span>a</span>: <span>1</span>;
}

<span>interface</span> B {
  <span>b</span>: <span>1</span>;
}

<span>const</span> <span>x</span>: A &amp; B = { <span>a</span>: <span>1</span> }; 
<span>const</span> <span>y</span>: A &amp; B = { <span>b</span>: <span>1</span> }; 
<span>const</span> <span>z</span>: A &amp; B = { <span>a</span>: <span>1</span>, <span>b</span>: <span>1</span> }; 
</code></pre>
<p>An intersection of primitives like <code>string &amp; number</code> always produces <code>never</code>, because no primitive can ever share elements with another. But interfaces are subsets of <code>object</code>, so an intersection of interfaces always produces an interface that can satisfy both input object shapes simultaneously. Even if the intersected interfaces have no properties in common, they share the commonality of being slices of all possible object shapes.</p>
<p>And again, carrying our intuition of intersecting primitives over to intersecting non-primitives causes us to think in boolean <code>AND</code> terms, and so we risk assuming, incorrectly, that <code>x</code> and <code>y</code> above should succeed when they do not.</p>
<div><p><strong>Cumulative effect:</strong></p><p>When we unionize different interfaces, the overlap accumulates properties. When we intersect different interfaces, the output type accumulates properties. When we declare that an interface <code>extends</code> another, the child interface accumulates properties.</p><p>In all three cases, this cumulative effect resembles that of <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">interface declaration merging</a>, where separate declarations of the same interface create an aggregate interface that accumulates the properties in each.</p></div>
<h3 id="part-3-resolution-of-conditional-types">Part 3: Resolution of conditional types</h3>
<p>In set theory, there are equations that hold universally true for all elements in a set.</p>

<p>Commutative laws</p>

<p>Associative laws</p>

<p>Distributive laws</p>
<p>In total, there are twelve laws for all four operators supported by sets — but since TypeScript implements only <code>|</code> and <code>&amp;</code>, only some of all twelve laws apply to both sets and types. Of these, two pairs of laws are especially useful for making sense of conditional types: <strong>identity laws</strong> and <strong>idempotent laws</strong>.</p>

<p>Identity laws</p>
<p>A set in union with the empty set resolves to itself; a set in intersection with the universal set also resolves to itself. The special sets, just like their TypeScript equivalents, are collapsed by the identity laws:</p>
<pre><code><span>type</span> A = <span>string</span> | <span>never</span>; 
<span>type</span> B = <span>string</span> &amp; <span>unknown</span>; 
</code></pre>

<p>Idempotent laws</p>
<p>A set in union with itself resolves to itself; a set in intersection with itself also resolves to itself. The duplicates, whether sets or types, are filtered out by the idempotent laws:</p>
<pre><code><span>type</span> A = <span>string</span> | <span>string</span>; 
<span>type</span> B = <span>string</span> &amp; <span>string</span>; 
</code></pre>
<p>How do identity laws and idempotent laws relate to conditional types?</p>
<p>If a type is a set, then the condition in a conditional type amounts to a subset check. Is a set a (proper) subset of another? If so, then the given type is assignable to the recipient type. As the focus of the check, this given type we are asking about is called the <strong>checked type</strong>.</p>
<pre><code><span>type</span> R = <span>&#39;a&#39;</span> <span>extends</span> <span>string</span> ? <span>true</span> : <span>false</span>; 
<span>type</span> S = <span>&#39;a&#39;</span> | <span>&#39;b&#39;</span> <span>extends</span> <span>number</span> ? <span>true</span> : <span>false</span>; 

<span>type</span> T = { <span>a</span>: <span>1</span>; <span>b</span>: <span>2</span> } <span>extends</span> { <span>a</span>: <span>1</span> } ? <span>true</span> : <span>false</span>; 
<span>type</span> U = { <span>a</span>: <span>1</span> } <span>extends</span> { <span>a</span>: <span>1</span>; <span>b</span>: <span>2</span> } ? <span>true</span> : <span>false</span>; 
</code></pre>
<p>If the checked type is concrete, conditional type resolution is straightforward. But what if the checked type is generic? When we introduce a generic into a conditional type, we usually do so in order to be able to access the generic in the resolved type, often to filter the input and/or transform the output:</p>
<pre><code><span>type</span> X&lt;T&gt; = T <span>extends</span> <span>OtherType</span> ? T : <span>never</span>;
<span>type</span> Y&lt;T&gt; = T <span>extends</span> <span>OtherType</span> ? T[] : <span>never</span>;
<span>type</span> Z&lt;T&gt; = T <span>extends</span> <span>OtherType</span> ? { <span>a</span>: T } : <span>never</span>;
</code></pre>
<p>Generic being checked and then being used in the output.</p>
<p>It is when we <strong>pass a union type into a checked generic</strong> that conditional type resolution stops being straightforward and becomes open to interpretation.</p>
<p>When we pass a union to a generic in a conditional type, do we mean...?</p>
<ul>
<li>Check if <em>each constituent of the union</em> is a (proper) subset of the other type and resolve each type. Aggregate all resolved types in a union.</li>
<li>Check if <em>the union as a whole</em>, meaning as a single set, is a (proper) subset of the other type and resolve the type.</li>
</ul>
<p>The first interpretation is a <strong>distributive conditional type</strong>. Here, the check is distributed over each constituent of the union. This means that a question is asked of each union constituent, and a type is resolved based on the answer for each union constituent. This is TypeScript&#39;s default resolution strategy for a conditional type having a checked generic to which a union is passed.</p>
<pre><code>
<span>type</span> <span>ToArrayDist</span>&lt;T&gt; = T <span>extends</span> <span>unknown</span> ? T[] : <span>never</span>;


<span>type</span> R = <span>ToArrayDist</span>&lt;<span>string</span> | <span>number</span>&gt;; 


<span>type</span> R =
  | (<span>string</span> <span>extends</span> <span>unknown</span> ? <span>string</span>[] : <span>never</span>)
  | (<span>number</span> <span>extends</span> <span>unknown</span> ? <span>number</span>[] : <span>never</span>);


<span>type</span> R = <span>string</span>[] | <span>number</span>[];
</code></pre>
<div><p><strong>Mind the difference:</strong></p><p>A distributive conditional type distributes a check over a union, producing one resolved type per union constituent. Therefore, a <strong>distributive conditional type</strong> is unrelated to <strong>set distributive laws</strong>, which redistribute intersections and unions for three different sets, as shown at the start of this section.</p></div>
<p>The second interpretation, operating on the union as a whole, is a non-distributive conditional type. Since distributivity is the default behavior, disabling distributivity requires wrapping each of the two types in the condition with square brackets. Non-distributivity is TypeScript&#39;s alternative resolution strategy for a conditional type having a checked generic to which a union is passed.</p>
<pre><code>
<span>type</span> <span>ToArrayNonDist</span>&lt;T&gt; = [T] <span>extends</span> [<span>unknown</span>] ? T[] : <span>never</span>;


<span>type</span> R = <span>ToArrayNonDist</span>&lt;<span>string</span> | <span>number</span>&gt;;


<span>type</span> R = (<span>string</span> | <span>number</span>)[];
</code></pre>
<p>In the examples above, the conditions are always true (i.e., the false branches are never reached) so that we can focus on the distributive effect. Other ways of achieving an always-true condition are <code>T extends any</code> and <code>T extends T</code>. These always-true conditions are useful for creating distributive helpers:</p>
<pre><code>
<span>type</span> <span>GetKeys</span>&lt;T&gt; = T <span>extends</span> T ? keyof T : <span>never</span>;


<span>type</span> R = <span>GetKeys</span>&lt;{ <span>a</span>: <span>1</span>; <span>b</span>: <span>2</span> } | { <span>c</span>: <span>3</span> }&gt;;


<span>type</span> R
  | { <span>a</span>: <span>1</span>; <span>b</span>: <span>2</span> } <span>extends</span> { <span>a</span>: <span>1</span>; <span>b</span>: <span>2</span> } ? keyof { <span>a</span>: <span>1</span>; <span>b</span>: <span>2</span> } : <span>never</span>
  | { <span>c</span>: <span>3</span> } <span>extends</span> { <span>c</span>: <span>3</span> } ? keyof { <span>c</span>: <span>3</span> } : <span>never</span>;


<span>type</span> R = keyof { <span>a</span>: <span>1</span>; <span>b</span>: <span>2</span> } | keyof { <span>c</span>: <span>3</span> };


<span>type</span> R = <span>&#39;a&#39;</span> | <span>&#39;b&#39;</span> | <span>&#39;c&#39;</span>;
</code></pre>
<p>By contrast, in distributive conditional types where true and false branches are both reachable, the resolution of each constituent is bound to turn up duplicate types and instances of <code>never</code> chained together in the output union. When duplicate types and instances of <code>never</code> occur, TypeScript applies identity and idempotent laws to filter and collapse the union of resolved types into its minimal expression:</p>
<pre><code>
<span>type</span> <span>NonNullable</span>&lt;T&gt; = T <span>extends</span> <span>null</span> | <span>undefined</span> ? <span>never</span> : T;


<span>type</span> R = <span>NonNullable</span>&lt;<span>string</span> | <span>string</span> | <span>string</span>[] | <span>null</span> | <span>undefined</span>&gt;;


<span>type</span> R =
  | (<span>string</span> <span>extends</span> <span>null</span> | <span>undefined</span> ? <span>never</span> : <span>string</span>)
  | (<span>string</span> <span>extends</span> <span>null</span> | <span>undefined</span> ? <span>never</span> : <span>string</span>)
  | (<span>string</span>[] <span>extends</span> <span>null</span> | <span>undefined</span> ? <span>never</span> : <span>string</span>[])
  | (<span>null</span> <span>extends</span> <span>null</span> | <span>undefined</span> ? <span>never</span> : <span>null</span>)
  | (<span>undefined</span> <span>extends</span> <span>null</span> | <span>undefined</span> ? <span>never</span> : <span>undefined</span>);


<span>type</span> R = <span>string</span> | <span>string</span> | <span>string</span>[] | <span>never</span> | <span>never</span>;


<span>type</span> R = <span>string</span> | <span>string</span> | <span>string</span>[];


<span>type</span> R = <span>string</span> | <span>string</span>[];
</code></pre>
<p>Finally, be aware that for a conditional type to trigger distributivity, the checked generic must be <em>by itself</em> to the left of <code>extends</code>, that is, not passed into another generic or otherwise altered during the check.</p>
<pre><code>
<span>type</span> R&lt;T&gt; = T <span>extends</span> <span>OtherType</span> ? <span>true</span> : <span>false</span>;


<span>type</span> R&lt;T&gt; = <span>SomeType</span>&lt;T&gt; <span>extends</span> <span>OtherType</span> ? <span>true</span> : <span>false</span>;
</code></pre></div></div></div>
  </body>
</html>
