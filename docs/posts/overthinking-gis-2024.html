<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scottsexton.co/post/overthinking_gis/">Original</a>
    <h1>Overthinking GIS (2024)</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      <main>
        
  <div>
    
    <div>
      
      
        <ul>
          <li>
            <em></em>
            <span>
                
                  15/7/2024
                

              
            </span>
          </li>
          <li>
            <em></em>
            <span>7-minute read</span>
          </li>
        </ul>
      <p>A roundabout way to downsampling data</p>
<hr/>
<h3 id="maps-in-the-modern-era">Maps in the Modern Era</h3>
<p>GIS is probably one of the best things to happen to cartography in the last couple hundred years.  I say that with absolutely no knowledge of the history of map making, but GIS is wildly useful and consistent in how it is presented on publicly-accessible sites.  I can go to the <a href="https://www.usgs.gov/tools/national-map-viewer">USGS National Map Viewer</a> and am presented with more data and information than I could possibly ever find useful.</p>
<p><img src="https://scottsexton.co/post/overthinking_gis/images/national_map.jpg" alt="national_map"/></p>
<p>Even more surprising is that county-level GIS websites look similar enough to the national map and other county maps that someone just roughly familiar with GIS and layers can find more granular information about a single parcel of land.  Personally I don’t have a use for a color-coded sale year plot, but this county in Georgia provides it.  The breadth and depth of information to the general public is incredible.</p>
<p><img src="https://scottsexton.co/post/overthinking_gis/images/sale_year.jpg" alt="sale_year"/></p>
<h3 id="custom-metrics">Custom Metrics</h3>
<p>Still though, all of this information is quantifiable because computers don’t speak human languages (LLMs are still <em>just</em> math) and what I wanted is something more human-centric, more qualitative: usability.  I’m defining usability as “not too steep to build on” which sounds straightforward until you actually try to come up with a number that defines that.  The closest thing to my usability metric is <a href="https://en.wikipedia.org/wiki/Grade_(slope)">grade</a> and while the USGS map provides elevation and topographic information it does not tell me the grade, at least I couldn’t find that option in the layers.  If a GIS wizard out there wants to point me in the direction of a grade map it would make my life a lot easier.</p>
<p>I decided to define usability as the average grade for some area of land. Ok, great, but how do I calculate that with the data on hand?  The USGS map provides topographic lines, and past experience reading topo maps has taught me what “too steep” is, but that’s the result of over a decade of hiking and reading maps.  How do I tell the computer “when you see topo lines close together it’s <em>probably</em> too steep and has a low usability score”?.</p>
<p>In this section of map the grade on the Western side of the river is too steep to use, but the flat area on the Eastern side is perfect.  Topo lines close to each other indicate steep terrain, and lines far apart indicate flatter terrain.</p>
<p><img src="https://scottsexton.co/post/overthinking_gis/images/topo.jpg" alt="topo"/></p>
<h3 id="source-data">Source Data</h3>
<p>Topo maps are available for download from the USGS site, but that’s just a map and isn’t very useful to the computer.  I suppose using <a href="https://docs.opencv.org/3.4/d7/d4d/tutorial_py_thresholding.html">thresholding</a> I could select only the topo lines but that still doesn’t give me the usability score I want.  Digging deeper, the topo maps are derived from elevation data and that is also available to download.  Multiple sources and derived products are available, and I chose the highest resolution data offered which is the DEM source in ~3m resolution.</p>
<p><img src="https://scottsexton.co/post/overthinking_gis/images/dem_download.jpg" alt="download"/></p>
<p>I verified the resolution with <code>gdalinfo</code> looking at <code>Pixel Size</code>:</p>
<div><pre tabindex="0"><code data-lang="fallback">$ gdalinfo steep_north_tile.tif | grep Pixel
Pixel Size = (3.125000000000000,-3.125000000000000)
</code></pre></div><h3 id="calculating-usability">Calculating Usability</h3>
<p>With the source data downloaded it was time come up with a calculation for my usability metric.  As I said earlier the closest common value to what I want is grade.  Grade can be defined as “rise over run” or $y=mx + b$ where $b$ is 0 and we don’t really care what $y$ is.  The value we care about is $x$, the slope of the terrain. This works for a 1D case but I want to take into account slope in two directions so we have to move up from middle school math to calculus, specifically vector calculus.  In vector calculus the <a href="https://en.wikipedia.org/wiki/Gradient">gradient</a> describes the rate of change of a function in multiple directions (dimenions) and is just the partial derivative of a function for a given direction.  If I have some function that describes how how the land is shaped and I wanted to find the rate of change (grade) in the $x$ direction I would calculate the partial derivative of the function with respect to $x$, and similarly for $y$. The first derivative gives us the slope, and the second derivative gives us the rate of change of the slope.  <strong>This rate of change of slope is “how close are the topo lines?” described mathematically.</strong></p>
<p>Glossing over a lot of details, there is a mathematical operator called the <a href="https://en.wikipedia.org/wiki/Laplace_operator">Laplacian</a> that calculates the second order differential for a scalar field.  In practical terms what that means is that it calculates the rate of change in the intensity of pixels in an image.  An even more hand-wavy and pratical explanation is that calculating the Laplacian shows us where in an image the pixels change for both the X and Y directions.  OpenCV’s documentation does a good job of <a href="https://docs.opencv.org/4.x/d5/d0f/tutorial_py_gradients.html">explaining this</a> and has a great example image showing the partial derivative in the X direction, the Y direction, and both.</p>
<p><img src="https://docs.opencv.org/4.x/gradients.jpg" alt="derivatives"/></p>
<p>Doing the same thing with the data I have on hand takes just a few lines, including plotting the result.  <code>plt.clim</code> is used to set the limits of the color mapping and enhance the contrast in the resulting plot.</p>
<div><pre tabindex="0"><code data-lang="python"><span>import</span> <span>cv2</span>
<span>import</span> <span>matplotlib.pylab</span> <span>as</span> <span>plt</span>
<span>import</span> <span>numpy</span> <span>as</span> <span>np</span>

<span>def</span> <span>normalize_array</span><span>(</span><span>array</span><span>):</span>
    <span>array_min</span><span>,</span> <span>array_max</span> <span>=</span> <span>array</span><span>.</span><span>min</span><span>(),</span> <span>array</span><span>.</span><span>max</span><span>()</span>
    <span>return</span> <span>(</span><span>array</span> <span>-</span> <span>array_min</span><span>)</span> <span>/</span> <span>(</span><span>array_max</span> <span>-</span> <span>array_min</span><span>)</span>

<span>def</span> <span>get_laplacian</span><span>(</span><span>f</span><span>:</span> <span>str</span><span>):</span>
    <span>img</span> <span>=</span> <span>cv2</span><span>.</span><span>imread</span><span>(</span><span>f</span><span>,</span> <span>-</span><span>1</span><span>)</span>
    <span># Normalize the data and set to a max of 255</span>
    <span>norm</span> <span>=</span> <span>normalize_array</span><span>(</span><span>img</span><span>)</span> <span>*</span> <span>255</span>
    <span># Set data type to 8-bit integer for processing</span>
    <span>norm</span> <span>=</span> <span>norm</span><span>.</span><span>astype</span><span>(</span><span>np</span><span>.</span><span>uint8</span><span>)</span>
    <span>return</span> <span>cv2</span><span>.</span><span>Laplacian</span><span>(</span><span>norm</span><span>,</span> <span>cv2</span><span>.</span><span>CV_64F</span><span>)</span>

<span>l</span> <span>=</span> <span>get_laplacian</span><span>(</span><span>&#39;steep_tile.tif&#39;</span><span>)</span>
<span>plt</span><span>.</span><span>imshow</span><span>(</span><span>l</span><span>)</span>
<span>plt</span><span>.</span><span>clim</span><span>(</span><span>-</span><span>1</span><span>,</span><span>2</span><span>)</span> 
<span>plt</span><span>.</span><span>show</span><span>()</span>
</code></pre></div><p><img src="https://scottsexton.co/post/overthinking_gis/images/almost_topo.jpg" alt="almost_topo"/></p>
<p>This looks a lot like topo lines but inspecting individual pixels it’s evident that both positive and negative values exist.  What we’re seeing here is the second-order derivative which is the rate of change of the pixel values, or in human terms this is how quickly the grade changes.  When looking at a topo map if the lines are close to each other we would expect to see a (relatively) large value in the plot above, and for an area where topo lines are far apart we should see a value of 0.  Comparing the plot against a topo map for this section of land it’s evident that what we’re seeing does in fact describe the steepness of the terrain.  Note the zero values (green) along the road, and higher values (yellowish) on the adjacent hill.</p>
<p><img src="https://scottsexton.co/post/overthinking_gis/images/topo_comparison.jpg" alt="topo_comparison"/></p>
<p>We now have a plot describing how close topo lines are and the next step is to calculate the average value for a given area.  To accomplish this I used a sliding window that moves across the image and returns the values just inside that window.</p>
<div><pre tabindex="0"><code data-lang="python"><span>def</span> <span>sliding_window</span><span>(</span><span>image</span><span>,</span> <span>stepSize</span><span>,</span> <span>windowSize</span><span>):</span>
    <span># slide a window across the image</span>
    <span>for</span> <span>y</span> <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>image</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>],</span> <span>stepSize</span><span>):</span>
        <span>for</span> <span>x</span> <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>image</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>],</span> <span>stepSize</span><span>):</span>
            <span># yield the current window</span>
            <span>yield</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>image</span><span>[</span><span>y</span><span>:</span><span>y</span> <span>+</span> <span>windowSize</span><span>[</span><span>1</span><span>],</span> <span>x</span><span>:</span><span>x</span> <span>+</span> <span>windowSize</span><span>[</span><span>0</span><span>]])</span>
</code></pre></div><p>I can then calculate the average value of the window and store that in an array to be plotted later.  Using some known-good examples of steep and “flat enough” land I arrived on a mean value of 0.45 being too steep.  If a tile’s average rate of change is 0.45 or above I set it to a high value of 0.75, otherwise it’s set to zero.  This will result in a binary “usability” map.  Done!</p>
<div><pre tabindex="0"><code data-lang="python"><span># Each pixel is ~3m, set the window size to 30m</span>
<span>stepSize</span> <span>=</span> <span>10</span>
<span>windowSize</span> <span>=</span> <span>(</span><span>stepSize</span><span>,</span><span>stepSize</span><span>)</span>
<span>l_mean_map</span> <span>=</span> <span>np</span><span>.</span><span>zeros_like</span><span>(</span><span>l</span><span>)</span>
<span>for</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>window</span><span>)</span> <span>in</span> <span>sliding_window</span><span>(</span><span>l</span><span>,</span> <span>stepSize</span><span>=</span><span>stepSize</span><span>,</span> <span>windowSize</span><span>=</span><span>windowSize</span><span>):</span>
    <span>this_reading</span> <span>=</span> <span>0</span>
    <span># Threshold based on known-good values</span>
    <span>if</span> <span>window</span><span>.</span><span>mean</span><span>()</span> <span>&gt;</span> <span>0.45</span><span>:</span>
        <span>this_reading</span> <span>=</span> <span>0.75</span>
    <span>l_mean_map</span><span>[</span><span>y</span><span>:</span><span>y</span><span>+</span><span>windowSize</span><span>[</span><span>1</span><span>],</span><span>x</span><span>:</span><span>x</span><span>+</span><span>windowSize</span><span>[</span><span>0</span><span>]]</span> <span>=</span> <span>this_reading</span>
</code></pre></div><h3 id="overthinking-it">Overthinking It</h3>
<p>Plotting the usability map, raw Laplacian, and raw source data all next to each other it’s clear how this is effectively just a very complicated downstampling method, hence the blog post title.  I need to confirm this but I could probably achieve a similar result straight from the Laplacian by downsampling / blurring with a kernel size set to <code>stepSize</code>.  Oh well, at least I have a lot of knobs to turn in case I want to tweak more parameters in the future.</p>
<p><img src="https://scottsexton.co/post/overthinking_gis/images/usability.jpg" alt="usability"/></p>
<h3 id="usability-equation">Usability Equation</h3>
<h2 id="u_ij--fracsum_k0nnabla2f_ijn">$U_{(i,j)} = \frac{\sum_{k=0}^{n}\nabla^2F_{(i,j)}}{n}$</h2>
<p>Where $F_{(i,j)}$ is the window that slides across the image.</p>
<hr/>
<h3 id="update">Update</h3>
<p>I’ve posted more and the tool is better now, see <a href="https://scottsexton.co/post/more_gis/">rethinking GIS</a></p>
</div>
    

    
  </div>

      </main>
    </div></div>
  </body>
</html>
