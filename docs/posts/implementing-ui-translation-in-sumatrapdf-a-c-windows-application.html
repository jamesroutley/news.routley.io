<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.kowalczyk.info/a-vn0v/implementing-ui-translation-in-sumatrapdf-a-c-windows-application.html">Original</a>
    <h1>Implementing UI translation in SumatraPDF, a C&#43;&#43; Windows application</h1>
    
    <div id="readability-page-1" class="page"><div id="post">
        <div id="vn0v">


<p><a target="_blank" href="https://www.sumatrapdfreader.org/free-pdf-reader">SumatraPDF</a> is the best PDF/eBook/Comic Book viewer for Windows. It’s small, fast, full of features, free and open-source.</p>

<p>It became popular enough that it made sense to translate the UI for non-English users. Currently we support 72 languages.</p>

<p>This article describes how I designed and implemented a translation system in SumatraPDF, a native win32 C++ Windows application.</p>



<p>There are 2 hard things about translating an application</p>

<ul>
<li>code for translation system (extracting strings to translate, translate strings from English to user’s language)</li>
<li>translating them into many languages</li>
</ul>



<p>Currently there are 381 strings in SumatraPDF subject to translation. It’s important that the system requires the least amount of effort when adding new strings to translate.</p>

<p>Every string that needs to be translated is marked in <code>.cpp</code> or <code>.h</code> file with one of two macros:</p>

<ul>
<li><code>_TRA(&#34;Rename&#34;)</code></li>
<li><code>_TRN(&#34;Open&#34;)</code></li>
</ul>

<p>I have a script that extracts those strings from source files. Mine is written in Go but it could just as well be Python or JavaScript. It’s a simple regex job.</p>

<p><code>_TR</code> stands for “translation”.</p>

<p><code>_TRA(s)</code> expands into <code>const char* trans::GetTranslation(const char* str)</code> function which returns <code>str</code> translated to current UI language.</p>

<p>We auto-detect language at startup based on Windows settings and allow the user to explicitly set UI language.</p>

<p>For English we just return the original string.</p>

<p>If a string to be translated is e.g. a part of <code>const char* array[]</code>, we can’t use <code>trans::GetTranslation()</code>.</p>

<p>For cases like that we have <code>_TRN()</code> which expands to English string. We have to write code to translate it at some point.</p>

<p>Adding new strings is therefore as simple as wrapping them in <code>_TRA()</code> or <code>_TRN()</code> macros.</p>



<p>Now that we’ve extracted strings to be translated, we need to translate them into 72 languages.</p>

<p>SumatraPDF is a free, open-source program. I don’t have a budget to hire translators. I don’t have a budget, period.</p>

<p>The only option was to get help from SumatraPDF users.</p>

<p>It was vital to make it very easy for users to send me translations. I didn’t want to ask them, for example, to download some translation software.</p>

<h2 id="design-and-implementation-of-apptranslator-web-app"><p>Design and implementation of AppTranslator web app</p><a href="#design-and-implementation-of-apptranslator-web-app">

</a>
</h2>





<p>I designed it to be generic but I don’t think anyone else is using it.</p>



<ul>
<li>4k lines of Go server code</li>
<li>451 lines of html code</li>
<li>a single dependency: bootstrap CSS framework (the project is old)</li>
</ul>

<p>It’s simple because I don’t want to spend a lot of time writing translation software. It’s just a side project in service of the goal of translating SumatraPDF.</p>

<p>Login is exclusively via GitHub.</p>

<p>It doesn’t even use a database. Like in Redis, changes are stored as a series of operations in an append-only log. We keep the whole state in memory and re-create it from the log at startup.</p>

<p>Main operation is <code>translate a string from English to language X</code> represented as <code>[kOpTranslation, english string, language, translation, user who provided translation]</code>.</p>

<p>When user provides a translation in the web UI, we send an API call to the server which appends the translation operation to the log.</p>

<p>Simple and reliable.</p>

<p>Because the code is written in Go, it’s very fast and memory efficient. When running it uses mere megabytes of RAM. It can comfortably run on the smallest 256 MB VPS server.</p>

<p>I backup the log to S3 so if the server ever fails, I can re-install the program on a new server and re-download the translations from S3.</p>

<p>I provide RSS feed for each language so that people who provide translations can monitor for new strings to be translated.</p>

<h2 id="sending-strings-for-translation-and-receiving-translations"><p>Sending strings for translation and receiving translations</p><a href="#sending-strings-for-translation-and-receiving-translations">

</a>
</h2>

<p>So I have a web app for collecting translations and a script that extracts strings to be translated from source code.</p>

<p>How do they connect?</p>

<p>AppTranslator has an API for submitting the current set of strings to be translated in the simplest possible format: a line for each string (I ensure there are no newlines in the string itself by escaping them with <code>\n</code>)</p>

<p>API is password protected because only I can submit the strings.</p>

<p>The server compares the strings sent with the current set and records a difference in the log.</p>

<p>It also sends a response with translations. Again the simplest possible format:</p>
<pre><code><span><span>AppTranslator: SumatraPDF
</span></span><span><span>651b739d7fa110911f25563c933f42b1d37590f8
</span></span><span><span>:%s annotation. Ctrl+click to edit.
</span></span><span><span>am:%s մեկնաբանություն: Ctrl+քլիք՝ խմբագրելու համար:
</span></span><span><span>ar:ملاحظة %s. اضغط Ctrl للتحرير.
</span></span><span><span>az:Qeyd %s. Düzəliş etmək üçün Ctrl+düyməyə basın.
</span></span></code></pre>
<p>As you can see:</p>

<ul>
<li>a string to translate is on a line starting with :</li>
<li>is followed by translations of that strings in the format: <code>${lang}: ${translation}</code></li>
</ul>

<p>An optimization: <code>651b739d7fa110911f25563c933f42b1d37590f8</code> is a hash of this response. If I submit this hash with my request and translations didn’t change on the server, the response is empty.</p>

<h2 id="implementing-c-part-of-translation-system"><p>Implementing C++ part of translation system</p><a href="#implementing-c-part-of-translation-system">

</a>
</h2>

<p>So now I have a text file with translation downloaded from the server. How do I get a translation in my C++ code?</p>

<p>As with everything in SumatraPDF, I try to do things in a simple and efficient way.</p>

<p>The whole <code>Translation.cpp</code> is only 239 lines of code.</p>

<p>The core of translation system is <code>const char* trans::GetTranslation(const char* s);</code> function.</p>

<p>I embed the translations in exact the same format as received from AppTranslator in the executable as data file in resources.</p>

<p>If the UI language is English, we do nothing. <code>trans::GetTranslation()</code> returns its argument.</p>

<p>When we switch the language, we load the translations from resources and build an index:</p>

<ul>
<li>an array of English strings</li>
<li>an array of corresponding translations</li>
</ul>

<p>Both arrays use my own <a href="https://interjectedfuture.com/a-u2y2/implementation-of-optimized-vector-of-strings-in-c-in-sumatrapdf.html">StrVec</a> class optimized for storing an array of strings.</p>

<p>To find a translation we scan the first array to find an index of the string and return translation from the second array, at the same index.</p>

<p>Linear scan seems like it would be slow but it isn’t.</p>



<p>I have a few dialogs defined in <code>SumatraPDF.rc</code> file.</p>

<p>The problem with dialogs is that position of UI elements is fixed.</p>

<p>A translated string will almost certainly have a different size than the English string which will mess up fixed layout.</p>

<p>Thankfully someone wrote DialogSizer that smartly resizes dialogs and solves this problem.</p>



<h2 id="no-apptranslator"><p>No AppTranslator</p><a href="#no-apptranslator">

</a>
</h2>

<p>My initial implementation was simpler. I didn’t yet have AppTranslator so I stored the strings in a text file in repository in the same format as what I described above.</p>

<p>People would download it, make changes using a text editor and send me the file via email which I would then checkin.</p>

<p>It worked for a while but it became worse over time. More strings, more languages created more work for me to manually manage e-mail submissions.</p>

<p>I decided to automate the process.</p>

<h2 id="code-generation"><p>Code generation</p><a href="#code-generation">

</a>
</h2>

<p>My first implementation of C++ side used code generation instead of embedding the text file in resources.</p>

<p>My Go script would generate C++ source code files with static <code>const char* []</code> arrays.</p>

<p>This worked well but I decided to improve it further by making the code use the text file with translations embedded in the app.</p>

<p>The main motivation for the change was to open a possibility of downloading latest translations from the server to fix the problem of translations not being all ready when I build the release executable.</p>

<p>I haven’t done that yet but it’s now easier to implement given that the format of strings embedded in the exe is the same as the one I can download from AppTranslator.</p>

<h2 id="only-utf-8"><p>Only utf-8</p><a href="#only-utf-8">

</a>
</h2>

<p>SumatraPDF started by using both <code>WCHAR*</code> Unicode strings and <code>char*</code> utf8 strings.</p>

<p>For that reason the translation system had to support returning translation in both <code>WCHAR*</code> and <code>char*</code> version.</p>

<p>Over time I refactored the code to use mostly utf8 and at some point I no longer needed to support <code>WCHAR*</code> version.</p>

<p>That made the code even smaller and reduced memory usage.</p>



<p>I’m happy how things turned out.</p>

<p><a target="_blank" href="https://www.apptranslator.org/app/SumatraPDF">AppTranslator</a> proved to be reliable and hassle free. It runs for many years now and collected 35440 string translations from users.</p>

<p>I automated everything so that all I need to do is to periodically re-run the script that extracts strings from source code, uploads them to AppTranslator and downloads latest translations.</p>

<p>One problem is that translations are not always ready in time for release so I make a release and then people start translating strings added since last release.</p>

<p>I’ve considered downloading the latest translations from the server, in addition to embedding them in an executable at the time of building the app.</p>



<p>While AppTranslator is reliable and doesn’t require on-going work, it would be better to not have to run a server at all.</p>

<p>The world has changed since I started SumatraPDF.</p>

<p>Namely: people are comfortable using GitHub and you can edit files directly in GitHub UI. It’s not a great experience but it works.</p>

<p>One option would be to generate a translation text file for each language, in this format:</p>
<pre><code><span><span>:first untranslated string
</span></span><span><span>:second untranslated string
</span></span><span><span>:first translated string
</span></span><span><span>translation of first string
</span></span><span><span>:second translated string
</span></span><span><span>translation of second string
</span></span></code></pre>
<p>Untranslated strings are listed at the top, to make it easier to find.</p>

<p>A link would send a translator directly to edit this file in GitHub UI.</p>

<p>When translator saves translations, it creates a PR for me to review and merge.</p>



<blockquote>
<p>But why did you re-invent everything? You should do X instead.</p>
</blockquote>

<p>All other X that I know about suck.</p>

<h2 id="using-per-language-rc-resource-files"><p>Using per-language .rc resource files</p><a href="#using-per-language-rc-resource-files">

</a>
</h2>

<p>Traditional way of localizing / translating Window GUI apps is to store all strings and dialog definitions in an <code>.rc</code> file. Each language gets its own <code>.rc</code> file (or files) and the program picks the right resource based on a language.</p>

<p>This doesn’t solve the 2 hard problems:</p>

<ul>
<li>having an easy way to add strings for translations</li>
<li>having an easy way for users to provide translations</li>
</ul>

<h2 id="xml-horror-show"><p>XML horror show</p><a href="#xml-horror-show">

</a>
</h2>

<p>There was a dark time when the world was under the iron grip of XML fanaticism.</p>

<p>Everything had to be an XML file even when it was the worst possible solution for the problem.</p>

<p>XML doesn’t solve the 2 hard problems and a string storage format is an absolute nightmare for human editing.</p>

<h2 id="gnu-gettext"><p>GNU gettext</p><a href="#gnu-gettext">

</a>
</h2>

<p>There’s a C library gettext that uses <code>.po</code> files.</p>

<p>This is much saner solution than XML horror show. <code>.po</code> files are relatively simple text format. The code is already written.</p>

<p>Warning: tooting my own horn.</p>

<p>My format is better. It’s easier for people to edit, it’s easier to write code to parse it. <a target="_blank" href="https://github.com/autotools-mirror/gettext">This</a> looks like many times more than 239 lines of code.</p>

<p>Ok, gettext probably does a bit more than my code, but clearly nothing than I need.</p>

<p>It also doesn’t solve the 2 hard problems. I would still have to write code to extract strings from source code and build a way to allow users to translate them easily.</p>

</div>

    </div></div>
  </body>
</html>
