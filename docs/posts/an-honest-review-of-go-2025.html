<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://benraz.dev/blog/golang_review.html">Original</a>
    <h1>An Honest Review of Go (2025)</h1>
    
    <div id="readability-page-1" class="page"><div>
        <main>
            <header>
                
                
            </header>
            <div data-box="note">
            <p>NOTE:</p>
            <p>I have written a few small projects in Go, so don’t
            assume what I am writing is expert opinion on Go. These are
            just my first thoughts from using the language.</p>
            </div>
            <p>For the past few months, I have been writing Go. I am now
            considering returning to Rust, but I first want to write
            what I <a href="#like">do</a> and <a href="#hate">don’t</a>
            like about Go.</p>
            <h2 id="like">Things I like</h2>
            <h3 id="concurrency">Concurrency</h3>
            <p>Unlike most other languages, concurrency is not an
            afterthought in Go. Channels and Goroutines are built right
            into the language as first class features and are mostly a
            joy to work with in my experience. Go manages to avoid the
            famous problem of <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">colored
            functions</a> that plague a lot of other languages’
            concurrency models. Additionally, Channels and
            <code>select</code> statements are in general really nice to
            use. It’s really hard to get concurrency right and the fact
            that Go has mostly Gotten concurrency right is very
            impressive.</p>
            <h3 id="type-system">Type System</h3>
            <p>Go’s type system is intentionally very simple and does
            not allow for complex inheritance trees. While Go does have
            struct embedding:</p>
            <div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>// all methods of Animal are now implemented on Dog</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>type</span> Dog <span>struct</span> <span>{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    Animal </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>It is different from single inheritance because you can
            embed multiple structs and struct embedding is fundamentally
            syntactic sugar. Instead of writing this:</p>
            <div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Animal <span>struct</span> <span>{</span> <span>...</span> <span>}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>a Animal<span>)</span> DoSomething<span>()</span> <span>{</span> <span>...</span> <span>}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span>type</span> Dog <span>struct</span> <span>{</span> Animal Animal <span>}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span>func</span> main<span>()</span> <span>{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    Dog<span>{}.</span>Animal<span>.</span>DoSomething<span>()</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>You write this:</p>
            <div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Animal <span>struct</span> <span>{</span> <span>...</span> <span>}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>a Animal<span>)</span> DoSomething<span>()</span> <span>{</span> <span>...</span> <span>}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span>type</span> Dog <span>struct</span> <span>{</span> Animal <span>}</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span>func</span> main<span>()</span> <span>{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    Dog<span>{}.</span>DoSomething<span>()</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>While <code>Dog</code> can override
            <code>DoSomething</code>:</p>
            <div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>d Dog<span>)</span> DoSomething<span>()</span> <span>{</span> <span>...</span> <span>}</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span>func</span> main<span>(</span> </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    Dog<span>{}.</span>DoSomething<span>()</span> </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span>)</span></span></code></pre></div>
            <p>The original implementation still exists:</p>
            <div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>// both work</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>Dog<span>{}.</span>DoSomething<span>()</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>Dog<span>{}.</span>Animal<span>.</span>DoSomething<span>()</span> </span></code></pre></div>
            <div data-box="note">
            <p>NOTE:</p>
            <p>Struct embedding also includes fields not just
            methods</p>
            </div>
            <p>Additionally, in Go a struct does not have to explicitly
            fulfill an interface for it to apply. This is different from
            most other languages, where interfaces must be implemented
            explicitly for them to apply. This means that the empty
            interface <code>interface{}</code> or <code>any</code> can
            be used to effectively introduce dynamic typing, where types
            can be switched on with for example a type switch statement
            at runtime. This makes things like <code>Printf</code> and
            html and text templates way simpler to understand, and, most
            importantly, possible to write without using macros like C
            and Rust.</p>
            <h3 id="syntax">Syntax</h3>
            <div data-box="warning">
            <p>WARNING:</p>
            <p>While the rest of this post can at least pretend to be
            objective, this is just raw unfiltered opinion.</p>
            </div>
            <p>I like Go’s condensed syntax when it comes to ergonomics.
            It’s way simpler to write type annotations without the colon
            or other characters and it saves typing time.</p>
            <p>I also like using uppercase and lowercase letters for
            visibility:</p>
            <div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>// only accessible to the package</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span>type</span> hello <span>struct</span><span>{</span> <span>...</span> <span>}</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span>// public</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span>type</span> World <span>interface</span> <span>{</span> <span>...</span> <span>}</span></span></code></pre></div>
            <p>It just makes sense.</p>
            <p>Also, I <strong>hate</strong> having to write
            <code>pub</code> all the time in Rust.</p>
            <h2 id="hate">Things I Don’t Like</h2>
            <h3 id="enums1">Enums<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></h3>
            <div data-box="note">
            <p>NOTE:</p>
            <p>Yes, I know that this is a horse that has been already
            beaten to death, but it’s really annoying so I have to
            contribute my own beating to make sure this horse is really
            dead.</p>
            </div>
            <p>One of my least favorite things in Go is the lack of any
            enum type. Sometimes you just want to have an enum and Go
            makes it a pain to do. The most commonly accepted “solution”
            to this problem is to just make a bunch of constants which
            are part of one type:</p>
            <div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>type</span> State <span>int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>const</span> <span>(</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    Off State <span>=</span> <span>iota</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    On</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    Error</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span>)</span></span></code></pre></div>
            <p>This “solution” is to enums what a piece of tape is to a
            collapsed bridge. Not only is this syntax annoying and
            decoupled, it doesn’t even accomplish it’s primary Goal.
            There is no guarantee that every value of <code>State</code>
            will be either <code>On</code>, <code>Off</code>, or
            <code>Error</code>. So unless you exhaustively check every
            value of <code>State</code> in every switch statement in
            every function in your program, you have no guarantee of
            anything. A consumer of your program could just pass in a
            value of <code>State(500)</code> and it’s anyone’s guess how
            the program will mess up. Any sane language would have some
            sort of syntactic sugar for constant groups to ensure that
            it’s a closed set but Go just decides to leave that work to
            the programmer.</p>
            <p>To make things worse, Go has no idea that that you want
            exhaustiveness in switch statements either.</p>
            <div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>// this code compiles without warnings!</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>var</span> st State</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>switch</span> st <span>{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span>case</span> On<span>:</span> <span>...</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span>case</span> Off<span>:</span> <span>...</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>While you could just trust the consumer of your API not
            to do something stupid like pass in <code>State(500)</code>
            and maybe use linters to ensure exhaustivity, this is an
            astonishingly bad solution forced upon the developer by a
            language that prides itself on being simple and elegant.</p>
            <h3 id="immutability">Immutability</h3>
            <p>Go has two types of variables: constants and mutable
            variables, declared like so:</p>
            <div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>const</span> a <span>=</span> <span>45</span> <span>+</span> <span>77</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span>var</span> b <span>=</span> <span>22</span></span></code></pre></div>
            <p>Here is the problem: variables declared with
            <code>const</code> need to be <em>compile time
            constants</em>. All of these examples involve assigning to a
            constant a value <em>known at compile time</em> but none of
            them will work:</p>
            <div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>type</span> A <span>struct</span><span>{</span> val <span>int</span> <span>}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span>const</span> a <span>=</span> A<span>{</span><span>3</span><span>}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span>func</span> B<span>()</span> <span>int</span> <span>{</span> <span>return</span> <span>3</span> <span>}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span>const</span> b <span>=</span> B<span>()</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span>const</span> hash <span>=</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>int</span> <span>{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span>&#34;HELLO&#34;</span><span>:</span> <span>1</span><span>,</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span>&#34;WORLD&#34;</span><span>:</span> <span>2</span><span>,</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>What is the alternative? Use <code>var</code> of
            course:</p>
            <div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>var</span> a <span>=</span> A<span>{</span><span>3</span><span>}</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>var</span> b <span>=</span> b<span>()</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>var</span> hash <span>=</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>int</span> <span>{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span>&#34;HELLO&#34;</span><span>:</span> <span>1</span><span>,</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span>&#34;WORLD&#34;</span><span>:</span> <span>2</span><span>,</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>This is an absolutely terrible solution especially if
            your API will be used by people and these are symbols
            exported by your package. Anyone can change these variables
            and break your package. The “solution” to this problem is to
            use a function:</p>
            <div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>var</span> _data <span>=</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>int</span> <span>{</span> <span>...</span> <span>}</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span>func</span> Data<span>()</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>int</span> <span>{</span> <span>return</span> _data <span>}</span></span></code></pre></div>
            <p>This works but it sucks.</p>
            <h3 id="errors">Errors</h3>
            <p>In Go, idiomatic error management involves using the
            <code>error</code> type. For example, a safe division
            function could be implemented as so:</p>
            <div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>func</span> safe_divide<span>(</span>a<span>,</span>b <span>int</span><span>)</span> <span>(</span>float<span>,</span> <span>error</span><span>)</span> <span>{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span>if</span> b <span>==</span> <span>0</span> <span>{</span> </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>0.0</span><span>,</span> fmt<span>.</span>Errorf<span>(</span><span>&#34;divide by zero&#34;</span><span>)</span> </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span>return</span> a<span>/</span>b<span>,</span> <span>nil</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>This value can be consumed as follows:</p>
            <div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>res<span>,</span> err <span>:=</span> safe_divide<span>(</span><span>4</span><span>,</span><span>2</span><span>)</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>if</span> err <span>!=</span> <span>nil</span> <span>{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    log<span>.</span>Fatal<span>(</span>err<span>)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>doSomethingWith<span>(</span>res<span>)</span></span></code></pre></div>
            <p>It’s become something of a meme to bemoan the supposed
            difficulty of writing <code>if err != nil</code>. I actually
            won’t make that point because I think it is a very surface
            level point that has been talked about to death and I don’t
            think the ‘verbosity’ of this code snippet is such an
            issue.</p>
            <p>I have two principal problems with this approach, one of
            them about the “tuple” being used as a return type and
            another about the <code>error</code> type itself.</p>
            <h4 id="tuples-dont-exist">Tuples don’t exist</h4>
            <p>This type, <code>(T, err)</code> is not actually a real
            type. Go’s type system does not include tuples. This
            expression is something that can only be handled by
            immediate destructuring.</p>
            <p>For example, this (albeit contrived) snippet won’t
            work:</p>
            <div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>func</span> doIfErrNil<span>[</span>T<span>](</span>val <span>(</span>T<span>,</span> <span>error</span><span>),</span> f <span>func</span><span>(</span>T<span>))</span> <span>{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    v<span>,</span> err <span>:=</span> val</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span> <span>return</span> <span>}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    f<span>(</span>v<span>)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>This restriction prevents chaining, which is unidiomatic
            anyway (and maybe for good reason) or doing anything with
            (T, error) values</p>
            <h4 id="the-error-type-sucks">The <code>error</code> type
            sucks</h4>
            <p>Here is the full definition of the type
            <code>error</code>:</p>
            <div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>error</span> <span>interface</span> <span>{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    Error<span>()</span> <span>string</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>So if I am writing a library that runs some programs I
            can create my own type that implements
            <code>error</code>:</p>
            <div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>type</span> progError <span>struct</span> <span>{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    prog <span>string</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    code <span>int</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    reason <span>string</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>e progError<span>)</span> Error<span>()</span> <span>string</span> <span>{</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span>return</span> fmt<span>.</span>Sprintf<span>(</span><span>&#34;%q returned code %d: %q&#34;</span><span>,</span> e<span>.</span>prog<span>,</span> e<span>.</span>code<span>,</span> e<span>.</span>reason<span>)</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>In Go, the idiomatic thing to do is to hide
            <code>progError</code> behind the return value
            <code>error</code>. In that case, the information we have in
            the struct is left behind. The user now has an interface
            value <code>error</code> that the only thing they can do is
            access the string representation of. How is this error
            useful to the people writing the program? Sure, they can
            print it out, but wouldn’t the programmer want to do
            different things depending on what type of error is
            returned? The only resort the consumer of this library has
            is to parse the string value of this error for useful
            information. This is a <em>terrible</em> strategy because
            nothing is stopping the library authors from changing the
            string representation, something which is totally at their
            discretion in my opinion.</p>
            <p>The worst part is that this is not even a hypothetical.
            It in fact happened to me when writing code that used
            <code>os.Stat</code> to get file information<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p>
            <div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>func</span> rootInfo<span>(</span>root<span>,</span> path <span>string</span><span>)</span> <span>(</span>has <span>bool</span><span>,</span> isDir <span>bool</span><span>,</span> err <span>error</span><span>)</span> <span>{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    path <span>=</span> pathpkg<span>.</span>Clean<span>(</span>path<span>)</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    info<span>,</span> err <span>:=</span> os<span>.</span>Stat<span>(</span>root <span>+</span> <span>&#34;/&#34;</span> <span>+</span> path<span>)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span>if</span> errors<span>.</span>Is<span>(</span>err<span>,</span> os<span>.</span>ErrNotExist<span>)</span> <span>{</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>nil</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span>if</span> err <span>!=</span> <span>nil</span> <span>&amp;&amp;</span> strings<span>.</span>HasSuffix<span>(</span>err<span>.</span>Error<span>(),</span> <span>&#34;not a directory&#34;</span><span>)</span> <span>{</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span>//                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span>//                   Manually checking if the error is a certain type of error</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>nil</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>false</span><span>,</span> <span>false</span><span>,</span> err</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>true</span><span>,</span> info<span>.</span>IsDir<span>(),</span> <span>nil</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
            <p>It’s true that this code sucks and that there was
            probably a better alternative. It’s probably even true that
            the “not a directory” message is almost 100% not going to
            change in the future. However, it’s still a problem and a
            problem that stems from one thing:</p>
            <p><strong>In Go, errors are values. They just aren’t
            particularly <em>useful</em> values.</strong></p>
            <p>Contrast this to how Rust handles errors.</p>
            <p>In Rust, errors are also values but they are
            <em>useful</em> values. If I do an I/O operation in Rust, I
            am likely to get a <code>std::io::Result&lt;T&gt;</code>,
            which is just a
            <code>Result&lt;T, std::io::Error&gt;</code>. This
            <code>std::io::Error</code>’s type can be easily accessed
            with the <code>kind()</code> method of
            <code>std::io::error</code> which lets you easily understand
            what kind of error you are dealing with.</p>
            <p>Why does Rust have more useful errors than Go?</p>
            <ul>
            <li>Rust has enums and sum types</li>
            <li>Rust doesn’t have the pervasive idiom of hiding your
            error behind an interface that reveals little about the
            error</li>
            </ul>
            
            
            <hr/>
            
            
            
            
            
            
        </main>
    </div></div>
  </body>
</html>
