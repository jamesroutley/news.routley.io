<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nolanlawson.com/2024/09/28/web-components-are-okay/">Original</a>
    <h1>Web Components Are Okay</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>Every so often, the web development community gets into a tizzy about something, usually web components. I find these fights tiresome, but I also see them as a good opportunity to reach across <a href="https://css-tricks.com/the-great-divide/">“the great divide”</a> and try to find common ground rather than another opportunity to dunk on each other.</p>
<p>Ryan Carniato started the latest round with <a href="https://dev.to/ryansolid/web-components-are-not-the-future-48bh">“Web Components Are Not the Future”</a>. Cory LaViska followed up with <a href="https://www.abeautifulsite.net/posts/web-components-are-not-the-future-they-re-the-present/">“Web Components Are Not the Future — They’re the Present”</a>. I’m not here to escalate, though – this is a peace mission.</p>
<p>I’ve been an avid follower of Ryan Carniato’s work for years. <a href="https://nolanlawson.com/2023/12/02/lets-learn-how-modern-javascript-frameworks-work-by-building-one/">This post</a> and the steady climb of <a href="https://lwc.dev">LWC</a> on the <a href="https://github.com/krausest/js-framework-benchmark"><code>js-framework-benchmark</code></a> demonstrate that I’ve been paying attention to what he has to say, especially about performance and framework design. The guy has single-handedly done more to move the web framework ecosystem forward in the past 5 years than anyone else I can think of.</p>
<p>That said, I also heavily work with web components, both on the framework side and as a <a href="https://github.com/nolanlawson/emoji-picker-element/">component author</a>. I’ve participated in the <a href="https://www.w3.org/community/webcomponents/">Web Components Community Group</a> and <a href="https://github.com/WICG/aom/">Accessibility Object Model group</a>, and I’ve written extensively on shadow DOM, custom elements, and web component accessibility in this blog.</p>
<p>So <em>obviously</em> I’m going to be interested when I see a post from Ryan Carniato on web components. And it’s a thought-provoking post! But I also think he misses the mark on a few things. So let’s dive in:</p>
<h2>Performance</h2>
<blockquote><p>
  [T]he fundamental problem with Web Components is that they are built on Custom Elements.</p>
<p>  […] [E]very interface needs to go through the DOM. And of course this has a performance overhead.
</p></blockquote>
<p>This is completely true. If your goal is to build the absolute fastest framework you can, then you want to minimize DOM nodes wherever possible. This means that web components are off the table.</p>
<p>I fully believe that Ryan knows how to build the fastest possible framework. Again, the <a href="https://krausest.github.io/js-framework-benchmark/">results</a> for Solid on the <code>js-framework-benchmark</code> are a testament to this.</p>
<p>That said – and I might alienate some of my friends in the web performance community by saying this – performance isn’t everything. There are other tradeoffs in software development, such as maintainability, security, usability, and accessibility. Sometimes these things come into conflict.</p>
<p>To make a silly example: I could make DOM rendering slightly faster by never rendering any <code>aria-*</code> attributes. But of course sometimes you <em>have</em> to render <code>aria-*</code> attributes to make your interface accessible, and nobody would argue that a couple milliseconds are worth excluding screen reader users.</p>
<p>To make an even sillier example: you can improve performance by using <code>for</code> loops instead of <code>.forEach()</code>. Or using <a href="https://www.reddit.com/r/sveltejs/comments/1fklm73/curious_about_the_use_of_var_in_the_svelte_5/"><code>var</code> instead of <code>const</code>/<code>let</code></a>. Typically, though, these kinds of micro-optimizations are just not worth it.</p>
<p>When I see this kind of stuff, I’m reminded of <a href="https://www.youtube.com/watch?v=7rIJNT7dCmE">speedrunners trying to shave milliseconds</a> off a 5-minute run of Super Mario Bros using precise inputs and obscure glitches. If that’s your goal, then by all means: <a href="https://ukikipedia.net/wiki/Backwards_Long_Jump">backwards long jump</a> across the entire stage instead of just having Mario run forward. I’ll continue to be impressed by what you’re doing, but it’s just not for me.</p>
<p>Minimizing the use of DOM nodes is a classic optimization – this is the main idea behind <a href="https://web.dev/articles/virtualize-long-lists-react-window">virtualization</a>. That said, sometimes you can get away with <a href="https://nolanlawson.com/2024/09/18/improving-rendering-performance-with-css-content-visibility/">simpler approaches</a>, even if it’s not the absolute fastest option. I’d put “components as elements” in the same bucket – yes it’s sub-optimal, but optimal is not always the goal.</p>
<p>Similarly, I’ve long argued that <a href="https://nolanlawson.com/2021/08/01/why-its-okay-for-web-components-to-use-frameworks/">it’s fine for custom elements to use different frameworks</a>. Sometimes you just need to gradually migrate from Framework A to Framework B. Or you have to compose some micro-frontends together. Nobody would argue that this is the fastest possible interface, but fine – sometimes tradeoffs have to be made.</p>
<p>Having worked for a long time in the web performance space, I find that the lowest-hanging fruit for performance is usually something dumb like <a href="https://web.dev/articles/avoid-large-complex-layouts-and-layout-thrashing">layout thrashing</a>, network waterfalls, unnecessary re-renders, etc. Framework authors like myself love to play <a href="https://en.wikipedia.org/wiki/Code_golf">performance golf</a> with things like the <code>js-framework-benchmark</code>, and it’s a great flex, but it just doesn’t usually matter in the real world.</p>
<p>That said, if it does matter to you – if you’re building for resource-constrained environments where every millisecond counts: great! Ditch web components! I will geek out and cheer for every speedrunning record you break.</p>
<h2>The cost of standards</h2>
<blockquote><p>
  More code to ship and more code to execute to check these edge cases. It’s a hidden tax that impacts everyone.
</p></blockquote>
<p>Here’s where I completely get off the train from Ryan’s argument. As a framework author, I just don’t find that it’s that much effort to support web components. Detecting props versus attributes is a simple <code>prop in element</code> check. <em>Outputting</em> web components is indeed painful, but hey – nobody said you have to do it. Vue 2 got by with a standalone <a href="https://github.com/vuejs/vue-web-component-wrapper">web component wrapper library</a>, and <a href="https://github.com/rstacruz/remount">Remount</a> exists without any input from the React team.</p>
<p>As a framework author, if you want to freeze your thinking in 2011 and code as if nothing new was added to the web platform since then, you absolutely can! And you can still write a great framework! This is the beauty of the web. jQuery v1 is still chugging away on plenty of websites, and in fact it gets faster and faster with every new browser release, since browser perf teams are often targeting whatever patterns web developers used ~5 year ago in an endless <a href="https://learn.microsoft.com/en-us/shows/webplatformsummit-microsoft-edge-web-summit-2017/es15">cat-and-mouse game</a>.</p>
<p>But assuming you don’t want to freeze your brain in amber, then yes: you do need to account for new stuff added to the web platform. But this is also true of things like <code>Symbol</code>s, <code>Proxy</code>s, Promises, etc. I just see it as part of the job, and I’m not particularly bothered, since I know that whatever I write will still work in 10 years, thanks to the web’s backwards compatibility guarantees.</p>
<p>Furthermore, I get the impression that a wide swath of the web development community does not care about web components, does not want to support them, and you probably couldn’t convince them to. And that’s okay! The web is a big tent, and you can build entire UIs based on web components, or with a sprinkling of <a href="https://adactio.com/journal/20618">HTML web components</a>, or with none at all. If you want to declare your framework a “no web components” zone, then you can do that and still get plenty of avid fans.</p>
<p>That said, Ryan is right that, by blessing something as “the standard,” it inherently becomes a mental default that needs to be grappled with. Component authors must decide whether <a href="https://dev.to/richharris/why-i-don-t-use-web-components-2cia">their <code>&lt;slot&gt;</code>s should work like native <code>&lt;slot&gt;</code>s</a>. That’s true, but again, you could say this about a lot of new browser APIs. You have to decide whether <code>IntersectionObserver</code> or <code>&lt;img loading=&#34;lazy&#34;&gt;</code> is worth it, or whether you’d rather write your own abstraction. That’s fine! At least we have a common point of reference, a shared vocabulary to compare and contrast things.</p>
<p>And just because something is a web standard doesn’t mean you have to use it. For the longest time, <a href="https://www.reddit.com/r/ProgrammerHumor/comments/621qrt/javascript_the_good_parts/">the classic joke</a> about <em>JavaScript: The Good Parts</em> was how small it is compared to <em>JavaScript: The Definitive Guide</em>. The web is littered with deprecated (but still supported) APIs like <code>document.domain</code>, <code>with</code>, and <code>&lt;frame&gt;</code>s. Take it or leave it!</p>
<h2>Conclusion</h2>
<blockquote><p>
  [I]n a sense there are nothing wrong with Web Components as they are only able to be what they are. It’s the promise that they are something that they aren’t which is so dangerous.
</p></blockquote>
<p>Here I totally agree with Ryan. As <a href="https://nolanlawson.com/2023/08/23/use-web-components-for-what-theyre-good-at/">I’ve said before</a>, web components are bad at a lot of things – Server-Side Rendering, accessibility, even interop in some cases. They’re good at plenty of things, but replacing all JavaScript frameworks is not one of them. Maybe we can check back in 10 years, but for now, there are still cases where React, Solid, Svelte, and friends shine and web components flounder.</p>
<p>Ryan is making an eminently reasonable point here, as is the rest of the post, and on its own it’s a good contribution to the discourse. The title is a bit inflammatory, which leads people to wield it as a bludgeon against their perceived enemies on social media (likely without reading the piece), but <a href="https://nolanlawson.com/2022/02/02/five-years-of-quitting-twitter/">this is something I blame on social media</a>, not on Ryan.</p>
<p>Again, I find these debates a bit tiresome. I think the fundamental issue, as <a href="https://nolanlawson.com/2023/12/30/shadow-dom-and-the-problem-of-encapsulation/">I’ve previously said</a>, is that people are talking past each other because they’re building different things with different constraints. It’s as if a salsa dancer criticized ballet for not being enough like salsa. There is more than one way to dance!</p>
<p>From my own personal experience: at Salesforce, we build a client-rendered app, with its own <a href="https://appexchange.salesforce.com/">marketplace of components</a>, with <a href="https://developer.salesforce.com/blogs/2024/01/introducing-component-level-api-versioning-for-lwc">strict backwards-compatibility guarantees</a>, where the intended support is measured in years if not decades. Is this you? If not, then maybe you shouldn’t build your entire UI out of web components, with shadow DOM and the whole kit-n-kaboodle. (Or maybe you should! I can’t say!)</p>
<p>What I find exciting about the web is the sheer number of people doing so many wild and bizarre things with it. It has everything from games to art projects to enterprise SaaS apps, built with WebGL and Wasm and Service Workers and all sorts of zany things. Every new capability added to the web platform isn’t a limitation on your creativity – it’s an opportunity to express your creativity in ways that nobody imagined before.</p>
<p>Web components may not be the future for you – that’s great! I’m excited to see what you build, and I might steal some ideas for my own corner of the web.</p>
							</div></div>
  </body>
</html>
