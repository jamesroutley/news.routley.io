<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://typicalprogrammer.com/why-dont-software-development-methodologies-work">Original</a>
    <h1>Why don‚Äôt software development methodologies work? (2014)</h1>
    
    <div id="readability-page-1" class="page"><div>
			<header>
				
				
				</header>

			<section>
				


<p>10 Feb 2014</p>

<div>
  <blockquote>
  <p>This article got some great commments. Scroll down to read those.</p>
</blockquote>

<p>I‚Äôve worked on big projects, small projects, in huge teams and by myself, in fossilized federal agencies and cool Silicon Valley companies. I have learned and used at least twenty programming languages. I‚Äôve lived through waterfall/BDUF (big design up front), structured programming, top-down, bottom-up, modular design, components, agile, Scrum, extreme, TDD, OOP, rapid prototyping, RAD, and probably others I‚Äôve forgotten about. I‚Äôm not convinced any of these things work.</p>

<blockquote>
  <p>[Edit: Let me explain what I mean by writing methodologies ‚Äúdon‚Äôt work.‚Äù I mean they don‚Äôt deliver a predictable or repeatable software development process in and of themselves. I don‚Äôt mean that using a methodology dooms the project. Most software development methodologies try to make programming a more engineering-like process, and in that regard they fall short.]</p>
</blockquote>

<h3 id="how-can-you-tell-if-a-methodology-works">How can you tell if a methodology works?</h3>
<p>Whether a methodology works or not depends on the criteria: team productivity, happiness, retention, conformity, predictability, accountability, communication, lines per day, man-months, code quality, artifacts produced, etc. Every methodology works if you measure the right thing. But in terms of the only measurement that really matters‚Äîsatisfying requirements on time and within budget‚ÄîI haven‚Äôt seen any methodology deliver consistent results.</p>

<p>My own experiences are anecdotal, but they are shared by almost every programmer I know. It turns out that anecdotes are all that anyone has: rigorous studies of software development methodologies haven‚Äôt been done because it‚Äôs impossible to control for all of the variables.</p>

<p>Try this thought experiment: Imagine two teams of programmers, working with identical requirements, schedules, and budgets, in the same environment, with the same language and development tools. One team uses waterfall/BDUF, the other uses agile techniques. It‚Äôs obvious this isn‚Äôt a good experiment: The individual skills and personalities of the team members, and how they communicate with each other, will have a much bigger effect than the methodology.</p>

<p>In his 2003 thesis <a href="http://alistair.cockburn.us/People+and+methodologies+in+software+development">People and methodologies in software development</a> Alistair Cockburn concludes ‚ÄúPeople‚Äôs characteristics, which vary from person to person and even from moment to moment, form a first-order driver of the team‚Äôs behavior and results. Such issues as how well they get along with each other and the fit (or misfit) of their personal characteristics with their job roles create significant, project-specific constraints on the methodology. This result indicates that people‚Äôs personal characteristics place a limit on the effect of methodologies in general.‚Äù</p>

<h3 id="our-own-worst-enemy">Our own worst enemy</h3>
<p>When I started programming in the 1970s software development was tightly controlled by management through a hierarchy of project managers, business analysts, and senior programmers. We did not get to pick the language or tools. I worked on some big, complex projects in companies that worked this way. Some succeeded, some didn‚Äôt. Now it‚Äôs common for the programmers to choose the methodology and style of working, along with their languages and tools. Analysts are not part of most programmer‚Äôs experience anymore, and project managers have been reduced to ‚Äúteam leads‚Äù and ‚ÄúScrum masters,‚Äù neutered of any managerial authority and not really in control of anything other than rituals dictated by team consensus.</p>

<p>Strict management, in love with Gantt charts and schedules and documentation, was reduced to ‚Äústakeholders‚Äù and ‚Äúusers,‚Äù and then abstracted away into ‚Äúuser stories.‚Äù It‚Äôs common now for me to get involved in a project that seems to have no adult supervision. Surprisingly, left to themselves programmers don‚Äôt revert to cowboy coding‚Äîthey adopt or create methodologies stricter and more filled with ritual than anything I experienced in 1980. In fact programmers today can be much more rigid and religious about their methodologies than they imagine a 1970s-era COBOL shop was. I now routinely get involved with projects developed by one or two people burdened with so much process and ‚Äúbest practices‚Äù that almost nothing of real value is produced.</p>

<p>Once a programming team has adopted a methodology it‚Äôs almost inevitable that a few members of the team, or maybe just one bully, will demand strict adherence and turn it into a religion. The resulting passive-aggression kills productivity faster than any methodology or technology decision.</p>

<h3 id="does-anything-work">Does anything work?</h3>
<p>My own experience, validated by Cockburn‚Äôs thesis and Frederick Brooks in <a href="http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html">No Silver Bullet</a>, is that software development projects succeed when the key people on the team share a common vision, what Brooks calls ‚Äúconceptual integrity.‚Äù This doesn‚Äôt arise from any particular methodology, and can happen in the absence of anything resembling a process. I know the feeling working on a team where everyone clicks and things just get done. What I don‚Äôt understand is why I had that feeling a lot more in the bad old days of BDUF and business analysts than I do now.</p>

<p>I think programmers should pay much more attention to listening to and working with their peers than to rituals and tools, and that we should be skeptical of too much process or methodologies that promise to magically make everyone more productive. Maybe social skills come harder to programmers than to other people (I‚Äôm not convinced that‚Äôs true), but developing those skills will certainly pay off a lot more than trying yet another development methodology.</p>

<blockquote>
  <p>[Giles Bowkett published an excellent take-down of Scrum that ties in with this article. He covers the shortcomings of Scrum and how ‚Äúagile‚Äù is practiced in real life in more (and funnier) detail than I got into here: <a href="http://gilesbowkett.blogspot.com/2014/09/why-scrum-should-basically-just-die-in.html">Why Scrum Should Basically Just Die In A Fire</a></p>
</blockquote>



<h4 id="keith-on-10-february-2014-at-745-am">Keith on 10 February 2014 at 7:45 am</h4>
<p>Amen Brother.</p>

<h4 id="gordon-morehouse-on-10-february-2014-at-749-am">Gordon Morehouse on 10 February 2014 at 7:49 am</h4>
<p>Heck, I‚Äôm green enough that I went straight from cowboy coding to something resembling Agile and then achieved my ‚Äògrizzled veteran‚Äô stage of programmer incompetence (search that, it‚Äôs funny) with Agile. The only time I‚Äôve seen it ‚Äúwork‚Äù in any real sense is on projects undertaken with programmers who are also my friends. Otherwise ‚Äì at best ‚Äì it can wring a little more customer-focused work out of a dysfunctional team. I don‚Äôt know if this was true in BDUF days, but it‚Äôs my sense that in Agile, team dysfunction is usually lack of a product manager and/or terrible executive management before personal conflicts get a nod.</p>

<h4 id="paul-w-homer-on-10-february-2014-at-803-am">Paul W Homer on 10 February 2014 at 8:03 am</h4>
<p>My experience is similar, what is often behind a high-functioning team is talented people who communicate well about a shared vision. The methodology helps, but if the other characteristics are missing than things won‚Äôt function. I have found that an overall culture of engineering at the organizational level is necessary for the initial creation of teams. The same group of developers working in a bad environment just won‚Äôt gel.</p>

<p>I do worry that the overall gamification of software development has shifted the focus away from producing quality results and onto less critical goals. What counts in the end is the quality of the system and whether or not it actually makes the user‚Äôs lives easier or better. Everything else is secondary.</p>

<h4 id="fred-zisk-on-10-february-2014-at-824-am">Fred Zisk on 10 February 2014 at 8:24 am</h4>
<p>The only method that seems to work is Waterfall. You have to know what you need to produce, design it thoroughly, and know the technology and solutions you are presenting. If there are any ‚Äòunknowns‚Äô things go awry. Only very experienced devs (10+ years) can spot hidden unknowns that deep six a lot of projects.</p>

<h4 id="bjorn-louser-on-10-february-2014-at-836-am">Bjorn Louser on 10 February 2014 at 8:36 am</h4>
<p>‚ÄúSurprisingly, left to themselves programmers don‚Äôt revert to cowboy coding‚Äîthey adopt or create methodologies stricter and more filled with ritual than anything I experienced in 1980.‚Äù</p>

<p>Programmers today artificially inflate the complexity of their work under the guise of ‚Äòbest practices‚Äô in the hope that it will create job security and lead others to perceive them as experts in the field.</p>

<p>It‚Äôs just the delusional thinking of generalists whose contributions to the product are as well regarded within the company as the efforts of the office custodial staff.</p>

<p>The lack of fear for the evil that lurks beneath the fingers of a subpar programmer leaves this neutered ‚Äòprofession‚Äô with no recourse but to build monuments to itself through a religion of methodology.</p>

<h4 id="daniel-meyer-on-6-september-2015-at-1137-am">Daniel Meyer on 6 September 2015 at 11:37 am</h4>
<p>Your statement was so accurate I had to send you this response. I have been programming and in development for 35 years. From COBOL to .NET. I have worked for major technology corporations. Our current batch of programmers are ‚Äúpretenders‚Äù, that do not respect or care about development, they are more concerned with CTOA‚Äôs so they can make money. It got so bad that I went independent, and I am now working on my own. I absolutely love the freedom of being able to create my own programs faster and more efficiently than any of the past development teams I have been on in the past five years. So to all the ‚Äúpretenders‚Äù out there. Thank you üôÇ</p>

<h4 id="chuck-norris-on-10-february-2014-at-940-am">Chuck Norris on 10 February 2014 at 9:40 am</h4>
<p>I agree that a common vision is needed. It‚Äôs also interesting that MVVG (mission, vision, values, and goals) are some of the first things that B-schools teach.</p>

<h4 id="jon-on-10-february-2014-at-944-am">Jon on 10 February 2014 at 9:44 am</h4>
<p>I like your article, and I get it. In my personal experiences, I have found that scrum is successful when it is used to reinforce a single coherent vision and to build a tight integrated team.</p>

<p>It does not work when it‚Äôs used as a magic machine of happy fun time productivity‚Ä¶. Sprints and stories don‚Äôt translate into more productivity. Focus and teamwork do.</p>

<h4 id="ashish-jain-on-10-february-2014-at-950-am">Ashish Jain on 10 February 2014 at 9:50 am</h4>
<p>I am the one, who is big fan of agility and least fan of any methodologies. Recent pattern I have observed (and currently facing), stakeholders wants to use newer methodologies to hide basic problems with projects, like not enough competent team, not enough clear goals for quarter or year. They think, using agile practices, things will fall into place automatic. That‚Äôs what everyone says.</p>

<p>In end, developers are spending 50% of their time in managing tasks, not really doing it. And little time they get, they just finish it off.</p>

<h4 id="tom-moxon-on-10-february-2014-at-952-am">Tom Moxon on 10 February 2014 at 9:52 am</h4>
<p>Nice Article Greg, I couldn‚Äôt agree more.
However, I would also add that ‚Äúthe Vision thing‚Äù
matters the most ‚Äì someone who can visualize all the
pieces, protocol, cogs, and gears working together.
IMHO, without that ‚Äì all big projects fail‚Ä¶</p>

<h4 id="calvin-on-10-february-2014-at-954-am">calvin on 10 February 2014 at 9:54 am</h4>
<p>The only ‚Äúmethodology‚Äù I‚Äôve read that I have seen consistently work in action is the one described in the mythical man month. (the author used a surgical team as the model) A single technical lead with full authority to make decisions, with a next tier assistant, associated technical staff, and a non-technical support person. the achievement of the team is then determined by the leadership of the team. the size of the team and project complexity is then limited by the leader and her ability to understand the problem and assign tasks. it prevents death by committee, it creates ownership, the size of the team is optimized. methodologies go into that, but only that they serve a purpose for the team and the production.</p>

<p>mark andreeson, steve jobs, elon musk. are famous examples of this model. And while I don‚Äôt know if it‚Äôs in MMM, the leader should arise, and not be appointed by management. The team knows who should be leader, there should be no conflict of title and ability. nothing dooms a project quicker than a leader who cannot lead a technical team. it‚Äôs about the act of an ability to take charge vs being put in charge.</p>

<h5 id="noname-on-10-february-2014-at-1009-am">noname on 10 February 2014 at 10:09 am</h5>
<p>collaborative work sucks, esp in a git environment</p>

<h4 id="chuck-on-10-february-2014-at-1038-am">Chuck on 10 February 2014 at 10:38 am</h4>
<p>The issue with methodologies seems to lie with the misconception that it‚Äôs a cookbook that doesn‚Äôt require any thinking, deep or otherwise. Too often I‚Äôve heard people say ‚Äújust follow the methodology and it will just work‚Äù without understanding that methodologies are just frameworks that need to be tailored to the problem at hand. If the cookbook approach worked and required no additional thinking then we wouldn‚Äôt need people to build things because it could simply be automated. Having said that, there are a large number of things that likely should be automated so that people can focus on solving problems, not inventing new boilerplate methodologies.</p>

<h4 id="topher-on-10-february-2014-at-1107-am">topher on 10 February 2014 at 11:07 am</h4>
<p>I always think of the following quote when someone is advocating that a tool/process/methodology will solve all the problems: ‚ÄúLife is pain, Highness! Anyone who says differently is selling something.‚Äù</p>

<p>Brooks was right, there is no silver bullet.</p>

<p>What I‚Äôve seen work:</p>

<ol>
  <li>Get the smallest number of the smartest people possible together.</li>
  <li>Give them a clear goal.</li>
  <li>Get out of the way.</li>
</ol>

<h4 id="gates-vp-on-10-february-2014-at-1110-am">Gates VP on 10 February 2014 at 11:10 am</h4>
<p>The reason for all of this conflict in ‚Äúwhat works‚Äù with Software Development Methodologies is simply that there is no one ‚Äúsoftware‚Äù. The methodology for creating the software depends necessarily on the the purpose of the software and the needs of the people using the software.</p>

<p>Facebook‚Äôs Zuckerberg famously touts ‚ÄúMove Fast and Break Things‚Äù. That‚Äôs a reasonable idea in web apps that are continuously deployed 10 times / day. It‚Äôs completely useless while building Mars lander software or the banking software that makes sure you get your paycheck. Clearly a bad idea if you‚Äôre building the next Therac machine, right?</p>

<p>But lots of software lives in between. Could healthcare.gov have succeeded with ‚ÄúMove Fast &amp; Break Things‚Äù? Well ostensibly that‚Äôs exactly what they did and in a year or so it will probably be functional, if only by virtue of trading off massive user headaches.</p>

<p>And as much as some groups would like to tout things like TDD, I‚Äôve never met a database that ships with its own mocks, meaning that systems will fail regardless of their ability to pass unit tests. That stated, some form of automated testing has proven to be an improvement in basically every environment I‚Äôve seen it used. But it has a real cost trade-off.</p>

<p>At the end of the day, the tooling and methodologies you use are tightly coupled to the product you‚Äôre developing. In many cases, managers and academics are still trying to quantify the trade-offs being made.</p>

<p>And all of the this is regardless of the team involved. Clearly, good vision and the right caliber of team will help smooth over the methodology problems. But methodology is about enabling ‚Äúeveryone‚Äù to succeed, not just the all-stars.</p>

<h4 id="ayan-on-10-february-2014-at-1124-am">Ayan on 10 February 2014 at 11:24 am</h4>
<p>I‚Äôve struggled with the idea of finding the most efficient usage of time. Even after reading the comments and this article, I‚Äôm still disheartened from looking for the ‚Äúperfect model‚Äù. Maybe that‚Äôs just how other perfect things work: they don‚Äôt exist.</p>

<p>However, and in in the tiniest part, your point on developing social skills might be just that: the ‚Äòperfect‚Äô plan. Of course it‚Äôs not perfect because us, the people are not, but it‚Äôs personalized and adaptive. Listening, analyzing, and measuring how your team works best, while being knowledgeable about all these ways of working sounds like a great plan. What we need to measure, how alert we need to be to our teams, and how we can grow and learn fast, while having the experience to avoid the pitfalls, is paramount in this methodology.</p>

<p>Anyways, thanks for the read and for sharing your experience.</p>

<h4 id="hein-b-on-10-february-2014-at-1201-pm">Hein B on 10 February 2014 at 12:01 pm</h4>
<p>Biggest problem is a bunch of introverts not communicating.</p>

<h4 id="clark-on-10-february-2014-at-412-pm">Clark on 10 February 2014 at 4:12 pm</h4>
<p>We‚Äôve discussed this a lot lately where I work, so I have a long stream of thoughts on the issue. I can relate to poor team communication, having worked with developers who either do not communicate enough and put the team out of sync, and also those developers who turn certain practices into a religion and demand strict adherence.</p>

<p>I would agree that a methodology that consistently satisfies requirements on time and within budget is one that ‚Äúworks,‚Äù but only for projects in which requirements never change, architectural decisions never need to be revisited, and time/budget requirements are immediately obvious at the beginning of the project‚Äôs lifespan (this sort of project would be a <em>great</em> fit for waterfall/BDUF).</p>

<p>Requirements change frequently, of course. How much effort should you spend nailing down a specific, achievable deadline at a stage in the project when you know the least about what the end product will look like? Would a 4 week delay be a deal-breaker? How about 8-12 weeks? Are the customer‚Äôs margins so narrow that any development methodology failing to meet or beat a somewhat arbitrary deadline is not ‚Äúworking‚Äù?</p>

<p>Improving developers‚Äô listening and interpersonal skills might do more for productivity and success than finding the right methodology, for many teams. This absolutely doesn‚Äôt mean finding and following a good methodology is not important.</p>

<p>You would also be right to say that a driver‚Äôs skill and attention to the road and other vehicles does far more to get the vehicle safely to its destination in a timely manner than his choice of which route to take, or the presence of signals and signs that require adherence to certain traffic laws. Many freeways have too much traffic. Sometimes alarming amounts of your drive time is spent waiting at traffic lights at intersections. Does this diminish the importance of building roads, placing traffic signals, and requiring every driver on the road to follow a common set of rules and procedures while driving? At most, it seems to me these inefficiencies call for a new round of evaluation and improvement, so they become things that facilitate your safe journey to a desired destination, rather than a hindrance.</p>

<p>I‚Äôm not forgetting the possibility that a skilled HR department can put together a dream team of developers that bring with them a depth of technical skill and near precog-level interpersonal skills, allowing effective collaboration to begin on day one of each project. They are obviously hard to find and recruit, and this requires specific language when posting job openings (‚Äùrockstar‚Äù, ‚Äú10x‚Äù, ‚Äúsuperstar‚Äù, ‚Äúninja‚Äù). Barring such a team, it‚Äôs probably safe to assume we‚Äôll continue working on teams with developers of mixed ability and communication skills.</p>

<p>I believe that scrum/agile methodologies can be extremely effective when implemented in a way that makes sense for the team/company. We don‚Äôt need to be overburdened with processes and SOP‚Äôs. Ceremony for the sake of ceremony shouldn‚Äôt be an unavoidable consequence of our process, and the use of an underlying process doesn‚Äôt preclude effective communication.</p>

<h4 id="jakob-martienz-on-10-february-2014-at-522-pm">Jakob Martienz on 10 February 2014 at 5:22 pm</h4>
<p>Glad people like you are wrting about this.</p>

<p>So True:</p>

<p>‚ÄúOnce a programming team has adopted a methodology it‚Äôs almost inevitable that a few members of the team, or maybe just one bully, will demand strict adherence and turn it into a religion. The resulting passive-aggression kills productivity faster than any methodology or technology decision.‚Äù</p>

<h4 id="ricki-on-10-february-2014-at-631-pm">Ricki on 10 February 2014 at 6:31 pm</h4>
<p>Great article! After 10+ years of coding let me share the one programming methodology that has worked somehow consistently, at least for me, my style and the skills of the help I hire. I call it ‚Äúthe funnel‚Äù. These are the assumptions:</p>

<ol>
  <li>Specs will change: guesstimate, lie about the due date and charge double.</li>
  <li>Mostly we work on business-type software, process automations, so what we normally develop is a CRUD with some custom logic on update events (oversimplification, I know). Hence: deliver a prototype super fast (even with incomplete/unknown data models) and let the user ‚Äúdiscover‚Äù the missing pieces of the specs while using the prototype.</li>
  <li>Repeat cycle 1-2, funnel the client into the desired solution.</li>
  <li>When analyzing the initial specs, I identify the ‚Äúchallenges‚Äù, the real programming, the things we cannot count on a framework/plugin to solve, the stuff we have not done before. I put someone to work on just that task and plug it into the final product when ready. Recent real example: client wants a mobile app that scans docs/reads OCR/persists on user account. Everything aside from the ‚Äúread OCR‚Äù is pretty much a copy/paste client/API CRUD, we can do that in a few days. However, the challenge we work with one programmer, best ninja for the job, outsource if necessary, and when ready plug it in.</li>
</ol>

<p>Why I think this works?</p>

<p>1,2 and 3 are repetitive tasks, these can be treated as engineered software development, a factory of code, measurable, predictable.</p>

<p>4 is creative work. The ‚Äúart of programming‚Äù. It cannot be put under ‚Äúproject management‚Äù. If lucky it comes out in a few days, normally a few weeks or even months. Programmers are not robots (sorry managers this is true!)</p>

<p>Finally challenges can also be non-programming tasks: ever had to deal with 20+ rounds of UI graphic design approval? What about designing the right scalable infrastructure? Security? These challenges while not programming are nevertheless crucial for project success. They require a different methodology depending on each case.</p>

<h4 id="aahz-on-10-february-2014-at-908-pm">Aahz on 10 February 2014 at 9:08 pm</h4>
<p>I agree with you strategically but disagree tactically. That is, over-arching methodologies fail, but there are things we as a discipline have learned over the years that can be applied in almost every environment. Just a couple of examples:</p>

<ul>
  <li>Use source control. Preferably with a culture that encourages/forces decent commit comments.</li>
  <li>Have some kind of automated testing ‚Äî you can‚Äôt refactor easily (or sometimes at all) without it.</li>
</ul>

<h4 id="scaringella-on-10-february-2014-at-1117-pm">scaringella on 10 February 2014 at 11:17 pm</h4>
<p>Same problems in France ‚Ä¶.. Programmers come from the
engineering/scientific field most of the time. That‚Äôs the problem.</p>

<h4 id="lonny-eachus-on-10-february-2014-at-1139-pm">Lonny Eachus on 10 February 2014 at 11:39 pm</h4>
<p>In my experience, some of them (waterfall for example) don‚Äôt work simply because they‚Äôre dysfunctional as designed.</p>

<p>Others don‚Äôt work because very few actually do them right. For example I worked in one ‚ÄúAgile‚Äù shop that was great. People were good, it got the job done, and people actually did it as they were supposed to.</p>

<p>I worked in another shop that called itself ‚ÄúAgile‚Äù but in reality was anything but. They just used the informal trappings of agile as an excuse to really have a policy of ‚ÄúWe will throw any features we want at you at any time. And, oh‚Ä¶ no, you don‚Äôt get any time to do any of that useless refactoring stuff.‚Äù It was even worse than just regular top-down.</p>

<p>Guess which of those two I liked working for?</p>

<h4 id="micky-kurniawan-on-10-february-2014-at-1158-pm">Micky Kurniawan on 10 February 2014 at 11:58 pm</h4>
<p>Nice share üôÇ</p>

<h4 id="magnus-gustin-on-11-february-2014-at-113-am">Magnus Gustin on 11 February 2014 at 1:13 am</h4>
<p>Great post!
I have a similar background and experiences. I like to compare to the world of team sports (say soccer, since I am european). An offence and defence strategy will of course help, but it all comes down to having the right players and a good coach who will stand up for the team. You want to have the right mix of people ‚Äì workers who don‚Äôt ask too many questions, and the creative guys that will find the unexpected ways.</p>

<h4 id="markg-on-11-february-2014-at-121-am">markG on 11 February 2014 at 1:21 am</h4>
<p>I‚Äôve worked in software development for close to 40 years now, started as a programmer, and been a CIO/Head of IT three times, including at corporates and start-ups. I‚Äôve worked in and with some high quality engineering teams and used, introduced, varied, applied several different methodologies.</p>

<p>I would not say that software methodologies do not work, they can and do, what I do think is that it is simply not realistic to expect that a single method will be able to fit all known problem domains.</p>

<p>Software development is not an empirical science. You cannot explicitly define or quantify many of the tasks, unlike, say, a production line, or in construction where there are well proven industry formulae for certain tasks. So from the outset one must accept that no single methodology is likely to prove a panacea.</p>

<p>Organisations ideally should have a range of tools and methods to suit the business problems that they are likely to face, and select the most appropriate method during the preparation and evaluation phase, and the resources to be assigned to the project should have the maturity and flexibility to be adapatable. Any good developer worth their salt will choose the right tool for the job at hand. Similarly, in my view, any good delivery organisation should select the right mix of methods for the problem to be solved and the project manager and developers work to that method. In most organisations there is not likely to be significant variation in methods in any given year, but over time methods change, they have to. 20 years ago I was developing client-server applications in the oil industry, the same methods and techniques used their have morphed and changed over the years.</p>

<p>Having an adaptable approach is an ideal; it is very hard to make such a thing reality in the large corporates, mainly because their quality and compliance departments have choke holds on methods and processes, guarded by those whose annual bonus depends on adherence to process. Smaller companies often have the flex, but not the experience to make such an approach work. At two of the IT departments I set up, we agreed (myself, the architects and the developers) to use an appropriate mix of waterfall and agile methods, and that the project initiation process would involve resources qualified to make an appropriate assessment. Similarly at an organisation I worked at where there were 50 running projects concurrently and again we introduced a flexible approach.</p>

<p>As an aside, I do not think any single method can lay claim to be productive with repeatable results for all types of problem, there is no perfect approach. Consider for example football teams; they can be said to use methods, usually dictated by the experience of the manager and the quality of the resources. But there is no single demonstrably reliable method of guaranteeing success ‚Äì the best teams are those that meld method and the individual talents into a cohesive group who work well together and enjoy their work. And that is probably the key, enjoyment. If you are surrounded by peers who, like you, enjoy the work, understand the methods and know the strengths and weaknesses of them, it will probably work, whether it is agile or waterfall.</p>

<h4 id="amit-gupta-on-11-february-2014-at-217-am">Amit Gupta on 11 February 2014 at 2:17 am</h4>
<p>Excellent article. It gives us insight how little has been done int he science of product development. I like author‚Äôs view on bringing how human factor, give more priority can change the course of entire product development. May be those methodologies were inspired by product development in other industries in the beginning. However, a bunch of people building product, require more of a better interpersonal chemistry, than the process itself. In modern days, where we see excellent products coming out of dorm-rooms and by even some amateurs, it‚Äôs the apt time to re-think the process oriented development methodologies.</p>

<h4 id="kevb-on-11-february-2014-at-303-am">KevB on 11 February 2014 at 3:03 am</h4>
<p>Hate how the word ‚Äòmethodology‚Äô has been highjacked to make following a ‚Äòmethod‚Äô sound more scientific.</p>

<p>If you are following a procedure, or talking about a defined procedure it is a METHOD.</p>

<p>If you are talking about the study of methods then it is ‚Äòmethodology‚Äô. Basic High School English, if you add ‚Äò-ology‚Äô to the end of a word you are talking about the study of.</p>

<h4 id="jacques-on-11-february-2014-at-315-am">Jacques on 11 February 2014 at 3:15 am</h4>
<p>Your conclusion is the first point of the agile manefesto: individuals and interactions over processes and tools</p>

<h4 id="francis-w-porretto-on-11-february-2014-at-326-am">Francis W. Porretto on 11 February 2014 at 3:26 am</h4>
<p>There are any number of reasons why software methodologies ‚Äî at least, those purveyed by institutions such as the Software Productivity Consortium and ISO ‚Äî don‚Äôt deliver as hoped or expected, but one that must not be overlooked is that they keep changing. We‚Äôre overrun with methodologies du jour, and fads that accompany them.</p>

<p>We‚Äôre largely ignorant about how the programming mentality works. There‚Äôs some irony in that, programming being about the imposition of computerized order on chaotic human practices. Nevertheless, it‚Äôs so ‚Äî and until we grasp the structure of that mentality (which might never happen) we‚Äôre doomed to flounder in our attempts to structure our approach to programming.</p>

<p>I recall, from a discussion of alternative currencies and currency management some years ago, a commentator saying that ‚ÄúCompetition is a proper response to ignorance.‚Äù Well, the million-plus Americans working in software today are competing, in a fashion, through their individual approaches to their work. Perhaps the best thing we can do is just watch, and try to learn from those who do it better than we.</p>

<h4 id="ken-mcnamara-on-11-february-2014-at-406-am">Ken McNamara on 11 February 2014 at 4:06 am</h4>
<p>Success in any group effort is directly related to leadership.</p>

<p>Consider Steve Jobs ‚Äì or more elementary Vince Lombardi.</p>

<p>Lombardi takes a failing team and in one season takes them almost to the championship.</p>

<p>How?</p>

<p>He understood football better than anyone else ‚Äì and concentrated on the fundamentals.</p>

<p>AND he knew how to lead.</p>

<p>Try this book:</p>

<p>http://www.amazon.com/That-First-Season-Vince-Lombardi/dp/B004H8GM12/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1392120078&amp;sr=1-1&amp;keywords=that+first+season</p>

<h4 id="penguinman-on-11-february-2014-at-425-am">Penguinman on 11 February 2014 at 4:25 am</h4>
<p>Hi,
you listed a few bad methodologies amongst the two good ones: ‚ÄòTop-down‚Äô, and ‚ÄòAgile‚Äô.</p>

<p>That is; people have to use them, not just say them.</p>

<p>something like this:</p>

<p>Focus on what your software needs to do, and hack it together quickly.
Don‚Äôt worry about language, or get caught up on objects, patterns, or coding style. If there are any people on the team that argue about which editor is best, or serial port monitor application is best: Fire them. Also, if someone mentions SLOC counts to monitor productivity; Fire them.</p>

<p>If the software is new, or related to a new product, there is 50% chance it will fail no matter what.</p>

<p>So, fail early, get something working for the customer quickly..i.e hack it together with existing products, existing source. Give them 70% of the functionality, or even the 10% functionality that is most important.</p>

<p>Start getting feedback and test results from the end user early (within a week or two) Also, this can flow into progress payments.</p>

<p>Even If the product IS a success, it will take 50% longer than expected , change five times and be riddled with bugs. Avoid all these problems, by getting something into the customers hands early to test. So they can change their mind early and often.</p>

<p>Divide the project into small milestones, chunks..at the end of most is a workable release of the product. and feedback from the end user. Be it one application in one language, or a string of applications and services cobbled together performing whatever you need to perform.
etc.</p>

<p>I hope you get the gist.
I think the difference between (Top-down, Agile, product functionality focus) and (Bottom up, structured , methodology, code-factory focus) is: millions of dollars and months of work.</p>

<p>Forget about the last project,</p>

<p>Start with the new requirements, and find the best and newest tools to meet them.</p>

<p>(In my humble opinion)</p>

<h4 id="mike-breeden-on-11-february-2014-at-431-am">Mike Breeden on 11 February 2014 at 4:31 am</h4>
<p>This is a great article. I think I can add a couple useful comments. (Programmer about 20 years)
I recently worked in a very progressive software development shop. I say that positively, because they were smart, dedicated people. We used Agile. They were good, so I wanted to see what Agile offered. Like the author said, it‚Äôs about how you use it. I did see one weakness. They seemed to lack any overall vision, such as you base Waterfall or BDUF on. Agile is fine, but I suggest you add that vision to it.</p>

<p>Another point I say is that I have often had the task of fixing Programmer Art and Programmer Junk. Not sure which is worse. It is not surprising that a highly intelligent developer creates art, but it can be a problem to avoid. We need business code or you‚Äôre gonna need someone like me.</p>

<p>Remember, from every strength comes weakness and from every weakness comes strength.</p>

<h4 id="sean-farrell-on-11-february-2014-at-450-am">Sean Farrell on 11 February 2014 at 4:50 am</h4>
<p>If you look at it methodologies are primarily about communication. The Waterfall Model tried to get everything onto paper so that it was obvious. The agile practices like stand up meetings or kan ban are about enabling communication between developers and ensuring that everybody is in the loop.</p>

<p>If you have a good team people will just talk to each other and any additional forced communication is perceived as a burden. On the other hand dysfunctional / semi-functional teams the methodology sort of force them to communicate, which raises the odds that the project will succeed.</p>

<p>I think most methodologies are mostly about average results. That means you can get bad to average developers to produce average results, but it comes at the cost that stellar developers are also slowed down to the average level.</p>

<p>I personally think the best thing you can do is get a small group of stellar developers, ensure that they work together and get out of their way. (Yes it sort of was said here already.)</p>

<h4 id="greg-jorgensen-on-11-february-2014-at-453-am">Greg Jorgensen on 11 February 2014 at 4:53 am</h4>
<p>@Jacques: I am a big fan of the Agile Manifesto. My experience in so-called ‚Äúagile‚Äù teams is that it‚Äôs a buzzword that appeals to management and an excuse for more process.</p>

<p>@KevB: Thanks for schooling me on the correct usage of ‚Äúmethodology.‚Äù The dictionaries I consulted have mostly succumbed to the same error, but keep fighting the good fight.</p>

<h4 id="mike-valverde-on-11-february-2014-at-507-am">Mike Valverde on 11 February 2014 at 5:07 am</h4>
<p>‚Äúsatisfying requirement on time and within budget‚Äù</p>

<p>I have never (in 15 years of software development) worked on a project large or small that the project due date was not already determined and promised to executive management before we even began working on the project. It seems that the due date must be the most import aspect of a project, since it is always determined before requirements, scope of work, features requests, design and implementation plans.</p>

<h4 id="a-scrum-master-on-11-february-2014-at-600-am">A Scrum Master on 11 February 2014 at 6:00 am</h4>
<p>I feel I must defend the agile / Scrum camp here.</p>

<p>The blog post boils down to: Independent of the process in place, the team must function as a group. The author says that when a ‚Äúfew members of the team, or maybe just one bully, will demand strict adherence and turn it into a religion‚Äù, then ‚ÄúThe resulting passive-aggression kills productivity faster than any methodology or technology decision.‚Äù</p>

<p>Well, that is really not much of an insight, I think that goes without saying. But how can you deduce from this that ‚ÄúScrum, TDD, OOP‚Äù.. do not work? Let‚Äôs just look at Scrum here.</p>

<p>Almost all of the Scrum Master training, and most of the communication in e.g. Scrum alliance mailing lists, revolves around human factors like that. Technology is not an issue there, tools to a certain extend (but much more tools for maintaining your Scrum artifacts like backlog and burndown charts, not development tools). Every Scrum Master worth the job title is very well aware of group dynamics like these and will try to restrict/rechannel them.</p>

<p>Promoting a common vision is a major part of the job, every sprint even is supposed to have a ‚Äútheme‚Äù. Many will try to make architecture a team effort, try to find an iterative approach to it etc., and avoid to have one team member dictating decisions.</p>

<p>I have had both successes and failures with Scrum, where the reasons for the failures could be tracked down to ignoring some important guidelines despite knowing better. Today I would say if done right, Scrum &amp; lean development work very well.</p>

<p>I think the author has a) not really understood what Scrum is about (because it addresses exactly what he says needs addressing, group dynamics, common vision and such), and b) has worked with a Scrum Master that was maybe not focussed, or experienced, or trained enough. One should not condemn Scrum on those grounds.</p>

<h4 id="greg-jorgensen-on-11-february-2014-at-619-am">Greg Jorgensen on 11 February 2014 at 6:19 am</h4>
<p>@Mike I have had the same experience with schedules. That‚Äôs how business works, though. The problem isn‚Äôt usually the due date. The problem is that requirements change and expand against the due date. Programmers bear some responsibility for agreeing to one change after another and not alerting management when it‚Äôs clear the schedule is unrealistic. Management is often unwilling to listen to the warnings, and choose to throw more people at the project, which of course makes it later.</p>

<h4 id="steve-naidamast-on-11-february-2014-at-624-am">Steve Naidamast on 11 February 2014 at 6:24 am</h4>
<p>Bravo !!!</p>

<p>As a senior software engineer who started in the field in 1974 I know exactly what the author of this essay is talking about. Like design-patterns, most software development methodologies are solutions looking for problems. There is only one way to design a software system or application and that is the tried and true method of the ‚Äúwaterfall‚Äù approach, which when taken down to its barest essential primarily demands up-front analysis and design, then coding, which is subsequently tested.</p>

<p>No software development technique since has been able to get away from such a basic format no matter how much you spice it up with fancy terminology or try to change the perspective on different aspects of such techniques.</p>

<p>If any of you follow senior software engineering analyst, Stephen McConnell, you will note that in his classic 1996 text, ‚ÄúRapid Application Development‚Äù, he demonstrates 13 known software development techniques, all of which in the end implement some level of the waterfall approach.</p>

<p>Good software is a result of competent individual professionals working together or alone to make a quality product. Business development environments always promote ‚Äúdevelopment by committee‚Äù, unless of course you are the only developer on staff. In any event, a ‚Äúcommittee‚Äù has never designed anything of worth providing the reason for why most business software is so poor in quality. But every now and then you do get a business team that produces something of quality. Unfortunately, that experience for me has been a rarity in close to 40 years in the field‚Ä¶</p>

<h4 id="greg-jorgensen-on-11-february-2014-at-625-am">Greg Jorgensen on 11 February 2014 at 6:25 am</h4>
<p>@Scrum Master: You‚Äôre agreeing with me. If a Scrum project works it‚Äôs because the Scrum Master has the management and communication skills required to focus the team, reign in personalities and egos, deal with management, and ‚Äúpromote a common vision.‚Äù</p>

<p>Someone with those skills can lead a successful project using almost any methodology.</p>

<p>I don‚Äôt mean to insult your skills or training, but you must know that it‚Äôs pretty easy to get certified as a Scrum Master. I‚Äôve attended Scrum training, I‚Äôve worked with several Scrum Masters on different projects. Those projects succeeded or failed because of the team, not because of Scrum. Using Scrum techniques can certainly help a functional team succeed, but it can‚Äôt help a dysfunctional team not fail.</p>

<h4 id="ls-on-11-february-2014-at-629-am">l&amp;S on 11 February 2014 at 6:29 am</h4>
<p>@Ricki‚Ä¶.that,s true‚Ä¶.i to use that though am new in the software developing world.</p>

<h4 id="greg-jorgensen-on-11-february-2014-at-633-am">Greg Jorgensen on 11 February 2014 at 6:33 am</h4>
<p>@Steve Naidamast Completely agree. Even so-called RAD and Agile projects have a BDUF because that‚Äôs what management is comfortable with. The design may not be detailed or thought through very well, and it may be dribbled out to the developers bit by bit.</p>

<p>That‚Äôs been my experience with most Agile projects: the team is not discovering requirements or working from use cases ‚Äî they are just getting requirements spoon-fed to them so they ‚Äúdon‚Äôt worry‚Äù about the big picture and get distracted.</p>

<p>I‚Äôve worked on both BDUF/waterfall and agile (small a) projects that succeeded. Looking back on those projects I remember the people and the conceptual integrity, not the process.</p>

<h4 id="winston-on-11-february-2014-at-636-am">Winston on 11 February 2014 at 6:36 am</h4>
<p>My first real experience in a ‚Äúteam‚Äù environment came in my 15th year of programming ‚Äì I‚Äôm now in my 40th if that means anything. I was looking forward to some actual design specs to work from and a common goal. Those illusions were dashed within a few weeks. My indie experience ‚Äì considered a negative during the interview process for that job ‚Äì proved to be my best asset, i.e. being able to do a major makeover on short notice, and being able to deal with huge shifts in the scope and direction of the project and taking it all in stride. As well as keeping a wary eye on a part of the project and the incompetent that was working on it, and preparing myself to take it over when that person inevitably quit or was fired. He did, and I did. My cynicism about the methodology was at first considered ‚Äúnegativity‚Äù, but then later elevated to prophetic genius when all of my predictions about release dates etc. came true. As if someone‚Äôs a genius for saying it will rain in Seattle. I‚Äôm convinced programmers as a group fit the definition of insanity: doing the same thing over and over expecting different results. Oh the methodologies are different, but the ‚Äúthis time we‚Äôre going to use a methodology and make it work‚Äù mantra never dies.</p>

<p>When the last vestiges of the original Gantt chart lie smoldering in ruins, that‚Äôs when it‚Äôs time for me to get to work. I‚Äôm in my element. And I‚Äôve never had to personally torch the chart to get there. They have a habit of spontaneously combusting, usually rotting from the inside out but sometimes a spectacular flare-up that scares the crap out of everyone from top to bottom. For many, it‚Äôs the end of their world. For me, it‚Äôs freedom.</p>

<h4 id="john-keklak-on-11-february-2014-at-647-am">John Keklak on 11 February 2014 at 6:47 am</h4>
<p>No doubt most would agree that software development is mostly ‚Äúresearch‚Äù. @Greg Jorgensen Even most of your work fixing web site code consists of research. To have even half a chance of estimating rationally, it is necessary to first accept the research nature of software development.</p>

<p>See Chapter 3 of ‚ÄúIntroduction to Software Development‚Äù: http://bit.ly/M8wxS1 (pardon the rough state of the text; it is currently only a draft version)</p>

<p>@KevB @Greg Jorgensen It seems we also need another word for ‚Äòtechnology‚Äô.</p>

<h4 id="anon-on-11-february-2014-at-651-am">Anon on 11 February 2014 at 6:51 am</h4>
<p>Agile is no more and no less than anthropomorphic observation of the human behaviour capable of producing good results. It does not show you how to get it. It just gives you the awareness to recognise the processes and people behaviours you are likely to find in a well functioning group of people. if you happen to be in one or see one take note and think yourself lucky.</p>

<h4 id="greg-jorgensen-on-11-february-2014-at-657-am">Greg Jorgensen on 11 February 2014 at 6:57 am</h4>
<p>@Winston Thank you ‚Äî you said it better than I could but I know exactly what you‚Äôre talking about.</p>

<h4 id="captain-kirk-on-11-february-2014-at-723-am">Captain Kirk on 11 February 2014 at 7:23 am</h4>
<p>While I started in the 80s as a Cowboy Programmer, I think I have seen most of this. It is complicated.</p>

<p>Vision: Knowing what you are building &amp; Why!
Clarity: Knowing what you are NOT building.
Focus: Having access to the people who will use it and train you in their jobs enough to ‚Äúget it‚Äù.</p>

<p>Then you have Conceptual Integrity (is there a metaphor or elevator pitch maintained by the architect so everyone understands the system will have limitations but strengths as well)</p>

<p>A Clear definition of success (which should include how fast the response times need to be, because I am tired of people finishing a system that takes 30 seconds to add a new record and think it is fine when it is a keypunch type application).</p>

<p>Finally, you need competent people, time to do the right thing, and management to stop picking RANDOM dates.</p>

<p>The toughest part is the schedule, and unless you are building the same widget you have done over and over (or management is willing to spend 30% to get an accurate estimate [see cone of certainty]), having lots of unrealistic deadlines and no ability to get the message to the stake holders is RISKY.</p>

<p>Many years ago, we estimated (rough) that it would take use 2man years of effort to take on a new business line. The owner then counted EVERYONE in the room (6 of us) as full-time developers and concluded that we should be done in 4 months (on top of our existing workload, of course).</p>

<p>I suggested we label everyone in the office a programmer and we could have done tomorrow at noon! Somehow, I was the one being belligerent!!!</p>

<p>There are many places to place the blame, but for me it starts with management not understanding the process.</p>

<p>If a Secretary told her boss that she would 500 pages of hand written notes in 2hrs, he would not believe her.</p>

<p>Yes, a detailed plan of attack, and thorough analysis are required. But that should be DONE BEFORE the project actually starts! I find too many companies consider ALL of that to be part of the project, and they want the ESTIMATE first (with a target they already have in mind, and no limits to what they will ask for, of course).</p>

<p>I feel the world has gone mad. The places that succeed often control the definition of success (MSFT ships offices with HUNDREDS of unfixed bugs)</p>

<h4 id="arun-sunny-on-11-february-2014-at-741-am">Arun Sunny on 11 February 2014 at 7:41 am</h4>
<p>Good post .The comments made by experinced professionals are rather more informative</p>

<h4 id="bob-on-11-february-2014-at-814-am">bob on 11 February 2014 at 8:14 am</h4>
<p>We use BDUF where I work, and I too get the feeling of working on a team where everyone clicks and things just get done. That‚Äôs not to say it‚Äôs completely fault-free. The designer and project lead spend hours each week in design meetings, hammering out one page at a time which gets sent down to the development team. Even so, we often get those pages done in time with the designer and work gets done at a quick pace. Another instance of BDUF failing to deliver is when the development team and when the designer were not in agreement on how to structure pages on a site and we had to restructure the website. Luckily, this happened early in the process so it didn‚Äôt cost too much in terms of time, but it was a learning experience.</p>

<p>We are looking at ways to improve the process, but that leads me to think that something like BDUF should just be looked at as a template. Once you start working with your team you tune the process, adding what works and removing what doesn‚Äôt work.</p>

<h4 id="araybould-on-11-february-2014-at-842-am">araybould on 11 February 2014 at 8:42 am</h4>
<p>Methodologies don‚Äôt deliver the results their adherents expect because their expectations are based on a fundamental misunderstanding of software development: it is not a form of manufacturing, where the goal is to produce many replicas of the production prototype, it is a design-like activity which concludes with the creation of the production prototype. Success depends on knowledge and good judgement, and methodologies cannot substitute for this; at best they provide guidelines for competent people.</p>

<h4 id="mark-on-11-february-2014-at-851-am">Mark on 11 February 2014 at 8:51 am</h4>
<p>Wonderful vindication of DeMarco &amp; Lister‚Äôs ‚ÄúPeopleware‚Äù (1987).</p>

<h4 id="dan-sutton-on-11-february-2014-at-853-am">Dan Sutton on 11 February 2014 at 8:53 am</h4>
<p>Absolutely right. Another way to look at it is like this: just as one should work out what the problem is before choosing a language in which to write the solution, the same goes for the development method: as you say, no one method suits any problem: to choose a development method irrespectively of what you have to solve is just as idiotic.</p>

<p>There‚Äôs something more, though: in many cases, these potted methodologies do little more than shield the incapable from detection: as someone who‚Äôs been programming since the ‚Äô70s, you‚Äôre no doubt as aware as me that most of today‚Äôs programmers simply don‚Äôt understand the basics ‚Äî they run around spouting acronyms and ‚Äúleveraging functionality‚Äù ‚Äì whatever the hell that means ‚Äì but they can‚Äôt write a simple sort algorithm: ‚ÄúThere‚Äôs a class for that‚Äù‚Ä¶ so, from that point of view, the best development methodology is education.</p>

<h4 id="brainiacv-on-11-february-2014-at-853-am">BrainiacV on 11 February 2014 at 8:53 am</h4>
<p>I agree with everything you said, and many of the comments.</p>

<p>I‚Äôve always seen ‚Äúmethodology‚Äù as a way everyone (mostly management) to turn off their brains and think the process will guarantee results instead of the efforts of the team.</p>

<p>It‚Äôs what I call ‚ÄúIndustrial Age Thinking‚Äù as opposed to ‚ÄúInformation Age Thinking‚Äù. Industrial processes are based on the idea that you can come up with the ideal way to manufacture widgets through design and/or time/motion studies.</p>

<p>That doesn‚Äôt apply to software development. Programming is driven by cognition and you can‚Äôt force everyone to understand everything at the same time or degree.</p>

<p>You can try to make things easier, but there is no guarantee what you do this time will work the next.</p>

<p>Which is why I view software development like jazz, you go with what works at the moment.</p>

<h4 id="robb-on-11-february-2014-at-915-am">robb on 11 February 2014 at 9:15 am</h4>
<p>Very thought-provoking article. IMO, it comes down to this:
People, process, tools‚Ä¶.in that order.
Without the right people, any process is worthless.
With the right people, it can help alot.</p>

<h4 id="james-ashley-on-11-february-2014-at-1124-am">James Ashley on 11 February 2014 at 11:24 am</h4>
<blockquote>
  <blockquote>
    <p>Why don‚Äôt software methodologies work?</p>
  </blockquote>
</blockquote>

<p>Because you aren‚Äôt doing it right and nobody else is either?</p>

<p>The saddest thing is when even the people implementing an agile process have no real faith in it. I had a project where SCRUM was done off of a visual studio template and after about three weeks no one was even adding stories or moving cards anymore ‚Äî and worse, no one seemed to care. They still extolled the virtues of git over TFS, tho.</p>

<p>Oh ‚Äî and the project took twice the time projected, went way over budget, functionality was cut, people were thrown under the bus (including most of the design team) and, it turned out, the iOS expert leading a big portion of the project didn‚Äôt actually know how to build iOS apps, etc. Good times.</p>

<h4 id="thomas-phaneuf-on-11-february-2014-at-1203-pm">Thomas Phaneuf on 11 February 2014 at 12:03 pm</h4>
<p>Good article. And I agree with the author and most of the comments.
Any methodology (yes, more accurately, ‚Äúmethod‚Äù) should be looked at as a prospective path, not a silver bullet. It can‚Äôt replace the overall vision, or the compensate for problems with people in a development team, or address all the unknowns or even make coffee.
But it is a starting point. It can also help guide the development and help keep it moving towards a goal. Methodologies, if used right, are a good thing ‚Äì but not magic, and not a guarantee. However, if there is more focus on the development method used than the project itself, then things will go awry very quickly.</p>

<p>I like what Topher wrote and it is worth stealing and repeating:</p>
<ol>
  <li>Get the smallest number of the smartest people possible together.</li>
  <li>Give them a clear goal.</li>
  <li>Get out of the way.</li>
</ol>

<h4 id="andrej-on-11-february-2014-at-1255-pm">Andrej on 11 February 2014 at 12:55 pm</h4>
<p>Non professionals + Good Methodology = fail</p>

<p>Non experienced team of construction workers will not build a skyscraper</p>

<h4 id="wyattmobilecom-on-11-february-2014-at-209-pm">WyattMobile.com on 11 February 2014 at 2:09 pm</h4>
<p>All Software Methodologies are a desperate attempt to include stupid people in the game. From SCRUM to TQM, they are all an attempt to allow someone with a communications degree to be included. Those people are cheap to employ, and owners are convinced it is a matter of having enough idiots who can tell a programmer what to do.</p>

<h4 id="cassandra-andra-on-11-february-2014-at-424-pm">Cassandra Andra on 11 February 2014 at 4:24 pm</h4>
<p>Claro! Animated cartoons often depict a group of IT planners gathered around a blackboard with arrowed lines drawn in every direction, criss-crossing dotted lines and unfathomable schematics, meaning haplessly confused. How to create more content over time is a driving function of the world. Even this example generates five seconds of entertainment!</p>

<p>Though I don‚Äôt think the purpose is to include poorer programmers in the game, I rather think it is to create a sideshow. It‚Äôs something else that can be ‚Äúdone‚Äù and therefore is. Short of the sense to not destroy the world, ‚Äúdo override‚Äù is major problem in the logic of the mind. A better law would be, ‚ÄúA system at rest should be left to rest.‚Äù</p>

<p>Most people in a room empty except for a button, would push it. Then, a bouncing ball in the same room would inevitably push it. I agree, it‚Äôs just one more thing that IT persons can do ‚Äì is philosophize about work. Hmm‚Ä¶</p>

<h4 id="matt-on-11-february-2014-at-427-pm">Matt on 11 February 2014 at 4:27 pm</h4>
<p>I‚Äôve been a developer for 20+ years. Like the author I‚Äôve seen all the methodologies and lots worked / failed in many different situations.</p>

<p>The one common thing I‚Äôve noticed is the owners (managers, stakeholders etc) do not know how to document what they want or don‚Äôt really even know what they want.</p>

<p>I‚Äôve started using a few simple diagrams that I borrowed from a book called ICONIX by Doug Rosenberg. I found that these simple diagrams (Use case, Domain Diagram, Robustness) were all I needed to bridge the huge gap.</p>

<p>It gave us all a common nomenclature (domain diagram)
it helped managers quantify the invisible (like when we‚Äôre working on things they can‚Äôt see, like databases, views, procedures, functions, etc)
it helped us to estimate (count the bubbles and multiple by some coefficient)</p>

<p>It forced project owners to do more than draw up a screen in photoshop and then believe that since they can see it it must be really easy to build. It also forced them to think about what they are asking so that they don‚Äôt make illogical or contradictory requests.</p>

<p>So, no matter which methodology, increased communication of <em>what</em> the software should do, not how it should do it, and the god forsaken question ‚Äúhow many hours is that going to take‚Äù have always been signs of success for me in my career.</p>

<p>Good developers self monitor and don‚Äôt need a stupid scrum meeting daily.</p>

<p>Peace,</p>

<p>-Matt</p>

<h4 id="david-slick-on-11-february-2014-at-919-pm">David Slick on 11 February 2014 at 9:19 pm</h4>
<p>Your thoughts definitely resonate. Particularly the fact that there‚Äôs not one silver bullet. All too often ‚ÄúAgile‚Äù is used as just that, a silver bullet to solve other problems deeply embedded in the company culture/leadership. Agile doesn‚Äôt solve those problems, but I‚Äôve seen it help shed light on them so they can be fixed. But it still takes mature teams/orgs to do something about them. It also enables you to get customer feedback and integrate that so you can adapt to build things incrementally toward your ultimate value goals, but it takes a company that has customers and is willing/able to access them.</p>

<p>Also, I‚Äôve seen great code written using TDD and without any unit tests. But on average, the code I‚Äôve seen unit tested is of higher quality, if TDD‚Äôd even better, and it mostly stays working over time.</p>

<p>I think it‚Äôs important to be clear about any methodology is meant to give you. Do you need that? Are you willing to pay the costs associated to get it? Is it worth it? Do you have teams mature enough to handle it? Do you have management skilled enough to deal with the output?</p>

<p>And more importantly than the practices, agile is about the values. You share those values outlines in the agile manifesto? If not, don‚Äôt bother, you‚Äôre just wasting your time.</p>

<h4 id="stephan-schmidt-on-12-february-2014-at-1207-am">Stephan Schmidt on 12 February 2014 at 12:07 am</h4>
<p>‚Äúrigorous studies of software development methodologies haven‚Äôt been done because it‚Äôs impossible to control for all of the variables.‚Äù</p>

<p>No, because it‚Äôs so much easier to go by anecdotes than do some multi-year research on a topic.</p>

<h4 id="greg-jorgensen-on-12-february-2014-at-429-am">Greg Jorgensen on 12 February 2014 at 4:29 am</h4>
<p>@Stephan Schmidt: Maybe ‚Äúeasier‚Äù to go by anecdotes, but when you can‚Äôt control for the biggest variable ‚Äî people ‚Äî it‚Äôs not possible to test the effectiveness of a methodology. There‚Äôs no way to have the same team do the same programming task using different methodologies and from that determine which works best, unless you have a Men In Black memory eraser.</p>

<h4 id="edub-on-12-february-2014-at-820-am">Edub on 12 February 2014 at 8:20 am</h4>
<p>‚ÄúOnce a programming team has adopted a methodology it‚Äôs almost inevitable that a few members of the team, or maybe just one bully, will demand strict adherence and turn it into a religion. The resulting passive-aggression kills productivity faster than any methodology or technology decision.‚Äù Excellent point!!! So, So very true!!! I have been subject to the bullying of system engineers and DBAs who seem to base their adherence of a ‚Äúpolicy‚Äù based on how they feel that day. Policy is in quotes because either they have never read the policy (just hear say) or in absence of a policy they make up their own rules.</p>

<h4 id="tim-on-12-february-2014-at-115-pm">Tim on 12 February 2014 at 1:15 pm</h4>
<p>#4 Fred Zisk: ‚ÄúThe only method that seems to work is waterfall.‚Äù</p>

<p>Having completed well over a dozen implementations of enterprise systems in the last decade, I can say with complete confidence that waterfall is a project killer. There indeed is no silver bullet but Agile comes the closest to acknowledging the realities of modern business.</p>

<h4 id="tom-on-12-february-2014-at-249-pm">Tom on 12 February 2014 at 2:49 pm</h4>
<p>Would you ask a biology graduate to remove your appendix? Would you travel in a jet plane designed by a team of mathematicians? Would you work in a chemical plant designed by chemistry grads. Wonder why the development processes don‚Äôt yield better results? Just look at the people.</p>

<p>Roughly half of all software developers have degrees in computer science. Most of the rest do not have degrees related to computing. I did some work for a government agency and discovered that one developer had a masters in Eastern European folk dancing. Hopefully he minored in Java or something similar.</p>

<p>Training shows you how to do something while education broadens your mind.</p>

<p>The people who graduated in physics or math have some change, but even the people who graduated from Computer Science were educated by the Science Faculty. The Science faculty does not train people in product development. There are no courses in development metrics, configuration management, project management or quality assurance. Basically the vast majority of the people producing software today were never prepared for this role by their education. They are essentially all self taught.</p>

<p>And they do not know what they do not know!!!!</p>

<p>As for the methodologies that do not work, I have very seldom seen an accurate description of the so called waterfall model. Advocates of other methods us it as a straw man to show how much more reasonable their approach is. But the waterfall model just says requirements before design, design before construction, construction before testing. All engineering processes follow this model at some level (although the TDD people seem to want to reverse this). Basically, most of the people involved in software development have not really studied any development approaches and most groups adopt a given method as the result of the preference of the loudest person in the group.</p>

<p>Another really bad thing about most software development processes that are actually in use is that they are oriented towards building features. While that is what users are interested in, it is not what engineers produce. Engineers produce designs for things which is software translates into components. In a feature oriented development, anyone can change anything which typically forces code merges and the associated defects that merging introduces. It also forces everyone to be familiar with everything which is okay if the system is 10,000 lines of code but is a disaster when the system is 500KLOCs or bigger. Nobody can understand enough of such a large system to safely make modifications to arbitrary parts of it. And if everyone is responsible for all of the designs of all of the changes they make to all of the bits they touch to implement their assigned features, nobody is accountable when there is no design.</p>

<p>Failure is not left to chance. And even when a project fails, it is often deemed a success. Look that the Chrysler c3 payroll project that gave us agile development.</p>

<h4 id="initdotd-on-12-february-2014-at-706-pm">initdotd on 12 February 2014 at 7:06 pm</h4>
<p>One word, plastics! All kidding aside the common vision is critical. As it develops and the truth begins to show itself, you end up with, regardless of what you call it, requirements. Idea to concept to something well defined that indeed can be measured and deemed success when reached. Methodology has nothing to do with finding the truth although some would argue it helps you get there. I‚Äôll buy that. The point is you learn as you go and what you measure as success will directly impact the way you choose to define it.</p>

<h4 id="rick-mowen-on-12-february-2014-at-948-pm">Rick Mowen on 12 February 2014 at 9:48 pm</h4>
<p>Yes ‚Äì I heartily concur with this interesting treatise on the fundamental nature of practices in the area of software development postulated by this intriquing author. I myself have developed several similar methodologies. My first foray into this area led me to develop ‚Äúyum-go-go‚Äù a work framework which simply states that the relative work accomplished is directly proportional to the size of one‚Äôs breakfast. It was adopted throughout the many large organizations and led directly to the implementation of work sponsored cafeterias. Having worked mostly at smaller companies, I never did directly benefit from those advancements which led me to develop over time ‚Äúobscure-o‚Äù, which postulates that the amount of equipment one‚Äôs office, working or otherwise, is directly proportional to one‚Äôs worth as a team member. Lastly, my hobby as a collector of Americana, as well as my involvement in Linux (which I pronounce Lin-ish as a tribute to my own personal involvement in the erstwhile os), has given me the perspective to write ‚ÄúWorking Without Effectivity‚Äù which is an explorations into the field of ‚ÄúMalleable Task Management using Waterwings‚Äù.</p>

<p>Keep up the good work!!</p>

<h4 id="a-scrum-master-on-13-february-2014-at-126-am">A Scrum Master on 13 February 2014 at 1:26 am</h4>
<p>@Greg Oh yes, I‚Äôm not arguing that you don‚Äôt need a well-cooperating team, or that process would be more important than the people on the team finding that spirit and ‚Äúclicking‚Äù, as you put it. I was just surprised that you dismiss the agile / Scrum approach on that basis, since from my perspective that‚Äôs exactly what they‚Äôre about. As someone else pointed out above, after all the first sentence of the Agile Manifesto is ‚ÄúIndividuals and interactions over processes and tools‚Äù. Isn‚Äôt that also what you are saying?</p>

<p>And of course anyone can take a two day seminar and get a Scrum Master certificate. But I find it hard to imagine that within those two days, you would not speak about group dynamics, about Tuckman‚Äôs stages of group development, about handling ‚Äúdifficult‚Äù people, about how team members have different expectations and motivation, about retrospectives and how to make them effective, and how to set an atmosphere where everybody speak their mind. I‚Äôm not saying that you are given solutions for all of those challenges, or that everything then subsequently just works, but at least you‚Äôll have some awareness of these issues.</p>

<p>Which brings me to my last point: Those projects you mention you are involved in routinely, those where ‚Äúalmost nothing of real value is produced‚Äù ‚Äì are Scrum projects among those? If one of these projects was a Scrum project, how did the Scrum Master handle the situation? When nothing of real value was produced, clearly there must have been sprints where the sprint goals where not reached. It‚Äôs hard to imagine that the Scrum Master wouldn‚Äôt address that at all. Was the burden of too much process etc. never brought up in a retrospective? Being agile is about adjusting the process ‚Äì you sprint, find out what went well and what went badly, encourage the former and try to reduce the latter. If in your project things didn‚Äôt work out and you just kept doing them anyway, well, then that wasn‚Äôt really an agile approach, no matter what your managers might have called it.</p>

<p>I really think most of what you write is correct, but the headline for me just isn‚Äôt. ‚ÄúWhy is everything that has been found out about collaborative software development in the last 20 years being ignored in the projects I work in?‚Äù would be a more appropriate, if less catchy, title.</p>

<h4 id="alessandro-koterle-on-13-february-2014-at-319-am">Alessandro Koterle on 13 February 2014 at 3:19 am</h4>
<p>After having thought it over for a while before leaving a comment, it came clear enough to me that this article is lacking too much in giving clear boundaries and contexts and then it could be likely misleading. Indeed, seems that even the author has recognized it and retreat a bit by editing original post which lead me to consider this article more seriously. Having been worked for many years on many small/big projects, with huge teams, adopting any of existing methods, processes, practices, technologies doesn‚Äôt necessarily mean having got them right or at least not giving them enough attention. Claiming that no methodology works is like saying ‚ÄòNo girl/boy-friend is good enough for me‚Äô should I live alone then? or ‚ÄòNone of any car is suitable for me‚Äô should I walk a lot then? or ‚ÄòNone of programming languages fit my expectations‚Äô should I learn and use them all together ? (guessing whether learning well enough more than ten could be actually possible).</p>

<p>Furthermore, should we all discuss on a mix of several relevant topics such TDD, OOP, Agile, RAD, Scrum, Human interaction all at once in an misleading if not erroneously ordered unlikely recipe?</p>

<p>More than that, reading the article, I have personally perceived that it is mainly focused on people ant that leads me to to think how often people run into troubles with his peers (job mates). Please note that Alistair Cockburn thesis reports several answers we all could further discuss on and not just keep them as a generic and ‚Äòpessimistic‚Äô conclusion over human beings. Indeed he also answers that: ‚ÄúEvery project needs a slightly different methodology, based on those people characteristics, the project‚Äôs specific priorities, and the technologies being used. This result indicates that a team‚Äôs methodology should be personalized to the team during the project and may even change during the project.‚Äù So he is saying something slightly different from what this article aims to.</p>

<p>I perfectly agree on ‚ÄòStrict Management‚Äô issues, on ‚ÄòNo Silver Bullet‚Äô concept and on what ‚ÄòTwo-different-programmer-teams‚Äô thought experiment aimed to claim at and also that human beings personalities and interactions obviously will ever make the difference. People interaction over processes is another good point I agree upon.</p>

<p>But there is a quite big discrepancy between arguing on such issues and claiming that most of or even all methodologies will fail. Furthermore, who or what will exactly fail? How long a project should last before stating a given process/methodology makes it fail? Who or what lead the change in adopting a new process or methodology and who or what actually caused the failure?</p>

<p>Scrum has been mentioned as well. Scrum is not a methodology but rather a framework providing teams with some guidance in adopting proven ‚Äòagile‚Äô practices. It‚Äôs up to managers, software development teams, hardware teams, even sales get a try and work hard to achieve continuous improvements.</p>

<p>Here we go, Is the continuous improvement a ‚Äòtypical programmer‚Äô aims at?</p>

<h4 id="mr-csharp-on-13-february-2014-at-105-pm">Mr CSharp on 13 February 2014 at 1:05 pm</h4>
<p>I agree with this blog on the most part. No one methodology works alone. You got to take the best of every methodology and adapt as the situation comes along. Definitely some methodology and standards are better than none. The thing you‚Äôd hate the most, especially on a mid to large sized teams is when you have numerous code achieving the same functionality and that similar code is copied and pasted everywhere. Then, when the functionality changes, multiple code changes are required throughout the app. That‚Äôs what you call cowboy programming. Methodology and standards that are too strict definitely kills the spirit on a team level since rules cannot be bent to allow for flexibility. Think of it this way, software development is like the Matrix. The Matrix keeps everything in-bounds, which is a good thing. The Matrix can also warp to adjust for other things and it‚Äôs not rigid. The Matrix is your friend in the software world, unlike the movie where it is the enemy. üôÇ</p>

<h4 id="gnum-on-13-february-2014-at-235-pm">Gnum on 13 February 2014 at 2:35 pm</h4>
<p>All you saying is the rephrase of the old statement ‚Äì ‚ÄúAny system is only as good as it‚Äôs parts combined‚Äù. Of course no method can substitute the actual skills, effort and genuine commitment. You can‚Äôt expect to take a bunch of sloppy inexperienced, willing to work for a higher salary, workers, call them developers and with the magic of some Methodology produce good software in short time for small cost. Of course you need to have an adequate skills and sufficient level of commitment in a first place. This is all only a premise for methodology.</p>

<p>Methodology comes to play when you DO have a good team with good skills, well committed, with right attitude and sufficient social skills. When you have all that then you have a choice of how exactly you organize your work, and then it comes to the choice of pattern and the process.</p>

<p>Saying there is no need of pattern or the process is effectively saying that the team is either not in a state when it is ready for any organized work. In other words it means you don‚Äôt have a team. You have some may be well talented individuals, may be even in the same room, but that doesn‚Äôt make them a team.</p>

<p>Until you have a qualified team the question of methodology or the process is an abstract. It is like choosing the route of commute before getting the job. It doesn‚Äôt matter which way you come to work of you don‚Äôt have a job. It doesn‚Äôt matter how you dress for work if you don‚Äôt have a job. It doesn‚Äôt matter what you decide your daily work routine to be if you don‚Äôt have a job. None of these choice will make any difference on your income if you don‚Äôt have a job.</p>

<p>Same story with the process, methodology and the team. If you don‚Äôt have a functional team ‚Äì no process will help. When you do have a team ‚Äì the choice of methodology and the process will make a whole world of difference then.</p>

<h4 id="gene-on-13-february-2014-at-913-pm">Gene on 13 February 2014 at 9:13 pm</h4>
<p>I had to weigh in on this excellent article. As said directly above, the comments made by the experienced professionals are of more value than the others but it is good to see technical professionals debating this subject.</p>

<p>I coded, then project managed, then directed but when you have your own business and it is really your money that is being lost and your firm‚Äôs name that is at risk with your customers, the learning curve steepens. Following are a few things I‚Äôve learned and some quick thoughts on the matter.</p>

<p>Clearly no one methodology fits all projects. I have a lot of trouble listening to individuals who think one method is the best (sometimes the only) solution. The overall approach must fit the type of project, type and criticality of the application(s), complexity, timeline, acceptable level of risk, customer‚Äôs team, customer‚Äôs business controls, technology team‚Äôs familiarity in the application area, available tools, diversity in the team, customer‚Äôs maturity with the process, the team‚Äôs professional maturity, acceptability of frank and open challenges in the various environments, communication skills among the members, experience the team has with each other, proximity and access the team has to each other and all the various constraints whether technical or project oriented. I‚Äôm not being glib here making this list. This was just a quick flow and is not organized but if you really dig into projects you will see that every one of these things and more factor into the equation.</p>

<p>This is why each project should start with an approach yet remain flexible as more is learned about all of the above. Long academic debates about waterfall vs. agile are interesting and much can be learned, but at the end of the day a general approach needs to be determined and then some principles developed to control the project.</p>

<p>Principles allow the project to be controlled as tightly or as loosely as fits the overall landscape. For example a principle may state ‚Äúno code shall be final-tested by the same individual that did the programming‚Äù and ‚Äúsubject matter experts shall control the final testing‚Äù and ‚Äúsubject matter experts shall be named and will formally have defined functional responsibilities‚Äù. Obviously much care must be taken developing and applying the principles and they must be comprehensive but statements like these are easy for everyone on the team to understand and it is easy to measure compliance. And principles can be loosened up to be more of ‚Äúguidelines‚Äù or tightened down to be more of a ‚Äúspecification‚Äù.</p>

<p>So after my 30+ years at this on projects small and large and in some very critical environments I have come to the same conclusion a neurosurgeon who was my doctor told me one time ‚Äúthe more experienced I get the more I realize the less I really understand‚Äù. The key word is understand because certainly the experienced professional knows more than the less experienced, but how much is really understood of a complex subject as this, with humans as the primary variable, is the elusive part which really matters. So my conclusion is to start with the best approach you can given the experience level in your team, consider using principles you develop instead of very rigid structures, encourage debate and be willing to listen, learn and adapt but keep the eye on the goal. Most importantly keep moving forward without dwelling too intently on trying to control every element of the process. Oh and the obvious hire and provide motivation at all levels for the very best people you can afford!</p>

<h4 id="stefan-on-14-february-2014-at-1256-am">Stefan on 14 February 2014 at 12:56 am</h4>
<p>I‚Äôve found that all software processes have two things in common:</p>
<ol>
  <li>plan your development in managable chunks, over managable intervals of time</li>
  <li>reassess your achievements in regular intervals and adapt your assignments accordingly</li>
</ol>

<p>The projects that were good at these two things also went reasonable well. Those that didn‚Äôt went way over budget or failed. That said, I recall only one case of failing at the first üòâ</p>

<h4 id="piotr-on-14-february-2014-at-244-am">Piotr on 14 February 2014 at 2:44 am</h4>
<p>The answer is easy ‚Äì the ‚Äúproblem‚Äù is not because of methodology, the ‚Äúproblem‚Äù is because of skills‚Ä¶
New methodologies are invented to ‚Äúlegitimate‚Äù lame development instead of facing the issue directly ‚Äì poore skills. Really good developer can be successful even with waterfall up-side-down or whatever. The thing is that education is tough, requires lots of effort and time, so it‚Äôs being skipped in our greedy world.</p>

<h4 id="hmm√ºller-on-14-february-2014-at-720-am">H.M.M√ºller on 14 February 2014 at 7:20 am</h4>
<p>All ‚Äúengineering‚Äù (design-level engineering) works like that .. what‚Äôs ‚Äúthe problem‚Äù? Talk to people designing (not building!!) a next generation car engine; or an airport (even a small one); or a new assembly line. We always go to the limit of what is possible ‚Äì that‚Äôs the whole idea of that ‚Äúprogress enterprise‚Äù mankind has been doing at least for the last 400 years.</p>

<p>All teams I have worked with in the last 30 years have used methodologies ‚Äì i.e. abstract ideas about how work (thinking, designing, communicating, writing code, testing, etc.etc.) should be done: They had their rules ‚Äì sometimes purely local ones, but most of the time a mix of external and local ones they adapted ‚Äì knowingly or unknowingly ‚Äì to their environment. And they worked to the level they worked ‚Äì depending on the environment (much/little money, much little/time, good/bad managers, ‚Ä¶) and the problem to be solved (standard/risky, large/small, ‚Ä¶).</p>

<p>This article shows once again that programmers (me included, in my younger years) are a bunch of people that believe that they can rule the world with what they think. This is simply wrong. But of course it is still worthwhile to try to organize oneself and the people around ‚Äì from team to project/department to all stakeholders ‚Äì so that the enterprises we start come to an end that is as good as possible (measured on that very multi-dimensional scale of ‚Äúgood‚Äù*).</p>

<ul>
  <li>There are even projects where it is a success if they fail ‚Ä¶ I could tell a few stories about that.</li>
</ul>

<p>H.M.</p>

<h4 id="tim-s-on-14-february-2014-at-103-pm">Tim S. on 14 February 2014 at 1:03 pm</h4>
<p>Definitely agree. This was one of the best programming articles I‚Äôve read in a long time. I‚Äôm sharing this with my-workers as our management is looking to implement stricter red-tape/processes in our environment, even though all is well.</p>

<h4 id="cms-on-14-february-2014-at-1136-pm">CMS on 14 February 2014 at 11:36 pm</h4>
<p>I agree it comes down to the talent. The ‚Äúnot reverting to cowboy coding‚Ä¶‚Äù comment grabbed my attention the most. My initial reaction was skepticism and admittedly some disdain. However, who am I to question your life‚Äôs experience.</p>

<p>My reaction stems from the following. There are oceans of garbage development in the industrial automation business. Which I believe is a somewhat different craft, but surely shares many fundamentals. Per my life experience most of the people I‚Äôve run into that deride specs, processes, documentation, meetings, etc. often do the worst quality work, AND can‚Äôt see it! And even when forced into more structured work processes, it only helps so much, because the values still don‚Äôt match.</p>

<p>So I come back to my opening, the talent, and good leaders/mentors are the most important part of project success.</p>

<p>I shouldn‚Äôt complain about bad coders, they are good for business in our arena. But it disheartening at times being immersed in rotten systems all the time.</p>

<h4 id="ricky-on-15-february-2014-at-315-pm">ricky on 15 February 2014 at 3:15 pm</h4>
<p>You left out an interesting if expensive option that I‚Äôve seen work. Plan to throw one away: In particular, first build a BDUF thingy a as a prototype; Document the hell out of every function and module; Use the documents and running code as spec for the next version.</p>

<h4 id="andy-on-16-february-2014-at-244-pm">Andy on 16 February 2014 at 2:44 pm</h4>
<p>IT Consultants can take much of the blame for corrupting methodologies. It is often‚Ä¶no always in their interests to pad out a project with extra staff, extra process and to take as long as possible. Their version of ‚Äúgood practice‚Äù is all about profit‚Ä¶and it works depressingly well.</p>

<p>I have seen $800M spent on a data warehouse that was designed to fail. (raw XML in relational tables with one column!) 80% of the ‚Äúteam‚Äù had never coded yet they were convinced they were ‚Äúhigh level‚Äù design geniuses. I can design a nuclear power plant at a ‚Äúhigh level‚Äù and it is similarly useful!</p>

<p>Why is all this failure and waste not reported? The ones who hire them cover their reputations and call the project a ‚Äúsuccess‚Äù then claim their bonus.</p>

<p>EG. A large Telco spent over a decade trying to get a ‚Äúflexible‚Äù billing system to work‚Ä¶they gave up and hired the <em>same consultancy</em> to replace it with a new one. This seemed baffling until you realise how the ‚Äúalumni‚Äù system works: You scratch their back‚Ä¶</p>

<p>IT is productive, it creates wealth. Like leeches to a bloated swimmer, the consultants and pretenders tap into the wealth. Programmers are now beast of burden, to be tapped and carefully contained by the ladder climbers and pseudo-techs.</p>

<h4 id="jacek-dalkowski-on-17-february-2014-at-320-pm">Jacek Dalkowski on 17 February 2014 at 3:20 pm</h4>
<p>Best methodology is good will and common sense. Unfortunatelly, it is not popular enough üòâ</p>

<h4 id="phil-w-on-18-february-2014-at-1129-am">Phil W on 18 February 2014 at 11:29 am</h4>
<p>That opening paragraph nails it ‚Äì in decades of programming that has become the problem. There‚Äôs a hole in the hierarchy between the managers who say ‚ÄúWe want this‚Äù and the developers. The middle guys who could translate requirements into development strategy, plans, code, objects or whatever (the Powerpoint to coding guys) have gone. I think managers were never happy about their technical objections or their salaries after years in the business, so a bunch of largely clueless programmers beneath a manager who can‚Äôt actually guide them technically has become the norm. I keep seeing this in many setups and the results are as predictable as you‚Äôd expect, regardless of methodology or tools.</p>

<h4 id="daniel-garcia-on-18-february-2014-at-721-pm">Daniel Garcia on 18 February 2014 at 7:21 pm</h4>
<p>‚ÄúI think programmers should pay much more attention to listening to and working with their peers than to rituals and tools‚Äù
Do you think pair-programming could help in some degree to ‚Äúwork with peers‚Äù?
Just curious to know your opinion.</p>

<h4 id="nooshin-on-19-february-2014-at-152-pm">nooshin on 19 February 2014 at 1:52 pm</h4>
<p>hi,I‚Äôm doing a project and I need information about the software engineering methodology developed in 20 of the last 50 years to know please help me in this regard</p>

<h4 id="brian-shreeves-on-2-april-2014-at-709-pm">Brian Shreeves on 2 April 2014 at 7:09 pm</h4>
<p>Greg,
I realize this post is not old, but chances are your experiences have a little more mileage.
Considering that you have realized that personalities, teamanship and proper leadership are crucial to the success of a methodology, therefore the product. Have you recognized ways to aptly put together a well functioning team?</p>

<h4 id="john-hunter-on-23-august-2014-at-610-am">John Hunter on 23 August 2014 at 6:10 am</h4>
<p>I think the key bit there is ‚Äúin and of themselves.‚Äù Certain methodologies are excellent in the right situation. But I do believe things need to be molded to the organization.</p>

<p>I do think agile-like methodologies are very good for most (if not nearly all) situations. But different situations will require somewhat (to very) different practices within the agile range of options. I wrote about my experience</p>

<p>http://management.curiouscatblog.net/2014/05/29/building-a-great-software-development-team/</p>

<h4 id="erin-shellman-on-26-august-2014-at-702-pm">Erin Shellman on 26 August 2014 at 7:02 pm</h4>
<p>I wonder if maybe you had that feeling of conceptual integrity in the bad old days because people don‚Äôt stay in their jobs very long anymore. With such high turnover it‚Äôs got to be hard to really develop a high-functioning, super productive team.</p>

<h4 id="gregory-mcintyre-on-26-august-2014-at-703-pm">Gregory McIntyre on 26 August 2014 at 7:03 pm</h4>
<p>I agree.</p>

<p>Question: Is agile not <em>meant</em> to be taken with a grain of salt and applied wisely and perhaps adaptively to the circumstances at hand?</p>

<p>If you read the agile manifesto, that seems to be the implication. Perhaps it‚Äôs the eroding of the original spirit as larger corporations adopt a top-down authoritarian approach to agile that goes against the entire point of it, that agile becomes silly.</p>

<h4 id="doug-reeder-on-27-august-2014-at-700-am">Doug Reeder on 27 August 2014 at 7:00 am</h4>
<p>I‚Äôd say, rather, that the real goal is something beyond process that we can‚Äôt yet describe. The goal of any process is to get programmers in the state of mind where they write good code.</p>

<h4 id="isidro-l√≥pez-on-27-august-2014-at-1021-am">Isidro L√≥pez on 27 August 2014 at 10:21 am</h4>
<p>The point is: would two IDENTICAL teams within IDENTICAL conditions get the same results with a waterfall and with an ‚Äúagile‚Äù methodology?</p>

<p>When I say ‚Äúthe same results‚Äù I‚Äôm thinking about everything: the quality of the code, the satisfaction of the customer, the satisfaction of the team itself, the economical cost, the duration, etc.</p>

<p>Obviously, it‚Äôs scientifically impossible to prove it (because two things can not happen at the same time‚Ä¶ I think üôÇ ), but all the experiences that I had myself and saw around scream out the same answer: NO. I would definitely bet my own life that the overall outcome would be mucho more satisfactory following agile-like methodologies rather than waterfall ones.</p>

<p>Oh, sure, I forgot to write down ‚ÄúIMHO‚Äù at the very beginning of every sentence that I wrote :-p</p>

</div>


	
	

	


			</section>

			
		</div></div>
  </body>
</html>
