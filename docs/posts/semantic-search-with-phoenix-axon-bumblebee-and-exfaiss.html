<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dockyard.com/blog/2023/01/11/semantic-search-with-phoenix-axon-bumblebee-and-exfaiss">Original</a>
    <h1>Semantic Search with Phoenix, Axon, Bumblebee, and ExFaiss</h1>
    
    <div id="readability-page-1" class="page"><section>
    <div>
      <div id="ember4872333"><!---->
<h2>Introduction</h2>
<p>In my previous post, <a href="https://dockyard.com/blog/2022/09/28/semantic-search-with-phoenix-axon-and-elastic">Semantic Search with Phoenix, Axon, and Elastic</a>, I detailed how you can use Elixir’s machine learning libraries to create a semantic search tool capable of pairing users with wines based on natural language descriptions. </p>
<p>Since that post was published, Elixir’s machine learning ecosystem has grown significantly with the introduction of the <a href="https://github.com/elixir-nx/bumblebee">Bumblebee</a> library. <a href="https://dockyard.com/blog/2022/12/15/unlocking-the-power-of-transformers-with-bumblebee">Bumblebee is a library that gives Elixir developers access to a variety of powerful pre-trained models</a> available on <a href="https://huggingface.co">HuggingFace</a>. </p>
<p>Additionally, <a href="https://dockyard.com/blog/2021/04/08/up-and-running-nx">Nx</a> recently introduced a serving capability designed for online deployment scenarios. Finally, <a href="https://dockyard.com/blog/2023/01/04/search-and-clustering-with-exfaiss">I recently released a library</a> called <a href="https://github.com/elixir-nx/ex_faiss">ExFaiss</a>, which provides bindings to the powerful vector search library <a href="https://github.com/facebookresearch/faiss">FAISS</a>.</p>
<p>With these recent additions to the Elixir ecosystem, I thought it would be a good idea to update my previous post with the newest libraries available. For additional context, I suggest you read <a href="https://dockyard.com/blog/2022/09/28/semantic-search-with-phoenix-axon-and-elastic">my original post</a> on this topic. In this post, we’ll create a semantic search tool for wines using Phoenix, Axon, Bumblebee, and ExFaiss.</p>
<h2>Setting Up the Application</h2>
<p>Start by creating a new Phoenix application. I am using Phoenix 1.7:</p>
<pre><code>mix phx.new sommelier</code></pre>
<p>Next, you’ll need to add the following dependencies to your application:</p>
<pre><code>[
  ...
  {:bumblebee, &#34;~&gt; 0.1&#34;},
  {:nx, &#34;~&gt; 0.4&#34;},
  {:exla, &#34;~&gt; 0.4&#34;},
  {:ex_faiss, github: &#34;elixir-nx/ex_faiss&#34;}
]</code></pre>
<p>Then, run <code>mix deps.get</code>:</p>
<pre><code>mix deps.get</code></pre>
<p>Finally, you’ll need to create your database:</p>
<pre><code>mix ecto.create</code></pre>
<p>And you’re ready to get started!</p>
<h2>Setting up the Wine Resource</h2>
<p>In the original semantic search application, you didn’t need to use Ecto to manage wine documents because you used Elasticsearch for persistence. This time, without Elasticsearch, you’ll need an Ecto resource to persist information about wines. Run the following command to generate a new context and schema for wines:</p>
<pre><code>mix phx.gen.context Wines Wine wines name:string url:string embedding:binary</code></pre>
<p>For each wine, we’ll store the name, its URL on wine.com, and an embedding, which is a vector that mathematically captures semantic information about the wine. The embedding will be generated from a semantic similarity model.</p>
<p>Make sure you run <code>mix ecto.migrate</code> to create the wine table:</p>
<pre><code>mix ecto.migrate</code></pre>
<h2>Creating the Embedding Pipeline</h2>
<p>Your semantic search application will take a natural language query, compute an embedded representation of the query using an Axon model, and then compare the embedded representation to existing representations of wines in an index. </p>
<p>Create a new file <code>lib/sommelier/model.ex</code>. This module will be responsible for the embedding pipeline you’ll use to embed natural language queries:</p>
<pre><code>defmodule Sommelier.Model do
end</code></pre>
<p>In <code>model.ex</code>, create a new function called <code>serving</code> that looks like:</p>
<pre><code>def serving() do
  {:ok, %{model: model, params: params}} = Bumblebee.load_model({:hf, &#34;sentence-transformers/paraphrase-MiniLM-L6-v2&#34;})
  {:ok, tokenizer} = Bumblebee.load_tokenizer({:hf, &#34;sentence-transformers/paraphrase-MiniLM-L6-v2&#34;})

  {_init_fn, predict_fn} = Axon.build(model, compiler: EXLA)

  Nx.Serving.new(fn -&gt;
    fn %{size: size} = inputs -&gt;
      inputs = Nx.Batch.pad(inputs, @batch_size - size)
      predict_fn.(params, inputs)[:pooled_state]
    end
  end)
  |&gt; Nx.Serving.client_preprocessing(fn input -&gt;
    inputs = Bumblebee.apply_tokenizer(tokenizer, texts,
      length: @sequence_length,
      return_token_type_ids: false
    )

    {Nx.Batch.concatenate([inputs]), :ok}
  end)
end</code></pre>
<p>Next, add the following <code>predict</code> function to the module:</p>
<pre><code>def predict(text) do
  Nx.Serving.batched_run(SommelierModel, text)
end</code></pre>
<p>Next, add the following to your <code>application.ex</code>:</p>
<pre><code>...
{Nx.Serving,
  serving: Sommelier.Model.serving(),
  name: SommelierModel,
  batch_size: 8,
  batch_timeout: 100},
# Start the Endpoint (http/https)
SommelierWeb.Endpoint</code></pre>
<p>This will create and start a new <code>Nx.Serving</code>, which will handle the pre-processing and model inference in batches behind the scenes to better use resources on the server. You can test that your serving works by starting your application:</p>
<pre><code>iex -S mix phx.server</code></pre>
<p>And attempting to embed some text:</p>
<pre><code>iex&gt; Sommelier.Model.predict(&#34;a nice red wine&#34;)
[info] TfrtCpuClient created.
#Nx.Tensor&lt;
  f32[1][384]
  EXLA.Backend&lt;host:0, 0.1077614924.2375680020.62643&gt;
  [
    [-0.02617456577718258, -8.819118374958634e-4, 0.05722760409116745, 0.12959082424640656, -0.1351461410522461, 0.020610297098755836, 0.005453622899949551, 0.1129845529794693, 0.005040481220930815, 0.041092704981565475, 0.0013414014829322696, 0.045418690890073776, 0.12092263251543045, -0.050827134400606155, -0.01729273609817028, 0.14232997596263885, 0.19483818113803864, 0.032853033393621445, -0.09650719165802002, 0.11645855009555817, 0.01761060580611229, -0.026606624945998192, 0.009240287356078625, -0.05202469229698181, 0.010420262813568115, 0.1607143133878708, -0.03218967467546463, 0.024632470682263374, 0.03334266319870949, 0.03204822167754173, 0.012620541267096996, 0.022357983514666557, -0.05593165010213852, 0.02747185155749321, 0.030256617814302444, -0.08117566257715225, 0.08132530748844147, 0.11905942112207413, 0.014421811327338219, 0.06395658850669861, 0.06002272665500641, 0.06929747760295868, -0.10164055973291397, 0.14846278727054596, -0.019189205020666122, 0.04716624692082405, -0.17113839089870453, -0.01575590670108795, 0.02289806306362152, -0.09108022600412369, ...]
  ]
&gt;</code></pre>
<h2>Creating the Vector Index</h2>
<p>In order to perform vector search, you need to create a vector search index using ExFaiss. You can read in depth about ExFaiss in my post <a href="https://dockyard.com/blog/2023/01/04/search-and-clustering-with-exfaiss">here</a>. Create a new module <code>lib/sommelier/index.ex</code>:</p>
<pre><code>defmodule Sommelier.Index do
end</code></pre>
<p>Next, scaffold out a basic GenServer:</p>
<pre><code>use GenServer

def start_link(_opts) do
  GenServer.start_link(__MODULE__, [], name: __MODULE__)
end

@impl true
def init(_opts \\ []) do
  index = ExFaiss.Index.new(384, &#34;IDMap,Flat&#34;)
  {:ok, index}
end</code></pre>
<p>When your GenServer starts, it will create a new Flat ExFaiss Index with dimensionality of 384. Next, add the following <code>add</code> client/server API to your GenServer:</p>
<pre><code>def add(id, embedding) do
  GenServer.cast(__MODULE__, {:add, id, embedding})
end

def handle_cast({:add, id, embedding}, index) do
  index = ExFaiss.Index.add_with_ids(index, embedding, id)
  {:noreply, index}
end</code></pre>
<p>Then, add the following <code>search</code> client/server API to your GenServer:</p>
<pre><code>def search(embedding, k) do
  GenServer.call(__MODULE__, {:search, embedding, k})
end

def handle_call({:search, embedding, k}, _from, index) do
  results = ExFaiss.Index.search(index, embedding, k)
  {:reply, results, index}
end</code></pre>
<p>Finally, add the <code>Sommelier.Index</code> to your supervision tree:</p>
<pre><code>[
  ...
  Sommelier.Index,
]</code></pre>
<p>Now, you can test that your index is working properly by restarting your application and adding a few dummy embeddings to the index, and then searching:</p>
<pre><code>iex&gt; embeds = Sommelier.Model.predict(&#34;a nice red wine&#34;)
iex&gt; Sommelier.Index.add(Nx.tensor([0]), embeds)
iex&gt; Sommelier.Index.search(embeds, 5)
%{
  distances: #Nx.Tensor&lt;
    f32[1][5]
    [
      [0.0, 3.4028234663852886e38, 3.4028234663852886e38, 3.4028234663852886e38, 3.4028234663852886e38]
    ]
  &gt;,
  labels: #Nx.Tensor&lt;
    s64[1][5]
    [
      [0, -1, -1, -1, -1]
    ]
  &gt;
}</code></pre>
<h2>Creating the Search Functionality and LiveView</h2>
<p>With your basic search and embedding infrastructure in place, you can go about creating the search LiveView. Create a file <code>lib/sommelier_web/search_live/index.ex</code>:</p>
<pre><code>defmodule SommelierWeb.SearchLive.Index do
  use SommelierWeb, :live_view

  @impl true
  def mount(_params, _session, socket) do
    {:ok, assign(socket, :results, [])}
  end
end</code></pre>
<p>Next, implement the following <code>render</code> function to render search results:</p>
<pre><code>@impl true
def render(assigns) do
  ~H&#34;&#34;&#34;
  &lt;div&gt;
    &lt;form name=&#34;wines-search&#34; id=&#34;wines-search&#34; phx-submit=&#34;search_for_wines&#34;&gt;
      &lt;label for=&#34;search&#34; class=&#34;block text-sm font-medium text-gray-700&#34;&gt;Quick search&lt;/label&gt;
      &lt;div class=&#34;relative mt-1 flex items-center&#34;&gt;
        &lt;input type=&#34;text&#34; name=&#34;query&#34; id=&#34;query&#34; class=&#34;block w-full rounded-md border-gray-300 pr-12 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm&#34;&gt;
        &lt;div class=&#34;absolute inset-y-0 right-0 flex py-1.5 pr-1.5&#34;&gt;
          &lt;kbd class=&#34;inline-flex items-center rounded border border-gray-200 px-2 font-sans text-sm font-medium text-gray-400&#34;&gt;⌘K&lt;/kbd&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/form&gt;
    &lt;ul role=&#34;list&#34; class=&#34;divide-y divide-gray-200&#34;&gt;
      &lt;li :for={result &lt;- @results}&gt;
        &lt;p class=&#34;text-sm font-medium text-gray-900&#34;&gt;
          &lt;a href={result.url}&gt;&lt;%= result.name %&gt;&lt;/a&gt;
        &lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &#34;&#34;&#34;
end</code></pre>
<p>Next, implement <code>handle_params/3</code> like this:</p>
<pre><code>@impl true
def handle_params(%{&#34;q&#34; =&gt; query}, _uri, socket) do
  results = Sommelier.Wines.search_wine(query)
  {:noreply, assign(socket, :results, results)}
end

def handle_params(_params, _uri, socket) do
  {:noreply, socket}
end</code></pre>
<p>This will look for query parameters in the URL and use the query to search for wines in the database using the unimplemented <code>search_wine/1</code> function. Finally, implement the following event handler to handle search submissions:</p>
<pre><code>def handle_event(&#34;search_for_wines&#34;, %{&#34;query&#34; =&gt; query}, socket) do
  {:noreply, push_patch(socket, to: ~p&#34;/search?q=#{query}&#34;)}
end</code></pre>
<p>Next, you need to implement the actual search functionality in your wine context, like this:</p>
<pre><code>def search_wine(query) do
  embedding = Sommelier.Model.predict(query)
  %{labels: labels} = Sommelier.Index.search(embedding, 5)

  labels
  |&gt; Nx.to_flat_list()
  |&gt; get_wines()
end

def get_wines(ids) do
  from(w in Wine, where: w.id in ^ids) |&gt; Repo.all()
end</code></pre>
<p>Finally, add the following route to your router:</p>
<pre><code>live &#34;/search&#34;, SearchLive.Index, :index</code></pre>
<p>Now if you navigate <code>localhost:4000/search</code> and type in a search, you’ll see the URL change, but no results! That’s because you haven’t actually added any wines to the database!</p>
<h2>Seeding the Database</h2>
<p>The wine dataset is based on the dataset from my original semantic search post. You can access the wine dataset from <a href="https://gist.github.com/seanmor5/af60a4a22dfc51250661380975281fa6">here</a>. Download the document and move it to the <code>priv</code> directory of your sommelier project. Next, add the following to <code>priv/repo/seeds.exs</code>:</p>
<pre><code>defmodule EmbedWineDocuments do
  def format_document(document) do
    &#34;Name: #{document[&#34;name&#34;]}\n&#34; &lt;&gt;
      &#34;Varietal: #{document[&#34;varietal&#34;]}\n&#34; &lt;&gt;
      &#34;Location: #{document[&#34;location&#34;]}\n&#34; &lt;&gt;
      &#34;Alcohol Volume: #{document[&#34;alcohol_volume&#34;]}\n&#34; &lt;&gt;
      &#34;Alcohol Percent: #{document[&#34;alcohol_percent&#34;]}\n&#34; &lt;&gt;
      &#34;Price: #{document[&#34;price&#34;]}\n&#34; &lt;&gt;
      &#34;Winemaker Notes: #{document[&#34;notes&#34;]}\n&#34; &lt;&gt;
      &#34;Reviews:\n#{format_reviews(document[&#34;reviews&#34;])}&#34;
  end

  defp format_reviews(reviews) do
    reviews
    |&gt; Enum.map(fn review -&gt;
      &#34;Reviewer: #{review[&#34;author&#34;]}\n&#34; &lt;&gt;
        &#34;Review: #{review[&#34;review&#34;]}\n&#34; &lt;&gt;
        &#34;Rating: #{review[&#34;rating&#34;]}&#34;
    end)
    |&gt; Enum.join(&#34;\n&#34;)
  end
end

&#34;priv/wine_documents.jsonl&#34;
|&gt; File.stream!()
|&gt; Stream.map(&amp;Jason.decode!/1)
|&gt; Stream.map(fn document -&gt;
  desc = EmbedWineDocuments.format_document(document)
  embedding = Sommelier.Model.predict(desc)
  {document[&#34;name&#34;], document[&#34;url&#34;], embedding}
end)
|&gt; Enum.each(fn {name, url, embedding} -&gt;
  Sommelier.Wines.create_wine(%{&#34;name&#34; =&gt; name, &#34;url&#34; =&gt; url, &#34;embedding&#34; =&gt; Nx.to_binary(embedding)})
end)</code></pre>
<p>Now, run <code>mix run priv/repo/seeds.exs</code> to add each wine to your database:</p>
<pre><code>mix run priv/repo/seeds.exs</code></pre>
<p>Note that this may run for a while depending on the machine you’re using.</p>
<p>Next, you need to ensure your database remains in sync with your wine index. You can do this by loading embeddings into the index on application startup. Adjust your <code>init/1</code> function in <code>Sommelier.Index</code> to look like this:</p>
<pre><code>def init(_opts \\ []) do
  index = ExFaiss.Index.new(384, &#34;IDMap,Flat&#34;)
  index =
    Sommelier.Wines.list_wines()
    |&gt; Enum.reduce(index, fn wine, index -&gt;
      embedding = wine.embedding
      id = wine.id
      ExFaiss.Index.add_with_ids(index, Nx.from_binary(embedding, :f32), Nx.tensor([id]))
    end)

  {:ok, index}
end</code></pre>
<p>This will load embeddings from the database when your application starts. Note that there are better ways to do this (e.g. by persisting snapshots of your index with native Faiss IO); however, this works well for simplicity.</p>
<h2>Running the Search</h2>
<p>With your database and index seeded with wines, restart your application and navigate to <code>localhost:4000/search</code>. Now, try running a few queries for wines. You’ll find that you can find excellent wine pairings just by describing what you’re looking for!</p>
<h2>Conclusion</h2>
<p>The Elixir ecosystem makes it easy to build machine-learning-enabled applications. This is a relatively simplistic example, but it’s still powerful! In about 15 minutes you have a working semantic search application, and you don’t need to use any external tools or services. </p>
<p>Until next time!</p>

</div>
    </div>
  </section></div>
  </body>
</html>
