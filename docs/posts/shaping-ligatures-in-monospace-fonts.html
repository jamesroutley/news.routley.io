<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joshleeb.com/posts/monospace-ligatures.html">Original</a>
    <h1>Shaping ligatures in monospace fonts</h1>
    
    <div id="readability-page-1" class="page"><article><p>Published on
<time datetime="2025-01-09">2025-01-09
</time>to <a href="https://joshleeb.com/">joshleeb&#39;s blog</a></p><p>For some time I’ve been working towards building a graphical code editor from
scratch. I’m still in the explorative phase of this project which involves
creating many small, <a href="https://git.sr.ht/~joshleeb/concepts">conceptual pieces</a> to better understand
the various problem spaces. The problem space I’m working through at the
moment is text rendering, with the current focus being shaping.</p><p>Shaping is the process of converting text (UTF-8 code points in our case) to a
sequence of glyphs with positional information to be rendered. It can get very
complex and computationally expensive. For more info take a look at the
<a href="https://harfbuzz.github.io">HarfBuzz Manual</a>.</p><p>You might think shaping for a code editor with a monospace font should be
trivial (hint: nothing with text rendering is trivial). The text is almost all
English with glyphs from the <a href="https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)">Basic Latin Unicode
block</a>. That means there are rarely diacritics or
other complex font structures. So we <em>should</em> be able to match every code
point to a single glyph, and each glyph has the same width as we’re working
with a monospace font.</p><p>With these simplifications you can go a long way with text rendering for a
basic code editor, that is, until you want to handle emojis (which also relies
on a font fallback subsystem) or ligatures.</p><h2 id="inspecting-the-glyphs">Inspecting the Glyphs</h2><p>For this post, we’ll be using the <a href="https://docs.rs/swash/latest/swash">swash</a> crate to provide us with a
shaping algorithm. We’ll also be using the monospace font <a href="https://www.monolisa.dev">MonoLisa</a>
which has ligature support, though similar behavior has also been observed
with <a href="https://github.com/tonsky/FiraCode">Fira Code</a>.</p><p>Now, let’s try shaping some ligatures and inspect the sequence of glyphs we
get back.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>for</span><span> </span>cluster<span> </span><span>in</span><span> </span>shape(<span>&#34;#{Q}&#34;</span>,<span> </span>Ligatures::Enabled)<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span>glyph<span> </span><span>in</span><span> </span>cluster.glyphs<span> </span>{<span>
</span></span></span><span><span><span>        </span>println!(<span>&#34;id: </span><span>{}</span><span>, name: </span><span>{}</span><span>&#34;</span>,<span> </span>glyph.id,<span> </span>glyph.name);<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// id: 0763, name: &#34;numbersign_braceleft.liga&#34;
</span></span></span><span><span><span>// id: 1252, name: &#34;LIGSPACE&#34;
</span></span></span><span><span><span>// id: 0129, name: &#34;Q&#34;
</span></span></span><span><span><span>// id: 0705, name: &#34;braceright&#34;
</span></span></span></code></pre></div><figcaption>Code 1. Glyph sequence from shaping the text &#34;#{Q}&#34;
with ligatures enabled.</figcaption><p>And we’ll compare this to the output when ligatures are disabled.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>for</span><span> </span>cluster<span> </span><span>in</span><span> </span>shape(<span>&#34;#{Q}&#34;</span>,<span> </span>Ligatures::Disabled)<span> </span>{<span> </span><span>..</span>.<span> </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// id: 0694, name: “numbersign”
</span></span></span><span><span><span>// id: 0704, name: “braceleft”
</span></span></span><span><span><span>// id: 0129, name: “Q”
</span></span></span><span><span><span>// id: 0705, name: “braceright”
</span></span></span></code></pre></div><figcaption>Code 2. Glyph sequence from shaping the text “#{Q}”
with ligatures disabled.</figcaption><p>From the glyph names it appears we are correctly receiving the ligature
“numbersign_braceleft” when ligatures are enabled. To be sure, let’s rasterize
glyph #763 to see what we get.</p><p><img src="https://joshleeb.com/posts/monospace-ligatures/fig1.png" alt=""/></p><figcaption>Figure 1. MonoLisa glyph #763.</figcaption><p>That looks good to me. But hold on… If this ligature is combining “#” and
“{” into a single glyph #763 representing “#{”, then shouldn’t we see an
output sequence of three glyphs, not four? What is this glyph “LIGSPACE”?</p><p>Inspecting the available glyph codes in Apple Font Book we see glyph #1251
and glyph #1253, but glyph #1252 is nowhere to be found.</p><p>Let’s see if we can determine what this glyph is in code. The swash
<a href="https://docs.rs/swash/latest/swash/shape/cluster/struct.GlyphCluster.html">GlyphCluster</a> has a very convenient <code>is_ligature</code>
function we can call. I expect that at least one of #763 and #1252 will be
identified as a ligature.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>for</span><span> </span>cluster<span> </span><span>in</span><span> </span>shape(<span>&#34;#{Q}&#34;</span>,<span> </span>Ligatures::Enabled)<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span>glyph<span> </span><span>in</span><span> </span>cluster.glyphs<span> </span>{<span>
</span></span></span><span><span><span>        </span>println!(<span>&#34;id: </span><span>{}</span><span>, is_lig: </span><span>{}</span><span>&#34;</span>,<span> </span>glyph.id,<span> </span>cluster.is_ligature());<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// id: 0763, is_lig: false
</span></span></span><span><span><span>// id: 1252, is_lig: false
</span></span></span><span><span><span>// id: 0129, is_lig: false
</span></span></span><span><span><span>// id: 0705, is_lig: false
</span></span></span></code></pre></div><figcaption>Code 3. Glyph sequence from shaping the text “#{Q}”
including `is_ligature` result.</figcaption><p>But that isn’t what we get. At this stage it’s not obvious how to handle the
“LIGSPACE” glyph, others like it, or even identify them in the first place.</p><p>As a quick aside, when I initially encountered this I thought it might be
specific to the shaping algorithm used by swash. I tried
[rustybuzz][rustybyzz] and inspecting the <a href="https://learn.microsoft.com/en-us/typography/opentype/spec/gdef">GDEF table</a> but got
effectively the same results. I also thought this might be specific to the
MonoLisa font, but all the same is true with Fira Code.</p><h2 id="how-ligatures-_should_-work">How Ligatures <em>Should</em> Work</h2><p>Perhaps this is just how monospace fonts handle ligatures. To get a better
idea let’s take a look at how ligatures are shaped for the Apple Color Emoji
proportional font.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>for</span><span> </span>cluster<span> </span><span>in</span><span> </span>shape_emoji(<span>&#34;</span><span>\u{1f3f3}\u{fe0f}\u{200d}\u{1f308}</span><span>&#34;</span>)<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span>glyph<span> </span><span>in</span><span> </span>cluster.glyphs<span> </span>{<span>
</span></span></span><span><span><span>        </span>println!(<span>&#34;id: </span><span>{}</span><span>, name: </span><span>{}</span><span>&#34;</span>,<span> </span>glyph.id,<span> </span>glyph.name);<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// id: 0967, name: “u1F3F3_u1F308”
</span></span></span></code></pre></div><figcaption>Code 4. Glyph sequence from shaping an emoji with
four UTF-8 code points.</figcaption><p>This works exactly as expected - the four UTF-8 code points get mapped to a
single glyph #967 which is rasterized to the correct image.</p><p><img src="https://joshleeb.com/posts/monospace-ligatures/fig2.png" alt=""/></p><figcaption>Figure 2. Apple Color Emoji glyph #967.</figcaption><p>If the expectation is that shaping a ligature will map multiple code points to
a single glyph then maybe we should be ignoring this “LIGSPACE” glyph. Even
though we don’t know how to reliably determine if a glyph is a ligature
spacer, I’ll hardcode skipping the glyph with id #1252 when rendering…</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>mut</span><span> </span>image<span> </span><span>=</span><span> </span>RgbaImage::new();<span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span>cursor<span> </span><span>=</span><span> </span><span>0.0</span>;<span>
</span></span></span><span><span><span></span><span>for</span><span> </span>cluster<span> </span><span>in</span><span> </span>shape(<span>&#34;#{Q}&#34;</span>,<span> </span>Ligatures::Enabled)<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span>glyph<span> </span><span>in</span><span> </span>cluster.glyphs<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span>glyph.id<span> </span><span>!=</span><span> </span><span>1252</span><span> </span>{<span>
</span></span></span><span><span><span>            </span>render(cluster,<span> </span><span>&amp;</span><span>mut</span><span> </span>image,<span> </span>cursor);<span>
</span></span></span><span><span><span>            </span>cursor<span> </span><span>+=</span><span> </span>glyph.advance;<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><figcaption>Code 5. Text rendering that skips the ligature spacer
glyph #1252.</figcaption><p>… which clearly produces the wrong output.</p><p><img src="https://joshleeb.com/posts/monospace-ligatures/fig3.png" alt=""/></p><figcaption>Figure 3. Incorrect render of “#{Q}” with ligatures
enabled.</figcaption><h2 id="correctly-handling-ligatures">Correctly Handling Ligatures</h2><p>From this experiment we know that the ligature spacer glyph has some
information we need to process and since we’re working with a monospace font
my best guess is it’s the horizontal advance. So we’ll update our loop to
accumulate the advance of all glyphs including #1252…</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>mut</span><span> </span>image<span> </span><span>=</span><span> </span>RgbaImage::new();<span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span>cursor<span> </span><span>=</span><span> </span><span>0.0</span>;<span>
</span></span></span><span><span><span></span><span>for</span><span> </span>cluster<span> </span><span>in</span><span> </span>shape(<span>&#34;#{Q}&#34;</span>,<span> </span>Ligatures::Enabled)<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span>glyph<span> </span><span>in</span><span> </span>cluster.glyphs<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span>glyph.id<span> </span><span>!=</span><span> </span><span>1252</span><span> </span>{<span>
</span></span></span><span><span><span>            </span>render(cluster,<span> </span><span>&amp;</span><span>mut</span><span> </span>image,<span> </span>cursor);<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>        </span>cursor<span> </span><span>+=</span><span> </span>glyph.advance;<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><figcaption>Code 6. Text rendering that skips rasterizing the
ligature spacer glyph #1252 but accumulates its advance.</figcaption><p>… which produces the output we’re looking for.</p><p><img src="https://joshleeb.com/posts/monospace-ligatures/fig4.png" alt=""/></p><figcaption>Figure 4. Correct render of &#34;#{Q}&#34; with ligatures
enabled.</figcaption><h2 id="identifying-ligature-spacers">Identifying Ligature Spacers</h2><p>Now that we have something working, we need to get rid of hardcoding the glyph
id. We will always get back false when inspecting if the glyph is a ligature
so it’s unclear what we’re meant to do to identify this case.</p><p>Actually though, it turns out that there is a more general solution that will
handle ligature spacers as well as any other glyph where rasterization should
be skipped. To illustrate this, let’s try to rasterize each glyph and inspect
the size of the produced image.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>for</span><span> </span>cluster<span> </span><span>in</span><span> </span>shape(<span>&#34;#{Q}&#34;</span>,<span> </span>Ligatures::Enabled)<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span>glyph<span> </span><span>in</span><span> </span>cluster.glyphs<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span>image<span> </span><span>=</span><span> </span>rasterize(glyph.id);<span>
</span></span></span><span><span><span>        </span>println!(<span>&#34;id: </span><span>{}</span><span>, dim: </span><span>{}</span><span>&#34;</span>,<span> </span>glyph.id,<span> </span>image.dimensions());<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// id: 0763, dim: 17x12
</span></span></span><span><span><span>// id: 1252, dim: 2x0
</span></span></span><span><span><span>// id: 0129, dim: 9x11
</span></span></span><span><span><span>// id: 0705, dim: 8x12
</span></span></span></code></pre></div><figcaption>Code 7. Glyph sequence from shaping the text &#34;#{Q}&#34;
including rasterization dimensions.</figcaption><p>Of course, the most interesting output is that glyph #1252 (our ligature
spacer) rasterizes to an empty image. What this means is that we don’t need to
identify and ignore ligature spacer glyphs specifically but rather any glyph
that has an empty rasterization.</p><h2 id="whats-going-on">What’s Going On</h2><p>Honestly, I’m not certain.</p><p>I’m not an expert with text rendering. I haven’t read the full <a href="https://learn.microsoft.com/en-us/typography/opentype/spec">OpenType
spec</a>, nor the Harfbuzz shaping algorithm. I’m not a font
creator. And when I searched all over the web to find answers (for ligatures
in monospace fonts specifically) I couldn’t find a thing.</p><p>However, going off these experimentations I can make an educated guess.</p><p>Let’s take a look at the advance width of each non-empty glyph, i.e. skipping
our ligature spacer glyph. The min X value of each blue box is the cursor
position and the width is the glyph’s horizontal advance width.</p><p><img src="https://joshleeb.com/posts/monospace-ligatures/fig5.png" alt=""/></p><figcaption>Figure 5. Advance-width boxes of glyphs for text “#{Q}” skipping
glyph #1252.</figcaption><p>Since we are working with a monospace font, every glyph must have the same
advance, but the glyph advance is too small for the ligature “#{”. To get
around this, it seems the font designers use the ligature spacer glyph which
can’t be rendered (with dimensions of 2 x 0 pixels) but will add to the
advance of the previous glyph.</p><p><img src="https://joshleeb.com/posts/monospace-ligatures/fig6.png" alt=""/></p><figcaption>Figure 6. Advance-width boxes of glyphs for text “#{Q}” including
glyph #1252.</figcaption><h2 id="wrapping-up">Wrapping Up</h2><p>Having come to this conclusion of how to handle ligature spacer glyphs in
monospace fonts, it all seems very logical and straight forward. I was,
however, surprised that I didn’t encounter an explanation of this given the
number of code editors, text editors, word processors, browsers, terminals,
and any other program that needs to shape and render text.</p><p>For anyone else undertaking their own text rendering journey, I hope this
helps make it a little bit easier. And for those with much more text
experience, if you know of any articles that either back up this educated
guess, or disprove it, please let me know.</p></article></div>
  </body>
</html>
