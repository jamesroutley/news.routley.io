<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://backbonenotbad.hyperclay.com/">Original</a>
    <h1>React vs. Backbone in 2025</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <h2>15 Years of Progress</h2>

        <p>
          Look at the two implementations above. The code is roughly the same length. They do exactly the same thing. One was written with a framework from 2010, the other with a framework that&#39;s had countless developer hours and a massive ecosystem behind it for over a decade.
        </p>

        <p>The interesting part is <b>not</b> how much better React is—it&#39;s how little progress we&#39;ve actually made.</p>

        <h3>The Illusion of Simplicity</h3>

        <p>
          React <em>looks</em> cleaner. It reads better at first glance. But that readability comes at a cost: you&#39;re trading explicit simplicity for abstraction complexity.
        </p>

        <p>
          The Backbone code is brutally honest about what it&#39;s doing. An event fires, a handler runs, you build some HTML, you put it in the DOM. It&#39;s verbose, sure, but there&#39;s no mystery. A junior developer can trace exactly what happens and when. The mental model is straightforward: &#34;when this happens, do this.&#34;
        </p>

        <p>
          The React code hides a lot. And once you move past simple examples, you hit problems that don&#39;t make sense until you understand React&#39;s internals.
        </p>

        <p>
          Your input mysteriously clears itself. Turns out you switched a list item&#39;s key from a stable ID to an index, so React thinks it&#39;s a completely different component and remounts it, wiping state. Or maybe you forgot that <code>value</code> can&#39;t be <code>undefined</code>—React saw it flip from uncontrolled to controlled and reset the input.
        </p>

        <p>
          You add a <code>useEffect</code> to fetch data, and suddenly your app is stuck in an infinite loop. The dependency array includes an object that gets recreated every render, so React thinks it changed and runs the effect again. Now you need <code>useMemo</code> and <code>useCallback</code> sprinkled everywhere to &#34;stabilize identities,&#34; which is a thing you never had to think about before.
        </p>

        <p>
          Your click handler sees old state even though you just set it. That&#39;s a stale closure—the function captured the value from when it was created, and later renders don&#39;t magically update it. You either need to put the state in the dependency array (creating a new handler every time) or use functional updates like <code>setState(x =&gt; x + 1)</code>. Both solutions feel like workarounds.
        </p>

        <h3>Magic Has a High Price</h3>

        <p>
          These aren&#39;t edge cases. They&#39;re normal problems you hit building moderately complex apps. And debugging them requires understanding reconciliation algorithms, render phases, and how React&#39;s scheduler batches updates. Your code &#34;just works&#34; without you needing to understand why it works, which is nice until it breaks.
        </p>

        <p>
          People say <a href="https://pomb.us/build-your-own-react/">&#34;you need to rebuild React from scratch to really understand it,&#34;</a> and they&#39;re right. But that&#39;s kind of damning, isn&#39;t it? You shouldn&#39;t need to understand virtual DOM diffing, scheduling priorities, and concurrent rendering to build a password validator.
        </p>

        <p>
          Backbone might be tedious, but it doesn&#39;t lie to you. jQuery is hackable. You can view source, understand it, and add to it easily. It&#39;s just DOM methods. React&#39;s abstraction layers make that much harder.
        </p>

        <h3>So, What&#39;s Next?</h3>

        <p>
          We understand the problem: <strong>event + state = UI</strong>. That&#39;s it. That&#39;s what both of these implementations are solving.
        </p>

        <p>
          For massive apps with 1,000 components on the same page, maybe React&#39;s complexity is justified. But what the other 99% of apps? What about small apps that just want to do a job and don&#39;t need all the magic?
        </p>

        <p>
          Is there a better model? Something feels as hard and steady as the DOM, but still feels intuitive to write? Something hackable like Backbone and jQuery were, where you can pop open devtools and understand what&#39;s happening?
        </p>

        <p>— <a href="https://panphora.com">panphora</a></p>
      </article>
    </div></div>
  </body>
</html>
