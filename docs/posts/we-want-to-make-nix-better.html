<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://determinate.systems/posts/we-want-to-make-nix-better">Original</a>
    <h1>We want to make Nix better</h1>
    
    <div id="readability-page-1" class="page"><div><div data-layout-label="Post Body" data-type="item" id="item-6310f4509c10b91b94094db3"><div><div><div data-block-type="2" id="block-d8bc0896d5e0218ac61b"><div><p><a href="https://nixos.org">Nix</a> is immensely powerful but it can have quite the steep learning curve. Numerous people in our industry hotly desire what Nix has to offer: hermetic development environments, fully reproducible package builds, declaratively configured operating systems. But even those who are aware of Nix’s benefits know that actually <em>using</em> Nix to solve real problems has some jagged edges. The Nix <a href="https://nixos.wiki/wiki/Overview_of_the_Nix_Language">expression language</a> is a bit odd coming from most other languages, the <a href="https://nixos.org/guides/how-nix-works.html">core concepts</a> aren’t always super digestible, the <a href="https://nixos.org/manual/nix/stable/package-management/basic-package-mgmt.html">package manager</a> is unlike apt, deb, Homebrew and the rest—all in all, it’s just a different paradigm of doing things that requires a substantial investment of time and energy.</p><p>At <a href="https://determinate.systems">Determinate Systems</a>, we <em>love</em> Nix, but to those who don’t love it enough to make that investment: we hear you. Many folks in software engineering, even some seasoned Nix veterans, feel that Nix’s sterling feature set often comes at too high a cost. It’s easy enough to convince your team or your boss that Nix <em>could</em> have a transformative impact, but convincing people to commit the resources to adopt Nix is another matter. Other tools and approaches may be good enough to get the job done well enough and call it a day; best to stick with a just-okay but known quantity. For those who are passionate about Nix, this can be a tough pill to swallow.</p><h3>Our mission</h3><p>We’re confident that we can break this impasse. Our objective at Determinate Systems is to enable people across the software world to reap the many benefits of Nix without nearly as much effort—and occasional pain—as Nix has demanded in the past. In some cases, that will mean that we improve the experience of using Nix itself by contributing to the Nix ecosystem. But in other cases it will mean giving users access to Nix’s wonderful features without requiring them to use it directly, letting Nix quietly do its vital work in the background while exposing few if any internals.</p><p>We love Nix because it solves a wide range of problems with aplomb. Those who have used it directly—to build a package, to configure a <a href="https://nixos.org">NixOS</a> system, to create a development environment—have a keen sense of its power. But we know that it isn’t reasonable to make learning and struggling with Nix a condition of benefiting from it. All programming languages and paradigms require an investment, but Nix is meant to <em>facilitate</em> software development, not be the center of attention. It’s supposed to help you write, distribute, and deploy <a href="https://rust-lang.org">Rust</a>, <a href="https://go.dev">Go</a>, <a href="https://python.org">Python</a>, <a href="https://javascript.com">JavaScript</a>, and others. Helping those who have already invested in Nix is very much part of our mission—but so is helping those who want a better way to ship software without taking on a new learning project.</p><h3>A representative problem</h3><p>Let’s make this more concrete by talking about a specific problem that we’re currently looking into: the problem of <em>external dependencies</em>. These are dependencies that are written in a different language from the one you’re currently developing in. Some examples: the <a href="https://developers.google.com/protocol-buffers">Protobuf</a> compiler, <code>protoc</code>, is a problem in <a href="https://rust-lang.org">Rust</a> projects because it’s written in C++; <a href="https://nokogiri.org">Nokogiri</a> is a problem in Ruby projects because it’s written in C; and <a href="https://openssl.org">OpenSSL</a> presents a problem in all kinds of languages. Ideally we’d all be able to <code>git clone</code> and <code>cd</code> into any software project and immediately start building and testing, but we all know the experience of Googling and StackOverflowing just to get off the ground.</p><p>Fortunately, the external dependency problem already has a solution: <strong>Nix</strong>! You can use Nix to configure a <a href="https://nixos.wiki/wiki/Development_environment_with_nix-shell">shell environment</a> with all the necessary dependencies installed. A Python project that requires OpenSSL? No problem. A Haskell project that requires <a href="https://asciidoc.org">Asciidoc</a>? No problem. Need to share those environments across teams and port them to your continuous integration system? No problem.</p><p>But there’s a catch: to make that happen you need to write some Nix, use Nix tools, and probably consult several documentation sources. If you’re already using Nix to solve external dependency problems, great! You’re in good company. But this is the kind of problem we want to solve for people who don’t have the bandwidth or the desire to learn Nix.</p><h3>Where we go from here</h3><p>The external dependency problem is far from alone. It’s part of a vast constellation of interrelated problems that make developing, distributing, and deploying software much more brittle, complicated, and resource intensive than they should be. In Nix, we as an industry have <em>the</em> tool to take an enormous chunk out of these kinds of problems. At Determinate Systems, we’re committed to being a major driving force behind this. We’ll have some specific—and exciting—announcements about our approach to the external dependency problem—amongst others—very soon, so stay tuned here on our <a href="https://determinate.systems/posts">blog</a>, in the <a href="https://github.com/DeterminateSystems">DeterminateSystems</a> GitHub organization, and <a href="https://twitter.com/DeterminateSys">on Twitter</a>.</p>


</div></div></div></div></div></div></div>
  </body>
</html>
