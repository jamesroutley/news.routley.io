<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.netmeister.org/blog/dns-size.html">Original</a>
    <h1>What’s the maximum size of a DNS response?</h1>
    
    <div id="readability-page-1" class="page"><div width="75%">
    <tbody><tr>
      <td>
<p><small>July 17th, 2022</small></p>

<p>Pop quiz: What is the maximum number of <tt>A</tt> records in a
DNS round robin?  Or the largest number of bytes in a
<tt>TXT</tt> record?  Maybe it&#39;s all the same, and we should
ask what is the maximum size of a DNS response? Is
it...</p>
<ul>
<li>512 bytes</li>
<li>1232 bytes</li>
<li>65536 bytes</li>
<li>&#34;It depends.&#34;</li>
</ul>

<p>Let&#39;s find out.  The answer is, as all things
involving the DNS, entertaining.</p>

<h3><a name="512"></a>512 bytes?</h3>

<p>
Now just about every website on this here internet
will tell you that the DNS uses UDP port 53, and that
any response must fit into a single 512 byte UDP
packet, and of course that answer is right.  Except
when it isn&#39;t.  But let&#39;s start with that assumption
and see how much data we can then fit into a single
512 byte response:</p>

<p>Most people care about <a href="https://www.netmeister.org/blog/dns-rrs.html#a">A
records</a>, so let&#39;s create a DNS round-robin
response with as many IPv4 addresses as will fit into
a single 512-byte UDP response.
</p>

<div><pre>$ dig +noall +answer +comments @166.84.7.99 512.size.dns.netmeister.org a
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 34695
;; flags: qr aa rd; QUERY: 1, ANSWER: <span>28</span>, AUTHORITY: 0, ADDITIONAL: 1

;; ANSWER SECTION:
512.size.dns.netmeister.org. 209 IN     A 127.0.0.2
512.size.dns.netmeister.org. 209 IN     A 127.0.0.10
512.size.dns.netmeister.org. 209 IN     A 127.0.0.19
512.size.dns.netmeister.org. 209 IN     A 127.0.0.18
512.size.dns.netmeister.org. 209 IN     A 127.0.0.23
512.size.dns.netmeister.org. 209 IN     A 127.0.0.1
[...]
</pre></div>

<p>This returned <span>28</span> A records.  So far, so good.  But 28
IPv4 addresses is only <tt>28 * 4 bytes = 112
bytes</tt>.  Shouldn&#39;t we have been able to add
a whole bunch of IPv4 addresses more?</p>

<p>Let&#39;s take a look at what the packets actually look like,
using <tt>tcpdump(1)</tt>:</p>

<div><pre>$ tcpdump -n -t -r /tmp/out.pcap
reading from PCAP-NG file /tmp/out.pcap
IP 172.16.1.22.62634 &gt; 166.84.7.99.53: 31626+ [1au] A? 512.size.dns.netmeister.org. (56)
IP 166.84.7.99.53 &gt; 172.16.1.22.62634: 31626 <span>28</span>/0/1 A 127.0.0.10, A 127.0.0.8,
        A 127.0.0.1, A 127.0.0.19, A 127.0.0.22, A 127.0.0.6, A 127.0.0.16,
        A 127.0.0.12, A 127.0.0.13, A 127.0.0.18, A 127.0.0.7, A 127.0.0.3,
        A 127.0.0.14, A 127.0.0.15, A 127.0.0.21, A 127.0.0.27, A 127.0.0.24,
        A 127.0.0.5, A 127.0.0.20, A 127.0.0.9, A 127.0.0.0, A 127.0.0.17,
        A 127.0.0.23, A 127.0.0.4, A 127.0.0.26, A 127.0.0.25, A 127.0.0.11,
        A 127.0.0.2 (<span>504</span>)
</pre></div>

<p>We easily see we are able to squeeze it all into a
single UDP packet, which gives us the above mentioned
<span>28</span>
<tt>A</tt> records stuffed into <span>504</span> bytes.</p>

<p>Wait, <em>504</em> bytes?  What happened to the
<tt>28 * 4 = 112</tt> bytes calculation?  Let&#39;s dig
deeper, this time using <a href="https://www.wireshark.org">Wireshark</a>:</p>

<center><img src="https://www.netmeister.org/blog/images/dns/512.png" alt="Wireshark for
512.size.dns.netmeister.org" width="600"/></center>

<p>Ok, so there&#39;s a bit more overhead in the DNS
packet, where for every answer record we have at least
12 additional bytes.  Compare to the wire format from
<a href="https://datatracker.ietf.org/doc/html/rfc1035#section-3.2.1">RFC1035</a>,
DNS message (identical for query and response) on the
left and the RR format on the right:</p>

<table>
<tbody><tr>
<td>
<div><pre>                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| transaction id (2 bytes)      | flags (2 bytes)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| # of questions (2 bytes)      | # of answers (2 bytes)        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| # of authority RRs (2 bytes)  | # of additional RRs (2 bytes) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                           questions                           /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                           answer RRs                          /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                         authority RRs                         /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                         additional RRs                        /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
</td>
<td>
<div><pre>                     1 1 1 1 1 1
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |
|                               |
/             name              /
|                               |
|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             type              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             class             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              ttl              |
|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            rdlength           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |
|                               |
/             rdata             /
/                               /
|                               |
|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
</td>
</tr>
</tbody></table>

<p>That is, every complete DNS response has:</p>
<ul>
<li>12 bytes DNS header</li>
<li>a few bytes for the query</li>
<li>for every <tt>A</tt> record:</li><li>possibly additional bytes for additional records</li>
</ul>

<p> The query for <tt>512.size.dns.netmeister.org</tt>
comes out to <tt>strlen(&#34;512.size.dns.netmeister.org&#34;)
+ 1 byte NULL + 1 byte numlabels + 2 bytes type + 2
bytes class = 33 bytes</tt>; our DNS server also
returns 11 bytes of additional records (more on that
below), and each <tt>A</tt> record answer will be 16
bytes, so we get to <tt>12 + 33 + (28 * 16) + 11 =
504</tt> bytes.</p>

<p>So that&#39;s why we had 28 <tt>A</tt> records: if we had
one more <tt>A</tt> record, we&#39;d need to add 16 more
bytes and then yield 520 bytes.</p>

<h3><a name="513"></a>More than 512 bytes?</h3>

<p>But what if we add more <tt>A</tt> records?  Let&#39;s
try to use a record that&#39;d be just under 1024
bytes:</p>

<div><pre>$ sudo tcpdump -w /tmp/out.pcap port 53 2&gt;&amp;/dev/null &amp;
$ dig +short @166.84.7.99 1024.size.dns.netmeister.org a | wc -l
      60
$ fg
^C
$ tcpdump -t -r /tmp/out.pcap
IP 172.16.1.22.62299 &gt; 166.84.7.99.53: 19287+ [1au] A? 1024.size.dns.netmeister.org. (57)
IP 166.84.7.99.53 &gt; 172.16.1.22.62299: 19287*- <span>60</span>/0/1 A 127.0.0.12, A 127.0.0.47, A 127.0.0.56,
        A 127.0.0.33, A 127.0.0.28, A 127.0.0.1, A 127.0.0.36, A 127.0.0.48,
        A 127.0.0.52, [...] 127.0.0.49, A 127.0.0.59 (<span>1017</span>)
</pre></div>

<p>Okay, so with <span>60</span> <tt>A</tt> records (<span>1017</span> bytes)
returned here, clearly we can have a response &gt; 512
bytes and still get it back in a single UDP packet.
But doesn&#39;t that contradict just about every lesson in
your CS curriculum?  How did we do that?</p>

<p>Enter <a href="https://en.wikipedia.org/wiki/Extension_Mechanisms_for_DNS">EDNS(0)</a>,
currently specified in <a href="https://datatracker.ietf.org/doc/html/rfc6891">RFC6891</a>.
Since a 512 byte UDP packet limit (which needs to
account for all the other protocol headers) only
allows for really small amounts of data, and since
adding especially additional records such as those
needed for DNSSEC to a response may increase the DNS
result size, it is useful for clients to be able to
tell a DNS resolver that it can actually accept
more octets.</p>

<p>This is done via a pseudo-RR of type <tt>OPT</tt>.
In our query, we can set this explicitly via the
<tt>+bufsize=4096</tt> option to <tt>dig(1)</tt>; the
result looks like so:</p>

<center><img src="https://www.netmeister.org/blog/images/dns/1024-query.png" alt="Wireshark for query for
1024.size.dns.netmeister.org, showing EDNS(0) OPT" width="600"/></center>

<p>Neat!  So we should be able to get much larger
results, right? Let&#39;s give that a try, querying for a
response that fits into 2048 bytes, clearly well below
the 4096 UDP payload size we advertized.  Since we
expect this to fit into a single UDP packet, we can
pass <tt>+ignore</tt> to <tt>dig(1)</tt>.  But:</p>

<div><pre>$ dig +ignore +bufsize=4096 +noall +comments @166.84.7.99 2048.size.dns.netmeister.org 
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 28512
;; flags: qr aa <span>tc</span> rd; QUERY: 1, ANSWER: 123, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: <span>1232</span>
</pre></div>

<p>We are not getting any results, and instead notice
that our response has the <span>tc</span> flag set,
indicating it was truncated.  If we then repeat the
same command without <tt>+ignore</tt>, we then see
<tt>dig(1)</tt> dutifully repeat the query using TCP
when it encounters the <a href="https://www.netmeister.org/blog/images/dns/2048-truncated.png">truncated</a>
bit:</p>

<center><img src="https://www.netmeister.org/blog/images/dns/2048-truncated.png" alt="Wireshark for query for
2048.size.dns.netmeister.org, showing retry via TCP" width="600"/></center>

<p>But why do we get a truncated response when we had
asked for 4096 bytes payload size via EDNS(0)?
Looking at the Additional RR, it seems
the server had <em>its</em> UDP payload buffer size set to
<span>1232</span>
bytes.  But what kind of whacky number is that?</p>

<p>Well, turns out it&#39;s not quite as arbitrary as it
may seem.  Given that we want to <a href="https://web.archive.org/web/20191225071857/https://u.cs.biu.ac.il/~herzbea/security/13-03-frag.pdf">avoid
packet fragmentation</a> along the way from the
resolver to the client, we are looking to establish a
reasonable guess for the most common Maximum
Transmission Unit (MTU) for the networks our packets
might cross.  That number is <a href="https://blog.benjojo.co.uk/post/why-is-ethernet-mtu-1500">rather
commonly</a> 1500 bytes (in part because <a href="https://en.wikipedia.org/wiki/Ethernet_frame#Ethernet_II">Ethernet
II</a> uses 1500 byte frames, and
measurements done by <a href="https://indico.dns-oarc.net/event/36/contributions/776/attachments/754/1277/DefragDNS-Axel_Koolhaas-Tjeerd_Slokker.pdf">researchers
Axel Koolhaas and Tjeerd Slokker</a> confirmed this
size).</p>

<p>For IPv6 we have a mandated minimum size of 1280
bytes, so we are going to be conservative and use
that.  Subtracting the 40 bytes length of the IPv6
header and 8 bytes UDP header, we end up with 1232
bytes as the recommended default UDP payload size.
And that is indeed the size widely implemented since
<a href="https://dnsflagday.net/2020/">DNS Flag Day
2020</a>.</p>

<p>But what if we bump our UDP payload buffer size on
the DNS server?  With <tt>bind</tt>, that looks like
so:</p>

<div><pre>options {
        edns-udp-size 4096;
        max-udp-size 4096;
};
</pre></div>

<p>...and then we can indeed stuff the entire response
into a single UDP packet:</p>

<center><img src="https://www.netmeister.org/blog/images/dns/edns0-4096.png" alt="Wireshark for
2048.size.dns.netmeister.org with EDNS0 4096" width="600"/></center>

<p>This packet capture also shows us why it might not
be a good idea to set the EDNS UDP size so large: we
can see that our packet <em>did</em> get fragmented in
between the server and the client.  If you look at the
first answer packet, you should see the &#34;more
fragments&#34; flag set - no good, since fragmented UDP
DNS responses <a href="https://blog.powerdns.com/2018/09/10/spoofing-dns-with-fragments/">can
be spoofed</a> (<a href="https://blog.apnic.net/2019/07/12/its-time-to-consider-avoiding-ip-fragmentation-in-the-dns/">see
also</a>)!  So let&#39;s stick with 1232 as
recommended.</p>

<h3><a name="65536"></a>65536 bytes?</h3>

<p>Ok, so we can play around a bit with EDNS0 to avoid
truncation and retry over TCP, but once we <em>do</em>
retry using TCP, how many records can we return?</p>

<p>We saw that <tt>2048.size.dns.netmeister.org</tt>
returned 123 <tt>A</tt> records.  Let&#39;s try incrementing the
number of <tt>A</tt> records we return and see how many bytes
we can transmit:</p>

<div><pre>$ dig +short @166.84.7.99 256-a.size.dns.netmeister.org a | wc -l
     256
# 4156 bytes in total
$ dig +short @166.84.7.99 512-a.size.dns.netmeister.org a | wc -l
     512
# 8252 bytes in total
$ dig +short @166.84.7.99 1024-a.size.dns.netmeister.org a | wc -l
    1024
# 16445 bytes in total
$ dig +short @166.84.7.99 2048-a.size.dns.netmeister.org a | wc -l
    2048
# 32829 bytes in total
$ dig +short @166.84.7.99 4096-a.size.dns.netmeister.org a | wc -l
    0
$ </pre></div>

<p>Ok, so with all the overhead per record as well as
for the response and additional records, we can at
least get 2048 <tt>A</tt> records returned in just over 32K
bytes.  But why can&#39;t we do 4096 <tt>A</tt> records?  Let&#39;s see
what happens in the packet capture:</p>

<center><img src="https://www.netmeister.org/blog/images/dns/4096-a-truncated.png" alt="Wireshark for
4096.size.dns.netmeister.org showing TCP truncated" width="600"/></center>

<p>The first response via UDP is, no surprise,
truncated, so we retry via TCP.  But now the DNS
result delivered via TCP is <em>also</em> truncated!
That is, the DNS server has determined that the result
will not fit into the maximum response size.  Why is
that?</p>


<p>Our payload is <tt>4096 * 16 = 65536</tt> bytes
<tt>RDATA</tt>, which should fit into the DNS packet,
which uses a two byte <tt>RDLENGTH</tt> field.  But we
also need to again account for the overhead noted
above:   12 bytes DNS header, 36 bytes for the query,
11 bytes additional records, and 16 bytes for each
<tt>A</tt> record, yielding <tt>(4096 * 16) + 12 + 36
+ 11 = 65595</tt> bytes in total.  And the maximum
size of an <em>IP</em> packet is 16 bit (via the IPv4
total length / IPv6 payload length).  And
<em>that</em> is now our limiting factor: 65536 bytes
for DNS overhead + payload.</p>

<p>(&#34;<em>What about jumbo frames?</em>&#34; That doesn&#39;t
really buy us anything, either, because <em>TCP</em>
itself is <em>also</em> limited to 16 bits, albeit
semi-indirectly via the 16-bit urgent pointer, so
we&#39;re still restricted to 65536 bytes there as
well.)</p>

<p>So the maximum number of A records we can stuff
into a response needs to be smaller than 65536 bytes
to account for the overhead.  Here, let&#39;s give this
one a try:</p>

<div><pre>$ dig +short @166.84.7.99 max.size.dns.netmeister.org a | wc -l
        4092
$ </pre></div>

<p>With 4092 A records and all overhead accounted for,
this gives us a DNS response in 65530 bytes, with a
cushy 6 bytes left to spare.  So the answer to the
question &#34;<em>How many A records can you put into a DNS
round-robin?</em>&#34;, depending on the length of the
query, hovers somewhere below 4K, it seems.  (Not that
I&#39;d advocate  using such a large round-robin.)</p>

<h3><a name="txt"></a>TXT limits</h3>

<p>But can we max out the full 64K theoretical size?
Maybe using a <tt>TXT</tt> record?  Let&#39;s try.</p>

<p><a href="https://datatracker.ietf.org/doc/html/rfc1035">RFC1035</a>
limits the size of a <em>name</em> in the DNS to 255
octets, so that doesn&#39;t seem to get us anywhere.  But
then again, we actually can have multiple names for a
single RR, can&#39;t we?  That is different from having
multiple RRs of the same type.  Compare:</p>

<div><pre>$ dig +short @166.84.7.99 one.size.dns.netmeister.org txt
&#34;one&#34; &#34;one&#34;
$ dig +short @166.84.7.99 two.size.dns.netmeister.org txt
&#34;two&#34;
&#34;one&#34;
$ </pre></div>

<p>Note that in the first case we are getting back one
DNS answer record with two strings, in the second, we
get two answer records.  (Compare the two wireshark
captures: <a href="https://www.netmeister.org/blog/images/dns/one.png">one</a>, <a href="https://www.netmeister.org/blog/images/dns/two.png">two</a>)  That is, we can
create larger TXT records by using multiple names.
How large?  Let&#39;s see:</p>

<div><pre>$ dig +short @166.84.7.99 txt510.size.dns.netmeister.org txt
&#34;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#34;
&#34;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#34;
$ dig +short @166.84.7.99 txt1020.size.dns.netmeister.org txt
&#34;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
[...]
$ dig +short @166.84.7.99 txt2040.size.dns.netmeister.org txt | tr -d &#39;[&#34; \n]&#39; | wc -c
        2040
$ dig +short @166.84.7.99 txt4080.size.dns.netmeister.org txt | tr -d &#39;[&#34; \n]&#39; | wc -c
        4080
$ dig +short @166.84.7.99 txt8160.size.dns.netmeister.org txt | tr -d &#39;[&#34; \n]&#39; | wc -c
        8160
$ dig +short @166.84.7.99 txt16320.size.dns.netmeister.org txt | tr -d &#39;[&#34; \n]&#39; | wc -c
       16320
$ dig +short @166.84.7.99 txt32640.size.dns.netmeister.org txt | tr -d &#39;[&#34; \n]&#39; | wc -c
       32640
$ dig +short @166.84.7.99 max.size.dns.netmeister.org txt | tr -d &#39;[&#34; \n]&#39; | wc -c
       65211
$ </pre></div>

<p>Doubling the payload at every step, things make
sense up until 32640.  Doubling again would yield
65280 bytes payload, which would again go over the 64K
absolute max we discussed above.  So we need to 
trim the last string and we can create the TXT record
for <tt>max.size.dns.netmeister.org</tt> delivering
65211 bytes payload.</p>

<h3><a name="txt2"></a>More TXT limits</h3>

<p>So that&#39;s the observed limit for a single TXT
record for this name, but what is the size limitation
on multiple TXT records?  If each TXT record is 255
bytes in length, and we account for the 13 bytes
overhead per TXT record (2 bytes name + 2 bytes type +
2 bytes class + 4 bytes TTL + 2 bytes data length + 1
byte text length), then we can have 244 TXT records
with 255 characters each (<tt>244 * (255 + 13)</tt>)
plus 1 TXT record with 72 characters (<tt>72 +
13</tt>) plus the previously observed overhead:</p>

<div><pre>$ dig +short @166.84.7.99 txts.size.dns.netmeister.org txt | wc -l
     245
$ </pre></div>

<p>But how many TXT records could we have if we put
only a few bytes into each?  Each TXT record must be
unique, so for simplicity&#39;s sake I picked four bytes
per TXT record, which then leads me to:</p>

<div><pre>$ dig +short @166.84.7.99 smalltxts.size.dns.netmeister.org txt | wc -l
    3851
$ </pre></div>

<h3><a name="others"></a>Other resolvers</h3>

<p>Now one of the things in all of this above is that
chances are that you&#39;ll observe different results if
you query your local resolver.  This is the beauty of
troubleshooting the DNS: different people will observe
different results based on a number of aspects of the
network or the resolver in question, none of which are
immediately obvious.  This is why in all of the above
<tt>dig(1)</tt> commands, I&#39;ve always directly
specified the authoritative nameserver responsible for
the domain.</p>

<p>What kind of differences might we see, and why are
there differences?  Let&#39;s take a look:</p>

<p>To compare results from different public resolvers,
I&#39;ve previously put together a <a href="https://github.com/jschauma/puddy">command-line
tool</a> and online <a href="https://www.netmeister.org/puddy/">service</a>.  If
you try out e.g., lookup up the <a href="https://www.netmeister.org/puddy/index.cgi?name=1024.size.dns.netmeister.org&amp;type=A&amp;format=html"><tt>A</tt>
records for <tt>1024.size.dns.netmeister.org</tt></a>,
most resolvers give you the same results, but for
other queries you may see <tt>SERVFAIL</tt> and
connection time outs.</p>

<p>To understand why that is, remember that our DNS
server may return additional records under certain
circumstances.  Normally, additional records are
dropped by the server if they do not fit into the
response, but in some cases, the additional records
are required: if you request DNSSEC validation in your
query, then for every result, the DNS server needs to
also serve the <tt><a href="https://www.netmeister.org/blog/dns-rrs.html#rrsig">RRSIG</a></tt> record, which
adds more bytes to the response.</p>

<p>So if the result is already near the max (65536
bytes), then adding a 119 byte additional RRSIG record
will lead the server to truncating the reply even over
TCP:</p>

<div><pre>$ dig @166.84.7.99 max.size.dns.netmeister.org | wc -l
    4092
$ dig <span>+dnssec</span> +noall +comment @166.84.7.99 max.size.dns.netmeister.org 
<span>;; Truncated, retrying in TCP mode.</span>
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 749
;; flags: qr aa <span>tc</span> rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags: do; udp: 1232
$ </pre></div>

<p>This is why you&#39;ll see e.g., results from asking
Google&#39;s public DNS resolvers return <tt>SERVFAIL</tt>
or <tt>time out</tt>: they enable DNSSEC by default
and thus receive a larger response than if you query
directly without <tt>+dnssec</tt>.  Likewise, some
public resolvers may include an <a href="https://en.wikipedia.org/wiki/EDNS_Client_Subnet">EDNS
Client Subnet</a> (ECS) option, which again adds additional
bytes to the result.</p>

<p>You may also observe some enterprise software
attempting to protect your device from malicious DNS
lookups make flawed assumptions about DNS traffic over
TCP or monkey around with EDNS(0) or otherwise
interfere in uneducated ways.  Middle-boxes and
firewalls may make all sorts of mistakes here and drop
packets.  Good times, good times.
</p>

<hr/>

<h3>Summary</h3>

<p>Alright, that was a fun little rabbit hole to fall
down.  But I think the main takeaways are that the
often repeated mantra of &#34;<em>your DNS response needs
to fit into the 512 byte UDP packet</em>&#34; is simply
not -- or at least no longer -- a universal truth.
Failover to TCP is at least theoretically understood
as taking place by most engineers, but the actual
maximum sizes, EDNS(0) and fragmentation, and how
DNSSEC, label length, and possibly other factors such
as e.g., ECS extensions influence the practical limit
are far from obvious.</p>

<p>As always, the DNS is more fun than a barrel of
monkeys.  Although that depends on your definition of
&#34;fun&#34;.  And your monkeys.  But I <tt>dig(1)</tt> it,
and remember, when in doubt: <a href="https://ops-lessons.creator-spring.com/listing/new-pcap-or-it-didn-t-happen?product=663">pcap
or it didn&#39;t happen</a>!</p>

<p><small>July 17th, 2022</small></p>

<hr/>

<p><small>Links:</small></p>

<ul>
<li><small><a href="https://raw.githubusercontent.com/jschauma/dns-rrs/main/bind/size.dns.netmeister.org">bind zone file for all examples</a></small></li>
<li><small><a href="https://twitter.com/jschauma/status/1548845116370059264">This blog post as a Twitter thread</a></small></li>
<li><small><a href="https://news.ycombinator.com/item?id=32254434">Discussion on HackerNews</a></small></li>
<li><small><a href="https://lobste.rs/s/exi4ws">Discussion on Lobste.rs</a></small></li>
<li><small><a href="https://www.netmeister.org/blog/dns-rrs.html">(All) DNS Resource Records</a></small></li>
<li><small><a href="https://www.netmeister.org/blog/dns-tcpdump.html">DNS tcpdump by example </a></small></li>
<li><small><a href="https://www.netmeister.org/puddy/">Compare public DNS resolver results</a></small></li>
<li><small><a href="https://dnsflagday.net/">DNS Flag Day</a></small></li>
<li><small><a href="https://labs.apnic.net/?p=1380">DNS XL</a></small></li>
<li><small><a href="https://web.archive.org/web/20191225071857/https://u.cs.biu.ac.il/~herzbea/security/13-03-frag.pdf">Fragmentation Considered Poisonous</a></small></li>
<li><small><a href="https://blog.powerdns.com/2018/09/10/spoofing-dns-with-fragments/">Spoofing DNS with fragments</a></small></li>
<li><small><a href="https://blog.apnic.net/2019/07/12/its-time-to-consider-avoiding-ip-fragmentation-in-the-dns/">It’s time to consider avoiding IP fragmentation in the DNS</a></small></li>
</ul>

      </td>
    </tr>
  </tbody></div></div>
  </body>
</html>
