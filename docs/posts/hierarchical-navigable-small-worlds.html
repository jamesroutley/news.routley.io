<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zilliz.com/blog/hierarchical-navigable-small-worlds-HNSW">Original</a>
    <h1>Hierarchical Navigable Small Worlds</h1>
    
    <div id="readability-page-1" class="page"><div><div><hr/>
<p>In the previous tutorial, we took a look at <a href="https://zilliz.com/blog/scalar-quantization-and-product-quantization">scalar quantization and product quantization</a> - two indexing strategies which are used to reduce the overall <em>size</em> of the database without reducing the scope of our search. To better illustrate how scalar quantization and product quantization works, we also implemented our own versions in Python.</p>
<p>In this tutorial, we&#39;ll build on that knowledge by looking at today&#39;s most commonly used primary algorithm: Hierarchical Navigable Small Worlds (HNSW). HNSW performs very well regarding speed and accuracy, making it an incredibly robust vector search algorithm. Unfortunately, despite being popular, understanding HNSW can be tricky, but don&#39;t fret - in the next couple of sections, we&#39;ll break down HNSW into its steps, developing our own simple implementation along the way.</p>
<p>Recall from a previous tutorial that there are four types of vector search indexes: hash-based, tree-based, cluster-based, and graph-based. HNSW fits firmly into the lattermost, combining two core concepts - the <em>skip list</em> and <em>Navigable Small World</em> (NSW). Let&#39;s first dive into these two concepts individually before discussing HNSW.</p>
<p><strong>Skip list overview</strong></p>
<p>First up: skip lists. Recall the venerable linked list - a well-known data structure where each element maintains a pointer for the next element. Although linked lists work great for implementing LIFO and FIFO data structures such as stacks and queues, a major downside is their time complexity regarding random access: <code>O(n)</code>. Skip lists aim to solve this problem by introducing additional layers, allowing for <code>O(log n)</code> random access time complexity by incurring extra memory (<code>O(n log n)</code> space complexity as opposed to <code>O(n)</code> for a normal linked list) and a bit of runtime overhead for inserts and deletes.</p>
<p>A skip list is a multi-level linked list where the upper levels maintain long connections. As we move down the layers, the connections become shorter and shorter, with the bottommost layer being the &#34;original&#34; linked list containing all of the elements. The image below illustrates this:</p>
<p>
      <span>
        <a href="https://assets.zilliz.com/skip_list_c08b630b31.png" title="skip_list.png" target="_blank"><img src="https://assets.zilliz.com/skip_list_c08b630b31.png" alt="skip_list.png" id="skip_list.png"/></a>
        <span>skip_list.png</span>
      </span>
    </p>
<p><sub>The skip list, illustrated. Higher layers have fewer elements.</sub></p>
<p>We start at the highest layer to reach element <code>i</code> in a skip list. Once we find a node corresponding to an element in the list greater than <code>i</code>, we backtrack to the previous node and move to the layer below. This continues until we&#39;ve found the element we&#39;re looking for. Note that skip lists only work for sorted lists, as we need a way to compare the magnitude of two objects directly.</p>
<p>Inserts work probabilistically. For any new element, we first need to figure out the layer with which the element appears first. The uppermost layer has the lowest probability, increasing probability as we move down in layers. The general rule is that any element in a layer will appear in layer above it with some pre-defined probability <code>p</code>. Therefore, if an element first appears in some layer <code>l</code>, it will also get added to layers <code>l-1</code>, <code>l-2</code>, and so on.</p>
<p>Note that, while it is possible to have a balanced skip list that performs no better than a standard linked list, the probability of this happening is incredibly low.</p>
<p><strong>What the heck is a Navigable Small World?</strong></p>
<p>Now that we&#39;ve gotten skip lists out of the way let&#39;s take some time to talk about Navigable Small Worlds. The general idea here is first to imagine many nodes in a network. Each node will have short-, medium-, and long-range connections to other nodes. When performing a search, we&#39;ll begin at some pre-defined entry point. From there, we&#39;ll evaluate connections to other nodes and jump to the one closest to the one we hope to find. This process repeats until we&#39;ve found our nearest neighbor.</p>
<p>This type of search is called <em>greedy search</em>. This algorithm works for small NSWs in the hundreds or thousands of nodes, but it tends to break down for much larger NSWs. We can fix this by increasing the average number of short-, medium-, and long-range connections for each node, but this increases the overall complexity of the network and results in longer search times. In the absolute &#34;worst&#34; case, where each node is connected to every other node in our dataset, NSW is no better than na√Øve (linear) search.</p>
<p>NSWs are cool, but how does this relate to vector search? The idea here is to imagine all vectors in our dataset as points in an NSW, with long-range connections defined by vectors dissimilar from one another and the opposite for short-range connections. Recall that vector similarity scores are measured with a similarity metric - typically L2 distance or inner product for floating point vectors and Jaccard or Hamming distance for binary vectors.</p>
<p>By constructing an NSW with dataset vectors as vertices, we can effectively perform nearest neighbor search by greedily traversing the NSW towards vertices closer and closer to our query vector.</p>
<p><strong>HNSW, explained</strong></p>
<p>When it comes to vector search, we often have dataset sizes in the hundreds of millions or even billions of vectors. Plain NSWs are less effective at this scale, so we&#39;ll need a better graph.</p>
<p>
      <span>
        <a href="https://assets.zilliz.com/better_graph_d464cbf359.png" title="better_graph.png" target="_blank"><img src="https://assets.zilliz.com/better_graph_d464cbf359.png" alt="better_graph.png" id="better_graph.png"/></a>
        <span>better_graph.png</span>
      </span>
    </p>
<p><sub>Enter HNSW.</sub></p>
<p>HNSW extends NSW by borrowing from the concept of skip lists. Like the skip list, HNSW maintains multiple layers (hence the term <em>Hierarchical</em> Navigable Small World), only of NSWs instead of linked lists. The uppermost layer of an HNSW graph has few nodes and the longest links, while the bottommost layer has all nodes and the shortest links. During the search process, we enter a pre-defined point in the uppermost layer and greedily route ourselves toward the nearest neighbor to our query vector. Once we reach the nearest node, we repeat this process to the second layer. This continues until we&#39;ve reached our nearest neighbor.</p>
<p>
      <span>
        <a href="https://assets.zilliz.com/hnsw_visualized_a9b401e55b.jpg" title="hnsw_visualized.jpg" target="_blank"><img src="https://assets.zilliz.com/hnsw_visualized_a9b401e55b.jpg" alt="hnsw_visualized.jpg" id="hnsw_visualized.jpg"/></a>
        <span>hnsw_visualized.jpg</span>
      </span>
    </p>
<p><sub>A diagram from the HNSW paper which visualizes the layered graph concept. From https://arxiv.org/abs/1603.09320.</sub></p>
<p>Inserts work similarly to the skip list. For some vector <strong><code>v</code></strong>, We first traverse the first layer of the graph, finding its nearest neighbor before moving to the layer below it. Then, we traverse the graph again to find its nearest neighbor in the second layer. This process until we&#39;ve reached the nearest neighbor in the bottommost graph.</p>
<p>We must determine which links (connections between vertices) to create from here. Again, we have a pre-defined parameter <code>M</code> which determines the maximum number of bidirectional links we can add. These links are usually set as the nearest neighbors to <strong><code>v</code></strong>, but other heuristics can also be used. The same process repeats for the upper layers, assuming the vector appears.</p>
<p>As with the skip list, the query vector will appear in upper layers with exponentially decreasing probability. Specifically, the HNSW paper uses the equation <code>floor(-ln(rand(0, 1)))</code>, where <code>rand(0, 1)</code> is a random number sampled from a uniform distribution between (0, 1]. Note how this does not constrain the minimum distance between any two vertices/vectors in a particular layer - we may end up with a poorly constructed graph. Still, the probability of this happening is incredibly low, especially as we scale up the number of vectors in the HNSW index.</p>
<p>HNSW is not trivial, so we&#39;ll implement only a basic version here. As usual, let&#39;s start with creating a dataset of (128 dimensional) vectors:</p>
<pre><code><span>&gt;&gt;&gt; </span><span>import</span> numpy <span>as</span> np
<span>&gt;&gt;&gt; </span>dataset = np.random.normal(size=(<span>1000</span>, <span>128</span>))
</code></pre>
<p>The first step is to build the HNSW index. We&#39;ll need to add each vector to our dataset to do so. So let&#39;s first create a data structure to hold our index. In this basic example, we&#39;ll use a list of lists to represent the index, with the inner lists corresponding to each layer/graph:</p>
<pre><code><span>&gt;&gt;&gt; </span>L = <span>5</span>  
<span>&gt;&gt;&gt; </span>index = [[] <span>for</span> _ <span>in</span> <span>range</span>(L)]
</code></pre>
<p>Every element in each graph is a 3-tuple containing the vector, a list of indexes the vector links to within the graph, and the index for the corresponding node in the layer below it. For the bottommost layer, the third element of the 3-tuple will be set to <code>None</code>.</p>
<p>Since every insert first requires a search for the nearest neighbor in graph, let&#39;s implement that first. We can traverse any of the subgraphs in the index as so:</p>
<pre><code><span>def</span> <span>_search_layer</span>(<span>graph, entry, query, ef=<span>1</span></span>):

    best = (np.linalg.norm(graph[entry][<span>0</span>] - query), entry)

    nns = [best]
    visit = <span>set</span>(best)  
    candid = [best]  
    heapify(candid)

    
    <span>while</span> candid:
        cv = heappop(candid)

        <span>if</span> nns[-<span>1</span>][<span>0</span>] &lt; cv[<span>0</span>]:
            <span>break</span>

        
        <span>for</span> e <span>in</span> graph[cv[<span>1</span>]][<span>1</span>]:
            d = np.linalg.norm(graph[e][<span>0</span>] - query)
            <span>if</span> (d, e) <span>not</span> <span>in</span> visit:
                visit.add((d, e))

                
                <span>if</span> d &lt; nns[-<span>1</span>][<span>0</span>] <span>or</span> <span>len</span>(nns) &lt; ef:
                    heappush(candid, (d, e))
                    insort(nns, (d, e))
                    <span>if</span> <span>len</span>(nns) &gt; ef:
                        nns.pop()

    <span>return</span> nns
</code></pre>
<p>This code snippet is more involved, but it&#39;s much easier to understand with some explanation. Here, we use a heap to implement a priority queue, which we use to order nearest neighbor vectors in the graph. Like all of the previous examples, I&#39;m using L2 distance here, but this code can also be extended to other distance metrics. We first populate the heap with the entry point.</p>
<p>Here, all we&#39;re doing is implementing <em>greedy</em> search. At every iteration, we aim to update two variables: <code>nns</code>, our output list of nearest neighbors, and <code>candid</code>, a heap of candidate points. So, first, we evaluate all nearest neighbors to the &#34;best&#34; vector in <code>candid</code>, adding better (better means closer to the query vector) vectors to the output list of nearest neighbors and the heap of candidate points for evaluation on the next iteration. This repeats until one of two stopping conditions is reached: we either run out of candidate points to evaluate, or we&#39;ve determined that we can no longer do any better than we already have.</p>
<p>With top-k graph search out of the way, we can now implement the top-level <code>search</code> function for searching the entire HNSW index:</p>
<pre><code><span>def</span> <span>search</span>(<span>index, query, ef=<span>1</span></span>):

    
    <span>if</span> <span>not</span> index[<span>0</span>]:
        <span>return</span> []

    best_v = <span>0</span>  
    <span>for</span> graph <span>in</span> index:
        best_d, best_v = _search_layer(graph, best_v, query, ef=<span>1</span>)[<span>0</span>]
        <span>if</span> graph[best_v][<span>2</span>]:
            best_v = graph[best_v][<span>2</span>]
        <span>else</span>:
            <span>return</span> _search_layer(graph, best_v, query, ef=ef)
</code></pre>
<p>We first start at the entry point (zeroth element in the uppermost graph), and search for the nearest neighbor in each index layer until we reach the bottommost layer. Recall that the final element of the 3-tuple will resolve to <code>None</code> if we are at the bottommost layer - this is what the final <code>if</code> statement is for. Once we reach the lowermost layer, we search the graph using <code>best_v</code> as the entry point.</p>
<p>Let&#39;s go back go the HNSW insert. We&#39;ll first need to figure out which layer to insert our new vector into. This is fairly straightforward:</p>
<pre><code><span>def</span> <span>_get_insert_layer</span>(<span>L, mL</span>):
    
    l = -<span>int</span>(np.log(np.random.random()) * mL)
    <span>return</span> <span>min</span>(l, L)
</code></pre>
<p>With everything in place, we can now implement the insertion function.</p>
<pre><code><span>def</span> <span>insert</span>(<span>self, vec, efc=<span>10</span></span>):

    
    <span>if</span> <span>not</span> index[<span>0</span>]:
        i = <span>None</span>
        <span>for</span> graph <span>in</span> index[::-<span>1</span>]:
            graph.append((vec, [], i))
            i = <span>0</span>
        <span>return</span>

    l = _get_insert_layer(<span>1</span>/np.log(L))

    start_v = <span>0</span>
    <span>for</span> n, graph <span>in</span> <span>enumerate</span>(index):

        
        <span>if</span> n &lt; l:
            _, start_v = _search_layer(graph, start_v, vec, ef=<span>1</span>)[<span>0</span>]
        <span>else</span>:
            node = (vec, [], <span>len</span>(_index[n+<span>1</span>]) <span>if</span> n &lt; L-<span>1</span> <span>else</span> <span>None</span>)
            nns = _search_layer(graph, start_v, vec, ef=efc)
            <span>for</span> nn <span>in</span> nns:
                node[<span>1</span>].append(nn[<span>1</span>])  
                graph[nn[<span>1</span>]][<span>1</span>].append(<span>len</span>(graph))  
            graph.append(node)

        
        start_v = graph[start_v][<span>2</span>]
</code></pre>
<p>If the index is empty, we&#39;ll insert <code>vec</code> into all layers and return immediately. This serves to initialize the index and allow for successful insertions later. If the index has already been populated, we begin insertion by first computing the insertion layer via the <code>get_insert_layer</code> function we implemented in the previous step. From there, we find the nearest neighbor to the vector in the uppermost graph. This process continues for the layers below it until we reach layer <code>l</code>, the insertion layer.</p>
<p>For layer <code>l</code> and all those below it, we first find the nearest neighbors to <code>vec</code> up to a pre-determined number <code>ef</code>. We then create connections from the node to its nearest neighbors and vice versa. Note that a proper implementation should also have a pruning technique to prevent early vectors from being connected to too many others - I&#39;ll leave that as an exercise for the reader :sunny:.</p>
<p>We now have both search (query) and insert functionality complete. Let&#39;s combine everything in a class:</p>
<pre><code><span>from</span> bisect <span>import</span> insort
<span>from</span> heapq <span>import</span> heapify, heappop, heappush

<span>import</span> numpy <span>as</span> np

<span>from</span> ._base <span>import</span> _BaseIndex


<span>class</span> <span>HNSW</span>(<span>_BaseIndex</span>):

    <span>def</span> <span>__init__</span>(<span>self, L=<span>5</span>, mL=<span>0.62</span>, efc=<span>10</span></span>):
        self._L = L
        self._mL = mL
        self._efc = efc
        self._index = [[] <span>for</span> _ <span>in</span> <span>range</span>(L)]

<span>    @staticmethod</span>
    <span>def</span> <span>_search_layer</span>(<span>graph, entry, query, ef=<span>1</span></span>):

        best = (np.linalg.norm(graph[entry][<span>0</span>] - query), entry)

        nns = [best]
        visit = <span>set</span>(best)  
        candid = [best]  
        heapify(candid)

        
        <span>while</span> candid:
            cv = heappop(candid)

            <span>if</span> nns[-<span>1</span>][<span>0</span>] &gt; cv[<span>0</span>]:
                <span>break</span>

            
            <span>for</span> e <span>in</span> graph[cv[<span>1</span>]][<span>1</span>]:
                d = np.linalg.norm(graph[e][<span>0</span>] - query)
                <span>if</span> (d, e) <span>not</span> <span>in</span> visit:
                    visit.add((d, e))

                    
                    <span>if</span> d &lt; nns[-<span>1</span>][<span>0</span>] <span>or</span> <span>len</span>(nns) &lt; ef:
                        heappush(candid, (d, e))
                        insort(nns, (d, e))
                        <span>if</span> <span>len</span>(nns) &gt; ef:
                            nns.pop()

        <span>return</span> nns

    <span>def</span> <span>create</span>(<span>self, dataset</span>):
        <span>for</span> v <span>in</span> dataset:
            self.insert(v)

    <span>def</span> <span>search</span>(<span>self, query, ef=<span>1</span></span>):

        
        <span>if</span> <span>not</span> self._index[<span>0</span>]:
            <span>return</span> []

        best_v = <span>0</span>  
        <span>for</span> graph <span>in</span> self._index:
            best_d, best_v = HNSW._search_layer(graph, best_v, query, ef=<span>1</span>)[<span>0</span>]
            <span>if</span> graph[best_v][<span>2</span>]:
                best_v = graph[best_v][<span>2</span>]
            <span>else</span>:
                <span>return</span> HNSW._search_layer(graph, best_v, query, ef=ef)

    <span>def</span> <span>_get_insert_layer</span>(<span>self</span>):
        
        l = -<span>int</span>(np.log(np.random.random()) * self._mL)
        <span>return</span> <span>min</span>(l, self._L-<span>1</span>)

    <span>def</span> <span>insert</span>(<span>self, vec, efc=<span>10</span></span>):

        
        <span>if</span> <span>not</span> self._index[<span>0</span>]:
            i = <span>None</span>
            <span>for</span> graph <span>in</span> self._index[::-<span>1</span>]:
                graph.append((vec, [], i))
                i = <span>0</span>
            <span>return</span>

        l = self._get_insert_layer()

        start_v = <span>0</span>
        <span>for</span> n, graph <span>in</span> <span>enumerate</span>(self._index):

            
            <span>if</span> n &lt; l:
                _, start_v = self._search_layer(graph, start_v, vec, ef=<span>1</span>)[<span>0</span>]
            <span>else</span>:
                node = (vec, [], <span>len</span>(self._index[n+<span>1</span>]) <span>if</span> n &lt; self._L-<span>1</span> <span>else</span> <span>None</span>)
                nns = self._search_layer(graph, start_v, vec, ef=efc)
                <span>for</span> nn <span>in</span> nns:
                    node[<span>1</span>].append(nn[<span>1</span>])  
                    graph[nn[<span>1</span>]][<span>1</span>].append(<span>len</span>(graph))  
                graph.append(node)

            
            start_v = graph[start_v][<span>2</span>]
</code></pre>
<p>Boom, done!</p>
<p>In this tutorial, we did a deep dive into Hierarchical Navigable Small Worlds - a powerful graph-based vector search strategy that involves multiple layers of connected graphs. HNSW is an incredibly popular algorithm, and is often the go-to choice for Milvus users looking for maximum query performance.</p>
<p>In the next tutorial, we&#39;ll continue our deep dive into indexing strategies with Approximate Nearest Neighbor Oh Yeah (ANNOY) - a tree-based indexing algorithm that I particularly enjoy because of its playful name.</p>
<ol>
<li><ul>
<li><a href="https://zilliz.com/blog/introduction-to-unstructured-data">Introduction to Unstructured Data</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/learn/what-is-vector-database">What is a Vector Database?</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/introduction-to-milvus-vector-database">Introduction to Milvus</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/milvus-vector-database-quickstart">Milvus Quickstart</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/vector-similarity-search">Introduction to Vector Similarity Search</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/vector-index">Vector Index Basics and the Inverted File Index</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/scalar-quantization-and-product-quantization">Scalar Quantization and Product Quantization</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/hierarchical-navigable-small-worlds-HNSW">Hierarchical Navigable Small Worlds (HNSW)</a></li>
</ul></li>
</ol>
</div></div></div>
  </body>
</html>
