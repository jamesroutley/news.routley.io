<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cockroachlabs.com/blog/why-cockroachdb-doesnt-use-evalplanqual/">Original</a>
    <h1>Why CockroachDB doesn&#39;t use EvalPlanQual</h1>
    
    <div id="readability-page-1" class="page"><div>
          
          <div>

            
            <p><img src="http://ablwr.github.io/img/Ben-r23.png"/></p><h3>
              Tech Talk
            </h3>
            
            <p>Co-Founder Ben Darnell on Van Halen, brown M&amp;Ms, and isolation.</p>
  
             
              <p><a href="https://www.cockroachlabs.com/roachfest/2023/no-brown-mms-on-foreign-keys-isolation-levels-and-van-halen/">Watch now</a> 
            
          </p></div>
            

        <p>Here’s a surprising behavior of PostgreSQL you might not know about: under READ
COMMITTED isolation, <strong>PostgreSQL can sometimes miss rows</strong> when performing
UPDATE, DELETE, SELECT FOR UPDATE, or SELECT FOR SHARE statements. This is due
to the <em>EvalPlanQual</em> recheck PostgreSQL adds to these statements to prevent
lost-update anomalies.</p>
<p>For CockroachDB’s new implementation of READ COMMITTED isolation, we considered
building our own version of <em>EvalPlanQual</em>, but decided to use a different
technique instead which doesn’t miss rows. By not missing rows, CockroachDB
alleviates the need for application-level retries.</p>




<h2 id="what-is-evalplanqual">What is EvalPlanQual?</h2>
<p>Under READ COMMITTED isolation, PostgreSQL adds a special recheck step to
UPDATE, DELETE, SELECT FOR UPDATE, and SELECT FOR SHARE statements. This
recheck is known as <a href="https://github.com/postgres/postgres/blob/ada87a4d95fc39dfb1214edf6653390314b6f0df/src/backend/executor/README#L350" target="_blank" rel="noopener"><em>EvalPlanQual</em></a>, and consists of a re-evaluation
of part of the statement after all qualifying rows are locked. PostgreSQL uses
<em>EvalPlanQual</em> to prevent lost updates under READ COMMITTED isolation.</p>
<p>To make this concrete, let’s walk through an example.</p>
<h2 id="an-example-of-conflicting-updates-in-postgresql-and-cockroachdb">An example of conflicting updates in PostgreSQL and CockroachDB</h2>
<p>Suppose we’re using SQL to organize a 3-on-3 basketball league. One of the
tables in our schema holds information about every player in the league,
including (a) their ID, (b) their name, (c) their skill level, and (d) their
team assignment if they have one.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>CREATE</span> <span>TABLE</span> player (
    id    integer <span>NOT</span> <span>NULL</span>,
    name  text <span>NOT</span> <span>NULL</span>,
    <span>level</span> text <span>NOT</span> <span>NULL</span>,
    team  text,
    <span>PRIMARY</span> <span>KEY</span> (id)
);

<span>INSERT</span> <span>INTO</span> player <span>VALUES</span>
    (<span>1</span>, <span>&#39;Gray&#39;</span>,         <span>&#39;A&#39;</span>,  <span>&#39;Dolphins&#39;</span>),
    (<span>2</span>, <span>&#39;Mohan&#39;</span>,        <span>&#39;A&#39;</span>,  <span>&#39;Dolphins&#39;</span>),
    (<span>3</span>, <span>&#39;Stonebreaker&#39;</span>, <span>&#39;A&#39;</span>,  <span>&#39;Dolphins&#39;</span>),
    (<span>4</span>, <span>&#39;Lamport&#39;</span>,      <span>&#39;A&#39;</span>,  <span>&#39;Gophers&#39;</span>),
    (<span>5</span>, <span>&#39;Ullman&#39;</span>,       <span>&#39;A&#39;</span>,  <span>&#39;Gophers&#39;</span>),
    (<span>6</span>, <span>&#39;Lynch&#39;</span>,        <span>&#39;A&#39;</span>,  <span>&#39;Gophers&#39;</span>),
    (<span>7</span>, <span>&#39;Bernstein&#39;</span>,    <span>&#39;AA&#39;</span>, <span>&#39;Elephants&#39;</span>),
    (<span>8</span>, <span>&#39;Liskov&#39;</span>,       <span>&#39;AA&#39;</span>, <span>&#39;Elephants&#39;</span>),
    (<span>9</span>, <span>&#39;Codd&#39;</span>,         <span>&#39;AA&#39;</span>, <span>&#39;Elephants&#39;</span>);
</code></pre></div><p>When modifying this table, we’ll try to maintain two invariants:</p>
<ol>
<li>teams must have exactly 3 players</li>
<li>all players on a team must have the same skill level</li>
</ol>
<p>After a wildly successful season, we decide to move all of the Gophers up to
skill level AA. We use a single UPDATE statement in an implicit transaction,
which should atomically modify all three players and thus maintain our
invariants.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>UPDATE</span> player <span>SET</span> <span>level</span> <span>=</span> <span>&#39;AA&#39;</span> <span>WHERE</span> team <span>=</span> <span>&#39;Gophers&#39;</span>;
</code></pre></div><p>(But to more easily demonstrate, let’s sleep for 5 seconds at the beginning of
the update.)</p>
<div><pre tabindex="0"><code data-lang="sql"><span>WITH</span> sleep <span>AS</span> (<span>SELECT</span> pg_sleep(<span>5</span>))
    <span>UPDATE</span> player <span>SET</span> <span>level</span> <span>=</span> <span>&#39;AA&#39;</span> <span>FROM</span> sleep <span>WHERE</span> team <span>=</span> <span>&#39;Gophers&#39;</span>;
</code></pre></div><p>While that update is running, the Gophers and Dolphins decide to exchange
players 3 and 4 in a trade. Again, we use a single UPDATE statement in an
implicit transaction. This should atomically swap the skill level and team of
the two players and thus, again, maintain our invariants.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>UPDATE</span> player p1 <span>SET</span> (<span>level</span>, team) <span>=</span> 
        (<span>SELECT</span> <span>level</span>, team <span>FROM</span> player p2
         <span>WHERE</span> p2.id <span>IN</span> (<span>3</span>, <span>4</span>) <span>AND</span> p2.id <span>!=</span> p1.id)
    <span>WHERE</span> p1.id <span>IN</span> (<span>3</span>, <span>4</span>);
</code></pre></div><p>The second update succeeds immediately. What happens to the first update? Let’s
consider the result by both database and isolation level.</p>
<h3 id="postgresqls-result">PostgreSQL’s result</h3>
<p>In PostgreSQL, under SERIALIZABLE isolation, the first update fails with a
“could not serialize” error. During execution, PostgreSQL detects that another
transaction has concurrently modified players 3 and 4, and aborts.</p>
<p>Under READ COMMITTED isolation, the first update succeeds, but the result is
anomalous: player 3 is now on the Gophers but is <em>still at level A</em>. Only two
of the Gophers were moved up to level AA.</p>
<pre tabindex="0"><code>michae2=# SELECT * FROM player ORDER BY id;
 id |     name     | level |   team
----+--------------+-------+-----------
  1 | Gray         | A     | Dolphins
  2 | Mohan        | A     | Dolphins
  3 | Stonebreaker | A     | Gophers     &lt;- still at level A
  4 | Lamport      | A     | Dolphins
  5 | Ullman       | AA    | Gophers
  6 | Lynch        | AA    | Gophers
  7 | Bernstein    | AA    | Elephants
  8 | Liskov       | AA    | Elephants
  9 | Codd         | AA    | Elephants
(9 rows)
</code></pre><p>This violates invariant 2, which is surprising, because when considered
individually both updates should have maintained our invariants.</p>
<h3 id="cockroachdbs-result">CockroachDB’s result</h3>
<p>In CockroachDB, under both SERIALIZABLE and READ COMMITTED isolation the result
is the same: the first update succeeds, player 3 is now on the Gophers, and is
correctly at level AA.</p>
<pre tabindex="0"><code>demo@127.0.0.1:26257/demoapp/defaultdb&gt; SELECT * FROM player ORDER BY id;
  id |     name     | level |   team
-----+--------------+-------+------------
   1 | Gray         | A     | Dolphins
   2 | Mohan        | A     | Dolphins
   3 | Stonebreaker | AA    | Gophers     &lt;- correctly at level AA
   4 | Lamport      | A     | Dolphins
   5 | Ullman       | AA    | Gophers
   6 | Lynch        | AA    | Gophers
   7 | Bernstein    | AA    | Elephants
   8 | Liskov       | AA    | Elephants
   9 | Codd         | AA    | Elephants
(9 rows)
</code></pre><p>How does PostgreSQL arrive at its anomalous result, and how does CockroachDB
avoid the anomaly? To answer these questions let’s examine execution of the
first UPDATE statement under READ COMMITTED isolation in both databases.</p>
<h2 id="a-closer-look-at-postgresqls-update-under-read-committed-isolation">A closer look at PostgreSQL’s UPDATE under READ COMMITTED isolation</h2>
<p>We’ll start by looking at EXPLAIN in PostgreSQL. The plan for the first UPDATE
statement seems quite simple: a scan of the table followed by a filter.</p>
<pre tabindex="0"><code>michae2=# EXPLAIN UPDATE player SET level = &#39;AA&#39; WHERE team = &#39;Gophers&#39;;
                         QUERY PLAN
-------------------------------------------------------------
 Update on player  (cost=0.00..1.11 rows=0 width=0)
   -&gt;  Seq Scan on player  (cost=0.00..1.11 rows=3 width=38)
         Filter: (team = &#39;Gophers&#39;::text)
</code></pre><p>But that <code>Update on player</code> operation hides a lot of complexity. We can think
of PostgreSQL executing the update under READ COMMITTED isolation in roughly
seven steps.</p>
<ol>
<li>Establish a read snapshot for the statement. This snapshot is before the
second update begins.</li>
<li>Scan <code>player</code> at the read snapshot. (<code>Seq Scan</code> in the plan.)</li>
<li>Filter on <code>team = &#39;Gophers&#39;</code>. (<code>Filter</code> in the plan.) Players 4, 5, and 6
qualify since the read snapshot is before the second update.</li>
<li>Lock all qualifying rows. (Part of <code>Update</code> in the plan.)</li>
<li><strong>Re-read the latest committed version of all locked rows. (<code>Seq Scan</code> in
the plan again.)</strong> This picks up the change to player 4.</li>
<li><strong>Re-run the filter on the latest committed versions. (<code>Filter</code> in the plan
again.)</strong> Now only players 5 and 6 qualify.</li>
<li>Write a new version of each qualifying row. (<code>Update</code> in the plan.)</li>
</ol>
<p>Steps 5 and 6 are <strong>PostgreSQL’s strategy for preventing lost updates</strong> under
READ COMMITTED isolation. After locking all qualifying rows, PostgreSQL
<em>re-evaluates the query steps a second time</em> on the latest version of each
locked row. This is the <em>EvalPlanQual</em> recheck. By doing this recheck,
PostgreSQL picks up any changes made to those rows between reading them and
locking them, which in this case correctly prevents modifying the skill level
of player 4. Unfortunately, because PostgreSQL only rechecks the locked rows,
it <strong>misses the change to player 3</strong>. We were expecting at least one of those
two players to move up to skill level AA, but neither did.</p>
<p>This behavior is <a href="https://www.postgresql.org/docs/16/transaction-iso.html#XACT-READ-COMMITTED" target="_blank" rel="noopener">documented</a>, but it can still <a href="https://www.cybertec-postgresql.com/en/transaction-anomalies-with-select-for-update/" target="_blank" rel="noopener">cause</a>
<a href="https://dev.to/aws-heroes/read-committed-anomalies-in-postgresql-1ieg" target="_blank" rel="noopener">surprises</a>.</p>
<h2 id="a-closer-look-at-cockroachdbs-update-under-read-committed-isolation">A closer look at CockroachDB’s UPDATE under READ COMMITTED isolation</h2>
<p>Next, let’s look at EXPLAIN in CockroachDB. Again, the plan for the UPDATE
statement seems quite simple: a scan of the table followed by a filter.</p>
<pre tabindex="0"><code>demo@127.0.0.1:26257/demoapp/defaultdb&gt; EXPLAIN UPDATE player SET level = &#39;AA&#39; WHERE team = &#39;Gophers&#39;;
                                           info
-------------------------------------------------------------------------------------------
  distribution: local
  vectorized: true

  • update
  │ table: player
  │ set: level
  │ auto commit
  │
  └── • render
      │
      └── • filter
          │ estimated row count: 3
          │ filter: team = &#39;Gophers&#39;
          │
          └── • scan
                estimated row count: 9 (100% of the table; stats collected 8 seconds ago)
                table: player@player_pkey
                spans: FULL SCAN
</code></pre><p>Again, that <code>update</code> operation hides a lot of complexity. We can think of
CockroachDB executing the update under READ COMMITTED isolation in roughly six
steps.</p>
<ol>
<li>Create a savepoint in the current transaction.</li>
<li>Establish a read snapshot for the statement. This snapshot is before the
second update begins.</li>
<li>Scan <code>player</code> at the read snapshot. (<code>scan</code> in the plan.)</li>
<li>Filter on <code>team = &#39;Gophers&#39;</code>. (<code>filter</code> in the plan.) Players 4, 5, and 6
qualify since the read snapshot is before the second update.</li>
<li>Write an intent for each qualifying row.<sup><a href="#footnote1" target="_blank" rel="noopener">1</a></sup> (<code>update</code> in the plan.)</li>
<li>While writing intents, if the latest committed version of a row is newer
than our read snapshot, <strong>rollback to the savepoint and go back to step
1.</strong> This gives us a new read snapshot which is <em>after</em> the second update.</li>
</ol>
<p>Step 6 is <strong>CockroachDB’s strategy for preventing lost updates</strong> under READ
COMMITTED isolation. CockroachDB <a href="https://github.com/cockroachdb/cockroach/blob/04e1faeb6b674729e989e001d37429786b584c6e/pkg/sql/conn_executor_exec.go#L1696" target="_blank" rel="noopener"><em>retries the entire UPDATE
statement</em></a> with a new read snapshot if it encounters a newer
version of a row while writing an intent.<sup><a href="#footnote2" target="_blank" rel="noopener">2</a></sup> By executing the entire statement
again with a new read snapshot, CockroachDB can pick up <em>any</em> changes made
after the previous read snapshot, which in this case includes changes to <em>both</em>
players 3 and 4. Crucially, CockroachDB holds onto locks and intents across
retries, which helps it make progress even during periods of heavy contention.</p>
<h2 id="how-to-prevent-lost-updates-a-tradeoff">How to prevent lost updates: a tradeoff?</h2>
<p>At first glance these two different techniques for preventing lost updates seem
to embody a tradeoff: on the one hand, PostgreSQL avoids retries, on the other
hand, CockroachDB avoids anomalies. But if we consider things from the
application’s point of view, this is less of a tradeoff than it first appears.
What would an application need to do to be sure that all Gophers were updated
to skill level AA?</p>
<p>When using PostgreSQL, the application itself would need to retry the first
UPDATE statement until all Gophers were at level AA. <strong>Application-level
retries are more expensive than database-level retries</strong>, due to network
latency, so this is strictly worse than retrying within the database. There’s
no way to avoid retrying the first UPDATE statement in this scenario, but
CockroachDB is able to hide the retry from the application.</p>
<h2 id="conclusion">Conclusion</h2>
<p>PostgreSQL adds <em>EvalPlanQual</em> rechecks to UPDATE, DELETE, SELECT FOR UPDATE,
and SELECT FOR SHARE statements under READ COMMITTED isolation to prevent
lost-update anomalies. EvalPlanQual lets PostgreSQL avoid internal retries of
these statements, but it can cause PostgreSQL to <strong>miss rows</strong> which will in
turn require application-level retries to handle.<sup><a href="#footnote3" target="_blank" rel="noopener">3</a></sup></p>
<p>In CockroachDB’s new implementation of READ COMMITTED isolation, instead of
EvalPlanQual we built an internal statement-retry mechanism that <strong>does not
miss rows and thus alleviates the need for application-level retries</strong>.</p>
<p><a name="footnote1">1</a> <a href="https://www.cockroachlabs.com/docs/v23.2/architecture/transaction-layer#write-intents"><em>Intents</em></a> are new versions of a row that also act as exclusive
locks.</p>
<p><a name="footnote2">2</a> Under SERIALIZABLE isolation, CockroachDB retries <em>entire transactions</em>
when a serializable history cannot be achieved through other means. In this
case we’re using a single-statement implicit transaction, so CockroachDB
appears to have the same behavior under both SERIALIZABLE and READ COMMITTED
isolation. But note that if the scenario were slightly different, say a <em>move</em>
of a player to the Gophers rather than a swap, the two isolation levels would
show different behavior.</p>
<p><a name="footnote3">3</a> This article focuses on PostgreSQL, but it’s worth noting that MySQL
(using InnoDB) can also miss rows with some tweaks to the scenario. Of the
databases we’ve studied, so far Oracle has the most similar UPDATE behavior
under READ COMMITTED isolation to CockroachDB.</p>

      </div></div>
  </body>
</html>
