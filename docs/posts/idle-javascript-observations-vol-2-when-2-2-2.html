<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://george.mand.is/2021/11/idle-javascript-observations-vol-2-when-2-2-=-2/">Original</a>
    <h1>Idle JavaScript Observations, Vol. 2: When 2 &#43; 2 = 2</h1>
    
    <div id="readability-page-1" class="page"><div><article><section><header><p><date>Wednesday, November 17th 2021</date></p></header><p>When does two plus two equal two? Never, if we&#39;re being truthful</p><p>But if we want to be deceitful and have fun using addition and booleans in JavaScript we could write something like this that <em>almost</em> suggests this, if you&#39;re just taking a glance:</p><pre><code>((2 === 2) + (2 === 2)) === 2
//^true
</code></pre><p>That&#39;s because JavaScript lets us perform arithmetic with booleans. When you do this <code>true</code> is always 1 and <code>false</code> is always zero.</p><p>Here&#39;s good example of this in conjunction with demonstrating JavaScript&#39;s strict equality operator:</p><pre><code>(true - 1) == false
// ^true
(true - 1) === false
// ^false
</code></pre><p>When might this actually be useful? That&#39;s a good question.</p><p>A half-baked hypothetical situation: Let&#39;s say you&#39;re waiting for <code>x</code> number of functions to resolve to true/false and you care about how <em>many</em> resolve to true.</p><p>Let&#39;s pretending you&#39;ve built a quiz. Each function maps to a question on a quiz, and calling that function assesses the question and returns whether or not the user got it right. You care about the total number of right and wrong answers.</p><p>You might be able to employ something like this:</p><pre><code>// Pretend these are returning right/wrong answers on a quiz
const questions = [
  () =&gt; true,
  () =&gt; true,
  () =&gt; true,
  () =&gt; false,
  () =&gt; false
]

const rightAnswers = questions.reduce((acc, question) =&gt; acc + question(), 0)
//^ 3 right answers
</code></pre><p>Technically this works because it&#39;s doing arithmetic with the boolean responses.</p><p>It&#39;s definitely a bit of a parlor trick though. You could just as easily do this:</p><pre><code>const someRightAnswers = questions.filter((q) =&gt; q()).length
</code></pre><p>Is one appreciably faster or more efficient than the other? I don&#39;t know.</p><p>It&#39;s probably more common to see a scenario like this, where you might only care if <em>some</em> or <em>all</em> of the values are truthy:</p><pre><code>const someRightAnswers = questions.some((q) =&gt; q())
//^true, because the user did indeed have *some* right answers

const allRightAnswers = questions.every((q) =&gt; q())
//^true, because the user did not get *all* the answers correct
</code></pre></section></article></div></div>
  </body>
</html>
