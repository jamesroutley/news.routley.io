<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://avtok.com/2014/11/05/interface-upgrades.html">Original</a>
    <h1>Interface Upgrades in Go</h1>
    
    <div id="readability-page-1" class="page"><div id="contentwrap">
        <div id="content">
          <article>
            
            <span>November 5, 2014</span>
            <p>Much <a href="http://research.swtch.com/interfaces">has been written</a> about <a href="http://golang.org/doc/effective_go.html#interfaces">Go’s interfaces</a>. They’re one of
the language features I like best, providing a very pragmatic trade-off between
the complexity of more powerful type systems and the anarchy of duck typing. If
you’re not already familiar with Go or Go’s interfaces, I’d encourage you to
read an <a href="http://tour.golang.org/">introduction to Go</a> and to play around with the language a
bit—it’ll help you better understand the remainder of this post.</p>

<p>Interfaces in Go are most commonly used as a means of encapsulation. They allow
programmers to hide an object’s underlying state, only exposing a carefully
curated API. They also allow objects to be decoupled in a way that allows them
to be easily replaced by alternate implementations or stubbed out entirely.</p>

<p>However, Go’s interfaces—and in particular, interface conversions—allow for
a more interesting and less obvious pattern that I call “interface upgrades.”
The crucial observation here is that not only can interfaces be safely cast to
narrower interfaces (i.e., every <a href="http://golang.org/pkg/io/#ReadCloser"><code>io.ReadCloser</code></a> is also an
<a href="http://golang.org/pkg/io/#Reader"><code>io.Reader</code></a>), but they can also be cast to wider or even unrelated
interfaces if their <a href="http://golang.org/ref/spec#Types">dynamic types</a> support it.<sup id="fnref:1"><a href="#fn:1">1</a></sup></p>

<p>The reason I call these sorts of casts interface upgrades is that they remind me
of protocol upgrades, e.g., the one performed during HTTP to negotiate the use
of web sockets. In both cases, two cooperating parties communicating over one
specified protocol (HTTP in one case, and some interface type in the other) can
attempt to switch to another protocol with a different set of features.</p>

<p>A good place to search for Go examples is its standard library, so in order to
illustrate interface upgrades, let’s dive into three examples taken from the
source of Go itself.</p>

<h3 id="efficient-io">Efficient <code>io</code></h3>

<p>Like all articles about Go’s interfaces, we are obligated to start with Go’s
<a href="http://golang.org/pkg/io"><code>io</code> package</a>.</p>

<p>The <code>io</code> package is essentially a set of protocols for copying bytes around.
Unfortunately, this is quite slow, and therefore it’s in Go’s best interest to
try to move each byte as few times as possible.</p>

<p>There’s quite possibly no better place to attack this problem than
<a href="http://golang.org/pkg/io/#Copy"><code>io.Copy</code></a>, Go’s powerhouse of byte moving. This function takes an
<a href="http://golang.org/pkg/io/#Reader"><code>io.Reader</code></a> and an <a href="http://golang.org/pkg/io/#Writer"><code>io.Writer</code></a>, and moves data from one to
the other. Simple enough.</p>

<p>But there’s a catch: both <code>io.Reader</code>’s <code>Read</code> and <code>io.Writer</code>’s <code>Write</code> take
buffers as arguments: they expect their caller to provide the necessary memory
for them. The only sensible implementation of <code>io.Copy</code>, then, is to allocate a
buffer and pass it alternately to <code>Read</code> and <code>Write</code> until all the data has been
copied. The end result is that every byte gets copied twice: once when <code>Read</code>
places it into the <code>Copy</code>-internal buffer, and once when <code>Write</code> removes it.</p>

<p>In many cases we can do better, however. If we’re writing to a file from an
internal <a href="http://golang.org/pkg/bytes/#Buffer"><code>bytes.Buffer</code></a>, for instance, there’s no need to allocate an
intermediary buffer at all: we can pass <code>bytes.Buffer</code>’s internal buffer to
<a href="http://golang.org/pkg/syscall/#Write"><code>syscall.Write</code></a> directly, turning a two-copy process into a single-copy
one.</p>

<p>Supporting this kind of copy elision in <code>io.Copy</code> is tricky since we can’t
change the signature of either <code>io.Reader.Read</code> or <code>io.Writer.Write</code> without
sacrificing generality. Luckily, interface upgrades come to our rescue. The <code>io</code>
package defines two auxiliary types, <a href="http://golang.org/pkg/io/#WriterTo"><code>io.WriterTo</code></a> and
<a href="http://golang.org/pkg/io/#ReaderFrom"><code>io.ReaderFrom</code></a> which <code>io.Reader</code>s and <code>io.Writer</code>s (respectively)
may optionally implement. If at least one of the sides of any given <code>io.Copy</code>
can be upgraded to one of these alternate interfaces, they can arrange to copy
data directly between their respective buffers (or to use the other’s buffers
directly), eliminating the need for <code>io.Copy</code> to allocate buffers of its own.</p>

<p>You’ll find that many of Go’s built-in buffer types (e.g., those in package
<a href="http://golang.org/pkg/bufio/"><code>bufio</code></a>, as well as <code>bytes.Buffer</code> and <a href="http://golang.org/pkg/strings/#Reader"><code>strings.Reader</code></a>)
also implement <code>io.ReaderFrom</code> and <code>io.WriterTo</code>, allowing many common <code>io</code>
pipelines to be performed with less byte movement than one might expect.</p>

<h3 id="extending-nethttp">Extending <code>net/http</code></h3>

<p>Interface upgrades can also be used to add functionality to existing interfaces,
especially when you are <a href="https://golang.org/doc/go1compat">unable</a> (or unwilling) to modify an existing
interface.</p>

<p>A good example of this is <a href="http://golang.org/pkg/net/http/"><code>net/http</code>’s</a>
<a href="http://golang.org/pkg/net/http/#ResponseWriter"><code>ResponseWriter</code></a>. In particular, <code>net/http</code> exposes three
additional interfaces, <a href="http://golang.org/pkg/net/http/#CloseNotifier"><code>CloseNotifier</code></a>, <a href="http://golang.org/pkg/net/http/#Flusher"><code>Flusher</code></a>,
and <a href="http://golang.org/pkg/net/http/#Hijacker"><code>Hijacker</code></a>, each of which augment the capabilities of a vanilla
<code>ResponseWriter</code>. The default implementation of a <code>ResponseWriter</code> incidentally
supports all three of these additional interfaces (although nothing in the
exposed types would tell you that), and using type assertions to upgrade a
<code>http.ResponseWriter</code> to one of these other interfaces allows you to unlock this
additional functionality.</p>

<p>For instance, if you wanted to flush an HTTP response body halfway through, you
might write:</p>

<div><pre><code>func(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, &#34;It&#39;s going to be legen... &#34;)
        io.WriteString(w, &#34;(wait for it) &#34;)
        if fl, ok := w.(http.Flusher); ok {
                fl.Flush()
                time.Sleep(1 * time.Second)
        }
        io.WriteString(w, &#34;...dary. Legendary!\n&#34;)
}
</code></pre>
</div>

<p>The variable <code>w</code> is a <code>http.ResponseWriter</code> and does not ordinarily support the
<code>Flush()</code> function, but by performing a <a href="http://golang.org/ref/spec#Type_assertions">type assertion</a> to
<code>http.Flusher</code> you can upgrade to a interface type that does.</p>

<p>For library authors, this sort of interface upgrade is pretty neat, since it
allows them to provide additional functionality in a backwards-compatible way.
By simply defining additional methods on some interface’s dynamic type (in the
case of <code>net/http.ResponseWriter</code>, this is a private struct named
<a href="https://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release-branch.go1.3#291"><code>response</code></a>) you can let people opt in to new methods without
breaking any existing code.</p>

<p>For consumers of libraries, including standard ones like <code>net/http</code>, the story
isn’t quite as great. While it just so happens that all the <code>ResponseWriter</code>s
that <code>net/http</code> give you implement (e.g.) <code>CloseNotifier</code>, there’s not really
any way for you to know that without reading the source. The type system
certainly can’t tell you this (almost by design), and even the
<a href="http://golang.org/pkg/net/http/">documentation</a>—which is normally very good—falls short here. This is
by no means inherent to interface upgrades themselves (compare
<a href="http://golang.org/pkg/net/http/#CloseNotifier"><code>CloseNotifier</code>’s</a> documentation to, for instance,
<a href="http://golang.org/pkg/io/#Copy"><code>io.Copy</code>’s</a>), but without a concious effort to document supported
upgrades they’re likely to remain largely unused.</p>

<p>This is also probably a good place to mention that interface upgrades put you
beyond the safety of the type checker. If you write an invalid upgrade either
due to programmer error or due to a change in a library you’re using, the way
you’ll find out is when your program <code>panic</code>s at runtime.  Therefore, you should
always use the “comma, ok” idiom when performing type assertions, and always
provide fallback behavior for when you discover that an upgrade cannot be
made.<sup id="fnref:2"><a href="#fn:2">2</a></sup></p>

<h3 id="optimizing-net">Optimizing <code>net</code></h3>

<p>A final, rather astounding example can be found in Go’s <a href="http://golang.org/pkg/net/"><code>net</code></a> package.</p>

<p>As I mentioned above, moving data around is pretty slow, and a good way to make
programs faster is to avoid copies at all. Unfortunately, the normal read and
write cycle forces us to do at least two copies (regardless of whatever
<code>io.Copy</code> tricks we do in Go): once from kernel space to receive data, and once
to kernel space to send it somewhere else.</p>

<p>Just like before, we can sometimes do better. Certain operating systems expose
system calls like <a href="http://man7.org/linux/man-pages/man2/sendfile.2.html"><code>sendfile(2)</code></a> (available in some form on most
UNIX systems; a similar <code>TransmitFile</code> mechanism exists on Windows), which
instructs the kernel to move data to and from certain sorts of file descriptors
with a single kernel-internal copy operation, an improvement over the ordinary
two kernel-to-userspace copies.</p>

<p>Making use of these more efficient system calls often requires careful
application-level bookkeeping and invasive architectural changes, and as a
result only high-performance HTTP servers typically use them. Go, however, can
simply leverage its existing abstractions, treating this as an interface upgrade
like any other.<sup id="fnref:3"><a href="#fn:3">3</a></sup></p>

<p>Let’s dive in to the source of <code>net</code> to have a look. <a href="http://golang.org/pkg/net/#TCPConn"><code>net.TCPConn</code></a>,
the type underlying every TCP connection, defines a function which should now be
familiar to you: <code>io.ReaderFrom</code>’s <a href="https://code.google.com/p/go/source/browse/src/pkg/net/tcpsock_posix.go?name=release-branch.go1.3#67"><code>ReadFrom</code></a>. You’ll notice that
this function first attempts to call a function named <code>sendFile</code>, falling back
to a generic <code>ReadFrom</code> implementation if that didn’t work.</p>

<p><a href="https://code.google.com/p/go/source/browse/src/pkg/net/sendfile_linux.go?name=release-branch.go1.3#24"><code>sendFile</code></a> is where all the interesting work happens. Since the
<code>sendfile(2)</code> system call only works when sending regular files (and not, for
instance, a <code>bytes.Buffer</code> or any other <code>io.Reader</code>), <code>sendFile</code> first attempts
two type assertions to determine if the <code>io.Reader</code> it was passed happens to be
a <a href="http://golang.org/pkg/os/#File"><code>os.File</code></a>, possibly wrapped in an <a href="http://golang.org/pkg/io/#LimitedReader"><code>io.LimitedReader</code></a>. If
so, the <code>io.Reader</code> is (potentially) eligible, and <code>sendfile(2)</code> is used to
shuttle bytes around.</p>

<p>Let’s stop here for a second and think about how cool this is. The Go standard
library has automatically, and in all likelihood without you knowing, upgraded
every <code>io.Copy</code> from a file to a TCP socket to use a system call that was
previously reserved for high-performance proxies, <em>just because it could</em>.</p>

<p>But that’s not even the most amazing thing. By making this upgrade path rely on
the standard <code>io.ReaderFrom</code> interface, Go has given us enough rope to allow
<em>any</em> <code>io.Writer</code> that wraps a <code>net.TCPConn</code> to take advantage of this
optimization, just by enabling an interface upgrade to <code>io.ReaderFrom</code>.</p>

<p>So let’s tie this entire post together by going back and having another look at
<code>http.ResponseWriter</code>. We previously looked at how it offered additional
functionality through interface upgrades. What we overlooked at the time was the
fact that the default <code>http.ResponseWriter</code> actually implements one more method:
<a href="https://code.google.com/p/go/source/browse/src/pkg/net/http/server.go?name=release-branch.go1.3#373"><code>ReadFrom</code></a>.</p>

<p>So not only does <code>net</code> perform an interface upgrade to support <code>sendfile(2)</code>
when it can, but <code>net/http</code> is able to support the same upgrade to make every
<code>io.Copy</code> to an <code>http.ResponseWriter</code>—for instance, the one in the standard
<a href="http://golang.org/pkg/net/http/#ServeFile"><code>http.ServeFile</code></a> function—<em>also</em> support <code>sendfile(2)</code>. Because
of an unlikely combination of well-designed interface types and the ability to
upgrade to more efficient interfaces when necessary, Go is able to serve files
as efficiently as nginx without your knowledge or cooperation.</p>

<p>And that’s fucking amazing.</p>

<h3 id="the-proxy-problem">The Proxy Problem</h3>

<p>Interface upgrades aren’t without their faults. Besides the aforementioned
problems for library users, interface upgrades present an enormous burden on
authors of <a href="http://en.wikipedia.org/wiki/Proxy_pattern">proxy objects</a>.</p>

<p>Let’s again look at <code>http.ResponseWriter</code>. Let’s say we want to write a request
logger middleware that captures and prints out the HTTP status code that we
returned. A naive solution might look like this:</p>

<div><pre><code>type StatusLogger struct {
        http.ResponseWriter
        StatusCode int
}

func (s *StatusLogger) WriteHeader(code int) {
        s.StatusCode = code
        s.ResponseWriter.WriteHeader(code)
}

func RequestLogger(h http.Handler) http.Handler {
        fn := func(w http.ResponseWriter, r *http.Request) {
                sl := &amp;StatusLogger{ResponseWriter: w}
                h.ServeHTTP(sl, r)
                log.Println(&#34;HTTP status code&#34;, sl.StatusCode)
        }
        return http.HandlerFunc(fn)
}
</code></pre>
</div>

<p>Let’s set aside all the ways in which the code above is subtly incorrect and
focus on the interaction between the <code>StatusLogger</code> and the
<code>http.ResponseWriter</code> it wraps. Our intent is fairly clear: we want to intercept
all calls to <code>WriteHeader</code>, saving the status code that is sent, but otherwise
act exactly as the object we’re proxying.</p>

<p>Unfortunately, our <code>StatusLogger</code> only implements the bare minimum required of
an <code>http.ResponseWriter</code>, and in particular doesn’t implement any interface
upgrades. Users who are expecting upgradable functionality (including those that
rely on the performance characteristics of, e.g., <code>sendfile(2)</code> upgrades) will
find their applications broken in subtle and in all likelihood, hard-to-debug
ways.</p>

<p>In general, it’s impossible to know which interface upgrades a given object
supports, since doing so would require deep knowledge of the method set of a
interface’s dynamic type. It’s therefore also impossible to write a
general-purpose proxy type that supports arbitrary interface upgrades. Even if
we have only a small number of interface upgrades to support (for example.
<code>http.ResponseWriter</code>’s four), supporting all combinations of those interfaces
becomes an unwieldy power set (<code>http.ResponseWriter</code> would require sixteen
implementations).</p>

<p>But in practice it’s possible to do pretty well, especially for standard library
types like <code>http.ResponseWriter</code>s. Here, for any given version of Go we have a
single well-known set of upgrades to support. In this case, there are two common
configurations: a bare <code>http.ResponseWriter</code>, and one with all the fancy bells
and whistles. If you want to see this technique at work, I’ve written a generic,
interface upgrade aware <a href="https://github.com/zenazn/goji/blob/22c4c96f3bf62ef5ae2074c115c99da857452b75/web/util/writer_proxy.go#L30-L43"><code>http.ResponseWriter</code> proxy</a> as part of
<a href="https://goji.io">Goji</a>.</p>

<h3 id="use-sparingly">Use Sparingly</h3>

<p>Interface upgrades allow for some of the coolest behaviors in Go, but I’m going
to end this post on a somewhat unusual note: I’d strongly encourage you <a href="http://en.wikipedia.org/wiki/Law_of_the_instrument">not to
write your own</a>.</p>

<p>Interface upgrades derive a lot of their utility from being standard. Just like
a network protocol upgrade, both sides need to agree on what the resulting
behavior is. There are a few well-known interface upgrades in Go’s standard
library which I will happily promote the use of (particularly the ones in <code>io</code>),
but chances are your library isn’t standard enough to make good use of a custom
interface upgrade. The downsides of sidestepping the type system are very real,
and I doubt the complexity will often be worth it.</p>



<p>It took me a while to truly appreciate Go’s interfaces: they manage to hide a
remarkable amount of complexity for such a simple idea. It’s really amazing how
much power you can get from just a few well thought out interfaces and the means
to convert between them, and it’s a constant reminder of how well designed Go’s
standard library is.</p>



          </article>
        </div>
      </div></div>
  </body>
</html>
