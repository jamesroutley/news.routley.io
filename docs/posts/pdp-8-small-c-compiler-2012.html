<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://so-much-stuff.com/pdp8/C/Small-C.php">Original</a>
    <h1>PDP-8 Small-C Compiler (2012)</h1>
    
    <div id="readability-page-1" class="page"><div>
<tbody><tr>
<td>
    <p>As mentioned on the previous page, the architecture of the PDP-8 
is not really suited to C.  The job of the C compiler is to span this
gap.  In this PDP-8 implementation several, possibly contentious, 
decisions had to made.  One way to illustrate this is to look at a few 
alternative C compiler designs:

</p><dl>
<dt>
4K, no recursion, mostly native PDP-8 instruction sequences.
</dt><dd>
One of the possible ways to do a C compiler would be to mimic the way that 
assembler code is typically written for the PDP-8.  The PDP-8 doesn&#39;t support 
a notion of a base register (hence of a frame pointer), stack, etc.  So most 
PDP-8 code is written with explicit references to variables whose memory 
address is fixed.  This, together with the JMS instruction and the lack of 
a call stack, typically means non-recursive code.  Parameters typically 
follow the JMS instruction.  With the elimination of recursion, local variables 
can be of &#34;static&#34; storage class, for more efficient referencing.  (The result 
would actually be a bit like the FORTRAN II/SABR solution, but for C, or a subset 
of C, instead of for FORTRAN II.)
</dd><dt>
4K, recursion/stack/VM (Like this implementation.)
</dt><dd>
Another possibility would be to retain recursion, but &#34;lift&#34; the PDP-8 &#34;Virtual 
Machine&#34; to provide a stack, frame pointer, perhaps a couple of registers, etc.
This turns out to be the easiest, requiring few changes to the compiler, since 
the &#34;VM&#34; essentially emulates the machine the compiler is designed to target.
<p>
One of the decisions that has to be made in a C implementation is the representation 
of the basic types: &#34;char&#34;, &#34;int&#34;, &#34;long&#34; (if supported), and pointer types.  On the
PDP-8, keeping a pointer to a single word limits the address space to 4K.  An argument
can also be made for one-word &#34;int&#34;, since &#34;int&#34;s are supposed to be &#34;fast&#34;.  (An 
&#34;int&#34; is also supposed to be &#34;16 or more bits&#34;, but there&#39;s probably no way to do 
that that is not also slow.  There is ample precedent for ignoring the 16 bit rule on 
small processors in the world of C for micro-controllers.)  If pointers are to be a 
single word, &#34;char&#34; will probably also need to be a simple word.
</p></dd><dt>
32K/128K, recursion/stack/VM, big smart pointers, big ints.
</dt><dd>
To be practical for larger programs, it may be necessary to make pointers larger.
A representation which I think would work well would be two word pointers, where
the first word is a pointer to a subroutine (in the current field) to establish 
addressability to the object using the value in the second word.  Since pointers 
are big, and we have more memory to work with, we can also make &#34;int&#34; standard 
conformant at two words, and maybe even implement &#34;long&#34; at 3 words.  (Heck, 
even some floating point, maybe.)  We&#39;d still need a VM to implement the notions 
of frame pointer and stack pointer.
</dd><dt>
32K, recursion/stack, VM, SABR-style pointers, small or big ints.
</dt><dd>
A variation of the above idea, but it imposes a 4K limit on each module.  &#34;Near&#34; 
references (to use a term from my Intel 286 days) can still be used for data 
declared within the module, but &#34;far&#34; references for parameters and for externs 
in other modules, as other modules may have been loaded in a different field.
</dd><dt>
FORTRAN IV/FPP output
</dt><dd>
The FORTRAN IV implementation for the PDP-8 used a very different model of 
computation.  Essentially code is generated, not for the PDP-8, but rather 
for the Floating Point Processor (FPP).  On machines that don&#39;t have an FPP, 
an emulation provides the necessary VM.  The result would be much like the 
FORTRAN IV/RALF environment, but for (a subset of) C, rather than FORTRAN IV.
</dd></dl>
<p>
You can see there are several design decisions, and more combinations than 
are described above.  Here are the major decisions taken in this compiler:
</p><ul>
<li>The &#34;char&#34; and &#34;int&#34; types, as well as the pointer types, are all 
a single PDP-8 word.  This means the compiler isn&#39;t standard conformant, 
as an int should really be 16 or more bits, but I decided that doing 
extended precision arithmetic all the time would simply waste too much 
time and memory to be practical on such a small machine.
</li><li>The Small-C compiler was chosen (for it&#39;s simplicity), and a &#34;Virtual 
Machine&#34; was implemented on the PDP-8 that closely matches the machine 
used in Small-C &#34;middle-end&#34;, where the peep-hole optimizer does it&#39;s 
work.  Most of the operations are then implemented with a simple indirect 
JMS through a page 0 pointer.  Having these pointers on page zero also 
makes the code output by the compiler position independent, which rather 
simplifies the linker&#39;s job.
    <p>The VM implements a machine with two main &#34;registers&#34; for arithmetic, 
a third &#34;register&#34; used to pass the argument count to subroutines, a &#34;register&#34; 
used as a pointer, a frame pointer &#34;register&#34;, and a stack pointer &#34;register&#34;.  
These &#34;registers&#34; are actually implemented as memory locations on page zero.
    </p><p>The middle end op-codes/routines all follow a simple naming convention, 
which helps sort out what is going on in the code.  A simple example would be 
&#34;add12&#34; which adds the content of &#34;register 2&#34; to &#34;register 1&#34;, and leaves the 
result in &#34;register 1&#34;.  This operation would be invoked via &#34;JMS I __add12&#34;.
A more complicated example would be &#34;getw1s&#34; which takes a word of immediate 
offset following the &#34;JMS I __getw1s&#34;, adds it to the stack pointer, 
and loads the contents of that address into &#34;register 1&#34;.  This is typical of 
how a reference to a local variable or parameter would be loaded into &#34;register 1&#34;.  
    </p><p>There are also routines to call functions, return, push and pop arguments, etc. etc.
All told, there are over 80 such routines, and implementing them, together with 
their page zero pointers and &#34;register&#34; storage, takes about 660 (decimal) words.
That may not seem like that much, but it is about 17% of the available storage 
in field 1.
    </p><p>On the other hand, it does make the code position independent, which solves 
a variety of addressing mode problems and it also makes it possible to access stack-based 
variables with reasonable code density.
    </p><p>Another idea would be to try to trim down the size of the VM, eliminating 
some of the lesser-used &#34;opcodes&#34; in favor of longer sequences of simpler operations.
You&#39;d want to keep the resulting code density high, though.  One of the things 
that might work would be to eliminate &#34;register 2&#34;, always calculating into a 
single &#34;register&#34;, and storing to memory (or stack) as needed.
</p></li></ul>
<p>
You can go <a href="https://so-much-stuff.com/pdp8/C/C.php">back</a><a> to the &#34;C&#34; page, or </a><a href="https://so-much-stuff.com/pdp8/C/Assembler.php">on</a>
to the assembler page.

</p></td></tr></tbody></div></div>
  </body>
</html>
