<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/sekigon-gonnoc/Pico-PIO-USB">Original</a>
    <h1>Software defined USB port (Raspberry Pi pico RP2040)</h1>
    
    <div id="readability-page-1" class="page"><div>
			
			<p><small>February 15, 2022
            </small></p><p><em>Note: this is a follow-up to <a href="https://dubroy.com/blog/three-ways-of-handling-user-input/">Three ways of handling user input</a>. You should read that article first if you haven‚Äôt already!</em></p>


<p>In <a href="http://localhost:8000/blog/three-ways-of-handling-user-input/">my last post</a>, I looked at three different ways of handling user input in a web-based interface. The last approach I discussed was based on concurrent processes, using a small, proof-of-concept library I built called Abro.</p>
<p>Since writing the post, I discovered a Python library called <a href="https://github.com/python-trio/trio">Trio</a>, which enables a form of structured concurrency that‚Äôs similar to what I was attempting with Abro. The ideas behind Trio have influenced a number of other languages, including <a href="https://www.hackingwithswift.com/swift/5.5/structured-concurrency">Swift</a>, <a href="https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/06_StructuredConcurrency">Kotlin</a>, and <a href="https://openjdk.java.net/jeps/8277129">Java</a>. In JavaScript, <a href="https://github.com/thefrontside/effection">Effection</a> seems to be the most mature library.</p>
<h2>What is structured concurrency?</h2>
<p>The term <em>structured concurrency</em> is general enough that it‚Äôs been used to mean a lot of things over the years. The current usage, which comes from Martin S√∫strik, specifically means <strong>tree-structured concurrency</strong>. Here‚Äôs how he describes it:</p>
<blockquote>
<p>Structured concurrency means that lifetimes of concurrent functions are cleanly nested. If coroutine foo launches coroutine bar, then bar must finish before foo finishes.</p>
<p>This is not structured concurrency:</p>
<p><img src="https://dubroy.com/blog/images/structured-concurrency-1.jpg"/></p>
<p>This is structured concurrency:</p>
<p><img src="https://dubroy.com/blog/images/structured-concurrency-2.jpg"/></p>
<p>The goal of structured concurrency is to guarantee encapsulation. If the main function calls foo, which in turn launches bar in a concurrent fashion, main will be guaranteed that once foo has finished, there will be no leftover functions still running in the background.</p>
<p>What you end up with is a tree of coroutines rooted in the main function. This tree spreads out towards the smallest worker functions, and you may think of this as a generalization of the call stack ‚Äî a call tree, if you will.</p>
</blockquote>
<p><em>(From <a href="http://libdill.org/structured-concurrency.html">libdill: Structured Concurrency for C</a>)</em></p>
<h2>Implementing structured concurrency</h2>
<p><strong>or, <em>Lessons learned from Abro</em></strong></p>
<p>The key ingredients of structured concurrency are:</p>
<ol>
<li>Some form of coroutines, as the basis for concurrent processes (aka <em>fibers</em>, <em>tasks</em>, etc.).</li>
<li>An explicit parent-child relationship between processes.</li>
<li>A way of canceling processes from the outside, to ensure that no child can outlive its parent.</li>
</ol>
<p>Let‚Äôs take a look at how you can implement these things in JavaScript. Most of these things I learned the hard way, in the process of building and re-building Abro multiple times.</p>
<h3>Coroutines</h3>
<p>JavaScript actually has two different coroutine-like mechanisms: generators, and async functions. Without putting much thought into it, I built the first version of Abro on async functions. Later, after discovering some of the issues with this approach, I built a second version based on generators.</p>
<p>The main challenge was that async functions are scheduled implicitly: when a promise is ready, its <code>then</code>/<code>catch</code>/<code>finally</code> handlers are automatically scheduled (put into the microtask queue). So you schedule the processes/fibers by controlling the order in which the promises are resolved.</p>
<p>For this to work, the scheduler needs to be aware of all of the promises that are <code>await</code>ed by the fibers. In other words, a fiber can only use <code>await</code> on functions that are provided by the concurrency library (in my case, Abro). This is not a big limitation ‚Äî it‚Äôs possible to support ‚Äúforeign‚Äù promises as long as they‚Äôre wrapped by a scheduler-controlled promise ‚Äî but it‚Äôs a bit of a footgun. Using <code>await</code> with any other function would result in <em>all</em> threads being paused until the promise resolves.</p>
<p>Another problem I had was how to run bookkeeping code before a fiber executes. For example, it‚Äôs useful to keep track of which fiber is currently running. This is the solution that I ended up with:</p>
<pre><code>// Resolve the promises for all processes waiting on this event.
promises.forEach(({ fiber, resolve }) =&gt; {
  if (fiber.state === &#34;RUNNING&#34;) {
    queueMicrotask(() =&gt; { // üëà 2Ô∏è‚É£
      currentFiber = fiber;
    });
    resolve(evt); // üëà 1Ô∏è‚É£
  }
}</code></pre>


<p>Calling <code>resolve</code> (see 1Ô∏è‚É£ <a href="#code-resolve">‚Ü©</a>) will enqueue a microtask to perform the promise‚Äôs <code>then</code> operation. The call to <code>queueMicrotask</code> (see 2Ô∏è‚É£ <a href="#code-queueMicrotask">‚Ü©</a>) just before that allows me to run some code immediately before the fiber wakes up. Unfortunately, this relies on unspecified behaviour ‚Äî the ECMAScript spec <a href="https://262.ecma-international.org/12.0/#sec-jobs">allows implementations to treat Promise-handling jobs with higher priority</a>. But from what I can tell, V8 handles everything on the microtask queue with equal priority.</p>
<p>Using generators as the basis for coroutines eliminates these problems. It gives the scheduler full control, since a generator must be explicitly resumed by calling its <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next"><code>next</code></a> method. It‚Äôs also easy to distinguish between coroutine preemption (<code>yield</code>) and other async function calls. Even if the user makes a mistake (e.g. by <code>yield</code>ing the result of an async function), it‚Äôs easy to detect and raise a runtime error.</p>
<h3>Parent-child relationship</h3>
<p>Maintaining a parent-child relationship between fibers is straightforward as long as you keep track of the currently-running fiber. The fiber-creation primitives (e.g., <code>loop</code>, <code>run</code>, and <code>or</code> in Abro) can maintain a list of each fiber‚Äôs children.</p>
<h3>Cancelation</h3>
<p>To ensure that no fiber can outlive its parent, we need a way to cleanly terminate fibers. How this works depends on the coroutine mechanism ‚Äî either way, we have a notion of explicit <em>suspension points</em> (identified by <code>yield</code> or <code>await</code>) where a fiber yields control to the scheduler. These are the same points where fiber can be canceled.</p>
<p>In the original version of Abro, I handled cancelation by (a) keeping track of the promise that each fiber was waiting on, and (b) rejecting that promise when I needed to cancel the fiber. This requires that a unique promise is created at any possible suspension point, and that promises are never shared between fibers.</p>
<p>In the drag-and-drop example I used in my previous post, the yield points all looked something like this:</p>
<pre><code>const events = new abro.EventSource(draggable);
// ...
await events.pointerdown;</code></pre>


<p>‚Ä¶where <code>events.pointerdown</code> was a getter that allocated a new promise each time. Even if two fibers are waiting on the same event, it‚Äôs important that promises aren‚Äôt shared. Depending on the relationship between the fibers, it may be necessary to cancel one but not the other. If each promise is owned by a single fiber, then we can cancel a fiber by rejecting the promise that it‚Äôs waiting on, without affecting any other fibers.</p>
<p>This solution works, but obviously it‚Äôs not ideal. For one thing, there‚Äôs no way to prevent promises from being shared between fibers. And there‚Äôs another problem: rejecting a promise results in an exception being raised in the async function. It‚Äôs possible that user code might (inadvertently or deliberately) handle the rejection and continue running. For example:</p>
<pre><code>try {
  await events.pointerdown; // ‚¨Ö If this promise is rejected...
} finally {
  // ...then by the time this block is executed, the parent fiber could
  // have already exited ‚Äî¬†breaking the promise of structured concurrency.
  await events.pointerup;
}</code></pre>


<p>With generator-based coroutines, cancelation is trivial. Since the scheduler must explicitly resume fibers, we can cancel a fiber by simply discarding it (along with any associated state).</p>
<p>You do still need to be careful that fibers don‚Äôt share state in certain ways. For example, in the generator-based version of Abro, the yield points look like this:</p>
<pre><code>yield abro.await(document, &#34;pointerdown&#34;);</code></pre>


<p>The result of <code>abro.await</code> is a promise-like object (but specific to Abro). Depending on the implementation, sharing such an object between fibers could still be problematic.</p>


<p>By this point, it‚Äôs probably clear that generator-based coroutines are a much better foundation for structured concurrency in JavaScript. Effection, a JavaScript library for structured concurrency, <a href="https://frontside.com/effection/docs/guides/tasks">is based on generators</a>. Trio uses Python 3‚Äôs <code>async</code>/<code>await</code> syntax, but Python‚Äôs async functions are much closer to generators than they are to JavaScript‚Äôs async functions.</p>
<p>Building Abro was a great exercise to help me dig deeper into these ideas, but I don‚Äôt currently have plans to develop it further. I‚Äôve already started to use <a href="https://frontside.com/effection">Effection</a> in new projects.</p>
<p>If you want to learn more about the ideas behind structured concurrency, you should read <a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Notes on structured concurrency, or: Go statement considered harmful</a> from the author of Trio. The Trio forum also has a <a href="https://trio.discourse.group/c/structured-concurrency/7">a separate category for general discussion of structured concurrency</a> (in any language). There‚Äôs some interesting historical discussions, and links to other articles, talks, etc.</p>
<p>üí¨ <em>Want to leave feedback? <a href="https://dubroy.com/blog/about/#contact">Send me an email</a> or <a href="https://twitter.com/dubroy/status/1493587148452384776">respond on on Twitter</a>.</em></p>


<p>If you liked this post, you should consider <a href="https://buttondown.email/pdubroy">subscribing to my newsletter</a>! I share all new posts there, and the occasional newsletter-only content.</p></div></div>
  </body>
</html>
