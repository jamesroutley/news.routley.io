<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.berkansasmaz.com/every-programmer-should-know-idempotency/">Original</a>
    <h1>Every Programmer Should Know #1: Idempotency</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        


        <div>
        <section>

            <ul>
                <li>
                    <a href="https://www.berkansasmaz.com/author/berkan/">
                        <img src="https://www.berkansasmaz.com/content/images/size/w100/2023/04/avatar-1.png" alt="Berkan Sasmaz"/>
                    </a>
                </li>
            </ul>

            <div>
                
                <p><time datetime="2023-09-20">Sep 20, 2023</time>
                        <span><span>•</span> 6 min read</span>
                </p>
            </div>

        </section>
        </div>

            <figure>
                <img srcset="/content/images/size/w300/2023/09/1.1.0.JPG 300w,
                            /content/images/size/w600/2023/09/1.1.0.JPG 600w,
                            /content/images/size/w1000/2023/09/1.1.0.JPG 1000w,
                            /content/images/size/w2000/2023/09/1.1.0.JPG 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://www.berkansasmaz.com/content/images/size/w2000/2023/09/1.1.0.JPG" alt="Every Programmer Should Know #1: Idempotency"/>
                    <figcaption>Topkapi Palace Museum</figcaption>
            </figure>

    </header>

    <section>
        <p>In the world of programming, there are many concepts that every developer should understand in order to build efficient and reliable systems. One such vital concept is idempotency, which refers to the property of an operation or function that produces the same result when applied multiple times as it does when applied only once. This may seem like a simple concept, but it has significant implications for building distributed systems. In this article, we will explore what idempotency is, why it is important, and how to achieve it. Whether you are a beginner or an experienced developer, understanding idempotency is an essential skill that will help you build more robust and reliable systems.</p><h2 id="why-should-programmers-care-about-it">Why Should Programmers Care About It?</h2><p>Idempotency is a concept that is important for programmers to understand, especially those working on building distributed systems. In simple terms, idempotency means that if you perform an operation multiple times, the end result should be the same as if you had only performed it once.</p><p>In other words, an idempotent operation is one that can be repeated multiple times without causing any additional side effects. This is important in distributed systems because messages can sometimes be lost or duplicated due to network issues, and if an operation is not idempotent, repeating it can cause unintended consequences.</p><p>Let&#39;s say you&#39;re building an API for processing payments. If you design the API with idempotency in mind, you can ensure that even if the same payment request is sent multiple times due to network issues, it will only be processed once. This can prevent double-charging customers, which can lead to trust issues and lost revenue.</p><!--kg-card-begin: html--><blockquote> The &#34;same&#34; request hitting your API should not modify your state for the second time. (<a href="https://x.com/mjovanovictech/status/1685169352432140288?s=20&amp;ref=berkansasmaz.com" target="_blank">Milan Jovanović - Tweet</a>)</blockquote><!--kg-card-end: html--><figure><img src="https://www.berkansasmaz.com/content/images/2023/09/3..JPG" alt="" loading="lazy" width="2000" height="1333" srcset="https://www.berkansasmaz.com/content/images/size/w600/2023/09/3..JPG 600w, https://www.berkansasmaz.com/content/images/size/w1000/2023/09/3..JPG 1000w, https://www.berkansasmaz.com/content/images/size/w1600/2023/09/3..JPG 1600w, https://www.berkansasmaz.com/content/images/size/w2400/2023/09/3..JPG 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Topkapi Palace Museum</figcaption></figure><h2 id="a-little-more-idempotency-apis">A little more Idempotency APIs</h2><p>We use many methods to design our systems to tolerate and reduce the probability of failure and avoid turning a small percentage of failures into a complete outage. Some of these are especially vital in distributed systems.</p><figure><img src="https://www.berkansasmaz.com/content/images/2023/09/Renkli-Modern-Al-nt--Motivasyon-Facebook-Go-nderisi.png" alt="" loading="lazy" width="940" height="788" srcset="https://www.berkansasmaz.com/content/images/size/w600/2023/09/Renkli-Modern-Al-nt--Motivasyon-Facebook-Go-nderisi.png 600w, https://www.berkansasmaz.com/content/images/2023/09/Renkli-Modern-Al-nt--Motivasyon-Facebook-Go-nderisi.png 940w" sizes="(min-width: 720px) 720px"/><figcaption>Microservices example</figcaption></figure><p>Let&#39;s say we have a food ordering application, and to keep our application simple, let&#39;s say we have two basic services, Shipping and Order. When one of our customers places an order, first the order is created, and then shipping instructions are created. If all transactions are successful, it sends a notification to the client. Even in this simple scenario, many failures can occur. These failures can come from a variety of factors. They include servers, networks, load balancers, software, operating systems, or even mistakes from system operators. For example, even if the order and shipping service do their job properly, what happens if the customer cannot receive a response due to network latency while returning the response? Of course, the first thing that comes to mind for such cases is to use patterns such as timeout, retry, and backoff. But what if we try the service call again in this scenario? Is it a situation that we want to re-order? Retrying the request can result in multiple orders with very serious consequences. That&#39;s why it&#39;s important to design Idempotent APIs.</p><h3 id="idempotency-with-http-methods">Idempotency with HTTP Methods</h3><p>HTTP (Hypertext Transfer Protocol) is a widely used protocol for communicating between web servers and clients. Idempotency plays an important role in the design of HTTP methods, which are used to define the type of action that a client wants to perform on a resource. In this section, we will explore how idempotency applies to some HTTP methods.</p><ol><li><code>GET</code> Method:</li><li><code>PUT</code> Method:</li><li><code>DELETE</code> Method:</li><li><code>POST</code> Method:</li></ol><figure><img src="https://www.berkansasmaz.com/content/images/2023/09/3.0.JPG" alt="" loading="lazy" width="2000" height="1333" srcset="https://www.berkansasmaz.com/content/images/size/w600/2023/09/3.0.JPG 600w, https://www.berkansasmaz.com/content/images/size/w1000/2023/09/3.0.JPG 1000w, https://www.berkansasmaz.com/content/images/size/w1600/2023/09/3.0.JPG 1600w, https://www.berkansasmaz.com/content/images/size/w2400/2023/09/3.0.JPG 2400w" sizes="(min-width: 1200px) 1200px"/><figcaption>Istanbul</figcaption></figure><h2 id="and-now-a-brief-pause-for-a-personal-note">And now a brief pause for a personal note</h2><p>I want to make sure that my newsletter is meeting your needs and providing you with valuable content. That&#39;s why I am taking a brief pause to ask for your input.</p><h2 id="how-to-achieve-idempotency-in-post-method">How to achieve idempotency in POST method?</h2><p>In a distributed system with many clients making many calls and with many requests in flight, the challenge is how do we identify that a request is a repeat of some previous request?</p><p>Simply, it is possible to make a POST request idempotent by including a unique identifier in the request body or header, which can be used to identify and prevent duplicate requests.</p><p>Many approaches can be used to determine whether a request is a copy of an earlier request. For example, it may be possible to derive a synthetic token based on the parameters in the request. You can derive a hash of existing parameters and assume that any request with the same parameters from the same caller is a duplicate. On the surface, this seems to simplify both the customer experience and service implementation. Any request that looks exactly like a previous request is considered a duplicate request. However, this approach is unlikely to work in all situations. For example, let&#39;s say you order a meal, and when your next-door neighbor orders the same meal, are these requests repeated or are they two different requests? Or after you place an order, your friend calls and says he&#39;s hungry, and when you re-create the same order a short time later, will we treat them as renewed requests? Is this scenario very similar to the client retrying the service because of the network latency we just mentioned? It’s possible that the caller actually wants two identical meals.</p><p>The generally preferred approach is to include a unique caller-supplied client request identifier in the API contract. Requests from the same caller with the same customer request identifier can be considered duplicate requests and handled accordingly. A unique caller-supplied client request identifier for idempotent operations satisfies this need.</p><p>The following diagram shows a sample request/response flow that uses a unique client request identifier in an idempotent retry scenario:</p><figure><a href="https://github.com/ikyriak/IdempotentAPI?ref=berkansasmaz.com"><img src="https://www.berkansasmaz.com/content/images/2023/09/IdempotentAPI_FlowExample.png" alt="" loading="lazy" width="700" height="604" srcset="https://www.berkansasmaz.com/content/images/size/w600/2023/09/IdempotentAPI_FlowExample.png 600w, https://www.berkansasmaz.com/content/images/2023/09/IdempotentAPI_FlowExample.png 700w"/></a><figcaption>A simplified example of the <code>IdempotentAPI</code> flow for two exact POST requests. </figcaption></figure><p>In this example, a customer requests the creation of a resource that presents a unique client request identifier. On receiving the request, the service first checks to see if it has seen this identifier before. If it has not, it starts to process the request. It creates and stores an idempotent “session” for this request keyed off the customer identifier and their unique client request identifier. If a subsequent request is received from the same customer with the same unique client request identifier, then the service knows it has already seen this request and can take appropriate action.</p><p>There are two important points here. One is how long the unique customer request identifier will be stored and the other one is not successful if the transaction is not successful, the unique customer request identifier should not be created, that is, it should be an <strong>ACID</strong> transaction.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we have explored how idempotency applies to HTTP methods, which are a fundamental part of web development. We have seen that some HTTP methods, such as <strong>GET</strong>, <strong>PUT</strong>, and <strong>DELETE</strong>, are idempotent, while others, such as <strong>POST</strong>, are not. Knowing which methods are idempotent is crucial for building efficient and reliable systems.</p><p>Overall, understanding and implementing idempotency can help you build more robust and reliable systems, which is crucial in today&#39;s world of distributed systems. Whether you are a beginner or an experienced developer, understanding idempotency is an essential skill that will help you build better software.</p><p>Thanks for reading! If you enjoyed this newsletter, please share it with your friends and/or subscribe!</p>
    </section>

        

</article>
</div></div>
  </body>
</html>
