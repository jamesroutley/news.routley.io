<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tbray.org/ongoing/When/202x/2025/08/14/RFC9839">Original</a>
    <h1>RFC 9839 and Bad Unicode</h1>
    
    <div id="readability-page-1" class="page"><div id="centercontent">
<p itemprop="description">Unicode is good. If you’re designing a data structure or protocol that has text fields, they should contain
    Unicode characters encoded in UTF-8. There’s another question, though:
    “<em>Which</em> Unicode characters?” The 
    answer is “Not all of them, please exclude some.”</p>

<p>This issue keeps coming up, so Paul Hoffman and I put together an individual-submission draft
    to the IETF and now (where by “now” I mean “two years later”) it’s been published as
    <a href="https://www.rfc-editor.org/rfc/rfc9839.html">RFC 9839</a>. It explains which characters are bad, and why, then offers
    three plausible less-bad subsets that you might want to use.
    Herewith a bit of background, but…</p>

<p id="p-2"><span>Please</span> · 
If you’re actually working on something new that will have text fields, please read the RFC. It’s only ten pages long, and that’s
    with all the IETF boilerplate. It’s written specifically for software and networking people.</p>

<p id="p-3"><span>The smoking gun</span> · 
The badness that 9839 focuses on is “problematic characters”, so let’s start with a painful example of what that means.
    Suppose you’re designing a protocol that uses JSON and one of your constructs has a <code>username</code> field.
    Suppose you get this message (I omit all the non-<code>username</code> fields). It’s 
    a perfectly legal JSON text:</p>

<div><pre><span></span><span>{</span>
  <span>  </span><span>&#34;username&#34;</span><span>:</span><span> </span><span>&#34;\u0000\u0089\uDEAD\uD9BF\uDFFF&#34;</span>
<span>}</span>    </pre></div>
    <p>Unpacking all the JSON escaping gibberish reveals that the value of the <code>username</code> field contains four 
    numeric “code points” identifying Unicode characters:</p>

    <ol>
      <li><p>The first code point is zero, in Unicode jargon <code>U+0000</code>. In human-readable text it
      has no meaning, but it will interfere with the operation of certain programming languages.</p>
</li>
      <li><p>Next is Unicode <code>U+0089</code>, official name “CHARACTER TABULATION WITH JUSTIFICATION”. It’s what Unicode calls a
      <a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes">C1
      control code</a>, inherited from ISO/IEC 6429:1992, adopted from 
      <a href="https://www.ecma-international.org/wp-content/uploads/ECMA-48_5th_edition_june_1991.pdf">ECMA 48</a> (1991), which calls it
      “HTJ” and says: <i>HTJ causes the contents of the active field (the field in the presentation component that contains the
      active presentation position) to be shifted forward so that it ends at the character position preceding the
      following character tabulation stop. The active presentation position is moved to that following character
      tabulation stop. The character positions which precede the beginning of the shifted string are put into the
      erased state.</i></p>

      <p>Good luck with that.</p>
</li>
      <li><p>The third code point, <code>U+DEAD</code>, in Unicode lingo, is an “unpaired surrogate”.  To understand,
      you’d have to learn how Unicode’s much-detested
      <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> encoding works.
      I recommend not bothering.</p>

      <p>All you need to know is that surrogates are only meaningful when they come in pairs in UTF-16 encoded text. There is
      effectively no such text on the wire and thus no excuse for tolerating surrogates in your data. In fact, the UTF-8 specification
      says that you mustn’t use UTF-8 to encode surrogates. But the real problem is that different libraries in different
      programming languages don’t always do the same things when they encounter this sort of fœtid interloper.</p>
    </li>
      <li><p>Finally, <code>\uD9BF\uDFFF</code> is JSON for the code point <code>U+7FFFF</code>.
      Unicode has a category called “noncharacter”, containing a few dozen code points that, for a variety of
      reasons, some good, 
      don’t represent anything and must not be interchanged on the wire. <code>U+7FFFF</code> is one of those.</p>
</li>
    </ol>
    <p>The four code points in the example are all clearly problematic. 
    The just-arrived RFC 9839 formalizes the notion of “problematic” and
    offers easy-to-cite language saying which of these problematic types you want to
    exclude from your text fields. Which, if you’re going to use JSON, you should probably do.</p>

    <p id="p-6"><span>Don’t blame Doug</span> · 
    Doug Crockford I mean, the inventor of JSON.  If he (or I or really anyone careful) were inventing JSON now that Unicode is
    mature, he’d have been fussier about its character repertoire. Having said that, we’re stuck with JSON-as-it-is forever, so we
    need a good way to say which of the problematic characters we’re going to exclude even if JSON allows them.</p>

    <p id="p-5"><span>PRECISion</span> · 
    You may find yourself wondering why the IETF waited until 2025 to provide help with Bad Unicode.
    It didn’t; here’s
    <a href="https://www.rfc-editor.org/rfc/rfc8264.html">RFC 8264</a>: <cite>PRECIS Framework: Preparation, Enforcement, and
    Comparison of Internationalized Strings in Application Protocols</cite>; the first PRECIS predecessor was published in 2002.
    8264 is 43 pages long, containing a <em>very</em>
    thorough discussion of many more potential Bad Unicode issues than 9839 does.</p>

    <p>Like 9839, PRECIS specifies subsets of the Unicode character repertoire and goes further, providing a mechanism for defining
    more.</p>

    <p>Having said that, PRECIS doesn’t seem to be very widely used by people who are defining new data structures and protocols. My
    personal opinion is that there are two problems which make it hard to adopt. First, it’s large and 
    complex, with many moving parts, and requires careful study to understand. Developers are (for good reason) lazy.</p>

    <p>Second, using PRECIS ties you to a specific version of Unicode. In particular, it forbids the use of the (nearly a million)
    unassigned code points. Since each release of Unicode includes new code point assignments, that means that a sender and receiver
    need to agree on exactly which version of Unicode they’re both going to use if they want reliably interoperable behavior. This
    makes life difficult for anyone writing a general-purpose code designed to be used in lots of different applications.</p>

    <p>I personally think that the only version of Unicode anybody wants to use is “as recent as possible”, so they can be confident
    of having all the latest emojis.</p>

    <p>Anyhow, 9839 is simpler and dumber than PRECIS. But I think some people will find it useful and now the IETF agrees.</p>

    <p id="p-7"><span>Source code</span> · 
    I’ve written a little Go-language library to validate incoming text fields against each of the three subsets that 9839
    specifies,
    <a href="https://github.com/timbray/RFC9839">here</a>.  I don’t claim it’s optimal, but it is well-tested.</p>

    <p>It doesn’t have a version number or release just yet, I’ll wait till a few folk have had a chance to spot any dumb mistakes I
    probably made.</p>

    <p id="p-9"><span>Details</span> · 
    Here’s a compact summary of the world of problematic Unicode code points and data formats and standards.</p>

    <table>
      <tbody><tr><td></td><th colspan="3">Problematic classes excluded?</th></tr>
      <tr><td></td><th>Surrogates</th><th>Legacy controls</th><th>Noncharacters</th></tr>
      <tr><td>CBOR</td><td>yes</td><td>no</td><td>no</td></tr>
      <tr><td>I-JSON</td><td>yes</td><td>no</td><td>yes</td></tr>
      <tr><td>JSON</td><td>no</td><td>no</td><td>no</td></tr>
      <tr><td>Protobufs</td><td>no</td><td>no</td><td>no</td></tr>
      <tr><td>TOML</td><td>yes</td><td>no</td><td>no</td></tr>
      <tr><td>XML</td><td>yes</td><td>partial [1]</td><td>partial [2]</td></tr>
      <tr><td>YAML</td><td>yes</td><td>mostly [3]</td><td>partial [2]</td></tr>
      <tr><td></td><th colspan="3">RFC 9839 Subsets</th></tr>
      <tr><td>Scalars</td><td>yes</td><td>no</td><td>no</td></tr>
      <tr><td>XML</td><td>yes</td><td>partial</td><td>partial</td></tr>
      <tr><td>Assignables</td><td>yes</td><td>yes</td><td>yes</td></tr>
    </tbody></table>
    <p>Notes:</p>

    <p><b>[1]</b> XML allows C1 controls.</p>

    <p><b>[2]</b> XML and YAML don’t exclude the noncharacters outside the Basic Multilingual Pane.</p>

    <p><b>[3]</b> YAML excludes all the legacy controls except for the mostly-harmless <code>U+0085</code>, another version of
    <code>\n</code> used in IBM mainframe documents.</p>

    <p id="p-8"><span>Thanks!</span> · 
    9839 is not a solo production. It received an extraordinary amount of discussion and improvement from a lot of smart and
    well-informed people 
    and the published version, 15 draft revisions later, is immensely better than my initial draft. My sincere thanks go to my
    co-editor Paul Hoffman and to all those mentioned in the RFC’s “Acknowledgements” section.</p>

    <p id="p-4"><span>On individual submissions</span> · 
    9839 is the second “individual submission” RFC I’ve pushed through the IETF (the other is
    <a href="https://datatracker.ietf.org/doc/html/rfc7725">RFC 7725</a>, which registers the HTTP 451 status code).  While it’s nice
    to decide something is worth standardizing and eventually have that happen, it’s really a lot of work. Some of that work is
    annoying.</p>

    <p>I’ve been involved in
    other efforts as Working-Group member, WG chair, and WG specification editor, and I can report authoritatively that creating an
    RFC the traditional way, through a Working Group, is easier and better.</p>

    <p>I feel discomfort advising others not to follow in my footsteps, but in this case I think it’s the right advice.</p>

  <hr/>


<hr/>

</div></div>
  </body>
</html>
