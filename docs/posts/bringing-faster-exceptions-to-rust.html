<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://purplesyringa.moe/blog/bringing-faster-exceptions-to-rust/">Original</a>
    <h1>Bringing Faster Exceptions to Rust</h1>
    
    <div id="readability-page-1" class="page"><section><div><h2>Bringing faster exceptions to Rust</h2><p><time>November 6, 2024</time><a href="https://www.reddit.com/r/rust/comments/1gl050z/bringing_faster_exceptions_to_rust/"> Reddit</a></p><p>Three months ago, I wrote about why <a href="https://purplesyringa.moe/blog/you-might-want-to-use-panics-for-error-handling/">you might want to use panics for error handling</a>. Even though it’s a catchy title, panics are hardly suited for this goal, even if you try to hack around with macros and libraries. The real star is <em>the unwinding mechanism</em>, which powers panics. This post is the first in a series exploring what unwinding is, how to speed it up, and how it can benefit Rust and C++ programmers.</p><p>Check out the <a href="https://lib.rs/lithium">Lithium</a> crate for faster exceptions and unwinding in Rust.</p><p>Typically, a function returns to the statement immediately following the call:</p><pre><code><span>fn</span> <span>f</span>() {
    <span>let</span> <span>x</span> = <span>g</span>();
    dbg!(x); 
}

<span>fn</span> <span>g</span>() <span>-&gt;</span> <span>i32</span> {
    <span>return</span> <span>123</span>;
}
</code></pre><p>Now imagine that calls could specify <em>alternate</em> return points, letting the callee decide the statement to return to:</p><pre><code>
<span>fn</span> <span>f</span>() {
    <span>g</span>() alternate |x| {
        dbg!(x); 
    };
}

<span>fn</span> <span>g</span>() <span>-&gt;</span> () alternate <span>i32</span> {
    return_alternate <span>123</span>;
}
</code></pre><p>At first glance, this looks straightforward. Returning to an alternate address shouldn’t be significantly more expensive than returning to the default address, so this has to be cheap.</p><p>But wait. This alternate return mechanism reminds me of something…</p><pre><code>
<span>fn</span> <span>f</span>() {
    <span>g</span>() catch |x| {
        dbg!(x); 
    };
}

<span>fn</span> <span>g</span>() <span>-&gt;</span> () throws <span>i32</span> {
    throw <span>123</span>;
}
</code></pre><p>That’s just exceptions! And we all know exceptions are slow. How did we get from alternate return addresses to something you should avoid at all costs in performant code?</p><p>The core of the alternate return mechanism is <em>the unwinder</em>, a system library responsible for mapping default return addresses to alternate return addresses, passing alternate return values across calls, and consuming the return values. The specific API differs between operating systems, but on Linux, the main parts are these two functions:</p><ul><li><code>_Unwind_RaiseException(Exception)</code>: Perform an alternate return, assuming we’re currently in a default return point.</li><li><code>_Unwind_Resume(Exception)</code>: Perform an alternate return, assuming we’re currently in an alternate return point.</li></ul><p>So, what implementation detail makes panics and exceptions so slow? We’ll uncover this in the series, and today, we’ll try to speed up the Rust side of panic handling without modifying the unwinder.</p><h2>Digging deeper</h2><p>Let’s start by measuring Rust’s current panic performance with <a href="https://docs.rs/criterion">criterion</a>:</p><pre><code>
std::panic::<span>set_hook</span>(<span>Box</span>::<span>new</span>(|_| {}));

b.<span>iter</span>(|| {
    <span>let</span> <span>_</span> = std::panic::<span>catch_unwind</span>(|| <span>panic!</span>(<span>&#34;Hello, world!&#34;</span>));
})
</code></pre><p>Result: <code>2.3814 µs</code>. That’s less than a million panics per second. Why is it this slow?</p><p>Let’s see what happens when you call <code>panic!()</code>. After passing arguments through some macro calls, we land on <code>core::panic::panic_fmt</code>:</p><pre><code><span>pub</span> <span>const</span> <span>fn</span> <span>panic_fmt</span>(fmt: fmt::Arguments&lt;<span>&#39;_</span>&gt;) <span>-&gt;</span> ! {
    

    <span>extern</span> <span>&#34;Rust&#34;</span> {
        <span>#[lang = <span>&#34;panic_impl&#34;</span>]</span>
        <span>fn</span> <span>panic_impl</span>(pi: &amp;PanicInfo&lt;<span>&#39;_</span>&gt;) <span>-&gt;</span> !;
    }

    <span>let</span> <span>pi</span> = PanicInfo::<span>new</span>(
        fmt,
        Location::<span>caller</span>(),
         <span>true</span>,
         <span>false</span>,
    );

    <span>unsafe</span> { <span>panic_impl</span>(&amp;pi) }
}
</code></pre><p>The format arguments are type-erased, which prevents some optimizations.</p><p>In addition, many Rust builtins panic, so <code>panic!</code> is defined in <code>core</code>, but the panic mechanism is OS-dependent, so panicking is implemented in <code>std</code>. Therefore, <code>panic_impl</code> is an extern function crossing crate boundaries, which prevents inlining without LTO.</p><pre><code><span>pub</span> <span>fn</span> <span>begin_panic_handler</span>(info: &amp;core::panic::PanicInfo&lt;<span>&#39;_</span>&gt;) <span>-&gt;</span> ! {
    <span>struct</span> <span>FormatStringPayload</span>&lt;<span>&#39;a</span>&gt; {  }

    

    <span>unsafe</span> <span>impl</span> <span>PanicPayload</span> <span>for</span> <span>FormatStringPayload</span>&lt;<span>&#39;_</span>&gt; {
        <span>fn</span> <span>take_box</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> *<span>mut</span> (<span>dyn</span> Any + <span>Send</span>) {
            
            
            
            <span>let</span> <span>contents</span> = mem::<span>take</span>(<span>self</span>.<span>fill</span>());
            <span>Box</span>::<span>into_raw</span>(<span>Box</span>::<span>new</span>(contents))
        }

        
    }

    

    crate::sys::backtrace::__rust_end_short_backtrace(<span>move</span> || {
        <span>if</span> <span>let</span> <span>Some</span>(s) = msg.<span>as_str</span>() {
            
        } <span>else</span> {
            <span>rust_panic_with_hook</span>(
                &amp;<span>mut</span> FormatStringPayload { inner: &amp;msg, string: <span>None</span> },
                loc,
                info.<span>can_unwind</span>(),
                info.force_no_backtrace(),
            );
        }
    })
}


<span>fn</span> <span>rust_panic_with_hook</span>(
    payload: &amp;<span>mut</span> <span>dyn</span> PanicPayload,
    location: &amp;Location&lt;<span>&#39;_</span>&gt;,
    can_unwind: <span>bool</span>,
    force_no_backtrace: <span>bool</span>,
) <span>-&gt;</span> ! {
    
    <span>match</span> *HOOK.<span>read</span>().<span>unwrap_or_else</span>(PoisonError::into_inner) {
        
        Hook::<span>Custom</span>(<span>ref</span> hook) =&gt; {
            <span>hook</span>(&amp;PanicHookInfo::<span>new</span>(location, payload.<span>get</span>(), can_unwind, force_no_backtrace));
        }
    }
    
    <span>rust_panic</span>(payload)
}
</code></pre><p>Here, we generate a type-erased panic payload object that wraps the format arguments in another type-erased box, and then we invoke the panic hook – before unwinding even starts!</p><p>Luckily, we can skip most of this logic by calling <code>std::panic::resume_unwind</code> instead of <code>panic!</code>. This function ignores the panic hook and takes a <code>Box&lt;dyn Any + Send&gt;</code> argument instead of an arbitrary format string, which lets us shed some load:</p><pre><code>b.<span>iter</span>(|| {
    <span>let</span> <span>_</span> = std::panic::<span>catch_unwind</span>(|| std::panic::<span>resume_unwind</span>(<span>Box</span>::<span>new</span>(<span>&#34;Hello, world!&#34;</span>)));
})
</code></pre><p>Result: <code>1.8379 µs</code>, a 24% improvement. Not bad for simply removing indirection!</p><p><code>resume_unwind</code> forwards calls to <a href="https://doc.rust-lang.org/1.82.0/src/std/panicking.rs.html#828-850">rust_panic_without_hook</a>:</p><pre><code><span>pub</span> <span>fn</span> <span>rust_panic_without_hook</span>(payload: <span>Box</span>&lt;<span>dyn</span> Any + <span>Send</span>&gt;) <span>-&gt;</span> ! {
    panic_count::<span>increase</span>(<span>false</span>);

    <span>struct</span> <span>RewrapBox</span>(<span>Box</span>&lt;<span>dyn</span> Any + <span>Send</span>&gt;);

    <span>unsafe</span> <span>impl</span> <span>PanicPayload</span> <span>for</span> <span>RewrapBox</span> {
        <span>fn</span> <span>take_box</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> *<span>mut</span> (<span>dyn</span> Any + <span>Send</span>) {
            <span>Box</span>::<span>into_raw</span>(mem::<span>replace</span>(&amp;<span>mut</span> <span>self</span>.<span>0</span>, <span>Box</span>::<span>new</span>(())))
        }
        
    }
    
    <span>rust_panic</span>(&amp;<span>mut</span> <span>RewrapBox</span>(payload))
}

<span>fn</span> <span>rust_panic</span>(msg: &amp;<span>mut</span> <span>dyn</span> PanicPayload) <span>-&gt;</span> ! {
    <span>let</span> <span>code</span> = <span>unsafe</span> { __rust_start_panic(msg) };
    rtabort!(<span>&#34;failed to initiate panic, error {code}&#34;</span>)
}

<span>extern</span> <span>&#34;Rust&#34;</span> {
    
    
    <span>fn</span> <span>__rust_start_panic</span>(payload: &amp;<span>mut</span> <span>dyn</span> PanicPayload) <span>-&gt;</span> <span>u32</span>;
}
</code></pre><p>There’s still type-erasure here: firstly, the payload is <code>Box&lt;dyn Any + Send&gt;</code>, and secondly, we cast <code>&amp;mut RewrapBox</code> to <code>&amp;mut dyn PanicPayload</code>. None of this is necessary for statically typed alternate returns. The double-panic protection (<code>panic_count</code>) wouldn’t be required in this context either.</p><p>So what do you say we call <code>__rust_start_panic</code> directly?</p><pre><code><span>#![feature(std_internals)]</span>

<span>use</span> core::any::Any;
<span>use</span> core::panic::PanicPayload;

<span>struct</span> <span>RewrapBox</span>(<span>Box</span>&lt;<span>dyn</span> Any + <span>Send</span>&gt;);

<span>unsafe</span> <span>impl</span> <span>PanicPayload</span> <span>for</span> <span>RewrapBox</span> {
    <span>fn</span> <span>take_box</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> *<span>mut</span> (<span>dyn</span> Any + <span>Send</span> + <span>&#39;static</span>) {
        <span>Box</span>::<span>into_raw</span>(core::mem::<span>replace</span>(&amp;<span>mut</span> <span>self</span>.<span>0</span>, <span>Box</span>::<span>new</span>(())))
    }

    <span>fn</span> <span>get</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> &amp;(<span>dyn</span> Any + <span>Send</span> + <span>&#39;static</span>) {
        &amp;*<span>self</span>.<span>0</span>
    }
}

<span>impl</span> <span>core</span>::fmt::Display <span>for</span> <span>RewrapBox</span> {
    <span>fn</span> <span>fmt</span>(&amp;<span>self</span>, f: &amp;<span>mut</span> core::fmt::Formatter&lt;<span>&#39;_</span>&gt;) <span>-&gt;</span> core::fmt::<span>Result</span> {
        f.<span>write_str</span>(<span>&#34;Box&lt;dyn Any&gt;&#34;</span>)
    }
}

<span>unsafe</span> <span>extern</span> <span>&#34;Rust&#34;</span> {
    safe <span>fn</span> <span>__rust_start_panic</span>(payload: &amp;<span>mut</span> <span>dyn</span> PanicPayload) <span>-&gt;</span> <span>u32</span>;
}

b.<span>iter</span>(|| {
    <span>let</span> <span>_</span> = std::panic::<span>catch_unwind</span>(|| {
        __rust_start_panic(&amp;<span>mut</span> <span>RewrapBox</span>(<span>Box</span>::<span>new</span>(<span>&#34;Hello, world!&#34;</span>)))
    });
})
</code></pre><p>Result: <code>580.44 ns</code>. That’s a 68% improvement! It’s not <em>sound</em>, as we’re now messing with the panic counter, but we’ll fix this soon.</p><p>Let’s figure out how to bypass the mirroring decrement of the panic count. We’re looking for <code>std::panic::catch_unwind</code>, which merely forwards the call <a href="https://doc.rust-lang.org/1.82.0/src/std/panicking.rs.html#474-584">here</a>. After adding <code>#[inline(always)]</code>, removing <code>#[cold]</code>, and removing the panic count decrement, we restore soundness without affecting performance.</p><p>The next layer of abstraction to peel is these two functions:</p><pre><code><span>extern</span> <span>&#34;Rust&#34;</span> <span>fn</span> <span>__rust_start_panic</span>(payload: &amp;<span>mut</span> <span>dyn</span> PanicPayload) <span>-&gt;</span> <span>u32</span>;
<span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>__rust_panic_cleanup</span>(payload: *<span>mut</span> <span>u8</span>) <span>-&gt;</span> *<span>mut</span> (<span>dyn</span> Any + <span>Send</span> + <span>&#39;static</span>);
</code></pre><p>Depending on the <code>-C panic=&#34;unwind/abort&#34;</code> rustc flag, different crates providing these functions are linked. The crate we are interested in is <code>panic_unwind</code>. Its sources are available <a href="https://github.com/rust-lang/rust/tree/1.82.0/library/panic_unwind">on GitHub</a>.</p><p>Here we finally enter platform-specific code. I’m using Linux, so we’re interested in the Itanium exception handling ABI (called <code>GCC</code> in Rust code). The implementation is <a href="https://github.com/rust-lang/rust/blob/1.82.0/library/panic_unwind/src/gcc.rs#L61-L106">quite simple</a>:</p><pre><code><span>pub</span> <span>unsafe</span> <span>fn</span> <span>panic</span>(data: <span>Box</span>&lt;<span>dyn</span> Any + <span>Send</span>&gt;) <span>-&gt;</span> <span>u32</span> {
    <span>let</span> <span>exception</span> = <span>Box</span>::<span>new</span>(Exception {
        _uwe: uw::_Unwind_Exception {
            exception_class: <span>rust_exception_class</span>(),
            exception_cleanup: <span>Some</span>(exception_cleanup),
            private: [core::ptr::<span>null</span>(); uw::unwinder_private_data_size],
        },
        canary: &amp;CANARY,
        cause: data,
    });
    <span>let</span> <span>exception_param</span> = <span>Box</span>::<span>into_raw</span>(exception) <span>as</span> *<span>mut</span> uw::_Unwind_Exception;
    <span>return</span> uw::_Unwind_RaiseException(exception_param) <span>as</span> <span>u32</span>;

    
}

<span>pub</span> <span>unsafe</span> <span>fn</span> <span>cleanup</span>(ptr: *<span>mut</span> <span>u8</span>) <span>-&gt;</span> <span>Box</span>&lt;<span>dyn</span> Any + <span>Send</span>&gt; {
    <span>let</span> <span>exception</span> = ptr <span>as</span> *<span>mut</span> uw::_Unwind_Exception;
    <span>if</span> (*exception).exception_class != <span>rust_exception_class</span>() {
        
    }

    <span>let</span> <span>exception</span> = exception.cast::&lt;Exception&gt;();
    
    <span>let</span> <span>exception</span> = <span>Box</span>::<span>from_raw</span>(exception <span>as</span> *<span>mut</span> Exception);
    exception.cause
}
</code></pre><p>To throw a panic, we allocate <em>yet another</em> object on the heap and pass it to <code>_Unwind_RaiseException</code>. Catching a panic involves casting it back to a <code>Box</code> and retrieving the <code>cause</code> field.</p><p>To simplify this code for our statically annotated code, we can embed the cause directly in the exception object without wrapping it in <code>Box</code> beforehand. To separate our exceptions from Rust panics, we’ll use a custom exception class:</p><pre><code><span>#[repr(C)]</span>
<span>struct</span> <span>UwException</span> {
    class: <span>u64</span>,
    destructor: <span>Option</span>&lt;<span>extern</span> <span>&#34;C&#34;</span> <span>fn</span>(<span>u32</span>, *<span>mut</span> <span>Self</span>)&gt;,
    private: [*<span>const</span> (); <span>2</span>],
}

<span>#[repr(C)]</span>
<span>struct</span> <span>Exception</span>&lt;E&gt; {
    uw: UwException,
    cause: E,
}

<span>const</span> CLASS: <span>u64</span> = <span>u64</span>::<span>from_ne_bytes</span>(*<span>b&#34;RUSTpurp&#34;</span>);

<span>#[inline(always)]</span>
<span>fn</span> <span>throw</span>&lt;E&gt;(cause: E) {
    <span>let</span> <span>exception</span> = <span>Box</span>::<span>new</span>(Exception {
        uw: UwException {
            class: CLASS,
            destructor: <span>Some</span>(destructor),
            private: [core::ptr::<span>null</span>(); <span>2</span>],
        },
        cause,
    });
    <span>unsafe</span> {
        _Unwind_RaiseException(<span>Box</span>::<span>into_raw</span>(exception).<span>cast</span>());
    }
    std::process::<span>abort</span>();
}

<span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>destructor</span>(_code: <span>u32</span>, _exception: *<span>mut</span> UwException) {
    std::process::<span>abort</span>();
}

<span>#[inline(always)]</span>
<span>unsafe</span> <span>fn</span> <span>cleanup</span>&lt;E&gt;(exception: *<span>mut</span> UwException) <span>-&gt;</span> E {
    <span>if</span> (*exception).class != CLASS {
        std::process::<span>abort</span>();
    }
    <span>Box</span>::<span>from_raw</span>(exception.cast::&lt;Exception&lt;E&gt;&gt;()).cause
}

<span>extern</span> <span>&#34;C-unwind&#34;</span> {
    <span>fn</span> <span>_Unwind_RaiseException</span>(exception: *<span>mut</span> UwException) <span>-&gt;</span> <span>u32</span>;
}

b.<span>iter</span>(|| {
    <span>let</span> <span>_</span> = catch::&lt;_, &amp;<span>&#39;static</span> <span>str</span>, _&gt;(|| throw::&lt;&amp;<span>&#39;static</span> <span>str</span>&gt;(<span>&#34;Hello, world!&#34;</span>));
})
</code></pre><p>Result: <code>562.69 ns</code>, or a 3% improvement. This isn’t much, but every bit matters here.</p><p>We only have one heap allocation remaining now, containing the exception cause next to the <code>_Unwind_Exception</code> header for the system unwinder.</p><p>Why can’t we put it on the stack? When <code>throw</code> performs an alternate return, its call frame can be overwritten by the catch handlers. We could store it inside the <code>catch</code> call frame, but then we’d need to pass a pointer to it to <code>throw</code>, complicating the API.</p><p>Thread-locals are the perfect middle ground, as they are almost as cheap as stack allocation:</p><pre><code>thread_local! {
    <span>static</span> LOCAL: UnsafeCell&lt;MaybeUninit&lt;[<span>u8</span>; <span>4096</span>]&gt;&gt; = <span>const</span> {
        UnsafeCell::<span>new</span>(MaybeUninit::<span>uninit</span>())
    };
}

<span>unsafe</span> <span>fn</span> <span>local_write</span>&lt;T&gt;(x: T) <span>-&gt;</span> *<span>mut</span> T {
    <span>let</span> <span>p</span> = LOCAL.<span>with</span>(|local| local.<span>get</span>().cast::&lt;T&gt;());
    <span>unsafe</span> {
        p.<span>write</span>(x);
    }
    p
}
</code></pre><p>While this is just a proof-of-concept (it doesn’t work with nested or greater than 4 KiB exceptions), it indicates the resulting performance: <code>556.32 ns</code>, or a 1.5% improvement.</p><h2>Conclusions</h2><p>Starting at <code>2.3814 µs</code>, we’ve optimized down to <code>556.32 ns</code> – a <eq><math><mrow><mn>4.3</mn><mo>×</mo></mrow></math></eq> speedup without loss in functionality. We secured this win without modifying the Rust compiler or the system unwinder by applying the following optimizations:</p><ul><li>Remove the hook invocation</li><li>Remove type erasure of format arguments</li><li>Remove panic counters</li><li>Get rid of <code>dyn PanicPayload</code></li><li>Add inlining and mark <code>catch</code> code as hot</li><li>Remove various non-inlined cross-crate invocations</li><li>Avoid boxing the exception cause</li><li>Store the exception object in a thread-local</li></ul><p>While unwinding is popular for exception propagation, that’s not the only use case. For example, if success is more rare than an error, success could be the alternate path rather than the error. Another use of lightweight unwinding is coroutines. Thinking outside the box might help you find other applications in your projects.</p><p>To make these optimizations accessible, I have released the <a href="https://lib.rs/lithium">Lithium</a> crate, which supports efficient unwinding in Rust. It’s light as <code>Li</code> and includes features beyond the ones supported by this prototype:</p><ul><li>Efficient rethrowing</li><li>Nested exceptions</li><li>Large exception objects</li><li>Exceptions that aren’t <code>Send + &#39;static</code></li><li>Broad target support, including Windows, macOS, Emscripten, and WASI</li><li>Compatibility with the stable compiler, falling back to panics</li><li>Support for native Rust panics inside <code>catch</code></li><li><code>#![no_std]</code> support</li></ul><p>Check out <a href="https://github.com/iex-rs/lithium">the GitHub repository</a> and feel free to open issues!</p><p>There are some caveats:</p><ul><li>Using <code>lithium::throw</code> inside <code>std::panic::catch_unwind</code> (rather than <code>lithium::catch</code>) is unsound.</li><li>On nightly, Lithium relies on the implementation details of std and rustc. I monitor changes to unwinding, so this should not be a significant issue.</li><li>Lithium’s API may evolve incompatibly with semver due to interoperability if unsound is discovered in Lithium. I do not expect this to be problematic past the first month.</li></ul><p>In the following posts, we’ll explore Itanium and SEH designs, dive into unwinder implementations, and and figure out how to speed up exceptions significantly based on this knowledge. <a href="https://purplesyringa.moe/blog/feed.rss">Subscribe to RSS</a> if you are interested.</p></div></section></div>
  </body>
</html>
