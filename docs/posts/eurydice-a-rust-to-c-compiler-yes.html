<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jonathan.protzenko.fr/2025/10/28/eurydice.html">Original</a>
    <h1>Eurydice: a Rust to C compiler (yes)</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Perhaps the greatest surprise of the last two years was, for me, the realization
that people not only care about compiling C to Rust (for obvious reasons, such
as, ahem, memory safety) – they also care about compiling Rust to C! Wait,
what?</p>

<p>I <a href="https://jonathan.protzenko.fr/2024/01/05/eurydice.html">wrote about this</a> briefly a couple years
ago, but the level of interest for the project, I must say, took me somewhat by
surprise. So let’s talk about compiling Rust to C a little more today.</p>



<p>Rust is making big progress in terms of adoption, and represents a great value
proposition, especially for new code. Both my <a href="https://microsoft.com">former
employer</a> and my <a href="https://google.com">new employer</a>, like
pretty much everyone else these days, have big projects that are written in pure
Rust or can have Rust components. Even <a href="https://techcommunity.microsoft.com/blog/windowsdriverdev/towards-rust-in-windows-drivers/4449718">Windows kernel drivers can be written
in
Rust</a>
now. Amazing stuff.</p>

<p>However, if your project is, say, an open-source library that gets compiled on a
wonderfully diverse set of target architectures, OSes, distributions and
toolchains, well, chances are… one of these is not going to support Rust. Think of a
crypto library: there <strong>will</strong> be people out there with an obscure compiler for a weird
embedded target, and they really want to compile your library, because they’ve
been told not to roll out their own crypto. Or perhaps you have a format library
ridden with memory errors and you want to port it to Rust. Or maybe your company
has an in-house analysis that only runs on C code. Regardless of the scenario,
there will always be that one legacy use-case that prevents you from switching
to Rust until it’s 2035, all those LTS versions (looking at you RHEL) are
finally retired, and you yourself are too close to retirement to even care
anymore.</p>

<p>That is, unless you’re willing to use a Rust to C compiler.</p>



<p>Having a backwards-compat scenario where Rust can be compiled to C serves
several purposes.</p>

<ol>
  <li>It allows for a gradual transition. The codebase can be ported to Rust,
and refactored / cleaned up / rewritten to use all the nice Rust things (data
types, pattern-matching, polymorphism, memory safety), thus making you and
your developers much, much happier. Meanwhile, the C version co-exists so
that you don’t alienate your userbase.</li>
  <li>It only requires maintaining a single version. The Rust code is
authoritative; the C code is derived from it automatically, either on CI, or
at least with a CI job that checks that the two are in sync.</li>
  <li>It allows for a census of problematic scenarios. By making the Rust version
the default (and putting the fallback C behind a <code>--write-us-an-email</code> flag),
there is finally a way to enumerate those mythical users who cannot switch to
Rust just yet.</li>
</ol>

<p>If that sounds appealing, meet Eurydice.</p>



<p>Eurydice is a compiler from Rust to C that aims to produce <em>readable</em> C code. Of
course, readability is subjective; also, seeing that Rust relies on
whole-program monomorphization, the C code is bound to be more verbose than the
Rust code. But you can judge for yourself: here’s the result of <a href="https://github.com/AeneasVerif/eurydice/blob/9b14f74c05228b8335700efcffb55bf82a991975/out/test-libcrux/libcrux_mlkem_portable.c#L936">compiling
libcrux to
C</a>.</p>

<p>The output of the test suite is under version control, and there are <a href="https://github.com/AeneasVerif/eurydice/tree/9b14f74c05228b8335700efcffb55bf82a991975/out">a lot more
tests</a>
to peruse. See for instance <a href="https://github.com/AeneasVerif/eurydice/blob/9b14f74c05228b8335700efcffb55bf82a991975/out/test-symcrust/symcrust.c">this
bit</a>,
compared to the <a href="https://github.com/AeneasVerif/eurydice/blob/9b14f74c05228b8335700efcffb55bf82a991975/test/symcrust.rs">Rust
original</a>.</p>



<p>Eurydice plugs in directly at the MIR level, using
<a href="https://github.com/AeneasVerif/charon/">Charon</a> to avoid reimplementing the
wheel and paying the price of interacting with the guts of <code>rustc</code>. <a href="https://arxiv.org/abs/2410.18042">Our
paper</a> on Charon says more about its
architecture.</p>

<p>The advantage of plugging in at the MIR level is that i) we do not have to
interpret syntactic sugar, which means our translation is more faithful to the
Rust semantics, and ii) we have way fewer constructs that need compiling to C. Even then,
it’s no easy feat to translate Rust to C.</p>

<p>There is naturally, the need to perform whole-program monomorphization, over
types and const-generic arguments; the compilation of pattern matches into
tagged unions; recognizing instances of iterators that can be compiled to native
C <code>for</code>-loops. Then, there are more subtle things, such as compiling array
repeat expressions sensibly – zero-initializers when possible, initializer
lists otherwise, unless it generates too much code, in which case <code>for</code>-loops are
preferable. And finally, there are all the rules about visibility, <code>static</code>,
<code>inline</code>, etc. that are very C-specific and depend on how you want to lay out
your C files.</p>

<p>The translation is complicated by the constraint that the generated code
ought to be readable: for instance, we compile Rust structs to
C structs, including
<a href="https://doc.rust-lang.org/reference/dynamically-sized-types.html">DST</a>s, by
relying on <a href="https://en.cppreference.com/w/c/language/struct.html">flexible array
members</a>.
We also
work hard to avoid using the fully-generic tagged union pattern when possible,
instead eliminating the tag when e.g. the Rust enum only has a single case.
Additionally, we rely on Charon to reconstruct control-flow, rather than compile
the MIR <a href="https://en.wikipedia.org/wiki/Control-flow_graph">CFG</a> to C code ridden
with <code>goto</code>s; again, this is for code quality.</p>

<p>At a low-level, there were many interesting tidbits.</p>
<ul>
  <li>Because arrays in Rust are values, we wrap them within C structs to give them
value semantics in C, too; concretely, <code>[u32; 8]</code> becomes <code>struct {
uint32_t data[8]; }</code>. (A previous version of Eurydice would emit <code>uint32_t *</code>,
and rely on various <code>memcpy</code>s to implement value semantics, but this produced
a translation that was not type-generic, and there were plenty of finicky
corner cases. We revamped the compilation scheme recently.)</li>
  <li>The notion of <code>lvalue</code> in C means we need to insert more variable declarations
than in Rust – for instance, you can’t trivially compile <code>&amp;[0u32; 1]</code> without
naming the array.</li>
  <li>The fact that the evaluation order is so loosely defined in C means that
intermediary computations need to be stored in intermediary variables to
enforce the evaluation order.</li>
  <li>Rust relies on whole-program monomorphization; this means that the C code is
inevitably going to contains multiple copies of the same types and functions,
but for different choices of type and const generic argumnets. This is
currently done with a builtin phase in Eurydice (for historical reasons), but
in the long run, we want to rely on Charon’s support for monomorphization.</li>
  <li>There are plenty of peephole optimizations that are required for good code
quality, such as recognizing <code>array::from_fn</code> and generating sensible code
that initializes the array in-place (instead of relying on the fully-general
compilation scheme for closures), or recognizing instances of the <code>Eq</code>
trait that deserve dedicated treatment (such as using <code>memcmp</code> for arrays and
slices of flat data).</li>
</ul>

<p>A final design choice is that for now, Eurydice may define more behaviors than
Rust – for instance, Rust panics on integer overflow, but Eurydice-compiled
code does not. This is because we assume the input code is verified, and
therefore has been shown to be free of panics. This design choice can be easily
changed, though.</p>

<p>In practice, as soon as you use traits, the C code becomes more voluminous than
the Rust code. We rely on a configuration file mechanism to control the
placement of monomorphized instances of a given function, rather than put
everything in one big C file. This currently requires a lot of manual
intervention to give good results on large projects.</p>



<p>Eurydice starts by compiling the MIR AST obtained out of Charon into
<a href="https://github.com/FStarLang/karamel/">KaRaMeL</a>’s internal AST. This is ~3000
lines of OCaml code, so that’s already pretty involved. A lot of the work
revolves around trait methods and their monomorphization, given Rust’s
expressive trait system.</p>

<p>Then, about 30 nanopasses simplify the KaRaMeL AST until it becomes eligible for
compilation to C. Of those, a handful were originally written for KaRaMeL and
were somewhat reusable; this includes compilation of data types, as well as
monomorphization. The rest was written from scratch for Eurydice, and totals
about ~5000 lines of OCaml code.</p>

<p>A particularly gnarly phase was eliminating MIR’s variable assignments as much
as possible: in MIR, every variable starts out uninitialized at the beginning of
the function; then, <em>in lieu</em> of the variable declaration, we have an assignment
with the initial value. Naturally, having a variable declaration in the right
spot is better for code quality, so an initial phase tries to reconstruct these
assignments. That’s a drawback of using MIR, but we still firmly believe that
sticking to something that has clear semantics is ultimately better.</p>

<p>Fun fact: because there are so many peephole optimizations, I got tired of
maintaining <a href="https://github.com/AeneasVerif/eurydice/blob/29a05cc79df4d63d6a0a3816f1617a3bba4814e2/lib/Cleanup2.ml#L616-L655">enormous
pattern-matches</a>
that would try to catch every flavor of
Rust iterator that can be compiled to a C for-loop. Instead, a <a href="https://github.com/AeneasVerif/eurydice/blob/94cdf3b2ea4541b658dff74e4307ce01041fcc22/cremepat">custom OCaml syntax
extension</a> allows writing <a href="https://github.com/AeneasVerif/eurydice/blob/94cdf3b2ea4541b658dff74e4307ce01041fcc22/lib/Cleanup2.ml#L609-L626">concrete
syntax</a>
for the internal KaRaMeL language in OCaml patterns. Those magic patterns then get
compiled at compile-time to OCaml AST nodes for an actual OCaml pattern that
matches the (deeply-embedded) syntax of KaRaMeL’s AST. This relies on a <code>ppx</code>
that lexes, parses and compiles the concrete syntax.</p>



<p>Eurydice-generated code expects some hand-written glue that contains macros and
<code>static inline</code> functions; sometimes, it’s simply more convenient to write a
single macro that uses a type, rather than have Eurydice generate N copies of a
polymorphic function that gets specialized each time. A typical example is
compiling the Eq trait for arrays: it’s nicer to emit <code>Eurydice_array_eq(a1, a2,
len, t)</code>, which macro-expands to <code>!(memcmp(a1, a2, len*sizeof(t)))</code>, rather than
have N such functions, each containing a for-loop specialized for different
values of <code>t</code>.</p>

<p>Eurydice generates code that is either (C11 and C++20-compatible) or (C++-17
compatible, but not C-compatible). The reason for this is that Rust allows enum
values (e.g. <code>Foo { bar: baz }</code>) in any expression position. For simplicity,
Eurydice emits a compound initializer <code>(Foo) { .tag = bar, .value = { .case_Foo
= { .bar = baz }}}</code>, or a C++20 aggregate that uses designated initializers,
relying on a macro (not shown here) to hide the syntax differences between the
two. But C++17 does not have designated initializers, so there is an option for
Eurydice to emit different code that <a href="https://github.com/AeneasVerif/eurydice/blob/94cdf3b2ea4541b658dff74e4307ce01041fcc22/include/eurydice_glue.h#L37">relies on member pointers</a> to achieve
sensibly the <a href="https://github.com/AeneasVerif/eurydice/blob/94cdf3b2ea4541b658dff74e4307ce01041fcc22/out/testxx-result/result.cc#L34">same effect</a>.</p>



<p>Naturally, there are many limitations to this approach. Here are the
main ones that come to mind:</p>
<ul>
  <li>we cannot guarantee that the layout of objects will be the same in C as in
Rust; conceivably, one could parse the layout information from MIR, then emit
compiler-specific alignment directives to keep the two identical, but this is
not done currently;</li>
  <li>the generated code <a href="https://github.com/AeneasVerif/eurydice/blob/main/out/test-dst/dst.c#L15">violates strict
aliasing</a>,
because creating a user-defined DST involves casting one pointer type (a
struct containing an array) to another (a struct with a flexible array
member instead); I’m not sure what the best fix is, so for now, please compile your
code with <code>-fno-strict-aliasing</code>;</li>
  <li>the code that Eurydice sees is MIR <em>after</em> applying <code>cfg</code> tweaks; this means
that for code that is intended to be multi-platform, <a href="https://github.com/AeneasVerif/eurydice/pull/260">some
tricks</a> need to be applied,
otherwise, Eurydice will only “see” one version of the code (AVX2, or ARM64,
or something else)</li>
  <li>because monorphization is so pervasive, the configuration language needs to
express things such as “types that reference <code>__m256i</code>, an AVX2-only type,
need to go into a separate file to be compiled with <code>-mavx2</code>”; this can get
tedious <a href="https://github.com/AeneasVerif/eurydice/blob/94cdf3b2ea4541b658dff74e4307ce01041fcc22/test/libcrux/c.yaml">real
fast</a>
but I’m not sure I know how to do better.</li>
</ul>



<p>There is ongoing work to integrate Eurydice-generated code for both
<a href="https://www.microsoft.com/en-us/research/blog/rewriting-symcrypt-in-rust-to-modernize-microsofts-cryptographic-library/">Microsoft</a>
and
<a href="https://boringssl-review.googlesource.com/c/boringssl/+/77027?tab=comments">Google</a>’s
respective crypto libraries.</p>

<p>The community grew recently, with wonderful contributions by GitHub users
@ssyram and @lin23299. There are more in the pipeline, and I look forward to
seeing the supported subset of Rust grow even more. Next on the horizon is
support for <code>dyn</code> traits via vtables, and relying on Charon’s monomorphization
to get MIR exactly as the Rust compiler would monomorphize it, intead of relying
on a custom procedure in Eurydice.</p>

<p>An ambitious goal is for the whole standard library of Rust to be extractable
via Eurydice in 2026. This is non-trivial, but I believe this achievement is
within reach. Stay tuned.</p>



<p>People keep asking about the name; because the project shares a large amount of
infrastructure with <a href="https://github.com/AeneasVerif/aeneas">Aeneas</a> and
<a href="https://github.com/AeneasVerif/charon">Charon</a>, I had to follow the Greek
mythology theme. Specifically, the myth of
<a href="https://en.wikipedia.org/wiki/Eurydice">Eurydice</a> resonated with me: I thought
I was saved from the hell of <a href="https://jonathan.protzenko.fr/2019/01/04/behind-the-scenes.html">generating C code</a>, and was going to go back to the world of the
living, but alas, no.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
