<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pixelspark.nl/2022/making-advanced-bi-queries-childs-play-with-puzzle-pieces">Original</a>
    <h1>I made advanced BI queries with Scratch puzzle pieces</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
						
<figure><a href="https://pixelspark.nl/wp-content/uploads/2022/07/demo1.gif"><img width="813" height="591" src="https://pixelspark.nl/wp-content/uploads/2022/07/demo1.gif" alt=""/></a></figure>



<p>Back in 2011 our research consultancy team had collected quite a lot of interesting data for one of our clients. While previously we would put all of it in a report, print it out, and call it a day, one of my colleagues at the time proposed to make the results into an interactive dashboard instead. The client agreed – now we only needed to build a dashboard!</p>



<p>Now remember this was back in 2011 – the same year Internet Explorer 9 and Power BI were released. Big data was not a thing yet and most of our data collection and analysis relied on manual data wrangling in Excel. This meant that we could probably create the dashboard and prepare all the analysis in Excel just fine, but how were we going to put this on the web? We decided to contract a web development agency to develop a content management system of sorts – with special support for displaying charts based on CSVs and Highcharts. </p>



<p>At the time, our client was very impressed – the charts <em>animated</em>! Still the maintenance of such a dashboard required a lot of handwork. Meanwhile we managed to highly structure the underlying data in what became to look more and more like an actual database. Couldn’t we just upload this database to some database system and use that directly? </p>



<p>In 2012 I came on board fresh out of college. I had quite some knowledge of web development – HTML, PHP, MySQL and a sprinkle of JavaScript had provided me with quite a nice side job while I was still studying. At the time I was always very excited to try new technologies – NoSQL! MongoDB! – and so I quickly noticed <a href="https://en.wikipedia.org/wiki/Blockly">Google Blockly</a>, which was released in May that year. As a side project I began to hack on the dashboarding software by the end of 2012 and tried to integrate the library. </p>



<p>The first prototype was quickly up and running and proved to be quite interesting. For the first time, my Excel-savvy colleagues could interact with a database without having to learn the language to do so. Instead, they could drag and drop colorful puzzle pieces (which, initially at least, did require some explaining to fellow colleagues whose eyes would fall on screens showing what at first appears like a child’s game). </p>



<p>The system quickly converged thanks to user feedback to what it essentially still looks like today – a demo is below. </p>



<p>How does this work? In the blockly editor, our system injects various puzzle pieces that correspond to operations in SQL: select, order, group, et cetera. Additionally users could add new puzzle pieces representing data sources, such as a plain old CSV file or (a little later) tables in MySQL. These puzzle pieces could then be combined in a way that actually quite closely resembles <a href="https://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> (the puzzle pieces being functions that ‘project’, ‘select’, ‘rename’, ‘join’ et cetera, taking other puzzle pieces as their inputs).   </p>



<p>When a chart is saved, we obtain the puzzle lay-out (as XML) as well as a JSON representation of the query. This JSON more or less looks like this:</p>



<pre><code>{
  &#34;op&#34;: &#34;order&#34;,
  &#34;by&#34;: &#34;amount&#34;,
  &#34;ascending&#34;: true,
  &#34;from&#34;: {
    &#34;op&#34;: &#34;select&#34;,
    &#34;from&#34;: { &#34;op&#34;: &#34;file&#34;, &#34;id&#34;: 1337 },
    &#34;field&#34;: &#34;name&#34;,
    &#34;value&#34;: { &#34;op&#34;: &#34;const&#34;, &#34;value&#34;: &#34;Tommy&#34; }
  }
}</code></pre>



<p>Our system then takes this JSON and executes it. At first this was implemented as recursive function calls, with functions (in PHP) mapping to the different ‘ops’, e.g.:</p>



<pre><code>order(select(file(1337), &#34;name&#34;, value(&#34;Tommy&#34;)), &#34;amount&#34;, true)</code></pre>



<p>The data would be passed around as plain PHP arrays-of-objects. PHP was however not very fast and at some point we had to resort to <a href="https://github.com/facebook/hhvm">Facebook’s ‘Hip-Hop VM’ or HHVM</a> to make this usable – fun times!). </p>



<p>When I wanted to add support for MySQL tables, I quickly realized that downloading all data into PHP arrays was not going to be an ideal solution. Instead, I tried to convert the ‘ops’ to SQL code so I would only have to download the actual <em>result</em> of the query. Additionally my queries would make use of the database’s indexes which of course is good for performance. The main issue is that of course, my colleagues didn’t care about the difference between MySQL and the good old CSV files, and the system needed to support mixing the two. </p>



<p>Eventually I ended up with a fairly sophisticated execution engine, that could execute parts of a ‘puzzle’ in SQL. Then, when a CSV entered the mix, it would (based on heuristics) decide to either download the intermediate result from the database (and continue in-memory) or <em>upload</em> the in-memory result to a temporary table in MySQL and continue in SQL (this actually proved to be the quickest way to execute e.g. joins between an SQL table and a CSV, which commonly happened). This also allowed to implemented several ops that were difficult in SQL (e.g. pivot tables – these were done partially in SQL and partially in-memory). </p>



<p>Finally, interactivity was added. The ‘puzzles’ could be partially executed, up to a point where user input was required. Then, the user would be asked to select values, and the puzzle would be re-executed, now with the required parameters. </p>



<p>Of course my colleagues managed to find the limits of this system each and every time. Below is a picture of (the top part of) an example of a ginormous puzzle, of which there are many in the system still today. </p>



<p>Interestingly, many colleagues who started out with the puzzle pieces moved on to learn SQL afterwards. As time progressed, this knowledge became more widespread, and we actually hired data scientists and other people who already knew SQL. Still, to this day, the now infamous ‘puzzle pieces’ prove an invaluable tool in our projects.</p>


<div>
<figure><a href="https://pixelspark.nl/wp-content/uploads/2022/07/image.png"><img loading="lazy" src="https://pixelspark.nl/wp-content/uploads/2022/07/image-1024x912.png" alt="" width="379" height="337" srcset="https://pixelspark.nl/wp-content/uploads/2022/07/image-1024x912.png 1024w, https://pixelspark.nl/wp-content/uploads/2022/07/image-300x267.png 300w, https://pixelspark.nl/wp-content/uploads/2022/07/image-768x684.png 768w, https://pixelspark.nl/wp-content/uploads/2022/07/image-1536x1368.png 1536w, https://pixelspark.nl/wp-content/uploads/2022/07/image-225x200.png 225w, https://pixelspark.nl/wp-content/uploads/2022/07/image.png 1696w" sizes="(max-width: 379px) 100vw, 379px"/></a></figure></div>

											</div></div>
  </body>
</html>
