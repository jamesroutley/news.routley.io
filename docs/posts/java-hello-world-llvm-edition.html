<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.javaadvent.com/2025/12/java-hello-world-llvm-edition.html">Original</a>
    <h1>Java Hello World, LLVM Edition</h1>
    
    <div id="readability-page-1" class="page"><div>
							
<p>After exploring Java bytecode in previous years (<a href="https://www.javaadvent.com/2022/12/jvm-hello-world.html">2022</a>, <a href="https://www.javaadvent.com/2023/12/my-first-compiler.html">2023</a>, <a href="https://www.javaadvent.com/2024/12/peering-through-the-peephole-build-a-peephole-optimiser-using-the-new-java-class-file-api.html">2024</a>), this year we’ll take an unexpected detour for a Java advent: instead of generating Java bytecode, we’ll use Java to build and execute <a href="https://llvm.org/docs/LangRef.html">LLVM IR</a>, the intermediate language behind compilers like clang.</p>



<p>Using Java’s <a href="https://docs.oracle.com/en/java/javase/22/core/foreign-function-and-memory-api.html">Foreign Function &amp; Memory (FFM) API</a>, we’ll call the LLVM C API, generate a “Hello, World!” program, and even JIT-compile it to native code – all from Java.</p>



<p>The task is simple: create a program that simply prints “Hello, World!”. But we must do this from Java via LLVM.</p>



<h2>What is LLVM?</h2>



<p>The <a href="https://llvm.org/">LLVM Project</a>, a collection of modular compiler and toolchain technologies, began as a research project over 20 years ago at the University of Illinois. It has grown significantly, underpinning many compilers and tools like clang.</p>



<p>The core libraries provide a source &amp; target independent optimizer along with code generation for a multitude of target machines. They are built around the <a href="https://llvm.org/docs/LangRef.html">LLVM IR</a>, an intermediate representation, which we’ll generate &amp; execute from Java.</p>



<h2>Installing LLVM</h2>



<p>To use the LLVM C API from Java, we’ll need LLVM’s shared libraries and headers installed locally. There is an automatic installation script available to easily install LLVM on Ubuntu/Debian systems, for example to install LLVM 20:</p>


<div><pre title="">$ wget https://apt.llvm.org/llvm.sh
$ chmod +x llvm.sh
$ ./llvm.sh 20
</pre></div>


<p>Once we have LLVM installed we can use the LLVM tooling to execute textual-form LLVM IR and we’ll also be able to use the LLVM C API in Java via the FFM API.</p>



<h2>LLVM IR</h2>



<p>LLVM IR is a strongly-typed, SSA-based intermediate language. It abstracts away most machine-specific details, making it easier to represent high-level constructs in a compiler-friendly format. There are three equivalent representations of the IR: an in-memory format, a bitcode format for serialisation and<a href="http://llvm.org/docs/LangRef.html"> a human readable assembly language representation</a>.</p>



<p>The textual form of the LLVM IR for our “Hello, World!” looks like this:</p>


<div><pre title="">@str = private constant [14 x i8] c&#34;Hello, World!\00&#34;

declare i32 @puts(ptr)

define i32 @main() {
  call i32 @puts(ptr @str)
  ret i32 0
}
</pre></div>


<p>Eventually, we’ll generate this via Java but, for now, if you save this in a file called helloworld.ll you can try executing it with the LLVM interpreter, <a href="https://llvm.org/docs/CommandGuide/lli.html">lli</a>:</p>


<div><pre title="">$ lli helloworld.ll
Hello, World!
</pre></div>


<p>There are a few types of entities used in the helloworld.ll example:</p>



<ul>
<li>A global variable containing the string “Hello World!”</li>



<li>A declaration of the external <a href="https://man7.org/linux/man-pages/man3/puts.3.html">libc puts</a> function</li>



<li>A definition of the main function</li>



<li>Instructions to call puts and return an integer exit code</li>
</ul>



<p>You can dive deeper into the <a href="https://jameshamilton.eu/programming/llvm-hello-world">LLVM “Hello, World!” example here</a> if you like before continuing to the next section, where we’ll start using the Java FFM API.</p>



<h2>What is the Java FFM API?</h2>



<p>The <a href="https://docs.oracle.com/en/java/javase/22/core/foreign-function-and-memory-api.html">Foreign Function and Memory (FFM) API</a> enables Java programs to interoperate with code and data outside the Java runtime. The API is a replacement for the older JNI API that enables Java programs to call native libraries in a safer way. The API can be used to call foreign functions and safely access foreign memory that is not managed by the JVM.</p>



<p>A companion to the FFM API is a tool named <a href="https://docs.oracle.com/en/java/javase/21/core/call-native-functions-jextract.html">jextract</a> that can automatically generate Java bindings from a C header file. <code>jextract</code> parses C header files and automatically generates the Java source code with method handles and type-safe FFM bindings.</p>



<p>We’ll use the <code>jextract</code> tool to generate bindings for the LLVM C API and those bindings will allow us to call the LLVM API from Java.</p>



<h2>Getting started</h2>



<p>First, let’s create a simple project to start. We’ll use maven to build our project but you can use another build tool if you like, it’s not important:</p>


<div><pre title="">$ mvn archetype:generate -DgroupId=com.example -DartifactId=jvm-llvm-helloworld -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
</pre></div>


<p>Once you have a project skeleton, update the pom.xml file to set the Java version &gt;= 22:</p>


<div><pre title=""> &lt;properties&gt;
    &lt;maven.compiler.source&gt;25&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;25&lt;/maven.compiler.target&gt;
 &lt;/properties&gt;
</pre></div>


<p>Then build and run the program to check everything is OK:</p>


<div><pre title="">$ mvn clean install
$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App
Hello World!
</pre></div>


<p>The maven generated sample already printed “Hello, World!” but that’s too easy! We’ll remove that and generate it via LLVM in the following sections.</p>



<p>Let’s now create the LLVM bindings using <code>jextract</code> so that we can use the LLVM API.</p>



<h2>Creating LLVM bindings</h2>



<p>We’ll use jextract to generate bindings from the LLVM C API header files. Make sure LLVM is available on your system (see Installing LLVM above) and you’ll also need to download <a href="https://docs.oracle.com/en/java/javase/21/core/call-native-functions-jextract.html">jextract</a>.</p>



<p>The following jextract command (on Linux) will create Java bindings for the specified LLVM C headers, placing the generated code into the <code>com.example.llvm</code> package within the <code>src/main/java</code> directory, with the main header class named <code>LLVM</code>.</p>


<div><pre title="">$ jextract -l LLVM-20 -I /usr/include/llvm-c-20 \
     -I /usr/include/llvm-20 \
     -t com.example.llvm \
     --output src/main/java \
     --header-class-name LLVM \
     /usr/include/llvm-c-20/llvm-c/Core.h \
     /usr/include/llvm-c-20/llvm-c/Support.h \
     /usr/include/llvm-c-20/llvm-c/ExecutionEngine.h \
     /usr/include/llvm-c-20/llvm-c/Target.h \
     /usr/include/llvm-c-20/llvm-c/TargetMachine.h
</pre></div>


<p>To test the generated bindings, let’s print the LLVM version using the static method generated for LLVM version string constant: edit the sample’s App.java file to print the version using the following:</p>



<p>If you run this, you’ll see the LLVM version printed:</p>


<div><pre title="">$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar --enable-native-access=ALL-UNNAMED com.example.App
LLVM version: 20.0.0
</pre></div>


<p>Note the use of <code>--enable-native-access=ALL-UNNAMED</code> to prevent warnings about native code access; I’ll omit this for brevity in later commands.</p>



<h2>Memory Segments</h2>



<p>The <code>LLVM_VERSION_STRING</code> method returns a <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemorySegment.html">MemorySegment</a> rather than a Java String. In the FFM API, a <code>MemorySegment</code> represents a contiguous region of memory—either on or off the Java heap—enabling safe, structured access to native memory.</p>



<p>Let’s take a look at the implementation in the generated source file:</p>


<div><pre title="">   public static MemorySegment LLVM_VERSION_STRING() {
    class Holder {
      static final MemorySegment LLVM_VERSION_STRING
         = LLVM.LIBRARY_ARENA.allocateFrom(&#34;20.0.0&#34;);
    }
    return Holder.LLVM_VERSION_STRING;
  }
</pre></div>


<p>This method allocates memory containing the version string that contains the version number. The allocated MemorySegment is returned from the method and to get the String back into Java-land we need to call <code>getString(0)</code> on the memory segment which reads a null-terminated string at the given offset (<code>0</code>), using the UTF-8 charset.</p>



<p>Memory segments are managed through arenas (such as the <code>LLVM.LIBRARY_ARENA</code> in the code above), which bridge Java’s managed heap and foreign memory spaces by applying familiar resource management patterns like try-with-resources.</p>



<p>Since we’ll need to allocate native memory, let’s declare an <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html">Arena</a>:</p>


<div><pre title=""> public static void main(String[] args)
 {
    try (Arena arena = Arena.ofConfined()) {
       // TODO
    }
 }
</pre></div>


<h2>Creating an LLVM module</h2>



<p>As a reminder, we need to recreate the following LLVM IR via the LLVM C API:</p>


<div><pre title="">declare i32 @puts(ptr)

@str = constant [14 x i8] c&#34;Hello, World!\00&#34;

define i32 @main() {
  call i32 @puts(ptr @str)
  ret i32 0
}
</pre></div>


<p>Let’s start by creating an LLVM module – the container for all functions and globals – and print it so that we can run it through the LLVM interpreter:</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // TODO: Fill in the module
            
  	var llvmIrCharPtr = LLVMPrintModuleToString(module);

    try {
      System.out.println(llvmIrCharPtr.getString(0));
    } catch (Exception e) {
      System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    }

	   // Clean up LLVM resources
     LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>If we execute this now, we’ll see an empty IR module:</p>


<div><pre title="">$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App
; ModuleID = &#39;hello&#39;
source_filename = &#34;hello&#34;
</pre></div>


<p>If you pass this output through the LLVM interpreter, you’ll see that it tries to execute the module but cannot find the entry point main function:</p>


<div><pre title="">$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App | lli
Symbols not found: [ main ]
</pre></div>


<p>We now have an LLVM module, but it has no executable code – the interpreter rightly complains that main is missing; so let’s add the main function.</p>



<h2>Adding a main function</h2>



<p>The entry point to our program is the function named main which takes no parameters and returns an integer exit code, where a non-negative integer denotes success. We can add a function to the module using the <a href="https://llvm.org/doxygen/group__LLVMCCoreModule.html#gaaf70ab92a261e636dc0b2cf30cfede9a">LLVMAddFunction</a> function, along with the <a href="https://llvm.org/doxygen/classllvm_1_1FunctionType.html">LLVMFunctionType</a> and <a href="https://llvm.org/doxygen/group__LLVMCCoreTypeInt.html#ga71ee1444644798c8750ffb5be6a06819">LLVMInt32Type</a> functions to create the function type. </p>



<p>Notice that all of these functions return a <code>MemorySegment</code> and all 3 <code>LLVMAddFunction</code> parameters are <code>MemorySegment</code>s.</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

    // TODO: Add the code

  	var llvmIrCharPtr = LLVMPrintModuleToString(module);

    try {
      System.out.println(llvmIrCharPtr.getString(0));
    } catch (Exception e) {
      System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    }

	   // Clean up LLVM resources
     LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>If you execute this now you’ll see a declaration of the main function but it has no body so the LLVM interpreter will produce the same error:</p>


<div><pre title="">$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App
; ModuleID = &#39;hello&#39;
source_filename = &#34;hello&#34;

declare i32 @main()

$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App|lli
Symbols not found: [ main ]
</pre></div>


<p>Next we’ll add some instructions to the body of the function.</p>



<h2>Adding an entry basic block</h2>



<p>In order to add code to a function we need to add at least 1 basic block – the entry block. A basic block is a sequence of instructions within a function that executes straight through from start to finish, with no branches in the middle. These blocks form the nodes of the Control-Flow Graph (CFG), and they connect to each other based on how control flows between them.</p>



<p>Basic blocks can be added to a function with the <a href="https://llvm.org/doxygen/group__LLVMCCoreValueBasicBlock.html#gaf1760061b837b6b255224f243cfe94c8">LLVMAppendBasicBlock</a> function:</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

	  var entry = LLVMAppendBasicBlock(mainFunc, arena.allocateFrom(&#34;entry&#34;));
 
	  // TODO: Add the instructions

  	var llvmIrCharPtr = LLVMPrintModuleToString(module);

    try {
      System.out.println(llvmIrCharPtr.getString(0));
    } catch (Exception e) {
      System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    }

	   // Clean up LLVM resources
     LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>If you run the program through <code>lli</code> now, you’ll see a different error:</p>


<div><pre title="">$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App | lli
lli: &lt;stdin&gt;:6:1: error: expected instruction opcode
}
</pre></div>


<p>That makes sense, we don’t yet have any instructions in our function!</p>



<h2>Building instructions</h2>



<p>To add instructions, we first create an instruction builder using the <a href="https://llvm.org/doxygen/group__LLVMCCoreInstructionBuilder.html#ga0b336d71db0aa80eef35fe0572ca69bb">LLVMCreateBuilder</a> function. This gives us an LLVMBuilder that we can use to insert new instructions into a basic block.</p>



<p>We’ll also use the <a href="https://llvm.org/doxygen/group__LLVMCCoreInstructionBuilder.html#gab9bdbf21d7fd0bc5a2ee669b333ced2a">LLVMPositionBuilderAtEnd</a> function to position the builder at the end of the entry block and <a href="https://llvm.org/doxygen/group__LLVMCCoreInstructionBuilder.html#gab246fd9294b3801060f0ceb972c262d0">LLVMBuildRet</a> to build a return instruction:</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

	  var entry = LLVMAppendBasicBlock(mainFunc, arena.allocateFrom(&#34;entry&#34;));
 	  var builder = LLVMCreateBuilder();
    LLVMPositionBuilderAtEnd(builder, entry);

    // TODO: Call puts “Hello, World!”

	  // Return 0
    LLVMBuildRet(builder, LLVMConstInt(int32Type, 0, 0));

  	var llvmIrCharPtr = LLVMPrintModuleToString(module);

    try {
      System.out.println(llvmIrCharPtr.getString(0));
    } catch (Exception e) {
      System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    }

	   // Clean up LLVM resources
     LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeBuilder(builder);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>If you run the program and pass the output through <code>lli</code> now, you’ll see nothing happen:</p>


<div><pre title="">$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App | lli
</pre></div>


<p>Great news – the errors are gone! Checking the return code confirms the program exited successfully, returning 0.</p>





<p>Try changing the 0 to some other number to confirm that the value is indeed coming from the exit code returned by the LLVM IR program!</p>



<h2>Global variables</h2>



<p>A global variable, defined at the top-level in LLVM IR, defines a region of memory with a fixed address that is allocated when the program is loaded, rather than dynamically at runtime. Globals can be declared as constant if their values will never change.</p>



<p>We’ll add the string “Hello, World!” to our LLVM program as a global constant.</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

	  var entry = LLVMAppendBasicBlock(mainFunc, arena.allocateFrom(&#34;entry&#34;));
 	  var builder = LLVMCreateBuilder();
    LLVMPositionBuilderAtEnd(builder, entry);

	  // Create a global string constant containing &#34;Hello, World!&#34;
    var helloStr = 
           LLVMBuildGlobalStringPtr(builder,
                arena.allocateFrom(&#34;Hello, World!&#34;),
                arena.allocateFrom(&#34;hello_str&#34;));

    // TODO: Call puts “Hello, World!”

	  // Return 0
    LLVMBuildRet(builder, LLVMConstInt(int32Type, 0, 0));

  	var llvmIrCharPtr = LLVMPrintModuleToString(module);

    try {
      System.out.println(llvmIrCharPtr.getString(0));
    } catch (Exception e) {
      System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    }

	   // Clean up LLVM resources
     LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeBuilder(builder);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>We don’t use the <code>hello_str</code> yet so running <code>lli</code> would produce the same as before, but you can see the string is now declared in the LLVM IR (prefixed with @ because it is a global, like the main function):</p>


<div><pre title="">$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App 
; ModuleID = &#39;hello&#39;
source_filename = &#34;hello&#34;

@hello_str = private unnamed_addr constant [14 x i8] c&#34;Hello, World!\00&#34;, align 1

define i32 @main() {
entry:
  ret i32 0
}
</pre></div>


<p>Let’s add the final instruction next – a call to <code>puts</code> to print the string.</p>



<h2>Calling functions</h2>



<p>Before we can call the libc puts function we must declare it in the module by first building the function type and then calling <code>LLVMAddFunction</code> to add it to the module:</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

	  var entry = LLVMAppendBasicBlock(mainFunc, arena.allocateFrom(&#34;entry&#34;));
 	  var builder = LLVMCreateBuilder();
    LLVMPositionBuilderAtEnd(builder, entry);

	  // Create a global string constant containing &#34;Hello, World!&#34;
    var helloStr = 
           LLVMBuildGlobalStringPtr(builder,
                arena.allocateFrom(&#34;Hello, World!&#34;),
                arena.allocateFrom(&#34;hello_str&#34;));

    // Create puts function type: int puts(char*)
    var putsParamTypes = arena.allocate(ADDRESS, 1);
    var charPtrType = LLVMPointerType(LLVMInt8Type(), 0);
    putsParamTypes.set(ADDRESS, 0, charPtrType);
    var putsType = LLVMFunctionType(int32Type, putsParamTypes, 1, 0);
    // Add puts function to the module
    var putsFunc = LLVMAddFunction(module, arena.allocateFrom(&#34;puts&#34;), putsType);

    // TODO: Call puts “Hello, World!”

	  // Return 0
    LLVMBuildRet(builder, LLVMConstInt(int32Type, 0, 0));

  	var llvmIrCharPtr = LLVMPrintModuleToString(module);

    try {
      System.out.println(llvmIrCharPtr.getString(0));
    } catch (Exception e) {
      System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    }

	   // Clean up LLVM resources
     LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeBuilder(builder);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>Now that we’ve declared the function we can call it with the <code>@hello_str</code> global as a parameter using the <a href="https://llvm.org/doxygen/group__LLVMCCoreInstructionBuilder.html#ga40cf5b22d9d28f1f82e76048a69d537a">LLVMBuildCall2</a> function:</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

	  var entry = LLVMAppendBasicBlock(mainFunc, arena.allocateFrom(&#34;entry&#34;));
 	  var builder = LLVMCreateBuilder();
    LLVMPositionBuilderAtEnd(builder, entry);

	  // Create a global string constant containing &#34;Hello, World!&#34;
    var helloStr = 
           LLVMBuildGlobalStringPtr(builder,
                arena.allocateFrom(&#34;Hello, World!&#34;),
                arena.allocateFrom(&#34;hello_str&#34;));

    // Create puts function type: int puts(char*)
    var putsParamTypes = arena.allocate(ADDRESS, 1);
    var charPtrType = LLVMPointerType(LLVMInt8Type(), 0);
    putsParamTypes.set(ADDRESS, 0, charPtrType);
    var putsType = LLVMFunctionType(int32Type, putsParamTypes, 1, 0);
    // Add puts function to the module
    var putsFunc = LLVMAddFunction(module, arena.allocateFrom(&#34;puts&#34;), putsType);

    // Create puts function call
    var callArgs = arena.allocate(ADDRESS, 1);
    callArgs.set(ADDRESS, 0, helloStr);
    LLVMBuildCall2(builder, putsType, putsFunc, callArgs, 1, arena.allocateFrom(&#34;puts&#34;));

	  // Return 0
    LLVMBuildRet(builder, LLVMConstInt(int32Type, 0, 0));

  	var llvmIrCharPtr = LLVMPrintModuleToString(module);

    try {
      System.out.println(llvmIrCharPtr.getString(0));
    } catch (Exception e) {
      System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    }

	   // Clean up LLVM resources
     LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeBuilder(builder);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>Running the program’s output through <code>lli</code> will finally display the expected result: “Hello, World!”:</p>


<div><pre title="">$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App | lli
Hello, World!
</pre></div>


<p>Congratulations, you’ve successfully used the Java FFM API to call the LLVM C API to build an LLVM module that contains code to print “Hello, World!”.</p>



<h2>Just-in-time (JIT) Compilation</h2>



<p>So far, we’ve been printing LLVM IR and letting <code>lli</code> execute it. But LLVM also exposes a JIT compiler API, allowing us to generate and execute machine code in-memory. Let’s see how to JIT our “Hello, World!” directly from Java.</p>



<p>LLVM IR is target independent but once we start compiling to native code we must know which machine we are targeting. We’ll target x86 Linux in the following code; if you’re using ARM, Mac or Windows you’ll need to adjust the code for your machine.</p>



<p>The first step is to initialise and create an LLVM JIT compiler for the target machine:</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

	  var entry = LLVMAppendBasicBlock(mainFunc, arena.allocateFrom(&#34;entry&#34;));
 	  var builder = LLVMCreateBuilder();
    LLVMPositionBuilderAtEnd(builder, entry);

	  // Create a global string constant containing &#34;Hello, World!&#34;
    var helloStr = 
           LLVMBuildGlobalStringPtr(builder,
                arena.allocateFrom(&#34;Hello, World!&#34;),
                arena.allocateFrom(&#34;hello_str&#34;));

    // Create puts function type: int puts(char*)
    var putsParamTypes = arena.allocate(ADDRESS, 1);
    var charPtrType = LLVMPointerType(LLVMInt8Type(), 0);
    putsParamTypes.set(ADDRESS, 0, charPtrType);
    var putsType = LLVMFunctionType(int32Type, putsParamTypes, 1, 0);
    // Add puts function to the module
    var putsFunc = LLVMAddFunction(module, arena.allocateFrom(&#34;puts&#34;), putsType);

    // Create puts function call
    var callArgs = arena.allocate(ADDRESS, 1);
    callArgs.set(ADDRESS, 0, helloStr);
    LLVMBuildCall2(builder, putsType, putsFunc, callArgs, 1, arena.allocateFrom(&#34;puts&#34;));

	  // Return 0
    LLVMBuildRet(builder, LLVMConstInt(int32Type, 0, 0));

    // Initialize LLVM JIT + x86 Target
    LLVMLinkInMCJIT();
    LLVMInitializeX86Target();
    LLVMInitializeX86TargetInfo();
    LLVMInitializeX86TargetMC();
    LLVMInitializeX86AsmPrinter();
    LLVMInitializeX86AsmParser();

    // Create JIT execution engine
    var jitCompiler = arena.allocate(ADDRESS);
    var jitErrorMsgPtrPtr = arena.allocate(ADDRESS);
    LLVMCreateJITCompilerForModule(jitCompiler, module, /* optimization level = */ 2, jitErrorMsgPtrPtr);

    // Disable the IR printing now
  	// var llvmIrCharPtr = LLVMPrintModuleToString(module);
    //
    // try {
    //  System.out.println(llvmIrCharPtr.getString(0));
    // } catch (Exception e) {
    //   System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    // }

	   // Clean up LLVM resources
     // LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeBuilder(builder);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p><code>LLVMCreateJITCompilerForModule</code> sets up a JIT execution engine to compile an LLVM module to native machine code. <code>LLVMCreateJITCompilerForModule</code> will return a 1 upon failure and then we can check the error message string for more information but to simplify things we’ll ignore error handling for now. </p>



<p>Requesting the address of the main function triggers its compilation – LLVM generates the machine code only when it’s first needed, hence the name Just-In-Time compilation. We can retrieve a pointer to the compiled function using <code>LLVMGetPointerToGlobal</code>:</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

	  var entry = LLVMAppendBasicBlock(mainFunc, arena.allocateFrom(&#34;entry&#34;));
 	  var builder = LLVMCreateBuilder();
    LLVMPositionBuilderAtEnd(builder, entry);

	  // Create a global string constant containing &#34;Hello, World!&#34;
    var helloStr = 
           LLVMBuildGlobalStringPtr(builder,
                arena.allocateFrom(&#34;Hello, World!&#34;),
                arena.allocateFrom(&#34;hello_str&#34;));

    // Create puts function type: int puts(char*)
    var putsParamTypes = arena.allocate(ADDRESS, 1);
    var charPtrType = LLVMPointerType(LLVMInt8Type(), 0);
    putsParamTypes.set(ADDRESS, 0, charPtrType);
    var putsType = LLVMFunctionType(int32Type, putsParamTypes, 1, 0);
    // Add puts function to the module
    var putsFunc = LLVMAddFunction(module, arena.allocateFrom(&#34;puts&#34;), putsType);

    // Create puts function call
    var callArgs = arena.allocate(ADDRESS, 1);
    callArgs.set(ADDRESS, 0, helloStr);
    LLVMBuildCall2(builder, putsType, putsFunc, callArgs, 1, arena.allocateFrom(&#34;puts&#34;));

	  // Return 0
    LLVMBuildRet(builder, LLVMConstInt(int32Type, 0, 0));

    // Initialize LLVM JIT + x86 Target
    LLVMLinkInMCJIT();
    LLVMInitializeX86Target();
    LLVMInitializeX86TargetInfo();
    LLVMInitializeX86TargetMC();
    LLVMInitializeX86AsmPrinter();
    LLVMInitializeX86AsmParser();

    // Create JIT execution engine
    var jitCompiler = arena.allocate(ADDRESS);
    var jitErrorMsgPtrPtr = arena.allocate(ADDRESS);
    LLVMCreateJITCompilerForModule(jitCompiler, module, /* optimization level = */ 2, jitErrorMsgPtrPtr);

    var executionEngine = jitCompiler.get(ADDRESS, 0);
    var addressOfMainFunc = LLVMGetPointerToGlobal(executionEngine, mainFunc);

    // Disable the IR printing now
  	// var llvmIrCharPtr = LLVMPrintModuleToString(module);
    //
    // try {
    //  System.out.println(llvmIrCharPtr.getString(0));
    // } catch (Exception e) {
    //   System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    // }

	   // Clean up LLVM resources
     // LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeBuilder(builder);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>Now that we’ve compiled the function, we need a way to invoke it from Java. To do this, we use the foreign linker to create a <code>MethodHandle</code> for the JIT-compiled main function. This handle acts as a callable reference to the native code:</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

	  var entry = LLVMAppendBasicBlock(mainFunc, arena.allocateFrom(&#34;entry&#34;));
 	  var builder = LLVMCreateBuilder();
    LLVMPositionBuilderAtEnd(builder, entry);

	  // Create a global string constant containing &#34;Hello, World!&#34;
    var helloStr = 
           LLVMBuildGlobalStringPtr(builder,
                arena.allocateFrom(&#34;Hello, World!&#34;),
                arena.allocateFrom(&#34;hello_str&#34;));

    // Create puts function type: int puts(char*)
    var putsParamTypes = arena.allocate(ADDRESS, 1);
    var charPtrType = LLVMPointerType(LLVMInt8Type(), 0);
    putsParamTypes.set(ADDRESS, 0, charPtrType);
    var putsType = LLVMFunctionType(int32Type, putsParamTypes, 1, 0);
    // Add puts function to the module
    var putsFunc = LLVMAddFunction(module, arena.allocateFrom(&#34;puts&#34;), putsType);

    // Create puts function call
    var callArgs = arena.allocate(ADDRESS, 1);
    callArgs.set(ADDRESS, 0, helloStr);
    LLVMBuildCall2(builder, putsType, putsFunc, callArgs, 1, arena.allocateFrom(&#34;puts&#34;));

	  // Return 0
    LLVMBuildRet(builder, LLVMConstInt(int32Type, 0, 0));

    // Initialize LLVM JIT + x86 Target
    LLVMLinkInMCJIT();
    LLVMInitializeX86Target();
    LLVMInitializeX86TargetInfo();
    LLVMInitializeX86TargetMC();
    LLVMInitializeX86AsmPrinter();
    LLVMInitializeX86AsmParser();

    // Create JIT execution engine
    var jitCompiler = arena.allocate(ADDRESS);
    var jitErrorMsgPtrPtr = arena.allocate(ADDRESS);
    LLVMCreateJITCompilerForModule(jitCompiler, module, /* optimization level = */ 2, jitErrorMsgPtrPtr);

    var executionEngine = jitCompiler.get(ADDRESS, 0);
    var addressOfMainFunc = LLVMGetPointerToGlobal(executionEngine, mainFunc);

    // Create method handle to the int main() function that
    // we just created and compiled.
    var functionHandle = Linker.nativeLinker().downcallHandle(
        addressOfMainFunc,
        FunctionDescriptor.of(/* returnType = */ JAVA_INT)
    );

    // Disable the IR printing now
  	// var llvmIrCharPtr = LLVMPrintModuleToString(module);
    //
    // try {
    //  System.out.println(llvmIrCharPtr.getString(0));
    // } catch (Exception e) {
    //   System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    // }

	   // Clean up LLVM resources
     // LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeBuilder(builder);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>The <code>downcallHandle</code> method tells Java how to interpret the native function’s signature – in this case, a function that takes no arguments and returns an int.</p>



<p>Now we can invoke the compiled native function directly from Java, just like a regular method call:</p>


<div><pre title="">public static void main(String[] args)
{
  try (Arena arena = Arena.ofConfined()) {
    var module = LLVMModuleCreateWithName(arena.allocateFrom(&#34;hello&#34;));
          
    // Create main function signature: int main()
    var int32Type = LLVMInt32Type();
    var mainType = LLVMFunctionType(int32Type, NULL, 0, 0);
    var mainName = arena.allocateFrom(&#34;main&#34;);
    var mainFunc = LLVMAddFunction(module, mainName, mainType);

	  var entry = LLVMAppendBasicBlock(mainFunc, arena.allocateFrom(&#34;entry&#34;));
 	  var builder = LLVMCreateBuilder();
    LLVMPositionBuilderAtEnd(builder, entry);

	  // Create a global string constant containing &#34;Hello, World!&#34;
    var helloStr = 
           LLVMBuildGlobalStringPtr(builder,
                arena.allocateFrom(&#34;Hello, World!&#34;),
                arena.allocateFrom(&#34;hello_str&#34;));

    // Create puts function type: int puts(char*)
    var putsParamTypes = arena.allocate(ADDRESS, 1);
    var charPtrType = LLVMPointerType(LLVMInt8Type(), 0);
    putsParamTypes.set(ADDRESS, 0, charPtrType);
    var putsType = LLVMFunctionType(int32Type, putsParamTypes, 1, 0);
    // Add puts function to the module
    var putsFunc = LLVMAddFunction(module, arena.allocateFrom(&#34;puts&#34;), putsType);

    // Create puts function call
    var callArgs = arena.allocate(ADDRESS, 1);
    callArgs.set(ADDRESS, 0, helloStr);
    LLVMBuildCall2(builder, putsType, putsFunc, callArgs, 1, arena.allocateFrom(&#34;puts&#34;));

	  // Return 0
    LLVMBuildRet(builder, LLVMConstInt(int32Type, 0, 0));

    // Initialize LLVM JIT + x86 Target
    LLVMLinkInMCJIT();
    LLVMInitializeX86Target();
    LLVMInitializeX86TargetInfo();
    LLVMInitializeX86TargetMC();
    LLVMInitializeX86AsmPrinter();
    LLVMInitializeX86AsmParser();

    // Create JIT execution engine
    var jitCompiler = arena.allocate(ADDRESS);
    var jitErrorMsgPtrPtr = arena.allocate(ADDRESS);
    LLVMCreateJITCompilerForModule(jitCompiler, module, /* optimization level = */ 2, jitErrorMsgPtrPtr);

    var executionEngine = jitCompiler.get(ADDRESS, 0);
    var addressOfMainFunc = LLVMGetPointerToGlobal(executionEngine, mainFunc);

    // Create method handle to the int main() function that
    // we just created and compiled.
    var functionHandle = Linker.nativeLinker().downcallHandle(
        addressOfMainFunc,
        FunctionDescriptor.of(/* returnType = */ JAVA_INT)
    );

    // Execute the main function via the method handle.
    try {
      int result = (int) functionHandle.invoke();
      System.out.println(&#34;main() returned: &#34; + result);
    } catch (Throwable e) {
      System.err.println(&#34;Error calling JIT function: &#34; + e.getMessage());
    }

    // Disable the IR printing now
  	// var llvmIrCharPtr = LLVMPrintModuleToString(module);
    //
    // try {
    //  System.out.println(llvmIrCharPtr.getString(0));
    // } catch (Exception e) {
    //   System.err.println(&#34;Failed to write LLVM IR: failed to get error message: &#34; + e.getMessage());
    // }

	   // Clean up LLVM resources
     // LLVMDisposeMessage(llvmIrCharPtr);
     LLVMDisposeBuilder(builder);
     LLVMDisposeModule(module);
  }
}
</pre></div>


<p>When <code>functionHandle.invoke()</code> runs, Java crosses into the native world and calls the machine code that was just compiled by the LLVM JIT compiler.</p>



<p>And that’s it, you can now run the Java application without the LLVM interpreter and see the resulting “Hello, World!”:</p>


<div><pre title="">$ java -cp target/jvm-llvm-helloworld-1.0-SNAPSHOT.jar com.example.App 
Hello, World!
</pre></div>


<p>Congratulations, you’ve now JIT-compiled Hello World, with the help of Java’s FFM API calling LLVM’s C API.</p>



<h2>Next steps</h2>



<p>In this Java advent we built and executed native machine code from pure Java and a little help from LLVM – no JNI, no C glue, just memory segments, method handles, and a modern FFI. By the end, we had just a simple program that prints “Hello, World!” but it shows the potential of the Java FFM API and the things you can do when Java and native code work together.</p>



<p>Now see what else you can do, for example, try generating other instructions: print more text, do simple calculations, or even build tiny programs entirely in LLVM from Java.</p>



<p>The full code for this post is available <a href="https://github.com/mrjameshamilton/java-llvm-helloworld">on GitHub over here</a>.</p>

		<div>
		<p><img alt="" src="https://secure.gravatar.com/avatar/ba9492d96e5b0bf5ea269360a8a81e6df6a18d89d79ff77831450e1e74232f27?s=80&amp;d=retro&amp;r=g" srcset="https://secure.gravatar.com/avatar/ba9492d96e5b0bf5ea269360a8a81e6df6a18d89d79ff77831450e1e74232f27?s=160&amp;d=retro&amp;r=g 2x" height="80" width="80"/>
		</p>
		<div>
			<h4>Author: <span><a href="https://www.javaadvent.com/author/jhamilton">James Hamilton</a></span></h4><p>I’m a senior software engineer working at Diffblue where we build a tool for automated Java unit test generation using code analysis techniques and reinforcement learning.  I previously worked at Guardsquare on JVM/Android related tools &amp; libraries including ProGuardCORE, ProGuard and DexGuard.
		</p></div>
	
	
	</div>
	
						</div></div>
  </body>
</html>
