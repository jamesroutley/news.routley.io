<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pzakrzewski.com/find-legal-moves-in-brass-birmingham-with-logic-programming">Original</a>
    <h1>Find Legal Moves in Brass Birmingham with Datalog</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>Have you ever tried expressing board game rules in code? Does it sound a bit tedious? I bet it does, I implemented a few board game rulesets in Python and JavaScript to write a simulator or implement a version of the board game playable in a browser. It felt like implementing an overcomplicated business process with plenty of exceptions, discontinuities and generous use of state machines. The same rules that take a lot of Python code can be expressed pretty succinctly and not ambiguously in their instruction manuals, which suggests there should be a better way.</p>
<p>Take for example <a target="_blank" href="https://boardgamegeek.com/boardgame/224517/brass-birmingham">Brass Birmingham</a>, it is an acclaimed strategic board game set during the British Industrial Revolution. Players compete as industrialists, building logistical networks and developing industries like cotton mills and breweries. Most of the rules of the game pertain to when you are allowed to build factories, railway links or when you are allowed to sell your goods. Let&#39;s have a look at one such rule:</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1700418583435/5b0601a7-5113-440c-a020-46d6187e5797.png?auto=compress,format&amp;format=webp" alt=""/></p>
<p><em>Taken from</em> <a target="_blank" href="http://files.roxley.com/Brass-Birmingham-Rulebook-2018.11.20-highlights.pdf"><em>Roxley Rules Highlights</em></a></p>
<p>How would you implement this rule in an imperative paradigm? Let&#39;s write some pseudo-code (that might smell a bit of Python)</p>
<pre><code><span><span>def</span> <span>can_consume_beer</span>(<span>player, sell_location, beer_location</span>) -&gt; bool:</span>
    <span>if</span> <span>not</span> has_beer(beer_location):
        
        <span>return</span> <span>False</span>
    <span>if</span> sell_location == beer_location:
        
        
        <span>return</span> <span>True</span>
    <span>if</span> is_connected(sell_location, beer_location):
        
        
        <span>return</span> <span>True</span>
    <span>if</span> owner(beer_location) == player:
        
        
        <span>return</span> <span>True</span>
    <span>return</span> <span>False</span>
</code></pre>
<p>Not too bad. But how do we find all legal combinations of sell and beer locations?</p>
<pre><code>legal_moves = []
<span>for</span> player <span>in</span> players:
    <span>for</span> location1 <span>in</span> locations:
        <span>for</span> location2 <span>in</span> locations:
            <span>if</span> can_consume_beer(player, location1, location2):
                legal_moves.append((player, location1, location2))
</code></pre>
<p>I guess this would work ... But how would it look if we keep adding new rules and for each of them we want to know what are the legal moves for the given player for a given state of the game? We probably need to come up with some clever abstraction for the rule itself, and its parameters and then iterate through them all checking if they are satisfied for the given input domain, which likely would be brute-forcing all possible combinations of their parameters.</p>

<p><a target="_blank" href="https://en.wikipedia.org/wiki/Logic_programming">Logic programming</a> is a rather obscure (as in - not commonly used) programming paradigm. It is declarative - you describe the rules and facts of your program and rely on the interpreter to find solutions. A more mainstream example of a declarative language is SQL. Let&#39;s have a look at the same rule for consuming beer but implemented in Datalog (a logic programming language).</p>
<pre><code>can_consume_beer(player, sell_location, beer_location) :- 
    has_beer(beer_location),
    is_connected(sell_location, beer_location).
can_consume_beer(player, sell_location, beer_location) :- 
    has_beer(beer_location),
    owns(player, beer_location).
</code></pre>
<p>The syntax might look foreign to you so the benefit is not obvious yet. <code>can_consume_beer</code> is a rule and its conditions are listed after the so-called horn clause <code>:-</code> .The commas stand for logical <code>AND</code>, a full stop stands for logical <code>OR</code>, so either of the two implementations of <code>can_consume_beer</code> needs to be satisfied.</p>
<p>How about finding all legal moves for this rule? This is where logic programming starts to shine:</p>
<pre><code>.output can_consume_beer(IO=stdout, delimiter=&#34;\t&#34;)
</code></pre>
<p>Depending on the game state (or in logic programming parlance: facts) you might get the following output from this program:</p>
<pre><code>---------------
can_consume_beer
Player    SellLocation    BeerLocation
===============
Player1    Birmingham    Birmingham
Player2    Nuneaton    Birmingham
===============
</code></pre>
<p>What would a complete running program look like for this specific rule?</p>
<pre><code>
.decl has_beer(Location:symbol)
// the following is a fact, a piece of data that 
// describes state of the game in our case
has_beer(&#34;Birmingham&#34;).

.decl is_connected(Location1:symbol, Location2:symbol)
// simplified fact-based implementation, only 1-hop connections
// for a more complete example of is_connected graph rule
// see https://souffle-lang.github.io/tutorial
is_connected(&#34;Birmingham&#34;, &#34;Birmingham&#34;).
is_connected(&#34;Birmingham&#34;, &#34;Nuneaton&#34;).
is_connected(&#34;Nuneaton&#34;, &#34;Birmingham&#34;).

// ownership facts simplified from Brass Birmingham rules perspective
// in brass players own only given slots, not entire locations
.decl owns(Player:symbol, Location:symbol)
owns(&#34;Player1&#34;, &#34;Birmingham&#34;).
owns(&#34;Player2&#34;, &#34;Nuneaton&#34;).

.decl has_unflipped_factory(Player:symbol, Location:symbol)
has_unflipped_factory(&#34;Player1&#34;, &#34;Birmingham&#34;).
has_unflipped_factory(&#34;Player2&#34;, &#34;Nuneaton&#34;).


.decl can_consume_beer(Player:symbol, SellLocation:symbol, BeerLocation:symbol)
can_consume_beer(player, sell_location, beer_location) :- 
    has_unflipped_factory(player, sell_location),
    has_beer(beer_location),
    is_connected(sell_location, beer_location).
can_consume_beer(player, sell_location, beer_location) :- 
    has_unflipped_factory(player, sell_location),
    has_beer(beer_location),
    owns(player, beer_location).
.output can_consume_beer(IO=stdout, delimiter=&#34;\t&#34;, headers=true)
</code></pre>
<p>Which produces the following output:</p>
<pre><code>---------------
can_consume_beer
Player    SellLocation    BeerLocation
===============
Player1    Birmingham    Birmingham
Player2    Nuneaton    Birmingham
===============
</code></pre>
<p>This tells us that Player1 can sell in Birmingham using beer from Birmingham and Player2 can sell in Nuneaton with beer from Birmingham (supposedly not at the same time!).</p>
<p>If you want to run the above program yourself or play around with Datalog, have a look at <a target="_blank" href="https://souffle-lang.github.io/install">Souffle</a>, pretty easy to install and run locally the Datalog dialect I used for this blog post.</p>
<p><em>Let me know if you find this use case convincing, follow this blog to read more write-ups like this one, I will likely continue implementing more Brass rules in Datalog.</em></p>
</div></div></div>
  </body>
</html>
