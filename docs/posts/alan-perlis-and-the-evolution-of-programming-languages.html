<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://deprogrammaticaipsum.com/alan-perlis-and-the-evolution-of-programming-languages/">Original</a>
    <h1>Alan Perlis and the evolution of programming languages</h1>
    
    <div id="readability-page-1" class="page"><div>

		<p><a href="https://en.wikipedia.org/wiki/Alan_Perlis" target="_blank" rel="noopener">Alan Jay Perlis</a> knew a thing or two about programming languages, both as an early pioneer of our industry and as one of the designers of ALGOL. The language that has inspired the one you, dear reader of this magazine, probably use every day to earn a living.</p>
<p>In his <a href="https://amturing.acm.org/award_winners/perlis_0132439.cfm" target="_blank" rel="noopener">first-ever ACM Turing Award Lecture</a>, “The Synthesis of Algorithmic Systems,” in 1966, Dr. Perlis enumerated three ways programming languages evolve from one to the next.</p>
<blockquote><p>Successor languages come into being from a variety of causes:</p>
<p>(a) The correction of an error or omission or superfluity in a given language exposes a natural redesign which yields a superior language.</p>
<p>(b) The correction of an error or omission or superfluity in a given language requires a redesign to produce a useful language.</p>
<p>(c) From any two existing languages a third can usually be created which (i) contains the facilities of both in an integrated form, and (it) requires a grammar and evaluation rules less complicated than the collective grammar and evaluation rules of both.</p></blockquote>
<p>Perlis did not stop there. In 1982 he published his famous <a href="http://pu.inf.uni-tuebingen.de/users/klaeren/epigrams.html" target="_blank" rel="noopener">epigrams</a>, which you have most probably read on Twitter. Those observations were natural memes, even if that name did not exist.</p>
<blockquote><p>41. Some programming languages manage to absorb change, but withstand progress.</p></blockquote>
<p>Let us look in detail at how each of these (three plus one) principles stated by Perlis can be applied to the evolution of programming languages of the last 56 years. Maybe much of this evolution was inspired by <a href="https://en.wikipedia.org/wiki/Peter_Landin" target="_blank" rel="noopener">Peter Landin</a> and his 1966 (what a year, huh?) <a href="https://en.wikipedia.org/wiki/ISWIM" target="_blank" rel="noopener">ISWIM</a> proposal for the <a href="https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf" target="_blank" rel="noopener">following 700 languages</a>; let us not digress and identify some patterns of programming language evolution by looking backward in time.</p>
<h2>Natural Redesign Towards A Superior Language</h2>
<p>What do we understand by “superior”? As privileged observers from 2022, we can quickly identify some “modern” traits that make languages undoubtedly (well, at least from our point of view) superior. Let us mention a few: support for types (if at all) or of a more robust type system than its predecessor (although abusing this characteristic invariably leads to longer compilation times); essential IDE support; the generation of safer and (or) faster code; type inference facilities; a stronger community and ecosystem.</p>
<p>Languages featuring such changes represent small evolutionary steps, welcome but not revolutionary changes. They are praised on Hacker News and adopted by the community as welcome improvements over existing languages. Some examples, roughly in chronological order:</p>
<ul>
<li>C (for B)</li>
<li>Pascal (proposed by Wirth as a better ALGOL 60, even though <a href="https://deprogrammaticaipsum.com/brian-kernighan/" target="_blank" rel="noopener">Brian Kernighan</a> <a href="https://www.lysator.liu.se/c/bwk-on-pascal.html" target="_blank" rel="noopener">did not like it</a>)</li>
<li>D (for C++)</li>
<li><a href="https://lwn.net/Articles/802329/" target="_blank" rel="noopener">Raku</a> (for Perl)</li>
<li>Scala (for Java)</li>
<li><a href="https://crystal-lang.org/" target="_blank" rel="noopener">Crystal</a> (for Ruby)</li>
<li><a href="https://en.wikipedia.org/wiki/Hack_(programming_language)" target="_blank" rel="noopener">Hack</a> (as an attempt by Facebook to bring PHP to another level)</li>
<li><a href="https://9to5google.com/2022/07/19/carbon-programming-language-google-cpp/" target="_blank" rel="noopener">Carbon</a> (for C++, maybe?)</li>
</ul>
<p>Some of these redesigns involve syntax changes (D, Pascal, Hack); some others with a recreation of their compilers or runtime models (Crystal, HipHop); in other cases, introducing a completely different paradigm (Scala) to an existing platform (the Java virtual machine) or even a new syntax but with backward compatibility (Carbon.)</p>
<h2>Redesign Towards A Useful Language</h2>
<p>Paraphrasing Bjarne Stroustrup, this is the realm of languages <a href="https://www.goodreads.com/quotes/226225-there-are-only-two-kinds-of-languages-the-ones-people" target="_blank" rel="noopener">everyone complains about</a>. What do we understand by “useful”? In the opinion of this author, pragmatic languages. The ones that <a href="https://the.scapegoat.dev/why-i-love-php-and-javascript/" target="_blank" rel="noopener">get shit done</a>. The languages we use every day. They are generally featuring the “industry” moniker, usually easier to understand by masses of engineers and usually (sadly) adopted by <a href="https://deprogrammaticaipsum.com/teacher-leave-this-kid-alone/" target="_blank" rel="noopener">academia</a> at some point. Bundled with everything <a href="https://www.joelonsoftware.com/2007/06/05/smart-and-gets-things-done/" target="_blank" rel="noopener">smart people need to get stuff done</a>: a package manager, a “batteries included” library of pre-built functions, a (not very) strict type system (which predictably yields a healthy equilibrium between correctness and productivity), and advanced IDE support.</p>
<p>And marketing. Lots of marketing. Usually, a big organization is behind, financing the evolution of the language through a foundation, committee, GitHub project, or some other similar mechanism.</p>
<p>They also feature more uncomplicated licensing conditions and might include some functional programming facilities over their predecessors; it is undoubtedly fancier to use a <code>map()</code> function than to use a <code>while</code>. Even though, according to Turing, both will get the job done.</p>
<p>Some examples? Classics:</p>
<ul>
<li>Delphi and Turbo Pascal (as useful Pascal compilers)</li>
<li>C# (as a useful Java)</li>
<li>Pharo (<a href="https://medium.com/smalltalk-talk/behold-pharo-the-modern-smalltalk-38e132c46053" target="_blank" rel="noopener">as a useful</a> Smalltalk)</li>
<li>F# (as a useful OCaml)</li>
<li>Kotlin (as another useful Java, but this time compatible with it)</li>
<li>Elixir (as a useful Erlang)</li>
<li>Scheme and Clojure (as a useful Lisp)</li>
<li>TypeScript (as a useful <a href="https://deprogrammaticaipsum.com/innovationscript/" target="_blank" rel="noopener">JavaScript</a>)</li>
</ul>
<p>The astute reader will have realized by now that at least three languages designed by <a href="https://en.wikipedia.org/wiki/Anders_Hejlsberg" target="_blank" rel="noopener">Anders Hejlsberg</a> appear in this list. As a software engineer concerned with solving practical problems for my customers, I have always favored useful languages in my work. But developers should be beware of Dr. Perlis’ third aphorism because it is in this category where it hurts the most:</p>
<blockquote><p>3. Syntactic sugar causes cancer of the semi-colons.</p></blockquote>
<p>There are more “market driven” evolutions in this category; languages that mostly evolve their associated libraries or ecosystem to fulfill some novel role:</p>
<ul>
<li>R and Python have effectively replaced Fortran as the <em>de facto</em> language for scientific calculus.</li>
<li>Python also reinvented itself as the language of AI.</li>
<li>C# chose to evolve alone and gradually replace itself. The current iteration of the language is quite different from when it debuted in 2000: arguably, it was a Microsoft-owned clone of Java.</li>
<li>Go became the language of choice for Cloud Native systems and cross-platform CLI tools; <a href="https://ballerina.io/" target="_blank" rel="noopener">Ballerina</a>, although initially intended to compete in this space, does not have nearly the same traction.</li>
<li>Dart, a <a href="https://akos.ma/blog/dart-is-boring/" target="_blank" rel="noopener">boring</a> but highly effective language, is slowly positioning itself in the mobile app development market. With the current (in the opinion of this author, deserved) backlash against React Native, Dart has a real chance to grow beyond its current status.</li>
</ul>
<h2>From Many Existing To An Integrated And Less Complicated One</h2>
<p>These languages usually mark historical <a href="https://thenewstack.io/rust-creator-graydon-hoare-recounts-the-history-of-compilers/" target="_blank" rel="noopener">milestones</a>, representing significant shifts in the programming industry. Usually, there is one of these every 18 years, give or take, roughly following <a href="https://proebsting.cs.arizona.edu/law.html" target="_blank" rel="noopener">Proebsting’s Law</a>, named after University of Arizona computer science professor Todd A. Proebsting. Perhaps contradicting Dr. Perlis, history showed that sometimes there were more than just two languages involved in the evolutionary process. Normal, since we have many more languages today than in 1966.</p>
<ul>
<li>C++ (at least in its early forms 40 years ago) evolved from Simula and C;</li>
<li>Objective-C, taking cues from Smalltalk and building upon C;</li>
<li>Java, <a href="https://cs.gmu.edu/~sean/stuff/java-objc.html" target="_blank" rel="noopener">from</a> Objective-C, Simula, and Smalltalk;</li>
<li>Rust, <a href="https://www.infoq.com/news/2012/08/Interview-Rust/" target="_blank" rel="noopener">from</a> C, C++, OCaml, Haskell, and many others.</li>
<li>Swift, from Objective-C, Haskell, Rust, and so many others.</li>
</ul>
<p>Rust is <a href="https://people.kernel.org/linusw/rust-in-perspective" target="_blank" rel="noopener">arguably</a> targeting a higher goal today than any other language in the past 60 years, aiming to unify computer science with software engineering. Let us meet again in this magazine in one or two decades and see if it kept its promise.</p>
<p>The problem in this category is that, although Dr. Perlis sees the final result as “less complicated,” these languages become extremely <a href="https://deprogrammaticaipsum.com/complex-vs-complicated/" target="_blank" rel="noopener">complicated</a> as they grow.</p>
<h2>Absorbing Change But Withstanding Progress</h2>
<p>Dr. Perlis’ fourth category holds some venerable languages that have been able to pass the test of time, staying almost unscathed since version 1.0, almost begrudgingly adopting some fads (object-oriented programming, multiple CPU support, etc.) while remaining (stubbornly?) faithful to their origins: COBOL; Lisp; APL; Forth; PHP; BASIC; C; and Go.</p>
<p>These languages are withstanding progress, yes, but only to a certain degree. COBOL has had a new standard roughly every 20 years, and C got a new one every decade. Go has recently adopted generics, its most significant addition in 15 years. BASIC has yielded many offspring, yet its core has seldom changed. PHP features type annotations. Lisp will always be <a href="http://www.paulgraham.com/lisp.html" target="_blank" rel="noopener">Paul Graham</a>‘s preferred programming language. Nearly all of these languages have been safe bets for a long-sustained career in software development during (at least) the past 25 years.</p>
<p>Comes to mind <a href="https://en.wikipedia.org/wiki/Greenspun&#39;s_tenth_rule" target="_blank" rel="noopener">Greenspun’s Tenth Rule</a>:</p>
<blockquote><p>Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.</p></blockquote>
<h2>Observations</h2>
<p>The overall life expectancy of a programming language has dwindled in the past 56 years. A COBOL developer in the 1960s most probably retired in the 2000s, still writing COBOL. As a former professional VBScript, then C#, then Objective-C, later Swift, and finally Go developer, I can only see this trend accelerating. We should expect our favorite programming language to be replaced and removed from the market in a relatively shorter time every decade. To add insult to injury, new versions of the same programming language are sometimes incompatible with their previous ones.</p>
<p>The above is one of the reasons why this author believes that <a href="https://deprogrammaticaipsum.com/specialization-is-for-insects/" target="_blank" rel="noopener">hyper-specialization</a>, as demanded and supported by industry pundits, is a risk, a bet.</p>
<p>Another of Perlis’ epigrams tells us that the evolution of programming languages is an unsolved problem:</p>
<blockquote><p>73. It is not a language’s weaknesses but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.</p></blockquote>
<p>And if we believe <a href="http://www.canonical.org/~kragen/tao-of-programming.html" target="_blank" rel="noopener">Geoffrey James</a>,</p>
<blockquote><p>Each language has its purpose, however humble. Each language expresses the Yin and Yang of software. Each language has its place within the Tao.</p>
<p>But do not program in <tt>COBOL</tt> if you can avoid it.</p></blockquote>
<p>Cover photo by <a href="https://unsplash.com/@grstocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">GR Stocks</a> on <a href="https://unsplash.com/s/photos/chess-king?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a>.</p>
	</div></div>
  </body>
</html>
