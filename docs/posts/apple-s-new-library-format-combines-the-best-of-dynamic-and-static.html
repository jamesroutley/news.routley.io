<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.apple.com/videos/play/wwdc2023/10268">Original</a>
    <h1>Apple&#39;s new library format combines the best of dynamic and static</h1>
    
    <div id="readability-page-1" class="page"><div data-supplement-id="transcript" data-shortcut-base-url="/videos/play/wwdc2023-10268/">
							<section>
								<p><span id="get-transcript">Download</span></p>
								<p><span><span data-start="0.0">♪ ♪ </span></span><span><span data-start="10.0">Cyndy: Hello, I&#39;m Cyndy, and I&#39;m a compiler engineer </span></span><span><span data-start="13.0">on the Languages and Runtimes Team. </span></span><span><span data-start="16.0">In this session, we&#39;re meeting Mergeable Libraries. </span></span><span><span data-start="19.0">This is a new model for building and distributing libraries </span></span><span><span data-start="22.0">powered by the static linker. </span></span><span><span data-start="25.0">I&#39;ll share how mergeable libraries work to make your apps build and run faster.</span></span></p><p><span><span data-start="32.0">Then, I&#39;ll demonstrate how to enable mergeable libraries </span></span><span><span data-start="35.0">in Xcode 15. </span></span><span><span data-start="38.0">And lastly, I&#39;ll cover considerations </span></span><span><span data-start="41.0">and what we recommend when using mergeable libraries. </span></span><span><span data-start="45.0">Before we dive in, I&#39;ll provide a brief overview </span></span><span><span data-start="48.0">of static and dynamic libraries. </span></span><span><span data-start="51.0">This will highlight the benefits of mergeable ones.</span></span></p><p><span><span data-start="55.0">Static libraries are a collection of object files. </span></span><span><span data-start="59.0">At build time, the static linker finds which APIs to use </span></span><span><span data-start="64.0">from those libraries and copies that code into the app binary.</span></span></p><p><span><span data-start="70.0">And since it&#39;s copied, the library isn&#39;t needed after building. </span></span><span><span data-start="75.0">If code in static libraries changes or if more libraries are used, </span></span><span><span data-start="79.0">it introduces a build time slowdown. </span></span><span><span data-start="82.0">This is a result of how they are archived and linked into apps, </span></span><span><span data-start="86.0">which makes iterative building and debugging slower. </span></span><span><span data-start="90.0">Instead, dynamic libraries can be used to prevent this. </span></span><span><span data-start="95.0">Dynamic libraries are commonly called dylibs. </span></span><span><span data-start="99.0">They are the binary file type for framework targets in Xcode.</span></span></p><p><span><span data-start="104.0">The code from frameworks isn&#39;t copied into executables. </span></span><span><span data-start="108.0">Rather, the static linker records the installed path of the library </span></span><span><span data-start="113.0">into the app binary for later. </span></span><span><span data-start="116.0">Any frameworks not in the Apple SDK </span></span><span><span data-start="118.0">must be embedded into the app bundle. </span></span><span><span data-start="122.0">The key difference is when dynamic libraries are added or updated, </span></span><span><span data-start="127.0">the static linker does not need to copy code. </span></span><span><span data-start="130.0">This results in faster builds. </span></span><span><span data-start="133.0">However, it adds complexity to when apps are used at runtime. </span></span><span><span data-start="138.0">This is where a dynamic linker is needed. </span></span><span><span data-start="142.0">When an app is launched, the dynamic linker named dyld </span></span><span><span data-start="146.0">must find and load framework dependencies. </span></span><span><span data-start="149.0">This includes libraries those frameworks depend on.</span></span></p><p><span><span data-start="154.0">As more are used, this results in a steady increase </span></span><span><span data-start="158.0">in memory consumption and app launch time. </span></span><span><span data-start="162.0">And when you factor in dependencies from the Apple SDK, </span></span><span><span data-start="165.0">apps can often load hundreds of frameworks. </span></span><span><span data-start="169.0">Our platforms have heavily optimized system libraries to account for this. </span></span><span><span data-start="175.0">But this doesn&#39;t apply to frameworks that get embedded in apps. </span></span><span><span data-start="179.0">So to recap, there are some tradeoffs </span></span><span><span data-start="182.0">when deciding between using static and dynamic libraries.</span></span></p><p><span><span data-start="187.0">While dynamic libraries have little impact on build time </span></span><span><span data-start="191.0">but noticeable launch time consequences, </span></span><span><span data-start="193.0">static libraries provide minimal launch time impact </span></span><span><span data-start="196.0">but are costly on build time. </span></span><span><span data-start="199.0">Due to this, we have historically recommended </span></span><span><span data-start="201.0">measuring what&#39;s best for your app. </span></span><span><span data-start="205.0">With mergeable libraries, this is no longer needed. </span></span><span><span data-start="210.0">Mergeable libraries unlock the best of both linking strategies. </span></span><span><span data-start="215.0">I&#39;ll describe how mergeable libraries are able to optimize </span></span><span><span data-start="219.0">for performance and development. </span></span><span><span data-start="222.0">Consider any binary image, like an executable. </span></span><span><span data-start="227.0">The frameworks this binary depends on are given to the static linker. </span></span><span><span data-start="231.0">These dependencies can become mergeable libraries. </span></span><span><span data-start="235.0">And the linked output can become the merged binary. </span></span><span><span data-start="240.0">But what makes these dependencies mergeable? </span></span><span><span data-start="243.0">This can be explained by how they are built. </span></span><span><span data-start="246.0">Any dynamic library can be built as mergeable. </span></span><span><span data-start="250.0">When the static linker creates the library, </span></span><span><span data-start="252.0">it also generates metadata. </span></span><span><span data-start="256.0">The metadata is within the binary, increasing its overall size. </span></span><span><span data-start="261.0">It allows the linker to treat the library similarly to a static library </span></span><span><span data-start="266.0">when it&#39;s used as a link dependency. </span></span><span><span data-start="269.0">With the metadata, users of the library can choose </span></span><span><span data-start="272.0">to statically link as normal dynamic libraries </span></span><span><span data-start="275.0">or merge them. </span></span><span><span data-start="277.0">The merged binary output can be an executable, like an app, </span></span><span><span data-start="281.0">or another dynamic library, like a framework. </span></span><span><span data-start="286.0">Merging is comparable to how static libraries get linked. </span></span><span><span data-start="290.0">In the end, you&#39;re left with a binary </span></span><span><span data-start="292.0">that contains the segments of the libraries. </span></span><span><span data-start="295.0">And that output binary remains the same file type. </span></span><span><span data-start="299.0">Merging is brand-new in Xcode 15. </span></span><span><span data-start="303.0">The newly implemented static linker is what enables this. </span></span><span><span data-start="307.0">It works by using new linker options. </span></span><span><span data-start="310.0">First, the libraries to merge are built with the option -make_mergeable. </span></span><span><span data-start="315.0">This tells the linker to record the metadata. </span></span><span><span data-start="319.0">Next, for the merged binary, the linker uses that metadata </span></span><span><span data-start="323.0">along with the libraries to produce the final output </span></span><span><span data-start="326.0">with the option -merge_library or -merge_framework. </span></span><span><span data-start="330.0">Xcode handles these details for you. </span></span><span><span data-start="333.0">However, you can see these options being applied </span></span><span><span data-start="336.0">when inspecting your build log. </span></span><span><span data-start="338.0">But how is merging better than just linking? </span></span><span><span data-start="342.0">Well, let&#39;s consider the size after merging. </span></span><span><span data-start="346.0">Firstly, libraries and their metadata aren&#39;t needed </span></span><span><span data-start="349.0">and can be removed after they&#39;ve been merged. </span></span><span><span data-start="352.0">So the only focus is the size of the merged binary. </span></span><span><span data-start="357.0">When merging, the linker can de-duplicate content, </span></span><span><span data-start="360.0">such as strings, across all libraries. </span></span><span><span data-start="362.0">For instance, it removes redundant symbol references, </span></span><span><span data-start="365.0">Objective-C selectors, and objc_msgsend stubs. </span></span><span><span data-start="370.0">This results in a smaller overall app bundle. </span></span><span><span data-start="374.0">The image type of the final binary remains the same too. </span></span><span><span data-start="378.0">That means any already supported linker optimizations can be applied.</span></span></p><p><span><span data-start="384.0">This also has a positive impact on app launch. </span></span><span><span data-start="388.0">When fewer frameworks are loaded, it reduces the work dyld </span></span><span><span data-start="392.0">and the kernel need to do when launching your app, </span></span><span><span data-start="395.0">and it reduces memory usage, keeping your users happy. </span></span><span><span data-start="399.0">But we know separating code into libraries </span></span><span><span data-start="402.0">is vital for effective development and maintenance. </span></span><span><span data-start="406.0">With mergeable libraries, you can have both. </span></span><span><span data-start="410.0">Mergeable libraries make this possible </span></span><span><span data-start="412.0">with minimal code and configuration changes. </span></span><span><span data-start="415.0">And this scales nicely as you adopt newer frameworks. </span></span><span><span data-start="419.0">Let&#39;s revisit the earlier diagram about dynamic linking. </span></span><span><span data-start="424.0">All of these embedded frameworks can become mergeable </span></span><span><span data-start="427.0">since the linker can generate metadata for them. </span></span><span><span data-start="431.0">We can create a framework that merges the contents of the other libraries. </span></span><span><span data-start="435.0">So you end up with only one framework to embed. </span></span><span><span data-start="439.0">Dyld only needs to load that one library </span></span><span><span data-start="442.0">containing all segments across the embedded frameworks. </span></span><span><span data-start="446.0">Merging, in this way, can greatly simplify large dependency chains. </span></span><span><span data-start="451.0">That&#39;s what mergeable libraries can achieve. </span></span><span><span data-start="455.0">Let&#39;s talk about how to enable them. </span></span><span><span data-start="457.0">There&#39;s two ways to enable library merging in Xcode. </span></span><span><span data-start="461.0">I&#39;ll start with the simplest, automatic merging. </span></span><span><span data-start="464.0">Then, I&#39;ll get into manual merging for whenever you&#39;d like </span></span><span><span data-start="467.0">to take control of what should be mergeable. </span></span><span><span data-start="470.0">I&#39;ll describe how mergeable libraries are able to provide </span></span><span><span data-start="473.0">optimal build times when in debug mode. </span></span><span><span data-start="477.0">And after, I&#39;ll share what to expect when you need to debug into </span></span><span><span data-start="480.0">and symbolicate your mergeable libraries. </span></span><span><span data-start="484.0">Automatic merging informs the build system </span></span><span><span data-start="487.0">to merge all direct dependencies that are embedded framework targets. </span></span><span><span data-start="492.0">It is especially useful on app targets. </span></span><span><span data-start="495.0">I&#39;ll show you. </span></span><span><span data-start="497.0">I&#39;m using the Swift and C++ Forest Project as an example. </span></span><span><span data-start="502.0">There&#39;s an app target that links against four frameworks. </span></span><span><span data-start="507.0">There&#39;s SwiftUI, which comes from the Apple SDK. </span></span><span><span data-start="511.0">The other three, ForestBuilder, ForestUI, and Forest, </span></span><span><span data-start="514.0">are built in the project. </span></span><span><span data-start="517.0">When automatic merging is enabled, </span></span><span><span data-start="519.0">the three forest frameworks will become mergeable. </span></span><span><span data-start="522.0">SwiftUI is left as is since it&#39;s a system library. </span></span><span><span data-start="527.0">While linking the app, these frameworks will be merged </span></span><span><span data-start="530.0">directly into the app binary. </span></span><span><span data-start="533.0">That means these frameworks won&#39;t be needed at launch </span></span><span><span data-start="536.0">and can be removed from disk. </span></span><span><span data-start="539.0">Let&#39;s see how to turn this on in Xcode.</span></span></p><p><span><span data-start="542.0">Inside the project, I&#39;ve already clicked on the Swift and C++ app target </span></span><span><span data-start="546.0">and I&#39;m inside the build settings tab. </span></span><span><span data-start="549.0">I need to update the MERGED_BINARY_TYPE build setting. </span></span><span><span data-start="553.0">I can use the filter text box to search for it.</span></span></p><p><span><span data-start="559.0">&#34;Create Merged Binary&#34; is exactly what I want to update. </span></span><span><span data-start="563.0">It&#39;s the option that&#39;s mapped to the setting MERGED_BINARY_TYPE. </span></span><span><span data-start="568.0">I&#39;ll click on the setting and update its value to Automatic. </span></span><span><span data-start="572.0">And that&#39;s it! </span></span><span><span data-start="576.0">Mergeable library settings are under the General Linking options. </span></span><span><span data-start="580.0">They are conveniently displayed in their own section </span></span><span><span data-start="583.0">named &#34;Linking - Mergeable Libraries.&#34; </span></span><span><span data-start="587.0">When an app is enabled for library merging, </span></span><span><span data-start="590.0">the segments of the libraries are linked directly into the app binary. </span></span><span><span data-start="594.0">This results in a similar performance to static libraries. </span></span><span><span data-start="599.0">But the exports of mergeable libraries are preserved in the app. </span></span><span><span data-start="604.0">It&#39;s often not applicable that apps export symbols </span></span><span><span data-start="606.0">and it negatively impacts the size and build time. </span></span><span><span data-start="611.0">To prevent this, use the linker option -no_exported_symbols. </span></span><span><span data-start="616.0">This can be applied in Xcode by updating Other Linker Flags </span></span><span><span data-start="619.0">with &#34;-Wl, -no_exported_symbols.&#34; </span></span><span><span data-start="624.0">If your app needs entry points for app extensions, </span></span><span><span data-start="627.0">use an export list that lists those symbols to tightly control this. </span></span><span><span data-start="631.0">This can be set under the same General Linking options </span></span><span><span data-start="634.0">using Exported Symbols File. </span></span><span><span data-start="637.0">This allows the static linker to be the most effective </span></span><span><span data-start="640.0">for size optimizations like dead code stripping. </span></span><span><span data-start="644.0">That was automatic merging, but there can be times </span></span><span><span data-start="648.0">when only some of your frameworks should be merged together. </span></span><span><span data-start="652.0">Xcode supports this via Manual Merging. </span></span><span><span data-start="656.0">Manual merging is a fine-grained approach to specifying the libraries to merge. </span></span><span><span data-start="662.0">This is useful when some dependencies need to stay in the app bundle. </span></span><span><span data-start="666.0">I&#39;ll expand on this later when discussing considerations. </span></span><span><span data-start="670.0">It is enabled by setting MERGED_BINARY_TYPE = manual </span></span><span><span data-start="674.0">on the overarching target. </span></span><span><span data-start="677.0">The libraries that should make up the final merged product </span></span><span><span data-start="680.0">are recognized by setting MERGEABLE_LIBRARY to YES. </span></span><span><span data-start="684.0">And for libraries that should stay on disk, </span></span><span><span data-start="686.0">keep the default setting of MERGEABLE_LIBRARY to NO. </span></span><span><span data-start="690.0">Let&#39;s go back to the Swift and C++ Forest Project to demonstrate. </span></span><span><span data-start="694.0">We&#39;re starting fresh without any changes related to automatic merging. </span></span><span><span data-start="699.0">There&#39;s still the app target and the four frameworks it links against. </span></span><span><span data-start="705.0">But now, I&#39;m also considering tests. </span></span><span><span data-start="708.0">There&#39;s an XCTest target and a support framework in the project. </span></span><span><span data-start="712.0">The tests also depend on the forest framework. </span></span><span><span data-start="716.0">Between the project&#39;s frameworks, the dependencies are all intertwined. </span></span><span><span data-start="721.0">In this example, we have an XCTest target, </span></span><span><span data-start="724.0">but in your project, you may have targets like app extensions </span></span><span><span data-start="728.0">that create a similar-looking dependency graph.</span></span></p><p><span><span data-start="733.0">To leverage mergeable libraries, </span></span><span><span data-start="735.0">I&#39;ll isolate the app dependencies for the three forest frameworks.</span></span></p><p><span><span data-start="740.0">I&#39;ll create a framework, ForestKit, that merges the libraries </span></span><span><span data-start="744.0">I need for the app but will also satisfy my test dependency.</span></span></p><p><span><span data-start="750.0">ForestKit is considered a group library because it&#39;ll encapsulate </span></span><span><span data-start="754.0">the mergeable libraries both my app and tests depend on.</span></span></p><p><span><span data-start="759.0">As I&#39;m enabling manual mode, </span></span><span><span data-start="761.0">I&#39;ll explicitly set which frameworks to make mergeable. </span></span><span><span data-start="765.0">In this case, that&#39;s ForestBuilder, ForestUI, and Forest.</span></span></p><p><span><span data-start="771.0">Those dependencies will merge into ForestKit. </span></span><span><span data-start="775.0">By reducing the libraries to load, </span></span><span><span data-start="777.0">my app has improved in launch time and bundle size. </span></span><span><span data-start="782.0">Let&#39;s turn this on in Xcode.</span></span></p><p><span><span data-start="784.0">I&#39;ve restarted the project and removed any settings used for automatic merging. </span></span><span><span data-start="790.0">I&#39;ll start by creating the framework target </span></span><span><span data-start="792.0">that will merge the other frameworks. </span></span><span><span data-start="794.0">This is my group library, ForestKit. </span></span><span><span data-start="797.0">I can do this by clicking at the bottom of the Targets section.</span></span></p><p><span><span data-start="803.0">I&#39;m in the macOS tab in the template pop-up, </span></span><span><span data-start="807.0">and I&#39;ll find the Framework template using the filter text box.</span></span></p><p><span><span data-start="812.0">I&#39;m going to set the product name to ForestKit and click Finish.</span></span></p><p><span><span data-start="819.0">In this framework, I want to merge all libraries </span></span><span><span data-start="822.0">except for the Forest Test Support framework. </span></span><span><span data-start="824.0">But since my dependencies are intertwined, </span></span><span><span data-start="827.0">I&#39;ll link against all of them for the time being. </span></span><span><span data-start="830.0">To do this, I&#39;ll update the &#34;Link Binary with Libraries&#34; build phase </span></span><span><span data-start="835.0">to add the frameworks using the plus sign.</span></span></p><p><span><span data-start="839.0">After the libraries pop-up has appeared, I&#39;ll click on the Forest framework </span></span><span><span data-start="843.0">and hold SHIFT and DOWN to highlight the other frameworks in the Xcode project.</span></span></p><p><span><span data-start="851.0">Next, I need to enable manual merging on this target. </span></span><span><span data-start="855.0">I&#39;ll do this by going to the Build Settings tab </span></span><span><span data-start="857.0">and looking for &#34;Create Merged Binary&#34; again. </span></span><span><span data-start="861.0">I&#39;ll use the filter text box and type &#34;MERGE.&#34; </span></span><span><span data-start="866.0">This time I&#39;ll select Manual as the value. </span></span><span><span data-start="870.0">That&#39;s everything I need to set on the group library target. </span></span><span><span data-start="873.0">I can select which libraries to merge by going to the build settings </span></span><span><span data-start="877.0">for each framework target. </span></span><span><span data-start="880.0">Navigating in the targets section, I&#39;ll start with the Forest framework. </span></span><span><span data-start="885.0">I&#39;m in the Build Settings tab and can click Build Mergeable Library. </span></span><span><span data-start="889.0">This option is mapped to the build setting MERGEABLE_LIBRARY, </span></span><span><span data-start="893.0">and I&#39;ll update this value to Yes.</span></span></p><p><span><span data-start="897.0">I need to do the same for ForestUI and Forest Builder.</span></span></p><p><span><span data-start="907.0">I&#39;m finished creating my merged ForestKit framework. </span></span><span><span data-start="910.0">But I need to update some dependencies. </span></span><span><span data-start="914.0">Because I&#39;ve created a framework that encapsulates most of my dynamic libraries, </span></span><span><span data-start="918.0">I need to ensure my app and tests link against ForestKit and not the others. </span></span><span><span data-start="923.0">I&#39;ll fix up the app first by clicking the Swift and C++ App Target.</span></span></p><p><span><span data-start="932.0">I&#39;m going back to the Build Phases Tab and down to &#34;Link Binary with Libraries.&#34; </span></span><span><span data-start="938.0">This is where I will remove the unnecessary frameworks. </span></span><span><span data-start="941.0">I select Forest and hold SHIFT and UP to collect ForestUI </span></span><span><span data-start="946.0">and ForestBuilder to delete them. </span></span><span><span data-start="949.0">The final step is the tests. </span></span><span><span data-start="951.0">I&#39;ll click on the XCTest target and go to the build phases tab </span></span><span><span data-start="955.0">under &#34;Link Binary with Libraries.&#34; </span></span><span><span data-start="959.0">I&#39;ll remove the Forest framework by clicking the name in the table </span></span><span><span data-start="963.0">and deleting it.</span></span></p><p><span><span data-start="967.0">Then I will add ForestKit using the plus sign.</span></span></p><p><span><span data-start="972.0">Once the pop-up appears, I&#39;ll double-click ForestKit.</span></span></p><p><span><span data-start="979.0">And this is how to configure manual merging. </span></span><span><span data-start="982.0">For the Swift and C++ Forest Project, I&#39;ve been working in release mode. </span></span><span><span data-start="987.0">This is when libraries are merged then removed from disk. </span></span><span><span data-start="990.0">However, there is a build time overhead to merging </span></span><span><span data-start="994.0">that can get costly for development, </span></span><span><span data-start="996.0">similar to the build time behavior with static libraries.</span></span></p><p><span><span data-start="1001.0">To support iterative development in Xcode, the linker will not merge in debug mode. </span></span><span><span data-start="1007.0">The build system tells the linker to reexport the libraries instead. </span></span><span><span data-start="1012.0">Reexporting is a linker option that allows the implementation of code </span></span><span><span data-start="1016.0">to live in one dynamic library but has it show up </span></span><span><span data-start="1019.0">as if it&#39;s implemented in another. </span></span><span><span data-start="1022.0">In other words, this means all of the libraries&#39; APIs are reachable </span></span><span><span data-start="1027.0">by just depending on the merged target, </span></span><span><span data-start="1030.0">like your app extensions or tests. </span></span><span><span data-start="1033.0">This results in a similar build time benefit </span></span><span><span data-start="1036.0">as with dynamic libraries. </span></span><span><span data-start="1039.0">At launch, dyld redirects any references to the reexported libraries </span></span><span><span data-start="1044.0">instead of expecting them to come directly from the merged binary. </span></span><span><span data-start="1049.0">That does mean in the debug case, the mergeable libraries stay on disk.</span></span></p><p><span><span data-start="1055.0">Speaking of debugging, let&#39;s look into a symbol </span></span><span><span data-start="1058.0">that could be in a mergeable library. </span></span><span><span data-start="1060.0">I have a function that takes in an integer and returns back its squared result. </span></span><span><span data-start="1066.0">This is code that gets built. </span></span><span><span data-start="1068.0">However, we know this is not the code a machine executes. </span></span><span><span data-start="1072.0">Instead, this code goes through many transformations. </span></span><span><span data-start="1077.0">This is all fine until we need to look into that code for bugs. </span></span><span><span data-start="1081.0">This is why Xcode supports symbolication. </span></span><span><span data-start="1084.0">Symbolication is the process of associating these machine instructions </span></span><span><span data-start="1089.0">back to the original source code. </span></span><span><span data-start="1092.0">This is useful to be able to understand crash logs </span></span><span><span data-start="1095.0">or to profile and debug your code. </span></span><span><span data-start="1098.0">How does this work with merged binaries? </span></span><span><span data-start="1102.0">When you enable merging, source location information </span></span><span><span data-start="1106.0">is still preserved from the original library. </span></span><span><span data-start="1109.0">That means your debugging experience remains the same. </span></span><span><span data-start="1113.0">But keep in mind, when library information is displayed, </span></span><span><span data-start="1116.0">like for stack traces, it will show the path to the merged binary. </span></span><span><span data-start="1121.0">This information is presented in crash logs, </span></span><span><span data-start="1124.0">inside Instruments, and in the debugger. </span></span><span><span data-start="1128.0">It&#39;s time to take into consideration </span></span><span><span data-start="1130.0">how your own project could adopt mergeable libraries. </span></span><span><span data-start="1134.0">In many cases, enabling them takes a few Xcode settings. </span></span><span><span data-start="1138.0">But there are some factors worth noting. </span></span><span><span data-start="1141.0">I&#39;m going to cover five topics that are important to think about.</span></span></p><p><span><span data-start="1146.0">I&#39;ll begin with how you should handle any pre-existing dependencies </span></span><span><span data-start="1150.0">you have on mergeable libraries. </span></span><span><span data-start="1153.0">Then, I&#39;ll go into what autolinking is and how it works with mergeable libraries. </span></span><span><span data-start="1158.0">And there are some restrictions I&#39;ll get into </span></span><span><span data-start="1160.0">if you use runtime lookup APIs </span></span><span><span data-start="1163.0">like dlopen or the bundle interface. </span></span><span><span data-start="1166.0">Since merging is powered by the static linker in Xcode 15, </span></span><span><span data-start="1170.0">I&#39;ll mention important differences between it and its predecessor. </span></span><span><span data-start="1175.0">And the last consideration will be for folks </span></span><span><span data-start="1177.0">interested in shipping their frameworks to other developers.</span></span></p><p><span><span data-start="1182.0">For library dependencies, let&#39;s go back to the diagram demonstrating dyld&#39;s work. </span></span><span><span data-start="1188.0">If there are dependents of a mergeable library </span></span><span><span data-start="1190.0">that are not merged-- for example, other executables-- </span></span><span><span data-start="1195.0">they will need to update to depend on the merged framework, </span></span><span><span data-start="1199.0">because mergeable ones are removed from disk. </span></span><span><span data-start="1203.0">Another way this can come up is when an app relies on autolinking. </span></span><span><span data-start="1207.0">Autolinking is a compiler option that&#39;s on by default. </span></span><span><span data-start="1211.0">When the compiler finds module imports in source code, </span></span><span><span data-start="1215.0">it detects framework dependencies to then pass to the linker. </span></span><span><span data-start="1219.0">So if you&#39;re importing a module from a mergeable library, </span></span><span><span data-start="1223.0">this could cause dynamic linking issues. </span></span><span><span data-start="1227.0">You won&#39;t need to disable autolinking, though. </span></span><span><span data-start="1230.0">The solution here is the same as before: link against the merged framework.</span></span></p><p><span><span data-start="1237.0">The most common way to do this is to add the merged framework </span></span><span><span data-start="1240.0">in the &#34;Link Binary with Libraries&#34; Build Phase </span></span><span><span data-start="1244.0">and remove the mergeable ones if it&#39;s there already. </span></span><span><span data-start="1247.0">Otherwise, dyld won&#39;t be able to load the right frameworks for your app.</span></span></p><p><span><span data-start="1254.0">Most developers don&#39;t need to use dynamic linking APIs like dlopen. </span></span><span><span data-start="1259.0">But if you do, those input paths will also need </span></span><span><span data-start="1262.0">to point to the merged framework target.</span></span></p><p><span><span data-start="1267.0">Similarly, resource lookup could be impacted by library merging. </span></span><span><span data-start="1272.0">This is because of what the runtime expects. </span></span><span><span data-start="1275.0">In Swift, bundle is an API to have the runtime load a framework&#39;s bundle. </span></span><span><span data-start="1281.0">The equivalent API in Objective-C is NSBundle&#39;s bundleForClass. </span></span><span><span data-start="1286.0">These APIs are used to work with a framework&#39;s resources </span></span><span><span data-start="1291.0">without having to consider the bundle&#39;s structure.</span></span></p><p><span><span data-start="1295.0">Up until iOS 12, the runtime needed the framework&#39;s binary </span></span><span><span data-start="1299.0">to discover bundles, </span></span><span><span data-start="1301.0">but mergeable frameworks won&#39;t have binaries in them </span></span><span><span data-start="1304.0">by the time the process is running. </span></span><span><span data-start="1307.0">Good news! </span></span><span><span data-start="1308.0">In iOS 12, a hook was added to enable lookup for this scenario. </span></span><span><span data-start="1312.0">That does mean if you rely on bundle lookup support, </span></span><span><span data-start="1316.0">you should update your minimum deployment version </span></span><span><span data-start="1318.0">to iOS 12 or later to use mergeable libraries. </span></span><span><span data-start="1323.0">But if you don&#39;t rely on these APIs, you can disable this support </span></span><span><span data-start="1327.0">with the new linker option -no_merged_libraries_hook. </span></span><span><span data-start="1331.0">Then you won&#39;t need to update your app&#39;s deployment version. </span></span><span><span data-start="1335.0">If you&#39;re merging frameworks that don&#39;t contain bundle resources, </span></span><span><span data-start="1338.0">you also may not need the bundle hook. </span></span><span><span data-start="1342.0">If this is the case, you should consider adding </span></span><span><span data-start="1344.0">this option anyway to improve launch time performance. </span></span><span><span data-start="1349.0">Throughout this talk, I&#39;ve mentioned some new linker options. </span></span><span><span data-start="1353.0">These options will only work with the newly implemented linker. </span></span><span><span data-start="1357.0">But if you peek inside the toolchain, </span></span><span><span data-start="1360.0">you&#39;ll notice there are two static linkers. </span></span><span><span data-start="1363.0">The older linker is still supported for backwards compatibility. </span></span><span><span data-start="1367.0">Most notably, that linker can still build for armv7k, </span></span><span><span data-start="1371.0">but the new linker does not. </span></span><span><span data-start="1374.0">The last platform to support the armv7k architecture was watchOS 8. </span></span><span><span data-start="1379.0">If you don&#39;t need to deploy to watchOS 8 or earlier, </span></span><span><span data-start="1383.0">upgrade the deployment version to watchOS 9 to use the new linker. </span></span><span><span data-start="1388.0">I&#39;ve described how to build and use mergeable libraries in your apps, </span></span><span><span data-start="1393.0">but what if you want to ship a mergeable library for others to use? </span></span><span><span data-start="1397.0">You can do this by creating an XCFramework </span></span><span><span data-start="1400.0">in the Swift Package Manager or in Xcode. </span></span><span><span data-start="1403.0">This allows you to build the framework including its metadata for distribution. </span></span><span><span data-start="1409.0">When other developers use the framework, they can decide whether to enable merging. </span></span><span><span data-start="1414.0">Mergeable metadata roughly doubles the size of the dylib. </span></span><span><span data-start="1418.0">This doesn&#39;t impact the size of an app because metadata is discarded </span></span><span><span data-start="1422.0">along with the mergeable library after building the app. </span></span><span><span data-start="1426.0">Otherwise, that metadata does get stripped </span></span><span><span data-start="1429.0">to prevent bloat when embedding them in apps. </span></span><span><span data-start="1433.0">I&#39;ve described some nuances to mergeable libraries. </span></span><span><span data-start="1436.0">Now I&#39;ll share our recommendations. </span></span><span><span data-start="1439.0">Setting dependencies on the merged binary is key to seamlessly adopting. </span></span><span><span data-start="1445.0">This is necessary for any link dependencies. </span></span><span><span data-start="1449.0">It is especially important if you feed libraries </span></span><span><span data-start="1451.0">into tools that expect binaries during script phases. </span></span><span><span data-start="1456.0">The static linker only merges direct dependencies. </span></span><span><span data-start="1460.0">So, to include more mergeable libraries, </span></span><span><span data-start="1463.0">you should set them as explicit link dependencies. </span></span><span><span data-start="1467.0">The settings for merging instructs the Xcode build system </span></span><span><span data-start="1470.0">to remove a framework&#39;s binary from disk. </span></span><span><span data-start="1473.0">This will cause side effects if it&#39;s not intentional, </span></span><span><span data-start="1476.0">so we recommend enabling them at the Xcode target level. </span></span><span><span data-start="1480.0">And finally, to get the biggest benefit on productivity </span></span><span><span data-start="1484.0">while still optimizing for performance, consider updating any static libraries </span></span><span><span data-start="1489.0">that could be mergeable to dynamic. </span></span><span><span data-start="1492.0">Mergeable libraries offer convenience and flexibility. </span></span><span><span data-start="1496.0">Between automatic and manual workflows, you can restructure </span></span><span><span data-start="1500.0">and add mergeable libraries at your leisure </span></span><span><span data-start="1503.0">and leave the necessary ones on disk. </span></span><span><span data-start="1506.0">This flexibility is helpful when gradually adopting or profiling. </span></span><span><span data-start="1511.0">Mergeable libraries offer size, build, and runtime improvements </span></span><span><span data-start="1516.0">when applied to framework and executable targets. </span></span><span><span data-start="1520.0">You can have the build system merge all direct framework dependencies </span></span><span><span data-start="1524.0">by using the automatic configuration. </span></span><span><span data-start="1527.0">But when you need to pick and choose which dependencies to merge, </span></span><span><span data-start="1531.0">this can be done with the manual mode. </span></span><span><span data-start="1534.0">And lastly, when updating your project to use mergeable libraries, </span></span><span><span data-start="1538.0">ensure all dependents of those libraries are relying on the merged binary </span></span><span><span data-start="1543.0">instead of the libraries that get removed. </span></span><span><span data-start="1547.0">For documentation about mergeable libraries, </span></span><span><span data-start="1549.0">review &#34;Configuring your project to use mergeable libraries.&#34; </span></span><span><span data-start="1553.0">And to learn more about static and dynamic linking, </span></span><span><span data-start="1556.0">check out the session &#34;Link fast: Improve build and launch times.&#34; </span></span><span><span data-start="1561.0">We are thrilled to learn how mergeable libraries will be used </span></span><span><span data-start="1564.0">in your projects. </span></span><span><span data-start="1566.0">Thank you for joining me.</span></span></p>
							</section>
						</div></div>
  </body>
</html>
