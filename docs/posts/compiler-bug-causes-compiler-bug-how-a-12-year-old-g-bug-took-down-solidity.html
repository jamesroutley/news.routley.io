<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://osec.io/blog/2025-08-11-compiler-bug-causes-compiler-bug/">Original</a>
    <h1>Compiler Bug Causes Compiler Bug: How a 12-Year-Old G&#43;&#43; Bug Took Down Solidity</h1>
    
    <div id="readability-page-1" class="page"><section><div><!--[--><div><p><!--[-->Compilers aren&#39;t supposed to crash — especially not when compiling perfectly valid code like this:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>// SPDX-License-Identifier: UNLICENSED
</span></span><span line="2"><span>pragma</span><span> solidity</span><span> ^0.8.25;
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span>contract</span><span> A</span><span> {
</span></span><span line="5"><span>    function</span><span> a</span><span>() </span><span>public</span><span> pure</span><span> returns</span><span> (</span><span>uint256</span><span>) {
</span></span><span line="6"><span>        return</span><span> 1</span><span> **</span><span> 2</span><span>;
</span></span><span line="7"><span>    }
</span></span><span line="8"><span>}
</span></span></code><!--]--></pre><!--]--><p><!--[-->Yet running Solidity&#39;s compiler (solc) on this file on a standard Ubuntu 22.04 system (G++ 11.4, Boost 1.74) causes an immediate segmentation fault.<!--]--></p><p><!--[-->At first, this seemed absurd. The code just returns 1 to the power of 2 — no memory tricks, unsafe casting, or undefined behavior.<!--]--></p><p><!--[-->And yet, it crashes.<!--]--></p><p><!--[-->Another minimal example?<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>// SPDX-License-Identifier: UNLICENSED
</span></span><span line="2"><span>pragma</span><span> solidity</span><span> ^0.8.25;
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span>contract</span><span> A</span><span> {
</span></span><span line="5"><span>    function</span><span> a</span><span>() </span><span>public</span><span> pure</span><span> {
</span></span><span line="6"><span>        uint256</span><span>[</span><span>1</span><span>] data;
</span></span><span line="7"><span>    }
</span></span><span line="8"><span>}
</span></span></code><!--]--></pre><!--]--><p><!--[-->Still crashes.<!--]--></p><p><!--[-->So what’s going on?<!--]--></p><p><!--[-->We traced it down to a seemingly unrelated C++ line deep in the compiler backend:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>if</span><span> (</span><span>*</span><span>lengthValue </span><span>==</span><span> 0</span><span>) { ... }
</span></span></code><!--]--></pre><!--]--><p><!--[-->That single comparison — a <code><!--[-->boost::rational<!--]--></code> compared to 0 — causes infinite recursion in G++ &lt; 14 when compiled under C++20. And the resulting stack overflow crashes solc.<!--]--></p><p><!--[-->This post unpacks how this happened — and why none of the individual components are technically &#34;broken&#34;:<!--]--></p><ul><!--[--><li><!--[-->A 12-year-old overload resolution bug in G++<!--]--></li><li><!--[-->An outdated symmetric comparison pattern in Boost<!--]--></li><li><!--[-->A subtle but impactful rewrite rule in C++20<!--]--></li><!--]--></ul><p><!--[-->Put together, they form a perfect storm — one that takes down Solidity compilation on default Linux setups, even though your code is perfectly fine.<!--]--></p><hr/><h2 id="background-the-setup"><a href="#background-the-setup"><!--[-->Background: The Setup<!--]--></a></h2><p><!--[-->If you follow the <a href="https://docs.soliditylang.org/en/v0.8.30/installing-solidity.html#building-from-source" rel="nofollow"><!--[-->Solidity build documentation (v0.8.30)<!--]--></a>, you&#39;ll see it recommends:<!--]--></p><ul><!--[--><li><!--[-->Boost ≥ 1.67<!--]--></li><li><!--[-->GCC ≥ 11<!--]--></li><!--]--></ul><p><!--[-->Ubuntu 22.04, for example, ships with:<!--]--></p><ul><!--[--><li><!--[-->G++ 11.4.0<!--]--></li><li><!--[-->Boost 1.74.0<!--]--></li><!--]--></ul><p><!--[-->So far, so good.<!--]--></p><p><!--[-->However, Solidity enabled <strong><!--[-->C++20<!--]--></strong> in January 2025:<!--]--></p><blockquote><!--[--><p><!--[--><a href="https://github.com/ethereum/solidity/commit/233a5081835a04939ccf85dfb5286c0b53d23c66" rel="nofollow"><!--[-->Enable C++20 in Solidity<!--]--></a><!--]--></p><!--]--></blockquote><p><!--[-->This wasn&#39;t accompanied by an update to the versions of dependencies in the documentation. As we&#39;ll soon see, that&#39;s what opened the trapdoor.<!--]--></p><hr/><h2 id="part-i-a-12-year-old-g-bug-in-overload-resolution"><a href="#part-i-a-12-year-old-g-bug-in-overload-resolution"><!--[-->Part I: A 12-Year-Old G++ Bug in Overload Resolution<!--]--></a></h2><h3 id="whats-overload-resolution"><a href="#whats-overload-resolution"><!--[-->What’s Overload Resolution?<!--]--></a></h3><p><!--[-->In C++, when you write an expression like <code><!--[-->a == b<!--]--></code>, the compiler chooses among available <code><!--[-->operator==<!--]--></code> implementations by comparing their <strong><!--[-->match quality<!--]--></strong>. A <strong><!--[-->member function<!--]--></strong> like <code><!--[-->a.operator==(b)<!--]--></code> usually has higher priority than a <strong><!--[-->non-member function<!--]--></strong> like <code><!--[-->operator==(a, b)<!--]--></code> — unless the types differ too much or are ambiguous.<!--]--></p><p><!--[-->That’s the rule. But G++ didn’t always follow it.<!--]--></p><h3 id="the-bug"><a href="#the-bug"><!--[-->The Bug<!--]--></a></h3><p><!--[-->In 2012, a bug was filed: <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53499" rel="nofollow"><!--[-->GCC Bug 53499 – overload resolution favors non-member function<!--]--></a>. The issue? In expressions where:<!--]--></p><ul><!--[--><li><!--[-->A class <code><!--[-->rational&lt;T&gt;<!--]--></code> has a templated <code><!--[-->operator==<!--]--></code> member function<!--]--></li><li><!--[-->There&#39;s also a more generic free <code><!--[-->operator==(rational&lt;T&gt;, U)<!--]--></code> function<!--]--></li><!--]--></ul><p><!--[--><strong><!--[-->Clang correctly chooses the member function.<!--]--></strong><!--]--></p><p><!--[--><strong><!--[-->G++ (before v14) chooses the non-member function.<!--]--></strong><!--]--></p><p><!--[-->Why? Because G++ mishandles <strong><!--[-->templated conversion + non-exact match<!--]--></strong>, overvaluing a non-member function with worse match quality. It does not correctly apply the overload resolution ranking rules defined in <a href="https://cplusplus.github.io/CWG/issues/532.html" rel="nofollow"><!--[-->CWG532: Member/nonmember operator template partial ordering<!--]--></a>.<!--]--></p><h3 id="a-minimal-reproducer"><a href="#a-minimal-reproducer"><!--[-->A Minimal Reproducer<!--]--></a></h3><p><!--[-->Let’s see this in action:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>#include</span><span> &lt;iostream&gt;
</span></span><span line="2"><span emptylineplaceholder="true">
</span></span><span line="3"><span>template</span><span> &lt;</span><span>typename</span><span> IntType</span><span>&gt;
</span></span><span line="4"><span>class</span><span> rational</span><span> {
</span></span><span line="5"><span>public:
</span></span><span line="6"><span>    template</span><span> &lt;</span><span>class</span><span> T</span><span>&gt;
</span></span><span line="7"><span>    bool</span><span> operator</span><span>==(</span><span>const</span><span> T</span><span>&amp;</span><span> i</span><span>) </span><span>const</span><span> {
</span></span><span line="8"><span>        std::cout </span><span>&lt;&lt;</span><span> &#34;clang++ resolved member&#34;</span><span> &lt;&lt;</span><span> std::endl;
</span></span><span line="9"><span>        return</span><span> true</span><span>;
</span></span><span line="10"><span>    }
</span></span><span line="11"><span>};
</span></span><span line="12"><span emptylineplaceholder="true">
</span></span><span line="13"><span>template</span><span> &lt;</span><span>class</span><span> Arg</span><span>, </span><span>class</span><span> IntType</span><span>&gt;
</span></span><span line="14"><span>bool</span><span> operator</span><span>==(</span><span>const</span><span> rational</span><span>&lt;</span><span>IntType</span><span>&gt;</span><span>&amp;</span><span> a</span><span>, </span><span>const</span><span> Arg</span><span>&amp;</span><span> b</span><span>) {
</span></span><span line="15"><span>    std::cout </span><span>&lt;&lt;</span><span> &#34;g++ &lt;14 resolved non-member&#34;</span><span> &lt;&lt;</span><span> std::endl;
</span></span><span line="16"><span>    return</span><span> false</span><span>;
</span></span><span line="17"><span>}
</span></span><span line="18"><span emptylineplaceholder="true">
</span></span><span line="19"><span>int</span><span> main</span><span>() {
</span></span><span line="20"><span>    rational</span><span>&lt;</span><span>int</span><span>&gt;</span><span> r;
</span></span><span line="21"><span>    return</span><span> r </span><span>==</span><span> 0</span><span>;
</span></span><span line="22"><span>}
</span></span></code><!--]--></pre><!--]--><ul><!--[--><li><!--[-->Compile with g++&lt;14:<!--[--><pre><!--[--><code><span line="1"><span>g++</span><span> -std=c++17</span><span> main.cpp</span><span> -o</span><span> test</span><span> &amp;&amp; </span><span>./test
</span></span></code><!--]--></pre><!--]--><!--[--><!--]--><!--]--></li><li><!--[-->Compile with clang++:<!--[--><pre><!--[--><code><span line="1"><span>clang++</span><span> -std=c++17</span><span> main.cpp</span><span> -o</span><span> test</span><span> &amp;&amp; </span><span>./test
</span></span></code><!--]--></pre><!--]--><!--[--><!--]--><!--]--></li><!--]--></ul><p><!--[-->In short, the wrong function gets picked. G++ was broken here until v14.<!--]--></p><hr/><h2 id="part-ii-c20s-symmetric-comparison-feature"><a href="#part-ii-c20s-symmetric-comparison-feature"><!--[-->Part II: C++20’s Symmetric Comparison Feature<!--]--></a></h2><h3 id="what-changed-in-c20"><a href="#what-changed-in-c20"><!--[-->What Changed in C++20?<!--]--></a></h3><p><!--[-->C++20 introduced the <a href="https://en.cppreference.com/w/cpp/language/operator_comparison" rel="nofollow"><!--[-->spaceship operator <code><!--[-->&lt;=&gt;<!--]--></code><!--]--></a> and <strong><!--[-->defaulted comparison rewrites<!--]--></strong>.<!--]--></p><p><!--[-->When you define a two-argument <code><!--[-->operator==<!--]--></code>, C++20 may implicitly define the &#34;reversed&#34; version:<!--]--></p><ul><!--[--><li><!--[-->If you define: <code><!--[-->bool operator==(T1, T2);<!--]--></code><!--]--></li><li><!--[-->Then <code><!--[-->T2 == T1<!--]--></code> may call the same function by reversing the arguments.<!--]--></li><!--]--></ul><p><!--[-->This rewrite is <strong><!--[-->recursive<!--]--></strong>: <code><!--[-->a == b<!--]--></code> becomes <code><!--[-->b == a<!--]--></code>, which becomes <code><!--[-->a == b<!--]--></code> again, and so on — if not handled carefully.<!--]--></p><p><!--[-->This is great for reducing boilerplate — unless the call becomes ambiguous or self-referential.<!--]--></p><hr/><h2 id="part-iii-the-boost-trapdoor"><a href="#part-iii-the-boost-trapdoor"><!--[-->Part III: The Boost Trapdoor<!--]--></a></h2><p><!--[-->The old Boost <code><!--[-->rational<!--]--></code> class (prior to v1.75) defined both member function and non-member function of <code><!--[-->operator==<!--]--></code>:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>template</span><span> &lt;</span><span>class</span><span> Arg</span><span>, </span><span>class</span><span> IntType</span><span>&gt;
</span></span><span line="2"><span>template</span><span> &lt;</span><span>typename</span><span> IntType</span><span>&gt;
</span></span><span line="3"><span>class</span><span> rational
</span></span><span line="4"><span>{
</span></span><span line="5"><span>    ...
</span></span><span line="6"><span>public:
</span></span><span line="7"><span>    ...
</span></span><span line="8"><span>    
</span></span><span line="9"><span>    template</span><span> &lt;</span><span>class</span><span> T</span><span>&gt;
</span></span><span line="10"><span>    BOOST_CONSTEXPR </span><span>typename</span><span> boost::enable_if_c&lt;rational_detail::is_compatible_integer&lt;</span><span>T</span><span>, </span><span>IntType</span><span>&gt;::</span><span>value</span><span>, </span><span>bool</span><span>&gt;::</span><span>type</span><span> operator</span><span>== (</span><span>const</span><span> T</span><span>&amp;</span><span> i</span><span>) </span><span>const
</span></span><span line="11"><span>    {
</span></span><span line="12"><span>       return</span><span> ((den </span><span>==</span><span> IntType</span><span>(</span><span>1</span><span>)) </span><span>&amp;&amp;</span><span> (num </span><span>==</span><span> i));
</span></span><span line="13"><span>    }
</span></span><span line="14"><span>    ...
</span></span><span line="15"><span>}
</span></span><span line="16"><span emptylineplaceholder="true">
</span></span><span line="17"><span>template</span><span> &lt;</span><span>class</span><span> Arg</span><span>, </span><span>class</span><span> IntType</span><span>&gt;
</span></span><span line="18"><span>BOOST_CONSTEXPR
</span></span><span line="19"><span>inline</span><span> typename</span><span> boost::</span><span>enable_if_c</span><span> &lt;
</span></span><span line="20"><span>   rational_detail::is_compatible_integer&lt;</span><span>Arg</span><span>, </span><span>IntType</span><span>&gt;::value, </span><span>bool</span><span>&gt;</span><span>::type
</span></span><span line="21"><span>   operator</span><span> == (</span><span>const</span><span> Arg</span><span>&amp;</span><span> b</span><span>, </span><span>const</span><span> rational</span><span>&lt;</span><span>IntType</span><span>&gt;</span><span>&amp;</span><span> a</span><span>)
</span></span><span line="22"><span>{
</span></span><span line="23"><span>      return</span><span> a </span><span>==</span><span> b; 
</span></span><span line="24"><span>}
</span></span></code><!--]--></pre><!--]--><p><!--[-->This was designed under C++17 semantics. Back then, <code><!--[-->rhs == lhs<!--]--></code> would fall back to member overloads if available. All good.<!--]--></p><p><!--[-->But under <code><!--[-->C++20<!--]--></code> with <code><!--[-->G++ &lt; 14<!--]--></code>:<!--]--></p><ul><!--[--><li><!--[-->G++ incorrectly chooses this non-member operator first<!--]--></li><li><!--[-->C++20 reverses the comparison<!--]--></li><li><!--[-->Which calls the same function again with arguments flipped<!--]--></li><li><!--[-->And so on...<!--]--></li><!--]--></ul><p><!--[-->This creates <strong><!--[-->infinite recursion<!--]--></strong>.<!--]--></p><p><!--[-->A minimal example:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>// g++ -std=c++20 -o crash main.cpp &amp;&amp; ./crash
</span></span><span line="2"><span>#include</span><span> &lt;boost/rational.hpp&gt;
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span>int</span><span> main</span><span>() {
</span></span><span line="5"><span>    boost::rational</span><span>&lt;</span><span>int</span><span>&gt;</span><span> r;
</span></span><span line="6"><span>    return</span><span> r </span><span>==</span><span> 0</span><span>;
</span></span><span line="7"><span>}
</span></span></code><!--]--></pre><!--]--><p><!--[-->Expected output: nothing.<!--]--></p><p><!--[-->Actual: segmentation fault (stack overflow).<!--]--></p><p><!--[-->This exact pattern was <a href="https://github.com/boostorg/rational/issues/43" rel="nofollow"><!--[-->reported and fixed in Boost rational<!--]--></a>, but only in version 1.75+.<!--]--></p><p><!--[-->Here’s the one-line fix:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>template &lt;class Arg, class IntType&gt;
</span></span><span line="2"><span>BOOST_CONSTEXPR
</span></span><span line="3"><span>inline typename boost::enable_if_c &lt;
</span></span><span line="4"><span>   rational_detail::is_compatible_integer&lt;Arg, IntType&gt;::value, bool&gt;::type
</span></span><span line="5"><span>   operator == (const Arg&amp; b, const rational&lt;IntType&gt;&amp; a)
</span></span><span line="6"><span>{
</span></span><span line="7"><span>-     return a == b;
</span></span><span line="8"><span>+     return a.operator==(b);
</span></span><span line="9"><span>}
</span></span></code><!--]--></pre><!--]--><p><!--[-->Instead of calling <code><!--[-->a == b<!--]--></code> — which triggers overload resolution again — the patched version directly calls the member function <code><!--[-->operator==<!--]--></code>.<!--]--></p><p><!--[-->This prevents C++20 from triggering recursive rewrites.<!--]--></p><hr/><h2 id="part-iv-how-this-breaks-solidity"><a href="#part-iv-how-this-breaks-solidity"><!--[-->Part IV: How This Breaks Solidity<!--]--></a></h2><p><!--[-->The Solidity codebase uses <code><!--[-->boost::rational<!--]--></code> to represent certain compile-time constant expressions.<!--]--></p><p><!--[-->One snippet that can trigger this issue appears in <code><!--[-->DeclarationTypeChecker::endVisit<!--]--></code>:<!--]--></p><!--[--><pre><!--[--><code><span line="1"><span>if</span><span> (Expression </span><span>const</span><span>*</span><span> length </span><span>=</span><span> _typeName</span><span>.</span><span>length</span><span>()) {
</span></span><span line="2"><span>    std::optional</span><span>&lt;</span><span>rational</span><span>&gt;</span><span> lengthValue;
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span>    if</span><span> (</span><span>length</span><span>-&gt;</span><span>annotation</span><span>().</span><span>type</span><span> &amp;&amp;</span><span> length</span><span>-&gt;</span><span>annotation</span><span>().</span><span>type</span><span>-&gt;</span><span>category</span><span>() </span><span>==</span><span> Type::Category::RationalNumber)
</span></span><span line="5"><span>        ...
</span></span><span line="6"><span>    else</span><span> if</span><span> (std::optional</span><span>&lt;</span><span>ConstantEvaluator::TypedRational</span><span>&gt;</span><span> value </span><span>=</span><span> ConstantEvaluator::</span><span>evaluate</span><span>(...))
</span></span><span line="7"><span>        lengthValue </span><span>=</span><span> value</span><span>-&gt;</span><span>value</span><span>;
</span></span><span line="8"><span emptylineplaceholder="true">
</span></span><span line="9"><span>    if</span><span> (</span><span>!</span><span>lengthValue)
</span></span><span line="10"><span>        ...
</span></span><span line="11"><span>    else</span><span> if</span><span> (</span><span>*</span><span>lengthValue </span><span>==</span><span> 0</span><span>)</span><span>  // &lt;-- Infinite recursion happens here
</span></span><span line="12"><span>        ...
</span></span><span line="13"><span>}
</span></span></code><!--]--></pre><!--]--><p><!--[-->Under normal circumstances, this expression is benign. But:<!--]--></p><ul><!--[--><li><!--[-->G++ &lt; 14 wrongly prefers Boost&#39;s non-member operator<!--]--></li><li><!--[-->C++20 reverses the arguments<!--]--></li><li><!--[-->The non-member operator recursively calls itself<!--]--></li><!--]--></ul><p><!--[-->💥: segmentation fault.<!--]--></p><hr/><h2 id="part-v-what-environments-are-affected"><a href="#part-v-what-environments-are-affected"><!--[-->Part V: What Environments are Affected?<!--]--></a></h2><p><!--[-->If a system uses any of the following:<!--]--></p><ul><!--[--><li><!--[-->G++ &lt; 14 (e.g., Ubuntu 22.04 uses 11.4)<!--]--></li><li><!--[-->Boost &lt; 1.75 (e.g., 1.74 ships with Ubuntu)<!--]--></li><li><!--[-->C++20 enabled (default in recent Solidity builds)<!--]--></li><!--]--></ul><p><!--[-->They will encounter this crash <strong><!--[-->as soon as<!--]--></strong> it processes a Solidity source with a length expression like <code><!--[-->T[0]<!--]--></code> or anything involving compile-time rational comparisons.<!--]--></p><hr/><h2 id="recommendations"><a href="#recommendations"><!--[-->Recommendations<!--]--></a></h2><ul><!--[--><li><!--[--><strong><!--[-->Update Boost to ≥ 1.75<!--]--></strong><!--]--></li><li><!--[--><strong><!--[-->Pin G++ to v14 or later<!--]--></strong><!--]--></li><!--]--></ul><hr/><h2 id="conclusion"><a href="#conclusion"><!--[-->Conclusion<!--]--></a></h2><p><!--[-->This isn’t a security vulnerability. It doesn’t corrupt memory or allow code execution.<!--]--></p><p><!--[-->But it <strong><!--[-->is<!--]--></strong> a reminder of the fragility of modern build stacks. A bug introduced in 2012, fixed in 2024, quietly broke one of the most used blockchain compiler toolchains — all without any code in the Solidity repo being “wrong.”<!--]--></p><p><!--[-->Every layer here — Boost, G++, the C++20 spec, and Solidity — behaved “as documented.” But together, they composed into undefined behavior.<!--]--></p><p><!--[-->The lesson? Always test critical software under multiple compilers and library versions — especially when enabling a new language standard.<!--]--></p></div><!--]--></div></section></div>
  </body>
</html>
