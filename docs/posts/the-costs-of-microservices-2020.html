<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://robertovitillo.com/costs-of-microservices/">Original</a>
    <h1>The costs of microservices (2020)</h1>
    
    <div id="readability-page-1" class="page"><article><header><p>November 22, 2020</p></header><p>An application typically starts its life as a monolith. Take a modern backend of a single-page Javascript application, for example - it starts out as a single stateless web service that exposes a RESTful HTTP API and uses a relational database as a backing store. The service is composed of a number of components, or libraries, that implement different business capabilities:</p><p><span>
      <a href="https://robertovitillo.com/static/20b3d909b15d98f33bee31e8357203ce/024d6/monolith.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Monolith" title="Monolith" src="https://robertovitillo.com/static/20b3d909b15d98f33bee31e8357203ce/fcda8/monolith.png" srcset="/static/20b3d909b15d98f33bee31e8357203ce/12f09/monolith.png 148w,/static/20b3d909b15d98f33bee31e8357203ce/e4a3f/monolith.png 295w,/static/20b3d909b15d98f33bee31e8357203ce/fcda8/monolith.png 590w,/static/20b3d909b15d98f33bee31e8357203ce/efc66/monolith.png 885w,/static/20b3d909b15d98f33bee31e8357203ce/024d6/monolith.png 961w" sizes="(max-width: 590px) 100vw, 590px" loading="lazy"/>
  </a>
    </span></p><p>As the number of feature teams contributing to the same codebase increases, its components become increasingly coupled over time. This leads the teams to step on each other’s toes more and more frequently, decreasing their productivity. </p><p>The codebase becomes complex enough that nobody fully understands every part of it, and implementing new features or fixing bugs becomes time-consuming. Even if the backend is componentized into different libraries owned by different teams, a change to a library requires the service to be redeployed. And if a change introduces a bug - like a memory leak - the entire service can potentially be affected by it. Additionally, rolling back a faulty build affects the velocity of all teams, not just the one that introduced the bug.</p><p>One way to mitigate the growing pains of a <em>monolithic</em> backend is to split it into a set of independently deployable services that communicate via APIs. The APIs decouple the services from each other by creating boundaries that are hard to violate, unlike the ones between components running in the same process: </p><p><span>
      <a href="https://robertovitillo.com/static/54b0da5dd791ad53ea771e66c73f5d67/dc61a/api_gw.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Microservices" title="Microservices" src="https://robertovitillo.com/static/54b0da5dd791ad53ea771e66c73f5d67/fcda8/api_gw.png" srcset="/static/54b0da5dd791ad53ea771e66c73f5d67/12f09/api_gw.png 148w,/static/54b0da5dd791ad53ea771e66c73f5d67/e4a3f/api_gw.png 295w,/static/54b0da5dd791ad53ea771e66c73f5d67/fcda8/api_gw.png 590w,/static/54b0da5dd791ad53ea771e66c73f5d67/efc66/api_gw.png 885w,/static/54b0da5dd791ad53ea771e66c73f5d67/dc61a/api_gw.png 1147w" sizes="(max-width: 590px) 100vw, 590px" loading="lazy"/>
  </a>
    </span></p><p>This architectural style is also referred to as the microservice architecture. The term <em>micro</em> can be misleading, though - there doesn’t have to be anything micro about the services. In fact, I would argue that if a service doesn’t do much, it just creates more operational toll than benefits. A more appropriate name for this architecture is <a href="https://en.wikipedia.org/wiki/Service-oriented_architecture">service-oriented architecture</a>, but unfortunately, that name comes with some old baggage as well. Perhaps in 10 years, we will call the same concept with yet another name, but for now we will have to stick to microservices. </p><p>Breaking down the backend by business capabilities into a set of services with well-defined boundaries allows each service to be developed and operated by a single small team. The reduced team size increases the application’s development speed for a variety of reasons:</p><ul><li>Smaller teams are more effective as the communication overhead grows <a href="https://en.wikipedia.org/wiki/The_Mythical_Man-Month">quadratically</a> with the team’s size.</li><li>As each team dictates its own release schedule and has complete control over its codebase, less cross-team communication is required, and therefore decisions can be taken in less time.</li><li>The codebase of a service is smaller and easier to digest by its developers, reducing the time it takes to ramp up new hires. Also, a smaller codebase doesn’t slow down IDEs, which makes the developers more productive. </li><li>The boundaries between services are much stronger than the boundaries between components in the same process. Because of that, when a developer needs to change a part of the backend, they only need to understand a small part of the whole. </li><li>Each service can be scaled independently and adopt a different technology stack based on its own needs. The consumers of the APIs don’t care how the functionality is implemented after all. This makes it easy to experiment and evaluate new technologies without affecting other parts of the system.</li><li>Each microservice can have its own independent data model and data store(s) that best fit its use-cases, allowing developers to change its schema without affecting other services. </li></ul><h2 id="costs"><a href="#costs" aria-label="costs permalink"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Costs</h2><p>The microservices architecture adds more moving parts to the overall system, and this doesn’t come for free. The cost of fully embracing microservices is only worth paying if it can be amortized across dozens of development teams. </p><p><strong>Development Experience</strong></p><p>Nothing forbids the use of different languages, libraries, and datastores for each microservice - but doing so transforms the application into an unmaintainable mess. For example, it makes it more challenging for a developer to move from one team to another if the software stack is completely different. And think of the sheer number of libraries - one for each language adopted - that need to be supported to provide common functionality that all services need, like logging.</p><p>It’s only reasonable then that a certain degree of standardization is needed. One way to do that - while still allowing some degree of freedom - is to loosely encourage specific technologies by providing a great development experience for the teams that stick with the recommended portfolio of languages and technologies.</p><p><strong>Resource Provisioning</strong></p><p>To support a large number of independent services, it should be simple to spin up new servers, data stores, and other commodity resources - you don’t want every team to come up with their own way of doing it. And once these resources have been provisioned, they have to be configured. To be able to pull this off, you will need a fair amount of automation.</p><p><strong>Communication</strong></p><p>Remote calls are expensive and introduce <a href="https://robertovitillo.com/default-timeouts/">new and fun ways</a> your systems can crumble. You will need defense mechanisms to protect against failures, like timeouts, retries and circuit breakers. You will also have to leverage asynchrony and batching to mitigate the performance hit of communicating across the network. All of which increases the system’s complexity. A lot of what I describe in my <a href="https://understandingdistributed.systems/">book about distributed systems</a> is about dealing with this complexity. </p><p>That being said, even a monolith doesn’t live in isolation as it’s being accessed by remote clients, and it’s likely to use third-party APIs as well. So eventually, these issues need to be solved there as well, albeit on a smaller scale.</p><p><strong>Continuous Integration, Delivery, and Deployment</strong></p><p>Continuous integration ensures that code changes are merged into the main branch after an automated build and test processes have run. Once a code change has been merged, it should be automatically published and deployed to a production-like environment, where a battery of integration and end-to-end tests run to ensure that the microservice doesn’t break any service that depends on it.</p><p>While testing individual microservices is not more challenging than testing a monolith, testing the integration of all the microservices is an order of magnitude harder. Very subtle and unexpected behavior can emerge when individual services interact with each other. </p><p><strong>Operations</strong></p><p>Unlike with a monolith, it’s much more expensive to staff each team responsible for a service with its own operations team. As a result, the team that develops a service is typically also on-call for it. This creates friction between development work and operational toll as the team needs to decide what to prioritize during each sprint. </p><p>Debugging systems failures becomes more challenging as well - you can’t just load the whole application on your local machine and step through it with a debugger. The system has more ways to fail, as there are more moving parts. This is why good logging and monitoring becomes crucial at all levels.</p><p><strong>Eventual Consistency</strong></p><p>A side effect of splitting an application into separate services is that the data model no longer resides in a single data store. Atomically updating records stored in different data stores, and guaranteeing strong consistency, is slow, expensive, and hard to get right. Hence, this type of architecture usually requires embracing eventual consistency.</p><h2 id="practical-considerations"><a href="#practical-considerations" aria-label="practical considerations permalink"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Practical Considerations</h2><p>Splitting an application into services adds a lot of complexity to the overall system. Because of that, it’s generally best to start with a monolith and split it up only when there is a good reason to do so. </p><p>Getting the boundaries right between the services is challenging - it’s much easier to move them around within a monolith until you find a sweet spot. Once the monolith is well matured and growing pains start to rise, then you can start to peel off one microservice at a time from it. </p><p>You should only start with a microservice first approach if you already have experience with it, and you either have built out a platform for it or have accounted for the time it will take you to build one. </p><hr/></article></div>
  </body>
</html>
