<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/hanickadot/compile-time-regular-expressions">Original</a>
    <h1>Compile time regular expression in C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a href="https://travis-ci.org/hanickadot/compile-time-regular-expressions" rel="nofollow"><img src="https://camo.githubusercontent.com/6bc5e935ae49891f8eed0de3b70687e456dd52886d86c21a09a27443ec399c8e/68747470733a2f2f7472617669732d63692e6f72672f68616e69636b61646f742f636f6d70696c652d74696d652d726567756c61722d65787072657373696f6e732e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/hanickadot/compile-time-regular-expressions.svg?branch=master"/></a></p>
<p dir="auto">Fast compile-time regular expressions with support for matching/searching/capturing during compile-time or runtime.</p>
<p dir="auto">You can use the single header version from directory <code>single-header</code>. This header can be regenerated with <code>make single-header</code>. If you are using cmake, you can add this directory as subdirectory and link to target <code>ctre</code>.</p>
<p dir="auto">More info at <a href="https://compile-time.re/" rel="nofollow">compile-time.re</a></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-what-this-library-can-do" aria-hidden="true" tabindex="-1" href="#what-this-library-can-do"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What this library can do</h2>
<div dir="auto" data-snippet-clipboard-copy-content="ctre::match&lt;&#34;REGEX&#34;&gt;(subject); // C++20
&#34;REGEX&#34;_ctre.match(subject); // C++17 + N3599 extension"><pre>ctre::match&lt;<span><span>&#34;</span>REGEX<span>&#34;</span></span>&gt;(subject); <span><span>//</span> C++20</span>
<span><span>&#34;</span>REGEX<span>&#34;</span></span>_ctre.match(subject); <span><span>//</span> C++17 + N3599 extension</span></pre></div>
<ul dir="auto">
<li>Matching</li>
<li>Searching (<code>search</code> or <code>starts_with</code>)</li>
<li>Capturing content (named captures are supported too)</li>
<li>Back-Reference (\g{N} syntax, and \1...\9 syntax too)</li>
<li>Multiline support (with <code>multi_</code>) functions</li>
<li>Unicode properties and UTF-8 support</li>
</ul>
<p dir="auto">The library is implementing most of the PCRE syntax with a few exceptions:</p>
<ul dir="auto">
<li>callouts</li>
<li>comments</li>
<li>conditional patterns</li>
<li>control characters (<code>\cX</code>)</li>
<li>match point reset (<code>\K</code>)</li>
<li>named characters</li>
<li>octal numbers</li>
<li>options / modes</li>
<li>subroutines</li>
<li>unicode grapheme cluster (<code>\X</code>)</li>
</ul>
<p dir="auto">More documentation on <a href="https://www.pcre.org/current/doc/html/pcre2syntax.html" rel="nofollow">pcre.org</a>.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-unknown-character-escape-behaviour" aria-hidden="true" tabindex="-1" href="#unknown-character-escape-behaviour"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Unknown character escape behaviour</h3>
<p dir="auto">Not all escaped characters are automatically inserted as self, behaviour of the library is escaped characters are with special meaning, unknown escaped character is a syntax error.</p>
<p dir="auto">Explicitly allowed character escapes which insert only the character are:</p>
<p dir="auto"><code>\-\&#34;\&lt;\&gt;</code></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-basic-api" aria-hidden="true" tabindex="-1" href="#basic-api"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic API</h2>
<p dir="auto">This is approximated API specification from a user perspective (omitting <code>constexpr</code> and <code>noexcept</code> which are everywhere, and using C++20 syntax even the API is C++17 compatible):</p>
<div dir="auto" data-snippet-clipboard-copy-content="// look if whole input matches the regex:
template &lt;fixed_string regex&gt; auto ctre::match(auto Range &amp;&amp;) -&gt; regex_results;
template &lt;fixed_string regex&gt; auto ctre::match(auto First &amp;&amp;, auto Last &amp;&amp;) -&gt; regex_results;

// look if input contains match somewhere inside of itself:
template &lt;fixed_string regex&gt; auto ctre::search(auto Range &amp;&amp;) -&gt; regex_results;
template &lt;fixed_string regex&gt; auto ctre::search(auto First &amp;&amp;, auto Last &amp;&amp;) -&gt; regex_results;

// check if input starts with match (but doesn&#39;t need to match everything):
template &lt;fixed_string regex&gt; auto ctre::starts_with(auto Range &amp;&amp;) -&gt; regex_results;
template &lt;fixed_string regex&gt; auto ctre::starts_with(auto First &amp;&amp;, auto Last &amp;&amp;) -&gt; regex_results;

// result type is deconstructible into a structured bindings
template &lt;...&gt; struct regex_results {
	operator bool() const; // if it&#39;s a match
	auto to_view() const -&gt; std::string_view; // also view()
	auto to_string() const -&gt; std::string; // also str()
	operator std::string_view() const; // also supports all char variants
	explicit operator std::string() const;
	
	// also size(), begin(), end(), data()
	
	size_t count() const; // number of captures 
	template &lt;size_t Id&gt; const captured_content &amp; get() const; // provide specific capture, whole regex_results is implicit capture 0
};"><pre><span><span>//</span> look if whole input matches the regex:</span>
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::match</span>(<span>auto</span> Range &amp;&amp;) -&gt; regex_results;
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::match</span>(<span>auto</span> First &amp;&amp;, <span>auto</span> Last &amp;&amp;) -&gt; regex_results;

<span><span>//</span> look if input contains match somewhere inside of itself:</span>
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::search</span>(<span>auto</span> Range &amp;&amp;) -&gt; regex_results;
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::search</span>(<span>auto</span> First &amp;&amp;, <span>auto</span> Last &amp;&amp;) -&gt; regex_results;

<span><span>//</span> check if input starts with match (but doesn&#39;t need to match everything):</span>
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::starts_with</span>(<span>auto</span> Range &amp;&amp;) -&gt; regex_results;
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::starts_with</span>(<span>auto</span> First &amp;&amp;, <span>auto</span> Last &amp;&amp;) -&gt; regex_results;

<span><span>//</span> result type is deconstructible into a structured bindings</span>
<span>template </span>&lt;...&gt; <span>struct</span> <span>regex_results</span> {
	<span>operator</span> <span>bool</span>() <span>const</span>; <span><span>//</span> if it&#39;s a match</span>
	<span>auto</span> <span>to_view</span>() <span>const</span> -&gt; std::string_view; <span><span>//</span> also view()</span>
	<span>auto</span> <span>to_string</span>() <span>const</span> -&gt; std::string; <span><span>//</span> also str()</span>
	<span>operator</span> <span>std::string_view</span>() <span>const</span>; <span><span>//</span> also supports all char variants</span>
	<span>explicit</span> <span>operator</span> <span>std::string</span>() <span>const</span>;
	
	<span><span>//</span> also size(), begin(), end(), data()</span>
	
	<span>size_t</span> <span>count</span>() <span>const</span>; <span><span>//</span> number of captures </span>
	<span>template </span>&lt;<span>size_t</span> Id&gt; <span>const</span> captured_content &amp; <span>get</span>() <span>const</span>; <span><span>//</span> provide specific capture, whole regex_results is implicit capture 0</span>
};</pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-range-outputing-api" aria-hidden="true" tabindex="-1" href="#range-outputing-api"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Range outputing API</h3>
<div dir="auto" data-snippet-clipboard-copy-content="// search for regex in input and return each occurence, ignoring rest:
template &lt;fixed_string regex&gt; auto ctre::range(auto Range &amp;&amp;) -&gt; range of regex_result;
template &lt;fixed_string regex&gt; auto ctre::range(auto First &amp;&amp;, auto Last &amp;&amp;) -&gt; range of regex_result;

// return range of each match, stopping at something which can&#39;t be matched
template &lt;fixed_string regex&gt; auto ctre::tokenize(auto Range &amp;&amp;) -&gt; range of regex_result;
template &lt;fixed_string regex&gt; auto ctre::tokenize(auto First &amp;&amp;, auto Last &amp;&amp;) -&gt; range of regex_result;

// return parts of the input splited by the regex, returning it as part of content of the implicit zero capture (other captures are not changed, you can use it to access how the values were splitted):
template &lt;fixed_string regex&gt; auto ctre::split(auto Range &amp;&amp;) -&gt; regex_result;
template &lt;fixed_string regex&gt; auto ctre::split(auto First &amp;&amp;, auto Last &amp;&amp;) -&gt; range of regex_result;"><pre><span><span>//</span> search for regex in input and return each occurence, ignoring rest:</span>
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::range</span>(<span>auto</span> Range &amp;&amp;) -&gt; range of regex_result;
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::range</span>(<span>auto</span> First &amp;&amp;, <span>auto</span> Last &amp;&amp;) -&gt; range of regex_result;

<span><span>//</span> return range of each match, stopping at something which can&#39;t be matched</span>
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::tokenize</span>(<span>auto</span> Range &amp;&amp;) -&gt; range of regex_result;
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::tokenize</span>(<span>auto</span> First &amp;&amp;, <span>auto</span> Last &amp;&amp;) -&gt; range of regex_result;

<span><span>//</span> return parts of the input splited by the regex, returning it as part of content of the implicit zero capture (other captures are not changed, you can use it to access how the values were splitted):</span>
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::split</span>(<span>auto</span> Range &amp;&amp;) -&gt; regex_result;
<span>template </span>&lt;fixed_string regex&gt; <span>auto</span> <span>ctre::split</span>(<span>auto</span> First &amp;&amp;, <span>auto</span> Last &amp;&amp;) -&gt; range of regex_result;</pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-functors" aria-hidden="true" tabindex="-1" href="#functors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Functors</h3>
<p dir="auto">All the functions (<code>ctre::match</code>, <code>ctre::search</code>, <code>ctre::starts_with</code>, <code>ctre::range</code>, <code>ctre::tokenize</code>, <code>ctre::split</code>) are functors and can be used without parenthesis:</p>
<div dir="auto" data-snippet-clipboard-copy-content="auto matcher = ctre::match&lt;&#34;regex&#34;&gt;;
if (matcher(input)) ..."><pre><span>auto</span> matcher = ctre::match&lt;<span><span>&#34;</span>regex<span>&#34;</span></span>&gt;;
<span>if</span> (matcher(input)) ...</pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-possible-subjects-inputs" aria-hidden="true" tabindex="-1" href="#possible-subjects-inputs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Possible subjects (inputs)</h3>
<ul dir="auto">
<li><code>std::string</code>-like objects (<code>std::string_view</code> or your own string if it&#39;s providing <code>begin</code>/<code>end</code> functions with forward iterators)</li>
<li>pairs of forward iterators</li>
</ul>
<h3 tabindex="-1" dir="auto"><a id="user-content-unicode-support" aria-hidden="true" tabindex="-1" href="#unicode-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Unicode support</h3>
<p dir="auto">To enable you need to include:</p>
<ul dir="auto">
<li><code>&lt;ctre-unicode.hpp&gt;</code></li>
<li>or <code>&lt;ctre.hpp&gt;</code> and <code>&lt;unicode-db.hpp&gt;</code></li>
</ul>
<p dir="auto">Otherwise you will get missing symbols if you try to use the unicode support without enabling it.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-supported-compilers" aria-hidden="true" tabindex="-1" href="#supported-compilers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Supported compilers</h2>
<ul dir="auto">
<li>clang 7.0+ (template UDL, C++17 syntax)</li>
<li>xcode clang 10.0+ (template UDL, C++17 syntax)</li>
<li>clang 12.0+ (C++17 syntax, C++20 cNTTP syntax)</li>
<li>gcc 8.0+ (template UDL, C++17 syntax)</li>
<li>gcc 9.0+ (C++17 &amp; C++20 cNTTP syntax)</li>
<li>MSVC 14.29+ (Visual Studio 16.11+) (C++20)</li>
</ul>
<h3 tabindex="-1" dir="auto"><a id="user-content-template-udl-syntax" aria-hidden="true" tabindex="-1" href="#template-udl-syntax"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Template UDL syntax</h3>
<p dir="auto">The compiler must support extension N3599, for example as GNU extension in gcc (not in GCC 9.1+) and clang.</p>
<div dir="auto" data-snippet-clipboard-copy-content="constexpr auto match(std::string_view sv) noexcept {
    using namespace ctre::literals;
    return &#34;h.*&#34;_ctre.match(sv);
}"><pre><span>constexpr</span> <span>auto</span> <span>match</span>(std::string_view sv) <span>noexcept</span> {
    <span>using</span> <span>namespace</span> <span>ctre</span>::literals<span>;</span>
    <span>return</span> <span><span>&#34;</span>h.*<span>&#34;</span></span>_ctre.<span>match</span>(sv);
}</pre></div>
<p dir="auto">If you need extension N3599 in GCC 9.1+, you can&#39;t use -pedantic. Also, you need to define macro <code>CTRE_ENABLE_LITERALS</code>.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-c17-syntax" aria-hidden="true" tabindex="-1" href="#c17-syntax"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>C++17 syntax</h3>
<p dir="auto">You can provide a pattern as a <code>constexpr ctll::fixed_string</code> variable.</p>
<div dir="auto" data-snippet-clipboard-copy-content="static constexpr auto pattern = ctll::fixed_string{ &#34;h.*&#34; };

constexpr auto match(std::string_view sv) noexcept {
    return ctre::match&lt;pattern&gt;(sv);
}"><pre><span>static</span> <span>constexpr</span> <span>auto</span> pattern = ctll::fixed_string{ <span><span>&#34;</span>h.*<span>&#34;</span></span> };

<span>constexpr</span> <span>auto</span> <span>match</span>(std::string_view sv) <span>noexcept</span> {
    <span>return</span> ctre::match&lt;pattern&gt;(sv);
}</pre></div>
<p dir="auto">(this is tested in MSVC 15.8.8)</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-c20-syntax" aria-hidden="true" tabindex="-1" href="#c20-syntax"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>C++20 syntax</h3>
<p dir="auto">Currently, the only compiler which supports cNTTP syntax <code>ctre::match&lt;PATTERN&gt;(subject)</code> is GCC 9+.</p>
<div dir="auto" data-snippet-clipboard-copy-content="constexpr auto match(std::string_view sv) noexcept {
    return ctre::match&lt;&#34;h.*&#34;&gt;(sv);
}"><pre><span>constexpr</span> <span>auto</span> <span>match</span>(std::string_view sv) <span>noexcept</span> {
    <span>return</span> ctre::match&lt;<span><span>&#34;</span>h.*<span>&#34;</span></span>&gt;(sv);
}</pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-examples" aria-hidden="true" tabindex="-1" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<h3 tabindex="-1" dir="auto"><a id="user-content-extracting-number-from-input" aria-hidden="true" tabindex="-1" href="#extracting-number-from-input"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Extracting number from input</h3>
<div dir="auto" data-snippet-clipboard-copy-content="std::optional&lt;std::string_view&gt; extract_number(std::string_view s) noexcept {
    if (auto m = ctre::match&lt;&#34;[a-z]+([0-9]+)&#34;&gt;(s)) {
        return m.get&lt;1&gt;().to_view();
    } else {
        return std::nullopt;
    }
}"><pre>std::optional&lt;std::string_view&gt; <span>extract_number</span>(std::string_view s) <span>noexcept</span> {
    <span>if</span> (<span>auto</span> m = ctre::match&lt;<span><span>&#34;</span>[a-z]+([0-9]+)<span>&#34;</span></span>&gt;(s)) {
        <span>return</span> m.<span>get</span>&lt;<span>1</span>&gt;().<span>to_view</span>();
    } <span>else</span> {
        <span>return</span> std::nullopt;
    }
}</pre></div>
<p dir="auto"><a href="https://gcc.godbolt.org/z/5U67_e" rel="nofollow">link to compiler explorer</a></p>
<h3 tabindex="-1" dir="auto"><a id="user-content-extracting-values-from-date" aria-hidden="true" tabindex="-1" href="#extracting-values-from-date"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Extracting values from date</h3>
<div dir="auto" data-snippet-clipboard-copy-content="struct date { std::string_view year; std::string_view month; std::string_view day; };

std::optional&lt;date&gt; extract_date(std::string_view s) noexcept {
    using namespace ctre::literals;
    if (auto [whole, year, month, day] = ctre::match&lt;&#34;(\\d{4})/(\\d{1,2})/(\\d{1,2})&#34;&gt;(s); whole) {
        return date{year, month, day};
    } else {
        return std::nullopt;
    }
}

//static_assert(extract_date(&#34;2018/08/27&#34;sv).has_value());
//static_assert((*extract_date(&#34;2018/08/27&#34;sv)).year == &#34;2018&#34;sv);
//static_assert((*extract_date(&#34;2018/08/27&#34;sv)).month == &#34;08&#34;sv);
//static_assert((*extract_date(&#34;2018/08/27&#34;sv)).day == &#34;27&#34;sv);"><pre><span>struct</span> <span>date</span> { std::string_view year; std::string_view month; std::string_view day; };

std::optional&lt;date&gt; <span>extract_date</span>(std::string_view s) <span>noexcept</span> {
    <span>using</span> <span>namespace</span> <span>ctre</span>::literals<span>;</span>
    <span>if</span> (<span>auto</span> [whole, year, month, day] = ctre::match&lt;<span><span>&#34;</span>(<span>\\</span>d{4})/(<span>\\</span>d{1,2})/(<span>\\</span>d{1,2})<span>&#34;</span></span>&gt;(s); whole) {
        <span>return</span> date{year, month, day};
    } <span>else</span> {
        <span>return</span> std::nullopt;
    }
}

<span><span>//</span>static_assert(extract_date(&#34;2018/08/27&#34;sv).has_value());</span>
<span><span>//</span>static_assert((*extract_date(&#34;2018/08/27&#34;sv)).year == &#34;2018&#34;sv);</span>
<span><span>//</span>static_assert((*extract_date(&#34;2018/08/27&#34;sv)).month == &#34;08&#34;sv);</span>
<span><span>//</span>static_assert((*extract_date(&#34;2018/08/27&#34;sv)).day == &#34;27&#34;sv);</span></pre></div>
<p dir="auto"><a href="https://gcc.godbolt.org/z/x64CVp" rel="nofollow">link to compiler explorer</a></p>
<h3 tabindex="-1" dir="auto"><a id="user-content-using-captures" aria-hidden="true" tabindex="-1" href="#using-captures"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using captures</h3>
<div dir="auto" data-snippet-clipboard-copy-content="auto result = ctre::match&lt;&#34;(?&lt;year&gt;\\d{4})/(?&lt;month&gt;\\d{1,2})/(?&lt;day&gt;\\d{1,2})&#34;&gt;(s);
return date{result.get&lt;&#34;year&#34;&gt;(), result.get&lt;&#34;month&#34;&gt;, result.get&lt;&#34;day&#34;&gt;};

// or in C++ emulation, but the object must have a linkage
static constexpr ctll::fixed_string year = &#34;year&#34;;
static constexpr ctll::fixed_string month = &#34;month&#34;;
static constexpr ctll::fixed_string day = &#34;day&#34;;
return date{result.get&lt;year&gt;(), result.get&lt;month&gt;, result.get&lt;day&gt;};

// or use numbered access
// capture 0 is the whole match
return date{result.get&lt;1&gt;(), result.get&lt;2&gt;, result.get&lt;3&gt;};"><pre><span>auto</span> result = ctre::match&lt;<span><span>&#34;</span>(?&lt;year&gt;<span>\\</span>d{4})/(?&lt;month&gt;<span>\\</span>d{1,2})/(?&lt;day&gt;<span>\\</span>d{1,2})<span>&#34;</span></span>&gt;(s);
<span>return</span> date{result.<span>get</span>&lt;<span><span>&#34;</span>year<span>&#34;</span></span>&gt;(), result.<span>get</span>&lt;<span><span>&#34;</span>month<span>&#34;</span></span>&gt;, result.<span>get</span>&lt;<span><span>&#34;</span>day<span>&#34;</span></span>&gt;};

<span><span>//</span> or in C++ emulation, but the object must have a linkage</span>
<span>static</span> <span>constexpr</span> ctll::fixed_string year = <span><span>&#34;</span>year<span>&#34;</span></span>;
<span>static</span> <span>constexpr</span> ctll::fixed_string month = <span><span>&#34;</span>month<span>&#34;</span></span>;
<span>static</span> <span>constexpr</span> ctll::fixed_string day = <span><span>&#34;</span>day<span>&#34;</span></span>;
<span>return</span> date{result.<span>get</span>&lt;year&gt;(), result.<span>get</span>&lt;month&gt;, result.<span>get</span>&lt;day&gt;};

<span><span>//</span> or use numbered access</span>
<span><span>//</span> capture 0 is the whole match</span>
<span>return</span> date{result.<span>get</span>&lt;<span>1</span>&gt;(), result.<span>get</span>&lt;<span>2</span>&gt;, result.<span>get</span>&lt;<span>3</span>&gt;};</pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-lexer" aria-hidden="true" tabindex="-1" href="#lexer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Lexer</h3>
<div dir="auto" data-snippet-clipboard-copy-content="enum class type {
    unknown, identifier, number
};

struct lex_item {
    type t;
    std::string_view c;
};

std::optional&lt;lex_item&gt; lexer(std::string_view v) noexcept {
    if (auto [m,id,num] = ctre::match&lt;&#34;([a-z]+)|([0-9]+)&#34;&gt;(v); m) {
        if (id) {
            return lex_item{type::identifier, id};
        } else if (num) {
            return lex_item{type::number, num};
        }
    }
    return std::nullopt;
}"><pre><span>enum</span> <span>class</span> <span>type</span> {
    unknown, identifier, number
};

<span>struct</span> <span>lex_item</span> {
    type t;
    std::string_view c;
};

std::optional&lt;lex_item&gt; <span>lexer</span>(std::string_view v) <span>noexcept</span> {
    <span>if</span> (<span>auto</span> [m,id,num] = ctre::match&lt;<span><span>&#34;</span>([a-z]+)|([0-9]+)<span>&#34;</span></span>&gt;(v); m) {
        <span>if</span> (id) {
            <span>return</span> lex_item{type::identifier, id};
        } <span>else</span> <span>if</span> (num) {
            <span>return</span> lex_item{type::number, num};
        }
    }
    <span>return</span> std::nullopt;
}</pre></div>
<p dir="auto"><a href="https://gcc.godbolt.org/z/PKTiCC" rel="nofollow">link to compiler explorer</a></p>
<h3 tabindex="-1" dir="auto"><a id="user-content-range-over-input" aria-hidden="true" tabindex="-1" href="#range-over-input"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Range over input</h3>
<p dir="auto">This support is preliminary, probably the API will be changed.</p>
<div dir="auto" data-snippet-clipboard-copy-content="auto input = &#34;123,456,768&#34;sv;

for (auto match: ctre::range&lt;&#34;([0-9]+),?&#34;&gt;(input)) {
    std::cout &lt;&lt; std::string_view{match.get&lt;0&gt;()} &lt;&lt; &#34;\n&#34;;
}"><pre><span>auto</span> input = <span><span>&#34;</span>123,456,768<span>&#34;</span></span>sv;

<span>for</span> (<span>auto</span> match: ctre::range&lt;<span><span>&#34;</span>([0-9]+),?<span>&#34;</span></span>&gt;(input)) {
    std::cout &lt;&lt; std::string_view{match.<span>get</span>&lt;<span>0</span>&gt;()} &lt;&lt; <span><span>&#34;</span><span>\n</span><span>&#34;</span></span>;
}</pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-unicode" aria-hidden="true" tabindex="-1" href="#unicode"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Unicode</h3>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;ctre-unicode.hpp&gt;
#include &lt;iostream&gt;
// needed if you want to output to the terminal
std::string_view cast_from_unicode(std::u8string_view input) noexcept {
    return std::string_view(reinterpret_cast&lt;const char *&gt;(input.data()), input.size());
}
int main()
{
    using namespace std::literals;
    std::u8string_view original = u8&#34;Tu es un génie&#34;sv;

    for (auto match : ctre::range&lt;&#34;\\p{Letter}+&#34;&gt;(original))
        std::cout &lt;&lt; cast_from_unicode(match) &lt;&lt; std::endl;
    return 0;
}"><pre>#<span>include</span> <span><span>&lt;</span>ctre-unicode.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>iostream<span>&gt;</span></span>
<span><span>//</span> needed if you want to output to the terminal</span>
std::string_view <span>cast_from_unicode</span>(std::u8string_view input) <span>noexcept</span> {
    <span>return</span> <span>std::string_view</span>(<span>reinterpret_cast</span>&lt;<span>const</span> <span>char</span> *&gt;(input.<span>data</span>()), input.<span>size</span>());
}
<span>int</span> <span>main</span>()
{
    <span>using</span> <span>namespace</span> <span>std</span>::literals<span>;</span>
    std::u8string_view original = <span><span>u8&#34;</span>Tu es un génie<span>&#34;</span></span>sv;

    <span>for</span> (<span>auto</span> match : ctre::range&lt;<span><span>&#34;</span><span>\\</span>p{Letter}+<span>&#34;</span></span>&gt;(original))
        std::cout &lt;&lt; <span>cast_from_unicode</span>(match) &lt;&lt; std::endl;
    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto"><a href="https://godbolt.org/z/erTshe6sz" rel="nofollow">link to compiler explorer</a></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-installing-ctre-using-vcpkg" aria-hidden="true" tabindex="-1" href="#installing-ctre-using-vcpkg"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installing ctre using vcpkg</h2>
<p dir="auto">You can download and install ctre using the <a href="https://github.com/Microsoft/vcpkg">vcpkg</a> dependency manager:</p>
<div dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.sh
./vcpkg integrate install
./vcpkg install ctre"><pre>git clone https://github.com/Microsoft/vcpkg.git
<span>cd</span> vcpkg
./bootstrap-vcpkg.sh
./vcpkg integrate install
./vcpkg install ctre</pre></div>
<p dir="auto">The ctre port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please <a href="https://github.com/Microsoft/vcpkg">create an issue or pull request</a> on the vcpkg repository.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-running-tests-for-developers" aria-hidden="true" tabindex="-1" href="#running-tests-for-developers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Running tests (for developers)</h2>
<p dir="auto">Just run <code>make</code> in root of this project.</p>
</article>
          </div></div>
  </body>
</html>
