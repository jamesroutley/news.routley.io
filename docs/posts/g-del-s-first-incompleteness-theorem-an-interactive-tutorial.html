<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigyog.app/d/H7XOvXvC_x/r/goedel-s-first-incompleteness-theorem">Original</a>
    <h1>Gödel’s first incompleteness theorem – an interactive tutorial</h1>
    
    <div id="readability-page-1" class="page"><div><p aria-hidden="false"><h2>An interactive tutorial</h2></p><p>Back in 1936, Kurt Gödel published his first mathematical mic-drop: “Our formal systems of logic can make statements that they can neither prove nor disprove.” In this chapter, you’ll learn what this famous theorem means, and you’ll learn a proof of it that builds upon Turing’s solution to the Halting Problem.</p><p aria-hidden="true"><h2>What is a formal system? 🤵</h2></p><p>Gödel’s theorem is about “formal systems”, but what are they? The standard examples on Wikipedia have weird names like “Zermelo–Fraenkel set theory with the axiom of choice”, and they use fancy math symbols like “<span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>∃</span><span>x</span><span>,</span><span></span><span>y</span><span></span><span>∈</span><span></span></span><span><span></span><span>N</span></span></span></span></span></span>”. You’d be forgiven for thinking ‘formality’ means black tie.</p><p>Yes, because we’ll instead illustrate the theorem with a dirty, concrete formal system: <a href="https://leanprover.github.io/" target="_blank"><b>the Lean proof assistant</b></a>, a program made by Microsoft Research.</p><p>Suppose we wanted to say that “for all natural numbers <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span></span></span>, <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>0</span><span></span><span>+</span><span></span></span><span><span></span><span>n</span><span></span><span>=</span><span></span></span><span><span></span><span>n</span></span></span></span></span></span>”. In Lean, we could write this as</p><p>You don’t need to understand the syntax precisely. Just scan over it and notice the <code>0 + n = n</code>. Now, we could also use Lean to state that “there exists a natural number <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span></span></span>, such that <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>n</span><span></span><span>=</span><span></span></span><span><span></span><span>n</span><span></span><span>+</span><span></span></span><span><span></span><span>1</span></span></span></span></span></span>”. What do you think of this?</p><p>So, we need some way to distinguish true statements from false statements! Mathematicians do this using <b>proofs.</b> In Lean, we can prove our first statement with these magic words:</p><p>Don’t sweat the details here! You just need to know that if we run the <code>lean</code> program on this file, it derives the statement that <code>(n : nat) : 0 + n = n</code>. We can imagine <code>lean</code> as a function that takes a proof string, and either returns <code>null</code> (meaning the proof string is nonsense), or returns the statement string that it proves. Examples:</p><p>(Note that <code>lean</code> will always halt with either <code>null</code> or a theorem. It just runs the finite list of commands in the proof; it cannot loop forever.)</p><p>Now let’s see what makes Lean a ‘formal system.’ A formal system has three things:</p><p>1. A language to make <b>statements. </b>In Lean, those are things like <code>(n : nat) : 0 + n = n</code>.</p><p>2. A language to make <b>proofs.</b> In Lean, those are things like <code>lemma zero_add ... end</code>, which we saw earlier.</p><p>3. A way to interpret a proof string as a way to generate a proved statement, which we call a <b>theorem.</b> In the Lean formal system, that’s the program <code>lean</code>.</p><p aria-hidden="true"><h2>Enumerating theorems ... 🔢</h2></p><p>So now the computer can help check our proofs. But <i>finding</i> theorems is still hard work! Can’t we get the computer to prove everything for us? How might we do that?</p><p>Here’s an idea ... just list out all the possible strings! Every Lean theorem is just a string, so it must be somewhere in the list of all possible strings! Here’s how we can list all strings, in order of increasing length, using a JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank">generator</a>:</p><p>This generates strings in length order, shortest first: all 0-char strings, then all 1-char strings, then all 2-char strings, and so on. The list looks like this:</p><p>Will the string <code>&#34;(n : nat) : 0 + n = n&#34;</code> appear in this list?</p><p>But now we have a problem. For each string in the list, we want to ask whether it’s a theorem. Can we do that by passing it to the <code>lean</code> program?</p><p>The <code>lean</code> program cannot tell us whether a statement is a theorem, because it does not accept <i>statements</i> as input. It accepts <i>proofs</i> as inputs! So instead, we will iterate through all strings, and try to interpret each string as a <i>proof</i>:</p><p>This procedure <code>theorems()</code> goes through every possible string, and for each, calls <code>lean</code> on it. If <code>lean</code> says the string is a valid proof, it outputs the theorem that it proves.</p><p aria-hidden="true"><h2>Does <code>theorems()</code> do what it says on the tin? 🥫</h2></p><p>Before we get too excited, let’s distinguish two things:</p><p>• The set of strings outputted by <code>theorems()</code></p><p>• The set of strings that are Lean theorems</p><p>Are these the same sets? Let’s check. First, consider the earlier Lean statement, <code>(n : nat) : 0 + n = n</code>. Will this statement eventually be found by <code>theorems()</code>?</p><p>Next, consider some string <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span></span></span> outputted by <code>theorems()</code>. Is it possible that <span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span></span></span> is <i>not </i>a Lean theorem? Read the source of <code>theorems()</code> to check.</p><p>So, we’ve found that <code>theorems()</code> is indeed one and the same as the set of all theorems! Although, here’s one wrinkle ... let’s say we wait around until the theorem  <code>(n : nat) : 0 + n = n</code> is outputted by <code>theorems()</code>. After that, is it possible that that same theorem could be outputted again?</p><p>A theorem will be outputted once for every possible proof of that theorem. But this turns out to unimportant; we can just de-duplicate these outputs.</p><p>Well ... the computer can generate all the Lean theorems. And that’s really cool! In fact, let’s take a moment to see just how cool it is ...</p><p aria-hidden="true"><h2>Statements about programs! 👩‍💻</h2></p><p>Statements like “<span><span translate="no"><span><span aria-hidden="true"><span><span></span><span>x</span><span></span><span>+</span><span></span></span><span><span></span><span>0</span><span></span><span>=</span><span></span></span><span><span></span><span>x</span></span></span></span></span></span>” seem a bit dull. Is Lean limited to arithmetic, or can it tackle more interesting math? In <a href="https://tigyog.app/d/fr9uub3hqgab/r/the-halting-problem">the previous chapter</a>, we learned about the halting problem. That topic is surely mathematics! So can we ‘formalize’ it in Lean?</p><p> If you run <code>theorems()</code>, will it discover this theorem?</p><p>And not only that: <code>theorems()</code> will find the shortest proof. Perhaps it’s much more elegant than the one we humans found. So, <code>theorems()</code> really is amazing! Let’s try it out, and see if we can win ourselves a mathematical prize!</p><p aria-hidden="true"><h2>Theorem mining — better than crypto?</h2></p><p>Instead of just listing out <i>all</i> theorems, let’s say we’re just interested in one particular mathematical claim, and we want to know whether it’s true. Consider the following famous function:</p><p>Try it out! Does <code>collatz(3)</code> halt?</p><p>Okay, now what about for any starting number? In 1937, <a href="https://en.wikipedia.org/wiki/Lothar_Collatz" target="_blank">Herr Collatz</a> himself conjectured: “<code>collatz(n)</code> always halts, for every natural number <code>n</code>.” What do you think of this claim?</p><p>There’s <a href="https://mathprize.net/posts/collatz-conjecture/" target="_blank">a $1M prize</a> for proving the truth or non-truth of this famous conjecture. So let’s deploy our amazing function <code>theorems()</code> to earn some easy money! Here’s a first draft:</p><p>Here’s how it should work: if the conjecture is true, <code>is_collatz_true</code> should return <code>true</code>, and if the conjecture is false, <code>is_collatz_true</code> should return <code>false</code>.</p><p>Now, imagine that the Collatz conjecture is false. Read the source: what does <code>is_collatz_true</code> do in this case?</p><p>The problem is that we never actually search for a proof that the conjecture is false; we only search for a proof that it’s true!</p><p>In Lean, the word ‘not’ is written as <code>¬</code>. So the inverse of the conjecture is <code>¬coll_conj</code>. So let’s just add that to our search!</p><p>This is looking better! We have an amazing function, <code>is_statement_true</code>, that can tell us whether anything is true or false, given enough time!</p><p>Read it through, and try to prove to yourself that <code>is_collatz_true</code> really does eventually return the truth of the Collatz conjecture.</p><p>Eventually, I think you’ll realize the algorithm relies on this assumption:  “<code>theorems()</code> contains <b>either</b> <code>coll_conj</code> <b>or</b> <code>¬coll_conj</code>. It does not contain both, or neither.”</p><p>This assumption is quite natural. We’ve already accepted that the Collatz conjecture is either true or false. So, similarly, <code>theorems()</code> should contain either <code>coll_conj</code> or <code>¬coll_conj</code>. This gets to the heart of what Godel wanted to prove.</p><p aria-hidden="true"><h2>Consistency 👎👍</h2></p><p>But what if <code>theorems()</code> contains <i>both</i> <code>coll_conj</code> <i>and</i> <code>¬coll_conj</code>? Is that possible?</p><p>This property is known as <b>consistency.</b> Lean is ‘consistent’ if there are no statements <code>S</code> where both <code>S</code> and <code>¬S</code> are theorems.</p><p>Recall the ‘proof by contradiction’ method that we used in Chapter 1 to prove Turing’s theorem. The idea is that, if an assumption leads to a contradiction, the assumption must be false. The Lean system lets you use this proof method to generate theorems.</p><p>Now, imagine that both <code>coll_conj</code> and <code>¬coll_conj</code> are both theorems. Could we prove that <code>1+1=3</code> in Lean?</p><p>Worse, we could use this method to prove <i>anything</i> in Lean! So, inconsistency would be <b>disastrous. </b>Mathematicians generally assume that their systems are consistent. (But it turns out to be rather hard to show it! We’ll see why in a future chapter!)</p><p aria-hidden="true"><h2>Completeness</h2></p><p>This leaves one final possibility. What if <code>theorems()</code> contains <i>neither</i> <code>coll_conj</code> <i>nor</i> <code>¬coll_conj</code>? How disastrous would that be? Could you use that to prove that <code>1+1=3</code> in Lean?</p><p>In general, the absence of a proof doesn’t lead to a complete collapse. It would just mean that Lean is not powerful enough to comment on the truth of the statement.</p><p>However, it would still be extremely nice if Lean were able to say, one way or another, whether the Collatz conjecture is true. And it would be even nicer if Lean were able to say, one way or the other, whether <i>any</i> statement is true.</p><p>If this were the case, we would say that Lean is <b>complete.</b> Precisely: if Lean is complete, then we can make any statement <code>S</code>, and either <code>S</code> or <code>¬S</code> is in <code>theorems()</code>.</p><p>So, earlier when we tried to prove that <code>is_statement_true</code> is a correct algorithm, we relied on the assumption that Lean is both consistent and complete.</p><p aria-hidden="true"><h2>A proof using Turing’s theorem</h2></p><p>So, is Lean consistent and complete? Here’s Gödel’s famous answer: <b>No, Lean is either inconsistent or incomplete!</b></p><p>Our proof works by way of contradiction. The assumption: <i>Lean is consistent and complete</i>. We decided earlier that, if this is true, then our <code>is_statement_true</code> function works perfectly.</p><p>Now, recall the Halting Problem from Chapter 1. This problem asks for a function <code>halts(tm)</code> that returns <code>true</code> or <code>false</code> telling us whether the Turing Machine <code>tm</code> halts. With our <code>is_statement_true</code> function, we can easily solve the Halting Problem!:</p><p>We saw earlier that Lean can talk about whether Turing Machines halt. So we can construct a Lean statement claiming that the Turing Machine <code>tm</code> halts. Then we just ... ask whether that statement is true!</p><p>Yes! We also learned in Chapter 1 that the Halting Problem is impossible to solve! So we got a contradiction!</p><p>The problem must be our initial assumption, that “Lean is consistent and complete.” We can therefore conclude that <b>Lean is either inconsistent or incomplete!</b></p><p aria-hidden="true"><h2>What about other formal systems?</h2></p><p>In this chapter, we applied this reasoning to Lean, one specific formal system. But the same reasoning can be applied to any formal system F, with fairly minimal assumptions:</p><p>1. F is enumerable. (This comes for free via the <code>theorems</code> trick.)</p><p>2. We can reason about programs and halting in F.</p><p>Gödel’s original proof was slightly stronger: it only required that F can reason about arithmetic, rather than programs and halting. But it turns out that pretty much any formal system can reason about programs — we’ll learn how easily in a future chapter!</p><p aria-hidden="true"><h2>Conclusion</h2></p><p>You might be wondering ... Okay, perhaps we can’t show that our systems of logic are complete, but perhaps we can at least show that they are consistent. But Gödel has some more bad news for you, coming up in the next chapter ...</p><p><b>If you want to know when the next chapter comes out, </b><a href="https://tigyog.app/d/C:tWWwvJDWlo/enrollment"><b>sign up for updates here!</b></a><b> You might also enjoy our course </b><a href="https://tigyog.app/d/C-I1weB9CpTH/r/everyday-data-science"><i><b>Everyday Data Science</b></i></a><b>, which teaches fundamental data science using the same interactive format.</b></p></div></div>
  </body>
</html>
