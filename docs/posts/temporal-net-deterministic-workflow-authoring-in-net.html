<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://temporal.io/blog/introducing-temporal-dotnet">Original</a>
    <h1>Temporal .NET ‚Äì Deterministic Workflow Authoring in .NET</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><img src="https://images.ctfassets.net/0uuz8ydxyd9p/1q9LnWFadl5QKUKH7S3qmd/59c200248a827f27cff2aad16abe4165/dotnet.png" alt="dotnet-banner"/></p>
<p>A Temporal workflow is code that is executed in a durable, reliable, and scalable way. Today Temporal allows you to
write workflows in Go, Java, Python, TypeScript, and more. You can now add .NET to that list with the new alpha release
of the .NET SDK. While this post will focus on C#, any .NET language will work.</p>
<p>Different language runtimes have different trade-offs for writing workflows. Go is very fast and resource efficient due
to runtime-supported coroutines, but that comes at the expense of type safety (even generics as implemented in Go are
limited for this use). Java is also very fast and type safe, but a bit less resource efficient due to the lack of
runtime-supported coroutines (but virtual threads are coming). It might sound weird to say, but our dynamic languages of
JS/TypeScript and Python are probably the most type-safe SDKs when used properly; however, as can be expected, they are
not the most resource efficient. .NET provides the best of all worlds: high performance like Go/Java, good resource
utilization like Go, and high quality type-safe APIs.</p>
<p>This post will give a high-level overview of the .NET SDK and some interesting challenges encountered during its
development. To get more info about the SDK, see:</p>
<ul>
<li><a href="https://github.com/temporalio/sdk-dotnet">GitHub Repository</a> ‚Äì The README here provides the most comprehensive docs
for .NET at the moment</li>
<li><a href="https://www.nuget.org/packages/Temporalio">NuGet Package</a></li>
<li><a href="https://docs.temporal.io">Temporal Documentation</a> ‚Äì Contains general-purpose Temporal documentation with
.NET-specific content coming soon</li>
<li><a href="https://dotnet.temporal.io">API Documentation</a></li>
<li><a href="https://github.com/temporalio/samples-dotnet">Samples</a></li>
</ul>
<p><strong>‚ö†Ô∏èWarning</strong> ‚Äì As of this writing the .NET SDK is still in alpha, so APIs are subject to change. However the SDK is
feature complete, so beta and GA are coming soon. We really need user feedback to get to those stages. Please give us
positive or negative feedback in <code node="[object Object]">#dotnet-sdk</code> on <a href="https://t.mp/slack">Slack</a> or on
<a href="https://community.temporal.io/tag/dotnet-sdk">the forums</a>. Any feedback helps!</p>
<p><strong>Contents:</strong></p>
<ul>
<li><a href="#introduction-to-temporal-with-c">Introduction to Temporal with C#</a>
<ul>
<li><a href="#implementing-an-activity">Implementing an Activity</a></li>
<li><a href="#implementing-a-workflow">Implementing a Workflow</a></li>
<li><a href="#running-a-worker">Running a Worker</a></li>
<li><a href="#executing-a-workflow">Executing a Workflow</a></li>
</ul>
</li>
<li><a href="#why-the-ref-pattern">Why the &#39;Ref&#39; Pattern?</a>
<ul>
<li><a href="#what-problem-does-ref-solve">What Problem Does &#39;Ref&#39; Solve?</a></li>
<li><a href="#how-does-ref-work">How Does &#39;Ref&#39; Work?</a></li>
<li><a href="#what-other-solutions-exist">What Other Solutions Exist?</a></li>
</ul>
</li>
<li><a href="#how-it-works--workflow-determinism">How It Works ‚Äì Workflow Determinism</a></li>
<li><a href="#future-of-the-net-sdk">Future of the .NET SDK</a></li>
</ul>
<h2 id="introduction-to-temporal-with-c">Introduction to Temporal with C#</h2>
<p>To give a quick walkthrough of Temporal .NET, we&#39;ll implement a simplified form of one-click buying in C# where a
purchase is started and then, unless cancelled, will be performed in 10 seconds.</p>
<h3 id="implementing-an-activity">Implementing an Activity</h3>
<p>Activities are the only way to interact with external resources in Temporal, such as making an HTTP request or accessing
the file system. In .NET, all activities are just delegates which are usually just methods with the <code node="[object Object]">[Activity]</code>
attribute. Here&#39;s an activity that performs a purchase:</p>
<p><code node="[object Object]"><div><pre><code>namespace MyNamespace;

using System.Net;
using System.Net.Http;
using System.Net.Http.Json;
using Temporalio.Activities;
using Temporalio.Exceptions;

public record Purchase(string ItemID, string UserID);

public class PurchaseActivities
{
    // See &#34;Why the &#39;Ref&#39; Pattern&#34; below for an explanation of this
    public static readonly PurchaseActivities Ref = ActivityRefs.Create&lt;PurchaseActivities&gt;();

    private readonly HttpClient client = new();

    [Activity]
    public async Task DoPurchaseAsync(Purchase purchase)
    {
        using var resp = await client.PostAsJsonAsync(
          &#34;https://api.example.com/purchase&#34;,
          purchase,
          ActivityExecutionContext.Current.CancellationToken);

        // Make sure we succeeded
        try
        {
            resp.EnsureSuccessStatusCode();
        }
        catch (HttpRequestException e) when (resp.StatusCode &lt; HttpStatusCode.InternalServerError)
        {
            // We don&#39;t want to retry 4xx status codes, only 5xx status codes
            throw new ApplicationFailureException(&#34;API returned error&#34;, e, nonRetryable: true);
        }
    }
}
</code></pre></div></code></p><p>This activity makes an HTTP call and takes care not to retry some types of HTTP errors. Note the <code node="[object Object]">Ref</code> property at the
top. This is used for activity callers to be able to reference methods. See the <a href="#why-the-ref-pattern">Why the &#39;Ref&#39; Pattern</a> section below.
If we used a static method we would not need this.</p>
<h3 id="implementing-a-workflow">Implementing a Workflow</h3>
<p>Now that we have an activity, we can implement our workflow:</p>
<p><code node="[object Object]"><div><pre><code>namespace MyNamespace;

using Temporalio.Workflows;

public enum PurchaseStatus
{
    Pending,
    Confirmed,
    Cancelled,
    Completed
}

[Workflow]
public class OneClickBuyWorkflow
{
    // See &#34;Why the &#39;Ref&#39; Pattern&#34; below for an explanation of this
    public static readonly OneClickBuyWorkflow Ref = WorkflowRefs.Create&lt;OneClickBuyWorkflow&gt;();

    private PurchaseStatus currentStatus = PurchaseStatus.Pending;
    private Purchase? currentPurchase;

    [WorkflowRun]
    public async Task&lt;PurchaseStatus&gt; RunAsync(Purchase purchase)
    {
        currentPurchase = purchase;

        // Give user 10 seconds to cancel or update before we send it through
        try
        {
            await Workflow.DelayAsync(TimeSpan.FromSeconds(10));
        }
        catch (TaskCanceledException)
        {
            currentStatus = PurchaseStatus.Cancelled;
            return currentStatus;
        }

        // Update the status, perform the purchase, update the status again
        currentStatus = PurchaseStatus.Confirmed;
        await Workflow.ExecuteActivityAsync(
            PurchaseActivities.Ref.DoPurchaseAsync,
            currentPurchase!,
            new() { ScheduleToCloseTimeout = TimeSpan.FromMinutes(2) });
        currentStatus = PurchaseStatus.Completed;
        return currentStatus;
    }

    [WorkflowSignal]
    public async Task UpdatePurchaseAsync(Purchase purchase) =&gt; currentPurchase = purchase;

    [WorkflowQuery]
    public PurchaseStatus CurrentStatus() =&gt; currentStatus;
}
</code></pre></div></code></p><p>Workflows must be deterministic, and we use a custom task scheduler (explained <a href="#how-it-works--workflow-determinism">later</a> in this post). Also note that this
has the same type of <code node="[object Object]">Ref</code> property as the activity for the same reasons.</p>
<p>Notice the <code node="[object Object]">Workflow.DelayAsync</code> call there? That is a durable Temporal timer. When a cancellation token is not provided
to it, it defaults to <code node="[object Object]">Workflow.CancellationToken</code> so that cancelling the workflow implicitly cancels the tasks being
awaited. Workflows must use Temporal-defined timing and scheduling, so something like <code node="[object Object]">Task.DelayAsync</code> cannot be used.
See the <a href="#how-it-works--workflow-determinism">Workflow Determinism</a> section below for more details.</p>
<h3 id="running-a-worker">Running a Worker</h3>
<p>Workflows and activities are run in workers like so:</p>
<p><code node="[object Object]"><div><pre><code>using MyNamespace;
using Temporalio.Client;
using Temporalio.Worker;

// Create a client to localhost on &#34;default&#34; namespace
var client = await TemporalClient.ConnectAsync(new(&#34;localhost:7233&#34;));

// Cancellation token to shut down worker on ctrl+c
using var tokenSource = new CancellationTokenSource();
Console.CancelKeyPress += (_, eventArgs) =&gt;
{
    tokenSource.Cancel();
    eventArgs.Cancel = true;
};

// Create an activity instance since we have instance activities. If we had
// all static activities, we could just reference those directly.
var activities = new PurchaseActivities();

// Create worker with the activity and workflow registered
using var worker = new TemporalWorker(
    client,
    new(taskQueue: &#34;my-task-queue&#34;)
    {
        Activities = { activities.DoPurchaseAsync },
        Workflows = { typeof(OneClickBuyWorkflow) },
    });

// Run worker until cancelled
Console.WriteLine(&#34;Running worker&#34;);
try
{
    await worker.ExecuteAsync(tokenSource.Token);
}
catch (OperationCanceledException)
{
    Console.WriteLine(&#34;Worker cancelled&#34;);
}
</code></pre></div></code></p><p>When executed, the worker will listen for Temporal server requests to perform workflow and activity invocations.</p>
<h3 id="executing-a-workflow">Executing a Workflow</h3>
<p><code node="[object Object]"><div><pre><code>using MyNamespace;
using Temporalio.Client;

// Create a client to localhost on &#34;default&#34; namespace
var client = await TemporalClient.ConnectAsync(new(&#34;localhost:7233&#34;));

// Start a workflow
var handle = await client.StartWorkflowAsync(
    OneClickBuyWorkflow.Ref.RunAsync,
    new Purchase(ItemID: &#34;item1&#34;, UserID: &#34;user1&#34;),
    new(id: &#34;my-workflow-id&#34;, taskQueue: &#34;my-task-queue&#34;));

// We can update the purchase if we want
await handle.SignalAsync(
    OneClickBuyWorkflow.Ref.UpdatePurchaseAsync,
    new Purchase(ItemID: &#34;item2&#34;, UserID: &#34;user1&#34;));

// We can cancel it if we want
await handle.CancelAsync();

// We can query its status, even if the workflow is complete
var status = await handle.QueryAsync(OneClickBuyWorkflow.Ref.CurrentStatus);
Console.WriteLine(&#34;Purchase workflow status: {0}&#34;, status);

// We can also wait on the result (which for our example is the same as query)
status = await handle.GetResultAsync();
Console.WriteLine(&#34;Purchase workflow result: {0}&#34;, status);
</code></pre></div></code></p><p>This is a tiny taste of the many features offered by Temporal .NET. See the
<a href="https://github.com/temporalio/sdk-dotnet">.NET SDK README</a> for more details.</p>
<h2 id="why-the-ref-pattern">Why the &#39;Ref&#39; Pattern?</h2>
<p>In the code samples above, you may notice the <code node="[object Object]">Ref</code> properties that are created via
<code node="[object Object]">ActivityRefs.Create&lt;PurchaseActivities&gt;()</code> and <code node="[object Object]">WorkflowRefs.Create&lt;OneClickBuyWorkflow&gt;()</code>. We will explain why they
exist and what alternatives were considered.</p>
<h3 id="what-problem-does-ref-solve">What Problem Does &#39;Ref&#39; Solve?</h3>
<p>When you need to invoke an activity from a workflow, or a workflow/signal/query/etc from a client, you need to know
<em>which</em> one you want to call. Each of the calls for invoking those items has an overload that accepts a string name,
which works fine but does not provide type safety for the return type and/or parameter.</p>
<p>For type safety, we want to accept a generically typed delegate we can ensure type safety on. Say we want to accept a
<code node="[object Object]">Func&lt;T, TResult&gt;</code> as an activity. If it&#39;s a static method, no problem ‚Äî <code node="[object Object]">MyClass.MyStaticMethod</code> is just fine to pass
for that type. But if it&#39;s an instance method, there is a problem. <code node="[object Object]">MyClass.MyInstanceMethod</code> does not work because C#
does not allow you to reference an instance method without the instance.</p>
<p>In Java you could have <code node="[object Object]">MyClass::myInstanceMethod</code>, or in Go you could have <code node="[object Object]">MyReceiver.MyInstanceMethod</code>, or in Python
you could have <code node="[object Object]">MyClass.my_instance_method</code>, and they will all work by accepting the instance as the first parameter.
But not C#, so we need to work around this.</p>
<h3 id="how-does-ref-work">How Does &#39;Ref&#39; Work?</h3>
<p>We solve this problem by allowing users to create instances of the class/interface without invoking anything on it. For
classes this is done via
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatterservices.getuninitializedobject"><code node="[object Object]">FormatterServices.GetUninitializedObject</code></a>
and for interfaces this is done via <a href="http://www.castleproject.org/projects/dynamicproxy/">Castle Dynamic Proxy</a>. This
lets us &#34;reference&#34; (hence the name <code node="[object Object]">Ref</code>) methods on the objects without actually instantiating them with side effects.
Method calls should never be made on these objects (and most wouldn&#39;t work anyways).</p>
<p>So now you can have <code node="[object Object]">public static readonly MyClass Ref = ActivityRefs.Create&lt;MyClass&gt;()</code> at the top of <code node="[object Object]">MyClass</code>. Then
you can use <code node="[object Object]">Workflow.ExecuteActivityAsync(MyClass.Ref.MyInstanceMethod, &#34;some-param&#34;, ...</code> and know that if
<code node="[object Object]">MyInstanceMethod</code> took an <code node="[object Object]">int</code> parameter instead, you&#39;d get a compile-time error.</p>
<p>For this reason, we recommend all activity classes with instance methods have a <code node="[object Object]">Ref</code> and all workflow classes have a
<code node="[object Object]">Ref</code>.</p>
<h3 id="what-other-solutions-exist">What Other Solutions Exist?</h3>
<p>There are a couple of other solutions to the reference-instance-method-for-type-safety problem.</p>
<p>The most common approach is to use the dynamic proxy pattern. This is what Durable Entities, Orleans, and our own
Temporal Java SDK use. This creates dynamic proxies of interfaces that you then invoke the methods on, which in turn
do the remote invocation. While this is type safe for parameters and return types, this has drawbacks listed below:</p>
<ul>
<li>You have to conform to the sync/async nature of the methods. Which means that since we support synchronous activities,
you&#39;d invoke them via a proxy as synchronous, which is not valid since they are asynchronous. We&#39;d have to disallow
synchronous activities for this use case, which we don&#39;t want to do. Similarly, we&#39;d have to make queries async which is
also undesirable because it might encourage side-effecting calls in queries.</li>
<li>It is not easy to pass options at the call site. When you invoke the proxied method, there is no parameter to give
options. For some Temporal calls like invoking an activity, we <em>require</em> at least one option. You end up having to
move the options for a call away from the call which is bad for authors and readers.</li>
<li>It is not obvious you are making an external call. When invoking an activity or similar, it is important that it is
obvious you are invoking an activity. If done on a proxied object, it&#39;ll look like any other invocation.</li>
<li>You cannot differentiate multiple uses of the same method. For example, in Temporal you have a call for just starting
the workflow and a call for executing the workflow and waiting on its result. The proxy would only be for executing,
so you&#39;d still need some way to reference the run method for just starting a workflow.</li>
<li>This requires interfaces or at least classes with virtual methods. Dynamic proxying in .NET cannot proxy non-virtual
methods. We don&#39;t want to require interfaces/virtual.</li>
</ul>
<p>Another approach that&#39;s becoming more common these days is source generators. This is something we hope to fully
support, we just have not built it yet (see the <a href="#future-of-the-net-sdk">Future</a> section below).</p>
<h2 id="how-it-works--workflow-determinism">How It Works ‚Äì Workflow Determinism</h2>
<p>In Temporal, workflows must be deterministic. This means in addition to disallowing all the obvious stuff like random
and system time, Temporal must also have strict control over task scheduling and coroutines in order to ensure
deterministic execution.</p>
<p>While Python and others allow <em>full</em> control over the event loop (see
<a href="https://temporal.io/blog/durable-distributed-asyncio-event-loop">this blog post</a>), .NET does not. We make a custom
<code node="[object Object]">TaskScheduler</code> to order all created tasks deterministically, but we cannot control timers and many Task management
calls in .NET (e.g. simple overloads of <code node="[object Object]">Task.Run</code>) use <code node="[object Object]">TaskScheduler.Default</code> implicitly instead of the preferred
<code node="[object Object]">TaskScheduler.Current</code>. Even
<a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2008">some analyzer rules</a>
discourage use of calls that implicitly use <code node="[object Object]">TaskScheduler.Current</code> though that is exactly what needs to be used in
workflows. Sometimes it&#39;s not even obvious that something internal will
<a href="https://github.com/dotnet/runtime/issues/83159">use the default scheduler unexpectedly</a>.</p>
<p>In order to solve this and prevent other non-deterministic calls, we would run in a sandbox. But recent versions of .NET
have done away with some of this tooling (specifically &#34;Code Access Security&#34; and &#34;Partially Trusted Code&#34; features).
These same issues also appear in Temporal Go and Java SDKs where we ask users not to do any platform threading/async
outside of our deterministic scheduler.</p>
<p>So, we ask users to make sure all task calls are done on the current task scheduler and not to use timers. See the
<a href="https://github.com/temporalio/sdk-dotnet">.NET SDK README</a> for more details on what we limit.</p>
<p>We found it so hard to know which calls use threading and system timers in .NET that we are trying to eagerly detect
these situations at runtime and compile time. At runtime, by default, we enable a tracing
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventlistener"><code node="[object Object]">EventListener</code></a> that intercepts
a select few info-level task events to check whether, if we are running in a workflow, all tasks are being performed on
the proper scheduler. Technically this event listener listens for all of these specific task events regardless of
whether a workflow is executing, but our check to disregard non-workflow events is very cheap (basically just a thread
local check). But we do allow the listener to be disabled if needed. This listener will suspend the workflow (i.e. fail
the &#34;workflow task&#34;) when invalid task scheduling is encountered. The workflow will resume when code is deployed with a
fix.</p>
<p>In the future, there are two things that can help here. First, we want to create analyzers to find these mistakes at
compile time (see &#34;Future&#34; section below). Second for timers, the
<a href="https://github.com/dotnet/runtime/issues/36617">new <code node="[object Object]">TimeProvider</code> API</a> recently merged will allow modern .NET versions
to let us control timer creation instead of falling back to system timers.</p>
<h2 id="future-of-the-net-sdk">Future of the .NET SDK</h2>
<p>The .NET SDK is already a full-featured SDK on par with the others. Its alpha label is due to immaturity, not
incompleteness. During this period, APIs are not guaranteed to remain compatible. There are three things we want to add
in the near term (though no guarantees they will be added before GA).</p>
<p>First, we want to add source generation. We have the shape of activities and workflows, and therefore we can generate
idiomatic caller-side structures to make invocation safer/easier. Source generation will always be optional, but may
become the preferred way to call activities and workflows.</p>
<p>Second, we want to create a set of analyzers. We know what you can and can&#39;t call in a workflow, so static analysis to
catch these invalid calls should be fairly easy to develop. This would work like any other .NET analyzer and is
something we want to develop soon. Then again, maybe our approaches/investments in AI to find Temporal workflow mistakes
will be completed first üôÇ.</p>
<p>Finally, the <a href="https://github.com/dotnet/runtime/issues/36617">new <code node="[object Object]">TimeProvider</code> API</a> will allow us to intercept timers
in a much more transparent way for users. Granted, it will only work on the newest .NET versions.</p>
<p>The .NET SDK will be supported like other SDKs. Therefore, Temporal features like workflow
updates will be added to the .NET SDK as they are added to other SDKs.</p>
<p>Try it out today! We want all feedback, positive or negative! Join us in <code node="[object Object]">#dotnet-sdk</code> on <a href="https://t.mp/slack">Slack</a> or
on <a href="https://community.temporal.io/tag/dotnet-sdk">the forums</a>.</p></div></div></div>
  </body>
</html>
