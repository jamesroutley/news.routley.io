<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://r.ena.to/blog/optimizing-postgres-table-layout-for-maximum-efficiency/">Original</a>
    <h1>Optimizing Postgres table layout for maximum efficiency</h1>
    
    <div id="readability-page-1" class="page"><article>
    <header>
        <p><a href="https://r.ena.to/blog/optimizing-postgres-table-layout-for-maximum-efficiency/">
                <img src="https://r.ena.to/blog/optimizing-postgres-table-layout-for-maximum-efficiency/cover_hu17784599788914226208.webp" srcset="/blog/optimizing-postgres-table-layout-for-maximum-efficiency/cover_hu17784599788914226208.webp 800w, /blog/optimizing-postgres-table-layout-for-maximum-efficiency/cover_hu13882444287557351277.webp 1600w" width="800" height="800" loading="lazy" alt="Featured image of post Optimizing Postgres table layout for maximum efficiency"/>
                
            </a>
        </p>
    

    

</header>

    <section>
    
    
    <h2 id="introduction">Introduction
</h2><p>When modeling a Postgres database, you probably don’t give much thought to the order of columns in your tables. After all, it seems like the kind of thing that wouldn’t affect storage or performance. But what if I told you that simply reordering your columns could reduce the size of your tables and indexes by 20%? This isn’t some obscure database trick — it’s a direct result of how Postgres aligns data on disk.</p>
<p>In this post, I’ll explore how column alignment works in Postgres, why it matters, and how you can optimize your tables for better efficiency. Through a few real-world examples, you’ll see how even small changes in column order can lead to measurable improvements.</p>
<h2 id="weighing-a-row">Weighing a row
</h2><p>As a direct result of the <a href="https://www.postgresql.org/docs/current/storage-page-layout.html#STORAGE-TUPLE-LAYOUT" target="_blank" rel="noopener">table row layout</a>, the smallest possible size for a row is 24 bytes.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sql"><span><span><span>SELECT</span><span> </span><span>pg_column_size</span><span>(</span><span>ROW</span><span>());</span><span>
</span></span></span><span><span><span> </span><span>pg_column_size</span><span>
</span></span></span><span><span><span></span><span>----------------
</span></span></span><span><span><span></span><span>             </span><span>24</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Then, for each new column you add to a row, the more space it will take:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sql"><span><span><span>-- One column of type integer: 24 + 4 = 28 bytes
</span></span></span><span><span><span></span><span>SELECT</span><span> </span><span>pg_column_size</span><span>(</span><span>ROW</span><span>(</span><span>1</span><span>::</span><span>int</span><span>));</span><span>
</span></span></span><span><span><span> </span><span>pg_column_size</span><span>
</span></span></span><span><span><span></span><span>----------------
</span></span></span><span><span><span></span><span>             </span><span>28</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Integer + smallint columns: 24 + 4 + 2 = 30 bytes
</span></span></span><span><span><span></span><span>SELECT</span><span> </span><span>pg_column_size</span><span>(</span><span>ROW</span><span>(</span><span>1</span><span>::</span><span>int</span><span>,</span><span> </span><span>1</span><span>::</span><span>smallint</span><span>));</span><span>
</span></span></span><span><span><span> </span><span>pg_column_size</span><span>
</span></span></span><span><span><span></span><span>----------------
</span></span></span><span><span><span></span><span>             </span><span>30</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>So far so good. That’s exactly what you’d expect: the more data you have in your row, the more space in disk it will use. Disk usage is directly proportional to the data types.</p>
<p>In other words, if we have one integer column, we expect the row size to be 24 + 4 = 28 bytes. If we have one integer column and one smallint column, we expect the row size to be 24 + 4 + 2 = 30 bytes.</p>
<p>How can we explain the following output, then?</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sql"><span><span><span>SELECT</span><span> </span><span>pg_column_size</span><span>(</span><span>ROW</span><span>(</span><span>1</span><span>::</span><span>smallint</span><span>,</span><span> </span><span>1</span><span>::</span><span>int</span><span>));</span><span>
</span></span></span><span><span><span> </span><span>pg_column_size</span><span>
</span></span></span><span><span><span></span><span>----------------
</span></span></span><span><span><span></span><span>             </span><span>32</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>How is this possible?! We <em>just</em> saw that a <code>(integer, smallint)</code> row yields 30 bytes of storage, but a <code>(smallint, integer)</code> row costs 32 bytes of disk space! It happens with other data types, too:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sql"><span><span><span>-- (bigint, boolean) = 24 + 8 + 1 = 33 bytes
</span></span></span><span><span><span></span><span>SELECT</span><span> </span><span>pg_column_size</span><span>(</span><span>ROW</span><span>(</span><span>1</span><span>::</span><span>bigint</span><span>,</span><span> </span><span>true</span><span>::</span><span>boolean</span><span>));</span><span>
</span></span></span><span><span><span> </span><span>pg_column_size</span><span>
</span></span></span><span><span><span></span><span>----------------
</span></span></span><span><span><span></span><span>             </span><span>33</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- (boolean, bigint) = 24 + ? + 8 = 40 bytes!?!?
</span></span></span><span><span><span></span><span>SELECT</span><span> </span><span>pg_column_size</span><span>(</span><span>ROW</span><span>(</span><span>true</span><span>::</span><span>boolean</span><span>,</span><span> </span><span>1</span><span>::</span><span>bigint</span><span>));</span><span>
</span></span></span><span><span><span> </span><span>pg_column_size</span><span>
</span></span></span><span><span><span></span><span>----------------
</span></span></span><span><span><span></span><span>             </span><span>40</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Rows with <code>(boolean, bigint)</code> structure use 21% more disk space than a <code>(bigint, boolean)</code> row!</p>
<p>What is going on here?</p>
<h2 id="data-alignment">Data Alignment
</h2><p>The answer is <a href="https://en.wikipedia.org/wiki/Data_structure_alignment" target="_blank" rel="noopener"><strong>data alignment</strong></a>.</p>
<p>Postgres will happily add padding to the underlying data in order to make sure it is properly aligned at the physical layer. Having the data aligned ensures faster access time when retrieving pages from disk.</p>
<blockquote>
<p>This is actually a <a href="https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff" target="_blank" rel="noopener">space-time tradeoff</a>: we are adding seemingly wasteful space in order to have faster data access.</p>
</blockquote>
<h3 id="visual-representation">Visual representation
</h3><p>Let’s try to visualize what the data would look like on disk. Below is a properly-aligned <code>(integer, smallint)</code> row:</p>
<p><img src="https://r.ena.to/blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_1.png" width="710" height="356" srcset="/blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_1_hu8588515971306457955.png 480w, /blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_1_hu12393775208528255437.png 1024w" loading="lazy" alt="(integer, smallint) = 30 bytes per row" data-flex-grow="199" data-flex-basis="478px"/></p>
<p>Contrast it to the misaligned <code>(smallint, integer)</code> row:</p>
<p><img src="https://r.ena.to/blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_2.png" width="687" height="348" srcset="/blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_2_hu17358260829673272382.png 480w, /blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_2_hu5333542421841964515.png 1024w" loading="lazy" alt="(smallint, integer) = 32 bytes per row" data-flex-grow="197" data-flex-basis="473px"/></p>
<p>Notice how Postgres had to pad the <code>smallint</code> column to enforce the necessary alignment of 4 bytes.</p>
<p>Below is another example, now with <code>(bigint, smallint, boolean)</code> resulting in a row of 35 bytes.</p>
<p><img src="https://r.ena.to/blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_5.png" width="852" height="358" srcset="/blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_5_hu2648855763955735646.png 480w, /blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_5_hu16443045373977630918.png 1024w" loading="lazy" alt="(bigint, smallint, boolean) = 35 bytes per row" data-flex-grow="237" data-flex-basis="571px"/></p>
<p>And the same row, with different order, resulting in 40 bytes per row:</p>
<p><img src="https://r.ena.to/blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_4.png" width="1080" height="454" srcset="/blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_4_hu16289019807719247674.png 480w, /blog/optimizing-postgres-table-layout-for-maximum-efficiency/example_4_hu5507881336590707772.png 1024w" loading="lazy" alt="(boolean, smallint, bigint) = 40 bytes per row" data-flex-grow="237" data-flex-basis="570px"/></p>
<h3 id="calculating-alignment-boundaries">Calculating alignment boundaries
</h3><p>What determines the alignment used by Postgres? From the <a href="https://www.postgresql.org/docs/current/catalog-pg-type.html" target="_blank" rel="noopener">docs</a>:</p>
<blockquote>
    <p><code>typalign</code> is the alignment required when storing a value of this type. It applies to storage on disk as well as most representations of the value inside PostgreSQL. When multiple values are stored consecutively, such as in the representation of a complete row on disk, <strong>padding is inserted before a datum of this type so that it begins on the specified boundary</strong>. The alignment reference is the beginning of the first datum in the sequence. Possible values are:</p>
<ul>
<li>c = char alignment, i.e., no alignment needed.</li>
<li>s = short alignment (2 bytes on most machines).</li>
<li>i = int alignment (4 bytes on most machines).</li>
<li>d = double alignment (8 bytes on many machines, but by no means all).</li>
</ul></blockquote>
<p>We can confirm this by querying <code>pg_type</code> directly:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sql"><span><span><span>SELECT</span><span> </span><span>typname</span><span>,</span><span> </span><span>typalign</span><span>,</span><span> </span><span>typlen</span><span>
</span></span></span><span><span><span></span><span>FROM</span><span> </span><span>pg_type</span><span>
</span></span></span><span><span><span></span><span>WHERE</span><span> </span><span>typname</span><span> </span><span>IN</span><span> </span><span>(</span><span>&#39;int4&#39;</span><span>,</span><span> </span><span>&#39;int2&#39;</span><span>,</span><span> </span><span>&#39;int8&#39;</span><span>,</span><span> </span><span>&#39;bool&#39;</span><span>,</span><span> </span><span>&#39;varchar&#39;</span><span>,</span><span> </span><span>&#39;text&#39;</span><span>,</span><span> </span><span>&#39;float4&#39;</span><span>,</span><span> </span><span>&#39;float8&#39;</span><span>,</span><span> </span><span>&#39;uuid&#39;</span><span>,</span><span> </span><span>&#39;date&#39;</span><span>,</span><span> </span><span>&#39;timestamp&#39;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>typname</span><span>  </span><span>|</span><span> </span><span>typalign</span><span> </span><span>|</span><span> </span><span>typlen</span><span>
</span></span></span><span><span><span></span><span>-----------+----------+--------
</span></span></span><span><span><span></span><span> </span><span>bool</span><span>      </span><span>|</span><span> </span><span>c</span><span>        </span><span>|</span><span>      </span><span>1</span><span>
</span></span></span><span><span><span> </span><span>int8</span><span>      </span><span>|</span><span> </span><span>d</span><span>        </span><span>|</span><span>      </span><span>8</span><span>
</span></span></span><span><span><span> </span><span>int2</span><span>      </span><span>|</span><span> </span><span>s</span><span>        </span><span>|</span><span>      </span><span>2</span><span>
</span></span></span><span><span><span> </span><span>int4</span><span>      </span><span>|</span><span> </span><span>i</span><span>        </span><span>|</span><span>      </span><span>4</span><span>
</span></span></span><span><span><span> </span><span>text</span><span>      </span><span>|</span><span> </span><span>i</span><span>        </span><span>|</span><span>     </span><span>-</span><span>1</span><span>
</span></span></span><span><span><span> </span><span>float4</span><span>    </span><span>|</span><span> </span><span>i</span><span>        </span><span>|</span><span>      </span><span>4</span><span>
</span></span></span><span><span><span> </span><span>float8</span><span>    </span><span>|</span><span> </span><span>d</span><span>        </span><span>|</span><span>      </span><span>8</span><span>
</span></span></span><span><span><span> </span><span>varchar</span><span>   </span><span>|</span><span> </span><span>i</span><span>        </span><span>|</span><span>     </span><span>-</span><span>1</span><span>
</span></span></span><span><span><span> </span><span>date</span><span>      </span><span>|</span><span> </span><span>i</span><span>        </span><span>|</span><span>      </span><span>4</span><span>
</span></span></span><span><span><span> </span><span>timestamp</span><span> </span><span>|</span><span> </span><span>d</span><span>        </span><span>|</span><span>      </span><span>8</span><span>
</span></span></span><span><span><span> </span><span>uuid</span><span>      </span><span>|</span><span> </span><span>c</span><span>        </span><span>|</span><span>     </span><span>16</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>You can see, for example, that <code>int8</code> will require an alignment of <code>d</code> (double, or 8 bytes) whereas <code>int4</code> needs half the space.</p>
<p><code>varchar</code> and <code>text</code> work differently. Even though they have an alignment of <code>i</code>, their <code>typlen</code> is negative. Why is that? Because they have variable size, i.e. they use a <code>varlena</code> structure.</p>
<p>The fact that these two fields have variable length is not really relevant to alignment, except for the fact that such variable column will be aligned in boundaries of 4 bytes (unless the data is TOASTed, as we’ll see below).</p>
<p>It’s also worth pointing out that the <code>uuid</code> type is different. It has a <code>typlen</code> of 16 bytes, but it has <code>c</code> alignment (meaning it needs no prior alignment). As such, you don’t need to worry if you have a <code>boolean</code> column right before an <code>uuid</code>, for example.</p>
<p>In the Postgres codebase you’ll find this value being used in the <code>MAXALIGN</code> macro to determine the necessary alignment for fixed-width types.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>define</span> <span>TYPEALIGN</span><span>(</span><span>ALIGNVAL</span><span>,</span><span>LEN</span><span>)</span>  \
</span></span><span><span>	<span>(((</span><span>uintptr_t</span><span>)</span> <span>(</span><span>LEN</span><span>)</span> <span>+</span> <span>((</span><span>ALIGNVAL</span><span>)</span> <span>-</span> <span>1</span><span>))</span> <span>&amp;</span> <span>~</span><span>((</span><span>uintptr_t</span><span>)</span> <span>((</span><span>ALIGNVAL</span><span>)</span> <span>-</span> <span>1</span><span>)))</span>
</span></span><span><span>
</span></span><span><span><span>#define MAXALIGN(LEN)			TYPEALIGN(MAXIMUM_ALIGNOF, (LEN))
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><blockquote>
<p>NOTE: the documentation states that <strong>padding is inserted before […] this type</strong>. This means that, if we have a structure like <code>(char, int4, char, int8)</code> then we will have 3 bytes of padding before <code>int4</code> and 7 bytes of padding before <code>int8</code>.</p>
</blockquote>
<h3 id="alignment-applies-to-indexes-too">Alignment applies to indexes, too!
</h3><p>What’s often overlooked is that data alignment doesn’t just impact the rows in your tables — it applies to indexes as well. This can be surprising because we typically think of indexes as compact, optimized structures that exist purely to speed up queries. However, Postgres ensures that data in indexes follows the same alignment rules as table rows, which means that misaligned columns can inflate the size of your indexes just as they do with tables.</p>
<p>This is actually how I originally found out about the importance of data alignment in Postgres. I had an <code>(int8, int8)</code> index, which I restructured to be <code>(int4, int8)</code> to result in a smaller table/index size. Imagine my surprise when I benchmarked and realized the index size did not change at all!</p>
<p>This is a critical point to take home: <strong>misaligned columns affect your indexes too</strong>, potentially increasing both disk usage and memory consumption. Keeping indexes aligned can therefore have a significant impact on database performance and resource efficiency.</p>
<h3 id="what-it-looks-like-in-practice">What it looks like in practice
</h3><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sql"><span><span><span>-- Let&#39;s create the first table, which has (int4, int8, int4) structure
</span></span></span><span><span><span></span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>table_1</span><span> </span><span>(</span><span>int4_1</span><span> </span><span>INTEGER</span><span>,</span><span> </span><span>int8_2</span><span> </span><span>BIGINT</span><span>,</span><span> </span><span>int4_3</span><span> </span><span>INTEGER</span><span>);</span><span>
</span></span></span><span><span><span></span><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>int_4_int_8_int_4</span><span> </span><span>ON</span><span> </span><span>table_1</span><span> </span><span>(</span><span>int4_1</span><span>,</span><span> </span><span>int8_2</span><span>,</span><span> </span><span>int4_3</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- The second table has a better alignment: (int4, int4, int8)
</span></span></span><span><span><span></span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>table_2</span><span> </span><span>(</span><span>int4_1</span><span> </span><span>INTEGER</span><span>,</span><span> </span><span>int4_2</span><span> </span><span>INTEGER</span><span>,</span><span> </span><span>int8_3</span><span> </span><span>BIGINT</span><span>);</span><span>
</span></span></span><span><span><span></span><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>int_4_int_4_int_8</span><span> </span><span>ON</span><span> </span><span>table_2</span><span> </span><span>(</span><span>int4_1</span><span>,</span><span> </span><span>int4_2</span><span>,</span><span> </span><span>int8_3</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- Add 10_000_000 entries to each table
</span></span></span><span><span><span></span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>table_1</span><span> </span><span>(</span><span>int4_1</span><span>,</span><span> </span><span>int8_2</span><span>,</span><span> </span><span>int4_3</span><span>)</span><span> </span><span>SELECT</span><span> </span><span>gs</span><span> </span><span>AS</span><span> </span><span>int4_1</span><span>,</span><span> </span><span>gs</span><span> </span><span>AS</span><span> </span><span>int8_2</span><span>,</span><span> </span><span>gs</span><span> </span><span>AS</span><span> </span><span>int4_3</span><span> </span><span>FROM</span><span> </span><span>GENERATE_SERIES</span><span>(</span><span>1</span><span>,</span><span> </span><span>10000000</span><span>)</span><span> </span><span>AS</span><span> </span><span>gs</span><span>;</span><span>
</span></span></span><span><span><span></span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>table_2</span><span> </span><span>(</span><span>int4_1</span><span>,</span><span> </span><span>int4_2</span><span>,</span><span> </span><span>int8_3</span><span>)</span><span> </span><span>SELECT</span><span> </span><span>gs</span><span> </span><span>AS</span><span> </span><span>int4_1</span><span>,</span><span> </span><span>gs</span><span> </span><span>AS</span><span> </span><span>int4_2</span><span>,</span><span> </span><span>gs</span><span> </span><span>AS</span><span> </span><span>int8_3</span><span> </span><span>FROM</span><span> </span><span>GENERATE_SERIES</span><span>(</span><span>1</span><span>,</span><span> </span><span>10000000</span><span>)</span><span> </span><span>AS</span><span> </span><span>gs</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- The first table uses more disk space than the second one
</span></span></span><span><span><span></span><span>SELECT</span><span>
</span></span></span><span><span><span>  </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>&#39;table_1&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>table_1_size</span><span>,</span><span>
</span></span></span><span><span><span>  </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>&#39;table_2&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>table_2_size</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>table_1_size</span><span> </span><span>|</span><span> </span><span>table_2_size</span><span>
</span></span></span><span><span><span></span><span>--------------+--------------
</span></span></span><span><span><span></span><span> </span><span>498</span><span> </span><span>MB</span><span>       </span><span>|</span><span> </span><span>422</span><span> </span><span>MB</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>-- The first index uses more disk (and memory) than the second one
</span></span></span><span><span><span></span><span>SELECT</span><span>
</span></span></span><span><span><span>  </span><span>indexrelid</span><span>::</span><span>regclass</span><span> </span><span>AS</span><span> </span><span>index_name</span><span>,</span><span>
</span></span></span><span><span><span>  </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>indexrelid</span><span>::</span><span>regclass</span><span>))</span><span> </span><span>AS</span><span> </span><span>index_size</span><span>
</span></span></span><span><span><span></span><span>FROM</span><span>
</span></span></span><span><span><span>  </span><span>pg_stat_user_indexes</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>index_name</span><span>     </span><span>|</span><span> </span><span>index_size</span><span>
</span></span></span><span><span><span></span><span>-------------------+------------
</span></span></span><span><span><span></span><span> </span><span>int_4_int_8_int_4</span><span> </span><span>|</span><span> </span><span>386</span><span> </span><span>MB</span><span>
</span></span></span><span><span><span> </span><span>int_4_int_4_int_8</span><span> </span><span>|</span><span> </span><span>300</span><span> </span><span>MB</span><span>
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>For a single table, with only one misaligned datum, the properly aligned table uses 76 less megabytes (a 15% improvement), and the properly aligned index uses 86 less megabytes (a 22% improvement).</p>
<p>These experimental tables have 10 million entries, which is a small number for real-world databases. Imagine the level of improvement one may find on those databases!</p>
<blockquote>
    <p>NOTE: It’s important to mention that the benefits of a properly aligned table are not exclusive to storage. It will likely lead to <strong>performance gains</strong>, too.</p>
<p>It’s intuitively easy to understand why that’s the case. With a better data alignment, your rows will be smaller. With smaller rows, you will fit more rows per page. With tightly packed pages:</p>
<ol>
<li>Potentially fewer pages need to be retrieved from disk.</li>
<li>Postgres can fit more rows in memory (i.e. more rows for the same number of cached pages)</li>
</ol>
</blockquote>
<p>I don’t have the time to measure how much performance would be improved, but I believe the potential performance gains are non-negligible.</p>
<h3 id="when-to-start-worrying">When to start worrying
</h3><p>Friends don’t let friends create misaligned tables. But you don’t necessarily want to become the alignment police in your company’s PR reviews!</p>
<p><img src="https://r.ena.to/blog/optimizing-postgres-table-layout-for-maximum-efficiency/data_alignment_police.webp" width="600" height="600" srcset="/blog/optimizing-postgres-table-layout-for-maximum-efficiency/data_alignment_police_hu14090633319460890224.webp 480w, /blog/optimizing-postgres-table-layout-for-maximum-efficiency/data_alignment_police_hu15204283844245078670.webp 1024w" loading="lazy" alt="You have the right to remain aligned" data-flex-grow="100" data-flex-basis="240px"/></p>
<p>Startups, specially early-stage ones, often have a frenetic development process, and saving 10-20% of disk space is usually not a top priority. Quite often, these savings are absolutely irrelevant at this stage. So, when should your team worry about table alignment?</p>
<p>The right answer depends heavily on the context behind your product, but eventually you will notice dramatic infrastructure-related costs (specific to your databases) and maybe that’s a good starting point.</p>
<p>However, I hold the opinion that a competent software engineer should always keep this fact in mind and, whenever possible, make adjustments while developing features. No need to fret over it, but try to keep your tables aligned from early on.</p>
<p>This will significantly save <em>time</em> in the future. Refactoring your data model is not easy. It’s not only a matter of reordering your table columns, but your indexes too (which also means reordering your query pattern at the application layer).</p>
<p>In fact, for early-stage startups, <strong>my recommendation is to always keep an eye on how well-aligned your <em>indexes</em> are</strong>. You can reorder the actual table columns later on, but pay close attention to your indexes. I think this is a good recommendation because:</p>
<ol>
<li>As mentioned above, indexes are hard to reorder. You’d need to make sure the access pattern is reordered too, since a query on <code>(a, b)</code> will not use an index on <code>(b, a)</code>.</li>
<li>It is easy to change the order of indexes during development, since they are added individually and don’t depend on previous migrations.</li>
<li>Changing the order of columns during development is hard, though, because they often build upon previous migrations.</li>
<li>Refactoring the data model to reorder table columns, while not trivial, does not need application-level changes (unless you are doing something fringe), so it can be postponed to a later stage.</li>
</ol>
<h3 id="rule-of-thumb">Rule of thumb
</h3><p>A generic rule of thumb I’ve been using for the past few years is to, whenever possible, define columns based on a descending order of data types size.</p>
<p>In other words: start with larger data types like <code>int8</code>, <code>float8</code> and <code>timestamp</code>, and place smaller types at the end. This will naturally align your table.</p>
<p>Keep in mind this is an “all else being equal” kind of rule. Other factors, like cardinality or even readability, may have higher priority than data alignment, especially when it comes to indexes.</p>
<h3 id="a-note-on-toasted-values">A note on TOASTed values
</h3><p>Some data types have variable length and their value may be stored elsewhere if it gets too big to the point that a row would not fit in a single page. When this happens, we say the value is TOASTed. In this scenario, the row will contain a pointer to the underlying data.</p>
<p>Different types of pointer may exist depending on the size of the data. For single-byte pointers, no alignment is necessary, whereas a 4-byte alignment is applied to 4-byte pointers. From the <a href="https://www.postgresql.org/docs/current/storage-toast.html" target="_blank" rel="noopener">docs</a>:</p>
<blockquote>
    <p>Values with single-byte headers aren’t aligned on any particular boundary, whereas values with four-byte headers are aligned on at least a four-byte boundary; this omission of alignment padding provides additional space savings that is significant compared to short values.</p></blockquote>
<h2 id="does-this-apply-to-other-databases">Does this apply to other databases?
</h2><p>Do we need to consider data alignment when working with databases other than Postgres? Here’s what I found out:</p>
<h3 id="sqlite">SQLite
</h3><p>No. Here’s a <a href="https://sqlite.org/forum/info/5e030d06c5b32ab5y" target="_blank" rel="noopener">quote from Richard Hipp</a>:</p>
<blockquote>
    <p>SQLite does not pad or align columns within a row. Everything is tightly packed together using minimal space. Two consequences of this design:</p>
<ol>
<li>SQLite has to work harder (use more CPU cycles) to access data within a row once it has that row in memory.</li>
<li>SQLite uses fewer bytes on disk, less memory, and spends less time moving content around because there are fewer bytes to move.</li>
</ol>
<p>We believe that the benefit of #2 outweighs the disadvantage of #1, especially on modern hardware in which #1 is operating out of L1 cache whereas #2 is using main-memory transfers. But your mileage may vary depending on what you store in the database file.</p>
<span><span>― </span><a href="https://sqlite.org/forum/info/5e030d06c5b32ab5y"><cite>drh</cite></a></span></blockquote>
<p>For those familiar with the SQLite architecture, I’d say this is not surprising and well in-line with the SQLite philosophy.</p>
<h3 id="mysql">MySQL
</h3><p>MySQL is not my forte, so you will want to dive deeper to corroborate my findings. I’m only quoting the docs and adding a few thoughts of my own, which I have not verified. You can use the links below as a starting point for your own research.</p>
<h4 id="ndb">NDB
</h4><p>From <a href="https://dev.mysql.com/doc/refman/8.4/en/storage-requirements.html#data-types-storage-reqs-ndb" target="_blank" rel="noopener">the docs</a>:</p>
<blockquote>
    <p>NDB tables use 4-byte alignment; all NDB data storage is done in multiples of 4 bytes. Thus, a column value that would typically take 15 bytes requires 16 bytes in an NDB table. For example, in NDB tables, the TINYINT, SMALLINT, MEDIUMINT, and INTEGER (INT) column types each require 4 bytes storage per record due to the alignment factor.</p></blockquote>
<p>Based on the above, I believe padding would be added to columns smaller than 4 bytes.</p>
<h4 id="innodb">InnoDB
</h4><p>I failed to see a mention of alignment and padding in <a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html" target="_blank" rel="noopener">chapter 17 of the MySQL docs</a>, except maybe for this bit:</p>
<blockquote>
<p>[<code>innodb_compression_failure_threshold_pct</code>] [d]efines the compression failure rate threshold for a table, as a percentage, at which point MySQL begins adding padding within compressed pages to avoid expensive compression failures.</p>
</blockquote>
<p>Not helpful. It hints to padding at the page level, but we want to know if the columns are individually padded. Well, MySQL is Oracle-open-sourced, so we can look at the code to try to get some hints. Here’s an interesting bit from <a href="https://github.com/mysql/mysql-server/blob/596f0d238489a9cf9f43ce1ff905984f58d227b6/storage/innobase/row/row0mysql.cc#L339" target="_blank" rel="noopener">storage/innobase/row/row0mysql.cc</a>:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="cpp"><span><span><span>/** Pad a column with spaces.
</span></span></span><span><span><span>@param[in] mbminlen Minimum size of a character, in bytes
</span></span></span><span><span><span>@param[out] pad Padded buffer
</span></span></span><span><span><span>@param[in] len Number of bytes to pad */</span>
</span></span><span><span><span>void</span> <span>row_mysql_pad_col</span><span>(</span><span>ulint</span> <span>mbminlen</span><span>,</span> <span>byte</span> <span>*</span><span>pad</span><span>,</span> <span>ulint</span> <span>len</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>const</span> <span>byte</span> <span>*</span><span>pad_end</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>switch</span> <span>(</span><span>UNIV_EXPECT</span><span>(</span><span>mbminlen</span><span>,</span> <span>1</span><span>))</span> <span>{</span>
</span></span><span><span>    <span>default</span><span>:</span>
</span></span><span><span>      <span>ut_error</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>1</span><span>:</span>
</span></span><span><span>      <span>/* space=0x20 */</span>
</span></span><span><span>      <span>memset</span><span>(</span><span>pad</span><span>,</span> <span>0x20</span><span>,</span> <span>len</span><span>);</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>2</span><span>:</span>
</span></span><span><span>      <span>/* space=0x0020 */</span>
</span></span><span><span>      <span>pad_end</span> <span>=</span> <span>pad</span> <span>+</span> <span>len</span><span>;</span>
</span></span><span><span>      <span>ut_a</span><span>(</span><span>!</span><span>(</span><span>len</span> <span>%</span> <span>2</span><span>));</span>
</span></span><span><span>      <span>while</span> <span>(</span><span>pad</span> <span>&lt;</span> <span>pad_end</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>*</span><span>pad</span><span>++</span> <span>=</span> <span>0x00</span><span>;</span>
</span></span><span><span>        <span>*</span><span>pad</span><span>++</span> <span>=</span> <span>0x20</span><span>;</span>
</span></span><span><span>      <span>};</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>4</span><span>:</span>
</span></span><span><span>      <span>/* space=0x00000020 */</span>
</span></span><span><span>      <span>pad_end</span> <span>=</span> <span>pad</span> <span>+</span> <span>len</span><span>;</span>
</span></span><span><span>      <span>ut_a</span><span>(</span><span>!</span><span>(</span><span>len</span> <span>%</span> <span>4</span><span>));</span>
</span></span><span><span>      <span>while</span> <span>(</span><span>pad</span> <span>&lt;</span> <span>pad_end</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>*</span><span>pad</span><span>++</span> <span>=</span> <span>0x00</span><span>;</span>
</span></span><span><span>        <span>*</span><span>pad</span><span>++</span> <span>=</span> <span>0x00</span><span>;</span>
</span></span><span><span>        <span>*</span><span>pad</span><span>++</span> <span>=</span> <span>0x00</span><span>;</span>
</span></span><span><span>        <span>*</span><span>pad</span><span>++</span> <span>=</span> <span>0x20</span><span>;</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Okay, clearly something, somewhere is padding columns in the InnoDB storage engine. However, when I grep the MySQL codebase for users of this function, I get the impression it’s used only in some special cases (instead of always checking for alignment and padding if necessary, as the Postgres codebase does). For example, it seems it’s used only for padding fixed-length CHAR columns (see usage at <a href="https://github.com/mysql/mysql-server/blob/596f0d238489a9cf9f43ce1ff905984f58d227b6/storage/innobase/row/row0ins.cc#L587" target="_blank" rel="noopener">row0ins.cc</a>).</p>
<p>In any case, I urge the reader to try the snippet at the “<a href="#what-it-looks-like-in-practice">What it looks like in practice</a>” section in MySQL and analyze the results. Something tells me that misaligned tables will not be as big of an issue in MySQL as they are with Postgres.</p>

</section>


    

<section>
  <section>
  <span>Subscribe to receive more posts like this</span>

  
</section>

</section>


    
</article></div>
  </body>
</html>
