<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2023/03/10/trimming-spaces-from-strings-faster-with-sve-on-an-amazon-graviton-3-processor/">Original</a>
    <h1>Trimming spaces from strings faster with SVE on an Amazon Graviton 3 processor</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>Programmers sometimes need to trim, or remove, characters, such as spaces from strings. It might be a surprising expensive task. In C/C++, the following function is efficient:</p>
<pre><span>size_t</span> trimspaces<span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>,</span> <span>size_t</span> len<span>,</span> <span>char</span> <span>*</span>out<span>)</span> <span>{</span>
<span>  char</span> <span>*</span> init_out<span>{</span>out<span>}</span><span>;</span>
<span>  for</span><span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>+</span><span>+</span><span>)</span> <span>{</span>
<span>    *</span>out <span>=</span> s<span>[</span>i<span>]</span><span>;</span>
    out <span>+</span><span>=</span> <span>(</span>s<span>[</span>i<span>]</span> <span>!</span><span>=</span> <span>&#39; &#39;</span><span>)</span><span>;</span>
<span>  }</span>
<span>  return</span> out <span>-</span> init_out<span>;</span>
<span>}</span>

</pre>
<p>Basically, we write all characters from the input, but we only increment the pointer if the input is not a space.</p>
<p>Amazon makes available new ARM-based systems relying on their Graviton 3 processors. These processors support advanced instructions called “SVE”. One very nice family of instructions to ‘compact’ values (effectively, remove unwanted values). I put it to good use <a href="https://lemire.me/blog/2022/07/14/filtering-numbers-faster-with-sve-on-amazon-graviton-3-processors/">when filtering out integer values from arrays</a>.</p>
<p>Unfortunately, the SVE compact instructions cannot be directly applied to the problem of pruning spaces in strings, because they only operate on larger words (e.g., 32-bit words). But, fortunately, it is possible to load bytes directly into 32-bit values so that each byte value occupies 32-bit in memory using intrinsics functions such as <tt>svld1sb_u32</tt>. As you would expect, you can also do the reverse, and take an array of 32-bit values, and automatically convert it to a byte array (e.g., using <tt>svst1b_u32</tt>).</p>
<p>Thus I can take my byte array (a string), load it into temporary 32-bit vectors, prune these vectors, and then store the result as a byte array, back to a string. The following C code is a reasonable implementation of this idea:</p>
<pre><span>size_t</span> sve_trimspaces<span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>,</span> <span>size_t</span> len<span>,</span> <span>char</span> <span>*</span>out<span>)</span> <span>{</span>
  uint8_t <span>*</span>out8 <span>=</span> reinterpret_cast<span>&lt;</span>uint8_t <span>*</span><span>&gt;</span><span>(</span>out<span>)</span><span>;</span>
<span>  size_t</span> i <span>=</span> <span>0</span><span>;</span>
<span>  for</span> <span>(</span><span>;</span> i <span>+</span> svcntw<span>(</span><span>)</span> <span>&lt;</span><span>=</span> len<span>;</span> i <span>+</span><span>=</span> svcntw<span>(</span><span>)</span><span>)</span> <span>{</span>
   svuint32_t input <span>=</span> svld1sb_u32<span>(</span>svptrue_b32<span>(</span><span>)</span><span>,</span> <span>(</span><span>const</span> int8_t <span>*</span><span>)</span>s <span>+</span> i<span>)</span><span>;</span>
   svbool_t matches <span>=</span> svcmpne_n_u32<span>(</span>svptrue_b32<span>(</span><span>)</span><span>,</span> input<span>,</span> <span>32</span><span>)</span><span>;</span>
   svuint32_t compressed <span>=</span> svcompact_u32<span>(</span>matches<span>,</span> input<span>)</span><span>;</span>
   svst1b_u32<span>(</span>svptrue_b32<span>(</span><span>)</span><span>,</span> out8<span>,</span> compressed<span>)</span><span>;</span>
   out8 <span>+</span><span>=</span> svcntp_b32<span>(</span>svptrue_b32<span>(</span><span>)</span><span>,</span> matches<span>)</span><span>;</span>
<span>  }</span>
<span>  if</span> <span>(</span>i <span>&lt;</span> len<span>)</span> <span>{</span>
   svbool_t read_mask <span>=</span> svwhilelt_b32<span>(</span>i<span>,</span> len<span>)</span><span>;</span>
   svuint32_t input <span>=</span> svld1sb_u32<span>(</span>read_mask<span>,</span> <span>(</span><span>const</span> int8_t <span>*</span><span>)</span>s <span>+</span> i<span>)</span><span>;</span>
   svbool_t matches <span>=</span> svcmpne_n_u32<span>(</span>read_mask<span>,</span> input<span>,</span> <span>32</span><span>)</span><span>;</span>
   svuint32_t compressed <span>=</span> svcompact_u32<span>(</span>matches<span>,</span> input<span>)</span><span>;</span>
   svst1b_u32<span>(</span>read_mask<span>,</span> out8<span>,</span> compressed<span>)</span><span>;</span>
   out8 <span>+</span><span>=</span> svcntp_b32<span>(</span>read_mask<span>,</span> matches<span>)</span><span>;</span>
<span>  }</span>
<span>  return</span> out8 <span>-</span> reinterpret_cast<span>&lt;</span>uint8_t <span>*</span><span>&gt;</span><span>(</span>out<span>)</span><span>;</span>
<span>}</span>

</pre>
<p>Is it faster? Using GCC 12 on a Graviton 3, I get that the SVE approach is 3.6 times faster and it uses 6 times fewer instructions. The SVE code is not six times faster, because it is retiring fewer instructions per cycle. <a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2023/03/10">My code is available.</a></p>
<table>
<tbody>
<tr>
<td>conventional code</td>
<td>1.8 cycles/bytes</td>
<td>7 instructions/byte</td>
</tr>
<tr>
<td>SVE code</td>
<td>0.5 cycles/bytes</td>
<td>1.1 instructions/byte</td>
</tr>
</tbody>
</table>
	</div></div>
  </body>
</html>
