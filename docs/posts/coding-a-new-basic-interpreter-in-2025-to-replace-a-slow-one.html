<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nanochess.org/ecs_basic.html">Original</a>
    <h1>Coding a new BASIC interpreter in 2025 to replace a slow one</h1>
    
    <div id="readability-page-1" class="page"><div>

<p><img src="https://nanochess.org/img/ecsbasic_1.jpg" width="50%" alt="Mattel Electronics Intellivision along the ECS running Jetsons"/></p><p>
Recently, I had the chance to get an Intellivision II console along the ECS (Entertainment Computer System) and keyboard. I found and typed a game <a href="http://spatula-city.org/~intvlib/inty/ecsbasic.html">Bomb Run 1</a>, using its integrated BASIC language, and I was pretty surprised to see <a href="https://forums.atariage.com/topic/384664-typing-basic-on-my-ecs/#findComment-5719486">how incredibly slow is it</a>.
</p>
<p>
Apparently, Mattel Electronics only <a href="https://history.blueskyrangers.com/hardware/ecs.html">developed the ECS</a> to avoid paying a daily penalty of $10,000 dollars to the USA government because they were advertising a keyboard component that wasn&#39;t yet available. They developed the ECS in secret, while putting all their money in the ill-fated Keyboard Component which was a full 6502 computer around the Intellivision with an officially licensed MS-Basic.
</p>
<p>
After getting the ECS on sale, Mattel forgot completely about it. It is a shame, because the keyboard is reasonable enough, it looks nice, and it could have been a nice starter BASIC platform.</p>
<p>
    Anyway, the turtle speed intrigued me as I was pretty convinced that the Intellivision processor could do faster floating-point, so why not write my own extended BASIC interpreter?
</p>
<p>
    For the remaining of this article, the original Mattel ECS BASIC will be simply called ECS BASIC.
</p>
<h2>System background</h2>
<p>
The implementation of my extended BASIC interpreter is for a General Instruments CP1610 processor. This is a 16-bit processor introduced in 1975, with a resemblance to the PDP-11. However, General Instruments didn&#39;t allowed second sources, only wanted big orders, and ignored small requests (basically shooting itself in the foot), and this processor was used widely only in the Mattel Intellivision, and it ceased production in 1985 at the same time of the Intellivision demise.
</p>
<div><p>
A full documentation of the instruction set is available along the jzintv emulator that can be downloaded from <a href="http://spatula-city.org/~im14u2c/intv/">http://spatula-city.org/~im14u2c/intv/</a>.</p></div>
<p>I&#39;ll be using the basic 8K words between $5000-$6fff for the BASIC language, and I&#39;ll ignore altogether the EXEC (the Intellivision BIOS) and the ECS ROMs (I didn&#39;t even bother disabling it).</p>
<p>
    I never coded a full BASIC language before, because it was not needed. In the eighties, I had access to a Z80 BASIC that was already ported to the homebrew computer I was using, and in the nineties, I managed to put floating-point in the <a href="https://nanochess.org/emulator.html">Li-Chen Wang&#39;s Tiny BASIC</a>, do some statement extensions for it, and also tried to do a tokenized BASIC, but I never went too far.
</p>
<h2>The floating-point core</h2>
<p>
I started in Sep/17/2025 by coding a floating-point addition subroutine. I didn&#39;t had a format in mind, it only had to be 32-bit because the CP1610 registers are 16-bit, so two registers fit nicely for keeping a floating-point number, and another two for the second operand.
</p>
<p>
The format was decided in the basis of how so easy was to extract the sign, exponent, and the mantissa with 16-bit operations, as 8-bit operations are difficult to do. This automatically discarded an IEEE-754 compatible format, and I settled for a format based on a 24-bit mantissa in the higher bits, followed by the sign bit, and the exponent in the lower 7 bits. The exponent is a bit smaller than the classic IEEE-754, but we get an extra precision bit.
</p>
<p>
    The code for extracting the mantissa is pretty short:
</p>
<pre><small>
    ANDI #$FF00,R1  ; Remove the sign and exponent.
    SETC
    RRC R0,1        ; Insert the top bit of the mantissa (fixed one)
    RRC R1,1        ; Now we have a 25-bit mantissa,
                    ; aligned at the higher bit.
</small></pre>
<p>
    I didn&#39;t define denormalized numbers, nor infinity and NaN (Not a Number), because this wasn&#39;t supported in the BASIC interpreters of the eighties.
</p>
<p>
    It was easy to get the subtraction routine once I got the addition subroutine working, because you only need to flip the sign bit in the second operand.
</p>
<p>
    I did later the multiplication routine, but I stumbled over a problem where sometimes the mantissa overflowed. I simply added a very complicated code to move the mantissa by one bit. It was several days later when I studied it, and I discovered you can only have a result of x+y-1 bits or x+y bits (where x is the number of significant bits in the first operand, and y is the number of significant bits in the second operand), and I could optimize it by simply inserting an extra zero bit at the left to account for the carry.
</p>
<p>
    Of course, I made a small test program to check for the validity of the arithmetic operations with several cases. It took me four days to code the fully functional floating-point library.
</p>
<h2>The interface</h2>
<p>
I couldn&#39;t start a BASIC interpreter without the keyboard reading code, and terminal-style output. Fortunately, Joe Zbiciak (intvnut) already had developed routines for reading the ECS keyboard, and I integrated these with a ROM header, adding along terminal handling for displaying letters, scrolling the screen, and moving the cursor. 
</p>
<p>
    With all this integrated I had a dumb terminal working, you type anything on the keyboard, and you get the same keys displayed on the screen. This was Sep/19/2025.
</p>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_2.jpg" width="80%" alt="The ECS keyboard, and the screen shows World Series Baseball"/></p></div>
<h2>Inner guts</h2>
<p>
    The CP1610 processor cannot address directly the internal memory in byte terms, instead everything is handled by full words. I had to take this in account for my tokenized BASIC representation. A standard Intellivision doesn&#39;t have enough memory for a BASIC interpreter, so the ECS BASIC included 2K of 8-bit RAM.
</p>
<p>
    However, a few years ago, the JLP-Flash cartridge was manufactured and it provides 8K of 16-bit RAM over $8000-$9fff, so for my extended BASIC this was excellent.
</p>
<p>
    When I talk about tokenization, I mean that all the language&#39;s reserved words are represented with a token. This speeds up the execution of the language, as it doesn&#39;t have to run a word match each time.
</p>
<p>
    My first version of the internal representation for BASIC lines was the line number as a word, followed by a pointer to the next line, followed by the tokenized BASIC code for the line, ended with a zero word.
</p>
<p>
    As I coded the line insertion routines in Sep/22/2025, I discovered the pointer to the next line wasn&#39;t a good idea, because it needed to move <i>every</i> pointer after a line insertion. Instead, I converted the pointer into a length (the number of words used by the tokenized line). This allowed for a very compact code to jump over lines:
</p>
<pre><small>
    INCR R4     : Jump over the line number.
    ADD@ R4,R4  ; Add the tokenized length to the current pointer
                ; Et voila! It jumped over the line.
</small></pre>
<p>
    With the line insertion routines completed, I went to implement the BASIC tokenization subroutine. I decided against handling tokenization byte-per-byte, and instead made each token a word. Of course, it is wasted space if you are using strings, but it is faster on execution. Token numbers start at $0100. It only remained to interface the input with the new routines.
</p>
<p>
    I decided to read the text directly from the screen, very unplanned, and probably buggy, but it has worked for the current time. And maybe later I&#39;ll extend it for a full-screen editor.
</p>
<pre><small>
keywords:
	DECLE &#34;:&#34;,0	; $0100
	DECLE &#34;LIST&#34;,0
	DECLE &#34;NEW&#34;,0
	DECLE &#34;CLS&#34;,0
	DECLE &#34;RUN&#34;,0	; $0104
	DECLE &#34;STOP&#34;,0
	DECLE &#34;PRINT&#34;,0
	DECLE &#34;INPUT&#34;,0
	DECLE &#34;GOTO&#34;,0	; $0108
	DECLE &#34;IF&#34;,0
	DECLE &#34;THEN&#34;,0
	DECLE &#34;ELSE&#34;,0
	DECLE &#34;FOR&#34;,0	; $010C
	DECLE &#34;TO&#34;,0
	DECLE &#34;STEP&#34;,0
	DECLE &#34;NEXT&#34;,0
	DECLE &#34;GOSUB&#34;,0	; $0110
</small></pre>
<p>Excerpt of the tokenization table.</p>
<h2>Execution</h2>
<div><p>
    Now I was able to edit, correct, and delete BASIC code lines. The next logical step was the execution of the program. I implemented </p><tt>RUN</tt><p> by reading each program line sequentially, and each token found choose directly the command to execute.
</p></div>
<div><p>
    My first program was simply </p><tt>10 CLS</tt><p> and I was happy when I typed </p><tt>RUN</tt><p> and the screen was cleared.
</p></div>
<div><p>
    This was followed shortly by </p><tt>PRINT</tt><p> and </p><tt>GOTO</tt><p>. Where </p><tt>PRINT</tt><p> was only capable of putting a string on the screen, and </p><tt>GOTO</tt><p> changed the execution flow. I added a check for the Esc key to exit an infinite loop.
</p></div>
<div><p>
    I was also pretty impatient to see if my extended BASIC language was speedier than the ECS BASIC, so I decided to implement </p><tt>IF</tt><p>, and a small expression parser supporting the relational operators, and the basic arithmetic operators (</p><tt>+</tt><p>, </p><tt>-</tt><p>, </p><tt>*</tt><p> and </p><tt>/</tt><p>), along numbers and variables.
</p></div>
<p>
    The numbers were simply read as integers and converted to floating-point format, while the variables used 26 double-word memory spaces covering the A to Z variables.
</p>
<p>
    In order to create a loop, it was required to implement variable assignment.
</p>
<pre><small>
    10 A=1
    20 PRINT &#34;Hello&#34;
    30 A=A+1
    40 IF 6&gt;A THEN 20
</small></pre>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_3.png" width="80%" alt="The tokenization of the BASIC program."/></p></div>
<p>
    For some reason, I couldn&#39;t type the less-than operator with the emulated ECS keyboard. Later, I discovered that intvnut missed the character in the Shift table, and it was a matter of a simple fix.
</p>
<p>It was past midnight when I finally could try the <a href="https://forums.atariage.com/topic/284474-ecs-basic-color-coding-patent/#comment-4145747">benchmark</a>. As I didn&#39;t had yet a <i>FOR</i> statement, I had to replicate it using increment and comparison.
</p>
<p>I ran it, and I was amazed when I discovered it took only 15 seconds. In the ECS BASIC it takes 210 seconds! There are screenshots of the programs in the git.
</p>
<h2>More floating-point curiosities</h2>
<p>
    This wasn&#39;t the first time I programmed a floating-point package. My first one was for a Z80-based computer, I don&#39;t remember if it was complete, if it had bugs, or if it was actually used. What I can remember is that I was never able to make a proper subroutine for displaying floating-point numbers. I got stuck with a simple conversion to integer, and printing the integer. 
</p>
<p>
    The display of a number followed by fraction and exponent, for me was closer to black magic than anything. I believed that a single routine did everything, but I was wrong. And I came to illumination by reading a Commodore 64 BASIC manual, it says something like numbers in this range are displayed complete, while in other cases the number will be displayed in exponent format.
</p>
<p>
    This triggered a pattern in my mind: If the whole integer fits in the mantissa, display it alongside a small fraction, and if the number doesn&#39;t fit, make it bigger or smaller so it fits in an integer, and this one can be displayed in exponent format.
</p>
<p>
    The algorithm is as follows:
</p>
<ol>
    <li>
        The 25-bit mantisa allows integers up from 0 to 33554431. We limit it to the biggest integer all nines, or 9999999.
    </li>
    <li>
        If the floating-point number is less than 10,000,000 then the integer part is displayed, and then it gets 2 fraction digits.
    </li>
    <li>
        If the floating-point number is less than 0.01 then it is multiplied until it reachs the range 1,000,000 - 9,999,999. The first digit will be the integer part, the following digits will be the fractional part, and the exponent will be displayed along.
    </li>
    <li>
        If the floating-point number is greater than 9,999,999 then it is divided by 10 until it fits the same range. And again display like in step 3.
    </li>
</ol>
<p>
    And this way, thirty years later, I discovered printing floating-point numbers isn&#39;t so obscure as I believed, but indeed it has a lot of magic.
</p>
<h2>Core completion</h2>
<div><p>
    The statements </p><tt>GOSUB/RETURN</tt><p> allow to create small subroutines, and these have their own stack to keep track of where to return (a pointer plus the line number)
</p></div>
<div><p>
The </p><tt>FOR/NEXT</tt><p> loop is one of the most known statements of the core BASIC language. Implementing this required a redesign of my execution loop, because I was doing it line-by-line, but the </p><tt>NEXT</tt><p> changed the line, but on the next statement it would lost track and get back to the line following the </p><tt>NEXT</tt><p>.
</p></div>
<div><p>
The loops also require their own stack, but including the counter variable address, a pointer to the </p><tt>TO</tt><p> expression, and a pointer to the </p><tt>STEP</tt><p> expression (5 words in total)
</p></div>
<div><p>
The </p><tt>RUN</tt><p> statement was replaced with a code that runs sequentially over the tokens, and jumps over the line headers. This way is easier to change the execution flow to a new token.
</p></div>
<div><p>
I also added the negation operator (required for </p><tt>STEP -1</tt><p>) and some functions like </p><tt>INT</tt><p>, </p><tt>ABS</tt><p>, </p><tt>SGN</tt><p>, and </p><tt>RND</tt><p>. The </p><tt>RND</tt><p> function in particular allows to create little games for guessing numbers, and so.
</p></div>
<div><p>
Checking against the ECS BASIC, I was only missing </p><tt>READ</tt><p>, </p><tt>DATA</tt><p>, and </p><tt>REM</tt><p>. So I bite the bullet to implement these. Adding along </p><tt>RESTORE</tt><p>.
</p></div>
<div>
<tt>DIM</tt><p> for creating arrays was pretty easy, and I adjusted all the variable access paths of the interpreter in a way that any indexed access is the same as accessing a normal variable.
</p></div>
<h2>Diverging ways</h2>
<p>
At this point, my extended BASIC language was already orders of magnitude faster than the ECS BASIC, and it could be used to write little text games (well, using only numbers)
</p>
<p>
However, it didn&#39;t handled yet the controllers, sound, graphics, and sprites. The ECS BASIC had some statements for it, but the sprites cannot be defined, and instead these had to be &#34;grabbed&#34; from a game cartridge. Of course, the user was limited to these game sprites. Also positioning sprites was done with multiple variable assignments in an array-like style of access.
</p>
<p>
For my extended BASIC I decided for a kind of advanced statements patterned after the ones from my <a href="https://nanochess.org/intybasic.html">compiled IntyBASIC language</a> but not exactly the same:
</p>
<ul>
    <li><tt>MODE 0,0</tt> for setting the color stack mode.</li>
    <li><tt>MODE 1</tt> for setting the foreground/background mode.</li>
    <li><tt>DEFINE 0,&#34;55AA55AA55AA55AA&#34;</tt> for defining GRAM cards.</li>
    <li><tt>COLOR</tt> for setting the paint color used in <tt>PRINT</tt>.</li>
    <li><tt>SPRITE</tt> for displaying a sprite on the screen.</li>
    <li><tt>WAIT</tt> for waiting the next video frame.</li>
    <li><tt>SOUND</tt> for accessing the sound chip.</li>
    <li><tt>STICK(0)</tt> for reading the 16 disc directions.</li>
    <li><tt>TRIG(0)</tt> for reading the side-buttons.</li>
    <li><tt>KEY(0)</tt> for reading the keypad.</li>
    <li><tt>BK(0-239)</tt> for accesing the screen.</li>
</ul>
<p>
Once these were implemented, I started coding a minimal game to test the interpreter, and I called it UFO Invasion. Of course, I found a few bugs in my interpreter and fixed them.
</p>
<p>
The game was working, and at a reasonable speed. What about testing in real hardware? I loaded the interpreter into a LTO-Flash cartridge and connected my ECS system.
</p>
<p>
My first attempt crashed continuously. I lost half an hour looking for errors, until I noticed <i>anything</i> crashed the interpreter. I had forgot to enable the extra RAM of the JLP cartridge. And finally it worked!
</p>
<p>
Typing the program was difficult, as the keyboard bounced a lot. This happens when you read too fast the keyboard, so fast you can see that effectively the key contact isn&#39;t perfect. I had to add a small wait before reading the keyboard, and it solved most of the problems.
</p>
<p>
    At the end, my extended BASIC interpreter was coded in six days! I think it is way faster when you are enjoying programming it.
</p>
<pre><small>10 CLS:REM UFO INVASION. NANOCHESS 2025
20 DEFINE 0,&#34;183C00FF007E3C000018183C3C7E7E000000183C3C3C3C7EFF2400&#34;
50 x=96:w=0:v=0:u=0:t=159
60 SPRITE 0,776+x,344,2061
70 SPRITE 1,776+v,256+w,2066
80 SPRITE 2,1796+t,256+u,6149
90 WAIT:c=STICK(0)
100 IF c&gt;=3 AND c&lt;=7 THEN IF x&lt;152 THEN x=x+4
110 IF c&gt;=11 AND c&lt;=15 THEN IF x&gt;0 THEN x=x-4
120 IF w=0 THEN SOUND 2,,0:IF STRIG(0) THEN v=x:w=88
130 t=t+5:IF t&gt;=160 THEN t=0:u=INT(RND*32)+8
140 IF w THEN SOUND 2,w+20,12:w=w-4:IF ABS(w-u)&lt;8 AND ABS(v-t)&lt;8 THEN
    t=164:w=0:SOUND 3,8000,9:SOUND 1,2048,48
150 GOTO 60
</small></pre>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_4.jpg" width="40%" alt="UFO Invasion running on the Mattel Intellivision ECS"/>
    <img src="https://nanochess.org/img/ecsbasic_5.jpg" width="40%" alt="Partial listing of UFO Invasion on the Mattel Intellivision ECS"/></p></div>
<h2>What&#39;s in the future</h2>
<p>
A big difference against &#34;standard&#34; BASIC is the lack of proper strings. In the ECS BASIC, you could read a string from the keyboard using GET, and put it again on the screen using PUT, but that was all.
</p>
<p>
Adding the support for standard strings would mean it could run some text-processing programs like Eliza in BASIC, and some other small games could be easily translated.
</p>
<p>
This was one of the portability things that the BASIC language had at the time, and it was used by many books in a way that the programs were written with that &#34;core&#34; BASIC language in mind, and these could be typed into almost any computer with a decent interpreter.
</p>
<p>
The source code is released at <a href="https://github.com/nanochess/ecsbasic">https://github.com/nanochess/ecsbasic</a>. I tried to release it so early as possible, so you can get a glance of how it was growing in the commits.
</p>
<div><p>
Enjoy it! <i>Did you like this article? <a href="https://ko-fi.com/nanochess">Invite me a coffee on ko-fi!</a></i>
</p></div>
<h2>But... why so slow?</h2>
<p>After publishing this article in Sep/28/2025, several people pointed to me that I didn&#39;t explained why the ECS BASIC was so slow. Truth to be told, I was so happy with my working extended BASIC that I didn&#39;t even bother to look more on the ECS BASIC.</p>
<p>First and all, there is a thread in Atariage about the <a href="https://forums.atariage.com/topic/284474-ecs-basic-color-coding-patent/">ECS BASIC Color Patent</a>, and the <a href="https://forums.atariage.com/topic/284474-ecs-basic-color-coding-patent/#findComment-4145393">eighth post</a> also by intvnut explains in great detail how he disassembled the code and found a terrible way of doing a shift of the floating-point accumulator.</p>
<p>However, there are a few other details that make it slow. For example, the extra RAM is 2K of <i>8 bits</i>, and all the Intellivision memory accesses are for 16 bits (one word), so every single access to variables requires the SDBD instruction. This instruction tells the CP1610 processor to read the word in two steps.</p>
<p>I did my own disassembly, and after giving a look around the same zone disassembled by intvnut, I found this code that extracts the exponent of a floating-point number:</p>
<pre><small>
 $E1DD: PSHR R5                                     
 $E1DE: MVI@ R1,R2                                  
 $E1DF: ANDI #$007F,R2                              
 $E1E1: MOVR R2,R5                                  
 $E1E2: ANDI #$0040,R5                              
 $E1E4: BNEQ $E1E8                                  
 $E1E6: NEGR R2                                     
 $E1E7: PULR R7                                     
 $E1E8: XORI #$0040,R2                              
 $E1EA: PULR R7                                     
</small></pre>
<p>It extracts the seven bits of the exponent. In the range $00-$3f makes it negative, and the range $40-$7f is converted to $00-$3f. So simply reading the exponent takes 7 instructions. Whoever developed this code didn&#39;t take in account that you could save the exponent in two&#39;s complement format offset by $40, and it is used nine times.</p>
<div><p>For comparison, my code for extracting the exponent is simply </p><tt>ANDI #$007F,R1</tt><p>.</p></div>
<p>It gets worst when I found the code calling $E1DD, and it is for extracting two exponents and doing a comparison between both:</p>
<pre><small>
 $E147: PSHR R5                                     
 $E148: MOVR R3,R1                                  
 $E149: JSR  R5,$E1DD                               
 $E14C: MOVR R2,R0                                  
 $E14D: MOVR R4,R1                                  
 $E14E: JSR  R5,$E1DD                               
 $E151: CMPR R0,R2                                  
 $E152: BEQ  $E159                                  
 $E154: BMI  $E15B                                  
 $E156: MVII #$0001,R0                              
 $E158: PULR R7                                     
 $E159: CLRR R0                                     
 $E15A: PULR R7                                     
 $E15B: CLRR R0                                     
 $E15C: DECR R0                                     
 $E15D: PULR R7                                     
</small></pre>
<p>My code for exponent comparison is composed of only three instructions (two AND and one CMPR) This big code would be kind of reasonable if it wasn&#39;t for the fact that it is only called <i>one time</i>, and it is by the floating-point addition subroutine starting at $E059:</p>
<pre><small>
 $E067: CLRR R0                                     
 $E068: SDBD                                        
 $E069: MVII #$47D4,R3                              
 $E06C: MOVR R3,R4                                  
 $E06D: SUBI #$0007,R4                              
 $E06F: JSR  R5,$E147                               
 $E072: TSTR R0                                     
 $E073: BEQ  $E081                                  
 $E075: MOVR R4,R1                                  
 $E076: TSTR R0                                     
 $E077: BMI  $E07B                                  
 $E079: ADDI #$0007,R1                              
 $E07B: CLRR R0                                     
 $E07C: JSR  R5,$E15E                               
 $E07F: B    $E067                                  
</small></pre>
<p>This routine calls the exponent comparison at $E06F, and if both are equal it jumps out to $E081, else it adjusts the exponent of one number, and <i>repeats</i> the comparison (notice the B $E067 instruction) The mantissa shifting routine at $E15E operates shifting in steps of 4 bits.</p>
<p>At $E081 (not shown), it checks the sign of the second operand, and if it is negative, it calls $E194 to do a negation of the number.</p>
<p>At $E091 it does the addition of the two numbers calling $E1C0, and calls $E183 to check if both signs are equal.</p>
<p>The code at $E0A4 reinserts the exponent in a very slow way, and it ends by calling $E21A to normalize the floating-point number, again shifting the mantissa in steps of 4 bits.</p>
<p>It has been just too much code yet, but let&#39;s look at the shifting routine:</p>
<pre><small>
 $E238: MVI@ R1,R2                                  
 $E239: MOVR R2,R5                                  
 $E23A: ANDI #$000F,R2                              
 $E23C: SLL  R2,2                                   
 $E23D: SLL  R2,2                                   
 $E23E: XORR R4,R2                                  
 $E23F: MVO@ R2,R1                                  
 $E240: MOVR R5,R2                                  
 $E241: ANDI #$00F0,R2                              
 $E243: SLR  R2,2                                   
 $E244: SLR  R2,2                                   
 $E245: MOVR R2,R4                                  
 $E246: DECR R1                                     
 $E247: SDBD                                        
 $E248: CMPI #$47CD,R1                              
 $E24B: BNEQ $E238                                  
</small></pre>
<p>It takes a byte, shifts it left 4 bits, inserts the carry, and copies the extra 4 bits as the new carry. I couldn&#39;t resist showing how it could be made a lot smaller and faster this way:</p>
<pre><small>
LE238:
    MVI@ R1,R2  ; R2 = 0x00ff
    SLL R2,2
    SLL R2,2    ; R2 = 0x0ff0
    XORR R4,R2  ; R2 = 0x0ff0 + carry
    MVO@ R2,R1  ; This saves the low byte.
    SWAP R2     ; R2 = 0xf00f
    ANDI #$000F,R2
    MOVR R2,R4  ; R4 = 0x000f
    DECR R1
    SDBD
    CMPI #$47CD,R1
    BNEQ LE238
</small></pre>
<p>This saves four instructions in the loop, and it is faster.</p>
<p>The ECS BASIC has a mantissa of six bytes, so it has more precision than my extended BASIC (three bytes), but it is done in a very slow way!</p>
<p>For sure the ECS BASIC could be optimized to run at least two times faster.</p>
<h2>Exact cycles</h2>
<p>Ok, but I haven&#39;t yet answered a simple question. How many cycles takes adding 3.0 and 7.0?</p>
<p>I ran the jzintv emulator with this command line (remember we need a game cartridge so the ECS BASIC works):</p>
<pre><small>./jzintv -d -s1 -z3 Basketball.bin</small></pre>
<p>I entered the R command to make it run the ECS BASIC. When I reached the ECS BASIC, I typed PRIN 3+7 and before pressing Enter, I went to the debugger window and pressed Ctrl+C. Then I put breakpoints at selected places (start of the floating-point addition, the place where it calls the addition, and the return instruction):</p>
<pre><small>B E060
B E091
B E0BA</small></pre>
<p>Again, I typed the R command, using along M47C0 to watch the memory addresses where floating-point addition happened until I saw the numbers 3 and 7.</p>
<p>I took note of the cycle number at the right. The operation 3+7 takes exactly 1558 cycles. By the way, the interpreter executes further three floating point additions when processing the numbers, and another two for displaying the number.</p>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_6.png" width="80%" alt="jzintv debug window with the ECS BASIC"/></p></div>
<p>Now, let&#39;s do the same with my extended BASIC interpreter.</p>
<p>After assembling with as1600, I generate a .lst file where I searched for the <i>fpadd</i> label (start) and <i>fpadd.2</i> label (return) The addresses are $61d1 and $625b.</p>
<p>I ran again the jzintv emulator with the debugging option, and I typed PRINT 3+7, and before pressing Enter, I stopped the debugger using Ctrl+C, and I setup these breakpoints:</p>
<pre><small>B 61D1
B 625B</small></pre>
<p>Then I entered the command R, and pressed Enter on the BASIC screen. It took me four R commands to see the values 3 and 7 in the registers, and the result 10.</p>
<p>And the total cycles used were 479. This means that only in the floating-point addition the Mattel ECS BASIC is five times slower.</p>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_7.png" width="80%" alt="jzintv debug window with my extended ECS BASIC"/></p></div>
<h2>Related links</h2>
<ul>
    <li><a href="https://forums.atariage.com/topic/384664-typing-basic-on-my-ecs/">Typing BASIC on my ECS</a>. The original thread where I posted my experiences typing a game on the ECS, and later started posting about my BASIC interpreter.</li>
    <li><a href="https://nanochess.org/intybasic.html">The IntyBASIC cross-compiler</a>.</li>
    <li><a href="https://history.blueskyrangers.com/hardware/ecs.html">The history of the ECS</a> from the people who developed it.</li>
</ul>
<p>Last modified: Sep/29/2025</p>
</div></div>
  </body>
</html>
