<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gavinhoward.com/2024/09/rewriting-rust-a-response/">Original</a>
    <h1>Rewriting Rust: A Response</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><a href="https://v4.chriskrycho.com/2018/assumed-audiences.html"><strong>Assumed Audience</strong></a>: Hackers, Rustaceans, and anyone interested in
programming language design.</p><p><a href="https://v5.chriskrycho.com/journal/epistemic-status/"><strong>Epistemic Status</strong></a>: Quite confident. The ideas are partially
implemented and working.</p></div><p><strong>This post is partially an ad!</strong></p><h2 id="introduction">Introduction</h2><p><a href="https://josephg.com/blog/"><code>josephg</code></a> wrote a <a href="https://josephg.com/blog/rewriting-rust/">post about what he’d like to see in future Rust</a>, or
another programming language following Rust.</p><p>Unbeknownst to <code>josephg</code>, that language is coming into existence <em>right now!</em> It
is called <a href="https://git.yzena.com/Yzena/Yc/src/branch/master/docs/yao">Yao</a>.</p><p>I already wrote about <a href="https://gavinhoward.com/2024/05/what-rust-got-wrong-on-formal-verification/">what else Rust got wrong</a>, but let’s go over the
features <code>josephg</code> wants and see how Yao stacks up.</p><p>Before I do, in order to avoid misunderstandings, I must admit that <em><strong>I am not
completely certain that these ideas are possible.</strong></em> More on that later.</p><h2 id="function-traits-effects">Function Traits (Effects)</h2><p>I briefly mentioned function traits <a href="https://gavinhoward.com/2024/05/what-rust-got-wrong-on-formal-verification/#the-good">here</a>, but I should expand on them.</p><p>First of all, function traits require <a href="https://gavinhoward.com/2024/05/what-rust-got-wrong-on-formal-verification/#the-solution">Restricted Structured Concurrency
(RSC)</a>, so if you’re looking for a catch, that is one of them.</p><p>The second catch is that every function trait needs to be <em>restrictive</em>. For
example, <code>pure</code> is a restrictive trait because it restricts the function from
having side effects. On the other hand, <code>async</code> is <em>not</em> restrictive; it
actually allows the function to do <em>more</em>.</p><p>Why does this matter? Because a function <em>without</em> <code>pure</code> will <em>always</em> be able
to call a function with it, while a function <em>without</em> <code>async</code> cannot just call
a function with it.</p><p>This is actually the root of the function color problem: <code>async</code> is exactly
backwards! Instead of marking asynchronous functions, languages should have had
us mark <em>synchronous</em> functions, and then <code>async</code> should have been the default!</p><p>Although that wouldn’t remove the possibility of bugs when calling a blocking
function in <code>async</code> code, which is the <em>real</em> reason I hate <code>async</code>.</p><p>Anyway, Yao’s function traits will always be restrictive, and that’s what will
make them scale better than Rust’s while avoiding much of the problems because
by default, functions will be able to do anything.</p><h3 id="global-context">Global Context</h3><p>But RSC gives so much more than just function traits: it can make it possible to
safely handle <strong>global context</strong>.</p><p>An example: on both POSIX and Windows, there is a bit of global context called
the “current working directory.” On all platforms, it’s global context, and it
can be changed at any time. This can easily lead to problems, especially in
multi-threaded code.</p><p>However, Yao code can have multiple current working directories. In fact, each
thread can have its own!</p><p>To demonstrate this, you can do this:</p><pre tabindex="0"><code>$ git clone https://git.yzena.com/Yzena/Yc.git
$ cd Yc
$ make
&lt;...&gt;
BOOTSTRAP OK
$ ./release/yc yao tests/yao/cd.yao
/home/gavin/Downloads/Yc
test.txt DOES NOT EXIST
/home/gavin/Downloads/Yc/test1
test.txt DOES NOT EXIST
/home/gavin/Downloads/Yc/test1/test2
test.txt EXISTS
/home/gavin/Downloads/Yc/test1
test.txt DOES NOT EXIST
/home/gavin/Downloads/Yc
</code></pre><p>That clones <a href="https://git.yzena.com/Yzena/Yc">this repo</a>, bootstraps Yao and its build system, then runs Yao
on <a href="https://git.yzena.com/Yzena/Yc/src/branch/master/tests/yao/cd.yao">this file</a>, which uses the <code>pwd</code> command to demonstrate that the current
working directory is, in fact, being changed. Also, notice that the file
existence check is relative to the CWD; it only succeeds when the CWD is
<code>test1/test2</code>, so path operations are relative to the CWD Yao sets.</p><p>And in none of this is Yao setting the global CWD; in fact, <em>none</em> of my code
changes that global CWD. Yao is written to use its own CWD rather than the
global CWD.</p><p>Now, this doesn’t demonstrate separate threads having the same capability, but
that’s only because I haven’t implemented thread spawning in Yao yet. But the
same capability exists <a href="https://git.yzena.com/Yzena/Yc/src/commit/9d353ac6ac5a9/include/yc/io.h#L1302-L1323">in my C code</a>, which <a href="https://git.yzena.com/Yzena/Yc/src/commit/9d353ac6ac5a9/src/concurrency/ctxts.c#L405-L519">can span threads</a>.</p><p>This uses something called “context stacks,” a concept I stole from <a href="https://www.youtube.com/watch?v=TH9VCN6UkyQ&amp;list=PLmV5I2fxaiCKfxMBrNsU1kgKJXD3PkyxO">Jonathan
Blow and his language, Jai</a>. The “current working directory” is just the
directory on the top of the CWD context stack for the thread.</p><p>But what if the thread doesn’t have one? Well, it is the directory that was on
top of the <em>parent thread’s</em> CWD context stack when the child thread was
created, and so on, recursively to the root thread.</p><p>When combined with RSC, context stacks are enormously powerful and incredibly
safe! I know that a CWD that is pushed onto a parent’s context stack before a
child thread is created will always be on the stack for the entire lifetime of
the child.</p><p>Another example: environments. The <code>environ</code> variable, as well as <code>getenv</code> and
<code>setenv</code>, are the <a href="https://rachelbythebay.com/w/2017/01/30/env/">source of</a> <a href="https://rachelbythebay.com/w/2023/10/16/env/">many footguns</a>.</p><p>In Yao, environments are just another context stack:</p><pre tabindex="0"><code>$ ./release/yc yao tests/yao/env.yao
------------------
------------------
BC_ENV_ARGS=-l
BC_LINE_LENGTH=64
------------------
BC_ENV_ARGS=-l
++++++++++++++++++
BC_ENV_ARGS: -l
------------------
BC_ENV_ARGS=-l
BC_LINE_LENGTH=64
------------------
------------------
BC_ENV_ARGS=-l
BC_LINE_LENGTH=64
------------------
BC_ENV_ARGS: -l
BC_LINE_LENGTH: 64
</code></pre><p>That uses Yao to run <a href="https://git.yzena.com/Yzena/Yc/src/branch/master/tests/yao/env.yao">this file</a>, which uses <code>env</code> to demonstrate that the
environment is changed for child processes. It also grabs an environment
variable with the equivalent of <code>getenv()</code> (<code>env.env</code> in the script) to
demonstrate that yes, you can still grab individual environment variables.</p><p>You can set whatever you want in the environment before you run that, and it
doesn’t matter: the output will be exactly the same (barring any bugs).</p><h3 id="automatic-memory-management-without-gc">Automatic Memory Management Without GC</h3><p>Another thing that I think RSC gives us, when combined with <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">scope-based
resource management</a>, is fully automatic memory management without a garbage
collector.</p><p>Rust has already proven that this is possible, and I believe, but I’m not
completely sure, that RSC would make it easier to reason about.</p><p>Regardless, Yao as currently implemented has no leaks. You can run Yao on both
of those scripts above and under Valgrind to check:</p><pre tabindex="0"><code>$ ./release/yc rig -Dvalgrind=1
$ valgrind ./build/yc yao tests/yao/env.yao
$ valgrind ./build/yc yao tests/yao/cd.yao
</code></pre><h2 id="compile-time-capabilities">Compile-Time Capabilities</h2><p>Next, <code>josephg</code> wants compile-time capabilities.</p><p>Yao already has them. In fact, it not only has them for functions, but it has
them for <strong>keywords</strong>, which are Yao’s equivalent of macros.</p><p>To demonstrate this, run this:</p><pre tabindex="0"><code>$ ./release/yc yao tools/rig_slam.yao
Panic: Unimplemented
    Source:    /home/gavin/Downloads/Yc/src/yao/keywords.c:2105
    Function:  yao_parse_while()

Illegal instruction
</code></pre><p>That panic happens because it is trying to parse the <code>while</code> loop in <a href="https://langdev.stackexchange.com/questions/32/how-can-i-check-if-a-new-language-is-turing-complete/146#146">this
file</a>, and I haven’t implemented parsing <code>while</code> loops yet.</p><p>However, say you want to restrict a Yao script; you want to make sure it can’t
be fully Turing-complete. And you don’t trust the author because he’s in the
cubicle next to yours, and you know he’s dumb.</p><p>Yao has a builtin mode that makes the language non-Turing-complete, which
removes a lot of stuff. One of those things is <code>while</code>, which <a href="https://langdev.stackexchange.com/questions/32/how-can-i-check-if-a-new-language-is-turing-complete/146#146">makes things
Turing-complete</a>.</p><p>So you could tell Yao to use the <code>iterative</code> language mode, which enables
restricted loops, but not unrestricted loops like <code>while</code>:</p><pre tabindex="0"><code>$ ./release/yc yao --lang-mode=iterative tools/rig_slam.yao
yc: tools/rig_slam.yao[146:2]
    Parse error: Incomplete variable declaration for name: while

yc: tools/rig_slam.yao[146:8]
    Invalid token: Expected semicolon (&#39;;&#39;)


Panic: Unimplemented
    Source:    /home/gavin/Downloads/Yc/src/yao/keywords.c:1753
    Function:  yao_parse_if()

Illegal instruction
</code></pre><p>Another unimplemented panic, but notice that it’s different: Yao tried to parse
<code>while</code> as a plain name! It’s as though it didn’t even exist!</p><p>So yeah, Yao has compile-time capabilities <em>right now!</em> It does it by simply not
even importing the definition of things that are restricted, which means that
the restricted code can’t access it, no matter what.</p><p>It’s fine-grained too; <code>while</code> is gone, but <code>if</code> is not; that’s where the panic
happened! And yes, this shows that it applies to “builtin” keywords too, not
just user-defined ones. It can also apply to functions, packages, types, and
context stacks!</p><p>Although it is only implemented on keywords and packages at the moment.</p><h3 id="runtime-capabilities">Runtime Capabilities</h3><p>But if Yao has compile-time capabilities on context stacks, it can prevent code
from accessing certain context stacks. What if we used that to go a step further
and use context stacks to implement <strong>runtime capabilities</strong>?</p><p>Take the CWD context stack for example. We could use something like it, along
with <code>RESOLVE_BENEATH</code> on Linux and <code>O_RESOLVE_BENEATH</code> on FreeBSD, to implement
<a href="https://val.packett.cool/blog/use-openat/">filesystem capabilities at runtime</a>.</p><p>What if your program <code>foo</code> started with <code>/</code> as an open directory on a context
stack? Then, your setup code could use that directory to <code>openat()</code> on
<code>/etc/foo</code> and <code>/home/$USER/.config/foo</code>, and push both of those open
directories onto the context stack.</p><p>Then you call a dependency that you don’t trust; you didn’t give it access to
that directory context stack, so it can’t change them. Perhaps it does open
files, but since it has to use the standard library to do that, and the standard
library <em>does</em> have access to that context stack, it can read the top of the
context stack and try to open a file in either <code>/etc/foo</code> or
<code>/home/$USER/.config/foo</code>. Since it is using <code>{O_}RESOLVE_BENEATH</code>, it can
<em>only</em> open files in those two locations.</p><p>This means that the untrusted dependency can only open files in the config
directories of your <code>foo</code> program; it can’t steal your SSH keys or your crypto
wallet. And it certainly can’t encrypt your whole drive and demand a ransom.</p><p>And the best part? Because those directories are <em>open</em> directories, <code>foo</code>
avoids <a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">TOCTTOU bugs</a> on directory operations.</p><p>These RSC- and context stack-based runtime capabilities are enormously powerful!
You can imagine one for restricting what external commands a dependency can run
(only a set of C compilers, for example), or what domain names can be resolved.
Or even what IP addresses to connect to.</p><h3 id="distribution">Distribution</h3><p>Unfortunately, there is a cost to such awesomeness: Yao can’t be compiled in the
traditional way.</p><p>Instead, Yao will be compiled to an LLVM-like IR (which <a href="https://git.yzena.com/Yzena/Yc/src/branch/master/docs/yvm">already exists</a>),
and that’s how it will be distributed. Users will have to do the final compile
step on their local machines.</p><p>However, there is a nice side effect: Yao will avoid the stupid-long link times
that traditional object files suffer from.</p><h2 id="pin-move-and-struct-borrows">Pin, Move, and Struct Borrows</h2><p>I agree with <code>josephg</code> that Pin is complicated.</p><p>Yao will have the same problems, but unlike Rust, there will be another way to
avoid <code>Box</code>: since Yao uses RSC, anything allocated on the stack before child
threads are created can be safely passed to those child threads.</p><p>And lest you think that that could easily blow out the stack, Yao actually has a
shadow stack on the heap that is capable of allocations of any size.</p><p>In like manner, struct fields can be borrowed by child threads with smaller
lifetimes. Easy as pie.</p><p>Okay, not completely easy, but easier than Rust!</p><h2 id="comptime">Comptime</h2><p>I wish I had code to demonstrate this, but I haven’t gotten there yet.</p><p>But Yao will have comptime!</p><p>Unlike Zig, its comptime will <em>not</em> be lazy.</p><p>First, some background: one of my first design decisions is that Yao will use
<a href="https://en.wikipedia.org/wiki/Currying">currying</a>. It will look like this:</p><pre tabindex="0"><code>fn curried(n: num) -&gt; (s: str) -&gt; bool
{
    // stuff
}
</code></pre><p>This is actually how Yao will implement <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a> because <a href="https://peps.python.org/pep-0020/">explicit is
better than implicit</a>:</p><pre tabindex="0"><code>n: num = 1;
curried(n);
</code></pre><p>Anyway, I have always loved the idea of Zig, but hated the execution! I have
written Haskell, and I <em>can</em> think in lazy languages, but I don’t like it.</p><p>So what if I just used currying to have comptime? Comptime callable code can be
marked with a <code>#</code> (like C’s preprocessor), so it would look like this:</p><pre tabindex="0"><code>fn comp#(n: num) -&gt; (s: str) -&gt; bool
{
    // stuff
}
</code></pre><p>Then you can call <code>comp#(n)</code> at compile time and get back a compile-time
constant function. This is how Yao will implement generic functions.</p><p>With the addition that comptime functions can take and return types, Yao will
get generic types too:</p><pre tabindex="0"><code>fn vec#(t: type) -&gt; type
{
    return struct {
        array: ^t;
        len: usize;
    };
}
</code></pre><p>I will also add <code>pure</code> as a function trait for zero side effects, as well as
<code>total</code> for functions that are not Turing-complete (guaranteed to halt). If
comptime functions are required to be <code>pure</code> and <code>total</code>, then even though Yao’s
type system will be powerful, <a href="https://3fx.ch/typing-is-hard.html">it won’t be Turing-complete</a>!</p><h2 id="conclusion">Conclusion</h2><p>If all of that is sounding too good to be true, it kind of is.</p><p>See, while I <em>have</em> succeeded in implementing <em>some</em> of Yao’s design, I haven’t
implemented <em>all</em> of it. So <a href="https://justinas.org/the-bizarre-world-of-v">unlike the V creator</a>, I’m going to be very
honest, clear, and precise: <em><strong>I do not know if Yao’s design is even possible to
implement!</strong></em></p><p>I do have some evidence that it <em>is</em> possible, and I do have some demos, but I
do not know for sure!</p><p>In addition, while there is some <a href="https://gavinhoward.com/2024/05/what-rust-got-wrong-on-formal-verification/#the-good">good</a> about RSC and Yao, there is some
<a href="https://gavinhoward.com/2024/05/what-rust-got-wrong-on-formal-verification/#the-bad">bad</a> and <a href="https://gavinhoward.com/2024/05/what-rust-got-wrong-on-formal-verification/#the-ugly">ugly</a> to them as well.</p><p>If Yao works, will it even be worth it with those disadvantages?</p><p>Of course, I do think so, but every programmer needs to make that decision
personally. It could be that most, or all, just don’t think Yao is worth it.</p><p>And I need to be fine with that.</p><hr/><p>Oh, and if you’re worried about the license on the repo, I expressly give any
reader permission to use that code to run the demonstrations in this post. Also,
I would like to remove the SSPL and move to an <a href="https://yzena.com/yzena-viral-license/">AGPL-like license</a>, but I
need lawyer money first.</p></div></div>
  </body>
</html>
