<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.standardnotes.com/40921/no-react-native-is-not-the-future">Original</a>
    <h1>React Native is not the future</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Standard Notes has seen its codebase evolve many times through the years. When we first launched in late 2016, we started with <strong>three</strong> codebases: our web app (which our Electron desktop app contained), a native Swift iOS app, and a native Kotlin Android app. This was immediately untenable. Coordinating bug fixes across three platforms was hard enough, but building new features? Out of the question. We had to call our app &#34;simple&#34; because we literally couldn&#39;t make it anything else. (Tongue-in-cheek, but there&#39;s probably some truth to it.)</p>

<h2>From Three to Two Codebases</h2>

<p>In 2017 we transitioned to React Native for our mobile app, cutting down our total number of codebases to two. This felt like <a href="https://mough.xyz/235/i-ve-seen-heaven-and-it-s-written-in-javascript" rel="noopener nofollow" target="_blank">heaven</a>, for a time. Now whenever we wanted to introduce a new feature, like encrypted images and files, we would need to write it &#34;only&#34; two times—wonderful, right? Not so. Sure, maximize your use of libraries and ensure you&#39;re not writing critical business logic twice. At some point however we reached the limit of that approach, having to write low-level streaming encryption functions in C because our web encryption library was not reusable on mobile.</p>

<p>But even assuming you&#39;ve maximized your business logic DRYness, orchestrating new UI features for two codebases with a small team is still a doubling of effort. Our mobile and web platforms had different issues and worked on different timelines. A bug that existed on mobile but not web which required two days to fix meant that web and mobile were constantly on different wavelengths. To get the web and mobile teams to sync up on new features was a constant struggle. Building on web was also typically much faster than mobile, so mobile was always behind. The result was that neither web nor mobile saw any notable momentum of new features.</p>

<p>There is also no practical way to build on React Native without using a metric ton of third party libraries. Packages for React Native are their own special breed of monstrosity because the package author would be the one writing code twice: once for iOS and once for Android (and of course the JavaScript wrapper). The result is a drastic increase in library abandonment and stability issues. In addition, keeping your packages in sync with the latest version of React Native (which is notoriously difficult to keep up to date) was a nightmare of its own.</p>

<p>At some point we had seen enough. Two codebases—that&#39;s one too many for us. We started having dreams of being able to write code only once. Imagine how fast we could ship. Imagine the concentration of quality and focus into one place. Imagine not having to treat mobile like an afterthought anymore. Imagine dreaming of a feature and not being let down because &#34;Ah, right! We have to build this for mobile too,&#34; and then abandoning the feature altogether due to the impracticality of doubling the effort. A single-codebase’s feature is effort enough.</p>

<h2>One Codebase</h2>

<p>When we finished the transition from two to one, we asked ourselves why we hadn&#39;t done it sooner. Today, Standard Notes is just one codebase. Our mobile app is just our web app with access to native mobile functionality, and it runs much better than we could have imagined. It sports 1:1 feature parity with our desktop app, a feat impossible with our old setup. It accesses the native mobile keychain, biometrics, local storage, camera, and more. </p>

<p><img src="https://standard-notes.s3.amazonaws.com/blog/Mobile-App-Collage.png" alt="Mobile app collage"/></p>

<h2>Removing the React from React Native</h2>

<p>Our migration was quite simple really, and consists primarily of a bridge between web-land and mobile native-land. Our new mobile app still uses React Native, but is only a single component: a function that renders a webview. The webview facilitates message passing between web-land and native-land through a postMessage bridge. When web-land wants to access the device keychain, it sends a message to native-land, and native-land responds with a primitive value.</p>

<p>Neither native-land or web-land ever have to think about &#34;messages&#34; though. They&#39;re just function calls. Web-land has doesn’t know that its function calls are being converted to postMessage calls behind the scenes. Web is also using <code>await</code> for a response just like it would any other async function. This is not meant to be a technical post, but at a high level, our architecture consists of each platform simply having to provide a DeviceInterface class to an Application instance, and with that interface, an application can run on any platform, even say a command line. The device interface provides access to device APIs, like the database, keychain, or camera.</p>

<h2>A practical way to build mobile</h2>

<p>Don&#39;t get me wrong: there&#39;s a lot to love about React Native. Its community and package ecosystem are vibrant, probably more so than many competing ecosystems. But if too you&#39;re finding that two codebases is one too many for your small team, there is a way out. You don&#39;t have to rewrite your web application UI from scratch into React Native. Instead, you can use RN as the bridge to access native system functionality from your web app core. In our case, our new mobile app is, in our estimation, many times better than our old, perpetually tailing semi-native app. <a href="https://standardnotes.com/" rel="noopener nofollow" target="_blank">Try it</a> for yourself.</p>

<p>If you&#39;re starting today, you can take a similar approach to ours, or take a look at libraries like <a href="https://capacitorjs.com/" rel="noopener nofollow" target="_blank">Capacitor</a> which do something very similar, with the downsides of not having the same rich third-party package ecosystem as React Native.</p>
</div></div></div>
  </body>
</html>
