<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pwy.io/posts/kruci-post-mortem/">Original</a>
    <h1>Kruci: Post-mortem of a UI library</h1>
    
    <div id="readability-page-1" class="page"><div id="post">
        

        <p>
          I love doing
          <a href="https://codeberg.org/pwy/ostfs">experiments</a> -
          <a href="https://codeberg.org/pwy/strolle">side projects</a> to my
          <a href="https://codeberg.org/pwy/doome">side projects</a>,
          <a href="https://codeberg.org/pwy/nonogram-solver">for fun</a> or
          <a href="https://codeberg.org/pwy/lxd-snapper">out of necessity</a>.
        </p>

        <p>
          Sometimes those experiments and end up in
          <a href="https://codeberg.org/pwy/linez">something useful</a>, other
          times - not so much. Let me tell you about one of the latter projects
          - about terminals, user interfaces, and trade-offs.
        </p>

        

        <ul>
          <li>&gt; <a href="#water"> Water </a></li>
          <li>&gt; <a href="#waste"> Waste </a></li>
          <li>&gt; <a href="#wager"> Wager </a></li>
          <li>&gt; <a href="#wisdom"> Wisdom </a></li>
          <li>&gt; <a href="#wisdom-widgets"> Wisdom - Widgets </a></li>
          <li>&gt; <a href="#wisdom-layouts"> Wisdom - Layouts </a></li>
          <li>&gt; <a href="#summary"> Summary </a></li>
        </ul>

        <h2 id="water"><a href="#water"> Water </a></h2>

        <p>
          My programming spare time is dedicated mostly towards
          <a href="https://codeberg.org/pwy/kartoffels">kartoffels</a>, a game
          of mine where you&#39;re implementing firmwares for tiny robots:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/intro.png"/>

          <figcaption>Main menu of the upcoming kartoffels v0.8.</figcaption>
        </figure>

        <p>
          For the next version I&#39;ve started to work on a new challenge, a map
          where your bot is stranded on an island - as the player, you have to
          implement a bot that collects some nearby rocks and arranges them into
          a <code>HELP ME</code> text:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/stranded-island.png"/>

          <figcaption>
            An island in the middle of an ocean -- if only you squeeze your eyes
            a bit and assume that the gray dots are, in fact, sand; this is
            work-in-progress, so you have to picture rocks as well.
          </figcaption>
        </figure>

        <p>
          Since ocean is rarely stationary, I thought it&#39;d be nice to add waves
          as a visual gimmick - inspired by
          <a href="https://www.shadertoy.com/view/MdXyzX">a shader</a>, I went
          with:
        </p>

        <figure>
          <video src="/posts/kruci-post-mortem/assets/stranded-island.webm" controls=""></video>

          <figcaption>Waves, slowly waving around.</figcaption>
        </figure>

        <p>
          ... then I ran <code>htop</code> and saw that <i>damn</i>, those wave
          calculations are heavy!
        </p>

        <p>
          For each ocean tile you have to calculate a couple of sines and
          exponentials - it&#39;s not the end of the world for a modern CPU, but it
          does become problematic in my case, because the game is rendered
          entirely on the server, players are just SSH terminals.
        </p>

        <p>
          So it&#39;s actually a couple of sines and exponentials for each pixel,
          for each frame, for each player.
        </p>

        <p>
          Fortunately, eyes can be easily fooled. Even though the ocean seems
          alive, it&#39;s not like the entire ocean changes between every two
          consecutive frames - so, intuitively, we shouldn&#39;t be forced to
          recalculate everything from scratch all the time.
        </p>

        <p>
          This is not a novel thought - games have been amortizing calculations
          across frames for years now,
          <a href="https://research.nvidia.com/publication/2021-06_restir-gi-path-resampling-real-time-path-tracing">for better</a>
          or <a href="https://www.reddit.com/r/FuckTAA/">for worse</a>.
        </p>

        <p>
          Eventually I&#39;ve been able to get an acceptable frame time by keeping a
          buffer that&#39;s updated both less frequently than the main frame rate
          and merely stochastically - and this got me thinking:
        </p>

        <p>Are there any other places where I&#39;m wasting CPU cycles?</p>

        <h2 id="waste"><a href="#waste"> Waste </a></h2>

        <p>
          kartoffels delegates drawing to
          <a href="https://github.com/ratatui/ratatui">Ratatui</a>, a Rust crate
          for building terminal user interfaces. It works in
          <a href="https://en.wikipedia.org/wiki/Immediate_mode_(computer_graphics)">immediate mode</a>, which means that every frame you&#39;re supposed to draw everything you
          want to see on the screen, always from scratch:
        </p>

        

        <div>
          <pre><span></span><span>fn</span><span> </span><span>run</span><span>(</span><span>terminal</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>DefaultTerminal</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>terminal</span><span>.</span><span>draw</span><span>(</span><span>render</span><span>)</span><span>?</span><span>;</span>

<span>        </span><span>if</span><span> </span><span>should_quit</span><span>()</span><span>?</span><span> </span><span>{</span>
<span>            </span><span>break</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>Ok</span><span>(())</span>
<span>}</span>

<span>// Always starts with an empty frame</span>
<span>fn</span><span> </span><span>render</span><span>(</span><span>frame</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Frame</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>greeting</span><span> </span><span>=</span><span> </span><span>Paragraph</span><span>::</span><span>new</span><span>(</span><span>&#34;Hello World! (press &#39;q&#39; to quit)&#34;</span><span>);</span>

<span>    </span><span>frame</span><span>.</span><span>render_widget</span><span>(</span><span>greeting</span><span>,</span><span> </span><span>frame</span><span>.</span><span>area</span><span>());</span>
<span>}</span>
</pre>
        </div>

        <p>
          After <code>render()</code> returns, the frame is painted - but it
          can&#39;t be sent to the user&#39;s terminal yet, since terminals can be slow
          and some could have a hard time processing a continuous stream of
          frames, especially with
          <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>
          floating around.
        </p>

        <p>
          Luckily, since a new frame is usually similar to the previous one,
          instead of sending everything, we can send just the difference - a
          couple of instructions such as <code>go to (30,5)</code>,
          <code>overwrite with &#39;vsauce&#39;</code>.
        </p>

        <p>
          This is essentially a video codec, but for text - and Ratatui provides
          one out of the box:
        </p>

        

        <div>
          <pre><span></span><span>// Takes two buffers, returns a list of differences between them (x, y, char).</span>
<span>pub</span><span> </span><span>fn</span><span> </span><span>diff</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>other</span><span>:</span><span> </span><span>&amp;</span><span>Self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Vec</span><span>&lt;</span><span>(</span><span>u16</span><span>,</span><span> </span><span>u16</span><span>,</span><span> </span><span>&amp;</span><span>Cell</span><span>)</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>updates</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[];</span>
<span>    </span><span>let</span><span> </span><span>buffers</span><span> </span><span>=</span><span> </span><span>next_buffer</span><span>.</span><span>iter</span><span>().</span><span>zip</span><span>(</span><span>previous_buffer</span><span>.</span><span>iter</span><span>()).</span><span>enumerate</span><span>();</span>

<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>(</span><span>current</span><span>,</span><span> </span><span>previous</span><span>))</span><span> </span><span>in</span><span> </span><span>buffers</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>current</span><span> </span><span>!=</span><span> </span><span>previous</span><span> </span><span>{</span>
<span>            </span><span>let</span><span> </span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>pos_of</span><span>(</span><span>i</span><span>);</span>
<span>            </span><span>updates</span><span>.</span><span>push</span><span>((</span><span>x</span><span>,</span><span> </span><span>y</span><span>,</span><span> </span><span>&amp;</span><span>next_buffer</span><span>[</span><span>i</span><span>]));</span>
<span>        </span><span>}</span>

<span>        </span><span>/* ... */</span>
<span>    </span><span>}</span>

<span>    </span><span>updates</span>
<span>}</span>
</pre>
        </div>

        

        <p>
          Even though this codec is rather minimalistic, what I&#39;ve found out is
          that for some views - for instance this welcome screen you saw at the
          beginning - this diffing can take <i>half</i> of the frame time!
        </p>

        <p>
          This is KCachegrind, showing timings for a single frame - you can see
          that
          <code>Terminal::flush()</code> (expanded below) takes about the same
          time as everything else, including drawing the frame:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/callgrind-1.png"/>
        </figure>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/callgrind-2.png"/>

          <figcaption>
            Zoom-in to <code>Terminal::flush()</code> where
            <code>Buffer::diff()</code>
            is seen taking almost all of the time.
          </figcaption>
        </figure>

        <p>but if computers fast then why codec slow ??</p>

        <h2 id="wager"><a href="#wager"> Wager </a></h2>

        <p>
          Most of the overhead seems to come from, out of all things, Unicode
          ✅💻🖥️💻✅ - but I&#39;m getting ahead of myself. When you see a terminal:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/terminal.png"/>

          <figcaption>btop running in Kitty</figcaption>
        </figure>

        <p>
          ... you might imagine it&#39;s basically a two-dimensional array of
          characters:
        </p>

        <div>
          <pre><span></span><span>struct</span><span> </span><span>Buffer</span><span> </span><span>{</span>
<span>    </span><span>cells</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>char</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>
</pre>
        </div>

        <p>
          But this is an oversimplification as each character (also known as
          <i>cell</i>) can be colored:
        </p>

        <div>
          <pre><span></span><span>struct</span><span> </span><span>Buffer</span><span> </span><span>{</span>
<span>    </span><span>cells</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>

<span>struct</span><span> </span><span>Cell</span><span> </span><span>{</span>
<span>    </span><span>symbol</span><span>:</span><span> </span><span>char</span><span>,</span>
<span>    </span><span>foreground</span><span>:</span><span> </span><span>Color</span><span>,</span>
<span>    </span><span>background</span><span>:</span><span> </span><span>Color</span><span>,</span>
<span>    </span><span>/* underline, strike-through etc. */</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... and even <i>that</i> is too naive - Rust&#39;s <code>char</code> can
          encode a single Unicode scalar value, while sometimes what you
          perceive as one character is actually a couple of <code>char</code>s
          bundled together.
        </p>

        <p>
          For instance 🐕‍🦺 (service dog) is really two separate emojis, 🐕 (dog)
          and 🦺 (safety vest).
        </p>

        

        <p>
          So if we want to implement a terminal-ui application that supports
          Unicode, it must be able to represent cells with potentially multiple
          <code>char</code>s:
        </p>

        <div>
          <pre><span></span><span>struct</span><span> </span><span>Cell</span><span> </span><span>{</span>
<span><span>    </span><span>symbol</span><span>:</span><span> </span><span>String</span><span>,</span>
</span><span>    </span><span>/* ... */</span>
<span>}</span>
</pre>
        </div>

        <p>That is the case for Ratatui - and most TUI libraries, I suppose:</p>

        

        <div>
          <pre><span></span><span>/// A buffer cell</span>
<span>#[derive(Debug, Clone, Eq, PartialEq, Hash)]</span>
<span>#[cfg_attr(feature = </span><span>&#34;serde&#34;</span><span>, derive(serde::Serialize, serde::Deserialize))]</span>
<span>pub</span><span> </span><span>struct</span><span> </span><span>Cell</span><span> </span><span>{</span>
<span>    </span><span>/// The string to be drawn in the cell.</span>
<span>    </span><span>///</span>
<span>    </span><span>/// This accepts unicode grapheme clusters which might take up more than one cell.</span>
<span>    </span><span>///</span>
<span>    </span><span>/// This is a [`CompactString`] which is a wrapper around [`String`] that uses a small inline</span>
<span>    </span><span>/// buffer for short strings.</span>
<span>    </span><span>///</span>
<span>    </span><span>/// See &lt;https://github.com/ratatui/ratatui/pull/601&gt; for more information.</span>
<span><span>    </span><span>symbol</span><span>:</span><span> </span><span>CompactString</span><span>,</span>
</span>
<span>    </span><span>/* ... */</span>
<span>}</span>
</pre>
        </div>

        <p>But doing so causes this inconspicuous bit from before:</p>

        

        <div>
          <pre><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>diff</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>other</span><span>:</span><span> </span><span>&amp;</span><span>Self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Vec</span><span>&lt;</span><span>(</span><span>u16</span><span>,</span><span> </span><span>u16</span><span>,</span><span> </span><span>&amp;</span><span>Cell</span><span>)</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>

<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>(</span><span>current</span><span>,</span><span> </span><span>previous</span><span>))</span><span> </span><span>in</span><span> </span><span>buffers</span><span> </span><span>{</span>
<span><span>        </span><span>if</span><span> </span><span>current</span><span> </span><span>!=</span><span> </span><span>previous</span><span> </span><span>{</span>
</span><span>            </span><span>/* ... */</span>
<span>        </span><span>}</span>

<span>        </span><span>/* ... */</span>
<span>    </span><span>}</span>

<span>    </span><span>/* ... */</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... to suddenly become heavy, because the CPU might be forced to chase
          pointers and perform
          <a href="https://github.com/ParkMyCar/compact_str/blob/9bf30edeb67e7e7051ed1e8ca7b26ba3b8aeec5f/compact_str/src/repr/mod.rs#L355">logic</a>
          that otherwise wouldn&#39;t be there - an overhead for each cell, for each
          frame, for each player.
        </p>

        <p>
          I&#39;ve been fiddling with Ratatui internals for a while now and my notes
          tell me that dropping support for Unicode reduces the frame time by
          half - but those changes are somewhat un-upstreamable.
        </p>

        <p>
          While they do help in my specific use case, I&#39;d say that most TUI apps
          should have support for Unicode - for most apps this &#34;overhead&#34;
          doesn&#39;t matter, because they are run locally, and we&#39;re talking about
          a millisecond, if even; it&#39;s negligible.
        </p>

        <p>
          (&#34;overhead&#34; in quotes, since it&#39;s not <i>really</i> overhead when your
          application relies on the Unicode support being there - it would be
          overhead if the algorithm did something otherwise unnecessary.)
        </p>

        <p>
          Besides, Unicode or not, the fundamental problem I&#39;ve got with diffing
          is that it feels like a self-made problem: we need to diff, because
          every frame we get a brand new buffer. So what if instead of diffing,
          the UI <i>just knew</i> how to update the terminal incrementally,
          without the need to diff?
        </p>

        <p>Consider a clock app:</p>

        <div>
          <pre><span></span>-------------------
| time = 12:00:00 |
-------------------
</pre>
        </div>

        <p>
          If the time now changes to <code>12:00:01</code>, why bother redrawing
          everything just to get the diff?
        </p>

        <hr/>

        <p>
          So this got me thinking - the diffing, plus the fact that I&#39;ve got a
          bit of a beef with Ratatui&#39;s layouting method, which, as compared to
          Swift&#39;s:
        </p>

        <div>
          <pre><span></span><span>var</span><span> </span><span>body</span><span>:</span><span> </span><span>some</span><span> </span><span>View</span><span> </span><span>{</span>
<span>    </span><span>VStack</span><span> </span><span>{</span>
<span>        </span><span>Text</span><span>(</span><span>&#34;Hello&#34;</span><span>)</span>
<span>        </span><span>Text</span><span>(</span><span>&#34;World&#34;</span><span>)</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>... or egui&#39;s:</p>

        <div>
          <pre><span></span><span>egui</span><span>::</span><span>CentralPanel</span><span>::</span><span>default</span><span>().</span><span>show</span><span>(</span><span>ctx</span><span>,</span><span> </span><span>|</span><span>ui</span><span>|</span><span> </span><span>{</span>
<span>    </span><span>ui</span><span>.</span><span>label</span><span>(</span><span>&#34;Hello&#34;</span><span>);</span>
<span>    </span><span>ui</span><span>.</span><span>label</span><span>(</span><span>&#34;World&#34;</span><span>);</span>
<span>});</span>
</pre>
        </div>

        <p>
          ... has this disadvantage of forcing you to imperatively hand-place
          the widgets:
        </p>

        <div>
          <pre><span></span><span>let</span><span> </span><span>(</span><span>area</span><span>,</span><span> </span><span>buf</span><span>)</span><span> </span><span>=</span><span> </span><span>(</span><span>frame</span><span>.</span><span>area</span><span>(),</span><span> </span><span>frame</span><span>.</span><span>buffer_mut</span><span>());</span>

<span>Paragraph</span><span>::</span><span>new</span><span>(</span><span>&#34;Hello&#34;</span><span>).</span><span>render</span><span>(</span><span>area</span><span>,</span><span> </span><span>buf</span><span>);</span>

<span>Paragraph</span><span>::</span><span>new</span><span>(</span><span>&#34;World&#34;</span><span>)</span>
<span>    </span><span>.</span><span>render</span><span>(</span><span>area</span><span>.</span><span>offset</span><span>(</span><span>Offset</span><span> </span><span>{</span><span> </span><span>x</span><span>:</span><span> </span><span>0</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>1</span><span> </span><span>}),</span><span> </span><span>buf</span><span>);</span>
<span>//          ^--------------------------------^</span>
</pre>
        </div>

        <p>
          Even though most of the time most of the calculations can be
          abstracted away using <code>Layout</code>:
        </p>

        <div>
          <pre><span></span><span>let</span><span> </span><span>(</span><span>area</span><span>,</span><span> </span><span>buf</span><span>)</span><span> </span><span>=</span><span> </span><span>(</span><span>frame</span><span>.</span><span>area</span><span>(),</span><span> </span><span>frame</span><span>.</span><span>buffer_mut</span><span>());</span>

<span>let</span><span> </span><span>[</span><span>hello_area</span><span>,</span><span> </span><span>world_area</span><span>]</span><span> </span><span>=</span><span> </span><span>Layout</span><span>::</span><span>vertical</span><span>([</span>
<span>    </span><span>Constraint</span><span>::</span><span>Length</span><span>(</span><span>1</span><span>),</span>
<span>    </span><span>Constraint</span><span>::</span><span>Length</span><span>(</span><span>1</span><span>),</span>
<span>])</span>
<span>.</span><span>areas</span><span>(</span><span>area</span><span>);</span>

<span>Paragraph</span><span>::</span><span>new</span><span>(</span><span>&#34;Hello&#34;</span><span>).</span><span>render</span><span>(</span><span>hello_area</span><span>,</span><span> </span><span>buf</span><span>);</span>
<span>Paragraph</span><span>::</span><span>new</span><span>(</span><span>&#34;World&#34;</span><span>).</span><span>render</span><span>(</span><span>world_area</span><span>,</span><span> </span><span>buf</span><span>);</span>
</pre>
        </div>

        <p>
          ... the awkwardness demon comes back once you have a layout whose size
          depends on its content - for instance in kartoffels there&#39;s this
          world-selection window:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/play.png"/>
        </figure>

        <p>
          ... whose width relies on the longest world name, height relies on the
          number of worlds, and position relies on the window size itself (it&#39;s
          centered).
        </p>

        <p>
          If you start to implement this in Ratatui, you quickly get backed into
          a corner where you have to calculate the layout before you can draw,
          but you can&#39;t easily calculate the layout until you get to the drawing
          part:
        </p>

        <div>
          <pre><span></span><span>// Step 1: Center the area horizontally</span>
<span>let</span><span> </span><span>[</span><span>_</span><span>,</span><span> </span><span>area</span><span>,</span><span> </span><span>_</span><span>]</span><span> </span><span>=</span><span> </span><span>Layout</span><span>::</span><span>horizontal</span><span>([</span>
<span>    </span><span>Constraint</span><span>::</span><span>Fill</span><span>(</span><span>1</span><span>),</span>
<span>    </span><span>Constraint</span><span>::</span><span>Length</span><span>(</span><span>/* ughh, expected width? */</span><span>),</span>
<span>    </span><span>Constraint</span><span>::</span><span>Fill</span><span>(</span><span>1</span><span>),</span>
<span>])</span>
<span>.</span><span>areas</span><span>(</span><span>area</span><span>);</span>

<span>// Step 2: Center the area vertically</span>
<span>let</span><span> </span><span>[</span><span>_</span><span>,</span><span> </span><span>area</span><span>,</span><span> </span><span>_</span><span>]</span><span> </span><span>=</span><span> </span><span>Layout</span><span>::</span><span>vertical</span><span>([</span>
<span>    </span><span>Constraint</span><span>::</span><span>Fill</span><span>(</span><span>1</span><span>),</span>
<span>    </span><span>Constraint</span><span>::</span><span>Length</span><span>(</span><span>/* ughh, expected height? */</span><span>),</span>
<span>    </span><span>Constraint</span><span>::</span><span>Fill</span><span>(</span><span>1</span><span>),</span>
<span>])</span>
<span>.</span><span>areas</span><span>(</span><span>area</span><span>);</span>

<span>/* drawing happens here */</span>
</pre>
        </div>

        <p>
          Of course, you clearly <i>can</i> precalculate everything by hand:
        </p>

        <div>
          <pre><span></span><span>let</span><span> </span><span>expected_width</span><span> </span><span>=</span>
<span>    </span><span>// left-right padding:</span>
<span>    </span><span>2</span>
<span>    </span><span>// name of the longest world or the `go back` button:</span>
<span>    </span><span>+</span><span> </span><span>worlds</span>
<span>        </span><span>.</span><span>iter</span><span>()</span>
<span>        </span><span>.</span><span>map</span><span>(</span><span>|</span><span>world</span><span>|</span><span> </span><span>{</span>
<span>            </span><span>4</span><span> </span><span>// `[1] `, `[2] ` etc.</span>
<span>            </span><span>+</span><span> </span><span>world</span><span>.</span><span>name</span><span>.</span><span>len</span><span>()</span>
<span>        </span><span>})</span>
<span>        </span><span>.</span><span>max</span><span>()</span>
<span>        </span><span>.</span><span>unwrap</span><span>()</span>
<span>        </span><span>.</span><span>max</span><span>(</span><span>13</span><span>);</span><span> </span><span>// `[esc] go-back`</span>

<span>let</span><span> </span><span>expected_height</span><span> </span><span>=</span><span> </span><span>worlds</span><span>.</span><span>len</span><span>()</span><span> </span><span>+</span><span> </span><span>2</span><span>;</span>

<span>// Step 1: Center the area horizontally</span>
<span>let</span><span> </span><span>[</span><span>_</span><span>,</span><span> </span><span>area</span><span>,</span><span> </span><span>_</span><span>]</span><span> </span><span>=</span><span> </span><span>Layout</span><span>::</span><span>horizontal</span><span>([</span>
<span>    </span><span>Constraint</span><span>::</span><span>Fill</span><span>(</span><span>1</span><span>),</span>
<span>    </span><span>Constraint</span><span>::</span><span>Length</span><span>(</span><span>expected_width</span><span>),</span>
<span>    </span><span>Constraint</span><span>::</span><span>Fill</span><span>(</span><span>1</span><span>),</span>
<span>])</span>
<span>.</span><span>areas</span><span>(</span><span>area</span><span>);</span>

<span>// Step 2: Center the area vertically</span>
<span>let</span><span> </span><span>[</span><span>_</span><span>,</span><span> </span><span>area</span><span>,</span><span> </span><span>_</span><span>]</span><span> </span><span>=</span><span> </span><span>Layout</span><span>::</span><span>vertical</span><span>([</span>
<span>    </span><span>Constraint</span><span>::</span><span>Fill</span><span>(</span><span>1</span><span>),</span>
<span>    </span><span>Constraint</span><span>::</span><span>Length</span><span>(</span><span>expected_height</span><span>),</span>
<span>    </span><span>Constraint</span><span>::</span><span>Fill</span><span>(</span><span>1</span><span>),</span>
<span>])</span>
<span>.</span><span>areas</span><span>(</span><span>area</span><span>);</span>
</pre>
        </div>

        <p>
          ... it&#39;s just that even if you abstract the widgets, the calculations
          <a href="https://codeberg.org/pwy/kartoffels/src/commit/9ea866eaf6a1f892f1f30118955c7b45408ecf0d/app/crates/kartoffels-front/src/views/index/play.rs#L72">remain a chore</a>.
        </p>

        <hr/>

        <p>
          So, those were - and still remain - the pain points I have with
          Ratatui:
        </p>

        <ul>
          <li>diffing feels &#34;unnecessary&#34; and takes &#34;too much&#34; time,</li>
          <li>laying widgets out feels &#34;like a chore&#34;.</li>
        </ul>

        <p>What&#39;s more, in my specific case:</p>

        <ul>
          <li>I don&#39;t care about proper Unicode support,</li>
          <li>
            I&#39;m fine with better performance at the cost of worse developer
            experience.
          </li>
        </ul>

        <p>
          With those in mind and <code>cargo new</code> at my fingertips, would
          I be able to come up with a better library?
        </p>

        <h2 id="wisdom"><a href="#wisdom"> Wisdom </a></h2>

        <p>
          Turns out - <i>no</i>! But hey, I&#39;ve learned a thing or two - let me
          walk you through a couple of decisions I&#39;ve made and through my
          thought process.
        </p>

        

        <p>
          Since I&#39;d like to avoid repainting unchanged bits of the screen, I&#39;ve
          decided that my library cannot use Ratatui&#39;s approach of &#34;let&#39;s run a
          function that draws everything&#34; - instead, I went with a widget tree.
        </p>

        <p>
          If you&#39;ve done a bit of HTML or Swift or Yew or any modern UI library
          really, you&#39;re probably familiar with the concept - instead of
          describing the interface imperatively, you describe it mostly
          declaratively, like so:
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>ui</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>ui</span><span>::</span><span>column</span><span>()</span>
<span>        </span><span>.</span><span>with</span><span>(</span><span>ui</span><span>::</span><span>text</span><span>(</span><span>&#34;Hello&#34;</span><span>))</span>
<span>        </span><span>.</span><span>with</span><span>(</span><span>ui</span><span>::</span><span>text</span><span>(</span><span>&#34;World&#34;</span><span>))</span>
<span>}</span>
</pre>
        </div>

        <p>In practice this can be implemented with a trait:</p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>trait</span><span> </span><span>Node</span><span> </span><span>{</span><span> </span><span>// aka &#34;widget&#34; or &#34;component&#34;</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>buffer</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Buffer</span><span>,</span><span> </span><span>x</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>u16</span><span>);</span>
<span>}</span>
</pre>
        </div>

        <p>... and a couple of types such as:</p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>struct</span><span> </span><span>Text</span><span> </span><span>{</span>
<span>    </span><span>body</span><span>:</span><span> </span><span>String</span><span>,</span>
<span>}</span>

<span>impl</span><span> </span><span>Text</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>set</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>body</span><span>:</span><span> </span><span>impl</span><span> </span><span>Into</span><span>&lt;</span><span>String</span><span>&gt;</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>self</span><span>.</span><span>body</span><span> </span><span>=</span><span> </span><span>body</span><span>.</span><span>into</span><span>();</span>
<span>    </span><span>}</span>
<span>}</span>

<span>impl</span><span> </span><span>Node</span><span> </span><span>for</span><span> </span><span>Text</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>buffer</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Buffer</span><span>,</span><span> </span><span>x</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>/* draw text to buffer at (x, y) */</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          Under this design, rendering every frame consists of painting the root
          node which then recursively paints its children and so on - for
          instance this screen from before:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/play.png"/>
        </figure>

        <p>
          ... could be described by this tree (in reality this would be Rust
          code, of course):
        </p>

        <div>
          <pre><span></span><span>(</span><span>zstack</span>
<span>  </span><span>(</span><span>background</span><span>)</span>
<span>  </span><span>(</span><span>centered</span>
<span>    </span><span>(</span><span>window</span><span> </span><span>&#34;play&#34;</span>
<span>      </span><span>(</span><span>vstack</span>
<span>        </span><span>(</span><span>button</span><span> </span><span>&#34;1&#34;</span><span> </span><span>&#34;arena&#34;</span><span>)</span>
<span>        </span><span>(</span><span>button</span><span> </span><span>&#34;2&#34;</span><span> </span><span>&#34;grotta&#34;</span><span>)</span>
<span>        </span><span>(</span><span>line</span><span>)</span>
<span>        </span><span>(</span><span>button</span><span> </span><span>&#34;esc&#34;</span><span> </span><span>&#34;go-back&#34;</span><span>)))))</span>
</pre>
        </div>

        <p>
          For convenience, most UI libraries tell you to build a new widget tree
          every frame - but since we&#39;re fine with trading worse developer
          experience for better performance, we&#39;re going to re-use the same tree
          in-place, just with manually-tracked dirty flags:
        </p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>struct</span><span> </span><span>Text</span><span> </span><span>{</span>
<span>    </span><span>body</span><span>:</span><span> </span><span>String</span><span>,</span>
<span><span>    </span><span>dirty</span><span>:</span><span> </span><span>bool</span><span>,</span>
</span><span>}</span>

<span>impl</span><span> </span><span>Text</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>set</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>body</span><span>:</span><span> </span><span>impl</span><span> </span><span>Into</span><span>&lt;</span><span>String</span><span>&gt;</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>self</span><span>.</span><span>body</span><span> </span><span>=</span><span> </span><span>body</span><span>.</span><span>into</span><span>();</span>
<span><span>        </span><span>self</span><span>.</span><span>dirty</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span>
</span><span>    </span><span>}</span>
<span>}</span>

<span>impl</span><span> </span><span>Node</span><span> </span><span>for</span><span> </span><span>Text</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>buffer</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Buffer</span><span>,</span><span> </span><span>x</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>{</span>
<span><span>        </span><span>if</span><span> </span><span>!</span><span>self</span><span>.</span><span>dirty</span><span> </span><span>{</span>
</span><span><span>            </span><span>// Already drawn</span>
</span><span><span>            </span><span>return</span><span>;</span>
</span><span><span>        </span><span>}</span>
</span>
<span>        </span><span>/* draw text to buffer at (x, y) */</span>

<span><span>        </span><span>self</span><span>.</span><span>dirty</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span>
</span><span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... aaand hey what&#39;s that - this is day zero and we&#39;re already
          cheating!
        </p>

        <p>
          After all, keeping a dirty flag per node <i>is</i> a form of diffing,
          simply in &#34;node-space&#34; (per each widget) instead of &#34;cell-space&#34; (per
          each cell).
        </p>

        <p>
          I think diffing limited to nodes is acceptable, though - it&#39;s linear
          in the number of nodes displayed on the screen, it doesn&#39;t depend on
          the screen size itself. So the &#34;cost&#34; would be 9 for the scene above
          (9 nodes) instead of, say, 128*64 (width * height) if we were to diff
          terminal cells.
        </p>

        <p>
          Now, does it look good on paper? Quite! So let&#39;s get to the nasty
          parts.
        </p>

        <h3>Reality check: Events</h3>

        <p>
          What about event processing - how can we handle key presses, mouse
          clicks?
        </p>

        <p>
          In Ratatui this is painfully obvious, you simply check the keyboard
          and mouse every frame:
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>should_quit</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>bool</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>event</span><span>::</span><span>poll</span><span>(</span><span>Duration</span><span>::</span><span>from_millis</span><span>(</span><span>250</span><span>)).</span><span>unwrap</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>event</span><span>::</span><span>read</span><span>()</span>
<span>            </span><span>.</span><span>unwrap</span><span>()</span>
<span>            </span><span>.</span><span>as_key_press_event</span><span>()</span>
<span>            </span><span>.</span><span>is_some_and</span><span>(</span><span>|</span><span>key</span><span>|</span><span> </span><span>key</span><span>.</span><span>code</span><span> </span><span>==</span><span> </span><span>KeyCode</span><span>::</span><span>Char</span><span>(</span><span>&#39;q&#39;</span><span>))</span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>        </span><span>false</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          But the moment you use a widget tree, the control gets inverted - now
          the ui library has to somehow <i>call you</i>. You can then choose
          between callbacks:
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>quit_btn</span><span>(</span><span>on_press</span><span>:</span><span> </span><span>impl</span><span> </span><span>FnOnce</span><span>())</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>ui</span><span>::</span><span>button</span><span>(</span><span>&#34;Press Q to quit&#34;</span><span>)</span>
<span>        </span><span>.</span><span>on_key_pressed</span><span>(</span><span>&#39;q&#39;</span><span>,</span><span> </span><span>on_press</span><span>)</span>
<span>}</span>
</pre>
        </div>

        <p>... channels:</p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>quit_btn</span><span>(</span><span>tx</span><span>:</span><span> </span><span>mpsc</span><span>::</span><span>Sender</span><span>&lt;</span><span>()</span><span>&gt;</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>ui</span><span>::</span><span>button</span><span>(</span><span>&#34;Press Q to quit&#34;</span><span>).</span><span>on_key_pressed</span><span>(</span><span>&#39;q&#39;</span><span>,</span><span> </span><span>move</span><span> </span><span>||</span><span> </span><span>{</span>
<span>        </span><span>_</span><span> </span><span>=</span><span> </span><span>tx</span><span>.</span><span>send</span><span>(());</span>
<span>    </span><span>})</span>
<span>}</span>
</pre>
        </div>

        <p>... or some sort of pretend-algebraic effects:</p>

        <div>
          <pre><span></span><span>enum</span><span> </span><span>QuitBtnEvent</span><span> </span><span>{</span>
<span>    </span><span>Quit</span><span>,</span>
<span>}</span>

<span>fn</span><span> </span><span>quit_btn</span><span>(</span><span>tx</span><span>:</span><span> </span><span>mpsc</span><span>::</span><span>Sender</span><span>&lt;</span><span>()</span><span>&gt;</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span>&lt;</span><span>QuitBtnEvent</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>ui</span><span>::</span><span>button</span><span>(</span><span>&#34;Press Q to quit&#34;</span><span>)</span>
<span>        </span><span>.</span><span>on_key_pressed</span><span>(</span><span>&#39;q&#39;</span><span>,</span><span> </span><span>QuitBtnEvent</span><span>::</span><span>Quit</span><span>)</span>
<span>}</span>
</pre>
        </div>

        <p>
          But none of them compose that well once you have to bundle widgets
          together:
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>menu</span><span>(</span>
<span>    </span><span>on_start</span><span>:</span><span> </span><span>impl</span><span> </span><span>FnOnce</span><span>(),</span>
<span>    </span><span>on_settings</span><span>:</span><span> </span><span>impl</span><span> </span><span>FnOnce</span><span>(),</span>
<span>    </span><span>on_quit</span><span>:</span><span> </span><span>impl</span><span> </span><span>FnOnce</span><span>(),</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>ui</span><span>::</span><span>column</span><span>()</span>
<span>        </span><span>.</span><span>with</span><span>(</span><span>start_btn</span><span>(</span><span>on_start</span><span>))</span>
<span>        </span><span>.</span><span>with</span><span>(</span><span>settings_btn</span><span>(</span><span>on_settings</span><span>))</span>
<span>        </span><span>.</span><span>with</span><span>(</span><span>quit_btn</span><span>(</span><span>on_quit</span><span>))</span>
<span>}</span>
</pre>
        </div>

        <div>
          <pre><span></span><span>enum</span><span> </span><span>MenuEvent</span><span> </span><span>{</span>
<span>    </span><span>Start</span><span>,</span>
<span>    </span><span>Settings</span><span>,</span>
<span>    </span><span>Quit</span><span>,</span>
<span>}</span>

<span>fn</span><span> </span><span>menu</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span>&lt;</span><span>MenuEffect</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>ui</span><span>::</span><span>column</span><span>()</span>
<span>        </span><span>.</span><span>with</span><span>(</span>
<span>            </span><span>start_btn</span><span>()</span>
<span>                </span><span>.</span><span>map_effect</span><span>(</span><span>|</span><span>_</span><span>|</span><span> </span><span>MenuEffect</span><span>::</span><span>Start</span><span>)</span>
<span>        </span><span>)</span>
<span>        </span><span>.</span><span>with</span><span>(</span>
<span>            </span><span>settings_btn</span><span>()</span>
<span>                </span><span>.</span><span>map_effect</span><span>(</span><span>|</span><span>_</span><span>|</span><span> </span><span>MenuEffect</span><span>::</span><span>Settings</span><span>)</span>
<span>        </span><span>)</span>
<span>        </span><span>.</span><span>with</span><span>(</span>
<span>            </span><span>quit_btn</span><span>()</span>
<span>                </span><span>.</span><span>map_effect</span><span>(</span><span>|</span><span>_</span><span>|</span><span> </span><span>MenuEffect</span><span>::</span><span>Quit</span><span>)</span>
<span>        </span><span>)</span>
<span>}</span>
</pre>
        </div>

        <p>Ick.</p>

        <p>
          Using declarative widgets instead of imperative code also spawns a new
          dimension of problems - state management.
        </p>

        <h3>Reality check: State</h3>

        <p>
          Say, we&#39;re writing a to-do app - how do you pass the state from parent
          nodes to their children?
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>tasks</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>/* okkk, where do i get the list from ?? */</span>
<span>}</span>
</pre>
        </div>

        <p>Sure, you can pass the list when you create the widget:</p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>tasks</span><span>(</span><span>tasks</span><span>:</span><span> </span><span>&amp;</span><span>[</span><span>Task</span><span>])</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... but since we&#39;re not rebuilding the entire widget tree every frame,
          how do you update it?
        </p>

        <div>
          <pre><span></span><span>enum</span><span> </span><span>Event</span><span> </span><span>{</span>
<span>    </span><span>DeleteSelectedTask</span><span>,</span>
<span>}</span>

<span>fn</span><span> </span><span>menu</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span>&lt;</span><span>Event</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>
<span>}</span>

<span>fn</span><span> </span><span>tasks</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>tasks</span><span>:</span><span> </span><span>&amp;</span><span>[</span><span>Task</span><span>])</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>
<span>}</span>

<span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>tasks</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[</span>
<span>        </span><span>/* ... */</span>
<span>    </span><span>];</span>

<span>    </span><span>let</span><span> </span><span>ui</span><span> </span><span>=</span><span> </span><span>Ui</span><span>::</span><span>new</span><span>();</span>

<span>    </span><span>ui</span><span>.</span><span>set_root</span><span>(</span>
<span>        </span><span>ui</span><span>::</span><span>column</span><span>()</span>
<span>            </span><span>.</span><span>with</span><span>(</span><span>menu</span><span>())</span>
<span><span>            </span><span>.</span><span>with</span><span>(</span><span>tasks</span><span>(</span><span>&amp;</span><span>tasks</span><span>))</span>
</span><span>    </span><span>);</span>

<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>ui</span><span>.</span><span>paint</span><span>();</span>

<span>        </span><span>match</span><span> </span><span>ui</span><span>.</span><span>react</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>Event</span><span>::</span><span>DeleteSelectedTask</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span><span>                </span><span>tasks</span><span>.</span><span>remove</span><span>(</span><span>/* ... */</span><span>);</span>
</span><span><span>                </span><span>/* how do you refresh the `tasks()` widget? */</span>
</span><span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          I&#39;ve tried to play with
          <a href="https://github.com/plausiblelabs/lens-rs">lenses</a> where
          you extend the node&#39;s definition to support arbitrary arguments:
        </p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>trait</span><span> </span><span>Node</span><span>&lt;</span><span>Arg</span><span>,</span><span> </span><span>Event</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>buffer</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Buffer</span><span>,</span><span> </span><span>x</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>arg</span><span>:</span><span> </span><span>&amp;</span><span>Arg</span><span>);</span>
<span>}</span>
</pre>
        </div>

        <p>... and then you weave them throughout the call stack:</p>

        <div>
          <pre><span></span><span>// Menu doesn&#39;t need any arguments, it works for any:</span>
<span><span>fn</span><span> </span><span>menu</span><span>&lt;</span><span>A</span><span>&gt;</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span>&lt;</span><span>A</span><span>,</span><span> </span><span>Event</span><span>&gt;</span><span> </span><span>{</span>
</span><span><span>    </span><span>/* ... */</span>
</span><span><span>}</span>
</span>
<span>// On the other hand, the task list doesn&#39;t throw any effect:</span>
<span><span>fn</span><span> </span><span>tasks</span><span>&lt;</span><span>E</span><span>&gt;</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span>&lt;</span><span>[</span><span>Task</span><span>],</span><span> </span><span>E</span><span>&gt;</span><span> </span><span>{</span>
</span><span><span>    </span><span>/* ... */</span>
</span><span><span>}</span>
</span>
<span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>tasks</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[</span>
<span>        </span><span>/* ... */</span>
<span>    </span><span>];</span>

<span>    </span><span>let</span><span> </span><span>ui</span><span> </span><span>=</span><span> </span><span>Ui</span><span>::</span><span>new</span><span>();</span>

<span>    </span><span>ui</span><span>.</span><span>set_root</span><span>(</span>
<span>        </span><span>ui</span><span>::</span><span>column</span><span>()</span>
<span>            </span><span>.</span><span>with</span><span>(</span><span>menu</span><span>())</span>
<span>            </span><span>.</span><span>with</span><span>(</span><span>tasks</span><span>())</span>
<span>    </span><span>);</span>

<span>    </span><span>loop</span><span> </span><span>{</span>
<span><span>        </span><span>ui</span><span>.</span><span>paint</span><span>(</span><span>&amp;</span><span>tasks</span><span>);</span>
</span>
<span>        </span><span>/* ... */</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... but I couldn&#39;t figure out any design that would work given
          anything more complicated than a <code>Hello World!</code> and maybe a
          single text input.
        </p>

        <p>
          A natural approach would be to keep the state and UI materialized
          separately:
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>task</span><span>(</span><span>task</span><span>:</span><span> </span><span>&amp;</span><span>Task</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>ui</span><span>::</span><span>Node</span><span>&lt;</span><span>Event</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>/* title, priority, an &#34;open&#34; button etc. */</span>
<span>}</span>

<span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>// state:</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>tasks</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[</span>
<span>        </span><span>/* ... */</span>
<span>    </span><span>];</span>

<span>    </span><span>// user interface:</span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>task_nodes</span><span> </span><span>=</span><span> </span><span>tasks</span><span>.</span><span>iter</span><span>().</span><span>map</span><span>(</span><span>task</span><span>).</span><span>collect</span><span>();</span>
</span>
<span>    </span><span>let</span><span> </span><span>ui</span><span> </span><span>=</span><span> </span><span>Ui</span><span>::</span><span>new</span><span>();</span>

<span>    </span><span>ui</span><span>.</span><span>set_root</span><span>(</span>
<span>        </span><span>ui</span><span>::</span><span>column</span><span>()</span>
<span>            </span><span>.</span><span>with</span><span>(</span><span>menu</span><span>())</span>
<span><span>            </span><span>.</span><span>with</span><span>(</span><span>list</span><span>(</span><span>task_nodes</span><span>))</span>
</span><span>    </span><span>);</span>

<span>    </span><span>/* ... */</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... but in addition to being memory-heavy, this approach doesn&#39;t play
          with the concept of ownership:
        </p>

        <div>
          <pre><span></span><span>loop</span><span> </span><span>{</span>
<span>    </span><span>ui</span><span>.</span><span>paint</span><span>();</span>

<span>    </span><span>match</span><span> </span><span>ui</span><span>.</span><span>react</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>Event</span><span>::</span><span>DeleteSelectedTask</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>            </span><span>tasks</span><span>.</span><span>remove</span><span>(</span><span>/* ... */</span><span>);</span>

<span><span>            </span><span>// ugh, `task_nodes` has been moved to `ui.set_root()`, it&#39;s not</span>
</span><span><span>            </span><span>// accessible anymore here:</span>
</span><span><span>            </span><span>// task_nodes.remove(/* ... */);</span>
</span><span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          My initial demos used an <code>Arc&lt;RwLock&lt;...&gt;&gt;</code>:
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>

<span>    </span><span>let</span><span> </span><span>task_nodes</span><span> </span><span>=</span><span> </span><span>tasks</span><span>.</span><span>iter</span><span>().</span><span>map</span><span>(</span><span>task</span><span>).</span><span>collect</span><span>();</span>
<span><span>    </span><span>let</span><span> </span><span>task_nodes</span><span> </span><span>=</span><span> </span><span>Arc</span><span>::</span><span>new</span><span>(</span><span>RwLock</span><span>::</span><span>new</span><span>(</span><span>task_nodes</span><span>));</span>
</span>
<span>    </span><span>/* ... */</span>

<span>    </span><span>ui</span><span>.</span><span>set_root</span><span>(</span>
<span>        </span><span>ui</span><span>::</span><span>column</span><span>()</span>
<span>            </span><span>.</span><span>with</span><span>(</span><span>menu</span><span>())</span>
<span><span>            </span><span>.</span><span>with</span><span>(</span><span>list</span><span>(</span><span>task_nodes</span><span>.</span><span>clone</span><span>()))</span>
</span><span>    </span><span>);</span>

<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>ui</span><span>.</span><span>paint</span><span>();</span>

<span>        </span><span>match</span><span> </span><span>ui</span><span>.</span><span>react</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>Event</span><span>::</span><span>DeleteSelectedTask</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                </span><span>tasks</span><span>.</span><span>remove</span><span>(</span><span>/* ... */</span><span>);</span>
<span><span>                </span><span>task_nodes</span><span>.</span><span>write</span><span>().</span><span>remove</span><span>(</span><span>/* ... */</span><span>);</span>
</span><span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... but that, in turn, means that you have to lock that
          <code>RwLock</code>
          every frame, also not great.
        </p>

        <p>
          <a href="https://github.com/gyscos/cursive">Cursive</a> does something
          else, akin to JavaScript&#39;s <code>document.getElementById()</code>,
          where you can query a widget for a child:
        </p>

        

        <div>
          <pre><span></span><span>fn</span><span> </span><span>delete_name</span><span>(</span><span>s</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Cursive</span><span>)</span><span> </span><span>{</span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>select</span><span> </span><span>=</span><span> </span><span>s</span><span>.</span><span>find_name</span><span>::</span><span>&lt;</span><span>SelectView</span><span>&lt;</span><span>String</span><span>&gt;&gt;</span><span>(</span><span>&#34;select&#34;</span><span>).</span><span>unwrap</span><span>();</span>
</span><span>    </span><span>match</span><span> </span><span>select</span><span>.</span><span>selected_id</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>s</span><span>.</span><span>add_layer</span><span>(</span><span>Dialog</span><span>::</span><span>info</span><span>(</span><span>&#34;No name to remove&#34;</span><span>)),</span>
<span>        </span><span>Some</span><span>(</span><span>focus</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>            </span><span>select</span><span>.</span><span>remove_item</span><span>(</span><span>focus</span><span>);</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          This solves the ownership issue, but it also makes querying for
          widgets a fallible operation - if you rename a widget but forget to
          rename references to it, your code will probably panic or display a
          spurious error message.
        </p>

        <p>
          What&#39;s more, under this design finding widgets takes non-constant
          time, which could become a performance bottleneck for more complicated
          views:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/bots.png"/>
        </figure>

        <h3>Reality check: Stacking</h3>

        <p>
          On the topic of complicated views, another problem I&#39;ve stumbled upon
          was z-stacking - consider:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/stacked-1.png"/>
        </figure>

        <p>
          If you now press <code>b</code>, a modal will open and cover the map:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/stacked-2.png"/>
        </figure>

        <p>
          This doesn&#39;t pause the game, the map is still getting updated in the
          background - you can see bots moving and happily stabbing each other
          behind the window (I mean, not here, since that&#39;s just a screenshot,
          but you know).
        </p>

        <p>In terms of the widget-tree, this is something akin to:</p>

        <div>
          <pre><span></span><span>(</span><span>zstack</span>
<span>  </span><span>(</span><span>map</span><span>)</span>
<span>  </span><span>(</span><span>backdrop</span><span>)</span>
<span>  </span><span>(</span><span>bots-dialog</span>
<span>    </span><span>(</span><span>...</span><span>)))</span>
</pre>
        </div>

        <p>
          Now, we&#39;d like to avoid diffing, right? So when
          <code>Map::paint()</code> is called, it needs to somehow know
          <i>not</i> to overwrite the area that is allocated for
          <code>BotsDialog</code>.
        </p>

        <p>
          This is plenty problematic, because <code>zstack</code> behaves like:
        </p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>struct</span><span> </span><span>ZStack</span><span> </span><span>{</span>
<span>    </span><span>nodes</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>Node</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>

<span>impl</span><span> </span><span>Node</span><span> </span><span>for</span><span> </span><span>ZStack</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>/* ... */</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>for</span><span> </span><span>node</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>.</span><span>nodes</span><span> </span><span>{</span>
<span>            </span><span>node</span><span>.</span><span>paint</span><span>(</span><span>/* ... */</span><span>);</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... and what we&#39;d need is for <code>Map</code>, the first node on the
          list, to somehow know where the next nodes are <i>going to</i> paint
          before they are painted.
        </p>

        <p>
          Let&#39;s pretend that we&#39;ve somehow managed to figure it out, though -
          another problem is that not all nodes are opaque, some of the nodes
          behave like shaders, i.e. they just modify whatever is underneath
          them.
        </p>

        <blockquote>
          <p>
            my man that&#39;s quite complicated for a tui game, are you sure you
          </p>
        </blockquote>

        <p>
          don&#39;t &#34;my man&#34; me here, we&#39;re all in this together now
        </p>

        <p>
          Uhm, anyway -- while it sounds spooky, the problem is simple. Compare
          the previous screenshots:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/stacked-1.png"/>
        </figure>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/stacked-2.png"/>
        </figure>

        <p>
          After a window is opened, there&#39;s an extra &#34;grayscale&#34; effect applied
          to whatever lays &#34;underneath&#34; that window - that&#39;s called backdrop.
        </p>

        <p>
          If you always render an entire frame from scratch, you can simply
          iterate through all of the cells and replace their foreground color to
          gray (or do some kind of interpolation if you want to have a fade in
          effect or something).
        </p>

        <p>
          But we don&#39;t want to generate the entire frame from scratch, we want
          to be
          <span>incremental</span> - so the backdrop effect
          has to somewhat know what cells have changed between the current and
          the previous frame, like:
        </p>

        <div>
          <pre><span></span><span>impl</span><span> </span><span>Node</span><span> </span><span>for</span><span> </span><span>ZStack</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>/* ... */</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>/* ... */</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>invalidated_points</span><span> </span><span>=</span><span> </span><span>HashSet</span><span>::</span><span>&lt;</span><span>(</span><span>u16</span><span>,</span><span> </span><span>u16</span><span>)</span><span>&gt;</span><span>::</span><span>new</span><span>();</span>

<span>        </span><span>for</span><span> </span><span>node</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>.</span><span>nodes</span><span> </span><span>{</span>
<span>            </span><span>let</span><span> </span><span>new_invalidated_points</span><span> </span><span>=</span><span> </span><span>node</span><span>.</span><span>paint</span><span>(</span><span>/* ... */</span><span>,</span><span> </span><span>&amp;</span><span>invalidated_points</span><span>);</span>

<span>            </span><span>invalidated</span><span>.</span><span>extend</span><span>(</span><span>new_invalidated_points</span><span>);</span>
<span>        </span><span>}</span>

<span>        </span><span>invalidated_points</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          I don&#39;t frequently use memes on my blog, but at this point I realized
          I was just:
        </p>

        <figure>
          <img src="https://pwy.io/posts/kruci-post-mortem/assets/conspiracy.jpg"/>

          <figcaption>
            Charlie Conspiracy (always Sunny In Philidelphia) meme
          </figcaption>
        </figure>

        <h3>So</h3>

        <p>
          As you can see, all of the options here somehow suuuck - from event
          processing up to the incremental updates.
        </p>

        <p>
          One of the reasons why I&#39;ve eventually abandoned my custom tui-ui
          project was that I was getting increasingly worried that the overhead
          of managing trees and subtrees and selectors and surfaces and whatnot
          will be greater than any potential gains I could win by avoiding the
          diffing.
        </p>

        <p>
          A
          <a href="https://en.wikipedia.org/wiki/Galactic_algorithm">galactic UI algorithm</a>, if you want.
        </p>

        <h2 id="wisdom-layouts">
          <a href="#wisdom-layouts"> Wisdom - Layouts </a>
        </h2>

        <p>
          On the upside, there is one decision that turned out quite nice - as I
          said before, one of the problems I&#39;ve got with Ratatui is that you
          have to place the widgets by hand:
        </p>

        <div>
          <pre><span></span><span>Paragraph</span><span>::</span><span>new</span><span>(</span><span>&#34;World&#34;</span><span>)</span>
<span>    </span><span>.</span><span>render</span><span>(</span><span>area</span><span>.</span><span>offset</span><span>(</span><span>Offset</span><span> </span><span>{</span><span> </span><span>x</span><span>:</span><span> </span><span>0</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>1</span><span> </span><span>}),</span><span> </span><span>buf</span><span>);</span>
<span>//          ^--------------------------------^</span>
</pre>
        </div>

        <p>... which stands in contrast to, say, Swift:</p>

        <div>
          <pre><span></span><span>var</span><span> </span><span>body</span><span>:</span><span> </span><span>some</span><span> </span><span>View</span><span> </span><span>{</span>
<span>    </span><span>VStack</span><span> </span><span>{</span>
<span>        </span><span>Text</span><span>(</span><span>&#34;Hello&#34;</span><span>)</span>
<span>        </span><span>Text</span><span>(</span><span>&#34;World&#34;</span><span>)</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          While I&#39;m not a Swift developer, I would say that I&#39;m
          Swift-<i>aware</i>, so for my library I&#39;ve decided to
          <s>steal</s> borrow a couple of concepts from Swift UI:
        </p>

        <ul>
          <li>
            a single
            <a href="https://developer.apple.com/documentation/swiftui/text"><code>Text</code></a>
            widget for all-things-text (compared to Ratatui&#39;s
            <code>Span</code> vs <code>Line</code> vs <code>Paragraph</code>),
          </li>

          <li>
            <a href="https://developer.apple.com/documentation/swiftui/hstack"><code>HStack</code></a>, <code>VStack</code>, and <code>ZStack</code> for
            all-things-placement,
          </li>

          <li>
            <a href="https://developer.apple.com/documentation/swiftui/proposedviewsize"><code>ProposedViewSize</code></a>
            for-all-things &#34;how do I make widgets talk to each other&#34;.
          </li>
        </ul>

        <p>But first things first.</p>

        <p>
          Fundamentally, the problem with laying things out is that it&#39;s a
          chicken-and-egg game - that&#39;s because from a drawing-node&#39;s point of
          view, an ideal rendering interface would be just:
        </p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>trait</span><span> </span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>buffer</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Buffer</span><span>,</span><span> </span><span>x</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>u16</span><span>);</span>
<span>}</span>
</pre>
        </div>

        <p>
          But this simplified interface doesn&#39;t work with &#34;combinator-nodes&#34;
          such as:
        </p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>struct</span><span> </span><span>Centered</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>body</span><span>:</span><span> </span><span>T</span><span>,</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>Node</span><span> </span><span>for</span><span> </span><span>Centered</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>buffer</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Buffer</span><span>,</span><span> </span><span>x</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>/* okk, how do i query `body` for its size? */</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <blockquote>
          <p>let&#39;s add a new method, then - <code>size()</code>!</p>
        </blockquote>

        <p>Sure:</p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>trait</span><span> </span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>size</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>(</span><span>u16</span><span>,</span><span> </span><span>u16</span><span>);</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>buffer</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Buffer</span><span>,</span><span> </span><span>x</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>u16</span><span>);</span>
<span>}</span>
</pre>
        </div>

        <p>
          That&#39;s cute, but what about nodes that don&#39;t inherently have static
          size? Like a text that wraps - its size depends on the provided width
          (the narrower you make the node, the longer it&#39;s going to be).
        </p>

        <p>This means you need something like:</p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>trait</span><span> </span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>size</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>width</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>height</span><span>:</span><span> </span><span>u16</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>(</span><span>u16</span><span>,</span><span> </span><span>u16</span><span>);</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>buffer</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Buffer</span><span>,</span><span> </span><span>x</span><span>:</span><span> </span><span>u16</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>u16</span><span>);</span>
<span>}</span>
</pre>
        </div>

        <p>
          But this, in turn, means that most of the time you&#39;re going to be
          walking your widget tree <i>twice</i> - once to size it and then
          another time to paint it, even if the inner-widget is already of known
          size.
        </p>

        <p>For instance, if you to had to print a row of non-wrapping text:</p>

        <div>
          <pre><span></span>| first | second | third |
</pre>
        </div>

        <p>
          ... then under the <code>size()</code> approach that would require
          calling each widget twice:
        </p>

        <div>
          <pre><span></span>- first.size()
- second.size()
- third.size()
- first.paint()
- second.paint()
- third.paint()
</pre>
        </div>

        <p>
          ... even though all of the widgets have up-front known sizes and even
          though we&#39;re not centering anything - can we do better?
        </p>

        <p>
          My library&#39;s nodes have two main methods, <code>paint()</code> and
          <code>mount()</code>:
        </p>

        <div>
          <pre><span></span><span>pub</span><span> </span><span>trait</span><span> </span><span>Node</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>paint</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>buffer</span><span>:</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>Buffer</span><span>,</span><span> </span><span>pos</span><span>:</span><span> </span><span>Pos</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>Size</span><span>,</span><span> </span><span>RSize</span><span>&gt;</span><span>;</span>
<span>    </span><span>fn</span><span> </span><span>mount</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>size</span><span>:</span><span> </span><span>Size</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>Size</span><span>&gt;</span><span>;</span>
<span>}</span>
</pre>
        </div>

        <p>Under this design:</p>

        <ul>
          <li>
            <p>
              when a node has static size (like a box with constant width and
              height or a text that doesn&#39;t wrap), its
              <code>paint()</code> always returns
              <code>Ok(ThatStaticSize)</code>,
            </p>
          </li>
          <li>
            <p>
              when a node needs help with determining its size, its
              <code>paint()</code> returns <code>Err</code> with a rough
              constraint (e.g. <code>width must be between 2..50</code>) -
              parent is then responsible for calling <code>mount()</code> with a
              proposed size until the child-node accepts the size via
              <code>mount()</code>, after which the parent calls
              <code>paint()</code> again.
            </p>
          </li>
        </ul>

        <p>
          So you can imagine <code>paint() = Err</code> as communicating to the
          parent <code>help, i need to get sized!</code>, which the parent then
          handles via <code>mount()</code>.
        </p>

        <p>
          This allows to handle the happy case (e.g. a row of sized widgets)
          without having to walk the tree multiple times, at a small &#34;cache
          miss&#34; penalty for when the child-node actually needs to get sized (in
          which case its
          <code>paint()</code> method would get called twice - but the first
          time wouldn&#39;t draw anything, it would insta-return <code>Err</code>).
        </p>

        <p>
          (most parents also cache the size of their childen, in which case a
          child can make <code>paint() = Err</code> to communicate to the parent
          that <code>help, i need to get re-sized!</code>, e.g. after you change
          a text.)
        </p>

        <p>
          Armed with this, I&#39;ve been able to successfully implement all of the
          basic combinators like <code>HStack</code> or <code>VStack</code>, and
          the code turned out only mildly spooky:
        </p>

        <p>
          <a href="https://codeberg.org/pwy/kruci/src/branch/main/src/nodes/stack.rs">https://codeberg.org/pwy/kruci/src/branch/main/src/nodes/stack.rs</a>
        </p>

        <p>
          ... and hey, it&#39;s
          <a href="https://codeberg.org/pwy/kruci/src/branch/main/tests/acc.rs">tested</a>!
        </p>

        <h2 id="summary"><a href="#summary"> Summary </a></h2>

        <p>
          As I said, I&#39;ve eventually abandoned the project - for the most part,
          I&#39;ve just realized that I need to pick my fights better.
        </p>

        <p>
          There&#39;s no pressure for kartoffels to have hyper-optimized user
          interface, Ratatui is <i>good enough</i> - as it stands, the game does
          not have any performance issues. The time I&#39;ve sacrificed to pursue
          this user inteface experiment could&#39;ve been spent better actually
          improving the game, developing new challenges and whatnot (optimizing
          Ratatui, even).
        </p>

        <p>
          Of course, both the game itself and this UI experiment are nothing
          more than side projects, <i>both</i> are written out of fun - so you
          well could argue: who cares, why bother being a project manager for
          yourself? Why bother creating a game on a hard mode, with
          server-rendered interface?
        </p>

        <p>
          I guess I&#39;d just like to see far I can get with this idea. Many people
          wrote to me that being able to just ssh into the game is a nice
          quality of life thingie, so I&#39;d like to continue with that as the
          &#34;core design choice&#34; and see what problems unfold.
        </p>

        <p>
          Sometimes in pursuing a larger goal I find myself lost in a sea of
          seemingly small, unlit corridors that I feel I need to explore -
          sometimes I do and it turns out good (<a href="https://pwy.io/posts/kartoffels-v0.7/">migrating from 64-bit RISC-V to 32-bit RISC-V</a>
          was a good choice), but sometimes you just have to push the brakes and
          roll back.
        </p>

        <p>
          I think it&#39;s okay to both explore and to give up, other paths await.
        </p>

        <p>
          <a href="https://codeberg.org/pwy/kruci">https://codeberg.org/pwy/kruci</a>
        </p>
      </div></div>
  </body>
</html>
