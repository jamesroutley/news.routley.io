<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.codethink.co.uk/articles/2024/secure_bootloader/">Original</a>
    <h1>A cryptographically secure bootloader for RISC-V in Rust</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p><a href="https://github.com/LawrenceHunter/SentinelBoot">SentinelBoot</a> is a demonstrative, cryptographically secure <a href="https://riscv.org">RISC-V</a> bootloader written in <a href="https://www.rust-lang.org">Rust</a>. This project forms a final-year project at <a href="https://www.manchester.ac.uk">The University of Manchester</a> sponsored by Codethink.</p>
<h2>Motivation</h2>
<p>Memory safety is a persistent issue in software, especially system software, such as bootloaders. Implementing some kinds of run-time safety checks can be very computationally expensive, as such, programming languages which employ them to promote memory safety are incompatible with system software due to performance degradation<sup id="fnref:1"><a href="#fn:1">1</a></sup>. That said, exploiting vulnerabilities that arise from a lack of memory safety leads to a myriad of issues, including data leaks, denial-of-service, and arbitrary code execution<sup id="fnref:2"><a href="#fn:2">2</a></sup>. Until recently, there has been no viable memory-safe alternative to C/C++/Assembly for such applications. However, the Rust programming language, which performs static analysis at compile time, has been presented as a viable alternative and has begun being explored for such applications, with projects such as <a href="https://rust-for-linux.com">Rust for Linux</a>.</p>
<p>SentinelBoot is a cryptographically secure bootloader aimed at enhancing boot flow safety of RISC-V through memory-safe principles, predominantly leveraging the Rust programming language with its ownership, borrowing, and lifetime constraints. Additionally, SentinelBoot employs public-key cryptography to verify the integrity of a booted kernel (digital signature), by the use of the RISC-V Vector Cryptography extension, establishing secure boot functionality. SentinelBoot achieves these objectives with a 20.1% hashing overhead (approximately 0.27s additional runtime) when compared to an example U-Boot binary (mainline at time of development), and produces a resulting binary one-tenth the size of an example U-Boot binary with half the memory footprint.</p>
<h2>Background</h2>
<p>There are three main principles employed by Rust that aid in reducing the likelihood of memory safety vulnerabilities. Note, however, the keyword ‘reduce’: a developer can overrule these checks, and even then, vulnerabilities can still exist in allegedly 100% safe, non-overruled Rust code, they’re just less likely<sup id="fnref:3"><a href="#fn:3">3</a></sup>. The three principles are:</p>
<ol>
<li>
<p>Ownership: aims to ensure that a piece of memory has a single &#39;owner&#39;. This is primarily to allow automatic deallocation when the owner goes out of scope, helping to prevent vulnerabilities such as memory leaks.</p>
</li>
<li>
<p>Borrowing: allows a variable that does not own a certain piece of memory to access the memory location, by &#39;borrowing&#39; from the owner, helping to prevent vulnerabilities such as data races due to the two types of borrowing that exist:</p>
<ul>
<li>
<p>Non-mutable (shared) borrows, where the borrower can read the data in the memory location but not write to it, any number of non-mutable borrows can exist simultaneously.</p>
</li>
<li>
<p>Mutable (exclusive) borrows, where the borrower can read and write to the memory location. If a mutable borrow exists, no other borrows (mutable or non-mutable) may exist.</p>
</li>
</ul>
</li>
<li>
<p>Lifetimes: defines the &#39;duration&#39; of a memory location (i.e. a variable has a lifetime from when it is declared to when it is last used) or of a borrow of that location (i.e. all borrows have a lifetime associated with them). This allows Rust to avoid using a garbage collector, as the memory location can be automatically deallocated when its lifetime expires, and it also allows the static analysis to determine if a program could be at risk of accessing a freed memory location, helping to prevent use-after-free errors.</p>
</li>
</ol>
<p>The Linux kernel&#39;s bootflow can be viewed as a sequential series of steps that load and execute the following stage, as seen below.</p>
<p><img alt="Kernel Bootflow" src="https://elijer.github.io/articles/2024/secure_bootloader/bootflow.png"/></p>
<h2>Threat Model</h2>
<p>SentinelBoot&#39;s threat model focuses on thin client devices which do not store their own OS and <a href="https://en.wikipedia.org/wiki/Over-the-air_update">over-the-air updates</a> (e.g. how phones are updated): both of these cases involve executable code being sent over a network, usually the internet. We ignore the risk of direct hardware modification, as an attacker can just swap out the bootloader (making any potential defence implemented by SentinelBoot in vain). Instead, SentinelBoot focuses on defending against a subclass of <a href="https://en.wikipedia.org/wiki/Social_engineering_(security)">social engineering</a> and <a href="https://en.wikipedia.org/wiki/Evil_maid_attack">Evil Maid</a> attack vectors, where the goal is to modify the root-of-trust. As well as defending against <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-In-The-Middle</a> attacks which undermine secure communication, shown below. Finally, SentinelBoot aims to prevent exploitation by minimising memory safety vulnerabilities.</p>
<p><img alt="Man-In-The-Middle attack" src="https://elijer.github.io/articles/2024/secure_bootloader/mitm.png"/></p>
<h2>Assembly to Rust</h2>
<p>Firstly, it is necessary to write a <a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html">linker script</a> to format the resulting binary into an <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF format</a>. Next, it is necessary to write RISC-V assembly to initialise hardware, including handling multiple hardware threads (HARTs), setting control and status registers, disabling interrupts, etc. The control flow is shown below.</p>
<p><img alt="Machine mode control flow" src="https://elijer.github.io/articles/2024/secure_bootloader/mm_control_flow.png"/></p>
<p>As a final-year university project, a decision was taken to limit the projects&#39; scope by allowing U-Boot to perform <a href="https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol">TFTP</a> operations on SentinelBoot&#39;s behalf. To support this decision, additional assembly was needed to handle executing from supervisor mode.</p>
<h2>&#39;Unsafe&#39; to &#39;Safe&#39; Rust</h2>
<p>The assembly code has now jumped to the Rust entry point, which is nominally memory-safe. The next two steps in the initialisation - initialising a serial driver and a memory allocator - both require a lot of unsafe work, which can be done in Rust with an <code>unsafe</code> overrule (this tells the compiler that certain operations it would otherwise be unprepared to permit are acceptable and that the programmer has verified that at the end of the overrule block memory-safety rules are now being observed). After that, there is a symbolic change from this &#34;unsafe&#34; Rust to &#34;truly safe&#34; Rust.</p>
<p>The serial driver implements <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a>, a simple protocol for asynchronous communication that groups data in frames according to an agreed configuration. The actual transmission is handled by a memory-mapped chip, so we need to set the configuration and wrap the raw register interactions with an API in order to enforce checks around unsafe operations. The control flow of the API is shown below.</p>
<p><img alt="Serial driver control flow" src="https://elijer.github.io/articles/2024/secure_bootloader/serial_driver.png"/></p>
<p>To allow dynamic memory allocation we need a memory allocator: doing so allows for more advanced data structures, such as vectors. By implementing the <a href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html">GlobalAlloc trait</a> and therefore facilitating more advanced data structures, SentinelBoot provides wider support for Rust crates. SentinelBoot implements a simple memory allocator based upon a doubly linked list of memory allocation structures. The doubly linked list data structure is useful as it allows bidirectional traversal of the data structure, allowing efficient amalgamation of allocations, as shown below.</p>
<p><img alt="Memory allocator amalgamation" src="https://elijer.github.io/articles/2024/secure_bootloader/allocator_amalgamation.png"/></p>
<p>Additionally, implementing the doubly linked list comes with its own problems: it violates Rust&#39;s borrowing rules as each allocation structure has mutable pointers to the next and previous structures, and therefore each structure is mutably borrowed twice. That said, it is possible to still safely implement the doubly linked list by wrapping the mutable borrows in a <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex</a> and performing accesses through them, shown below; however, the project deadline meant this feature was not implemented, as SentinelBoot only runs on a single HART, so a race is not possible.</p>
<p><img alt="Memory allocator mutex" src="https://elijer.github.io/articles/2024/secure_bootloader/allocator_mutex.png"/></p>
<h2>Verifying &amp; Booting</h2>
<p>Utilising a hashing function that provides properties such as <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">collision resistance, preimage resistance, and second pre-image resistance</a>, it is possible to be extremely confident of the integrity of a binary object. An example of a hashing algorithm that provides such properties is <a href="https://en.wikipedia.org/wiki/SHA-2">SHA256</a>, and therefore it was suitable for SentinelBoot. To hash the kernel we need to accurately determine the size of the kernel binary from just a pointer, as including a single extra memory location will completely change the result (due to the <a href="https://en.wikipedia.org/wiki/Avalanche_effect">avalanche effect</a>). Therefore, functionality to parse the kernel’s ELF header and sum the section sizes was required, shown below.</p>
<p><img alt="ELF binary parsing" src="https://elijer.github.io/articles/2024/secure_bootloader/elf_parsing.png"/></p>
<p>Hashing only goes so far: if we are sent a binary and an accompanying hash, we can verify they match - ensuring integrity - however, we need to ensure authenticity too. Currently, an attacker can simply intercept the kernel, inject malicious code, rehash, and then forward the malicious kernel and valid hash for that malicious kernel to SentinelBoot.</p>
<p>Therefore, to enhance the security model, we can utilise <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public key cryptography</a> (PKC). PKC utilises a pair of keys, one widely known and one secret, which are mathematically linked. Additionally, a <a href="https://en.wikipedia.org/wiki/Certificate_authority">trusted 3rd party</a> can verify the public key by using certificates. The operation of an example PKC system is shown below.</p>
<p><img alt="Public key cryptography operation" src="https://elijer.github.io/articles/2024/secure_bootloader/pkc.png"/></p>
<p>This would allow us to fully encrypt the kernel binary, ensuring it cannot be altered without the secret key. However, PKC works on fixed block sizes, only <a href="https://mbed-tls.readthedocs.io/en/latest/kb/cryptography/rsa-encryption-maximum-data-size/">245 bytes for RSA</a>, and performs expensive mathematical operations with very large numbers - as such it is far too slow.</p>
<p>However, by modifying PKC slightly, we only need to encrypt a small chunk of data: when the server hashes the kernel it can encrypt the hash with its private key (this is a &#34;<a href="https://en.wikipedia.org/wiki/Digital_signature">digital signature</a>&#34;). When SentinelBoot receives the hash, SentinelBoot will decrypt it with the server&#39;s public key (which can be verified by a certificate from a trusted 3rd party) to compare hashes, thereby authenticating the server (as an attacker would not be able to sign the kernel correctly without access to the server&#39;s private key). Further, as the hash could not have been re-encrypted, we also verify the integrity. This operation is shown below.</p>
<p><img alt="Digital signature operation" src="https://elijer.github.io/articles/2024/secure_bootloader/digital_signature.png"/></p>
<p>Finally, once the kernel has been verified, we can <a href="https://github.com/torvalds/linux/blob/e33c4963bf536900f917fb65a687724d5539bc21/Documentation/arch/riscv/boot.rst">set up for the kernel jump</a> by setting <code>a0</code> to contain the <code>HARTID</code> and <code>a1</code> to contain the address of the DTB. After debugging using Ghidra to decompile the kernel, and then comparing the decompiled instructions against the control flow shown in GDB, it was possible to achieve full booting, as shown below.</p>
<p><img alt="Kernel successful boot" src="https://elijer.github.io/articles/2024/secure_bootloader/kernel_execution_handoff.png"/></p>
<h2>Accelerating SHA256</h2>
<p>It is possible, due to <a href="https://www.codethink.co.uk/articles/2023/vcrypto_qemu/">support in QEMU</a>, to emulate the RISC-V Vector Cryptography extension to &#39;accelerate&#39; the SHA256 hashing of the kernel. The QEMU implementation is not optimised for speed, however, the extension is fully supported and therefore demonstrates functionality for future hardware support. The extension utilises <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a> principles to improve throughput.</p>
<p><img alt="SIMD operation" src="https://elijer.github.io/articles/2024/secure_bootloader/simd.png"/>
<img alt="SISD operation" src="https://elijer.github.io/articles/2024/secure_bootloader/sisd.png"/></p>
<p>As the <a href="https://wiki.riscv.org/display/HOME/Vector+Crypto+Standardization+Status+Summary">extension was only ratified in September 2023</a>, tooling is still in its infancy, so the vector cryptography assembly instructions had to be pre-assembled to be included.</p>
<p><img alt="Vector Cryptography instruction assembly" src="https://elijer.github.io/articles/2024/secure_bootloader/assembling.png"/></p>
<p>With the assembly instructions pre-assembled, the raw binary word could be included into Rust. Finally, the full SHA256 algorithm had to be implemented in vector cryptography assembly where the control flow operated on 512 bit chunks with 16 quad rounds. The SHA256 algorithm control flow is shown below.</p>
<p><img alt="SHA2 control flow" src="https://elijer.github.io/articles/2024/secure_bootloader/sha2.png"/></p>
<h2>Continuous Integration</h2>
<p>Throughout the development process, <a href="https://docs.github.com/en/actions">GitHub actions</a> were employed to verify all of SentinelBoot&#39;s targets were buildable, the code met <a href="https://doc.rust-lang.org/stable/clippy/usage.html">clippy</a> standards, and that SentinelBoot executed as expected both under emulation and on a <a href="https://www.starfivetech.com/en/site/boards">VisionFive 2</a> connected to a Raspberry Pi which acted as a rig controller.</p>
<h2>Analysis</h2>
<p>SentinelBoot achieves the secure boot mechanism with only a 20.1% performance overhead, compared to an example U-Boot binary.</p>
<p><img alt="Performance analysis" src="https://elijer.github.io/articles/2024/secure_bootloader/performance.png"/></p>
<p>Secondly, ~80% of lines were marked safe for the serial hashing implementation and ~68% of lines marked safe for vector cryptography implementation (due to SHA256 needing to be implemented in assembly).</p>
<p><img alt="Safe line serial analysis" src="https://elijer.github.io/articles/2024/secure_bootloader/safe_line_serial.png"/>
<img alt="Safe line vector cryptography analysis" src="https://elijer.github.io/articles/2024/secure_bootloader/safe_line_vector.png"/></p>
<p>Thirdly, SentinelBoot&#39;s resulting binary is approximately one-tenth the size of an example U-Boot binary at about 70kB.</p>
<table>
<thead>
<tr>
<th>Target</th>
<th>Binary Size (kB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>QEMU</td>
<td>73.824</td>
</tr>
<tr>
<td>QEMU Vector Cryptography</td>
<td>61.504</td>
</tr>
<tr>
<td>Visionfive 2</td>
<td>73.824</td>
</tr>
<tr>
<td>HiFive Unmatched</td>
<td>73.824</td>
</tr>
<tr>
<td>U-Boot example</td>
<td>742.70</td>
</tr>
</tbody>
</table>
<p>Finally, SentinelBoot compiles in approximately one-quarter the time of an example U-Boot binary, compiled with -j8, whereas Rust&#39;s toolchain does not fully utilise parallelism yet.</p>
<p><img alt="Compile time analysis" src="https://elijer.github.io/articles/2024/secure_bootloader/compile_time.png"/></p>
<h2>Conclusion</h2>
<p>By developing SentinelBoot, the utilisation of the Rust programming language (and memory-safe principles) to improve the memory safety of RISC-V bootflow has been shown, all while additionally implementing a cryptographic secure boot mechanism. SentinelBoot is able to execute both on hardware and under emulation, where the SHA256 implementation in QEMU is accelerated via the RISC-V Vector Cryptography extension. SentinelBoot achieves this functionality with ~80% of serial and ~68% vector cryptography safe line proportions. Even with the additional functionality and safety provided by SentinelBoot, when compared to an example U-Boot binary, SentinelBoot is one-tenth the size with only a 20.1% performance overhead.</p>
<h3>Concluding Remarks</h3>
<p>This blog post summarises the <a href="https://lawrencehunter.github.io/SentinelBoot-Thesis/SentinelBoot.pdf">SentinelBoot Thesis</a> and the corresponding <a href="https://github.com/LawrenceHunter/SentinelBoot">SentinelBoot GitHub</a>. Additionally, if you&#39;d like to discuss RISC-V or Codethink&#39;s work in Rust, contact <a href="mailto:sales@codethink.co.uk">sales@codethink.co.uk</a>.</p>

    </section></div>
  </body>
</html>
