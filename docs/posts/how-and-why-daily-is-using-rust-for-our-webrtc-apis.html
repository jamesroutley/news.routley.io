<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.daily.co/blog/how-and-why-daily-is-using-rust-for-our-webrtc-apis/">Original</a>
    <h1>How and why Daily is using Rust for our WebRTC APIs</h1>
    
    <div id="readability-page-1" class="page"><article>

            

            <figure>
                <img srcset="/blog/content/images/size/w300/2022/04/Rust-directory-image--1-.png 300w,
                                    /blog/content/images/size/w600/2022/04/Rust-directory-image--1-.png 600w,
                                    /blog/content/images/size/w1000/2022/04/Rust-directory-image--1-.png 1000w,
                                    /blog/content/images/size/w2000/2022/04/Rust-directory-image--1-.png 2000w" sizes="(max-width: 800px) 400px,
                                (max-width: 1170px) 1170px,
                                    2000px" src="https://www.daily.co/blog/content/images/size/w2000/2022/04/Rust-directory-image--1-.png" alt="How and why Daily is using Rust for our WebRTC APIs"/>
            </figure>

            <section>
                <div>
                    <h2 id="introduction">Introduction</h2><p>Daily provides user-friendly WebRTC APIs to help customers build video and audio call functionality into their applications. As part of this goal, we strive to support a multitude of platforms for our customers. Up until now, however, Daily has not offered <em>true</em> native development support. Our offering has included a <a href="https://docs.daily.co/reference/rest-api">REST API</a>, a <a href="https://docs.daily.co/reference/daily-js">JavaScript library</a>, and a <a href="https://docs.daily.co/reference/rn-daily-js">React Native</a> library.</p><p>That&#39;s not to say one couldn&#39;t build iOS and Android apps with Daily before. For example, our <a href="https://www.daily.co/blog/how-to-build-a-billion-dollar-audio-app-in-a-weekend/">Party Line audio-only demo</a> uses a headless WebView to load <code>daily-js</code> on iOS and Android devices. While this worked for our purpose, it was still not a truly native experience.</p><p>We&#39;re using <a href="https://www.rust-lang.org/">Rust</a> to change that!</p><p>In this post, we&#39;ll tell you a little bit about how we utilize Rust at Daily and why we chose Rust to build <code>daily-core</code>: the Daily library to rule them all.</p><h2 id="what-are-we-doing-with-rust">What are we doing with Rust?</h2><p>We&#39;ve used Rust to create a central, cross-platform library called <code>daily-core</code>. <code>daily-core</code> is intended to sit behind lightweight, platform-specific API wrappers. This allows us to keep our core business logic consistent across platforms while taking full advantage of the various native platforms’ capabilities.</p><p>The platform-specific wrappers communicate with this core layer using a Foreign Function Interface (FFI) layer (<a href="https://webassembly.org/">WebAssembly</a> for web APIs, C for native APIs).</p><p>The main challenge of interfacing our Rust code with WebRTC has to do with WebRTC’s C++ API, which is typically not a problem for browser vendors, as most modern browsers are also written in C++. However, Rust, as most other languages, cannot interface directly with C++ due to lack of Application Binary Interface (ABI) stability. This is why we wrote and maintain a thin C layer around the WebRTC APIs we need to use. Rust also helps us here as we can write thin, “smart” types around some necessary C++ types like smart pointers to ensure we are handling different kinds of pointer and memory lifetimes across all levels of the stack.</p><blockquote>Smart pointers are a feature of modern C++. A <a href="https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170">smart pointer</a> lives on the stack and wraps a &#34;bare&#34; pointer. The smart pointer then handles destruction of the underlying resource when it goes out of scope, allowing developers to do less manual memory management by hand.</blockquote><figure><img src="https://www.daily.co/blog/content/images/2022/03/image-1.png" alt="A markdown graphic showing Daily&#39;s native stack with daily-core. From top to bottom layers: libwebrtc + libmediasoupclient, FFI, daily-core, FFI, platform-specific wrappers." loading="lazy" width="478" height="612"/><figcaption>Native/mobile stack with daily-core</figcaption></figure><h2 id="why-did-we-choose-rust">Why did we choose Rust?</h2><p>As previously mentioned, one of the main goals of this initiative was to provide consistent core business logic across all platforms. Additionally, we also wanted to provide APIs that feel native to each platform, while minimizing the differences between the different platforms. This should allow our customers to more easily reason about <em>how</em> they are interacting with our APIs when developing applications in different platforms, and help them feel confident that all of their applications will behave exactly the same no matter the platform of their choosing.</p><p>Of course, this includes the Web as many of our customers also wish to provide browser-native versions of their applications.</p><p>The two main options we considered for building our core library were C++ and Rust.</p><p>Some of our favorite features of Rust include:</p><ul><li>Multi platform cross-compilation, especially <a href="https://webassembly.org/">WebAssembly</a></li><li>Memory management advantages with Rust’s borrow checker</li><li>A robust, extensible type system</li><li>A concurrency model which gives us the control we want without introducing complexity</li><li>Performance on-par with C++</li><li>A rich package (crate) <a href="https://crates.io/">ecosystem</a></li></ul><p>Now, let&#39;s look at these features and why they suit our vision for <code>daily-core</code> so well in a little more detail.</p><h3 id="webassembly-as-a-first-class-citizen">WebAssembly as a first class citizen</h3><p>Rust supports WebAssembly as a first class citizen. It is possible to compile C++ to WASM, but not as nicely supported as it is with Rust. Rust has a <a href="https://github.com/rustwasm">whole host of active projects</a> aimed toward enabling convenient interaction with WebAssembly. Take <a href="https://github.com/rustwasm/gloo">gloo</a> for example, which provides a collection of Rust wrappers for browser APIs. For C++, the options for compiling to WASM runtimes are limited to <a href="https://emscripten.org/">Emscripten</a>.</p><h3 id="safety-advantages">Safety advantages</h3><p>We also liked the safety and memory management advantages Rust offered over C++. Rust&#39;s borrow checker lowers the cognitive load compared to C++ when dealing with memory and ownership. Our developers don&#39;t have to worry about preventing dangling pointers or data races at runtime. Rust&#39;s compiler, <a href="https://doc.rust-lang.org/rustc/what-is-rustc.html">rustc</a>, will help us catch these issues much earlier than we might with C++. We decided that it would be easier to write code safely <em>and</em> debug it over time with Rust.</p><h3 id="robust-type-system">Robust type system</h3><p>Rust’s robust type system brings several key advantages that help us feel confident in the quality of the product we are developing.</p><p>By wrapping WebRTC’s C++ API with Rust, we have access to richer types which can eliminate entire classes of problems which otherwise would require significant changes to WebRTC itself. These richer types can carry information that is used during type checking and erased afterwards, ensuring that there is no runtime cost for the benefit of having safer code.</p><p>One such use case is related to WebRTC’s threading model. WebRTC makes use of three threads with different purposes: a network thread, a signaling thread, and a worker thread. These threads are not interchangeable and different interactions with WebRTC require the use of different threads.</p><p>An example is the creation of media devices and the media tracks from those devices. All of these should occur in the same thread (the worker thread), but the WebRTC C++ APIs for interacting with media devices and creation of media tracks only require that <em>a</em> thread is passed as a parameter, and it is up to the developer to ensure that it is the same worker thread in both cases.</p><p>In Rust, we can write a thin wrapper around WebRTC threads as follows:</p><pre><code>pub trait ThreadPurpose {};

pub struct Network;

Impl ThreadPurpose for Network;

Pub struct Signaling;

Impl ThreadPurpose for Signaling;

Pub struct Worker;

Impl ThreadPurpose for Worker;

pub struct Thread&lt;T: ThreadPurpose&gt; {
  thread_ptr: AtomicPtr&lt;webrtc::Thread&gt;,
  Phantom_data: PhantomData&lt;T&gt;
}

Impl Thread&lt;Network&gt; {
   // This will always create a `Network` thread
  Pub fn new() -&gt; Self { … }
}

Impl Thread&lt;Signaling&gt; {
   // This will always create a `Signaling` thread
  Pub fn new() -&gt; Self { … }
}

Impl Thread&lt;Worker&gt; {
   // This will always create a `Worker` thread
  Pub fn new() -&gt; Self { … }
}
</code></pre><p>Now, whenever we have a Rust method or function calling into WebRTC which requires one of these threads, it can have a signature like the following artificial example:</p><pre><code>fn call_webrtc_function(worker_thread: Thread&lt;Worker&gt;, …) { … }
</code></pre><p>This Rust function only accepts a thread of type <code>Thread&lt;Worker&gt;</code>, which can be created via <code>Thread::&lt;Worker&gt;::new()</code>. If we would attempt to pass a non-worker thread to this function (maybe as a result of a refactoring gone wrong), the compiler immediately lets us know that the thread we are passing is not of the right type, and we avoid getting hit with a nasty runtime exception when WebRTC detects that the wrong thread was used. To make things even better, this kind of approach to type-safety also brings no performance impact as the type markers are erased at compile-time, so we get all the same performance, but with the benefit of having the Rust type-checker looking over our shoulder.</p><p>Rust’s excellent error messages, combined with <a href="https://github.com/rust-lang/rust-clippy">Clippy</a>, a linter that catches common mistakes and anti-patterns, makes sure we stay productive while following the language’s best-practices.</p><p>By compiling our Rust code to WebAssembly, we can bring all of these type-safety advantages to the Web, where normally our developers would be subject to the well-documented warts and gotchas of JavaScript.</p><h3 id="concurrency-independent-of-thread-count">Concurrency independent of thread count</h3><p>In addition, Rust&#39;s <a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">async/.await</a> allows us to express concurrent logic regardless of whether we&#39;re running on a single thread or not. This is particularly important for the WebAssembly use case.</p><p>Most major browsers support WebAssembly threads as of the time of writing, but we also wanted to ensure we supported the largest set of devices possible, particularly in mobile platforms. Therefore, it was important to ensure that our code can run even in browser versions with more basic WebAssembly support.</p><p>This means that whenever we decide to throw the switch to multi-threaded WebAssembly, essentially no code needs to change as all of our logic is <em>already</em> written in a concurrent-friendly manner. We simply reap the benefits of a multi-threaded runtime on the Web.</p><h3 id="performance">Performance</h3><p>Performance-wise, Rust is on par with C++ and in some cases even beats it, as we can see by comparing the performance and resource usage of both <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/measurements/rust.html">Rust</a> and <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/measurements/gpp.html">C++</a> in <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">Benchmarks Game</a>.</p><p>The lack of garbage collection in Rust ensures the performance of our libraries is predictable, and that our code is as lightweight as we can write it.</p><h3 id="rich-crate-ecosystem">Rich crate ecosystem</h3><p>Aside from the language itself, the Rust <a href="https://doc.rust-lang.org/rust-by-example/crates.html">crate</a> ecosystem is extremely rich. We stand on the shoulders of giants with high quality, well maintained, and well documented libraries that reduce the amount of work a project of this nature would entail. This goes for everything from robust, battle-tested asynchronous runtimes such as <a href="https://tokio.rs/">Tokio</a>, to versatile JSON serialization via <a href="https://serde.rs/"><code>serde</code></a>, to automatic binding generation with <a href="https://rustwasm.github.io/wasm-bindgen/"><code>wasm-bindgen</code></a> and <a href="https://rust-lang.github.io/rust-bindgen/"><code>bindgen</code></a>.</p><p>We also make use of the excellent Rust tooling ecosystem to ensure software supply chain quality via <a href="https://github.com/EmbarkStudios/cargo-deny"><code>cargo-deny</code></a>, which allows us to automatically audit our codebase for known security vulnerabilities.</p><h2 id="what-are-our-long-term-plans-for-rust">What are our long term plans for Rust?</h2><p>Keep improving! With a single core library at the root of all of our APIs, the performance, stability, and other improvements we make can immediately benefit all the platform-specific wrappers that consume it.</p><p>From here, we can build on a solid foundation to create lightweight, easy to use platform libraries for Daily&#39;s customers to use when building their applications.</p><p>We hope this brief primer about how — and why — we use Rust at Daily has been interesting. Please <a href="https://www.daily.co/contact">reach out</a> if you have any questions or thoughts about Daily or our journey into building a single core to rule them all with Rust.</p><p>If you’re curious to learn more about how we’re developing a cross-platform WebRTC using Rust and WebAssembly at Daily, check out <a href="https://www.youtube.com/watch?v=rjbxhv_U9tw">the recording of our talk at Kranky Geek</a>!</p><!--kg-card-begin: markdown--><p><sub>Rust logo by Mozilla is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</sub></p>
<!--kg-card-end: markdown-->
                </div>
            </section>


        </article></div>
  </body>
</html>
