<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mazzo.li/posts/stopping-linux-threads.html">Original</a>
    <h1>How to stop Linux threads cleanly</h1>
    
    <div id="readability-page-1" class="page"><div id="wrapper">



<div>
<p>Let’s say you’re writing a long running multi-threaded application, on Linux. Maybe it’s a database or a server of some sort. Let’s also imagine that you’re not running on some managed runtime (maybe the JVM, Go, or BEAM), but rather managing threads spawned using the <a href="https://man7.org/linux/man-pages/man2/clone.2.html"><code>clone</code></a> syscall. Think of threads created in C with <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html"><code>pthread_create</code></a>, or using C++’s <a href="https://en.cppreference.com/w/cpp/thread/thread/thread"><code>std::thread</code></a>.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Once you get into the business of starting threads, you’re probably also in the business of stopping them. However the former is much easier than the latter. With “stopping” I mean stopping the thread while giving it a chance to run some cleanup operations before fully terminating. Or in other words, we want to terminate a thread while ensuring that memory is freed, locks are released, logs are flushed, and so on.<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>This task is sadly not as straightforward as it should be, and there definitely isn’t a one-size-fits-all solution. This blog post aims to give an overview of the problem space and to highlight some pitfalls in an area with no shortage, and present <a href="#rseq">a little magic trick at the end.</a></p>
</div>

<h2 id="quasi-busy-looping">(Quasi-)busy looping <a href="#quasi-busy-looping">#</a></h2>
<p>If you can afford it, you can structure each thread as such:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>stop<span>)</span> <span>{</span> <span>break</span><span>;</span> <span>}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span>// Perform some work completing in a reasonable time</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p><code>stop</code> here is a per-thread boolean. When we want to stop a thread, we set <code>stop</code> to <code>true</code>, and then call <a href="https://man7.org/linux/man-pages/man3/pthread_join.3.html"><code>pthread_join</code></a> or equivalents to ensure that the thread has actually terminated.</p>
<p>Here’s a contrived but working example in C++:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;thread&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;atomic&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;stdio.h&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;unistd.h&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>std::</span>atomic<span>&lt;</span><span>bool</span><span>&gt;</span> stop <span>=</span> <span>false</span><span>;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>thread thr<span>([]</span> <span>{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span>// prints every second until stopped</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> <span>!</span>stop<span>.</span>load<span>();</span> i<span>++)</span> <span>{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>      printf<span>(</span><span>&#34;iterated </span><span>%d</span><span> times</span><span>\n</span><span>&#34;</span><span>,</span> i<span>);</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>      sleep<span>(</span><span>1</span><span>);</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    printf<span>(</span><span>&#34;thread terminating</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span>});</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span>// waits 5 seconds, then stops thread</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  sleep<span>(</span><span>5</span><span>);</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  stop<span>.</span>store<span>(</span><span>true</span><span>);</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  thr<span>.</span>join<span>();</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  printf<span>(</span><span>&#34;thread terminated</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>0</span><span>;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div>
<p>Which prints:</p>
<div>
<pre><code>iterated 0 times
iterated 1 times
iterated 2 times
iterated 3 times
iterated 4 times
thread terminating
thread terminated</code></pre>
</div>
<p>If you can write or refactor your code to work in such time slices, then terminating threads is very easy.</p>
<p>Note that the loop body does not need to be fully non blocking – it just needs to be terminated as quickly as we want our termination to be quick. For instance, if our thread is reading from a socket, we could set <code>SO_TIMEOUT</code> to be 100 milliseconds so that we know that every iteration of the loop will terminate quickly.<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
</div>

<h2 id="what-if-i-want-to-block-forever">What if I want to block forever? <a href="#what-if-i-want-to-block-forever">#</a></h2>
<div>
<p>Quasi-busy loops are all well and good, but they’re sometimes not desirable. The most common roadblock is foreign code that we don’t control which does not fit this pattern – think of a third-party library doing some blocking network call.</p>
<p>As we’ll see later, there’s essentially no clean way to stop a thread running code we don’t control, but there are other reasons to not want to write all our code with the quasi-busy loop pattern.</p>
<p>If we have many threads even relatively slow timeouts might cause significant scheduling overhead due to spurious wakeups, especially on an already busy system. The timeouts will also make debugging and inspecting the system considerably more annoying (e.g. imagine what the output of <code>strace</code> would look like).</p>
<p>So it is worth thinking about how to stop a thread while it is blocked on a syscall. The most straightforward way to do that is through signals.<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
</div>

<h2 id="we-need-to-talk-about-signals">We need to talk about signals <a href="#we-need-to-talk-about-signals">#</a></h2>
<div>
<p>Signals are the main way to interrupt execution of a thread without explicit coordination of the interrupted thread, and are therefore very relevant to the topic of this blog post. They’re also a bit of a mess. These two facts generate unhappiness.</p>
<p>For a good overview on signals I recommend the surprisingly informative <a href="https://man7.org/linux/man-pages/man7/signal.7.html">man page</a>, but I’ll give a sufficient overview here. If you already know how signals work,<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a> you can skip to <a href="#thread-cancellation">the next section</a>.</p>
<p>Signals can arise because of some hardware exception<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a> or be initiated by software. The most familiar instance of a software-initiated signal is your shell sending SIGINT to the foreground process when you press <code>ctrl-c</code>. All signals initiated by software originate from a handful of syscalls – for instance <a href="https://man7.org/linux/man-pages/man3/pthread_kill.3.html"><code>pthread_kill</code></a> will send a signal to a thread.<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>Hardware initiated signals are generally handled immediately, while software initiated signals are handled when a CPU is about to re-enter user mode after the kernel has done some work.<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a> In any event, when a signal needs to handled in a given thread:</p>
<ol type="1">
<li><p>If the signal has been blocked by the receiving thread, it’ll wait to be handled until it is unblocked;</p></li>
<li><p>If the signal is not blocked, it might be:</p>
<ol type="a">
<li>ignored;</li>
<li>handled in the “default” manner;</li>
<li>handled using some custom signal handler.</li>
</ol></li>
</ol>
</div>

<p>Which signals are blocked is controlled by modifying the <em>signal mask</em> using <a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html"><code>sigprocmask</code></a>/<a href="https://man7.org/linux/man-pages/man3/pthread_sigmask.3.html"><code>pthread_sigmask</code></a>, and which action is taken if the thread is not blocked is controlled by <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html"><code>sigaction</code></a>.</p>
<p>Assuming that the signal is <em>not</em> blocked, paths 2.a and 2.b will be managed entirely by the kernel, while path 2.c will cause the kernel to pass control to a user-space signal handler which will do something with the signal.</p>
<p>Importantly, if some thread is in a syscall (for instance blocked while reading from a socket), and a signal needs to be handled, the syscall will return early with error code <code>EINTR</code> after the signal handler has run.</p>
<p>The signal handler code is subject <a href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">to various constraints</a>, but otherwise it can do as it pleases, including deciding to not give back control to the code that was executing before. By default, most signals just cause the program to stop abruptly, possibly with a core dump. In the next few sections we’re going to explore various ways to use signals to stop our threads.</p>
<h2 id="thread-cancellation">Thread cancellation, a false hope <a href="#thread-cancellation">#</a></h2>
<p>Let’s first examine a way to stop threads, implemented through signals, which would seem to do exactly what we want: thread cancellation.</p>
<p>The API for thread cancellation is very promising. <a href="https://man7.org/linux/man-pages/man3/pthread_cancel.3.html"><code>pthread_cancel(tid)</code></a> will “cancel” thread <code>tid</code>. The way <code>pthread_cancel</code> works boils down to:</p>
<ol type="1">
<li>A special signal is sent to thread <code>tid</code>;</li>
<li>The libc you’re using (say <a href="https://en.wikipedia.org/wiki/Glibc">glibc</a> or <a href="https://en.wikipedia.org/wiki/Musl">musl</a>) sets up a handler so that when the cancel signal is received the thread winds down.</li>
</ol>
<p>There are additional details, but that’s essentially all there is to it. However, trouble lies ahead.</p>
<h3 id="resource-management-thread-cancellation">Resource management + thread cancellation = 😢 <a href="#resource-management-thread-cancellation">#</a></h3>
<p>Recall that signals can essentially arise anywhere in your code. So if we have code such as</p>
<div>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>lock<span>();</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>// critical work here</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>unlock<span>();</span></span></code></pre></div>
</div>
<p>we might get a signal in the critical section. In the case of thread cancellation, our thread might get cancelled while we’re holding a lock as above, or with some memory to be freed, or in general with some outstanding resource, and our cleanup code will never run. This is not good.</p>
<p>There are some mitigating circumstances, although none sufficient:</p>
<ul>
<li><p>Thread cancellation can be temporarily disabled. So we could disable it any time we are in such a critical section.</p>
<p>However some “critical sections” are very long (consider the lifespan of some allocated memory), and moreover we’d have to make sure to decorate all relevant code by enabling/disabling cancellation at the right time.</p></li>
<li><p>Linux threads include facilities to add/remove global cleanup handlers with <a href="https://man7.org/linux/man-pages/man3/pthread_cleanup_push.3.html"><code>pthread_cleanup_push</code></a> and <code>pthread_cleanup_pop</code>. These cleanup handlers <em>are</em> run when a thread is cancelled.</p>
<p>However to ensure safety using these functions one would have to again decorate every critical section with not only with a push/pop, but also temporarily disabling cancellations to avoid races as we setup the cleanup.</p>
<p>Again, this would be very error prone and would slow down our code considerably.</p></li>
<li><p>By default the signal sent by thread cancellation is only received at “cancellation points”, which to a first approximation are the syscalls that might block – see <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html"><code>pthreads(7)</code></a>.</p>
<p>So really we would only run into trouble if we have such a syscall in the critical sections. But again, we’d have to manually ensure that either critical section have no cancellation points, or that they’re made safe otherwise (possibly with the two measures described above).</p></li>
</ul>
<h3 id="thread-cancellation-is-incompatible-with-modern-c">Thread cancellation is incompatible with modern C++ <a href="#thread-cancellation-is-incompatible-with-modern-c">#</a></h3>
<div>
<p>If you’re a C++/Rust programmer, you might have sneered at the explicit locking above – you’ve got RAII to handle such cases:</p>
<div>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span>const</span> <span>std::</span>lock_guard<span>&lt;</span><span>std::</span>mutex<span>&gt;</span> lock<span>(</span>mutex<span>);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span>// critical work here</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span>// The destructor for `lock` will do the unlocking</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
</div>
<p>You might have also been wondering what happens if a thread cancellation arrives in the RAII-managed critical section here.</p>
<p>The answer is that thread cancellation will trigger a stack unwinding very much like throwing an exception would (in fact it’s implemented with a special exception), which means that destructors <em>will</em> be run on cancellation. This mechanism is known as <em>forced unwinding</em>. Great, right?<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<p>Well, since thread cancellation is implemented using exceptions, and thread cancellation can happen in arbitrary places, <a href="https://gcc.gnu.org/legacy-ml/gcc/2017-08/msg00121.html">we’re always liable to a cancellation happening in a <code>noexcept</code> block</a>, which will cause your program to crash via <a href="https://en.cppreference.com/w/cpp/error/terminate"><code>std::terminate</code></a>.</p>
<p>So since C++11, and especially since C++14 where destructors are marked as <code>noexcept</code> by default, thread cancellation is essentially useless in C++.<a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
</div>

<h3 id="forced-unwinding-is-unsafe-anyway">Forced unwinding is unsafe anyway <a href="#forced-unwinding-is-unsafe-anyway">#</a></h3>
<div>
<p>However note that even if this mechanism worked in C++, it’d still not be safe in many situations. Consider situations like:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span>const</span> <span>std::</span>lock_guard<span>&lt;</span><span>std::</span>mutex<span>&gt;</span> lock<span>(</span>mutex<span>);</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  balance_1 <span>+=</span> x<span>;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  balance_2 <span>-=</span> x<span>;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>If we get forcefully unwound after <code>balance_1 += x</code>, our invariants go out of the window. This is why Java’s form of forced unwinding, <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html"><code>Thread.stop</code></a>, was deprecated.<a href="#fn11" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
</div>

<h2 id="you-cant-cleanly-stop-threads-running-code-you-dont-control">You can’t cleanly stop threads running code you don’t control <a href="#you-cant-cleanly-stop-threads-running-code-you-dont-control">#</a></h2>
<p>As a brief aside, the nature of signals (and by extension thread cancellation) implies that it’s impossible to cleanly stop code that you don’t control. You cannot guarantee that memory isn’t leaked, files are closed, global locks are released, and so on.</p>
<p>If you need to interrupt foreign code reliably, it’s better to isolate it in its own process. It might still leak temporary files and other such persistent resources, but most relevant state would be cleaned up by the operating system when the process dies.</p>
<h2 id="controlled-thread-cancellation">Controlled thread cancellation <a href="#controlled-thread-cancellation">#</a></h2>
<div>
<p>Hopefully you’re now convinced that unrestricted thread cancellation is not a great idea in most circumstances. However we can pick the circumstances explicitly by enabling thread cancellation only at specific times. So our event loop becomes:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>pthread_setcancelstate<span>(</span>PTHREAD_CANCEL_DISABLE<span>);</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  pthread_setcancelstate<span>(</span>PTHREAD_CANCEL_ENABLE<span>);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span>// syscall that might block indefinitely, e.g. reading</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span>// from a socket</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  pthread_setcancelstate<span>(</span>PTHREAD_CANCEL_DISABLE<span>);</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span>// Perform some work completing in a reasonable time</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We turn off thread cancellation by default, but turn it back on as we do our blocking syscall.<a href="#fn12" id="fnref12" role="doc-noteref"><sup>12</sup></a></p>
<p>Refactoring our code to fit this pattern might seem onerous. However many applications with long lived threads already contain loops with a blocking syscall at the beginning (reading from a socket, sleeping on a timer, and so on), followed by some work that will not block indefinitely.</p>
</div>

<h2 id="homegrown-thread-cancellation">Homegrown thread cancellation <a href="#homegrown-thread-cancellation">#</a></h2>
<div>
<p>However once we’ve done this, it might be worth getting rid of thread cancellation entirely. Relying on the stack unwinding to free resources would not be portable to alternative libcs, and we’d need to be <a href="https://udrepper.livejournal.com/21541.html">fairly careful</a> if we wanted to perform some explicit cleanup actions outside destructors.</p>
<p>So instead we can work with signals directly. We can pick SIGUSR1 as our “stopping” signal, install a handler which sets our stopping variable, and check the variable before doing blocking syscalls.<a href="#fn13" id="fnref13" role="doc-noteref"><sup>13</sup></a></p>
<p><a href="https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/7f5a705198f5f9c3c250d24ec085bb75796a4752">Here’s a worked out example in C++.</a> The interesting parts of the code are setting up the signal handler:</p>
</div>

<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>// thread_local isn&#39;t really necessary here with one thread,</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>// but it would be necessary if we had many threads we wanted</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>// to kill separately.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>thread_local</span> <span>std::</span>atomic<span>&lt;</span><span>bool</span><span>&gt;</span> stop <span>=</span> <span>false</span><span>;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>void</span> stop_thread_handler<span>(</span><span>int</span> signum<span>)</span> <span>{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  stop<span>.</span>store<span>(</span><span>true</span><span>);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span>// install signal handler</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span>{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span>struct</span> sigaction act <span>=</span> <span>{{</span> <span>0</span> <span>}};</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    act<span>.</span>sa_handler <span>=</span> <span>&amp;</span>stop_thread_handler<span>;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>sigaction<span>(</span>SIGUSR1<span>,</span> <span>&amp;</span>act<span>,</span> <span>nullptr</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>      die_syscall<span>(</span><span>&#34;sigaction&#34;</span><span>);</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span></code></pre></div>
<p>And the code checking the flag before running the syscall:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>ssize_t</span> recvlen<span>;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span>if</span> <span>(</span>stop<span>.</span>load<span>())</span> <span>{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span>break</span><span>;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span>}</span> <span>else</span> <span>{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  recvlen <span>=</span> recvfrom<span>(</span>sock<span>,</span> buffer<span>.</span>data<span>(),</span> buffer<span>.</span>size<span>(),</span> <span>0</span><span>,</span> <span>nullptr</span><span>,</span> <span>nullptr</span><span>);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span>if</span> <span>(</span>recvlen <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> errno <span>==</span> EINTR <span>&amp;&amp;</span> stop<span>.</span>load<span>())</span> <span>{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span>// we got the signal while running the syscall</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span>break</span><span>;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>However, the code checking the flag and starting the syscall is racy:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>if</span> <span>(</span>stop<span>.</span>load<span>())</span> <span>{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span>break</span><span>;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span>}</span> <span>else</span> <span>{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span>// signal handler runs here, syscall blocks until</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span>// packet arrives -- no prompt termination!</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  recvlen <span>=</span> recvfrom<span>(</span>sock<span>,</span> buffer<span>.</span>data<span>(),</span> buffer<span>.</span>size<span>(),</span> <span>0</span><span>,</span> <span>nullptr</span><span>,</span> <span>nullptr</span><span>);</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div>
<p>There’s no easy way to check the flag and run the syscall atomically.<a href="#fn14" id="fnref14" role="doc-noteref"><sup>14</sup></a></p>
<p><a href="https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/139cc58cbdbba88ef311f7ea1b47a06050f03016">Another approach to this problem</a> would be to have USR1 blocked normally, and unblock it only when the syscall runs, similarly to what we did with the temporary thread cancellation. If the syscall terminates with <code>EINTR</code>, we know that we should quit.<a href="#fn15" id="fnref15" role="doc-noteref"><sup>15</sup></a></p>
<p>Sadly the race is still there, just between the unblocking and running the syscall:</p>
</div>

<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ptread_sigmask<span>(</span>SIG_SETMASK<span>,</span> <span>&amp;</span>unblock_usr1<span>);</span> <span>// unblock USR1</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>// signal handler runs here, syscall blocks until</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>// packet arrives -- no prompt termination!</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span>ssize_t</span> recvlen <span>=</span> recvfrom<span>(</span>sock<span>,</span> buffer<span>.</span>data<span>(),</span> buffer<span>.</span>size<span>(),</span> <span>0</span><span>,</span> <span>nullptr</span><span>,</span> <span>nullptr</span><span>);</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>ptread_sigmask<span>(</span>SIG_SETMASK<span>,</span> <span>&amp;</span>block_usr1<span>);</span> <span>// block USR1 again</span></span></code></pre></div>
<h3 id="changing-the-sigmask-atomically">Changing the sigmask atomically <a href="#changing-the-sigmask-atomically">#</a></h3>
<div>
<p>However, there often <em>is</em> an easy to atomically change the sigmask and run a syscall:</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man2/select.2.html"><code>select</code></a>/<a href="https://man7.org/linux/man-pages/man2/poll.2.html"><code>poll</code></a>/<a href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html"><code>epoll_wait</code></a> have <code>pselect</code>/<code>ppoll</code>/<code>epoll_pwait</code> variants which take a <code>sigmask</code> argument;</li>
<li><code>read</code>/<code>write</code> and similar syscalls can be replaced by their non-blocking versions and a blocking <code>ppoll</code>;</li>
<li>To sleep one can use <a href="https://man7.org/linux/man-pages/man2/timerfd_create.2.html"><code>timerfd</code></a> or just <code>ppoll</code> with no file descriptors but with a timeout;</li>
<li>The newly added <a href="https://man7.org/linux/man-pages/man2/io_uring_enter.2.html"><code>io_uring_enter</code></a> supports this use case out of the box.</li>
</ul>
<p>The syscalls above already cover a very large footprint.<a href="#fn16" id="fnref16" role="doc-noteref"><sup>16</sup></a></p>
</div>

<p>In this style, the <a href="https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/9bd6b18f6329a0b07cba5cb38d3c45bbf27ae968">receive loop of the program becomes</a>:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>struct</span> pollfd pollsock <span>=</span> <span>{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span>.</span>fd <span>=</span> sock<span>,</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span>.</span>events <span>=</span> POLLIN<span>,</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span>};</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span>if</span> <span>(</span>ppoll<span>(&amp;</span>pollsock<span>,</span> <span>1</span><span>,</span> <span>nullptr</span><span>,</span> <span>&amp;</span>usr1_unmasked<span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>errno <span>==</span> EINTR<span>)</span> <span>{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span>break</span><span>;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  die_syscall<span>(</span><span>&#34;ppoll&#34;</span><span>);</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span>ssize_t</span> recvlen <span>=</span> recvfrom<span>(</span>sock<span>,</span> buffer<span>.</span>data<span>(),</span> buffer<span>.</span>size<span>(),</span> <span>0</span><span>,</span> <span>nullptr</span><span>,</span> <span>nullptr</span><span>);</span></span></code></pre></div>
<h3 id="rseq">Making it work with any syscall <a href="#rseq">#</a></h3>
<div>
<p>Sadly, not all syscalls have variants which let us atomically change the sigmask as they execute. <a href="https://man7.org/linux/man-pages/man2/futex.2.html"><code>futex</code></a>, the main syscall used to implement userspace concurrency primitives, is a notable example of a syscall which does <em>not</em> include such a facility.<a href="#fn17" id="fnref17" role="doc-noteref"><sup>17</sup></a></p>
<p>In the case of <code>futex</code> one can interrupt threads through <code>FUTEX_WAKE</code>, but it turns out we can setup a mechanism to safely check the boolean stop flag atomically with starting <em>any</em> syscall.<a href="#fn18" id="fnref18" role="doc-noteref"><sup>18</sup></a></p>
<p>To recap, the problematic code <a href="https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/7f5a705198f5f9c3c250d24ec085bb75796a4752">looks like this</a>:</p>
</div>

<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>if</span> <span>(</span>stop<span>.</span>load<span>())</span> <span>{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span>break</span><span>;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span>}</span> <span>else</span> <span>{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span>// signal handler runs here, syscall blocks until</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span>// packet arrives -- no prompt termination!</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  recvlen <span>=</span> recvfrom<span>(</span>sock<span>,</span> buffer<span>.</span>data<span>(),</span> buffer<span>.</span>size<span>(),</span> <span>0</span><span>,</span> <span>nullptr</span><span>,</span> <span>nullptr</span><span>);</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div>
<p>If we could know that no signal handler is ran between the flag check and the syscall, then we’d be safe.</p>
<p>Linux 4.18 introduced a syscall, <a href="https://mazzo.li/assets/other/rseq.html"><code>rseq</code></a> (“restartable sequences”),<a href="#fn19" id="fnref19" role="doc-noteref"><sup>19</sup></a> which lets us achieve this, although with some effort.<a href="#fn20" id="fnref20" role="doc-noteref"><sup>20</sup></a> The <code>rseq</code> machinery works as follows:</p>
<ul>
<li><p>You write some code which you want to run atomically with regards to preemption or signals – the critical section.</p></li>
<li><p>Before the critical section is entered, we inform the kernel that the critical section is about to run by writing to a bit of memory shared between the kernel and userspace.</p></li>
<li><p>This bit of memory contains:</p>
<ol type="a">
<li><code>start_ip</code>, the instruction pointer which marks the begin of the critical section;</li>
<li><code>post_commit_offset</code>, the length of the critical section;</li>
<li><code>abort_ip</code>, the instruction pointer to jump to if the kernel needs to preempt the critical section.</li>
</ol></li>
<li><p>If the kernel has preempted a thread, or if a signal needs to be delivered to the thread, it checks if the thread is in a <code>rseq</code> critical section, and if it does sets the program counter for the thread to <code>abort_ip</code>.</p></li>
</ul>
</div>

<p>The process above forces the critical section to be a single contiguous block (from <code>start_ip</code> to <code>start_ip+post_commit_offset</code>) which we must know the address of. These requirements force us to write it in inline assembly.</p>
<div>
<p>Note that rather than disabling preemption entirely, <code>rseq</code> lets us specify some code (the code starting at <code>abort_ip</code>) to perform some cleanup if the critical section is interrupted. The correct functioning of the critical section therefore often depends on a “commit instruction” at the very end of the critical section which makes the changes in the critical section visible.</p>
<p>In our case the “commit instruction” is <code>syscall</code> – the instruction which will invoke the syscall that we’re interested in.<a href="#fn21" id="fnref21" role="doc-noteref"><sup>21</sup></a></p>
<p>Which leads us to the following x86-64 widget for a 6-argument syscall stub which atomically checks a stop flag and executes a <code>syscall</code>:</p>
</div>

<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>// Returns -1 and sets errno to EINTR if `*stop` was true</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>// before starting the syscall.</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span>long</span> syscall_or_stop<span>(</span><span>bool</span><span>*</span> stop<span>,</span> <span>long</span> n<span>,</span> <span>long</span> a<span>,</span> <span>long</span> b<span>,</span> <span>long</span> c<span>,</span> <span>long</span> d<span>,</span> <span>long</span> e<span>,</span> <span>long</span> f<span>)</span> <span>{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span>long</span> ret<span>;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span>register</span> <span>long</span> rd <span>__asm__</span><span>(</span><span>&#34;r10&#34;</span><span>)</span> <span>=</span> d<span>;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span>register</span> <span>long</span> re <span>__asm__</span><span>(</span><span>&#34;r8&#34;</span><span>)</span>  <span>=</span> e<span>;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span>register</span> <span>long</span> rf <span>__asm__</span><span>(</span><span>&#34;r9&#34;</span><span>)</span>  <span>=</span> f<span>;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span>__asm__</span> __volatile__ <span>(</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span>R&#34;(</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span>      # struct rseq_cs {</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span>      #     __u32   version;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span>      #     __u32   flags;</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span>      #     __u64   start_ip;</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span>      #     __u64   post_commit_offset;</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span>      #     __u64   abort_ip;</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span>      # } __attribute__((aligned(32)));</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span>      .pushsection __rseq_cs, &#34;aw&#34;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span>      .balign 32</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span>      1:</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span>      .long 0, 0                # version, flags</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span>      .quad 3f, (4f-3f), 2f     # start_ip, post_commit_offset, abort_ip</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span>      .popsection</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span>      .pushsection __rseq_failure, &#34;ax&#34;</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a><span>      # sneak in the signature before abort section as</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span>      # `ud1 &lt;sig&gt;(</span><span>%%</span><span>rip), </span><span>%%</span><span>edi`, so that objdump will print it</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a><span>      .byte 0x0f, 0xb9, 0x3d</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span>      .long 0x53053053</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a><span>      2:</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a><span>      # exit with EINTR</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a><span>      jmp 5f</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span>      .popsection</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span>      # we set rseq-&gt;rseq_cs to our structure above.</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span>      # rseq = thread pointer (that is fs) + __rseq_offset</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a><span>      # rseq_cs is at offset 8</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span>      leaq 1b(</span><span>%%</span><span>rip), </span><span>%%</span><span>r12</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a><span>      movq </span><span>%%</span><span>r12, </span><span>%%</span><span>fs:8(%[rseq_offset])</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a><span>      3:</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span>      # critical section start -- check if we should stop</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a><span>      # and if yes skip the syscall</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a><span>      testb $255, %[stop]</span></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a><span>      jnz 5f</span></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a><span>      syscall</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a><span>      # it&#39;s important that syscall is the very last thing we do before</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a><span>      # exiting the critical section to respect the rseq contract of</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a><span>      # &#34;no syscalls&#34;.</span></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a><span>      4:</span></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a><span>      jmp 6f</span></span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a><span>      5:</span></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a><span>      movq $-4, </span><span>%%</span><span>rax # EINTR</span></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a><span>      6:</span></span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a><span>    </span><span>)&#34;</span></span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>    <span>:</span> <span>&#34;=a&#34;</span> <span>(</span>ret<span>)</span> <span>// the output goes in rax</span></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a>    <span>:</span> <span>[</span>stop<span>]</span> <span>&#34;m&#34;</span> <span>(*</span>stop<span>),</span></span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a>      <span>[</span>rseq_offset<span>]</span> <span>&#34;r&#34;</span> <span>(</span>__rseq_offset<span>),</span></span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a>      <span>&#34;a&#34;</span><span>(</span>n<span>),</span> <span>&#34;D&#34;</span><span>(</span>a<span>),</span> <span>&#34;S&#34;</span><span>(</span>b<span>),</span> <span>&#34;d&#34;</span><span>(</span>c<span>),</span> <span>&#34;r&#34;</span><span>(</span>rd<span>),</span> <span>&#34;r&#34;</span><span>(</span>re<span>),</span> <span>&#34;r&#34;</span><span>(</span>rf<span>)</span></span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a>    <span>:</span> <span>&#34;cc&#34;</span><span>,</span> <span>&#34;memory&#34;</span><span>,</span> <span>&#34;rcx&#34;</span><span>,</span> <span>&#34;r11&#34;</span><span>,</span> <span>&#34;r12&#34;</span></span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a>  <span>);</span></span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>ret <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> ret <span>&gt;</span> <span>-</span><span>4096</span><span>)</span> <span>{</span></span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a>    errno <span>=</span> <span>-</span>ret<span>;</span></span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a>    ret <span>=</span> <span>-</span><span>1</span><span>;</span></span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true" tabindex="-1"></a>  <span>return</span> ret<span>;</span></span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true" tabindex="-1"></a><span>// A version of recvfrom which atomically checks</span></span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true" tabindex="-1"></a><span>// the flag before running.</span></span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>long</span> recvfrom_or_stop<span>(</span><span>bool</span><span>*</span> stop<span>,</span> <span>int</span> socket<span>,</span> <span>void</span><span>*</span> buffer<span>,</span> <span>size_t</span> length<span>)</span> <span>{</span></span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true" tabindex="-1"></a>  <span>return</span> syscall_or_stop<span>(</span>stop<span>,</span> __NR_recvfrom<span>,</span> socket<span>,</span> <span>(</span><span>long</span><span>)</span>buffer<span>,</span> length<span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>);</span></span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We’re using glibc’s <a href="https://lwn.net/Articles/883104/">recently added support for <code>rseq</code></a>, which provides a <code>__rseq_offset</code> variable containing the offset where the critical section information lives, relative to the thread pointer. All we need to do in the critical section is check the flag, skip the syscall if it’s set, and perform the syscall if it is. If the flag is set we pretend the syscall has failed with <code>EINTR</code>.</p>
<p>You can find the full code for the previous example using this trick to call <code>recvfrom</code> <a href="https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9">here</a>. I’m not necessarily advocating the use of this technique, but it’s definitely an interesting curiosity.</p>
<h2 id="wrapping-up">Wrapping up <a href="#wrapping-up">#</a></h2>
<p>It’s quite frustrating that there’s no agreed upon way to interrupt and stack unwind a Linux thread and to protect critical sections from such unwinding. There are no technical obstacles to such facilities existing, but clean teardown is often a neglected part of software.</p>
<p>Haskell is one language where these capabilities do exist in the form of <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Exception.html#v:throwTo">asynchronous exceptions</a>, although one still needs to be careful to protect critical sections appropriately.</p>
<h2 id="acknowledgements">Acknowledgements <a href="#acknowledgements">#</a></h2>
<p><a href="https://twitter.com/corsix">Peter Cawley</a> provided input on many details treated in this blog post and read its draft. He also suggested <code>rseq</code> as a possible solution. Many thanks also go to <a href="https://nh2.me/">Niklas Hambüchen</a>, <a href="https://scvalex.net/">Alexandru Sçvortov</a>, <a href="https://www.asayers.com/">Alex Sayers</a>, and Alex Appetiti for reading drafts of this blog post.</p>






</div></div>
  </body>
</html>
