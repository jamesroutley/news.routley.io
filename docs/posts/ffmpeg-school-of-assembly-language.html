<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/FFmpeg/asm-lessons/blob/main/lesson_01/index.md">Original</a>
    <h1>FFmpeg School of Assembly Language</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><section aria-labelledby="file-name-id-wide file-name-id-mobile"><div data-hpc="true"><article itemprop="text"><p dir="auto"><strong>FFmpeg Assembly Language Lesson One</strong></p>
<p dir="auto"><strong>Introduction</strong></p>
<p dir="auto">Welcome to the FFmpeg School of Assembly Language. You have taken the first step on the most interesting, challenging, and rewarding journey in programming. These lessons will give you a grounding in the way assembly language is written in FFmpeg and open your eyes to what&#39;s actually going on in your computer..</p>
<p dir="auto"><strong>Required Knowledge</strong></p>
<ul dir="auto">
<li>Knowledge of C, in particular pointers. If you don&#39;t know C, work through <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language" rel="nofollow">The C Programming Language</a> book</li>
<li>High School Mathematics (scalar vs vector, addition, multiplication etc)</li>
</ul>
<p dir="auto"><strong>What is assembly language?</strong></p>
<p dir="auto">Assembly language is a programming language where you write code that directly corresponds to the instructions a CPU processes. Human readable assembly language is, as the name suggests, <em>assembled</em> into binary data, known as <em>machine code</em>, that the CPU can understand. You might see assembly language code referred to as “assembly” or “asm” for short.</p>
<p dir="auto">The vast majority of assembly code in FFmpeg is what&#39;s known as <em>SIMD, Single Instruction Multiple Data</em>. SIMD is sometimes referred to as vector programming. This means that a particular instruction operates on multiple elements of data at the same time. Most programming languages operate on one data element at a time, known as scalar programming.</p>
<p dir="auto">As you might have guessed, SIMD lends itself well to processing images, video, and audio which have lots of data ordered sequentially in memory. There are specialist instructions available in the CPU to help us process sequential data.</p>
<p dir="auto">In FFmpeg, you&#39;ll see the terms “assembly function”, “SIMD”, and “vector(ise)” used interchangeably. They all refer to the same thing: Writing a function in assembly language by hand to process multiple elements of data in one go. Some projects may also refer to these as “assembly kernels”.</p>
<p dir="auto">All of this might sound complicated, but it&#39;s important to remember that in FFmpeg, high schoolers have written assembly code. As with everything, learning is 50% jargon and 50% actual learning.</p>
<p dir="auto"><strong>Why do we write in assembly language?</strong></p>
<p dir="auto">You’ll often see, online, people use <em>intrinsics,</em> which are C-like functions that map to assembly instructions to allow for faster development. In FFmpeg we don’t use intrinsics but instead write assembly code by hand. This is an area of controversy, but intrinsics are typically around 10-15% slower than hand-written assembly (intrinsics supporters would disagree), depending on the compiler. For FFmpeg, every bit of extra performance helps, which is why we write in assembly code directly. There’s also an argument that intrinsics are difficult to read owing to their use of “<a href="https://en.wikipedia.org/wiki/Hungarian_notation" rel="nofollow">Hungarian Notation</a>”.</p>
<p dir="auto">You may also see <em>inline assembly</em> (i.e. not using intrinsics) remaining in a few places in FFmpeg for historical reasons, or in projects like the Linux Kernel because of very specific use cases there. This is where assembly code is not in a separate file, but written inline with C code. The prevailing opinion in projects like FFmpeg is that this code is hard to read, not widely supported by compilers and unmaintainable.</p>
<p dir="auto">Lastly, you’ll see a lot of self-proclaimed experts online saying none of this is necessary and the compiler can do all of this “vectorisation” for you. At least for the purpose of learning, ignore them: recent tests in e.g. <a href="https://www.videolan.org/projects/dav1d.html" rel="nofollow">the dav1d project</a> showed around a 2x speedup from this automatic vectorisation, while the hand-written versions could reach 8x.</p>
<p dir="auto"><strong>Flavours of assembly language</strong></p>
<p dir="auto">There are two flavours of x86 assembly syntax that you’ll see online: AT&amp;T and Intel. AT&amp;T Syntax is older and harder to read compared to Intel syntax. So we will use Intel syntax.</p>
<p dir="auto"><strong>Supporting materials</strong></p>
<p dir="auto">Many books go into a lot of computer architecture details before teaching assembly. This is fine if that’s what you want to learn, but from our standpoint, it’s like studying engines before learning to drive a car.</p>
<p dir="auto">That said, the diagrams in the later parts of “The Art of 64-bit assembly” book showing SIMD instructions and their behaviour in a visual form are helpful: <a href="https://artofasm.randallhyde.com/" rel="nofollow">https://artofasm.randallhyde.com/</a></p>
<p dir="auto">A discord server is available to answer questions:</p>
<p dir="auto"><strong>Registers</strong></p>
<p dir="auto"><strong>General Purpose Registers</strong></p>
<p dir="auto">In most assembly books, there are whole chapters dedicated to the subtleties of GPRs, the historical background etc. This is because GPRs are important when it comes to operating system programming, reverse engineering, etc. In the assembly code written in FFmpeg, GPRs are more like scaffolding and most of the time their complexities are not needed and abstracted away.</p>
<p dir="auto"><strong>Vector registers</strong></p>
<ul dir="auto">
<li>mm registers - MMX registers, 64-bit sized, historic and not used much any more</li>
<li>xmm registers - XMM registers, 128-bit sized, widely available</li>
<li>ymm registers - YMM registers, 256-bit sized, some complications when using these</li>
<li>zmm registers - ZMM registers, 512-bit sized, limited availability</li>
</ul>
<p dir="auto">Most calculations in video compression and decompression are integer-based so we’ll stick to that. Here’s an example of 16 bytes in an xmm register:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>g</th>
<th>h</th>
<th>i</th>
<th>j</th>
<th>k</th>
<th>l</th>
<th>m</th>
<th>n</th>
<th>o</th>
<th>p</th>
</tr>
</thead>
</table></markdown-accessiblity-table>
<p dir="auto">But it could be eight words (16-bit integers)</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>g</th>
<th>h</th>
</tr>
</thead>
</table></markdown-accessiblity-table>
<p dir="auto">Or four double words (32-bit integers)</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
</table></markdown-accessiblity-table>
<p dir="auto">Or two quadwords (64-bit integers):</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>a</th>
<th>b</th>
</tr>
</thead>
</table></markdown-accessiblity-table>
<p dir="auto">To recap:</p>
<ul dir="auto">
<li><strong>b</strong>ytes - 8-bit data</li>
<li><strong>w</strong>ords - 16-bit data</li>
<li><strong>d</strong>oublewords - 32-bit data</li>
<li><strong>q</strong>uadwords - 64-bit data</li>
<li><strong>d</strong>ouble <strong>q</strong>uadwords - 128-bit data</li>
</ul>
<p dir="auto">The bold characters will be important later.</p>
<p dir="auto"><strong>x86inc.asm include</strong></p>
<p dir="auto"><strong>A simple scalar asm snippet</strong></p>
<p dir="auto">Let’s look at a simple (and very much artificial) snippet of scalar asm (assembly code that operates on individual data items, one at a time, within each instruction) to see what’s going on:</p>
<div dir="auto" data-snippet-clipboard-copy-content="mov  r0q, 3  
inc  r0q  
dec  r0q  
imul r0q, 5"><pre><span>mov</span><span>  r0q</span><span>,</span><span> </span><span>3</span><span>  </span>
<span>inc</span><span>  r0q  </span>
<span>dec</span><span>  r0q  </span>
<span>imul</span><span> r0q</span><span>,</span><span> </span><span>5</span></pre></div>
<p dir="auto">In the first line, the <em>immediate value</em> 3 (a value stored directly in the assembly code itself as opposed to a value fetched from memory) is being stored into register r0 as a quadword. Note that in Intel syntax, the source operand (the value or location providing the data, located on the right) is transferred to the destination operand (the location receiving the data, located on the left), much like the behavior of memcpy. You can also read it as “r0q = 3”, since the order is the same. The “q” suffix of r0 designates the register as being used as a quadword. inc increments the value so that r0q contains 4, dec decrements the value back to 3. imul multiplies the value by 5. So at the end, r0q contains 15.</p>
<p dir="auto">Note that the human readable instructions such as mov and inc, which are assembled into machine code by the assembler, are known as <em>mnemonics</em>. You may see online and in books mnemonics represented with capital letters like MOV and INC but these are the same as the lower case versions. In FFmpeg, we use lower case mnemonics and keep upper case reserved for macros.</p>
<p dir="auto"><strong>Understanding a basic vector function</strong></p>
<p dir="auto">Here’s our first SIMD function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="%include &#34;x86inc.asm&#34;

SECTION .text

;static void add_values(const uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2  
cglobal add_values, 2, 2, 2, src, src2   
    movu  m0, [srcq]  
    movu  m1, [src2q]

    paddb m0, m1

    movu  [srcq], m0

    RET"><pre><span>%include</span> <span>&#34;x86inc.asm&#34;</span>

<span>SECTION</span><span> .text</span>

<span>;static void add_values(const uint8_t *src, const uint8_t *src2)  </span>
<span>INIT_XMM sse2  </span>
<span>c</span><span>global</span> <span>add_values</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>2</span><span>,</span><span> src</span><span>,</span><span> src2   </span>
<span>    movu  m0</span><span>,</span><span> </span><span>[</span><span>srcq</span><span>]</span><span>  </span>
<span>    movu  m1</span><span>,</span><span> </span><span>[</span><span>src2q</span><span>]</span>

<span>    </span><span>paddb</span><span> m0</span><span>,</span><span> m1</span>

<span>    movu  </span><span>[</span><span>srcq</span><span>],</span><span> m0</span>

<span>    </span><span>RET</span></pre></div>
<p dir="auto">Let’s go through it line by line:</p>

<p dir="auto">This is a “header” developed in the x264, FFmpeg, and dav1d communities to provide helpers, predefined names and macros (such as cglobal below) to simplify writing assembly.</p>

<p dir="auto">This denotes the section where the code you want to execute is placed. This is in contrast to the .data section, where you can put constant data.</p>
<div dir="auto" data-snippet-clipboard-copy-content=";static void add_values(const uint8_t *src, const uint8_t *src2);  
INIT_XMM sse2"><pre><span>;static void add_values(const uint8_t *src, const uint8_t *src2);  </span>
<span>INIT_XMM sse2</span></pre></div>
<p dir="auto">The first line is a comment (the semi-colon “;” in asm is like “//” in C) showing what the function argument looks like in C. The second line shows how we are initialising the function to use XMM registers, using the sse2 instruction set. This is because paddb is an sse2 instruction. We’ll cover sse2 in more detail in the next lesson.</p>
<div dir="auto" data-snippet-clipboard-copy-content="cglobal add_values, 2, 2, 2, src, src2"><pre><span>c</span><span>global</span> <span>add_values</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>2</span><span>,</span><span> src</span><span>,</span><span> src2</span></pre></div>
<p dir="auto">This is an important line as it defines a C function called “add_values”.</p>
<p dir="auto">Let’s go through each item one at a time:</p>
<ul dir="auto">
<li>The next parameter shows it has two function arguments.</li>
<li>The parameter after that shows that we’ll use two GPRs for the arguments. In some cases we might want to use more GPRs so we have to tell x86util we need more.</li>
<li>The parameter after that tells x86util how many XMM registers we are going to use.</li>
<li>The following two parameters are labels for the function arguments.</li>
</ul>
<p dir="auto">It’s worth noting that older code may not have labels for the function arguments but instead address GPRs directly using r0, r1 etc.</p>
<div dir="auto" data-snippet-clipboard-copy-content="    movu  m0, [srcq]  
    movu  m1, [src2q]"><pre><span>    movu  m0</span><span>,</span><span> </span><span>[</span><span>srcq</span><span>]</span><span>  </span>
<span>    movu  m1</span><span>,</span><span> </span><span>[</span><span>src2q</span><span>]</span></pre></div>
<p dir="auto">movu is shorthand for movdqu (move double quad unaligned). Alignment will be covered in another lesson but for now movu can be treated as a 128-bit move from [srcq]. In the case of mov, the brackets mean that the address in [srcq] is being dereferenced, the equivalent of *<em>src in C.</em> This is what’s known as a load. Note that the “q” suffix refers to the size of the pointer *(*i.e in C it represents *sizeof(*src) == 8 on 64-bit systems, and x86asm is smart enough to use 32-bit on 32-bit systems) but the underlying load is 128-bit.</p>
<p dir="auto">Note that we don’t refer to vector registers by their full name, in this case xmm0,but as m0, an abstracted form. In future lessons you’ll see how this means you can write code once and have it work on multiple SIMD register sizes.</p>

<p dir="auto">paddb (read this in your head as <em>p-add-b</em>) is adding each byte in each register as shown below. The “p” prefix stands for “packed” and is used to identify vector instructions vs scalar instructions. The “b” suffix shows that this is bytewise addition (addition of bytes).</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>g</th>
<th>h</th>
<th>i</th>
<th>j</th>
<th>k</th>
<th>l</th>
<th>m</th>
<th>n</th>
<th>o</th>
<th>p</th>
</tr>
</thead>
</table></markdown-accessiblity-table>
<p dir="auto">+</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>q</th>
<th>r</th>
<th>s</th>
<th>t</th>
<th>u</th>
<th>v</th>
<th>w</th>
<th>x</th>
<th>y</th>
<th>z</th>
<th>aa</th>
<th>ab</th>
<th>ac</th>
<th>ad</th>
<th>ae</th>
<th>af</th>
</tr>
</thead>
</table></markdown-accessiblity-table>
<p dir="auto">=</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>a+q</th>
<th>b+r</th>
<th>c+s</th>
<th>d+t</th>
<th>e+u</th>
<th>f+v</th>
<th>g+w</th>
<th>h+x</th>
<th>i+y</th>
<th>j+z</th>
<th>k+aa</th>
<th>l+ab</th>
<th>m+ac</th>
<th>n+ad</th>
<th>o+ae</th>
<th>p+af</th>
</tr>
</thead>
</table></markdown-accessiblity-table>

<p dir="auto">This is what’s known as a store. The data is written back to the address in the srcq pointer.</p>

<p dir="auto">This is a macro to denote the function returns. Virtually all assembly functions in FFmpeg modify the data in the arguments as opposed to returning a value.</p>
<p dir="auto">As you’ll see in the assignment, we create function pointers to assembly functions and use them where available.</p>
<p dir="auto"><a href="https://github.com/FFmpeg/asm-lessons/blob/main/lesson_02/index.md">Next Lesson</a></p>
</article></div></section></div></div></div></div>
  </body>
</html>
