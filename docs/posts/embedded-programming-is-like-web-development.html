<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the.scapegoat.dev/embedded-programming-is-like-web-development/">Original</a>
    <h1>Embedded programming is like web development</h1>
    
    <div id="readability-page-1" class="page"><div>
<div><p>(I wrote a follow-up article: <a href="https://the.scapegoat.dev/embedded-development-is-not-like-web-development/">Embedded programming is not like web development</a>)</p>
<p>I often see people discuss embedded development and web development as being two opposite sides of the spectrum of software engineering: one is low-level and hardcore, and the other one is high-level and almost trivial. After more than 20 years working in both domains, I have come to view web and embedded as highly similarâ€”I can use the same approaches in both worlds.</p>
<p>The usual discourse goes as follows:</p>
<ul>
<li>Embedded development is complex and open to a select few experienced developers. It requires precise thinking and strict software engineering.</li>
<li>Web development, on the other hand is easy, relaxed, mainly concerned with making things pretty and throwing CSS, javascript frameworks, and SQL at a CRUD application</li>
</ul>
<h2 id="web-applications-and-embedded-systems-are-both-distributed-systems">Web applications and embedded systems are both distributed systems</h2>
<p>In an embedded system, you have sensors, actuators, multiple microcontrollers, often a Linux system, increasingly standard cloud connectivity, and over-the-air updates. In a web application, you have client browsers, servers, storage services, databases, caches, logging, and monitoring. These components need to communicate to present the user with the desired functionality.</p>
<p>Furthermore, these components need to be monitored and maintained. The system is usually permanently online. Building software updates is intricate; distributed and update processes often require orchestration. Debugging at scale usually requires monitoring and log collection, as interacting with any individual component is often impossible.</p>
<h2 id="web-and-embedded-software-engineering-is-remarkably-similar">Web and embedded software engineering is remarkably similar</h2>
<p>At a more technical level, the software and architecture of web and embedded systems are built on the same underlying abstractions and must fulfill similar constraints.</p>
<p>At a higher abstraction level:</p>
<ul>
<li>The user application is implemented by a distributed system</li>
<li>Actors communicate over a network, using a variety of protocols</li>
<li>The application is long-lived, requiring special attention to error handling</li>
<li>Most actions require a sequence of asynchronous steps</li>
<li>Deployment at scale requires synchronization because of interdependent components</li>
<li>Because of their complexity, systems often exhibit emergent behavior</li>
<li>The execution environment is remote (local web development usually requires some docker setup; embedded development requires some playground for the actual sensors and actors)</li>
<li>Performance is an essential component of system design due to power, real-time, response time, or cost constraints</li>
</ul>
<p>The similarities are even more striking once we zoom in on the code level:</p>
<ul>
<li>User and hardware interaction often require complex behavior due to UX design,</li>
<li>Most of the code is sequencing asynchronous steps</li>
<li>There is no happy path. Because at least part of the system runs without direct user supervision, we need at least restarts and error logging</li>
<li>The same software patterns prove very effective:<ul>
<li>state machines, promises, or coroutines</li>
<li>event-driven development</li>
<li>structured logging and observability metrics</li>
<li>structured RPC IDLs</li>
<li>monoidal state handling (state reducers like redux store)</li>
</ul>
</li>
<li>Instrumentation for debugging is extremely useful, yet can quickly impact runtime behavior</li>
<li>Many issues can only be caught in production (or in-field testing). Mocking only goes so far due to the emergent behaviors mentioned above</li>
</ul>
<h2 id="there-is-a-lot-to-learn-from-both-fields">There is a lot to learn from both fields</h2>
<p>I have learned a lot from working in both domains and have carried over not just ideas but actual code and tooling. Framing embedded development as low-level systems requiring advanced skills versus web development as a free-for-all, low-hanging fruit obscures how similar they are.</p>
<p>Both are hard to get right, both benefit from a holistic systems approach, and actual code and tooling carry over surprisingly easily.</p>
<p>I plan this to become a longer series that explores what I learned in my career in web and embedded, so stay tuned!</p>
<p>Feel free to comment on <a href="https://news.ycombinator.com/item?id=33450575">HN</a>.</p>
</div>
</div></div>
  </body>
</html>
