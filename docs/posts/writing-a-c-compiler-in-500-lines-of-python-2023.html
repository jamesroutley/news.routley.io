<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vgel.me/posts/c500/">Original</a>
    <h1>Writing a C compiler in 500 lines of Python (2023)</h1>
    
    <div id="readability-page-1" class="page"><article>
    
    
  
  <p>A few months ago, I set myself the challenge of writing a C compiler in 500 lines of Python, after writing my <a href="https://vgel.me/posts/donut/">SDF donut</a> post.
How hard could it be?
The answer was, pretty hard, even when dropping quite a few features.
But it was also pretty interesting, and the result is surprisingly functional and not too hard to understand!</p>
<p>There&#39;s too much code for me to comprehensively cover in a single blog post, so I&#39;ll just give an overview of the decisions I made, things I had to cut, and the general architecture of the compiler, touching on a representative piece of each part.
Hopefully after reading this post, <a href="https://github.com/vgel/c500/blob/main/compiler.py">the code</a> is more approachable!</p>
<span id="continue-reading"></span><h2 id="Decisions,_decisions"><a href="#Decisions,_decisions">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Decisions,_decisions"/>
</a>Decisions, decisions</h2>
<p>The first, and most critical decision, was that this would be a <em>single-pass</em> compiler.
500 lines is too spare to be defining and transforming an abstract syntax tree!
What does that mean?</p>
<h3 id="Most_compilers:_faffing_around_with_syntax_trees"><a href="#Most_compilers:_faffing_around_with_syntax_trees">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Most_compilers:_faffing_around_with_syntax_trees"/>
</a>Most compilers: faffing around with syntax trees</h3>
<p>Well, most compiler&#39;s internals look something like this:</p>
<center>
<img src="https://vgel.me/posts/c500/parsenon.png" alt="the codepoints walk down the yellow brick road, get lexed into tokens, then worship at the world&#39;s largest chomsky to become syntax trees, then are torn to pieces by the codegen hydra to produce machine instructions"/>
</center>
<p>The tokens get lexed, then a <em>parser</em> runs over them and builds pretty little syntax trees:</p>
<pre data-lang="python"><code data-lang="python"><span># hypothetical code, not from anywhere
</span><span>def </span><span>parse_statement</span><span>(</span><span>lexer</span><span>) -&gt; PrettyLittleSyntaxTree:
</span><span>    </span><span>...
</span><span>    </span><span>if </span><span>type </span><span>:= </span><span>lexer.try_next(TYPE_NAME):
</span><span>        variable_name </span><span>= </span><span>lexer.next(IDENTIFIER)
</span><span>
</span><span>        </span><span>if </span><span>lexer.try_next(</span><span>&#34;=&#34;</span><span>):
</span><span>            initializer </span><span>= </span><span>parse_initializer(lexer)
</span><span>        </span><span>else</span><span>:
</span><span>            initializer </span><span>= </span><span>None
</span><span>
</span><span>        lexer.next(SEMICOLON)
</span><span>
</span><span>        </span><span>return </span><span>VariableDeclarationNode(
</span><span>            </span><span>type </span><span>= </span><span>type</span><span>,
</span><span>            </span><span>name </span><span>= </span><span>variable_name,
</span><span>            </span><span>initializer </span><span>= </span><span>initializer,
</span><span>        )
</span><span>    </span><span>...
</span><span>
</span><span># much later...
</span><span>def </span><span>emit_code_for</span><span>(</span><span>node</span><span>: PrettyLittleSyntaxTree) -&gt; DisgustingMachineCode:
</span><span>    </span><span>...
</span><span>    </span><span>if </span><span>isinstance</span><span>(node, VariableDeclarationNode):
</span><span>        slot </span><span>= </span><span>reserve_stack_space(node.type.sizeof())
</span><span>        add_to_environment(node.name, slot)
</span><span>        </span><span>if </span><span>node.initializer </span><span>is not </span><span>None</span><span>:
</span><span>            register </span><span>= </span><span>emit_code_for(node.initializer)
</span><span>            emit(</span><span>f</span><span>&#34;mov </span><span>{register}</span><span>, [</span><span>{slot}</span><span>]&#34;</span><span>)
</span><span>    </span><span>...
</span></code></pre>
<p>The important thing here is that there&#39;s <em>two passes</em>, first the parsing builds up a syntax tree, then a second pass chews that tree up and turns it into machine code.
That&#39;s really useful for most compilers!
It keeps the parsing and codegen separate, so each can evolve independently.
It also means that you can transform the syntax tree before using it to generate code—for example, by applying optimizations to it.
In fact, most compilers have <em>multiple</em> levels of &#34;intermediate representations&#34; between the syntax tree and codegen!</p>
<p>This is really great, good engineering, best practices, recommended by experts, etc.
But… it takes too much code, so we can&#39;t do it.</p>
<p>Instead, we&#39;ll be <em>single-pass</em>: code generation happens <em>during parsing</em>.
We parse a bit, emit some code, parse a bit more, emit a bit more code.
So for example, here&#39;s some real code from the <code>c500</code> compiler for parsing the prefix <code>~</code> op:</p>
<pre data-lang="python"><code data-lang="python"><span># lexer.try_next() checks if the next token is ~, and if so, consumes
</span><span># and returns it (truthy)
</span><span>elif </span><span>lexer.try_next(</span><span>&#34;~&#34;</span><span>):
</span><span>    </span><span># prefix() parses and generates code for the expression after the ~,
</span><span>    </span><span># and load_result emits code to load it, if needed
</span><span>    meta </span><span>= </span><span>load_result(prefix())
</span><span>    </span><span># immediately start yeeting out the negation code!
</span><span>    emit(</span><span>&#34;i32.const 0xffffffff&#34;</span><span>)
</span><span>    emit(</span><span>&#34;i32.xor&#34;</span><span>)
</span><span>    </span><span># webassembly only supports 32bit types, so if this is a smaller type,
</span><span>    </span><span># mask it down
</span><span>    mask_to_sizeof(meta.type)
</span><span>    </span><span># return type information
</span><span>    </span><span>return </span><span>meta
</span></code></pre>
<p>Notice there&#39;s no syntax trees, no <code>PrefixNegateOp</code> nodes.
We see some tokens and immediately spit out the corresponding instructions.</p>
<p>You may have noticed those instructions are <em>WebAssembly</em>, which leads us into the next section...</p>
<h3 id="Using_WebAssembly,_for_some_reason?"><a href="#Using_WebAssembly,_for_some_reason?">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Using_WebAssembly,_for_some_reason?"/>
</a>Using WebAssembly, for some reason?</h3>
<p>So I decided to make the compiler target WebAssembly.
I honestly don&#39;t know why I did this, it really didn&#39;t make it easier—I guess I was just curious?
WebAssembly is a really weird target, especially for C.
Besides the somewhat-external issues like spending a lot of time confused before I realized WebAssembly v2 is pretty different than WebAssembly v1, the instruction set itself is <em>weird</em>.</p>
<p>For one, there&#39;s <em>no goto</em>.
Instead, you have blocks—structured assembly, imagine that!—and &#34;break&#34; instructions that jump to either the beginning or end of a specific nesting-level of block.
This was basically inconsequential for <code>if</code> and <code>while</code>, but made implementing <code>for</code> <em>extremely</em> cursed, which we&#39;ll go over later.</p>
<p>Additionally, WebAssembly doesn&#39;t have registers, it has a stack, and is a stack machine.
At first you might think that&#39;s awesome, right?
C needs a stack!
We can just use the WebAssembly stack as our C stack!
Nope, because you can&#39;t take references to the WebAssembly stack.
So instead, we need to maintain our own in-memory stack <em>anyways</em>, and then shuffle it on and off of the WASM parameter stack.</p>
<p>So in the end, I think I ended up with slightly <em>more</em> code than I would have needed to target a more normal ISA like x86 or ARM.
But it was interesting!
And theoretically, you could run code compiled with <code>c500</code> in a browser, although I haven&#39;t tried (I just use the <code>wasmer</code> CLI).</p>
<h3 id="Error_handling"><a href="#Error_handling">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Error_handling"/>
</a>Error handling</h3>
<p>It basically doesn&#39;t.
There&#39;s a function <code>die</code>, which is called when anything weird happens and dumps a compiler stack trace—if you&#39;re lucky, you get a line number and a somewhat-vague error message.</p>
<pre><code><span>------------------------------
</span><span>
</span><span>  File &#34;...compiler.py&#34;, line 835, in &lt;module&gt;
</span><span>    compile(&#34;&#34;.join(fi))  # todo: make this line-at-a-time?
</span><span>  File &#34;...compiler.py&#34;, line 823, in compile
</span><span>    global_declaration(global_frame, lexer)
</span><span>  &lt;snip&gt;
</span><span>  File &#34;...compiler.py&#34;, line 417, in value
</span><span>    var, offset = frame.get_var_and_offset(varname)
</span><span>  File &#34;...compiler.py&#34;, line 334, in get_var_and_offset
</span><span>    return self.parent.get_var_and_offset(name)
</span><span>  File &#34;...compiler.py&#34;, line 336, in get_var_and_offset
</span><span>    die(f&#34;unknown variable {n}&#34;, None if isinstance(name, str) else name.line)
</span><span>  File &#34;...compiler.py&#34;, line 14, in die
</span><span>    traceback.print_stack()
</span><span>
</span><span>------------------------------
</span><span>
</span><span>error on line 9: unknown variable c
</span></code></pre>
<p>The Rust compiler, this is not :-)</p>
<h3 id="What_to_drop"><a href="#What_to_drop">
  <img src="https://vgel.me/permalink.svg" alt="permalink for What_to_drop"/>
</a>What to drop</h3>
<p>Finally, I had to decide what <em>not</em> to support, since it just wasn&#39;t feasible to get <em>all</em> of C into 500 lines. (sorry!)
I decided I wanted a really decent sampling of features that tested what the general implementation approach was capable of—for example, if I had skipped pointers, I could have just gotten away with the WASM parameter stack and shed a lot of complexity, but that would have felt like cheating.</p>
<p>I ended up implementing the following features:</p>
<ul>
<li>arithmetic operations and binary operators, with proper precedence</li>
<li><code>int</code>, <code>short</code>, and <code>char</code> types</li>
<li>string constants (with escapes)</li>
<li>pointers (of however many levels), including correct pointer arithmetic (incrementing an <code>int*</code> adds 4)</li>
<li>arrays (only single-level, not <code>int[][]</code>)</li>
<li>functions</li>
<li>typedefs (and the lexer hack!)</li>
</ul>
<p>Notably, it doesn&#39;t support:</p>
<ul>
<li>structs :-( would be possible with more code, the fundamentals were there, I just couldn&#39;t squeeze it in</li>
<li>enums / unions</li>
<li>preprocessor directives (this would probably be 500 lines by itself...)</li>
<li>floating point. would also be possible, the <code>wasm_type</code> stuff is in, again just couldn&#39;t squeeze it in</li>
<li>8 byte types (<code>long</code>/<code>long long</code> or <code>double</code>)</li>
<li>some other small things like pre/post cremements, in-place initialization, etc., which just didn&#39;t quite fit</li>
<li>any sort of standard library or i/o that isn&#39;t returning an integer from <code>main()</code></li>
<li>casting expressions</li>
</ul>
<p>The compiler passes 34/220 test cases in the <a href="https://github.com/c-testsuite/c-testsuite">c-testsuite</a>.
More importantly to me, it can compile and run the following program successfully:</p>
<pre data-lang="c"><code data-lang="c"><span>int </span><span>swap</span><span>(</span><span>int</span><span>* </span><span>a</span><span>, </span><span>int</span><span>* </span><span>b</span><span>) {
</span><span>  </span><span>int</span><span> t;
</span><span>  t </span><span>= *</span><span>a; </span><span>*</span><span>a </span><span>= *</span><span>b; </span><span>*</span><span>b </span><span>=</span><span> t;
</span><span>  </span><span>return</span><span> t;
</span><span>}
</span><span>
</span><span>int </span><span>fib</span><span>(</span><span>int </span><span>n</span><span>) {
</span><span>  </span><span>int</span><span> a, b;
</span><span>  </span><span>for </span><span>(a </span><span>=</span><span> b </span><span>= </span><span>1</span><span>; n </span><span>&gt; </span><span>2</span><span>; n </span><span>=</span><span> n </span><span>- </span><span>1</span><span>) {
</span><span>    swap(</span><span>&amp;</span><span>a, </span><span>&amp;</span><span>b);
</span><span>    b </span><span>=</span><span> b </span><span>+</span><span> a;
</span><span>  }
</span><span>  </span><span>return</span><span> b;
</span><span>}
</span><span>
</span><span>int </span><span>main</span><span>() {
</span><span>  </span><span>return </span><span>fib(</span><span>10</span><span>); </span><span>// 55
</span><span>}
</span></code></pre>
<p>OK, enough about deciding things, let&#39;s get into the code!</p>
<h2 id="Helper_types"><a href="#Helper_types">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Helper_types"/>
</a>Helper types</h2>
<p>There&#39;s a small collection of helper types and classes that the compiler uses.
None of them are particularly strange, so I&#39;ll pass over them fairly quickly.</p>
<h3 id="Emitter_(compiler.py:21)"><a href="#Emitter_(compiler.py:21)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Emitter_(compiler.py:21)"/>
</a><code>Emitter</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L21">compiler.py:21</a>)</small></h3>
<p>This is a singleton helper to emit nicely-formatted WebAssembly code.</p>
<p>WebAssembly, at least the textual format, is formatted as s-expressions, but individual instructions don&#39;t need to be parenthesized:</p>
<pre data-lang="clojure"><code data-lang="clojure"><span>(module
</span><span>  </span><span>;; &lt;snip...&gt;
</span><span>  (func $swap
</span><span>    (param $a i32)
</span><span>    (param $b i32)
</span><span>    (result i32)
</span><span>    global.get $__stack_pointer </span><span>;; prelude -- adjust stack pointer
</span><span>    i32.const </span><span>12
</span><span>    i32.sub
</span><span>    </span><span>;; &lt;snip...&gt;
</span><span>  )
</span><span>)
</span></code></pre>
<p><code>Emitter</code> just helps with emitting code with nice indentation so it&#39;s easier to read.
It also has a <code>no_emit</code> method, which will be used for an ugly hack later—stay tuned!</p>
<h3 id="StringPool_(compiler.py:53)"><a href="#StringPool_(compiler.py:53)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for StringPool_(compiler.py:53)"/>
</a>StringPool <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L53">compiler.py:53</a>)</small></h3>
<p><code>StringPool</code> holds all the string constants so they can be arranged in a contiguous region of memory, and hands out addresses into that for the codegen to use.
When you write <code>char *s = &#34;abc&#34;</code> in <code>c500</code>, what really happens is:</p>
<ol>
<li><code>StringPool</code> appends a null terminator</li>
<li><code>StringPool</code> checks if it&#39;s already stored <code>&#34;abc&#34;</code>, and if so, just hands that address back</li>
<li>Otherwise, <code>StringPool</code> adds it to a dictionary along with the base address + the total byte length stored so far—the address of this new string in the pool</li>
<li><code>StringPool</code> hands <em>that</em> address back</li>
<li>When all the code is finished compiling, we create an <code>rodata</code> section with the giant concatenated string produced by <code>StringPool</code>, stored at the string pool base address (retroactively making all the addresses <code>StringPool</code> handed out valid)</li>
</ol>
<h3 id="Lexer_(compiler.py:98)"><a href="#Lexer_(compiler.py:98)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Lexer_(compiler.py:98)"/>
</a><code>Lexer</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L98">compiler.py:98</a>)</small></h3>
<p>The <code>Lexer</code> class is complex, because lexing C is complex <small>(<code>(\\([\\abfnrtv&#39;&#34;?]|[0-7]{1,3}|x[A-Fa-f0-9]{1,2}))</code> is a real regex in that code for character escapes)</small>, but conceptually simple: the lexer marches along identifying what the token at the current position is.
The caller can peek that token, or it can use <code>next</code> to tell the lexer to advance, &#34;consuming&#34; that token.
It can also use <code>try_next</code> to conditionally advance only if the next token is a certain kind—basically, <code>try_next</code> is a shortcut for <code>if self.peek().kind == token: return self.next()</code>.</p>
<p>There&#39;s some additionally complexity because of something called the <a href="https://en.wikipedia.org/wiki/Lexer_hack">&#34;lexer hack&#34;</a>.
Essentially, when parsing C you want to know if something is a type name or variable name (because that context matters for compiling certain expressions), but there&#39;s no syntactic distinction between them: <code>int int_t = 0;</code> is perfectly valid C, as is <code>typedef int int_t; int_t x = 0;</code>.</p>
<p>To know if an arbitrary token <code>int_t</code> is a type name or a variable name, we need to feed type information from the parsing/codegen stage back into the lexer.
This is a giant pain for regular compilers that want to keep their lexer, parser, and codegen modules pure and plantonically separate, but it&#39;s actually not very hard for us!
I&#39;ll explain it more when we get to the <code>typedef</code> section, but basically we just keep <code>types: set[str]</code> in <code>Lexer</code>, and when lexing, check if a token is in that set before giving it a token kind:</p>
<pre data-lang="python"><code data-lang="python"><span>if </span><span>m </span><span>:= </span><span>re.match(</span><span>r</span><span>&#34;</span><span>^</span><span>[a-zA-Z_][a-zA-Z0-9_]</span><span>*</span><span>&#34;</span><span>, self.src[self.loc :]):
</span><span>    tok </span><span>= </span><span>m.group(</span><span>0</span><span>)
</span><span>    </span><span>...
</span><span>    </span><span># lexer hack
</span><span>    </span><span>return </span><span>Token(TOK_TYPE </span><span>if </span><span>tok </span><span>in </span><span>self.types </span><span>else </span><span>TOK_NAME, tok, self.line)
</span></code></pre>
<h3 id="CType_(compiler.py:201)"><a href="#CType_(compiler.py:201)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for CType_(compiler.py:201)"/>
</a><code>CType</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L201">compiler.py:201</a>)</small></h3>
<p>This is just a dataclass for representing information about a C type, like you&#39;d write in <code>int **t</code> or <code>short t[5]</code> or <code>char **t[17]</code>, minus the <code>t</code>.</p>
<p>It contains:</p>
<ul>
<li>the type&#39;s name (with any typedefs resolved), such as <code>int</code> or <code>short</code></li>
<li>what level of pointer is is (<code>0</code> = not a pointer, <code>1</code> = <code>int *t</code>, <code>2</code> = <code>int **t</code>, and so on)</li>
<li>what the array size is (<code>None</code> = not an array, <code>0</code> = <code>int t[0]</code>, <code>1</code> = <code>int t[1]</code>, and so on)</li>
</ul>
<p>Notably, as mentioned before, this type only supports single-level arrays, and not nested arrays like <code>int t[5][6]</code>.</p>
<h3 id="FrameVar_and_StackFrame_(compiler.py:314)"><a href="#FrameVar_and_StackFrame_(compiler.py:314)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for FrameVar_and_StackFrame_(compiler.py:314)"/>
</a><code>FrameVar</code> and <code>StackFrame</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L314">compiler.py:314</a>)</small></h3>
<p>These classes handle our C stack frames.</p>
<p>As I mentioned before, because you can&#39;t take references to the WASM stack, we have to manually handle the C stack, we can&#39;t use the WASM one.</p>
<p>To set up the C stack, the prelude emitted in <code>__main__</code> sets up a global <code>__stack_pointer</code> variable, and then every function call decrements that by however much space the function needs for its parameters and local variables—calculated by that function&#39;s <code>StackFrame</code> instance.</p>
<p>I&#39;ll go over how that calculation works in more detail when we get to parsing functions, but essentially, each parameter and local variable gets a slot in that stack space, and increases <code>StackFrame.frame_size</code> (and thus the offset of the <em>next</em> variable) depending on its size.
The offset, type information, and other data for each parameter and local variable are stored in a <code>FrameVar</code> instance, in <code>StackFrame.variables</code>, in order of declaration.</p>
<h3 id="ExprMeta_(compiler.py:344)"><a href="#ExprMeta_(compiler.py:344)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for ExprMeta_(compiler.py:344)"/>
</a><code>ExprMeta</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L344">compiler.py:344</a>)</small></h3>
<p>This final dataclass is used to track whether the result of an expression is a <em>value</em> or a <em>place</em>.
We need to keep track of this distinction in order to handle certain expressions differently based on how they&#39;re used.</p>
<p>For example, if you have a variable <code>x</code> of type <code>int</code>, it can be used in two ways:</p>
<ol>
<li><code>x + 1</code> wants the <em>value</em> of <code>x</code>, say <code>1</code>, to operate on</li>
<li><code>&amp;x</code> wants the <em>address</em> of <code>x</code>, say <code>0xcafedead</code></li>
</ol>
<p>When we parse the <code>x</code> expression, we can easily fetch the address from the stack frame:</p>
<pre data-lang="python"><code data-lang="python"><span># look the variable up in the `StackFrame`
</span><span>var, offset </span><span>= </span><span>frame.get_var_and_offset(varname)
</span><span># put the base address of the C stack on top of the WASM stack
</span><span>emit(</span><span>f</span><span>&#34;global.get $__stack_pointer&#34;</span><span>)
</span><span># add the offset (in the C stack)
</span><span>emit(</span><span>f</span><span>&#34;i32.const </span><span>{offset}</span><span>&#34;</span><span>)
</span><span>emit(</span><span>&#34;i32.add&#34;</span><span>)
</span><span># the address of the variable is now on top of the WASM stack
</span></code></pre>
<p>But now what?
If we <code>i32.load</code> this address to get the value, then <code>&amp;x</code> will have no way to get the address.
But if we don&#39;t load it, then <code>x + 1</code> will try to add one to the address, resulting in <code>0xcafedeae</code> instead of <code>2</code>!</p>
<p>That&#39;s where <code>ExprMeta</code> comes in: we leave the address on the stack, and return an <code>ExprMeta</code> indicating this is a <em>place</em>:</p>
<pre data-lang="python"><code data-lang="python"><span>return </span><span>ExprMeta(</span><span>True</span><span>, var.type)
</span></code></pre>
<p>Then, for operations like <code>+</code> that always want to operate on values instead of places, there&#39;s a function <code>load_result</code> that turns any places into values:</p>
<pre data-lang="python"><code data-lang="python"><span>def </span><span>load_result</span><span>(</span><span>em</span><span>: ExprMeta) -&gt; ExprMeta:
</span><span>    </span><span>&#34;&#34;&#34;Load a place `ExprMeta`, turning it into a value
</span><span>    `ExprMeta` of the same type&#34;&#34;&#34;
</span><span>    </span><span>if </span><span>em.is_place:
</span><span>        </span><span># emit i32.load, i32.load16_s, etc., based on the type
</span><span>        emit(em.type.load_ins())
</span><span>    </span><span>return </span><span>ExprMeta(</span><span>False</span><span>, em.type)
</span><span>
</span><span>...
</span><span># in the code for parsing `+`
</span><span>lhs_meta </span><span>= </span><span>load_result(parse_lhs())
</span><span>...
</span></code></pre>
<p>Meanwhile, an operation like <code>&amp;</code> just doesn&#39;t load the result, and instead leaves the address on the stack: in an important sense, <code>&amp;</code> is a no-op in our compiler, since it doesn&#39;t emit any code!</p>
<pre data-lang="python"><code data-lang="python"><span>if </span><span>lexer.try_next(</span><span>&#34;&amp;&#34;</span><span>):
</span><span>    meta </span><span>= </span><span>prefix()
</span><span>    </span><span>if not </span><span>meta.is_place:
</span><span>        die(</span><span>&#34;cannot take reference to value&#34;</span><span>, lexer.line)
</span><span>    </span><span># type of &amp;x is int* when x is int, hence more_ptr
</span><span>    </span><span>return </span><span>ExprMeta(</span><span>False</span><span>, meta.type.more_ptr())
</span></code></pre>
<p>Note also that, despite being an <em>address</em>, the result of <code>&amp;</code> <em>isn&#39;t</em> a place! <small>(The code returns an <code>ExprMeta</code> with <code>is_place=False</code>.)</small>
The result of <code>&amp;</code> should be treated like a value, since <code>&amp;x + 1</code> <em>should</em> add <code>1</code> (or rather, <code>sizeof(x)</code>) to the address.
That&#39;s why we need the place/value distinction, since just &#34;being an address&#34; isn&#39;t enough to know whether the result of an expression should be loaded.</p>
<p>OK, enough about helper classes.
Let&#39;s move on to the meat of codegen!</p>
<h2 id="Parsing_and_code_generation"><a href="#Parsing_and_code_generation">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Parsing_and_code_generation"/>
</a>Parsing and code generation</h2>
<p>The general control flow of the compiler goes like this:</p>
<center>
<img src="https://vgel.me/posts/c500/compiler-flow.drawio.svg"/>
</center>
<p>The blue rectangles represent the main functions of the compiler—<code>__main__</code>, <code>compile()</code>, <code>global_declaration()</code>, <code>statement()</code>, and <code>expression()</code>.
The long chain of squares at the bottom shows the operator precedence—most of those functions are automatically generated by a higher-order function, however!</p>
<p>I&#39;ll go through the blue squares one-by-one and explain anything interesting in each.</p>
<h3 id="__main___(compiler.py:827)"><a href="#__main___(compiler.py:827)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for __main___(compiler.py:827)"/>
</a><code>__main__</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L827">compiler.py:827</a>)</small></h3>
<p>This one is pretty short and dull.
Here it is in full:</p>
<pre data-lang="python"><code data-lang="python"><span>if </span><span>__name__ </span><span>== </span><span>&#34;__main__&#34;</span><span>:
</span><span>    </span><span>import </span><span>fileinput
</span><span>
</span><span>    </span><span>with </span><span>fileinput.input(</span><span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>) </span><span>as </span><span>fi:
</span><span>        </span><span>compile</span><span>(</span><span>&#34;&#34;</span><span>.join(fi))  </span><span># todo: make this line-at-a-time?
</span></code></pre>
<p>Clearly I never finished that TODO!
The only really interesting thing here is the <code>fileinput</code> module, which you may not have heard of.
From the module docs,</p>
<blockquote>
<p>Typical use is:</p>
<pre data-lang="python"><code data-lang="python"><span>import </span><span>fileinput
</span><span>for </span><span>line </span><span>in </span><span>fileinput.input(</span><span>encoding</span><span>=</span><span>&#34;utf-8&#34;</span><span>):
</span><span>    process(line)
</span></code></pre>
<p>This iterates over the lines of all files listed in sys.argv[1:],
defaulting to sys.stdin if the list is empty.  If a filename is &#39;-&#39; it
is also replaced by sys.stdin and the optional arguments mode and
openhook are ignored.  To specify an alternative list of filenames,
pass it as the argument to input().  A single file name is also allowed.</p>
</blockquote>
<p>This means, technically, <code>c500</code> supports multiple files!
<small>(If you don&#39;t mind them all being concatenated and having messed-up line numbers :-) <code>fileinput</code> is actually fairly sophisticated and has a <code>filelineno()</code> method, I just didn&#39;t use it for space reasons.)</small></p>
<h3 id="compile()_(compiler.py:805)"><a href="#compile()_(compiler.py:805)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for compile()_(compiler.py:805)"/>
</a><code>compile()</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L805">compiler.py:805</a>)</small></h3>
<p><code>compile()</code> is the first interesting function here, and is short enough to also include verbatim:</p>
<pre data-lang="python"><code data-lang="python"><span>def </span><span>compile</span><span>(</span><span>src</span><span>: </span><span>str</span><span>) -&gt; </span><span>None</span><span>:
</span><span>    </span><span># compile an entire file
</span><span>
</span><span>    </span><span>with </span><span>emit.block(</span><span>&#34;(module&#34;</span><span>, </span><span>&#34;)&#34;</span><span>):
</span><span>        emit(</span><span>&#34;(memory 3)&#34;</span><span>)
</span><span>        emit(</span><span>f</span><span>&#34;(global $__stack_pointer (mut i32) (i32.const </span><span>{PAGE_SIZE </span><span>* </span><span>3</span><span>}</span><span>))&#34;</span><span>)
</span><span>
</span><span>        emit(</span><span>&#34;(func $__dup_i32 (param i32) (result i32 i32)&#34;</span><span>)
</span><span>        emit(</span><span>&#34;  (local.get 0) (local.get 0))&#34;</span><span>)
</span><span>        emit(</span><span>&#34;(func $__swap_i32 (param i32) (param i32) (result i32 i32)&#34;</span><span>)
</span><span>        emit(</span><span>&#34;  (local.get 1) (local.get 0))&#34;</span><span>)
</span><span>
</span><span>        global_frame </span><span>= </span><span>StackFrame()
</span><span>        lexer </span><span>= </span><span>Lexer(src, </span><span>set</span><span>([</span><span>&#34;int&#34;</span><span>, </span><span>&#34;char&#34;</span><span>, </span><span>&#34;short&#34;</span><span>, </span><span>&#34;long&#34;</span><span>, </span><span>&#34;float&#34;</span><span>, </span><span>&#34;double&#34;</span><span>]))
</span><span>        </span><span>while </span><span>lexer.peek().kind </span><span>!= </span><span>TOK_EOF:
</span><span>            global_declaration(global_frame, lexer)
</span><span>
</span><span>        emit(</span><span>&#39;(export &#34;main&#34; (func $main))&#39;</span><span>)
</span><span>
</span><span>        </span><span># emit str_pool data section
</span><span>        emit(</span><span>f</span><span>&#39;(data $.rodata (i32.const </span><span>{str_pool.base}</span><span>) &#34;</span><span>{str_pool.pooled()}</span><span>&#34;)&#39;</span><span>)
</span></code></pre>
<p>This function handles emitting the module level prelude.</p>
<p>First, we emit a pragma for the WASM VM to reserve 3 pages of memory (<code>(memory 3)</code>), and we set the stack pointer to start at the end of that reserved region (it will grow downwards).</p>
<p>Then, we define two stack manipulation helpers <code>__dup_i32</code> and <code>__swap_i32</code>.
These should be familiar if you&#39;ve ever used Forth: <code>dup</code> duplicates the item on top of the WASM stack <small>(<code>a -- a a</code>)</small>, and <code>swap</code> swaps the position of the top two items on the WASM stack <small>(<code>a b -- b a</code>)</small>.</p>
<p>Next, we initialize a stack frame to hold the global variables, initialize the lexer with the built-in typenames for the lexer hack, and chew up global declarations until we run out!</p>
<p>Finally, we export <code>main</code> and dump the string pool.</p>
<h3 id="global_declaration()_(compiler.py:743)"><a href="#global_declaration()_(compiler.py:743)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for global_declaration()_(compiler.py:743)"/>
</a><code>global_declaration()</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L743">compiler.py:743</a>)</small></h3>
<p>This function is too long to inline the whole thing, but the signature looks like this:</p>
<pre data-lang="python"><code data-lang="python"><span>def </span><span>global_declaration</span><span>(</span><span>global_frame</span><span>: StackFrame, </span><span>lexer</span><span>: Lexer) -&gt; </span><span>None</span><span>:
</span><span>    </span><span># parse a global declaration -- typedef, global variable, or function.
</span><span>    </span><span>...
</span></code></pre>
<p>It handles typedefs, global variables, and functions.</p>
<p>Typedefs are cool, since this is where the lexer hack happens!</p>
<pre data-lang="python"><code data-lang="python"><span>if </span><span>lexer.try_next(</span><span>&#34;typedef&#34;</span><span>):
</span><span>    </span><span># yes, `typedef int x[24];` is valid (but weird) c
</span><span>    </span><span>type</span><span>, name </span><span>= </span><span>parse_type_and_name(lexer)
</span><span>    </span><span># lexer hack!
</span><span>    lexer.types.add(name.content)
</span><span>    typedefs[name.content] </span><span>= </span><span>type
</span><span>
</span><span>    lexer.next(</span><span>&#34;;&#34;</span><span>)
</span><span>    </span><span>return
</span></code></pre>
<p>We reuse a general type-name parsing tool since typedefs inherit all of C&#39;s weird &#34;declaration reflects usage&#34; rules, which is convenient for us. (and less so for the perplexed newbie!)
Then we inform the lexer we&#39;ve discovered a new type name, so that in the future that token will be lexed as a type name instead of a variable name.</p>
<p>Finally for typedefs, we store the type in the global typedef registry, consume the trailing semicolon, and return back to <code>compile()</code> for the next global declaration.
Importantly, the type we store is a <em>whole parsed type</em>, since if you do <code>typedef int* int_p;</code> and then later write <code>int_p *x</code>, <code>x</code> should get a resulting type of <code>int**</code>—the pointer level is additive!
That means we can&#39;t just store the base C typename, and instead need to store an entire <code>CType</code>.</p>
<p>If the declaration <em>wasn&#39;t</em> a typedef, we parse a variable type and name.
If we find a <code>;</code> token we know it&#39;s a global variable declaration (since we don&#39;t support global initializers).
In that case, we add the global variable to the global stack frame and bail.</p>
<pre data-lang="python"><code data-lang="python"><span>if </span><span>lexer.try_next(</span><span>&#34;;&#34;</span><span>):
</span><span>    global_frame.add_var(name.content, decl_type, </span><span>False</span><span>)
</span><span>    </span><span>return
</span></code></pre>
<p>If there&#39;s no semicolon, however, we&#39;re definitely dealing with a function.
To generate code for a function, we need to:</p>
<ol>
<li>Make a new <code>StackFrame</code> for the function, named <code>frame</code></li>
<li>Then, parse all the parameters and store them in the frame with <code>frame.add_var(varname.content, type, is_parameter=True)</code></li>
<li>After that, parse all the variable declarations with <code>variable_declaration(lexer, frame)</code>, which adds them to <code>frame</code></li>
<li>Now we know how large the function&#39;s stack frame needs to be (<code>frame.frame_size</code>), so we can start emitting the prelude!</li>
<li>First, for all the parameters in the stack frame (added with <code>is_parameter=True</code>), we generate WASM <code>param</code> declarations so the function can be called with the WASM calling convention (passing the parameters on the WASM stack):</li>
</ol>
<pre data-lang="python"><code data-lang="python"><span>for </span><span>v </span><span>in </span><span>frame.variables.values():
</span><span>    </span><span>if </span><span>v.is_parameter:
</span><span>        emit(</span><span>f</span><span>&#34;(param $</span><span>{v.name} {v.type.wasmtype}</span><span>)&#34;</span><span>)
</span></code></pre>
<ol start="5">
<li>Then, we can emit a <code>result</code> annotation for the return type, and adjust the C stack pointer to make space for the function&#39;s parameters and variables:</li>
</ol>
<pre data-lang="python"><code data-lang="python"><span>emit(</span><span>f</span><span>&#34;(result </span><span>{decl_type.wasmtype}</span><span>)&#34;</span><span>)
</span><span>emit(</span><span>&#34;global.get $__stack_pointer&#34;</span><span>)
</span><span># grow the stack downwards
</span><span>emit(</span><span>f</span><span>&#34;i32.const </span><span>{frame.frame_offset </span><span>+ </span><span>frame.frame_size}</span><span>&#34;</span><span>)
</span><span>emit(</span><span>&#34;i32.sub&#34;</span><span>)
</span><span>emit(</span><span>&#34;global.set $__stack_pointer&#34;</span><span>)
</span></code></pre>
<ol start="6">
<li>For each parameter (in reverse order, because stacks), copy it from the WASM stack to our stack:</li>
</ol>
<pre data-lang="python"><code data-lang="python"><span>for </span><span>v </span><span>in </span><span>reversed</span><span>(frame.variables.values()):
</span><span>    </span><span>if </span><span>v.is_parameter:
</span><span>        emit(</span><span>&#34;global.get $__stack_pointer&#34;</span><span>)
</span><span>        emit(</span><span>f</span><span>&#34;i32.const </span><span>{frame.get_var_and_offset(v.name)[</span><span>1</span><span>]}</span><span>&#34;</span><span>)
</span><span>        emit(</span><span>&#34;i32.add&#34;</span><span>)
</span><span>        </span><span># fetch the variable from the WASM stack
</span><span>        emit(</span><span>f</span><span>&#34;local.get $</span><span>{v.name}</span><span>&#34;</span><span>)
</span><span>        </span><span># and store it at the calculated address in the C stack
</span><span>        emit(v.type.store_ins())
</span></code></pre>
<ol start="7">
<li>Finally, we can call <code>statement(lexer, frame)</code> in a loop to codegen all the statements in the function, until we hit the closing bracket:</li>
</ol>
<pre data-lang="python"><code data-lang="python"><span>while not </span><span>lexer.try_next(</span><span>&#34;}&#34;</span><span>):
</span><span>    statement(lexer, frame)
</span></code></pre>
<ol start="8">
<li>Bonus step: we assume the function will always have a <code>return</code>, so we <code>emit(&#34;unreachable&#34;)</code> so the WASM analyzer doesn&#39;t freak out.</li>
</ol>
<p>Whoof!
That was a lot.
But that&#39;s all for functions, and thus for <code>global_declaration()</code>, so let&#39;s move on to <code>statement()</code>.</p>
<h3 id="statement()_(compiler.py:565)"><a href="#statement()_(compiler.py:565)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for statement()_(compiler.py:565)"/>
</a><code>statement()</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L565">compiler.py:565</a>)</small></h3>
<p>There&#39;s a lot of code in <code>statement()</code>.
However, most of it is fairly repetitive, so I&#39;ll just explain <code>while</code> and <code>for</code>, which should give a good overview.</p>
<p>Remember how WASM doesn&#39;t have jumps, and instead has structured control flow?
That&#39;s relevant now.</p>
<p>First, let&#39;s see how it works with <code>while</code>, where it&#39;s not too much trouble.
A while loop in WASM looks like this:</p>
<pre data-lang="clojure"><code data-lang="clojure"><span>block
</span><span>  loop
</span><span>    </span><span>;; &lt;test&gt;
</span><span>    i32.eqz
</span><span>    br_if </span><span>1
</span><span>    </span><span>;; &lt;loop body&gt;
</span><span>    br </span><span>0
</span><span>  end
</span><span>end
</span></code></pre>
<p>As you can see, there are two types of blocks—<code>block</code> and <code>loop</code> (there&#39;s also an <code>if</code> block type, which I didn&#39;t use).
Each encloses some number of statements and then ends with <code>end</code>.
Inside a block, you can break with <code>br</code>, or conditionally based on the top of the WASM stack with <code>br_if</code> (there&#39;s also <code>br_table</code>, which I didn&#39;t use).</p>
<p>The <code>br</code> family takes a <em>labelidx</em> parameter, here either <code>1</code> or <code>0</code>, which is what level of block the operation applies to.
So in our while loop, the <code>br_if 1</code> applies to the outer block—index 1, while the <code>br 0</code> applies to the inner block—index 0. <small>(indices are always relative to the instruction in question—0 is the innermost block <em>to that instruction</em>.)</small></p>
<p>Finally, the last rule to know is that a <code>br</code> in a <code>block</code> jumps <em>forwards</em>, to the end of the <code>block</code>, whereas a <code>br</code> in a <code>loop</code> jumps <em>backwards</em>, to the beginning of the <code>loop</code>.</p>
<p>So hopefully the while loop code makes sense now!
Looking at it again,</p>
<pre data-lang="clojure"><code data-lang="clojure"><span>block
</span><span>  loop
</span><span>    </span><span>;; &lt;test&gt;
</span><span>    i32.eqz
</span><span>
</span><span>    </span><span>;; if test == 0, jump forwards (1 = labelidx of the `block`),
</span><span>    </span><span>;; out of the loop
</span><span>    br_if </span><span>1
</span><span>
</span><span>    </span><span>;; &lt;loop body&gt;
</span><span>
</span><span>    </span><span>;; unconditionally jump backwards (0 = labelidx of the `loop`).
</span><span>    </span><span>;; to the beginning of the loop
</span><span>    br </span><span>0
</span><span>  end
</span><span>end
</span></code></pre>
<p>In more normal assembly, this would correspond to:</p>
<pre data-lang="nasm"><code data-lang="nasm"><span>.loop_start
</span><span>  ;; &lt;test&gt;
</span><span>  </span><span>jz </span><span>.block_end
</span><span>  ;; &lt;loop body&gt;
</span><span>  </span><span>jmp </span><span>.loop_start
</span><span>.block_end
</span></code></pre>
<p>But with jumps, you can express things that you can&#39;t (easily) in WASM—for example, you could jump into the middle of a block.</p>
<p><small>(This mainly is an issue for compiling C&#39;s <code>goto</code>, which I didn&#39;t even attempt—there&#39;s an algorithm that can transform any code using <code>goto</code> into an equivalent program using structured control flow, but it&#39;s complicated and I don&#39;t think it would work with our single-pass approach.)</small></p>
<p>But for while loops, this isn&#39;t too bad.
All we have to do is:</p>
<pre data-lang="python"><code data-lang="python"><span># `emit.block` is a context manager to emit the first parameter (&#34;block&#34; here),
</span><span># and then the second (&#34;end&#34;) on exit
</span><span>with </span><span>emit.block(</span><span>&#34;block&#34;</span><span>, </span><span>&#34;end&#34;</span><span>):
</span><span>    </span><span>with </span><span>emit.block(</span><span>&#34;loop&#34;</span><span>, </span><span>&#34;end&#34;</span><span>):
</span><span>        </span><span># emit code for the test, ending with `i32.eqz`
</span><span>        parenthesized_test()
</span><span>        </span><span># emit code to exit the loop if the `i32.eqz` was true
</span><span>        emit(</span><span>&#34;br_if 1&#34;</span><span>)
</span><span>        </span><span># emit code for the body
</span><span>        bracketed_block_or_single_statement(lexer, frame)
</span><span>        </span><span># emit code to jump back to the beginning
</span><span>        emit(</span><span>&#34;br 0&#34;</span><span>)
</span></code></pre>
<p>With for loops though, it gets nasty.
Consider a for loop like this:</p>
<pre data-lang="c"><code data-lang="c"><span>for </span><span>(i </span><span>= </span><span>0</span><span>; i </span><span>&lt; </span><span>5</span><span>; i </span><span>=</span><span> i </span><span>+ </span><span>1</span><span>) {
</span><span>    j </span><span>=</span><span> j </span><span>* </span><span>2 </span><span>+</span><span> i;
</span><span>}
</span></code></pre>
<p>The order the parts of the for loop will be seen by the lexer/code generator is:</p>
<ol>
<li><code>i = 0</code></li>
<li><code>i &lt; 5</code></li>
<li><code>i = i + 1</code></li>
<li><code>j = j * 2 + i</code></li>
</ol>
<p>But the order we need to put them in the code, to work with WASM&#39;s structured control flow, is:</p>
<pre><code><span>block
</span><span>  ;; &lt; code for `i = 0` (1) &gt;
</span><span>  loop
</span><span>    ;; &lt; code for `i &lt; 5` (2) &gt;
</span><span>    br_if 1
</span><span>    ;; &lt; code for `j = j * 2 + i` (4!) &gt;
</span><span>    ;; &lt; code for `i = i + 1` (3!) &gt;
</span><span>    br 0
</span><span>  end
</span><span>end
</span></code></pre>
<p>Notice that 3 and 4 are inverted in the generated code, making the order 1, 2, 4, 3.
This is a problem for a single pass compiler!
Unlike a normal compiler, we can&#39;t store the advancement statement for later.
Or… can we?</p>
<p>How I ended up handling this is by making the lexer <em>cloneable</em>, and re-parsing the advancement statement <em>after</em> parsing the body.
Essentially, the code looks like:</p>
<pre data-lang="python"><code data-lang="python"><span>elif </span><span>lexer.try_next(</span><span>&#34;for&#34;</span><span>):
</span><span>    lexer.next(</span><span>&#34;(&#34;</span><span>)
</span><span>    </span><span>with </span><span>emit.block(</span><span>&#34;block&#34;</span><span>, </span><span>&#34;end&#34;</span><span>):
</span><span>        </span><span># parse initializer (i = 0)
</span><span>        </span><span># (outside of loop since it only happens once)
</span><span>        </span><span>if </span><span>lexer.peek().kind </span><span>!= </span><span>&#34;;&#34;</span><span>:
</span><span>            expression(lexer, frame)
</span><span>            emit(</span><span>&#34;drop&#34;</span><span>) </span><span># discard result of initializer
</span><span>        lexer.next(</span><span>&#34;;&#34;</span><span>)
</span><span>
</span><span>        </span><span>with </span><span>emit.block(</span><span>&#34;loop&#34;</span><span>, </span><span>&#34;end&#34;</span><span>):
</span><span>            </span><span># parse test (i &lt; 5), if present
</span><span>            </span><span>if </span><span>lexer.peek().kind </span><span>!= </span><span>&#34;;&#34;</span><span>:
</span><span>                load_result(expression(lexer, frame))
</span><span>                emit(</span><span>&#34;i32.eqz ;; for test&#34;</span><span>)
</span><span>                emit(</span><span>&#34;br_if 1 ;; exit loop&#34;</span><span>)
</span><span>            lexer.next(</span><span>&#34;;&#34;</span><span>)
</span><span>
</span><span>            </span><span># handle first pass of advancement statement, if present
</span><span>            saved_lexer </span><span>= </span><span>None
</span><span>            </span><span>if </span><span>lexer.peek().kind </span><span>!= </span><span>&#34;)&#34;</span><span>:
</span><span>                saved_lexer </span><span>= </span><span>lexer.clone()
</span><span>                </span><span># emit.no_emit() disables code output inside of it,
</span><span>                </span><span># so we can skip over the advancement statement for now
</span><span>                </span><span># to get to the for loop body
</span><span>                </span><span>with </span><span>emit.no_emit():
</span><span>                    expression(lexer, frame)
</span><span>            lexer.next(</span><span>&#34;)&#34;</span><span>)
</span><span>
</span><span>            </span><span># parse body
</span><span>            bracketed_block_or_single_statement(lexer, frame)
</span><span>
</span><span>            </span><span># now that we parsed the body, go back and re-parse
</span><span>            </span><span># the advancement statement using the saved lexer
</span><span>            </span><span>if </span><span>saved_lexer </span><span>!= </span><span>None</span><span>:
</span><span>                expression(saved_lexer, frame)
</span><span>
</span><span>            </span><span># jump back to beginning of loop
</span><span>            emit(</span><span>&#34;br 0&#34;</span><span>)
</span></code></pre>
<p>As you can see, the hack is to save the lexer, then use <em>that</em> to go back and handle the advancement statement later, instead of saving the syntax tree like a normal compiler would.
Not very elegant—compiling for loops is probably the gnarliest code in the compiler—but it works well enough!</p>
<p>The other parts of <code>statement()</code> are mostly similar, so I&#39;ll skip over them to get to the last main part of the compiler—<code>expression()</code>.</p>
<h3 id="expression()_(compiler.py:375)"><a href="#expression()_(compiler.py:375)">
  <img src="https://vgel.me/permalink.svg" alt="permalink for expression()_(compiler.py:375)"/>
</a><code>expression()</code> <small>(<a href="https://github.com/vgel/c500/blob/e10f78891f925c2501611b848c10086ecc16ca4f/compiler.py#L375">compiler.py:375</a>)</small></h3>
<p><code>expression()</code> is the last big method in the compiler, and it handles parsing expressions, as you might expect.
It contains many inner methods, one for each precedence level, each returning the <code>ExprMeta</code> struct described earlier (which handle the &#34;place vs value&#34; distinction and can be turned into a value using <code>load_result</code>).</p>
<p>The bottom of the precedence stack is <code>value()</code> (somewhat confusingly named, since it can return <code>ExprMeta(is_place=True, ...)</code>).
It handles constants, parenthesized expressions, function calls, and variable names.</p>
<p>Above that, the basic pattern for a precedence level is a function like this:</p>
<pre data-lang="python"><code data-lang="python"><span> </span><span>def </span><span>muldiv</span><span>() -&gt; ExprMeta:
</span><span>    </span><span># lhs is the higher precedence operation (prefix operators, in this case)
</span><span>    lhs_meta </span><span>= </span><span>prefix()
</span><span>    </span><span># check if we can parse an operation
</span><span>    </span><span>if </span><span>lexer.peek().kind </span><span>in </span><span>(</span><span>&#34;*&#34;</span><span>, </span><span>&#34;/&#34;</span><span>, </span><span>&#34;%&#34;</span><span>):
</span><span>        </span><span># if so, load in the left hand side
</span><span>        lhs_meta </span><span>= </span><span>load_result(lhs_meta)
</span><span>        </span><span># grab the specific operator
</span><span>        op_token </span><span>= </span><span>lexer.next()
</span><span>        </span><span># the right hand side should use this function, for e.g. `x * y * z`
</span><span>        load_result(muldiv())
</span><span>        </span><span># emit an opcode to do the operation
</span><span>        </span><span>if </span><span>op_token </span><span>== </span><span>&#34;*&#34;</span><span>:
</span><span>            emit(</span><span>f</span><span>&#34;i32.mul&#34;</span><span>)
</span><span>        </span><span>elif </span><span>op_token </span><span>== </span><span>&#34;/&#34;</span><span>:
</span><span>            emit(</span><span>f</span><span>&#34;i32.div_s&#34;</span><span>)
</span><span>        </span><span>else</span><span>: </span><span># %
</span><span>            emit(</span><span>f</span><span>&#34;i32.rem_s&#34;</span><span>)
</span><span>        </span><span># mask down the result if this is a less-than-32bit type
</span><span>        mask_to_sizeof(lhs_meta.type)
</span><span>        </span><span># we produced a value (is_place=False)
</span><span>        </span><span>return </span><span>ExprMeta(</span><span>False</span><span>, lhs_meta.type)
</span><span>    </span><span># if we didn&#39;t find a token, just return the left hand side unchanged
</span><span>    </span><span>return </span><span>lhs_meta
</span></code></pre>
<p>In fact, this pattern is so consistent that most operations, including <code>muldiv</code>, aren&#39;t written out, but instead defined by a higher-order function <code>makeop</code>:</p>
<pre data-lang="python"><code data-lang="python"><span># function for generating simple operator precedence levels from declarative
</span><span># dictionaries of { token: instruction_to_emit }
</span><span>def </span><span>makeop</span><span>(
</span><span>    </span><span>higher</span><span>: Callable[[], ExprMeta], </span><span>ops</span><span>: </span><span>dict</span><span>[</span><span>str</span><span>, </span><span>str</span><span>], </span><span>rtype</span><span>: CType </span><span>| </span><span>None </span><span>= </span><span>None
</span><span>) -&gt; Callable[[], ExprMeta]:
</span><span>    </span><span>def </span><span>op</span><span>() -&gt; ExprMeta:
</span><span>        lhs_meta </span><span>= </span><span>higher()
</span><span>        </span><span>if </span><span>lexer.peek().kind </span><span>in </span><span>ops.keys():
</span><span>            lhs_meta </span><span>= </span><span>load_result(lhs_meta)
</span><span>            op_token </span><span>= </span><span>lexer.next()
</span><span>            load_result(op())
</span><span>            </span><span># TODO: type checking?
</span><span>            emit(</span><span>f</span><span>&#34;</span><span>{ops[op_token.kind]}</span><span>&#34;</span><span>)
</span><span>            mask_to_sizeof(rtype </span><span>or </span><span>lhs_meta.type)
</span><span>            </span><span>return </span><span>ExprMeta(</span><span>False</span><span>, lhs_meta.type)
</span><span>        </span><span>return </span><span>lhs_meta
</span><span>
</span><span>    </span><span>return </span><span>op
</span><span>
</span><span>muldiv </span><span>= </span><span>makeop(prefix, {</span><span>&#34;*&#34;</span><span>: </span><span>&#34;i32.mul&#34;</span><span>, </span><span>&#34;/&#34;</span><span>: </span><span>&#34;i32.div_s&#34;</span><span>, </span><span>&#34;%&#34;</span><span>: </span><span>&#34;i32.rem_s&#34;</span><span>})
</span><span>...
</span><span>shlr </span><span>= </span><span>makeop(plusminus, {</span><span>&#34;&lt;&lt;&#34;</span><span>: </span><span>&#34;i32.shl&#34;</span><span>, </span><span>&#34;&gt;&gt;&#34;</span><span>: </span><span>&#34;i32.shr_s&#34;</span><span>})
</span><span>cmplg </span><span>= </span><span>makeop(
</span><span>    shlr,
</span><span>    {</span><span>&#34;&lt;&#34;</span><span>: </span><span>&#34;i32.lt_s&#34;</span><span>, </span><span>&#34;&gt;&#34;</span><span>: </span><span>&#34;i32.gt_s&#34;</span><span>, </span><span>&#34;&lt;=&#34;</span><span>: </span><span>&#34;i32.le_s&#34;</span><span>, </span><span>&#34;&gt;=&#34;</span><span>: </span><span>&#34;i32.ge_s&#34;</span><span>},
</span><span>    CType(</span><span>&#34;int&#34;</span><span>),
</span><span>)
</span><span>cmpe </span><span>= </span><span>makeop(cmplg, {</span><span>&#34;==&#34;</span><span>: </span><span>&#34;i32.eq&#34;</span><span>, </span><span>&#34;!=&#34;</span><span>: </span><span>&#34;i32.ne&#34;</span><span>}, CType(</span><span>&#34;int&#34;</span><span>))
</span><span>bitand </span><span>= </span><span>makeop(cmpe, {</span><span>&#34;&amp;&#34;</span><span>: </span><span>&#34;i32.and&#34;</span><span>})
</span><span>bitor </span><span>= </span><span>makeop(bitand, {</span><span>&#34;|&#34;</span><span>: </span><span>&#34;i32.or&#34;</span><span>})
</span><span>xor </span><span>= </span><span>makeop(bitor, {</span><span>&#34;^&#34;</span><span>: </span><span>&#34;i32.xor&#34;</span><span>})
</span><span>...
</span></code></pre>
<p>Only a few operations with special behavior need to be defined explicitly, like <code>plusminus</code> which needs to handle the nuances of C pointer math.</p>
<p>And that&#39;s it!
That&#39;s the last main piece of the compiler.</p>
<h2 id="Wrapping_up..."><a href="#Wrapping_up...">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Wrapping_up..."/>
</a>Wrapping up...</h2>
<p>That&#39;s been our tour of the <a href="https://github.com/vgel/c500/">C compiler in 500 lines of Python</a>!
Compilers have a reputation for being complex—GCC and Clang are massive, and even TCC, the <em>Tiny</em> C Compiler, is tens of thousands of lines of code—but if you&#39;re willing to sacrifice code quality and do everything in a single pass, they can be surprisingly compact!</p>
<p>I&#39;d be interested to hear if you write your own single-pass compiler—maybe for a custom language?
I think this kind of compiler could potentially be a great stage0 for a self-hosted language, since it&#39;s so simple.</p>
<p>Next time, this blog will be back to regularly-scheduled LLM posting with a post about making a small transformer by hand!</p>
<pre data-lang="python"><code data-lang="python"><span>MODEL </span><span>= </span><span>{
</span><span>    </span><span># EMBEDDING USAGE
</span><span>    </span><span>#  P = Position embeddings (one-hot)
</span><span>    </span><span>#  T = Token embeddings (one-hot, first is `a`, second is `b`)
</span><span>    </span><span>#  V = Prediction scratch space
</span><span>    </span><span>#
</span><span>    </span><span>#       [P, P, P, P, P, T, T, V]
</span><span>    </span><span>&#34;wte&#34;</span><span>: np.array(
</span><span>        </span><span># one-hot token embeddings
</span><span>        [
</span><span>            [</span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>1</span><span>, </span><span>0</span><span>, </span><span>0</span><span>],  </span><span># token `a` (id 0)
</span><span>            [</span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>1</span><span>, </span><span>0</span><span>],  </span><span># token `b` (id 1)
</span><span>        ]
</span><span>    ),
</span><span>    </span><span>&#34;wpe&#34;</span><span>: np.array(
</span><span>        </span><span># one-hot position embeddings
</span><span>        [
</span><span>            [</span><span>1</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>],  </span><span># position 0
</span><span>            [</span><span>0</span><span>, </span><span>1</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>],  </span><span># position 1
</span><span>            [</span><span>0</span><span>, </span><span>0</span><span>, </span><span>1</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>],  </span><span># position 2
</span><span>            [</span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>1</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>],  </span><span># position 3
</span><span>            [</span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>1</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>],  </span><span># position 4
</span><span>        ]
</span><span>    ),
</span><span>    </span><span>...</span><span>: </span><span>...
</span><span>}
</span></code></pre>
<p>If that sounds interesting, or you want to see more posts like this, consider <a href="https://twitter.com/voooooogel/">following me on Twitter</a> or subscribing to my mailing list to get updates on new posts!</p>

<p>If you have thoughts about this post, please feel free to <a href="https://vgel.me/contact">get in touch</a>!
<small>(Even if you just want to say &#34;that was cool&#34; or want to ask a clarifying question—don&#39;t feel like it needs to be capital-I-Important!)</small></p>
<p>And if you&#39;re still around, you must really like the blog, so here&#39;s some more stuff to check out :-)</p>
<ul>
<li><a href="https://vgel.me/posts">My other blog posts</a>, such as:
<ul>
<li><a href="https://vgel.me/posts/donut">Signed distance functions in 46 lines of Python</a></li>
<li><a href="https://vgel.me/posts/tools-not-needed/">GPT-3 will ignore tools when it disagrees with them</a></li>
<li><a href="https://vgel.me/posts/mmap-arena-alloc">mmap(1Tb): A Rust arena allocator (ab)using Linux overcommit</a></li>
<li><a href="https://vgel.me/posts/gpt4-javascript">Does GPT-4 think better in Javascript?</a></li>
</ul>
</li>
<li><a href="https://vgel.me/">My other projects</a>, including <a href="https://vgel.me/fiction">my short fiction</a></li>
<li>My <a href="https://twitter.com/voooooogel/">Twitter</a></li>
</ul>
<hr/>

<!---->



    <ul>
      
        <li><strong>Previous entry:</strong> <a href="https://vgel.me/posts/adversarial-training-data/">I&#39;m worried about adversarial training data</a></li>
      
      
        <li><strong>Next entry:</strong> <a href="https://vgel.me/posts/handmade-transformer/">I made a transformer by hand (no training!)</a></li>
      
    </ul>
</article></div>
  </body>
</html>
