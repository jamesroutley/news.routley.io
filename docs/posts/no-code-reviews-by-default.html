<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.raycast.com/blog/no-code-reviews-by-default/">Original</a>
    <h1>No code reviews by default</h1>
    
    <div id="readability-page-1" class="page"><div data-v-52892cf0=""><p data-v-52892cf0="">How we built an engineering culture based on trust that allows us to move incredibly fast without requiring code reviews.</p><div data-v-52892cf0=""><!----><p><span data-v-52892cf0="">Published on</span><span data-v-52892cf0="">June 23, 2021</span></p></div></div><div><p>At Raycast, we do not require code reviews. Engineers push to the main branch and request reviews when they think it&#39;s necessary. In this blog post, I outline how we built an engineering culture that is based on trust and allows us to move incredibly fast.</p><h2 id="the-beginning"><a href="#the-beginning" aria-hidden="true"><span></span></a>The beginning</h2><p>When Petr and I started Raycast, we were sitting next to each other in the same flat for three months. Every day, we built features to iterate as fast as possible to something users want. At this time, we didn&#39;t do any code reviews and trusted each other blindly. If there was a technical question, we solved it in person, committed the code to the main branch and moved on to the next problem.</p><p>When we started to grow our distributed team, we asked ourselves if we should adopt code reviews. Common wisdom tells you that pull requests are best practice in high-performing engineering teams. But we liked the trust, collaboration and speed of our &#34;process&#34; and decided to <strong><em>not</em></strong> require code reviews. Instead, every engineer has the right to push their changes to the main branch. They can request a review if they want somebody else to take another look at their code. Sometimes this happens after the change has landed in the trunk.</p><h2 id="responsibility-over-convention"><a href="#responsibility-over-convention" aria-hidden="true"><span></span></a>Responsibility over convention</h2><p>We use GitHub for source control, which comes with the concept of pull requests (PR) for code reviews. Typically, an engineer works on a task and then proposes their changes to the repository. After a discussion and potential changes, the engineer merges their changes into the base branch. This model works great for open source and allows strangers to contribute to projects. However, we found it impractical for our team for a few reasons:</p><ul><li><strong>Pull requests discourage trust.</strong> Proposing every code change that somebody else has to approve doesn&#39;t feel encouraging for teams that should operate with a high degree of trust. There are more efficient ways to collaborate on code.</li><li><strong>Pull requests don&#39;t prevent bugs.</strong> Reviewing code is hard! You can catch obvious mistakes, but you won&#39;t have consistent in-depth scrutiny. Many issues reveal themselves only after extensive use, which doesn&#39;t happen during code reviews. We rely on fast iterations with <a href="https://www.raycast.com/blog/feedback/">user feedback</a>.</li><li><strong>Pull requests slow down.</strong> Code reviews aren&#39;t high priority for engineers. They have to make time to clean up their review queue. In reality, PRs are an afterthought and not what you want to spend your time on as an engineer.</li></ul><p>We value <a href="https://www.raycast.com/jobs#what-we-offer">full responsibility</a> and all our engineers own features from ideation to maintenance. Our engineering culture reflects this by giving engineers the freedom to push to the main branch and only request code reviews if they think it&#39;s necessary.</p><h2 id="how-does-this-work-in-practice"><a href="#how-does-this-work-in-practice" aria-hidden="true"><span></span></a>How does this work in practice?</h2><p>Our goal is to dogfood changes as quickly as possible. For this, everybody works on the main branch. This produces a constant stream of changes that can be immediately tested by others. Our continuous integration builds and tests every commit. In addition, we trigger an internal release every night which includes all changes that got committed during the day. Each release is automatically installed for the entire team. This allows us to test new changes within 24 hours.</p><p>The daily internal releases make it simple to collect a lot of feedback to iron out bugs or usability issues. If the team is happy with the quality of a feature, it gets released as part of our next public release. If it needs further iterations, we use a feature flag to keep it internal. This workflow helps us to consistently ship <a href="https://www.raycast.com/changelog">updates every other week</a>.</p><p>There are some situations when we request code reviews. If we touch a new part of the codebase, we open a pull request. A good example for such a change is adding a database migration for the first time. Nobody wants to screw up the production environment and rather double checks it. Often new team members request code reviews for the first couple of weeks to familiarize themselves with our codebase. Over time, they gain confidence to work on bigger changes and start pushing to the main branch directly. </p><p>It doesn&#39;t always have to be a PR. Sometimes it&#39;s enough to make a teammate aware of a particular change with a &#34;post-commit message&#34;. After somebody committed their change, they link the relevant person in a Slack channel that is subscribed to our repository or on the commit on GitHub itself. This is useful for changes that could affect the work of others. This is also a great way to avoid blocking code reviews due to time differences. If there is some problem that needs the input of multiple engineers, we hop on a quick <a href="https://www.around.co/?ref=raycast" target="_blank" rel="nofollow noopener noreferrer">Around</a> video call and use screen sharing to collaborate. This is handy to sort out bigger topics such as refactoring parts of the codebase or aligning on features that depend on each other.</p><p>We found this way of working more effective. It avoids isolated work on long-lived branches and creates momentum through the continuous updating of the app.</p><h2 id="make-your-own-rules"><a href="#make-your-own-rules" aria-hidden="true"><span></span></a>Make your own rules</h2><p>Every company or team is different, but one thing is the same: They all want to build the best product in the shortest time possible. There are different ways to achieve this. Ours is to bet on our team and give all engineers the trust to do their best job. This includes letting them decide whenever they want their code reviewed by somebody else. This might be not the right process for other teams that have more strict security requirements. So far, this works well for us. It allows us to rapidly iterate on features, attract great engineers who want to tackle big problems, and establish an asynchronous communication culture that fits our fully distributed team. </p><p>It&#39;s up to you and your colleagues to set the rules for your team. Don&#39;t adopt best practices in a dogmatic fashion. Rather, ask yourself if the circumstances of others apply to you. There is a high chance that they won&#39;t, and you find a more suited way to do things.</p></div></div>
  </body>
</html>
