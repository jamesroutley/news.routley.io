<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.windytan.com/2023/02/using-hdmi-radio-interference-for-high.html">Original</a>
    <h1>Using HDMI radio interference for high-speed data transfer</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-5359688901110033558" itemprop="description articleBody">
<p>This story, too, begins with noise. I was browsing the radio waves with a software radio, looking for mysteries to accompany my ginger tea. I had started to notice a wide-band spiky signal on a number of frequencies that only seemed to appear indoors. Some sort of interference from electronic devices, probably. Spoiler alert, it eventually led me to broadcast a webcam picture over the radio waves... but how?</p>

<h3>It sounds like video</h3>

<p>The mystery deepened when I listened to how this interference sounded like as an AM signal. It reminded me of a time I mistakenly plugged our home stereo system to the Nintendo console&#39;s video output and heard a very similar buzz.</p>



<p>Am I possibly listening to video? Why would there be analog video transmitting on any frequency, let alone inside my home?</p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgXUsWHBMqcYxy4gA0sBUBqWrLsHi4PWksuIljM1lNuhYfc9YCgUGSjo9jAeGmgf1IEMrBrCgaqDTfunlFkWw_5yGTUujWYw3Twd16cn_JQkPzXCoL4YeRU_aCXxu1bDzbssBxo5wBtXuRXWVMSCCjZ2rj80CsOQCEORg1FhVSVLK724BQNDxMtHKGT7A/s1726/Screen%20Shot%202023-02-26%20at%2011.16.20.png"><img alt="" width="500" data-original-height="538" data-original-width="1726" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgXUsWHBMqcYxy4gA0sBUBqWrLsHi4PWksuIljM1lNuhYfc9YCgUGSjo9jAeGmgf1IEMrBrCgaqDTfunlFkWw_5yGTUujWYw3Twd16cn_JQkPzXCoL4YeRU_aCXxu1bDzbssBxo5wBtXuRXWVMSCCjZ2rj80CsOQCEORg1FhVSVLK724BQNDxMtHKGT7A/s480/Screen%20Shot%202023-02-26%20at%2011.16.20.png" srcset="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgXUsWHBMqcYxy4gA0sBUBqWrLsHi4PWksuIljM1lNuhYfc9YCgUGSjo9jAeGmgf1IEMrBrCgaqDTfunlFkWw_5yGTUujWYw3Twd16cn_JQkPzXCoL4YeRU_aCXxu1bDzbssBxo5wBtXuRXWVMSCCjZ2rj80CsOQCEORg1FhVSVLK724BQNDxMtHKGT7A/s960/Screen%20Shot%202023-02-26%20at%2011.16.20.png 2x" alt="[Image: Oscillogram of a noisy waveform that seems to have a pulse every 10 microseconds or so.]"/></a></p>

<p>If we plot the signal&#39;s amplitude against time we can see that there is a strong pulse exactly 60 times per second. This could be the vertical synchronisation signal of 60 Hz video. A shorter pulse (pictured above) can be seen repeating more frequently; it could be the horizontal one. Between these pulses there is what appears to be noise. Maybe, if we use the strong pulses for synchronisation and plot the amplitude of that noise as a two-dimensional picture, we could see something?</p>

<p>And sure enough, when main screen turn on, we get signal:</p>
<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg9CNpvezklyb70HXN6VomYVMSpTsW6AFDkXmP_0O4DjuaWfEhvDDu_j1owOPDDOaIYvEcLe9L4ifzTy2wSfzqaMzBfSFa9xIlax5CSJVAQDiFb_81KkdjDr3yaJwbQsxbldjLlhjBwUUs4xyVSdZKeiunBFFkLlGKR734HbGYvi6PJ_9JlKv6l0-wDDw/s947/saved_frame.jpg"><img alt="" width="473" data-original-height="668" data-original-width="947" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg9CNpvezklyb70HXN6VomYVMSpTsW6AFDkXmP_0O4DjuaWfEhvDDu_j1owOPDDOaIYvEcLe9L4ifzTy2wSfzqaMzBfSFa9xIlax5CSJVAQDiFb_81KkdjDr3yaJwbQsxbldjLlhjBwUUs4xyVSdZKeiunBFFkLlGKR734HbGYvi6PJ_9JlKv6l0-wDDw/s473/saved_frame.jpg" alt="[Image: A grainy greyscale image of what appears to be a computer desktop.]"/></a></p>

<p>(I&#39;ve hidden the bright synchronisation signal from this picture.)</p>

<p>It seems to be my Raspberry Pi&#39;s desktop with weirdly distorted greyscale colours! Somehow, some part of the monitor setup is radiating it quite loudly into the aether. The frequency I&#39;m listening to is a multiple of the monitor&#39;s pixel clock frequency.</p>

<p>As it turns out, this vulnerability of some monitors has been known for a long time. In 1985, van Eck demonstrated how CRT monitors can be spied on from a distance<a href="#vanEck1985">[1]</a>; and in 2004, Markus Kuhn showed that the same still works on flat-screen monitors<a href="#Kuhn2004">[2]</a>. The image is heavily distorted, but some shapes and even bigger text can be recognisable.</p>

<p>The next thought was, could we get any more information out of these images? Is there any information about colour?</p>

<h3>Mapping all the colours</h3>

<p>HDMI is fully digital; there is no linear dependency between pixel values and greyscale brightness in this amplitude image. I believe the brightness is related to the number of bit transitions over my radio&#39;s sampling time (which is around 8 bit-lengths); and in HDMI, this is dependent on many things, not just the actual RGB value of the pixel. HDMI also uses multiple differential wires that all are transmitting their own picture channels side by side.</p>

<p>This is why I don&#39;t think it&#39;s <del>possible</del> easy to reconstruct a clear picture of what&#39;s being shown on the screen, let alone decode any colours.</p>

<p>But could the reverse be possible? Could we control this phenomenon to draw the greyscale pictures of our choice on the receiver&#39;s screen? How about sending binary data by displaying alternating pixel values on the monitor?</p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjYlBNJnxusLm0zga8IEeSTo8OwbdhSK_FlW37ms4d_Vs443hYuSLpUnGWl1_pvmYsdo9u4Tmnc0GSPr4He9tFsSOd3kC6JZ2LTJnsNI1Gy7KhEsL_qXGBi-TWeolcUiwyprFVL_F7Rw4MOCe3zVh6XBzeCpdeiHumCgQOxPmz22WZTT2V1yeRFjKJAwA/s1360/gradients1.jpg"><img alt="" width="480" data-original-height="768" data-original-width="1360" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjYlBNJnxusLm0zga8IEeSTo8OwbdhSK_FlW37ms4d_Vs443hYuSLpUnGWl1_pvmYsdo9u4Tmnc0GSPr4He9tFsSOd3kC6JZ2LTJnsNI1Gy7KhEsL_qXGBi-TWeolcUiwyprFVL_F7Rw4MOCe3zVh6XBzeCpdeiHumCgQOxPmz22WZTT2V1yeRFjKJAwA/s480/gradients1.jpg" alt="[Image: On the left, gradients of red, green, and blue; on the right, greyscale lines of seemingly unrelated brightness.]"/></a></p>

<p>My monitor uses 16-bit colours. There are &#34;only&#34; 65,536 different colours, so it&#39;s possible to go through all of them and see how each appears in the receiver. But it&#39;s not that simple; the bit-pattern of a HDMI pixel can actually get modified based on what came before it. And my radio isn&#39;t fast enough to even tell the bits apart anyway. What we could do is fill entire lines with one colour and average the received signal strength. We would then get a mapping for single-colour horizontal streaks (above). Assuming a long run of the same colour always produces the same bitstream, this could be good enough.</p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgO5yrhvrmVgWY1dt800HyVjAVnsiJYj2pbYfwLS45kGP3hB9BAfqqFYHQalZ7dkL8sztMslCKuAk91yIbe20DrVrKjGgIxWpBacpQ6PhYuG7Qj7BAqeitzSpTEIp5hZ062sr8KK5rMEAJcaRadvfomtelE9qSUTYy-OdDZsfuMapsWmYogOcC0p2P39Q/s1936/565.png"><img alt="" width="500" data-original-height="816" data-original-width="1936" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgO5yrhvrmVgWY1dt800HyVjAVnsiJYj2pbYfwLS45kGP3hB9BAfqqFYHQalZ7dkL8sztMslCKuAk91yIbe20DrVrKjGgIxWpBacpQ6PhYuG7Qj7BAqeitzSpTEIp5hZ062sr8KK5rMEAJcaRadvfomtelE9qSUTYy-OdDZsfuMapsWmYogOcC0p2P39Q/s500/565.png" srcset="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgO5yrhvrmVgWY1dt800HyVjAVnsiJYj2pbYfwLS45kGP3hB9BAfqqFYHQalZ7dkL8sztMslCKuAk91yIbe20DrVrKjGgIxWpBacpQ6PhYuG7Qj7BAqeitzSpTEIp5hZ062sr8KK5rMEAJcaRadvfomtelE9qSUTYy-OdDZsfuMapsWmYogOcC0p2P39Q/s1000/565.png 2x" alt="[Image: An XY plot where x goes from 0 to 65536 and Y from 0 to 1.2. A pattern seems to repeat itself every 256 values of x. Values from 16128 to 16384 are markedly higher.]"/></a></p>

<p>Here&#39;s the map of all the colours and their intensity in the radio receiver. (Whatever happens between 16,128 and 16,384? I don&#39;t know.)</p>

<p>Now, we can resample a greyscale image so that its pixels become short horizontal lines. Then, for every greyscale value find the closest matching RGB565 color in the above map. When we display this psychedelic hodge-podge of colour on the screen (on the right), enough of the above mapping seems to be preserved to produce a recognizable picture of a movie<a href="#KungFury">[3]</a> on the receiver side (on the left):</p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgqVgmnnJ63CKp_QK6jXBh2Bk0_Geg4Q1HyIsjmAVDsqckXYPgor6K-i6eS3w7EFBqUG8riRKO58_HtEawOZ8SayDR2ExvxH7_odJDyYO4TTZ_GejF6DlnbqpOlfIRZoiuF9lJWjtIa-Ibxv7RMLhRvqjHofnXgFLDHcK7l_bNFhkQBvGVX7pg9wzL-WA/s1200/hackermans.jpg"><img alt="" width="500" data-original-height="729" data-original-width="1200" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgqVgmnnJ63CKp_QK6jXBh2Bk0_Geg4Q1HyIsjmAVDsqckXYPgor6K-i6eS3w7EFBqUG8riRKO58_HtEawOZ8SayDR2ExvxH7_odJDyYO4TTZ_GejF6DlnbqpOlfIRZoiuF9lJWjtIa-Ibxv7RMLhRvqjHofnXgFLDHcK7l_bNFhkQBvGVX7pg9wzL-WA/s500/hackermans.jpg" alt="[Image: On the right, a monitor shows a noisy green and blue image. On the left, another monitor shows a grainy picture of a man and the text &#39;Hackerman&#39;.]"/></a></p>

<p>These colours are not constant in any way. If I move the antenna around, even if I turn it from vertical to horizontal, the greyscales will shift or even get inverted. If I tune the radio to another harmonic of the pixel clock frequency, the image seems to break down completely. (Are there more secrets to be unfolded in these variations?)</p>

<h3>The binary exfiltration protocol</h3>

<p>Now we should have enough information to be able to transmit bits. Maybe even big files and streaming data, depending on the bitrate we can achieve.</p>

<p>First of all, how should one bit be encoded? The absolute brightness will fluctuate depending on radio conditions. So I decided to encode bits as the brightness difference between two short horizontal lines. Positive difference means 1 and negative 0. This should stay fairly constant, unless the colours completely flip around that is.</p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgQ036DGW7I3bTtvUHyLhOKnRRI7x_4NJE_SVbM7UR5BOpzA1zggZkuX4X9iuxL1_hWmgQ45SibjU1yUxamIDsksiydE9KoHwQKSvRfc5koVN6UPB12OQJ0OWwQhb1Byzy2YiA4ojTBCElyE-so6nj7uYKftnRdoSxjhCvW_jqQTp0wWSSS_bZKciifxw/s1200/exprotocol.jpg"><img alt="" width="500" data-original-height="613" data-original-width="1200" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgQ036DGW7I3bTtvUHyLhOKnRRI7x_4NJE_SVbM7UR5BOpzA1zggZkuX4X9iuxL1_hWmgQ45SibjU1yUxamIDsksiydE9KoHwQKSvRfc5koVN6UPB12OQJ0OWwQhb1Byzy2YiA4ojTBCElyE-so6nj7uYKftnRdoSxjhCvW_jqQTp0wWSSS_bZKciifxw/s500/exprotocol.jpg" alt="[Image: When a bit is 0, the leftmost line is darker than the rightmost line, and vice versa. These lines are used to form 768-bit packets.]"/></a></p>

<p>The monitor has 768 pixels vertically. This is a nice number so I designed a packet that runs vertically across the display. (This proved to be a bad decision, as we will later see.) We can stack as many packets side-by-side as the monitor width allows. A new batch of packets can be displayed in each frame, or we can repeat them over multiple frames to improve reliability.</p>

<p>These packets should have some metadata, at least a sequence number. Our medium is also quite noisy, so we need some kind of forward error correction. I&#39;m using a Hamming(12,8) code which adds 4 error correction bits for every 8 bits of data. Finally, we need to add a CRC to each packet so we can make sure it arrived intact; I chose CRC16 with the polynomial <code>0x8005</code>.</p>

<h3>First results!</h3>

<p>It was quite unbelievable, I was able to transmit a looping 64 kbps audio stream almost without any glitches, with the monitor and the receiver in the same room approximately 2 meters from each other.</p>



<p>But can we get more? Slowly I added more samples per second, and a second audio channel. Suddenly we were at 256 kbps and still running smoothly. 200 kbps was even possible from the adjacent room, with a directional antenna 5 meters away, and with the door closed! In the same room, it worked up to around 512 kilobits per second but then hit a wall.</p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiVWff6eBNhzq5ilkn_CQ9jtwaioTzBniaOrssVlPVsFM8fyKMiFvZiQRgvzKZpmiNgVnCJMNd2OvRCP4RGr0SjtVtB-Kr1EAUVpqf2y0GPRZLTU0eBFZBMDgjZzIO5RnYB0EQA3vbZ3h6RbPsMR4yL3EMt7QPY797dHd2z5ggc_BhDTdXwqUpq7xRhZw/s500/500k.jpg"><img alt="" width="320" data-original-height="292" data-original-width="500" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiVWff6eBNhzq5ilkn_CQ9jtwaioTzBniaOrssVlPVsFM8fyKMiFvZiQRgvzKZpmiNgVnCJMNd2OvRCP4RGr0SjtVtB-Kr1EAUVpqf2y0GPRZLTU0eBFZBMDgjZzIO5RnYB0EQA3vbZ3h6RbPsMR4yL3EMt7QPY797dHd2z5ggc_BhDTdXwqUpq7xRhZw/s320/500k.jpg" alt="[Image: Info window that says HasPreamble: 1. Total: 928.5 kbps, Fresh: 853.6 kbps, Fresh (payload): 515.7 kbps.]"/></a></p>

<h3>A tearful performance</h3>

<p>The heavy error correction and framing adds around 60% of overhead, and we&#39;re left wit 480 bits of &#39;payload&#39; per packet. If we have 39 packets per frame at 60 frames per second we should get more than a megabit per second, right? But for some reason it always caps at half a megabit.</p>

<p>The reason revealed itself when I noticed every other frame was often completely discarded at the CRC check. Of course; I should have thought of properly synchronising the screen update to the graphics adapter&#39;s frame update cycle (or VSYNC). This would prevent the picture information changing mid-frame, also known as tearing. But whatever options I tried with the SDL library I couldn&#39;t get the Raspberry Pi 4 to not introduce tearing.</p>

<p>Screen tearing appears to be an unsolved problem plaguing the Raspberry Pi 4 specifically (see this <a href="https://www.google.com/search?q=raspi+4+tearing">Google search</a>). I tried another mini computer, the Asus Tinker Board R2.0, but I couldn&#39;t get the graphics drivers to work properly. I then realised it was a mistake to have the packets run from top to bottom; any horizontal tearing will cut every single packet in half! With a horizontal design only one packet per frame would suffer this fate.</p>

<h3>A new design enables video-over-video</h3>

<p>Packets that run horizontally across the screen indeed fix most of the packet loss. It may also help with CPU load as it improves memory access locality. I&#39;m now able to get 1000 kbps from the monitor! What could this be used for? A live video stream, perhaps?</p>

<p>At this point, time was running out. I had a <a href="https://disobey.fi/2023/profile/dont_mind_the_air_gap">presentation</a> coming up and I really wanted to show a video transfer demo. I quite literally got it working on the morning of the event. For simplicity, I chose MJPEG, even though other schemes could compress way more efficiently. The packet loss issues are mostly mitigated by repeating frames.</p>

<p>The data stream is &#34;hidden&#34; in a Windows desktop screenshot; I&#39;m changing the colours in a way that both creates a readable bit and also looks inconspicuous when you look from far away.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/iemOXp6bQXA?rel=0" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen=""></iframe>

<h3>Mitigations</h3>

<p>This was a fun project but this kind of a vulnerability could, in the tinfoiliest of situations, be used for exfiltrating information out of a supposedly airgapped computer.</p>

<p>The issue has been alleviated in some modern display protocols. DisplayPort<a href="#VESA2006">[4]</a> makes use of scrambling: a pseudorandom sequence of bits is mixed with the bitstream to remove the strong clock oscillations that are so easily radiated out. This also randomizes the bitstream-to-amplitude correlation. I haven&#39;t personally tested whether it still has some kind of video in their radio interference, though. (Edit: Scrambling seems to be optionally supported by later versions of HDMI, too – but it might depend on which features exactly the two devices negotiate. How could you know if it&#39;s turned on?)</p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiwU4DaZn87NEYfQkxI97gJex5Obh2ZmISUAeK01b1S5MhdQ-SU04ozJ1OJcba2jF80FSyyN4KJV2RuPo6D2lIfx-ow_VRu-RFV8UkEix8M67H46Kj8s556zVu2UMVNGWGlwCZBGk8iy6Y0EI96uXiSl_6Hfy3KiARTucPqe8-QWz3pvyuAgRRr9HlhtQ/s1200/impractical.jpg"><img alt="" width="400" data-original-height="885" data-original-width="1200" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiwU4DaZn87NEYfQkxI97gJex5Obh2ZmISUAeK01b1S5MhdQ-SU04ozJ1OJcba2jF80FSyyN4KJV2RuPo6D2lIfx-ow_VRu-RFV8UkEix8M67H46Kj8s556zVu2UMVNGWGlwCZBGk8iy6Y0EI96uXiSl_6Hfy3KiARTucPqe8-QWz3pvyuAgRRr9HlhtQ/s400/impractical.jpg" alt="[Image: A monitor completely wrapped in tinfoil, with the text IMPRACTICAL written over it.]"/></a></p>

<p>I&#39;ve also tried wrapping the monitor in tinfoil (very impractical) and inside a cage made out of chicken wire (it had no effect - perhaps I should have grounded it?). I can&#39;t recommend either of these.</p>

<h3>Software considerations</h3>

<p>This project was made possible by at least C++, Perl, SoX, ImageMagick, liquid-dsp, Dear Imgui, GLFW, turbojpeg, and v4l2! If you&#39;re a library that feels left out, please leave a comment.</p>

<p>If you wish to play around with video emanations, I heard there is a project called TempestSDR. For generic analog video decoding via a software radio, there is TVSharp.</p>

<h3>References</h3>
<ol>
  <li id="vanEck1985">Van Eck, Wim (1985): Electromagnetic radiation from video display units: An eavesdropping risk?</li>
  <li id="Kuhn2004">Kuhn, Markus (2004): Electromagnetic Eavesdropping Risks of Flat-Panel Displays</li>
  <li id="KungFury"><a href="https://www.youtube.com/watch?v=bS5P_LAqiVg">KUNG FURY Official Movie [HD]</a> (2015)</li>
  <li id="VESA2006">Video Electronics Standards Association (2006): DisplayPort Standard, version 1.</li>
</ol>

</div></div>
  </body>
</html>
