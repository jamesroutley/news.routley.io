<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/file-management-tools-linux-shell/">Original</a>
    <h1>File Management Tools for Your Favorite Shell</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/removing_home.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/removing_home.jpg" alt="File management systems for Linux are powerful"/></picture><p>Going around your files and directories using the shell can feel slow and confusing, and not only when you’re a beginner. Personally, I was using GUIs (Graphical User Interfaces) to display, rename, move, and delete my files for a long time. It took me a couple of years to really get used to the shell to perform these operations. Today, I only use the shell to manage my files, and I think it is the better way.</p><p>It doesn’t mean that GUIs are useless, but, even if they could feel optimal for files and directories management, they’re not as effective as the CLIs (Command-Line Interfaces) and TUIs (Terminal User Interfaces). If you follow this blog for long enough, you know that I love <a href="https://thevaluable.dev/mouseless-development-environment/" target="_blank" rel="noopener">Mouseless environments</a> centered around the shell, and for good reasons.</p><p>This article exists because of an email I received from a reader, wondering if there were some tips and tools to make the file management experience in the shell more effective and user-friendly. The short answer: there are such tools, and that’s exactly what we’ll explore in this article. More precisely, we’ll look at:</p><ul><li>The basic CLIs to manage files and directories, as well as some tips to manage them more easily.</li><li>Other minimal tools complementing the basic ones we’ve seen previously.</li><li>We’ll look at some interesting TUIs to make your filesystem more visual, similar to GUIs, but inside the shell.</li><li>We’ll finally look at different ways to bookmark your favorite directories to access them as quickly as possible.</li></ul><p>We’ll only look to the tools aiming to help you manage your filesystem, nothing for reading or writing your files directly. Also, this article is only about tools available for Unix or Linux-based system.</p><p>Last warning: this article expects you to know some basics about the Unix/Linux shell. If you don’t, I encourage you to <a href="https://themouseless.dev" target="_blank" rel="noopener">read my book</a> ‘cause it’s the best book on Earth (obviously), even better than The Little Prince. I swear. With that, you’ll learn a lot about Linux, its shell, and bad humor.</p><p>Are you ready to improve your experience of managing your precious files and directories? Let’s go, then!</p><h2 id="the-basics-of-file-management-in-the-shell">The Basics of File Management in the Shell</h2><p>Let’s first look quickly at the tools you’re likely to already have on your system. I’ll always reference the GNU tools here, so if you run macOS, I definitely recommend you to use them, instead of the inferior BSD alternatives.</p><h3 id="common-tools">Common Tools</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/basic_tools.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/basic_tools.jpg" alt="The basic tools to know to manage files from your shell"/></picture><p>If you have any experience with a shell, I’m pretty sure you know already these tools. To me, they are the basic ones you can use to manage your filesystem. Like many, I use them every day.</p><p>If you wonder what the “working directory” is, it’s the current directory you’re in.</p><table><tbody><tr><th>Command</th><th>Description</th><th>Interesting options</th></tr><tr><td><code>cd</code></td><td>Move to a different directory (change your working directory).</td><td>_</td></tr><tr><td><code>pwd</code></td><td>Print your working directory.</td><td>_</td></tr><tr><td><code>ls</code></td><td>List the files and directories of your working directory.</td><td><code>-l</code> (long listing format) | <code>-h</code> (human-readable) | <code>-a</code> (display hidden files)</td></tr><tr><td><code>cp</code></td><td>Copy files.</td><td><code>-r</code> (recursive - to copy directories) | <code>-i</code> (interactive - prompt before overwriting)</td></tr><tr><td><code>mv</code></td><td>Move files and directories.</td><td><code>-i</code> (interactive - prompt before overwriting)</td></tr><tr><td><code>touch</code></td><td>Create a file if it doesn’t exist, only “touch” it if it does (change its access time stamp).</td><td>_</td></tr><tr><td><code>mkdir</code></td><td>Create directory(ies).</td><td><code>-p</code> (parents - also create parents, no error thrown if the directory you try to create already exists)</td></tr><tr><td><code>rm</code></td><td>Delete files.</td><td><code>-r</code> (recursive - to delete directories) | <code>-i</code> (interactive - prompt before removing)</td></tr><tr><td><code>rmdir</code></td><td>Remove empty directories.</td><td>_</td></tr></tbody></table><h3 id="documentation">Documentation</h3><p>If you don’t know these commands, or if you don’t know how to use them, you can look at their official (and less official) documentation.</p><ol><li>For most of these tools, you can use the options <code>--help</code> or <code>-h</code> directly in your shell, like <code>mkdir --help</code> for example, to get a quick idea how to use them.</li><li>For (way) more information, you can look at their respective man page ; for example, run <code>man cd</code> or <code>man mv</code> in your shell.</li><li>You can install something like <a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">tldr</a> to get some useful examples. It’s more beginner-friendly than the good (but crowded) man pages.</li></ol><p>You can also search how to use these tools on The Great Internet™ directly (you know, by using Bing). But you have big chances to get swamped in basic (and somewhat useless) information. Good documentation always top stack overflow.</p><h3 id="best-practices">Best Practices</h3><p>Here’s a couple of best practices to name your files and directories. They will help you greatly to manage your file and directory names on Unix and Linux-based filesystems:</p><ul><li>Avoid spaces at all costs. It’s allowed, but you’ll need to escape them each time you want to use the paths of your files. If you want a space in your file (or directory) name, use an underscore (<code>_</code>) instead.</li><li>Avoid uppercase. The reason: macOS filesystem will ignore them, but Linux won’t. If a couple of people use both OS and work on the same files, it will create problems. Been there, done that.</li><li>You can use underscore and hyphens, but avoid other special characters.</li></ul><p>This has nothing official, but believe me, it will make your file and directory management easier.</p><h3 id="the-shell-chainsaw">The Shell Chainsaw</h3><p>One of the major problem novices and experts alike will painfully stumble upon when managing files and directories using the shell: the CLIs we saw above are powerful tools; maybe a bit too much. If you run <code>rm</code> on multiple file (for example <code>rm file1 file2 file3</code>) all your files will be removed forever, without any prompt or warning.</p><p>Tools like <code>cp</code> and <code>mv</code> can be dangerous too: they will overwrite files with the same names without any warning. But fear not! These three tools have a useful option to avoid using a chainsaw (and cut your arm) when you need a simple axe: <code>-i</code>, for interactive.</p><p>For example, if you run <code>rm -i file1 file2 file3</code>, you’ll need to confirm that, indeed, you want to remove every single file. It adds another level of security, in case you wanted to delete a simple file and you end up trying to delete your home directory. Been there, done that; lesson learned. That’s why I like to use the three tools mentioned above with the option <code>-i</code> by default.</p><p>If you want to do the same, simply create these three aliases in your favorite shell:</p><div><pre><code data-lang="bash"><span>alias</span> <span>cp</span><span>=</span><span>&#39;cp -i -v&#39;</span>
<span>alias</span> <span>mv</span><span>=</span><span>&#39;mv -i -v&#39;</span>
<span>alias</span> <span>rm</span><span>=</span><span>&#39;rm -i -v&#39;</span>
</code></pre></div><p>I also added the verbose option <code>-v</code> to display what’s going on.</p><p>These aliases will directly replace the basic tools, always applying the two options <code>-i</code> and <code>-v</code>. If you don’t want to apply them and use the raw tool, you can add a backslash <code>\</code> before its name.</p><p>For example, even if you’ve aliased <code>rm</code> as above, running <code>\rm</code> will bypass your alias and run the CLI without any option. Thanks to this trick, you can easily create other aliases if you think that some CLIs would be better if they would always use some options by default. For example, <code>ls</code> could be aliased to <code>ls -lah</code>.</p><p>Another good practice which might save your life: when you try to delete a directory, don’t use the all too common <code>rm -rf</code>. The <code>-f</code> option will force removing everything, which is rarely a good idea. First, try something like <code>rm -r</code>. Be gentle. Don’t force things. This might save your life; it saved mine multiple times.</p><p>What I call “minimal tools” are CLIs respecting more or less the Unix philosophy: each program must do one thing well. Of course, this “one thing” can include a lot of things (it depends on how you define the “thing”), so keep in mind that it’s a subjective concept. That’s great, because, let’s face it, this whole article is subjective anyway. Let’s dive deep even more into my subjectivity!</p><h3 id="whats-better-than-a-tree">What’s Better Than a tree?</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/tree.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/tree.jpg" alt="The CLI tree is very useful to visualize your filetree"/></picture><p>The CLI ls is great to display files and directories, but it’s not possible to display multiple layers of the filesystem in a friendly manner.</p><p>Many applications meant to manage your filesystem represent it as a tree. It’s a common and practical way to visualize your data. That’s exactly what the CLI tree can do: it will display every file, directory, and sub-directories recursively. The root of the tree will be the current working directory by default, or any other directory if you give it as argument.</p><p>This tool has many interesting options, like <code>-d</code> to only display the directories, for example.</p><h3 id="when-you-search-you-must-find">When You Search, You Must find</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/find.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/find.jpg" alt="The CLI find is great to find recursively anything you want in your filesystem"/></picture><p>There is an essential functionality missing for managing our files: a way to search files or directories. This is the purpose of the CLI find; it’s a bit more complex to use than the other tools we’ve seen until now, but it’s also very powerful.</p><p>For example, to find the file named <code>file1</code> in the directory <code>dir1</code> recursively (find will also search in the subdirectories), you can run the following:</p><p>If there is no directory name given (for example <code>find -name file1</code>), find will search by default in the current working directory and all its subdirectories.</p><p>The expression <code>-name</code> is one filter among many you can use. For example, if you want to match the path of a file (or directory) instead of its name, you can use <code>-path</code>.</p><p>To learn more about find and the crazy amount of stuff you can do with it, I’ve written <a href="https://themouseless.dev/posts/find-guide-example-mouseless/" target="_blank" rel="noopener">another article about it</a>.</p><h3 id="fuzzy-find-with-fzf">Fuzzy Find with fzf</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/fzf.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/fzf.jpg" alt="The CLI fzf can be a versatile file manager on its own!"/></picture><p>The <a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">CLI fzf</a> is the crown jewel of my shell experience. And not only for file management. In that area, it can be interfaced with your shell and bring two useful keyboard shortcuts to find whatever files or directory you want. If you use Bash, Zsh, or even Fish, you’ll have access to these two keystrokes:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>CTRL-t</code></td><td>Fuzzy search any file in the current working directory and subdirectories.</td></tr><tr><td><code>ALT-c</code></td><td>Fuzzy search any directory in the current working directory and subdirectories.</td></tr></tbody></table><p>Fuzzy searching is a bit more easy to use than regex pattern, because you’ll try to match strings approximately. It’s a powerful tool; if you want to know more about it, I’ve made a <a href="https://www.youtube.com/watch?v=FvNFxx3Z9qI&amp;t=2s" target="_blank" rel="noopener">couple of videos</a> explaining its shattering power. This tool is so godlike, you can come with your own, customized file management tool with a minimum of configuration. You’re in luck: that’s exactly what I explain in my videos!</p><p>And no, I never exaggerate anything.</p><h3 id="file-management-in-your-editor">File Management in Your Editor</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/vidir.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/vidir.jpg" alt="The CLI vidir is a simple but powerful way to copy, move, and rename your files in bulk."/></picture><p>The tools <code>cp</code>, <code>rm</code>, and <code>mv</code> are great to copy, remove, and move (or rename) files, but it’s difficult to use them for doing these operations on a large amount of files or directories. You can use some globing, sure, at least for deleting, moving, and copying stuff. Even so, for the last two, you’ll need to find a way to create effectively the paths you want to copy or move to. And what about renaming?</p><p>It’s where <a href="https://man.archlinux.org/man/community/moreutils/vidir.1.en" target="_blank" rel="noopener">vidir</a> shines: to do bulk operations on your precious files. In practice, you modify a list of files and directory paths, directly in your favorite shell editor. The modifications will then become a reality in your filesystem.</p><p>By default, vidir will pick the editor set up to the environment variable <code>$EDITOR</code> or, if it’s not set, <code>$VISUAL</code>. Of course, in my opinion, <a href="https://thevaluable.dev/phpstorm-vs-vim/">it should be Vim</a>. But it’s only my opinion.</p><p>Again, <a href="https://www.youtube.com/watch?v=QJSer-VDY_8" target="_blank" rel="noopener">I’ve done a video about vidir</a> so I won’t speak about it in details here. Using it without any argument will allow you to modify the paths of all the files and directories of your current working directory (but not recursively in the subdirectories). You can also pass a list of files you want to rename, move, or delete, by passing all the file paths to the tool, using the good old pipe. For example:</p><p>You’ll then be able to delete, move, and rename all the files, directories, and subdirectories of <code>dir1</code> using vidir. If you use Vim, you’ll have access to the whole <a href="https://thevaluable.dev/vim-search-find-replace/">search and replace</a> tools to do so. I love it, and I use it all the time.</p><h3 id="the-venerable-tmux">The Venerable tmux</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/tmux.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/tmux.jpg" alt="tmux is a more complex but very powerful TUI."/></picture><p>Alright, <a href="https://github.com/tmux/tmux/wiki" target="_blank" rel="noopener">tmux</a> is not the best example when it comes to the famous Unix philosophy: you can do a lot of unrelated stuff with it. That said, regarding file management, it allows you to have multiple shell in one window of your terminal. It’s convenient if you want to access to multiple paths in your filesystem at once.</p><p>To use the different shells’ working directories from one pane to another, I like to use the tmux plugin <a href="https://github.com/laktak/extrakto" target="_blank" rel="noopener">extrakto</a>. With it, it’s very easy to copy and paste whatever info from one tmux pane to another, including file or directory paths.</p><p>I’ve already <a href="https://thevaluable.dev/tmux-config-mouseless/">covered tmux at length</a> in another article. You’ll find many tips in there.</p><h2 id="visualize-your-filesystem-with-tuis">Visualize Your Filesystem with TUIs</h2><p>We’ve only seen, until now, CLIs with a simple (and for some, austere) textual interface. Terminal User Interfaces (TUI) is somehow between the GUI and the CLI: it’s more visual than a pure textual interface, it runs in the terminal, and, like CLIs, it often offers good keystrokes to be manageable only with a keyboard.</p><p>Being able to visualize part of your filetree can help you when you want to navigate, copy, or move files. Personally, that’s exactly what prevented me, for years, to only use CLIs for managing my files and directories. That said, I discovered that this inconvenience was more a question of habit than a lack of efficiency. To me, using a TUI (or a full-blown GUI) is not necessary when using all the tools I’ve described earlier together.</p><p>That said, I also know that transitioning between GUIs to CLIs can be difficult. That’s why TUIs are great to smoothly transition from the world of graphical interfaces to the magical shell world.</p><h3 id="vim-with-netrw">Vim with netrw</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/vim_netrw.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/vim_netrw.jpg" alt="Vim coupled with netrw can be very powerful in its own rights."/></picture><p>Vim comes often by default with a file manager called netrw. With this tool, you can create, rename, move, delete files and directories quite easily. If you already use Vim, you might want to look at it.</p><p>Again, I won’t describe netrw in details here because <a href="https://thevaluable.dev/vim-browsing-remote-netrw/">I already did it in another article</a>.</p><h3 id="vifm">vifm</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/vifm.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/vifm.jpg" alt="Vim coupled with netrw can be very powerful in its own rights."/></picture><p>The tool <a href="https://vifm.info/" target="_blank" rel="noopener">vifm</a> is one of my favorite TUI to manage files. It tries to use Vim keystrokes to manage files and directories; it is similar to vidir at time, coupled with a powerful way to navigate through your filesystem. Don’t be mistaken, however: vifm can do way more than vidir, but it’s also more complex to use.</p><p>Here are some basic shortcuts to help you begin with this great TUI:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>j</code></td><td>Move to the next item in the current directory.</td></tr><tr><td><code>k</code></td><td>Move to the previous item in the current directory.</td></tr><tr><td><code>h</code></td><td>Move up to the directory tree (parent directory).</td></tr><tr><td><code>l</code></td><td>Move down to the directory tree (child directory).</td></tr><tr><td><code>TAB</code></td><td>Switch pane.</td></tr><tr><td><code>t</code></td><td>Select a file or directory. <code>ESC</code> to unselect.</td></tr><tr><td><code>cw</code></td><td>Rename (<code>c</code>hange <code>w</code>ord) the file under the cursor, or the selected ones.</td></tr><tr><td><code>dd</code></td><td>Delete the file under the cursor, or the selected ones.</td></tr><tr><td><code>y</code></td><td>Yank (copy) the file under the cursor, or the selected ones.</td></tr><tr><td><code>p</code></td><td>Copy the yanked files to the current directory.</td></tr><tr><td><code>P</code></td><td>Move the yanked files to the current directory.</td></tr><tr><td><code>v</code></td><td>Switch to visual mode (another way to select files and directories). <code>ENTER</code> to validate, <code>ESC</code> to cancel.</td></tr></tbody></table><p>You can also run some commands in vifm. To switch to the COMMAND-LINE mode, you need, like in Vim, to hit the colon <code>:</code> key, and then type your command.</p><table><tbody><tr><th>Command</th><th>Description</th></tr><tr><td><code>:mkdir &lt;dir&gt;</code></td><td>Create the directory <code>&lt;dir&gt;</code>.</td></tr><tr><td><code>:touch &lt;file&gt;</code></td><td>Create the file <code>&lt;file&gt;</code>.</td></tr><tr><td><code>:quit</code></td><td>Quit vifm.</td></tr></tbody></table><h3 id="ranger">Ranger</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/ranger.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/ranger.jpg" alt="Ranger is another vi-inspired file manager which can display images and highly customizable."/></picture><p><a href="https://github.com/ranger/ranger" target="_blank" rel="noopener">Ranger</a> is an older TUI to manage your files and directories. Like many others, it’s highly customizable. It can display three levels of your filesystem at once: the parents, siblings, and children of the current working directory. It can also display a preview of the file under the cursor by default,</p><p>If you want to try Ranger, here are some basic keystrokes you can use:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>?</code></td><td>Open the manual. You can then choose to see the list of keystrokes, commands, or settings.</td></tr><tr><td><code>j</code></td><td>Move to the next item in the current directory.</td></tr><tr><td><code>k</code></td><td>Move to the previous item in current directory.</td></tr><tr><td><code>h</code></td><td>Move up to the directory tree (parent directory).</td></tr><tr><td><code>l</code></td><td>Move down to the directory tree (child directory).</td></tr><tr><td><code>yy</code></td><td>Yank the selection.</td></tr><tr><td><code>dd</code></td><td>Cut the selection.</td></tr><tr><td><code>pp</code></td><td>Paste what was yanked or cut. Nothing will be overwritten but renamed.</td></tr></tbody></table><p>Like vifm, there is also a COMMAND-LINE mode in Ranger. You can switch to it by pressing the colon <code>:</code> key:</p><table><tbody><tr><th>Command</th><th>Description</th></tr><tr><td><code>:rename &lt;newname&gt;</code></td><td>Rename the current file to <code>&lt;newname&gt;</code>.</td></tr><tr><td><code>:mkdir &lt;dir&gt;</code></td><td>Create the directory <code>&lt;dir&gt;</code>.</td></tr><tr><td><code>:touch &lt;file&gt;</code></td><td>Create the file <code>&lt;file&gt;</code>.</td></tr><tr><td><code>:quit</code></td><td>Quit vifm.</td></tr></tbody></table><p>I find ranger more complicated to handle and customize than vifm, even if I spent more time with ranger. Nowadays, I don’t use it anymore.</p><h3 id="nnn">nnn</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/nnn.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/nnn.jpg" alt="nnn is a very simple file manager supporting 4 different contexts."/></picture><p>The tool <a href="https://github.com/jarun/nnn" target="_blank" rel="noopener">nnn</a> is another simple TUI to manage your filesystem. When you open it, you’ll have only one pane this time (contrary to vifm and Ranger), but you can switch between 4 different contexts. Think of a context as a precise location in your filesystem, with whatever else you’ve done in there (like filtering the list of files and directories). At the beginning, only one context is open; you can use the keys from <code>2</code> to <code>4</code> to open new ones (or using <code>TAB</code> or <code>SHIFT-TAB</code>). When you open a new context, it will be the copy of the previous one.</p><p>Each context can point to a different location in your filesystem. On top of the context, you have the session, which can save your contexts to be used later.</p><p>Mostly, nnn use the usual shell tools we’ve seen at the beginning of this article to perform the usual operations: copy, delete, and so on.</p><p>As always, here are some keystrokes which will help you experiment with nnn:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>?</code></td><td>Show the list of keybinding.</td></tr><tr><td><code>j</code></td><td>Move to the next item in the current directory.</td></tr><tr><td><code>k</code></td><td>Move to the previous item in the current directory.</td></tr><tr><td><code>h</code></td><td>Move up to the directory tree (parent directory).</td></tr><tr><td><code>l</code></td><td>Move down to the directory tree (child directory).</td></tr><tr><td><code>CTRL-R</code></td><td>Rename the file under the cursor.</td></tr><tr><td><code>SPACE</code></td><td>Select the file under the cursor.</td></tr><tr><td><code>p</code></td><td>Copy the selected files in the current directory.</td></tr><tr><td><code>v</code></td><td>Move the selected files in the current directory</td></tr><tr><td><code>x</code></td><td>Delete the selection.</td></tr><tr><td><code>]</code></td><td>Launch the command prompt. You can use your usual shell commands (like touch or mkdir) to create whatever you want.</td></tr><tr><td><code>!</code></td><td>Launch a shell process, child of nnn. To come back to nnn, simply close the shell.</td></tr><tr><td><code>1</code> to <code>4</code></td><td>Change the current context.</td></tr><tr><td><code>q</code></td><td>Quit the current context. Quit all the context to quit nnn.</td></tr><tr><td><code>Q</code></td><td>Quit all open contexts.</td></tr></tbody></table><p>You can also use interesting options when launching nnn from your shell:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>-d</code></td><td>Display more details for files and directories.</td></tr><tr><td><code>-e</code></td><td>Open text files using the <code>$EDITOR</code> or <code>$VISUAL</code> environment variable.</td></tr><tr><td><code>-S</code></td><td>Persistent session: closing and reopening nnn with this option will bring back all your contexts.</td></tr></tbody></table><p>This tool has many other interesting functionalities, like <em>cd on quit</em>, to quickly change your shell working directory using nnn. The tool has also a couple of interesting plugins you can install to increase its might.</p><h3 id="rover">Rover</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/rover.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/rover.jpg" alt="Rover is great to navigate more easily without using cd all the time."/></picture><p>If you want a lightweight tool to navigate through your files and directory visually, <a href="https://github.com/lecram/rover" target="_blank" rel="noopener">Rover</a> is the TUI you need. You can use the usual keybinding almost every other TUI uses (<code>h</code>,<code>j</code>,<code>k</code>,<code>l</code>,<code>/</code>…) to navigate quickly through your files. When you quit the TUI (or press <code>ENTER</code>), you’ll come back victorious in your favorite shell and, more importantly, in the directory you’ve navigated into using Rover.</p><p>Here are many keystrokes to help you begin with Rover. As I said, it’s a simple tool, so it covers almost everything:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>?</code></td><td>Show Rover’s manual.</td></tr><tr><td><code>j</code></td><td>Move the cursor down (uppercase: down 10 lines).</td></tr><tr><td><code>k</code></td><td>Move the cursor up (uppercase: up 10 lines).</td></tr><tr><td><code>g</code></td><td>Move the cursor to the top of the listing.</td></tr><tr><td><code>G</code></td><td>Move the cursor to the bottom of the listing.</td></tr><tr><td><code>l</code></td><td>Enter the selected directory.</td></tr><tr><td><code>h</code></td><td>Move to the parent directory.</td></tr><tr><td><code>H</code></td><td>Move to the <code>$HOME</code> directory.</td></tr><tr><td><code>0-9</code></td><td>Change tab.</td></tr><tr><td><code>RETURN</code></td><td>Open the <code>$SHELL</code> on the current directory.</td></tr><tr><td><code>SPACE</code></td><td>Open the <code>$PAGER</code> with the selected file.</td></tr><tr><td><code>e</code></td><td>Open <code>$VISUAL</code> or <code>$EDITOR</code> with the selected file.</td></tr><tr><td><code>/</code></td><td>Start incremental search (RETURN to finish).</td></tr><tr><td><code>n</code></td><td>create new file.</td></tr><tr><td><code>N</code></td><td>Create new directory.</td></tr><tr><td><code>R</code></td><td>Rename selected file or directory.</td></tr><tr><td><code>D</code></td><td>Delete selected file or (empty) directory.</td></tr><tr><td><code>m</code></td><td>Toggle mark on the selected entry.</td></tr><tr><td><code>M</code></td><td>Toggle mark on all visible entries.</td></tr><tr><td><code>a</code></td><td>Mark all visible entries.</td></tr><tr><td><code>X</code></td><td>Delete all marked entries.</td></tr><tr><td><code>C</code></td><td>Copy all marked entries.</td></tr><tr><td><code>V</code></td><td>Move all marked entries.</td></tr><tr><td><code>q</code></td><td>Quit Rover.</td></tr></tbody></table><p>I never heard of it before writing this article, but I really like its simplicity. It pushed me, with a lot of emotions, to say goodbye to vifm.</p><h3 id="gnu-midnight-commander">GNU Midnight Commander</h3><picture>
<source srcset="https://thevaluable.dev/images/2022/file_management_terminal/midnight_command.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/file_management_terminal/midnight_command.jpg" alt="midnight_command is great to navigate more easily without using cd all the time."/></picture><p>We quit the realm of Vi-inspired file managers with the venerable GNU Midnight Command. This is the grandparent of many other TUIs out there; this fact will jump to your face as soon as you launch it. This tool looks more like a file manager from the MS-DOS era, where you have a good mouse support, and the usual menu on top of the application.</p><p>I never used it seriously (I don’t have any nostalgia for the MS-DOS era, especially when I was struggling to run my games on there), but I include it in case you’d like something a bit different.</p><h2 id="bookmark-file-managers">Bookmark File Managers</h2><p>There is another category of CLIs which could help you manage your precious files and directories: bookmark managers.</p><h3 id="z">z</h3><p>The CLI <a href="https://github.com/rupa/z" target="_blank" rel="noopener">z</a> tracks the directories you’re using the most often (the most “frecent” directory), and allows you to jump to them easily. For example, if you run <code>z dir1 dir2</code>, you’ll move to a “frecent” directory matching both regex <code>dir1</code> and <code>dir2</code>.</p><p>You can also use a couple of options with z:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>-c</code></td><td>Restrict the matches to the subdirectories of the current directory.</td></tr><tr><td><code>-e</code></td><td>Don’t move anywhere, just output the best match.</td></tr><tr><td><code>-l</code></td><td>Only list all directories matching the regex(es).</td></tr><tr><td><code>-r</code></td><td>Match by rank only.</td></tr><tr><td><code>-t</code></td><td>Match by recent access.</td></tr><tr><td><code>-x</code></td><td>Remove the current directory from the datafile.</td></tr></tbody></table><h3 id="bashmarks">Bashmarks</h3><p><a href="https://github.com/huyng/bashmarks" target="_blank" rel="noopener">Bashmarks</a> is a simple bash script allowing you to create bookmarks and access them easily. You can also display your bookmarks and delete them; that’s basically all.</p><p>Simple and potentially useful.</p><h3 id="bm">bm</h3><p>The tool <a href="https://github.com/fezcode/bm" target="_blank" rel="noopener">bm</a> is similar to z, except that it doesn’t automate anything. You need to actively add bookmarks, list them, and choose whatever directory you want to navigate to. Like Bashmarks, it’s a very simple tool.</p><h2 id="master-of-your-filesystem">Master of Your Filesystem</h2><p>There are many others tools to manage your filesystem. For example, I also use <a href="https://github.com/Tarrasch/zsh-bd" target="_blank" rel="noopener">bd</a> with Zsh to come back easily to parent directories which are multiple levels up. I also use the directory stack or the shell history quite heavily. You’ll find these tips (and many more) in <a href="https://thevaluable.dev/zsh-install-configure-mouseless/">this article about Zsh</a>.</p><p>What did we see in this article?</p><ul><li>We took a quick look at the most comment CLIs to manage files and directories in the shell, like rm, cd, touch, or mkdir for example.</li><li>Looking at the documentation of your CLIs and TUIs is the best way to harness their power.</li><li>Following some best practices to name your files and directories on a Unix or Linux-based system is essential. No spaces, no uppercase, no special characters (except underscores and hyphens).</li><li>There are many other CLIs to help you manage your files: for example tree, fzf, vidir, tmux…</li><li>If you come from the GUI world, using TUIs can help you transition from your desktop interface to the shell more easily.</li><li>There are many good TUIs out there to manage your files and directories: vifm, ranger, Rover, nnn…</li><li>You can also use bookmarks to access easily specific nodes of your filetree.</li></ul><p>Don’t be fooled: it’s not because a tool doesn’t look user-friendly that it’s less comfortable (or efficient) to use. Keep your mind open, try, and experiment enough to find the good shoes for your specific feet.</p></section></article></div></div>
  </body>
</html>
