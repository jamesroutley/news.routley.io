<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://macwright.com/2022/03/04/browsers-and-files.html">Original</a>
    <h1>Using files with browsers, in reality</h1>
    
    <div id="readability-page-1" class="page"><div><p>This is a post about new APIs that browsers have to read &amp; write files, and how I’m using them in Placemark.</p><h3 id="files">Files</h3><p>The meaning and importance of the <em>file</em> has shifted a lot in the last decade. The Verge wrote about how <a href="https://www.theverge.com/22684730/students-file-folder-directory-structure-education-gen-z">students today don’t have a grasp</a> on how files and folders work - or they have a very good understanding of the norms of storing information in the cloud, but not on their local computers. The web contains all sorts of things that we never think of or use as files: is your email an <a href="https://en.wikipedia.org/wiki/Mbox">Mbox file</a>? Do you ever directly use the <a href="https://en.wikipedia.org/wiki/High_Efficiency_Image_File_Format">HEIC files</a> that are the native format of Apple Photos? Or consider any rich text on the internet, like a Notion page - does it have a defined file type and an option to download? And think of the mobile web. You can download a file from mobile Safari, but do you?</p><p>So files are a changing medium. New programs that use files, like <a href="https://obsidian.md/">Obsidian</a>, include that fact in their taglines because it’s so unusual. The default is a notetaking application that stores opaque formats in the cloud, not one that stores text files on your computer.</p><p>But nevertheless, some applications continue to consider files. Mine, <a href="https://placemark.io/">Placemark, a map editor</a>, is one of them. The world of maps has lots of nice, well-defined file formats, and Placemark reads and writes many of them.</p><h3 id="the-status-quo">The status quo</h3><p>Reading &amp; writing files from a web browser has been always been inconvenient and hacky.</p><p>You could read a file by creating a hidden <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file">file input</a> and triggering a click event, or by encouraging your users to <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop">drag &amp; drop</a> files onto the page. Neither is very convenient: the web’s drag &amp; drop APIs are derived from ad-hoc implementations in Internet Explorer, and creating hidden input elements in order to read a file is a hack.</p><p>You could then write a file using an abstraction like <a href="https://github.com/eligrey/FileSaver.js/">fileSaver</a>, which behind the scenes would create hidden link elements and trigger click elements on them, use an Internet Explorer-only API, or open a popup window with the file as the contents.</p><p>So the existing approaches for working with files on the web are bad, and rely on hacks like creating hidden elements. They’re also limited.</p><p>Let’s say you’re building a graphics editor and someone can save their work as <code>file.svg</code>. If this were a desktop application, they could press <strong>⌘s</strong> to save again. Or you might even auto-save to the file. You can’t do this on the web: every time you save a file, it’ll go through the same “Save as…” workflow, which asks you to choose a location and confirms if you overwrite an existing file.</p><h3 id="the-future">The future</h3><p>The future comes in the form of the <a href="https://wicg.github.io/file-system-access/">File System Access</a> API, which is part of Google’s overall mission - <a href="https://www.chromium.org/teams/web-capabilities-fugu/">Fugu</a> - to bring more desktop application capabilities to the web. This is <em>bleeding edge stuff</em>. There are very few applications that use it - <a href="https://excalidraw.com/">Excalidraw</a> is the canonical example.</p><p><img alt="caniuse for the file access api" src="https://macwright.com/images/2022-03-04-browsers-and-files-caniuse-for-the-file-access-api.png"/></p><figcaption><a href="https://caniuse.com/native-filesystem-api">Caniuse data for the Native FileSystem API</a></figcaption><p>Because so few browsers support this API, you’re nearly required to use a polyfill or abstraction over the API. I’m using <a href="https://github.com/GoogleChromeLabs/browser-fs-access">browser-fs-access</a>, a Google project. When it detects and incompatible browser, it falls back to the old ways, creating hidden inputs and simulating click elements on them in order to open and save files.</p><p>But, when you use Placemark with a compatible browser, you can hit <strong>⌘s</strong> to save a file, the browser asks whether it’s okay to save back to your computer, and after that point you can save at any time you want.</p><p><img alt="Placemark confirming local file access" src="https://macwright.com/images/2022-03-04-browsers-and-files-placemark-confirming-local-file-access.png"/></p><p>It’s really quite spectacular, and if the native filesystem API expands to cover more usecases - like if you can grant semi-permanent access to a folder - then web applications can also be <a href="https://www.inkandswitch.com/local-first/">local-first applications</a>: you can own your data, in spite of the cloud. And you can do that with just Chrome, or your preferred browser.</p><h3 id="the-bad">The bad</h3><p>Unfortunately, that’s not the end of it. A few weeks ago, I posted this bug to Twitter.</p><blockquote><p dir="ltr" lang="en">okay, this was the bug i ran into yesterday (this example from <a href="https://t.co/KcjaxJaKUi">https://t.co/KcjaxJaKUi</a> - there&#39;s a bug in this code. i think it&#39;s a 9/10 difficulty bug. see if you can find it: what goes wrong and why. <a href="https://t.co/3hqMBoNhPI">pic.twitter.com/3hqMBoNhPI</a></p>— Tom MacWright (@tmcw) <a href="https://twitter.com/tmcw/status/1481649674708676608?ref_src=twsrc%5Etfw">January 13, 2022</a></blockquote><p>Spot the bug? You can read the thread, or get the tl;dr version:</p><ul><li>Certain event data is cleared once “event propagation” ends, and that includes the <code>e.dataTransfer.items</code> value here.</li><li>By using an <code>await</code> and making this event listener an asynchronous function, this <code>for</code> loop will process one <code>item</code>, then process the next item on the next ‘tick’, which will be after event propagation ends.</li><li>Hence, if you try and drop multiple items, only the first will be read.</li></ul><p>The moral of the story isn’t anything. It’s that web APIs fit together in awkward ways that make it easy to write bugs. So easy, in fact, that Google’s documentation and the specification itself contained this bug in example code. This filesystem topic combines everything - async code, decades-old browser behaviors, differing conventions.</p><p>There are, unfortunately, a lot of examples of this sort of issue in the world of file reading.</p><p>Look at the <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileEntry/file">FileSystemEntry.file</a> method:</p><div><div><pre><code>FileSystemFileEntry.file(successCallback[, errorCallback]);
</code></pre></div></div><p>The method returns undefined, can calls one of two callbacks. This method could have returned a Promise. Or it could have used a Node-js style <a href="http://fredkschott.com/post/2014/03/understanding-error-first-callbacks-in-node-js/">error-first callback</a>. It does neither: why? Even the specification <a href="https://wicg.github.io/entries-api/#dom-filesystemfileentry-file">includes an example of how to adapt this into a Promise</a>.</p><p>Oh, and notice that this is an asynchronous API. The File System API is filled with them - asynchronous ways to get files, handles, to traverse directories. Remember that first bug in the paragraph above, about how if you call asynchronous APIs in the wrong place in an event listener, the data you’re dealing with disappears, like a racoon trying to wash candy cotton in a stream?</p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0" height="320" src="https://www.youtube-nocookie.com/embed/rfbb4yRBH64" title="YouTube video player" width="100%"></iframe><p>That not enough for you? Okay, read the <a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransferItem/kind">DataTransferItem.kind</a> documentation. The kind can be a <code>file</code> or <code>string</code>. You’d probably think that if something is a file, you can read it and treat it as a file, but you’d be stepping into another trap: the value for <code>DataTransferItem.kind</code> for folders is… <code>&#34;file&#34;</code>.</p><p>Instead of relying on the <code>DataTransferItem</code> object, it’s better to immediately request a <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemEntry">FileSystemEntry</a> by calling <a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransferItem/webkitGetAsEntry">webkitGetAsEntry</a> on each item, a method that despite its name is implemented in all modern browsers.</p><p>Instead of relying on a <code>.kind</code> property like <code>DataTransferItem</code>, though, for the FileSystemEntry object you’re given <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemEntry/isDirectory">isDirectory</a> and isFile properties. In some cases, both <code>isDirectory</code> and <code>isFile</code> can be true at the same time. I don’t know.</p><p>But along with that FileSystemEntry object, to save that file back to the filesystem, you’ll also need a <code>FileSystemHandle</code> object, which has a <code>.kind</code> property, with the values <code>file</code> or <code>directory</code>. In this case, as far as I can tell, they mean what you’d expect.</p><h3 id="the-moral-of-the-story">The moral of the story</h3><p>I wrote <a href="https://github.com/placemark/flat-drop-files">flat-drop-files</a> to abstract around many of these gotchas, and I’m using it in Placemark, so I have a good reason to keep it up-to-date and fix bugs. I think it simplifies a lot of these APIs.</p><p>But this is also just about what engineering is. This stuff is the opposite of being an <a href="https://www.joelonsoftware.com/2008/05/01/architecture-astronauts-take-over/">architecture astronaut</a> and seeing everything from a pleasant level of abstraction. Working with the web platform is dealing with history, with the accumulated matter of <a href="https://www.quirksmode.org/">quirksmode</a> and good-enough standards. In exchange for the ability to deliver instantly-updating software directly to customers with no middlemen and no installation, you have to absorb a great deal of nearly-useless information that’s entirely about dodging meaningless traps.</p><p>Sometimes you spend all day learning and at the end of the day, you’ve learned nothing. But it goes with the territory. I’m building things in a world with history and endless complexity. The implementation is made of implementation details.</p></div></div>
  </body>
</html>
