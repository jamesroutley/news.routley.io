<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/">Original</a>
    <h1>I still like Sublime Text in 2025</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="ArticleBody text"><p>I still get people asking me why I use Sublime Text in 2025 given there are <em>soooo</em> many other great editors out there.</p><p>My response: there is? Because I still think Sublime Text holds up as a great editor.</p><p><em>Table Of Contents</em></p><ul><li><a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/#it-fast">It fast</a></li><li><a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/#lsp">LSP</a></li><li><a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/#snippets">Snippets</a></li><li><a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/#project-workspaces">Project workspaces</a></li><li><a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/#build-systems">Build systems</a></li><li><a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/#multiple-cursors">Multiple cursors</a></li><li><a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/#key-mouse-bindings">Key/mouse bindings</a></li><li><a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/#included-niceness">Included niceness</a></li><li><a href="https://ohdoylerules.com/workflows/why-i-still-like-sublime-text-in-2025/#wish-list">Wish List</a></li></ul><p>I started with Sublime Text 2 back in 2010/2011 while I was in college. I mainly started using it because it was free, cross-platform, and came as a &#34;portable app&#34; that I could put on a USB and just use.</p><p>Back then, I had a really basic Toshiba laptop that dual booted Windows XP and Ubuntu (or maybe it was Mint?) so it was nice that it worked on both. I really liked how snappy it was compared to the tools our teacher suggested using. At that time it was Dreamweaver and maybe Notepad++.</p><p>Sublime, at that time, was pretty novel. It clearly took a lot of inspirations from <a rel="noopener nofollow noreferrer" href="https://github.com/textmate/textmate" target="_blank">TextMate</a>, another classic editor, considering that one is 4 years older than Sublime. It had multiple cursors, plugins, a build system. But the <a rel="noopener nofollow noreferrer" href="https://www.vendr.com/blog/consumer-dev-tools-command-palette" target="_blank">biggest claim to fame for Sublime, was the &#34;command palette&#34;</a>. I&#39;m sure there is some other older app that had a precursor or similar feature to it, but generally speaking, it seems like that user experience pattern really kicked off with Sublime.</p><p>I built my web-dev chops on Sublime. The shortcuts are ingrained in my bones at this point. I&#39;m not some key-combo-king, but I know a lot of the shortcuts that can help me get the UI and commands I need without thinking much at all.</p><blockquote><p>I have been, and continue to be, a Sublime user of about 15 years.</p></blockquote><p>So take all this with that in mind. I have been, and continue to be, a Sublime user of about 15 years.</p><p>So why do I keep using Sublime?</p><p>If you thought Sublime was dead, well you couldn&#39;t be more wrong! The latest build of Sublime as of this post is &#34;4192&#34; and was released 20th January 2025. So basically a week ago from this post. Not too bad.</p><p>It has regularly been updated with minor tweaks and fixes about a dozen times a year. I think the last major upgrade would be when Package Control (the plugin installer/manager) bumped to the next version which allowed plugins to install external dependencies.</p><p>You can nitpick here and say that Package Control is not part of Sublime. But most people won&#39;t use Sublime without it. So I am going to take some liberties and say it is part of it.</p><p>I think the thing to consider is how Sublime is basically &#34;done&#34; software. It has been around a <em>long</em> time. It was first released around 2008. It just passed it&#39;s 17-year anniversary actually. Congrats to them!</p><p>Before I dive into the details of <strong>why</strong> I still use it, consider this: if you are using a modern GUI-driven editor, it probably has taken inspiration from Sublime. So why not check out one of the OGs? You might find something you like.</p><p>Without further adieu, my reasons for still using Sublime in 2025:</p><h3 id="it-fast">It fast</h3><p>Sublime is fast. It starts instantly. Uses very few resources. Handles large files gracefully. Rarely crashes.</p><p>Nothing else to add here. A+ performance.</p><h3 id="lsp">LSP</h3><p><a rel="noopener nofollow noreferrer" href="https://github.com/sublimelsp" target="_blank">Sublime LSP</a> is really doing a lot for Sublime to keep it feeling modern and keeping up with other tools in the same class.</p><p>If you aren&#39;t aware of what an LSP is, this isn&#39;t the post to learn about it. But the gist is, it handles all that fancy code-aware completion and hover info you like from VS Code. If you want to learn more <a href="https://www.youtube.com/watch?v=LaS32vctfOY" rel="noopener nofollow noreferrer" target="_blank">give TJ 5 minutes to learn you</a>.</p><p>Some of the cool things about the Sublime LSP:</p><p><strong>Multiple servers per file</strong></p><p>You can enable as many LSP servers per file that you want. Restart them individually and configure them on a per-project basis (more on that later) which really helps bolster the capabilities of this already great editor.</p><p><strong>Detection on a scope level</strong></p><p>When configuring an LSP, outside of one installed with a plugin, you tell the LSP plugin which &#34;scope&#34; (think of this as an id for a syntax) to enable an LSP on.</p><p>Want your LSP to only turn on if you only open a file with a specific syntax? No problem. Want it to turn on only if a type of syntax is detected? Like a specific flavour of CSS? Sure. It is very configurable.</p><p><strong>Extensible configuration</strong></p><p>I know VS Code is the LSP king, which the tech originating with that editor, but I haven&#39;t seen the ability to just add an LSP installed as a binary in on your <code>usr/local/bin</code>.</p><p>There are a few &#34;cutting-edge&#34; LSPs that are installed via Cargo that are usually only targeting Neovim, but can easily be configured in Sublime with a simple JSON object.</p><p>Here is an example of configuring <a rel="noopener nofollow noreferrer" href="https://github.com/matkrin/md-lsp" target="_blank">md-lsp</a> (Markdown language server with support for GitHub flavored Markdown) in a few lines:</p><pre data-lang="json"><code data-lang="json"><span>// in the &#34;LSP Settings&#34; file, under &#34;clients[]&#34;
</span><span>&#34;</span><span>md-lsp</span><span>&#34;: {
</span><span>  </span><span>// default enabled?
</span><span>  &#34;</span><span>enabled</span><span>&#34;: </span><span>true</span><span>,
</span><span>  &#34;</span><span>command</span><span>&#34;: [
</span><span>    </span><span>// as long as the system path is setup right, we can find this binary
</span><span>    &#34;</span><span>md-lsp</span><span>&#34;,
</span><span>  ],
</span><span>  </span><span>// when we see this scope, the LSP will start this server
</span><span>  &#34;</span><span>selector</span><span>&#34;: &#34;</span><span>text.html.markdown</span><span>&#34;,
</span><span>},
</span></code></pre><p>It should be noted that md-lsp <strong>does not have a Sublime LSP plugin</strong> nor any mention of Sublime in their README. They only mention support for <em>Helix</em> and <em>Neovim</em>. Well, guess what? You support Sublime too!</p><h3 id="snippets">Snippets</h3><p>I write a lot of snippets. Right now, my snippets folder in Sublime has 123 snippets. The latest one was added <strong>today</strong>. It was a &#34;TODO&#34; snippet for Blade.</p><p>Sublime lets you create snippets from the <code>Tools &gt; Developer &gt; New Snippet</code> dropdown. They get sent to your &#34;User&#34; folder in the Sublime directory and are sourced on startup.</p><p><strong>Scope based</strong></p><p>Snippets are also scope-based. VS Code has scopes too, so there is nothing new here. I wonder where they got that from? 😮</p><p>A quick note on scopes: they can be very vague (like <code>source.txt</code>, targeting a whole <code>.txt</code> file) or super specific (like <code>text.html.basic.liquid text.html.basic meta.object.liquid</code> which targets a nested object in a liquid template) based on what you need.</p><p>I have found the Sublime scope integration to be straightforward to understand. A syntax defines scopes, and you can target those scopes in snippets, keybindings, and macros. More on those other two later.</p><p>I&#39;m sure I didn&#39;t get the details perfect. But it doesn&#39;t really matter given the point I&#39;m going to make: not all snippet systems work this way.</p><p>Specifically, I have found Helix, Neovim, and Zed snippets to be more based around &#34;filetype&#34; and not the scope of the where you are in the &#34;syntax&#34;.</p><p>I&#39;m sure this will change. Or perhaps I&#39;ve missed something. From what I can see on the surface, snippets based on syntax-specific scopes seem to be the default in VS Code and Sublime.</p><p><strong>Tab stops with nesting, placeholders, and references</strong></p><p>Here is the snippet I made today:</p><pre data-lang="xml"><code data-lang="xml"><span>&lt;</span><span>snippet</span><span>&gt;
</span><span>    &lt;</span><span>content</span><span>&gt;&lt;![</span><span>CDATA</span><span>[
</span><span>&lt;!-- TODO: $1 --&gt;$0
</span><span>]]&gt;&lt;/</span><span>content</span><span>&gt;
</span><span>    &lt;</span><span>description</span><span>&gt;Blade todo comment&lt;/</span><span>description</span><span>&gt;
</span><span>    </span><span>&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;
</span><span>    &lt;</span><span>tabTrigger</span><span>&gt;todo&lt;/</span><span>tabTrigger</span><span>&gt;
</span><span>    </span><span>&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;
</span><span>    &lt;</span><span>scope</span><span>&gt;text.html.blade&lt;/</span><span>scope</span><span>&gt;
</span><span>&lt;/</span><span>snippet</span><span>&gt;
</span></code></pre><p>Pretty simple. People who have written snippets before will recognize the syntax. The <code>$1</code> is where your caret is sent first, you can then type, then hit tab, and you get sent to <code>$0</code>.</p><p>Here is a TODO snippet I have for &#34;javascript&#34; files:</p><pre data-lang="xml"><code data-lang="xml"><span>&lt;</span><span>snippet</span><span>&gt;
</span><span>  &lt;</span><span>content</span><span>&gt;&lt;![</span><span>CDATA</span><span>[
</span><span>/** @todo ${1:this is my todo} */$0
</span><span>]]&gt;&lt;/</span><span>content</span><span>&gt;
</span><span>  </span><span>&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;
</span><span>  &lt;</span><span>tabTrigger</span><span>&gt;todo&lt;/</span><span>tabTrigger</span><span>&gt;
</span><span>  &lt;</span><span>description</span><span>&gt;Insert a TODO JS comment&lt;/</span><span>description</span><span>&gt;
</span><span>  </span><span>&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;
</span><span>  &lt;</span><span>scope</span><span>&gt;source.js, source.ts, source.jsx meta.function.js meta.block.js meta.group.js meta.jsx.js meta.interpolation.js, source.tsx meta.function.js meta.block.js meta.group.js meta.jsx.js meta.interpolation.js&lt;/</span><span>scope</span><span>&gt;
</span><span>&lt;/</span><span>snippet</span><span>&gt;
</span></code></pre><p>Here you can see that the first tab stop has default content of &#34;this is my todo&#34;. Here you can see a more complex scope setup that only expands this snippet under those conditions. Nothing really spectacular here.</p><p>But snippets in Sublime also support some transformations...</p><p><strong>Transformations (Vue component)</strong></p><p>Here is a much more complicated snippet:</p><pre data-lang="xml"><code data-lang="xml"><span>&lt;</span><span>snippet</span><span>&gt;
</span><span>  &lt;</span><span>content</span><span>&gt;&lt;![</span><span>CDATA</span><span>[
</span><span>&lt;!--
</span><span>  ${1:Namespace} Component
</span><span>  Usage:
</span><span>    &lt;${1/([a-zA-Z]+)(?:(\s+?)|\b)/\L\1(?2:\-)\E/g}&gt;&lt;/${1/([a-zA-Z]+)(?:(\s+?)|\b)/\L\1(?2:\-)\E/g}&gt;
</span><span>  ${2:Here is a description of my web component.}
</span><span>  @element ${3:div}
</span><span>  @fires change - This jsdoc tag makes it possible to document events.
</span><span>  @fires submit
</span><span>  @prop {String} title - You can use this jsdoc tag to document properties.
</span><span>  @slot - This is an unnamed slot (the default slot)
</span><span>  @slot start - This is a slot named &#34;start&#34;.
</span><span>  @slot end
</span><span> --&gt;
</span><span>
</span><span>&lt;script setup lang=&#34;ts&#34;&gt;
</span><span>import type { HTMLAttributes } from &#39;vue&#39;;
</span><span>export interface Props extends /* @vue-ignore */ HTMLAttributes {
</span><span>  ${4:title?: string;${5}}
</span><span>}
</span><span>
</span><span>withDefaults(defineProps&lt;Props&gt;(), {});
</span><span>&lt;/script&gt;
</span><span>
</span><span>&lt;template&gt;
</span><span>  &lt;${3:div} :key=&#34;${1/(\w+)(\W*)/\L\1\E(?2:\-)/g}&#34; class=&#34;${1/(\w+)(\W*)/\L\1\E(?2:\-)/g}wrapper&#34;&gt;
</span><span>    ${6:&lt;!-- content --&gt;}
</span><span>  &lt;/${3:div}&gt;
</span><span>&lt;/template&gt;
</span><span>]]&gt;&lt;/</span><span>content</span><span>&gt;
</span><span>  </span><span>&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;
</span><span>  &lt;</span><span>tabTrigger</span><span>&gt;sfc&lt;/</span><span>tabTrigger</span><span>&gt;
</span><span>  </span><span>&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;
</span><span>  &lt;</span><span>scope</span><span>&gt;text.html.vue&lt;/</span><span>scope</span><span>&gt;
</span><span>  &lt;</span><span>description</span><span>&gt;Vue single-file component template&lt;/</span><span>description</span><span>&gt;
</span><span>&lt;/</span><span>snippet</span><span>&gt;
</span></code></pre><p>This snippet has some transformations in it. This means we can actually format what the content in the different tab stops will be.</p><p>I won&#39;t harp on what is going on too much. Just know that I can format the content in the &#34;Usage&#34; comment as <code>UpperCamelCase</code> and I can format the content in <code>:key</code> to be <code>lower-snake-case</code>. VS Code can do this. The syntax for it is a bit nicer. But I prefer authoring snippets in XML rather than JSON.</p><p>Obviously, I&#39;m twisted.</p><h3 id="project-workspaces">Project workspaces</h3><p>Sublime supports the concept of workspaces under the banner of a &#34;project&#34;. All without a plugin, by the way. You can open a folder and save that folder as a project.</p><p>This creates an empty <code>your-project-name.sublime-project</code> which you can really save wherever you like in your project as it has some features to target where the root of the project is.</p><p>This file is just a JSON file and contains editor settings that you are overriding for that specific project. You can target global settings, set rules for specific folders, create a build system, tweak/toggle LSP settings, etc. etc.</p><p>This is a lot like the <code>.vscode/settings.json</code> file from what I understand. I also believe you can do this in Vim with a <code>.vim</code> folder in the root of your project with a feature called &#34;exrc&#34;. I haven&#39;t used it personally, so I can&#39;t speak to it much.</p><p>In my brief flirtations with Neovim and Helix, you need a plugin for this. In Zed, they also have a settings file that can be saved into a project root to get the same thing.</p><p><strong>Including/excluding files and folders</strong></p><p>I think all the editors I referenced above can do this. Not much to share. It is just nice to have an array of file configurations for a project that may or not be in that directory, can be matched with a glob, or just listed explicitly.</p><p>Here is an example of how I would use the project file in a Next.js site:</p><pre data-lang="json"><code data-lang="json"><span>{
</span><span>    &#34;</span><span>folders</span><span>&#34;: [
</span><span>        {
</span><span>            &#34;</span><span>file_exclude_patterns</span><span>&#34;: [
</span><span>                &#34;</span><span>.gitkeep</span><span>&#34;,
</span><span>                &#34;</span><span>*.min.*</span><span>&#34;,
</span><span>                &#34;</span><span>*.snap</span><span>&#34;,
</span><span>                &#34;</span><span>*.lock</span><span>&#34;,
</span><span>                &#34;</span><span>*lock.json</span><span>&#34;
</span><span>            ],
</span><span>            &#34;</span><span>folder_exclude_patterns</span><span>&#34;: [
</span><span>                &#34;</span><span>.sanity</span><span>&#34;,
</span><span>                &#34;</span><span>.netlify</span><span>&#34;,
</span><span>                &#34;</span><span>.next</span><span>&#34;,
</span><span>                &#34;</span><span>.vercel</span><span>&#34;,
</span><span>                &#34;</span><span>.cache</span><span>&#34;,
</span><span>                &#34;</span><span>out</span><span>&#34;,
</span><span>                &#34;</span><span>dist</span><span>&#34;,
</span><span>                &#34;</span><span>node_modules</span><span>&#34;
</span><span>            ],
</span><span>            &#34;</span><span>path</span><span>&#34;: &#34;</span><span>.</span><span>&#34;
</span><span>        }
</span><span>    ],
</span><span>    &#34;</span><span>build_systems</span><span>&#34;: [
</span><span>        {
</span><span>            &#34;</span><span>name</span><span>&#34;: &#34;</span><span>Project - Build</span><span>&#34;,
</span><span>            &#34;</span><span>working_dir</span><span>&#34;: &#34;</span><span>$project_path</span><span>&#34;,
</span><span>            &#34;</span><span>shell_cmd</span><span>&#34;: &#34;</span><span>pnpm run build</span><span>&#34;
</span><span>        },
</span><span>        {
</span><span>            &#34;</span><span>name</span><span>&#34;: &#34;</span><span>Project - Test</span><span>&#34;,
</span><span>            &#34;</span><span>working_dir</span><span>&#34;: &#34;</span><span>$project_path</span><span>&#34;,
</span><span>            &#34;</span><span>shell_cmd</span><span>&#34;: &#34;</span><span>pnpm run test</span><span>&#34;
</span><span>        },
</span><span>        {
</span><span>            &#34;</span><span>name</span><span>&#34;: &#34;</span><span>Project - Open Test</span><span>&#34;,
</span><span>            &#34;</span><span>working_dir</span><span>&#34;: &#34;</span><span>$project_path</span><span>&#34;,
</span><span>            &#34;</span><span>shell_cmd</span><span>&#34;: &#34;</span><span>find tests -print | grep $file_base_name.spec | sed -n 1p | xargs subl</span><span>
</span><span>        },
</span><span>        {
</span><span>            &#34;</span><span>name</span><span>&#34;: &#34;</span><span>Project - Test Snapshots</span><span>&#34;,
</span><span>            &#34;</span><span>working_dir</span><span>&#34;: &#34;</span><span>$project_path</span><span>&#34;,
</span><span>            &#34;</span><span>shell_cmd</span><span>&#34;: &#34;</span><span>pnpm run test:snapshots</span><span>&#34;
</span><span>        },
</span><span>        {
</span><span>            &#34;</span><span>name</span><span>&#34;: &#34;</span><span>Project - Test File</span><span>&#34;,
</span><span>            &#34;</span><span>working_dir</span><span>&#34;: &#34;</span><span>$project_path</span><span>&#34;,
</span><span>            &#34;</span><span>shell_cmd</span><span>&#34;: &#34;</span><span>pnpm run test -- $file_base_name.spec</span><span>&#34;
</span><span>        },
</span><span>        {
</span><span>            &#34;</span><span>name</span><span>&#34;: &#34;</span><span>Project - Test File Snapshot</span><span>&#34;,
</span><span>            &#34;</span><span>working_dir</span><span>&#34;: &#34;</span><span>$project_path</span><span>&#34;,
</span><span>            &#34;</span><span>shell_cmd</span><span>&#34;: &#34;</span><span>pnpm run test:snapshots -- $file_base_name.spec</span><span>&#34;
</span><span>        },
</span><span>        {
</span><span>            &#34;</span><span>name</span><span>&#34;: &#34;</span><span>Project - Format README.md</span><span>&#34;,
</span><span>            &#34;</span><span>working_dir</span><span>&#34;: &#34;</span><span>$project_path</span><span>&#34;,
</span><span>            &#34;</span><span>shell_cmd</span><span>&#34;: &#34;</span><span>mdformat $file</span><span>&#34;
</span><span>        }
</span><span>    ],
</span><span>    &#34;</span><span>settings</span><span>&#34;: {
</span><span>        &#34;</span><span>match_brackets_angle</span><span>&#34;: </span><span>true</span><span>,
</span><span>        &#34;</span><span>tab_size</span><span>&#34;: </span><span>2</span><span>,
</span><span>        &#34;</span><span>translate_tabs_to_spaces</span><span>&#34;: </span><span>true</span><span>,
</span><span>        &#34;</span><span>jsdocs_return_tag</span><span>&#34;: &#34;</span><span>@return</span><span>&#34;,
</span><span>        &#34;</span><span>lsp_format_on_save</span><span>&#34;: </span><span>false</span><span>,
</span><span>        &#34;</span><span>lsp_code_actions_on_save</span><span>&#34;: {
</span><span>            &#34;</span><span>source.organizeImports</span><span>&#34;: </span><span>false</span><span>,
</span><span>            &#34;</span><span>source.fixAll.eslint</span><span>&#34;: </span><span>true
</span><span>        },
</span><span>        &#34;</span><span>LSP</span><span>&#34;: {
</span><span>            &#34;</span><span>formatters</span><span>&#34;: {
</span><span>                &#34;</span><span>source.ts</span><span>&#34;: &#34;</span><span>LSP-biome</span><span>&#34;,
</span><span>                &#34;</span><span>source.js</span><span>&#34;: &#34;</span><span>LSP-biome</span><span>&#34;,
</span><span>                &#34;</span><span>source.tsx</span><span>&#34;: &#34;</span><span>LSP-biome</span><span>&#34;,
</span><span>                &#34;</span><span>source.jsx</span><span>&#34;: &#34;</span><span>LSP-biome</span><span>&#34;,
</span><span>                &#34;</span><span>text.html.basic</span><span>&#34;: &#34;</span><span>LSP-biome</span><span>&#34;
</span><span>            },
</span><span>            &#34;</span><span>LSP-eslint</span><span>&#34;: {
</span><span>                &#34;</span><span>enabled</span><span>&#34;: </span><span>false
</span><span>            },
</span><span>            &#34;</span><span>LSP-biome</span><span>&#34;: {
</span><span>                &#34;</span><span>enabled</span><span>&#34;: </span><span>true
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>I&#39;m doing a lot here. Setting files to ignore, folders to exclude from indexing, setting build commands that use <code>pnpm</code> as well as <code>mdformat</code>, setting from editor setting for tab spacing, and finally a few LSP tweaks that make sense for a Next project.</p><p>VS Code can do all of what I&#39;ve listed here. But they split it up into different files. Kinda annoying.</p><p><strong>Configure plugin settings per project</strong></p><p>You can also configure plugin settings per project. Here is how I would add project settings for the &#34;syntax override&#34; plugin. This plugin forces the editor to use a specific syntax for certain files that match a given pattern:</p><pre data-lang="json"><code data-lang="json"><span>{
</span><span>    </span><span>// everything is the same as above but this is added on the end
</span><span>    &#34;</span><span>syntax_override</span><span>&#34;: {
</span><span>        &#34;</span><span>\\</span><span>.env.*$</span><span>&#34;: [
</span><span>            &#34;</span><span>ShellScript</span><span>&#34;,
</span><span>            &#34;</span><span>Shell-Unix-Generic</span><span>&#34;
</span><span>        ],
</span><span>        &#34;</span><span>\\</span><span>.*rc$</span><span>&#34;: [
</span><span>            &#34;</span><span>JSON</span><span>&#34;,
</span><span>            &#34;</span><span>JSON</span><span>&#34;
</span><span>        ],
</span><span>        &#34;</span><span>\\</span><span>.ts.snap$</span><span>&#34;: [
</span><span>            &#34;</span><span>JavaScript</span><span>&#34;,
</span><span>            &#34;</span><span>TypeScript</span><span>&#34;
</span><span>        ],
</span><span>        &#34;</span><span>\\</span><span>.css$</span><span>&#34;: [
</span><span>            &#34;</span><span>Tailwind CSS</span><span>&#34;,
</span><span>            &#34;</span><span>Tailwind CSS</span><span>&#34;
</span><span>        ]
</span><span>    }
</span><span>}
</span></code></pre><p>I don&#39;t always want all <code>.css</code> files to be highlighted with the Tailwind syntax. But in this project I do. So I can set it locally here, and when I open a <code>.css</code> file in this project, it will switch the syntax for me. Nice!</p><p><strong>Add build systems per project</strong></p><p>You can see in the example above that I have set build systems on this specific project. You can do this in VS Code with &#34;tasks&#34;. Zed has this feature as well and calls it &#34;tasks&#34; too. I just find it annoying that they are in their own files. I guess that makes them more portable.</p><p>I just like my project configuration <em>in one central place</em>. I must be nuts.</p><h3 id="build-systems">Build systems</h3><p>I&#39;ve touched on build systems a bit already. But in summation, they are just tasks you can run in your project.</p><p>Sometimes they call a global command (like <code>curl</code>), sometimes a local dependency is installed with a package manager (think some binary in <em>node_modules/.bin/</em>), or maybe just runs a command already setup in your other tools (like <code>composer run test</code> or <code>php artisan migrate:fresh</code>) that run in the root of the project but need some context.</p><p><strong>Can also be provided by a plugin</strong></p><p>A plugin can provide build systems. The neat thing is they are just Sublime files. JSON that ends in <code>.sublime-build</code>. Like snippets. So they are really portable too. Just like the other editors with their <code>tasks.json</code> file.</p><p><strong>Just a simple file</strong></p><p>Here is one I saved in my &#34;User&#34; directory called <code>dot-env-linter.sublime-build</code>:</p><pre data-lang="json"><code data-lang="json"><span>{
</span><span>  &#34;</span><span>cmd</span><span>&#34;: [&#34;</span><span>dotenv-linter</span><span>&#34;, &#34;</span><span>$file</span><span>&#34;],
</span><span>  &#34;</span><span>selector</span><span>&#34;: &#34;</span><span>source.shell</span><span>&#34;,
</span><span>  &#34;</span><span>file_patterns</span><span>&#34;: [&#34;</span><span>\\</span><span>.env.*$</span><span>&#34;],
</span><span>  &#34;</span><span>file_regex</span><span>&#34;: &#34;</span><span>^(.*?)</span><span>\\</span><span>:(</span><span>\\</span><span>d+)(</span><span>\\</span><span>s)(.*+)</span><span>&#34;
</span><span>}
</span></code></pre><p>You can see there are some special variables (like <code>$file</code>) that will expand based on context. In this case, that one is the full path to the currently active file.</p><p>Here is my <code>phpmd.sublime-build</code> with a bit more flavour:</p><pre data-lang="json"><code data-lang="json"><span>{
</span><span>  &#34;</span><span>cmd</span><span>&#34;: [&#34;</span><span>phpmd</span><span>&#34;, &#34;</span><span>${file}</span><span>&#34;, &#34;</span><span>text</span><span>&#34;, &#34;</span><span>codesize,unusedcode,naming</span><span>&#34;],
</span><span>  &#34;</span><span>path</span><span>&#34;: &#34;</span><span>${PATH}</span><span>&#34;,
</span><span>  &#34;</span><span>working_dir</span><span>&#34;: &#34;</span><span>$project_path</span><span>&#34;,
</span><span>  &#34;</span><span>selector</span><span>&#34;: &#34;</span><span>source.php</span><span>&#34;
</span><span>}
</span></code></pre><p>You can see some more vars here for the project path as well as a reference to my system PATH. Of course, we got a nice lil scope as well.</p><p><strong>Build systems with 🐍</strong></p><p><a rel="noopener nofollow noreferrer" href="https://www.sublimetext.com/docs/build_systems.html#advanced-example" target="_blank">You can actually write build systems in Python as well</a>. So if you need something more complicated, you can reach for that.</p><p>You don&#39;t even need to make any semblance of a plugin. You can toss a <code>.py</code> file in your &#34;User&#34; directory and implement a class that takes a <code>sublime_plugin.WindowCommand</code>.</p><h3 id="multiple-cursors">Multiple cursors</h3><p>Yep. Multiple cursors. I use them all the time. I know that the &#34;vim&#34; way is to start recording a macro, apply the changes on a single line, and then replay that macro on all the lines you want to change. Or do some <code>s//g</code> fu for a fancy find and replace. I get it. I just don&#39;t like it.</p><p>Most of the editors these days have multiple cursors. Including some terminal editors like Helix. I have tried Helix and I think it is a lot closer to what I would want from a modern editor than my previous terminal editor of Neovim + LazyVim.</p><h3 id="key-mouse-bindings">Key/mouse bindings</h3><p>The key and mouse bindings are what you would expect from a modern editor. It is basically the same as VS Code. Nothing exhilarating here. But I do like the way conceptual key bindings are handled.</p><p><strong>Contextual key bindings</strong></p><p>Like any good editor, Sublime supports contextual key bindings.</p><p>I think the best usage I have seen for contextual key bindings is in <a rel="noopener nofollow noreferrer" href="https://github.com/sublimehq/Packages/blob/master/JavaScript/Default.sublime-keymap#L11-L17" target="_blank">the JavaScript language support package</a> that comes with Sublime.</p><p>When you have an active selection, and that selection is not empty, and you are inside a string-like scope, then ` will wrap that selection with `. Basically, it will wrap your selection as a template string. Handy!</p><p><strong>Just a simple file</strong></p><p>Like the build systems and snippets, key bindings are just saved in a file that ends with <code>.sublime-keymap</code>. They can be in your &#34;User&#34; directory or in a plugin. Unfortunately, unlike build systems, they cannot be saved on a per-project basis - from what I can tell.</p><p>You can also have key bindings for different platforms. They are named as follows:</p><pre><code><span>Default (Windows).sublime-keymap
</span><span>Default (OSX).sublime-keymap
</span><span>Default (Linux).sublime-keymap
</span></code></pre><h3 id="included-niceness">Included niceness</h3><p>These are just some notable mentions of things I like:</p><p><strong>Python all the way down</strong></p><p>Given how Python is probably the most popular language, at least <a rel="noopener nofollow noreferrer" href="https://www.theregister.com/2024/11/05/python_dethrones_javascript_github/" target="_blank">the last time GitHub checked</a>, I&#39;m surprised this isn&#39;t the go-to editor. I don&#39;t think you need to know python to use Sublime but it helps if you want to craft a nice plugin.</p><p>One more thing to add around authoring plugins, they are super simple. It is just a <code>.py</code> file in a folder. No build system, external dependencies, or ever-changing APIs to navigate.</p><p>You can see <a rel="noopener nofollow noreferrer" href="https://github.com/james2doyle/sublime_scratchpad/blob/master/Scratchpad.py" target="_blank">my recent fork of the Scratchpad plugin</a> and how the whole thing is mostly powered by a single python file.</p><p>This plugin has been trucking along for 11 years. I can&#39;t imagine any VS Code plugin lasting that long!</p><p><strong>Macros</strong></p><p>Yep you can record macros in Sublime. You can also save them to... a file! Then put that file (<code>.sublime-macro</code>) in a plugin, or, of course, your &#34;User&#34; folder. The macro is just an array of key presses. They also support scopes and can be bound to a key combo. Pretty sweet.</p><p>This is one feature that VS Code has not stolen - I mean implemented - and that requires an additional plugin to have. Of course the Vimmers have had this for decades.</p><p><strong>Diff hunks (revert or show)</strong></p><p>Sublime supports viewing inline diff hunks. Handy for when you don&#39;t want to dive into the diff of a file. You can just ask to see the diff hunk for that line or group of lines. You can also revert just as easily.</p><p><strong>Case conversion and line permute functions</strong></p><p>There are some handy case conversion functions that are built in. Nice with multiple cursors. VS Code has a couple of conversion choices. Sublime has 8 different case conversions built in.</p><p><strong>Package control and repo URLs for packages</strong></p><p>Package control packages can be installed from the central repository. But you can also install them from a git repo URL. You can also clone a repo to your &#34;Packages&#34; folder, and it will work too. No marketplace or anything like that is required.</p><p>This is really handy if you have forked a package and just want to install your fork.</p><p><strong>All the config and settings are plain files</strong></p><p>Since the whole of a Sublime setup is mostly plain files, that makes it really easy to sync your setup across multiple computers. I actually symlink my Sublime folder to Dropbox. So any changes I make will be shared across all my computers that use it.</p><p>This isn&#39;t unique to Sublime. I think it is just a benefit of having tools that use plain text-driven configuration.</p><p><strong>Distraction-free mode</strong></p><p>Sublime has a &#34;distraction free mode&#34; which will full-screen your editor and focus the content to the middle of the screen. I am using it to write this post right now!</p><h3 id="wish-list">Wish List</h3><p>Of course there could be a few things that could be better.</p><p><strong>Better docs</strong></p><p>I do find the docs for developing plugins to be sparse. There are doc sites. There are two big ones. One for the &#34;official&#34; docs that document the APIs. There is also another site that is tagged as the &#34;unofficial&#34; docs.</p><p>Usually when I want to know how to do something in a plugin, I just read the source of another plugin that does something I want to emulate. It isn&#39;t a bad way to learn, it is just a bit tedious.</p><p><strong>Plugin development DX</strong></p><p>Speaking of building plugins, there does not seem to be any &#34;stubs&#34; for the Sublime python API. I am by no means a python guru. I only use it in Sublime, and I usually forget everything once I finish what I am trying to do. But I think there could be some &#34;plugin starter template&#34; that could include a Pyright setup and some basic guide for how to get going.</p><p>I also find that getting plugins on the Package Control site to be quite a chore. You need to open a PR to a repo and put your repo into a list based on where it goes into an alphabet. It doesn&#39;t allow forks and plugins that are too similar. There is also no way to mark a package as &#34;abandoned&#34;.</p><p>I like the way Composer/Packagist does packages. You create a repo, submit that URL to the Packagist site, and it will automatically keep track of it for you. You release a new version by just using git tags and releases.</p><p>NPM is also a bit nicer. But forcing an NPM account and having to juggle the mixing of git tags and the <code>package.json</code> &#34;version&#34; key to be a bit unclear at times.</p><p><strong>Key/Mouse bindings per project</strong></p><p>Simple one here. It would be nice to have key and mouse bindings on a project level. I don&#39;t know how often I would really use it, but it would be nice to have just for those projects that have tedious tasks or macros that I want to run under specific scopes.</p><h2 id="in-summation">In Summation</h2><p>I like Sublime. I think it is still incredibly capable in 2025. If you are in search of something a little snappier, classier, and not riddled with AI slop, then give it a try.</p><p>I doubt I can pry your Vim from your <code>HJKL</code> riddled right hand, but if you have been let down or uninspired by the latest offerings when it comes to editors, you might find Sublime still has a lot to offer.</p><p><em>Note: if any of my information is wrong or outdated, I will update it accordingly</em></p></div></div>
  </body>
</html>
