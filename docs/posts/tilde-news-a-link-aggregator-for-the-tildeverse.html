<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tilde.news">Original</a>
    <h1>Tilde.news – A Link Aggregator for the Tildeverse</h1>
    
    <div id="readability-page-1" class="page"><div><p><time datetime="2023-02-25 16:19:04 -0500 EST">2023-02-25</time>
|
tags: [ <a href="https://aos.github.io/tags/infrastructure">infrastructure</a> ]</p></div><div><p>When managing multiple dissimilar resources in Terraform, best practices
dictate that you use the <a href="https://developer.hashicorp.com/terraform/language/meta-arguments/for_each"><code>for_each</code>
meta-argument</a>.
Furthermore, when needing to convert a list to a set or map for chaining, the
advice given is usually of the form:</p><pre><code>for_each = {
  for k, v in aws_subnet.all : k =&gt; v
}
</code></pre><p>This will work but unfortunately it becomes unwieldy the more you need to rely
on these generated resources.</p><h2 id="a-motivating-example">A motivating example</h2><p>In one of <a href="https://learn.cantrill.io/">Adrian Cantrill’s excellent courses on
AWS</a>, we are tasked with setting up a multi-tier
subnet design:</p><p><img src="https://aos.github.io/img/vpc_endstate.png" alt="VPC endstate"/>
<em>(Courtesy of <a href="https://learn.cantrill.io">https://learn.cantrill.io</a>)</em></p><p>We can set this up in Terraform like so:</p><div><pre><code data-lang="hcl"><span>locals</span> {
  subnet_tiers = [<span>&#34;reserved&#34;, &#34;db&#34;, &#34;app&#34;, &#34;web&#34;</span>]
  subnet_azs   = [<span>&#34;A&#34;, &#34;B&#34;, &#34;C&#34;</span>]
  subnet_tiers_azs = [
    <span>for</span> <span>i</span>, <span>s</span> <span>in</span> <span>setproduct</span>(<span>local</span>.<span>subnet_tiers</span>, <span>local</span>.<span>subnet_azs</span>) <span>:</span> {
      name   = <span>s</span>[<span>0</span>]
      az     = <span>s</span>[<span>1</span>]
      cidr   = <span>cidrsubnet</span>(<span>var</span>.<span>vpc_cidr</span>, <span>4</span>, <span>i</span>)
    }
  ]
}<span>
</span><span>
</span><span># It&#39;s not possible to directly use `subnet_tier_azs` here since it only
</span><span># accepts maps or a set of strings
</span><span></span><span>resource</span> <span>&#34;aws_subnet&#34; &#34;all&#34;</span> {
  for_each = {
    for k, v in local.subnet_tiers_azs : k =<span>&gt;</span> <span>v</span>
  }

  tags = {
    Name = <span>&#34;sn-${each.value.name}-${each.value.az}&#34;</span>
  }<span>
</span><span>  # ... etc.
</span><span></span>}
</code></pre></div><p>This is serviceable<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> and the <code>Name</code> tag allows us to pick a single subnet.
Let’s create a bastion in the <code>web-A</code> subnet:</p><div><pre><code data-lang="hcl"><span>resource</span> <span>&#34;aws_instance&#34; &#34;bastion&#34;</span> {<span>
</span><span>  # ...
</span><span>  # Get the subnet ID from the tag `sn-web-A`
</span><span></span>  subnet_id = <span>one</span>([
    <span>for</span> <span>v</span> <span>in</span> <span>aws_subnet</span>.<span>all</span> <span>:</span> <span>v</span>.<span>id</span> <span>if</span> <span>length</span>(<span>regexall</span>(<span>&#34;.*-web-A&#34;, v[&#34;tags&#34;][&#34;Name&#34;</span>])) <span>&gt;</span> <span>0</span>
  ])
}
</code></pre></div><p>Having to rely on <code>one</code>, <code>length</code> and <code>regex</code> functions to pick out the <code>web-A</code>
subnet becomes error-prone and unergonomic.</p><h2 id="a-better-way">A better way</h2><p>There is a better way to name our resources upon creation. Instead of
<code>k =&gt; v</code> in the <code>for_each</code> block, we can explicitly name the key of each
subnets:</p><div><pre><code data-lang="hcl"><span>resource</span> <span>&#34;aws_subnet&#34; &#34;all&#34;</span> {
  for_each = {
    for k, v in local.subnet_tiers_azs : &#34;${v.name}-${v.az}&#34; =<span>&gt;</span> <span>v</span>
  }<span>
</span><span>  # ...
</span><span></span>}
</code></pre></div><p>Now, we can refer to any subnet we’d like by using the key we’d named. Let’s
replace the <code>subnet_id</code> value above during creation of our bastion host:</p><div><pre><code data-lang="hcl">subnet_id = <span>aws_subnet</span>.<span>all</span>[<span>&#34;web-A&#34;</span>].<span>id</span>
</code></pre></div><p>The other upside of this method is that resource chaining <em>forward</em> will also
use these keys as default. This helped give me a better understanding of how
Terraform creates the final structure for resources made from <code>for_each</code>
blocks.</p><section role="doc-endnotes"><hr/><ol><li id="fn:1" role="doc-endnote"><p>In case you’re wondering what the structure of this ends up looking like,
it becomes a map keyed with the index. <a href="#fnref:1" role="doc-backlink">↩︎</a></p></li></ol></section></div></div>
  </body>
</html>
