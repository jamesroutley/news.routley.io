<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://research.google/blog/ai-in-software-engineering-at-google-progress-and-the-path-ahead/">Original</a>
    <h1>AI in software engineering at Google: Progress and the path ahead</h1>
    
    <div id="readability-page-1" class="page"><div data-gt-publish-date="20240606">
                    
                    


<section>
    
    <div>
        <p data-block-key="ygj61">In 2019, a software engineer — at Google or indeed anywhere else — would have heard of advances in machine learning, and how deep learning has become remarkably effective in fields such as computer vision or language translation. However, most of them would not have imagined, let alone experienced, the ways in which machine learning might benefit what <i>they</i> do.</p><p data-block-key="arj8a">Just five years later, in 2024, there is widespread enthusiasm among software engineers about how AI is helping write code. And a significant number of those have used ML-based autocomplete, whether it is using company internal tools at large companies, e.g., <a href="https://blog.research.google/2022/07/ml-enhanced-code-completion-improves.html">Google’s internal code completion</a>, or via commercially available products.</p><p data-block-key="5afae">In this blog, we present our newest AI-powered improvements within the context of the continuing transformation of Google’s internal software development tools, and discuss further changes that we expect to see in the coming 5 years. We also present our methodology on how to build AI products that deliver value for professional software development. Our team is responsible for the software development environments where Google engineers spend the majority of their time, including <i>inner loop</i> (e.g., IDE, <a href="https://abseil.io/resources/swe-book/html/ch19.html" target="_blank" rel="noopener noreferrer">code review</a>, <a href="https://developers.google.com/code-search" target="_blank" rel="noopener noreferrer">code search</a>), as well as <i>outer loop</i> surfaces (e.g., <a href="https://developers.google.com/issue-tracker" target="_blank" rel="noopener noreferrer">bug management</a>, planning). We illustrate that improvements to these surfaces can directly impact developer productivity and satisfaction, both metrics that we <a href="https://ieeexplore.ieee.org/document/9159122" target="_blank" rel="noopener noreferrer">monitor carefully</a>.</p>
    </div>


    
</section>

                    
                    


<section>
    
    <div>
        <h2 data-block-key="ygj61">The challenge</h2><p data-block-key="3lfr4">An ongoing challenge in this domain is that AI technology is evolving quickly and it is hard to predict which ideas to explore first. There is often a significant gap between technically feasible demos and successful productization. We approach deployment of ideas to products with three guidelines:</p><ol><li data-block-key="kapf"><i>Prioritize by technical feasibility and impact</i>: Work on ideas wherein both technical feasibility has already been established and high (measureable) impact on engineers’ workflows is expected.</li><li data-block-key="5v1pu"><i>Learn quickly, to improve UX and model quality</i>: Focus on iterating quickly and extracting lessons learned, while safeguarding developer productivity and happiness. User experience is just as important as model quality.</li><li data-block-key="6ha0d"><i>Measure effectiveness</i>: As our goal is to increase <a href="https://ieeexplore.ieee.org/document/10372494" target="_blank" rel="noopener noreferrer">productivity</a> and satisfaction metrics, we need to extensively monitor these metrics.</li></ol>
    </div>


    
</section>

                    
                    


<section>
    
    <div>
        <h2 data-block-key="ygj61">Applying LLMs to software development</h2><p data-block-key="1pl70">With the advent of <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener noreferrer">transformer</a> architectures, we started exploring how to apply LLMs to software development. LLM-based inline code completion is the most popular application of AI applied to software development: it is a natural application of LLM technology to use the code itself as training data. The UX feels natural to developers since word-level autocomplete has been a core feature of IDEs for many years. Also, it’s possible to use a rough measure of impact, e.g., the percentage of new characters written by AI. For these reasons and more, it made sense for this application of LLMs to be the first to deploy.</p><p data-block-key="9qvi8">Our <a href="https://blog.research.google/2022/07/ml-enhanced-code-completion-improves.html">earlier blog</a> describes the ways in which we improve user experience with code completion and how we measure impact. Since then, we have seen continued fast growth similar to <a href="https://arxiv.org/abs/2402.04141" target="_blank" rel="noopener noreferrer">other enterprise contexts</a>, with an acceptance rate by software engineers of 37%<footnote id="836bf139-6026-4010-9080-cf46311a03a0">[836bf1]</footnote> assisting in the completion of 50% of code characters<footnote id="5f21d2a5-56e2-4ad8-b41c-d21f3452375e">[5f21d2]</footnote>. In other words, the same amount of characters in the code are now completed with AI-based assistance as are manually typed by developers. While developers still need to spend time reviewing suggestions, they have more time to focus on code design.</p><p data-block-key="b4iqc">Key improvements came from both the models — larger models with improved coding capabilities, heuristics for constructing the context provided to the model, as well as tuning models on usage logs containing acceptances, rejections and corrections — and the UX. This cycle is essential for learning from practical behavior, rather than synthetic formulations.</p>
    </div>


    
</section>

                    
                    
    

<!-- mode: '' -->


  
    
    
    <picture>
      
      
      <source media="(min-width: 768px)" srcset="https://storage.googleapis.com/gweb-research2023-media/images/AIforSE-Hero1.width-800.png" alt="AIforSE-Hero1"/>
      
      <img src="https://storage.googleapis.com/gweb-research2023-media/images/AIforSE-Hero1.width-800.png" alt="AIforSE-Hero1" loading="lazy"/>
      
        <p data-block-key="qeeti"><i>Improving AI-based features in coding tools (e.g., in the IDE) with historical high quality data across tools and with usage data capturing user preferences and needs.</i></p>
      
    </picture>
  



                    
                    
    

<!-- mode: '' -->


  
    
    
    <picture>
      
      
      <source media="(min-width: 768px)" srcset="https://storage.googleapis.com/gweb-research2023-media/images/AIforSE-LineGraph2.width-800.png" alt="AIforSE-LineGraph2"/>
      
      <img src="https://storage.googleapis.com/gweb-research2023-media/images/AIforSE-LineGraph2.width-800.png" alt="AIforSE-LineGraph2" loading="lazy"/>
      
        <p data-block-key="qeeti"><i>Continued increase of the fraction of code created with AI assistance via code completion, defined as the number of accepted characters from AI-based suggestions divided by the sum of manually typed characters and accepted characters from AI-based suggestions. Notably, characters from copy-pastes are not included in the denominator.</i></p>
      
    </picture>
  



                    
                    


<section>
    
    <div>
        <p data-block-key="ygj61">We use our extensive and high quality logs of internal software engineering activities across multiple tools, which we have curated over many years. This data, for example, enables us to represent fine-grained code edits, build outcomes, edits to resolve <a href="https://en.wikipedia.org/wiki/Software_build" target="_blank" rel="noopener noreferrer">build</a> issues, code copy-paste actions, fixes of pasted code, code reviews, edits to fix reviewer issues, and change submissions to a repository. The training data is an aligned corpus of code with task-specific annotations in input as well as in output. The design of the data collection process, the shape of the training data, and the model that is trained on this data was described in our <a href="https://blog.research.google/2023/05/large-sequence-models-for-software.html">DIDACT</a> blog. We continue to explore these powerful datasets with newer generations of foundation models available to us (discussed more below).</p><p data-block-key="7v102">Our next significant deployments were <a href="https://research.google/blog/resolving-code-review-comments-with-ml/">resolving code review comments</a> (&gt;8% of which are now addressed with AI-based assistance) and automatically adapting pasted code to the surrounding context (now responsible for ~2% of code in the IDE<footnote id="5f21d2a5-56e2-4ad8-b41c-d21f3452375e">[5f21d2]</footnote>). Further deployments include instructing the IDE to perform code edits with natural language and predicting <a href="https://research.google/blog/safely-repairing-broken-builds-with-ml/">fixes to build failures</a>. Other applications, e.g., <a href="https://arxiv.org/abs/2405.13565" target="_blank" rel="noopener noreferrer">predicting tips for code readability</a> following a similar pattern are also possible.</p><p data-block-key="a6led">Together, these deployed applications have been successful, highly-used applications at Google, with measurable impact on productivity in a real, industrial context.</p>
    </div>


    
</section>

                    
                    
    

<!-- mode: '' -->


  
    <div>
      <video playsinline="" muted="true" loop="true" preload="auto">
        <source src="https://storage.googleapis.com/gweb-research2023-media/media/AIforSE-ExampleIDE3.mp4" type="video/mp4"/>
      </video>
      <div aria-label="Video Play/pause">
        <p><span>play silent looping video</span>
          <span>pause silent looping video</span>
        </p>
        
      </div>
      
      <p data-block-key="a3e6t"><i>A demonstration of how a variety of AI-based features can work together to assist with coding in the IDE.</i></p>
      
    </div>
  



                    
                    


<section>
    
    <div>
        <h2 data-block-key="kyiao">What we’ve learned</h2><p data-block-key="d7ocb">Our work so far has taught us several things:</p><ol><li data-block-key="fijbk">We achieved the highest <i>impact with UX that naturally blends into users’ workflows</i>. In all the above examples, a suggestion is presented to the user, taking them to the next step in their workflow with one tab or click. Experiments requiring the user to remember to trigger the feature have failed to scale.</li><li data-block-key="92tm">We observe that with AI-based suggestions, the <i>code author increasingly becomes a reviewer</i>, and it is <a href="https://research.google/pubs/if-its-what-i-wanted-thats-great-but-if-its-not-i-just-wasted-time-unpacking-the-perceived-costsbenefits-of-ml-enhanced-developer-tooling/">important to find a balance</a> between <a href="https://arxiv.org/abs/2205.06537" target="_blank" rel="noopener noreferrer">the cost of review and added value</a>. We typically address the tradeoff with acceptance rate targets.</li><li data-block-key="b83m8">Quick iterations with <i>online A/B experiments are key</i>, as offline metrics are often only rough proxies of user value. By surfacing our AI-based features on internal tooling, we benefit greatly from being able to easily launch and iterate, measure usage data, and ask users directly about their experience through UX research.</li><li data-block-key="g6lv"><i>High quality data</i> from activities of Google engineers across software tools, including interactions with our features, is essential for our model quality.</li></ol><p data-block-key="hc39">We observe across features that it’s <i>important to optimize for conversion</i> from the opportunity (mostly a user activity, shown at the top of the funnel below) to impact (applied AI assistance, at the bottom of the funnel), while removing bottlenecks from intermediate steps of the funnel by leveraging UX and model improvements.</p>
    </div>


    
</section>

                    
                    
    

<!-- mode: '' -->


  
    
    
    <picture>
      
      
      <source media="(min-width: 768px)" srcset="https://storage.googleapis.com/gweb-research2023-media/images/AIforSE-FunnelFinal4.width-800.png" alt="AIforSE-FunnelFinal4"/>
      
      <img src="https://storage.googleapis.com/gweb-research2023-media/images/AIforSE-FunnelFinal4.width-800.png" alt="AIforSE-FunnelFinal4" loading="lazy"/>
      
        <p data-block-key="ubz65"><i>An opportunity funnel starting from SWE actions down to actual application of ML-based suggestions. Opportunities are lost if the model prediction is not confident enough, the model doesn’t respond or responds too late, the prediction is subpar, the user doesn’t notice the prediction, and so on. We use UX and model improvements to harvest as many opportunities as we can.</i></p>
      
    </picture>
  



                    
                    


<section>
    
    <div>
        <h2 data-block-key="kyiao">What’s next</h2><p data-block-key="5cg9f">Encouraged by our successes so far, we are doubling down on bringing the latest foundation models (<a href="https://blog.google/technology/ai/google-gemini-ai/" target="_blank" rel="noopener noreferrer">Gemini series</a>) infused with the developer data (as part of <a href="https://blog.research.google/2023/05/large-sequence-models-for-software.html">DIDACT</a>, mentioned above) to power existing and new applications of ML to software engineering in Google.</p><p data-block-key="44ic3">Across the industry, ML-based code completion has provided a major boost for software developers. While there are still opportunities to improve code generation, we expect the next wave of benefits to come from ML assistance in a broader range of software engineering activities, such as testing, code understanding and code maintenance; the latter being of particular interest in enterprise settings. These opportunities inform our own ongoing work. We also highlight two trends that we see in the industry:</p><ol><li data-block-key="6emfq">Human-computer interaction has moved towards natural language as a common modality, and we are seeing a shift towards using language as the interface to software engineering tasks as well as the gateway to informational needs for software developers, all integrated in IDEs.</li><li data-block-key="2pi30">ML-based automation of larger-scale tasks — from diagnosis of an issue to landing a fix — has begun to show initial evidence of feasibility. These possibilities are driven by innovations in <i>agents</i> and <i>tool use</i>, which permit the building of systems that use one or more LLMs as a component to accomplish a larger task.</li></ol><p data-block-key="dfn6u">To expand on the above successes toward these next generation capabilities, the community of practitioners and researchers working in this topic would benefit from common benchmarks to help move the field towards practical engineering tasks. So far, benchmarks have been focused mostly around code generation (e.g., <a href="https://github.com/openai/human-eval" target="_blank" rel="noopener noreferrer">HumanEval</a>). In an enterprise setting, however, benchmarks for a wider range of tasks could be particularly valuable, e.g., code migrations and production debugging. Some benchmarks, such as one for bug resolution (e.g., <a href="https://www.swebench.com/" target="_blank" rel="noopener noreferrer">SWEBench</a>), and prototypes targeting those benchmarks (e.g., from <a href="https://www.cognition-labs.com/blog" target="_blank" rel="noopener noreferrer">Cognition AI</a>) have been published. We encourage the community to come together to suggest more benchmarks to span a wider range of software engineering tasks.</p>
    </div>


    
</section>

                    
                    


<section>
    
    <div>
        <h2 data-block-key="kyiao">Acknowledgements</h2><p data-block-key="98em"><i>This project is the result of work of many people from the Google Core Systems &amp; Experiences team and Google Deepmind, and</i> <a href="https://ai.googleblog.com/2023/05/large-sequence-models-for-software.html" target="_blank" rel="noopener noreferrer"><i>DIDACT</i></a><i>. This article was co-authored with Boris Bokowski (Google Coding Tools Director), Petros Maniatis (research), Ambar Murillo (UXR), and Alberto Elizondo (UXD). Deep gratitude goes to contributors to the various features: Adam Husting, Ahmed Omran, Alexander Frömmgen, Ambar Murillo, Ayoub Kachkach, Brett Durrett, Chris Gorgolewski, Charles Sutton, Christian Schneider, Danny Tarlow, Damien Martin-Guillerez, David Tattersall, Elena Khrapko, Evgeny Gryaznov, Fredde Ribeiro, Gabriela Surita, Guilherme Herzog, Henrik Muehe, Ilia Krets, Iris Chu, Juanjo Carin, Kevin Villela, Kristóf Molnár, Lera Kharatyan, Madhura Dudhgaonkar, Marcus Revaj, Nimesh Ghelani, Niranjan Tulpule, Pavel Sychev, Siddhant Sanyam, Stanislav Pyatykh, Stoyan Nikolov, Ugam Kumar, Tobias Welp, Vahid Meimand, Vincent Nguyen, Yurun Shen, and Zoubin Ghahramani. Thanks to Tom Small for creating graphics for this post.</i></p>
    </div>


    
</section>

                    
                </div></div>
  </body>
</html>
