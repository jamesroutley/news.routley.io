<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.redhat.com/sysadmin/speed-containers-podman-raspberry-pi">Original</a>
    <h1>We achieved a 6-fold increase in Podman startup speed</h1>
    
    <div id="readability-page-1" class="page"><div>

  
    

      
            <div property="schema:text"><p>In August 2022, Dan Walsh (one of the authors of this article) moved out of his role as container runtimes architect at Red Hat to architect for the <a href="https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/edge-computing" target="_blank">Red Hat Enterprise Linux (RHEL) for Edge</a> team. Specifically, he has moved to the <a href="https://www.redhat.com/en/blog/new-standard-red-hat-vehicle-operating-system-modern-and-future-vehicles" target="_blank">Red Hat In-Vehicle Operating System (RHIVOS)</a> Containers On Wheels (COW) team.</p>

<p>You might notice some <a href="https://www.redhat.com/en/topics/containers/what-is-podman" target="_blank">Podman</a> enhancements coming directly from the RHIVOS COW team, like <a href="https://www.redhat.com/sysadmin/quadlet-podman" target="_blank">Make systemd better for Podman with Quadlet</a> and <a href="https://www.redhat.com/sysadmin/multi-container-application-podman-quadlet" target="_blank">Deploying a multi-container application using Podman and Quadlet</a>. Alexander Larson, a COW team member, created Quadlet to make running <a href="https://www.redhat.com/en/topics/containers" target="_blank">containers</a> under systemd easier. One of the cornerstones of RHIVOS is using systemd to manage the life cycle of containers created by Podman.</p>

<p><em><strong>[ Download now: <a href="https://developers.redhat.com/cheat-sheets/podman-basics-cheat-sheet?intcmp=701f20000012ngPAAQ" target="_blank">Podman basics cheat sheet</a> ]</strong></em> </p>



<h2>Satisfy the need for speed</h2>

<p>During Podman&#39;s development, as with most container engines, the speed requirements were mainly around pulling container images. Search the internet and you&#39;ll find thousands of discussions on shrinking the size of container images. Pulling images has always been the number 1 complaint when using container engines. No one pays attention if it takes a second or 2 to start a container at the command line or in <a href="https://www.redhat.com/en/topics/containers/what-is-kubernetes" target="_blank">Kubernetes</a>.</p>

<p>When we examine <a href="https://www.redhat.com/en/blog/running-containers-cars" target="_blank">running containers in a car</a>, this equation tips upside down. In a car, most container images are preinstalled and then updated as part of the operating system or at specific times—but not on startup. If a container image will be installed on behalf of a user command, the user must wait while the container downloads. However, applications critical to driving cars aren&#39;t updated in this way.</p>

<p>What is important is the speed at which the applications start. When you turn the key in a car, you expect the applications to be up and running as fast as possible. Some countries enforce a legal requirement that when you put the car into reverse, the backup camera must start within a couple of seconds.</p>

<p>When our team measured the time to start a Podman container on a low-level system (Raspberry Pi), we found it takes almost two seconds just to start the application. If the backup camera or other sensors were to run as containers, we needed to improve the starting speed significantly.</p>

<p>The goal became removing microseconds from the container startup time.</p>

<p>In this article, I cover Podman&#39;s speed—primarily the speed to start a container. The chart below provides an overview of progress. If you absorb nothing else from this article, at least understand what the chart tells you.</p>


<figure><div data-embed-button="media_entity_embed" data-entity-embed-display="view_mode:media.embed_large" data-entity-type="media" data-entity-uuid="8dd0b1c1-6ade-4f2e-bbfd-0f4e18c60930" data-langcode="en" data-entity-embed-display-settings="[]"><div>
  
  
  

</div>
</div>
<figcaption>(Pierre-Yves Chibon, CC BY-SA 4.0)</figcaption></figure><p>The rest of the article explains how we improved Podman&#39;s speed.</p>

<p>One of the first things we did was analyze what happens when Podman starts a container and why it takes so long. It turns out there was a lot of low-hanging fruit.</p>

<h2>Catch the details</h2>

<p>When working with a large codebase with hundreds of contributors, sometimes small inefficiencies get added to the code. Since each one adds only tens of microseconds, they are easy to miss. They just have to be found and fixed by grinding with a profiler.</p>

<p>Here are a few that we addressed:</p>

<ul><li>Don&#39;t unnecessarily do in-depth copies of large structures.</li>
	<li>Use <code>pidfd_open()</code> to avoid sleeping in a loop to wait for process exit.</li>
	<li>Avoid <a href="https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces" target="_blank">APIs</a> that take a long time, such as retrieving the whole system configuration to read a single configuration value, especially when there are simpler ways.</li>
	<li>Properly fix races in image event shutdown routines instead of sleeping 100msec.</li>
	<li>Avoid repeatedly creating the same large data structure, loading it, and sometimes writing it to disk by caching it to memory.</li>
</ul><p><strong><em>[ Get <a href="https://lab.redhat.com/tracks/podman-deploy?intcmp=701f20000012ngPAAQ" target="_blank">hands on with Podman</a> in this tutorial scenario. ]</em></strong></p>

<h2>Compile regular expressions with Go</h2>

<p>Podman is written in <a href="https://www.redhat.com/sysadmin/learn-go-programming" target="_blank">Go</a>. The Go compiler supports initializing variables when they are created in the global state. It is fairly common to initialize regular expressions (regex) globally with code like:</p>

<pre><code>AlphaRegexp := regexp.MustCompile(`[a-zA-Z]`)</code></pre>

<p>If this is done in the global space, then every start of an application pays the price of executing the slow operation of compiling the regex, even when the program never uses this global variable.</p>

<p>Go also encourages the idea of &#34;vendoring,&#34; which allows users to include—or vendor—other people&#39;s code directly into their executable, instead of using shared libraries.</p>

<p>While the compilation might take only a few microseconds, through vendoring and code reuse, we found that same regex-init construct multiple times throughout the code and in many of the vendored sub-libraries. A new package that compiled these variables on demand rather than on initialization eliminated the inadvertent overhead everywhere. We opened multiple pull requests for vendored code to get those teams to remove the global regex compiles.</p>



<h2>Drop virtual networks</h2>

<p>One of the most time-consuming parts of setting up a container is creating the virtual networks. By default, Podman sets up private networking by executing <a href="https://www.redhat.com/sysadmin/podman-new-network-stack" target="_blank">netavark and sometimes aardvark-dns.</a> Just running a sub-program can take some time since the kernel needs to duplicate all of the code and then wait for the program to start. Switching to <code>--network=host</code> to use the host network, or using <code>--network=none</code> if the container does not use the network, greatly sped up the container startup. Since most applications within the car can probably use the host network or don&#39;t need a network, we suggest running with one of these flags.</p>

<h2>Use crun improvements</h2>

<p>Over the years, Giuseppe Scrivano has continuously improved the speed of Podman&#39;s default OCI runtime <a href="https://www.redhat.com/sysadmin/introduction-crun" target="_blank">crun</a>. Runc, a popular alternative OCI runtime written in Go, takes considerably longer to start and uses more resources than <code>crun</code>. Giuseppe wrote an article describing all of the <a href="https://www.redhat.com/sysadmin/speed-oci-containers" target="_blank">crun speedups</a>.</p>

<h2>Precompile seccomp</h2>

<p>Most of the improvements were made over the last few years, but when the COW team got involved, we found that compiling the seccomp rules cost us considerable time. Seccomp rules are usually defined in the <code>/usr/share/containers/seccomp.json</code> file. Almost everyone that runs Podman uses this file, and yet we compile it into BPF bytecode on every container start. crun now uses a precompiled version of the <code>seccomp.json</code> file, if it exists, eliminating the recompilation.</p>

<p>As Giuseppe points out in his article:</p>

<blockquote>
<p>With that in place, the cost of compiling the seccomp profile is paid only when the generated BPF filter is not in the cache. This is what I have now:</p>
</blockquote>

<pre><code># hyperfine &#39;crun-from-the-future run foo&#39;
Benchmark 1: &#39;crun-from-the-future run foo&#39;
Time (mean ± σ): 5.6 ms ± 3.0 ms \[User: 1.0 ms, System: 4.5 ms\]
Range (min … max): 4.2 ms … 26.8 ms 101 runs</code></pre>

<p>This demonstrates considerable improvement from the original 159ms in 2017.</p>

<h2>Execute programs during initialization</h2>

<p>Podman does a series of checks when it starts to figure out what the kernel supports and which <a href="https://opensource.com/article/22/10/osi-model-network-communications" target="_blank">OCI runtime</a> version the system uses. In some cases, this involves a fork or exec of the OCI runtime to check the version. We found it no longer needs to do this and we removed the check, saving startup time.</p>

<h2>Work around kernel issues</h2>

<p>RHIVOS uses a real-time kernel variant that changes some behavior, making container setup slower. In particular, the real-time kernel changes the default behavior of the read-copy-update (RCU) framework. RCU is a kernel synchronization mechanism that avoids the use of lock primitives. Unfortunately, some optimizations in the RCU framework (something called &#34;expedited grace periods&#34;) are not compatible with real-time guarantees, so they are disabled by default on the real-time kernel.</p>

<p>It turns out that these optimizations are important for events during container setup, like mounts, unmounts, and cgroup setup. So container startup on real-time kernels can be quite a lot slower.</p>

<p>You can work around this by using the <code>rcupdate.rcu_normal_after_boot=0</code> kernel option, but this affects real-time guarantees. We are currently working on <a href="https://lore.kernel.org/linux-rt-users/20230119211455.498968-2-echanude@redhat.com/" target="_blank">better fixes for this</a>.</p>

<p><strong><em>[ <a href="https://enterprisersproject.com/kubernetes-everything-you-need-know?intcmp=701f20000012ngPAAQ" target="_blank">Kubernetes: Everything you need to know</a> ]</em></strong></p>

<h2>Use transient storage</h2>

<p>By default, Podman keeps storage on physical partitions in <code>/var/lib/containers</code> for rootful users and <code>$HOME/.local/share/containers</code> for rootless users. When running a container, Podman hits the storage directories with lots of locking operations and often by creating JSON files. These activities involve many writes and kernel syncs, each slowing container startup. Podman also stores its internal database information in the container storage directories.</p>

<p>In RHIVOS, we do not intend to preserve containers over reboot, meaning all containers are destroyed when the car is off. We want to allow container image storage to be permanent but containers to be temporary, so we added the concept of transient storage.</p>

<p>You can see more information about this feature in Podman&#39;s man pages:</p>

<pre><code>$ man podman
...
 --transient-store
    Enables a global transient storage mode where all container metadata is
    stored on non-persistent media (i.e. in the location specified by
    --runroot). This mode allows starting containers faster, as well as
    guaranteeing a fresh state on boot in case of unclean shutdowns or
    other problems. However it is not compatible with a traditional model
    where containers persist across reboots.

    Default value for this is configured in containers-storage.conf(5).

$ man containers-storage.conf
...
    transient_store = &#34;false&#34; | &#34;true&#34;

    Transient store mode makes all container metadata be saved in temporary
    storage (i.e. runroot above). This is faster, but doesn&#39;t persist
    across reboots. Additional garbage collection must also be performed
    at boot-time, so this option should remain disabled in most
    configurations. (default: false)</code></pre>

<p>You can run containers with transient storage by providing the <code>--transient-store</code> command line flag:</p>

<pre><code># podman --transient-store run ubi9 echo hi</code></pre>

<p>This approach is similar to running all your containers with the <code>podman run --rm</code> option. All container locking, reads, and writes, as well as the Podman database, are moved to <code>/run</code>, which is a temporary filesystem (tmpfs). This dramatically increases the speed of starting a container.</p>

<p>Note that you can&#39;t run containers in a mixed mode, where some are transient and others persist. If you are running an <a href="https://www.redhat.com/en/topics/edge-computing/what-is-edge-computing" target="_blank">edge</a> device or server, where the speed of starting containers is critically important and persisting the containers over reboot is not, then using <code>--transient-store</code> is an excellent idea.</p>

<h2>Wrap up</h2>

<p>We continue to work on finding and fixing performance issues in container startup in Podman. At this point, we have successfully improved it from around 2 seconds on the Raspberry Pi to under 0.3 seconds, providing a 6-fold increase in speed.</p>

<p><strong><em>[ Learning path: <a href="https://cloud.redhat.com/learn/getting-started-red-hat-openshift-service-aws-rosa?intcmp=701f20000012ngPAAQ" target="_blank">Getting started with Red Hat OpenShift Service on AWS (ROSA)</a> ] </em></strong></p>
</div>
      
  
  </div></div>
  </body>
</html>
