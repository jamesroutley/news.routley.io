<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.philipzucker.com/unify/">Original</a>
    <h1>Don&#39;t implement unification by recursion</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><a href="https://en.wikipedia.org/wiki/Unification_(computer_science)">Unification</a> is formal methods speak for solving equations.</p>

<p>The most common form of unification discussed is first order syntactic unification. When it succeeds, it solves a pile of equations no matter what the actual functions represent.</p>

<p><code>[exists ?X ?Y] foo(bar(?X)) = foo(?Y)</code> has a solution <code>[forall ?Y ?X] ?Y = bar(?X)</code>. Or <code>cos(sin(?X)) = cos(?Y)</code> has a solution <code>?Y = sin(?X)</code>. From the perspective of first order unification, it doesn’t matter what <code>cos</code> and <code>sin</code> mean.</p>

<p>Actually implementing unification, similar to most other algorithms that manipulate variables, is kind of the bane of my existence. I avoid it at extreme cost.</p>

<p>It is somewhat surprising that unification is cleaner and easier to implement in an loopy imperative mutational style than in a recursive functional pure style. Typically theorem proving / mathematical algorithms are much cleaner in the second style in my subjective opinion. Unification has too much spooky action at a distance, a threaded state, and can usefully use access to the stack in the form a todo queue to canonize it or reorder it.</p>

<p>A recursion form can be convenient if you need to rebuild a term after you’re done doing whatever you’re doing. In the manual todo list form, you’ll need to store a zipper of some kind to replicate that. Unification typically only returns a substitution and not the original inputs terms specialized to the substitution (although this would be useful for critical pairs, narrowing etc). So for unification, this benefit of recursion is not so useful.</p>



<p>Unification can be seen as two sided pattern matching. Pattern matching (like python’s new match-case construct) takes in some tree and allows you to match it against patterns. Patterns maybe contain variables, and when the pattern matches, that branch of the <code>case</code> has the variables bound. Unification allows you to match patterns against patterns. In one possible low level implementation, the variables are refcells. Unification works via pointer manipulation, pointing the refcell to a piece of a tree or another refcell. It’d be neat and possible for a low level language like rust to support pointer based unification as something akin to a match statement. In logic programming languages, we typically have both unification and backtracking. These aren’t intrinsically coupled features.</p>

<p>Anyway, pattern matching is much easier to implement. Let’s take a look to make a point about recursive vs iterative implementations.</p>

<p>Like many algorithms, there is a recursive and iterative version. The iterative version more or less reifies the call stack of the recursive version into a normal data structure, keeping around a queue of thins to do.</p>

<p>You can also choose whether to manipulate the substitution you’re building purely functionally or mutationally.</p>

<div><div><pre><code><span># I&#39;m going to work over the z3py ast, because it&#39;s useful for knuckledragger and it avoids defining some arbitrary ast.
</span><span>from</span> <span>z3</span> <span>import</span> <span>*</span>
<span>def</span> <span>pmatch</span><span>(</span><span>pat</span><span>,</span> <span>t</span><span>):</span>
    <span>subst</span> <span>=</span> <span>{}</span>
    <span>def</span> <span>worker</span><span>(</span><span>pat</span><span>,</span> <span>t</span><span>):</span>
        <span>if</span> <span>is_var</span><span>(</span><span>pat</span><span>):</span>
            <span>if</span> <span>pat</span> <span>in</span> <span>subst</span><span>:</span>
                <span>return</span> <span>subst</span><span>[</span><span>pat</span><span>].</span><span>eq</span><span>(</span><span>t</span><span>)</span>
            <span>else</span><span>:</span>
                <span>subst</span><span>[</span><span>pat</span><span>]</span> <span>=</span> <span>t</span>
                <span>return</span> <span>True</span>
        <span>if</span> <span>is_app</span><span>(</span><span>pat</span><span>):</span>
            <span>if</span> <span>is_app</span><span>(</span><span>t</span><span>)</span> <span>and</span> <span>pat</span><span>.</span><span>decl</span><span>()</span> <span>==</span> <span>t</span><span>.</span><span>decl</span><span>():</span>
                <span>return</span> <span>all</span><span>(</span><span>worker</span><span>(</span><span>pat</span><span>.</span><span>arg</span><span>(</span><span>i</span><span>),</span> <span>t</span><span>.</span><span>arg</span><span>(</span><span>i</span><span>))</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>pat</span><span>.</span><span>num_args</span><span>()))</span>
            <span>return</span> <span>False</span>
    <span>if</span> <span>worker</span><span>(</span><span>pat</span><span>,</span> <span>t</span><span>):</span>
        <span>return</span> <span>subst</span>

<span># I&#39;m sort of abusing z3&#39;s Var here. It&#39;s meant for de bruijn vars
</span><span>x</span><span>,</span><span>y</span><span>,</span><span>z</span> <span>=</span> <span>Var</span><span>(</span><span>0</span><span>,</span><span>IntSort</span><span>()),</span> <span>Var</span><span>(</span><span>1</span><span>,</span><span>IntSort</span><span>()),</span> <span>Var</span><span>(</span><span>2</span><span>,</span><span>IntSort</span><span>())</span>
<span>assert</span> <span>pmatch</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{}</span>
<span>assert</span> <span>pmatch</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>4</span><span>))</span> <span>==</span> <span>None</span>
<span>assert</span> <span>pmatch</span><span>(</span><span>x</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>IntVal</span><span>(</span><span>3</span><span>)}</span>
<span>assert</span> <span>pmatch</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>)</span> <span>+</span> <span>IntVal</span><span>(</span><span>4</span><span>))</span> <span>==</span> <span>None</span>
<span>assert</span> <span>pmatch</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>)</span> <span>+</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>IntVal</span><span>(</span><span>3</span><span>)}</span>
<span>assert</span> <span>pmatch</span><span>(</span><span>x</span> <span>+</span> <span>y</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>)</span> <span>+</span> <span>IntVal</span><span>(</span><span>4</span><span>))</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>y</span> <span>:</span> <span>IntVal</span><span>(</span><span>4</span><span>)}</span>
</code></pre></div></div>

<p>But we can also write this in a loopy todo list form.</p>

<div><div><pre><code><span>from</span> <span>z3</span> <span>import</span> <span>*</span>
<span>def</span> <span>pmatch_loop</span><span>(</span><span>pat</span><span>,</span> <span>t</span><span>):</span>
    <span>subst</span> <span>=</span> <span>{}</span>
    <span>todo</span> <span>=</span> <span>[(</span><span>pat</span><span>,</span> <span>t</span><span>)]</span>
    <span>while</span> <span>todo</span><span>:</span>
        <span>pat</span><span>,</span> <span>t</span> <span>=</span> <span>todo</span><span>.</span><span>pop</span><span>()</span>
        <span>if</span> <span>is_var</span><span>(</span><span>pat</span><span>):</span>
            <span>if</span> <span>pat</span> <span>in</span> <span>subst</span><span>:</span>
                <span>if</span> <span>not</span> <span>subst</span><span>[</span><span>pat</span><span>].</span><span>eq</span><span>(</span><span>t</span><span>):</span>
                    <span>return</span> <span>None</span>
            <span>else</span><span>:</span>
                <span>subst</span><span>[</span><span>pat</span><span>]</span> <span>=</span> <span>t</span>
        <span>elif</span> <span>is_app</span><span>(</span><span>pat</span><span>):</span>
            <span>if</span> <span>not</span> <span>is_app</span><span>(</span><span>t</span><span>)</span> <span>or</span> <span>pat</span><span>.</span><span>decl</span><span>()</span> <span>!=</span> <span>t</span><span>.</span><span>decl</span><span>():</span>
                <span>return</span> <span>None</span>
            <span>todo</span><span>.</span><span>extend</span><span>(</span><span>zip</span><span>(</span><span>pat</span><span>.</span><span>children</span><span>(),</span> <span>t</span><span>.</span><span>children</span><span>()))</span> 
    <span>return</span> <span>subst</span>

<span>assert</span> <span>pmatch_loop</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{}</span>
<span>assert</span> <span>pmatch_loop</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>4</span><span>))</span> <span>==</span> <span>None</span>
<span>assert</span> <span>pmatch_loop</span><span>(</span><span>x</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>IntVal</span><span>(</span><span>3</span><span>)}</span>
<span>assert</span> <span>pmatch_loop</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>)</span> <span>+</span> <span>IntVal</span><span>(</span><span>4</span><span>))</span> <span>==</span> <span>None</span>
<span>assert</span> <span>pmatch_loop</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>)</span> <span>+</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>IntVal</span><span>(</span><span>3</span><span>)}</span>
<span>assert</span> <span>pmatch_loop</span><span>(</span><span>x</span> <span>+</span> <span>y</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>)</span> <span>+</span> <span>IntVal</span><span>(</span><span>4</span><span>))</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>y</span> <span>:</span> <span>IntVal</span><span>(</span><span>4</span><span>)}</span>
</code></pre></div></div>



<p>Unification can be presented as an inference system.</p>

<p>Inference rules as compared to pseudocode are nice sometimes. They make things feel mathier. They can make it clear that there is choice available on how to proceed. If you know prolog, rules are cool in that you can write them down as prolog clauses.</p>

<p>The huge downsides of inference rules is that they are a barrier to entry, and the leap from rules to any sort of implementable algorithm can be very non trivial.</p>

<p>If I write unification with a LIFO queue, FIFO queue or some other ordering, it doesn’t matter much. And this can matter in more complex unification domains  (E-unification and higher order unification) where you can get locally stumped on how to proceed, so it can be fruitful to pick off of you todo list the easiest to solve equation.</p>

<p><img src="https://www.philipzucker.com/assets/traat/unify_rules.png" alt=""/>
from <a href="https://dl.acm.org/doi/10.5555/280474">TRAAT</a> chapter 4</p>

<p><code>delete</code> remove a trivial equation, <code>decompose</code> matches heads and then zips together their children, <code>orient</code> puts variables in the lhs, <code>eliminate</code> takes an equation in solved for and substitues the solution everywhere.</p>

<p>A <code>todo</code> queue is basically our multiset <code>S</code> and we choose a particular order to process the equations.
We end up with something like this.</p>

<div><div><pre><code><span>def</span> <span>occurs</span><span>(</span><span>x</span><span>,</span> <span>t</span><span>):</span>
    <span>if</span> <span>is_var</span><span>(</span><span>t</span><span>):</span>
        <span>return</span> <span>x</span><span>.</span><span>eq</span><span>(</span><span>t</span><span>)</span>
    <span>if</span> <span>is_app</span><span>(</span><span>t</span><span>):</span>
        <span>return</span> <span>any</span><span>(</span><span>occurs</span><span>(</span><span>x</span><span>,</span> <span>t</span><span>.</span><span>arg</span><span>(</span><span>i</span><span>))</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>t</span><span>.</span><span>num_args</span><span>()))</span>
    <span>return</span> <span>False</span>

<span>def</span> <span>unify</span><span>(</span><span>p1</span><span>,</span><span>p2</span><span>):</span>
    <span>subst</span> <span>=</span> <span>{}</span>
    <span>todo</span> <span>=</span> <span>[(</span><span>p1</span><span>,</span><span>p2</span><span>)]</span>
    <span>while</span> <span>todo</span><span>:</span>
        <span>p1</span><span>,</span><span>p2</span> <span>=</span> <span>todo</span><span>.</span><span>pop</span><span>()</span> <span># we could pop _any_ of the todos, not just the top.
</span>        <span>if</span> <span>p1</span><span>.</span><span>eq</span><span>(</span><span>p2</span><span>):</span> <span># delete
</span>            <span>continue</span>
        <span>elif</span> <span>is_var</span><span>(</span><span>p1</span><span>):</span> <span># elim
</span>            <span>if</span> <span>occurs</span><span>(</span><span>p1</span><span>,</span> <span>p2</span><span>):</span>
                <span>return</span> <span>None</span>
            <span>todo</span> <span>=</span> <span>[(</span><span>substitute</span><span>(</span><span>t1</span><span>,(</span><span>p1</span><span>,</span><span>p2</span><span>)),</span> <span>substitute</span><span>(</span><span>t2</span><span>,(</span><span>p1</span><span>,</span><span>p2</span><span>)))</span> <span>for</span> <span>(</span><span>t1</span><span>,</span><span>t2</span><span>)</span> <span>in</span> <span>todo</span><span>]</span>
            <span>subst</span> <span>=</span> <span>{</span><span>k</span> <span>:</span> <span>substitute</span><span>(</span><span>v</span><span>,</span> <span>(</span><span>p1</span><span>,</span><span>p2</span><span>))</span> <span>for</span> <span>k</span><span>,</span><span>v</span> <span>in</span> <span>subst</span><span>.</span><span>items</span><span>()}</span>
            <span>subst</span><span>[</span><span>p1</span><span>]</span> <span>=</span> <span>p2</span>
        <span>elif</span> <span>is_var</span><span>(</span><span>p2</span><span>):</span> <span># orient
</span>            <span>todo</span><span>.</span><span>append</span><span>((</span><span>p2</span><span>,</span><span>p1</span><span>))</span>
        <span>elif</span> <span>is_app</span><span>(</span><span>p1</span><span>):</span> <span># decompose
</span>            <span>if</span> <span>not</span> <span>is_app</span><span>(</span><span>p2</span><span>)</span> <span>or</span> <span>p1</span><span>.</span><span>decl</span><span>()</span> <span>!=</span> <span>p2</span><span>.</span><span>decl</span><span>():</span>
                <span>return</span> <span>None</span>
            <span>todo</span><span>.</span><span>extend</span><span>(</span><span>zip</span><span>(</span><span>p1</span><span>.</span><span>children</span><span>(),</span> <span>p2</span><span>.</span><span>children</span><span>()))</span> 
        <span>else</span><span>:</span>
            <span>raise</span> <span>Exception</span><span>(</span><span>&#34;unexpected case&#34;</span><span>,</span> <span>p1</span><span>,</span> <span>p2</span><span>)</span>
    <span>return</span> <span>subst</span>

<span>x</span><span>,</span><span>y</span><span>,</span><span>z</span> <span>=</span> <span>Var</span><span>(</span><span>0</span><span>,</span><span>IntSort</span><span>()),</span> <span>Var</span><span>(</span><span>1</span><span>,</span><span>IntSort</span><span>()),</span> <span>Var</span><span>(</span><span>2</span><span>,</span><span>IntSort</span><span>())</span>
<span>assert</span> <span>unify</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{}</span>
<span>assert</span> <span>unify</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>4</span><span>))</span> <span>==</span> <span>None</span>
<span>assert</span> <span>unify</span><span>(</span><span>x</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>IntVal</span><span>(</span><span>3</span><span>)}</span>
<span>assert</span> <span>unify</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>y</span><span>}</span>
<span>assert</span> <span>unify</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>y</span> <span>+</span> <span>y</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>y</span><span>}</span>
<span>assert</span> <span>unify</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>y</span> <span>+</span> <span>z</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>y</span><span>,</span> <span>z</span> <span>:</span> <span>y</span><span>}</span>
<span>assert</span> <span>unify</span><span>(</span><span>x</span> <span>+</span> <span>y</span><span>,</span> <span>y</span> <span>+</span> <span>z</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>z</span><span>,</span> <span>y</span> <span>:</span> <span>z</span><span>}</span>
<span>assert</span> <span>unify</span><span>(</span><span>y</span> <span>+</span> <span>z</span><span>,</span> <span>x</span> <span>+</span> <span>y</span><span>)</span> <span>==</span> <span>{</span><span>y</span> <span>:</span> <span>x</span><span>,</span> <span>z</span> <span>:</span> <span>x</span><span>}</span>
<span># non terminating if no occurs check
</span><span>assert</span> <span>unify</span><span>((</span><span>x</span> <span>+</span> <span>x</span><span>)</span> <span>+</span> <span>x</span><span>,</span> <span>x</span> <span>+</span> <span>(</span><span>x</span> <span>+</span> <span>x</span><span>))</span> <span>==</span> <span>None</span>
<span>assert</span> <span>unify</span><span>(</span><span>1</span> <span>+</span> <span>x</span><span>,</span> <span>x</span><span>)</span> <span>==</span> <span>None</span>
</code></pre></div></div>



<p>You can wait to remove the solved for variables from your <code>todo</code> expressions. There is a lot of wasteful passes doing nothing in the eager method where I immediately eliminate <code>x</code> everywhere as soon as it is solved.</p>

<p>The lazy method also becomes basically required if you write in a recursive functional style since you do not have access to the <code>todo</code> queue that is on your call stack.</p>

<p>The lazy method is a bit more confusing IMO.</p>

<p>There is also a choice about whether to canonize your substitutions as you use them. The is the analog of path compression in a union find. You can also choose to keep your substitutions in a triangular form where your substitution mapping is never normalized, but then you need to apply it recursively until a fixed point. This style is made popular by <a href="http://minikanren.org/">minikanren</a>.</p>

<div><div><pre><code><span>def</span> <span>unify_lazy</span><span>(</span><span>p1</span><span>,</span><span>p2</span><span>):</span>
    <span>subst</span> <span>=</span> <span>{}</span>
    <span>todo</span> <span>=</span> <span>[(</span><span>p1</span><span>,</span><span>p2</span><span>)]</span>
    <span>def</span> <span>lookup_var</span><span>(</span><span>v</span><span>):</span>
        <span>while</span> <span>v</span> <span>in</span> <span>subst</span><span>:</span>
            <span>v</span> <span>=</span> <span>subst</span><span>[</span><span>v</span><span>]</span>
        <span>return</span> <span>v</span>
    <span>def</span> <span>lookup_term</span><span>(</span><span>t</span><span>):</span>
        <span>if</span> <span>is_var</span><span>(</span><span>t</span><span>):</span>
            <span>t</span> <span>=</span> <span>lookup_var</span><span>(</span><span>t</span><span>)</span>
        <span>if</span> <span>is_var</span><span>(</span><span>t</span><span>):</span>
            <span>return</span> <span>t</span>
        <span>if</span> <span>is_app</span><span>(</span><span>t</span><span>):</span>
            <span>return</span> <span>t</span><span>.</span><span>decl</span><span>()(</span><span>*</span><span>[</span><span>lookup_term</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>t</span><span>.</span><span>children</span><span>()])</span>
    <span>while</span> <span>todo</span><span>:</span>
        <span>p1</span><span>,</span><span>p2</span> <span>=</span> <span>todo</span><span>.</span><span>pop</span><span>()</span>
        <span>p1</span><span>,</span><span>p2</span> <span>=</span> <span>lookup_term</span><span>(</span><span>p1</span><span>),</span> <span>lookup_term</span><span>(</span><span>p2</span><span>)</span>
        <span>if</span> <span>p1</span><span>.</span><span>eq</span><span>(</span><span>p2</span><span>):</span>
            <span>continue</span>
        <span>elif</span> <span>is_var</span><span>(</span><span>p1</span><span>):</span> <span># elim
</span>            <span>if</span> <span>occurs</span><span>(</span><span>p1</span><span>,</span> <span>p2</span><span>):</span>
                <span>return</span> <span>None</span>
            <span>subst</span><span>[</span><span>p1</span><span>]</span> <span>=</span> <span>p2</span>
        <span>elif</span> <span>is_var</span><span>(</span><span>p2</span><span>):</span> <span># orient
</span>            <span>todo</span><span>.</span><span>append</span><span>((</span><span>p2</span><span>,</span><span>p1</span><span>))</span>
        <span>elif</span> <span>is_app</span><span>(</span><span>p1</span><span>):</span> <span># decompose
</span>            <span>if</span> <span>not</span> <span>is_app</span><span>(</span><span>p2</span><span>)</span> <span>or</span> <span>p1</span><span>.</span><span>decl</span><span>()</span> <span>!=</span> <span>p2</span><span>.</span><span>decl</span><span>():</span>
                <span>return</span> <span>None</span>
            <span>todo</span><span>.</span><span>extend</span><span>(</span><span>zip</span><span>(</span><span>p1</span><span>.</span><span>children</span><span>(),</span> <span>p2</span><span>.</span><span>children</span><span>()))</span> 
        <span>else</span><span>:</span>
            <span>raise</span> <span>Exception</span><span>(</span><span>&#34;unexpected case&#34;</span><span>,</span> <span>p1</span><span>,</span> <span>p2</span><span>)</span>
    <span>return</span> <span>subst</span>

<span>x</span><span>,</span><span>y</span><span>,</span><span>z</span> <span>=</span> <span>Var</span><span>(</span><span>0</span><span>,</span><span>IntSort</span><span>()),</span> <span>Var</span><span>(</span><span>1</span><span>,</span><span>IntSort</span><span>()),</span> <span>Var</span><span>(</span><span>2</span><span>,</span><span>IntSort</span><span>())</span>
<span>assert</span> <span>unify_lazy</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{}</span>
<span>assert</span> <span>unify_lazy</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>4</span><span>))</span> <span>==</span> <span>None</span>
<span>assert</span> <span>unify_lazy</span><span>(</span><span>x</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>IntVal</span><span>(</span><span>3</span><span>)}</span>
<span>assert</span> <span>unify_lazy</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>y</span><span>}</span>
<span>assert</span> <span>unify_lazy</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>y</span> <span>+</span> <span>y</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>y</span><span>}</span>
<span>assert</span> <span>unify_lazy</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>y</span> <span>+</span> <span>z</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>z</span><span>,</span> <span>z</span> <span>:</span> <span>y</span><span>}</span>
<span>assert</span> <span>unify_lazy</span><span>(</span><span>x</span> <span>+</span> <span>y</span><span>,</span> <span>y</span> <span>+</span> <span>z</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>z</span><span>,</span> <span>y</span> <span>:</span> <span>z</span><span>}</span>
<span>assert</span> <span>unify_lazy</span><span>(</span><span>y</span> <span>+</span> <span>z</span><span>,</span> <span>x</span> <span>+</span> <span>y</span><span>)</span> <span>==</span> <span>{</span><span>z</span> <span>:</span> <span>y</span><span>,</span> <span>y</span> <span>:</span> <span>x</span><span>}</span>
<span>assert</span> <span>unify_lazy</span><span>(</span><span>y</span> <span>+</span> <span>z</span><span>,</span> <span>x</span> <span>-</span> <span>y</span><span>)</span> <span>==</span> <span>None</span>
</code></pre></div></div>



<p>Finally here is the recursive form. All the looking up and the laziness is what makes it confusing to me.
This is basically the lazy iterative form turned back into recursion.</p>

<p>Note that we have kind of removed the ability to inspect which equation in our todo to process next. We are forced to pick some order and then maybe retrieve that ordering by some wacky continuation thing or returning frozen constraints or something.</p>

<div><div><pre><code><span>def</span> <span>unify_rec1</span><span>(</span><span>p1</span><span>,</span><span>p2</span><span>,</span> <span>subst</span><span>):</span>
    <span>def</span> <span>lookup_var</span><span>(</span><span>v</span><span>):</span>
        <span>while</span> <span>v</span> <span>in</span> <span>subst</span><span>:</span>
            <span>v</span> <span>=</span> <span>subst</span><span>[</span><span>v</span><span>]</span>
        <span>return</span> <span>v</span>
    <span>def</span> <span>lookup_term</span><span>(</span><span>t</span><span>):</span>
        <span>if</span> <span>is_var</span><span>(</span><span>t</span><span>):</span>
            <span>t</span> <span>=</span> <span>lookup_var</span><span>(</span><span>t</span><span>)</span>
        <span>if</span> <span>is_var</span><span>(</span><span>t</span><span>):</span>
            <span>return</span> <span>t</span>
        <span>if</span> <span>is_app</span><span>(</span><span>t</span><span>):</span>
            <span>return</span> <span>t</span><span>.</span><span>decl</span><span>()(</span><span>*</span><span>[</span><span>lookup_term</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>t</span><span>.</span><span>children</span><span>()])</span>
    <span>p1</span><span>,</span><span>p2</span> <span>=</span> <span>lookup_term</span><span>(</span><span>p1</span><span>),</span> <span>lookup_term</span><span>(</span><span>p2</span><span>)</span>
    <span>if</span> <span>p1</span><span>.</span><span>eq</span><span>(</span><span>p2</span><span>):</span>
        <span>return</span> <span>subst</span>
    <span>elif</span> <span>is_var</span><span>(</span><span>p1</span><span>):</span> <span># elim
</span>        <span>if</span> <span>occurs</span><span>(</span><span>p1</span><span>,</span> <span>p2</span><span>):</span>
            <span>return</span> <span>None</span>
        <span>return</span> <span>{</span><span>**</span><span>subst</span><span>,</span> <span>p1</span> <span>:</span> <span>p2</span><span>}</span>
    <span>elif</span> <span>is_var</span><span>(</span><span>p2</span><span>):</span> <span># orient
</span>        <span>return</span> <span>unify_rec1</span><span>(</span><span>p2</span><span>,</span><span>p1</span><span>,</span> <span>subst</span><span>)</span>
    <span>elif</span> <span>is_app</span><span>(</span><span>p1</span><span>):</span> <span># decompose
</span>        <span>if</span> <span>not</span> <span>is_app</span><span>(</span><span>p2</span><span>)</span> <span>or</span> <span>p1</span><span>.</span><span>decl</span><span>()</span> <span>!=</span> <span>p2</span><span>.</span><span>decl</span><span>():</span>
            <span>return</span> <span>None</span>
        <span>for</span> <span>c</span> <span>in</span> <span>zip</span><span>(</span><span>p1</span><span>.</span><span>children</span><span>(),</span> <span>p2</span><span>.</span><span>children</span><span>()):</span>
            <span>subst</span> <span>=</span> <span>unify_rec1</span><span>(</span><span>c</span><span>[</span><span>0</span><span>],</span> <span>c</span><span>[</span><span>1</span><span>],</span> <span>subst</span><span>)</span>
            <span>if</span> <span>subst</span> <span>is</span> <span>None</span><span>:</span>
                <span>return</span> <span>None</span>
    <span>else</span><span>:</span>
        <span>raise</span> <span>Exception</span><span>(</span><span>&#34;unexpected case&#34;</span><span>,</span> <span>p1</span><span>,</span> <span>p2</span><span>)</span>
    <span>return</span> <span>subst</span>
<span>def</span> <span>unify_rec</span><span>(</span><span>p1</span><span>,</span><span>p2</span><span>):</span>
    <span>return</span> <span>unify_rec1</span><span>(</span><span>p1</span><span>,</span><span>p2</span><span>,{})</span>

<span>x</span><span>,</span><span>y</span><span>,</span><span>z</span> <span>=</span> <span>Var</span><span>(</span><span>0</span><span>,</span><span>IntSort</span><span>()),</span> <span>Var</span><span>(</span><span>1</span><span>,</span><span>IntSort</span><span>()),</span> <span>Var</span><span>(</span><span>2</span><span>,</span><span>IntSort</span><span>())</span>
<span>assert</span> <span>unify_rec</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{}</span>
<span>assert</span> <span>unify_rec</span><span>(</span><span>IntVal</span><span>(</span><span>3</span><span>),</span> <span>IntVal</span><span>(</span><span>4</span><span>))</span> <span>==</span> <span>None</span>
<span>assert</span> <span>unify_rec</span><span>(</span><span>x</span><span>,</span> <span>IntVal</span><span>(</span><span>3</span><span>))</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>IntVal</span><span>(</span><span>3</span><span>)}</span>
<span>assert</span> <span>unify_rec</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>y</span><span>}</span>
<span>assert</span> <span>unify_rec</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>y</span> <span>+</span> <span>y</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>y</span><span>}</span>
<span>assert</span> <span>unify_rec</span><span>(</span><span>x</span> <span>+</span> <span>x</span><span>,</span> <span>y</span> <span>+</span> <span>z</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>y</span><span>,</span> <span>y</span> <span>:</span> <span>z</span><span>}</span>
<span>assert</span> <span>unify_rec</span><span>(</span><span>x</span> <span>+</span> <span>y</span><span>,</span> <span>y</span> <span>+</span> <span>z</span><span>)</span> <span>==</span> <span>{</span><span>x</span> <span>:</span> <span>y</span><span>,</span> <span>y</span> <span>:</span> <span>z</span><span>}</span>
<span>assert</span> <span>unify_rec</span><span>(</span><span>y</span> <span>+</span> <span>z</span><span>,</span> <span>x</span> <span>+</span> <span>y</span><span>)</span> <span>==</span> <span>{</span><span>y</span> <span>:</span> <span>x</span><span>,</span> <span>z</span> <span>:</span> <span>x</span><span>}</span>
</code></pre></div></div>



<p>Thanks to Cody Roux for discussions.</p>

<p>Some unification implementations to compare. I’ve copied some of the relevant bits out far below.</p>

<ul>
  <li>minikanren , microkanren, faster-minikanren</li>
  <li>harrison <a href="https://www.cl.cam.ac.uk/~jrh13/atp/index.html">https://www.cl.cam.ac.uk/~jrh13/atp/index.html</a></li>
  <li>traat <a href="https://www21.in.tum.de/~nipkow/TRaAT/">https://www21.in.tum.de/~nipkow/TRaAT/</a> but it also has pascal</li>
  <li>pyres <a href="https://github.com/eprover/PyRes/blob/master/unification.py">https://github.com/eprover/PyRes/blob/master/unification.py</a></li>
  <li>prover9 - <a href="https://github.com/ai4reason/Prover9/blob/cdca95a51d3c3459b8fd2ebbb5ac1504be2172e3/ladr/unify.c#L345">https://github.com/ai4reason/Prover9/blob/cdca95a51d3c3459b8fd2ebbb5ac1504be2172e3/ladr/unify.c#L345</a></li>
  <li>unification fd <a href="https://hackage.haskell.org/package/unification-fd">https://hackage.haskell.org/package/unification-fd</a></li>
  <li>cody’s</li>
  <li>ocaml-alg <a href="https://github.com/smimram/ocaml-alg/blob/3905b52a90bc6ac7c91054e1f961b8685b77a30a/src/term.ml#L375">https://github.com/smimram/ocaml-alg/blob/3905b52a90bc6ac7c91054e1f961b8685b77a30a/src/term.ml#L375</a></li>
  <li>Graham’s</li>
  <li>eprover <a href="https://github.com/eprover/eprover/blob/ab3ea0835b13553d3872b858e93739c2b1aeb0e6/TERMS/cte_match_mgu_1-1.c#L463">https://github.com/eprover/eprover/blob/ab3ea0835b13553d3872b858e93739c2b1aeb0e6/TERMS/cte_match_mgu_1-1.c#L463</a></li>
  <li>vampire <a href="https://github.com/vprover/vampire/blob/6b4efd08c39a0fdc5b28f266dc6b639e807903d7/Kernel/RobSubstitution.cpp#L266">https://github.com/vprover/vampire/blob/6b4efd08c39a0fdc5b28f266dc6b639e807903d7/Kernel/RobSubstitution.cpp#L266</a></li>
  <li><a href="https://eli.thegreenplace.net/2018/unification/">https://eli.thegreenplace.net/2018/unification/</a></li>
</ul>

<p>I don’t know what I’m doing. Do not take this blog post as gospel.</p>

<p>“Don’t implement unification by recursion” is an aggressive way of saying. It’s more “Consider not using recursion”.</p>

<p>Also it’s nice to have the ability to fail the unification by <code>return None</code> instead of raising an error or option monading it. I have come full circle to “write the fucking loop” I guess. All my beloved functional programming has failed me. My cities in tatters. Sigh.</p>



<p>The pure var to var part of <code>subst</code> is being used as a union find</p>

<p>THis is  the find operation</p>

<div><div><pre><code>    def lookup_var(v):
        while v in subst:
            v = subst[v]
        return v
</code></pre></div></div>

<p>Union finds can be implemented in different styles. An arena style or a refcell/pointer style.</p>



<p><a href="https://en.wikipedia.org/wiki/Occurs_check">https://en.wikipedia.org/wiki/Occurs_check</a></p>

<p>I’m not sure where the idea that the occurs check is the “correct” thing to do and that we only avoid it as a near sighted optimization.</p>

<p>It is an interesting perspective and it is true for things like lists.</p>

<p>There is a related thing to the occurs check, which is correct scoping of forall and exists variables. Curiously, you can make the occurs check deal with this by making all the existential variables in scope parameters to a fresh forall variable in a goal. This is disccussed in the addendum here <a href="https://www.philipzucker.com/harrop-checkpoint/">https://www.philipzucker.com/harrop-checkpoint/</a> and the Otten provers <a href="https://jens-otten.de/tutorial_cade19/">https://jens-otten.de/tutorial_cade19/</a> . The occurs check will then detect an ill scoping. <a href="https://dl.acm.org/doi/pdf/10.1145/66068.66075">https://dl.acm.org/doi/pdf/10.1145/66068.66075</a></p>

<p>But for many other function symbols in the theorem proving context, it is perfectly natural to have a loopy equation. <code>pow(?X, 2) = ?X</code> has the solution of <code>1</code>. It is not an inconsistent thing to ask for. Nor is it an inconsistent universal thing to assert. It is saying multiplication is absorptive, like in boolean algebra.</p>

<p>Also, if we are “scientists” about it, we can take observation it is simpler to just not write the occurs check as evidence that unification is kind of naturally coinductive / loopy / observational / non-well-founded.</p>



<p>An interesting style for doing unification is to maintain two mappings.</p>

<p><code>var -&gt; option obs</code> and a <code>var -&gt; var</code> union find</p>

<p>I discussed this more here. <a href="https://www.philipzucker.com/coegraph/">https://www.philipzucker.com/coegraph/</a></p>

<p>You can process the equations quite lazily. The thing is very uniform. Also you can do bisimulation reduction and “hashcons” equivalent rational terms. The observation table is exactly what you need to do the automata minimization.</p>



<h2 id="inference-rules">Inference Rules</h2>

<p>There are a couple different ways to interpret inference rules into code.</p>

<p>We may have one function that has ~one case per inference rule
Or we may write a function per inference rule
The inference rules may recuyrsively call other inference rules.</p>

<p>We may choose which pieces are inputs and outputs of the rule</p>

<ol>
  <li>Bottom comes in, top comes out</li>
  <li>top comes in, bottoms come out</li>
  <li>some combo of top and bottom come out</li>
</ol>

<div><div><pre><code><span>def</span> <span>delete</span><span>(</span><span>S</span><span>):</span>
    <span>t</span><span>,</span><span>t1</span> <span>=</span> <span>S</span><span>.</span><span>pop</span><span>()</span>
    <span>assert</span> <span>t</span><span>.</span><span>eq</span><span>(</span><span>t1</span><span>)</span>
    <span>return</span> <span>S</span>

<span>def</span> <span>decompose</span><span>(</span><span>S</span><span>):</span>
    <span>t</span><span>,</span><span>t1</span> <span>=</span> <span>S</span><span>.</span><span>pop</span><span>()</span>
    <span>assert</span> <span>is_app</span><span>(</span><span>t</span><span>)</span> <span>and</span> <span>is_app</span><span>(</span><span>t1</span><span>)</span> <span>and</span> <span>t</span><span>.</span><span>decl</span><span>()</span> <span>==</span> <span>t1</span><span>.</span><span>decl</span><span>()</span>
    <span>S</span><span>.</span><span>extend</span><span>(</span><span>zip</span><span>(</span><span>t</span><span>.</span><span>children</span><span>(),</span> <span>t1</span><span>.</span><span>children</span><span>()))</span>
    <span>return</span> <span>S</span>

<span>def</span> <span>orient</span><span>(</span><span>S</span><span>):</span>
    <span>t</span><span>,</span><span>x</span> <span>=</span> <span>S</span><span>.</span><span>pop</span><span>()</span>
    <span>assert</span> <span>is_var</span><span>(</span><span>x</span><span>)</span> <span>and</span> <span>not</span> <span>is_var</span><span>(</span><span>t</span><span>)</span>
    <span>S</span><span>.</span><span>append</span><span>((</span><span>x</span><span>,</span> <span>t</span><span>))</span>

<span>def</span> <span>elim</span><span>(</span><span>S</span><span>):</span>
    <span>x</span><span>,</span><span>t</span> <span>=</span> <span>S</span><span>.</span><span>pop</span><span>()</span>
    <span>S</span> <span>=</span> <span>[</span>    <span>]</span>
    <span>return</span> <span>S</span>

<span># S is a multiset
</span><span>def</span> <span>permute</span><span>(</span><span>S</span><span>,</span> <span>perm</span><span>):</span>
    <span>return</span> <span>[</span><span>S</span><span>[</span><span>perm</span><span>[</span><span>i</span><span>]]</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>S</span><span>))]</span>
</code></pre></div></div>

<h2 id="other-1">other</h2>

<p>I am disturbed by the number of times I’ve already written posts about unification, and yet don’t feel that much wiser</p>

<p>I have no memory of this one <a href="https://www.philipzucker.com/unification-in-julia/">https://www.philipzucker.com/unification-in-julia/</a></p>

<p><a href="https://www.philipzucker.com/resolution1/">https://www.philipzucker.com/resolution1/</a> This was pretty recent. I wrote the same style unification here that I learned from PyRes.</p>

<p>In unification, we talk about “unification variables”. “unification variables”  can really refer to things that are very very different.</p>

<p>In theorem proving, there is both forward inference, deriving new theorems from axioms, or backward inference, breaking down goals into easier goals.</p>

<p>Goals and axioms/theorems are very different. Goals are things we want to show are true. Axioms are things we assert true. Unification variables in goals are implicitly existentially quantifier. Unification variables in axioms are implicitly universally quantified.</p>

<p>In prolog, the variables you enter at the prompt are existentially quantified. The variables in the rules and the answers are universally quantified. Running the prolog program converts these existentially quantified questions into universally quantified answers.</p>

<h2 id="variable-freshening-and-context">variable freshening and context</h2>

<ul>
  <li>Sometimes you want to unify two things where the variables are disjoint even if variable names are shared. This is for example the case when unifying two literals from different clauses, or a prolog goal against a prolog rule head. Just because I wrote <code>foo(Y,X) :- bar(X).</code> under the query <code>?- foo(X, Y)</code> should not imply <code>X = Y</code>. Implicitly there is a binding at the head of the rule <code>forall x y, foo(y,x) :- bar(x).</code>.</li>
  <li>Sometimes you want to unify two things where the variables can overlap. This is what happens when you apply the factoring rule inside a single clause.</li>
</ul>

<p>You can freshen all the variables to turn a routine for the second case into the first. Freshening may be a reason to inlcude an integer id in your variable datatype. Still this is pretty clunky and ugly.</p>

<p>Another option is to pass in two extra ctx parameters to unify and every variable is understood with respect to them. Then the second case comes from the first if the two ctx are aliased.</p>

<p>Python is a very imperative language. It doesn’t have good easy access immutable data structures. Basically making a whole new copy of lists or dicts is the only good option. This also informs what is the easiest style to write.</p>

<p>Substitution mapping considered as rewrite rules.</p>

<p><a href="https://en.wikipedia.org/wiki/Unification_(computer_science)">https://en.wikipedia.org/wiki/Unification_(computer_science)</a></p>

<p><a href="http://www.cs.man.ac.uk/~hoderk/ubench/unification_full.pdf">http://www.cs.man.ac.uk/~hoderk/ubench/unification_full.pdf</a> Comparing Unification Algorithms in First-Order
Theorem Proving</p>

<p><a href="https://users.soe.ucsc.edu/~lkuper/papers/walk.pdf">https://users.soe.ucsc.edu/~lkuper/papers/walk.pdf</a> Efficient representations for triangular substitutions: A comparison in miniKanren</p>

<p><a href="https://www.proquest.com/openview/f8298f16044b130532ceca70ed4d60c2/1?pq-origsite=gscholar&amp;cbl=2026366&amp;diss=y">https://www.proquest.com/openview/f8298f16044b130532ceca70ed4d60c2/1?pq-origsite=gscholar&amp;cbl=2026366&amp;diss=y</a> Automated Theorem Proving in Higher-Order Logic - Bhayat thesis</p>

<p>do on z3</p>

<p><a href="https://www.philipzucker.com/resolution1/">https://www.philipzucker.com/resolution1/</a></p>

<p>E-unificationun
<a href="https://web.archive.org/web/20200211213303id_/https://publikationen.sulb.uni-saarland.de/bitstream/20.500.11880/25047/1/RR_92_01.pdf">https://web.archive.org/web/20200211213303id_/https://publikationen.sulb.uni-saarland.de/bitstream/20.500.11880/25047/1/RR_92_01.pdf</a></p>

<p>HO-unification as a alngague. When you have full HO unfication, do you need prolog search anymore? You already have so much nontdeterminis</p>

<p>uniification  as observation
unification as fixed point - When written as an inference system this espcailly makes sense.</p>

<p>Lazy vs eager substitution in unification</p>

<p>Tringular = Lazy</p>

<p>Eager vs lazy normalization of union find.</p>

<p>Recursive vs loop.
We have access to the “todo” equations in loop form in the form of some kind of stack.</p>

<p>Inference rule form.
I kind of feel like completion you’re moving from E to S, building a valid substitution. E;S.
Inference rule form is closer to loop form. You have access to all of E.
Typical loop form just pops, but you could use a loop to find the next one to deal with.</p>

<p>Logical Form.
Exists([x,y,z], T) == Exist([x,y,z], T)
Exists([], T1 = T2)
ForAll([], ) # rigid.</p>

<p>occursw check vs scope escape. That prolog trick
Just having Exists and ForAll might give you a variation of miller. Ignore lambda?</p>

<div><div><pre><code><span>from</span> <span>dataclass</span> <span>import</span> <span>dataclass</span>
<span>@</span><span>dataclass</span>
<span>class</span> <span>Var</span><span>():</span>
    <span>x</span> <span>:</span> <span>ExprRef</span>
    <span>ctx</span> <span>:</span> <span>Context</span>
    <span>def</span> <span>collect_a</span><span>(</span><span>self</span><span>):</span>
        <span>res</span> <span>=</span> <span>[]</span>
        <span>x</span> <span>=</span> <span>self</span> 
        <span>while</span> <span>x</span> <span>!=</span> <span>None</span><span>:</span>
            <span>if</span> <span>isinstance</span><span>(</span><span>x</span><span>,</span> <span>AVar</span><span>):</span>
                <span>res</span><span>.</span><span>append</span><span>(</span><span>x</span><span>)</span>
            <span>x</span> <span>=</span> <span>x</span><span>.</span><span>ctx</span>
        <span>return</span> <span>res</span>
        
            


<span>class</span> <span>EVar</span><span>(</span><span>Var</span><span>):</span>
    <span>x</span> <span>:</span> <span>ExprRef</span>
    <span>ctx</span> <span>:</span> <span>Context</span>
<span>class</span> <span>AVar</span><span>(</span><span>Var</span><span>):</span>


<span>def</span> <span>unify</span><span>(</span><span>avars</span><span>,</span> <span>edecls</span><span>,</span> <span>p1</span><span>,</span><span>p2</span><span>):</span>
    <span>edecls</span> <span>=</span> <span>[]</span>

    <span>def</span> <span>freshe</span><span>():</span>
        <span>edecl</span> <span>=</span> <span>Function</span><span>(</span><span>&#34;e_&#34;</span><span>,</span> <span>[</span><span>x</span><span>.</span><span>sort</span><span>()</span> <span>for</span> <span>x</span> <span>in</span> <span>avars</span><span>])</span>
        <span>te</span> <span>=</span> <span>edecl</span><span>(</span><span>*</span><span>avars</span><span>)</span>
        <span>substitute_vars</span><span>(</span><span>t</span><span>,</span> <span>te</span><span>)</span>


<span>def</span> <span>unify</span><span>(</span><span>p1</span><span>,</span><span>p2</span> <span>vctx</span><span>):</span>
    <span>subst</span> <span>=</span> <span>{}</span>
    <span>ectx</span> <span>=</span> <span>{}</span>
    <span>todo</span> <span>=</span> <span>[([],</span> <span>p1</span><span>,</span><span>p2</span><span>)]</span>
    <span>while</span> <span>todo</span><span>:</span>
        <span>ctx</span><span>,</span><span>p1</span><span>,</span><span>p2</span> <span>=</span> <span>todo</span><span>.</span><span>pop</span><span>()</span>
        <span>if</span> <span>p1</span><span>.</span><span>eq</span><span>(</span><span>p2</span><span>):</span>
            <span>continue</span>
        <span>if</span> <span>is_quantifier</span><span>(</span><span>p1</span><span>):</span>
            <span>body</span><span>,</span> <span>vs</span> <span>=</span> <span>open_binder</span><span>(</span><span>p1</span><span>)</span>
            <span>if</span> <span>p1</span><span>.</span><span>is_exists</span><span>():</span>
                <span>for</span> <span>v</span> <span>in</span> <span>vs</span><span>:</span>
                    <span>ectx</span><span>[</span><span>v</span><span>]</span> <span>=</span> <span>ctx</span>
                <span>todo</span><span>.</span><span>append</span><span>((</span><span>ctx</span><span>,</span> <span>body</span><span>,</span> <span>p2</span><span>))</span>
            <span>elif</span> <span>p1</span><span>.</span><span>is_forall</span><span>():</span>
                <span>todo</span><span>.</span><span>append</span><span>((</span><span>ctx</span> <span>+</span> <span>vs</span><span>,</span> <span>body</span><span>,</span> <span>p2</span><span>))</span>
            <span>elif</span> <span>p1</span><span>.</span><span>is_lambda</span><span>():</span>
                <span>todo</span><span>.</span><span>append</span><span>((</span><span>ctx</span> <span>+</span> <span>vs</span><span>,</span> <span>body</span><span>,</span> <span>p2</span><span>))</span>
        <span>elif</span> <span>is_var</span><span>(</span><span>p1</span><span>):</span>
            <span>todo</span> <span>=</span> <span>[(</span><span>substitute</span><span>(</span><span>t1</span><span>,(</span><span>p1</span><span>,</span><span>p2</span><span>)),</span> <span>substitute</span><span>(</span><span>t2</span><span>,(</span><span>p1</span><span>,</span><span>p2</span><span>)))</span> <span>for</span> <span>(</span><span>t1</span><span>,</span><span>t2</span><span>)</span> <span>in</span> <span>todo</span><span>]</span>
            <span>subst</span> <span>=</span> <span>{</span><span>k</span> <span>:</span> <span>substitute</span><span>(</span><span>v</span><span>,</span> <span>(</span><span>p1</span><span>,</span><span>p2</span><span>))</span> <span>for</span> <span>k</span><span>,</span><span>v</span> <span>in</span> <span>subst</span><span>.</span><span>items</span><span>()}</span>
            <span>subst</span><span>[</span><span>p1</span><span>]</span> <span>=</span> <span>p2</span>
        <span>elif</span> <span>is_var</span><span>(</span><span>p2</span><span>):</span>
            <span>todo</span><span>.</span><span>append</span><span>((</span><span>ctx</span><span>,</span><span>p2</span><span>,</span><span>p1</span><span>))</span>
        <span>elif</span> <span>is_app</span><span>(</span><span>p1</span><span>):</span>
            <span>if</span> <span>not</span> <span>is_app</span><span>(</span><span>p2</span><span>)</span> <span>or</span> <span>p1</span><span>.</span><span>decl</span><span>()</span> <span>!=</span> <span>p2</span><span>.</span><span>decl</span><span>():</span>
                <span>return</span> <span>None</span>
            <span>todo</span><span>.</span><span>extend</span><span>(</span><span>zip</span><span>(</span><span>p1</span><span>.</span><span>children</span><span>(),</span> <span>p2</span><span>.</span><span>children</span><span>()))</span> 
        <span>else</span><span>:</span>
            <span>raise</span> <span>Exception</span><span>(</span><span>&#34;unexpected case&#34;</span><span>,</span> <span>p1</span><span>,</span> <span>p2</span><span>)</span>
    <span>return</span> <span>subst</span>

<span>def</span> <span>unify</span><span>(</span><span>p1</span><span>,</span><span>p2</span><span>,</span> <span>vctx</span><span>):</span>
    <span>subst</span> <span>=</span> <span>{}</span>
    <span>todo</span> <span>=</span> <span>[(</span><span>p1</span><span>,</span><span>p2</span><span>)]</span>
    <span>while</span> <span>todo</span><span>:</span>
        <span>p1</span><span>,</span><span>p2</span> <span>=</span> <span>todo</span><span>.</span><span>pop</span><span>()</span>
        <span>if</span> <span>p1</span><span>.</span><span>eq</span><span>(</span><span>p2</span><span>):</span>
            <span>continue</span>
        <span>elif</span> <span>is_var</span><span>(</span><span>p1</span><span>):</span>
            <span>if</span> <span># do &#34;occurs&#34;
</span>                <span>in</span> <span>vctx</span><span>[</span><span>p1</span><span>]</span> <span># narrow the contx  of any var in rhs.
</span>            <span>todo</span> <span>=</span> <span>[(</span><span>substitute</span><span>(</span><span>t1</span><span>,(</span><span>p1</span><span>,</span><span>p2</span><span>)),</span> <span>substitute</span><span>(</span><span>t</span>
                                                        
<span>def</span> <span>unify_miller</span><span>(</span><span>p1</span><span>,</span><span>p2</span><span>,</span> <span>vs</span><span>):</span>
    <span>if</span> <span>p1</span><span>.</span><span>decl</span><span>()</span> <span>in</span> <span>vs</span><span>:</span> <span># is_var
</span>        
        <span>#substitute(   p1.children(),  
</span>        <span># abstract out children
</span>        <span>subst</span><span>[</span><span>p1</span><span>.</span><span>decl</span><span>()]</span> <span>=</span> <span>Lambda</span><span>(</span><span>freshes</span><span>,</span> <span>substitute</span><span>(</span><span>p1</span><span>,</span> <span>zip</span><span>(</span><span>p1</span><span>.</span><span>children</span><span>(),</span> <span>freshes</span><span>)))</span>
        <span>t</span> <span>=</span> <span>Lambda</span><span>(</span><span>freshes</span><span>,</span> <span>substitute</span><span>(</span><span>p1</span><span>,</span> <span>zip</span><span>(</span><span>p1</span><span>.</span><span>children</span><span>(),</span> <span>freshes</span><span>)))</span>
        <span>check_no_escape</span><span>(</span><span>t</span><span>)</span>
        <span>todo</span> <span>=</span> <span>[</span>  <span>,</span> <span>substitute</span><span>(</span><span>p1</span><span>)]</span>
        <span>subst</span><span>[</span><span>p1</span><span>.</span><span>decl</span><span>()]</span> <span>=</span> <span>t</span>
    <span>todo</span> <span>=</span> <span>[]</span>
    <span>noescape</span> <span>=</span> <span>[]</span>
    <span>if</span> <span>is_quantifier</span><span>(</span><span>p1</span><span>)</span>
        <span>if</span> <span>is_quantifier</span><span>(</span><span>p2</span><span>)</span> <span>and</span> <span>p1</span><span>.</span><span>num_vars</span><span>()</span> <span>==</span> <span>p2</span><span>.</span><span>num_vars</span><span>()</span> <span>and</span> <span># sorts:
</span>            <span>body</span><span>,</span> <span>vs</span> <span>=</span> <span>open_binder</span><span>(</span><span>p1</span><span>)</span>
            <span>noescape</span> <span>+=</span> <span>vs</span>
            <span>body2</span> <span>=</span> <span>instantiate</span><span>(</span><span>p2</span><span>,</span> <span>vs</span><span>)</span>
            <span>todo</span><span>.</span><span>append</span><span>((</span><span>body</span><span>,</span><span>body2</span><span>))</span>


<span>Exisst</span> <span>x</span><span>,</span> <span>p</span><span>(</span><span>x</span><span>)</span> <span>=</span> <span>exists</span> <span>y</span><span>,</span> <span>p</span><span>(</span><span>y</span><span>)</span> <span># I guess we could allow this? Kind of odd
</span><span>ex</span><span>(</span><span>lam</span> <span>x</span><span>,</span> <span>p</span><span>(</span><span>x</span><span>))</span>
<span>all</span><span>(</span><span>lam</span> <span>x</span><span>,</span> <span>p</span><span>(</span><span>x</span><span>))</span> <span># all is basically treated as a lambda.
</span>
</code></pre></div></div>

<hr/>
<p>{ex x  f = ex y g} ==&gt;</p>

<hr/>
<p>{all x, f = all x, g} ==&gt;</p>

<hr/>
<p>{lam x. f = lam x. g} ==&gt;</p>



<p>Unification is useful for question asking (exists)
and for inferring new facts</p>

<p>questions ~ goals ~ queries ~ BoolRef ~ typed at prolog repl ~ prolog call
answers ~ solutions ~ Proof ~ returned to prolog repl ~ prolog return</p>

<p>questions can be forall or exists
answers can also be forall or exists</p>

<div><div><pre><code><span>def</span> <span>unify_generalized</span><span>(</span><span>t</span><span>):</span>
    <span>&#34;&#34;&#34;
    Miller nadathur book
    alternatig quatifiers then conjuction of equations
    Q Q Q Q Q (t1 =t2 /\ t3 = t4 /\ t5 = t6 /\ t7 = t8 /\ t9 = t10)

    &#34;&#34;&#34;</span>
    <span>vars</span> <span>=</span> <span>[]</span>
    <span>while</span> <span>is_quantifier</span><span>(</span><span>t</span><span>)</span>
        <span>vars</span><span>.</span><span>append</span><span>(</span><span>t</span><span>.</span><span>vars</span><span>)</span>
        <span>t</span> <span>=</span> <span>body</span><span>()</span>
    <span>todo</span> <span>=</span> <span>[</span><span>t</span><span>]</span>
    <span>eqs</span> <span>=</span> <span>[]</span>
    <span>while</span> <span>todo</span><span>:</span>
        <span>t</span> <span>=</span> <span>todo</span><span>.</span><span>pop</span><span>()</span>
        <span>if</span> <span>is_eq</span><span>(</span><span>t</span><span>):</span>
            <span>eqs</span><span>.</span><span>append</span><span>(</span><span>t</span><span>)</span>
        <span>elif</span> <span>is_conj</span><span>(</span><span>t</span><span>):</span>
            <span>todo</span><span>.</span><span>extend</span><span>(</span><span>t</span><span>.</span><span>children</span><span>())</span>
        <span>else</span><span>:</span>
            <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;not a conjunction of equations&#34;</span><span>)</span>
    <span>subst</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>eq</span> <span>in</span> <span>eqs</span><span>:</span>
        <span>if</span> <span>eq</span><span>.</span><span>lhs</span> <span>in</span> <span>subst</span><span>:</span>
            <span>if</span> <span>subst</span><span>[</span><span>eq</span><span>.</span><span>lhs</span><span>]</span> <span>!=</span> <span>eq</span><span>.</span><span>rhs</span><span>:</span>
                <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;inconsistent equations&#34;</span><span>)</span>
            <span># scope check
</span>        <span>else</span><span>:</span>
            <span>subst</span><span>[</span><span>eq</span><span>.</span><span>lhs</span><span>]</span> <span>=</span> <span>eq</span><span>.</span><span>rhs</span>

    
</code></pre></div></div>

<div><div><pre><code><span>def</span> <span>unify_prove</span><span>(</span><span>t</span> <span>:</span> <span>z3</span><span>.</span><span>BoolRef</span><span>):</span>
    <span>&#34;&#34;&#34;
    request an exists formula
    return a forall _Proof_.
    &#34;&#34;&#34;</span>
    <span>if</span> <span>is_quantifier</span><span>(</span><span>t</span><span>):</span>
        <span>assert</span> <span>t</span><span>.</span><span>is_exists</span><span>():</span>
    

<span>def</span> <span>unify_resolve</span><span>(</span><span>q</span> <span>:</span> <span>kd</span><span>.</span><span>Proof</span><span>,</span> <span>t</span> <span>:</span> <span>kd</span><span>.</span><span>Proof</span><span>):</span>
    <span># Take two forall proofs q and t, and return a proof of the resolution of q and t
</span>    <span># forall forall -&gt; forall
</span><span>def</span> <span>unify_apply</span><span>(</span><span>t</span> <span>:</span> <span>BoolRef</span><span>,</span> <span>t</span> <span>:</span> <span>kd</span><span>.</span><span>Proof</span><span>):</span>
    <span># exist goal + forall proof -&gt; (exist goal&#39;, Proof of exists goal&#39; -&gt; exists goal)
</span>    <span># can just use matching?
</span>    <span># forall goal + forall proof -&gt; (forall goal&#39;, Proof of forall (goal&#39; -&gt; goal)
</span>

</code></pre></div></div>

<div><div><pre><code><span>from</span> <span>z3</span> <span>import</span> <span>*</span>

<span>def</span> <span>subterms</span><span>(</span><span>t</span><span>):</span>
    <span>ts</span> <span>=</span> <span>set</span><span>(</span><span>t</span><span>)</span>
    <span>for</span> <span>c</span> <span>in</span> <span>t</span><span>.</span><span>children</span><span>():</span>
        <span>ts</span> <span>|=</span> <span>subterms</span><span>(</span><span>c</span><span>)</span>
    <span>return</span> <span>ts</span>

<span>def</span> <span>unify</span><span>(</span><span>t1</span> <span>:</span> <span>ExprRef</span><span>,</span> <span>t2</span> <span>:</span> <span>ExprRef</span><span>,</span> <span>subst</span><span>,</span> <span>vs</span><span>):</span>
    <span>if</span> <span>t1</span><span>.</span><span>eq</span><span>(</span><span>t2</span><span>):</span>
        <span>return</span>
    <span>if</span> <span>t2</span> <span>in</span> <span>vs</span><span>:</span>
        <span>t2</span><span>,</span> <span>t1</span> <span>=</span> <span>t1</span><span>,</span> <span>t2</span>
    <span>if</span> <span>t1</span> <span>in</span> <span>vs</span><span>:</span>
        <span>if</span> <span>t1</span> <span>in</span> <span>subst</span><span>:</span>
            <span>unify</span><span>(</span><span>subst</span><span>[</span><span>t1</span><span>],</span> <span>t2</span><span>,</span> <span>subst</span><span>,</span> <span>vs</span><span>)</span>
        <span>else</span><span>:</span>
            <span>if</span> <span>t1</span> <span>in</span> <span>subterms</span><span>(</span><span>t2</span><span>):</span> <span># occurs
</span>                <span>raise</span> <span>Exception</span><span>(</span><span>&#34;Unification failed&#34;</span><span>)</span>
            <span>subst</span> <span>=</span> <span>{</span><span>i</span> <span>:</span> <span>substitute</span><span>(</span><span>k</span><span>,</span> <span>t1</span><span>,</span> <span>t2</span><span>)</span> <span>for</span> <span>i</span><span>,</span><span>k</span> <span>in</span> <span>subst</span><span>.</span><span>items</span><span>()}</span> <span># eager subst. Oh but I can&#39;t normalize all my terms too
</span>            <span>subst</span><span>[</span><span>t1</span><span>]</span> <span>=</span> <span>t2</span>
    <span>else</span><span>:</span>
        <span>if</span> <span>t1</span><span>.</span><span>decl</span><span>()</span> <span>==</span> <span>t2</span><span>.</span><span>decl</span><span>():</span>
            <span>for</span>  <span>c1</span><span>,</span><span>c2</span> <span>in</span> <span>zip</span><span>(</span><span>t1</span><span>.</span><span>children</span><span>(),</span> <span>t2</span><span>.</span><span>children</span><span>()):</span>
                <span>unify</span><span>(</span><span>c1</span><span>,</span> <span>c2</span><span>,</span> <span>subst</span><span>,</span> <span>vs</span><span>)</span>
        <span>else</span><span>:</span>
            <span>raise</span> <span>Exception</span><span>(</span><span>&#34;Unification failed&#34;</span><span>)</span>
    <span>else</span><span>:</span>
        <span>raise</span> <span>Exception</span><span>(</span><span>&#34;Unification failed&#34;</span><span>)</span>
    

<span>unify</span><span>()</span>

</code></pre></div></div>

<div><div><pre><code><span>type</span><span>(</span><span>Var</span><span>(</span><span>0</span><span>,</span> <span>StringSort</span><span>()))</span>
<span>x</span> <span>=</span> <span>Int</span><span>(</span><span>&#39;x&#39;</span><span>)</span>
<span>is_app</span><span>(</span><span>x</span><span>)</span>
</code></pre></div></div>



<div><div><pre><code><span>from</span> <span>z3</span> <span>import</span> <span>*</span>
<span>def</span> <span>z3_match</span><span>(</span><span>t</span> <span>:</span> <span>ExprRef</span><span>,</span> <span>pat</span> <span>:</span> <span>ExprRef</span><span>)</span> <span>-&gt;</span> <span>dict</span><span>[</span><span>z3</span><span>.</span><span>ExprRef</span><span>,</span> <span>z3</span><span>.</span><span>ExprRef</span><span>]:</span>
    <span>&#34;&#34;&#34;
    Pattern match t against pat. Variables are constructed as `z3.Var(i, sort)`.
    Returns substitution dict if match succeeds.
    Returns None if match fails.
    Outer quantifier (Exists, ForAll, Lambda) in pat is ignored.
    &#34;&#34;&#34;</span>
    <span>if</span> <span>z3</span><span>.</span><span>is_quantifier</span><span>(</span><span>pat</span><span>):</span>
        <span>pat</span> <span>=</span> <span>pat</span><span>.</span><span>body</span><span>()</span>
    <span>subst</span> <span>=</span> <span>{}</span>
    <span>todo</span> <span>=</span> <span>[(</span><span>t</span><span>,</span><span>pat</span><span>)]</span>
    <span>while</span> <span>len</span><span>(</span><span>todo</span><span>)</span> <span>&gt;</span> <span>0</span><span>:</span>
        <span>t</span><span>,</span><span>pat</span>  <span>=</span> <span>todo</span><span>.</span><span>pop</span><span>()</span>
        <span>if</span> <span>t</span><span>.</span><span>eq</span><span>(</span><span>pat</span><span>):</span>
            <span>continue</span>
        <span>if</span> <span>z3</span><span>.</span><span>is_var</span><span>(</span><span>pat</span><span>):</span>
            <span>if</span> <span>pat</span> <span>in</span> <span>subst</span><span>:</span>
                <span>if</span> <span>not</span> <span>subst</span><span>[</span><span>pat</span><span>].</span><span>eq</span><span>(</span><span>t</span><span>):</span>
                    <span>return</span> <span>None</span>
            <span>else</span><span>:</span>
                <span>subst</span><span>[</span><span>pat</span><span>]</span> <span>=</span> <span>t</span>
        <span>elif</span> <span>z3</span><span>.</span><span>is_app</span><span>(</span><span>t</span><span>)</span> <span>and</span> <span>z3</span><span>.</span><span>is_app</span><span>(</span><span>pat</span><span>):</span>
            <span>if</span> <span>pat</span><span>.</span><span>decl</span><span>()</span> <span>==</span> <span>t</span><span>.</span><span>decl</span><span>():</span>
                <span>todo</span><span>.</span><span>extend</span><span>(</span><span>zip</span><span>(</span><span>t</span><span>.</span><span>children</span><span>(),</span> <span>pat</span><span>.</span><span>children</span><span>()))</span>
            <span>else</span><span>:</span>
                <span>return</span> <span>None</span>
        <span>else</span><span>:</span>
            <span>raise</span> <span>Exception</span><span>(</span><span>&#34;Unexpected subterm or subpattern&#34;</span><span>,</span> <span>t</span><span>,</span> <span>pat</span><span>)</span>
    <span>return</span> <span>subst</span>
<span># not worth doing
</span><span>def</span> <span>match_quant</span><span>(</span><span>t</span><span>,</span><span>p</span><span>):</span>
    <span>if</span> <span>is_quantifier</span><span>(</span><span>p</span><span>):</span>
        <span>return</span> <span>z3_match</span><span>(</span><span>t</span><span>,</span><span>p</span><span>.</span><span>body</span><span>())</span>
    <span>else</span><span>:</span>
        <span>raise</span> <span>Exception</span><span>(</span><span>&#34;Not a quantifier&#34;</span><span>)</span>
<span>R</span> <span>=</span> <span>RealSort</span><span>()</span>
<span>x</span><span>,</span><span>y</span><span>,</span><span>z</span> <span>=</span> <span>Reals</span><span>(</span><span>&#39;x y z&#39;</span><span>)</span>
<span>z3_match</span><span>(</span><span>x</span><span>,</span> <span>Var</span><span>(</span><span>0</span><span>,</span> <span>R</span><span>))</span>
<span>pmatch</span><span>(</span><span>x</span> <span>+</span> <span>y</span><span>,</span> <span>Var</span><span>(</span><span>0</span><span>,</span> <span>R</span><span>)</span> <span>+</span> <span>Var</span><span>(</span><span>1</span><span>,</span> <span>R</span><span>))</span>
<span>pmatch</span><span>(</span><span>x</span> <span>+</span> <span>y</span><span>,</span> <span>Var</span><span>(</span><span>0</span><span>,</span> <span>R</span><span>)</span> <span>+</span> <span>Var</span><span>(</span><span>1</span><span>,</span> <span>R</span><span>)</span> <span>+</span> <span>Var</span><span>(</span><span>2</span><span>,</span> <span>R</span><span>))</span>
<span>pmatch</span><span>(</span><span>x</span> <span>+</span> <span>y</span> <span>+</span> <span>x</span><span>,</span> <span>Var</span><span>(</span><span>0</span><span>,</span> <span>R</span><span>)</span> <span>+</span> <span>Var</span><span>(</span><span>1</span><span>,</span> <span>R</span><span>)</span> <span>+</span> <span>Var</span><span>(</span><span>0</span><span>,</span> <span>R</span><span>))</span>
<span>pmatch</span><span>(</span><span>x</span> <span>+</span> <span>y</span> <span>+</span> <span>x</span><span>*</span><span>6</span><span>,</span> <span>Var</span><span>(</span><span>0</span><span>,</span> <span>R</span><span>)</span> <span>+</span> <span>Var</span><span>(</span><span>1</span><span>,</span> <span>R</span><span>)</span> <span>+</span> <span>Var</span><span>(</span><span>2</span><span>,</span> <span>R</span><span>))</span>

<span>match_quant</span><span>(</span><span>x</span> <span>+</span> <span>y</span> <span>+</span> <span>x</span><span>*</span><span>6</span> <span>==</span> <span>0</span><span>,</span> <span>ForAll</span><span>([</span><span>x</span><span>,</span><span>y</span><span>,</span><span>z</span><span>],</span> <span>x</span> <span>+</span> <span>y</span> <span>+</span> <span>z</span> <span>==</span> <span>0</span><span>))</span>

<span># If I wanted deeper matching into binders, then what?
</span></code></pre></div></div>

<div><div><pre><code>{Var(0): x*6, Var(1): y, Var(2): x}
</code></pre></div></div>



<div><div><pre><code><span># E-unification Egraph Style
</span><span>from</span> <span>dataclasses</span> <span>import</span> <span>dataclass</span>
<span>from</span> <span>typing</span> <span>import</span> <span>Any</span>
<span>@</span><span>dataclass</span>
<span>class</span> <span>Unify</span><span>():</span>
    <span>uf</span><span>:</span> <span>list</span><span>[</span><span>int</span><span>]</span>
    <span>obs</span><span>:</span> <span>dict</span><span>[</span><span>int</span><span>,</span> <span>tuple</span><span>[</span><span>Any</span><span>,</span> <span>tuple</span><span>[</span><span>int</span><span>]]]</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>uf</span> <span>=</span> <span>[]</span>
        <span>self</span><span>.</span><span>obs</span> <span>=</span> <span>{}</span>
    <span>def</span> <span>make_var</span><span>(</span><span>self</span><span>):</span>
        <span>v</span> <span>=</span> <span>len</span><span>(</span><span>self</span><span>.</span><span>uf</span><span>)</span>
        <span>self</span><span>.</span><span>uf</span><span>.</span><span>append</span><span>(</span><span>v</span><span>)</span>
        <span>return</span> <span>v</span>
    <span>def</span> <span>add_term</span><span>(</span><span>self</span><span>,</span> <span>t</span><span>):</span>
        <span># try to check for rationality?
</span>        <span>if</span> <span>isinstance</span><span>(</span><span>t</span><span>,</span> <span>int</span><span>):</span>
            <span>return</span> <span>t</span>
        <span>head</span><span>,</span> <span>*</span><span>args</span> <span>=</span> <span>t</span>
        <span>args</span> <span>=</span> <span>tuple</span><span>(</span><span>self</span><span>.</span><span>add_term</span><span>(</span><span>arg</span><span>)</span> <span>for</span> <span>arg</span> <span>in</span> <span>args</span><span>)</span>
        <span># we&#39;re not interning at all here, which is fine but inefficient.
</span>        <span>x</span> <span>=</span> <span>self</span><span>.</span><span>make_var</span><span>()</span> 
        <span>self</span><span>.</span><span>observe</span><span>(</span><span>x</span><span>,</span> <span>(</span><span>head</span><span>,</span> <span>args</span><span>))</span>
        <span>return</span> <span>x</span>
    <span>def</span> <span>find</span><span>(</span><span>self</span><span>,</span> <span>x</span><span>):</span>
        <span>while</span> <span>self</span><span>.</span><span>uf</span><span>[</span><span>x</span><span>]</span> <span>!=</span> <span>x</span><span>:</span>
            <span>x</span> <span>=</span> <span>self</span><span>.</span><span>uf</span><span>[</span><span>x</span><span>]</span>
        <span>return</span> <span>x</span>
    <span>def</span> <span>union</span><span>(</span><span>self</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>):</span>
        <span>x</span> <span>=</span> <span>self</span><span>.</span><span>find</span><span>(</span><span>x</span><span>)</span>
        <span>y</span> <span>=</span> <span>self</span><span>.</span><span>find</span><span>(</span><span>y</span><span>)</span>
        <span>self</span><span>.</span><span>uf</span><span>[</span><span>x</span><span>]</span> <span>=</span> <span>y</span>
        <span>return</span> <span>y</span>
    <span>def</span> <span>merge_obs</span><span>(</span><span>self</span><span>,</span> <span>obs</span><span>,</span> <span>obs1</span><span>):</span> <span># unify_flat
</span>        <span>head</span><span>,</span> <span>args</span> <span>=</span> <span>obs</span>
        <span>head1</span><span>,</span> <span>args1</span> <span>=</span> <span>obs1</span>
        <span>if</span> <span>head</span> <span>!=</span> <span>head1</span><span>:</span>
            <span>raise</span> <span>Exception</span><span>(</span><span>&#34;head mismatch&#34;</span><span>)</span>
        <span>if</span> <span>len</span><span>(</span><span>args</span><span>)</span> <span>!=</span> <span>len</span><span>(</span><span>args1</span><span>):</span>
            <span>raise</span> <span>Exception</span><span>(</span><span>&#34;arity mismatch&#34;</span><span>)</span>
        <span>for</span> <span>a</span><span>,</span><span>a1</span> <span>in</span> <span>zip</span><span>(</span><span>args</span><span>,</span> <span>args1</span><span>):</span>
            <span>self</span><span>.</span><span>union</span><span>(</span><span>a</span><span>,</span><span>a1</span><span>)</span>
    <span>def</span> <span>observe</span><span>(</span><span>self</span><span>,</span> <span>x</span><span>,</span> <span>obs</span><span>):</span>
        <span>x</span> <span>=</span> <span>self</span><span>.</span><span>find</span><span>(</span><span>x</span><span>)</span>
        <span>o</span> <span>=</span> <span>self</span><span>.</span><span>obs</span><span>.</span><span>get</span><span>(</span><span>x</span><span>)</span>
        <span>if</span> <span>o</span> <span>!=</span> <span>None</span><span>:</span>
            <span>self</span><span>.</span><span>merge_obs</span><span>(</span><span>o</span><span>,</span> <span>obs</span><span>)</span>
        <span>self</span><span>.</span><span>obs</span><span>[</span><span>x</span><span>]</span> <span>=</span> <span>obs</span>
    <span>def</span> <span>extract</span><span>(</span><span>self</span><span>,</span><span>x</span><span>):</span>
        <span># assuming a well founded term. Could extract the rational term?
</span>        <span>x</span> <span>=</span> <span>self</span><span>.</span><span>find</span><span>(</span><span>x</span><span>)</span>
        <span>f</span> <span>=</span> <span>self</span><span>.</span><span>obs</span><span>.</span><span>get</span><span>(</span><span>x</span><span>)</span>
        <span>if</span> <span>f</span> <span>==</span> <span>None</span><span>:</span>
            <span>return</span> <span>x</span>
        <span>else</span><span>:</span>
            <span>head</span><span>,</span> <span>args</span> <span>=</span> <span>f</span>
            <span>return</span> <span>(</span><span>head</span><span>,</span> <span>*</span><span>[</span><span>self</span><span>.</span><span>extract</span><span>(</span><span>a</span><span>)</span> <span>for</span> <span>a</span> <span>in</span> <span>args</span><span>])</span>
    <span>def</span> <span>rebuild</span><span>(</span><span>self</span><span>):</span>
        <span>while</span> <span>True</span><span>:</span>
            <span>newobs</span> <span>=</span> <span>{}</span>
            <span># &#34;unobserved&#34; vars aren&#39;t be merged. unobserved is actually Maximally observed, i.e. has identity.
</span>            <span>for</span> <span>x</span><span>,</span><span>obs</span> <span>in</span> <span>self</span><span>.</span><span>obs</span><span>.</span><span>items</span><span>():</span>
                <span>x1</span> <span>=</span> <span>self</span><span>.</span><span>find</span><span>(</span><span>x</span><span>)</span>
                <span>obs1</span> <span>=</span> <span>self</span><span>.</span><span>obs</span><span>.</span><span>get</span><span>(</span><span>x1</span><span>)</span>
                <span>if</span> <span>obs1</span> <span>!=</span> <span>None</span><span>:</span>
                    <span>self</span><span>.</span><span>merge_obs</span><span>(</span><span>obs</span><span>,</span> <span>obs1</span><span>)</span>
                <span>(</span><span>head</span><span>,</span> <span>args</span><span>)</span> <span>=</span> <span>obs</span>
                <span>newobs</span><span>[</span><span>x1</span><span>]</span> <span>=</span> <span>(</span><span>head</span><span>,</span> <span>tuple</span><span>(</span><span>map</span><span>(</span><span>self</span><span>.</span><span>find</span><span>,</span> <span>args</span><span>)))</span>
            <span>if</span> <span>self</span><span>.</span><span>obs</span> <span>==</span> <span>newobs</span><span>:</span>
                <span>break</span>
            <span>self</span><span>.</span><span>obs</span> <span>=</span> <span>newobs</span>

<span>U</span> <span>=</span> <span>Unify</span><span>()</span>
<span>x</span> <span>=</span> <span>U</span><span>.</span><span>make_var</span><span>()</span>
<span>y</span> <span>=</span> <span>U</span><span>.</span><span>make_var</span><span>()</span>
<span>z</span> <span>=</span> <span>U</span><span>.</span><span>make_var</span><span>()</span>
<span>print</span><span>(</span><span>U</span><span>)</span>
<span>#U.union(x,y)
</span><span>a_x</span> <span>=</span> <span>U</span><span>.</span><span>add_term</span><span>((</span><span>&#34;a&#34;</span><span>,</span> <span>(</span><span>&#34;b&#34;</span><span>,</span> <span>z</span><span>)))</span>
<span>b_y</span> <span>=</span> <span>U</span><span>.</span><span>add_term</span><span>((</span><span>&#34;a&#34;</span><span>,</span> <span>y</span><span>))</span>
<span>U</span><span>.</span><span>union</span><span>(</span><span>a_x</span><span>,</span> <span>b_y</span><span>)</span>
<span>print</span><span>(</span><span>U</span><span>)</span>
<span>U</span><span>.</span><span>rebuild</span><span>()</span>
<span>print</span><span>(</span><span>U</span><span>)</span>
<span>U</span><span>.</span><span>extract</span><span>(</span><span>a_x</span><span>)</span>
</code></pre></div></div>



<h2 id="pyres">PyRes</h2>

<div><div><pre><code><span># https://github.com/eprover/PyRes/blob/master/unification.py
</span><span>def</span> <span>occursCheck</span><span>(</span><span>x</span><span>,</span> <span>t</span><span>):</span>
   <span>&#34;&#34;&#34;
   Perform an occurs-check, i.e. determine if the variable x occurs in
   the term t. If that is the case (and t != x), the two can never be
   unified.
   &#34;&#34;&#34;</span>
   <span>if</span> <span>termIsCompound</span><span>(</span><span>t</span><span>):</span>
        <span>for</span> <span>i</span> <span>in</span> <span>t</span><span>[</span><span>1</span><span>:]:</span>
            <span>if</span> <span>occursCheck</span><span>(</span><span>x</span><span>,</span> <span>i</span><span>):</span>
                <span>return</span> <span>True</span>
        <span>return</span> <span>False</span>
   <span>else</span><span>:</span>
       <span>return</span> <span>x</span> <span>==</span> <span>t</span>


<span>def</span> <span>mguTermList</span><span>(</span><span>l1</span><span>,</span> <span>l2</span><span>,</span> <span>subst</span><span>):</span>
    <span>&#34;&#34;&#34;
    Unify all terms in l1 with the corresponding terms in l2 with a
    common substitution variable &#34;subst&#34;. We don&#39;t use explicit
    equations or pairs of terms here - if l1 is [s1, s2, s3] and l2 is
    [t1, t2, t3], this represents the set of equations {s1=t1, s2=t2,
    s3=t3}. This makes several operations easier to implement.
    &#34;&#34;&#34;</span>
    <span>assert</span> <span>len</span><span>(</span><span>l1</span><span>)</span><span>==</span><span>len</span><span>(</span><span>l2</span><span>)</span>
    <span>while</span><span>(</span><span>len</span><span>(</span><span>l1</span><span>)</span><span>!=</span><span>0</span><span>):</span>
       <span># Pop the first term pair to unify off the lists (pop removes
</span>       <span># and returns the denoted elements)
</span>       <span>t1</span> <span>=</span> <span>l1</span><span>.</span><span>pop</span><span>(</span><span>0</span><span>)</span>
       <span>t2</span> <span>=</span> <span>l2</span><span>.</span><span>pop</span><span>(</span><span>0</span><span>)</span>
       <span>if</span> <span>termIsVar</span><span>(</span><span>t1</span><span>):</span>
          <span>if</span> <span>t1</span><span>==</span><span>t2</span><span>:</span>
             <span># This implements the &#34;Solved&#34; rule.
</span>             <span># We could always test this upfront, but that would
</span>             <span># require an expensive check every time.
</span>             <span># We descend recursively anyway, so we only check this on
</span>             <span># the terminal case.
</span>             <span>continue</span>
          <span>if</span> <span>occursCheck</span><span>(</span><span>t1</span><span>,</span> <span>t2</span><span>):</span>
             <span>return</span> <span>None</span>
          <span># Here is the core of the &#34;Bind&#34; rule
</span>          <span># We now create a new substitution that binds t2 to t1, and
</span>          <span># apply it to the remaining unification problem. We know
</span>          <span># that every variable will only ever be bound once, because
</span>          <span># we eliminate all occurances of it in this step - remember
</span>          <span># that by the failed occurs-check, t2 cannot contain t1.
</span>          <span>new_binding</span> <span>=</span> <span>Substitution</span><span>([(</span><span>t1</span><span>,</span> <span>t2</span><span>)])</span>
          <span>l1</span> <span>=</span> <span>[</span><span>new_binding</span><span>(</span><span>t</span><span>)</span> <span>for</span> <span>t</span> <span>in</span> <span>l1</span><span>]</span>
          <span>l2</span> <span>=</span> <span>[</span><span>new_binding</span><span>(</span><span>t</span><span>)</span> <span>for</span> <span>t</span> <span>in</span> <span>l2</span><span>]</span>
          <span>subst</span><span>.</span><span>composeBinding</span><span>((</span><span>t1</span><span>,</span> <span>t2</span><span>))</span>
       <span>elif</span> <span>termIsVar</span><span>(</span><span>t2</span><span>):</span>
          <span># Symmetric case
</span>          <span># We know that t1!=t2, so we can drop this check
</span>          <span>if</span> <span>occursCheck</span><span>(</span><span>t2</span><span>,</span> <span>t1</span><span>):</span>
             <span>return</span> <span>None</span>
          <span>new_binding</span> <span>=</span> <span>Substitution</span><span>([(</span><span>t2</span><span>,</span> <span>t1</span><span>)])</span>
          <span>l1</span> <span>=</span> <span>[</span><span>new_binding</span><span>(</span><span>t</span><span>)</span> <span>for</span> <span>t</span> <span>in</span> <span>l1</span><span>]</span>
          <span>l2</span> <span>=</span> <span>[</span><span>new_binding</span><span>(</span><span>t</span><span>)</span> <span>for</span> <span>t</span> <span>in</span> <span>l2</span><span>]</span>
          <span>subst</span><span>.</span><span>composeBinding</span><span>((</span><span>t2</span><span>,</span> <span>t1</span><span>))</span>
       <span>else</span><span>:</span>
          <span>assert</span> <span>termIsCompound</span><span>(</span><span>t1</span><span>)</span> <span>and</span> <span>termIsCompound</span><span>(</span><span>t2</span><span>)</span>
          <span># Try to apply &#34;Decompose&#34;
</span>          <span># For f(s1, ..., sn) = g(t1, ..., tn), first f and g have to
</span>          <span># be equal...
</span>          <span>if</span> <span>terms</span><span>.</span><span>termFunc</span><span>(</span><span>t1</span><span>)</span> <span>!=</span> <span>terms</span><span>.</span><span>termFunc</span><span>(</span><span>t2</span><span>):</span>
             <span># Nope, &#34;Structural fail&#34;:
</span>             <span>return</span> <span>None</span>
          <span># But if the symbols are equal, here is the decomposition:
</span>          <span># We need to ensure that for all i si=ti get
</span>          <span># added to the list of equations to be solved.
</span>          <span>l1</span><span>.</span><span>extend</span><span>(</span><span>termArgs</span><span>(</span><span>t1</span><span>))</span>
          <span>l2</span><span>.</span><span>extend</span><span>(</span><span>termArgs</span><span>(</span><span>t2</span><span>))</span>
    <span>return</span> <span>subst</span>


<span>def</span> <span>mgu</span><span>(</span><span>t1</span><span>,</span> <span>t2</span><span>):</span>
    <span>&#34;&#34;&#34;
    Try to unify t1 and t2, return substitution on success, or None on failure.
    &#34;&#34;&#34;</span>
    <span>res</span> <span>=</span>  <span>mguTermList</span><span>([</span><span>t1</span><span>],</span> <span>[</span><span>t2</span><span>],</span> <span>Substitution</span><span>())</span>
    <span>res2</span> <span>=</span> <span>&#34;False&#34;</span>
    <span>if</span> <span>res</span><span>:</span>
       <span>res2</span> <span>=</span> <span>&#34;True&#34;</span>
    <span># print(&#34;% :&#34;, term2String(t1), &#34; : &#34;, term2String(t2), &#34; =&gt; &#34;, res2);
</span>    <span>return</span> <span>res</span>
</code></pre></div></div>

<h2 id="minikanren">Minikanren</h2>

<div><div><pre><code><span>%</span><span>file</span> <span>/</span><span>tmp</span><span>/</span><span>minikanren_unif</span><span>.</span><span>scm</span>
<span>;;</span> <span>http</span><span>:</span><span>//</span><span>webyrd</span><span>.</span><span>net</span><span>/</span><span>scheme</span><span>-</span><span>2013</span><span>/</span><span>papers</span><span>/</span><span>HemannMuKanren2013</span><span>.</span><span>pdf</span>
<span>;;</span> <span>https</span><span>:</span><span>//</span><span>github</span><span>.</span><span>com</span><span>/</span><span>jasonhemann</span><span>/</span><span>microKanren</span><span>/</span><span>blob</span><span>/</span><span>master</span><span>/</span><span>microKanren</span><span>.</span><span>scm</span>

<span>;</span> <span>Jason</span> <span>Hemann</span> <span>and</span> <span>Dan</span> <span>Friedman</span>
<span>;;</span> <span>microKanren</span><span>,</span> <span>final</span> <span>implementation</span> <span>from</span> <span>paper</span>

<span>(</span><span>define</span> <span>(</span><span>var</span> <span>c</span><span>)</span> <span>(</span><span>vector</span> <span>c</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>var</span><span>?</span> <span>x</span><span>)</span> <span>(</span><span>vector</span><span>?</span> <span>x</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>var</span><span>=</span><span>?</span> <span>x1</span> <span>x2</span><span>)</span> <span>(</span><span>=</span> <span>(</span><span>vector</span><span>-</span><span>ref</span> <span>x1</span> <span>0</span><span>)</span> <span>(</span><span>vector</span><span>-</span><span>ref</span> <span>x2</span> <span>0</span><span>)))</span>

<span>(</span><span>define</span> <span>(</span><span>walk</span> <span>u</span> <span>s</span><span>)</span>
  <span>(</span><span>let</span> <span>((</span><span>pr</span> <span>(</span><span>and</span> <span>(</span><span>var</span><span>?</span> <span>u</span><span>)</span> <span>(</span><span>assp</span> <span>(</span><span>lambda</span> <span>(</span><span>v</span><span>)</span> <span>(</span><span>var</span><span>=</span><span>?</span> <span>u</span> <span>v</span><span>))</span> <span>s</span><span>))))</span>
    <span>(</span><span>if</span> <span>pr</span> <span>(</span><span>walk</span> <span>(</span><span>cdr</span> <span>pr</span><span>)</span> <span>s</span><span>)</span> <span>u</span><span>)))</span>

<span>(</span><span>define</span> <span>(</span><span>ext</span><span>-</span><span>s</span> <span>x</span> <span>v</span> <span>s</span><span>)</span> <span>`</span><span>((,</span><span>x</span> <span>.</span> <span>,</span><span>v</span><span>)</span> <span>.</span> <span>,</span><span>s</span><span>))</span>

<span>(</span><span>define</span> <span>(</span><span>==</span> <span>u</span> <span>v</span><span>)</span>
  <span>(</span><span>lambda</span> <span>(</span><span>s</span><span>/</span><span>c</span><span>)</span>
    <span>(</span><span>let</span> <span>((</span><span>s</span> <span>(</span><span>unify</span> <span>u</span> <span>v</span> <span>(</span><span>car</span> <span>s</span><span>/</span><span>c</span><span>))))</span>
      <span>(</span><span>if</span> <span>s</span> <span>(</span><span>unit</span> <span>`</span><span>(,</span><span>s</span> <span>.</span> <span>,(</span><span>cdr</span> <span>s</span><span>/</span><span>c</span><span>)))</span> <span>mzero</span><span>))))</span>

<span>(</span><span>define</span> <span>(</span><span>unit</span> <span>s</span><span>/</span><span>c</span><span>)</span> <span>(</span><span>cons</span> <span>s</span><span>/</span><span>c</span> <span>mzero</span><span>))</span>
<span>(</span><span>define</span> <span>mzero</span> <span>&#39;())

(define (unify u v s)
  (let ((u (walk u s)) (v (walk v s)))
    (cond
      ((and (var? u) (var? v) (var=? u v)) s)
      ((var? u) (ext-s u v s))
      ((var? v) (ext-s v u s))
      ((and (pair? u) (pair? v))
       (let ((s (unify (car u) (car v) s)))
         (and s (unify (cdr u) (cdr v) s))))
      (else (and (eqv? u v) s)))))

</span></code></pre></div></div>

<h2 id="harrison">Harrison</h2>

<div><div><pre><code><span>%%</span><span>file</span> <span>/</span><span>tmp</span><span>/</span><span>harrison</span><span>.</span><span>ml</span>
<span>(</span><span>*</span> <span>=========================================================================</span> <span>*</span><span>)</span>
<span>(</span><span>*</span> <span>Unification</span> <span>for</span> <span>first</span> <span>order</span> <span>terms</span><span>.</span>                                        <span>*</span><span>)</span>
<span>(</span><span>*</span>                 <span>https</span><span>:</span><span>//</span><span>www</span><span>.</span><span>cl</span><span>.</span><span>cam</span><span>.</span><span>ac</span><span>.</span><span>uk</span><span>/~</span><span>jrh13</span><span>/</span><span>atp</span><span>/</span><span>OCaml</span><span>/</span><span>unif</span><span>.</span><span>ml</span>                                                           <span>*</span><span>)</span>
<span>(</span><span>*</span> <span>Copyright</span> <span>(</span><span>c</span><span>)</span> <span>2003</span><span>-</span><span>2007</span><span>,</span> <span>John</span> <span>Harrison</span><span>.</span> <span>(</span><span>See</span> <span>&#34;LICENSE.txt&#34;</span> <span>for</span> <span>details</span><span>.)</span>  <span>*</span><span>)</span>
<span>(</span><span>*</span> <span>=========================================================================</span> <span>*</span><span>)</span>

<span>let</span> <span>rec</span> <span>istriv</span> <span>env</span> <span>x</span> <span>t</span> <span>=</span>
  <span>match</span> <span>t</span> <span>with</span>
    <span>Var</span> <span>y</span> <span>-&gt;</span> <span>y</span> <span>=</span> <span>x</span> <span>or</span> <span>defined</span> <span>env</span> <span>y</span> <span>&amp;</span> <span>istriv</span> <span>env</span> <span>x</span> <span>(</span><span>apply</span> <span>env</span> <span>y</span><span>)</span>
  <span>|</span> <span>Fn</span><span>(</span><span>f</span><span>,</span><span>args</span><span>)</span> <span>-&gt;</span> <span>exists</span> <span>(</span><span>istriv</span> <span>env</span> <span>x</span><span>)</span> <span>args</span> <span>&amp;</span> <span>failwith</span> <span>&#34;cyclic&#34;</span><span>;;</span>

<span>(</span><span>*</span> <span>-------------------------------------------------------------------------</span> <span>*</span><span>)</span>
<span>(</span><span>*</span> <span>Main</span> <span>unification</span> <span>procedure</span>                                                <span>*</span><span>)</span>
<span>(</span><span>*</span> <span>-------------------------------------------------------------------------</span> <span>*</span><span>)</span>

<span>let</span> <span>rec</span> <span>unify</span> <span>env</span> <span>eqs</span> <span>=</span>
  <span>match</span> <span>eqs</span> <span>with</span>
    <span>[]</span> <span>-&gt;</span> <span>env</span>
  <span>|</span> <span>(</span><span>Fn</span><span>(</span><span>f</span><span>,</span><span>fargs</span><span>),</span><span>Fn</span><span>(</span><span>g</span><span>,</span><span>gargs</span><span>))::</span><span>oth</span> <span>-&gt;</span>
        <span>if</span> <span>f</span> <span>=</span> <span>g</span> <span>&amp;</span> <span>length</span> <span>fargs</span> <span>=</span> <span>length</span> <span>gargs</span>
        <span>then</span> <span>unify</span> <span>env</span> <span>(</span><span>zip</span> <span>fargs</span> <span>gargs</span> <span>@</span> <span>oth</span><span>)</span>
        <span>else</span> <span>failwith</span> <span>&#34;impossible unification&#34;</span>
  <span>|</span> <span>(</span><span>Var</span> <span>x</span><span>,</span><span>t</span><span>)::</span><span>oth</span> <span>|</span> <span>(</span><span>t</span><span>,</span><span>Var</span> <span>x</span><span>)::</span><span>oth</span> <span>-&gt;</span>
        <span>if</span> <span>defined</span> <span>env</span> <span>x</span> <span>then</span> <span>unify</span> <span>env</span> <span>((</span><span>apply</span> <span>env</span> <span>x</span><span>,</span><span>t</span><span>)::</span><span>oth</span><span>)</span>
        <span>else</span> <span>unify</span> <span>(</span><span>if</span> <span>istriv</span> <span>env</span> <span>x</span> <span>t</span> <span>then</span> <span>env</span> <span>else</span> <span>(</span><span>x</span><span>|-&gt;</span><span>t</span><span>)</span> <span>env</span><span>)</span> <span>oth</span><span>;;</span>

<span>(</span><span>*</span> <span>-------------------------------------------------------------------------</span> <span>*</span><span>)</span>
<span>(</span><span>*</span> <span>Solve</span> <span>to</span> <span>obtain</span> <span>a</span> <span>single</span> <span>instantiation</span><span>.</span>                                   <span>*</span><span>)</span>
<span>(</span><span>*</span> <span>-------------------------------------------------------------------------</span> <span>*</span><span>)</span>

<span>let</span> <span>rec</span> <span>solve</span> <span>env</span> <span>=</span>
  <span>let</span> <span>env</span><span>&#39; = mapf (tsubst env) env in
  if env&#39;</span> <span>=</span> <span>env</span> <span>then</span> <span>env</span> <span>else</span> <span>solve</span> <span>env</span><span>&#39;;;

(* ------------------------------------------------------------------------- *)
(* Unification reaching a final solved form (often this isn&#39;</span><span>t</span> <span>needed</span><span>).</span>       <span>*</span><span>)</span>
<span>(</span><span>*</span> <span>-------------------------------------------------------------------------</span> <span>*</span><span>)</span>

<span>let</span> <span>fullunify</span> <span>eqs</span> <span>=</span> <span>solve</span> <span>(</span><span>unify</span> <span>undefined</span> <span>eqs</span><span>);;</span>
</code></pre></div></div>

<h2 id="prover9">Prover9</h2>

<div><div><pre><code><span>%%</span><span>file</span> <span>/</span><span>tmp</span><span>/</span><span>prover9</span><span>.</span><span>c</span>
<span>BOOL</span> <span>unify</span><span>(</span><span>Term</span> <span>t1</span><span>,</span> <span>Context</span> <span>c1</span><span>,</span>
           <span>Term</span> <span>t2</span><span>,</span> <span>Context</span> <span>c2</span><span>,</span> <span>Trail</span> <span>*</span><span>trp</span><span>)</span>
<span>{</span>
  <span>Trail</span> <span>tpos</span><span>,</span> <span>tp</span><span>,</span> <span>t3</span><span>;</span>
  <span>int</span> <span>vn1</span><span>,</span> <span>vn2</span><span>;</span>

  <span>DEREFERENCE</span><span>(</span><span>t1</span><span>,</span> <span>c1</span><span>)</span>  <span>/*</span> <span>dereference</span> <span>macro</span> <span>*/</span>

  <span>DEREFERENCE</span><span>(</span><span>t2</span><span>,</span> <span>c2</span><span>)</span>  <span>/*</span> <span>dereference</span> <span>macro</span> <span>*/</span>

  <span>/*</span> <span>Now</span><span>,</span> <span>neither</span> <span>t1</span> <span>nor</span> <span>t2</span> <span>is</span> <span>a</span> <span>bound</span> <span>variable</span><span>.</span> <span>*/</span>

  <span>if</span> <span>(</span><span>VARIABLE</span><span>(</span><span>t1</span><span>))</span> <span>{</span>
    <span>vn1</span> <span>=</span> <span>VARNUM</span><span>(</span><span>t1</span><span>);</span>
    <span>if</span> <span>(</span><span>VARIABLE</span><span>(</span><span>t2</span><span>))</span> <span>{</span>
      <span>/*</span> <span>both</span> <span>t1</span> <span>and</span> <span>t2</span> <span>are</span> <span>variables</span> <span>*/</span>
      <span>if</span> <span>(</span><span>vn1</span> <span>==</span> <span>VARNUM</span><span>(</span><span>t2</span><span>)</span> <span>&amp;&amp;</span> <span>c1</span> <span>==</span> <span>c2</span><span>)</span>
        <span>return</span> <span>TRUE</span><span>;</span>  <span>/*</span> <span>identical</span> <span>*/</span>
      <span>else</span> <span>{</span>
        <span>BIND_TR</span><span>(</span><span>vn1</span><span>,</span> <span>c1</span><span>,</span> <span>t2</span><span>,</span> <span>c2</span><span>,</span> <span>trp</span><span>)</span>
        <span>return</span> <span>TRUE</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>else</span> <span>{</span>
      <span>/*</span> <span>t1</span> <span>variable</span><span>,</span> <span>t2</span> <span>not</span> <span>variable</span> <span>*/</span>
      <span>if</span> <span>(</span><span>occur_check</span><span>(</span><span>vn1</span><span>,</span> <span>c1</span><span>,</span> <span>t2</span><span>,</span> <span>c2</span><span>))</span> <span>{</span>
        <span>BIND_TR</span><span>(</span><span>vn1</span><span>,</span> <span>c1</span><span>,</span> <span>t2</span><span>,</span> <span>c2</span><span>,</span> <span>trp</span><span>)</span>
        <span>return</span> <span>TRUE</span><span>;</span>
      <span>}</span>
      <span>else</span>
        <span>return</span> <span>FALSE</span><span>;</span>  <span>/*</span> <span>failed</span> <span>occur_check</span> <span>*/</span>
    <span>}</span>
  <span>}</span>

  <span>else</span> <span>if</span> <span>(</span><span>VARIABLE</span><span>(</span><span>t2</span><span>))</span> <span>{</span>
    <span>/*</span> <span>t2</span> <span>variable</span><span>,</span> <span>t1</span> <span>not</span> <span>variable</span> <span>*/</span>
    <span>vn2</span> <span>=</span> <span>VARNUM</span><span>(</span><span>t2</span><span>);</span>
    <span>if</span> <span>(</span><span>occur_check</span><span>(</span><span>vn2</span><span>,</span> <span>c2</span><span>,</span> <span>t1</span><span>,</span> <span>c1</span><span>))</span> <span>{</span>
      <span>BIND_TR</span><span>(</span><span>vn2</span><span>,</span> <span>c2</span><span>,</span> <span>t1</span><span>,</span> <span>c1</span><span>,</span> <span>trp</span><span>)</span>
      <span>return</span> <span>TRUE</span><span>;</span>
    <span>}</span>
    <span>else</span>
      <span>return</span> <span>FALSE</span><span>;</span>  <span>/*</span> <span>failed</span> <span>occur_check</span> <span>*/</span>
  <span>}</span>
    
  <span>else</span> <span>if</span> <span>(</span><span>SYMNUM</span><span>(</span><span>t1</span><span>)</span> <span>!=</span> <span>SYMNUM</span><span>(</span><span>t2</span><span>))</span>
    <span>return</span> <span>FALSE</span><span>;</span>  <span>/*</span> <span>fail</span> <span>because</span> <span>of</span> <span>symbol</span> <span>clash</span> <span>*/</span>

  <span>else</span> <span>if</span> <span>(</span><span>ARITY</span><span>(</span><span>t1</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
    <span>return</span> <span>TRUE</span><span>;</span>

  <span>else</span> <span>{</span>  <span>/*</span> <span>both</span> <span>complex</span> <span>with</span> <span>same</span> <span>symbol</span> <span>*/</span>
    <span>int</span> <span>i</span><span>,</span> <span>arity</span><span>;</span>

    <span>tpos</span> <span>=</span> <span>*</span><span>trp</span><span>;</span>  <span>/*</span> <span>save</span> <span>trail</span> <span>position</span> <span>in</span> <span>case</span> <span>of</span> <span>failure</span> <span>*/</span>
        
    <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>arity</span> <span>=</span> <span>ARITY</span><span>(</span><span>t1</span><span>);</span>
    <span>while</span> <span>(</span><span>i</span> <span>&lt;</span> <span>arity</span> <span>&amp;&amp;</span> <span>unify</span><span>(</span><span>ARG</span><span>(</span><span>t1</span><span>,</span><span>i</span><span>),</span> <span>c1</span><span>,</span> <span>ARG</span><span>(</span><span>t2</span><span>,</span><span>i</span><span>),</span> <span>c2</span><span>,</span> <span>trp</span><span>))</span>
      <span>i</span><span>++</span><span>;</span>

    <span>if</span> <span>(</span><span>i</span> <span>==</span> <span>arity</span><span>)</span>
      <span>return</span> <span>TRUE</span><span>;</span>
    <span>else</span> <span>{</span>  <span>/*</span> <span>restore</span> <span>trail</span> <span>and</span> <span>fail</span> <span>*/</span>
      <span>tp</span> <span>=</span> <span>*</span><span>trp</span><span>;</span>
      <span>while</span> <span>(</span><span>tp</span> <span>!=</span> <span>tpos</span><span>)</span> <span>{</span>
        <span>tp</span><span>-&gt;</span><span>context</span><span>-&gt;</span><span>terms</span><span>[</span><span>tp</span><span>-&gt;</span><span>varnum</span><span>]</span> <span>=</span> <span>NULL</span><span>;</span>
        <span>tp</span><span>-&gt;</span><span>context</span><span>-&gt;</span><span>contexts</span><span>[</span><span>tp</span><span>-&gt;</span><span>varnum</span><span>]</span> <span>=</span> <span>NULL</span><span>;</span>
        <span>t3</span> <span>=</span> <span>tp</span><span>;</span>
        <span>tp</span> <span>=</span> <span>tp</span><span>-&gt;</span><span>next</span><span>;</span>
        <span>free_trail</span><span>(</span><span>t3</span><span>);</span>
      <span>}</span>
      <span>*</span><span>trp</span> <span>=</span> <span>tpos</span><span>;</span>
      <span>return</span> <span>FALSE</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>  <span>/*</span> <span>unify</span> <span>*/</span>
</code></pre></div></div>

<h2 id="ocaml-alg">Ocaml alg</h2>

<div><div><pre><code><span>%%</span><span>file</span> <span>/</span><span>tmp</span><span>/</span><span>ocaml_alg</span><span>.</span><span>ml</span>
<span>(</span><span>*</span> <span>https</span><span>:</span><span>//</span><span>github</span><span>.</span><span>com</span><span>/</span><span>smimram</span><span>/</span><span>ocaml</span><span>-</span><span>alg</span><span>/</span><span>blob</span><span>/</span><span>main</span><span>/</span><span>src</span><span>/</span><span>term</span><span>.</span><span>ml</span><span>#L375 *)
</span><span>(</span><span>**</span> <span>Most</span> <span>general</span> <span>unifier</span><span>.</span> <span>*</span><span>)</span>
<span>let</span> <span>unify</span> <span>t1</span> <span>t2</span> <span>=</span>
  <span>(</span><span>*</span> <span>Printf</span><span>.</span><span>printf</span> <span>&#34;UNIFY %s WITH %s</span><span>\n</span><span>%!&#34;</span> <span>(</span><span>to_string</span> <span>t1</span><span>)</span> <span>(</span><span>to_string</span> <span>t2</span><span>);</span> <span>*</span><span>)</span>
  <span>let</span> <span>rec</span> <span>aux</span> <span>q</span> <span>s</span> <span>=</span>
    <span>match</span> <span>q</span> <span>with</span>
    <span>|</span> <span>[]</span> <span>-&gt;</span> <span>s</span>
    <span>|</span> <span>p</span><span>::</span><span>q</span> <span>-&gt;</span>
       <span>match</span> <span>p</span> <span>with</span>
       <span>|</span> <span>Var</span> <span>x</span><span>,</span> <span>t</span> <span>-&gt;</span>
          <span>if</span> <span>occurs</span> <span>x</span> <span>t</span> <span>then</span> <span>raise</span> <span>Not_unifiable</span><span>;</span>
          <span>let</span> <span>s</span><span>&#39; = Subst.simple x t in
          let f = Subst.app s&#39;</span> <span>in</span>
          <span>let</span> <span>q</span> <span>=</span> <span>List</span><span>.</span><span>map</span> <span>(</span><span>fun</span> <span>(</span><span>t1</span><span>,</span><span>t2</span><span>)</span> <span>-&gt;</span> <span>f</span> <span>t1</span><span>,</span> <span>f</span> <span>t2</span><span>)</span> <span>q</span> <span>in</span>
          <span>let</span> <span>s</span> <span>=</span> <span>Subst</span><span>.</span><span>compose</span> <span>s</span> <span>s</span><span>&#39; in
          aux q (Subst.add s x t)
       | t, Var x -&gt; aux ((Var x,t)::q) s
       | App (f1,a1), App (f2,a2) -&gt;
          if not (Op.eq f1 f2) then raise Not_unifiable;
          let q = (List.map2 pair a1 a2) @ q in
          aux q s
  in
  let s = aux [t1,t2] Subst.empty in
  assert (eq (Subst.app s t1) (Subst.app s t2));
  s
</span></code></pre></div></div>

<h2 id="traat">TRAAT</h2>

<div><div><pre><code><span>%%</span><span>file</span> <span>/</span><span>tmp</span><span>/</span><span>traat</span><span>.</span><span>ml</span>
<span>(</span><span>***</span> <span>https</span><span>:</span><span>//</span><span>www21</span><span>.</span><span>in</span><span>.</span><span>tum</span><span>.</span><span>de</span><span>/~</span><span>nipkow</span><span>/</span><span>TRaAT</span><span>/</span><span>programs</span><span>/</span><span>trs</span><span>.</span><span>ML</span> <span>The</span> <span>basics</span> <span>of</span> <span>term</span> <span>rewriting</span><span>:</span> <span>terms</span><span>,</span> <span>unification</span><span>,</span> <span>matching</span><span>,</span> <span>normalization</span>

<span>ML</span> <span>Programs</span> <span>from</span> <span>Chapter</span> <span>4</span> <span>of</span>

  <span>Term</span> <span>Rewriting</span> <span>and</span> <span>All</span> <span>That</span>
  <span>by</span> <span>Franz</span> <span>Baader</span> <span>and</span> <span>Tobias</span> <span>Nipkow</span><span>,</span>
  <span>(</span><span>Cambridge</span> <span>University</span> <span>Press</span><span>,</span> <span>1998</span><span>)</span>

<span>Copyright</span> <span>(</span><span>C</span><span>)</span> <span>1998</span> <span>by</span> <span>Cambridge</span> <span>University</span> <span>Press</span><span>.</span>
<span>Permission</span> <span>to</span> <span>use</span> <span>without</span> <span>fee</span> <span>is</span> <span>granted</span> <span>provided</span> <span>that</span> <span>this</span> <span>copyright</span>
<span>notice</span> <span>is</span> <span>included</span> <span>in</span> <span>any</span> <span>copy</span><span>.</span>
<span>***</span><span>)</span>

<span>type</span> <span>vname</span> <span>=</span> <span>string</span> <span>*</span> <span>int</span><span>;</span>

<span>datatype</span> <span>term</span> <span>=</span> <span>V</span> <span>of</span> <span>vname</span> <span>|</span> <span>T</span> <span>of</span> <span>string</span> <span>*</span> <span>term</span> <span>list</span><span>;</span>

<span>(</span><span>*</span> <span>indom</span><span>:</span> <span>vname</span> <span>-&gt;</span> <span>subst</span> <span>-&gt;</span> <span>bool</span> <span>*</span><span>)</span>
<span>fun</span> <span>indom</span> <span>x</span> <span>s</span> <span>=</span> <span>exists</span> <span>(</span><span>fn</span> <span>(</span><span>y</span><span>,</span><span>_</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>=</span> <span>y</span><span>)</span> <span>s</span><span>;</span>

<span>(</span><span>*</span> <span>app</span><span>:</span> <span>subst</span> <span>-&gt;</span> <span>vname</span> <span>-&gt;</span> <span>term</span> <span>*</span><span>)</span>
<span>fun</span> <span>app</span> <span>((</span><span>y</span><span>,</span><span>t</span><span>)::</span><span>s</span><span>)</span> <span>x</span>  <span>=</span>  <span>if</span> <span>x</span><span>=</span><span>y</span> <span>then</span> <span>t</span> <span>else</span> <span>app</span> <span>s</span> <span>x</span><span>;</span>

<span>(</span><span>*</span> <span>lift</span><span>:</span> <span>subst</span> <span>-&gt;</span> <span>term</span> <span>-&gt;</span> <span>term</span> <span>*</span><span>)</span>
<span>fun</span> <span>lift</span> <span>s</span> <span>(</span><span>V</span> <span>x</span><span>)</span>    <span>=</span> <span>if</span> <span>indom</span> <span>x</span> <span>s</span> <span>then</span> <span>app</span> <span>s</span> <span>x</span> <span>else</span> <span>V</span> <span>x</span>
  <span>|</span> <span>lift</span> <span>s</span> <span>(</span><span>T</span><span>(</span><span>f</span><span>,</span><span>ts</span><span>))</span> <span>=</span> <span>T</span><span>(</span><span>f</span><span>,</span> <span>map</span> <span>(</span><span>lift</span> <span>s</span><span>)</span> <span>ts</span><span>);</span>

<span>(</span><span>*</span> <span>occurs</span><span>:</span> <span>vname</span> <span>-&gt;</span> <span>term</span> <span>-&gt;</span> <span>bool</span> <span>*</span><span>)</span>
<span>fun</span> <span>occurs</span> <span>x</span> <span>(</span><span>V</span> <span>y</span><span>)</span>    <span>=</span> <span>x</span><span>=</span><span>y</span>
  <span>|</span> <span>occurs</span> <span>x</span> <span>(</span><span>T</span><span>(</span><span>_</span><span>,</span><span>ts</span><span>))</span> <span>=</span> <span>exists</span> <span>(</span><span>occurs</span> <span>x</span><span>)</span> <span>ts</span><span>;</span>

<span>exception</span> <span>UNIFY</span><span>;</span>

<span>(</span><span>*</span> <span>solve</span><span>:</span> <span>(</span><span>term</span> <span>*</span> <span>term</span><span>)</span><span>list</span> <span>*</span> <span>subst</span> <span>-&gt;</span> <span>subst</span> <span>*</span><span>)</span>
<span>fun</span> <span>solve</span><span>([],</span> <span>s</span><span>)</span> <span>=</span> <span>s</span>
  <span>|</span> <span>solve</span><span>((</span><span>V</span> <span>x</span><span>,</span> <span>t</span><span>)</span> <span>::</span> <span>S</span><span>,</span> <span>s</span><span>)</span> <span>=</span>
      <span>if</span> <span>V</span> <span>x</span> <span>=</span> <span>t</span> <span>then</span> <span>solve</span><span>(</span><span>S</span><span>,</span><span>s</span><span>)</span> <span>else</span> <span>elim</span><span>(</span><span>x</span><span>,</span><span>t</span><span>,</span><span>S</span><span>,</span><span>s</span><span>)</span>
  <span>|</span> <span>solve</span><span>((</span><span>t</span><span>,</span> <span>V</span> <span>x</span><span>)</span> <span>::</span> <span>S</span><span>,</span> <span>s</span><span>)</span> <span>=</span> <span>elim</span><span>(</span><span>x</span><span>,</span><span>t</span><span>,</span><span>S</span><span>,</span><span>s</span><span>)</span>
  <span>|</span> <span>solve</span><span>((</span><span>T</span><span>(</span><span>f</span><span>,</span><span>ts</span><span>),</span><span>T</span><span>(</span><span>g</span><span>,</span><span>us</span><span>))</span> <span>::</span> <span>S</span><span>,</span> <span>s</span><span>)</span> <span>=</span>
      <span>if</span> <span>f</span> <span>=</span> <span>g</span> <span>then</span> <span>solve</span><span>(</span><span>zip</span><span>(</span><span>ts</span><span>,</span><span>us</span><span>)</span> <span>@</span> <span>S</span><span>,</span> <span>s</span><span>)</span> <span>else</span> <span>raise</span> <span>UNIFY</span>

<span>(</span><span>*</span> <span>elim</span><span>:</span> <span>vname</span> <span>*</span> <span>term</span> <span>*</span> <span>(</span><span>term</span> <span>*</span> <span>term</span><span>)</span> <span>list</span> <span>*</span> <span>subst</span> <span>-&gt;</span> <span>subst</span> <span>*</span><span>)</span>
<span>and</span> <span>elim</span><span>(</span><span>x</span><span>,</span><span>t</span><span>,</span><span>S</span><span>,</span><span>s</span><span>)</span> <span>=</span>
      <span>if</span> <span>occurs</span> <span>x</span> <span>t</span> <span>then</span> <span>raise</span> <span>UNIFY</span>
      <span>else</span> <span>let</span> <span>val</span> <span>xt</span> <span>=</span> <span>lift</span> <span>[(</span><span>x</span><span>,</span><span>t</span><span>)]</span>
           <span>in</span> <span>solve</span><span>(</span><span>map</span> <span>(</span><span>fn</span> <span>(</span><span>t1</span><span>,</span><span>t2</span><span>)</span> <span>=&gt;</span> <span>(</span><span>xt</span> <span>t1</span><span>,</span> <span>xt</span> <span>t2</span><span>))</span> <span>S</span><span>,</span>
                    <span>(</span><span>x</span><span>,</span><span>t</span><span>)</span> <span>::</span> <span>(</span><span>map</span> <span>(</span><span>fn</span> <span>(</span><span>y</span><span>,</span><span>u</span><span>)</span> <span>=&gt;</span> <span>(</span><span>y</span><span>,</span> <span>xt</span> <span>u</span><span>))</span> <span>s</span><span>))</span>
           <span>end</span><span>;</span>

<span>(</span><span>*</span> <span>unify</span><span>:</span> <span>term</span> <span>*</span> <span>term</span> <span>-&gt;</span> <span>subst</span> <span>*</span><span>)</span>
<span>fun</span> <span>unify</span><span>(</span><span>t1</span><span>,</span><span>t2</span><span>)</span> <span>=</span> <span>solve</span><span>([(</span><span>t1</span><span>,</span><span>t2</span><span>)],</span> <span>[]);</span>

<span>(</span><span>*</span> <span>matchs</span><span>:</span> <span>(</span><span>term</span> <span>*</span> <span>term</span><span>)</span> <span>list</span> <span>*</span> <span>subst</span> <span>-&gt;</span> <span>subst</span> <span>*</span><span>)</span>
<span>fun</span> <span>matchs</span><span>([],</span> <span>s</span><span>)</span> <span>=</span> <span>s</span>
  <span>|</span> <span>matchs</span><span>((</span><span>V</span> <span>x</span><span>,</span> <span>t</span><span>)</span> <span>::</span> <span>S</span><span>,</span> <span>s</span><span>)</span> <span>=</span>
      <span>if</span> <span>indom</span> <span>x</span> <span>s</span> <span>then</span> <span>if</span> <span>app</span> <span>s</span> <span>x</span> <span>=</span> <span>t</span> <span>then</span> <span>matchs</span><span>(</span><span>S</span><span>,</span><span>s</span><span>)</span> <span>else</span> <span>raise</span> <span>UNIFY</span>
      <span>else</span> <span>matchs</span><span>(</span><span>S</span><span>,(</span><span>x</span><span>,</span><span>t</span><span>)::</span><span>s</span><span>)</span>
  <span>|</span> <span>matchs</span><span>((</span><span>t</span><span>,</span> <span>V</span> <span>x</span><span>)</span> <span>::</span> <span>S</span><span>,</span> <span>s</span><span>)</span> <span>=</span> <span>raise</span> <span>UNIFY</span>
  <span>|</span> <span>matchs</span><span>((</span><span>T</span><span>(</span><span>f</span><span>,</span><span>ts</span><span>),</span><span>T</span><span>(</span><span>g</span><span>,</span><span>us</span><span>))</span> <span>::</span> <span>S</span><span>,</span> <span>s</span><span>)</span> <span>=</span>
      <span>if</span> <span>f</span> <span>=</span> <span>g</span> <span>then</span> <span>matchs</span><span>(</span><span>zip</span><span>(</span><span>ts</span><span>,</span><span>us</span><span>)</span> <span>@</span> <span>S</span><span>,</span> <span>s</span><span>)</span> <span>else</span> <span>raise</span> <span>UNIFY</span><span>;</span>

<span>(</span><span>*</span> <span>match</span><span>:</span> <span>term</span> <span>*</span> <span>term</span> <span>-&gt;</span> <span>subst</span> <span>*</span><span>)</span>
<span>fun</span> <span>match</span><span>(</span><span>pat</span><span>,</span><span>obj</span><span>)</span> <span>=</span> <span>matchs</span><span>([(</span><span>pat</span><span>,</span><span>obj</span><span>)],[]);</span>

<span>exception</span> <span>NORM</span><span>;</span>

<span>(</span><span>*</span> <span>rewrite</span><span>:</span> <span>(</span><span>term</span> <span>*</span> <span>term</span><span>)</span> <span>list</span> <span>-&gt;</span> <span>term</span> <span>-&gt;</span> <span>term</span> <span>*</span><span>)</span>
<span>fun</span> <span>rewrite</span> <span>[]</span> <span>t</span> <span>=</span> <span>raise</span> <span>NORM</span>
  <span>|</span> <span>rewrite</span> <span>((</span><span>l</span><span>,</span><span>r</span><span>)::</span><span>R</span><span>)</span> <span>t</span> <span>=</span> <span>lift</span><span>(</span><span>match</span><span>(</span><span>l</span><span>,</span><span>t</span><span>))</span> <span>r</span>
                          <span>handle</span> <span>UNIFY</span> <span>=&gt;</span> <span>rewrite</span> <span>R</span> <span>t</span><span>;</span>

<span>(</span><span>*</span> <span>norm</span><span>:</span> <span>(</span><span>term</span> <span>*</span> <span>term</span><span>)</span> <span>list</span> <span>-&gt;</span> <span>term</span> <span>-&gt;</span> <span>term</span> <span>*</span><span>)</span>
<span>fun</span> <span>norm</span> <span>R</span> <span>(</span><span>V</span> <span>x</span><span>)</span> <span>=</span> <span>V</span> <span>x</span>
  <span>|</span> <span>norm</span> <span>R</span> <span>(</span><span>T</span><span>(</span><span>f</span><span>,</span><span>ts</span><span>))</span> <span>=</span>
      <span>let</span> <span>val</span> <span>u</span> <span>=</span> <span>T</span><span>(</span><span>f</span><span>,</span> <span>map</span> <span>(</span><span>norm</span> <span>R</span><span>)</span> <span>ts</span><span>)</span>
      <span>in</span> <span>(</span><span>norm</span> <span>R</span> <span>(</span><span>rewrite</span> <span>R</span> <span>u</span><span>))</span>  <span>handle</span> <span>NORM</span> <span>=&gt;</span> <span>u</span>  <span>end</span><span>;</span>
</code></pre></div></div>

<p>alpha prolog or lambda prolog as a librtary would be good.
alpha leantap
(an interpreter)</p>

<div><div><pre><code><span>import</span> <span>janus_swi</span> <span>as</span> <span>janus</span>

<span># leantap with higher order unify?
# trs with higher order unify?
</span>
<span>janus</span><span>.</span><span>consult</span><span>(</span><span>&#34;hounify&#34;</span><span>,</span> <span>&#34;&#34;&#34;

ho_unify(bvar()).
ho_unify(app(F1,X1), app(F2,X2)) :- ho_unify(F1,F2, Sig), ho_unify(X1,X2,Sig).
ho_unify(lam(X1,B1), lam(X2,B2), Sig) :- gensym(S), V =.. [S|Sig], X1 = V, X2 = V, ho_unify(B1,B2,Sig).

              
% noiminal_unify(T1, T2 ,  Perm)
nominal(atom(A), atom(B), Perm1, Perm2) :- member(A-B, Perm1), Perm1 = Perm2.
nominal(atom(A), atom(B), Perm1, Perm2) :- +/ member(A-Y, Perm1), +/ member(Z-B, Perm1), Perm2 = [A-B|Perm1].
nominal(app(F,Args), app(F1,Args2), Perm1, Perm2) :- nominal(F,F1)
nominal

% maybe a dcg of the permutation? We are threading a state.
nominal(atom(A), atom(B)) --&gt; 

% https://stackoverflow.com/questions/64638801/the-unification-algorithm-in-prolog#:~:text=unify(A%2CB)%3A%2D%20atomic,B)%2CA%3DB.        
              unify(A,B):-
   atomic(A),atomic(B),A=B.
unify(A,B):-
   var(A),A=B.            % without occurs check
unify(A,B):-
   nonvar(A),var(B),A=B.  % without occurs check
unify(A,B):-
   compound(A),compound(B),
   A=..[F|ArgsA],B=..[F|ArgsB],
   unify_args(ArgsA,ArgsB).
   
unify_args([A|TA],[B|TB]):-
   unify(A,B),
   unify_args(TA,TB).
unify_args([],[]).
&#34;&#34;&#34;</span><span>)</span>
</code></pre></div></div>

<p>bottom up ho unify is simpler. Dowek. Maybe anmm inverse method/magic set is in order.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
