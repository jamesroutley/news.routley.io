<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cloud.google.com/blog/products/compute/the-worlds-largest-distributed-llm-training-job-on-tpu-v5e">Original</a>
    <h1>Google Cloud TPU Multislice Training</h1>
    
    <div id="readability-page-1" class="page"><div><div><div jsname="tx2NYc"><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>With the boom in generative AI, the size of foundational large language models (LLMs) has grown exponentially, utilizing hundreds of billions of parameters and trillions of training tokens.</p></span></section><section></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>Training these kinds of large LLMs require tens of exa-FLOPs (10^18 FLOPs) of AI supercomputing power, which is typically distributed across large clusters that contain tens of thousands of AI accelerator chips. But utilizing large-scale clusters for distributed machine learning (ML) training presents many common and key technical challenges.</p><ol><li><b>Orchestration:</b> The software stack that is used for distributed training needs to manage all of these chips and scale as high as possible to accelerate training times. This stack also needs to be reliable, fault tolerant, and resilient in order to ensure training progress.</li><li><b>Compilation</b>: As training progresses, the computation and communication that happen across the chips need to be managed effectively by a high-performance compiler.</li><li><b>End-to-end optimization</b>: Distributed training at large scale requires deep expertise throughout both the ML training stack and the end-to-end ML training workflow, from storage and compute to memory and networking.</li></ol><h3>Google Cloud TPU Multislice Training</h3><p>To address each of the above distributed training challenges across orchestration, compilation, and end-to-end optimization, today we announced the general availability of Cloud TPU Multislice Training. This full-stack training offering — supporting TPU v4 and v5e — is built from the ground up to be scalable, reliable, and easy-to-use for end-to-end optimization of ML training. With Multislice, you can leverage Google’s cost-efficient, versatile, and scalable Cloud TPUs for training ML models efficiently and at large scale.</p></span></section><section></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>Cloud TPU Multislice Training has the following key features:</p><ol><li><b>Robust orchestration and scalability:</b> Scale large model training across tens of thousands of TPU chips in a reliable and fault-tolerant way across the training workflow.</li><li><b>Performant compilation:</b>Maximize performance and efficiency using the XLA compiler to automatically manage compute and communication.</li><li><b>Flexible stack for end-to-end training:</b> Provide first-class support for popular ML frameworks such as JAX and PyTorch, easy-to-use reference implementations and libraries, and support for a wide range of model architectures including LLMs, diffusion models and DLRM.</li></ol><p>Here we highlight some of the key components in the overall Multislice Training stack, many of which we have open-sourced in order to continue contributing to the broader AI/ML community:</p><ol><li><a href="https://github.com/google/xpk" target="_blank">Accelerated Processing Kit (XPK)</a> is an ML cluster and job orchestration tool built to be used with Google Kubernetes Engine (GKE) to standardize the best practices for orchestrating ML jobs. XPK focuses on ML semantics for creating, managing, and running ML training jobs to make it easier for machine learning engineers (MLE) to use, manage, and debug. XPK decouples provisioning capacity from running jobs through separate APIs.</li><li><a href="https://github.com/google/maxtext" target="_blank">MaxText</a> is a performant, scalable, and adaptable JAX LLM implementation. This implementation is built on top of open-source JAX libraries such as <a href="https://github.com/google/flax" target="_blank">Flax</a>, <a href="https://github.com/google/orbax" target="_blank">Orbax</a>, and <a href="https://github.com/google-deepmind/optax" target="_blank">Optax</a>. MaxText is a decoder-only LLM implementation written in pure Python, making it much easier for MLEs to understand, adapt, and modify. MaxText also leverages the XLA compiler heavily, making it easy for MLEs to achieve high performance without needing to build custom kernels. XLA through <a href="https://github.com/openxla/xla" target="_blank">OpenXLA</a> is an open-source ML compiler for a variety of hardware accelerators, such as TPUs, GPUs, CPUs, and others.</li><li><a href="https://github.com/google/aqt" target="_blank">Accurate Quantized Training (AQT)</a> is a Google-built training library that uses reduced numerical precision of 8-bit integers (INT8) instead of 16-bit floats (BF16) for training. AQT takes advantage of the fact that ML accelerators have 2X the compute speed when using INT8 operations versus BF16 operations. Using AQT’s simple and flexible API, MLEs can attain both higher performance during training and also higher model quality in production.</li></ol><p><b>Google Cloud TPU ran the world’s largest distributed training job for LLMs across 50,000+ TPU v5e chips</b></p><p>We used Multislice Training to run what we believe to be the world’s largest publicly disclosed LLM distributed training job (in terms of the number of chips used for training) on a compute cluster of 50,944 Cloud TPU v5e chips (spanning 199 Cloud TPU v5e pods) that is capable of achieving 10 exa-FLOPs (16-bit), or 20 exa-OPs (8-bit), of total peak performance. To give a sense of scale, this cluster of Cloud TPU v5e chips has more AI accelerators than the <a href="https://www.ornl.gov/news/frontier-supercomputer-debuts-worlds-fastest-breaking-exascale-barrier" target="_blank">TOP1 Supercomputer Frontier at Oak Ridge National Laboratory</a>, which featured <a href="https://en.wikipedia.org/wiki/Frontier_(supercomputer)" target="_blank">37,888 AMD M1250X GPUs</a></p><h3>Setting up the LLM distributed training job on Cloud TPU v5e</h3><p>We performed our large-scale LLM distributed training job using Cloud TPU Multislice Training on <a href="https://cloud.google.com/blog/products/compute/announcing-cloud-tpu-v5e-and-a3-gpus-in-ga">Cloud TPU v5e</a>. A Cloud TPU v5e pod consists of 256 chips connected via high-speed inter-chip interconnect (ICI). These pods are connected and communicate using Google’s <a href="https://cloud.google.com/blog/topics/systems/the-evolution-of-googles-jupiter-data-center-network">Jupiter data center networking</a> (DCN). We set up this distributed training job on the JAX framework, utilizing XPK, GKE, MaxText, AQT, and other components of the JAX training stack. The rest of this blog focuses on the JAX training stack portion of Cloud TPU Multislice Training.</p><p>We trained multiple MaxText models in various sizes of 16B, 32B, 64B, and 128B parameters. For each model, we scaled the training using data parallelism (DP) across pods over DCN, where each pod stores its own replica of the model. Then, each replica of the model is sharded across chips within a pod over ICI using fully sharded data parallelism (FSDP) for the 16B, 32B, and 64B configurations, and a mix of FSDP and tensor parallelism (TP) for the 128B configuration.</p></span></section><section></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>We managed TPU capacity with <a href="https://cloud.google.com/kubernetes-engine">Google Kubernetes Engine (GKE)</a> and utilized XPK on top of GKE to orchestrate ML jobs. XPK handles creating clusters, resizes them as necessary, submits jobs into the GKE <a href="https://github.com/kubernetes-sigs/kueue" target="_blank">Kueue</a> system as <a href="https://github.com/kubernetes-sigs/jobset" target="_blank">JobSets</a>, manages those Jobsets, and provides visibility into the state of the cluster.</p><p>To accelerate model training, we used the <a href="https://docs.google.com/document/d/1TyEdSSXlNcjgLuqd0w_bICFINMM-poYxzpkzqa2YB6o/edit?resourcekey=0-3n8xkMT1abcN3WcgoLARYQ" target="_blank">Accurate Quantized Training (AQT)</a> library to train in quantized INT8. As of October 2023, this approach enables a <a href="https://docs.google.com/document/d/1TyEdSSXlNcjgLuqd0w_bICFINMM-poYxzpkzqa2YB6o/edit?resourcekey=0-3n8xkMT1abcN3WcgoLARYQ" target="_blank">1.2X to 1.4X acceleration</a> in steps per second while producing a convergence gap smaller than that normally associated with quantizing a model trained in BF16 to INT8.</p><h3>How we scaled the largest distributed LLM training job</h3><p>As we scaled our TPU compute cluster, we began to push the limits of the stack.</p><p><b>Orchestration<br/></b>Managing over 50,000 accelerator chips working on a single training job requires a well-designed orchestration solution that enables both different users to submit smaller jobs for experiments as well as supporting a full-scale job that runs on the entire cluster. This functionality is provided through GKE’s <a href="https://github.com/kubernetes-sigs/jobset" target="_blank">Jobset</a> and <a href="https://kueue.sigs.k8s.io/" target="_blank">Kueue</a> features. As we pushed the limits on the number of VMs that GKE could handle, we optimized managing internal IP addresses, precaching docker images, designed clusters for scale, and enabled high-throughput scheduling. We also optimized GKE to push VM scaling limits in areas such as pod IP exhaustion, Domain Name Service (DNS) scalability, and control-plane node limits. We packaged and <a href="https://github.com/google/xpk/blob/main/xpk-large-scale-guide.sh" target="_blank">documented these solutions</a> alongside <a href="https://github.com/google/maxtext/tree/main/xpk" target="_blank">XPK</a> to make this a repeatable process for customers training at this massive scale.</p><p><b>Performance<br/></b>JAX is powered by XLA (Accelerated Linear Algebra), a compiler-based linear algebra execution engine that optimizes workloads for ML accelerators like TPUs and GPUs to deliver supercomputer-like performance. The key parallelism technique behind XLA is SPMD (single program, multiple data) where the same computation is run in parallel on different devices. XLA leverages <a href="https://arxiv.org/abs/2105.04663" target="_blank">GSPMD</a> which simplifies SPMD programming by allowing the user to program a single giant supercomputer and then automatically parallelizing the computation across devices based on a few user annotations. Running at large scale exposed the need for optimizations that only become necessary with a large number of slices. For example, each worker VM needs to communicate over DCN with the worker VMs of the same rank in other slices. Originally, this caused slowdowns due to excess device-to-host and host-to-device transfers that scaled linearly with the number of slices. By optimizing the XLA runtime, we were able to prevent these transfers from being the bottleneck.</p><p><b>Storage<br/></b>Interacting with persistent storage is a crucial aspect of training. Our 199-pod cluster had 1 Tb/s to Google Cloud Storage (GCS), 1,270 Tb/s inter-slice DCN, and 73,400 Tb/s intra-slice ICI. When loading docker images, loading data, and reading/writing checkpoints, we optimized the interaction with persistent storage.</p><p>We found that at large scale, data loading from GCS began to affect performance, starting at 64 pods scale. We have since mitigated this limit with a <a href="https://github.com/google/maxtext/pull/187" target="_blank">distributed data loading strategy that alleviates pressure on GCS by having a subset of hosts load data.</a></p><p>We also found limits due to checkpointing. By default, checkpointing loads the full checkpoint into each data parallel replica from GCS. Consider checkpoint loading for a 128B model sharded with cross-pod data parallelism. For a traditional optimizer state of three numbers per parameter (4bytes/number), this means loading a checkpoint of size ~1.536 TB separately into each pod (in this case for 199 pods). This would require 199 pods * 1.536TB/pod, or approximately 300TB of bandwidth. For reasonable performance from persistent storage of 1 Tb/s, this would require approximately 2,400 seconds (40 minutes). However, we needed much lower start or restart time, so had to take a different approach.</p><p>To alleviate the problem, we added features that enabled a <a href="https://github.com/google/maxtext/pull/187" target="_blank">single pod to load the checkpoint and broadcast it</a> to the other replicas. As a result, a single pod can read the checkpoint and then broadcast the optimizer state to the other pods by leveraging the flexibility of JAX. In principle, this should take 1.536TB/1Tb/s = ~12 seconds to load the checkpoint and then (2*1.536TB/pod) / (64 VM/per pod * 100 Gb/s/VM) = ~4 seconds to gather the optimizer state across the cluster, for a total of 16 seconds and a 150x speedup. Similarly, optimizations are needed when writing checkpoint data and loading training data. At write-time, a single leader replica can then write the entire checkpoint to avoid excessive QPS to GCS.</p><h3>How did we measure training performance?</h3><p>Training performance is measured in terms of Model FLOPs Utilization (MFU) and Effective Model FLOPs Utilization (EMFU). For an N-parameter decoder-only model, each token seen requires 6N matmul FLOPs for the learnable weights and 12LHQT matmul FLOPs for attention where L, H, Q, and T are the number of layers, the number of heads, the head dimension, and the sequence length respectively (see Appendix B of the <a href="https://arxiv.org/pdf/2204.02311.pdf" target="_blank">PaLM paper</a> for more details). Knowing the TFLOPs required for each token, we can represent the throughput of a step as observed TFLOP/chip/s which is computed as the total TFLOPs required for all tokens seen in the step for each chip divided by the step time.</p></span></section><section></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>We can then compute MFU by dividing the observed TFLOP/chip/s by the peak TFLOP/chip/s of the hardware (197 TFLOP/chip/s for TPU v5e).</p></span></section><section></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>EMFU broadens observed TFLOP/chip/s to observed TOP/chip/s (tera-operations/chip/s), which encapsulates both quantized operations and floating point operations. However, since the observed TOP/chip/s for quantized operations can be larger than the peak TFLOP/chip/s for floating point operations, it is possible to achieve greater than 100% EMFU.</p></span></section><section></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><h3>Largest LLM distributed training job scalability results</h3><p>For each model size (16B, 32B, 64B, 128B), we ran a sweep of training jobs, scaling the number of TPU v5e pods from 1 to 160. We saw as high as 66.86% MFU with BF16 training on a single TPU v5e pod and strong scaling outcomes when expanding to 160 pods. We also ran jobs exercising the entire 199-pod cluster with both BF16 training and INT8 quantized training (using AQT), achieving an impressive observed 5.32 exa-OP/s with INT8 quantized training. This scaling study was done with limited software optimizations across the Multislice Training JAX stack, and we will continue improving our software stack.</p></span></section><section></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><h3>Future work</h3><h2>Job start-up time</h2><p>Along with measuring training performance, we also measured the start-up time of our ML jobs on the cluster, which scaled near-linearly with the number of chips.</p></span></section><section></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>The start times we observed were impressive, but we believe we can improve these even further. We are working on areas such as optimizing scheduling in GKE to increase throughput and enabling ahead-of-time compilation in MaxText to avoid just-in-time compilations on the full cluster.</p><h2>Scaling efficiency</h2><p>We achieved excellent scaling across 50,944 TPU v5e chips, but we believe we can improve this even further. We’ve identified and are currently working on changes in the compiler and MaxText to improve stability and performance at large scale. We are considering scalable solutions such as hierarchical DCN collectives and further optimizing compiler scheduling in multipod regimes.</p></span></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Bn5EmqU.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Bn5EmqU.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Bn5EmqU.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Bn5EmqU.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><p><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>Google Internal data for TPU v5e As of November, 2023: All numbers normalized per chip. seq-len=2048 for 32 billion parameter decoder only language model implemented using MaxText. *2</p></span></p></section></div></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><h3>Conclusion</h3><p>Google Cloud TPU Multislice Training was built from the ground up to address the challenges of distributed ML training in orchestration, compilation, and end-to-end optimization. We demonstrated the benefits of Cloud TPU Multislice Training with what we believe is the largest publicly disclosed LLM distributed training job in the world (in terms of number of chips used for training) on a compute cluster of 50,944 Cloud TPU v5e chips on the JAX ML framework, utilizing both BF16 and INT8 quantized training.</p><p>As generative AI continues to trend towards bigger and bigger LLMs, we will continue to push the boundaries of innovation needed to further scale and improve our software stack. We have open-sourced all the code used in this project. Please check out our open-source repositories for <a href="https://github.com/google/maxtext" target="_blank">MaxText</a>, <a href="https://github.com/google/maxtext/tree/main/xpk" target="_blank">XPK</a>, <a href="https://github.com/google/aqt" target="_blank">AQT</a> and <a href="https://github.com/openxla/xla" target="_blank">XLA</a>. To learn more about Google Cloud TPU Multislice Training and how to use it with Cloud TPUs to accelerate your generative AI projects, please contact your <a href="https://cloud.google.com/contact">Google Cloud account representative</a>.</p><hr/><p><i><sup>This work constituted a massive effort across Google Cloud as well as multiple teams within Google. Special thanks to Raymond Zou, Rafi Witten, Lukasz Lew, Victor Barr and Andi Gavrilescu for their immense contributions to developing all of the components that made this project a success.</sup></i></p></span></section><section><section><span>Posted in</span><ul><li><a href="https://cloud.google.com/blog/products/compute" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/products/compute" track-metadata-module="tag list" track-metadata-module_headline="posted in">Compute</a></li><li><a href="https://cloud.google.com/blog/products/ai-machine-learning" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/products/ai-machine-learning" track-metadata-module="tag list" track-metadata-module_headline="posted in">AI &amp; Machine Learning</a></li></ul></section></section></div></div></div></div>
  </body>
</html>
