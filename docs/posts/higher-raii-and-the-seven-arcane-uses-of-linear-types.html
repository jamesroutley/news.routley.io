<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/higher-raii-uses-linear-types">Original</a>
    <h1>Higher RAII and the seven arcane uses of linear types</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
    <div>
  

        <div>
          <div>
  

            <div>
    

              
    

              <p>Linear types + whitelisted destroyers = powers yet unimagined!</p>
        

              <p><span>May 14, 2024</span>
        

                <span> — </span>
          

                
        

              </p>
      

            </div>
    
<section>
<div><p>
Also posted today: <a href="https://verdagon.dev/blog/llm-throughput-not-ram-limited">Layer-wise inferencing + batching: Small VRAM doesn&#39;t limit LLM throughput anymore</a>, on how even a normal small computer can now run huge LLMs, much more quickly!
</p></div>

</section>
<section>
<p>
Can you spot the problem in each of these comments?
</p>
<p>
<span>// Remember to update the database row with the new status.</span>
</p>
<p>
<span>// Remember to remove(&amp;cache, entityRef) before you destroy the entity!</span>
</p>
<p>
<span>// Remember to fulfill this promise with the result of the calculation.</span>
</p>

</section>
<section>
<p>
The problem, of course, is that they rely on our fallible human memory!
</p>

</section>
<section>
<p>
We&#39;d love a way to guarantee that we remember to do something. Unfortunately, today&#39;s compilers and languages can&#39;t really solve this problem for us.
</p>

</section>
<section>
<p>
But hark! We can change that, with <b>Higher RAII</b>, a technique where we use linear types that can only be destroyed in certain places.
</p>

</section>
<section>
<p><img src="https://verdagon.dev/images/asciigoblins.png" width="100%"/></p>


</section>
<section>
<h2 id="whats-a-linear-type">
 What&#39;s a linear type?</h2>

</section>
<section>
<p>
If you look up linear types online, you&#39;ll find a lot of unhelpful definitions, like <b>a linear type is a type that can&#39;t be aliased, can&#39;t be cloned, and must be &#34;used&#34; exactly once.</b> <a href="#note0" data-noteid="0">0</a>
</p>

</section>
<section>
<p>
That&#39;s somewhat unhelpful because, as Vale shows us, you can have a linear struct without any of the above restrictions.
</p>
<ul>
<li>
You can read/modify it as much as you like.
</li>
<li>
You can copy it.
</li>
<li>
You can make aliases to it.
</li>
</ul>

</section>
<section>
<p>
So for now, let&#39;s use a less correct but more helpful definition: <b>A linear struct must eventually be <i>explicitly</i> destroyed.</b> <a href="#note1" data-noteid="1">1</a>
</p>

</section>
<section>
<p>
In other words, a linear struct can&#39;t just go out of scope. When the user lets a linear struct go out of scope, the compiler gives an error.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Here we have a function that makes a linear struct <span>x</span>, makes a reference to it, and even reads its contents.
</p>
<p>
When <span>x</span> goes out of scope, we get a compile error.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code><span><span>linear struct <span>MyStruct</span> {</span>}</span></code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
Other languages might automatically clean it up, or call a destructor or <span>drop()</span> method, but here we&#39;ve opted into the compiler error instead.
</p>

</section>
<section>
<p>
If we put in the line <span>destruct x;</span>, it would resolve the compiler error.

</p>

</section>
</div>
</div>

</section>
<section>
<p>
This might seem like a weird restriction, but if we use it in a certain way, it can unlock some rather amazing capabilities:
</p>
<ul>
<li>
Keep your caches consistent with your data
</li>
<li>
Prevent zombie temporary states
</li>
<li>
Prevent concurrency bugs and ensure messages are handled
</li>
<li>
Help with database consistency; prevent forgotten updates
</li>
<li>
Prevent certain kinds of memory leaks (even GC or Rust leaks!)
</li>
<li>
Prevent accidentally canceling an ongoing thread or connection
</li>
<li>
Prevent an accidental rollback of a perfectly good transaction
</li>
<li>
Guarantee a provided callback is actually called
</li>
<li>
Guarantee we eventually log something
</li>
</ul>

</section>
<section>
<p>
So how can linear types help with all of that?
</p>
<p>
The answer is something I call <b>Higher RAII</b>, explained in the next section.
</p>

</section>
<section>
<p>
By the way, if linear types intrigue you, also check out this Developer Voices interview where I talked with Kris Jenkins about them:
</p>
<p>
<iframe name="ytvid1" src="https://www.youtube.com/embed/UavYVf0UEoc" title="Advanced Memory Management in Vale (with Evan Ovadia)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</p>
<p>
At <a href="https://www.youtube.com/embed/UavYVf0UEoc?start=958&amp;end=1000" target="ytvid1">time 15:48</a> I talked a bit about how we can use linear types for Higher RAII, but the potential is so much more vast than I hinted in that interview. Read on to find out!
</p>

</section>

      </div>
  
<div>

      <nav>
      <p>Higher RAII, and the Seven Arcane Uses of Linear Types</p>
    


      </nav>
      
    

      <div>
        <div>
    
<div id="note0" data-noteid="0">
<p><span>0</span></p><section>
<p>
 Some definitions:
</p>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems">Wikipedia</a>: &#34;Linear types correspond to linear logic and ensure that objects are used exactly once.&#34;
</li>
<li>
<a href="https://medium.com/@martriay/rust-and-linear-types-a-short-guide-4845e9f1bb8f">martriay</a>: &#34;the constraint that each variable can be used exactly once&#34; (though they explain the motivations really well)
</li>
<li>
<a href="https://www.cs.cornell.edu/courses/cs4110/2018fa/lectures/lecture29.pdf">Cornell</a>: In linear logic, you have to “use” every premise exactly once to construct the conclusion.]
</li>
<li>
<a href="https://austral-lang.org/linear-types">austral-lang.org</a>: a value of a linear type is a value that can only be used once.
</li>
</ul>

</section>
</div>
<div id="note1" data-noteid="1">
<p><span>1</span></p><section>
<p>
 One can reconcile the two definitions with enough mental acrobatics. We could say that marking a Vale struct as <span>linear</span> means its <i>owning reference</i> is linear.
</p>
<ul>
<li>
We&#39;d define &#34;use&#34; as &#34;destroy&#34;; now we can only use the linear type once.
</li>
<li>
Even though we can alias the struct (with a generational reference), we can&#39;t alias/clone the owning reference.
</li>
<li>
We can still read/modify the contents of the struct, but we can&#39;t directly read/modify the owning reference&#39;s underlying pointer.
</li>
</ul>


</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="higher-raii--linear-types--whitelisted-destroyers">
 Higher RAII = Linear types + whitelisted destroyers</h2>

</section>
<section>
<p>
Recall that <b>a linear struct must eventually be explicitly destroyed.</b>
</p>
<p>
Now, imagine a struct that must eventually be explicitly destroyed <b>by a specific function</b> (or functions).
</p>

</section>
<section>
<p>
We say that struct has <b>Higher RAII.</b>
</p>
<p>
I&#39;ll explain that term in a bit, <a href="#note2" data-noteid="2">2</a> but first, let&#39;s see an example!
</p>

</section>
<section>
<p>
Imagine a <span>Transaction</span> struct that must eventually be <span>commit</span>ted or <span>rollback</span>ed.
</p>
<p>
In today&#39;s mainstream languages, <a href="#note3" data-noteid="3">3</a> the user might forget to call <span>commit</span> or <span>rollback</span>, causing the transaction to hang or make a guess. <a href="#note4" data-noteid="4">4</a> This cost me a few hours the other day in my <a href="https://verdagon.dev/blog/llm-throughput-not-ram-limited#background-the-flora-bama-mullet-toss">weird event collector</a>, when I didn&#39;t <span>commit</span> one of my transactions.
</p>

</section>
<section>
<p>
To set up a <span>Transaction</span> struct with Higher RAII, we need to do three things.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
First, <b>make the struct linear</b>.
</p>
<p>
Here&#39;s some Vale as an example. <a href="#note5" data-noteid="5">5</a>

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code><span><span>linear struct <span>Transaction</span> </span>{</span></code></pre>
    </div>
  


</section>
</div>
</div>
<p>
This means the struct can never go out of scope; it can never be automatically destroyed. It must be <i>explicitly</i> destroyed now, such as with Vale&#39;s <span>destruct</span> keyword, shown below.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Second, <b>create the functions</b> that take the object and explicitly <span>destruct</span> it.
</p>

</section>
<section>
<p>
Here&#39;s our <span>commit</span> and <span>rollback</span> functions.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code><span>// (same file as struct Transaction)</span></code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
Note the <span>Transaction</span> parameter isn&#39;t <span>&amp;Transaction</span>; the functions take the instance itself, not a reference.
</p>

</section>
<section>
<p>
They then <span>destruct</span> the <span>Transaction</span>.

</p>

</section>
</div>
</div>

</section>
<section>
<p>
Third, make sure that <b><i>only</i> those functions can destroy the object</b>. 
</p>
<p>
In Vale, you don&#39;t actually have to do anything for this step: <span>destruct</span> can only be used from the file defining the struct.
</p>

</section>
<section>
<p>
<b>Success!</b> We&#39;re now guaranteed to <span>commit</span> or <span>destroy</span> every <span>Transaction</span> object.
</p>

</section>
<section>
<p>
More specifically, the user can&#39;t accidentally let the <span>Transaction</span> go out of scope, the compiler would notice and give a compile error. The only remaining option for the user is to move the object somewhere else, or destroy it via <span>commit</span> or <span>rollback</span>.
</p>

</section>
<section>
<p>
Zooming out, you can see how <b>this struct can only be destroyed by certain explicit operations</b>, which means we&#39;ve successfully enabled Higher RAII here.
</p>

</section>
<section>
<p>
This mechanism has <i>huge</i> benefits if used well, for example by keeping caches consistent or enforcing we update a database, as I&#39;ll list further below.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note2" data-noteid="2">
<p><span>2</span></p><section>
<p>
RAII stands for &#34;Resource Acquisition is Initialization&#34;, which is a secret key phrase that we C++ programmers whisper at the door to get into our secret covert gatherings. Careful: if they suspect you&#39;re an impostor, you&#39;ll be SFINAEd.
</p>

</section>
</div>
<div id="note3" data-noteid="3">
<p><span>3</span></p><section>
<p>
C++ and Rust&#39;s RAII can get halfway, but they can only implicitly call a single zero-arg void-returning function, the destructor. Some pretty amazing things happen when you can choose among multiple destructors with parameters and returns.
</p>

</section>
</div>
<div id="note4" data-noteid="4">
<p><span>4</span></p><section>
<p>
The most common strategy is to default to <span>rollback</span>, thankfully.
</p>

</section>
</div>
<div id="note5" data-noteid="5">
<p><span>5</span></p><section>
<p>
The HEAD version does this, stable and older versions still use the <span>#!DeriveStructDrop</span> keyword.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="why-havent-we-seen-this-before">
 Why haven&#39;t we seen this before?</h2>
<p>
(Or <a href="#the-seven-arcane-uses">skip to the Seven Arcane Uses</a>)
</p>

</section>
<section>
<p>
Existing languages can&#39;t quite do this, and I&#39;ll show why below.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="c">
 C++</h3>
<p>
A C++ class&#39;s destructor is guaranteed to be eventually run, so if we ever want to guarantee some future action, we just put the code in an object&#39;s destructor (which is guaranteed to run when the object goes out of scope), and keep the object alive until we want that code to run.
</p>
<p>
Scott Meyers <a href="https://youtu.be/ltCgzYcpFUI?t=937">once said</a> that &#34;the single most important feature in the language is probably destructors, because destructors have led to the introduction of RAII.&#34; <a href="#note6" data-noteid="6">6</a>
</p>
<p>
RAII stands for &#34;Resource Acquisition Is Initialization&#34;, a pattern where if you <b>acquire</b> a <b>resource</b> (such as a file descriptor), you should <b>initialize</b> an object with it. Then, the object can make sure to automatically release (such as with <span>fclose</span>) the resource when it goes out of scope. <a href="#note7" data-noteid="7">7</a>
</p>

</section>
<section>
<p>
Unfortunately, a C++ class can only have one destructor function, and our <span>Transaction</span> struct (from above) needs two.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
A <a href="https://stackoverflow.com/a/10984171/1424454">common half-solution</a> is to:
</p>
<ol>
<li>
Put the above <span>db</span> parameter in as a class member <span>DB* db;</span>, since C++ destructors have no parameters. Note this isn&#39;t always possible. <a href="#note8" data-noteid="8">8</a>
</li>
<li>
Have a <span>commit</span> method, which also sets a <span>committed</span> boolean to true.
</li>
<li>
In the destructor, run <span>rollback</span>&#39;s logic if the <span>committed</span> boolean is false.
</li>
</ol>
<p>
Alas, this doesn&#39;t quite solve the problem because the user still might forget to call <span>commit</span> where they should have.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code>struct Transaction {
  DB* db;
  bool committed = false;

  ...

  // Don&#39;t forget to call this!
  void commit() {
    ... // Commit to db
    committed = true;
  }

  // Destructor
  ~Transaction() {
    if (!committed) {
      ... // Rollback logic
    }
  }
}</code></pre>
    </div>
  


</section>
</div>
</div>


</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note6" data-noteid="6">
<p><span>6</span></p><section>
<p>
He goes on to describe how RAII is a general purpose undo mechanism. I would totally agree, except for the way C++ conflated destructors with exception handling. If they didn&#39;t use the same function for those two concerns, they could tap into the potential of Higher RAII.
</p>

</section>
</div>
<div id="note7" data-noteid="7">
<p><span>7</span></p><section>
<p>
The hardest thing about RAII is explaining the name. Similar to monads, which are like <a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">stateful burritos</a>.
</p>

</section>
</div>
<div id="note8" data-noteid="8">
<p><span>8</span></p><section>
<p>
This isn&#39;t always possible, for example if we don&#39;t know the parameter value yet at construction time. Imagine <span>commit</span> wanted a <span>priority</span> integer, only knowable from reading the database while inside the transaction.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="rust">
 Rust</h3>
<p>
Rust is unfortunately even less capable than C++ here.
</p>
<p>
Rust can almost do C++&#39;s workaround, but the borrow checker generally dislikes references inside structs, such as that <span>DB</span> reference. <a href="#note9" data-noteid="9">9</a>
</p>
<p>
Rust&#39;s workarounds include either using <span>unsafe</span>, using <span>Rc&lt;RefCell&lt;DB&gt;&gt;</span>, or if one considers those unidiomatic, giving up on RAII. I prefer the second, though I&#39;ve seen all three happen in the wild.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note9" data-noteid="9">
<p><span>9</span></p><section>
<p>
More specifically, Rust structs containing references generally work well as long as they stay within the same function. But at that point, we might as well be using <span>defer</span>.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="raii-vs-higher-raii">
 RAII vs Higher RAII</h3>
<p>
Summarizing the C++ section above, RAII is the practice of putting code in destructors that you want to guarantee will eventually run.
</p>
<p>
From that context, we could say that <i>higher</i> RAII is when we can have multiple named destructors, destructors with parameters, destructors with return values, and we can force the user to explicitly call one of them.
</p>

</section>
<section>
<p>
Whereas RAII eventually makes us implicitly call a specific zero-arg non-returning function (the destructor), Higher RAII eventually makes us explicitly call <i>any</i> approved function.
</p>

</section>
<section>
<p>
RAII is a terrible acronym, and I am <i>so, so sorry</i> for perpetuating its use. It turns out it&#39;s really hard to come up with a name for this concept. <a href="#note10" data-noteid="10">10</a> Feel free to bikeshed in the comments!
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note10" data-noteid="10">
<p><span>10</span></p><section>
<p>
&#34;Future constraint&#34;, &#34;future calling&#34; perhaps? &#34;Vow Objects&#34; maybe? I wish &#34;Promise&#34; wasn&#39;t taken.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="whats-the-difference-between-raii-and-defer">
 What&#39;s the difference between RAII and defer?</h3>
<p>
Go, Zig, and a few other languages have a <span>defer</span> statement which will run a statement at the end of the current scope (or function). <a href="#note11" data-noteid="11">11</a>
</p>
<p>
In RAII, we would put that code into an object&#39;s destructor, and the code will be run when the object goes out of scope.
</p>

</section>
<section>
<p>
They sound like two equivalent approaches, but RAII is more flexible: we can return the object to our caller, so the caller can decide when the destructor is run. Or, we put the object into another object, and the parent object can decide when it&#39;s run.
</p>
<p>
In short: <span>defer</span> can make sure something happens at the end of your function, but RAII can make sure that something happens <i>even past</i> the end of your function.
</p>

</section>
<section>
<p>
Now that we see the differences between Higher RAII and RAII and defer, let&#39;s see some more examples!
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note11" data-noteid="11">
<p><span>11</span></p><section>
<p>
 Zig runs a <span>defer</span>&#39;d statement at the end of the scope, as god intended.
</p>
<p>
Golang is different. For some reason, even if we <span>defer</span> from an inner scope, the <span>defer</span>&#39;d statement will run it at <a href="https://stackoverflow.com/a/49457047/1424454">the end of the function</a>. This can sometimes lead to surprising out-of-memory crashes.
</p>
<p>
Golang, I want to love you, I really do, but every time I get used to your latest nonsense you do something like this.

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="the-seven-arcane-uses">
 The Seven Arcane Uses <a href="#note12" data-noteid="12">12</a> <a href="#note13" data-noteid="13">13</a></h2>
<p>
There are, of course, more than seven ways to use linear types and Higher RAII.
</p>
<p>
But behold! Here are the seven most useful ones that I&#39;ve seen.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note12" data-noteid="12">
<p><span>12</span></p><section>
<p>
I call them &#34;arcane&#34; because they seem confusing at first, but once you know the technique, it unlocks some pretty incredible powers. Makes one feel rather... <i>sorcerous</i>.
</p>

</section>
</div>
<div id="note13" data-noteid="13">
<p><span>13</span></p><section>
<p>
Perceptive readers will notice that there&#39;s actually eight items here, but seven sounded cooler than eight, and some of them are similar to each other. Besides, everyone already knows I can&#39;t count after <a href="https://verdagon.dev/grimoire/grimoire">the last article</a>.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="cache-invalidation">
 Cache Invalidation</h3>
<p>
There are <a href="https://martinfowler.com/bliki/TwoHardThings.html">two hard problems in computer science</a>: cache invalidation, naming things, and off-by-one errors.
</p>
<p>
Luckily, naming things is a <a href="https://sph.mn/dynamic/svn">solved problem</a>.
</p>
<p>
But how can Higher RAII help with cache invalidation?
</p>

</section>
<section>
<p>
This was the topic of my 2022 article, <a href="https://verdagon.dev/blog/higher-raii-7drl">Vale&#39;s Higher RAII, the pattern that saved me a vital 5 hours in the 7DRL Challenge</a>.
</p>
<p>
I&#39;ll try to summarize below, but check out the article for a more in-depth explanation!
</p>

</section>
<section>
<p>
My game had two data structures:
</p>
<ul>
<li>
<span>levelGoblins List&lt;Goblin&gt;</span>
</li>
<li>
<span>locationToGoblinCache HashMap&lt;Location, &amp;Goblin&gt;</span>
</li>
</ul>
<p>
...and they must always be in sync.
</p>
<p>
<b>This, of course, had a risk:</b> I could accidentally remove from the list but not the cache.
</p>
<p>
So I did two things:
</p>
<ul>
<li>
Made a <span>linear struct GoblinInCacheToken</span>, returned by <span>addGoblinRefToCache</span>, and only ever destroyed by <span>removeGoblinRefFromCache</span>.
</li>
<li>
Changed <span>levelGoblins</span>&#39;s type to <span>List&lt;(Goblin, GoblinInCacheToken)&gt;</span>.
</li>
</ul>
<p>
Now, removing from <span>levelGoblins</span> will give us not only the <span>Goblin</span>, but also the linear <span>GoblinInCacheToken</span>, and the only way to get rid of the <span>GoblinInCacheToken</span> is to hand it to <span>removeGoblinRefFromCache</span>.
</p>

</section>
<section>
<p>
Suddenly, we&#39;ve <b>statically guaranteed</b> that we&#39;ll always remove from both the list and the cache! <a href="#note14" data-noteid="14">14</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note14" data-noteid="14">
<p><span>14</span></p><section>
<p>
 Easter egg note!
</p>
<p>
<a href="https://en.wikipedia.org/wiki/Cher_Ami">Cher Ami</a> was a carrier pigeon during World War I that served with the U.S. Army Signal Corps. Despite being shot and wounded by enemy fire, Cher Ami showed remarkable bravery and grit, delivering a crucial message that saved the lives of a trapped American battalion.
</p>
<p>
Cher Ami was awarded the Croix de Guerre, a French military honor, for her bravery.
</p>
<p>
If you read this note, sneak the word &#34;pigeon&#34; into an <a href="https://news.ycombinator.com/item?id=40359886">HN</a>/<a href="https://www.reddit.com/r/programming/comments/1crqi4e/higher_raii_and_the_seven_arcane_uses_of_linear/">reddit</a> comment <a href="https://youtu.be/-UBgNREvlIo">try to sound sane</a>, to be awarded the highest honor I can bestow.
</p>
<p>
(Cheers to <a href="https://news.ycombinator.com/item?id=36691658">cbsmith</a>, <a href="https://news.ycombinator.com/item?id=36692089">kubanczyk</a>, <a href="https://www.reddit.com/r/programming/comments/14wu830/comment/jrklcry/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">TheGoldenMinion</a>, <a href="https://news.ycombinator.com/item?id=36691564">lovich</a>, <a href="https://www.reddit.com/r/programming/comments/14wu830/comment/jrkmjiw/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">padraig_oh</a>, and <a href="https://news.ycombinator.com/item?id=36691737">leksak</a> for the <a href="https://verdagon.dev/blog/easter-egg-notes">last one</a>!)

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="get-the-result-of-a-thread-or-future">
 Get the Result of a Thread or Future</h3>

</section>
<section>
<p>
C++&#39;s <span>std::future</span> (and Javascript&#39;s <span>Promise</span>) is conceptually a little box that, at some point, will contain the result of some long-running operation. 
</p>

</section>
<section>
<p>
For example, let&#39;s say that each <span>Goblin</span> on our level has a read-only (but expensive!) <span>determineAction</span> function.
</p>

</section>
<section>
<p>
In this <span>determineAction</span>, we want to do two things in parallel:
</p>
<ul>
<li>
Find a path to the player.
</li>
<li>
Figure out what to shout at the player if there is no path.
</li>
</ul>
<p>
That second step will involve calling an LLM on the GPU.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Our code could look like this Typescript here.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code>async function determineAction(
    level: Level,
    goblin: Goblin,
    player: Player) {

  // shoutPromise will eventually contain
  // the result string to shout.
  const shoutPromise: Promise&lt;string&gt; =
    callGPU(&#34;taunt&#34;, goblin.personality);

  // Some expensive pathfinding
  const path: Location[] =
    findPathAStar(
      level, goblin.loc, player.loc);

  // Bug here!
  return new FollowPathAction(path);
}</code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
Here, we&#39;re sending the goblin&#39;s personality array to the &#34;shout&#34; function on the GPU, which runs an LLM.
</p>
<p>
While that&#39;s going, we&#39;re doing some expensive pathfinding, to figure out if there&#39;s a path to the player.
</p>

</section>
<section>
<p>
Then at the end, we return what the goblin should do this turn.
</p>

</section>
<section>
<p>
<b>But wait! There&#39;s a bug here!</b>
</p>
<p>
We sent the request to the GPU, but forgot to actually <i>use</i> the result.

</p>

</section>
</div>
</div>

</section>
<section>
<div>
<div>
<section>
<p>
After many hours of debugging, we realize the problem, and change that last statement to this code.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code>  ...
  if (path) {
    return new FollowPathAction(path);
  } else {
    return new ShoutAction(
        await shoutPromise);
  }
}</code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
This is where Higher RAII could have helped: that <span>shoutPromise</span> should have been linear, so we remember to use it.

</p>

</section>
</div>
</div>

</section>
<section>
<p>
Some of you might have seen something like this! This is similar to C++&#39;s <span>[[nodiscard]]</span>, C#&#39;s <span>MustUseReturnValueAttribute</span>, or Rust&#39;s <span>#[must_use]</span>. However, those are easily foiled: we could e.g. put the result into a List, and then accidentally drop the List. Those measures only look shallowly at the current scope, they don&#39;t follow the value through the rest of its lifetime.
</p>

</section>
<section>
<p>
I suspect a lot of—maybe even all—<span>Promise</span>s should be linear.
</p>

</section>
<section>
<p>
The stakes are even higher in languages with <span>async</span>/<span>await</span> where concurrent code doesn&#39;t run until we <span>.await</span>, because <a href="http://www.randomhacks.net/2019/03/09/in-nightly-rust-await-may-never-return/">accidentally dropped Futures can cause concurrency bugs</a>. A linear <span>Future</span> solves that bug nicely.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="remember-to-resolve-a-future">
 Remember to Resolve a Future</h3>
<p>
In C++, you can give a <span>std::future&lt;string&gt;</span> to someone, with the understanding that eventually, you will put a <span>string</span> into it.
</p>

</section>
<section>
<p>
Hopefully you don&#39;t forget!
</p>

</section>
<section>
<p>
Or, we can use Higher RAII to make sure we remember. Here&#39;s how!
</p>

</section>
<section>
<div>
<div>
<section>
<p>
First, we make a linear type that represents &#34;our vow to put a string into that future&#34;.
</p>
<p>
We&#39;ll call it <span>FutureVow</span>. <a href="#note15" data-noteid="15">15</a>

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code><span><span>linear struct <span>FutureVow</span><span>&lt;<span>T</span>&gt;</span> {</span>}</span></code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
Then, we would make sure that whenever we make a <span>Future</span>, we also make a corresponding <span>FutureVow</span>.
</p>
<p>
In Vale, that would mean changing <span>Future</span>&#39;s constructor to also return the <span>FutureVow</span> at the same time, <a href="#note16" data-noteid="16">16</a> but one can imagine many mechanisms to ensure one is never created without the other.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Then, we add a function <span>set</span> which consumes our FutureVow.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code><span><span>func <span>set</span><span>&lt;<span>T</span>&gt;</span><span>(<span><span><span>vow</span> <span><span>FutureVow</span>&lt;<span>T</span>&gt;</span></span></span>, <span><span><span>x</span> <span>T</span></span></span>)</span> <span>{</span></span></span></code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
Now there&#39;s no way to get rid of a <span>FutureVow</span> except by calling this <span>set</span> function.

</p>

</section>
</div>
</div>

</section>
<section>
<p>
Success! Now it&#39;s guaranteed that we&#39;ll eventually set every <span>Future</span>&#39;s value. <a href="#note17" data-noteid="17">17</a> <a href="#note18" data-noteid="18">18</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note15" data-noteid="15">
<p><span>15</span></p><section>
<p>
I wanted to call it <span>Promise</span>, because this is literally a linear version of <span>std::promise</span>, but I don&#39;t want to confuse things with Javascript&#39;s <span>Promise</span> which is completely unrelated to this.
</p>

</section>
</div>
<div id="note16" data-noteid="16">
<p><span>16</span></p><section>
<p>
Not terribly difficult, just make the default constructor private and then make a new function called <span>Future</span> that returns a tuple.
</p>

</section>
</div>
<div id="note17" data-noteid="17">
<p><span>17</span></p><section>
<p>
&#34;Guarantee&#34; could be a strong word here. A determined programmer can get around this if they tried hard enough.
</p>

</section>
</div>
<div id="note18" data-noteid="18">
<p><span>18</span></p><section>
<p>
 <span>async</span>/<span>await</span> also helps to prevent this bug in some cases. With <span>async</span>/<span>await</span>, we don&#39;t manually resolve a future, we <span>return</span> a value instead, and compilers are pretty good at preventing forgotten <span>return</span> statements.
</p>
<p>
However, there are times in <span>async</span>/<span>await</span>-enabled languages where we still use raw futures, such as the <span>callGPU</span> example above.

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="prevent-zombie-temporary-states">
 Prevent Zombie Temporary States</h3>
<p>
By day, my computer helps me write articles like this one.
</p>
<p>
But by night, it <a href="https://verdagon.dev/blog/llm-throughput-not-ram-limited">uses an LLM to crawl the internet searching for sufficiently weird yearly events</a>, such as:
</p>
<ul>
<li>
<a href="https://tickets.canterburypark.com/events/2023/corgi-dog-races">Corgi Races</a> in Minnesota. <a href="https://youtu.be/tPuKyeVsfZY?t=93">Go Logan Handsomepants!</a>
</li>
<li>
<a href="https://www.florabama.com/mullet-toss">Flora-Bama Mullet Toss</a> where people in Florida throw fish into Alabama!
</li>
<li>
<a href="https://visitvirginiacitynv.com/events/world-championship-outhouse-races-virginia-city/">Outhouse Races</a>, which is... hard to explain.
</li>
</ul>

</section>
<section>
<p>
Every time it finds a possible event, it adds it to the <span>Event</span> list.
</p>
<p>
Then, we do some <a href="https://blogs.nvidia.com/blog/what-is-retrieval-augmented-generation/">retrieval-augmented generation</a> by googling for information about the event, analyzing each result with an LLM, and coalescing the relevant pages into a summary, updating the <span>summary</span> field and making it visible on the map.
</p>

</section>
<section>
<p>
Alas, this was in Python, so <b>I had a bug: I forgot to update the</b> <span>summary</span> <b>in some cases.</b>
</p>
<p>
This struct was forevermore stuck in its temporary <span>summary</span>-less state, like some sort of zombie stuck between one realm and the next. And since I only show <span>summary</span>&#39;d events on the map, it took me a while to realize a lot of events were missing.
</p>

</section>
<section>
<p>
If Python had Higher RAII, I could have prevented this bug!
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Here&#39;s how Vale would do it:
</p>

</section>
<section>
<p>
First, we&#39;d split our struct into two structs, <span>InProgressEvent</span> and <span>Event</span>.
</p>

</section>
<section>
<p>
Then, we&#39;d make a <span>finish</span> function to consume the <span>InProgressEvent</span> and return a new <span>Event</span> object with the new <span>summary</span>.
</p>

</section>
<section>
<p>
Suddenly, we&#39;re guaranteed to eventually give our <span>InProgressEvent</span> to <span>finish</span> to properly make it into an <span>Event</span>!

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code><span><span>linear struct <span>InProgressEvent</span> {</span>}</span></code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
Savvy metaprogrammers would recognize the above as a kind of <a href="https://cliffle.com/blog/rust-typestate/">type-state pattern</a>. <a href="#note20" data-noteid="20">20</a> Higher RAII completes the type-state pattern, by forcing the developer to drive the state machine to its final state.
</p>

</section>
<section>
<p>
I also could have used Higher RAII to make sure the tool always reflected its findings into the database. As it is now, the database contains six zombie in-progress events... I let them remain, to remind me why I need to translate the tool to Vale.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note19" data-noteid="19">
<p><span>19</span></p><section>
<p>
 <span>[name] = destruct event;</span> is just putting <span>event</span>&#39;s old members into new local variables, in this case <span>name</span>.

</p>

</section>
</div>
<div id="note20" data-noteid="20">
<p><span>20</span></p><section>
<p>
In the type-state pattern, we split one struct into many, to more closely match the data&#39;s state machine diagram.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="remember-to-handle-messages">
 Remember to Handle Messages</h3>
<p>
Let&#39;s say you have thread A and thread B.
</p>
<p>
How does thread A ask thread B to run a certain function <span>foo</span>?
</p>

</section>
<section>
<p>
You&#39;re probably thinking, we should have thread A send a <span>FooMessage</span> of some sort to thread B, and then thread B can handle it and call <span>foo</span>.
</p>
<p>
That works, but what if thread B accidentally forgets to call <span>foo</span>, and lets the <span>FooMessage</span> go out of scope? We&#39;d have a bug.
</p>

</section>
<section>
<p>
Higher RAII can help with this: we would make <span>FooMessage</span> linear, and make it so only <span>foo</span> can destroy it.
</p>
<p>
Now, if thread B receives a <span>FooMessage</span>, it can&#39;t forget to call <span>foo</span> on it.
</p>

</section>
<section>
<p>
I suspect a lot of—maybe even most—messages should be linear.
</p>

</section>
<section>
<p>
Also, if we send a <span>linear</span> message through a channel, the channel&#39;s receiving end needs to be <span>linear</span> as well. That&#39;s a good thing, because it forces us to handle all remaining messages before we drop the receiver.
</p>
<p>
This serendipitously solves some missed-message concurrency bugs that e.g. Golang channels and <a href="https://docs.rs/tokio/latest/src/tokio/sync/mpsc/chan.rs.html#523">Tokio channels</a> <a href="#note21" data-noteid="21">21</a> are vulnerable to.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note21" data-noteid="21">
<p><span>21</span></p><section>
<p>
 In <a href="https://docs.rs/tokio/1.37.0/src/tokio/sync/mpsc/chan.rs.html#523">chan.rs</a>&#39;s <span>Chan::drop</span>, the <span>while</span> loop drains the incoming message list and just drops them on the floor. Those poor forgotten messages!

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="remember-to-make-a-decision">
 Remember to Make a Decision</h3>
<p>
In the Higher RAII explanation above, we showed how we could make a <span>Transaction</span> object that can only be destroyed via a <span>commit</span> or a <span>rollback</span> function.
</p>

</section>
<section>
<p>
Let&#39;s include that in our Seven Arcane Uses, and even generalize it a bit: <b>If there is a future decision to be made, Higher RAII guarantees that we&#39;ll eventually make it.</b>
</p>

</section>
<section>
<p>
I sometimes wish there was something like this for real life.
</p>

</section>
<section>
<p>
&#34;Evan, think you&#39;re going to cancel that membership?&#34;
</p>
<p>
&#34;Don&#39;t know, still thinking about it.&#34;
</p>
<p>
&#34;How long do you plan on thinking about it?&#34;
</p>
<p>
&#34;Probably until after it automatically renews.&#34;
</p>

</section>
<section>
<p>
Alas, I didn&#39;t make the decision, and so the default action was taken: my membership was renewed.
</p>
<p>
Truly, life would be better with Higher RAII. <a href="#note22" data-noteid="22">22</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note22" data-noteid="22">
<p><span>22</span></p><section>
<p>
 No! The grimoire is compelling me to write this article and spread <b>the curse.</b>
</p>
<p>
Heed my words, <i>never use Higher RAII,</i> lest you be cursed to see all the places in other languages&#39; code where it could have been used to prevent a bug.
</p>
<p>
Every time you see the words &#34;remember to&#34;, &#34;forget&#34;, or &#34;responsible for&#34; in comments or design discussions, you&#39;ll see another place that Higher RAII could have helped.
</p>
<p>
Even among friends you will be alone, the only one able to see the spirits of bugs prowling, knowing their inevitability yet being powerless to prevent them, <a href="https://www.youtube.com/watch?v=6AcbHiJtbcM">limited by the technology of your time</a>. Such is the curse. Such is our fate.
</p>
<p>
I hesitate to spread it to you, my dear readers, but I am compelled by the grimoire and am powerless to stop. I takes all my strength to merely put this side note in, hoping that someone sees it and spreads my warning.

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="prevent-leaks">
 Prevent Leaks</h3>
<p>
We all know that manually-managed-memory languages (like C) can leak memory, from forgetting to call <span>free</span>. We also know that reference-counted languages can leak memory, from reference cycles.
</p>

</section>
<section>
<p>
Did you know that <b>even garbage collected languages</b> (like Java) <a href="https://stackoverflow.com/a/10619408/1424454">can have memory leaks too</a>?
</p>
<p>
Imagine the above cache invalidation example in Java: the forgotten <span>Goblin</span> reference in the <span>HashMap&lt;Location, Goblin&gt; locationToGoblinCache</span> will prevent the GC from reclaiming it, effectively &#34;leaking&#34; it.
</p>
<p>
So we can already see how Higher RAII could help with leaks, by preventing that kind of accidental outstanding strong reference.
</p>

</section>
<section>
<p>
Of all the mainstream languages, I&#39;d say modern C++ is the most resistant to memory leaks, and you&#39;ll see why.
</p>

</section>
<section>
<p>
Surprisingly, Rust can be <b>more vulnerable to memory leaks</b> than C++! I&#39;ll show you what I mean by translating a C++ Red-Black tree to idiomatic Rust, and how it introduces the risk for memory leaks.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Let&#39;s say you have this C++ Red-Black Tree node class.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code>template&lt;typename T&gt;
class RBNode {
public:
  T data;
  unique_ptr&lt;RBNode&lt;T&gt;&gt; left;
  unique_ptr&lt;RBNode&lt;T&gt;&gt; right;
  RBNode&lt;T&gt;* parent;
  Color color;
};</code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
This has an implicit destructor. When we delete a node, the destructor will automatically delete (and call the destructors for) its <span>left</span> and <span>right</span> children.

</p>

</section>
</div>
</div>

</section>
<section>
<div>
<div>
<section>
<p>
Now let&#39;s translate this to Rust. The borrow checker doesn&#39;t like it when a node can be pointed at by multiple places, so we&#39;ll <b>&#34;collectionize&#34;</b>: we&#39;ll put all these nodes in a collection, a HashMap, and have nodes refer to each other by <span>u64</span> IDs.

</p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code>struct RBNode&lt;T&gt; {
  data: T,
  color: Color,
  parent: Option&lt;u64&gt;,
  left: Option&lt;u64&gt;,
  right: Option&lt;u64&gt;,
};</code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
We would store all these nodes in a <span>HashMap&lt;u64, RBNode&lt;T&gt;&gt;</span>, and separately keep track of which is the root node.
</p>
<p>
This is great! There&#39;s no way to use-after-free, which was a potential problem in the C++ version.
</p>

</section>
<section>
<p>
However, we&#39;ve just <b>introduced another possible bug.</b>
</p>
<p>
Remember how when we delete a C++ node, its destructor would automatically delete the node&#39;s children?
</p>
<p>
Unfortunately, that doesn&#39;t happen anymore in the Rust version. Rust doesn&#39;t automatically remove from a hash map when we drop a <span>u64</span>.
</p>
<p>
This can lead to &#34;orphaned&#34; nodes. This memory is &#34;leaked&#34; until the parent <span>Vec</span> goes out of scope, similar to how Java can leak objects.
</p>

</section>
<section>
<p>
The problem is more widespread than we think. Just like above, Rust programs <b>naturally tend to collectionize</b> <a href="#note23" data-noteid="23">23</a> because the borrow checker generally dislikes when multiple long-lived references point to the same object. <a href="#note24" data-noteid="24">24</a>
</p>
<p>
We end up with architectures where a lot of collections&#39; structs have IDs referring to other collections&#39; structs <b>instead of owning things directly</b>. The result is often similar to an entity-component-system architecture <a href="#note25" data-noteid="25">25</a> or a relational database. <a href="#note26" data-noteid="26">26</a>
</p>
<p>
With this collectionization, the risk for this kind of &#34;memory leak&#34; increases.
</p>

</section>
<section>
<p>
But Higher RAII can help!
</p>

</section>
<section>
<p>
Let&#39;s pretend Rust has a <span>linear</span> keyword, and see what happens.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
We&#39;ll make a linear <span>OwningIndex&lt;T&gt;</span> struct containing an index. The <span>OwningIndex</span> struct conceptually owns the <span>RBNode</span> its index refers to.
</p>
<p>
We also made <span>RBNode&lt;T&gt;</span> linear because only a linear struct can contain a linear struct. In fact, that Option<owningindex> is also implicitly linear.
</owningindex></p>
<p>
Finally, we make it so only one place can destroy an OwningIndex<t>: the <span>remove_node</span> function.

</t></p>

</section>
</div>
<div>
<section>

    <div>
      
      <pre><code>linear struct OwningIndex&lt;T&gt; {
  index: usize;
}
linear struct RBNode&lt;T&gt; {
  data: T,
  color: Color,
  parent: Option&lt;usize&gt;,
  left: Option&lt;OwningIndex&gt;,
  right: Option&lt;OwningIndex&gt;,
};</code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
This solves the problem! Though it can be hard to see why, so I&#39;ll try to explain:
</p>
<ul>
<li>
When we destroy a <span>RBNode&lt;T&gt;</span> instance, we&#39;re forced to take ownership of each child <span>Option&lt;OwningIndex&gt;</span> instances.
</li>
<li>
The only way to get rid of an <span>Option&lt;OwningIndex&gt;</span> is to <span>match</span> it into either a (non-linear) <span>None</span> or a (linear) <span>Some&lt;OwningIndex&gt;</span>.
</li>
<li>
The only way to get rid of a (linear) <span>Some&lt;OwningIndex&gt;</span> is to destruct it, taking ownership of the contained <span>OwningIndex</span>.
</li>
<li>
The only way to get rid of an <span>OwningIndex</span> is hand it to <span>remove_node</span> (or, we could stuff it into another <span>RBNode&lt;T&gt;</span>).
</li>
</ul>

</section>
<section>
<p>
In short, the language forces us to eventually deliver that <span>OwningIndex</span> to another node or to call <span>remove_node</span>.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note23" data-noteid="23">
<p><span>23</span></p><section>
<p>
See also <a href="https://www.reddit.com/r/rust/comments/1azbdb8/comment/ks0huy0/">1vader&#39;s insightful comment</a> about this natural collectionization and its benefits and drawbacks.
</p>

</section>
</div>
<div id="note24" data-noteid="24">
<p><span>24</span></p><section>
<p>
More precisely, the borrow checker generally doesn&#39;t allow us to ever modify something if anything else has a reference to it.
</p>

</section>
</div>
<div id="note25" data-noteid="25">
<p><span>25</span></p><section>
<p>
For more benefits and drawbacks of this natural collectionization, also check out this post on <a href="https://www.reddit.com/r/roguelikedev/comments/i3xekn/ec_vs_ecs_for_roguelikes/?rdt=44855">EC vs ECS in Roguelikes</a>.
</p>

</section>
</div>
<div id="note26" data-noteid="26">
<p><span>26</span></p><section>
<p>
At least relational databases have <span>ON DELETE CASCADE</span>, which is kind of like an owning reference if you think about it.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="solve-lookup-after-remove">
 Solve lookup-after-remove</h3>
<p>
Our final Arcane Use is to prevent a certain common logic bug.
</p>

</section>
<section>
<p>
In C++, if we don&#39;t own a <span>Spaceship</span> but we want to access it, we store a pointer <span>Spaceship*</span>. If we destroy the <span>Spaceship</span>, the <span>Spaceship*</span> becomes &#34;dangling&#34; and dereferencing it causes a use-after-free bug.
</p>
<p>
When we translate that code to Rust, the usual outcome is that we instead store a <span>u64</span> &#34;Spaceship ID&#34;, which is the key into a central <span>HashMap&lt;u64, Spaceship&gt;</span>. We would &#34;dereference&#34; the ID by calling <span>the_hash_map.get(spaceship_id)</span>.
</p>
<p>
Unfortunately, the bug is still here, but in a different form: if we remove the <span>Spaceship</span> from the map, and <i>then</i> call <span>get</span> with that &#34;dangling&#34; u64, we receive a <span>None</span> which likely represents a bug. In other words, Rust turned the use-after-free into a &#34;lookup-after-remove&#34; bug.
</p>

</section>
<section>
<p>
Higher RAII can help with this.
</p>
<p>
Let&#39;s make a special <span>LinearHashMap</span> with these three adjustments:
</p>
<ul>
<li>
<span>insert</span> takes a key (<span>u64</span>) and a value (<span>Spaceship</span>) and returns a <span>LinearKey</span> which is simply a linear struct containing the key.
</li>
<li>
<span>get</span> takes a <span>&amp;LinearKey</span> and returns a reference to the value (<span>&amp;Spaceship</span>).
</li>
<li>
<span>remove</span> takes ownership of the <span>LinearKey</span>, destroys it, and returns the value (<span>Spaceship</span>).
</li>
</ul>

</section>
<section>
<p>
<span>get</span> can return a <span>&amp;Spaceship</span> instead of an <span>Option&lt;&amp;Spaceship&gt;</span> because if the given <span>LinearKey</span> still exists, then we know that the <span>Spaceship</span> is still in the hash map.
</p>

</section>
<section>
<p>
This isn&#39;t <i>completely</i> immune to problems: we&#39;d still have a bug if we give one map&#39;s LinearKey to another map. Solving that will require a little more effort. <a href="#note27" data-noteid="27">27</a>
</p>

</section>
<section>
<p>
This is kind of similar to the cache invalidation example. In the cache invalidation example, we used Higher RAII to enforce consistency between two maps. In this example, we&#39;re using it to know an ID isn&#39;t dangling.
</p>

</section>
<section>
<p>
This particular use case shows an ability with much larger implications, and allows a lot of <b>spooky knowledge at a distance.</b> <a href="#note28" data-noteid="28">28</a> If you follow this curséd path, you&#39;ll eventually arrive at the nebulous &#34;linear reference counting&#34; concept I hinted at in <a href="https://verdagon.dev/grimoire/grimoire">the grimoire</a>. <a href="#note29" data-noteid="29">29</a>
</p>

</section>
<section>
<p>
By the way, also check out Niko Matsakis&#39;s <a href="https://smallcultfollowing.com/babysteps/blog/2023/03/16/must-move-types/">blog post</a> on what it would look like if Rust had linear &#34;must-move&#34; types! <a href="#note30" data-noteid="30">30</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note27" data-noteid="27">
<p><span>27</span></p><section>
<p>
We can make the LinearKey bound to the map&#39;s lifetime, or we can use an assertion, or make a different type for every map, or there are a few other solutions out there.
</p>

</section>
</div>
<div id="note28" data-noteid="28">
<p><span>28</span></p><section>
<p>
A taste: Here, some code can see that the LinearKey exists, and know that the corresponding object still exists. This technique can be used to, for example, elide generation checks and eliminate many classes of errors.
</p>

</section>
</div>
<div id="note29" data-noteid="29">
<p><span>29</span></p><section>
<p>
A hint: We can use the existence of a linear reference as proof that the pointee object still exists, because the object can&#39;t be destroyed until the linear references are returned to it.
</p>

</section>
</div>
<div id="note30" data-noteid="30">
<p><span>30</span></p><section>
<p>
See <a href="https://stackoverflow.com/questions/71694803/rust-type-that-requires-manual-drop">this StackOverflow answer</a> for a clever hack to make some types linear!
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="can-other-languages-add-higher-raii">
 Can other languages add Higher RAII?</h2>
<p>
Yes! It generally fits most cleanly into single-ownership-based languages (C++, Rust, Austral, Mojo, Carbon, CppFront, etc.), and Haskell shows us that GC&#39;d languages could have luck too.
</p>

</section>
<section>
<p>
To walk this path, there are some steps a language has to follow.
</p>

</section>
<section>
<p>
First, let&#39;s address <b>exceptions, panics, and async cancellation</b>. The reason that regular RAII requires a zero-argument destructor is that an in-flight exception (or panic, or <span>async</span> task cancellation) will unwind the stack, destroying everything in its path. <a href="#note31" data-noteid="31">31</a> To do this, it calls a zero-argument destructor or <span>drop()</span> function. So what does an in-flight exception do for a linear type?
</p>
<p>
The answer: we can add a separate <span>onException</span> function for any linear type; we don&#39;t have to conflate exception handling with destructors. This <span>onException</span> would take ownership of the type and attempt to correctly dispose of it. One can imagine a few other mechanisms to help with this too. <a href="#note32" data-noteid="32">32</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note31" data-noteid="31">
<p><span>31</span></p><section>
<p>
Exceptions are rather rude, aren&#39;t they? You&#39;re just having a nice time talking with your fellow local variables and then an exception bursts into the room and starts destroying everything.
</p>

</section>
</div>
<div id="note32" data-noteid="32">
<p><span>32</span></p><section>
<p>
 Even though this whole scheme is a big improvement, <span>onException</span> would still be a zero-arg no-return-value function, which is a similar challenge as RAII&#39;s destructors. We could:
</p>
<ul>
<li>
Allow <span>onException</span> to return data, which is collected and processed later somehow.
</li>
<li>
Have the thread register a <span>onExceptedLinearStruct</span> function which introspects the type of the given linear type, and specially handles it.
</li>
<li>
Last resort, add it to a global list for handling later.
</li>
</ul>
<p>
But even without these measures, we&#39;ve still reduced the problem drastically and enabled Higher RAII, which is an improvement.

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<p>
Second, <b>when dealing with generics</b> (like the <span>T</span> in <span>List&lt;T&gt;</span>), they need to take out the assumption that <span>T</span> has a destructor or a zero-argument <span>drop()</span> function.
</p>
<p>
This can require some standard library changes: a function like <a href="https://en.cppreference.com/w/cpp/container/vector/pop_back">std::vector<t>::pop_back</t></a> becomes problematic, it assumes it can just destroy the popped element.
</p>
<p>
In Vale, that function instead returns the popped element, so the caller can decide what to do with it.
</p>
<p>
As <a href="https://faultlore.com/blah/linear-rust/">Aria Beingessner wrote</a>, this is the main reason that Rust would have difficulty adding linear types: the entire existing ecosystem already assumes that it can drop given types. <a href="#note33" data-noteid="33">33</a> <a href="#note34" data-noteid="34">34</a> The same would likely apply to C++.
</p>

</section>
<section>
<p>
Third, <b>reconcile it with the aliasing</b> introduced by reference counting or garbage collection. One would assume that a reference-counted type can&#39;t have Higher RAII, but that&#39;s not true: we just need a single reference to be designated as the linear reference. This is similar to how <span>unique_ptr</span>, constraint references (from <a href="https://verdagon.dev/grimoire/grimoire#the-list">the grimoire</a>), and generational references work: one reference is a special &#34;owning reference&#34;.
</p>

</section>
<section>
<p>
Fourth, <b>figure out globals</b>. There&#39;s a lot of potential solutions to this one, <a href="#note35" data-noteid="35">35</a> for example just requiring all globals be non-linear, or requiring a destroyer function for any linear globals. <a href="#note36" data-noteid="36">36</a>
</p>

</section>
<section>
<p>
Fifth, <b><a href="mailto:verdagon_epsa@verdagon.dev">send me an email</a></b>, because there&#39;s a lot of interesting hidden design decisions to be made about whether a <i>type</i> is linear, or our <i>usage</i> of a type is linear.
</p>
<p>
These design decisions go straight to the original definition of linear types and affect, for example, whether <span>linear struct</span> literally means &#34;a linear struct&#34;, or whether it just means &#34;a <span>drop()</span>-less struct&#34;, a subtle distinction that can have quite a few benefits and tradeoffs.
</p>
<p>
I hope to write an article about this at some point, but I am compelled by unholy sorcery to complete <a href="https://verdagon.dev/grimoire/grimoire">the grimoire</a> first.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note33" data-noteid="33">
<p><span>33</span></p><section>
<p>
The rest of their post is really good too. Though my experience with Vale shows me that linear-type-enabled generics are more ergonomic than they suggest, once you have the right patterns in place.
</p>

</section>
</div>
<div id="note34" data-noteid="34">
<p><span>34</span></p><section>
<p>
 Though, ironically, there&#39;s a chance that by adding Vale&#39;s Rust FFI, I might be indirectly adding Higher RAII to Rust: I <i>may</i> have found a way that Vale can automatically and seamlessly call directly into Rust libraries, without user-written bindings, even though Rust doesn&#39;t have a stable ABI.
</p>
<p>
It would have some interesting constraints:
</p>
<ul>
<li>
We&#39;d only be allowed to put non-<span>linear</span> Vale structs inside Rust structs.
</li>
<li>
If we reinterpret a Rust struct as linear, we wouldn&#39;t be able to move it into a Rust function (which might <span>drop</span> it).
</li>
</ul>
<p>
but if it works, then Vale could just reinterpret external Rust types as linear, or wrap the external Rust types in linear Vale structs. I hope to prototype this over the next several months, so stay tuned!

</p>

</section>
</div>
<div id="note35" data-noteid="35">
<p><span>35</span></p><section>
<p>
I&#39;m curious about potentially requiring <span>main</span> to initialize and destroy globals explicitly, and call the &#34;global constructors&#34; for all dependencies (which would presumably then call <i>their</i> dependencies&#39; global constructors and so on). Lot&#39;s of interesting benefits and drawbacks to explore on that one.
</p>

</section>
</div>
<div id="note36" data-noteid="36">
<p><span>36</span></p><section>
<p>
Last resort, one can just make the global an <span>Option</span>, empty it from inside <span>main</span>, and have the global&#39;s destroyer function just assert it&#39;s empty.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="higher-raii-the-missing-piece-toward-correctness">
 Higher RAII: The missing piece toward correctness</h2>
<p>
A major implication of Higher RAII is that it can bring a language&#39;s programs much closer to the ever-elusive goal of <b>correctness</b>.
</p>
<p>
Correctness is <a href="https://www.hillelwayne.com/post/safety-and-liveness/">two things put together</a>:
</p>
<ul>
<li>
Safety: the assurance that &#34;bad things don&#39;t happen&#34;, for example, a panic, a crash, or a use-after-free.
</li>
<li>
Liveness: the assurance that &#34;good things <i>do</i> happen&#34;, for example a plane lowering its landing gear.
</li>
</ul>
<p>
Safety helps liveness: a panic&#39;d subsystem can&#39;t lower the landing gear. And liveness helps safety too, as we saw in our lookup-after-remove example. Like <a href="https://www.youtube.com/watch?v=wZPOUR3A24k">classical and techno</a>, the two blend and build upon each other in surprising and interesting ways.
</p>
<p>
Alas, no languages have nailed liveness yet. <a href="#note37" data-noteid="37">37</a>
</p>

</section>
<section>
<p>
But there&#39;s hope! Linear types and Higher RAII help with liveness and correctness.
</p>
<p>
There are two languages that could really shine here: <b><a href="https://www.modular.com/">Mojo</a></b> and <b><a href="https://austral-lang.org/">Austral</a></b>, both which use an easier form of borrowing for memory safety and speed.
</p>
<p>
Austral is using linear types today, and the Mojo folks are now looking into adding linear types to Mojo as well.
</p>
<p>
If they can harness this power well, they could bring correctness to the mainstream in a way that&#39;s simple enough to not require users to learn advanced category theory. And that&#39;s a <i>huge</i> deal.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note37" data-noteid="37">
<p><span>37</span></p><section>
<p>
 I think Vale is <i>close</i> in this regard, but not quite there yet. One can accomplish this in Vale with <a href="https://verdagon.dev/blog/linear-types-borrowing">move-only programming and regions</a>, but that technique is even harder to use than borrow checking.
</p>
<p>
A lot of my nights are spent chasing a certain holy grail: blending borrow checking with Vale&#39;s existing hybrid strategy. This quest has singlehandedly led to half of the grimoire!

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="software-architecture-implications">
 Software Architecture Implications</h2>
<p>
It wouldn&#39;t be a Languages ∩ Architecture blog without considering the architectural implications of a feature!
</p>
<p>
So how does Higher RAII do?
</p>
<p>
Aside from all the above powers, there&#39;s three more benefits and a drawback as well.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="benefit-makes-stateful-future-changes-explicit">
 Benefit: Makes stateful future changes explicit</h3>
<p>
The first benefit is that Higher RAII <b>helps our code be explicit.</b> This is better than regular RAII which implicitly and invisibly changes the state of the program.
</p>
<p>
This is so important that one of Zig&#39;s core principles is that <a href="https://ziggit.dev/t/what-does-zig-mean-by-no-hidden-control-flow/3618">there should be no hidden control flow</a>. Higher RAII means we can get RAII&#39;s benefits without that hidden control flow.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="benefit-makes-your-api-twice-as-easy-to-use-correctly">
 Benefit: Makes your API twice as easy to use correctly</h3>
<p>
The second extra benefit is that a function can help your future self, not just your past self.
</p>
<p>
Today&#39;s languages already make it easy to control the past: <span>second(f)</span> can require that you first call <span>first()</span>, by taking in a parameter`f` that only <span>first</span> returns.
</p>
<p>
However, this is one-sided. <span>first()</span> has no control over whether we ever call <span>second()</span>. We solve that with Higher RAII, by making that intermediate type <span>linear</span>.
</p>
<p>
In other words, <b>Higher RAII makes it twice as easy to use your API correctly.</b>
</p>
<p>
When working on a team, this is a major boon. You can now reach across space and time to help your teammate remember to call <span>teardown(thing, 3, true)</span>.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="benefit-less-fear-to-refactor">
 Benefit: Less fear to refactor</h3>
<p>
The third benefit is that by eliminating a certain class of errors, we give ourself <b>more freedom to refactor and improve</b> the codebase.
</p>
<p>
I explain this nebulous concept in <a href="https://verdagon.dev/blog/first-100k-lines">How To Survive Your Project&#39;s First 100,000 Lines</a>, but I&#39;ll summarize:
</p>
<ul>
<li>
It&#39;s easier to change your program if you have tests: you can know that your change isn&#39;t breaking the program in unexpected ways.
</li>
<li>
It&#39;s easier to refactor Java than Python, because Java&#39;s static typing means the compiler can sanity check everything you&#39;ve changed.
</li>
<li>
In Java, you can harness the type system a little bit, or a lot. Leaning on it more is generally better.
</li>
</ul>
<p>
Adding higher RAII is another step in this direction: it sanity checks that your modified code actually <i>did</i> remember to call everything it was supposed to.
</p>
<p>
This strengthens the codebase and makes it more resilient to bugs, which means we&#39;re less afraid to do refactors and other long-term investments.
</p>

</section>
<section>
<p>
Higher RAII has the above three benefits, but it also has a drawback.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="drawback-ity-can-be-viral">
 Drawback: <span>linear</span>ity can be viral</h3>
<p>
The first drawback is that <span>linear</span>ity is an <b>upwardly viral constraint</b> on our data, in that it can impose requirements on those who contain it.
</p>
<p>
For example, if a <span>Spaceship</span> is <span>linear</span>, then so is <span>List&lt;Spaceship&gt;</span>, and likely anything that contains it, such as a <span>Shipyard</span>. <a href="#note38" data-noteid="38">38</a>
</p>
<p>
This isn&#39;t necessarily a problem, unless you&#39;re adding a <span>linear</span> member to an existing non-<span>linear</span> struct: it could case an inconvenient refactor.
</p>
<p>
Other &#34;upwardly viral constraints&#34; include <span>async</span>/<span>await</span> <a href="#note39" data-noteid="39">39</a> and Rust&#39;s borrow references, <a href="#note40" data-noteid="40">40</a> though those are more about functions, not data.
</p>
<p>
This drawback can be mitigated by instead defining a custom <span>drop()</span> for the <span>Shipyard</span>, if it has the necessary data to call some other function to destroy the <span>Spaceship</span>s, but that&#39;s not always possible.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note38" data-noteid="38">
<p><span>38</span></p><section>
<p>
Or, if struct <span>Outer</span> contains <span>linear struct Inner</span>, then <span>Outer</span> will likely need to be linear as well, because <span>Outer</span>&#39;s auto-generated <span>drop()</span> function doesn&#39;t know what to do with <span>Inner</span>.
</p>

</section>
</div>
<div id="note39" data-noteid="39">
<p><span>39</span></p><section>
<p>
 See Bob Nystrom&#39;s <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">What Color is Your Function</a> article.
</p>
<p>
Though sometimes, a normal function can still call an <span>async</span> function and instead put the resulting Future onto a list somewhere instead of <span>await</span>ing it.
</p>

</section>
</div>
<div id="note40" data-noteid="40">
<p><span>40</span></p><section>
<p>
 When we have a <span>&amp;mut</span> in Rust, we usually need to get it via a parameter. This imposes the restriction on our caller, and all our callers&#39; callers, that none of them have a reference to this object.
</p>
<p>
Fortunately, we can mitigate the upwardly viral spread with <span>.clone()</span>s or reference counting, though both can have performance implications.

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    
    <div>
      <div>
  
<section>
<h2 id="thats-all">
 That&#39;s all!</h2>
<p>
One reason I love making languages is that I get to play with and write about new techniques and share their implications with the world. I didn&#39;t realize it at the time, but I&#39;ve been playing with Higher RAII since my <a href="https://verdagon.dev/blog/raii-next-steps#language-implications">very first article</a> four years ago.
</p>

</section>
<section>
<p>
After using it and seeing its potential, it&#39;s become a central feature of Vale, manifesting its benefits in user-space programs, the standard library, and even some aspects of Vale&#39;s memory safety approach.
</p>

</section>
<section>
<p>
There&#39;s so much more I could write about them! But alas, this one is almost... oh wow, 19 pages. Congrats on getting to the end!
</p>

</section>
<section>
<p>
I hope you all enjoyed this post! I&#39;m grateful to have all of you to share this arcane nonsense with. If you have any questions, always feel free to reach out via <a href="mailto:verdagon_epsa@verdagon.dev">email</a>, <a href="https://twitter.com/vale_pl">twitter</a>, <a href="https://discord.gg/SNB8yGH">discord</a>, or the <a href="https://reddit.com/r/vale">subreddit</a>.
</p>

</section>
<section>
<p>
Donations and sponsorships for Vale are currently paused, but if you like these articles, please <a href="https://www.doc.govt.nz/kakapo-donate">Donate to Kākāpō Recovery</a> and let me know! I love those birds, let&#39;s save them!
</p>

</section>
<section>
<p>
Cheers,
</p>
<p>
- Evan Ovadia
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="thank-you">
 Thank you!</h2>
<p>
I want to give a huge thanks to <a href="https://github.com/aweagel">Arthur Weagel</a>, <a href="https://github.com/KirilMihaylov">Kiril Mihaylov</a>, <a href="https://github.com/radekm">Radek Miček</a>, <a href="https://github.com/Geomitron">Geomitron</a>, <a href="https://github.com/chiuzon">Chiuzon</a>, <a href="https://github.com/soupertonic">Felix Scholz</a>, <a href="https://github.com/linkmonitor">Joseph Jaoudi</a>, <a href="https://github.com/lupuchard">Luke Puchner-Hardman</a>, <a href="https://github.com/tootoobeepbeep">Jonathan Zielinski</a>, <a href="https://github.com/albinkc">Albin Kocheril Chacko</a>, <a href="https://github.com/ezschemi">Enrico Zschemisch</a>, <a href="https://github.com/Svintooo">Svintooo</a>, <a href="https://github.com/tstack">Tim Stack</a>, <a href="https://github.com/kripken">Alon Zakai</a>, <a href="https://github.com/rovaughn">Alec Newman</a>, <a href="https://github.com/Shnatsel">Sergey Davidoff</a>, <a href="https://github.com/linuxy">Ian (linuxy)</a>, <a href="https://github.com/Ivo-Balbaert/">Ivo Balbaert</a>, <a href="https://github.com/pierrec">Pierre Curto</a>, <a href="https://github.com/loveJesus">Love Jesus</a>, <a href="https://github.com/jryans">J. Ryan Stinnett</a>, <a href="https://github.com/cdinu">Cristian Dinu</a>, and <a href="https://github.com/lasernoises">Florian Plattner</a> (plus a very generous anonymous donor!) for sponsoring Vale over all these years.
</p>
<p>
Your support has always given me the strength and resolve to explore these arcane corners of the world. And even though I&#39;m not doing sponsorships for a while, it&#39;s awesome to know you&#39;re with me in spirit. <a href="http://www.gamesurge.com/pc/strategy/pc_wt/Adom.shtml">Axes high!</a>
</p>

</section>


      </div>
  


    </div>
    
  

    </div>
  </div></div>
  </body>
</html>
