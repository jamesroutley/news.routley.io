<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sawyer.dev/posts/newbie-rust-style/">Original</a>
    <h1>My Newbie Rust Style Guide and Other Resources</h1>
    
    <div id="readability-page-1" class="page"><div>
      



<section id="post">

  <nav>
    &gt; <a href="https://mlumiste.com/">home</a>
    &gt; <a href="https://mlumiste.com/posts">blog posts</a>
  </nav>

  <container>
    <h2 id="post-title"> My Newbie Rust Style Guide and Other Resources </h2>

    <article>
      <p>I recently started another attempt at writing an RSS reader. I&#39;ve started this project a bunch of times, using Electron and Tauri and Django and now back to Tauri. One thing that kept me from embracing Tauri is that I didn&#39;t feel comfortable writing Rust. I&#39;ve used it for projects in the past, but I&#39;ve never used it often enough to build up the muscle memory of using it. This post is an attempt at writing down some guidelines I&#39;ve set for myself to be productive without falling off the complexity cliff of Rust&#39;s more advanced features.</p>
<h2>using <code>String</code></h2>
<p>I think this is a pretty common refrain, but it still took time for me to accept it. Steve Klabnik&#39;s <a href="https://steveklabnik.com/writing/when-should-i-use-string-vs-str/">recent post on using <code>String</code> and <code>&amp;str</code></a> hit the right combination of &#34;really clear distillation of material&#34; and &#34;I&#39;ve seen some version of this advice so many times in so many ways and this time it finally stuck&#34;. However, while I still clone values a lot, I&#39;ve substituted the recommendation of using <code>to_string()</code> into a more general-purpose rule: use <code>into()</code>.</p>
<h2>from, into, and their try counterparts</h2>
<p>Type safety is a beautiful thing. Type safety can also be a fragile thing. I often imagine my programs as a series of pipes; I&#39;m just setting up a way for data to flow from one place to another. However, at some point those pipes need to line up to other pipes. The types I&#39;ve constructed must become other types. In languages that provide little tooling for types, these connections often feel like taping two pipes together when what I really want is an appopriate fitting. In Rust, I see the <a href="https://doc.rust-lang.org/rust-by-example/conversion/from_into.html"><code>From</code> and <code>Into</code> traits</a> (and <a href="https://doc.rust-lang.org/rust-by-example/conversion/try_from_try_into.html">their <code>Try</code> counterparts</a>) as those fittings. To me, type conversions are part of the accidental complexity introduced by type systems, and these traits allow me to isolate that complexity from the rest of my code. Need to coerce a struct into a similar but different struct? Is there the possibility of an error? <code>TryInto</code> has my back. To bring this back to the example of converting <code>&amp;str</code> to <code>String</code>, I usually just fall back to calling <code>.into()</code> whenever I need to go from reference to owned.</p>
<h2>understanding async</h2>
<p>This isn&#39;t really a guideline, but a shoutout to a few resources that helped me get a place of reasonable comfort with async Rust. Two notable written resources are <a href="https://rust-lang.github.io/async-book/intro.html">the Async Rust Book</a> and <a href="https://fasterthanli.me/">fasterthanlime&#39;s articles</a>. The async book has clear, concise examples of async things and I mostly use it as a reference. The fasterthanlime articles are great, engaging deep-dives into some specific Rust functionality. The async posts I really liked are a few years old now, but I think they hold up pretty well.</p>
<p>Another resource came out of reading a bit of <a href="https://www.zero2prod.com/index.html">Zero to Production in Rust</a>: <a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a>. This tool expands proc macros and I&#39;ve found it extremely illuminating. For example, it provided a lightbulb moment when I could see that <code>#[tokio::main]</code> transforms <code>async fn main</code> into a synchronous main function that starts and polls the async code within. I haven&#39;t used this tool too often, but I feel it&#39;ll be an important part of my Rust experience.</p>
<p>--</p>
<p>These are the things that have helped me be a little more comfortable with Rust recently. I hope I was able to expand a bit on how they&#39;ve changed or augmented my mental model of Rust. These are not meant as a final destination of my Rust knowledge, but they let me use Rust enough that I start to encounter the second-level issues of using Rust, which are then addressed by the more advanced features I alluded to earlier.</p>

    </article>

  </container>


</section>

    </div></div>
  </body>
</html>
