<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/cosmo3/">Original</a>
    <h1>Cosmopolitan Third Edition</h1>
    
    <div id="readability-page-1" class="page">

<p>
Oct 31<sup>st</sup>, 2023 @ <a href="https://hypodyne.net/index.html">justine&#39;s web page</a>
</p>

<div>
<p><img src="https://hypodyne.net/tunnels-within-tunnels/honeybadger.png" alt="[cosmpolitan honeybadger logo]" width="334" height="200"/></p></div>

<p>
After nearly one year of development, I&#39;m pleased to announce our
<a href="https://github.com/jart/cosmopolitan/releases/tag/3.0.1">version
3.0.1</a> release of the Cosmopolitan library. The project is an
entirely new animal. For starters, Mozilla sponsored our work as part of
their <a href="https://future.mozilla.org/mieco/">MIECO program</a>.
Google also
<a href="https://opensource.googleblog.com/2023/05/google-open-source-peer-bonus-program-announces-first-group-of-winners-2023.html">awarded
me an open source peer bonus</a> for my work on Cosmopolitan, which is a
rare honor, and it&#39;s nice to see our project listed up there among the
greats, e.g. curl, linux, etc. In terms of this release, we&#39;re living up
to the great expectations you&#39;ve all held for this project in a number
of ways. The first is we invented a new linker that lets you build fat
binaries which can run on these platforms:

</p><ul>
  <li>AMD64
    <ul>
      <li>Linux
      </li><li>MacOS
      </li><li>Windows
      </li><li>FreeBSD
      </li><li>OpenBSD
      </li><li>NetBSD
    </li></ul>
  </li><li>ARM64
    <ul>
      <li>Linux
      </li><li>MacOS
      </li><li>Windows (non-native)
    </li></ul>
</li></ul>

<p>
It&#39;s called
<a href="https://github.com/jart/cosmopolitan/blob/3.0/tool/build/apelink.c">apelink.c</a>
and it&#39;s a fine piece of poetry that weaves together the Portable
Executable, ELF, Mach-O, and PKZIP file formats into shell scripts that
run on most PCs and servers without needing to be installed. This is an
idea whose time has come; POSIX
even <a href="https://austingroupbugs.net/view.php?id=1250">changed
their rules</a> about binary in shell scripts specifically to let us do
it. So we&#39;ve been using it to create a &#34;Fat Linux Distro&#34; which I&#39;ve
named the &#34;Cosmos&#34;. In the Cosmos, every program is statically linked
and contains a PKZIP central directory where its /usr/share dependencies
are embedded. You can think of it as a coalition of individualistic
executables, where each program can be separated from the whole and run
on other OSes. So far it includes programs like Emacs, Vim, CoreUtils,
Curl, Git, etc.

</p><p>
  <a href="https://github.com/jart/cosmopolitan/releases/download/3.0.1/cosmos-3.0.1.zip">cosmos-3.0.1.zip</a></p><p>
More specifically, the above zip file contains fat binaries for <code>ape</code>, <code>python</code>,
<code>lua</code>, <code>qjs</code>, <code>vim</code>, <code>emacs</code>, <code>emacsclient</code>, <code>nano</code>, <code>llama</code>, <code>bash</code>, <code>dash</code>, <code>less</code>, <code>git</code>, <code>grep</code>,
<code>curl</code>, <code>wget</code>, <code>tidy</code>, <code>zip</code>, <code>unzip</code>, <code>zstd</code>, <code>bzip2</code>, <code>sqlite3</code>, <code>life</code>, <code>nesemu1</code>, <code>make</code>
(GNU + SECCOMP + Landlock), <code>gmake</code> (GNU), <code>redbean</code>, <code>greenbean</code>, <code>datasette</code>, <code>assimilate</code>, <code>rusage</code>, <code>ctags</code>, <code>wall</code>, <code>pledge</code>, <code>verynice</code>,
<code>find</code>, <code>tree</code>, <code>basename</code>, <code>chgrp</code>, <code>cp</code>, <code>date</code>, <code>du</code>, <code>expr</code>, <code>groups</code>, <code>ls</code>, <code>mknod</code>, <code>nl</code>,
<code>pathchk</code>, <code>pwd</code>, <code>rm</code>, <code>seq</code>, <code>shred</code>, <code>stat</code>, <code>tee</code>, <code>uname</code>, <code>users</code>, <code>who</code>, <code>basenc</code>,
<code>chmod</code>, <code>csplit</code>, <code>dd</code>, <code>echo</code>, <code>factor</code>, <code>head</code>, <code>mktemp</code>, <code>nohup</code>, <code>pinky</code>,
<code>rmdir</code>, <code>shuf</code>, <code>stty</code>, <code>test</code>, <code>true</code>, <code>unexpand</code>, <code>vdir</code>, <code>whoami</code>, <code>awk</code>, <code>chown</code>, <code>df</code>,
<code>false</code>, <code>id</code>, <code>link</code>, <code>mv</code>, <code>nproc</code>, <code>pr</code>, <code>rsync</code>, <code>sleep</code>, <code>sum</code>, <code>truncate</code>, <code>uniq</code>, <code>yes</code>,
<code>b2sum</code>, <code>chroot</code>, <code>dir</code>, <code>fmt</code>, <code>install</code>, <code>md5sum</code>, <code>numfmt</code>, <code>printenv</code>, <code>readlink</code>,
<code>runcon</code>, <code>sort</code>, <code>sync</code>, <code>timeout</code>, <code>tsort</code>, <code>unlink</code>, <code>base32</code>, <code>cat</code>, <code>cksum</code>, <code>cut</code>,
<code>dircolors</code>, <code>env</code>, <code>fold</code>, <code>join</code>, <code>ln</code>, <code>mkdir</code>, <code>od</code>, <code>printf</code>, <code>realpath</code>, <code>script</code>,
<code>split</code>, <code>tac</code>, <code>touch</code>, <code>tty</code>, <code>wc</code>, <code>base64</code>, <code>chcon</code>, <code>comm</code>, <code>dirname</code>, <code>expand</code>, <code>kill</code>,
<code>logname</code>, <code>mkfifo</code>, <code>nice</code>, <code>paste</code>, <code>ptx</code>, <code>sed</code>, <code>sha1sum</code>, <code>sha224sum</code>, <code>sha256sum</code>,
<code>sha384sum</code>, <code>sha512sum</code>, <code>tail</code>, <code>tr</code>, <code>ttyinfo</code>, and <code>uptime</code>.

</p><p>
This only became possible in the last few months, in part thanks to
Gautham Venkatasubramanian, who spent a few weekends of his PhD studies
<a href="https://ahgamut.github.io/2023/07/13/patching-gcc-cosmo/">modifying
the C language</a> so it&#39;s possible to build conventional software with
Cosmopolitan. Since then it&#39;s been out of the frying pan and into the
fire, testing our library to see if it can support some of the most
complex and mature projects in the open source community. Running the
<code>./configure</code> scripts and <code>make check</code> rules of
projects (e.g. GMP) has done so much to help us fix bugs and battle test
new features.

</p><h2 id="overview">
  <a href="#overview">Build Once Anywhere, Run Anywhere C/C++</a>
</h2>

<p>
One of the things we&#39;re most happy with, is that Cosmo&#39;s cross platform
support is now good enough to support Cosmo development. We&#39;ve
traditionally only compiled code on x86 Linux. Devs using Cosmo would
build their programs on Linux, and then copy the binaries to other OSes.
Focusing on Linux-only helped us gain considerable velocity at the start
of the project; the Cosmopolitan monorepo has two million lines of code.
Today was the first day the whole thing compiled on Apple Silicon and
Microsoft Windows systems, and using Cosmo-built tools.

</p><h3>Windows Improvements</h3>

<p>
In order to get programs like GNU Make and Emacs to work on Windows, we
implemented <a href="https://github.com/jart/cosmopolitan/blob/3.0/libc/calls/sig.c">new
libraries for POSIX signals emulation</a>. Cosmopolitan is now able to
preempt i/o and deliver asynchronous signals on Windows, using
a <a href="https://github.com/jart/cosmopolitan/blob/3.0/libc/calls/sig.c#L316-L375"><code>SetThreadContext()</code>
trick</a> I learned from the Go developers. Cosmo does a considerably
better
job <a href="https://github.com/jart/cosmopolitan/blob/3.0/libc/calls/ntspawn.c">spawning
processes</a> now too. For example, we wrote
a <a href="https://github.com/jart/cosmopolitan/blob/3.0/libc/proc/posix_spawn.c">brand
new <code>posix_spawn()</code> function</a> that
goes <a href="https://hypodyne.net/tunnels-within-tunnels/cygwin-comparison.txt">10x faster</a> than
the <code>posix_spawn()</code> included with Cygwin.
Cosmo&#39;s <code>execve()</code> can now reparent
subprocesses, <a href="https://github.com/jart/cosmopolitan/blob/master/libc/proc/describefds.c">inherit
non-stdio file descriptor</a>, and
our <a href="https://github.com/jart/cosmopolitan/blob/3.0/libc/calls/read-nt.c"><code>read()</code>
function now contains a termios driver</a> which, for the first time,
lets us <code>poll()</code> standard input on consoles. Cosmo binaries
cleanly integrate with WIN32, depending pretty much only on KERNEL32,
and your fat binaries won&#39;t have to live on a separate partition like
WSL.

</p><h3>MacOS Improvements</h3>

<p>
While MacOS may not be the prodigal child of our support vector, this
release brings improvements to MacOS users that are equally important.
For starters, we now have first-class native ARM64
support. <a href="https://github.com/jart/cosmopolitan/blob/3.0/ape/ape-m1.c">APE
Loader</a> also now dynamically links the officially blessed Apple
libraries (e.g. libSystem.dylib) on ARM64, so there&#39;s less chance that
Apple will break your binaries. We&#39;ve also
made <a href="https://github.com/jart/cosmopolitan/blob/3.0/third_party/nsync/mu_semaphore_gcd.c">semaphores</a>
and <a href="https://github.com/jart/cosmopolitan/blob/3.0/third_party/nsync/futex.c">futexes</a>
much better on XNU, thanks to Grand Central Dispatch, and ulock on
AMD64.

</p><h3>Portability and Performance (Pick Two)</h3>

<p>
The end result is that if you switch your Linux build process to
use <code>cosmocc</code> instead of <code>cc</code> then the programs
you build, e.g. Bash and Emacs, will just work on the command prompts of
totally different platforms like Windows and MacOS, and when you run
your programs there, it&#39;ll <em>feel</em> like you&#39;re on Linux. However
portability isn&#39;t the only selling point. Cosmo Libc will make your
software faster and use less memory too. For example, when I build Emacs
using the cosmocc toolchain, Emacs thinks it&#39;s building for Linux. Then,
when I run it on Windows:

</p><p>
<img width="898" height="558" alt="[fat-emacs.png]" src="https://hypodyne.net/tunnels-within-tunnels/fat-emacs.png"/>

</p><p>
It actually goes 2x faster than the native WIN32 port that the Emacs
authors wrote on their own. Cosmo Emacs loads my dotfiles in 1.2 seconds
whereas GNU Emacs on Windows loads them in 2.3 seconds. Many years ago
when I started this project, I had this unproven belief that portability
toil could be abstracted by having a better C library. Now I think this
is all the proof we need that it&#39;s not only possible to make software
instantly portable, but actually <em>better</em> too. For example, one
of the things you may be wondering is, &#34;these fat binary files are huge,
wouldn&#39;t that waste memory?&#34; The answer is no, because Cosmo only pages
into memory the parts of the executable you need. Take for example one
of Linux&#39;s greatest hits: the Debian Almquist shell.

</p><pre>$ ls -hal /usr/bin/dash
-rwxr-xr-x 1 root root <strong>107K</strong> Nov 21  2022 /usr/bin/dash
$ ls -hal /opt/cosmos/bin/dash
-rwxr-xr-x 1 jart jart <strong>983K</strong> Oct 15 19:14 /opt/cosmos/bin/dash
</pre>

<p>
Here we see Cosmo&#39;s six OS + two architecture fat binary dash is 30%
bigger than the one that comes with Alpine Linux (which only supports
x86-Linux and dynamically links a separate 600kb Musl library). But if I
run them:

</p><pre>$ rusage /usr/bin/dash -c true
took 231µs wall time
ballooned to <strong>688kb</strong> in size
needed 183us cpu (0% kernel)
caused 34 page faults (100% memcpy)

$ rusage /opt/cosmos/bin/dash -c true
took 217µs wall time
ballooned to <strong>544kb</strong> in size
needed 172us cpu (0% kernel)
caused 36 page faults (100% memcpy)
</pre>

<p>
Here we see Cosmo&#39;s fat binary version of dash went faster and used less
memory than an x86-Linux-only binary built for Musl Libc. This is due to
(1) the magic of modern memory management, where CPU MMUs lazily load
4096 byte blocks at a time; and (2) how carefully <code>apelink</code>
plans your executable layout. For example, all that code which is needed
to support Windows (it takes a lot of code to support Windows) gets
linked into its own special section of the binary, far away from what
the MMU will want to page on UNIX systems. The same goes for the
embedded ARM64 build. Since I&#39;m running on AMD64 here, the ARM64 code is
never loaded off disk.

</p><h2 id="install">
  <a href="#install">Compiler Install Guide</a>
</h2>

<p>
You no longer need to choose between the amalgamation release or the
cosmo monorepo. We now have a third preferred option, which is our
new <code>cosmocc</code> command. It works pretty much the same as
the <code>cc</code> command you already know. The Cosmopolitan README
file
has <a href="https://github.com/jart/cosmopolitan#getting-started">getting
started</a> instructions, which basically boil down to this:

</p><pre>sudo mkdir -p /opt
sudo chmod 1777 /opt
git clone https://github.com/jart/cosmopolitan /opt/cosmo
export PATH=<span>&#34;/opt/cosmo/bin:/opt/cosmos/bin:$PATH&#34;</span>
echo <span>&#39;PATH=&#34;/opt/cosmo/bin:/opt/cosmos/bin:$PATH&#34;&#39;</span> &gt;&gt;~/.profile
ape-install        <span># optionally install a faster systemwide ape loader</span>
cosmocc --update   <span># pull cosmo and rebuild toolchain</span>
</pre>

<p>
If your development environment isn&#39;t x86_64 Linux, then you&#39;ll need to
download the latest toolchain, rather than using the one that&#39;s vendored
inside the cosmo repository.

</p><pre>cd /opt/cosmo
rm -rf o/third_party/gcc
wget https://github.com/jart/cosmopolitan/releases/download/3.0.1/cosmocc-0.0.16.zip
unzip cosmocc-0.0.16.zip
</pre>

<p>
If you&#39;re on Windows, then you need a shell before you can do any of the
above. If you download the cosmos.zip file at the top of the page, it&#39;ll
have a bin/ and libexec/ folder. Just extract those to
your <code>C:\</code> drive. Then
install <a href="https://apps.microsoft.com/detail/windows-terminal-preview/9N8G5RFZ9XK3?hl=en-US&amp;gl=US">Terminal
Preview</a> from the Microsoft Store, and configure it so that it
launches <code>C:\bin\bash -l</code> as your shell. You&#39;ll naturally
need a good unzip program in order to do this: one that supports
symbolic links (a.k.a. reparse points). The cosmos zip includes InfoZIP,
but you can download it directly
here: <a href="https://hypodyne.net/tunnels-within-tunnels/unzip.exe">unzip.exe</a>.

</p><p>
Now that your cosmo compiler is installed and added to
your <code>$PATH</code>, you can build standard C and C++ programs as
follows:

</p><pre>cosmocc -o foo foo.c
cosmoc++ -o bar bar.cc
</pre>

<p>
If you want to build programs as fat binaries, there&#39;s a special
compiler now which can make the process easier than using the
<code>x86_64-unknown-cosmo-cc</code>, <code>aarch64-unknown-cosmo-cc</code>, <code>fixupobj</code>,
and <code>apelink</code> commands directly. This compiler works by
manipulating your compiler flags so that a
concomitant <code>.aarch64/foo.o</code> gets created for
every <code>foo.o</code> you compile. It runs the x86_64 and aarch64
compilers in parallel too, so it doesn&#39;t go much slower
than <code>cosmocc</code> at the end of the day.

</p><pre>fatcosmocc -o foo foo.c
fatcosmoc++ -o bar bar.cc
</pre>

<p>
Integrating with GNU Autotools projects is easy as well.

</p><pre><span>export</span> CC=cosmocc
<span>export</span> CXX=cosmoc++
./configure --prefix=/opt/cosmos
make -j
make install
</pre>

<p>
Refer to
the <a href="https://github.com/jart/cosmopolitan#getting-started">README
file</a> for more detailed instructions. Also be sure to check out
the <a href="https://github.com/ahgamut/superconfigure">ahgamut/superconfigure</a>
repository for the largest source of high-quality examples on how to
build open source software using Cosmo.

</p><h2 id="web">
  <a href="#web">Production Web Servers</a>
</h2>

<p>
This cosmos release includes the latest version of
the <a href="https://redbean.dev/">redbean web server</a>. This is a fat
single-file forking Lua+SQLite+MbedTLS stack written by the Cosmopolitan
authors originally to showcase the capabilities of the library for
greenfield development. Cosmopolitan is good for more than just building
old GNU code and redbean proves that. It&#39;s
the <a href="https://bestofshowhn.com/">third most upvoted</a> hobby
project in Hacker News history. A few weeks ago Berwyn
Hoyt <a href="https://berwyn.hashnode.dev/update-openresty-vs-lua-54-a-benchmark">independently
determined</a> it to be the fastest Lua web server too!

</p><p>
<a href="https://hypodyne.net/tunnels-within-tunnels/redbean-benchmark.png"><img width="600" height="359" alt="[redbean-benchmark.png]" src="https://hypodyne.net/tunnels-within-tunnels/redbean-benchmark.png"/></a>

</p><p>
One of the reasons why redbean is a forking web server is because we
didn&#39;t develop our own
<a href="https://github.com/jart/cosmopolitan/tree/3.0/libc/thread">POSIX
Threads implementation</a> until last year. So we put a lot of thought
into writing an example of how you can build a bare minimal threaded web
server that&#39;s <em>even faster</em> than redbean, and it&#39;s called
greenbean. There&#39;s a prebuilt fat binary for it in the cosmos.zip
distribution above. Greenbean is
<a href="https://github.com/jart/cosmopolitan/blob/3.0/examples/greenbean.c">400
lines of liberally commented perfection</a>. I still can&#39;t believe how
good we got its memory usage, thanks to tricks
like <code>MAP_GROWSDOWN</code>. On Linux, if I ask greenbean to spawn
over 9,000 persistent worker threads:

</p><pre>$ sudo prlimit --pid=$$ --nofile=18000
$ sudo prlimit --pid=$$ --nproc=18000
$ rusage greenbean 9001
listening on http://127.0.0.1:8080
listening on http://10.10.10.237:8080
greenbean workers=0 connections=0 messages=0 ^C shutting down...
took 7,959,324µs wall time
ballooned to <strong>40,352kb</strong> in size
needed 929,917us cpu (92% kernel)
caused 10,039 page faults (100% memcpy)
54,689 context switches (99% consensual)
</pre>

<p>
Then it somehow only uses 40mb of peak resident memory, and according to
htop, greenbean&#39;s virtual memory usage is 76,652kb. That&#39;s for 9,001
threads. Like redbean, greenbean is able to handle hundreds of thousands
of requests per second on my Intel Core i9-9900, except (1) greenbean
has better shared memory support, (2) it sets up and tears down
connections faster, and (3) it lets you experience the joy of using Mike
Burrows&#39; <a href="https://github.com/google/nsync">*NSYNC</a> library,
which is the basis of Cosmopolitan&#39;s POSIX synchronization primitives.
If you&#39;re not familiar with the man, he&#39;s the guy who coded Chubby and
Altavista, a global search engine which was so efficient it only needed
to operate on a single server. But you wouldn&#39;t think *NSYNC is as
prolific as it is if you&#39;re only going off star count.

</p><p>
My favorite thing about greenbean is how elegantly it reacts to CTRL-C.
When you interrupt greenbean, it&#39;ll use the POSIX pthread_cancel() API
to immediately terminate all the worker threads, so that shutdown
happens without delay. Cancelation is one of the trickier concepts for a
C library to get right. It&#39;s up there with threads, signals, and fork in
terms of how its ramifications pervade everything. So similar to Musl
Libc, we&#39;ve put a lot of thought into ensuring that Cosmo does it
correctly. Cosmo avoids cancelation race conditions the same way as Musl
and Cosmo also implements Musl&#39;s <code>PTHREAD_CANCEL_MASKED</code>
extension to the POSIX standard, which has seriously got to be one of
Rich Felker&#39;s most brilliant ideas. Read the commentary in greenbean.c
if you want to learn more.

</p><p>
Some of you might view greenbean as just a toy example. In that case, if
you want to see something based on greenbean that is actually running in
production, then pay a visit
to <a href="https://ipv4.games/">https://ipv4.games/</a> whose source
code is
in <a href="https://github.com/jart/cosmopolitan/blob/3.0/net/turfwar/turfwar.c">net/turfwar/turfwar.c</a>
and <a href="https://github.com/jart/cosmopolitan/blob/3.0/net/turfwar/.init.lua">net/turfwar/.init.lua</a>.
This is a hybrid redbean + greenbean service, where redbean does the
HTTPS frontend, and greenbean does the HTTP backend. Hackers love to
unleash their botnets on the IPv4 Games, and it honestly isn&#39;t that hard
to withstand a DDOS with 49,131,669 IPs when your web server can do a
million requests per second. That&#39;s for a service where 99% of the
requests are <em>write requests</em>. If you want to have fun with this
server, then you&#39;re also welcome to check out
our <a href="https://ipv4.games/statusz">monitoring metrics</a> while
you do it.

</p><h2 id="games">
  <a href="#games">Cosmopolitan Games</a>
</h2>

<p>
This cosmos.zip release includes several games you can play which have
been vetted on all our supported platforms. For example you can actually
play Nintendo in the terminal and it&#39;ll even work inside the Windows 10
command prompt. Getting poll(stdin) to work in Windows is a messier
problem than even naming or cache invalidation, so it&#39;s super sweet that
Cosmopolitan Third Edition is now able to abstract that complexity.
Although in the case of our port of Bisqwit&#39;s fabulous NESEMU1 program,
it turned out we didn&#39;t need poll() at all! Just calling read() and
letting it be <code>EINTR</code>&#39;d by <code>setitimer()</code> sixty
times a second to pipe audio did the trick. So playing these games
helped battle test our new signals implementation too.

</p><p>
<img width="873" height="628" alt="[cosmo-mario.png]" src="https://hypodyne.net/tunnels-within-tunnels/cosmo-mario.png"/>

</p><p>
We may not have GUI support yet, but you can use your mouse in the
terminal. On Windows, your mouse cursor will generate the same ANSI
XTERM style control codes as it does on Linux, MacOS, BSD, etc. Try
running the <code>life</code> program that&#39;s included in Cosmos. Left
click draws cells. Space runs an iteration of the life game. Right click
can drag the display. You can also ctrl+wheel to zoom the display in and
out. To read the source code to this simple program, check
out <a href="https://github.com/jart/cosmopolitan/blob/3.0/tool/viz/life.c">tool/viz/life.c</a>.

</p><p>
<img width="873" height="628" alt="[cosmo-life.png]" src="https://hypodyne.net/tunnels-within-tunnels/cosmo-life.png"/>

<!-- <h2 id="docker"> -->
<!--   <a class="anchor" href="#docker">Cosmos Docker Image</a> -->
<!-- </h2> -->

<!-- <p> -->
<!-- If you use Docker, then here's how you can setup the Cosmos quickly: -->

<!-- <pre> -->
<!-- <span class="com"># syntax=docker/dockerfile:1-labs</span> -->

<!-- <span class="kwa">FROM</span> busybox as busybox -->

<!-- <span class="kwa">FROM</span> scratch as bootstrap -->

<!-- <span class="kwa">WORKDIR</span> /dl -->
<!-- <span class="kwa">ADD</span> --checksum=sha256:1e1b0d78c71f2207803187ea5673a2223201a5dd32ebd9fefee43f14babe8e73 \ -->
<!--   https://github.com/jart/cosmopolitan/releases/download/3.0/cosmopolitan-3.0.tar.gz . -->
<!-- <span class="kwa">ADD</span> --checksum=sha256:e6b3829f01a05c8fd871c970b771c3d59edf1a64e6cd535ba1613bbd4eceedc0 \ -->
<!--   https://github.com/jart/cosmopolitan/releases/download/3.0/cosmos-3.0.zip . -->
<!-- <span class="kwa">ADD</span> --checksum=sha256:2789991dd41483961a753040ffc083c0c5ff24b84c09a02892e5c584a3f8effa \ -->
<!--   --chmod=0755 https://justine.lol/ape.elf /usr/bin/ape -->

<!-- <span class="kwa">COPY</span> --from=busybox /bin/sh /bin/uname /bin/unzip /bin/tar /bin/rm /bin/ -->

<!-- <span class="kwa">ENV</span> PATH=/opt/cosmo/bin:/opt/cosmos/bin:/bin:/usr/bin -->

<!-- <span class="kwa">WORKDIR</span> /opt/cosmos -->
<!-- <span class="kwa">RUN</span> /bin/unzip -x /dl/cosmos-3.0.zip && rm bin/uname -->

<!-- <span class="kwa">WORKDIR</span> /opt/cosmo -->
<!-- <span class="kwa">RUN</span> /bin/tar -xf /dl/cosmopolitan-3.0.tar.gz --strip-components=1 \ -->
<!-- && /opt/cosmo/bin/cosmocc --update -->

<!-- <span class="kwa">RUN</span> /opt/cosmos/bin/ln -s /opt/cosmo/bin/cosmocc /usr/bin/cc \ -->
<!-- && /opt/cosmos/bin/ln -s /opt/cosmo/bin/cosmocc /usr/bin/gcc -->

<!-- <span class="kwa">RUN</span> rm -rf /dl /bin/tar /bin/unzip /bin/rm -->

<!-- <span class="kwa">FROM</span> scratch -->
<!-- <span class="kwa">COPY</span> --from=bootstrap / / -->
<!-- <span class="kwa">ENV</span> PATH=/opt/cosmo/bin:/opt/cosmos/bin:/bin:/usr/bin -->
<!-- <span class="kwa">ENTRYPOINT</span> [<span class="str">"/bin/sh"</span>, <span class="str">"-c"</span>] -->
<!-- <span class="kwa">CMD</span> [<span class="str">"/opt/cosmos/bin/bash"</span>] -->
<!-- </pre> -->

</p><h2 class="page" id="wasm"><a href="#wasm">WASM Containers</a></h2>

<p>
<img width="813" height="560" alt="[hermit-apw.jpg]" src="https://hypodyne.net/tunnels-within-tunnels/hermit-apw.jpg"/>

</p><p>
Boulder startup dylibso just announced a few weeks ago that they&#39;ve
adopted Cosmopolitan for their new
product <a href="https://dylibso.com/blog/hermit-actually-portable-wasm/">Hermit:
Actually Portable Wasm</a>. Hermit lets you create secure cross-platform
executables for WebAssembly modules. It&#39;s worth a try! Cosmopolitan has
a long history of serving the needs of the Wasm community. Our first
major adopter back in early 2021 was actually
the <a href="https://github.com/wasm3/wasm3">wasm3 project</a> which
provides a similarly great solution to running Wasm outside the browser.
I&#39;m happy to see these projects benefiting from the advantages
Cosmopolitan has to offer. Will you be the next adopter? If so, feel
free to reach out to me personally and I&#39;ll see what I can do to help
you be
successful: <a href="mailto:jtunney@gmail.com">jtunney@gmail.com</a>.
You&#39;re also invited to <a href="https://discord.gg/FwAVVu7eJ4">join our
Discord</a> community.

</p><h2 class="page" id="funding"><a href="#funding">Funding</a></h2>

<p>
  <a href="https://justine.lol/lemuria.png">
    <picture>
      <source srcset="//worker.jart.workers.dev/sectorlisp2/lemuria.webp" type="image/webp"/>
      <img src="https://worker.jart.workers.dev/sectorlisp2/lemuria.png" width="850" height="360" alt="[United States of Lemuria - two dollar bill - all debts public and primate]"/>
    </picture>
  </a>

</p><p>
Funding for Cosmopolitan Third Edition was crowdsourced from Justine
Tunney&#39;s <a href="https://github.com/sponsors/jart">GitHub sponsors</a>
and <a href="https://www.patreon.com/jart">Patreon subscribers</a>, the
backing of
<a href="https://future.mozilla.org/mieco/">Mozilla&#39;s MIECO program</a>,
and the generous contributions of our
<a href="https://discord.gg/FwAVVu7eJ4">developer community</a> on
Discord. Your support is what makes projects like Cosmopolitan possible.
Thank you!

</p>
<img src="https://ipv4.games/claim?name=jart"/>
</div>
  </body>
</html>
