<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gustedt.wordpress.com/2026/02/15/defer-available-in-gcc-and-clang/">Original</a>
    <h1>Defer available in gcc and clang</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>About a year ago I <a href="https://gustedt.wordpress.com/2025/01/06/simple-defer-ready-to-use/">posted about <code>defer</code></a> and that it would be available for everyone using gcc and/or clang soon. So it is probably time for an update.</p>



<p>Two things have happened in the mean time:</p>



<ul>
<li>A <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3734.pdf">technical specification (TS 25755)</a> edited by JeanHeyd Meneide is now complete and moves through ISO’s complicated publication procedures.</li>



<li>Both gcc and clang communities have worked on integrating this feature into their C implementations.</li>
</ul>



<p>I have not yet got my hands on the gcc implementation (but this is also less urgent, see below), but I have been able to use clang’s which is available starting with clang-22.</p>



<p>I think that with this in mind everybody developing in C could and should now seriously consider switching to <code>defer</code> for their cleanup handling: </p>



<ul>
<li>no more resource leakage or blocked mutexes on rarely used code paths, </li>



<li>no more spaghetti code just to cover all possibilities for preliminary exits from functions.</li>
</ul>



<p>I am not sure if the compiler people are also planning back ports of these features, but with some simple work around and slightly reduced grammar for the <code>defer</code> feature this works for me from gcc-9 onward and for clang-22 onward:</p>


<div><pre title="">#if __has_include(&lt;stddefer.h&gt;)
# include &lt;stddefer.h&gt;
# if defined(__clang__)
#  if __is_identifier(_Defer)
#   error &#34;clang may need the option -fdefer-ts for the _Defer feature&#34;
#  endif
# endif
#elif __GNUC__ &gt; 8
# define defer _Defer
# define _Defer      _Defer_A(__COUNTER__)
# define _Defer_A(N) _Defer_B(N)
# define _Defer_B(N) _Defer_C(_Defer_func_ ## N, _Defer_var_ ## N)
# define _Defer_C(F, V)                                                 \
  auto void F(int*);                                                    \
  __attribute__((__cleanup__(F), __deprecated__, __unused__))           \
     int V;                                                             \
  __attribute__((__always_inline__, __deprecated__, __unused__))        \
    inline auto void F(__attribute__((__unused__)) int*V)
#else
# error &#34;The _Defer feature seems not available&#34;
#endif

</pre></div>


<p>So this is already a large panel of compilers. Obviously it depends on your admissible compile platforms whether or not these are sufficient for you. In any case, with these you may compile for a very wide set of installs since <code>defer</code> does not need any specific software infrastructure or library once the code is compiled.</p>



<p>As already discussed many times, the gcc fallback uses the so-called “nested function” feature which is always subject of intense debate and even flame wars. Don’t worry, the implementation as presented here, even when compiled with no optimization at all, does not produce any hidden function in the executable, and in particular there is no “trampoline” or whatever that would put your execution at risk of a stack exploit.</p>



<p>You may also notice that there is no fallback for older clang version. This is because their so-called “blocks” extension cannot easily be used as a drop-in to replace nested function: their semantics to access variables from the surrounding scope are different and not compatible with the <code>defer</code> feature as defined by TS 25755.</p>



<p>So for example if you are scared of using big VLA on the stack, you may use the above code in headers and something like</p>


<div><pre title="">double* BigArray
  = malloc(sizeof(double[aLot]));
if (!BigArray {
  exit(EXIT_FALURE);
}
defer { 
  free(BigArray); 
}
</pre></div>


<p>to have an implementation of a big array with a failure mode for the allocation. </p>



<p>Or if you want to be sure that all your mutexes are unlocked when you leave a critical section, use and idiom as here</p>


<div><pre title="">{
  if (mtx_lock(&amp;mtx) != thrd_success) {
    exit(EXIT_FAILURE);
  }
  defer {
    mtx_unlock(&amp;mtx);
  }

  ... do something complicated ...

  if (rareCondition) {
    return 42;
  }

  ... do something even more complicated ...
}
</pre></div>


<p>Just notice, that you’d always have to use the <code>defer</code> feature with curly braces to ensure that the gcc fallback works smoothly.</p>
</div></div>
  </body>
</html>
