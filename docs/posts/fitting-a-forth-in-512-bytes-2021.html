<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://compilercrim.es/bootstrap/miniforth/">Original</a>
    <h1>Fitting a Forth in 512 bytes (2021)</h1>
    
    <div id="readability-page-1" class="page"><article>
                


<p>
June 10, 2021
· 39 minute read
</p>



<div><p>
  This article is part of the <a href="https://compilercrim.es/bootstrap/">Bootstrapping</a>
  
    series, in which I start from a 512-byte seed and try to bootstrap a
practical system.
  
  
</p>

</div>



<p>Software is full of circular dependencies if you look deep enough. Compilers
written in the language they compile are the most obvious example, but not the
only one. To compile a kernel, you need a running kernel. Linkers, build
systems, shells.  Even text editors, if you want to write the code instead of
just downloading it. How do you break this cycle? Since the <a href="http://bootstrappable.org/">bootstrapping
problem</a> has first come to my attention, I&#39;ve been drawn to
this unique area of software engineering.  Not out of fear that someone would
try to implement a <a href="http://users.ece.cmu.edu/%7Eganger/712.fall02/papers/p761-thompson.pdf">trusting trust</a> attack, but simply as an interesting
challenge.  <span id="continue-reading"></span></p>
<p>11 years ago, <a href="https://www.reddit.com/r/programming/comments/9x15g/programming_thought_experiment_stuck_in_a_room/"><em>vanjos72</em> described on Reddit</a> what he
calls a thought experiment: what if you were locked in a room with an IBM PC,
with no operating system on it? What would be the minimum amount of software
you&#39;d need to start out with to bootstrap back into comfort?</p>
<p>As it happens, I&#39;ve recently found myself with an abundance of free time on my
hands, so I&#39;ve decided to make this more than a thought experiment. Alas, my
computer didn&#39;t come equipped with front panel switches, so some software needs to
be present on the computer already...</p>
<p>The absolutely minimal option would be a simple program that accepts input from
the keyboard, and then jumps to it. Since the keyboard input routines in the
BIOS implement alt+numpad escape codes, you don&#39;t even need to write any base
conversion code. Moreover, the loop doesn&#39;t even need an end
condition — just write to the buffer backwards until you run into the existing
code and overwrite the jump target. This approach takes a mere 14 bytes:</p>
<pre data-lang="lst"><code data-lang="lst"><span>6a00    </span><span>push </span><span>word </span><span>0
</span><span>07      </span><span>pop </span><span>es
</span><span>fd      </span><span>std
</span><span>bf1e7c  </span><span>mov </span><span>di</span><span>, </span><span>buffer</span><span>+</span><span>16</span><span> ; Adjust to taste. Beware of fenceposting.
</span><span>       input_loop:
</span><span>b400    </span><span>mov </span><span>ah</span><span>, </span><span>0
</span><span>cd16    </span><span>int </span><span>0x16
</span><span>aa      </span><span>stosb
</span><span>ebf9    </span><span>jmp </span><span>short input_loop
</span><span>       buffer:
</span></code></pre>
<p>However, I do not find the prospect of entering code this way anywhere near
appealing. I&#39;ve decided that, since the BIOS loads an entire sector anyway, any
bootstrap seed that fits into the bootsector is fair game. Obviously,
one would want to maximize the utility of the chosen program. What is the most
powerful thing we can fit in 510 bytes?</p>
<p>Many interesting sector-sized programs have been written. In particular, Oscar Toledo
has authored a wide variety of examples. This includes various games,
such as <a href="https://github.com/nanochess/cubicDoom">a DooM-like raycasting game</a> or a <a href="https://github.com/nanochess/Toledo-Atomchess">chess AI</a>,
as well as a basic <a href="https://github.com/nanochess/bootBASIC">BASIC interpreter</a>, but
perhaps the most relevant one for our usecase is <a href="https://github.com/nanochess/bootOS">bootOS</a>:</p>
<blockquote>
<p><code>bootOS</code> is a monolithic operating system that fits in one boot sector. It&#39;s
able to load, execute, and save programs. Also keeps a filesystem.</p>
</blockquote>
<p>It exposes its filesystem routines with an interrupt interface, and includes a
builtin command that allows creating a file by typing in its hexdump. Very neat,
but clearly mostly intended as a multiplexer between other sector-sized
programs.</p>
<p>What I would seek is a solution that minimizes typing in hand-assembled machine
code. Ideally, it would be a programming language, but one that, unlike BASIC,
can be extended at runtime. If you&#39;ve read the title of this post, you already
know what I settled on — as it turns out, it&#39;s possible to fit a barebones Forth
in a bootsector. You can see the code in the <a href="https://github.com/meithecatte/miniforth/tree/post1">Miniforth repository on
GitHub</a>, but I will include most of it here.</p>
<p>The entire Forth takes, at this moment, 504 bytes. As you might expect, the
development process involved being on a perpetual lookout for byte-saving
opportunities. However, when I published what I thought was quite tightly
optimized code, <a href="https://twitter.com/ilyakurdyukov">Ilya Kurdyukov</a> came along and managed to find 24 bytes
to be saved! I promptly reinvested this saved space in <a href="https://compilercrim.es/bootstrap/miniforth/#s-string-poke">new
features</a>.</p>
<section><h2 id="a-primer-on-forth">A primer on Forth</h2>
<p><em>If you&#39;ve ever written anything in Forth, you can safely skip this section.</em></p>
<p>Forth is a stack-based language. For example, a number will push its value onto
the stack, while the <code>+</code> <em>word</em> will pop two numbers and push their sum. A
common debugging utility, but one not included in Miniforth, is the
<code>.s</code> word, which prints the contents of the stack.</p>
<pre><b>1 2 3 + .s</b> &lt;2&gt; 1 5  ok
</pre>
<p>The user can define their own words with <code>:</code> and <code>;</code>. For example:</p>
<pre><b>: double dup + ;</b>  ok
<b>3 double .</b> 6  ok
</pre>
<p>This defines the word <code>double</code>, which does the same thing as <code>dup +</code>. <code>dup</code>, by
the way, is one of Forth&#39;s stack manipulation words. It duplicates the top
element on the stack:</p>
<pre><b>42 dup .s</b> &lt;2&gt; 42 42  ok
</pre>
<p><em>This is basically the entire language.</em> There are some standard facilities for
conditionals and loops, but we don&#39;t need to concern ourselves with those for
now, as they can be built on top of Miniforth later on.</p>
<p>To talk about the effect a word has on the state of the stack, we use a notation
like this:</p>
<pre data-lang="forth"><code data-lang="forth"><span>dup </span><span>( a -- a a )
</span><span>swap </span><span>( a b -- b a )
</span></code></pre>
<p>The list before the <code>--</code> are the inputs, with the top of stack listed last.
After the <code>--</code>, we list the outputs, which start at the same stack depth.
This lets us succintly describe the common aspects of a word.</p>
</section><section><h2 id="threaded-code">Threaded code</h2>
<p>While some Forth systems do include full-blown, optimizing compilers similar to
those one&#39;d see in a typical programming language, there is a much simpler
strategy. After all, everything a Forth word can do is execute other words, so a
sequence of <code>call</code> instructions gets us very close:</p>
<pre data-lang="asm"><code data-lang="asm"><span>DOUBLE:
</span><span>    </span><span>call </span><span>DUP
</span><span>    </span><span>call </span><span>PLUS
</span><span>    </span><span>ret
</span></code></pre>
<p>However, this ties up the hardware <code>x86</code> stack for the return stack, making us
handroll a separate stack for the actual user-level stack (known as the
<em>parameter stack</em>). As accessing the parameter stack is much more common, we&#39;d
like to use the <code>push</code> and <code>pop</code> instructions for that, and instead handroll a
mechanism similar to <code>call</code>. Firstly, let&#39;s simply store a list of pointers to
words:</p>
<pre data-lang="asm"><code data-lang="asm"><span>DOUBLE:
</span><span>    </span><span>dw </span><span>DUP
</span><span>    </span><span>dw </span><span>PLUS
</span></code></pre>
<p>The way this comes to life is that each primitive word fetches the address of
the next word from memory, and jumps to it. A pointer to this sequence of
pointers is kept in <code>SI</code>, so that the <code>lodsw</code> instruction allows for easy
processing of this list:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    </span><span>mov </span><span>si</span><span>, </span><span>DOUBLE
</span><span>    </span><span>lodsw
</span><span>    </span><span>jmp </span><span>ax
</span><span>
</span><span>DUP:
</span><span>    </span><span>pop </span><span>ax
</span><span>    </span><span>push </span><span>ax
</span><span>    </span><span>push </span><span>ax
</span><span>
</span><span>    </span><span>lodsw
</span><span>    </span><span>jmp </span><span>ax
</span><span>
</span><span>PLUS:
</span><span>    </span><span>pop </span><span>ax
</span><span>    </span><span>pop </span><span>bx
</span><span>    </span><span>add </span><span>ax</span><span>, </span><span>bx
</span><span>    </span><span>push </span><span>ax
</span><span>
</span><span>    </span><span>lodsw
</span><span>    </span><span>jmp </span><span>ax
</span></code></pre>
<p>This common code can be abstracted away into a macro, which is traditionally
called <code>NEXT</code>:</p>
<pre data-lang="asm"><code data-lang="asm"><span>%macro </span><span>NEXT </span><span>0
</span><span>    </span><span>lodsw
</span><span>    </span><span>jmp </span><span>ax
</span><span>%endmacro
</span></code></pre>
<p>This mechanism, by the way, is known as <em>threaded code</em>. No relation to the concurrency
primitive.</p>
<p>What happens if one compiled word calls another one, though? This is where the
return stack comes in. It might feel natural to use the <code>BP</code> register for this
stack pointer. However, in 16-bit x86, there isn&#39;t actually a <code>[bp]</code> addressing
mode. The closest you can get is <code>[bp+imm8]</code>, which means that accessing the
memory at <code>bp</code> wastes a byte to specify that you do not want an offset. This is
why I use the <code>di</code> register for the return stack instead. Overall, this choice
saves 4 bytes.</p>
<p>Anyway, here is how the return stack is used to handle compiled words calling each
other. Pushing onto the return stack is particularily nice, since it&#39;s just the
<code>stosw</code> instruction.</p>
<pre data-lang="asm"><code data-lang="asm"><span>DOUBLE:
</span><span>    </span><span>call </span><span>DOCOL
</span><span>    </span><span>dw </span><span>DUP
</span><span>    </span><span>dw </span><span>PLUS
</span><span>    </span><span>dw </span><span>EXIT
</span><span>
</span><span>DOCOL:</span><span>   ; short for &#34;do colon word&#34;
</span><span>    </span><span>xchg </span><span>ax</span><span>, </span><span>si</span><span> ; used here as `mov ax, si`, but swaps with
</span><span>                ; ax are only one byte, while `mov`s are two bytes
</span><span>    </span><span>stosw
</span><span>    </span><span>pop </span><span>si</span><span> ; grab the pointer pushed by `call`
</span><span>    NEXT
</span><span>
</span><span>EXIT:
</span><span>    </span><span>dec </span><span>di
</span><span>    </span><span>dec </span><span>di
</span><span>    </span><span>mov </span><span>si</span><span>, [</span><span>di</span><span>]
</span><span>    NEXT
</span></code></pre>
<p><span id="tos-bx">This</span> is pretty much the execution strategy used by Miniforth, with one simple,
but significant improvement — the value on top of the stack is stored in the
<code>BX</code> register. This allows skipping a <code>push</code> and <code>pop</code> in many primitives:</p>
<pre data-lang="asm"><code data-lang="asm"><span>PLUS:
</span><span>    </span><span>pop </span><span>ax
</span><span>    </span><span>add </span><span>bx</span><span>, </span><span>ax
</span><span>    NEXT
</span><span>
</span><span>DROP:
</span><span>    </span><span>pop </span><span>bx
</span><span>    NEXT
</span><span>
</span><span>DUP:
</span><span>    </span><span>push </span><span>bx
</span><span>    NEXT
</span></code></pre>
<p>One case is still unresolved, though.  What happens if a word contains a number,
such as <code>: DOUBLE 2 * ;</code>? This is handled by <code>LIT</code>, which will fetch the literal
that follows out of the pointer stream:</p>
<pre data-lang="asm"><code data-lang="asm"><span>DOUBLE:
</span><span>    </span><span>call </span><span>DOCOL
</span><span>    </span><span>dw </span><span>LIT</span><span>, </span><span>2
</span><span>    </span><span>dw </span><span>MULT
</span><span>    </span><span>dw </span><span>EXIT
</span><span>
</span><span>LIT:
</span><span>    </span><span>push </span><span>bx
</span><span>    </span><span>lodsw
</span><span>    </span><span>xchg </span><span>bx</span><span>, </span><span>ax
</span><span>    NEXT
</span></code></pre>
</section><section><h2 id="the-dictionary">The dictionary</h2>
<p>We need a way to locate the implementation of the words the user types in.
This is the role of the <em>dictionary</em>. I use a structure similar to many other
small-scale Forths — a singly linked list of word headers, directly prepended
before the code of each word. Out of tradition, the head of the list is kept
in a variable called <code>LATEST</code>.</p>
<p><img src="https://compilercrim.es/bootstrap/miniforth/dictionary.svg" alt="The first two bytes of each header are the link field, which points at the beginning of the previously defined word. At the end of this list, there is a NULL to indicate the first word that was defined, and therefore the last one in the list. After each link field is one byte signifying the length of the name. This is then followed by the actual name, and the machine code implementation is directly afterwards."/></p>
<p>The most significant bits of the name length field also store some flags:</p>
<pre data-lang="asm"><code data-lang="asm"><span>F_IMMEDIATE </span><span>equ </span><span>0x80
</span><span>F_HIDDEN    </span><span>equ </span><span>0x40
</span><span>F_LENMASK   </span><span>equ </span><span>0x1f
</span></code></pre>
<p>If a word is marked as <code>IMMEDIATE</code>, it will be executed immediately, even if
we&#39;re currently compiling a definition. For example, this is used to implement
<code>;</code>.  If a word is marked as <code>HIDDEN</code>, it is ignored when searching through the
dictionary. Apart from being used as a rudimentary encapsulation mechanism, this
can be used to implement the traditional Forth semantics where a redefinition
can refer to the previous word with the same name (and <code>RECURSE</code> is used when
you want the definition currently being compiled). However, towards the end of
development, I have removed the code that actually does this from the default
implementation of <code>:</code> and <code>;</code>.</p>
</section><section><h2 id="compression">Compression</h2>
<p>It is usually not worth it to use compression when both the decompressor and its
payload have to fit in merely 512 bytes. However, in a Forth implementation, one
thing that&#39;s repeated very often is the implementation of <code>NEXT</code>.</p>
<pre data-lang="lst"><code data-lang="lst"><span>ad      </span><span>lodsw
</span><span>ffe0    </span><span>jmp </span><span>ax
</span></code></pre>
<p>We could try to save some bytes by replacing these with jumps to a shared copy.
However, a short jump still takes two bytes — not a significant saving. As it
turns out, a special compression scheme that can only handle this one repeating
pattern is worth it, as long as you combine it with the following observation:
<code>NEXT</code> is almost always followed by the dictionary entry of the next primitive,
of which the link field is predictable.</p>
<p>I chose to implement a compression scheme where every <code>0xff</code> byte is replaced
with <code>NEXT</code>, followed by a link field, which is computed based on the previous
occurence of an <code>0xff</code> byte. This strategy saved 19 bytes when I introduced
it.</p>
<p>At first, I used a <code>0x90</code> byte for this — after all, it&#39;s the opcode of <code>nop</code>,
which I&#39;m definitely not going to be using. However, the byte can still occur in
the immediate bytes of an instruction. It wasn&#39;t a problem at first, but when
the code was shifting around in memory, various addresses and offsets became
<code>0x90</code> often enough to be a nuisance. <code>0xff</code> doesn&#39;t seem to have this problem.</p>
<p>To create a link, we copy the value of <code>LATEST</code> to the decompressor output, and
update <code>LATEST</code> to point to the word we&#39;ve just written. This can be done in a
very compact sequence of instructions, but it still takes enough bytes that it
is worthy it to factor it out as a subroutine — it is also used by the
implementation of <code>:</code>, which creates dictionary entries at runtime.</p>
<pre data-lang="asm"><code data-lang="asm"><span>; Creates a dictionary linked list link at DI.
</span><span>MakeLink:
</span><span>    </span><span>mov </span><span>ax</span><span>, </span><span>di
</span><span>    </span><span>xchg </span><span>[</span><span>LATEST</span><span>], </span><span>ax</span><span>  ; AX now points at the old entry, while
</span><span>                       ; LATEST and DI point at the new one.
</span><span>    </span><span>stosw
</span><span>    </span><span>ret
</span></code></pre>
<p>The decompressor used to make use of an interesting trick, where instead of a
short forward jump, an opcode is placed so the immediate argument it requires
eats the instructions we want to jump over. That is, instead of</p>
<pre data-lang="asm"><code data-lang="asm"><span>    </span><span>jmp </span><span>short .after
</span><span>.write:
</span><span>    </span><span>stosb
</span><span>.after:
</span></code></pre>
<p>you write</p>
<pre data-lang="lst"><code data-lang="lst"><span>3c      </span><span>db </span><span>0x3c</span><span> ; skip the stosb below by comparing its opcode with AL
</span><span>    .write:
</span><span>aa      </span><span>stosb
</span></code></pre>
<p>Thus, if some other code jumps to <code>.write</code>, the <code>stosb</code> executes, but this
codepath just does <code>cmp al, 0xaa</code>. At first, I didn&#39;t think of the <code>cmp al</code>
instruction, and a <code>mov</code> into a throwaway register instead. This <a href="https://twitter.com/meithecatte/status/1401557309118103560">backfired
spectacularily</a> because of my inability to actually pick
a register that can be safely overwritten.</p>
<p>Ilya Kurdyukov then demonstrated <a href="https://twitter.com/ilyakurdyukov/status/1401736488681979906">that the same bytecount can be achieved
without this kind of &#34;magic&#34;</a>. An analogous modification allowed
me to remove the other occurence of this trick too. The essence is that instead
of trying to skip over the <code>stosb</code>, we execute it unconditionally before the
codepaths branch, and then essentially undo it with <code>dec di</code> if necessary:</p>
<pre data-lang="asm"><code data-lang="asm"><span>SPECIAL_BYTE </span><span>equ </span><span>0xff
</span><span>
</span><span>    </span><span>mov </span><span>si</span><span>, </span><span>CompressedData
</span><span>    </span><span>mov </span><span>di</span><span>, </span><span>CompressedBegin
</span><span>    </span><span>mov </span><span>cx</span><span>, </span><span>COMPRESSED_SIZE
</span><span>.decompress:
</span><span>    </span><span>lodsb
</span><span>    </span><span>stosb
</span><span>    </span><span>cmp </span><span>al</span><span>, </span><span>SPECIAL_BYTE
</span><span>    </span><span>jnz </span><span>short .not_special
</span><span>    </span><span>dec </span><span>di
</span><span>    </span><span>mov </span><span>ax</span><span>, </span><span>0xffad</span><span> ; lodsw / jmp ax
</span><span>    </span><span>stosw
</span><span>    </span><span>mov </span><span>al</span><span>, </span><span>0xe0
</span><span>    </span><span>stosb
</span><span>    </span><span>call </span><span>MakeLink
</span><span>.not_special:
</span><span>    </span><span>loop </span><span>.decompress
</span></code></pre>
<p>Actually generating the compressed stream is more involved. Because I want jumps
between the compressed and uncompressed portions to work, the assembler needs to
believe it is writing the code at the location it will actually run. I first
attempted to do this by adjusting the <code>org</code> after each <code>SPECIAL_BYTE</code>, but
unfortunately, yasm didn&#39;t like that.</p>
<pre><code><span>boot.s:137: error: program origin redefined
</span></code></pre>
<p>Clearly, a separate post-processing step is necessary. I wrote a macro to shim
the bytes the decompressor will insert:</p>
<pre data-lang="asm"><code data-lang="asm"><span>%macro </span><span>compression_sentinel </span><span>0
</span><span>    </span><span>db </span><span>SPECIAL_BYTE
</span><span>    </span><span>dd </span><span>0xdeadbeef
</span><span>%endmacro
</span></code></pre>
<p>This has the added benefit of allowing a simple automated way to verify that no
<code>SPECIAL_BYTE</code>s slipped in by accident.</p>
<p>I still had to allocate the space for the compressed data. I choose the
following layout:</p>
<ol>
<li>Uncompressed code starts at <code>7C00</code> — initialization, decompression, and the outer interpreter.</li>
<li>Compressed data immediately follows, filling up the bootsector up to a moment
before <code>7E00</code>.</li>
<li>The decompression buffer is allocated immediately after that, which is where
<code>yasm</code> outputs the target contents.</li>
</ol>
<p>To achieve this, I needed to know exactly how much space needs to be allocated
for the compressed data. First, I calculate the exact number of bytes saved by
incrementing a counter in the <code>compression_sentinel</code> macro:</p>
<pre data-lang="asm"><code data-lang="asm"><span>%assign </span><span>savings </span><span>0
</span><span>
</span><span>%macro </span><span>compression_sentinel </span><span>0
</span><span>%assign </span><span>savings savings</span><span>+</span><span>4
</span><span>    </span><span>db </span><span>SPECIAL_BYTE
</span><span>    </span><span>dd </span><span>0xdeadbeef
</span><span>%endmacro
</span></code></pre>
<p>Then, I simply subtract this from the size of the uncompressed segment:</p>
<pre data-lang="asm"><code data-lang="asm"><span>CompressedData:
</span><span>    </span><span>times </span><span>COMPRESSED_SIZE </span><span>db </span><span>0xcc
</span><span>
</span><span>CompressedBegin:
</span><span>; ...
</span><span>CompressedEnd:
</span><span>
</span><span>COMPRESSED_SIZE </span><span>equ </span><span>CompressedEnd </span><span>- </span><span>CompressedBegin </span><span>- </span><span>savings
</span></code></pre>
<p>The post-processing is done by a simple Python script:</p>
<pre data-lang="python"><code data-lang="python"><span>SPECIAL_BYTE </span><span>= </span><span>b</span><span>&#39;</span><span>\xff</span><span>&#39;
</span><span>SENTINEL </span><span>= </span><span>SPECIAL_BYTE </span><span>+ </span><span>b</span><span>&#39;</span><span>\xef\xbe\xad\xde</span><span>&#39;
</span><span>
</span><span>with </span><span>open</span><span>(</span><span>&#39;raw.bin&#39;</span><span>, </span><span>&#39;rb&#39;</span><span>) </span><span>as </span><span>f:
</span><span>    data </span><span>= </span><span>f.read()
</span><span>
</span><span># Recognize the reserved space by an arbitrary, but relatively large threshold
</span><span># of 20 repeated \xcc bytes.
</span><span>output_offset </span><span>= </span><span>data.index(</span><span>b</span><span>&#39;</span><span>\xcc</span><span>&#39; </span><span>* </span><span>20</span><span>)
</span><span>chunks </span><span>= </span><span>data[output_offset:].lstrip(</span><span>b</span><span>&#39;</span><span>\xcc</span><span>&#39;</span><span>).split(SENTINEL)
</span><span>
</span><span>assert </span><span>SPECIAL_BYTE </span><span>not in </span><span>chunks[</span><span>0</span><span>]
</span><span>compressed </span><span>= </span><span>bytearray</span><span>(chunks[</span><span>0</span><span>])
</span><span>
</span><span>for </span><span>chunk </span><span>in </span><span>chunks[</span><span>1</span><span>:]:
</span><span>    </span><span>assert </span><span>SPECIAL_BYTE </span><span>not in </span><span>chunk
</span><span>    compressed.extend(SPECIAL_BYTE)
</span><span>    compressed.extend(chunk)
</span><span>
</span><span># Make sure that exactly the right amount of space is allocated
</span><span># for the compressed data.
</span><span>assert </span><span>b</span><span>&#39;</span><span>\xcc</span><span>&#39; </span><span>* </span><span>len</span><span>(compressed) </span><span>in </span><span>data
</span><span>assert </span><span>b</span><span>&#39;</span><span>\xcc</span><span>&#39; </span><span>* </span><span>(</span><span>len</span><span>(compressed) </span><span>+ </span><span>1</span><span>) </span><span>not in </span><span>data
</span><span>
</span><span>output </span><span>= </span><span>data[:output_offset] </span><span>+ </span><span>compressed
</span><span>
</span><span>print</span><span>(</span><span>len</span><span>(output), </span><span>&#39;bytes used&#39;</span><span>)
</span><span>output </span><span>+= </span><span>b</span><span>&#39;</span><span>\x00</span><span>&#39; </span><span>* </span><span>(</span><span>510 </span><span>- </span><span>len</span><span>(output))
</span><span>output </span><span>+= </span><span>b</span><span>&#39;</span><span>\x55\xaa</span><span>&#39;
</span><span>
</span><span>with </span><span>open</span><span>(</span><span>&#39;boot.bin&#39;</span><span>, </span><span>&#39;wb&#39;</span><span>) </span><span>as </span><span>f:
</span><span>    f.write(output)
</span></code></pre>
<p>The same script also generates an extended disk image, which contains some
smoke-testing code in block 1:</p>
<pre data-lang="python"><code data-lang="python"><span>output </span><span>+= </span><span>b</span><span>&#39;</span><span>\x00</span><span>&#39; </span><span>* </span><span>512
</span><span>output </span><span>+= </span><span>open</span><span>(</span><span>&#39;test.fth&#39;</span><span>, </span><span>&#39;rb&#39;</span><span>).read().replace(</span><span>b</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>, </span><span>b</span><span>&#39; &#39;</span><span>)
</span><span>output </span><span>+= </span><span>b</span><span>&#39; &#39; </span><span>* </span><span>(</span><span>2048 </span><span>- </span><span>len</span><span>(output))
</span><span>
</span><span>with </span><span>open</span><span>(</span><span>&#39;test.img&#39;</span><span>, </span><span>&#39;wb&#39;</span><span>) </span><span>as </span><span>f:
</span><span>    f.write(output)
</span></code></pre>
<p><code>compression_sentinel</code> is most often used by the <code>defcode</code> macro, which creates
the dictionary entry for a primitive word. It takes a label (which can then be
used to jump to the implementation of some word), the name of the word as a string,
and optionally, some flags to be ORed into the length field:</p>
<pre data-lang="asm"><code data-lang="asm"><span>; defcode PLUS, &#34;+&#34;
</span><span>; defcode SEMI, &#34;;&#34;, F_IMMEDIATE
</span><span>%macro </span><span>defcode </span><span>2</span><span>-</span><span>3 0
</span><span>    compression_sentinel
</span><span>%strlen </span><span>namelength %</span><span>2
</span><span>    </span><span>db </span><span>%</span><span>3 </span><span>| namelength</span><span>, </span><span>%</span><span>2
</span><span>%</span><span>1</span><span>:
</span><span>%endmacro
</span></code></pre>
<p>This is then used to define the primitives. The code essentially falls-through
into a <code>defcode</code>:</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode PLUS</span><span>, </span><span>&#34;+&#34;
</span><span>    </span><span>pop </span><span>ax
</span><span>    </span><span>add </span><span>bx</span><span>, </span><span>ax
</span><span>
</span><span>defcode MINUS</span><span>, </span><span>&#34;-&#34;
</span><span>    </span><span>pop </span><span>ax
</span><span>    </span><span>sub </span><span>ax</span><span>, </span><span>bx
</span><span>    </span><span>xchg </span><span>bx</span><span>, </span><span>ax
</span><span>
</span><span>defcode PEEK</span><span>, </span><span>&#34;@&#34;
</span><span>    ; ...
</span></code></pre>
<p><span id="docol-compression">However,</span> <code>DOCOL</code>, <code>EXIT</code> and <code>LIT</code> also use
the compression mechanism for their <code>NEXT</code>s. Since the link field is still
written out, this essentially creates bogus dictionary entries. Fortunately, the
first opcode of <code>EXIT</code> and <code>LIT</code> has the <code>F_HIDDEN</code> bit set, so this is not a
problem:</p>
<pre data-lang="asm"><code data-lang="asm"><span>CompressedBegin:
</span><span>
</span><span>DOCOL:
</span><span>    </span><span>xchg </span><span>ax</span><span>, </span><span>si
</span><span>    </span><span>stosw
</span><span>    </span><span>pop </span><span>si</span><span> ; grab the pointer pushed by `call`
</span><span>    compression_sentinel
</span><span>
</span><span>LIT:
</span><span>    </span><span>push </span><span>bx
</span><span>    </span><span>lodsw
</span><span>    </span><span>xchg </span><span>bx</span><span>, </span><span>ax
</span><span>    compression_sentinel
</span><span>
</span><span>EXIT:
</span><span>    </span><span>dec </span><span>di
</span><span>    </span><span>dec </span><span>di
</span><span>    </span><span>mov </span><span>si</span><span>, [</span><span>di</span><span>]
</span><span>
</span><span>defcode PLUS</span><span>, </span><span>&#34;+&#34;
</span><span>    ; ...
</span></code></pre>
</section><section><h2 id="variables">Variables?</h2>
<p>Immediate load instructions tend to have shorter encodings than loads from
memory:</p>
<pre data-lang="lst"><code data-lang="lst"><span>be3412    </span><span>mov </span><span>si</span><span>, </span><span>0x1234
</span><span>8b363412  </span><span>mov </span><span>si</span><span>, [</span><span>0x1234</span><span>]
</span></code></pre>
<p>This is why Miniforth stores most of its variables in the immediate fields of
instructions (a practice known as self-modifying code). Of course, this means
that the address of these variables will change on every edit of the code, which
is problematic, since we will be wanting to access these variables in Forth
code. The typical way of exposing a variable is to create a word that pushes its
address. However, that&#39;s way too expensive with our constraints. What I settled
on is pushing the addresses onto the stack at startup. This can be done with
only 2 bytes for each address, by simply defining the initial contents of the
stack as data:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    org </span><span>0x7c00
</span><span>
</span><span>    </span><span>jmp </span><span>0</span><span>:start
</span><span>stack:
</span><span>    </span><span>dw </span><span>HERE
</span><span>    </span><span>dw </span><span>BASE
</span><span>    </span><span>dw </span><span>STATE
</span><span>    </span><span>dw </span><span>LATEST
</span><span>start:
</span><span>    ; ...
</span><span>    </span><span>mov </span><span>sp</span><span>, </span><span>stack
</span></code></pre>
<p>Even when a variable&#39;s address needs to be pushed onto the stack, this
self-modifying code strategy saves bytes if a variable needs to be initialized —
the best way to initialize a variable is to simply allocate it within the
bootsector and <code>dw</code> the initial value there, which exactly evens out the stack
data, and keeps the advantage of the shorter instruction encoding.</p>
</section><section><h2 id="initialization-code">Initialization code</h2>
<p>The first thing done after booting is setting up the <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">segment registers</a> and
stack. The direction flag is also cleared, so that the string instructions work
in the right direction.</p>
<pre data-lang="asm"><code data-lang="asm"><span>    </span><span>jmp </span><span>0</span><span>:start
</span><span>    ; ...
</span><span>start:
</span><span>    </span><span>push </span><span>cs
</span><span>    </span><span>push </span><span>cs
</span><span>    </span><span>push </span><span>cs
</span><span>    </span><span>pop </span><span>ds
</span><span>    </span><span>pop </span><span>es
</span><span>    </span><span>pop </span><span>ss
</span><span>    </span><span>mov </span><span>sp</span><span>, </span><span>stack
</span><span>    </span><span>cld
</span></code></pre>
<p>There are a two notable things about this code. Firstly, segment registers are
set through the stack. This is a byte-saving trick I&#39;ve picked up from
<code>bootBASIC</code> — it allows having to initialize a general-purpose register to zero:</p>
<pre data-lang="lst"><code data-lang="lst"><span>31c0    </span><span>xor </span><span>ax</span><span>, </span><span>ax</span><span>  ; through AX - 8 bytes
</span><span>8ed8    </span><span>mov </span><span>ds</span><span>, </span><span>ax
</span><span>8ec0    </span><span>mov </span><span>es</span><span>, </span><span>ax
</span><span>8ed0    </span><span>mov </span><span>ss</span><span>, </span><span>ax
</span><span>
</span><span>0e      </span><span>push </span><span>cs</span><span>     ; through the stack - 6 bytes
</span><span>0e      </span><span>push </span><span>cs
</span><span>0e      </span><span>push </span><span>cs
</span><span>1f      </span><span>pop </span><span>ds
</span><span>07      </span><span>pop </span><span>es
</span><span>17      </span><span>pop </span><span>ss
</span></code></pre>
<p>Secondly, one would think that, while the stack is being repointed, a small race
condition window occurs — if an interrupt happened between <code>pop ss</code> and <code>mov sp</code>,
chaos could ensue if the previous value of SP was in an unlucky place in memory.
Of course, I could just cross my fingers and hope this doesn&#39;t happen if the 2
bytes required to wrap this in an <code>cli</code>/<code>sti</code> pair were too much. However, it
turns out that this trade-off is not necessary due to an obscure corner of the
x86 architecture. To quote the Volume 2B of the <a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">x86 Software Developer&#39;s Manual</a>:</p>
<blockquote>
<p>Loading the SS register with a POP instruction suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the ESP register with the next instruction (POP ESP) before an event can be delivered.</p>
</blockquote>
<p>After the segments, stack and direction flag are set up, the decompressor is
ran. Crucially, it does not use the DL register, which contains the BIOS disk
number from which we were booted. It is then poked into the implementation of
<code>load</code> (which is in the compressed segment), and pushed onto the stack for later
use by user code:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    </span><span>mov </span><span>[</span><span>DRIVE_NUMBER</span><span>], </span><span>dl
</span><span>    </span><span>push </span><span>dx</span><span> ; for Forth code
</span></code></pre>
</section><section><h2 id="the-outer-interpreter">The outer interpreter</h2>
<p>At this point, we reach the <em>outer interpreter</em> - the part of a Forth system
that processes user input. The name &#34;<em>outer</em> interpreter&#34; distinguishes it from
the <em>inner</em> interpreter, which is the component that coordinates the execution
within a defined word, and consists of <code>NEXT</code>, <code>DOCOL</code>, <code>EXIT</code>, and <code>LIT</code>.</p>
<p>Normally, a Forth would expose the building blocks of its outer interpreter as
words in the dictionary, such as</p>
<ul>
<li><code>REFILL</code> (read a line of input from the currently executing source),</li>
<li><code>WORD</code> (parse a word from the input stream),</li>
<li><code>FIND</code> (look up a word in the dictionary),</li>
<li><code>&gt;NUMBER</code> (convert a string to number).</li>
</ul>
<p>In Miniforth, no attention is paid to this practice at all. Dictionary headers
cost bytes, and so does communicating only through the stack. In fact, <code>WORD</code>
and <code>&gt;NUMBER</code> are melded together into one routine that does the job of both —
that way, the loop can be shared, which saves bytes.</p>
<p>This monolithic architecture also lets us decide that <code>BX</code> and <code>DI</code> are not
reserved for the top of stack and the return stack pointer, respectively, while
the outer interpreter is executing. This significantly helps with register
starvation within these comparatively complex parts of the system. These
registers are set up just before jumping to a word, and saved after it returns.</p>
</section><section><h3 id="keyboard-input">Keyboard input</h3>
<p>After initialization is completed, the code falls through to <code>ReadLine</code>, the
routine for reading in an input line from the keyboard. We will also jump back
here later, when the current line of input is exhausted. The input buffer is at
<code>0x500</code>, directly after the <a href="https://www.matrix-bios.nl/system/bda.html">BDA</a>. While the idiomatic string format for Forth
uses a separate length field, this buffer is NULL-terminated, as that is easier
to handle when parsing. The pointer to the unparsed fragment of the input is
stored in <code>InputPtr</code>, which is the only variable which does <em>not</em> use the
self-modification technique, as it does not need to be explicitly initialized —
it naturally gets written to before it is read.</p>
<pre data-lang="asm"><code data-lang="asm"><span>InputBuf </span><span>equ </span><span>0x500
</span><span>InputPtr </span><span>equ </span><span>0xa02</span><span> ; dw
</span><span>
</span><span>ReadLine:
</span><span>    </span><span>mov </span><span>di</span><span>, </span><span>InputBuf
</span><span>    </span><span>mov </span><span>[</span><span>InputPtr</span><span>], </span><span>di
</span><span>.</span><span>loop</span><span>:
</span><span>    </span><span>mov </span><span>ah</span><span>, </span><span>0
</span><span>    </span><span>int </span><span>0x16
</span><span>    </span><span>cmp </span><span>al</span><span>, </span><span>0x0d
</span><span>    </span><span>je </span><span>short .</span><span>enter
</span><span>    </span><span>stosb
</span><span>    </span><span>cmp </span><span>al</span><span>, </span><span>0x08
</span><span>    </span><span>jne </span><span>short .write
</span><span>    </span><span>dec </span><span>di
</span><span>    </span><span>cmp </span><span>di</span><span>, </span><span>InputBuf</span><span> ; underflow check
</span><span>    </span><span>je </span><span>short .</span><span>loop
</span><span>    </span><span>dec </span><span>di
</span><span>.write:
</span><span>    </span><span>call </span><span>PutChar
</span><span>    </span><span>jmp </span><span>short .</span><span>loop
</span><span>.</span><span>enter</span><span>:
</span><span>    </span><span>call </span><span>PutChar
</span><span>    </span><span>mov </span><span>al</span><span>, </span><span>0x0a
</span><span>    </span><span>int </span><span>0x10
</span><span>    </span><span>xchg </span><span>ax</span><span>, </span><span>bx</span><span> ; write the null terminator by using the BX = 0 from PutChar
</span><span>    </span><span>stosb
</span><span>InterpreterLoop:
</span><span>    </span><span>call </span><span>ParseWord</span><span> ; returns length in CX. Zero implies no more input.
</span><span>    jcxz short ReadLine
</span></code></pre>
<p>The BIOS interrupt for getting a character from the keyboard does not print the
key — we have to do that ourselves. This is done with the &#34;TELETYPE OUTPUT&#34;
function, which already handles special characters like backspace or newline.</p>
<pre data-lang="asm"><code data-lang="asm"><span>PutChar:
</span><span>    </span><span>xor </span><span>bx</span><span>, </span><span>bx
</span><span>    </span><span>mov </span><span>ah</span><span>, </span><span>0x0e
</span><span>    </span><span>int </span><span>0x10
</span><span>    </span><span>ret
</span></code></pre>
<p>This function has its deficiencies. For example, the icky CRLF line endings are
needed (CR to move the cursor to the beginning of the line, and LF to move it
to the next line). Also, the backspace character only moves the cursor back a
character, and does not erase it. To get the behavior we&#39;ve come to expect, it
would be necessary to print <code>\b \b</code> (to be fair, this is also the case on modern
terminals). I chose to skip that.</p>
<p>Finally, <a href="http://www.ctyme.com/rbrown.htm">Ralf Brown&#39;s Interrupt List</a> mentions that some BIOSes clobber
BP when the printed character causes the screen to scroll. This does not concern
us, as we do not use this register at all.</p>
</section><section><h3 id="parsing">Parsing</h3>
<p>After we read in a line, we need to parse it into words. This is done on demand
— each word is executed (or compiled, depending on the state), as soon as it is
parsed. Apart from the interpreter loop, <code>ParseWord</code> is also called by
the implementation of <code>:</code> (to get the name of the word being defined).</p>
<p>As mentioned before, this routine also computes the numeric value of the word,
with the assumption that it&#39;s valid. There is no error checking in this regard —
if a word is not found in the dictionary, its numeric value is pushed, which is
probably nonsense if this wasn&#39;t intended.</p>
<p>We start out by skipping any whitespace in the input buffer:</p>
<pre data-lang="asm"><code data-lang="asm"><span>; returns
</span><span>; DX = pointer to string
</span><span>; CX = string length
</span><span>; BX = numeric value
</span><span>; clobbers SI and BP
</span><span>ParseWord:
</span><span>    </span><span>mov </span><span>si</span><span>, [</span><span>InputPtr</span><span>]
</span><span>    ; repe scasb would probably save some bytes here if the registers worked out - scasb
</span><span>    ; uses DI instead of SI :(
</span><span>.skiploop:
</span><span>    </span><span>mov </span><span>dx</span><span>, </span><span>si</span><span> ; if we exit the loop in this iteration, dx will point to the first letter
</span><span>               ; of the word
</span><span>    </span><span>lodsb
</span><span>    </span><span>cmp </span><span>al</span><span>, </span><span>&#34; &#34;
</span><span>    </span><span>je </span><span>short .skiploop
</span></code></pre>
<p>Note the way the pointer to the beginning of the string is saved. The loop will
go one byte past the whitespace, so storing it after the loop would require a
separate decrement. Instead, we update the register with each iteration of the
loop, but before the pointer is incremented by <code>lodsb</code>.</p>
<p>At this point, the <code>AL</code> register is loaded with the first character of the word.
Thus our next loop will need to do <code>lodsb</code> at its <em>end</em>.</p>
<pre data-lang="asm"><code data-lang="asm"><span>    </span><span>xor </span><span>cx</span><span>, </span><span>cx
</span><span>    </span><span>xor </span><span>bx</span><span>, </span><span>bx
</span><span>.takeloop:
</span><span>    </span><span>and </span><span>al</span><span>, </span><span>~</span><span>0x20
</span><span>    </span><span>jz </span><span>short Return</span><span> ; jump to a borrowed `ret` from some other routine
</span></code></pre>
<p>This <code>and</code> instruction is interesting, as it does three things at once. It
detects both spaces and null bytes in one fell swoop, but also also turns off
the bit that differs between uppercase and lowercase letters, which allows
handling both cases of hexadecimal numbers at no extra cost.</p>
<p>If we haven&#39;t detected the end of the word, we increment the length counter
and convert the digit to its numeric value:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    </span><span>inc </span><span>cx
</span><span>    </span><span>sub </span><span>al</span><span>, </span><span>&#34;0&#34; </span><span>&amp;~</span><span>0x20
</span><span>    </span><span>cmp </span><span>al</span><span>, </span><span>9
</span><span>    </span><span>jbe </span><span>.digit_ok
</span><span>    </span><span>sub </span><span>al</span><span>, </span><span>&#34;A&#34; </span><span>- </span><span>(</span><span>&#34;0&#34; </span><span>&amp;~</span><span>0x20</span><span>) </span><span>- </span><span>10
</span><span>.digit_ok
</span><span>    </span><span>cbw
</span></code></pre>
<p><code>cbw</code> is a little-known instruction that converts a signed number from <code>b</code>yte to
<code>w</code>ord, but for us it&#39;s just a shorter <code>mov ah, 0</code>. In a perhaps similar vein,
we use the signed multiply <code>imul</code>, because it has more options for how it uses
the registers than the unsigned <code>mul</code>. The specific form used here allows
multiplying by an immediate and doesn&#39;t overwrite <code>DX</code> with the upper half of
the product.</p>
<p>This particular instruction needs to be encoded manually to force the literal
width to be 2 bytes wide.</p>
<pre data-lang="asm"><code data-lang="asm"><span>    ; imul bx, bx, &lt;BASE&gt; but yasm insists on encoding the immediate in just one byte...
</span><span>    </span><span>db </span><span>0x69</span><span>, </span><span>0xdb
</span><span>BASE </span><span>equ </span><span>$
</span><span>    </span><span>dw </span><span>16
</span><span>    </span><span>add </span><span>bx</span><span>, </span><span>ax</span><span> ; add the new digit
</span></code></pre>
<p>Finally, we set up for the next iteration of the loop. We use a similar trick as
before, where a pointer result is updated in each iteration to avoid a separate
decrement at the end — we need to make sure that the input pointer doesn&#39;t point
after the terminator.</p>
<pre data-lang="asm"><code data-lang="asm"><span>    </span><span>mov </span><span>[</span><span>InputPtr</span><span>], </span><span>si
</span><span>    </span><span>lodsb
</span><span>    </span><span>jmp </span><span>short .takeloop
</span></code></pre>
</section><section><h3 id="dictionary-lookup">Dictionary Lookup</h3>
<p>After a word is parsed, we try to look it up in the dictionary. For each entry,
we need to compare the length of the name, and if it matches, the name itself.
By including <code>F_HIDDEN</code> in the mask, we automatically handle hidden entries,
too. The way we&#39;re comparing the length might look a bit weird. The goal is to
keep the <code>F_IMMEDIATE</code> bit in AL, so that we don&#39;t have to keep around the
pointer to the header of this word. This is one of Ilya Kurdyukov&#39;s clever
optimizations.</p>
<pre data-lang="asm"><code data-lang="asm"><span>InterpreterLoop:
</span><span>    </span><span>call </span><span>ParseWord
</span><span>    jcxz short ReadLine
</span><span>
</span><span>; Try to find the word in the dictionary.
</span><span>; SI = dictionary pointer
</span><span>; DX = string pointer
</span><span>; CX = string length
</span><span>; Take care to preserve BX, which holds the numeric value.
</span><span>LATEST </span><span>equ </span><span>$</span><span>+</span><span>1
</span><span>    </span><span>mov </span><span>si</span><span>, </span><span>0
</span><span>.find:
</span><span>    </span><span>lodsw
</span><span>    </span><span>push </span><span>ax</span><span> ; save pointer to next entry
</span><span>    </span><span>lodsb
</span><span>    </span><span>xor </span><span>al</span><span>, </span><span>cl</span><span> ; if the length matches, then AL contains only the flags
</span><span>    </span><span>test </span><span>al</span><span>, </span><span>F_HIDDEN | F_LENMASK
</span><span>    </span><span>jnz </span><span>short .next
</span><span>
</span><span>    </span><span>mov </span><span>di</span><span>, </span><span>dx
</span><span>    </span><span>push </span><span>cx
</span><span>    </span><span>repe </span><span>cmpsb
</span><span>    </span><span>pop </span><span>cx
</span><span>    </span><span>je </span><span>short .found
</span><span>.next:
</span><span>    </span><span>pop </span><span>si
</span><span>    </span><span>or </span><span>si</span><span>, </span><span>si
</span><span>    </span><span>jnz </span><span>short .find
</span><span>
</span><span>    ; If we reach this point, it&#39;s a number.
</span><span>    ; ...
</span><span>
</span><span>.found:
</span><span>    </span><span>pop </span><span>bx</span><span> ; discard pointer to next entry
</span><span>    ; When we get here, SI points to the code of the word, and AL contains
</span><span>    ; the F_IMMEDIATE flag
</span></code></pre>
<p>This part shows another advantage of not splitting the interpreter into reusable
chunks — we can easily exit into two different codepaths, based on the result of
the lookup.</p>
</section><section><h3 id="should-we-execute-it">Should we execute it?</h3>
<p>The system can be in two possible states:</p>
<ul>
<li>interpreting — all words should be executed</li>
<li>compiling — immediate words should be executed</li>
</ul>
<p>In other words, a word should be executed if it is immediate, or we&#39;re
interpreting. We store this flag in the immediate field of an <code>or</code> instruction —
it will be set to 0 when compiling:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    ; When we get here, SI points to the code of the word, and AL contains
</span><span>    ; the F_IMMEDIATE flag
</span><span>STATE </span><span>equ </span><span>$</span><span>+</span><span>1
</span><span>    </span><span>or </span><span>al</span><span>, </span><span>1
</span><span>    </span><span>xchg </span><span>ax</span><span>, </span><span>si</span><span> ; both codepaths need the pointer to be in AX
</span><span>    </span><span>jz </span><span>short .compile
</span><span>
</span><span>    ; Execute the word
</span><span>    ; ...
</span></code></pre>
<p>The most important words that need to change the state are <code>:</code> and <code>;</code>, but they
just jump to <code>[</code> and <code>]</code> — words that allow to temporarily drop back to
interpreted mode while compiling a word. The typical usecase is to eagerly
calculate the value of a constant expression:</p>
<pre data-lang="forth"><code data-lang="forth"><span>: </span><span>third-foo </span><span>[ </span><span>foos </span><span>3 </span><span>cells </span><span>+ </span><span>] literal </span><span>@ </span><span>;
</span></code></pre>
<p>Since the two values of <code>STATE</code> differ only by 1, we can switch between them
with <code>inc</code> and <code>dec</code>. This has the disadvantage that they are no longer
idempotent, but this shouldn&#39;t matter to well-written code:</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode LBRACK</span><span>, </span><span>&#34;[&#34;</span><span>, </span><span>F_IMMEDIATE
</span><span>    </span><span>inc </span><span>byte</span><span>[</span><span>STATE</span><span>]
</span><span>
</span><span>defcode RBRACK</span><span>, </span><span>&#34;]&#34;
</span><span>    </span><span>dec </span><span>byte</span><span>[</span><span>STATE</span><span>]
</span></code></pre>
</section><section><h3 id="executing-the-word">Executing the word</h3>
<p>If we decided to execute the word, we retrieve <code>BX</code> and <code>DI</code>, and set up <code>SI</code>
so that <code>NEXT</code> will jump back to <code>.executed</code>:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    ; Execute the word
</span><span>RetSP </span><span>equ </span><span>$</span><span>+</span><span>1
</span><span>    </span><span>mov </span><span>di</span><span>, </span><span>RS0
</span><span>    </span><span>pop </span><span>bx
</span><span>    </span><span>mov </span><span>si</span><span>, </span><span>.return
</span><span>    </span><span>jmp </span><span>ax
</span><span>.return:
</span><span>    </span><span>dw </span><span>.executed
</span><span>.executed:
</span><span>    </span><span>mov </span><span>[</span><span>RetSP</span><span>], </span><span>di
</span><span>    </span><span>push </span><span>bx
</span><span>    </span><span>jmp </span><span>short InterpreterLoop
</span></code></pre>
</section><section><h3 id="handling-numbers">Handling numbers</h3>
<p>There is no <code>F_IMMEDIATE</code> flag for numbers, so we just need to check the state
to decide.  It&#39;s a simple comparison, but if we&#39;re clever enough, you can save a
byte here. Let&#39;s look again at the code that searches the dictionary. What value
will <code>AH</code> have when we reach the number case?</p>
<pre data-lang="asm"><code data-lang="asm"><span>.find:
</span><span>    </span><span>lodsw
</span><span>    </span><span>push </span><span>ax</span><span> ; save pointer to next entry
</span><span>    </span><span>lodsb
</span><span>    </span><span>xor </span><span>al</span><span>, </span><span>cl</span><span> ; if the length matches, then AL contains only the flags
</span><span>    </span><span>test </span><span>al</span><span>, </span><span>F_HIDDEN | F_LENMASK
</span><span>    </span><span>jnz </span><span>short .next
</span><span>
</span><span>    </span><span>mov </span><span>di</span><span>, </span><span>dx
</span><span>    </span><span>push </span><span>cx
</span><span>    </span><span>repe </span><span>cmpsb
</span><span>    </span><span>pop </span><span>cx
</span><span>    </span><span>je </span><span>short .found
</span><span>.next:
</span><span>    </span><span>pop </span><span>si
</span><span>    </span><span>or </span><span>si</span><span>, </span><span>si
</span><span>    </span><span>jnz </span><span>short .find
</span><span>
</span><span>    ; AH = ?
</span></code></pre>
<p>Do you see it? At this point, AH is zero, since it contains the higher half of the pointer
to the next word, which we know is NULL, as we just got to the end of the list.
This allows us to check the value of <code>STATE</code> without loading it into a register
or any immediate bytes:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    ; It&#39;s a number. Push its value - we&#39;ll pop it later if it turns out we need to compile
</span><span>    ; it instead.
</span><span>    </span><span>push </span><span>bx
</span><span>    </span><span>cmp </span><span>byte</span><span>[</span><span>STATE</span><span>], </span><span>ah
</span><span>    </span><span>jnz </span><span>short InterpreterLoop
</span><span>    ; Otherwise, compile the literal.
</span><span>    ; ...
</span></code></pre>
</section><section><h3 id="compiling-things">Compiling things</h3>
<p>The output pointer for the compilation process is called <code>HERE</code>. It starts out
just after the decompressed data. The function that writes out a word into this
area is called <code>COMMA</code>, since the Forth word that does this is <code>,</code>.</p>
<pre data-lang="asm"><code data-lang="asm"><span>COMMA:
</span><span>HERE </span><span>equ </span><span>$</span><span>+</span><span>1
</span><span>    </span><span>mov </span><span>[</span><span>CompressedEnd</span><span>], </span><span>ax
</span><span>    </span><span>add </span><span>word</span><span>[</span><span>HERE</span><span>], </span><span>2
</span><span>    </span><span>ret
</span></code></pre>
<p>It is used in a straight-forward way to compile both numbers and words. We can
share the tail, though — compiling a word will jump into the middle of compiling
a number:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    ; Otherwise, compile the literal.
</span><span>    </span><span>mov </span><span>ax</span><span>, </span><span>LIT
</span><span>    </span><span>call </span><span>COMMA
</span><span>    </span><span>pop </span><span>ax
</span><span>.compile:
</span><span>    </span><span>call </span><span>COMMA
</span><span>    </span><span>jmp </span><span>short InterpreterLoop
</span></code></pre>
<p>The last piece of the puzzle are <code>:</code> and <code>;</code>. Let&#39;s look at <code>:</code> first. Since
<code>ParseWord</code> makes use of <code>BX</code> and <code>SI</code>, we need to save these registers.
Moreover, since we&#39;re writing the many parts of a dictionary header, we&#39;ll load
<code>HERE</code> to <code>DI</code> to streamline things. This is a lot of registers that we need to
push. However, we don&#39;t actually need to modify any register, so we can just
save <em>all</em> the registers with <code>pusha</code>.</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode COLON</span><span>, </span><span>&#34;:&#34;
</span><span>    </span><span>pusha
</span><span>    </span><span>mov </span><span>di</span><span>, [</span><span>HERE</span><span>]
</span><span>    </span><span>call </span><span>MakeLink</span><span>    ; link field
</span><span>    </span><span>call </span><span>ParseWord
</span><span>    </span><span>mov </span><span>ax</span><span>, </span><span>cx
</span><span>    </span><span>stosb</span><span>            ; length field
</span><span>    </span><span>mov </span><span>si</span><span>, </span><span>dx
</span><span>    </span><span>rep movsb</span><span>        ; name field
</span><span>
</span><span>    </span><span>mov </span><span>al</span><span>, </span><span>0xe8</span><span>     ; call
</span><span>    </span><span>stosb
</span><span>    ; The offset is defined as (call target) - (ip after the call instruction)
</span><span>    ; That works out to DOCOL - (di + 2) = DOCOL - 2 - di
</span><span>    </span><span>mov </span><span>ax</span><span>, </span><span>DOCOL </span><span>- </span><span>2
</span><span>    </span><span>sub </span><span>ax</span><span>, </span><span>di
</span><span>    </span><span>stosw
</span><span>    </span><span>mov </span><span>[</span><span>HERE</span><span>], </span><span>di
</span><span>    </span><span>popa
</span><span>    </span><span>jmp </span><span>short RBRACK</span><span> ; enter compilation mode
</span></code></pre>
<p><code>;</code> is much shorter. We merely need to compile <code>EXIT</code> and go back to
interpretation mode:</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode SEMI</span><span>, </span><span>&#34;;&#34;</span><span>, </span><span>F_IMMEDIATE
</span><span>    </span><span>mov </span><span>ax</span><span>, </span><span>EXIT
</span><span>    </span><span>call </span><span>COMMA
</span><span>    </span><span>jmp </span><span>short LBRACK
</span></code></pre>
<p>The way these words jump to another word at the end is quite convenient.
Remember how the <code>NEXT</code>s are written out as part of the <code>defcode</code> of the next
word? One of the words needs to be last in memory, and then it won&#39;t have any
&#34;next word&#34; after it. <code>:</code> and <code>;</code> are perfect candidates for this, since they
don&#39;t need a <code>NEXT</code> at all.</p>
</section><section><h2 id="loading-code-from-disk">Loading code from disk</h2>
<p>Since we don&#39;t want to type in disk routines on every boot, we need to include
a way to run source code loaded from disk. A filesystem would be its own beast,
but Forth tradition has a minimalistic solution: the disk is simply divided
into 1 KiB blocks, in which source code is stored, formatted as 16 lines of 64
characters. Then <code>load ( blknum -- )</code> will execute the block with the specified
number.</p>
<p>We map block 0 into LBA 0 and 1, block 1 into LBA 2 and 3, and so on. This does
mean that block 0 is partially taken by the MBR and LBA 1 is wasted, but I&#39;m not
particularily bothered by that.</p>
<p>Since the original BIOS service at <code>int 0x13 / ah = 0x02</code> requires CHS
addressing, I decided to use the EDD extension variant (<code>ah = 0x42</code>). This does
mean that floppies are not supported, but I wasn&#39;t planning on using any anyway.</p>
<p>To use the EDD interface, we need to build a <em>disk address packet</em>, which looks
like this:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    </span><span>db </span><span>0x10</span><span> ; size of packet
</span><span>    </span><span>db </span><span>0</span><span>    ; reserved
</span><span>    </span><span>dw </span><span>sector_count
</span><span>    </span><span>dw </span><span>buffer_offset</span><span>, </span><span>buffer_segment
</span><span>    </span><span>dq </span><span>LBA
</span></code></pre>
<p>We use a hybrid strategy to create this packet. The first part is kept as data
in the bootsector, but the rest is written at runtime, even if it doesn&#39;t
change. The &#34;template&#34; needs to be in a place where we can write after it, so
the perfect place is just before the compressed data:</p>
<pre data-lang="asm"><code data-lang="asm"><span>DiskPacket:
</span><span>    </span><span>db </span><span>0x10</span><span>, </span><span>0
</span><span>.count:
</span><span>    </span><span>dw </span><span>2
</span><span>.buffer:
</span><span>    ; rest is filled out at runtime, overwriting the compressed data,
</span><span>    ; which isn&#39;t necessary anymore
</span><span>
</span><span>CompressedData:
</span><span>    </span><span>times </span><span>COMPRESSED_SIZE </span><span>db </span><span>0xcc
</span></code></pre>
<p>The first four bytes of the packet are random enough to be hardcoded. However,
when it comes to the address of the buffer, we can do better. We will need to
write said address to <code>InputPtr</code> anyway. The most direct way to do that takes
six bytes:</p>
<pre data-lang="lst"><code data-lang="lst"><span>c706020a0006    </span><span>mov </span><span>word</span><span>[</span><span>InputPtr</span><span>], </span><span>BlockBuf
</span></code></pre>
<p>However, we can get that value in <code>AX</code> at no extra cost:</p>
<pre data-lang="lst"><code data-lang="lst"><span>b80006          </span><span>mov </span><span>ax</span><span>, </span><span>BlockBuf
</span><span>a3020a          </span><span>mov </span><span>[</span><span>InputPtr</span><span>], </span><span>ax
</span></code></pre>
<p>Thus, we can write these two bytes of the disk packet with only 1 byte of code:</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode LOAD</span><span>, </span><span>&#34;load&#34;
</span><span>    </span><span>pusha
</span><span>    </span><span>mov </span><span>di</span><span>, </span><span>DiskPacket.buffer
</span><span>    </span><span>mov </span><span>ax</span><span>, </span><span>BlockBuf
</span><span>    </span><span>mov </span><span>word</span><span>[</span><span>InputPtr</span><span>], </span><span>ax
</span><span>    </span><span>stosw
</span></code></pre>
<p>Next, we need to write the segment (<code>0000</code>) and the LBA (which ends in six <code>00</code>
bytes). I like to think of the instructions corresponding to these like so:</p>
<pre data-lang="asm"><code data-lang="asm"><span>31c0    </span><span>xor </span><span>ax</span><span>, </span><span>ax</span><span>    ; LBA zeroes
</span><span>ab      </span><span>stosw</span><span>         ; segment
</span><span>d1e3    </span><span>shl </span><span>bx</span><span>, </span><span>1</span><span>     ; LBA data
</span><span>93      </span><span>xchg </span><span>ax</span><span>, </span><span>bx</span><span>   ; LBA data
</span><span>ab      </span><span>stosw</span><span>         ; LBA data
</span><span>93      </span><span>xchg </span><span>ax</span><span>, </span><span>bx</span><span>   ; segment
</span><span>ab      </span><span>stosw</span><span>         ; LBA zeroes
</span><span>ab      </span><span>stosw</span><span>         ; LBA zeroes
</span><span>ab      </span><span>stosw</span><span>         ; LBA zeroes
</span></code></pre>
<p>That is, we write the six LBA zeroes in 5 bytes of code. Writing out the segment
only took moving the <code>xor ax, ax</code> earlier, and an additional <code>stosw</code> and <code>xchg ax, bx</code>. Thus, it is neutral at 2 bytes (but we need to write it out in code so
that the pointer is right for the rest of the packet). Lastly, of course, we
have the actual LBA data, which changes.</p>
<p>While <code>AX</code> is zero, let&#39;s take this opportunity to poke in a null terminator
after the buffer:</p>
<pre data-lang="asm"><code data-lang="asm"><span>    </span><span>mov </span><span>[</span><span>BlockBuf.end</span><span>], </span><span>al
</span></code></pre>
<p>Now we&#39;re ready to call the BIOS function. If it errors out, we just loop, as
recovering is complicated — the most annoying complication is that the sector
count in the packet is overwritten by the number of sectors <em>successfully read</em>,
which breaks our template.</p>
<pre data-lang="asm"><code data-lang="asm"><span>DRIVE_NUMBER </span><span>equ </span><span>$</span><span>+</span><span>1
</span><span>    </span><span>mov </span><span>dl</span><span>, </span><span>0
</span><span>    </span><span>mov </span><span>ah</span><span>, </span><span>0x42
</span><span>    </span><span>mov </span><span>si</span><span>, </span><span>DiskPacket
</span><span>    </span><span>int </span><span>0x13
</span><span>    </span><span>jc </span><span>short $
</span><span>    </span><span>popa
</span><span>    </span><span>pop </span><span>bx
</span></code></pre>
</section><section><h2 id="printing-numbers">Printing numbers</h2>
<p><code>u.</code> prints an unsigned number, followed by a space. Since splitting the number
into digits with division yields the least-significant digit first, we push the
digits onto the stack, and then pop and print in a separate loop. The space is
printed by pushing a fake &#34;digit&#34; that will get converted into a space. This
also lets us detect when we popped all the digits — the printing loop stops when
it just printed a space.</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode UDOT</span><span>, </span><span>&#34;u.&#34;
</span><span>    </span><span>xchg </span><span>ax</span><span>, </span><span>bx
</span><span>    </span><span>push </span><span>&#34; &#34; </span><span>- </span><span>&#34;0&#34;
</span><span>.split:
</span><span>    </span><span>xor </span><span>dx</span><span>, </span><span>dx
</span><span>    </span><span>div </span><span>word</span><span>[</span><span>BASE</span><span>]
</span><span>    </span><span>push </span><span>dx
</span><span>    </span><span>or </span><span>ax</span><span>, </span><span>ax
</span><span>    </span><span>jnz </span><span>.split
</span><span>.print:
</span><span>    </span><span>pop </span><span>ax
</span><span>    </span><span>add </span><span>al</span><span>, </span><span>&#34;0&#34;
</span><span>    </span><span>cmp </span><span>al</span><span>, </span><span>&#34;9&#34;
</span><span>    </span><span>jbe </span><span>.got_digit
</span><span>    </span><span>add </span><span>al</span><span>, </span><span>&#34;A&#34; </span><span>- </span><span>&#34;0&#34; </span><span>- </span><span>10
</span><span>.got_digit:
</span><span>    </span><span>call </span><span>PutChar
</span><span>    </span><span>cmp </span><span>al</span><span>, </span><span>&#34; &#34;
</span><span>    </span><span>jne </span><span>short .print
</span><span>    </span><span>pop </span><span>bx
</span></code></pre>
</section><section><h2 id="s-string-poke"><code>s:</code> — string poke</h2>
<p><code>s:</code> is a feature which is, I believe, uniquely relevant to bootstrapping. This
word takes the address of a buffer, and copies the rest of the current input
line there. Without this, a significant amount of code would&#39;ve had to be typed
in twice: first to actually run it and bootstrap a disk block editor, and then
again to actually save it on disk.</p>
<p>The implementation is just a simple loop, but the setup around it is noteworthy
— we want to load the input pointer into <code>SI</code>, but we also need to preserve <code>SI</code>
so that we can return properly. By using <code>xchg</code>, we can preserve it in
<code>[InputPtr]</code> for the duration of the copy, at no extra cost:</p>
<pre data-lang="asm"><code data-lang="asm"><span>;; Copies the rest of the line to buf.
</span><span>defcode LINE</span><span>, </span><span>&#34;s:&#34;</span><span> ; ( buf -- buf+len )
</span><span>    </span><span>xchg </span><span>si</span><span>, [</span><span>InputPtr</span><span>]
</span><span>.copy:
</span><span>    </span><span>lodsb
</span><span>    </span><span>mov </span><span>[</span><span>bx</span><span>], </span><span>al
</span><span>    </span><span>inc </span><span>bx
</span><span>    </span><span>or </span><span>al</span><span>, </span><span>al
</span><span>    </span><span>jnz </span><span>short .copy
</span><span>.done:
</span><span>    </span><span>dec </span><span>bx
</span><span>    </span><span>dec </span><span>si
</span><span>    </span><span>xchg </span><span>si</span><span>, [</span><span>InputPtr</span><span>]
</span></code></pre>
<p>The destination pointer is kept in <code>BX</code>. While writing at <code>DI</code> would only take a
<code>stosb</code>, getting the pointer in and out of <code>DI</code> outweights this benefit. At the
end, we leave a pointer to the null terminator on the stack. That way, you can
continue the string by just using <code>s:</code> again on the next line. Since we don&#39;t
skip any leading whitespace, this is even guaranteed to be properly spaced.</p>
</section><section><h2 id="other-primitives">Other primitives</h2>
<p>Choosing the primitives to include in Miniforth is perhaps the biggest tradeoff
to be made. I am fully expecting that some more primitive words will need to be
defined at runtime by poking in opcodes. After all, there aren&#39;t any branching
words. However, I&#39;m pretty certain that these opcodes will be able to be
generated by a simple Forth assembler, rather than simply hardcoded.</p>
<p>Arithmetic as basic as <code>+</code> is indispensible. I am defining both <code>+</code> and <code>-</code>,
though, if I wanted to fit in something more important, I could keep only <code>-</code>
and later define <code>: negate 0 swap - ;</code> and <code>: + negate - ;</code>.</p>
<p>Like any low-level programming language, we need a way to peek and poke values
into memory. The implementation of <code>!</code> is particularily nice, since we can just
pop directly into <code>[bx]</code>:</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode PEEK</span><span>, </span><span>&#34;@&#34;</span><span> ; ( addr -- val )
</span><span>    </span><span>mov </span><span>bx</span><span>, [</span><span>bx</span><span>]
</span><span>
</span><span>defcode POKE</span><span>, </span><span>&#34;!&#34;</span><span> ; ( val addr -- )
</span><span>    </span><span>pop </span><span>word </span><span>[</span><span>bx</span><span>]
</span><span>    </span><span>pop </span><span>bx
</span></code></pre>
<p>There also are variants that read and write only a single byte:</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode CPEEK</span><span>, </span><span>&#34;c@&#34;</span><span> ; ( addr -- ch )
</span><span>    </span><span>movzx </span><span>bx</span><span>, </span><span>byte</span><span>[</span><span>bx</span><span>]
</span><span>
</span><span>defcode CPOKE</span><span>, </span><span>&#34;c!&#34;</span><span> ; ( ch addr -- )
</span><span>    </span><span>pop </span><span>ax
</span><span>    </span><span>mov </span><span>[</span><span>bx</span><span>], </span><span>al
</span><span>    </span><span>pop </span><span>bx
</span></code></pre>
<p>We certainly need some stack manipulation words. <code>dup</code> and <code>drop</code> have
dead simple implementations, and <code>swap</code> is definitely too useful to skip it.</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode DUP</span><span>, </span><span>&#34;dup&#34;</span><span> ; ( a -- a a )
</span><span>    </span><span>push </span><span>bx
</span><span>
</span><span>defcode DROP</span><span>, </span><span>&#34;drop&#34;</span><span> ; ( a -- )
</span><span>    </span><span>pop </span><span>bx
</span><span>
</span><span>defcode SWAP</span><span>, </span><span>&#34;swap&#34;</span><span> ; ( a b -- b a )
</span><span>    </span><span>pop </span><span>ax
</span><span>    </span><span>push </span><span>bx
</span><span>    </span><span>xchg </span><span>ax</span><span>, </span><span>bx
</span></code></pre>
<p>I chose to also include <code>&gt;r</code> and <code>r&gt;</code>, which allow using the return stack as
a second stack for values (but, obviously, only within a single word). This is
quite powerful. In fact, combined with <code>dup</code>, <code>drop</code> and <code>swap</code>, they allow you
to implement any stack manipulation word you can imagine.</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode TO_R</span><span>, </span><span>&#34;&gt;r&#34;
</span><span>    </span><span>xchg </span><span>ax</span><span>, </span><span>bx
</span><span>    </span><span>stosw
</span><span>    </span><span>pop </span><span>bx
</span><span>
</span><span>defcode FROM_R</span><span>, </span><span>&#34;r&gt;&#34;
</span><span>    </span><span>dec </span><span>di
</span><span>    </span><span>dec </span><span>di
</span><span>    </span><span>push </span><span>bx
</span><span>    </span><span>mov </span><span>bx</span><span>, [</span><span>di</span><span>]
</span></code></pre>
<p>Finally, <code>emit</code> prints a character. This is far enough from the critical path
of the bootstrap, that I would be comfortable with removing this one if need be.</p>
<pre data-lang="asm"><code data-lang="asm"><span>defcode EMIT</span><span>, </span><span>&#34;emit&#34;
</span><span>    </span><span>xchg </span><span>bx</span><span>, </span><span>ax
</span><span>    </span><span>call </span><span>PutChar
</span><span>    </span><span>pop </span><span>bx
</span></code></pre>
</section><section><h2 id="conclusion">Conclusion</h2>
<p>I am pleased with how this turned out. For a system constrained to the boot
sector, I can pretty much call it feature-complete — I can&#39;t think of anything
that would significantly simplify the bootstrap, while taking few enough bytes
that it seems remotely within the reach of code golf. This is largely thanks to
Ilya Kurdyukov&#39;s help — without it, I wouldn&#39;t have been able to fit <code>s:</code> in.</p>
<p>I&#39;ve found an old PC I can use for my experiments. It boots Miniforth just fine,
so I&#39;ll be using it from now on.</p>
<p><img src="https://compilercrim.es/bootstrap/miniforth/hardware.jpg" alt="A photo of the corner of a monitor. We see the calculation &#34;6969 4242 100 + + u-dot&#34;, which results in &#34;ACAB&#34;. Then the &#34;1 load&#34; command is issued, to which the system describes &#34;Hello, world!&#34;"/></p>
<p>If you&#39;d like to see how to bootstrap on top of Miniforth&#39;s minimal set of
primitives, see the <a href="https://compilercrim.es/bootstrap/branches/">next post in this series</a>.</p>

<hr/>











</section>











                <center>
                    <p>
                        Fedi: <a href="https://donotsta.re/mei">@mei@donotsta.re</a>
                        •
                        GitHub: <a href="https://github.com/meithecatte">@meithecatte</a>
                        •
                        E-mail: catch-all on this domain
                    </p>

                    <a href="https://diyhrt.wiki">
                        <img src="https://compilercrim.es/e2.gif" width="88" height="31"/>
                    </a>
                </center>
            </article></div>
  </body>
</html>
