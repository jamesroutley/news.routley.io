<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/git-no-forge/">Original</a>
    <h1>Git without a forge</h1>
    
    <div id="readability-page-1" class="page">
    
    <p>[Simon Tatham, 2025-03-05]</p>
    <ul>
      <li>
        <a href="#intro">Introduction</a>
        <ul>
          <li>
            <a href="#purpose">Purposes of this article</a>
          </li>
        </ul>
      </li>
      <li>
        <a href="#submissions">How to interact with a bare git repo</a>
        <ul>
          <li>
            <a href="#preferences">What do I prefer in particular?</a>
            <ul>
              <li>
                <a href="#url">BEST: URL of a git repository + branch name</a>
              </li>
              <li>
                <a href="#bundle">An incremental git bundle</a>
              </li>
              <li>
                <a href="#format-patch">A set of patch files from <code>git
        format-patch</code></a>
              </li>
              <li>
                <a href="#diff">A bare diff file generated by <code>git diff</code></a>
              </li>
              <li>
                <a href="#send-email">WORST: A series of separate emails generated
        by <code>git send-email</code></a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <a href="#why-not">Why don’t I use a git forge?</a>
        <ul>
          <li>
            <a href="#trust">Trust</a>
          </li>
          <li>
            <a href="#heavy">Heavyweight</a>
          </li>
          <li>
            <a href="#accounts">Account management</a>
          </li>
          <li>
            <a href="#workflow">You get a workflow imposed on you</a>
          </li>
          <li>
            <a href="#inertia">Plain old inertia</a>
          </li>
          <li>
            <a href="#github">Special mention: especially not Github</a>
          </li>
        </ul>
      </li>
      <li>
        <a href="#why-so">Should I start using a git forge instead?</a>
      </li>
    </ul>
    <h2 id="intro">Introduction</h2>
    <p>I’ve written quite a lot of free software in my life. Most of
      it was from scratch: projects I started myself. So I get to
      choose where to host them – or rather, I <em>have</em> to choose
      where to host them.</p>
    <p>These days, all my projects are held in Git. And mostly, I put
      them in ‘bare’ git repositories on my personal website.</p>
    <p>I don’t use any git ‘forge’ system layered on top of Git, like
      Gitlab or Github, which automatically makes a bug tracking
      database for each project, and provides a convenient button for
      a user to open a merge request / pull request. I just use plain
      Git. People can ‘<code>git clone</code>’ my code, and there’s a
      web-based browsing interface (the basic <code>gitweb</code>) for
      looking around without having to clone it at all. But that’s all
      the automated facilities you get.</p>
    <p>Occasionally this confuses people, so I thought I should write
      something about it.</p>
    <h3 id="purpose">Purposes of this article</h3>
    <p>Sometimes people just can’t work out how to send me patches at
      all. Or they can think of several ways, and aren’t sure which is
      best. So one purpose of this article is to be a public statement
      of my own preferences, which I can link to when people ask that
      question.</p>
    <p>But it’s also a bit of a musing about <em>why</em> I don’t use
      a ‘forge’ style system like Gitlab or Github. People sometimes
      ask me that too – “why don’t you do what everyone else does?” or
      words to that effect.</p>
    <h2 id="submissions">How to interact with a bare git repo</h2>
    <p>People who are used to git forges look for a ‘pull request’
      button. When they don’t find it, they sometimes get confused.</p>
    <p>If you can’t find a button on a website to submit a patch, how
      do you send your patch to the maintainer?</p>
    <p>You send the author an email. And in the email, you put one of
      these things:</p>
    <ol>
      <li>A URL to your own clone of the repository, containing your
        patches on top of the ‘upstream’ code.</li>
      <li>The actual patches, in some form of email attachment.</li>
    </ol>
    <p>Either of these works. For option 2 there are multiple ways to
      do it in detail, and all of <em>those</em> work too.</p>
    <p>It doesn’t have to be by email, either. Any method of sending
      this data to the maintainer is fine. For example, I’m on
      Mastodon – so you could send me a repository URL via Mastodon if
      you really wanted to (provided you didn’t mind my responses
      being very short). Or you could send patches via any other
      communications medium that you and the maintainer are both on,
      if it lets you attach files to messages.</p>
    <h3 id="preferences">What do I prefer in particular?</h3>
    <p>But some people don’t just want to know <em>any</em> way to
      send patches. They want to know which is the <em>best</em> way,
      or at least the way I prefer.</p>
    <p>So here’s my own list, in descending order: most preferred at
      the top, least at the bottom.</p>
    <h4 id="url">BEST: URL of a git repository + branch name</h4>
    <p>This is my <em>absolute</em> favourite way to receive patches.
      If there’s anywhere on the Internet you can put a clone of my
      git repository with some extra patches, then the best thing is
      to do that, and send me an email saying something like</p>
    <blockquote>
      <p>I have some patches to [project] to [make some change]. You
        can find them in the branch called [whatever] here: [URL]</p>
    </blockquote>
    <p>The URL can be anything that’s convenient, as long as it’s
      either something I can give to <code>git clone</code>, or a
      human-readable web page <em>containing</em> something I can give
      to <code>git clone</code>. It can be anything from a git forge
      page (just because <em>I</em> don’t host my code on Github
      doesn’t mean you can’t put your patched version there for me to
      look at) to a static site where you’ve uploaded a repository and
      run <code>git update-server-info</code>.</p>
    <p>When you get right down to it, this is exactly what the
      formalised ‘pull request’ or ‘merge request’ in a git forge
      system <em>is</em>. That’s why you start by forking (i.e.
      cloning) the target repository and put your changes in a branch
      of your fork. A PR communicates to the maintainer: “Hey, see
      this repo over here, this branch in particular? It has changes
      I’d like you to take.” The formal PR button in a forge is a way
      to do that with one click, but a short email with all the same
      information is just as good.</p>
    <p><em>Why I like it</em>: This is my favourite way to receive
      patches because the patches themselves don’t go through my
      email. This saves space for me in the long term (I keep all my
      email), and it saves me messing about with moving attachments
      around (I read email on a different machine from the one I
      develop on). All I need is to paste the URL from the email into
      my git command line, and bing, I’ve got the patches in a form I
      can look at, review, and maybe merge.</p>
    <p>Also, if I make review comments and you want to update the
      patches, it saves space <em>again</em> if you don’t have to send
      a full set of updated patch files, but instead, push a modified
      version of your branch and just send another email saying</p>
    <blockquote>
      <p>OK, I’ve addressed those review comments. New patches are in
        the same place as before.</p>
    </blockquote>
    <h4 id="bundle">An incremental git bundle</h4>
    <p>Git bundles don’t seem to be very widely known. I think that’s
      a shame, because they’re awesome.</p>
    <p>The simplest kind of git bundle – a <em>full</em> bundle – is a
      whole git repository, wrapped up into a single file. It contains
      a collection of git objects, plus a collection of references
      (typically branch heads). You can access it by any of the same
      methods you’d use to access an actual git remote, by passing its
      filename to <code>git fetch</code> or <code>git pull</code>, or
      maybe start with <code>git ls-remote</code> to see what branches
      are in the bundle file and decide which one to fetch. The only
      thing you can’t usefully do is modify it. If you want a git
      bundle to contain something different, you just make a fresh one
      from scratch.</p>
    <p>But a bundle can also be <em>incremental</em>, which means that
      some objects are missing, because it expects the bundle
      recipient to have those objects already. This is just what you
      want when you’re sending patches against an existing repository:
      you know the recipient has all the objects you got from the
      original repo, and you only have to send the new objects.</p>
    <p>So, suppose you’ve prepared a series of commits (or just one
      commit) against the <code>main</code> branch of one of my
      repositories. Then you can do something like this:</p>
    <pre>git bundle create fix-weasel-rotator.bundle origin/main..HEAD</pre>
    <p>That will create a file called
      ‘<code>fix-weasel-rotator.bundle</code>’ (example name only!)
      which contains all the extra commits you’ve made on top
      of <code>origin/main</code> (my upstream branch). Now you can
      send that file as an attachment.</p>
    <p><em>Why I like it</em>: If I’m going to receive patches as
      email attachments at all, this is my favourite way to do it, for
      lots of reasons.</p>
    <p>Firstly, it’s <em>one</em> file, no matter how many patches you
      put in it. That means I can download it in one go to my
      development machine and not have to herd a whole collection of
      smaller files.</p>
    <p>Secondly, git bundles are <em>small</em>: significantly smaller
      than the corresponding textual patch files. (They use the same
      compression as git’s packed object format.)</p>
    <p>Thirdly, git bundles are <em>binary</em>: the compression turns
      them into completely impenetrable binary nonsense. That
      doesn’t <em>sound</em> like a good thing, but it does give email
      clients the best chance of transferring them completely
      unchanged, without trying to be clever (character set
      conversion, ‘helpfully’ rewrapping long lines).</p>
    <p>Perhaps most importantly, the commits in a git bundle are
      described in full detail: I can see what base commit you
      prepared them against, because they come with their parent
      links. So if I need to reapply the patches against a different
      parent, I know what parent I’m starting from, and what’s changed
      since then. This helps me to rebase the patches correctly. So
      does the fact that with the patches already in the form of git
      commits, I can use <code>git rebase</code> in the first place,
      and get its really nice conflict handling (better than <code>git
      am</code>).</p>
    <h4 id="format-patch">A set of patch files from <code>git
        format-patch</code></h4>
    <p>This is the most popular option people actually seem to choose:
      run ‘<code>git format-patch</code>’ to produce a sequence of
      textual patch files, one per commit, with names starting with
      0001, 0002, 0003, … so that the recipient can see what order
      they go in. Then send that lot as a pile of separate email
      attachments, or (rarely) in some single container like a zip
      file.</p>
    <p>I don’t think this is quite as nice as a git bundle, for a
      couple of reasons:</p>
    <p><em>Multiple files to herd</em>. When I get an email with five
      patch attachments, I have five files to copy around instead of
      one, with long awkward names.</p>
    <p><em>Text is vulnerable</em>. Because the patches are text
      files, there’s at least <em>some</em> chance that an MUA did
      something ‘helpful’ (not actually helpful) to them in transit.</p>
    <p><em>Harder to handle conflicts</em>. The <code>git am</code>
      command, which applies patches in this format, doesn’t handle
      conflicts in the way I most prefer, by applying the parts of the
      patch that worked and leaving in-file conflict markers at the
      places where something went wrong. Also, because <code>git
      format-patch</code> doesn’t mention what commit the
      patches <em>do</em> apply against, I’m more likely to encounter
      a conflict in the first place when trying to apply them.</p>
    <p>So, for all those reasons, I prefer a single binary git bundle
      citing its parent commit to a handful of text patch files. But
      these disadvantages don’t <em>normally</em> cause problems:
      the <code>format-patch</code> approach normally works well
      enough, and if it’s what a sender is happy with, I won’t spend
      any time trying to persuade them to do things differently.</p>
    <h4 id="diff">A bare diff file generated by <code>git diff</code></h4>
    <p>Plain <code>git diff</code> has all the same disadvantages
      of <code>git format-patch</code>, plus one extra downside: it
      doesn’t include the commit metadata: authorship and commit
      message.</p>
    <p>If you send me a plain <code>git diff</code>, I have to write
      the commit message myself. That either means understanding your
      patch well enough to know what your
      <em>intentions</em> were (maybe not the same as what you
      actually did!), or copying text out of the email you sent along
      with the patch.</p>
    <p>My <a href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/commit-messages/#cover">general advice</a> when
      submitting patches by email is that if you have an explanation
      of why the patch is desirable, or safe, or both, it’s better to
      put it in the commit message, so that it’s preserved for later
      people reading the git history. So you might as well put it
      there in the first place, and then I don’t have to move it!</p>
    <h4 id="send-email">WORST: A series of separate emails generated
        by <code>git send-email</code></h4>
    <p>Ugh, please, no. I really dislike receiving <code>git
      send-email</code> output. If you can <em>possibly</em> do it
      any other way, please do.</p>
    <p><em>Why I don’t like it</em>: because the patch series is split
      into multiple emails, they arrive in my inbox in a random order,
      and then I have to save them one by one to files, and manually
      sort those files back into the right order by their subject
      lines.</p>
    <p>With <code>git format-patch</code>, the files arrive as
      attachments to the same email, so I can save them all in one go,
      and then their names make it easy to sort them. <code>git
      send-email</code> has neither advantage.</p>
    <h2 id="why-not">Why don’t I use a git forge?</h2>
    <p>I promised I’d also talk about why I make this choice. Most
      people these days like git forges: why don’t I?</p>
    <h3 id="trust">Trust</h3>
    <p>For me, the first question in deciding where to host my code is
      not what facilities it provides, but who runs it. I want my code
      not to be at the mercy of people I don’t trust.</p>
    <p>I don’t mean that I have any especial <em>dis</em>trust of the
      organisations in charge of major Git forge websites. But I don’t
      know them personally, and I prefer to put my trust in people I
      do. So my git hosting arrangements live on a server run by a
      friend, instead of a server run by a company.</p>
    <p>Is that excessive paranoia on my part? I don’t think so.</p>
    <p>Perhaps it would be, if all my projects were low-stakes – not
      handling important secrets, and with very few users, so that
      they weren’t an attractive target for anyone to attack. But I
      maintain a security project, and also some of my stuff has
      become pretty popular. Even something completely frivolous like
      a videogame can be an attractive target if it’s installed on a
      lot of machines.</p>
    <p>Admittedly, this was a more serious concern before Git: the
      nature of Git’s commit hashing system is that it’s very
      difficult to quietly change the content of a repository to
      something malicious, without everyone who already had a clone of
      it noticing. In the Subversion days it was much easier to
      quietly hack a repository’s contents if you had admin access.</p>
    <p>But ‘difficult’ isn’t <em>impossible</em>, so it still seems
      worth taking some care.</p>
    <p>Trusting a company is also dangerous because management
      changes: even if you trust the people in charge <em>now</em>,
      they may not be in charge next year, and the people who are may
      be completely different. The same facilities that attract users
      to Github now would have attracted people to Sourceforge a
      couple of decades ago – and Sourceforge now has a pretty bad
      reputation.</p>
    <h3 id="heavy">Heavyweight</h3>
    <p>Of course, using a well-known forge <em>website</em> and using
      forge <em>software</em> aren’t the same thing. If I don’t want
      to host my code on <code>gitlab.com</code>, I could still
      arrange to run my own instance of the Gitlab <em>software</em>
      somewhere under my own control, and use that.</p>
    <p>From everything I’ve heard, that’s a lot more effort than
      hosting a plain git repository. I don’t think the overall
      convenience gain is worth the large amount of effort it would
      cost me to run a thing like that. It would take away from time
      I’d rather be spending on the actual code.</p>
    <h3 id="accounts">Account management</h3>
    <p>A particular thing I don’t like about git forge websites is the
      way they make you create an account.</p>
    <p>Even to <em>report a bug</em> against someone else’s project –
      let alone send a patch – if it’s hosted in some Gitlab instance
      I haven’t used before, I have to make an account on that
      instance, because until I do that, I can’t interact with the
      system at all. And it’s not <em>just</em> instances I haven’t
      used before: at least some Gitlab instances will delete old
      accounts, so that even if <em>have</em> interacted with a
      project before, when I find another bug in the same software
      years later I might still have to make a fresh account.</p>
    <p>Making accounts is a <em>bad thing</em>. Every one of them is
      an extra thing to track in your password manager; some kind of
      2FA setup if the site insists on it; periodic need to spend
      effort on it (like if the site notifies you that they’ve had a
      compromise and you need to reconfirm something); an outright
      risk (like if a <em>scammer</em> pretending to be the site sends
      you a fraudulent notification of that kind); an extra facet of
      your online identity to keep track of. Each one is individually
      small, but they add up, and managing a ton of accounts is
      annoying. I don’t enjoy having to do that myself, and I don’t
      want to inflict it on other people!</p>
    <h3 id="workflow">You get a workflow imposed on you</h3>
    <p>Git forge websites come with a bunch of stuff beyond the plain
      git repository. That’s their whole point.</p>
    <p>In particular, your project automatically gets a bug tracker –
      and you don’t get a choice about what bug tracker to use, or
      what it looks like. If you use Gitlab, you’re using the Gitlab
      bug tracker. The same goes for the pull request / merge request
      system.</p>
    <p>When I started using Git, PuTTY already <em>had</em> a bug
      tracker. A pretty simple one – not much more than a set of text
      files and a script that turns them into a set of web pages – but
      it’s there, and it integrates with our source control and
      releases and website in ways we’re familiar with. Throw it away
      in favour of a thing tied to the hosting system which doesn’t
      behave the way we carefully chose? No thanks.</p>
    <p>More generally, I don’t want that kind of decision about my
      development workflows to be a consequence of some unrelated
      thing like what version control I’m using. I want to
      decide <em>first</em> how to handle patches and bug reports, and
      then decide what software will best serve those needs – not the
      other way round.</p>
    <h3 id="inertia">Plain old inertia</h3>
    <p>I wouldn’t want anyone to think I was <em>concealing</em> this
      reason, or deluding myself that it wasn’t part of my
      motivations, so I should make sure to say it out loud.</p>
    <p>One reason I don’t use a forge is simply because I
      didn’t <em>start out</em> using a forge, and moving all my stuff
      into one would be effort. I’ve been providing public source
      repositories since before Git was a thing, and before forges
      themselves were a thing. (OK, not <em>quite</em> before the
      pre-Git Sourceforge was actually founded, but before it was well
      known.) Before Git, my stuff was hosted in SVN on a particular
      Linux box; when I moved my stuff from SVN to Git, the path of
      changing as little as possible was to host it in Git on the same
      Linux box.</p>
    <p>Of course, that’s not a good reason by itself. And that’s all
      right – it’s not my <em>only</em> reason. But I can’t deny that
      it’s <em>one</em> of my reasons. Change is effort, and ought to
      give enough benefit to be worth the effort.</p>
    <h3 id="github">Special mention: especially not Github</h3>
    <p>For all these reasons, I don’t really want to use <em>any</em>
      git forge. But I <em>particularly</em> don’t want to use
      Github.</p>
    <p>The biggest reason is that it’s not itself free software. If
      you want to take back control of your project by moving it to
      another instance of the same system (perhaps even setting up
      your own), you can do that with Gitlab – migrating all your bug
      records along with the git repository – but not with Github.
      You’re locked in.</p>
    <p>Also, I might as well come out and say this: one reason I don’t
      want to use Github is <em>because</em> it’s the most popular
      place to host your code. It’s almost never healthy to have a
      monoculture of <em>anything</em>, and a monoculture controlled
      by a single company is particularly dangerous. I’d rather
      contribute to the Internet being distributed than contribute to
      it being centralised.</p>
    <p>(I get particularly annoyed when people demand I move to Github
      for this reason. “Everyone is on Github, get with the programme!
      Conform!” I’m actually less likely to do it <em>because</em> you
      said that. Ugh.)</p>
    <p>Of course, these days Github is owned by Microsoft, and there
      are plenty of people who don’t 100% trust Microsoft. I can’t
      claim to be completely immune to that, but I <em>already</em>
      didn’t want to use Github before it was bought, so that’s not my
      only reason. Not even my main reason.</p>
    <h2 id="why-so">Should I start using a git forge instead?</h2>
    <p>Sometimes I get email from people who would prefer me to start
      doing things the ‘normal’ way. It’s not <em>always</em> just
      because my way isn’t what they’re already used to. Some of them
      have more interesting and thoughtful reasons.</p>
    <p>The most interesting comment I’ve had along these lines is that
      a forge puts all your interactions with contributors out in the
      open. If someone is considering contributing to your code base,
      they can look at past MRs / PRs and see what happened: whether
      there seems to be an active community at all, whether the
      developer(s) respond to contributions in good time, whether the
      reviews seem constructive, whether there’s any obnoxious or
      toxic behaviour going on. And then maybe decide not to waste
      their time on that project at all, if it doesn’t look
      welcoming or helpful.</p>
    <p>With my approach, where each discussion of a contribution
      happens in private email, it is true that the process of making
      a contribution is a lot less public. I could be amazingly rude
      to one contributor, and none of the others would necessarily
      find out about it (unless the hypothetical victim ranted about
      it on their blog, or something). I could take ages to get round
      to doing anything (for any reason – laziness or overloading or
      anything in between). I could lie to each contributor about what
      other contributors were doing (although I can’t think of any
      reason it would even be in my own interest to!)</p>
    <p>So I accept that there are downsides of doing it my way, as
      well as upsides. Forges aren’t a complete waste of time. I just
      haven’t yet been convinced that the advantages of a forge
      outweigh the disadvantages.</p>
    <p>But I’d be more interested in thoughts about how to get the
      best of both worlds. If there were a system for allowing
      contributions and their review and discussion to happen in
      public, using software much more lightweight and easier to run
      than Gitlab, which allowed contribution without requiring anyone
      to create and manage yet another account, with an extremely
      configurable form of workflow management (if any), and having a
      hard separation between the discussion-forum layer and the
      actual git repository so that a compromise wouldn’t allow
      injecting malware into the target project, I’d be interested in
      giving it a look!</p>
    <p>(Of course, just occasionally a contribution <em>does</em> have
      to happen via private communication, e.g. because it’s a fix for
      a not-yet-public security issue. I certainly wouldn’t want
      to <em>stop</em> people from contributing privately, if it was
      necessary, or just if that was what they preferred.)</p>
  

</div>
  </body>
</html>
