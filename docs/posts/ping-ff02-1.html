<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://astrid.tech/2024/05/28/0/ping-ff02-1/">Original</a>
    <h1>Ping Ff02:1</h1>
    
    <div id="readability-page-1" class="page"><div><main><article><header><p>repairing misconfigured hosts using link-local IPv6 addresses and ad-hoc networking</p><p><span title="created: 2024-05-28 03:42
published: 2024-05-28 04:10"><time datetime="2024-05-28 04:10">2024-05-28 04:10</time></span></p><p><span><a href="https://astrid.tech/t/networking">networking</a> <a href="https://astrid.tech/t/ipv6">ipv6</a> <a href="https://astrid.tech/t/linux">Linux</a> </span></p></header><p><strong>TL;DR:</strong> Link local addresses are great and can be used for lots of things,
like:</p>
<ul>
<li>finding and connecting to hosts that didn’t get an address via DHCP</li>
<li>transferring files directly between two computers via Ethernet with almost no
extra configuration</li>
</ul>
<p>To enumerate every IPv6-supporting device on your LAN, even if the device isn’t
DHCP’d or SLAAC’d correctly, you can run a command like this:</p>
<pre lang="sh"><code><span>ping</span><span> ff02::1%$</span><span>interface
</span></code></pre>
<p>For example:</p>
<pre><code><span>% ping ff02::1%enp4s0
</span><span>PING ff02::1%enp4s0(ff02::1%enp4s0) 56 data bytes
</span><span>64 bytes from fe80::54a4:74f4:3735:33ad%enp4s0: icmp_seq=1 ttl=64 time=0.023 ms
</span><span>64 bytes from fe80::da9d:67ff:fe26:463f%enp4s0: icmp_seq=1 ttl=64 time=0.243 ms
</span><span>64 bytes from fe80::28c7:cb09:9bf6:1062%enp4s0: icmp_seq=1 ttl=64 time=0.293 ms
</span><span>64 bytes from fe80::a02:8eff:fe9e:cf67%enp4s0: icmp_seq=1 ttl=64 time=0.796 ms
</span><span>64 bytes from fe80::5054:ff:fed6:96c%enp4s0: icmp_seq=1 ttl=64 time=0.888 ms
</span><span>64 bytes from fe80::768e:f8ff:feed:b700%enp4s0: icmp_seq=1 ttl=64 time=3.45 ms
</span><span>^C
</span><span>--- ff02::1%enp4s0 ping statistics ---
</span><span>1 packets transmitted, 1 received, +5 duplicates, 0% packet loss, time 0ms
</span><span>rtt min/avg/max/mdev = 0.023/0.949/3.453/1.160 ms
</span></code></pre>
<p>Some applications, like modern web browsers, don’t support the <code>%$interface</code>
syntax, because they are made by stupid people. However, you can still work
around it with socat, like so in the case of TCP:</p>
<pre lang="sh"><code><span>socat</span><span> TCP6-LISTEN:$</span><span>LOCAL_PORT_TO_FORWARD</span><span>,fork &#34;</span><span>TCP6:[</span><span>$</span><span>LINK_LOCAL_IPV6</span><span>%</span><span>$</span><span>YOUR_INTERFACE_NAME</span><span>]:</span><span>$</span><span>REMOTE_TCP_PORT</span><span>&#34;
</span></code></pre>
<p>Examples:</p>
<pre lang="sh"><code><span>socat</span><span> TCP6-LISTEN:8000,fork &#34;</span><span>TCP6:[fe80::dead:beef%enowhatever]:80</span><span>&#34;
</span><span>firefox</span><span> http://localhost:8000
</span></code></pre>
<pre lang="sh"><code><span>socat</span><span> TCP6-LISTEN:8000,fork &#34;</span><span>TCP6:[fe80::dead:beef%enowhatever]:443</span><span>&#34;
</span><span>firefox</span><span> https://localhost:8000
</span></code></pre>
<p>The rest of the article will dive deeper into IPv6 link-local and multicast
addresses, and demonstrate a way to transfer files to your friend’s computer
with directly-attached ethernet with absolutely no prior configuration besides
IPv6.</p>
<h2><a href="#link-local-addresses" aria-hidden="true" id="header-link-local-addresses"></a>Link local addresses</h2>
<p>In IPv6, every device almost always has at least one address on every interface
it has – the
<strong><a href="https://en.wikipedia.org/wiki/Link-local_address#IPv6">link-local address</a></strong>.
Technically, the block <code>fe80::/10</code> is reserved for link-local addresses, but in
practice, only <code>fe80::/64</code> is really used.</p>
<p>Computers almost always assign themselves a link-local address when they set up
the network interface, unlike in IPv4, where computers <em>rarely</em> do
this. Sometimes, the address is based on the MAC address, sometimes
it’s completely random, sometimes you can even statically assign yourself a
link-local address!</p>
<p>You can see your link-local address on a modern Linux computer if you type in
<code>ip address</code> or any of its various aliases:</p>
<pre>% ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host noprefixroute
       valid_lft forever preferred_lft forever
2: enp4s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether a8:a1:59:d6:b1:67 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.102/24 brd 192.168.1.255 scope global dynamic noprefixroute enp4s0
       valid_lft 6292sec preferred_lft 6292sec

    &lt;snip&gt;

    <b>inet6 fe80::54a4:74f4:3735:33ad/64 scope link noprefixroute</b>
       valid_lft forever preferred_lft forever
</pre>
<p>It’s marked as <code>scope link</code>, indicating it’s a link local address. Even if you
already have a DHCP IPv4 address, or a SLAAC-assigned IPv6 address, you probably
still have a link-local IPv6 most of the time.</p>
<p>Let’s try pinging it from another host on the subnet.</p>
<pre><code><span>% ping fe80::54a4:74f4:3735:33ad
</span><span>ping: Warning: IPv6 link-local address on ICMP datagram socket may require ifname or scope-id =&gt; use: address%&lt;ifname|scope-id&gt;
</span><span>PING fe80::54a4:74f4:3735:33ad(fe80::54a4:74f4:3735:33ad) 56 data bytes
</span><span>^C
</span><span>--- fe80::54a4:74f4:3735:33ad ping statistics ---
</span><span>8 packets transmitted, 0 received, 100% packet loss, time 7167ms
</span></code></pre>
<p>Uh oh, it didn’t work. Why not?</p>
<p>The problem is that link-local addresses are meant to be restricted to a
specific link. One <code>fe80::whatever</code> on one link won’t be the same on another
link, and these addresses are to never cross router boundaries, either. So,
that’s why link-local addresses must be associated with an interface.</p>
<p>As <code>ping</code> suggests, you can instead try <code>address%&lt;ifname|scope-id&gt;</code>, like so:</p>
<pre><code><span>% ping fe80::54a4:74f4:3735:33ad%eno1
</span><span>PING fe80::54a4:74f4:3735:33ad%eno1(fe80::54a4:74f4:3735:33ad%eno1) 56 data bytes
</span><span>64 bytes from fe80::54a4:74f4:3735:33ad%eno1: icmp_seq=1 ttl=64 time=0.182 ms
</span><span>64 bytes from fe80::54a4:74f4:3735:33ad%eno1: icmp_seq=2 ttl=64 time=0.203 ms
</span><span>64 bytes from fe80::54a4:74f4:3735:33ad%eno1: icmp_seq=3 ttl=64 time=0.178 ms
</span><span>64 bytes from fe80::54a4:74f4:3735:33ad%eno1: icmp_seq=4 ttl=64 time=0.214 ms
</span><span>^C
</span><span>--- fe80::54a4:74f4:3735:33ad%eno1 ping statistics ---
</span><span>4 packets transmitted, 4 received, 0% packet loss, time 3052ms
</span><span>rtt min/avg/max/mdev = 0.178/0.194/0.214/0.014 ms
</span></code></pre>
<p>The value after the <code>%</code> is called the <strong>zone index</strong>.</p>
<p>Besides ping, most network applications do support link-local addresses:</p>
<pre lang="sh"><code><span>ssh</span><span> fe80::da9d:67ff:fe26:463f%</span><span>enp4s0
</span></code></pre>
<pre lang="sh"><code><span>scp</span><span> ./a.out &#39;</span><span>[fe80::da9d:67ff:fe26:463f%enp4s0]:~</span><span>&#39;
</span></code></pre>
<pre lang="sh"><code><span>rsync</span><span> ./a.out &#39;</span><span>[fe80::da9d:67ff:fe26:463f%enp4s0]:~</span><span>&#39;
</span></code></pre>
<pre lang="sh"><code><span>nc</span><span> fe80::da9d:67ff:fe26:463f%</span><span>enp4s0</span><span> 80
</span></code></pre>
<pre lang="sh"><code><span>curl </span><span>&#39;</span><span>http://[fe80::da9d:67ff:fe26:463f%enp4s0]</span><span>&#39;
</span></code></pre>
<p>However, some applications do <em>not</em> support link-local addresses. In fact,
<a href="https://stackoverflow.com/a/46881540">most web browsers explicitly do not support this</a>,
which is a damn shame, especially if you have to access an admin page. However,
there is a workaround – more on that later.</p>
<p>Link-local addresses themselves are not that useful. The way they are
auto-configured, and the way you can scan for them, <em>is</em>.</p>
<h2><a href="#easily-finding-other-link-local-addresses-on-your-subnet" aria-hidden="true" id="header-easily-finding-other-link-local-addresses-on-your-subnet"></a>Easily finding other link-local addresses on your subnet</h2>
<p>Suppose you have a server or Raspberry Pi or whatever, you can’t connect a
monitor to, and you’ve fucked up the network configuration and it’s not getting
an IP address from DHCP. Or maybe your server has an out-of-band management page
that isn’t DHCPing.</p>
<p>Out of luck, right? Nope!</p>
<p>If it supports IPv6, it probably assigned itself a link-local address. The only
question now is, which of the <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span><span>64</span></span></span></span></span></span></span></span></span></span></span></span>

 addresses in <code>fe80::/64</code> did it give
itself?</p>
<p>Thankfully, link-local multicast addresses are here to save the
day! Simply run:</p>
<pre lang="sh"><code><span>ping</span><span> ff02::1%$</span><span>YOUR_INTERFACE_NAME
</span></code></pre>
<p>and that will send a ping to every link-local address on your subnet. And then,
every host will reply:</p>
<pre><code><span>% ping ff02::1%enp4s0
</span><span>PING ff02::1%enp4s0(ff02::1%enp4s0) 56 data bytes
</span><span>64 bytes from fe80::54a4:74f4:3735:33ad%enp4s0: icmp_seq=1 ttl=64 time=0.023 ms
</span><span>64 bytes from fe80::da9d:67ff:fe26:463f%enp4s0: icmp_seq=1 ttl=64 time=0.243 ms
</span><span>64 bytes from fe80::28c7:cb09:9bf6:1062%enp4s0: icmp_seq=1 ttl=64 time=0.293 ms
</span><span>64 bytes from fe80::a02:8eff:fe9e:cf67%enp4s0: icmp_seq=1 ttl=64 time=0.796 ms
</span><span>64 bytes from fe80::5054:ff:fed6:96c%enp4s0: icmp_seq=1 ttl=64 time=0.888 ms
</span><span>64 bytes from fe80::768e:f8ff:feed:b700%enp4s0: icmp_seq=1 ttl=64 time=3.45 ms
</span><span>^C
</span><span>--- ff02::1%enp4s0 ping statistics ---
</span><span>1 packets transmitted, 1 received, +5 duplicates, 0% packet loss, time 0ms
</span><span>rtt min/avg/max/mdev = 0.023/0.949/3.453/1.160 ms
</span></code></pre>
<p>Now you can sort through them and determine which host is which.</p>
<p>You don’t even need to have an ethernet switch between the two machines! I’ve
even saved a friend’s Raspberry Pi just by directly connecting its ethernet port
directly into my computer, pinging <code>ff02::1</code> to find the link-local IP it gave
itself, and SSHing into the discovered IP.</p>
<figure><picture><a href="https://s3.us-west-000.backblazeb2.com/nyaabucket/f12beedd22dda999dd4c895bd70936a9544e194276f49d9625f90f505c795304/pi-rescue-reenactment.jpg"><img src="https://s3.us-west-000.backblazeb2.com/nyaabucket/f12beedd22dda999dd4c895bd70936a9544e194276f49d9625f90f505c795304/pi-rescue-reenactment.jpg" alt="Two plush sharks staring intently at a surface pro. The surface pro has an ethernet dongle connected directly into a raspberry pi."/></a></picture><figcaption>A reenactment of the raspberry pi rescue.</figcaption></figure>

<h2><a href="#workaround-for-web-browsers-not-supporting-link-local-addresses" aria-hidden="true" id="header-workaround-for-web-browsers-not-supporting-link-local-addresses"></a>Workaround for web browsers not supporting link-local addresses</h2>
<p>Let’s say I’ve determined that <code>fe80::5054:ff:fed6:96c%enp4s0</code> is a router with
an admin page. Technically, URLs actually do support this syntax, you just need
to escape the <code>%</code> as a <code>%25</code>, like so:
<a href="http://%5Bfe80::5054:ff:fed6:96c%25enp4s0%5D">http://[fe80::5054:ff:fed6:96c%25enp4s0]</a></p>
<p>However, if you’re using a modern web browser, this is most likely completely
unsupported. Try clicking on it. I’m quite sure that it won’t work for you.
Firefox simply refuses to take me to it, and Chrome sends me to
<code>about:blank#blocked</code>.</p>
<p>As a workaround, you can forward the port with a socat command like this:</p>
<pre lang="sh"><code><span>socat</span><span> TCP6-LISTEN:8000,fork &#34;</span><span>TCP6:[fe80::5054:ff:fed6:96c%enp4s0]:443</span><span>&#34;
</span></code></pre>
<p>Explanation of arguments:</p>
<ul>
<li><code>TCP6-LISTEN:8000,fork</code> - listen on TCP/IPv6 port 8000. when you see a new
connection, fork a process to handle it and keep listening.</li>
<li><code>TCP6:[fe80::5054:ff:fed6:96c%enp4s0]:443</code> - after you’ve got a connection on
port <code>8000</code>, open a connection to <code>[fe80::5054:ff:fed6:96c%enp4s0]:443</code>, and
forward data to it.</li>
</ul>
<p>Once you have that running in the background, you can go to
<a href="https://localhost:8000">https://localhost:8000</a> and look at your beautiful admin page.</p>
<h2><a href="#sending-files-over-an-ethernet-cable-with-minimal-configuration" aria-hidden="true" id="header-sending-files-over-an-ethernet-cable-with-minimal-configuration"></a>Sending files over an ethernet cable with minimal configuration</h2>
<p>Tired of using USB sticks to transfer files between laptops? Connect your two
computers directly like this:</p>
<figure><picture><a href="https://s3.us-west-000.backblazeb2.com/nyaabucket/df978c5ae673ed0748f9b3f0a4e412493e2a21f978b9a44785a00d4d379bff77/direct-ethernet-attachment.jpg"><img src="https://s3.us-west-000.backblazeb2.com/nyaabucket/df978c5ae673ed0748f9b3f0a4e412493e2a21f978b9a44785a00d4d379bff77/direct-ethernet-attachment.jpg" alt="My surface pro directly connected to my partner’s Thinkpad via ethernet cable and USB to ethernet adapter."/></a></picture><figcaption>yuri</figcaption></figure>

<p>You can determine the link-local IP by typing <code>ip a</code> on both computers and
manually typing 26 characters in… or you can be lazy, ping <code>ff02::1</code>, and
copy/paste:</p>
<pre><code><span>% ping ff02::1%enp0s20f0u1c2
</span><span>PING ff02::1%enp0s20f0u1c2(ff02::1%enp0s20f0u1c2) 56 data bytes
</span><span>64 bytes from fe80::8a40:4905:d926:861c%enp0s20f0u1c2: icmp_seq=1 ttl=64 time=0.112 ms
</span><span>64 bytes from fe80::29b8:771a:dd16:fb28%enp0s20f0u1c2: icmp_seq=1 ttl=64 time=1.60 ms  # this is the other computer, time was much longer
</span><span>^C
</span><span>--- ff02::1%enp0s20f0u1c2 ping statistics ---
</span><span>1 packets transmitted, 1 received, +1 duplicates, 0% packet loss, time 0ms
</span><span>rtt min/avg/max/mdev = 0.112/0.855/1.598/0.743 ms
</span><span>
</span><span>% rsync -rv my-silly-files/ [fe80::29b8:771a:dd16:fb28%enp0s20f0u1c2]:/wherever
</span></code></pre>
<h3><a href="#hang-on-i-didnt-set-up-any-infrastructure-up-how-can-i-do-this-help" aria-hidden="true" id="header-hang-on-i-didnt-set-up-any-infrastructure-up-how-can-i-do-this-help"></a>hang on i didn’t set up any infrastructure up how can i do this help</h3>
<p>What if you don’t have SSH perms on the other machine because it’s your friend’s
machine, and you have a device-local firewall blocking any attempts at running
<code>nc -l</code>, and you’re too lazy to set up a firewall allow rule?</p>
<p>Well, you can do a little “TCP hole-punching” trick using netcat. Simultaneously
on both computers, run the following command to perform a TCP simultaneous-open:</p>
<pre lang="sh"><code><span>nc</span><span> -v </span><span>$</span><span>IP</span><span>%$</span><span>INTERFACE </span><span>$</span><span>PORT -p </span><span>$</span><span>PORT
</span></code></pre>
<p>where:</p>
<ul>
<li><code>$IP</code> is the other machine’s IP</li>
<li><code>$INTERFACE</code> is the interface you’re using</li>
<li><code>$PORT</code> is agreed upon between BOTH OF YOU. List it
TWICE. <code>-p</code> tells netcat to use that specific source
port.</li>
<li>The <code>-v</code> is useful because it will tell you how successfull it was.</li>
</ul>
<p>Example:</p>
<pre><code><span>astrid@shai-hulud% nc -v fe80::29b8:771a:dd16:fb28%enp0s20f0u1c2 10000 -p 10000
</span><span>Connection to fe80::29b8:771a:dd16:fb28%enp0s20f0u1c2 10000 port [tcp/ndmp] succeeded!
</span></code></pre>
<pre><code><span>alia@stargazer% nc -v fe80::8a40:4905:d926:861c%enp0s31f6 10000 -p 10000
</span><span>Connection to fe80::8a40:4905:d926:861c%enp0s31f6 10000 port [tcp/ndmp] succeeded!
</span></code></pre>
<p>And congratulations, you now have a shitty version of IRC running over that
ethernet cable.</p>
<p>If you want to transfer files, just pipe them in on the source:</p>
<pre lang="sh"><code><span>nc</span><span> -v </span><span>$</span><span>IP</span><span>%$</span><span>INTERFACE </span><span>$</span><span>PORT -p </span><span>$</span><span>PORT </span><span>&lt; ./my-silly-file
</span></code></pre>
<p>and pipe them out on the destination:</p>
<pre lang="sh"><code><span>nc</span><span> -v </span><span>$</span><span>IP</span><span>%$</span><span>INTERFACE </span><span>$</span><span>PORT -p </span><span>$</span><span>PORT </span><span>&gt; ./my-silly-file
</span></code></pre>
<p>If you have multiple files, you can <code>tar</code> them. If you want to go faster, you
could <code>gzip</code> them. The possibilities are endless.</p>
<h2><a href="#conclusion" aria-hidden="true" id="header-conclusion"></a>Conclusion</h2>
<p>ipv6 gives you lots of cool auto-configured goodies</p>
<h2><a href="#appendix-hang-on-isnt-ff021-basically-just-a-broadcast" aria-hidden="true" id="header-appendix-hang-on-isnt-ff021-basically-just-a-broadcast"></a>Appendix: hang on, isn’t <code>ff02::1</code> basically just a broadcast?</h2>
<p>In general, IPv6 multicast requires usage of
<a href="https://en.wikipedia.org/wiki/Multicast_Listener_Discovery">Multicast Listener Discovery (MLD)</a>
– essentially, hosts ask the router to subscribe to a multicast address, so we
can minimize the number of packets we transmit. But <code>ff02::1</code> is special – it
does <em>not</em> need MLD or any kind of subscription to work.</p>
<p>So what distinguishes it from a broadcast?</p>
<p>Here’s Wireshark’s dissection of that ICMP request to <code>ff02::1</code> from earlier:</p>
<pre>Frame 449: 118 bytes on wire (944 bits), 118 bytes captured (944 bits) on interface enp4s0, id 0
Ethernet II, Src: ASRockIn_d6:b1:67 (a8:a1:59:d6:b1:67), Dst: IPv6mcast_01 (33:33:00:00:00:01)
    Destination: IPv6mcast_01 (33:33:00:00:00:01)
        Address: IPv6mcast_01 (33:33:00:00:00:01)
        .... ..1. .... .... .... .... = LG bit: Locally administered address (this is NOT the factory default)
        <b>.... ...1 .... .... .... .... = IG bit: Group address (multicast/broadcast)</b>
    Source: ASRockIn_d6:b1:67 (a8:a1:59:d6:b1:67)
        Address: ASRockIn_d6:b1:67 (a8:a1:59:d6:b1:67)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Type: IPv6 (0x86dd)
Internet Protocol Version 6, Src: fe80::54a4:74f4:3735:33ad, Dst: ff02::1
    0110 .... = Version: 6
    .... 0000 0000 .... .... .... .... .... = Traffic Class: 0x00 (DSCP: CS0, ECN: Not-ECT)
    .... 0010 0000 0011 0111 0011 = Flow Label: 0x20373
    Payload Length: 64
    Next Header: ICMPv6 (58)
    Hop Limit: 1
    Source Address: fe80::54a4:74f4:3735:33ad
    Destination Address: ff02::1
Internet Control Message Protocol v6
    Type: Echo (ping) request (128)
    Code: 0
    Checksum: 0x7e2a [correct]
    [Checksum Status: Good]
    Identifier: 0x0001
    Sequence: 1
    Data (56 bytes)
</pre>
<p>This is sent to the MAC address <code>33:33:00:00:00:01</code>. Where the hell does that
come from?
<a href="https://datatracker.ietf.org/doc/html/rfc2464#section-7">IETF RFC 2464 §7</a>,
which specifies how to map multicast IPv6’s into multicast MAC addresses:</p>
<blockquote>
<p>An IPv6 packet with a multicast destination address DST, consisting of the
sixteen octets DST[1] through DST[16], is transmitted to the Ethernet
multicast address whose first two octets are the value 3333 hexadecimal and
whose last four octets are the last four octets of DST.</p>
<pre><code><span>                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>                |0 0 1 1 0 0 1 1|0 0 1 1 0 0 1 1|
</span><span>                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>                |   DST[13]     |   DST[14]     |
</span><span>                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>                |   DST[15]     |   DST[16]     |
</span><span>                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></code></pre>
</blockquote>
<p>Further note the bolded Group Address bit from above. That specific bit being 1
signals to ethernet switches “hey, this needs to be sent to multiple hosts.”
It’s not just <code>ff:ff:ff:ff:ff:ff</code> that has this behavior, any MAC with the group
bit set will be treated like this.</p>
<p>According to
<a href="https://datatracker.ietf.org/doc/html/rfc4541#section-1">IETF RFC 4541 §1</a>,
most “dumb” switches will effectively treat any packet with that bit enabled,
multicast or broadcast, as a broadcast, and simply forward the packet to every
single device on the layer 2 network. Of course, this would suck if you are
using IPv6, because it takes advantage of multicast very heavily to reduce
congestion. IGMP snooping was introduced to have switches (layer 2 devices)
“snoop” on the IP headers above them (layer 3 data) and <em>not</em> forward
multicasted packets to devices that don’t care about it.</p>
<p>However, <a href="https://datatracker.ietf.org/doc/html/rfc4541#autoid-7">§3</a> recommends
that <code>ff02::1</code> specifically should be ignored for IGMP purposes and be treated
as simply a broadcast:</p>
<blockquote>
<p>In IPv6, the data forwarding rules are more straight forward because MLD is
mandated for addresses with scope 2 (link-scope) or greater. The only
exception is the address FF02::1 which is the all hosts link-scope address for
which MLD messages are never sent. Packets with the all hosts link-scope
address should be forwarded on all ports.</p>
</blockquote>
<p>So yes, even though it is <em>technically</em> a multicast, and it isn’t addressed to
<code>ff:ff:ff:ff:ff:ff</code>, it is <em>effectively</em> a broadcast in all but the most painful
of vendor hardware.</p>
<p>As for why they didn’t just send it to <code>ff:ff:ff:ff:ff:ff</code>, it’s probably to
keep consistent with RFC 2464. I would imagine that <code>33:33:00:00:00:01</code> would
<em>theoretically</em> be beneficial over <code>ff:ff:ff:ff:ff:ff</code> because switches could
simply not forward those to IPv4-only hosts. In practice, I don’t know how often
that’s used, or if it’s used at all.</p>
<p>The reply packet, however, is merely unicasted, and does not have to deal with
any of these technicalities.</p>
<pre>Frame 452: 118 bytes on wire (944 bits), 118 bytes captured (944 bits) on interface enp4s0, id 0
Ethernet II, Src: HewlettP_26:46:3f (d8:9d:67:26:46:3f), Dst: ASRockIn_d6:b1:67 (a8:a1:59:d6:b1:67)
    Destination: ASRockIn_d6:b1:67 (a8:a1:59:d6:b1:67)
        Address: ASRockIn_d6:b1:67 (a8:a1:59:d6:b1:67)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        <b>.... ...0 .... .... .... .... = IG bit: Individual address (unicast)</b>
    Source: HewlettP_26:46:3f (d8:9d:67:26:46:3f)
        Address: HewlettP_26:46:3f (d8:9d:67:26:46:3f)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Type: IPv6 (0x86dd)
Internet Protocol Version 6, Src: fe80::da9d:67ff:fe26:463f, Dst: fe80::54a4:74f4:3735:33ad
    0110 .... = Version: 6
    .... 0000 0000 .... .... .... .... .... = Traffic Class: 0x00 (DSCP: CS0, ECN: Not-ECT)
    .... 1001 1100 0000 0101 0001 = Flow Label: 0x9c051
    Payload Length: 64
    Next Header: ICMPv6 (58)
    Hop Limit: 64
    Source Address: fe80::da9d:67ff:fe26:463f
    Destination Address: fe80::54a4:74f4:3735:33ad
    [Source SLAAC MAC: HewlettP_26:46:3f (d8:9d:67:26:46:3f)]
Internet Control Message Protocol v6
    Type: Echo (ping) reply (129)
    Code: 0
    Checksum: 0xf6a9 [correct]
    [Checksum Status: Good]
    Identifier: 0x0001
    Sequence: 1
    Data (56 bytes)
</pre>
<p><strong>TL;DR:</strong> you can only call it a broadcast if it comes from the
<code>ff:ff:ff:ff:ff:ff</code> region of France, otherwise it’s just sparkling multicast</p>

</article></main></div></div>
  </body>
</html>
