<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jemma.dev/blog/irb-measure">Original</a>
    <h1>IRB&#39;s Built-In Measure (2021)</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>When reading <a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">the official Ruby 3.0 release post</a>, one bullet caught my eye especially. With Ruby 3.0, IRB introduced a <code>measure</code> command. As someone who often times little snippets when debugging, comparing code, or writing new code, I was intrigued! IRB’s new <code>measure</code> command is a quick and easy way to measure different snippets from an IRB console.</p>

<h2 id="toggling-measure">Toggling measure</h2>

<p>As the <a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">release notes</a> demonstrated, we can toggle measure on by using <code>measure</code> (or <code>measure :on</code>), and off by using <code>measure :off</code></p>

<div><div><pre><code><span>irb</span><span>(</span><span>main</span><span>)</span><span>&gt;</span> <span>measure</span>
<span>TIME</span> <span>is</span> <span>added</span>
<span>=&gt;</span> <span>nil</span>

<span>irb</span> <span>&gt;</span> <span>sleep</span> <span>1</span>
<span>processing</span> <span>time: </span><span>1.000649</span><span>s</span>
<span>=&gt;</span> <span>1</span>

<span>irb</span> <span>&gt;</span> <span>1</span>
<span>processing</span> <span>time: </span><span>0.000025</span><span>s</span>
<span>=&gt;</span> <span>1</span>

<span>irb</span> <span>&gt;</span> <span>measure</span> <span>:off</span>
<span>=&gt;</span> <span>nil</span>
</code></pre></div></div>

<p>By default, as we can see above, the IRB console will print out the processing time in seconds (the <code>time</code> measurement) for all commands when measure is toggled on.</p>

<h2 id="stackprof">Stackprof</h2>

<p>When I was reading the release notes, the message of <code>TIME is added</code> caught my eye because it implies that there are other ways we can measure code with this new command! It turns out measure comes with one more default mode: <a href="https://github.com/tmm1/stackprof">Stackprof</a>.</p>

<p>Stackprof (short for Stack Profiler) is a sampling call stack profiler for Ruby code. This means that it will take many samples while code is running of where in the stack the execution is happening, and be able to give us an estimate of how much time we are spending in each step of a call stack. We can toggle measuring Stackprof with <code>measure :stackprof</code>.</p>

<p>Before demonstrating Stackprof functionality, we’ll need a code snippet which does a little more than print out an integer to really see what’s happening. And ideally we’ll run it a few (or few thousand) times. Let’s celebrate the fact that it’s no longer 2020 (and that Ruby 3 also introduced endless method definition), and use this snippet:</p>

<div><div><pre><code><span>def</span> <span>snippet</span><span>()</span><span>=</span> <span>10_000</span><span>.</span><span>times</span> <span>{</span> <span>Date</span><span>.</span><span>parse</span><span>(</span><span>Date</span><span>.</span><span>today</span><span>.</span><span>to_s</span><span>).</span><span>year</span> <span>!=</span> <span>2020</span> <span>}</span>
</code></pre></div></div>

<p>Now, we can run the snippet with Stackprof and see the following output:</p>

<div><div><pre><code><span>irb</span> <span>&gt;</span> <span>measure</span> <span>:stackprof</span>
<span>STACKPROF</span> <span>is</span> <span>added</span><span>.</span>
<span>=</span><span>&gt;</span> <span>nil</span>

<span>irb</span> <span>&gt;</span> <span>snippet</span>
<span>==================================</span>
  <span>Mode</span><span>:</span> <span>cpu</span><span>(</span><span>1000</span><span>)</span>
  <span>Samples</span><span>:</span> <span>26</span> <span>(</span><span>0.00</span><span>%</span> <span>miss</span> <span>rate</span><span>)</span>
  <span>GC</span><span>:</span> <span>2</span> <span>(</span><span>7.69</span><span>%</span><span>)</span>
<span>==================================</span>
     <span>TOTAL</span>    <span>(</span><span>pct</span><span>)</span>     <span>SAMPLES</span>    <span>(</span><span>pct</span><span>)</span>     <span>FRAME</span>
        <span>11</span>  <span>(</span><span>42.3</span><span>%</span><span>)</span>          <span>11</span>  <span>(</span><span>42.3</span><span>%</span><span>)</span>     <span>Regexp</span><span>#match</span>
         <span>5</span>  <span>(</span><span>19.2</span><span>%</span><span>)</span>           <span>5</span>  <span>(</span><span>19.2</span><span>%</span><span>)</span>     <span>String</span><span>#gsub!</span>
         <span>4</span>  <span>(</span><span>15.4</span><span>%</span><span>)</span>           <span>4</span>  <span>(</span><span>15.4</span><span>%</span><span>)</span>     <span>Integer</span><span>#div</span>
         <span>2</span>   <span>(</span><span>7.7</span><span>%</span><span>)</span>           <span>2</span>   <span>(</span><span>7.7</span><span>%</span><span>)</span>     <span>MatchData</span><span>#begin</span>
         <span>2</span>   <span>(</span><span>7.7</span><span>%</span><span>)</span>           <span>2</span>   <span>(</span><span>7.7</span><span>%</span><span>)</span>     <span>(</span><span>sweeping</span><span>)</span>
         <span>1</span>   <span>(</span><span>3.8</span><span>%</span><span>)</span>           <span>1</span>   <span>(</span><span>3.8</span><span>%</span><span>)</span>     <span>Date</span><span>.</span><span>today</span>
         <span>1</span>   <span>(</span><span>3.8</span><span>%</span><span>)</span>           <span>1</span>   <span>(</span><span>3.8</span><span>%</span><span>)</span>     <span>Date</span><span>#to_s</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>IRB</span><span>::</span><span>WorkSpace</span><span>#evaluate</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>IRB</span><span>::</span><span>Irb</span><span>#eval_input</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>IRB</span><span>.</span><span>init_config</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>StackProf</span><span>.</span><span>run</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>IRB</span><span>::</span><span>Irb</span><span>#signal_status</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>RubyLex</span><span>#each_top_level_statement</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>Kernel</span><span>#loop</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>Kernel</span><span>#catch</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>IRB</span><span>::</span><span>Irb</span><span>#run</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>IRB</span><span>.</span><span>start</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>&lt;</span><span>top</span> <span>(</span><span>required</span><span>)</span><span>&gt;</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>Kernel</span><span>#load</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>&lt;</span><span>main</span><span>&gt;</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>&lt;</span><span>main</span><span>&gt;</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>Kernel</span><span>#eval</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>&lt;</span><span>main</span><span>&gt;</span>
         <span>2</span>   <span>(</span><span>7.7</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>(</span><span>garbage</span> <span>collection</span><span>)</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>Integer</span><span>#times</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>Object</span><span>#snippet</span>
        <span>22</span>  <span>(</span><span>84.6</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>Date</span><span>.</span><span>parse</span>
        <span>24</span>  <span>(</span><span>92.3</span><span>%</span><span>)</span>           <span>0</span>   <span>(</span><span>0.0</span><span>%</span><span>)</span>     <span>IRB</span><span>::</span><span>Context</span><span>#evaluate</span>
<span>=&gt;</span> <span>10000</span>
</code></pre></div></div>

<p>Huzzah! We’re getting a Stackprof report from an IRB console with absolutely no custom code!</p>

<p>To further explain the output, we’re seeing how many samples were taken at each stack frame and what percentage of time that amounts to. For instance, the first tells us that there were 11 samples taken at the <code>Regexp#match</code> frame. The header at the top tells us there were 26 total samples taken. So Stackprof is extrapolating here that 11/26, or 42.3%, of our time is spent in <code>Regexp#match</code>. This 42.3% is represented in the <code>(pct)</code> column. In this way, the Stackprof output gives us an accurate estimate of how much time different stack frames are taking in the execution of our code.</p>

<p>We can also see in the header that this is profiling in <code>cpu</code> mode. This means Stackprof will take samples every millisecond of time where there is cpu activity. But, Stackprof has <a href="https://github.com/tmm1/stackprof#sampling">many more sampling modes</a>! One other interesting one is wall sampling, which takes samples every millisecond of actual time, regardless of if there is cpu activity or not.</p>

<p>The built-in <code>measure :stackprof</code> actually allows us to pass an argument, which is the mode for which we want to run Stackprof. For instance, to use wall time sampling, we can run:</p>

<div><div><pre><code><span>irb</span> <span>&gt;</span> <span>measure</span> <span>:stackprof</span><span>,</span> <span>:wall</span>
<span>STACKPROF</span> <span>is</span> <span>added</span><span>.</span>
<span>=</span><span>&gt;</span> <span>nil</span>

<span>irb</span> <span>&gt;</span> <span>snippet</span>
<span>==================================</span>
  <span>Mode</span><span>:</span> <span>wall</span><span>(</span><span>1000</span><span>)</span>
  <span>Samples</span><span>:</span> <span>56</span> <span>(</span><span>0.00</span><span>%</span> <span>miss</span> <span>rate</span><span>)</span>
  <span>GC</span><span>:</span> <span>5</span> <span>(</span><span>8.93</span><span>%</span><span>)</span>
<span>==================================</span>
     <span>TOTAL</span>    <span>(</span><span>pct</span><span>)</span>     <span>SAMPLES</span>    <span>(</span><span>pct</span><span>)</span>     <span>FRAME</span>
        <span>20</span>  <span>(</span><span>35.7</span><span>%</span><span>)</span>          <span>20</span>  <span>(</span><span>35.7</span><span>%</span><span>)</span>     <span>Regexp</span><span>#match</span>
        <span>10</span>  <span>(</span><span>17.9</span><span>%</span><span>)</span>          <span>10</span>  <span>(</span><span>17.9</span><span>%</span><span>)</span>     <span>Date</span><span>.</span><span>today</span>
<span>...</span>
<span>...</span>
<span>=&gt;</span> <span>10000</span>
</code></pre></div></div>

<p>We can get both <code>time</code> and <code>stackprof</code> measurements by simply toggling them both. Note that we can also set the measurement explicitly to time by using <code>measure :time</code>. They’ll print in the order in which we add them:</p>

<div><div><pre><code><span>irb</span> <span>&gt;</span> <span>measure</span> <span>:time</span>
<span>TIME</span> <span>is</span> <span>added</span><span>.</span>
<span>=</span><span>&gt;</span> <span>nil</span>

<span>irb</span> <span>&gt;</span> <span>measure</span> <span>:stackprof</span>
<span>STACKPROF</span> <span>is</span> <span>added</span><span>.</span>
<span>processing</span> <span>time: </span><span>0.000165</span><span>s</span>
<span>=&gt;</span> <span>nil</span>

<span>irb</span> <span>&gt;</span> <span>snippet</span>
<span>processing</span> <span>time: </span><span>0.058907</span><span>s</span>
<span>==================================</span>
  <span>Mode</span><span>:</span> <span>cpu</span><span>(</span><span>1000</span><span>)</span>
  <span>Samples</span><span>:</span> <span>35</span> <span>(</span><span>0.00</span><span>%</span> <span>miss</span> <span>rate</span><span>)</span>
  <span>GC</span><span>:</span> <span>5</span> <span>(</span><span>14.29</span><span>%</span><span>)</span>
<span>==================================</span>
     <span>TOTAL</span>    <span>(</span><span>pct</span><span>)</span>     <span>SAMPLES</span>    <span>(</span><span>pct</span><span>)</span>     <span>FRAME</span>
         <span>7</span>  <span>(</span><span>20.0</span><span>%</span><span>)</span>           <span>7</span>  <span>(</span><span>20.0</span><span>%</span><span>)</span>     <span>Regexp</span><span>#match</span>
         <span>6</span>  <span>(</span><span>17.1</span><span>%</span><span>)</span>           <span>6</span>  <span>(</span><span>17.1</span><span>%</span><span>)</span>     <span>Date</span><span>.</span><span>today</span>
<span>...</span>
<span>...</span>
<span>=&gt;</span> <span>10000</span>
</code></pre></div></div>

<p>To see which measurements we’re currently taking, we can use <code>measure :list</code>. Note that it’ll still also output the measurements (processing time and Stackprof output, in our case) from running <code>measure :list</code>:</p>

<div><div><pre><code><span>irb</span> <span>&gt;</span> <span>measure</span> <span>:list</span>
<span>-</span> <span>TIME</span>
<span>-</span> <span>STACKPROF</span>
<span>processing</span> <span>time: </span><span>0.000129</span><span>s</span>
<span>==================================</span>
  <span>Mode</span><span>:</span> <span>cpu</span><span>(</span><span>1000</span><span>)</span>
  <span>Samples</span><span>:</span> <span>0</span> <span>(</span><span>NaN</span><span>%</span> <span>miss</span> <span>rate</span><span>)</span>
  <span>GC</span><span>:</span> <span>0</span> <span>(</span><span>NaN</span><span>%</span><span>)</span>
<span>==================================</span>
     <span>TOTAL</span>    <span>(</span><span>pct</span><span>)</span>     <span>SAMPLES</span>    <span>(</span><span>pct</span><span>)</span>     <span>FRAME</span>
<span>=&gt;</span> <span>nil</span>
</code></pre></div></div>

<h2 id="custom-measure-procedures">Custom measure procedures</h2>

<p>Right about now, you might be thinking, “This is neat, but what if we want our own measure procedure?” You also might be thinking, “Wow, what a fun blog post!”</p>

<p>In either case, we’re just getting started! Check out the <a href="https://jemma.dev/blog/irb-custom-measure-procedures">second part</a> of this blog post to learn more about writing custom measure procedures.</p>

<h2 id="tldr">TL;DR</h2>

<p>In summary, here is what we learned about IRB’s new <code>measure</code> functionality</p>

<ul>
  <li><code>measure</code> will toggle measurement on, defaulting to measuring time of commands</li>
  <li><code>measure :off</code> toggles measurement off</li>
  <li><code>measure :stackprof</code> is built-in, and outputs Stackprof (default mode: cpu) results of code</li>
  <li><code>measure :list</code> lists all measurement modes currently in use</li>
  <li>And there’s <a href="https://jemma.dev/blog/irb-custom-measure-procedures">more about custom measure procedures</a></li>
</ul>


  </div>
  
</article>

      </div>
    </div></div>
  </body>
</html>
