<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2008/07/maxwells-equations-of-software-examined.html">Original</a>
    <h1>&#34;Maxwell&#39;s equations of software&#34; examined (2008)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-2219572455219389220" itemprop="description articleBody"><p>
A <a href="http://bc.tech.coop/blog/060224.html">recent post</a> quotes Alan Kay&#39;s <a href="http://www.doc.ic.ac.uk/~sue/475/AlanKay.html">statement</a> that expressing Lisp in itself is the &#34;<a href="https://en.wikipedia.org/wiki/Maxwell&#39;s_equations#General_formulations_of_Maxwell.27s_equations">Maxwell&#39;s Equations of Software</a>&#34;:
</p><blockquote>Yes, that was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” </blockquote>
<p>
This quote appears many places on the web, but the code itself is harder to find.  What <i>is</i> this amazing half page of code?
</p><p>
The Lisp 1.5 Manual, which was written by John McCarthy et al in 1961, is available at <a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">softwarepreservation.org</a>. In it, the &#34;Maxwell&#39;s equations&#34; define a universal Lisp function <code>evalquote</code> that can evaluate any given function:
</p><pre>evalquote[fn;x] = apply[fn;x;NIL]
</pre><p>
where 
</p><pre>apply[fn;x;a] =
     [atom[fn] -&gt; [eq[fn;CAR] -&gt; caar[x];
                  eq[fn;CDR] -&gt; cdar[x];
                  eq[fn;CONS] -&gt; cons[car[x];cadr[x]];
                  eq[fn;ATOM] -&gt; atom[car[x]];
                  eq[fn;EQ] -&gt; eq[car[x];cadr[x]];
                  T -&gt; apply[eval[fn;a];x;a]];
     eq[car[fn];LAMBDA] -&gt; eval[caddr[fn];pairlis[cadr[fn];x;a]];
     eq[car[fn];LABEL] -&gt; apply[caddr[fn];x;cons[cons[cadr[fn];
                               caddr[fn]];a]]]

eval[e;a] = [atom[e] -&gt; cdr[assoc[e;a]];
     atom[car[e]] -&gt;
      [eq[car[e],QUOTE] -&gt; cadr[e];
      eq[car[e];COND] -&gt; evcon[cdr[e];a];
      T -&gt; apply[car[e];evlis[cdr[e];a];a]];
      T -&gt; apply[car[e];evlis[cdr[e];a];a]]

evcon[c;a] = [eval[caar[c];a] -&gt; eval[cadar[c];a];
      T -&gt; evcon[cdr[c];a]]

evlis[m;a] = [null[m] -&gt; NIL;
      T -&gt; cons[eval[car[m];a];evlis[cdr[m];a]]]
</pre>
<p>
The above code is defined in a meta-language (M-expressions), which can be straighforwardly translated into S-expressions.  Functions in M-expressions use square brackets and have arguments separated by semicolons.  M-expressions conditionals are of the form <code>[predicate -&gt; value; predicate -&gt; value; ...]</code>.  M-expression <code>label</code> is analogous to <code>defun</code> or <code>define</code>.
</p><p>
The point of all this is that M-expressions are the code that operates on the S-expression data, but the M-expression meta-language and S-expression data actually coincide.  Thus, code and data are the same thing in Lisp, and a half-page of code is sufficient to define a basic Lisp interpreter in Lisp given a few primitives (<code>car, cdr, cons, eq, atom</code>).  The code presents a <a href="https://en.wikipedia.org/wiki/Meta-circular_evaluator">Meta-circular evaluator</a> for Lisp; see  (<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html">SICP chapter 4.1</a> for more details on metacircular evaluators.  (Unfortunately, this won&#39;t give you a working Lisp interpreter for free; things such as the garbage collector, the list primitives, and parsing need to be implemented somewhere.  Also note that this metacircular evaluator doesn&#39;t give you niceties such as arithmetic.))
</p><p>
To understand the above code, <code>apply</code> takes a function and argument, while <code>eval</code> acts on a form.  The last argument to these is an association list for the environment, which stores the values of bound values and function names.  In brief, <code>apply</code> implements <code>CAR</code>, <code>CDR</code>, <code>CONS</code>, <code>ATOM</code>, and <code>EQ</code> in terms of the primitives.  It implements <code>LAMBDA</code> by pairing up the variables and arguments and passing them to <code>eval</code>.  It implements <code>LABEL</code> (which defines a function) by adding the function name and definition to the association list.
</p><p>
The code for <code>eval</code> processes a form in a straightforward manner.  It handles the <code>QUOTE</code> form by returning the quoted value.  It handles <code>COND</code> by evaluating the predicates with the help of <code>evcon</code>.  Otherwise, it interprets an atom as a variable and returns the value.  If given a list, it interprets this as a function application; the arguments are evaluated with <code>evalis</code> and the function is evaluated by <code>apply</code>.
</p><p>
The above code is not quite complete; it relies on some other simple functions that were previously defined in the manual, such as <code>equals</code> and <code>cadr</code>  Less obvious functions are <code>pairlis[x;y;a]</code> pairs up lists <code>x</code> and <code>y</code> and adds them to association list <code>a</code>.  <code>assoc[x;a]</code> looks up <code>x</code> in association list <code>a</code>.  <code>sublis[a;y]</code> treats association list <code>a</code> as a mapping of variables to values, and replaces variables in S-expression <code>y</code> with the associated variables.  These functions can be straightforwardly built from the primitive functions.
</p><p>
(By the way, I&#39;m pretty sure the comma in <code>eq[car[e],QUOTE]</code> is a typo, but that&#39;s how it is in the original.)
</p>
</div></div>
  </body>
</html>
