<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/VictorTaelin/WebMonkeys">Original</a>
    <h1>WebMonkeys: parallel GPU programming in JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Allows you to spawn thousands of parallel tasks on the GPU with the simplest, dumbest API possible. It works on the browser (with browserify) and on Node.js. It is ES5-compatible and doesn&#39;t require any WebGL extension.</p>

<p dir="auto">On the browser, add <code>&lt;script src=&#34;WebMonkeys.js&#34;&gt;&lt;script&gt;</code> to your HTML. On Node.js, install it from npm:</p>
<div dir="auto" data-snippet-clipboard-copy-content="npm install webmonkeys --save"><pre>npm install webmonkeys --save</pre></div>
<p dir="auto">The example below uses the GPU to square all numbers in an array in parallel:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Creates a WebMonkeys object
const monkeys = require(&#34;WebMonkeys&#34;)(); // on the browser, call WebMonkeys() instead

// Sends an array of numbers to the GPU
monkeys.set(&#34;nums&#34;, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);

// Employs 16 monkeys to work in parallel on the task of squaring each number
monkeys.work(16, &#34;nums(i) := nums(i) * nums(i);&#34;);

// Receives the result back
console.log(monkeys.get(&#34;nums&#34;));

// output: [ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256 ]"><pre><span>// Creates a WebMonkeys object</span>
<span>const</span> <span>monkeys</span> <span>=</span> <span>require</span><span>(</span><span>&#34;WebMonkeys&#34;</span><span>)</span><span>(</span><span>)</span><span>;</span> <span>// on the browser, call WebMonkeys() instead</span>

<span>// Sends an array of numbers to the GPU</span>
<span>monkeys</span><span>.</span><span>set</span><span>(</span><span>&#34;nums&#34;</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>12</span><span>,</span> <span>13</span><span>,</span> <span>14</span><span>,</span> <span>15</span><span>,</span> <span>16</span><span>]</span><span>)</span><span>;</span>

<span>// Employs 16 monkeys to work in parallel on the task of squaring each number</span>
<span>monkeys</span><span>.</span><span>work</span><span>(</span><span>16</span><span>,</span> <span>&#34;nums(i) := nums(i) * nums(i);&#34;</span><span>)</span><span>;</span>

<span>// Receives the result back</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>monkeys</span><span>.</span><span>get</span><span>(</span><span>&#34;nums&#34;</span><span>)</span><span>)</span><span>;</span>

<span>// output: [ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256 ]</span></pre></div>
<p dir="auto"><code>set</code>/<code>get</code> allow you to send/receive data from the GPU, and <code>work</code> creates a number of parallel tasks (monkeys) that can read, process and rewrite that data. The language used is <a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf" rel="nofollow">GLSL 1.0</a>, extended array access <em>(<code>foo(index)</code>, usable anywhere on the source)</em>, setters <em>(<code>foo(index) := value</code>, usable on the end only)</em>, and <code>int i</code>, a global variable with the index of the monkey.</p>

<p dir="auto">More elaborate algorithms can be developed with GLSL.</p>
<ul dir="auto">
<li>
<p dir="auto">Vector multiplication:</p>
<div dir="auto" data-snippet-clipboard-copy-content="monkeys.set(&#34;a&#34;, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);
monkeys.set(&#34;b&#34;, [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);
monkeys.set(&#34;c&#34;, 16); // use a number to just alloc an array

monkeys.work(16, &#34;c(i) := a(i) * b(i);&#34;);

console.log(monkeys.get(&#34;c&#34;));"><pre><span>monkeys</span><span>.</span><span>set</span><span>(</span><span>&#34;a&#34;</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>12</span><span>,</span> <span>13</span><span>,</span> <span>14</span><span>,</span> <span>15</span><span>,</span> <span>16</span><span>]</span><span>)</span><span>;</span>
<span>monkeys</span><span>.</span><span>set</span><span>(</span><span>&#34;b&#34;</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>]</span><span>)</span><span>;</span>
<span>monkeys</span><span>.</span><span>set</span><span>(</span><span>&#34;c&#34;</span><span>,</span> <span>16</span><span>)</span><span>;</span> <span>// use a number to just alloc an array</span>

<span>monkeys</span><span>.</span><span>work</span><span>(</span><span>16</span><span>,</span> <span>&#34;c(i) := a(i) * b(i);&#34;</span><span>)</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span>monkeys</span><span>.</span><span>get</span><span>(</span><span>&#34;c&#34;</span><span>)</span><span>)</span><span>;</span></pre></div>
</li>
<li>
<p dir="auto">Crypto-currency mining:</p>
<div dir="auto" data-snippet-clipboard-copy-content="monkeys.set(&#34;blockhash&#34;, [blockhash]);
monkeys.set(&#34;monkeyNonce&#34;, monkeyNonce);
monkeys.set(&#34;result&#34;, [0]);
monkeys.work(totalMonkeys, `
  const float attempts = ${attemptsPerMonkey.toFixed(1)};
  float bhash = blockhash(0);
  float startNonce = monkeyNonce(i);
  float mined = 0.0;
  for (float nonce = startNonce; nonce &lt; startNonce+attempts; ++nonce){
    // Yes, this hash function is stupid
    float hash = mod(bhash * (nonce+1.0), pow(2.0,31.0) - 1.0);
    if (hash &gt;= 0.0 &amp;&amp; hash &lt;= 3000.0)
      mined = nonce;
  };
  result(mined &gt; 0.0 ? 0 : 1) := mined;
`);
// Will be set if mined a block
console.log(monkeys.get(&#34;result&#34;));"><pre><span>monkeys</span><span>.</span><span>set</span><span>(</span><span>&#34;blockhash&#34;</span><span>,</span> <span>[</span><span>blockhash</span><span>]</span><span>)</span><span>;</span>
<span>monkeys</span><span>.</span><span>set</span><span>(</span><span>&#34;monkeyNonce&#34;</span><span>,</span> <span>monkeyNonce</span><span>)</span><span>;</span>
<span>monkeys</span><span>.</span><span>set</span><span>(</span><span>&#34;result&#34;</span><span>,</span> <span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
<span>monkeys</span><span>.</span><span>work</span><span>(</span><span>totalMonkeys</span><span>,</span> <span>`</span>
<span>  const float attempts = <span><span>${</span><span>attemptsPerMonkey</span><span>.</span><span>toFixed</span><span>(</span><span>1</span><span>)</span><span>}</span></span>;</span>
<span>  float bhash = blockhash(0);</span>
<span>  float startNonce = monkeyNonce(i);</span>
<span>  float mined = 0.0;</span>
<span>  for (float nonce = startNonce; nonce &lt; startNonce+attempts; ++nonce){</span>
<span>    // Yes, this hash function is stupid</span>
<span>    float hash = mod(bhash * (nonce+1.0), pow(2.0,31.0) - 1.0);</span>
<span>    if (hash &gt;= 0.0 &amp;&amp; hash &lt;= 3000.0)</span>
<span>      mined = nonce;</span>
<span>  };</span>
<span>  result(mined &gt; 0.0 ? 0 : 1) := mined;</span>
<span>`</span><span>)</span><span>;</span>
<span>// Will be set if mined a block</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>monkeys</span><span>.</span><span>get</span><span>(</span><span>&#34;result&#34;</span><span>)</span><span>)</span><span>;</span></pre></div>
</li>
</ul>
<p dir="auto">You can also define libs, write to many indices in a single call, and work with raw Uint32 buffers if you wish to. For more details, please check the <a href="https://github.com/MaiaVictor/WebMonkeys/tree/master/examples"><code>examples</code></a> directory.</p>

<p dir="auto">The only reliable way to access the GPU on the browser is by using WebGL. Since it wasn&#39;t designed for general programming, doing it is very tricky. For one, the only way to upload data is as 2D textures of pixels. Even worse, your shaders (programs) can&#39;t write directly to them; you need to, instead, render the result using geometrical primitives. You&#39;re, thus, in charge of converting JS numbers (IEEE 754 floats) to pixels, projecting them to/from 2D textures and using proper geometries to render the results on the right places. You must also deal with aliasing/blurring, rounding, and loss of precision. It is a very delicate job with many small details that could go wrong and no satisfactory way of debugging. WebMonkeys takes care of all that for you, abstracting the overcomplication away and making the power of the GPU as easily accessible as possible, with a very simple API based on array reads and writes.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Performance and debugging tips</h3><a id="user-content-performance-and-debugging-tips" aria-label="Permalink: Performance and debugging tips" href="#performance-and-debugging-tips"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>
<p dir="auto">A single monkey can write to multiple places. If you need to fill an array of 100 numbers, you could use 100 monkeys writing to 1 index each, or 10 monkeys writing to 10 indices each. What is faster will depend on your application.</p>
</li>
<li>
<p dir="auto">While CPU/GPU bandwidth is huge these days, it still takes time to communicate data between them. Whenever possible, reduce your calls to <code>set/get</code>, and keep things internal to the GPU. For example, if you need to move data between two arrays, this: <code>monkeys.work(16, &#34;target(i) := source(i);&#34;)</code> - is much faster than this: <code>monkeys.set(&#34;target&#34;, monkeys.get(&#34;source&#34;))</code>.</p>
</li>
<li>
<p dir="auto">The first call to <code>monkeys.work(count, someTask)</code> is slow due to program compilation, but every call after that is fast. That is for two reasons: 1. WebMonkeys caches shaders so that, when you call <code>task</code> with a repeated source code, it just recovers the previously compiled program; 2. JS engines keep strings hashed, which means that retrieval can be done in O(1). In other words, it is perfectly reasonable to call <code>monkeys.work(n, bigSourceCode)</code> inside your animation loop (as long as <code>bigSourceCode</code> doesn&#39;t change).</p>
</li>
<li>
<p dir="auto">Since WebMonkeys stores numbers as WebGL textures, writing/reading to/from arrays has an encode/decode overhead. If your application spends much more time doing arithmetics than writing/reading data, that is acceptable. If not, use <a href="https://github.com/MaiaVictor/WebMonkeys/blob/master/examples/useRawBuffers.js">raw buffers</a> and do your own packing/unpacking.</p>
</li>
<li>
<p dir="auto">Remember you can&#39;t have setters (<code>foo(i) := v;</code>) in the middle of your program. They must be at the end. If you&#39;re having weird WebGL errors, it could be WebMonkeys&#39;s fault: its very simple parser sometimes fails to separate the program&#39;s body from the list of setters. Usually, just adding an extra line with a commented semicolon (<code>//;</code>) between your program and your setters solves it.</p>
</li>
<li>
<p dir="auto">Use <code>monkeys.fill(&#34;nums&#34;, 0)</code> rather than <code>monkeys.work(numsLength, &#34;nums(i) := 0.0;&#34;)</code> (and <code>clear</code>, its equivalent for raw Uint32s).</p>
</li>
</ul>
</article></div></div>
  </body>
</html>
