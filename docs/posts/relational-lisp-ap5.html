<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ap5.com/ap5-man.html">Original</a>
    <h1>Relational Lisp â€“ AP5</h1>
    
    <div id="readability-page-1" class="page"><div>
<td>


author: Don Cohen <a href="mailto:don@isis.cs3-inc.com">
don@isis.cs3-inc.com</a><!-- this makes so little sense that I de-document it...

@def{name=Set-Listof&rest, args=<vars @b[s.t.] (relation . args)
 @b[&rest] tuple-list>, type=macro} 

This is similar but accepts the tuple list as an &rest argument. -->




 

 

  
 



 
 
 


<!-- @def(name=History, args=<...>, type=function) -->






















<!-- [
 In general, we have adopted the strategy of using pessimistic (though
 not necessarily worst case) size estimates, e.g.,<br>
 (RelSize '(#,(dbo relation classification) output input) 1000.)<br>
 indicates that a typical type might have a thousand objects classified
 as that type.  Notice it's not sufficient to say independently how many 
 objects will be classified as people as opposed to employees, since at
 compile time AP5 might not know which type will be passed in at run time.  
] -->
<!-- [no longer (if ever) true:  On the other hand, one could 
 estimate the size of the Person relation.] -->



























<!-- @def(name=ap5::*advice-for-every-transition*, type=variable) -->




 
<!-- @def(name=ExpandDescription, args=<description @b[&key] allowevalargs 
keepstarts ...>, type=function) -->

 <!-- <
 <h2>Triggering Problems</h2>
 The current approach to triggering a wff is to simplify the wff (as far as 
 the simplifier is able - you can use ExpandDescription to see what it came
 up with) and then try to follow the structure of the result,
 i.e., trigger on each subwff.  This has some advantages:  wffs typed by
 people tend to be fairly well optimized in terms of length; this results
 in a relatively efficient match network; the nodes in the match network
 have some intuitive meaning to the human (if he has to examine them).
 It also has some problems: when people start using defined wffs and wffmacros
 the expanded forms starts to lose the tendency to be nearly as short as 
 possible; even worse, the approach sometimes fails in that there is no way
 to build a match network that mirrors the structure of the wff, while there
 is a way to build a match network with the structure of an equivalent wff.
 As an example, suppose that we have three base relations, P, Q, R, 
 and we want to notice whenever it becomes the case, for any x, y, that
 <pre>(AND (P x y) (OR (NOT (Q x)) (NOT (R y)))).</pre>
 In the current approach, this involves noticing whenever it becomes the
 case, for any x, y, that
 <pre>(OR (NOT (Q x)) (NOT (R y))).</pre>
 This cannot be done: if (Q a) is deleted, there are infinitely many values
 of y for which we must trigger (a, y).  However, it turns out that at the
 higher level, all but the finite set of these such that (P a y) are going
 to be filtered out.  If we were to transform the original wff into the
 equivalent
 <pre>(OR (AND (P x y) (NOT (Q x))) (AND (P x y) (NOT (R y))))</pre>
 then the triggering would be straight forward.  In fact, you can get this
 effect by rebinding ap5::DNF-ify to T for the AlwaysRequire or NeverPermit
 containing this wff.  However, this can also make a large wff much 
 (exponentially!) larger, and of course, this also presents more opportunities
 for the simplifier to fail to notice a simplification that might make a
 solution possible.  Clearly more work is needed here.
 @comment(see rule subrelations-have-same-arity)
> -->






 
<!-- @def(name=Memo, args= form, type=macro) -->
 
<!-- @def(name=Constant, args= form, type=macro) -->



<!-- { no longer needed ... 
 @append (Typical things to do when declaring an implementation)
 @verbatim{
 (++ implementation imp)
 (++ derived imp)            ; if it is derived
 (++ relupdater imp macro)   ; if it can be updated
 (++ reladder imp macro)
 (++ reldeleter imp macro)
 (++ reltester imp macro)    ; it it can be tested
 (++ relgenerator imp macro) ; if it can be generated
 (++ testeffort imp function)
 (++ implementation-parameter-relation imp rel) ; for DefRelation
 ; more rare declarations include:
 (++ testeffort rel function)
<p>
 @comment[(cxvaluefn imp fn)]
 @comment[(relinheriter imp macro)]
 (addchecker imp function)
 (deletechecker imp function)
 }
} -->




</td>
</div></div>
  </body>
</html>
