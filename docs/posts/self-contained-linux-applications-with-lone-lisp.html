<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.matheusmoreira.com/articles/self-contained-lone-lisp-applications">Original</a>
    <h1>Self-contained Linux applications with lone Lisp</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        
        <p>
          I started
          <a href="https://github.com/lone-lang/lone">the lone lisp project</a>
          to create a lisp language and environment exclusively for Linux. I
          built into it support for arbitrary
          <a href="https://www.matheusmoreira.com/articles/linux-system-calls">Linux system calls</a>
          so that it would be possible to implement any program without need for
          any external dependencies and so that every Linux feature would be
          available to programmers.
        </p>
        <p>
          Although far from ready for production use, I have achieved a
          significant milestone in the development of the language: it is now
          possible to create self-contained, standalone, freestanding,
          redistributable Linux applications written entirely in lisp.
        </p>
        <p>
          Lisp code can now be embedded directly into a copy of the lone
          interpreter which may then be copied to and run on any Linux system of
          the same architecture, unmodified and without any external
          dependencies. The application is limited only by the system calls it
          uses: newer system calls will naturally require newer kernels.
        </p>
        <p>
          In this article I will demonstrate this capability, explain how it
          works and the journey to implementing it. Every script bundling tool
          I&#39;ve ever seen unpacks the code to some file system location and then
          reads it back in. I came up with a different solution.
        </p>
        <h2>A simple implementation of <code>env</code> in lone lisp</h2>
        <p>
          The <code>env</code> utility is among the simplest programs available
          in Unix-like operating systems. It&#39;s most fundamental function is to
          print the user&#39;s environment. That function can be trivially
          implemented in lone lisp:
        </p>
        <pre><code><span>(</span><span>import</span> <span>(</span><span>lone</span> print<span>)</span> <span>(</span><span>linux</span> environment<span>)</span><span>)</span>

<span>(</span><span>print</span> environment<span>)</span>
</code></pre>
        <p>
          Running this simple program produces a table of environment variables
          and their values:
        </p>
        <pre><code>$ ./lone <span>&lt;</span> env.ln
<span>{</span> <span>&#34;HOME&#34;</span> <span>&#34;/home/matheus&#34;</span> <span>&#34;EDITOR&#34;</span> <span>&#34;vim&#34;</span> … <span>}</span>
</code></pre>
        <h3>Embedding <code>env.ln</code> into the interpreter</h3>
        <p>
          In order to transform <code>env.ln</code> into a self-contained
          <code>env</code> program, the lone lisp code must be embedded into a
          copy of the interpreter. This can be achieved by the purpose-built
          <code>lone-embed</code> tool:
        </p>
        <pre><code>$ <span>cp</span> lone <span>env</span>
$ lone-embed <span>env</span> env.ln
</code></pre>
        <p>The interpreter will then seamlessly load and execute the code:</p>
        <pre><code>$ ./env
<span>{</span> <span>&#34;HOME&#34;</span> <span>&#34;/home/matheus&#34;</span> <span>&#34;EDITOR&#34;</span> <span>&#34;vim&#34;</span> … <span>}</span>
</code></pre>
        <h2>Elven segments</h2>
        <p>
          Tracing the system calls of the application with <code>strace</code>
          reveals an interesting property:
        </p>
        <pre><code>$ <span>strace</span> <span>env</span>
execve<span>(</span><span>&#34;env&#34;</span>, <span>[</span><span>&#34;env&#34;</span><span>]</span>, 0x7fe9752d40 /* <span>31</span> vars */<span>)</span> <span>=</span> <span>0</span>
write<span>(</span><span>1</span>, <span>&#34;{ &#34;</span>, <span>2</span><span>)</span>                                  <span>=</span> <span>2</span>
write<span>(</span><span>1</span>, <span>&#34;<span title="\&#34;">\&#34;</span>&#34;</span>, <span>1</span><span>)</span>                                  <span>=</span> <span>1</span>
write<span>(</span><span>1</span>, <span>&#34;HOME&#34;</span>, <span>4</span><span>)</span>                                <span>=</span> <span>4</span>
write<span>(</span><span>1</span>, <span>&#34;<span title="\&#34;">\&#34;</span>&#34;</span>, <span>1</span><span>)</span>                                  <span>=</span> <span>1</span>
write<span>(</span><span>1</span>, <span>&#34; &#34;</span>, <span>1</span><span>)</span>                                   <span>=</span> <span>1</span>
…
</code></pre>
        <p>
          It begins writing its output immediately. There was no need for it to
          read from the file system. The code must be somewhere else.
        </p>
        <pre><code>$ xxd <span>env</span> <span>|</span> <span>tail</span> <span>-n7</span>
00032fe0: 0000 0000 0000 0000 0000 0000 0000 0000  <span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span>
00032ff0: 0000 0000 0000 0000 0000 0000 0000 0000  <span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span>
00033000: 7b20 <span>7275</span> 6e20 <span>2830</span> 202e <span>2036</span> <span>3329</span> 207d  <span>{</span> run <span>(</span><span>0</span> <span>.</span> <span>63</span><span>)</span> <span>}</span>
00033010: 0a28 696d 706f <span>7274</span> <span>2028</span> 6c6f 6e65 <span>2070</span>  .<span>(</span>import <span>(</span>lone p
00033020: <span>7269</span> 6e74 <span>2920</span> 286c 696e <span>7578</span> <span>2065</span> 6e76  rint<span>)</span> <span>(</span>linux <span>env</span>
00033030: <span>6972</span> 6f6e 6d65 6e74 <span>2929</span> 0a0a <span>2870</span> <span>7269</span>  ironment<span>))</span><span>..</span><span>(</span>pri
00033040: 6e74 <span>2065</span> 6e76 <span>6972</span> 6f6e 6d65 6e74 290a  nt environment<span>)</span>.
</code></pre>
        <p>
          It&#39;s at the very end of the executable itself, at an aligned offset.
          Through some elven magic the interpreter is reflecting upon its own
          contents at runtime. It&#39;s loading the code from inside itself and
          evaluating it. Without using any system calls to do it.
        </p>
        <p>The source of this magic is the ELF segment.</p>
        <pre><code>$ readelf <span>--segments</span> <span>env</span> <span>|</span> <span>grep</span> <span>33000</span>
LOAD           0x0000000000033000 0x0000000000312000 0x0000000000312000
LOOS+0xc6f6e65 0x0000000000033000 0x0000000000312000 0x0000000000312000
</code></pre>
        <p>
          ELF segments, also called program headers, describe the memory image
          of the program. There are many types of segments but especially
          interesting are the <code>LOAD</code> segments which tell Linux which
          parts of the file must be mapped to which addresses in order for the
          program to work correctly.
        </p>
        <p>
          The <code>lone-embed</code> tool copies the lisp code into the ELF and
          then creates a <code>LOAD</code> segment for it. Linux then maps in
          the embedded code automatically at load time before the interpreter
          has even started.
        </p>
        <h3>Finding the segment</h3>
        <p>
          The code will be in memory but its location and size are unknown. It
          could be anywhere inside the vastness of virtual address space. To
          that problem Linux provides an ingenious solution: it tells us where
          it is.
        </p>
        <p>
          In addition to argument and environment vectors, processes receive the
          auxiliary vector. It&#39;s essentially a null terminated array of
          key-value pairs of various types and it&#39;s placed right there on the
          stack just after the environment vector.
        </p>
        <pre><code><span>struct</span> <span>lone_auxiliary_value</span> <span>{</span>
    <span>union</span> <span>{</span>
        <span>char</span> <span>*</span>c_string<span>;</span>
        <span>void</span> <span>*</span>pointer<span>;</span>
        <span>long</span> integer<span>;</span>
        <span>unsigned</span> <span>long</span> unsigned_integer<span>;</span>
    <span>}</span> as<span>;</span>
<span>}</span><span>;</span>

<span>struct</span> <span>lone_auxiliary_vector</span> <span>{</span>
    <span>long</span> type<span>;</span>
    <span>struct</span> <span>lone_auxiliary_value</span> value<span>;</span>
<span>}</span> <span>*</span>auxv<span>;</span>

<span>void</span> <span>*</span><span>*</span>pointer <span>=</span> <span>(</span><span>void</span> <span>*</span><span>*</span><span>)</span> envp<span>;</span>
<span>while</span> <span>(</span><span>*</span>pointer<span>++</span> <span>!=</span> <span>0</span><span>)</span><span>;</span>
auxv <span>=</span> <span>(</span><span>struct</span> <span>auxiliary_vector</span> <span>*</span><span>)</span> pointer<span>;</span>
</code></pre>
        <p>
          Through this mechanism, Linux passes various bits of useful
          information to programs. These include things like processor
          architecture and capabilities, current user and group IDs, some random
          bytes, the location of the
          <a href="https://www.man7.org/linux/man-pages/man7/vdso.7.html">vDSO</a>, the system&#39;s page size...
        </p>
        <p>And the location of the program header table.</p>
        <pre><code><span>struct</span> <span>lone_auxiliary_value</span> <span>lone_auxiliary_vector_value</span><span>(</span><span>struct</span> <span>lone_auxiliary_vector</span> <span>*</span>auxiliary<span>,</span> <span>long</span> type<span>)</span>
<span>{</span>
    <span>for</span> <span>(</span><span>;</span> auxiliary<span>-&gt;</span>type <span>!=</span> AT_NULL<span>;</span> <span>++</span>auxiliary<span>)</span>
        <span>if</span> <span>(</span>auxiliary<span>-&gt;</span>type <span>==</span> type<span>)</span>
            <span>return</span> auxiliary<span>-&gt;</span>value<span>;</span>

    <span>return</span> <span>(</span><span>struct</span> <span>lone_auxiliary_value</span><span>)</span> <span>{</span> <span>.</span>as<span>.</span>integer <span>=</span> <span>0</span> <span>}</span><span>;</span>
<span>}</span>

<span>struct</span> <span>lone_elf_segments</span> <span>lone_auxiliary_vector_elf_segments</span><span>(</span><span>struct</span> <span>lone_auxiliary_vector</span> <span>*</span>auxv<span>)</span>
<span>{</span>
    <span>return</span> <span>(</span><span>struct</span> <span>lone_elf_segments</span><span>)</span> <span>{</span>
        <span>.</span>entry_size  <span>=</span> <span>lone_auxiliary_vector_value</span><span>(</span>auxv<span>,</span> AT_PHENT<span>)</span><span>.</span>as<span>.</span>unsigned_integer<span>,</span>
        <span>.</span>entry_count <span>=</span> <span>lone_auxiliary_vector_value</span><span>(</span>auxv<span>,</span> AT_PHNUM<span>)</span><span>.</span>as<span>.</span>unsigned_integer<span>,</span>
        <span>.</span>segments    <span>=</span> <span>lone_auxiliary_vector_value</span><span>(</span>auxv<span>,</span> AT_PHDR<span>)</span><span>.</span>as<span>.</span>pointer
    <span>}</span><span>;</span>
<span>}</span>
</code></pre>
        <p>
          The table is just a contiguous array of
          <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#Program_header">ELF program header structures</a>. Given this pointer, all the program has to do is scan the table and
          find the correct entry. One does not simply search for
          <code>LOAD</code> entries, however. Attempting to do it uncovers a
          couple of problems.
        </p>
        <p>
          The first problem is the fact there are lots of these loadable
          segments and they&#39;re all indistinguishable from one another. ELF
          sections have unique names for identification, program headers have
          nothing.
        </p>
        <p>
          The second problem is their alignment requirements. The addresses and
          sizes are usually aligned to page boundaries. This obfuscates the true
          size of the data they contain.
        </p>
        <h4>The lone segment</h4>
        <p>
          In order to solve this, I created my own custom segment type: the
          <code>LONE</code> segment.
        </p>
        <p>
          ELF provides an incredibly generous numeric range for operating
          system-specific segments. All the values between <code>LOOS</code> and
          <code>HIOS</code> are free for operating systems to allocate. Those
          definitions represent a range of integers between
          <code>0x60000000</code> and <code>0x6FFFFFFF</code> inclusive. That&#39;s
          268,435,455 magic numbers.
        </p>
        <p>
          So I just picked one. That&#39;s what the
          <code>LOOS+0xc6f6e65</code> means. Spelled out <code>lone</code> in
          ASCII and it just worked itself out.
        </p>
        <pre><code>
<span><span>#</span><span>define</span> <span>PT_LONE</span> <span><span>0x6c6f6e65</span></span></span>
</code></pre>
        <p>I figured if GNU can do it then I can do it too.</p>
        <p>
          The <code>LONE</code> segment is not loadable and thus does not have
          any alignment requirements, allowing it to describe the embedded
          segment exactly. It also serves as a magic number which makes it
          trivial to search for it in the program header table. Once found, it
          contains all the information lone needs to load and execute the code.
        </p>
        <pre><code><span>typedef</span> Elf64_Phdr lone_elf_segment<span>;</span> 
<span>typedef</span> Elf32_Phdr lone_elf_segment<span>;</span> 

lone_elf_segment <span>*</span><span>lone_auxiliary_vector_embedded_segment</span><span>(</span><span>struct</span> <span>lone_auxiliary_vector</span> <span>*</span>auxv<span>)</span>
<span>{</span>
    <span>struct</span> <span>lone_elf_segments</span> table <span>=</span> <span>lone_auxiliary_vector_elf_segments</span><span>(</span>auxv<span>)</span><span>;</span>

    <span>for</span> <span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> table<span>.</span>entry_count<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
        lone_elf_segment <span>*</span>entry <span>=</span> <span>&amp;</span>table<span>.</span>segments<span>[</span>i<span>]</span><span>;</span>

        <span>if</span> <span>(</span>entry<span>-&gt;</span>p_type <span>==</span> PT_LONE<span>)</span>
            <span>return</span> entry<span>;</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>

lone_elf_segment <span>*</span>segment <span>=</span> <span>lone_auxiliary_vector_embedded_segment</span><span>(</span>auxv<span>)</span><span>;</span>
<span>struct</span> <span>lone_bytes</span> data<span>;</span>
data<span>.</span>count <span>=</span> segment<span>-&gt;</span>p_memsz<span>;</span>
data<span>.</span>pointer <span>=</span> <span>(</span><span>unsigned</span> <span>char</span> <span>*</span><span>)</span> segment<span>-&gt;</span>p_vaddr<span>;</span>
</code></pre>
        <p>
          The interpreter now has the address and size of the data embedded into
          its own executable. At this point it&#39;s smooth sailing.
        </p>
        <p>
          All that&#39;s left to do is to make sense of the bytes. I chose to simply
          put a descriptor object in there and have the interpreter read it in.
          Seemed like the simplest possible solution.
        </p>
        <pre><code>{ run <span>(</span><span>0</span> <span>.</span> <span>63</span><span>)</span> }
</code></pre>
        <p>
          Just a good old hash table in lone lisp syntax. The run key contains
          the offset and size of the code the interpreter should run, relative
          to the end of the descriptor object. It just reads in that slice and
          evaluates it.
        </p>
        <p>
          Since it&#39;s just a normal hash table, it&#39;s also infinitely extensible
          with arbitrary schemas. I plan to implement a modules key to contain
          an arbitrary number of lone modules so that programs can statically
          link their libraries into the lone interpreter. All I gotta do is
          place the embedded segment into the module search path, before all the
          others. I suppose I could also allow configuring the interpreter via
          the descriptor object, eliminating the need for command line switches.
        </p>
        <h2>Special linker features</h2>
        <p>
          Remember the <code>lone-embed</code> tool which I briefly mentioned at
          the beginning of the articled? It&#39;s an ELF patching tool which I built
          specifically for this purpose and it&#39;s doing <em>a lot of</em> heavy
          lifting here.
        </p>
        <p>
          When programs are compiled and linked, the program headers are set in
          stone. Yet to do all of this I needed to append new segments to the
          program header table. This turned out to be <em>much</em> harder than
          anticipated.
        </p>
        <p>
          The program header table usually follows the ELF header and precedes
          the contents of the file. Appending new items to it would require
          resizing the table, which would require shifting up the addresses of
          <em>everything</em> that comes after it, invalidating pointers to the
          old addresses. As far as I can tell, it just can&#39;t be done without
          reinventing the linker itself.
        </p>
        <p>
          I tried to move the table to the end of the file instead but couldn&#39;t
          get that to work either. My program was somehow segfaulting before it
          even reached the entry point, gdb was useless, I couldn&#39;t understand
          what was going on and was reduced to desperately dumping
          <code>readelf</code> output on stackoverflow in hopes someone would
          spot the problem. Well <em>someone</em> did and quickly at that but
          clearly this was not a sustainable software development strategy.
        </p>
        <h3>The <code>mold</code> linker saves the day</h3>
        <p>
          The linker is in a privileged position. It knows everything there is
          to know about the program&#39;s memory layout and can easily add new ELF
          segments to it seemingly at will. If a solution exists, I was
          convinced it would be found in the linker.
        </p>
        <p>
          So I started learning
          <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>. Turns out it has a <code>PHDRS</code> command which is exactly what
          I needed but I couldn&#39;t figure out how to use it. I just kept getting
          &#34;unable to allocate headers&#34; errors no matter what I tried. I
          concluded it would be easier to simply <em>ask</em> for this feature
          instead.
        </p>
        <p>
          So I
          <a href="https://sourceware.org/pipermail/binutils/2023-November/130640.html">emailed</a>
          the GNU binutils mailing list... Then I created an
          <a href="https://github.com/llvm/llvm-project/issues/72386">LLVM issue</a>...
        </p>
        <p>
          Then I opened a <code>mold</code> issue. The maintainer immediately
          understood what I wanted to do and
          <a href="https://github.com/rui314/mold/commit/eb6c213f2a9aa8a101b2b52a791be369d165e6a9">made it happen</a>
          with what was essentially a single line of code change. Just
          <em>beyond awesome</em>.
        </p>
        <p>
          I waited eagerly for the new release but got so excited I built this
          huge C++ project from source <em>on my smartphone</em>
          just to integrate lone with it. All I had to do was put
          <code>-Wl,--spare-program-headers,2</code>
          in the <code>LDFLAGS</code>. It gave me two <code>NULL</code> program
          headers for my patching utility to edit any way it wanted. It worked
          <em>perfectly</em>.
        </p>
        <p>
          So far <code>mold</code> is the only linker with this feature and it&#39;s
          absolutely required for <code>lone-embed</code> to work. It will
          outright refuse to patch the ELF if it doesn&#39;t find at least two
          <code>NULL</code>
          program headers in it.
        </p>
        <p>
          Would be nice if the others gained this feature too. Unless I can
          figure out a way to move the program header table to the end of the
          file without breaking everything, I&#39;m pretty much locked into using
          <code>mold</code>. Well, I don&#39;t really mind. It&#39;s an awesome linker
          <em>and</em> it&#39;s free software. I&#39;m OK with this!
        </p>
      </article>
    </div></div>
  </body>
</html>
