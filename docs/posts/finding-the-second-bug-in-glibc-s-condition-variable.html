<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://probablydance.com/2022/09/17/finding-the-second-bug-in-glibcs-condition-variable/">Original</a>
    <h1>Finding the “Second Bug” in Glibc’s Condition Variable</h1>
    
    <div id="readability-page-1" class="page"><div>
			
<p>I continue to have <a href="https://probablydance.com/2022/02/19/reasons-why-babies-cry-in-the-first-three-months-how-to-tell-them-apart-and-what-to-do/">no time</a> for big programming projects, so here is a short blog post. Two years ago <a href="https://probablydance.com/2020/10/31/using-tla-in-the-real-world-to-understand-a-glibc-bug/">I looked into</a> a bug in the glibc implementation of condition variables: Sometimes pthread_cond_signal() doesn’t do anything, which can easily hang your program. The bug is still not fixed, partially because a mitigation patch was available right away that seemed to make it go away. Except that people kept on showing up in the <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=25847">bug report</a> saying that they still hit the bug sometimes, raising the suspicion that there might be a second bug. I finally got around to looking into this. I found that the mitigation patch only helps a little, it’s still the same bug, and the <a href="https://sourceware.org/pipermail/libc-alpha/2021-September/130840.html">patch I submitted</a> would actually fix it.</p>



<p>As I mentioned last time, one of the affected programming languages is Ocaml. Their master lock occasionally doesn’t notify a sleeper because sometimes pthread_cond_signal() doesn’t do anything. And then the whole process hangs forever, because that’s what happens when someone doesn’t get woken up in cooperative multithreading.</p>



<p>Checking this code in TLA+ happens to be easier than the code I was checking last time, because this results in a deadlock, which can be checked quickly. Last time I had to write temporal formulas, which make TLA+ run slowly, but a deadlock is easy to find: Find a state that has no successor states. All TLA+ has to do is enumerate all states. So whenever you can, try to write your TLA+ code so that it causes a deadlock on error.</p>



<p>The Ocaml <a href="https://github.com/ocaml-flambda/flambda-backend/blob/main/ocaml/otherlibs/systhreads/st_posix.h#L208">masterlock</a> can be directly translated into the PlusCal language of TLA+. It just wraps a normal mutex and adds a count of waiters, to make cooperative multithreading slightly more efficient: You can quickly check if anyone actually wants the lock, so you don’t have to give it up if nobody is waiting. For our purposes we don’t even need the yield function, just st_masterlock_acquire() and st_masterlock_release() ended up being enough. Then all we have to do is call those in a loop on multiple threads. Here is the code in PlusCal (it’s calling the mutex and condition-variable functions we wrote <a href="https://probablydance.com/2020/10/31/using-tla-in-the-real-world-to-understand-a-glibc-bug/">last time</a>)</p>


<div><pre title="">procedure acquire_masterlock()
{
acquire_masterlock_start:
  call lock_mutex();
acquire_masterlock_loop:
  while (busy)
  {
    waiters := waiters + 1;
    call cv_wait();
  acquire_lock_after_wait:
    waiters := waiters - 1;
  };
acquire_masterlock_after_loop:
  busy := TRUE;
  call unlock_mutex();
  return;
}

procedure release_masterlock()
{
release_masterlock_start:
  call lock_mutex();
release_masterlock_after_lock:
  busy := FALSE;
  call unlock_mutex();
release_masterlock_signal:
  call cv_signal();
  return;
};

fair process (Proc \in Procs)
variable num_loops = MaxNumLoops;
{
proc_start:
  while (num_loops &gt; 0)
  {
    num_loops := num_loops - 1;
    either { call acquire_masterlock(); }
    or     { goto proc_done; };
  proc_loop_done:
    call release_masterlock();
  };
proc_done:
  skip;
}
</pre></div>


<p>If you clicked on the github link, you will see that this is a direct translation. But the point is that it’s fairly straightforward code. Now we just have to run this with the magic number 3, three Procs and MaxNumLoops=3, and three hours later we have a trace that shows how you can hang even with the mitigation patch. (full reproduce steps at the bottom of this blog post)</p>



<p>One reason why I didn’t find this problem last time is that the trace is even more complicated. The mitigation patch does help for smaller traces, with fewer threads or smaller numbers for MaxNumLoops. To hit the bug you need a very specific long interleaving. This will be gibberish unless you have spent many hours studying the glibc condition variable code:</p>



<ol>
<li>Find the magic interleaving that makes you hit the “potential steal” code path in pthread_cond_wait(), discussed last time</li>



<li>Run the pthread_cond_broadcast() from the mitigation patch while no other thread is waiting, so that it will early-out without doing anything</li>



<li>Then signal again and trigger a call to quiesce_and_switch_g1()</li>



<li>At the same time as step 3 have a thread wait, consuming the leftover signal from the “potential steal” in step 1, then wait again</li>



<li>Now have step 3 finish with g_size=2 (because of the two waits) for the new g1, then signal after the switch, leaving g_size=1</li>



<li>Then have step 4 finish the second wait, consuming the signal from step 5</li>
</ol>



<p>You’re now left with g_size=1 for the new g1 even though nobody is waiting on it. The next call to pthread_cond_signal() just reduces g_size to 0 without waking anyone. Any signal after that will work again.</p>



<p>This is still really complicated for me, so I’m not sure exactly where the problem is, but it is suspicious that the pthread_cond_broadcast() in my trace would just early-out because nobody was waiting, so that the mitigation patch doesn’t result in any change to the state. If that can happen, TLA+ just had to find an interleaving where the lingering signal from the “potential steal” causes problems later.</p>



<p>Why didn’t I find this last time? Because I stopped looking after I had found the initial problem, and after the mitigation patch made the problem go away with my trace. Turns out I needed to run an even bigger job to find the problem with the mitigation patch.</p>



<p>So now the state of the glibc condition variable is</p>



<ol>
<li>It mostly works except occasionally a thread can take too long to wake up, which will cause it to steal a signal from a later wakeup. (and then the later thread doesn’t wake)</li>



<li>To fix that the code tries to detect whether we potentially stole a signal. But the response to that can leave the condition variable in a broken state, so that a later pthread_cond_signal() will signal on the wrong futex, causing sleepers to not be woken.</li>



<li>To fix that there is a mitigation patch which various distributions are running. But that mitigation patch has two issues:
<ul>
<li>it doesn’t work for the reasons that the author thinks it does (discussed <a href="https://probablydance.com/2020/10/31/using-tla-in-the-real-world-to-understand-a-glibc-bug/">last time</a>)</li>



<li>it sometimes doesn’t do anything, which allows the broken state to cause problems later. (discovered in this blog post)</li>
</ul>
</li>
</ol>



<p>Both of these fixes makes the issue less likely to happen, but also make it harder to understand (and debug). What’s the solution? I submitted <a href="https://sourceware.org/pipermail/libc-alpha/2021-September/130840.html">a patch</a> for this already a year ago: Fix the start of the chain of errors by broadening the scope of grefs, so that no waiter can ever be missed when we close a group. Then the “potential stealing” code path becomes unnecessary, and the bug in that path goes away, and the mitigation patch becomes unnecessary. The implementation also becomes simpler to reason about: My “patch” is actually a series of six patches in which the first one fixes the bug and the remaining five just clean up code.</p>



<p>If anyone has specific steps I can take to get this into glibc, I will try to do them. Last time I gave up a bit too easily because I got burned out on this problem after having spent way too many hours debugging it. Actually getting the fix in was too much extra work as a project to do in my spare time. But it’s been two years, so my burnout on this particular problem is gone and I’m game. As long as there are steps that actually work to get this in.</p>



<h2>Appendix: Detailed Steps to Reproduce</h2>



<ol>
<li>Download TLA+ <a rel="noreferrer noopener" href="https://github.com/tlaplus/tlaplus/releases/tag/v1.7.1#latest-tla-files" target="_blank">https://github.com/tlaplus/tlaplus/releases/tag/v1.7.1#latest-tla-files</a></li>



<li>Run the toolbox</li>



<li>Click “File -&gt; Open Spec -&gt; Add New Spec” then select <a href="https://github.com/skarupke/glibc_cv_tla_plus/blob/main/ocaml_mutex.tla">ocaml_mutex.tla</a></li>



<li>Click “TLC Model Checker -&gt; New Model”, click OK</li>



<li>In the model under
<ul>
<li>What is the behavior spec: leave as default “Spec”</li>



<li>What is the model?
<ul>
<li>UseSpinlockForCVMutex &lt;- TRUE</li>



<li>AlwaysSetGrefs &lt;- FALSE (this flag controls whether my patch should be used)</li>



<li>Procs &lt;- {P0, P1, P2}, also select “Set of model values” and “Symmetry set”</li>



<li>UseSpinlockForMutex &lt;- TRUE</li>



<li>UsePatch &lt;- TRUE (this flag controls whether the mitigation patch should be used)</li>



<li>MaxNumLoops &lt;- 3</li>
</ul>
</li>



<li>What to check?
<ul>
<li>Check “Deadlock” (should be checked by default)</li>



<li>Invariants: leave empty</li>



<li>Properties: leave empty</li>
</ul>
</li>
</ul>
</li>



<li>Click “TLC Model Checker -&gt; Run Model”</li>



<li>Watch the progress in the “Model Checking Results” column. Once per minute it should populate the table “Time, Diameter, States Found, Distinct States, Queue Size.” After ~2.5 hours, when “Diameter” reaches 342, a new panel should open up titled “TLC Errors”, and it should say “Deadlock reached.” in the first window.</li>



<li>Now you have 341 states to look at in the Error-Trace, in full detail. The “pc” variable shows you which line each process was on for every state. All other variables are also visible. They are a pretty direct translation from the C code. It should be possible to figure out by having the C code and TLA+ code side-by-side to see the minor differences. I uploaded a table with only the relevant information <a href="https://github.com/skarupke/glibc_cv_tla_plus/blob/main/second_bug.ods">here</a>. (this was from a run with slightly different source code, with the AlwaysSetGrefs commented out. This means your trace will be slightly different and the line numbers of the spreadsheet won’t align if you try to add more information. You’ll need to create your own by exporting the trace)</li>
</ol>



<p>(optional step before 6: Click on “Additional TLC Options” and increase “Number of worker threads” for your machine, also “Fraction of physical memory allocated to TLC” and set “Profiling” to “Off”, this should speed up the checking)</p>
					</div></div>
  </body>
</html>
