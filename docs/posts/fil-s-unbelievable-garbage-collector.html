<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fil-c.org/fugc">Original</a>
    <h1>Fil&#39;s Unbelievable Garbage Collector</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <main>


<p>Fil-C uses a <em>parallel concurrent on-the-fly grey-stack Dijkstra accurate non-moving</em> garbage collector called FUGC (Fil&#39;s Unbelievable Garbage Collector). You can find the source code for the collector itself in <a href="https://github.com/pizlonator/fil-c/blob/deluge/libpas/src/libpas/fugc.c">fugc.c</a>, though be warned, that code cannot possibly work without lots of support logic in the rest of the runtime and in the compiler.</p>

<p>Let&#39;s break down FUGC&#39;s features:</p>

<ul>
<li><p>Parallel: marking and sweeping happen in multiple threads, in parallel. The more cores you have, the
faster the collector finishes.</p></li>
<li><p>Concurrent: marking and sweeping happen on some threads other than the <em>mutator</em> threads (i.e. your
program&#39;s threads). Mutator threads don&#39;t have to stop and wait for the collector. The interaction
between the collector thread and mutator threads is mostly non-blocking (locking is only used on
allocation slow paths).</p></li>
<li><p>On-the-fly: there is no global stop-the-world, but instead we use
&#34;soft handshakes&#34; (aka &#34;ragged safepoints&#34;). This means that the GC may ask threads to do some work (like scan stack), but threads do this
asynchronously, on their own time, without waiting for the collector or other threads. The only &#34;pause&#34;
threads experience is the callback executed in response to the soft handshake, which does work bounded
by that thread&#39;s stack height. That &#34;pause&#34; is usually shorter than the slowest path you might take
through a typical <code>malloc</code> implementation.</p></li>
<li><p>Grey-stack: the collector assumes it must rescan thread stacks to fixpoint. That is, GC starts with
a soft handshake to scan stack, and then marks in a loop. If this
loop runs out of work, then FUGC does another soft handshake. If that reveals more objects, then
concurrent marking resumes. This prevents us from having a <em>load barrier</em> (no instrumentation runs
when loading a pointer from the heap into a local variable). Only a <em>store barrier</em> is
necessary, and that barrier is very simple. This fixpoint converges super quickly because all newly
allocated objects during GC are pre-marked.</p></li>
<li><p>Dijkstra: storing a pointer field in an object that&#39;s in the heap or in a global variable while FUGC
is in its marking phase causes the newly pointed-to object to get marked. This is called a <em>Dijkstra
barrier</em> and it is a kind of <em>store barrier</em>. Due to the grey stack, there is no load barrier like
in the <a href="https://lamport.azurewebsites.net/pubs/garbage.pdf">classic Dijkstra collector</a>. The FUGC store
barrier uses a compare-and-swap with relaxed memory ordering on the slowest path (if the GC is running
and the object being stored was not already marked).</p></li>
<li><p>Accurate: the GC accurately (aka precisely, aka exactly) finds all pointers to objects, nothing more,
nothing less. <code>llvm::FilPizlonator</code> ensures that the runtime always knows where the root pointers are
on the stack and in globals. The Fil-C runtime has a clever API and Ruby code generator for tracking
pointers in low-level code that interacts with pizlonated code. All objects know where their outgoing
pointers are - they can only be in the InvisiCap auxiliary allocation.</p></li>
<li><p>Non-moving: the GC doesn&#39;t move objects. This makes concurrency easy to implement and avoids
a lot of synchronization between mutator and collector. However, FUGC will &#34;move&#34; pointers to free
objects (it will repoint the <a href="https://fil-c.org/invisicaps.html">capability</a> pointer to the free singleton so it doesn&#39;t have to mark the
freed allocation).</p></li>
</ul>

<p>This makes FUGC an <em>advancing wavefront</em> garbage collector. Advancing wavefront means that the
mutator cannot create new work for the collector by modifying the heap. Once an
object is marked, it&#39;ll stay marked for that GC cycle. It&#39;s also an <em>incremental update</em> collector, since
some objects that would have been live at the start of GC might get freed if they become free during the
collection cycle.</p>

<p>FUGC relies on <em>safepoints</em>, which comprise:</p>

<ul>
<li><p><em>Pollchecks</em> emitted by the compiler. The <code>llvm::FilPizlonator</code> compiler pass emits pollchecks often enough that only a
bounded amount of progress is possible before a pollcheck happens. The fast path of a pollcheck is
just a load-and-branch. The slow path runs a <em>pollcheck callback</em>, which does work for FUGC.</p></li>
<li><p>Soft handshakes, which request that a pollcheck callback is run on all threads and then waits for
this to happen.</p></li>
<li><p><em>Enter</em>/<em>exit</em> functionality. This is for allowing threads to block in syscalls or long-running
runtime functions without executing pollchecks. Threads that are in the <em>exited</em> state will have
pollcheck callbacks executed by the collector itself (when it does the soft handshake). The only
way for a Fil-C program to block is either by looping while entered (which means executing a
pollcheck at least once per loop iteration, often more) or by calling into the runtime and then
exiting.</p></li>
</ul>

<p>Safepointing is essential for supporting threading (Fil-C supports pthreads just fine) while avoiding
a large class of race conditions. For example, safepointing means that it&#39;s safe to load a pointer from
the heap and then use it; the GC cannot possibly delete that memory until the next pollcheck or exit.
So, the compiler and runtime just have to ensure that the pointer becomes tracked for stack scanning at
some point between when it&#39;s loaded and when the next pollcheck/exit happens, and only if the pointer is
still live at that point.</p>

<p>The safepointing functionality also supports <em>stop-the-world</em>, which is currently used to implement
<code>fork(2)</code> and for debugging FUGC (if you set the <code>FUGC_STW</code> environment variable to <code>1</code> then the
collector will stop the world and this is useful for triaging GC bugs; if the bug reproduces in STW
then it means it&#39;s not due to issues with the store barrier). The safepoint infrastructure also allows
safe signal delivery; Fil-C makes it possible to use signal handling in a practical way. Safepointing is
a common feature of virtual machines that support multiple threads and accurate garbage collection,
though usually, they are only used to stop the world rather than to request asynchronous activity from all
threads. See <a href="https://foojay.io/today/the-inner-workings-of-safepoints/">here</a> for a write-up about
how OpenJDK does it. The Fil-C implementation is in <a href="https://github.com/pizlonator/fil-c/blob/deluge/libpas/src/libpas/filc_runtime.c"><code>filc_runtime.c</code></a>.</p>

<p>Here&#39;s the basic flow of the FUGC collector loop:</p>

<ol>
<li>Wait for the GC trigger.</li>
<li>Turn on the store barrier, then soft handshake with a no-op callback.</li>
<li>Turn on black allocation (new objects get allocated marked), then soft handshake with a callback
that resets thread-local caches.</li>
<li>Mark global roots.</li>
<li>Soft handshake with a callback that requests stack scan and another reset of thread-local caches.
If all collector mark stacks are empty after this, go to step 7.</li>
<li>Tracing: for each object in the mark stack, mark its outgoing references (which may grow the mark
stack). Do this until the mark stack is empty. Then go to step 5.</li>
<li>Turn off the store barrier and prepare for sweeping, then soft handshake to reset thread-local
caches again.</li>
<li>Perform the sweep. During the sweep, objects are allocated black if they happen to be allocated out
of not-yet-swept pages, or white if they are allocated out of alraedy-swept pages.</li>
<li>Victory! Go back to step 1.</li>
</ol>

<p>If you&#39;re familiar with the literature, FUGC is sort of like the DLG (Doligez-Leroy-Gonthier) collector
(published in <a href="https://xavierleroy.org/publi/concurrent-gc.pdf">two</a>
<a href="http://moscova.inria.fr/~doligez/publications/doligez-gonthier-popl-1994.pdf">papers</a> because they
had a serious bug in the first one), except it uses the Dijkstra barrier and a grey stack, which
simplifies everything but isn&#39;t as academically pure (FUGC fixpoints, theirs doesn&#39;t). I first came
up with the grey-stack Dijkstra approach when working on
<a href="http://www.filpizlo.com/papers/pizlo-eurosys2010-fijivm.pdf">Fiji VM</a>&#39;s CMR and
<a href="http://www.filpizlo.com/papers/pizlo-pldi2010-schism.pdf">Schism</a> garbage collectors. The main
advantage of FUGC over DLG is that it has a simpler (cheaper) store barrier and it&#39;s a slightly more
intuitive algorithm. While the fixpoint seems like a disadvantage, in practice it converges after a few
iterations.</p>

<p>Additionally, FUGC relies on a sweeping algorithm based on bitvector SIMD. This makes sweeping insanely
fast compared to marking. This is made thanks to the
<a href="https://github.com/pizlonator/fil-c/blob/deluge/libpas/src/libpas/verse_heap.h">Verse heap config</a>
that I added to
<a href="https://github.com/WebKit/WebKit/blob/main/Source/bmalloc/libpas/Documentation.md">libpas</a>. FUGC
typically spends &lt;5% of its time sweeping.</p>

<h2>Bonus Features</h2>

<p>FUGC supports a most of C-style, Java-style, and JavaScript-style memory management. Let&#39;s break down what that means.</p>

<h3>Freeing Objects</h3>

<p>If you call <code>free</code>, the runtime will flag the object as free and all subsequent accesses to the object will trap. Additionally, FUGC will not scan outgoing references from the object (since they cannot be accessed anymore).</p>

<p>Also, FUGC will redirect all capability pointers (<em>lower</em>s in <a href="https://fil-c.org/invisicaps.html">InvisiCaps</a> jargon) to free objects to point at the free singleton object instead. This allows freed object memory to really be reclaimed.</p>

<p>This means that freeing objects can be used to prevent <em>GC-induced leaks</em>. Surprisingly, a program that works fine with <code>malloc</code>/<code>free</code> (no leaks, no crashes) that gets converted to GC the naive way (<code>malloc</code> allocates from the GC and <code>free</code> is a no-op) may end up leaking due to dangling pointers that the program never accesses. Those dangling pointers will be treated as live by the GC. In FUGC, if you freed those pointers, then FUGC will really kill them.</p>

<h3>Finalizers</h3>

<p>FUGC supports finalizer queues using the <code>zgc_finq</code> API in <a href="https://github.com/pizlonator/fil-c/blob/deluge/filc/include/stdfil.h">stdfil.h</a>. This feature allows you to implement finalizers in the style of Java, except that you get to set up your own finalizer queues and choose which thread processes them.</p>

<h3>Weak References</h3>

<p>FUGC supports weak references using the <code>zweak</code> API in <a href="https://github.com/pizlonator/fil-c/blob/deluge/filc/include/stdfil.h">stdfil.h</a>. Weak references work just like the weak references in Java, except there are no reference queues. Also, Fil-C </p>

<h3>Weak Maps</h3>

<p>FUGC supports weak maps using the <code>zweak_map</code> API in <a href="https://github.com/pizlonator/fil-c/blob/deluge/filc/include/stdfil.h">stdfil.h</a>. This API works almost exactly like the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a>, except that Fil-C&#39;s weak maps allow you to iterate all of their elements and get a count of elements.</p>



<p>FUGC allows Fil-C to give the strongest possible guarantees on misuse of <code>free</code>:</p>

<ul>
<li><p>Freeing an object and then accessing it is guaranteed to result in a trap. Unlike tag-based approaches, which will trap on use after free until until memory reclamation is forced, FUGC means you will trap even after memory is reclaimed (due to <em>lower</em> repointing to the free singleton).</p></li>
<li><p>Freeing an object twice is guaranteed to result in a trap.</p></li>
<li><p>Failing to free an object means the object gets reclaimed for you.</p></li>
</ul>
        </main>
    </div></div>
  </body>
</html>
