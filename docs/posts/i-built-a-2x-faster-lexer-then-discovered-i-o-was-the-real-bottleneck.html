<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://modulovalue.com/blog/syscall-overhead-tar-gz-io-performance/">Original</a>
    <h1>I built a 2x faster lexer, then discovered I/O was the real bottleneck</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>I built an ARM64 assembly lexer (well, I generated one from my own parser generator, but this post is not about that) that processes Dart code 2x faster than the official scanner, a result I achieved using <a href="https://modulovalue.com/blog/statistical-methods-for-reliable-benchmarks/">statistical methods to reliably measure small performance differences</a>. Then I benchmarked it on 104,000 files and discovered my lexer was not the bottleneck. I/O was. This is the story of how I accidentally learned why <a href="https://pub.dev">pub.dev</a> stores packages as tar.gz files.</p>

<h2 id="the-setup">The setup</h2>

<p>I wanted to benchmark my lexer against the official Dart scanner. The pub cache on my machine had 104,000 Dart files totaling 1.13 GB, a perfect test corpus. I wrote a benchmark that:</p>

<ol>
  <li>Reads each file from disk</li>
  <li>Lexes it</li>
  <li>Measures time separately for I/O and lexing</li>
</ol>

<p>Simple enough.</p>

<h2 id="the-first-surprise-lexing-is-fast">The first surprise: lexing is fast</h2>

<p>Here are the results:</p>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>ASM Lexer</th>
      <th>Official Dart</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Lex time</td>
      <td>2,807 ms</td>
      <td>6,087 ms</td>
    </tr>
    <tr>
      <td>Lex throughput</td>
      <td>402 MB/s</td>
      <td>185 MB/s</td>
    </tr>
  </tbody>
</table>

<p>My lexer was 2.17x faster. Success! But wait:</p>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>ASM Lexer</th>
      <th>Official Dart</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>I/O time</td>
      <td>14,126 ms</td>
      <td>14,606 ms</td>
    </tr>
    <tr>
      <td><strong>Total time</strong></td>
      <td><strong>16,933 ms</strong></td>
      <td><strong>20,693 ms</strong></td>
    </tr>
    <tr>
      <td><strong>Total speedup</strong></td>
      <td><strong>1.22x</strong></td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<p>The total speedup was only 1.22x. My 2.17x lexer improvement was being swallowed by I/O. Reading files took 5x longer than lexing them.</p>

<h2 id="the-second-surprise-the-ssd-is-not-the-bottleneck">The second surprise: the SSD is not the bottleneck</h2>

<p>My MacBook has an NVMe SSD that can read at 5-7 GB/s. I was getting 80 MB/s. That is 1.5% of the theoretical maximum.</p>

<p>The problem was not the disk. It was the syscalls.</p>

<p>For 104,000 files, the operating system had to execute:</p>
<ul>
  <li>104,000 <code>open()</code> calls</li>
  <li>104,000 <code>read()</code> calls</li>
  <li>104,000 <code>close()</code> calls</li>
</ul>

<p>That is over 300,000 syscalls. Each syscall involves:</p>
<ul>
  <li>A context switch from user space to kernel space</li>
  <li>Kernel bookkeeping and permission checks</li>
  <li>A context switch back to user space</li>
</ul>

<p>Each syscall costs roughly 1-5 microseconds. Multiply that by 300,000 and you get 0.3-1.5 seconds of pure overhead, before any actual disk I/O happens. Add filesystem metadata lookups, directory traversal, and you understand where the time goes.</p>

<p>I tried a few things that did not help much. Memory-mapping the files made things worse due to the per-file mmap/munmap overhead. Replacing Dart&#39;s file reading with direct FFI syscalls (open/read/close) only gave a 5% improvement. The problem was not Dart&#39;s I/O layer, it was the sheer number of syscalls.</p>

<h2 id="the-hypothesis">The hypothesis</h2>

<p>I have mirrored pub.dev several times in the past and noticed that all packages are stored as tar.gz archives. I never really understood why, but this problem reminded me of that fact. If syscalls are the problem, the solution is fewer syscalls. What if instead of 104,000 files, I had 1,351 files (one per package)?</p>

<p>I wrote a script to package each cached package into a tar.gz archive:</p>

<div><div><pre><code>104,000 individual files -&gt; 1,351 tar.gz archives
1.13 GB uncompressed     -&gt; 169 MB compressed (6.66x ratio)
</code></pre></div></div>

<h2 id="the-results">The results</h2>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Individual Files</th>
      <th>tar.gz Archives</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Files/Archives</td>
      <td>104,000</td>
      <td>1,351</td>
    </tr>
    <tr>
      <td>Data on disk</td>
      <td>1.13 GB</td>
      <td>169 MB</td>
    </tr>
    <tr>
      <td>I/O time</td>
      <td>14,525 ms</td>
      <td>339 ms</td>
    </tr>
    <tr>
      <td>Decompress time</td>
      <td>-</td>
      <td>4,507 ms</td>
    </tr>
    <tr>
      <td>Lex time</td>
      <td>2,968 ms</td>
      <td>2,867 ms</td>
    </tr>
    <tr>
      <td><strong>Total time</strong></td>
      <td><strong>17,493 ms</strong></td>
      <td><strong>7,713 ms</strong></td>
    </tr>
  </tbody>
</table>

<p>The I/O speedup was <strong>42.85x</strong>. Reading 1,351 sequential files instead of 104,000 random files reduced I/O from 14.5 seconds to 339 milliseconds.</p>

<p>The total speedup was <strong>2.27x</strong>. Even with decompression overhead, the archive approach was more than twice as fast.</p>

<h2 id="breaking-down-the-numbers">Breaking down the numbers</h2>

<h3 id="io-14525-ms-to-339-ms">I/O: 14,525 ms to 339 ms</h3>

<p>This is the syscall overhead in action. Going from 300,000+ syscalls to roughly 4,000 syscalls (open/read/close for 1,351 archives) eliminated most of the overhead.</p>

<p>Additionally, reading 1,351 files sequentially is far more cache-friendly than reading 104,000 files scattered across the filesystem. The OS can prefetch effectively, the SSD can batch operations, and the page cache stays warm.</p>

<h3 id="decompression-4507-ms">Decompression: 4,507 ms</h3>

<p>gzip decompression ran at about 250 MB/s using the <code>archive</code> package from pub.dev. This is now the new bottleneck. I did not put much effort into optimizing decompression, an FFI-based solution using native zlib could be significantly faster. Modern alternatives like lz4 or zstd might also help.</p>

<h3 id="compression-ratio-666x">Compression ratio: 6.66x</h3>

<p>Source code compresses well. The 1.13 GB of Dart code compressed to 169 MB. This means less data to read from disk, which helps even on fast SSDs.</p>

<h2 id="why-pubdev-uses-targz">Why pub.dev uses tar.gz</h2>

<p>
  <img src="https://modulovalue.com/assets/pub-dev-versions-page.png" alt="pub.dev versions page with download button"/>
</p>

<p>
  <img src="https://modulovalue.com/assets/pub-dev-tar-gz-download.png" alt="pub.dev package download showing flame-1.34.0.tar.gz"/>
</p>

<p>This experiment accidentally explains the pub.dev package format. When you run <code>dart pub get</code>, you download tar.gz archives, not individual files. The reasons are now obvious:</p>

<ol>
  <li><strong>Fewer HTTP requests.</strong> One request per package instead of hundreds.</li>
  <li><strong>Bandwidth savings.</strong> 6-7x smaller downloads.</li>
  <li><strong>Faster extraction.</strong> Sequential writes beat random writes.</li>
  <li><strong>Reduced syscall overhead.</strong> Both on the server (fewer files to serve) and the client (fewer files to write).</li>
  <li><strong>Atomicity.</strong> A package is either fully downloaded or not. No partial states.</li>
</ol>

<p>The same principles apply to npm (tar.gz), Maven (JAR/ZIP), PyPI (wheel/tar.gz), and virtually every package manager.</p>

<h2 id="the-broader-lesson">The broader lesson</h2>

<p>Modern storage is fast. NVMe SSDs can sustain gigabytes per second. But that speed is only accessible for sequential access to large files. The moment you introduce thousands of small files, syscall overhead dominates.</p>

<p>This matters for:</p>

<ul>
  <li><strong>Build systems.</strong> Compiling a project with 10,000 source files? The filesystem overhead might exceed the compilation time.</li>
  <li><strong>Log processing.</strong> Millions of small log files? Concatenate them. Claude uses <a href="https://jsonlines.org/">JSONL</a> for this reason.</li>
  <li><strong>Backup systems.</strong> This is why rsync and tar exist.</li>
</ul>

<h2 id="what-i-would-do-differently">What I would do differently</h2>

<p>If I were optimizing this further:</p>

<ol>
  <li><strong>Use zstd instead of gzip.</strong> 4-5x faster decompression with similar compression ratios.</li>
  <li><strong>Use uncompressed tar for local caching.</strong> Skip decompression entirely, still get the syscall reduction.</li>
  <li><strong>Parallelize with isolates.</strong> Multiple cores decompressing multiple archives simultaneously.</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>I set out to benchmark a lexer and ended up learning about syscall overhead. The lexer was 2x faster. The I/O optimization was 43x faster.</p>

<hr/>

<h2 id="addendum-reader-suggestions">Addendum: Reader Suggestions</h2>

<h3 id="linux-specific-optimizations">Linux-Specific Optimizations</h3>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/comment/nzdms8e/">servermeta_net pointed out</a> two Linux-specific approaches: disabling speculative execution mitigations (which could improve performance in syscall-heavy scenarios) and using io_uring for asynchronous I/O. I ran these benchmarks on macOS, which does not support io_uring, but these Linux capabilities are intriguing. A follow-up post exploring how I/O performance can be optimized on Linux may be in order.</p>

<h3 id="macos-specific-optimizations">macOS-Specific Optimizations</h3>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/comment/nze8xm7/">tsanderdev pointed out</a> that macOS&#39;s <code>kqueue</code> could potentially improve performance for this workload. While <code>kqueue</code> is not equivalent to Linux&#39;s <code>io_uring</code> (it lacks the same syscall batching through a shared ring buffer), it may still offer some improvement over synchronous I/O. I have not benchmarked this yet.</p>

<h3 id="sqlite-as-an-alternative">SQLite as an Alternative</h3>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/comment/nze0jrf/">tsanderdev mentioned</a> that this is also why SQLite can be much faster than a directory with lots of small files. I had completely forgotten about SQLite as an option. Storing file contents in a SQLite database would eliminate the syscall overhead while providing random access to individual files, something tar.gz does not offer.</p>

<p>This also explains something I have heard multiple times: Apple uses SQLite extensively for its applications, <a href="https://news.ycombinator.com/item?id=26218218">essentially simulating a filesystem within SQLite databases</a>. If 100,000 files on a modern Mac with NVMe storage takes 14 seconds to read, imagine what it was like on older, slower machines. The syscall overhead would have been even more punishing. Using SQLite instead of the filesystem lets them avoid those syscalls entirely. This is worth exploring.</p>

<h3 id="skip-the-cleanup-syscalls">Skip the Cleanup Syscalls</h3>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/comment/nzeaegy/">matthieum suggested</a> a common trick used by batch compilers: never call <code>free</code>, <code>close</code>, or <code>munmap</code>, and instead let the OS reap all resources when the process ends. For a one-shot batch process like a compiler (or a lexer benchmark), there is no point in carefully releasing resources that the OS will reclaim anyway.</p>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/comment/nzguiwt/">GabrielDosReis added a caveat</a>: depending on the workload, you might actually need to call <code>close</code>, or you could run out of file descriptors. On macOS, you can check your limits with:</p>

<div><div><pre><code>$ launchctl limit maxfiles
maxfiles    256            unlimited

$ sysctl kern.maxfilesperproc
kern.maxfilesperproc: 61440
</code></pre></div></div>

<p>The first number (256) is the soft limit per process, the second is the hard limit. <code>kern.maxfilesperproc</code> shows the kernel&#39;s per-process maximum. With 104,000 files, skipping <code>close</code> calls would exhaust even the maximum limit.</p>

<p>There is even a further optimization: use a wrapper process. The wrapper launches a worker process that does all the work. When the worker signals completion (via stdout or a pipe), the wrapper terminates immediately without waiting for its detached child. Any script waiting on the wrapper can now proceed, while the OS asynchronously reaps the worker&#39;s resources in the background. I had not considered this approach before, but it seems worth trying.</p>

<h3 id="linker-strategies-for-fast-exits">Linker Strategies for Fast Exits</h3>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/comment/nzrrrnk/">MaskRay added context</a> about how production linkers handle this exact problem. The <a href="https://github.com/rui314/mold">mold linker</a> uses the wrapper process approach mentioned above, forking a child to do all the work while the parent exits immediately after the child signals completion. This lets build systems proceed without waiting for resource cleanup. The <code>--no-fork</code> flag disables this behavior for debugging. The <a href="https://github.com/nickelpacket/wild">wild linker</a> follows the same pattern.</p>

<p><a href="https://github.com/llvm/llvm-project/tree/main/lld">lld</a> takes a different approach with two targeted hacks: <a href="https://github.com/llvm/llvm-project/blob/a72958a95dcb7d815c01e20cc819532151d1856d/lld/Common/Filesystem.cpp#L44">async unlink</a> to remove old output files in a background thread, and <a href="https://github.com/llvm/llvm-project/blob/a72958a95dcb7d815c01e20cc819532151d1856d/lld/Common/ErrorHandler.cpp#L108">calling <code>_exit</code> instead of <code>exit</code></a> to skip the C runtime&#39;s cleanup routines (unless <code>LLD_IN_TEST</code> is set for testing).</p>

<p>MaskRay notes a tradeoff with the wrapper process approach: when the heavy work runs in a child process, the parent process of the linker (typically a build system) cannot accurately track resource usage of the actual work. This matters for build systems that monitor memory consumption or CPU time.</p>

<h3 id="why-pubdev-actually-uses-targz">Why pub.dev Actually Uses tar.gz</h3>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/comment/nzggloc/">Bob Nystrom from the Dart team clarified</a> that my speculation about pub.dev&#39;s format choice was partially wrong. Fewer HTTP requests and bandwidth savings definitely factored into the decision, as did reduced storage space on the server. Atomicity is important too, though archives do not fully solve the problem since downloads and extracts can still fail. However, it is unlikely that the I/O performance benefits (faster extraction, reduced syscall overhead) were considered: pub extracts archives immediately after download, the extraction benefit only occurs once during <code>pub get</code>, that single extraction is a tiny fraction of a fairly expensive process, and pub never reads the files again except for the pubspec. The performance benefit I measured only applies when repeatedly reading from archives, which is not how pub works.</p>

<p>This raises an interesting question: what if pub did not extract archives at all? For a clean (non-incremental) compilation of a large project like the Dart Analyzer with hundreds of dependencies, the compiler needs to access thousands of files across many packages. If packages remained in an archive format with random access support (like ZIP), the syscall overhead from opening and closing all those files could potentially be reduced. Instead of thousands of open/read/close syscalls scattered across the filesystem, you would have one open call per package archive, then seeks within each archive. Whether the decompression overhead would outweigh the syscall savings is unclear, but it might be worth exploring for build systems where clean builds of large dependency trees are common.</p>

<h3 id="use-dartio-for-gzip-instead-of-packagearchive">Use dart:io for gzip Instead of package:archive</h3>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/comment/nzi3muf/">Simon Binder pointed out</a> that dart:io already includes gzip support backed by zlib, so there is no need to use package:archive for decompression. Since dart:io does not support tar archives, I used package:archive for everything and did not think of mixing in dart:io&#39;s gzip support separately. Using dart:io&#39;s <code>GZipCodec</code> for decompression while only relying on package:archive for tar extraction could yield better performance. I will try this approach when I attempt to lex a bigger corpus.</p>

<h3 id="tar-vs-zip-sequential-vs-random-access">TAR vs ZIP: Sequential vs Random Access</h3>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/comment/nzih9eh/">vanderZwan pointed out</a> that ZIP files could provide SQLite-like random access benefits. This highlights a fundamental architectural difference between TAR and ZIP:</p>

<p><strong>TAR</strong> was designed in 1979 for sequential tape drives. Each file&#39;s metadata is stored in a header immediately before its contents, with no central index. To find a specific file, you must read through the archive sequentially. When compressed as tar.gz, the entire stream is compressed together, so accessing any file requires decompressing everything before it. The format was standardized by POSIX (POSIX.1-1988 for ustar, POSIX.1-2001 for pax), is well-documented, and preserves Unix file attributes fully.</p>

<p><strong>ZIP</strong> was designed in 1989 with a central directory stored at the end of the archive. This directory contains offsets to each file&#39;s location, enabling random access: read the central directory once, then seek directly to any file. Each file is compressed individually, so you can decompress just the file you need. This is why JAR files, OpenDocument files, and EPUB files all use the ZIP format internally.</p>

<table>
  <thead>
    <tr>
      <th>Aspect</th>
      <th>TAR</th>
      <th>ZIP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Random access</td>
      <td>No (sequential only)</td>
      <td>Yes (central directory)</td>
    </tr>
    <tr>
      <td>Standardization</td>
      <td>POSIX standard</td>
      <td>PKWARE-controlled specification</td>
    </tr>
    <tr>
      <td>Unix permissions</td>
      <td>Fully preserved</td>
      <td>Limited support</td>
    </tr>
    <tr>
      <td>Compression</td>
      <td>External (gzip, zstd, etc.)</td>
      <td>Built-in, per-file</td>
    </tr>
  </tbody>
</table>

<p>There seems to be no widely-adopted Unix-native format that combines random access with proper Unix metadata support. TAR handles sequential access with full Unix semantics. ZIP handles random access but originated from MS-DOS and has inconsistent Unix permission support. What we lack is something like &#34;ZIP for Unix&#34;: random access with proper ownership, permissions, extended attributes, and ACLs.</p>

<p>The closest answer is <a href="http://dar.linux.free.fr/">dar (Disk ARchive)</a>, designed explicitly as a tar replacement with modern features. It stores a catalogue index at the end of the archive for O(1) file extraction, preserves full Unix metadata including extended attributes and ACLs, supports per-file compression with choice of algorithm, and can isolate the catalogue separately for fast browsing without the full archive. However, dar has not achieved the ubiquity of tar or zip.</p>

<p>For my lexer benchmark, random access would not help since I process all files anyway. But for use cases requiring access to specific files within an archive, this architectural distinction matters.</p>

<hr/>

<p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1qbvvpn/i_built_a_2x_faster_lexer_then_discovered_io_was/">Discuss on r/ProgrammingLanguages</a></p>

  </div><p>I write occasionally. Subscribe if you want to know when.</p></div>
  </body>
</html>
