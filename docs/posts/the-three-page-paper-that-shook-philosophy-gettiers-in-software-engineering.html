<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jsomers.net/blog/gettiers">Original</a>
    <h1>The three-page paper that shook philosophy: Gettiers in software engineering</h1>
    
    <div id="readability-page-1" class="page"><div>
              <p>In 1963, the philosopher Edmund Gettier published a three-page <a href="http://www-bcf.usc.edu/~kleinsch/Gettier.pdf">paper</a> in the journal <em>Analysis</em> that quickly became a classic in the field. Epistemologists going back to the Greeks had debated what it meant to know something, and in the Enlightenment, a definition was settled upon: to know something is to have a <em>justified true belief</em> about it:</p>

<ul>
<li><strong>justified</strong> in the sense of deriving from evidence</li>
<li><strong>true</strong>, because it doesn&#39;t make sense to &#34;know&#34; a falsehoood</li>
<li><strong>belief</strong>, i.e., a proposition in your head</li>
</ul>

<p>Gettier, in his tiny paper, upended the consensus. He asked &#34;Is Justified True Belief Knowledge?&#34; and offered three cases---soon to be known as &#34;the Gettier cases&#34;---that suggested you could have a JTB about something and yet still we would want to say you didn&#39;t <em>know</em> it. For that, he earned lasting fame, and his paper generated a literature <a href="https://en.wikipedia.org/wiki/Gettier_problem">all its own</a>.</p>

<h2>A Gettier case</h2>

<p>Supppose you&#39;re standing in a field and off in the distance you see a cow. But suppose that what you&#39;re actually looking at isn&#39;t a cow, it&#39;s just a convincingly lifelike model of a cow made out of papier-mâché. You&#39;re not seeing a cow, you&#39;re seeing the model. But then finally suppose that right behind the papier-mâché cow is a real cow!</p>

<p>On the one hand, you have a justified true belief that &#34;there is a cow in the field&#34;: (1) you believe there&#39;s a cow in the field; (2) that belief didn&#39;t come from nowhere, but is justified by your seeing something that looks exactly like a cow; (3) and there is, in fact, a cow in the field. Still, we wouldn&#39;t want to say that you <em>know</em> there&#39;s a cow in the field, because in a sense you got lucky: by a strange coincidence, there happened to be a real cow there---a cow you knew nothing about.</p>

<h2>In software engineering</h2>

<p>At my old company, <a href="http://genius.com">Genius</a>, the CTO---who&#39;d studied philosophy as an undergrad---was obsessed with these Gettier cases. He called them &#34;gettiers&#34; for short. So we used to talk about gettiers all the time, no doubt in part just because it felt clever to talk about them, but also because when you&#39;re a programmer, you run into things that feel like Gettier cases with unusual frequency. And once you have a name for them, you start seeing them everywhere.</p>

<p>Here&#39;s a recent example. I was working on a web application that used a client-side framework that had been developed in-house. My app was a little search engine, and in my latest pull request, I&#39;d made it so that when you hit Enter in the search field, the field lost focus, so that folks who like to browse the web via their keyboard wouldn&#39;t have to manually escape from the input box.</p>

<p>When I released the new version, I noticed that I&#39;d broken the autofocusing of the search field that was supposed to happen on pageload. I started poking around, only to discover that I couldn&#39;t seem to get the correct behavior back. No matter what code I changed, which lines I commented out, how many times I hard-refreshed the browser, etc., I couldn&#39;t get the autofocus to work.</p>

<p>What had actually happened is that a coworker of mine had made a change to the framework itself, which changed how certain events were bound to the root DOM element, and as a result broke the &#34;autofocus&#34; attribute. At some point, I did a routine rebase on top of this change (and many other unrelated changes). Which meant that when I deployed my little pull request, I was <em>also</em> deploying a bug I had nothing to do with---one that ended up breaking autofocus. It only appeared as though my changes caused the problem, because I&#39;d edited some code having to do with focus in the search field.</p>

<p>Note that I had a justified belief that &#34;the pull request I just deployed broke autofocus on the production site,&#34; and in fact my change <em>did</em> break it---making the belief true. But the break actually happened for a completely different reason!</p>

<p>(Yes, I should have caught the bug in testing, and in fact I did notice some odd behavior. But making software is hard!)</p>

<p>Here&#39;s another example. (This one&#39;s from a long time ago, so the details might be a bit off.) A user once reported that on-site messages were no longer generating email notifications, and I was asked to investigate. Soon, I discovered that someone had recently pushed a change to the code that handled emails in our web app; the change seemed to introduce a bug that was responsible for the broken behavior. But---gettier!---the email service that the code relied on had itself gone down, at almost the exact same time that the change was released. I could have had a JTB that the code change had caused the emails to stop delivering, but still we wouldn&#39;t want to say I &#34;knew&#34; this was the cause, because it was actually the service outage that was directly responsible.</p>

<h2>A new term of art</h2>

<p>A philosopher might say that these aren&#39;t bona fide Gettier cases. True gettiers are rare. But it&#39;s still a useful idea, and it became something of a term of art at Genius---and has stuck with me since---because it&#39;s a good name for one of the trickiest situations you can get into as a programmer: a problem has multiple potential causes, and you have every reason to believe in one of them, even though another is secretly responsible.</p>

<p>Having a term for these tricky cases allows you, I think, to be ever-so-slightly more alert to them. You can be a better developer this way. As I&#39;ve spent more time writing software, I&#39;ve gotten better at sensing when my assumptions are probably wrong---when something gettieresque might be going on: have I forgotten to clear the cache? Am I working off the wrong branch? Am I even hitting this code path?</p>

<p>Software is a complex and ephemeral business. More than most people, developers are daily faced with bizarre epistemological problems. It helps to be able to distinguish a cow in the field from, well, a gettier.</p>
          </div></div>
  </body>
</html>
