<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ehayes.page/posts/breakpoints/">Original</a>
    <h1>Breakpoints</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’ve been working on a profiler and while I cook up a complete project I thought I’d share some things I’ve learned. Specifically, I’ve learned a lot about ptrace and breakpoints.</p><p>This will be a pretty technical post so if that isn’t your thing (Mom) you may want to wait for a future post.</p><p>The complete code used in this post can be found <a href="https://github.com/ehayes2000/breakpoints">here</a>.</p><h2 id="ptrace">ptrace</h2><p>Ptrace (short for process trace) is a system call and as described by the man page: “provides means by which one process may observe and control the execution of another”. This functionality is leveraged to build powerful tools like <code>gdb</code>, <code>strace</code>, <code>valgrind</code>, <code>perf</code>, and many more.</p><p>Ptrace has this signature:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>long</span> <span>ptrace</span><span>(</span><span>enum</span> <span>__ptrace_request</span> <span>op</span><span>,</span> <span>pid_t</span> <span>pid</span><span>,</span>
</span></span><span><span>  <span>void</span> <span>*</span><span>addr</span><span>,</span> <span>void</span> <span>*</span><span>data</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>The first argument is an enum option that may be one of 70 options and drastically changes the behavior and usage of the function.</p><h2 id="breakpoints">Breakpoints</h2><p>A breakpoint is a point in process execution that stops execution. In debuggers breakpoints are usually set in source code then when the program hits a breakpoint control is handed over to the user through some nice interface. In a profiler, a breakpoint may be used to collect statistics at some defined set of points like at the beginning and end of function calls.</p><p>Breakpoints are implemented by CPUs as instructions that cause a process to stop with a <code>SIGTRAP</code>. My Macbook has an ARM-based CPU, so the break instruction is <code>brk #0</code> or <code>0xd4200000</code>. On an x86 machine breakpoints are implemented with the <code>int 3</code> instruction.</p><h2 id="the-plan">The plan</h2><p>Implement breakpoints on a process using ptrace:</p><ol><li>Configure the child to be traced by its parent</li><li>Find the instruction we want to stop on</li><li>Set a breakpoint using <code>PTRACE_PEEKTEXT</code> and <code>PTRACE_POKETEXT</code></li><li>Start the child process and catch our breakpoint</li><li>Disable the breakpoint</li><li>Resume the child process</li></ol><p>This is a simple demonstration of how ptrace can be used to stop at predefined points in a program.</p><h3 id="1-config-child-and-parent">1. Config child and parent</h3><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>int</span> <span>main</span><span>(){</span>
</span></span><span><span>  <span>pid_t</span> <span>child</span> <span>=</span> <span>fork</span><span>();</span>
</span></span><span><span>  <span>if</span> <span>(</span><span>child</span> <span>==</span> <span>0</span><span>){</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>ptrace</span><span>(</span><span>PTRACE_TRACEME</span><span>,</span> <span>0</span><span>,</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>NULL</span><span>,</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>NULL</span><span>)</span> <span>&lt;</span> <span>0</span><span>){</span>
</span></span><span><span>      <span>perror</span><span>(</span><span>&#34;ptrace(TRACEME)&#34;</span><span>);</span>
</span></span><span><span>      <span>exit</span><span>(</span><span>errno</span><span>);</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>raise</span><span>(</span><span>SIGSTOP</span><span>);</span>
</span></span><span><span>    <span>the_joker</span><span>();</span>
</span></span><span><span>    <span>exit</span><span>(</span><span>0</span><span>);</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>...</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>This first block of code creates a child process that calls ptrace with <code>PTRACE_TRACEME</code> which sets up this process to be traced by its parent. The child process then stops itself to give the parent a chance to setup breakpoints. By default calling exec will also stop a process that has called ptrace with <code>PTRACE_TRACEME</code>.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>waitpid</span><span>(</span><span>child</span><span>,</span> <span>&amp;</span><span>status</span><span>,</span> <span>0</span><span>);</span>
</span></span><span><span>  <span>if</span> <span>(</span><span>!</span><span>WIFSTOPPED</span><span>(</span><span>status</span><span>)){</span>
</span></span><span><span>    <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;whats he up to??&#34;</span><span>);</span>
</span></span><span><span>    <span>exit</span><span>(</span><span>1</span><span>);</span>
</span></span><span><span>  <span>}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Back in the parent process, we can wait for the child to stop.</p><h3 id="2-find-a-breakpoint">2. Find a breakpoint</h3><p>Now we’re ready to figure out where to insert our breakpoint. If we look at the child process code we can see that the joker is up to no good.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>void</span> <span>the_joker</span><span>(){</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;I&#39;m going to break open arkham asylum and no one can stop me!</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;collecting cards ...</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;gathering cronies...</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;plotting route...</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;loading unmarked van...</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;driving to asylum...</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;melting gate with acid...</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;escaping with inmates...</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;we live in a society!!!</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>For dramatic effect let’s stop him right before he melts down the gate with acid. It would be nice if we could just directly use a line number in ptrace, but it’s not that simple. Instead, we need an address to write our instruction to. This address can be computed by finding an offset in the compiled binary then adding the base address of our process. For this example I’ll use gdb to find an offset. In a more modular program, this would be done by reading DWARF debug information from the compiled binary.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>$ gdb path/to/joker
</span></span><span><span><span>(</span>gdb<span>)</span> disassemble /m the_joker
</span></span><span><span>...
</span></span><span><span><span>26</span>        printf<span>(</span><span>&#34;melting gate with acid...\n&#34;</span><span>)</span><span>;</span>
</span></span><span><span>   0x0000000000000c44 &lt;+80&gt;:    adrp    x0, 0x1000 &lt;main+908&gt;
</span></span><span><span>   0x0000000000000c48 &lt;+84&gt;:    add     x0, x0, <span>#0x3c8</span>
</span></span><span><span>   0x0000000000000c4c &lt;+88&gt;:    bl      0xa60 &lt;puts@plt&gt;
</span></span><span><span>...
</span></span></code></pre></td></tr></tbody></table></div></div><p>Disassembling the binary with gdb shows us that each printf corresponds to three assembly instructions. I’m going to place a breakpoint on the call to <code>puts</code> at <code>0xc4c</code>. After finding this offset I read the base address of the child process from <code>/proc/&lt;child_id&gt;/maps</code> which I won’t show here for brevity. Now we have a base address and offset so we can first save the original instruction and overwrite it with a <code>brk #0</code> instruction.</p><h3 id="3-set-breakpoint">3. Set breakpoint</h3><p>On 64-bit machines ptrace reads and writes 64 bits at a time. This is necessary for reading and writing to 64-bit memory addresses and registers, but instructions are only 32-bit on ARM machines. This means that ptrace reads and writes 2 instructions at a time and that we’ll have to do some bitwise shenanigans to modify a single instruction.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span>  <span>printf</span><span>(</span><span>&#34;finding lair...</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>size_t</span> <span>base_address</span> <span>=</span> <span>get_process_base_address</span><span>(</span><span>child</span><span>);</span><span>s</span>
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;decyphering plans...</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>size_t</span> <span>offset</span> <span>=</span> <span>0xc4c</span><span>;</span> 
</span></span><span><span>  <span>printf</span><span>(</span><span>&#34;placing tracker on unmarked van...</span><span>\n\n</span><span>&#34;</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>First we can find the offset and base address, which together point to the instruction we want to overwrite.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span>  <span>long</span> <span>breakpt</span> <span>=</span> <span>0xd4200000</span><span>;</span>
</span></span><span><span>  <span>long</span> <span>original</span> <span>=</span> <span>ptrace</span><span>(</span><span>PTRACE_PEEKTEXT</span><span>,</span> <span>child</span><span>,</span> <span>offset</span> <span>+</span> <span>base_address</span><span>,</span> <span>NULL</span><span>);</span>
</span></span><span><span>  <span>long</span> <span>break_instn</span> <span>=</span> <span>(</span><span>0xffffffff00000000</span> <span>&amp;</span> <span>original</span><span>)</span> <span>|</span> <span>breakpt</span><span>;</span>
</span></span><span><span>  <span>ptrace</span><span>(</span><span>PTRACE_POKETEXT</span><span>,</span> <span>child</span><span>,</span> <span>offset</span> <span>+</span> <span>base_address</span><span>,</span> <span>break_instn</span><span>);</span>
</span></span><span><span>  <span>...</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Next, we define our breakpoint instruction as the lower 32 bits of a 64-bit number. We use a bitwise and to zero the lower 32 bits of the original instruction which represents the 1st instruction read from memory. Then or the breakpoint instruction in. Finally, we’re ready to write back to memory which is done with a call to ptrace with the <code>PTRACE_POKETEXT</code> option.</p><p>With the breakpoint set, we are ready to resume the child process and wait for our breakpoint to be hit.</p><h3 id="4-catch-breakpoint">4. Catch breakpoint</h3><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>ptrace</span><span>(</span><span>PTRACE_CONT</span><span>,</span> <span>child</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>waitpid</span><span>(</span><span>child</span><span>,</span> <span>&amp;</span><span>status</span><span>,</span> <span>0</span><span>);</span>
</span></span><span><span><span>size_t</span> <span>pc_offset</span> <span>=</span> <span>get_pc</span><span>(</span><span>child</span><span>)</span> <span>-</span> <span>base_address</span><span>;</span>
</span></span><span><span><span>if</span> <span>(</span><span>WIFSTOPPED</span><span>(</span><span>status</span><span>)){</span>
</span></span><span><span>  <span>int</span> <span>signal</span> <span>=</span> <span>WSTOPSIG</span><span>(</span><span>status</span><span>);</span>
</span></span><span><span>  <span>if</span> <span>(</span><span>signal</span> <span>==</span> <span>SIGTRAP</span><span>){</span>
</span></span><span><span>    <span>printf</span><span>(</span><span>&#34;we got him [%lx]</span><span>\n</span><span>&#34;</span><span>,</span> <span>pc_offset</span><span>);</span>
</span></span><span><span>  <span>}</span> <span>else</span> <span>{</span> 
</span></span><span><span>    <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;we lost him</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>    <span>exit</span><span>(</span><span>2</span><span>);</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span> <span>else</span> <span>{</span> 
</span></span><span><span>  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span><span>&#34;we lost him</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>  <span>exit</span><span>(</span><span>3</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>After waiting for the child process, the program counter is converted back to an offset which should match the number we set the breakpoint at.</p><h3 id="5-disable-breakpoint">5. Disable breakpoint</h3><p>Usually, when our process hits a breakpoint we’d like to do something then restart our process and stop at the same point again the next time our process hits the breakpoint. To achieve this behavior we’ll need to rewrite the original instruction over the breakpoint instruction, execute it, then rewrite the original instruction with our breakpoint instruction.</p><p>This is another place where ARM and x86 differ. In ARM hitting a <code>brk #0</code> sends a <code>SIGTRAP</code> before the instruction is executed. This means that the program counter is not moved and when the process is restarted it will execute the same instruction again. This is very convenient for our purposes because we don’t have to change the program counter or mess with registers.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>printf</span><span>(</span><span>&#34;he&#39;s escaping</span><span>\n\n</span><span>&#34;</span><span>);</span>
</span></span><span><span><span>ptrace</span><span>(</span><span>PTRACE_POKETEXT</span><span>,</span> <span>child</span><span>,</span> <span>offset</span> <span>+</span> <span>base_address</span><span>,</span> <span>original</span><span>);</span>
</span></span><span><span><span>ptrace</span><span>(</span><span>PTRACE_SINGLESTEP</span><span>,</span> <span>child</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>);</span>
</span></span><span><span><span>waitpid</span><span>(</span><span>child</span><span>,</span> <span>&amp;</span><span>status</span><span>,</span> <span>0</span><span>);</span>
</span></span><span><span><span>ptrace</span><span>(</span><span>PTRACE_POKETEXT</span><span>,</span> <span>child</span><span>,</span> <span>offset</span> <span>+</span> <span>base_address</span><span>,</span> <span>break_instn</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h3 id="resume-child-process">Resume child process</h3><p>After stepping over the breakpoint we can resume our child process.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>ptrace</span><span>(</span><span>PTRACE_CONT</span><span>,</span> <span>child</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>In this case, we expect the child process to exit without hitting another breakpoint or stopping.</p><h3 id="conclusion">Conclusion</h3><p>This program shows a simple demonstration of how ptrace can be used to interrupt processes at line numbers or offsets. Finding offsets has been simplified by using gdb but compiling with debug symbols enabled will expose a source/instruction mapping in the executable. Some mature tools like <code>libdw</code> and Go’s standard library exist to parse this debug info enabling a systematic approach to writing debuggers and profilers.</p><p>In this post, I’ve also glossed over nearly all error checking. System calls like <code>ptrace</code>, <code>waitpid</code>, and <code>fork</code> will return a flag value on an error which should be used to handle unexpected errors.</p><p>Thank you for reading. Stay tuned for future updates.</p></div></div>
  </body>
</html>
