<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bugs.pwno.io/0014">Original</a>
    <h1>Heap Overflow in FFmpeg EXIF</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>We recently found a cool four-bytes heap-buffer-overflow in FFmpeg&#39;s <code>avcodec/exif</code> during the processing of IFDs <em>(Image File Directory).</em> This affects <code>.png</code>, <code>.jpg</code>, <code>.webp</code>, <code>.avif</code> … the formats we use most often. The cause of this bug is very interesting, and I don’t want to spoil it here; I want you to find out.</p>
<p>It’s also a short in-depth dive of FFmpeg internal workings of EXIFs, something we use so often. So even if you’re not really into memory bugs, this can be a cool way to learn how it works under the hood.</p>
<blockquote>
<p>This bug wasn’t in FFmpeg long. We happened to catch it about three days after it got introduced in the codebase. You can always trust FFmpeg.</p>
</blockquote>
<div><p><span>c</span></p><pre><code>
<span>static</span> <span>int</span> <span>decode_exif_chunk</span><span>(</span>AVCodecContext <span>*</span>avctx<span>,</span> PNGDecContext <span>*</span>s<span>,</span>
                             GetByteContext <span>*</span>gb<span>)</span>
<span>{</span>
    
    s<span>-&gt;</span>exif_data <span>=</span> <span>av_buffer_alloc</span><span>(</span><span>bytestream2_get_bytes_left</span><span>(</span>gb<span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>!</span>s<span>-&gt;</span>exif_data<span>)</span>
        <span>return</span> <span>AVERROR</span><span>(</span>ENOMEM<span>)</span><span>;</span>
    <span>bytestream2_get_buffer</span><span>(</span>gb<span>,</span> s<span>-&gt;</span>exif_data<span>-&gt;</span>data<span>,</span> s<span>-&gt;</span>exif_data<span>-&gt;</span>size<span>)</span><span>;</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></div><p>To begin with (in context of PNG), <code>decode_exif_chunk</code> at <code>libavcodec/pngdec.c:763</code> handles the processing of the exif data in a image. Here is where we allocated the destination of the exif store (<code>s-&gt;exif_data</code>), in where the PNG decoder stores the exif chunk it read <em>(from <code>gb</code></em> )_ into.</p>
<div><p><span>c</span></p><pre><code>
    <span>if</span> <span>(</span>s<span>-&gt;</span>exif_data<span>)</span> <span>{</span>
        
        <span>FFSWAP</span><span>(</span>AVDictionary <span>*</span><span>,</span> p<span>-&gt;</span>metadata<span>,</span> s<span>-&gt;</span>frame_metadata<span>)</span><span>;</span>
        ret <span>=</span> <span>ff_decode_exif_attach_buffer</span><span>(</span>avctx<span>,</span> p<span>,</span> <span>&amp;</span>s<span>-&gt;</span>exif_data<span>,</span> AV_EXIF_TIFF_HEADER<span>)</span><span>;</span>
        <span>FFSWAP</span><span>(</span>AVDictionary <span>*</span><span>,</span> p<span>-&gt;</span>metadata<span>,</span> s<span>-&gt;</span>frame_metadata<span>)</span><span>;</span>
        <span>if</span> <span>(</span>ret <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>av_log</span><span>(</span>avctx<span>,</span> AV_LOG_WARNING<span>,</span> <span>&#34;unable to attach EXIF buffer\\n&#34;</span><span>)</span><span>;</span>
            <span>return</span> ret<span>;</span>
        <span>}</span>
    <span>}</span></code></pre></div><p>During frame production, that decoder buffer becomes the EXIF payload associated <em>(attaches)</em> with the outputting frame in <code>libavcodec/pngdec.c:1761</code> , via <code>ff_decode_exif_attach_buffer</code> .</p>
<div><p><span>c</span></p><pre><code>
<span>int</span> <span>ff_decode_exif_attach_buffer</span><span>(</span>AVCodecContext <span>*</span>avctx<span>,</span> AVFrame <span>*</span>frame<span>,</span> AVBufferRef <span>*</span><span>*</span>pbuf<span>,</span>
                                 <span>enum</span> <span>AVExifHeaderMode</span> header_mode<span>)</span>
<span>{</span>
    <span>int</span> ret<span>;</span>
    AVBufferRef <span>*</span>data <span>=</span> <span>*</span>pbuf<span>;</span>
    AVExifMetadata ifd <span>=</span> <span>{</span> <span>0</span> <span>}</span><span>;</span>

    ret <span>=</span> <span>av_exif_parse_buffer</span><span>(</span>avctx<span>,</span> data<span>-&gt;</span>data<span>,</span> data<span>-&gt;</span>size<span>,</span> <span>&amp;</span>ifd<span>,</span> header_mode<span>)</span><span>;</span>
    <span>if</span> <span>(</span>ret <span>&lt;</span> <span>0</span><span>)</span>
        <span>goto</span> end<span>;</span>

    ret <span>=</span> <span>exif_attach_ifd</span><span>(</span>avctx<span>,</span> frame<span>,</span> <span>&amp;</span>ifd<span>,</span> pbuf<span>)</span><span>;</span></code></pre></div><p>In which, in <code>ff_decode_exif_attach_buffer()</code> furthermore transcribes the raw EXIF bytes into FFmpeg’s native EXIF structure (<code>AVExifMetadata</code>) with <code>av_exif_parse_buffer</code>, via the <code>GetByteContext</code> way <em>(as we seen the decoder <code>g</code> did it).</em> It initializes base on what <code>header_mode</code> it is. (which is interesting, and <em>the author also put explanations on <code>AVExifHeaderMode</code> )</em>:</p>
<ol>
<li><code>AV_EXIF_EXIF00</code> expects for a <code>Exif\0\0</code> prefix, it skips six bytes.</li>
<li><code>AV_EXIF_T_OFF</code> expects a 4-byte offset at the start (where it actually starts) and uses it to find the <code>TIFF</code> header.</li>
<li><code>AV_EXIF_TIFF_HEADER</code> expects the buffer to start with a TIFF header; it decodes endianness + first <code>IFD</code> offset via <code>ff_tdecode_header</code></li>
<li><code>AV_EXIF_ASSUME_LE/BE</code> doesn’t decode a TIFF header, it just assumes little/big endian and starts at beginning of the buffer.</li>
</ol>
<p>After the setup, it starts to parse the main IFD <em>(Image File Directory),</em> which stores a table of metadata entries. These entries tell you how to interpret a specific IFD structure. <em>(What <code>tag</code> is it; what <code>type</code></em> ; <code>offset</code> to look for the specified IFD)_</p>
<div><p><span>c</span></p><pre><code>
    <span>{</span><span>&#34;ExifIFD&#34;</span><span>,</span>                    <span>0x8769</span><span>}</span><span>,</span> 
    <span>{</span><span>&#34;GPSInfo&#34;</span><span>,</span>                    <span>0x8825</span><span>}</span><span>,</span> 
    <span>{</span><span>&#34;InteropIFD&#34;</span><span>,</span>                 <span>0xA005</span><span>}</span><span>,</span> 
    <span>{</span><span>&#34;GlobalParametersIFD&#34;</span><span>,</span>        <span>0x0190</span><span>}</span><span>,</span>
    <span>{</span><span>&#34;ProfileIFD&#34;</span><span>,</span>                 <span>0xc6f5</span><span>}</span><span>,</span>
<span>}</span><span>;</span></code></pre></div><p>Yes, they are the thing that sometime accidentally leaks where you live, and also the explanation why sometimes when your friend send you a picture from iMessage, you clicked on it and it shows you where it is. But don’t worry much about it; typically social media now strip the EXIF parts away, thanks to these H1 reports.</p>
<p>These IFD tags also includes: <em>orientation; camera &amp; lens info; capture settings like ISO, shutter time, focal length; properties like resolution, pixel dimension etc.</em> Interesting some files also include a small JPEG thumbnail that tags points to (picture in a picture).</p>
<p>After parsing the <code>IFD0</code> (the main IFD lists), If there’s more IFD data <em>(if <code>ret &gt;0</code></em> )_, it tries seek to that next IFD offset and loops, up to 16 more IFDs. (In real-world, these extra IFDs can be <em>TIFF multi-page, thumbnails we mentioned…</em>)</p>
<div><p><span>c</span></p><pre><code>
    
    <span>for</span> <span>(</span><span>int</span> extra_tag <span>=</span> <span>0xFFFCu</span><span>;</span> extra_tag <span>&gt;</span> <span>0xFFECu</span><span>;</span> extra_tag<span>--</span><span>)</span> <span>{</span>
        AVExifMetadata extra_ifd <span>=</span> <span>{</span> <span>0</span> <span>}</span><span>;</span>
        ret <span>=</span> <span>exif_parse_ifd_list</span><span>(</span>logctx<span>,</span> <span>&amp;</span>gbytes<span>,</span> le<span>,</span> <span>0</span><span>,</span> <span>&amp;</span>extra_ifd<span>,</span> <span>1</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>ret <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>av_exif_free</span><span>(</span><span>&amp;</span>extra_ifd<span>)</span><span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
        next <span>=</span> ret<span>;</span>
        <span>av_log</span><span>(</span>logctx<span>,</span> AV_LOG_DEBUG<span>,</span> <span>&#34;found extra IFD: %04x with next=%d\n&#34;</span><span>,</span> extra_tag<span>,</span> ret<span>)</span><span>;</span>
        <span>bytestream2_seek</span><span>(</span><span>&amp;</span>gbytes<span>,</span> next<span>,</span> <span>SEEK_SET</span><span>)</span><span>;</span>
        ret <span>=</span> <span>av_exif_set_entry</span><span>(</span>logctx<span>,</span> ifd<span>,</span> extra_tag<span>,</span> AV_TIFF_IFD<span>,</span> <span>1</span><span>,</span> <span>NULL</span><span>,</span> <span>0</span><span>,</span> <span>&amp;</span>extra_ifd<span>)</span><span>;</span>
        <span>av_exif_free</span><span>(</span><span>&amp;</span>extra_ifd<span>)</span><span>;</span>
        <span>if</span> <span>(</span>ret <span>&lt;</span> <span>0</span> <span>||</span> <span>!</span>next <span>||</span> <span>bytestream2_get_bytes_left</span><span>(</span><span>&amp;</span>gbytes<span>)</span> <span>&lt;=</span> <span>0</span><span>)</span>
            <span>break</span><span>;</span>
    <span>}</span></code></pre></div><p>It stores these extra IFDs into the reserved synthetic tags from <code>0xFFFC</code> to <code>0xFFED</code> . By store them as a <code>AV_TIFF_IFD</code> entries into the main IFDs. </p>
<p>After the parsing of these IFDs finishes, these IFDs enter the decoding flow into <code>exif_attach_ifd()</code> (invoked by <code>ff_decode_exif_attach_buffer</code> , <code>libavcodec/decode.c:2447</code> ): We use the <code>AVExifMetadata</code> structured IFD <em>(structured from stream)</em> to apply (annotate) the outputting frame.</p>
<div><p><span>c</span></p><pre><code>
<span>static</span> <span>int</span> <span>exif_attach_ifd</span><span>(</span>AVCodecContext <span>*</span>avctx<span>,</span> AVFrame <span>*</span>frame<span>,</span> <span>const</span> AVExifMetadata <span>*</span>ifd<span>,</span> AVBufferRef <span>*</span><span>*</span>pbuf<span>)</span>
<span>{</span>
		
    <span>for</span> <span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> ifd<span>-&gt;</span>count<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>const</span> AVExifEntry <span>*</span>entry <span>=</span> <span>&amp;</span>ifd<span>-&gt;</span>entries<span>[</span>i<span>]</span><span>;</span>
        <span>if</span> <span>(</span>entry<span>-&gt;</span>id <span>==</span> <span>av_exif_get_tag_id</span><span>(</span><span>&#34;Orientation&#34;</span><span>)</span> <span>&amp;&amp;</span>
            entry<span>-&gt;</span>count <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> entry<span>-&gt;</span>type <span>==</span> AV_TIFF_SHORT<span>)</span> <span>{</span>
            orient <span>=</span> entry<span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>
    </code></pre></div><p>For <code>exif_attach_ifd</code> ’s <em>“annotating”</em>, we meant it:</p>
<ol>
<li>processing orientation <em>(finding it then converts it into a display matrix side-data to render the rotate; optionally removing it)</em>;</li>
<li>converting the remaining tags into <code>frame→metadata</code> , which is are strings in an <code>AVDictionary</code>;</li>
<li><em>(re)writing</em> these EXIF back <strong>into byte-stream</strong> via <code>av_exif_write</code> , and attaching that raw EXIF blob to the frame.</li>
</ol>
<p>Here the re-attaching the <em>(re)writing into</em> byte-stream for attachment is the most interesting, since it basically re-serializing the extra IFDs; taking them out from the main IFDs entries into a temporary <code>extra_tag</code> ; write the <em>(main)</em> <code>IFD0</code> , then append these extra IFDs as <code>IFD1</code> <em>(appending them after <code>IFD0</code> , and changing the previous IFD’s next into the appended IFDS)</em></p>
<div><p><span>c</span></p><pre><code>
    <span>if</span> <span>(</span>cloned <span>||</span> <span>!</span><span>*</span>pbuf<span>)</span> <span>{</span>
        <span>av_buffer_unref</span><span>(</span>pbuf<span>)</span><span>;</span>
        ret <span>=</span> <span>av_exif_write</span><span>(</span>avctx<span>,</span> ifd<span>,</span> pbuf<span>,</span> AV_EXIF_TIFF_HEADER<span>)</span><span>;</span>
        <span>if</span> <span>(</span>ret <span>&lt;</span> <span>0</span><span>)</span>
            <span>goto</span> end<span>;</span>
    <span>}</span>

    ret <span>=</span> <span>ff_frame_new_side_data_from_buf</span><span>(</span>avctx<span>,</span> frame<span>,</span> AV_FRAME_DATA_EXIF<span>,</span> pbuf<span>)</span><span>;</span>
    

<span>int</span> <span>av_exif_write</span><span>(</span><span>void</span> <span>*</span>logctx<span>,</span> <span>const</span> AVExifMetadata <span>*</span>ifd<span>,</span> AVBufferRef <span>*</span><span>*</span>buffer<span>,</span> <span>enum</span> <span>AVExifHeaderMode</span> header_mode<span>)</span>
<span>{</span>
    
    size <span>=</span> <span>exif_get_ifd_size</span><span>(</span>ifd<span>)</span><span>;</span>
    buf <span>=</span> <span>av_buffer_alloc</span><span>(</span>size <span>+</span> off <span>+</span> headsize<span>)</span><span>;</span>
    
    
    <span>int</span> extras<span>;</span>
    <span>for</span> <span>(</span>extras <span>=</span> <span>0</span><span>;</span> extras <span>&lt;</span> <span>FF_ARRAY_ELEMS</span><span>(</span>extra_ifds<span>)</span><span>;</span> extras<span>++</span><span>)</span> <span>{</span>
        AVExifEntry <span>*</span>extra_entry <span>=</span> <span>NULL</span><span>;</span>
        <span>uint16_t</span> extra_tag <span>=</span> <span>0xFFFCu</span> <span>-</span> extras<span>;</span>
        ret <span>=</span> <span>av_exif_get_entry</span><span>(</span>logctx<span>,</span> <span>(</span>AVExifMetadata <span>*</span><span>)</span> ifd<span>,</span> extra_tag<span>,</span> <span>0</span><span>,</span> <span>&amp;</span>extra_entry<span>)</span><span>;</span>
        <span>if</span> <span>(</span>ret <span>&lt;=</span> <span>0</span><span>)</span>
            <span>break</span><span>;</span>
        <span>av_log</span><span>(</span>logctx<span>,</span> AV_LOG_DEBUG<span>,</span> <span>&#34;found extra IFD tag: %04x\n&#34;</span><span>,</span> extra_tag<span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>!</span>ifd_new<span>)</span> <span>{</span>
            ifd_new <span>=</span> <span>av_exif_clone_ifd</span><span>(</span>ifd<span>)</span><span>;</span>
            <span>if</span> <span>(</span><span>!</span>ifd_new<span>)</span>
                <span>break</span><span>;</span>
            ifd <span>=</span> ifd_new<span>;</span>
        <span>}</span>
        
        AVExifMetadata <span>*</span>cloned <span>=</span> <span>av_exif_clone_ifd</span><span>(</span><span>&amp;</span>extra_entry<span>-&gt;</span>value<span>.</span>ifd<span>)</span><span>;</span>
		
		
		ret <span>=</span> <span>exif_write_ifd</span><span>(</span>logctx<span>,</span> <span>&amp;</span>pb<span>,</span> le<span>,</span> <span>0</span><span>,</span> ifd<span>)</span><span>;</span></code></pre></div><p>However, takes notes on how does <code>av_exif_write</code> take accounts for the extra IFDs from <code>0xFFFC</code> to <code>0xFFED</code> ; it “peels” the <code>extra_ifd</code> linearly downwards from <code>0xFFFCu</code> , and breaks on the first missing tag. Also note that, the size of the written buffer was calculated, <strong>in prior</strong>, to the peeling at <code>exif_get_ifd_size(ifd)</code> with the IFD list.</p>
<div><p><span>c</span></p><pre><code><span>static</span> <span>size_t</span> <span>exif_get_ifd_size</span><span>(</span><span>const</span> AVExifMetadata <span>*</span>ifd<span>)</span>
<span>{</span>
    
    
    <span>size_t</span> total_size <span>=</span> IFD_EXTRA_SIZE<span>;</span>
    <span>for</span> <span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> ifd<span>-&gt;</span>count<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>const</span> AVExifEntry <span>*</span>entry <span>=</span> <span>&amp;</span>ifd<span>-&gt;</span>entries<span>[</span>i<span>]</span><span>;</span>
        
        <span>if</span> <span>(</span>entry<span>-&gt;</span>type <span>==</span> AV_TIFF_IFD<span>)</span> <span>{</span>
            
            <span>size_t</span> base_size <span>=</span> entry<span>-&gt;</span>id <span>&gt;</span> <span>0xFFECu</span> <span>&amp;&amp;</span> entry<span>-&gt;</span>id <span>&lt;=</span> <span>0xFFFCu</span> <span>?</span> <span>0</span> <span>:</span> BASE_TAG_SIZE<span>;</span>
            total_size <span>+=</span> base_size <span>+</span> <span>exif_get_ifd_size</span><span>(</span><span>&amp;</span>entry<span>-&gt;</span>value<span>.</span>ifd<span>)</span> <span>+</span> entry<span>-&gt;</span>ifd_offset<span>;</span></code></pre></div><p>The sizing of <code>exif_get_ifd_size</code> , treats extra IFDs, <code>AV_TIFF_IFD</code> with <code>id</code> of  <code>&gt; 0xFFECu</code> , <code>&lt;= 0xFFFCu</code> calculated as zero. This calculation does makes sense because these tags are eventually going to be “peeled” out from the main IFDs entries <code>(libavcodec/exif.c:802</code>) as we mentioned previously; </p>
<p>However, what made these few slices of code worth me spending hours writing a analysis about, is because of this reasonable assumption: all extra IFD tags are going to be eventually removed.</p>
<p>You see, as we mentioned previously, </p>
<blockquote>
<p><code>av_exif_write</code> take accounts for the extra IFDs from <code>0xFFFC</code> to <code>0xFFED</code> ; it “peels” the <code>extra_ifd</code> <strong>linearly downwards.</strong> and breaks on the <strong>first missing</strong> tag.</p>
</blockquote>
<p>The extra IFD removal, “peeling” scan from <code>0xFFFCu</code> , <code>-1</code> step at a time; since <code>av_exif_parse_buffer</code> might not use all of the extra IFD tags <em>(in case there are less than 16 tags),</em> it ends when there’s no tag. <em>(the code slice above the</em> <code>exif_get_ifd_size</code> one is describing this). This very much make sense as well since our extra IFDs <strong>are</strong> linearly distributed from <code>av_exif_parse_buffer</code> by extra fields.</p>
<p>But the question is, what if they are <strong>non-contiguous</strong>?</p>
<p>This question might sound stupid, since we just said that the entries of these extra tags are distributed linearly, and contiguous, and that’s 100% true. There are no shenanigans you can pull of from the initialization on  <code>av_exif_parse_buffer</code> .</p>
<p>But what if we don’t go a expect route, and fake a extra <code>AV_TIFF_IFD</code> IFD, from the source?</p>
<p><code>exif_parse_ifd_list</code> <em>( <em><code>exif_decode_tag</code></em> )</em> is the used to extract IFDs from the byte-stream context (<code>GetByteContext *gb</code>). We’ve seen it in the structuring <code>av_exif_parse_buffer</code> stage to extract the <code>IPD0</code> <em>(main IFD entries);</em> as we mentioned, prior to when it deal with synthetic tags.</p>
<div><p><span>c</span></p><pre><code>
<span>static</span> <span>int</span> <span>exif_decode_tag</span><span>(</span><span>void</span> <span>*</span>logctx<span>,</span> GetByteContext <span>*</span>gb<span>,</span> <span>int</span> le<span>,</span>
                           <span>int</span> depth<span>,</span> AVExifEntry <span>*</span>entry<span>)</span>
<span>{</span>
		
    entry<span>-&gt;</span>id <span>=</span> <span>ff_tget_short</span><span>(</span>gb<span>,</span> le<span>)</span><span>;</span>
    type <span>=</span> <span>ff_tget_short</span><span>(</span>gb<span>,</span> le<span>)</span><span>;</span>
    count <span>=</span> <span>ff_tget_long</span><span>(</span>gb<span>,</span> le<span>)</span><span>;</span>
    payload <span>=</span> <span>ff_tget_long</span><span>(</span>gb<span>,</span> le<span>)</span><span>;</span>
    
    
    <span>if</span> <span>(</span>type <span>&gt;</span> AV_TIFF_IFD <span>||</span> count <span>&gt;=</span> INT_MAX<span>/</span><span>8U</span><span>)</span>
        <span>return</span> AVERROR_INVALIDDATA<span>;</span>

	
	
    ret <span>=</span> <span>exif_parse_ifd_list</span><span>(</span>logctx<span>,</span> <span>&amp;</span>gbytes<span>,</span> le<span>,</span> <span>0</span><span>,</span> ifd<span>,</span> <span>0</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>ret <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>av_log</span><span>(</span>logctx<span>,</span> AV_LOG_ERROR<span>,</span> <span>&#34;error decoding EXIF data: %s\n&#34;</span><span>,</span> <span>av_err2str</span><span>(</span>ret<span>)</span><span>)</span><span>;</span>
        <span>return</span> ret<span>;</span>
    <span>}</span></code></pre></div><p>If we take a closer look, it seems like there’re a little heuristic checks on the type of the IFDs; If <code>type &gt; AV_TIFF_IFD</code> or <code>count &gt;= INT_MAX/8U</code> ; However, nothing is stopping us from <strong>directly adding a reserved synthetic tags (</strong><code>0xFFFC</code> to <code>0xFFED</code><strong>)</strong> from the byte-stream (EXIF section of the file) through the <strong>IFD0 parsing</strong>, even through they’re used internally for accounting extra tags.</p>
<p>In which, allows us to add extra tags without following the expected <code>av_exif_parse_buffer</code> → int <code>extra_tag = 0xFFFCu; extra_tag &gt; 0xFFECu; extra_tag--</code> path; forging a non-contiguous extra IFD entries; making the <em>“peeling”</em> process <code>break</code> on first recursion; leaving extra tags in <code>IFD0</code> that are expected to be peeled, and already sized by zero by <code>exif_get_ifd_size</code> , accounting for no 12 bytes directory slot.</p>
<p>When it hits a small payload entry (e.g., SHORT), it executes <code>AV_WN32(pb-&gt;buffer, 0)</code> to zero inline padding (<code>libavcodec/exif.c:731</code>). At that point <code>pb-&gt;buffer</code>is already at <code>pb-&gt;buffer_end - 2</code>, so the 4‑byte zero write spills past the buffer end directly into the next heap chunk’s metadata.</p>
<h2>Repro</h2>
<p>This bug can be triggered by simply <code>./ffmpeg -i &lt;file&gt;</code> under default build, no prerequisites.</p>
<ul>
<li><code>poc/poc.png</code>: ASAN <code>heap-buffer-overflow (decoder thread av:png:df0)</code></li>
<li><code>poc/poc.webp</code>: ASAN <code>heap-buffer-overflow (T0)</code></li>
<li><code>poc/poc.jpg</code>: ASAN <code>heap-buffer-overflow (decoder thread dec0:0:mjpeg)</code></li>
<li><code>poc/poc.avif</code>: ASAN <code>heap-buffer-overflow (T0)</code></li>
<li><code>poc/poc.jxl</code>: ASAN <code>heap-buffer-overflow (decoder thread dec0:0:libjxl)</code></li>
</ul>
<figure><img src="https://bugs.pwno.io/notion-images/059fed1648d3459829ad463c5ccc2262.png" alt="ASan" loading="lazy"/><figcaption>ASan</figcaption></figure>
<p>This gave us <code>ASan</code> trace of: </p>
<ul>
<li><em><code>heap-buffer-overflow at libavcodec/exif.c:731 in exif_write_ifd</code></em></li>
<li><em><code>exif_write_ifd</code></em><ul>
<li><em><code>av_exif_write</code></em><ul>
<li><em><code>exif_attach_ifd</code></em><ul>
<li><em><code>ff_decode_exif_attach_buffer</code></em><ul>
<li><code>decode_frame_common</code><ul>
<li><em><code>decode_frame_png</code></em></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Matching the writeup.</p>
<p>Note that for <code>.tiff</code>:</p>
<ul>
<li><code>build-asan-jxl/ffmpeg -v debug -i poc-exif/poc_exif.tiff -f null -</code> logs:</li>
<li><code>writing IFD with 17 entries and initial offset 218</code></li>
<li><code>writing TIFF entry: id: 0xfffb ... offset value: 329</code></li>
<li><code>EXIF metadata: (323 bytes)</code><ul>
<li>The directory area is <code>IFD_EXTRA_SIZE + BASE_TAG_SIZE * count = 6 + 12*17 = 210</code> bytes. With the TIFF header, the initial payload offset is 218 (matches the log).</li>
<li>The under‑allocation from <code>exif_get_ifd_size()</code> is only 12 bytes (the skipped base tag size for the <code>0xfffb</code> IFD entry) in <code>libavcodec/exif.c</code>.</li>
<li>So even under‑allocated, the buffer still comfortably covers the directory area, where the only unguarded write happens (<code>AV_WN32(pb-&gt;buffer, 0)</code> for inline payloads in <code>exif_write_ifd()</code>).</li>
<li>The shortfall hits the payload area instead. Those writes use <code>bytestream2_put_*()</code> / <code>bytestream2_seek_p()</code> which clamp and set <code>p-&gt;eof</code> rather than OOB.</li>
</ul>
</li>
</ul>
<h2>Timeline</h2>
<blockquote>
<p>Since the bug is disclosed during the Christmas holiday, we do not disclose the specific dates.</p>
</blockquote>
<ul>
<li>Dec, 2025: Discovery of potential issue, replications &amp; validations.</li>
<li>Dec, 2025: Disclosed to ffmpeg-security.</li>
<li>Dec, 2025: <code>avcodec/exif</code> maintainer provided patch.</li>
<li>Dec, 2025: Patched merged</li>
</ul>
</article></div>
  </body>
</html>
