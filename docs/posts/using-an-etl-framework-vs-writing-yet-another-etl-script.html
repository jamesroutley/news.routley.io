<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://airbyte.io/blog/etl-framework-vs-etl-script">Original</a>
    <h1>Using an ETL framework vs. writing yet another ETL script</h1>
    
    <div id="readability-page-1" class="page"><div id="blog-content"><p>The first time your engineering team needs to pull data from an external source, you may be tempted to write an ETL script in your favourite programming language. Five years ago, that&#39;s what I would have done too! In 2021, however, tooling has progressed such that this should be considered an antipattern.<br/></p><p>Soon enough this simple ETL script turns into a more complex project when you make it production ready. Think for example of all the work needed to add scheduling, monitoring and debugging capabilities so you can fix it as soon as it breaks. And trust me, ETL scripts break often because you inherently don’t control the source data and API changes.<br/></p><p>In this article, we share a common story of how this little ETL script evolves as you need to add more features to make it production ready and finally becomes an internal ETL framework to maintain. I&#39;ve watched this narrative unfold in multiple high-performance engineering organizations. At Airbyte, we’ve built an <a href="https://github.com/airbytehq/airbyte">open-source ETL framework</a> (or should we say ELT) so you don’t have to code everything yourself.</p><h2>Building your first ETL script</h2><blockquote>&#34;We are doing a prototype on our new mapping product, we need to write a one-off script to pull in some map data.&#34;</blockquote><p>Your first ETL script will normally take the form of a CLI that calls an external API to extract some data, normalize it and load it to destination. You run it once and you think it&#39;s over...</p><h3>Adding scheduling</h3><p><em>1 week later.</em><br/></p><blockquote>&#34;For our prototype, we now need to pull the data daily, let&#39;s build a cron.&#34;<br/></blockquote><p>A cron job may be a good enough solution if you only need to schedule one ETL task at a time. But the moment you have one ETL job that runs long and is still running when the cron tries to schedule the next one, you’ll need to add more tooling.<br/></p><p>For example, you may be tempted to use Airflow to schedule your ETL scripts with dependencies, or directly use Airflow transfer and transformation operators instead. While Airflow shines as a workflow orchestrator, soon enough you will need extra logic to add incremental loads and integrate data from business applications. You can read more about the challenges of using Airflow for ETL pipelines <a href="https://airbyte.io/blog/airflow-etl-pipelines">here</a>.</p><h3>Adding monitoring</h3><p><em>1 month later.</em></p><blockquote>&#34;Wait a second, why is all of our traffic data a month old?”</blockquote><p>As time has passed, the prototype that this data supports has matured into a production system with real customers. Sure enough, the original implementation using cron did not include any monitoring to make sure the script completes successfully. It was just a &#34;little script&#34; after all! So the team makes sure that the script now reports whether it has succeeded or not.</p><h3>Adding configuration</h3><p><em>1 month later.</em><br/></p><blockquote>&#34;We are pulling data at the wrong cadence. The base map data we only want to pull once a month. The traffic data we need to pull every 5 minutes.&#34;</blockquote><p>More engineering work goes into making the &#34;little script&#34; more configurable. Now there are two crons running at different cadences, and the script decides which data to pull based on some arguments that are passed in at runtime. <br/></p><p>This is just one example of the configuration that might need to be grafted on to the script. Additional ones that crop up are: selecting subsets of columns, handling transformations for the different data types separately, or grouping the data into the right schema or directory.</p><h3>Adding incremental syncs</h3><p><em>1 month later.</em></p><blockquote>&#34;Our traffic data is falling behind, because we are trying to resend all of it every five minutes. We need to send only the <em>new</em> data&#34;.</blockquote><p>If you are building an ETL script that needs to run frequently, an engineer has to store state for the cron job, so that on each run, the cron can query for only the new data by remembering how far it got last time or query directly the destination data store.</p><h3>Fixing a broken connector</h3><p><em>1 month later.</em></p><blockquote>“The data provider changed the schema of the data.”</blockquote><p>Maintaining data integration pipelines is hard because you cannot control what the data provider is going to do. This means you have to be on call for changes they made. With the right monitoring you can reduce the disruption, but you still need to put in the time.</p><h3>Adding a new source</h3><p><em>1 month later.</em></p><blockquote>&#34;We are switching map data providers, we need a &#39;little script&#39; to pull data from Y&#34;</blockquote><p>Either way, the little ETL script now has its own database and is starting to look like an ETL framework of its own. Sound familiar?</p><p>This trajectory is commonplace among good engineering teams. At each step, they find the smallest valuable deliverable instead of over engineering for unknown future requirements (very scrum!). This trade off has historically made sense. Building in-house a fully fledged ETL pipeline with monitoring, schema evolution, etc, is hard. Thus, it did not make sense to put in all of that upfront cost, relative to just sinking a few hours to get an initial script that gets the project unblocked.</p><p>But in 2021, there is no reason to make this trade off anymore. </p><h2>Why use an open-source ETL framework?</h2><p>Airbyte&#39;s mission is to make it so easy to write a source and destination, that the upfront cost of writing that connector is lower than writing that &#34;little&#34; ETL script in the first place. To make it possible, we have created a <a href="https://docs.airbyte.io/connector-development/cdk-python">Connector Development Kit (CDK)</a>.<br/></p><p>The CDK provides an improved developer experience by providing basic implementation structure and abstracting away low-level glue boilerplate. This includes packaging, code structure, a test suite, setting up the release pipeline and several helper methods.<br/></p><p>The benefit of writing the connector using an ETL framework is that the monitoring features that are needed to make the ETL pipeline a reliable piece of a production system require no additional engineering time. Then for all of those future requirements (e.g. frequency changes, incremental syncs), they are just configuration changes in a UI!<br/></p><p>Airbyte is focused on the OSS approach because we believe that fundamentally it is the <em>only</em> way to solve the problems of data integration. It is not possible for a single company to write and support every single connector themselves. This is fundamental to how the data market has changed. Every year thousands of new tech companies are created, and each one is producing data. Given this growth, only the OSS community can keep up. The Airbyte and OSS community own patching connectors, which keeps the ongoing upkeep of the connector low.<br/></p><p>ETL solutions that do not leverage OSS, leave their customers in a difficult position. Those users often have to choose a tool that only supports 3 of the 6 connectors they need. Thus, they still have to maintain a side ETL pipeline for those other 3 data sources. They are stuck in the &#34;little ETL script&#34; antipattern! With an OSS approach, users can get all of the benefits of a SaaS ETL tool and also have it support all of its connectors. If the connector is not built in, it is easy to add using the CDK, so that it is all running through the same system.<br/></p><p>Any ETL solution that cannot cover all of the sources that a user needs is only fulfilling a fraction of that promise. The developer time savings really comes when the engineer does not have to maintain any side pipelines and can put the &#34;little ETL script&#34; antipattern behind them. With Airbyte, our focus is making connector writing so easy, so that teams can have an ETL tool that supports all the connectors they need and gives them all of the ETL features they deserve. </p><p>Say goodbye to the &#34;little ETL script&#34; antipattern!<br/></p></div></div>
  </body>
</html>
