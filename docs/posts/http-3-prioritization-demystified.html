<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://calendar.perfplanet.com/2022/http-3-prioritization-demystified/">Original</a>
    <h1>HTTP/3 prioritization demystified</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>If you deal with Web Performance, you‚Äôve probably heard about HTTP resource prioritization. This is especially true since last year, as Chromium added so-called ‚ÄúPriority Hints‚Äù with the new <a href="https://web.dev/priority-hints/"><code>fetchpriority</code> attribute</a>, which allow you to tweak said prioritizations. You may have also heard that the prioritization system changed between HTTP/2 and HTTP/3.</p>



<p>However, what exactly does prioritization mean? How does it work under the hood? Why is it important to have some control over it? and, crucially, do all browsers agree on which resources are most important (hint: no, they don‚Äôt)? This, and much more, down below!</p>



<ul><li><a href="#sec_concepts">What is prioritization?</a><ul><li><a href="#sec_loadingdelays">Resource loading delays</a></li></ul></li><li><a href="#sec_signals">Prioritization signals</a></li><li><a href="#sec_browsers">Browser differences</a><ul><li><a href="#sec_rawdetails">Raw protocol details</a></li><li><a href="#sec_keylearnings">Key learnings</a> (this is what you‚Äôre probably most interested in)</li></ul></li><li><a href="#sec_servers">Server differences</a></li><li><a href="#sec_conclusion">Conclusion</a></li></ul>



<blockquote><p>Note: HTTP prioritization is a very expansive topic; I‚Äôve heard <a href="https://www.researchgate.net/publication/347519865_Debugging_Modern_Web_Protocols">you can even do a PhD on it :O</a>. In this post, I <strong>intentionally</strong> leave out a lot of nuances to focus on the key points.</p></blockquote>









<p>HTTP resource prioritization is mainly a concept for HTTP/2 (H2) and HTTP/3 (H3). In HTTP/1.1 (H1), browsers typically open multiple TCP connections (up to 6 per domain) and each connection loads only 1 resource/file <strong>at a time</strong>. Prioritization is implicit by which resources are requested first on the available connections.</p>



<p>However, in H2 and also H3, we instead aim to improve efficiency by using only <strong>a single TCP/QUIC connection</strong>. If however that single connection could also only have just a single resource ‚Äúactive‚Äù at a time like H1, that would be bad for performance. So instead, H2 and H3 can send multiple requests at the same time. Crucially though, this does <strong>not</strong> mean these requests can also be fully responded to at the same time! This is because, at any given time, a connection is limited in how much data it can send by things like <a href="https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/#congestion-control">congestion and flow control</a>.</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/congestion-control.png" alt="Congestion control graph"/></p>



<p>Especially at the start of the connection, we can only send a limited amount of data each network round trip, as the server needs to wait for the browser to acknowledge it successfully received each burst of data. This means the server needs to choose which of the multiple requests to respond to first.</p>



<p>Let‚Äôs take an example where the browser has loaded the .html page and now requests 3 resources at the same time on one H2/H3 connection: a <code>defer</code>red JS file (100KB), and two .jpg images (300 and 400KB). Let‚Äôs say the server is limited to sending just 50KB (about 35 packets) in this round trip (the exact numbers depend on various factors). It now has to choose how to fill those 35 packets. What should it send first though?</p>



<p>You could make the argument that JS is always important (high priority), even though it‚Äôs deferred. You could also claim instead that there‚Äôs a high chance that one of the images is a likely Largest Contentful Paint candidate and that one of them should be given preference (but which one?). You could even go as far as to say that jpg images can be rendered progressively, and that it makes sense to give each image 25KB (we call this the ‚Äúinterleaving‚Äù or multiplexing of resource data). But what if the deferred JS is the thing that will actually load the LCP image instead‚Ä¶ maybe give it some bandwidth too?</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/multiplexing-options.png" alt="Multiplexing render blocking resources"/></p>



<p>It‚Äôs clear that the server‚Äôs choice here can have a big impact on various Webperf metrics, as some resource data will always be delayed behind ‚Äúmore important‚Äù data of a ‚Äúhigher priority‚Äù. If you send the JS first, the images are delayed by 1 or multiple network round trips, and vice versa. This is especially impactful for things like (render-blocking) JS and CSS, which have to be downloaded in full before they can be applied/executed.</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/multiplexing-render-blocking.png" alt="Multiplexing render blocking resources"/></p>



<blockquote><p>Note: this is why I hate it when people say that H2 and H3 allow you to send multiple resources <strong>in parallel</strong>, as it‚Äôs not really parallel at all! H1 is much more parallel than H2/3, as there you do have 6 independent connections. At best, the H2/3 data is <strong>interleaved</strong> or multiplexed on the wire (for example distributing data across the two images above), but usually the responses are still sent sequentially (first image 1 in its entirety, then image 2). As such, as a pedant, I rather speak of <strong>concurrent</strong> resources (or, if you really want, parallel requests and multiplexed responses).</p></blockquote>



<p>The problem here is that the server doesn‚Äôt really have enough information to make the best choice. In fact, it wouldn‚Äôt even know the JS file was marked as <code>defer</code> in the HTML, as that piece of context is not included in the HTTP request by the browser (and servers don‚Äôt typically parse the HTML themselves to discover these modifiers). Similarly, the server doesn‚Äôt know if the images are immediately visible (e.g., in the viewport) or not yet visible (user has to scroll down, 2nd image in a carousel, etc.). It also doesn‚Äôt know about the fancy new <code>fetchpriority</code> attribute! If you want some more in-depth examples, see my <a href="https://www.youtube.com/watch?v=nH4iRpFnf1c">FOSDEM 2019 talk</a> or my <a href="https://vimeo.com/768728308">Fronteers 2022 talk</a>.</p>



<p>It follows that it‚Äôs really the browser which has enough context to decide which resource should be loaded first. As such, it needs a way to communicate its preferences to the server. This is exactly what HTTP prioritization is all about: <strong>a standardized way for browsers to signal servers in what order requested resource data should be sent</strong>.</p>





<h2>Resource loading delays</h2>



<p>At this point, it‚Äôs important to note that prioritization isn‚Äôt the only thing influencing actual resource delivery order. After all, prioritization only determines how multiple requests that are active <strong>at the same time</strong> are processed. You might expect that, for HTTP/2 and HTTP/3, browsers will indeed request resources as soon as they are discovered in the HTML, relying on just prioritization to get correct behaviour. However, you would be wrong.</p>



<p>In practice, all browsers have some (advanced or basic) logic to <strong>actively delay certain requests</strong> even after the resource <a href="https://web.dev/preload-scanner/">has been discovered</a>. A simple example is a <code>prefetch-ed</code> resource, which is typically indicated in a &lt;link&gt; element in the &lt;head&gt;, but is only requested by the browser when the current page is done loading.</p>



<p>Another example is <a href="https://docs.google.com/document/d/1bCDuq9H1ih9iNjgzyAL0gpwNFiEP4TZS-YLRp_RuMlc">Chromium‚Äôs ‚Äútight mode‚Äù</a>, which will actively delay less important resources (e.g., images, CSS and JS in the HTML) until the more important resources have (mostly) been downloaded. There is for example also a limit on the amount of preloads that are active at the same time.</p>



<p>This general concept can also be seen in the following waterfall diagram, which clearly shows some resources only being requested after some time, even though they were discovered much earlier.</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/loading-delay-waterfall.jpg" alt="Resource loading delays"/></p>



<p>In practice, we get a quite complicated interplay between which requests the browser sends out at the same time and how they are prioritized in relation to each other. However, exploring this interplay completely would take us too far in this post. My test approach described below does allow for it however, so that‚Äôs something I plan to do in the future. You can also help me ping <a href="https://twitter.com/tunetheweb">Barry Pollard</a>, who‚Äôs been promising me a blog post on the finer points of these things for like, forever!</p>









<p>If you look at the priority column in the Network tab of the browser devtools (see Figure 4 above), you can see textual values of High to Low (or similar) and you might think that‚Äôs what is sent to the server as well. However, that‚Äôs (sadly) not the case.</p>



<p>Especially in HTTP/2, there is a much more advanced system at work, called the ‚ÄúPrioritization Tree‚Äù. Here, the resources are arranged in a tree datastructure. The position of the resource in the tree (what are its parents and siblings) and an associated ‚Äúweight‚Äù influences when it is given bandwidth and how much. When they request a resource, browsers use a special additional HTTP/2 message (the <a href="https://www.rfc-editor.org/rfc/rfc9113.html#name-priority">PRIORITY frame</a>) to tell the server where in the tree the resource belongs.</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/firefox-tree.jpg" alt="Firefox prioritization tree"/></p>



<p>This system is very flexible and powerful, but as it turns out, it‚Äôs also complex; too complex. So complex, that even today <a href="https://github.com/andydavies/http2-prioritization-issues">many HTTP/2 implementations have serious bugs in this system</a>, and some stacks simply don‚Äôt implement it at all (ignoring the browser‚Äôs signals). Browsers also <a href="https://speeder.edm.uhasselt.be/www18/files/h2priorities_mwijnants_www2018.pdf">use the system in very different ways</a>.</p>



<p>This is why, when work started on HTTP/3, we decided a simpler system was needed. This is what eventually became <a href="https://www.rfc-editor.org/rfc/rfc9218.html">RFC 9218: Extensible Prioritization Scheme for HTTP</a>. Instead of a full tree, this setup has just 8 numerical priority levels (called ‚Äúurgency‚Äù, with values 0-7) and one ‚Äúincremental‚Äù boolean flag to indicate if a resource can be interleaved with other resources or not (progressive jpgs: yes please. Render-blocking JS: probably best not). By default, a resource has an urgency of 3 and is non-incremental.</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/urgency-incremental.jpg" alt="RFC9218 priorities"/></p>



<p>The concept is simple: servers should first send all resources in the highest non-empty priority group (lowest urgency: u=0 should be processed before u=1 etc.) before moving on to the next group. As such, as long as there is a u=0 resource active (and we have data to send for it), there should be no data sent for other urgency groups. Within a single group, resources should be sent in request order (earlier before later), so JS higher in the &lt;head&gt; is delivered before JS lower in the &lt;head&gt; (as expected).</p>



<blockquote><p>Note: this is all simple if there are only incremental or only non-incremental resources in 1 urgency group. If we start to mix them (say a non-incremental JavaScript and two incremental images, all in u=3, as in our example above), it‚Äôs not very clear what to do. Do we send the JS in full first (as it‚Äôs non-incremental)? Or should we give some early bandwidth to the images as well (since they‚Äôre the same priority AND can be sent incrementally)? Sadly, this is where the RFC itself doesn‚Äôt really give concrete guidance, as there are pros and cons for the various options. At this point in time, it also doesn‚Äôt matter much, since browsers don‚Äôt create these situations yet (though there are plans to change, see below!). For some more discussion on these edge cases, I have <a href="https://youtu.be/nH4iRpFnf1c?t=1416">a nice video</a> for you.</p></blockquote>



<p>The new system is also simpler in how it sends the urgency and incremental signals: instead of a special HTTP/3 message, it can just use a new textual HTTP header called, shockingly, <code>priority</code>. The hope is that this overall simpler approach is easier to implement and debug, and that it will lead to much better support and fewer bugs than we had with the H2 system (spoiler for later: that‚Äôs not exactly true yet).</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/priority-header.jpg" alt="Priority header"/></p>



<blockquote><p>That‚Äôs at least the idea. In practice, the HTTP header can only be used to signal a resource‚Äôs <strong>initial</strong> priority. If the priority needs to be updated later (say a lazy loaded image first gets low priority, but needs to switch to high when scrolled into view), this sadly cannot be done using an HTTP header. For that, we do need a special H3 (and H2!) binary message: the <a href="https://www.rfc-editor.org/rfc/rfc9218.html#name-the-priority_update-frame">PRIORITY_UPDATE frame</a>. These details aren‚Äôt really important for most people, but I mention this because while Firefox and Safari use the HTTP header, Chromium does not. For ‚Äúreasons‚Äù, Google only uses the PRIORITY_UPDATE frame, even to signal the initial priority (put differently: it just immediately overrides the default priority).</p></blockquote>



<p>It‚Äôs important to note that this new scheme is not exclusive to HTTP/3. Indeed, the intent is that it would be backported to existing H2 implementations over time (though, by my knowledge, no H2 stack has adopted this today). Additionally, it‚Äôs called the ‚Äúextensible‚Äù scheme, with a view towards adding additional parameters beyond ‚Äúurgency‚Äù and ‚Äúincremental‚Äù in the future.</p>









<p>As I mentioned above, browsers used the complex HTTP/2 system in very different ways. Each of the major browser engines (Chromium, Firefox and Safari) produced radically different prioritization trees and signals. Cloudflare has a quite <a href="https://blog.cloudflare.com/better-http-2-prioritization-for-a-faster-web/">extensive blogpost</a> on this, and I have <a href="https://h3.edm.uhasselt.be/files/HTTP3_Prioritization_extended_3jul2019.pdf">an academic paper</a> that goes into way too much detail.</p>



<p>For the rest of the post, I will focus on HTTP/3 with the new system only, as all 3 of the main browsers support it. I was curious to find out if there are still big differences in their approaches. Sadly, only Chrome has some <a href="https://web.dev/priority-hints/#resource-priority">accessible public documentation</a> of their approach and logic, and no one had looked into Safari and Firefox behaviour yet, so it was time to roll up my sleeves and get my hands dirty!</p>



<blockquote><p>I could make a cynical remark here about the Googlers releasing (excellent) blog posts on the encompassingly named ‚Äúweb.dev‚Äù talking about ‚Äúbrowser features‚Äù but then often only describing how their own browser acts. However, let‚Äôs not do that, as similar remarks can be made towards the other browser vendors who (in my opinion) put way too little money towards public documentation.</p></blockquote>



<p>I immediately ran into two problems:</p>



<ol><li>Observing the new signals was difficult, as no tools have support for them yet. They don‚Äôt show up (in their raw form) in the browser devtools, nor in WebPageTest. I decided to <a href="https://github.com/http3-prioritization/aioquic/tree/priority-logging">modify the excellent aioquic HTTP/3 server</a> to add some additional logging for the prioritization signals.</li><li>I asked around, but there was no single test page that included all the different resource loading options that can impact prioritization (async/defer, lazy/eager, fetchpriority, preload/prefetch, etc.). I thus <a href="https://github.com/http3-prioritization/prioritization-test-page">created my own test page</a> that includes a whopping 36 different situations to make it easy to test.</li></ol>



<p>I then hosted the custom test page on the custom HTTP/3 server and loaded it with the 3 browsers. I stored the HAR files from the browsers, and the logs from the server to find out what the browsers were actually sending on the wire. More details on the results are/will be <a href="https://github.com/http3-prioritization/prioritization-experiments">available on github</a>, and I‚Äôll highlight the key points below.</p>





<h2>Raw protocol details</h2>



<p>I‚Äôll start here with some of the raw, low-level results. If you don‚Äôt care about the details, skip to <a href="#sec_keylearnings">the next section</a>, which provides a more high-level discussion.</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/raw-results.jpg" alt="Raw prioritization results"/></p>



<p>Firstly, as I mentioned before, Chromium uses only the <code>PRIORITY_UPDATE</code> frame, and not the HTTP header. Firefox and Safari do the opposite, only using the header. Due to the nature of the test page (just the initial load), I wasn‚Äôt able to observe if the browsers actually send updates, though <a href="https://web.dev/priority-hints/#summary">it is known</a> that Chromium does this for images (which start at a low priority and are then bumped to high if they are visible). In this situation, Chromium just sends 2 <code>PRIORITY_UPDATE</code> frames, one for the initial priority, and one for the actual update afterwards. Protocol nerd detail: the initial <code>PRIORITY_UPDATE</code> is sent before the HTTP headers!</p>



<p>A second big difference is the use of the incremental parameter. Chromium and Firefox never set it, causing it to default to ‚Äúoff‚Äù. This means that servers should not distribute bandwidth across multiple resources; the most important resource should be loaded in full before moving to the next. Safari does the opposite: it sets the incremental parameter for <strong>all resource types</strong>, including render-blocking JS and CSS resources. As explained above, that‚Äôs not always a great idea.</p>



<blockquote><p>It‚Äôs important to note that <strong>there are concrete plans to change Chromium‚Äôs behaviour</strong> in the near future. From what I‚Äôve heard, it would set the incremental parameter for everything, <strong>except</strong> the (high priority) JS and CSS files. This would solve some long standing bugs, such as <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=849106">this one</a> from Wikipedia, who found large HTML downloads can delay render-blocking CSS without a good reason. This work will be tracked in <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1362031">this crbug</a>, which highlights another issue with Chromium‚Äôs sequential-only approach. Crucially, this means that <strong>Chromium will use different prioritization logic for HTTP/2 compared to HTTP/3</strong> (as for HTTP/2, it also doesn‚Äôt use the equivalent of the incremental parameter today). This could have a large impact on your pages depending on your setup, and it might be <a href="https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2">yet another reason</a> to switch to HTTP/3 sooner rather than later. Finally, note that this is already the case for Firefox as well, which does use incremental signals in HTTP/2, but not in HTTP/3.</p></blockquote>



<p>Thirdly, there are some minor differences in how the signals are used. For example, Chromium and Firefox don‚Äôt explicitly send a signal for ‚Äúu=3‚Äù, as it‚Äôs the default, which they expect the servers to respect. Safari however does send ‚Äúu=3,i‚Äù explicitly. The browsers also use different urgency values. Internally, Chromium and Safari use 5 priority levels (conceptually: Highest, High, Medium, Low, Lowest), while Firefox seems to use just 4. Chromium maps these to the first 5 urgency numbers (0,1,2,3,4), while Safari spreads them out more (0,1,3,5,7) and Firefox skips 0 (1,2,3,4). This should have no impact on how servers deliver resources (lower urgency values are more important, no matter which exact number is used), but it‚Äôs still interesting we have 3 different approaches even for such a simple system.</p>



<blockquote><p>For the key learnings below, I‚Äôve mapped the different numerical urgency values to Highest, High, Medium, Low, Lowest (except for Firefox, which only uses 4, and so doesn‚Äôt have a ‚ÄúLowest‚Äù).</p></blockquote>





<h2>Key learnings</h2>



<p>As you probably expected, besides the protocol details, the <strong>browsers also differ quite a bit in the importance they assign to different types of resources and loading methods</strong>. Below I‚Äôll discuss a few groups of resource types (HTML and fonts, CSS, JS, images, fetch) and some key differences between the 3 browsers. Note that I‚Äôll try to refrain from ‚Äúpassing judgement‚Äù on which approach is the best here. This will depend on your specific page setup and which features you use. See these results more as a guide on how to (potentially) tweak things on a per-browser basis.</p>











<p>Luckily, all browsers agree the main HTML document is the most important (who knew!). However, for fonts, we see major differences. Chromium finds fonts as important as the HTML itself, while Safari and Firefox put them at Medium or even Low. Especially comparing this to the priority of other resources like CSS and JS (see below), Chromium puts a <strong>much</strong> higher emphasis on fonts than the other two browsers. Preloading fonts is also interesting: Chromium actually <em>lowers</em> the priority in this case (likely because preloading is used to hint at resources that will be needed down the line, but probably not <em>right now</em>). Firefox employs the opposite logic, assigning preloaded fonts a higher priority.</p>







<p>The key difference for CSS loaded in the &lt;head&gt; is that Chromium assigns it the highest priority, putting it on-par with the HTML document, while the others put all CSS in the ‚ÄúHigh‚Äù category. For CSS lower in the HTML (in my test case, on the very bottom), Chromium interestingly puts it in ‚ÄúMedium‚Äù (which makes sense, as it isn‚Äôt really ‚Äúrender blocking‚Äù for useful content at that point). All browsers (accurately) put the CSS with <code>media=&#34;print&#34;</code> in their lowest priority (remember: Firefox doesn‚Äôt do ‚ÄúLowest‚Äù).</p>







<p>For JS, things are a bit all over the place. All browsers emphasize render-blocking JS in the &lt;head&gt;, but besides that things diverge. For preloaded JS, only Firefox reduces the priority (probably using Chromium‚Äôs logic for fonts), but all browsers do (correctly) severely downgrade prefetched JS. Async/defer are weirder though, with both Chromium and Firefox assigning them equal priorities; personally, I‚Äôd maybe expect defer to be lower priority due to the semantics? Safari is the odd one here though, making defer higher priority than async (I really don‚Äôt see a good reason for that, as it <a href="https://caniuse.com/?search=defer">should support the feature</a>). Additionally, Safari assigns equal priority to JS that‚Äôs loaded later on the page compared to the &lt;head&gt;, while the others employ lower values. Finally, Safari uses the same priority (High) for almost all CSS and JS, which means less important files can easily delay crucial ones, especially since Safari uses the ‚Äúincremental‚Äù parameter for all requests (see above).</p>







<p>For the images, the behaviours are more consistent and (arguably) more expected. One interesting anomaly is that Safari gives a lower priority to hidden images that are not lazy loaded (normal &lt;img&gt; inside a <code>display: none</code> &lt;div&gt; in my test page), while Firefox and Chromium treat that the same as a visible image. Additionally, we have two clear examples that highlight that prioritization alone isn‚Äôt enough: both preload and lazy loading do not impact the image priority at all! These features will only impact <strong>when</strong> a resource is actually requested (<a href="#sec_loadingdelays">see above</a>)! This also shows very clearly why we need the new <code>fetchpriority</code>, as that‚Äôs the thing that actually increases the priority (at least in Chromium, though Firefox is reported to be working on support). Finally, the test page also had a hidden lazy loaded image, which wasn‚Äôt requested in any of the browsers (as expected!).</p>







<p>Finally, I wanted to test the prioritization of requests made using the JavaScript <code>fetch()</code> API. Here again, the browsers disagree quite heavily. Chromium finds these requests very important, while Firefox defaults to a Low priority (equal to images or, indeed, even prefetches‚Ä¶). I also tested doing <code>fetch()</code> from inside a deferred JS file (second line), as I thought maybe Chromium would give it lower priority (in line with the deferred JS itself), but that doesn‚Äôt happen. Next, we have another illustration of the usefulness of the <code>fetchpriority</code> attribute, in this case to lower the priority in Chromium.</p>



<p>Finally, I wanted to try overriding the priority information. After all, in the new system this is done using an HTTP header, and you can set custom headers in the <code>fetch()</code> call! Unsurprisingly, manually passing a header of <code>priority: u=0,1</code> we again find 3 different behaviours:</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/manual-fetch-priority.jpg" alt="Custom priority header in fetch"/></p>



<p>Chromium sends both its <code>PRIORITY_UPDATE</code> frame and the custom header. Firefox simply sends 2 <code>priority</code> header fields: its own and then the one from <code>fetch()</code>. I‚Äôm not 100% sure, but I think that‚Äôs not really allowed <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-field-order">per the HTTP RFC</a>, Mozillians. The two values are contradictory, so it‚Äôs not clear which the server should choose (in the table above, I‚Äôve chosen Firefox‚Äôs default of <code>u=4</code>). Finally, Safari overrides its own header with the one we passed to <code>fetch()</code>, which is arguably the ‚Äúcorrect‚Äù (or at least expected) behaviour.</p>



<p>Overall, it was somewhat surprising to me that the browsers allow manual setting of this header, as previously in discussions at the IETF they indicated they wouldn‚Äôt (at least Chromium was quite vocal about it). This can in theory be used to do very fine-grained resource loading with custom priorities for things like Single Page Apps, which would be interesting to explore!</p>



<p>In conclusion, I find it remarkable how much the browsers disagree on how important certain types of resources are. You would expect this would be more consistent, as it‚Äôs not dependent on browser implementation, but rather the (HTML) loading semantics, which are (should be) the same across browsers. It‚Äôs almost as if these approaches are chosen somewhat willy-nilly with a best-guess approach, without actually testing (nor properly documenting) them in the wild. I feel another rant coming on, so quickly, let‚Äôs switch to the next section!</p>









<p>As we‚Äôve seen, even in the new and simpler system, there are still plenty of differences in how and which prioritization signals the browsers send to the servers. Still, for the servers this shouldn‚Äôt matter: they should just be able to follow whatever the browser throws at them, and be able to adhere to that as best as possible. But do they?</p>



<blockquote><p>Note: it‚Äôs not always possible to follow the signals to the letter. Especially in more complex setups (for example with a CDN), it can be that there‚Äôs no data yet available for higher priority resources (for example, they weren‚Äôt cached at the edge yet), and it makes sense to start sending lower priority data in the mean time.</p></blockquote>



<p>Again, I found that no one had yet done a survey of (mature) HTTP/3 servers to determine their support for the new prioritization system (for reference, <a href="https://github.com/andydavies/http2-prioritization-issues">this was done for HTTP/2 servers</a> a while ago). Time to get my hands dirty, again.</p>



<p>Sadly, here I found some less than stellar results. Almost none of the servers I tested <strong>fully</strong> adhered to even relatively straightforward priority signals, and most had severe problems with the more complex combinations (which, again, aren‚Äôt used by browsers (yet!)).</p>



<p>Since this was the case, I have <strong>decided to not ‚Äúname and shame‚Äù server implementations</strong> here, as I don‚Äôt think that would be a constructive approach. Instead, I have (and will continue to) contact(ed) server implementers directly to see how the issues can be resolved. Then, in 6 months or a year, we can revisit and do a proper comparison.</p>



<p>Just to give you an idea of the bad behaviour observed however, look at these WebPageTest screenshots using <a href="https://github.com/pmeenan/http2priorities/tree/master/stand-alone">Patrick Meenan‚Äôs original test page</a> loaded via Chromium:</p>



<p><img src="https://calendar.perfplanet.com/wp-content/uploads/2022/12/server-behaviour.png" alt="HTTP/3 server behaviour"/></p>



<p>As you can see, data is not always received per the browser‚Äôs signals, which can again have an impact on some Webperf metrics. If you‚Äôve started experimenting with HTTP/3 and you get some less-than-expected results, this might be one of the reasons/things to look into.</p>



<p>Personally, I‚Äôm quite surprised that these issues exist. One of the reasons for bad HTTP/2 server behaviour was that the HTTP/2 prioritization tree was quite complex to implement correctly. Arguably, the new HTTP/3 system should be much easier, and still we see some high-impact bugs in so-called mature implementations. I could rant about this for a few hundred thousand more words, but instead, let‚Äôs just conclude this post, shall we üòâ</p>









<p>The main thing I hope you take away from this article is that browsers have major differences in how they load resources over HTTP (and priortization is just one example of this!). Depending on your page setup, you might see medium or large webperf differences between the browsers, and thus you should be aware of these nuances to deal with these edge cases.</p>



<p>I hope it also shows how important the new ‚Äúpriority hints‚Äù and <code>fetchpriority</code> attribute are. They don‚Äôt just allow changing a browser‚Äôs default behaviour, they allow getting more consistent behaviour <strong>across browsers</strong> (at least once Firefox and Safari get around to implementing them‚Ä¶).</p>



<p>Finally, on a broader ‚ÄúSoftware Engineering‚Äù note, it‚Äôs interesting that having a simpler system does not immediately imply consistent behaviour across implementations, nor does it mean those stacks will be bug-free from the start. Still, I‚Äôm proud to <a href="https://www.rfc-editor.org/rfc/rfc9218.html#name-acknowledgements">have helped design</a> the new HTTP/3 system. I think it is a step in the right direction and I hope we get to backport it to HTTP/2 implementations down the line as well.</p>



<h2>Acknowledgements</h2>



<p>Thanks in particular to Barry Pollard, Lucas Pardue and Patrick Meenan for some help when writing this article.</p>
</div></div>
  </body>
</html>
