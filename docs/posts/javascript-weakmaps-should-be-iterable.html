<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wingolog.org/archives/2024/08/19/javascript-weakmaps-should-be-iterable">Original</a>
    <h1>JavaScript weakmaps should be iterable</h1>
    
    <div id="readability-page-1" class="page"><div><p>Good evening.  Tonight, a brief position statement: it is a mistake for
JavaScript’s <tt>WeakMap</tt> to not be iterable, and we should fix it.</p><h3>story time</h3><p>A <tt>WeakMap</tt> associates a key with a value, as long as the key is
otherwise reachable in a program.  (It is an <a href="https://wingolog.org/archives/2022/10/31/ephemerons-and-finalizers">ephemeron
table</a>.)</p><p>When <tt>WeakMap</tt> was added to JavaScript, back in the ES6 times, some
implementors thought that it could be reasonable to implement weak maps
not as a data structure in its own right, but rather as a kind of
property on each object.  Under the hood, adding an <i>key→value</i>
association to a map <i>M</i> would set <tt>key[M] = value</tt>.  GC would be free
to notice dead maps and remove their associations in live objects.</p><p>If you implement weak maps like this, or are open to the idea of such an
implementation, then you can’t rely on the associations being enumerable
from the map itself, as they are instead spread out among all the key
objects.  So, ES6 specified <tt>WeakMap</tt> as not being
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterable</a>;
given a map, you can’t know what’s in it.</p><p>As with many things GC-related, non-iterability of weak maps then gained
a kind of legendary status: the lore states that
non-iterability preserves some key flexibility for JS implementations,
and therefore it is good, and you just have to accept it and move on.</p><h3>dynamics</h3><p>Time passed, and two things happened.</p><p>One was that this distributed <tt>WeakMap</tt> implementation strategy did not
pan out; everyone ended up implementing weak maps as their own kind of
object, and people use <a href="https://blog.mozilla.org/sfink/2022/06/09/ephemeron-tables-aka-javascript-weakmaps/">an algorithm like the one Steve Fink described a
couple years
ago</a>
to compute the <i>map×key⇒value</i> conjunction.  The main original
motivation for non-iterability was no longer valid.</p><p>The second development was <a href="https://github.com/tc39/proposal-weakrefs?tab=readme-ov-file#weakrefs-tc39-proposal"><tt>WeakRef</tt> and
<tt>FinalizationRegistry</tt></a>,
which expose some details of reachability as viewed by the garbage
collector to user JS code.  With <tt>WeakRef</tt> (and
<tt>WeakMap</tt>), <a href="https://github.com/tc39/proposal-weakrefs?tab=readme-ov-file#iterable-weakmaps">you can build an iterable
<tt>WeakMap</tt></a>.</p><p>(Full disclosure: I did work on ES6 and had a hand in
<tt>FinalizationRegistry</tt> but don’t do JS language work currently.)</p><p>Thing is, your iterable <tt>WeakMap</tt> is strictly inferior to what the
browser can provide: its implementation is extraordinarily gnarly,
shipped over the wire instead of already in the browser, uses more
memory, is single-threaded and high-latency (because
<tt>FinalizationRegistry</tt>), and non-standard.  What if instead as language
engineers we just did our jobs and standardized iterability, as we do
with literally every other collection in the JS standard?</p><p>Just this morning I wrote <a href="https://gitlab.com/spritely/guile-hoot/-/blob/main/reflect-js/reflect.js?ref_type=heads#L158-201">yet another iterable
<tt>WeakSet</tt></a>
(which has all the same concerns as <tt>WeakMap</tt>), and while it’s
sufficient for my needs, it’s not good (lacking prompt cleanup of dead
entries), and by construction can’t be great (because it has to be
redundantly implemented on top of <tt>WeakSet</tt> instead of being there
already).</p><p>I am sympathetic to deferring language specification decisions to allow
the implementation space to be explored, but when the exploration is
done and the dust has settled, we shouldn’t hesitate to pick a winner:
JS weak maps and sets should be iterable.  Godspeed, brave TC39 souls;
should you take up this mantle, you are doing the Lord’s work!</p><p><i>Thanks to Philip Chimento for notes on the timeline and Joyee Cheung for notes on the iterable <tt>WeakMap</tt> implementation in the <tt>WeakRef</tt> spec.  All errors
mine, of course!</i></p></div></div>
  </body>
</html>
