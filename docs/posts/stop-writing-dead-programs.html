<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jackrusher.com/strange-loop-2022/">Original</a>
    <h1>Stop Writing Dead Programs</h1>
    
    <div id="readability-page-1" class="page">
    <iframe id="vid" width="560" height="315" src="https://www.youtube.com/embed/8Ab3ArE8W3s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
    <p><h3>TRANSCRIPT AND NOTES</h3></p>
    <p><span>00:00:12.95</span> My talk today is <em>Stop Writing Dead Programs</em>.</p><p><span>00:00:14.57</span> This is sort of the thesis statement</p><p><span>00:00:16.01</span> for the talk, even though it&#39;s 40 years</p><p><span>00:00:18.52</span> old, this <a href="https://en.wikipedia.org/wiki/Seymour_Papert">Seymour Papert</a> quote saying</p><p><span>00:00:19.91</span> that we&#39;re still digging ourselves into</p><p><span>00:00:21.65</span> a kind of a pit by continuing to</p><p><span>00:00:23.68</span> preserve practices that have no rational</p><p><span>00:00:26.92</span> basis beyond being historical.</p><p><span>00:00:29.08</span> I will start with a somewhat personal</p><p><span>00:00:30.47</span> journey in technology. I&#39;m going to ask</p><p><span>00:00:31.66</span> you for some feedback at some different</p><p><span>00:00:34.13</span> places, so first off – by applause – how</p><p><span>00:00:36.97</span> many of you know what this is?</p><p><span>00:00:40.43</span> Okay, okay, that&#39;s actually more</p><p><span>00:00:41.86</span> than I expected. Now, how many of you</p><p><span>00:00:44.33</span> actually used one of these?</p><p><span>00:00:47.63</span> Okay, so what I can say is that I am part</p><p><span>00:00:49.36</span> of the last generation of people who</p><p><span>00:00:51.04</span> were forced to use punch cards at school.</p><p><span>00:00:52.79</span> I still had to write <a href="https://en.wikipedia.org/wiki/Fortran">Fortran</a> programs</p><p><span>00:00:55.25</span> with <a href="https://en.wikipedia.org/wiki/Punched_card">punch cards</a>, and this thing is a</p><p><span>00:00:56.93</span> card punch. It&#39;s like a keyboard,</p><p><span>00:00:58.85</span> except when you press the keys you&#39;re</p><p><span>00:01:00.22</span> actually making holes in a piece of</p><p><span>00:01:01.54</span> paper, and then you feed them</p><p><span>00:01:03.29</span> into this thing in the back, and the</p><p><span>00:01:05.57</span> pieces of paper look like this. So each</p><p><span>00:01:06.83</span> one of these vertical columns is</p><p><span>00:01:08.51</span> basically a byte, and you&#39;re stabbing</p><p><span>00:01:10.19</span> through the different bits of the</p><p><span>00:01:11.81</span> byte to indicate what letter it is. If</p><p><span>00:01:13.37</span> you look at the top left corner,</p><p><span>00:01:16.55</span> you see <code>Z(1) = Y + W(1)</code>.</p><p><span>00:01:19.19</span> This is one line of code – a</p><p><span>00:01:21.53</span> card is one line of code. Something to</p><p><span>00:01:23.87</span> notice about this card it&#39;s 80 columns</p><p><span>00:01:25.55</span> wide. We&#39;re going to come back to that</p><p><span>00:01:25.56</span> later.</p><p>Some commenters were confused that we still used punched cards in the 80s, when display terminals already existed. This was in the context of a required class for engineering students to prepare them for the possibility that they would encounter punch cards in the wild. Most of us never did, beyond this one class.</p><p><span>00:01:27.46</span> This design dates from</p><p><span>00:01:29.45</span> 1928. This is a <a href="https://en.wikipedia.org/wiki/Herman_Hollerith">Hollerith punch card</a>, the</p><p><span>00:01:31.42</span> same one used forever. Now, what does a</p><p><span>00:01:34.24</span> program look like if you&#39;re programming</p><p><span>00:01:35.33</span> like this? It looks like this: it&#39;s a deck.</p><p><span>00:01:37.37</span> Now notice the rubber band. When you&#39;re</p><p><span>00:01:40.01</span> doing this, you live in terminal fear</p><p><span>00:01:41.74</span> that you will drop the deck of cards. It</p><p><span>00:01:44.39</span> is a terrible experience resorting</p><p><span>00:01:47.21</span> the cards. That long diagonal stripe</p><p><span>00:01:48.89</span> there is so that this person, who made</p><p><span>00:01:50.51</span> this particular deck, could put it back</p><p><span>00:01:51.83</span> together without having to look at every</p><p><span>00:01:53.33</span> single line in the process. And the words</p><p><span>00:01:55.24</span> written on the top of the deck are sort</p><p><span>00:01:57.59</span> of indicating where different</p><p><span>00:01:58.49</span> subroutines are located within this program.</p><p><span>00:02:00.95</span> Now, to give you a sense of how long</p><p><span>00:02:02.99</span> these programs can get, this picture</p><p><span>00:02:05.45</span> (forgive me, it&#39;s a low quality picture).</p><p><span>00:02:06.64</span> This is the actual reader I used and</p><p><span>00:02:08.63</span> that in the front there is an actual</p><p><span>00:02:10.01</span> program I wrote. The lower right hand</p><p><span>00:02:11.80</span> corner one, which was a Fortran program</p><p><span>00:02:13.85</span> to simulate rocket flight, because my my</p><p><span>00:02:16.72</span> particular school had a connection to</p><p><span>00:02:18.22</span> NASA and we did a lot of Rocket-y things.</p><p><span>00:02:19.67</span> Right, so can you imagine how long it</p><p><span>00:02:22.25</span> took me to punch all these and put them</p><p><span>00:02:23.51</span> in there, and what we would do is give</p><p><span>00:02:25.25</span> them to a system operator who would feed</p><p><span>00:02:26.75</span> them into a computer. In this case the</p><p><span>00:02:28.67</span> computer I personally used was this one.</p><p><span>00:02:30.53</span> This is a <a href="https://en.wikipedia.org/wiki/VAX-11">VAX-11/780</a>. This machine cost</p><p><span>00:02:34.19</span> nearly a million dollars, and had 16</p><p><span>00:02:35.99</span> megabytes – that&#39;s megabytes – of RAM, ran at</p><p><span>00:02:38.69</span> 5 megahertz – that&#39;s megahertz! This</p><p><span>00:02:41.44</span> thing in front of me here is thousands</p><p><span>00:02:43.36</span> of times more powerful than the machine</p><p><span>00:02:44.80</span> that I was using then – that the whole</p><p><span>00:02:46.13</span> campus was using to do these kinds of</p><p><span>00:02:47.57</span> things then – and what would the output</p><p><span>00:02:49.49</span> look like that came from sending this</p><p><span>00:02:51.35</span> enormous deck of cards in? Well, it would</p><p><span>00:02:53.15</span> come out on a <a href="https://en.wikipedia.org/wiki/Line_printer">line printer</a> that looks like</p><p><span>00:02:54.77</span> this. And you wouldn&#39;t get it right</p><p><span>00:02:56.75</span> away. An operator would give it to you</p><p><span>00:02:58.72</span> later. Note the vintage haircuts, the</p><p><span>00:03:00.89</span> fellow in the middle there is the actual</p><p><span>00:03:02.57</span> operator who was handing me these</p><p><span>00:03:03.71</span> outputs, and he&#39;s the person who gave me</p><p><span>00:03:04.85</span> these photos of this equipment.</p><p><span>00:03:06.47</span> So this process, as you can imagine, was</p><p><span>00:03:08.57</span> hard, but it was hard in a dumb way.</p><p><span>00:03:11.33</span> Some things are hard because they have</p><p><span>00:03:13.07</span> to be, and I really support the idea of</p><p><span>00:03:14.69</span> overcoming challenges and doing hard</p><p><span>00:03:16.43</span> things, but this was hard</p><p><span>00:03:18.29</span> for reasons had nothing to do with the</p><p><span>00:03:19.79</span> actual problem you&#39;re trying to [solve].</p><p><span>00:03:22.19</span> Like, something with a rocket and a simulation,</p><p><span>00:03:23.57</span> and you&#39;re thinking about not dropping</p><p><span>00:03:25.13</span> your punch card deck, and it&#39;s taking you</p><p><span>00:03:26.57</span> forever to find out what happened. So, it</p><p><span>00:03:29.14</span> really hinges on your ability to emulate</p><p><span>00:03:30.94</span> the computer in your head because the</p><p><span>00:03:33.11</span> computer&#39;s not going to help you in any</p><p><span>00:03:34.30</span> way. There&#39;s not an editor, there&#39;s</p><p><span>00:03:35.44</span> nothing, and that in turn hinges on</p><p><span>00:03:38.08</span> working memory, which is something that</p><p><span>00:03:39.47</span> is not very well distributed among</p><p><span>00:03:41.08</span> humans. There were a small number of</p><p><span>00:03:42.94</span> us for whom this whole thing came pretty</p><p><span>00:03:44.57</span> naturally, and we were treated as, like,</p><p><span>00:03:46.78</span> special people – as kind of high priests</p><p><span>00:03:48.58</span> with magical powers, and this is how we</p><p><span>00:03:50.69</span> came to think of ourselves, right, that</p><p><span>00:03:52.36</span> we&#39;re special [because] we can make it work.</p><p><span>00:03:53.86</span> But the truth is we were less priests</p><p><span>00:03:55.97</span> like this than we were monks like this – </p><p><span>00:03:57.41</span> hitting ourselves in the head.</p><p><span>00:03:59.93</span> Right, but the problem is –</p><p><span>00:04:02.86</span> as <a href="https://twitter.com/pushcx/status/1566843542990880768">Peter Harkins mentions here</a> – that</p><p><span>00:04:05.39</span> programmers have this tendency to, once</p><p><span>00:04:07.07</span> they master something hard (often</p><p><span>00:04:08.86</span> pointlessly hard), rather than then making</p><p><span>00:04:10.78</span> it easy they feel proud of themselves</p><p><span>00:04:12.58</span> for having done it and just perpetuate</p><p><span>00:04:14.33</span> the hard nonsense. And I&#39;m going to argue</p><p><span>00:04:16.67</span> that a lot of what we still do today is</p><p><span>00:04:18.28</span> very much like what I was doing on that</p><p><span>00:04:19.78</span> old VAX. For one thing, there&#39;s a lot of</p><p><span>00:04:21.59</span> batch processing going on, and</p><p><span>00:04:23.74</span> what&#39;s wrong with batch processing? Hella</p><p><span>00:04:25.73</span> long feedback loops. It&#39;s no good, takes</p><p><span>00:04:27.77</span> you forever – it took me 45 minutes to</p><p><span>00:04:29.27</span> find out what a one card change would do</p><p><span>00:04:31.49</span> in the printout that I would get back,</p><p><span>00:04:32.99</span> because that was the loop. You&#39;re</p><p><span>00:04:34.79</span> thinking: well, it&#39;s not like that for us,</p><p><span>00:04:36.23</span> right, we&#39;re not poking holes in paper</p><p><span>00:04:37.67</span> cards – we have display terminals! But</p><p><span>00:04:40.31</span> how many of you guys have compile</p><p><span>00:04:42.05</span> cycles that can take 45 minutes? Famously,</p><p><span>00:04:44.87</span> the <a href="https://go.dev">Go</a> team wrote go because they</p><p><span>00:04:47.21</span> were so angry about waiting for an hour,</p><p><span>00:04:48.89</span> because they wanted to see what was</p><p><span>00:04:50.57</span> going to happen with some <a href="https://en.wikipedia.org/wiki/C++">C++</a></p><p><span>00:04:51.59</span> code they&#39;re running on some horrible</p><p><span>00:04:52.85</span> giant Google codebase. Maybe you want</p><p><span>00:04:54.89</span> to deploy your stuff and see if it works,</p><p><span>00:04:56.27</span> because we&#39;re all running web apps now.</p><p><span>00:04:57.29</span> So do you, like, stuff it in a</p><p><span>00:04:58.90</span> <a href="https://www.docker.com">Docker</a> container, and then ship it out to</p><p><span>00:05:00.65</span> the cloud and wait for a <a href="https://en.wikipedia.org/wiki/Continuous_integration">CI job</a>? How long</p><p><span>00:05:02.57</span> does that that take?</p><p><span>00:05:04.15</span> Two hours for this guy! I mean why do we</p><p><span>00:05:06.77</span> tolerate this? This is crazy! Docker</p><p><span>00:05:08.51</span> shouldn&#39;t exist. It exists only because</p><p><span>00:05:09.95</span> everything else is so terribly</p><p><span>00:05:11.15</span> complicated that they added another</p><p><span>00:05:12.40</span> layer of complexity to make it work. It&#39;s</p><p><span>00:05:14.74</span> like they thought: if deployment is bad,</p><p><span>00:05:16.12</span> we should make development bad too. It&#39;s</p><p><span>00:05:18.59</span> just... it&#39;s not good.</p><p><span>00:05:21.53</span> So, what kind of things do we inherit</p><p><span>00:05:23.15</span> from this way of thinking about the</p><p><span>00:05:24.59</span> world? We get funny ideas that are built</p><p><span>00:05:26.62</span> into programming about time and state.</p><p><span>00:05:28.79</span> Ideas like, there should be a compile/run</p><p><span>00:05:31.07</span> cycle. This is a terrible idea, but it&#39;s</p><p><span>00:05:33.23</span> an ancient idea, that you&#39;re going to</p><p><span>00:05:34.49</span> compile the thing and you&#39;re getting an</p><p><span>00:05:35.68</span> artifact and you&#39;re going to run the</p><p><span>00:05:36.71</span> artifact over there and those two things</p><p><span>00:05:38.15</span> are completely different phases of your</p><p><span>00:05:39.71</span> process. There&#39;s going to be linear</p><p><span>00:05:41.81</span> execution – most programming languages</p><p><span>00:05:43.79</span> assume that there&#39;s only one thread and</p><p><span>00:05:45.35</span> you&#39;re going to run straight through</p><p><span>00:05:46.43</span> from the beginning to the end; that your</p><p><span>00:05:48.35</span> program is going to start up from a</p><p><span>00:05:49.67</span> blank State and then run to termination.</p><p><span>00:05:51.40</span> Now, how many programs that we actually</p><p><span>00:05:53.45</span> write do that? We&#39;ll revisit that in a</p><p><span>00:05:55.43</span> moment. This really only works if your</p><p><span>00:05:56.99</span> program is some kind of input/output</p><p><span>00:05:58.49</span> transformer. So there&#39;s no runtime</p><p><span>00:06:00.77</span> introspection, because runtime is</p><p><span>00:06:02.02</span> happening over there and your actual</p><p><span>00:06:03.40</span> work is happening over here, and you just</p><p><span>00:06:04.85</span> have to kind of guess from what happened,</p><p><span>00:06:05.93</span> how it might be related to your code, and</p><p><span>00:06:08.09</span> if there&#39;s a bug – well, sorry, failures</p><p><span>00:06:10.12</span> just halt your program. You get maybe a</p><p><span>00:06:11.68</span> core dump, or you get a log message</p><p><span>00:06:13.18</span> somewhere with a stack trace in it. Now,</p><p><span>00:06:15.23</span> what kind of programs do we really write?</p><p><span>00:06:16.90</span> Mostly long-lived servers. I&#39;ve got</p><p><span>00:06:18.89</span> server processes with uptimes of a</p><p><span>00:06:20.81</span> thousand days.</p><p><span>00:06:21.89</span> They don&#39;t work the same way</p><p><span>00:06:23.62</span> <code>/usr/bin/sort</code> works. I don&#39;t want a</p><p><span>00:06:25.73</span> process that&#39;s optimized for writing</p><p><span>00:06:27.35</span> that. We also write GUI programs. GUI</p><p><span>00:06:29.51</span> programs are more intense than this, even.</p><p><span>00:06:31.30</span> So you&#39;ve got all of these</p><p><span>00:06:32.68</span> different kinds of input coming into the</p><p><span>00:06:34.37</span> program, and it&#39;s maybe it&#39;s talking to</p><p><span>00:06:35.68</span> the keyboard, it&#39;s talking to the mouse,</p><p><span>00:06:36.77</span> it&#39;s talking to the network, if it&#39;s Zoom</p><p><span>00:06:38.57</span> it&#39;s talking to the camera, it&#39;s talking</p><p><span>00:06:40.37</span> to the microphone – it&#39;s crazy. So this</p><p><span>00:06:42.59</span> approach to programming just</p><p><span>00:06:44.15</span> doesn&#39;t work well for the things we</p><p><span>00:06:45.59</span> actually build. It also infected</p><p><span>00:06:48.17</span> programming language theory. So, if the</p><p><span>00:06:50.21</span> program is a static artifact, what does</p><p><span>00:06:51.59</span> that mean? It means we&#39;re mostly going to</p><p><span>00:06:53.27</span> concentrate on algebraics, so we&#39;re going</p><p><span>00:06:54.46</span> to talk about syntax and semantics and</p><p><span>00:06:55.79</span> very little else.</p><p><span>00:06:57.05</span> There&#39;s going to be no concern really</p><p><span>00:06:58.49</span> for <i>pragmatics</i> – and what I mean here by</p><p><span>00:06:59.80</span> pragmatics is what it&#39;s actually like to</p><p><span>00:07:01.55</span> interact with your programming</p><p><span>00:07:02.74</span> environment, and this leads to</p><p><span>00:07:04.37</span> mathematics envy and a real fixation on</p><p><span>00:07:06.46</span> theorem proving.</p><p><span>00:07:07.96</span> So, to give an example of what happens</p><p><span>00:07:09.95</span> when people actually concentrate on a</p><p><span>00:07:11.80</span> part of programming and make progress,</p><p><span>00:07:13.01</span> we&#39;re going to take a quick tour through</p><p><span>00:07:14.74</span> syntax and semantics. We&#39;re going to do a</p><p><span>00:07:17.02</span> simple transformation here. We&#39;ve</p><p><span>00:07:18.40</span> got 1 through 4, we want it to be</p><p><span>00:07:19.67</span> 2 through 5. We want it to be</p><p><span>00:07:21.17</span> relatively general. I&#39;ve written some</p><p><span>00:07:22.90</span> example programs that do this in a</p><p><span>00:07:25.37</span> variety of programming languages. The</p><p><span>00:07:28.07</span> first one here is it is in <a href="https://en.wikipedia.org/wiki/AArch64">ARM64</a> machine</p><p><span>00:07:32.39</span> language, because my laptop happens to</p><p><span>00:07:34.18</span> run this processor now. As you can</p><p><span>00:07:35.87</span> plainly see from this code, it starts off</p><p><span>00:07:38.57</span> Oh wait! Does everyone here understand</p><p><span>00:07:40.15</span> ARM64? Okay, all right, it&#39;s a little easier</p><p><span>00:07:42.46</span> if I do this, so you can see where the</p><p><span>00:07:43.79</span> instructions are within these different</p><p><span>00:07:45.11</span> words. This is a cool instruction set.</p><p><span>00:07:47.39</span> It&#39;s not like <a href="https://en.wikipedia.org/wiki/X86">x86</a>. [In x86], all the</p><p><span>00:07:49.18</span> instructions are different lengths. In</p><p><span>00:07:50.45</span> ARM64, they&#39;re all the same length because</p><p><span>00:07:51.77</span> it&#39;s <a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">RISC</a>, but we&#39;ll do it in assembly</p><p><span>00:07:54.29</span> language – it&#39;ll be easier, right. So we</p><p><span>00:07:56.15</span> we&#39;ll start with this label here, add one,</p><p><span>00:07:57.83</span> and we&#39;ve got the signature of what it</p><p><span>00:07:59.08</span> would be as a C program after that.</p><p><span>00:08:00.95</span> What am I actually doing when I write</p><p><span>00:08:02.33</span> this program? Well, the first thing I&#39;m</p><p><span>00:08:03.58</span> doing is moving things from registers</p><p><span>00:08:05.51</span> onto the stack. Why am I doing this? I&#39;m</p><p><span>00:08:08.27</span> doing this because the ABI says I have</p><p><span>00:08:09.77</span> to. No other reason. It&#39;s nothing to do</p><p><span>00:08:11.62</span> with my problem. And then I want to call</p><p><span>00:08:13.37</span> <code>malloc</code> because I have to allocate some</p><p><span>00:08:14.74</span> memory to return the new, you know, array,</p><p><span>00:08:16.90</span> with the new stuff in it. So what I have</p><p><span>00:08:18.52</span> to do...</p><p><span>00:08:19.30</span> I&#39;m doing crazy things. Look down here,</p><p><span>00:08:21.89</span> you see the registers are all called</p><p><span>00:08:23.45</span> with X names? That&#39;s because</p><p><span>00:08:24.83</span> there&#39;s 64-bit registers at X, but I get</p><p><span>00:08:26.51</span> down here to set up for <code>malloc</code> and now</p><p><span>00:08:27.71</span> I&#39;m using W names. Why? Well, I just have</p><p><span>00:08:29.51</span> to know that I have to do something</p><p><span>00:08:30.46</span> special if it&#39;s a 32-bit number, and</p><p><span>00:08:32.44</span> it&#39;ll mask off 32 of the bits and still</p><p><span>00:08:34.31</span> work great. Now I have to stuff things</p><p><span>00:08:37.07</span> in these registers. I have to multiply</p><p><span>00:08:38.57</span> one of the variables. Do I use a multiply</p><p><span>00:08:39.94</span> for that? No, I&#39;m using it with a bit</p><p><span>00:08:41.38</span> shifting operation because that&#39;s what&#39;s</p><p><span>00:08:42.82</span> faster on this processor. And then I call</p><p><span>00:08:44.87</span> <code>malloc</code>, and I get back what I want. Great.</p><p><span>00:08:46.91</span> Now, I want a loop. This is what a loop</p><p><span>00:08:48.76</span> looks like. Notice we&#39;re on the second</p><p><span>00:08:49.91</span> page, and all I&#39;m doing is incrementing</p><p><span>00:08:52.25</span> some numbers. So, I come through and</p><p><span>00:08:54.23</span> I do a comparison. Okay, is this register</p><p><span>00:08:55.91</span> that I put this value into zero? If</p><p><span>00:08:57.71</span> it&#39;s less/equal, then I jump to return. You</p><p><span>00:08:59.15</span> can&#39;t see return, it&#39;s on another page.</p><p><span>00:09:00.47</span> There&#39;s a <i>third page</i>.</p><p><span>00:09:02.09</span> So, I move zero into this other register</p><p><span>00:09:04.25</span> and I go through here and bang bang... I&#39;m</p><p><span>00:09:06.23</span> I&#39;m not going to bore you with the whole</p><p><span>00:09:07.67</span> thing. I&#39;m bored just talking about it.</p><p><span>00:09:09.35</span> Imagine how I felt writing it!</p><p><span>00:09:11.15</span> And then at the end I have to do the</p><p><span>00:09:12.53</span> reverse of the things I did at the</p><p><span>00:09:13.79</span> beginning to set everything back into</p><p><span>00:09:15.59</span> the registers from the stack where I</p><p><span>00:09:16.85</span> saved them. Why? Because I have to have</p><p><span>00:09:18.23</span> the right return address to give this</p><p><span>00:09:19.61</span> thing back. I have to do this like a</p><p><span>00:09:20.99</span> voodoo incantation, because it&#39;s what the</p><p><span>00:09:22.55</span> processor wants. Nothing to do with the</p><p><span>00:09:24.41</span> problem I&#39;m trying to solve. How can we</p><p><span>00:09:26.09</span> do it better? Hey look – it&#39;s <a href="https://en.wikipedia.org/wiki/C_(programming_language">C</a>)! This is</p><p><span>00:09:28.25</span> exactly the same program. Many fewer</p><p><span>00:09:30.23</span> lines of code. However, it has a load of</p><p><span>00:09:32.50</span> problems that have nothing to do with</p><p><span>00:09:33.71</span> what I&#39;m trying to accomplish as well.</p><p><span>00:09:34.91</span> For one, I have to pass two things. I have</p><p><span>00:09:37.31</span> to pass the length of the array separate</p><p><span>00:09:38.99</span> from the array. Why? Because there&#39;s no</p><p><span>00:09:41.38</span> sequence type in C. Great work guys! 😆 So</p><p><span>00:09:43.67</span> then, from there, I want to return this</p><p><span>00:09:45.23</span> value. This modified sequence. And what do</p><p><span>00:09:46.79</span> I have to do? Well, I had to do this in</p><p><span>00:09:48.41</span> assembly too, but this is crazy. I have to</p><p><span>00:09:49.85</span> allocate memory give it back and then</p><p><span>00:09:51.29</span> hope that the other guy is going to free</p><p><span>00:09:52.67</span> that memory later. This has nothing to do</p><p><span>00:09:54.88</span> with what I&#39;m trying to accomplish. I</p><p><span>00:09:56.63</span> want to increment each of these numbers.</p><p><span>00:09:57.71</span> I do it with a <code>for</code> loop that counts from</p><p><span>00:09:59.81</span> one to the length of the array. Is</p><p><span>00:10:01.43</span> counting to the length of the array</p><p><span>00:10:02.38</span> relevant? Right, no. No, this is not</p><p><span>00:10:04.37</span> relevant. In fact, essentially one line</p><p><span>00:10:07.31</span> of code of this whole thing – the actual</p><p><span>00:10:08.99</span> increment – is the only thing that</p><p><span>00:10:10.49</span> actually matters. On the other hand, I can</p><p><span>00:10:13.00</span> complement C as a portable assembly</p><p><span>00:10:14.93</span> language because you see I don&#39;t have to</p><p><span>00:10:15.88</span> do the stack nonsense by hand, and</p><p><span>00:10:17.75</span> instead of telling it that it&#39;s four</p><p><span>00:10:19.85</span> bytes wide, I can actually use <code>sizeof</code></p><p><span>00:10:21.76</span> to know that but that&#39;s about the</p><p><span>00:10:23.44</span> only way it&#39;s really an improvement. Now</p><p><span>00:10:25.19</span> let&#39;s look at <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language">Lisp</a>. Note that Lisp is</p><p><span>00:10:26.75</span> about 10 years older than C. Here I have</p><p><span>00:10:29.32</span> a sequence abstraction. I have four</p><p><span>00:10:31.07</span> numbers and I can use a</p><p><span>00:10:32.57</span> higher order function to go over it and add</p><p><span>00:10:33.94</span> one to each of them. This is a tremendous</p><p><span>00:10:35.38</span> improvement by going back in time.</p><p><span>00:10:38.16</span> But we can do better. We can do better</p><p><span>00:10:38.87</span> than this notation. We can go to</p><p><span>00:10:41.09</span> Haskell. So, in Haskell what do we have?</p><p><span>00:10:43.07</span> This is really lovely. We have this thing</p><p><span>00:10:45.11</span> where we auto-curry the <code>(+ 1)</code>, and we</p><p><span>00:10:47.50</span> get a function that adds one. This is</p><p><span>00:10:49.25</span> getting pretty concise. Can anybody here</p><p><span>00:10:50.81</span> quickly name for me a language in which</p><p><span>00:10:52.37</span> this exact operation is even more</p><p><span>00:10:54.29</span> concise? I&#39;ll give you a moment.</p><p><span>00:10:56.03</span> I hear <a href="https://en.wikipedia.org/wiki/APL_(programming_language">APL</a>, and indeed APL! So here we</p><p><span>00:11:00.94</span> have [rank] polymorphism. I have</p><p><span>00:11:04.06</span> a single number –</p><p><span>00:11:06.41</span> a scalar – and I have a set of numbers.</p><p><span>00:11:07.67</span> Note that there&#39;s no stupid junk. I don&#39;t</p><p><span>00:11:09.35</span> have to put commas between everything. I</p><p><span>00:11:11.38</span> don&#39;t have to wrap anything in any</p><p><span>00:11:12.76</span> special [delimiters] or anything of this</p><p><span>00:11:14.09</span> nature. I just say add one to these</p><p><span>00:11:15.88</span> numbers, and I get what I was after. So if</p><p><span>00:11:17.44</span> we start from the assembly language and</p><p><span>00:11:20.38</span> we come to the APL, which is – you know –</p><p><span>00:11:21.65</span> again – you know – like eight years older</p><p><span>00:11:23.44</span> than C, we find that syntax and semantics</p><p><span>00:11:25.61</span> can take us a long way.</p><p><span>00:11:27.88</span> But there are other things that we care</p><p><span>00:11:30.05</span> about where no one has put in this much</p><p><span>00:11:32.03</span> effort. And one of those things is state</p><p><span>00:11:34.06</span> and time. Almost every programming</p><p><span>00:11:35.44</span> language doesn&#39;t do anything to help us</p><p><span>00:11:37.85</span> with managing state over time from</p><p><span>00:11:40.37</span> multiple sources. There are some notable</p><p><span>00:11:42.41</span> exceptions. I will talk about them now. So,</p><p><span>00:11:44.15</span> <a href="https://clojure.org">Clojure</a>,</p><p><span>00:11:46.56</span> because Rich Hickey – he really cared about</p><p><span>00:11:47.20</span> concurrency – he included immutable data</p><p><span>00:11:47.21</span> structures. So now you don&#39;t have</p><p><span>00:11:49.06</span> constant banging on the same things and</p><p><span>00:11:50.87</span> crushing each other&#39;s data. This is very</p><p><span>00:11:53.32</span> helpful. What else? He&#39;s got <code>atom</code>s. These</p><p><span>00:11:54.71</span> are synchronized mutable boxes with</p><p><span>00:11:56.81</span> functional update semantics. Everybody</p><p><span>00:11:58.25</span> uses these. These are great. He has also a</p><p><span>00:11:59.87</span> full <a href="https://en.wikipedia.org/wiki/Software_transactional_memory">Software Transactional Memory</a></p><p><span>00:12:01.06</span> implementation that frankly nobody uses,</p><p><span>00:12:02.63</span> but it&#39;s still great. It just has a more</p><p><span>00:12:05.50</span> complicated API, and the lesson from this</p><p><span>00:12:07.06</span> probably is: if you want people to do the</p><p><span>00:12:08.81</span> right thing, you have to give them an API</p><p><span>00:12:10.73</span> simple enough that they really will.</p><p><span>00:12:12.29</span> Then on top of this, we have <code>core.async</code>.</p><p><span>00:12:13.49</span> Now, I have less nice things to</p><p><span>00:12:14.63</span> say about <code>core.async</code>. I like</p><p><span>00:12:16.31</span> <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes</a>, the</p><p><span>00:12:18.94</span> way everybody else does, but this is</p><p><span>00:12:21.23</span> implemented as a macro and as a</p><p><span>00:12:22.31</span> consequence when it compiles your CSP</p><p><span>00:12:23.93</span> code you end up with something that you</p><p><span>00:12:25.31</span> can&#39;t really look into anymore. Like, you</p><p><span>00:12:27.76</span> can&#39;t ask a channel how many things are</p><p><span>00:12:30.41</span> in that channel. You can&#39;t really know</p><p><span>00:12:32.15</span> much about what&#39;s happening there. And I</p><p><span>00:12:33.94</span> would say that in the JVM, I agree with</p><p><span>00:12:35.26</span> what rich said the year before he</p><p><span>00:12:36.65</span> created <code>core.async</code>, which is that you</p><p><span>00:12:37.91</span> should just probably use the built-in</p><p><span>00:12:39.41</span> concurrent queues.</p><p><span>00:12:41.21</span> Now, in ClojureScript, of course,</p><p><span>00:12:43.31</span> these things were more useful because</p><p><span>00:12:44.87</span> everyone was trapped in callback hell.</p><p><span>00:12:46.43</span> We&#39;ll see what happens moving on, now</p><p><span>00:12:48.88</span> that we have <code>async</code>/<code>await</code> in JavaScript.</p><p><span>00:12:49.97</span> Moving on to another implementation</p><p><span>00:12:51.41</span> of CSP, Go. Go actually did something good</p><p><span>00:12:53.38</span> here, right, they – and I&#39;m not going to say</p><p><span>00:12:55.43</span> much else that&#39;s great about Go – is</p><p>The Go team includes several all-time great programmers. I respect them all. But I do feel that they had a chance to be more ambitious than they were with Go, which – with the weight of their reputations and the might of Google behind it – could have shifted the culture in a better direction.</p><p><span>00:12:59.62</span> they built a fantastic runtime for</p><p><span>00:13:01.91</span> this stuff. It&#39;s really lightweight, it</p><p><span>00:13:04.06</span> does a great job. The bad news is that Go</p><p><span>00:13:04.07</span> is a completely static language, so even</p><p><span>00:13:04.85</span> though you should be able to go in and</p><p><span>00:13:07.12</span> ask all of these questions during</p><p><span>00:13:09.29</span> runtime while you&#39;re developing from</p><p><span>00:13:11.26</span> within your editor, like a civilized</p><p><span>00:13:13.43</span> person, you can&#39;t. You end up with a</p><p><span>00:13:14.87</span> static artifact. Well, that&#39;s a bummer.</p><p><span>00:13:15.88</span> Okay.</p><p><span>00:13:17.26</span> And I would say, actually, before I</p><p><span>00:13:18.71</span> move on, that anytime you have this</p><p><span>00:13:20.56</span> kind of abstraction where you have a</p><p><span>00:13:22.31</span> bunch of threads running, when you have</p><p><span>00:13:22.32</span> processes doing things, you really want</p><p><span>00:13:23.21</span> <code>ps</code> and you really want <code>kill</code>. And,</p><p><span>00:13:24.82</span> unfortunately, neither Go nor Clojure can</p><p><span>00:13:26.44</span> provide these because their runtimes</p><p><span>00:13:27.41</span> don&#39;t believe in them. The JVM</p><p><span>00:13:28.49</span> runtime itself thinks that if you kill a</p><p><span>00:13:30.59</span> [thread] you&#39;re going to leak some</p><p><span>00:13:32.56</span> resources, and that the resources you</p><p><span>00:13:34.49</span> leak may include locks that you need to</p><p><span>00:13:35.87</span> free up some other threads that are</p><p><span>00:13:38.03</span> running elsewhere, so they&#39;ve just</p><p><span>00:13:40.37</span> forbidden the whole thing. And in Go you</p><p><span>00:13:41.21</span> have to send it a message, open a</p><p><span>00:13:42.76</span> separate Channel, blah blah blah.</p><p><span>00:13:44.50</span> <a href="https://www.erlang.org">Erlang</a>, on the other hand, gets almost</p><p><span>00:13:46.43</span> everything right in this area. In</p><p><span>00:13:47.56</span> this situation, they&#39;ve implemented the</p><p><span>00:13:49.31</span> <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a>, and they&#39;ve done it in a way</p><p><span>00:13:50.69</span> where you have a live interactive</p><p><span>00:13:52.37</span> runtime, and because they&#39;re using shared</p><p><span>00:13:54.11</span> nothing for their state and supervision</p><p><span>00:13:55.55</span> trees, you can kill anything anytime and</p><p><span>00:13:57.05</span> your system will just keep running. This</p><p><span>00:13:58.55</span> is fantastic. This is great. Why doesn&#39;t</p><p><span>00:13:59.93</span> everything work like this? It also</p><p><span>00:14:02.03</span> comes with introspection tools, like</p><p><span>00:14:03.65</span> <a href="https://www.erlang.org/doc/apps/observer/observer_ug.html">Observer</a>, that should make anyone using</p><p><span>00:14:05.21</span> any other platform to build a</p><p><span>00:14:06.88</span> long-running server thing fairly jealous.</p><p><span>00:14:08.32</span> Now, when I say this, I&#39;m not telling you</p><p><span>00:14:10.12</span> you should use Erlang. What I&#39;m telling</p><p><span>00:14:11.32</span> you is whatever you use should be at</p><p><span>00:14:13.31</span> least as good as Erlang at doing this,</p><p><span>00:14:14.50</span> and if you&#39;re developing a new language –</p><p><span>00:14:16.19</span> for God&#39;s sake – please take notice.</p><p><span>00:14:18.23</span> I can talk now about something that</p><p><span>00:14:19.91</span> I worked on with my colleague <a href="https://matt.is">Matt</a></p><p><span>00:14:21.76</span> <a href="https://matt.is">Huebert</a>. This is something that I</p><p><span>00:14:23.21</span> particularly like. This is a hack in</p><p>The cells project was Matt&#39;s baby. He did almost all the coding. I worked with him as a mentor because I had already implemented a number of dataflow systems.</p><p><span>00:14:24.94</span> ClojureScript. We call it cells, and it</p><p><span>00:14:28.19</span> takes spreadsheet like dataflow and adds</p><p><span>00:14:30.35</span> it into ClojureScript. This resulted in a</p><p><span>00:14:31.61</span> <a href="https://px16.matt.is">paper</a> that was delivered at the <a href="https://2016.ecoop.org/track/px-2016">PX16</a></p><p><span>00:14:33.05</span> workshop at <a href="https://ecoop.org">ECOOP</a> in Rome in 2016.</p><p><span>00:14:35.09</span> You&#39;ve got things like this, right. So, you</p><p><span>00:14:38.93</span> say: here&#39;s an interval, every 300</p><p><span>00:14:41.15</span> milliseconds give me another random</p><p><span>00:14:43.79</span> integer, and it does. And then you can</p><p><span>00:14:45.47</span> have another thing refer to that, in this</p><p><span>00:14:48.23</span> case <code>cons</code>ing them on, and now we build a</p><p><span>00:14:49.97</span> history of all the random integers that</p><p><span>00:14:51.29</span> have happened. What else can you do? Well</p><p><span>00:14:52.79</span> you can refer to that, and you can <code>(take 10)</code></p><p><span>00:14:54.76</span> with normal Clojure semantics, and</p><p><span>00:14:56.21</span> then <code>map</code> that out as a bar chart. What do you</p><p><span>00:14:57.71</span> get? A nice graph. A graph that</p><p><span>00:14:58.97</span> moves in real time. Or we can move on to</p><p><span>00:15:00.53</span> this. We added sort of <a href="https://en.wikipedia.org/wiki/Bret_Victor">Bret Victor</a>-style</p><p><span>00:15:02.03</span> scrubbers into it so that you could do</p><p><span>00:15:03.88</span> these kinds of things. I&#39;ll show you</p><p><span>00:15:05.93</span> instead of telling you, because it&#39;s</p><p><span>00:15:08.09</span> obvious if you look at it what&#39;s going</p><p><span>00:15:10.12</span> on here. We did this partially to</p><p><span>00:15:12.17</span> show people that you can just really</p><p><span>00:15:14.50</span> program with systems that have all those</p><p><span>00:15:15.71</span> features that Bret was demoing.</p><p><span>00:15:16.73</span> Source code&#39;s still out there – anybody</p><p><span>00:15:17.99</span> wants to do that, you can do that. We</p><p><span>00:15:20.32</span> moved on from that to <a href="https://jackrusher.com/strange-loop-2022/maria.cloud">maria.cloud</a>, which</p><p>Maria was a joint project of Matt, <a href="https://www.daveliepmann.com">Dave Liepmann</a>, and myself. We wanted a good teaching environment that requires no installfest for <a href="https://clojurebridge.org">ClojureBridge</a>.</p><p><span>00:15:21.47</span> takes all of that code we wrote for</p><p><span>00:15:23.32</span> cells and turns it into a notebook. We</p><p><span>00:15:25.85</span> actually did this for learners. Take a</p><p><span>00:15:27.41</span> look at this. This is a computational</p><p><span>00:15:29.38</span> notebook. It has the cells, it gives you</p><p><span>00:15:31.25</span> much better error messages than default</p><p><span>00:15:32.44</span> Clojure, and so on. We used this to teach.</p><p><span>00:15:34.06</span> It was a great experience, and currently –</p><p><span>00:15:36.41</span> this year – thanks to <a href="https://www.clojuriststogether.org">Clojurists Together</a>, we</p><p><span>00:15:38.38</span> have some additional funding to bring it</p><p><span>00:15:41.15</span> up to date and keep it running. I</p><p><span>00:15:42.53</span> encourage everybody to check it out. The</p><p><span>00:15:44.09</span> last thing here on this list is the</p><p><span>00:15:46.43</span> <a href="https://groups.csail.mit.edu/mac/users/gjs/propagators/">propagators</a>. The propagators come</p><p><span>00:15:48.23</span> from <a href="https://en.wikipedia.org/wiki/Gerald_Jay_Sussman">Sussman</a> – this is Sussman&#39;s</p><p><span>00:15:49.49</span> project from around the same time that</p><p><span>00:15:50.93</span> actors were happening and <a href="https://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a> was first</p><p><span>00:15:53.26</span> getting interested in <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a>. This</p><p><span>00:15:54.65</span> was a really fertile scene at MIT in the</p><p><span>00:15:56.21</span> early 70s. It was actually the project</p><p><span>00:15:58.61</span> he originally hired <a href="https://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman</a>, of</p><p><span>00:16:00.47</span> the GNU project, as a grad student, to</p><p><span>00:16:02.44</span> work on, and then later did some</p><p><span>00:16:03.94</span> additional work with <a href="https://www.semanticscholar.org/author/Alexey-Radul/1767709">Alexey Radul</a>, which</p><p><span>00:16:05.56</span> expanded the whole thing.</p><p><span>00:16:07.67</span> I can&#39;t tell you all about it here.</p><p><span>00:16:09.47</span> There&#39;s just too much to say, but I can</p><p><span>00:16:11.09</span> tell you there was a fantastic talk at</p><p><span>00:16:13.12</span> the 2011 strange Loop called <a href="https://www.youtube.com/watch?v=HB5TrK7A4pI">We Really</a></p><p><span>00:16:14.99</span> <a href="https://www.youtube.com/watch?v=HB5TrK7A4pI">Don&#39;t Know How to Compute!</a>, and I</p><p><span>00:16:16.67</span> recommend that you watch that when you</p><p><span>00:16:18.82</span> get out of Strange Loop. Just go home and</p><p><span>00:16:20.56</span> watch that talk. It&#39;s amazing. A side</p><p><span>00:16:22.00</span> thing is that the propagator model was</p><p><span>00:16:23.93</span> used by one of the grad students at MIT</p><p><span>00:16:25.18</span> at the time to make the very first</p><p><span>00:16:26.38</span> spreadsheet. <a href="https://en.wikipedia.org/wiki/VisiCalc">VisiCalc</a> was based on this</p><p><span>00:16:28.18</span> model. This is a really useful</p><p><span>00:16:30.11</span> abstraction that everyone should know</p><p><span>00:16:32.56</span> about. It&#39;s data flow based, it does truth</p><p><span>00:16:33.94</span> maintenance, and it keeps provenance of</p><p><span>00:16:35.21</span> where all of the conclusions the truth</p><p><span>00:16:37.55</span> maintenance system came from, which means</p><p><span>00:16:39.91</span> it&#39;s probably going to be very valuable</p><p><span>00:16:41.74</span> for explainable AI later.</p><p>There are a number of other approaches that I really like, but which I didn&#39;t have time to get into here. <a href="https://docs.racket-lang.org/frtime/">FrTime</a>, from the <a href="https://racket-lang.org">Racket</a> community, is great. In terms of formalisms for reasoning about this sort of thing, I really like the <a href="https://en.wikipedia.org/wiki/Π-calculus">π-calculus</a>.</p><p><span>00:16:44.03</span> We&#39;ll move to another area where</p><p><span>00:16:46.37</span> there&#39;s been even less progress.</p><p><span>00:16:47.87</span> Now we&#39;re getting to the the absolute</p><p><span>00:16:49.31</span> nadir of progress here, [and] that&#39;s in</p><p><span>00:16:50.50</span> program representation. Let&#39;s look at</p><p><span>00:16:52.55</span> that punch card again:</p><p><span>00:16:54.35</span> 80 columns, there it is.</p><p><span>00:16:57.11</span> Now look at this. This is the output of a</p><p><span>00:16:58.43</span> teletype. Notice that it is fixed width</p><p><span>00:16:59.62</span> and approximately 80 columns. Notice that</p><p><span>00:17:00.94</span> the fonts are all fixed with.</p><p><span>00:17:02.38</span> This is the teletype in question.</p><p><span>00:17:04.85</span> This looks like it should be in a museum,</p><p><span>00:17:06.82</span> and it should be in a museum, and – in fact –</p><p><span>00:17:09.11</span> is in a museum.</p><p><span>00:17:11.87</span> We got these. So, this is the terminal in</p><p><span>00:17:13.54</span> which I did a lot of hacking on that VAX</p><p><span>00:17:16.42</span> that you saw earlier (when I wasn&#39;t</p><p><span>00:17:17.75</span> forced to use punch cards), and a lot of</p><p><span>00:17:19.37</span> that was in languages like VAX <a href="https://en.wikipedia.org/wiki/Pascal_(programming_language">Pascal</a>) –</p><p><span>00:17:22.54</span> yeah – but also Bliss, which was pretty</p><p><span>00:17:25.42</span> cool. So you&#39;ll notice that this is a</p><p><span>00:17:26.99</span> <a href="https://en.wikipedia.org/wiki/VT100">VT100 terminal</a>. And all of you are</p><p><span>00:17:28.01</span> using machines today that have terminal</p><p><span>00:17:29.45</span> emulators that pretend to be this</p><p><span>00:17:32.39</span> terminal; that&#39;s why they have VT100</p><p><span>00:17:34.49</span> escape codes, because those escape codes</p><p><span>00:17:36.28</span> first shipped on this terminal. Now we&#39;ll</p><p><span>00:17:39.35</span> move on to another terminal. This is the</p><p><span>00:17:41.02</span> one that I used when I was doing all of</p><p><span>00:17:43.07</span> my early <a href="https://en.wikipedia.org/wiki/Unix">Unix</a> hacking back in the 80s.</p><p><span>00:17:45.35</span> This is called an <a href="https://en.wikipedia.org/wiki/ADM-3A">ADM-3A</a>. Now, by</p><p><span>00:17:46.97</span> applause, how many of you use an editor</p><p><span>00:17:49.66</span> that has <a href="https://en.wikipedia.org/wiki/Vi">vi</a> key bindings? Come on! Yeah,</p><p><span>00:17:51.52</span> all right, yeah. So then you might be</p><p><span>00:17:52.90</span> interested in the keyboard of the ADM-3A,</p><p><span>00:17:55.07</span> which was the one that <a href="https://en.wikipedia.org/wiki/Bill_Joy">Bill Joy</a> had at</p><p><span>00:17:58.31</span> home to connect to school through a</p><p><span>00:18:00.11</span> modem while he was writing vi. So here it</p><p><span>00:18:03.52</span> is. Note the arrow keys on the <i>h-j-k-l</i>.</p><p><span>00:18:05.51</span> They are there because those are the</p><p><span>00:18:07.07</span> <a href="https://en.wikipedia.org/wiki/ASCII#Control_characters">ASCII control codes</a> to move the roller and the</p><p><span>00:18:08.69</span> printhead on the old teletype that you</p><p><span>00:18:10.61</span> saw a moment ago. So you&#39;d hit control</p><p><span>00:18:12.89</span> plus those to control a teletype.</p><p>We used to use CTRL-h to back up over printed characters to then type a sequence of dashes as a strikethrough on these old printers. We also used the same trick on display terminals to make fancy spinning cursors.</p><p><span>00:18:17.15</span> It happened to have the arrow keys, he</p><p><span>00:18:18.95</span> used them. Look where the <i>control</i> key is.</p><p><span>00:18:21.89</span> For all you Unix people, it&#39;s right next</p><p><span>00:18:23.93</span> to the <i>a</i>. To this day, on this</p><p><span>00:18:25.66</span> supercomputer here, I bind the <i>caps lock</i></p><p><span>00:18:27.77</span> key to <i>control</i> because it makes my life</p><p><span>00:18:29.63</span> easier on the Unix machine that it is.</p><p><span>00:18:31.31</span> Look up there, where the <i>escape</i> key is, by</p><p><span>00:18:32.99</span> the <i>q</i>. That&#39;s why we use <i>escape</i> to get</p><p><span>00:18:35.15</span> into command mode in vi, because it was</p><p><span>00:18:37.31</span> easily accessible. Now scan across the</p><p><span>00:18:38.81</span> top row just right of the <i>0</i>. What&#39;s</p><p><span>00:18:41.45</span> that? The unshifted <i>*</i> is the <i>:</i>.</p><p><span>00:18:43.37</span> That&#39;s why [it does] what it does in vi,</p><p><span>00:18:45.40</span> because it was right there. And now the</p><p><span>00:18:47.27</span> last one, for all the Unix people in the</p><p><span>00:18:49.31</span> audience, in the upper right hand corner</p><p><span>00:18:51.28</span> there&#39;s a button where when you hit</p><p><span>00:18:53.81</span> <i>control</i> and that button, it would clear</p><p><span>00:18:55.97</span> the screen and take the cursor to the</p><p><span>00:18:58.07</span> home position. If you did not hit <i>control</i>,</p><p><span>00:18:59.33</span> instead hit <i>shift</i>, you got the <i>~</i>.</p><p><span>00:19:00.52</span> Notice tilde is right under home. If</p><p><span>00:19:01.54</span> you&#39;re wondering why your home directory</p><p><span>00:19:02.93</span> is tilde whatever username, it&#39;s</p><p><span>00:19:04.31</span> because of this keyboard.</p><p><span>00:19:07.97</span> Now here is Terminal.app on my mega</p><p><span>00:19:09.71</span> supercomputer. Notice 80 Columns of fixed</p><p><span>00:19:11.21</span> width type. Notice that when I look at</p><p><span>00:19:13.19</span> the processes they have <i>ttys</i> – that stands</p><p><span>00:19:14.99</span> for teletype.</p><p><span>00:19:15.00</span> This machine is cosplaying as a <a href="https://en.wikipedia.org/wiki/PDP-11">PDP-11</a>.</p><p><span>00:19:19.54</span> Now, whenever I get exercised about this,</p><p><span>00:19:23.45</span> and talk about it, somebody sends me this</p><p><span>00:19:25.78</span> <a href="https://graydon2.dreamwidth.org/193447.html">blog post from Graydon Hoare</a>. He&#39;s</p><p><span>00:19:27.77</span> talking [about how] he&#39;ll bet on text. He</p><p><span>00:19:29.57</span> makes good arguments. I love text. I use</p><p><span>00:19:35.73</span> text every day. Text is good! The thing</p><p><span>00:19:35.74</span> about it, though, is that the people who</p><p><span>00:19:42.40</span> send me this in support of text always</p><p><span>00:19:45.11</span> mean text <i>like this</i> – text like it came</p><p><span>00:19:46.54</span> out of a teletype – and never text like</p><p><span>00:19:48.04</span> Newton&#39;s <a href="https://en.wikipedia.org/wiki/Philosophiæ_Naturalis_Principia_Mathematica">Principia</a>, never text <i>like this</i></p><p><span>00:19:50.39</span> from <a href="https://en.wikipedia.org/wiki/Wolfgang_Weingart">Wolfgang Weingart</a>. That is, these</p><p><span>00:19:52.43</span> people don&#39;t even know what text is</p><p><span>00:19:55.25</span> capable of! They&#39;re denying the</p><p><span>00:19:56.93</span> possibilities of the medium!</p><p><span>00:19:58.90</span> This is how I feel about that. I&#39;ve</p><p><span>00:20:01.01</span> promised <a href="https://twitter.com/puredanger">Alex</a> I will not say anything</p><p><span>00:20:02.69</span> profane during this talk, so you will be</p><p><span>00:20:05.27</span> seeing this 💩 emoji again.</p><p><span>00:20:07.66</span> The reason I disagree with this position</p><p><span>00:20:08.87</span> is because the visual cortex exists, okay?</p><p><span>00:20:10.49</span> So this guy, this adorable little</p><p><span>00:20:12.65</span> fella, he branched off from our lineage</p><p><span>00:20:14.69</span> about 60 million years ago. Note the</p><p><span>00:20:16.66</span> little touchy fingers and the giant eyes,</p><p><span>00:20:18.47</span> just like we have. We&#39;ve had a long time</p><p><span>00:20:21.28</span> with the visual cortex. It is very</p><p><span>00:20:23.09</span> powerful. It is like a GPU accelerated</p><p><span>00:20:25.90</span> supercomputer of the brain, whereas the</p><p><span>00:20:28.37</span> part that takes in the words is like a</p><p><span>00:20:30.11</span> very serial, slow, single-thread CPU, and I</p><p><span>00:20:32.63</span> will give you all a demonstration right</p><p><span>00:20:34.07</span> now.</p><p><span>00:20:36.65</span> Take a look at this teletype-compatible</p><p><span>00:20:38.87</span> text of this data and tell me if any</p><p><span>00:20:42.47</span> sort of pattern emerges. Do you see</p><p><span>00:20:44.57</span> anything interesting?</p><p><span>00:20:46.31</span> Here it is plotted X/Y. Your brain knew</p><p><span>00:20:48.47</span> this was a dinosaur before you knew that</p><p><span>00:20:50.27</span> your brain knew this was a dinosaur.</p><p><span>00:20:50.28</span> That is how powerful the visual</p><p><span>00:20:51.11</span> cortex is, and there are loads of people</p><p><span>00:20:53.81</span> who have spent literally hundreds of</p><p><span>00:20:56.45</span> years getting very good at this. Data</p><p><span>00:20:58.66</span> visualization. If I gave you a table</p><p><span>00:20:59.99</span> talking about the troop strength of</p><p><span>00:21:03.35</span> <a href="https://www.edwardtufte.com/tufte/minard">Napoleon&#39;s March to and from Moscow</a>,</p><p><span>00:21:05.09</span> you&#39;d get kind of a picture. But if you</p><p><span>00:21:06.49</span> look at it like this, you know what kind</p><p><span>00:21:09.28</span> of tragedy it was. You can see right away.</p><p><span>00:21:11.39</span> This was 175 years ago, and we&#39;re still</p><p><span>00:21:12.77</span> doing paper tape.</p><p><span>00:21:14.57</span> Graphic designers – they know something.</p><p><span>00:21:16.31</span> They know a few things. For instance, they</p><p><span>00:21:18.52</span> know that these are all channels. These</p><p><span>00:21:20.45</span> different things: point, line, plane,</p><p><span>00:21:22.61</span> organization, asymmetry – that these things</p><p><span>00:21:24.11</span> are all channels that get directly to</p><p><span>00:21:25.73</span> our brain, and there is no need to eshew</p><p><span>00:21:28.54</span> these forms of representation when we&#39;re</p><p><span>00:21:31.78</span> talking about program representation.</p><p><span>00:21:33.71</span> I recommend everyone in this audience</p><p><span>00:21:35.69</span> who hasn&#39;t already done so, go just get</p><p><span>00:21:37.25</span> this <a href="https://www.holybooks.com/wp-content/uploads/Point-and-Line-to-Plane-by-Kandinsky.pdf">100 year old book from Kandinsky</a></p><p><span>00:21:38.69</span> and get a sense of what&#39;s possible.</p><p><span>00:21:40.61</span> Here&#39;s one of his students working on</p><p><span>00:21:42.59</span> some notation. Look how cool that is! Come</p><p><span>00:21:44.93</span> on! All right, so another thing with text</p><p><span>00:21:47.14</span> is that it&#39;s really bad at doing graphs</p><p><span>00:21:49.31</span> with cycles, and our world is full of</p><p><span>00:21:50.57</span> graphs with cycles. Here&#39;s a Clojure</p><p><span>00:21:52.13</span> notation idea of the the taxonomy of</p><p><span>00:21:54.35</span> animals, including us and that cute little</p><p><span>00:21:56.02</span> tarsier. And it works fine because</p><p><span>00:21:57.35</span> it&#39;s a tree, and trees are really good at</p><p><span>00:21:59.81</span> containment – they can do containment in a</p><p><span>00:22:02.45</span> single acyclic manner. Now this</p><p><span>00:22:04.07</span> sucks to write down as text. This is the</p><p><span>00:22:05.57</span> <a href="https://en.wikipedia.org/wiki/Citric_acid_cycle">Krebs cycle</a>. Hopefully, all of you learned</p><p><span>00:22:07.43</span> this at school. If not maybe read up on</p><p><span>00:22:09.52</span> it.</p><p><span>00:22:10.90</span> If you imagine trying to explain this</p><p><span>00:22:13.61</span> with paragraphs of text you would never</p><p><span>00:22:15.40</span> get anywhere. Our doctors would all fail.</p><p><span>00:22:17.75</span> We would all be dead. So instead, we draw</p><p><span>00:22:21.11</span> a picture. We should be able to draw</p><p><span>00:22:23.63</span> pictures when we&#39;re coding as well.</p><p><span>00:22:25.07</span> Here&#39;s the <a href="https://digital.sciencehistory.org/works/8p58pf13g">Periodic Table of the Elements</a>. Look how</p><p><span>00:22:27.28</span> beautiful this is. This is 1976. We&#39;ve</p><p><span>00:22:28.97</span> got all these channels working together to</p><p><span>00:22:30.59</span> tell us things about all these these</p><p><span>00:22:32.02</span> different elements, how these elements interact</p><p><span>00:22:33.59</span> with each other.</p><p><span>00:22:35.51</span> Another area that we&#39;ve pretty much</p><p><span>00:22:36.71</span> ignored is <i>pragmatics</i>, and what I mean by</p><p><span>00:22:37.97</span> that – I&#39;m borrowing it from linguistics</p><p><span>00:22:39.77</span> because we&#39;ve borrowed syntax and</p><p><span>00:22:41.93</span> semantics from linguistics – pragmatics is</p><p><span>00:22:43.49</span> studying the relationship between a</p><p><span>00:22:45.35</span> language and the users of the language,</p><p><span>00:22:47.51</span> and I&#39;m using it here to talk about</p><p><span>00:22:48.52</span> programming environments.</p><p><span>00:22:49.90</span> Specifically, I want to talk about</p><p><span>00:22:51.64</span> interactive programming, which is I think</p><p><span>00:22:53.14</span> the only kind of programming we should</p><p><span>00:22:55.01</span> really be doing. Some people call it live</p><p><span>00:22:56.57</span> coding, mainly in the art community, and</p><p><span>00:22:58.43</span> this is when you code with what <a href="https://en.wikipedia.org/wiki/Dan_Ingalls">Dan</a></p><p><span>00:22:59.63</span> <a href="https://en.wikipedia.org/wiki/Dan_Ingalls">Ingalls</a> refers to as <i>liveness</i>. It is the</p><p><span>00:23:01.13</span> opposite of batch processing. Instead,</p><p><span>00:23:02.93</span> there is a programming environment,</p><p><span>00:23:04.73</span> and the environment and the program are</p><p><span>00:23:06.28</span> combined during development. So what does</p><p><span>00:23:07.61</span> this do for us? Well, there&#39;s no compile</p><p><span>00:23:09.52</span> and run cycle. You&#39;re compiling inside</p><p><span>00:23:11.93</span> your running program, so you no longer</p><p><span>00:23:13.31</span> have that feedback loop. It</p><p><span>00:23:16.37</span> doesn&#39;t start with a blank slate and run</p><p><span>00:23:19.07</span> to termination. Instead, all of your</p><p><span>00:23:20.57</span> program state is still there while</p><p><span>00:23:22.01</span> you&#39;re working on it. This means that you</p><p><span>00:23:24.04</span> can debug. You can add things to it. You</p><p><span>00:23:26.99</span> can find out what&#39;s going on, all while</p><p><span>00:23:29.14</span> your program is running.</p><p><span>00:23:31.07</span> Of course, there&#39;s runtime introspection</p><p><span>00:23:33.23</span> and failures don&#39;t halt the</p><p><span>00:23:34.61</span> program. They give you some kind of</p><p><span>00:23:36.16</span> option to maybe fix and continue what&#39;s</p><p><span>00:23:37.73</span> happening now. This combination of</p><p><span>00:23:39.16</span> attributes, I would say, is most of what</p><p><span>00:23:41.21</span> makes spreadsheets so productive.</p><p><span>00:23:43.49</span> And it gives you these incredibly short</p><p><span>00:23:44.87</span> feedback loops, of which we&#39;ll now have</p><p><span>00:23:46.90</span> some examples. If you&#39;re compiling some</p><p><span>00:23:48.95</span> code, say, in <a href="https://en.wikipedia.org/wiki/Common_Lisp">Common Lisp</a>, you can compile</p><p><span>00:23:50.51</span> the code and disassemble it and see</p><p><span>00:23:52.37</span> exactly what you got. Now the program is</p><p><span>00:23:54.23</span> running. The program is alive right now,</p><p><span>00:23:56.09</span> and I&#39;m asking questions of that runtime.</p><p><span>00:23:58.49</span> And I look at this and I say, okay,</p><p><span>00:23:59.81</span> 36 bytes – that&#39;s too much – so I&#39;ll</p><p><span>00:24:01.66</span> go through and I&#39;ll add some some, you</p><p><span>00:24:03.47</span> know, optimizations to it, recompile,</p><p><span>00:24:06.23</span> 16 bytes that&#39;s about as many</p><p><span>00:24:07.43</span> instructions as I want to spend on this.</p><p><span>00:24:10.78</span> so I know a bunch of you are probably</p><p><span>00:24:12.89</span> allergic to <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a>. Here&#39;s <a href="https://julialang.org">Julia</a>.</p><p><span>00:24:14.45</span> You can do exactly the same thing in</p><p><span>00:24:17.51</span> Julia. Look at this. You get the native</p><p><span>00:24:19.07</span> code back for the thing that you just</p><p><span>00:24:20.87</span> made, and you can change it while it&#39;s</p><p><span>00:24:22.43</span> running.</p><p><span>00:24:24.59</span> Now what about types? This is where half</p><p><span>00:24:24.60</span> of you storm off in anger. So,</p><p><span>00:24:25.90</span> I&#39;m going to show you this tweet, and I</p><p><span>00:24:28.13</span> wouldn&#39;t be quite this uncharitable, but</p><p><span>00:24:29.93</span> I broadly agree with this position.</p><p><span>00:24:31.19</span> It&#39;s a lot of fun like. I have</p><p><span>00:24:32.81</span> been programming for 45 years. I have</p><p><span>00:24:34.01</span> shipped <a href="https://ocaml.org">OCaml</a>. I have shipped <a href="https://www.haskell.org">Haskell</a>. I</p><p><span>00:24:35.39</span> love Haskell, actually. I think it&#39;s great.</p><p><span>00:24:35.40</span> But I would say that over those many</p><p><span>00:24:37.66</span> decades, I have not really seen the</p><p><span>00:24:39.83</span> programs in these languages to have any</p><p><span>00:24:42.40</span> fewer defects than programs in any other</p><p><span>00:24:43.90</span> programming language that I use, modulo</p><p><span>00:24:46.01</span> the ones with really bad memory</p><p><span>00:24:48.77</span> allocation behavior.</p><p><span>00:24:51.28</span> And there has been considerable</p><p><span>00:24:52.97</span> empirical study of this question, and</p><p><span>00:24:55.31</span> there has been no evidence. It really</p><p>I was going to do a little literature review here to show that development speed claims for dynamic languages and code quality/maintenance claims for static languages appear to have no empirical evidence, but Dan Luu has already done a great job of that, so I&#39;ll just link to his <a href="https://danluu.com/empirical-pl/">page on the topic</a>. Summary: “[U]nder the specific set of circumstances described in the studies, any effect, if it exists at all, is small. [...] If the strongest statement you can make for your position is that there&#39;s no empirical evidence against the position, that&#39;s not much of a position.”</p><p><span>00:24:56.87</span> doesn&#39;t seem to matter. So if you like</p><p><span>00:24:59.14</span> programming in those languages, that&#39;s</p><p><span>00:25:01.90</span> great! I encourage you to do it! You</p><p><span>00:25:03.35</span> should program it whatever you enjoy, but</p><p><span>00:25:05.02</span> you shouldn&#39;t pretend that you have a</p><p><span>00:25:07.01</span> moral high ground because you&#39;ve chosen</p><p><span>00:25:08.75</span> this particular language. And I would say</p><p><span>00:25:10.31</span> really that if what you care about is</p><p><span>00:25:12.16</span> systems that are highly fault tolerant,</p><p><span>00:25:14.45</span> you should be using something like</p><p><span>00:25:16.37</span> Erlang over something like Haskell</p><p><span>00:25:18.47</span> because the facilities Erlang provides</p><p><span>00:25:19.78</span> are more likely to give you working</p><p><span>00:25:21.04</span> programs.</p><p>Imagine that you were about to take a transatlantic flight. If some engineers from the company that built the aircraft told you that they had not tested the engines, but had proven them correct by construction, would you board the plane? I most certainly would not. Real engineering involves testing the components of a system and using them within their tolerances, along with backup systems in case of failure. Erlang&#39;s supervision trees resemble what we would do for critical systems in other engineering disciplines.</p><p><span>00:25:22.85</span> You can throw fruit at me – rotten fruit –</p><p><span>00:25:24.47</span> at me later. You can find me in the</p><p><span>00:25:26.45</span> hallway track to tell me how wrong I am.</p><p><span>00:25:28.43</span> So, I&#39;ve said that, but I&#39;ll also</p><p><span>00:25:30.23</span> show you probably the most beautiful</p><p><span>00:25:32.51</span> piece of [code] that I&#39;ve ever seen.</p><p><span>00:25:33.64</span> Like, the best source code in the world.</p><p><span>00:25:35.33</span> And that&#39;s <a href="https://en.wikipedia.org/wiki/Douglas_McIlroy">McIlroy</a>&#39;s <i><a href="https://www.cs.dartmouth.edu/~doug/powser.html">Power Serious</a></i>, which</p><p><span>00:25:37.19</span> happens to be written in Haskell. So, this</p><p><span>00:25:38.75</span> is a mutually recursive definition of</p><p><span>00:25:38.76</span> the series of sine and cosine in two</p><p><span>00:25:40.13</span> lines of code. I want to cry when I look</p><p><span>00:25:42.11</span> at this because of how beautiful it is.</p><p><span>00:25:43.25</span> But that has nothing to do with software</p><p><span>00:25:44.63</span> engineering. Do you understand what I&#39;m</p><p><span>00:25:47.33</span> saying? There&#39;s a different question. The</p><p><span>00:25:48.89</span> beauty of the language is not always</p><p><span>00:25:50.87</span> what gets you to where you need to go.</p><p><span>00:25:52.13</span> I will make a an exception here for</p><p><span>00:25:53.87</span> model checkers, because</p><p><span>00:25:55.97</span> protocols are super hard! It&#39;s a good</p><p><span>00:25:57.52</span> idea to try to verify them I&#39;ve used</p><p><span>00:25:59.02</span> <a href="https://coq.inria.fr">Coq</a> and <a href="https://dl.acm.org/doi/10.1145/231379.231430">Teapot</a> [for example] for these kinds of</p><p><span>00:26:00.95</span> things in the past, and some systems do</p><p><span>00:26:02.14</span> have such a high cost of failure that it</p><p><span>00:26:03.64</span> makes sense to use them. If you&#39;re</p><p><span>00:26:05.14</span> doing some kind of, you know, horrible</p><p><span>00:26:07.01</span> cryptocurrency thing, where you&#39;re likely</p><p><span>00:26:08.75</span> to lose a billion dollars worth of</p><p><span>00:26:11.09</span> SomethingCoin™, then, yeah, you</p><p><span>00:26:14.39</span> maybe want to use some kind of verifier</p><p><span>00:26:15.83</span> to make sure you&#39;re not going to screw</p><p><span>00:26:17.33</span> it up. But, that said, space</p><p><span>00:26:18.71</span> probes written in Lisp and <a href="https://en.m.wikipedia.org/wiki/Forth_(programming_language">FORTH</a>)</p><p><span>00:26:20.21</span> have been <a href="https://corecursive.com/lisp-in-space-with-ron-garret/">debugged while off world</a>.</p><p>Had I had more time, I would have done an entire series of slides on FORTH. It&#39;s a tiny language that combines interactive development, expressive metaprogramming, and tremendous machine sympathy. I&#39;ve shipped embedded systems, bootloaders, and other close-to-the-metal software in FORTH.</p><p><span>00:26:22.25</span> If they had if they had proven their</p><p><span>00:26:23.81</span> programs correct by construction,</p><p><span>00:26:25.07</span> shipped them into space, and then found out</p><p><span>00:26:26.63</span> their spec was wrong, they would have</p><p><span>00:26:28.43</span> just had some dead junk on Mars. But what</p><p>In fact, they <em>did</em> prove their program correct by construction. But there was <a href="https://corecursive.com/lisp-in-space-with-ron-garret/#deep-space-failure">still human error</a>!</p><p><span>00:26:30.35</span> these guys had was the ability to fix</p><p><span>00:26:33.47</span> things while they are running on space</p><p><span>00:26:34.85</span> probes. I think that&#39;s actually more</p><p><span>00:26:35.93</span> valuable. Again, throw the rotten fruit</p><p><span>00:26:37.90</span> later. Meet me in the hallway track.</p><p><span>00:26:40.19</span> I would say overall that part of</p><p><span>00:26:42.40</span> this is because programming is actually</p><p><span>00:26:44.75</span> a design discipline. It — oh, we&#39;re losing</p><p><span>00:26:46.19</span> somebody – somebody&#39;s leaving now probably</p><p><span>00:26:47.51</span> out of anger about static types.</p><p>This was an improvised joke about someone leaving to eat lunch or use the bathroom or something. I&#39;ve since heard that that person felt embarassed and called out by the joke, so I&#39;d like to leave an apology here. It was meant to be funny in context!</p><p><span>00:26:48.95</span> As a design discipline, you find that you</p><p><span>00:26:50.93</span> will figure out what you&#39;re building as</p><p><span>00:26:52.43</span> you build it. You don&#39;t actually</p><p><span>00:26:54.83</span> know when you start, even if you think</p><p><span>00:26:57.04</span> you do, so it&#39;s important that we build</p><p><span>00:26:58.90</span> buggy approximations on the way, and I</p><p><span>00:27:00.89</span> think it&#39;s not the best use of your time</p><p><span>00:27:02.93</span> to prove theorems about code that you&#39;re</p><p><span>00:27:04.31</span> going to throw away anyway. In addition,</p><p><span>00:27:07.43</span> the spec is always wrong! It doesn&#39;t</p><p><span>00:27:08.57</span> matter where you got it, or who said it,</p><p><span>00:27:12.76</span> the only complete spec for any</p><p><span>00:27:14.87</span> non-trivial system is the source code of</p><p><span>00:27:16.25</span> the system itself. We learn through</p><p><span>00:27:18.28</span> iteration, and when the spec&#39;s right, it&#39;s</p><p><span>00:27:20.02</span> still wrong! Because the software will</p><p><span>00:27:21.71</span> change tomorrow. All software is</p><p><span>00:27:24.23</span> continuous change. The spec today is not</p><p><span>00:27:25.73</span> the spec tomorrow. Which leads me to</p><p><span>00:27:27.23</span> say that overall, debuggability is in my</p><p><span>00:27:29.26</span> opinion more important than correctness</p><p><span>00:27:32.14</span> by construction. So let&#39;s talk about</p><p><span>00:27:33.76</span> debugging!</p><p><span>00:27:35.51</span> I would say that actually most</p><p><span>00:27:37.25</span> programming is debugging. What do we</p><p><span>00:27:38.63</span> spend our time doing these</p><p><span>00:27:41.02</span> days? Well, we&#39;re spending a lot of time</p><p><span>00:27:43.25</span> with other people&#39;s libraries. We&#39;re</p><p><span>00:27:44.87</span> dealing with API endpoints. We&#39;re dealing</p><p><span>00:27:46.97</span> with huge legacy code bases, and we&#39;re</p><p><span>00:27:48.71</span> spending all our time like this robot</p><p><span>00:27:50.93</span> detective, trying to find out what&#39;s</p><p><span>00:27:52.37</span> actually happening in the code. And we do</p><p><span>00:27:54.16</span> that with exploratory programming,</p><p><span>00:27:54.17</span> because it reduces the amount of</p><p><span>00:27:55.66</span> suffering involved. So, for example, in a</p><p><span>00:27:57.64</span> dead coding language, I will have to run</p><p><span>00:27:58.90</span> a separate debugger, load in the program,</p><p><span>00:28:00.35</span> and run it, set a break point, and get it</p><p><span>00:28:01.31</span> here. Now, if I&#39;ve had a fault in</p><p><span>00:28:02.75</span> production, this is not actually so</p><p><span>00:28:04.49</span> helpful to me. Maybe I have a core dump,</p><p><span>00:28:06.35</span> and the core dump has some information</p><p><span>00:28:07.73</span> that I could use, but it doesn&#39;t show me</p><p><span>00:28:08.99</span> the state of things while it&#39;s running.</p><p><span>00:28:11.21</span> Now here&#39;s some Common Lisp. Look, I set</p><p><span>00:28:12.83</span> this variable. Look, I inspect this</p><p><span>00:28:14.51</span> variable on the bottom I see the value</p><p><span>00:28:16.49</span> of the variable. This is <i>valuable</i> to me.</p><p><span>00:28:18.16</span> I like this, and here we</p><p><span>00:28:20.33</span> have a way to look at a whole set of</p><p><span>00:28:22.49</span> nested data structures graphically. We</p><p><span>00:28:24.04</span> can actually see things – note in</p><p><span>00:28:25.85</span> particular the complex double float at</p><p><span>00:28:27.28</span> the bottom that shows you a geometric</p><p><span>00:28:28.37</span> interpretation.</p><p>This object inspector is called Clouseau. You can see a video about it <a href="https://youtube.com/watch?v=-1LzFxTbU9E">here</a>.</p><p><span>00:28:30.23</span> This is amazing! This is also 1980s</p><p><span>00:28:31.49</span> technology. You should be ashamed if</p><p><span>00:28:33.89</span> you&#39;re using a programming language that</p><p><span>00:28:35.57</span> doesn&#39;t give you this at run time.</p><p><span>00:28:37.31</span> Speaking of programming languages that</p><p><span>00:28:39.64</span> <em>do</em> give you this at runtime, here is a</p><p><span>00:28:43.07</span> modern version in Clojure. Here&#39;s somebody</p><p><span>00:28:45.95</span> doing a <a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> query and getting back</p><p><span>00:28:47.93</span> some information and graphing it as they</p><p><span>00:28:49.31</span> go. I will say that Clojure is slightly</p><p><span>00:28:51.64</span> less good at this than Common Lisp, at </p><p><span>00:28:53.02</span> present, in part because the <a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">Common Lisp</a></p><p><span>00:28:53.03</span> <a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">Object System</a> (CLOS) makes it particularly easy</p><p><span>00:28:54.16</span> to have good presentations for different</p><p><span>00:28:56.51</span> kinds of things, but at least it&#39;s in the</p><p><span>00:28:58.19</span> right direction.</p><p><span>00:28:59.14</span> As we talk about this, one of the</p><p><span>00:29:00.52</span> things in these kinds of programming</p><p><span>00:29:02.33</span> languages, like Lisp, is that you have an</p><p><span>00:29:04.31</span> editor and you&#39;re evaluating forms – all the</p><p><span>00:29:06.16</span> Clojure parameters here are going to</p><p><span>00:29:08.14</span> know this right off –</p><p><span>00:29:10.19</span> you&#39;re evaluating forms and they&#39;re</p><p><span>00:29:12.04</span> being added to the runtime as you go. And</p><p><span>00:29:13.43</span> this is great. It&#39;s a fantastic way to</p><p><span>00:29:14.69</span> build up a program, but there&#39;s a real</p><p><span>00:29:16.49</span> problem with it, which is that if you</p><p><span>00:29:18.35</span> delete some of that code, the thing</p><p><span>00:29:19.90</span> that you just evaluated earlier is still</p><p><span>00:29:20.93</span> in the runtime. So it would be great if</p><p><span>00:29:23.14</span> there were a way that we could know what</p><p><span>00:29:24.71</span> is current rather than having, say, a text</p><p><span>00:29:26.81</span> file that grows gradually out of sync</p><p><span>00:29:28.49</span> with the running system. And that&#39;s</p><p><span>00:29:29.69</span> called <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a>, and has been around</p><p><span>00:29:30.88</span> since at least the 70s. So this is the</p><p><span>00:29:32.14</span> Smalltalk object browser. We&#39;re</p><p><span>00:29:34.85</span> looking at <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a>,</p><p><span>00:29:36.47</span> specifically we&#39;re looking at</p><p><span>00:29:37.78</span> backtracking in the shortest path</p><p><span>00:29:39.11</span> algorithm, and if I change this I know I</p><p><span>00:29:41.26</span> changed it. I know what&#39;s happening if I</p><p><span>00:29:43.07</span> delete this method the method is gone.</p><p><span>00:29:44.63</span> It&#39;s no longer visible. So there is a</p><p><span>00:29:45.95</span> direct correspondence between what I&#39;m</p><p><span>00:29:48.40</span> doing and what the system knows and</p><p><span>00:29:50.57</span> what I&#39;m seeing in front of me, and</p><p><span>00:29:52.01</span> this is very powerful. And here we have</p><p><span>00:29:53.87</span> the <a href="https://gtoolkit.com">Glamorous toolkit</a>. This is</p><p><span>00:29:56.38</span> <a href="http://www.tudorgirba.com">Tudor Gîrba</a> and <a href="https://feenk.com">feenk</a>&#39;s thing. They embrace this</p><p><span>00:29:57.83</span> philosophy completely. They have built an</p><p><span>00:29:58.90</span> enormous suite of visualizations that</p><p><span>00:29:59.99</span> allow you to find out things about your</p><p><span>00:30:01.85</span> program while it&#39;s running. We should all</p><p><span>00:30:04.85</span> take inspiration from this. This is an</p><p><span>00:30:06.35</span> ancient tradition, and they have kind of</p><p><span>00:30:07.90</span> taken this old thing of Smalltalkers</p><p><span>00:30:10.37</span> and Lispers building their own tools as</p><p><span>00:30:12.40</span> they go to understand their own codebases,</p><p><span>00:30:13.97</span> and they have sort of pushed it –</p><p><span>00:30:15.16</span> they&#39;ve pushed the pedal all the way to</p><p><span>00:30:17.63</span> the floor, and they&#39;re rushing forward</p><p><span>00:30:19.90</span> into the future and we should follow</p><p><span>00:30:21.76</span> them.</p><p><span>00:30:23.81</span> Another thing that is very useful in</p><p><span>00:30:25.19</span> these situations is error handling. If</p><p><span>00:30:26.81</span> your error handling is &#39;the program stops&#39;,</p><p><span>00:30:29.02</span> then it&#39;s pretty hard to recover.</p><p><span>00:30:31.07</span> But in a Common Lisp program like this –</p><p><span>00:30:33.04</span> this is an incredibly stupid toy example –</p><p><span>00:30:34.85</span> but I have a version function. I have not</p><p><span>00:30:36.04</span> actually evaluated the function yet. I&#39;m</p><p><span>00:30:37.54</span> going to try to call it. So, what&#39;s going</p><p><span>00:30:39.28</span> to happen, well, the CL people here know</p><p><span>00:30:40.73</span> what&#39;s going to happen, it&#39;s going to pop</p><p><span>00:30:41.81</span> up the <a href="https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html">condition handler</a>. So this is</p><p><span>00:30:43.07</span> something that – programming in Clojure –</p><p><span>00:30:43.08</span> I actually really miss from Common Lisp.</p><p><span>00:30:43.90</span> It comes up, and I have options here. I</p><p><span>00:30:45.88</span> can type in the value of a specific</p><p><span>00:30:47.51</span> function, say &#39;hey call this one instead&#39;</p><p><span>00:30:49.13</span> for the missing function. I can try again,</p><p><span>00:30:50.99</span> which – if I don&#39;t change anything – will</p><p><span>00:30:52.90</span> just give me the same condition handler.</p><p><span>00:30:54.64</span> Or, I can change the state of the running</p><p><span>00:30:57.04</span> image and then try again. So, for example,</p><p><span>00:30:58.54</span> if I go down and evaluate the function</p><p><span>00:31:00.16</span> so that it&#39;s now defined and hit retry,</p><p><span>00:31:01.90</span> it just works. This is pretty amazing. We</p><p><span>00:31:02.81</span> should all expect this from our</p><p><span>00:31:05.09</span> programming environments. Again, when I</p><p><span>00:31:06.23</span> talk about Smalltalk and Lisp, people say</p><p><span>00:31:07.61</span> &#39;well, I don&#39;t want to use Smalltalk or Lisp&#39;. I&#39;m</p><p><span>00:31:09.64</span> not telling you to use Smalltalk or</p><p><span>00:31:11.45</span> Lisp. I&#39;m telling you that you should have</p><p><span>00:31:13.01</span> programming languages that are at least</p><p><span>00:31:14.99</span> as good as Smalltalk and Lisp.</p><p><span>00:31:16.37</span> Some people, when I show them all this</p><p><span>00:31:17.81</span> stuff – all this interactive stuff, they&#39;re,</p><p><span>00:31:19.61</span> like, &#39;Well, what if I just had a real fast</p><p><span>00:31:21.71</span> compiler, man? You know I can just</p><p><span>00:31:23.45</span> just change and hit a key and then the</p><p><span>00:31:25.19</span> things that –&#39; Well, we&#39;re back to that</p><p><span>00:31:28.01</span> 💩 again, because if you have a fast</p><p><span>00:31:29.81</span> compiler you still have all the problems</p><p><span>00:31:31.97</span> with the blank slate/run-to-termination</p><p><span>00:31:33.64</span> style. Data science workloads</p><p><span>00:31:35.09</span> take a long time to initialize. You might</p><p><span>00:31:36.23</span> have a big data load and you don&#39;t want</p><p><span>00:31:37.43</span> to have to do that every single time you</p><p><span>00:31:38.81</span> make a change to your code. And the data</p><p><span>00:31:41.21</span> science people know this! This is why R</p><p><span>00:31:42.76</span> is interactive. This is why we have</p><p><span>00:31:43.97</span> notebooks for Python and other languages,</p><p><span>00:31:45.71</span> because they know it&#39;s crazy to work</p><p><span>00:31:48.23</span> this other way. Also, GUI State – oh my word!</p><p><span>00:31:49.54</span> It can be incredibly tedious to click</p><p><span>00:31:50.87</span> your way back down to some sub-sub-menu</p><p><span>00:31:53.38</span> so that you can get to the part where</p><p><span>00:31:55.13</span> the problem is. You want to just keep it</p><p><span>00:31:56.57</span> right where it is and go in and see</p><p><span>00:31:58.78</span> what&#39;s happening behind the scenes, and</p><p><span>00:32:00.35</span> fix it while it&#39;s running.</p><p>Someone came up to me after the talk and described a situation where he was working on a big, fancy commercial video game. He had to play the same section of the game for 30 minutes to get back to where the error occurred each time. 😱</p><p><span>00:32:01.78</span> Also, you should be able to attach to</p><p><span>00:32:03.35</span> long-running servers and debug them</p><p><span>00:32:05.45</span> while they&#39;re in production. This is</p><p><span>00:32:07.13</span> actually good! It&#39;s scary to people who</p><p><span>00:32:08.75</span> are easily frightened, but it is very</p><p><span>00:32:10.78</span> powerful.</p><p><span>00:32:13.19</span> I&#39;ll say after all of this about</p><p><span>00:32:16.37</span> interactive programming, about escaping</p><p><span>00:32:18.40</span> batch mode, that almost all programming</p><p><span>00:32:20.21</span> today is still batch mode. And how do we</p><p><span>00:32:21.52</span> feel about that? I kind of feel like <a href="https://en.wikipedia.org/wiki/J._C._R._Licklider">Licklider</a></p><p><span>00:32:23.09</span> did. Licklider funded</p><p><span>00:32:24.88</span> almost all of the work that created the</p><p><span>00:32:26.26</span> world we live in today, and Engelbart</p><p><span>00:32:27.95</span> built half of it, and one of the things</p><p><span>00:32:29.69</span> that Licklider said that I found – I</p><p><span>00:32:31.07</span> just love the phrase – is &#39;getting into</p><p><span>00:32:33.23</span> position to think&#39;. That is, all of the</p><p><span>00:32:34.97</span> ceremony that you have to go through to</p><p><span>00:32:36.59</span> get ready to do your work should go away,</p><p><span>00:32:36.60</span> and that was their whole mission in the</p><p><span>00:32:38.99</span> 60s.</p><p><span>00:32:40.73</span> We almost got there, but then we have</p><p><span>00:32:42.40</span> languages like C++.</p><p><span>00:32:43.78</span> I could say a lot of mean things</p><p><span>00:32:46.31</span> about C++, but I used to work at the</p><p><span>00:32:47.57</span> same facility that Bjarne did, and I kind</p><p><span>00:32:49.66</span> of know him a little bit, so I&#39;m not</p><p><span>00:32:51.23</span> going to do that. Instead,</p><p><span>00:32:52.97</span> I&#39;m just going to quote Ken Thompson</p><p><span>00:32:56.99</span> This is a really funny situation,</p><p><span>00:32:59.21</span> because I worked [using] some of the early C++</p><p><span>00:33:01.31</span> compilers because I was</p><p><span>00:33:03.28</span> excited about the idea of having decent</p><p><span>00:33:05.69</span> abstractions in a low-level language</p><p><span>00:33:08.14</span> that I could use [at work]. But I will say that it</p><p><span>00:33:08.15</span> was never great, and that it has gotten</p><p><span>00:33:09.40</span> worse over time, paradoxically by adding</p><p><span>00:33:11.51</span> good features to the language. But</p><p><span>00:33:14.26</span> if you keep adding every feature that</p><p><span>00:33:16.13</span> you possibly want, you end up</p><p><span>00:33:17.69</span> with a language that is not in any way</p><p><span>00:33:19.66</span> principled. There is no way to reason</p><p><span>00:33:20.99</span> about it. It has too much junk in it. And</p><p><span>00:33:22.97</span> if you&#39;d like to see this happening in</p><p><span>00:33:26.45</span> real time to another language, I</p><p><span>00:33:31.43</span> recommend that you read what&#39;s going on</p><p><span>00:33:33.40</span> in <a href="https://tc39.es">TC39</a> with JavaScript, where they are</p><p><span>00:33:34.85</span> adding every possible feature and</p><p><span>00:33:36.52</span> muddying an already difficult language</p><p><span>00:33:38.81</span> further.</p><p>In all fairness, TC39 is in a terrible position. They can&#39;t remove features from the language because there&#39;s such a large corpus already in the world. At the same time, the language has a bunch of ergonomic problems that they want to fix. I wish they had frozen a primitive version of JS and added a marker at the beginning of scripts to switch out which language is used, much in the way <code>#lang</code> does in Racket.</p><p><span>00:33:40.07</span> So, what about Go? Well, I admire the</p><p><span>00:33:42.76</span> runtime and the <i>goroutines</i>, the garbage</p><p><span>00:33:44.81</span> collector, but it&#39;s really another punch</p><p><span>00:33:47.21</span> card compatible compile/run language. It</p><p><span>00:33:49.25</span> also shares with C++</p><p><span>00:33:50.87</span> the problem that it&#39;s not a great</p><p><span>00:33:52.19</span> library language, because if you want to</p><p><span>00:33:53.45</span> write a library in Go and then use it</p><p><span>00:33:54.88</span> from say a C program, or whatever, you</p><p><span>00:33:57.28</span> have to bring in the entire go runtime,</p><p><span>00:33:58.54</span> which is a couple [of megabytes]. not mostly what I</p><p><span>00:34:00.04</span> want. So what about <a href="https://www.rust-lang.org">Rust</a>? Well, I mean it&#39;s</p><p><span>00:34:01.61</span> a nice thing that Rust is a good library</p><p><span>00:34:03.59</span> language. I like that about it. But it&#39;s</p><p><span>00:34:04.90</span> also a huge missed opportunity in terms</p><p><span>00:34:06.35</span> of interactive programming. They just</p><p><span>00:34:06.36</span> went straight for the punch cards again.</p><p><span>00:34:07.61</span> And it&#39;s a super super complicated</p><p><span>00:34:10.01</span> language, so it would be nice when</p><p><span>00:34:11.51</span> trying to figure out which of the 40</p><p><span>00:34:12.95</span> different memory allocation keywords</p><p><span>00:34:15.29</span> you&#39;re going to use to tell it how to do</p><p><span>00:34:16.60</span> its thing if you could explore that</p><p><span>00:34:17.99</span> interactively instead of going through a</p><p><span>00:34:19.55</span> compile/test cycle. And another way that</p><p><span>00:34:21.40</span> I feel about it – I have to <a href="https://twitter.com/deech/status/1564245672068628480">quote Deech</a></p><p><span>00:34:23.38</span> here – which is that you know some people</p><p><span>00:34:25.07</span> hate stop the world GC, I really hate</p><p><span>00:34:27.23</span> stop the world type checkers. If</p><p><span>00:34:29.57</span> it&#39;s going to take me an hour to compile</p><p><span>00:34:30.95</span> my thing, I just want to give up. I&#39;m</p><p><span>00:34:32.81</span> going to become a carpenter or something.</p><p><span>00:34:35.03</span> In this family of languages,</p><p><span>00:34:36.34</span> I&#39;ll say that <a href="https://ziglang.org">Zig</a> is more to my taste. I</p><p><span>00:34:37.60</span> actually like Zig more than I like</p><p><span>00:34:40.12</span> Rust. This will anger all of the</p><p><span>00:34:41.99</span> Rustaceans. I apologize, but it is true.</p><p><span>00:34:43.31</span> But, Zig people – for goodness sake – why is</p><p><span>00:34:45.10</span> there no interactive story there either?</p><p><span>00:34:46.66</span> You&#39;ve got this nice little language</p><p><span>00:34:47.93</span> that has multi-stage compilation. It can</p><p><span>00:34:49.60</span> learn a lot from Lisp, and it just sort</p><p><span>00:34:52.43</span> of ignores all that and goes straight</p><p><span>00:34:53.57</span> to the 1970s or before.</p><p><span>00:34:55.43</span> So what do future directions that don&#39;t</p><p><span>00:34:57.34</span> suck look like? Well, I&#39;ll give you some</p><p><span>00:34:58.73</span> examples that try to use some</p><p><span>00:34:59.75</span> of the things I&#39;ve talked about as</p><p><span>00:35:01.55</span> underexplored areas. So, this</p><p><span>00:35:02.75</span> is a <a href="https://en.wikipedia.org/wiki/Structure_editor">structure editor</a> for <a href="https://racket-lang.org">Racket</a>, which</p><p><span>00:35:04.84</span> is a dialect of <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language">Scheme</a>), and it was built</p><p><span>00:35:07.01</span> by a fellow called <a href="https://andrewblinn.com">Andrew Blinn</a>, and it&#39;s</p><p><span>00:35:08.51</span> still Racket underneath. That is, it&#39;s</p><p><span>00:35:10.01</span> still a lot of parentheses – it&#39;s still</p><p><span>00:35:11.99</span> S-expressions – but when you&#39;re editing it,</p><p><span>00:35:14.56</span> you have this completely different</p><p><span>00:35:15.89</span> feeling where you&#39;re modifying this</p><p><span>00:35:17.39</span> living structure and it&#39;s quite colorful</p><p><span>00:35:19.13</span> and beautiful – probably for some of you</p><p><span>00:35:20.56</span> garish – but I like it.</p><p><span>00:35:22.13</span> And I recommend having a peek at how</p><p><span>00:35:25.67</span> that works, and compare it to how you&#39;re</p><p><span>00:35:27.53</span> editing code now. Another example that I</p><p><span>00:35:29.27</span> think will be more accessible to this</p><p><span>00:35:32.21</span> audience is this one from <a href="https://leifandersen.net">Leif Anderson</a>.</p><p><span>00:35:33.17</span> This is also Racket, and this is doing a</p><p><span>00:35:35.27</span> define using pattern matching for a red</p><p><span>00:35:37.25</span> black tree balancing algorithm. And it is</p><p><span>00:35:39.47</span> an ancient practice of many years to</p><p><span>00:35:42.29</span> document gnarly code like this with a</p><p><span>00:35:43.67</span> comment block over it, but you have a</p><p><span>00:35:46.13</span> couple of problems: (1) the comment block</p><p><span>00:35:47.51</span> is ugly and not completely obviously</p><p><span>00:35:49.01</span> meaning what it&#39;s supposed to mean; but</p><p><span>00:35:50.45</span> also (2) it can grow out of sync with the</p><p><span>00:35:52.43</span> code itself so. Leif has made this fine</p><p><span>00:35:53.81</span> thing that reads the code and produces</p><p><span>00:35:55.37</span> these diagrams, and you can switch the</p><p><span>00:35:57.82</span> diagram view on or off. So this is</p><p><span>00:35:59.45</span> what – if we want to talk about</p><p><span>00:36:01.43</span> self-documenting code, I would say</p><p><span>00:36:02.56</span> something like this that can actually</p><p><span>00:36:04.55</span> show you what the code does is better</p><p><span>00:36:07.49</span> than what most things do.</p><p><span>00:36:09.10</span> In the same vein, we&#39;ve got this piece.</p><p><span>00:36:11.27</span> This is called <a href="https://datarabbit.com">Data Rabbit</a>. Data</p><p><span>00:36:13.84</span> Rabbit is a crazy data visualization</p><p><span>00:36:15.71</span> thing written in Clojure. Each one of</p><p><span>00:36:17.08</span> these little blocks that are connected</p><p><span>00:36:18.29</span> by these tubes is actually a little</p><p><span>00:36:20.51</span> piece of Clojure code, and they can do</p><p><span>00:36:22.67</span> data visualization, they can do</p><p><span>00:36:24.53</span> refinement, they can do all of these nice</p><p><span>00:36:26.21</span> things. I&#39;m not a huge, you know, box</p><p><span>00:36:28.19</span> and arrow programming language guy, but I</p><p><span>00:36:29.63</span> think that Ryan has done great work here</p><p><span>00:36:32.27</span> and that everybody should take a look at</p><p><span>00:36:33.13</span> it.</p><p><span>00:36:34.91</span> There&#39;s also <a href="https://clerk.vision">Clerk</a>. I&#39;m a bit biased</p><p><span>00:36:36.05</span> here. This is something I work on. This is</p><p><span>00:36:38.03</span> something I&#39;ve been working on for the</p><p><span>00:36:39.95</span> last year with the team at <a href="https://nextjournal.com">Nextjournal</a>,</p><p><span>00:36:42.17</span> but I think it is actually very good, so</p><p><span>00:36:44.63</span> I&#39;m going to tell you a little something</p><p><span>00:36:46.67</span> about it.</p><p><span>00:36:48.17</span> This is this is what it looks like</p><p><span>00:36:49.43</span> when you&#39;re working with Clerk. You&#39;ve got</p><p><span>00:36:51.34</span> whatever editor you want on one side and</p><p><span>00:36:52.97</span> then you&#39;ve got a view onto the contents</p><p><span>00:36:54.17</span> of the namespace you&#39;re working on off</p><p><span>00:36:55.49</span> to the side. This has some special</p><p><span>00:36:57.53</span> properties. It means, for one thing, that</p><p><span>00:36:59.08</span> you can put these notebooks into version</p><p><span>00:37:01.19</span> control. You can ship these notebooks.</p><p><span>00:37:02.51</span> These can be libraries that you use. You</p><p><span>00:37:02.52</span> don&#39;t have this separation between your</p><p><span>00:37:03.47</span> notebook code and your production code.</p><p><span>00:37:05.45</span> They can be the same thing, and it</p><p><span>00:37:06.82</span> encourages a kind of <a href="https://en.wikipedia.org/wiki/Literate_programming">literate</a></p><p><span>00:37:07.84</span> <a href="https://en.wikipedia.org/wiki/Literate_programming">programming</a> approach where every comment</p><p><span>00:37:09.17</span> along the way – or every comment block</p><p><span>00:37:11.03</span> along the way – is interpretered as markdown,</p><p><span>00:37:11.93</span> with <a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX</a> and other features.</p><p><span>00:37:13.01</span> It&#39;s a very nice way to work. I</p><p><span>00:37:14.99</span> encourage the Clojure people here to</p><p><span>00:37:16.06</span> check it out. It is of no use to you if</p><p><span>00:37:18.10</span> you&#39;re not a Clojure person, because it&#39;s</p><p><span>00:37:20.15</span> very Clojure-specific. And I&#39;ll show you</p><p><span>00:37:21.89</span> a couple of other screenshots here, like</p><p><span>00:37:23.56</span> this we&#39;re doing some data science and</p><p><span>00:37:26.08</span> you&#39;ve got – that&#39;s my emacs on the</p><p><span>00:37:27.89</span> right hand side, and I&#39;m able to do all</p><p><span>00:37:30.23</span> of the things, like pretty printing data</p><p><span>00:37:31.97</span> structures, and inspecting them, and then</p><p><span>00:37:34.19</span> sending things over and seeing them in</p><p><span>00:37:35.63</span> Clerk. It is a very cozy way to work.</p><p><span>00:37:37.67</span> There&#39;s also, for instance, this example</p><p><span>00:37:38.81</span> where in around six lines of code I do a</p><p><span>00:37:40.37</span> query for some bioinformatic information</p><p><span>00:37:42.29</span> that shows me</p><p><span>00:37:43.91</span> what drugs affect what genes that are</p><p><span>00:37:45.34</span> known to be correlated with what</p><p><span>00:37:47.39</span> diseases, so we can see what drugs</p><p><span>00:37:48.77</span> might be interesting targets for genetic</p><p><span>00:37:50.08</span> disorders of differing type. Twenty</p><p><span>00:37:51.29</span> years ago, if you would have told people</p><p><span>00:37:53.56</span> they&#39;d be able to do a single query like</p><p><span>00:37:55.73</span> this and find these kinds of things out</p><p><span>00:37:57.10</span> they would have looked at you like had</p><p><span>00:37:58.79</span> two heads, but here it is and it&#39;s no</p><p><span>00:38:00.34</span> code at all. Or this, which is a <a href="https://github.com/sicmutils/sicmutils">port</a> of</p><p><span>00:38:02.15</span> Sussman&#39;s <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Classical_Mechanics">Structure and Interpretation</a></p><p><span>00:38:03.71</span> <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Classical_Mechanics">of Classical Mechanics</a> library into</p><p><span>00:38:05.27</span> Clojure that you can use inside of Clerk.</p><p>This is very nice work by <a href="https://samritchie.io">Sam Ritchie</a>. In addition to porting the libraries, he&#39;s working on an open edition of Sussman&#39;s textbooks using Clojure.</p><p><span>00:38:07.73</span> And then [you can] do things with physics –</p><p><span>00:38:09.95</span> real things. This is emulating a chaotic</p><p><span>00:38:11.87</span> system, and you can actually – you can&#39;t</p><p><span>00:38:13.43</span> see on this – but you can actually grab</p><p><span>00:38:15.77</span> sliders and move them around and change</p><p><span>00:38:17.75</span> the state of the system in real time.</p><p><span>00:38:18.82</span> It&#39;ll show you what&#39;s happening.</p><p><span>00:38:20.15</span> Or this. Martin here in the front row</p><p><span>00:38:23.56</span> wrote this. This is an example of <a href="https://en.wikipedia.org/wiki/Rule_30">Rule</a></p><p><span>00:38:25.49</span> <a href="https://en.wikipedia.org/wiki/Rule_30">30</a>, which is a <a href="https://en.wikipedia.org/wiki/Cellular_automaton">cellular automaton</a>, and he&#39;s</p><p><span>00:38:26.56</span> written a viewer for it, so instead of</p><p><span>00:38:27.89</span> looking at 1s and 0s, you can</p><p><span>00:38:28.91</span> actually see the thing he&#39;s working on.</p><p><span>00:38:29.87</span> And the amount of code this takes is</p><p><span>00:38:31.73</span> almost none.</p><p><span>00:38:34.55</span> This is a regular expression dictionary</p><p><span>00:38:36.10</span> that I wrote. This thing – one of the</p><p><span>00:38:38.87</span> nice things about Clerk is you have all</p><p><span>00:38:40.67</span> the groovy visualization [and] interactive</p><p><span>00:38:42.17</span> things that come from having a browser,</p><p><span>00:38:43.91</span> but you also have all the power of</p><p><span>00:38:45.41</span> Clojure running on the JVM on the other</p><p><span>00:38:46.60</span> side. So you can do things like talk to a</p><p><span>00:38:47.93</span> database on the file system, which is a</p><p><span>00:38:49.19</span> revelation compared to what you can</p><p><span>00:38:51.34</span> normally do with a browser.</p><p><span>00:38:53.15</span> With this kind of thing you</p><p><span>00:38:55.13</span> can do rapid application development. You</p><p><span>00:38:57.17</span> can do all kinds of things, and I will</p><p><span>00:38:58.60</span> add that clerk actually improves on the</p><p><span>00:38:59.69</span> execution semantics that you normally</p><p><span>00:39:00.95</span> get with emacs and Clojure. This is inside</p><p><span>00:39:02.32</span> baseball for the Clojure people, sorry</p><p><span>00:39:04.49</span> for everybody else, but that thing I was</p><p><span>00:39:06.23</span> talking about – about how you can add</p><p><span>00:39:08.08</span> things to the running image and then</p><p><span>00:39:09.29</span> delete the code and then they&#39;re not</p><p><span>00:39:11.15</span> there and you don&#39;t know it and maybe</p><p><span>00:39:12.65</span> you save your program it doesn&#39;t work</p><p><span>00:39:14.03</span> the next time you start – Clerk will not</p><p><span>00:39:15.34</span> use things that you&#39;ve removed from the</p><p><span>00:39:16.84</span> file. It actually reports that, so you get</p><p><span>00:39:18.65</span> errors when you have gotten your text</p><p><span>00:39:19.97</span> out of sync with your running image.</p><p><span>00:39:21.53</span> Now, obviously, I have a huge Lisp bias. I</p><p><span>00:39:23.51</span> happen to love Lisp, but it&#39;s not just</p><p><span>00:39:25.49</span> Lisps. There are other people doing good</p><p><span>00:39:27.89</span> things. This is called <a href="https://hazel.org">Hazel</a>. This is</p><p><span>00:39:29.99</span> from <a href="https://web.eecs.umich.edu/~comar/">Cyrus Omar</a>&#39;s team. You see those</p><p><span>00:39:31.25</span> little question marks after the function</p><p><span>00:39:32.87</span> there? This is an OCaml or <a href="https://elm-lang.org">Elm</a>-like</p><p><span>00:39:34.01</span> language, and they do something called</p><p><span>00:39:35.81</span> <i>typed holes</i> where they&#39;re actually</p><p><span>00:39:37.25</span> running interactively their type</p><p><span>00:39:38.75</span> inference and using it for its in my</p><p><span>00:39:40.06</span> opinion strongest purpose, which is</p><p><span>00:39:41.27</span> improving user interface. So here, when</p><p><span>00:39:42.34</span> you go to put something into one of</p><p><span>00:39:44.75</span> these typed holes, it knows what type</p><p><span>00:39:46.67</span> it&#39;s going to be, and it&#39;s going to give</p><p><span>00:39:48.71</span> you hints, and it&#39;s going to help you do</p><p><span>00:39:50.39</span> it, and they&#39;ve taken that to build this</p><p><span>00:39:52.25</span> nice student interface. If you&#39;re</p><p><span>00:39:54.71</span> going to teach students through design</p><p><span>00:39:55.73</span> recipes that involve type-based thinking,</p><p><span>00:39:56.87</span> then you should have a thing like this</p><p><span>00:39:58.31</span> that actually helps them in some way, and</p><p><span>00:40:00.41</span> the one they&#39;ve made is very good I</p><p><span>00:40:01.79</span> recommend reading the papers. [Cyrus] has</p><p><span>00:40:03.34</span> a student called <a href="https://dmoon.info">David Moon</a> who has made</p><p><span>00:40:04.84</span> this. This is called <a href="https://tylr.fun/tyde22.pdf">Tylr</a>. I can&#39;t really</p><p><span>00:40:06.41</span> show you this in a good way without</p><p><span>00:40:07.97</span> [many videos]. So I recommend that you go to</p><p><span>00:40:10.19</span> <a href="https://twitter.com/dm_0ney">David Moon&#39;s Twitter</a>, and you scroll</p><p><span>00:40:11.27</span> through and you look at some of these</p><p><span>00:40:13.49</span> things. It&#39;s got a beautiful</p><p><span>00:40:15.23</span> structure editing component that</p><p><span>00:40:16.43</span> prevents you from screwing up your code</p><p><span>00:40:17.51</span> syntactically while you&#39;re working on it,</p><p><span>00:40:18.71</span> and gives you advice based on type</p><p><span>00:40:20.39</span> information.</p><p><span>00:40:22.13</span> Here this is my absolute favorite</p><p><span>00:40:23.56</span> from Cyrus&#39;s group. This is also by</p><p><span>00:40:25.37</span> David Moon who did the structure editor</p><p><span>00:40:26.81</span> and Andrew Blinn who did the nice editor</p><p><span>00:40:28.73</span> for Scheme that we saw at the beginning</p><p><span>00:40:30.17</span> of this section. Here we have, again, an</p><p><span>00:40:32.27</span> OCaml or Elm-like language, but you can</p><p><span>00:40:34.13</span> put these little widgets in.</p><p><span>00:40:36.65</span> These are called <i><a href="https://hazel.org/papers/livelits-paper.pdf">livelits</a></i>, with the</p><p><span>00:40:37.79</span> syntactical affordance here [that] they</p><p><span>00:40:39.71</span> begin with a dollar sign.</p><p><span>00:40:41.51</span> He&#39;s got some data here, and the data</p><p><span>00:40:42.58</span> showed as a data frame. It&#39;s</p><p><span>00:40:43.97</span> actually a convenient, nice to edit thing,</p><p><span>00:40:45.41</span> and it&#39;s in-line with the source code.</p><p><span>00:40:47.56</span> This is a thing where you can have</p><p><span>00:40:49.13</span> more expressive source code by allowing</p><p><span>00:40:50.99</span> you to overlay different views onto the</p><p><span>00:40:51.00</span> source code. You can also see there&#39;s a</p><p><span>00:40:52.49</span> slider in there, and the slider is [live].</p><p><span>00:40:54.23</span> [It] immediately computes. The rest of the</p><p><span>00:40:56.08</span> values are immediately recomputed when</p><p><span>00:40:57.41</span> the slider slides in a data flow kind of</p><p><span>00:40:59.03</span> way. This is a great project. I hope they</p><p><span>00:41:00.23</span> do more of it. Here&#39;s something a little</p><p><span>00:41:02.75</span> crazier. This is <a href="https://github.com/enso-org/enso">Enzo</a>. Enzo is groovy</p><p><span>00:41:05.03</span> because it is a functional programming</p><p><span>00:41:07.06</span> language that has two representations. It</p><p><span>00:41:09.82</span> is projectional, so it is not just this</p><p><span>00:41:11.08</span> kind of lines between boxes thing.</p><p><span>00:41:13.55</span> It&#39;s line between boxes, and then you</p><p><span>00:41:15.10</span> can flip it over and see the code that</p><p><span>00:41:18.23</span> corresponds to those things. You can edit</p><p><span>00:41:19.79</span> either side and it fixes both.</p><p><span>00:41:21.34</span> And now we&#39;ll go on to our last example</p><p><span>00:41:22.97</span> from this section, which is also the</p><p><span>00:41:24.65</span> craziest one. And that is <a href="https://ivanish.ca/hest-podcast/">Hest</a> by <a href="https://ivanish.ca">Ivan Reese</a>.</p><p><span>00:41:27.10</span> Here we&#39;re computing factorial,</p><p><span>00:41:28.37</span> but we&#39;re doing it with animation, so we</p><p><span>00:41:29.69</span> see these values flowing through the</p><p><span>00:41:31.60</span> system in this way and splitting based</p><p><span>00:41:33.10</span> on uh based on criteria that are</p><p><span>00:41:34.60</span> specified in the code, and we&#39;re working</p><p><span>00:41:36.53</span> up to a higher and higher factorial now.</p><p><span>00:41:38.45</span> I look at this, and I don&#39;t say &#39;yeah,</p><p><span>00:41:41.45</span> that&#39;s how I want to program; I</p><p><span>00:41:42.89</span> want to spend every day in this thing&#39;,</p><p><span>00:41:44.81</span> but what I&#39;ve learned – if nothing else –</p><p><span>00:41:47.15</span> over the very long career that I&#39;ve had,</p><p><span>00:41:49.67</span> is if you see something that looks</p><p><span>00:41:50.99</span> completely insane and a little bit like</p><p><span>00:41:52.31</span> outsider art, you&#39;re probably looking at</p><p><span>00:41:53.87</span> something that has good ideas. So, whether</p><p><span>00:41:55.60</span> or not we ever want to work like this, we</p><p><span>00:41:58.01</span> shouldn&#39;t ignore it.</p><p><span>00:41:59.21</span> This was my last example for today.</p><div><p>I had to stop because I was already slightly over time, but there a number of other systems that I would like to have mentioned:</p><ul><li><a href="https://www.inkandswitch.com">Ink &amp; Switch</a> has funded a number of pieces of infrastructure that could be building blocks for new environments. They&#39;ve also funded a team that has produces one of the more interesting tablet interface experiments in recent years, shown <a href="https://www.youtube.com/watch?v=ifYuvgXZ108">in this video</a> by <a href="https://szymonkaliski.com">Szymon Kaliski</a>.</li><li><a href="https://www.subtext-lang.org">Subtext</a>, by Jonathan Edwards, is full of interesting ideas.</li><li><a href="https://natto.dev">Natto</a> by <a href="https://bypaulshen.com">Paul Shen</a> is another take on node/arrow systems.</li><li><a href="https://emilprogviz.com">This collection of videos</a> contains interesting ideas for visualizing programs and their execution.</li><li><a href="https://emacsconf.org/2021/talks/structural/">Tree-edit</a>, a structural editor that combines <a href="https://tree-sitter.github.io/tree-sitter/">Treesitter</a> and <a href="http://minikanren.org">miniKanren</a> to give the same sort of experience that Lispers have long taken for granted to programming languages with more complicated syntax.</li><li><a href="https://darklang.com">Darklang</a> has many features that I find admirable.</li><li><a href="https://en.wikipedia.org/wiki/JetBrains_MPS">JetBrains MPS</a> provides an environment for building tooling for programming languages.</li></ul><p>In this talk, I stayed away from artistic livecoding systems because many programmers can&#39;t see themselves in what artists are doing. However, I would be remiss not to show you these systems:</p><ul><li>Andrew Sorensen&#39;s <a href="https://extemporelang.github.io">Extempore</a> (<a href="https://www.youtube.com/watch?v=yY1FSsUV-8c">video</a>).</li><li><a href="https://sonic-pi.net">Sonic Pi</a>, by Sam Aaron. A Ruby dialect on an Erlang runtime for teaching programming through musical composition (and more).</li><li>Olivia Jack&#39;s <a href="https://cdm.link/2019/02/hydra-olivia-jack/">Hydra</a>, a collaborative environment for livecoding.</li><li><a href="https://100r.co/site/orca.html">Orca</a>, by Hundred Rabbits. A 2D programming language with a built-in clock for livecoding music. The rest of their projects are also worth your time!</li><li>I livecode most of my own artwork in Clojure and Scheme.</li></ul></div><p><span>00:42:01.91</span> I have some thank yous to do. First,</p><p><span>00:42:04.31</span> I&#39;d like to thank <a href="https://twitter.com/puredanger">Alex</a> for inviting me</p><p><span>00:42:07.25</span> to give this talk. I&#39;d like to thank Nextjournal</p><p><span>00:42:08.69</span> for sponsoring my work, including</p><p><span>00:42:10.91</span> the writing of this talk. And I would</p><p><span>00:42:13.25</span> like to thank all of you for watching!</p><p><span>00:42:15.41</span> Thank you very much!</p>
</div>
  </body>
</html>
