<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.xtof.info/MacMiniG4-the-best-classic-macintosh-for-retrogaming.html">Original</a>
    <h1>Mac Mini G4 – The best « classic » Macintosh for retro-gaming?</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>Well the title of this post promised you Bad Apple in vim only using search queries. So here’s Bad Apple in vim, but the only thing that’s changing is the search query:</p>
<div><video controls="" playsinline="" poster="/images/bad-apple-with-regex-in-vim/badapple-optimized-1500-small-firstframe.png" width="1510" height="932" preload="metadata" alt="The first several seconds of &#39;bad apple.&#39; The video is playing inside of vim at a low resolution. On the bottom of the screen search queries scroll by as the video plays"><p>Loading...</p></video><p>Unfortunately this is only 120x90; my screen isn&#39;t big enough to size up more</p></div>
<p>Let’s talk about how this works!</p>
<!-- -->
<h2 id="toc:wait-sorry-what-is-bad-apple">Wait, sorry, what is Bad Apple</h2>
<p><a href="https://knowyourmeme.com/memes/bad-apple">Bad Apple</a> is a visually compelling music video that folks enjoy embedding in surprising places. It’s a meme in the same way that running DOOM on a smartfridge is a meme.</p>
<p>I’ve wanted to run Bad Apple somewhere since I saw <a href="https://x.com/delatoid/status/1806130369269580081">this video</a> purporting to run it on One Million Checkboxes.</p>
<h2 id="toc:getting-the-frames">Getting the frames</h2>
<p>The first step here was pretty simple. I needed data for each frame of Bad Apple. <a href="https://github.com/Felixoofed">Felixoofed</a> had already done some of the work for me; I cloned <a href="https://github.com/Felixoofed/badapple-frames">their repo</a> which gave me the video along with a suggestion of an <code>ffmpeg</code> command to turn the video into ~6,500 PNGs representing each frame.</p>
<p>Then I wrote a little bit of Python code to turn each of those PNGs into a 2D array of 0s and 1s (where 1 represented a black pixel). The video was originally 480x360 - I shrunk it down to 120x90 after taking some measurements of my terminal and concluding that I couldn’t really go any bigger.</p>
<pre><code><span><span>from</span> PIL <span>import</span> Image
</span><span><span>import</span> numpy <span>as</span> np
</span><span>
</span><span><span>def</span> <span>process_image</span><span>(</span>path<span>,</span> target_width<span>=</span><span>120</span><span>,</span> target_height<span>=</span><span>90</span><span>)</span><span>:</span>
</span><span>    img <span>=</span> Image<span>.</span><span>open</span><span>(</span>path<span>)</span>
</span><span>    img <span>=</span> img<span>.</span>resize<span>(</span><span>(</span>target_width<span>,</span> target_height<span>)</span><span>,</span> Image<span>.</span>Resampling<span>.</span>LANCZOS<span>)</span>
</span><span>
</span><span>    <span>if</span> img<span>.</span>mode <span>!=</span> <span>&#34;L&#34;</span><span>:</span> img <span>=</span> img<span>.</span>convert<span>(</span><span>&#34;L&#34;</span><span>)</span>
</span><span>
</span><span>    pixels <span>=</span> np<span>.</span>array<span>(</span>img<span>)</span>
</span><span>    binary_pixels <span>=</span> <span>(</span>pixels <span>&lt;</span> <span>10</span><span>)</span><span>.</span>astype<span>(</span><span>int</span><span>)</span> 
</span><span>    <span>return</span> binary_pixels
</span><span>
</span><span><span>def</span> <span>text_preview</span><span>(</span>binary_pixels<span>)</span><span>:</span>
</span><span>    chars <span>=</span> <span>{</span><span>0</span><span>:</span> <span>&#34;.&#34;</span><span>,</span> <span>1</span><span>:</span> <span>&#34;#&#34;</span><span>}</span>
</span><span>
</span><span>    <span>return</span> <span>&#34;\n&#34;</span><span>.</span>join<span>(</span><span>&#34;&#34;</span><span>.</span>join<span>(</span>chars<span>[</span>px<span>]</span> <span>for</span> px <span>in</span> row<span>)</span> <span>for</span> row <span>in</span> binary_pixels<span>)</span>
</span></code></pre>
<p>I ran this against a couple of frames and printed out their <code>text_preview</code>s to confirm that they looked ok. They did!</p>
<h2 id="toc:drawing-in-vim">Drawing in vim</h2>
<p>So how do we draw something in vim? Well, to start I made a grid of text with a drawing embedded inside it. Here’s a grid that mostly has As, but if you search for B you see a little stick figure:</p>
<div><p><img alt="a vim window with a bunch of text. most of the text is the letter A, but there are some Bs. The Bs form a stick figure. The user has searched for &#39;B&#39; so the Bs are highlighted blue." loading="lazy" width="1370" height="920" decoding="async" data-nimg="1" src="https://www.xtof.info/images/bad-apple-with-regex-in-vim/grid-blue.png"/></p><p>hey little guy</p></div>
<p>So that kinda lets us create a drawing! But there are some problems. One is that the blue highlighting here (which I think is the default thing vim does?) isn’t super clear.</p>
<p>But vim highlighting is very configurable! We can tell it to highlight the foreground and background of each matched character with the same color. The invocation I use is <code>hi Search cterm=NONE ctermfg=grey ctermbg=grey</code> which gives us nice blocks instead:</p>
<div><p><img alt="a vim window with a bunch of text. most of the text is the letter A, but there is a stick figure that is drawn using monocolor rectangles" loading="lazy" width="1370" height="920" decoding="async" data-nimg="1" src="https://www.xtof.info/images/bad-apple-with-regex-in-vim/grid-blocks.png"/></p><p>much nicer</p></div>
<p>But there’s one more problem - we want square pixels! But right now each of our characters is more of a rectangle, because most fonts are taller than they are wide! I searched around and found <a href="https://strlen.com/square/">Square</a>, a font that is…square! It’s designed for roguelike games played in the terminal, and using it here gives us a very nice grid:</p>
<div><p><img alt="a vim window with a bunch of text. most of the text is the letter A, but there is a stick figure that is drawn using monocolor rectangles. The font is square" loading="lazy" width="2630" height="834" decoding="async" data-nimg="1" src="https://www.xtof.info/images/bad-apple-with-regex-in-vim/grid-square.png"/></p><p>all squared away</p></div>
<p>So that lets us create pictures by highlighting text. But how do we highlight the <em>right</em> text for each frame of Bad Apple?</p>
<h3 id="toc:drawing-arbitrary-rectangles">Drawing arbitrary rectangles</h3>
<p>I kicked around a bunch of vague ideas about file structure - maybe there was a way to analyze my frames, figure out which pixels were “hot,” and then generate a file that was optimized for regexs selecting those pixels?</p>
<p>But before going too far down this path I decided to read through vim’s docs on searching. I knew that vim’s search had all sorts of crazy features <a>1</a> and I wanted to know what tools I had available. And it turns out that vim already had exactly what I needed!</p>
<div data-is-footnote="true"><div><div><div><p><span>1</span></p><p>My favorites are <code>\zs</code> and <code>\ze</code>, which let you declare when a match starts or
ends. It’s basically a way to say “treat everything behind/ahead of me as a
lookahead/lookbehind” - it’s very ergonomic!</p></div></div></div></div>
<pre><code><span>				<span>/</span>\<span>%</span><span>l</span> <span>/</span>\<span>%</span><span>&gt;</span><span>l</span> <span>/</span>\<span>%</span><span>&lt;</span><span>l</span> E951 E1204 E1273
</span><span>\<span>%</span>23l	Matches <span>in</span> a specific line<span>.</span>
</span><span>\<span>%</span><span>&lt;</span>23l	Matches above a specific line <span>(</span>lower line <span>number</span><span>)</span><span>.</span>
</span><span>\<span>%</span><span>&gt;</span>23l	Matches below a specific line <span>(</span>higher line <span>number</span><span>)</span><span>.</span>
</span><span>\<span>%</span><span>.</span><span>l</span>	Matches at the cursor line<span>.</span>
</span><span>\<span>%</span><span>&lt;</span><span>.</span><span>l</span>	Matches above the cursor line<span>.</span>
</span><span>\<span>%</span><span>&gt;</span><span>.</span><span>l</span>	Matches below the cursor line<span>.</span>
</span></code></pre>
<p>vim searches can match on specific line numbers (and column numbers). And you can combine several of these searches together - for example <code>\%&gt;5c\%&lt;15c\%&gt;4l\%&lt;9l</code> matches the rectangle between columns 5 and 15 and between lines 4 and 9.</p>
<p>And better yet, you can OR <em>those</em> patterns together just like any other vim search - <code>\%&gt;5c\%&lt;15c\%&gt;4l\%&lt;9l\|\%&gt;12c\%&lt;25c\%&gt;10l\%&lt;15l</code> finds both our previous rectangle and the one between cols 12 and 25 and lines 10 and 15. So it’s easy to draw many rectangles to the screen with a single search.</p>
<div><p><img alt="A vim window with two highlighted squares. A vim search string is visible (the squares are selected by the search string). The search string is \%&gt;5c\%&lt;15c\%&gt;4l\%&lt;9l\|\%&gt;12c\%&lt;25c\%&gt;10l\%&lt;15l" loading="lazy" width="2630" height="770" decoding="async" data-nimg="1" src="https://www.xtof.info/images/bad-apple-with-regex-in-vim/square-drawing.png"/></p><p>two squares from one search string!</p></div>
<p>This transformed the problem - now the goal was to decompose each frame into a series of rectangles that we could search for!</p>
<h2 id="toc:frames-into-rectangles">Frames into rectangles</h2>
<p>Our grid was 90x120 so we had ~10,000 pixels. This meant that a super naive approach would potentially look for thousands of different rectangles and generate a search string tens of thousands of characters long. Some basic testing showed me that while vim’s search was fast, search strings that long would kill my framerate.</p>
<p>“Decompose this grid into the minimum number of rectangles required to fill it” seemed like the type of thing that would have a de-facto solution, so I looked for existing solutions. But I didn’t find much! There’s <a href="https://stackoverflow.com/questions/4304750/how-can-i-reduce-a-grid-of-equal-sized-squares-to-a-minimum-set-of-rectangles">a 14 year old stack overflow question</a> where the accepted answer is “it’s hard.”</p>
<p>So I wrote something naive. The approach I took was:</p>
<ul>
<li>Detect all runs of “1s” in the first row</li>
<li>Look at the next row, and find runs that overlap with the runs from the previous row</li>
<li>“Merge” those runs into a rectangle if the area of the merged rectangle is greater than the area of either row alone (remember, the runs may not overlap fully)</li>
<li>Keep going, making sure to merge new runs into old rectangles whenever possible</li>
</ul>
<p>The actual code is pretty long and I’m not sure it’s worth reading, but here it is if you’re curious:</p>
<details><summary><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg> <!-- -->The code, which I&#39;m not sure you really need to see</summary><pre><code><span>
</span><span><span>class</span> <span>Rect</span><span>:</span>
</span><span>    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> col_start<span>,</span> col_end<span>,</span> row_start<span>,</span> row_end<span>)</span><span>:</span>
</span><span>        self<span>.</span>row_start <span>=</span> row_start
</span><span>        self<span>.</span>row_end <span>=</span> row_end
</span><span>        self<span>.</span>col_start <span>=</span> col_start
</span><span>        self<span>.</span>col_end <span>=</span> col_end
</span><span>
</span><span>    <span>def</span> <span>height</span><span>(</span>self<span>)</span><span>:</span>
</span><span>        <span>return</span> self<span>.</span>row_end <span>-</span> self<span>.</span>row_start
</span><span>
</span><span>    <span>def</span> <span>width</span><span>(</span>self<span>)</span><span>:</span>
</span><span>        <span>return</span> self<span>.</span>col_end <span>-</span> self<span>.</span>col_start
</span><span>
</span><span>    <span>def</span> <span>area</span><span>(</span>self<span>)</span><span>:</span>
</span><span>        <span>return</span> self<span>.</span>height<span>(</span><span>)</span> <span>*</span> self<span>.</span>width<span>(</span><span>)</span>
</span><span>
</span><span>    <span>def</span> <span>to_vim_pattern</span><span>(</span>self<span>)</span><span>:</span>
</span><span>        
</span><span>        row_start <span>=</span> self<span>.</span>row_start
</span><span>        row_end <span>=</span> self<span>.</span>row_end <span>+</span> <span>1</span>
</span><span>        col_start <span>=</span> self<span>.</span>col_start
</span><span>        col_end <span>=</span> self<span>.</span>col_end <span>+</span> <span>1</span>
</span><span>        <span>return</span> <span><span>fr&#34;\%&gt;</span><span><span>{</span>col_start<span>}</span></span><span>c\%&lt;</span><span><span>{</span>col_end<span>}</span></span><span>c\%&gt;</span><span><span>{</span>row_start<span>}</span></span><span>l\%&lt;</span><span><span>{</span>row_end<span>}</span></span><span>l&#34;</span></span>
</span><span>
</span><span>    <span>def</span> <span>__repr__</span><span>(</span>self<span>)</span><span>:</span>
</span><span>        width <span>=</span> self<span>.</span>width<span>(</span><span>)</span>
</span><span>        height <span>=</span> self<span>.</span>height<span>(</span><span>)</span>
</span><span>        <span>return</span> <span><span>f&#34;R: (</span><span><span>{</span>width<span>}</span></span><span>x</span><span><span>{</span>height<span>}</span></span><span>) </span><span><span>{</span>self<span>.</span>row_start<span>}</span></span><span>:</span><span><span>{</span>self<span>.</span>row_end<span>}</span></span><span>, </span><span><span>{</span>self<span>.</span>col_start<span>}</span></span><span>:</span><span><span>{</span>self<span>.</span>col_end<span>}</span></span><span>&#34;</span></span>
</span><span>
</span><span>    <span>def</span> <span>test_merge_horizontal</span><span>(</span>self<span>,</span> run_start<span>,</span> run_end<span>,</span> run_row<span>)</span><span>:</span>
</span><span>        <span>if</span> run_end <span>&lt;=</span> self<span>.</span>col_start<span>:</span> <span>return</span> <span>[</span><span>False</span><span>,</span> <span>None</span><span>,</span> <span>None</span><span>,</span> <span>None</span><span>]</span>
</span><span>        <span>if</span> run_start <span>&gt;=</span> self<span>.</span>col_end<span>:</span> <span>return</span> <span>[</span><span>False</span><span>,</span> <span>None</span><span>,</span> <span>None</span><span>,</span> <span>None</span><span>]</span>
</span><span>
</span><span>        overlap_start <span>=</span> <span>max</span><span>(</span>run_start<span>,</span> self<span>.</span>col_start<span>)</span>
</span><span>        overlap_end <span>=</span> <span>min</span><span>(</span>run_end<span>,</span> self<span>.</span>col_end<span>)</span>
</span><span>        overlap_rect <span>=</span> Rect<span>(</span>overlap_start<span>,</span> overlap_end<span>,</span> self<span>.</span>row_start<span>,</span> run_row<span>+</span><span>1</span><span>)</span>
</span><span>
</span><span>        
</span><span>        top_rects <span>=</span> <span>[</span><span>]</span>
</span><span>        <span>if</span> overlap_start <span>&gt;</span> self<span>.</span>col_start<span>:</span>
</span><span>            top_rects<span>.</span>append<span>(</span>Rect<span>(</span>self<span>.</span>col_start<span>,</span> overlap_start<span>,</span> self<span>.</span>row_start<span>,</span> self<span>.</span>row_end<span>)</span><span>)</span>
</span><span>        <span>if</span> overlap_end <span>&lt;</span> self<span>.</span>col_end<span>:</span>
</span><span>            top_rects<span>.</span>append<span>(</span>Rect<span>(</span>overlap_end<span>,</span> self<span>.</span>col_end<span>,</span> self<span>.</span>row_start<span>,</span> self<span>.</span>row_end<span>)</span><span>)</span>
</span><span>
</span><span>        
</span><span>        
</span><span>        bot_rects <span>=</span> <span>[</span><span>]</span>
</span><span>        <span>if</span> overlap_start <span>&gt;</span> run_start<span>:</span>
</span><span>            bot_rects<span>.</span>append<span>(</span>Rect<span>(</span>run_start<span>,</span> overlap_start<span>,</span> run_row<span>,</span> run_row<span>+</span><span>1</span><span>)</span><span>)</span>
</span><span>        <span>if</span> overlap_end <span>&lt;</span> run_end<span>:</span>
</span><span>            bot_rects<span>.</span>append<span>(</span>Rect<span>(</span>overlap_end<span>,</span> run_end<span>,</span> run_row<span>,</span> run_row<span>+</span><span>1</span><span>)</span><span>)</span>
</span><span>
</span><span>        <span>return</span> <span>[</span><span>True</span><span>,</span> overlap_rect<span>,</span> top_rects<span>,</span> bot_rects<span>]</span>
</span><span>    
</span><span><span>def</span> <span>find_runs</span><span>(</span>row<span>)</span><span>:</span>
</span><span>    runs <span>=</span> <span>[</span><span>]</span>
</span><span>    start <span>=</span> <span>None</span>
</span><span>
</span><span>    <span>for</span> i<span>,</span> val <span>in</span> <span>enumerate</span><span>(</span>row<span>)</span><span>:</span>
</span><span>        <span>if</span> val <span>==</span> <span>1</span> <span>and</span> start <span>is</span> <span>None</span><span>:</span>
</span><span>            start <span>=</span> i
</span><span>        <span>elif</span> val <span>==</span> <span>0</span> <span>and</span> start <span>is</span> <span>not</span> <span>None</span><span>:</span>
</span><span>            runs<span>.</span>append<span>(</span><span>(</span>start<span>,</span> i<span>)</span><span>)</span>
</span><span>            start <span>=</span> <span>None</span>
</span><span>
</span><span>    <span>if</span> start <span>is</span> <span>not</span> <span>None</span><span>:</span>
</span><span>        runs<span>.</span>append<span>(</span><span>(</span>start<span>,</span> <span>len</span><span>(</span>row<span>)</span><span>)</span><span>)</span>
</span><span>    <span>return</span> runs
</span><span>
</span><span><span>def</span> <span>try_merge_with_prev_row</span><span>(</span>mergeable_rects<span>,</span> run_start<span>,</span> run_end<span>,</span> run_row<span>)</span><span>:</span>
</span><span>    candidate_merges <span>=</span> <span>[</span><span>]</span>
</span><span>    <span>for</span> i<span>,</span> rect <span>in</span> <span>enumerate</span><span>(</span>mergeable_rects<span>)</span><span>:</span>
</span><span>        merge_result <span>=</span> rect<span>.</span>test_merge_horizontal<span>(</span>run_start<span>,</span> run_end<span>,</span> run_row<span>)</span>
</span><span>        <span>if</span> merge_result<span>[</span><span>0</span><span>]</span><span>:</span> candidate_merges<span>.</span>append<span>(</span><span>(</span>merge_result<span>,</span> i<span>)</span><span>)</span>
</span><span>
</span><span>    best <span>=</span> <span>None</span>
</span><span>    best_idx <span>=</span> <span>None</span>
</span><span>    best_merge_result <span>=</span> <span>None</span>
</span><span>    run_length <span>=</span> run_end <span>-</span> run_start
</span><span>
</span><span>    <span>for</span> <span>(</span>candidate<span>,</span> candidate_idx<span>)</span> <span>in</span> candidate_merges<span>:</span>
</span><span>        _<span>,</span> overlap_rect<span>,</span> top_rects<span>,</span> bot_rects <span>=</span> candidate
</span><span>        overlap_area <span>=</span> overlap_rect<span>.</span>area<span>(</span><span>)</span>
</span><span>        <span>if</span> best <span>is</span> <span>None</span> <span>or</span> overlap_area <span>&gt;</span> best<span>:</span>
</span><span>            best <span>=</span> overlap_area
</span><span>            best_idx <span>=</span> candidate_idx
</span><span>            best_merge_result <span>=</span> <span>(</span>overlap_rect<span>,</span> top_rects<span>,</span> bot_rects<span>)</span>
</span><span>
</span><span>    <span>if</span> best <span>is</span> <span>None</span><span>:</span> <span>return</span> <span>(</span><span>None</span><span>,</span> <span>None</span><span>)</span>
</span><span>    <span>elif</span> best <span>&gt;</span> run_length<span>:</span> <span>return</span> <span>(</span>best_idx<span>,</span> best_merge_result<span>)</span>
</span><span>    <span>else</span><span>:</span> <span>return</span> <span>(</span><span>None</span><span>,</span> <span>None</span><span>)</span>
</span><span>
</span><span><span>def</span> <span>to_horizontal_merge_rect_representation</span><span>(</span>binary_pixels<span>)</span><span>:</span>
</span><span>    completed_rects <span>=</span> <span>[</span><span>]</span>
</span><span>    mergeable_rects <span>=</span> <span>[</span><span>]</span>
</span><span>
</span><span>    <span>for</span> row_idx<span>,</span> row <span>in</span> <span>enumerate</span><span>(</span>binary_pixels<span>)</span><span>:</span>
</span><span>        next_mergeable_rects <span>=</span> <span>[</span><span>]</span>
</span><span>        runs <span>=</span> find_runs<span>(</span>row<span>)</span>
</span><span>
</span><span>        <span>for</span> <span>(</span>run_start<span>,</span> run_end<span>)</span> <span>in</span> runs<span>:</span>
</span><span>            best_merge_idx<span>,</span> best_merge_result <span>=</span> try_merge_with_prev_row<span>(</span>mergeable_rects<span>,</span> run_start<span>,</span> run_end<span>,</span> row_idx<span>)</span>
</span><span>            <span>if</span> best_merge_idx <span>is</span> <span>None</span><span>:</span>
</span><span>                r <span>=</span> Rect<span>(</span>run_start<span>,</span> run_end<span>,</span> row_idx<span>,</span> row_idx<span>+</span><span>1</span><span>)</span>
</span><span>                next_mergeable_rects<span>.</span>append<span>(</span>r<span>)</span>
</span><span>            <span>else</span><span>:</span>
</span><span>                mergeable_rects<span>.</span>pop<span>(</span>best_merge_idx<span>)</span>
</span><span>                overlap_rect<span>,</span> top_rects<span>,</span> bot_rects <span>=</span> best_merge_result
</span><span>                mergeable_rects<span>.</span>extend<span>(</span>top_rects<span>)</span>
</span><span>                next_mergeable_rects<span>.</span>append<span>(</span>overlap_rect<span>)</span>
</span><span>                next_mergeable_rects<span>.</span>extend<span>(</span>bot_rects<span>)</span>
</span><span>
</span><span>        completed_rects<span>.</span>extend<span>(</span>mergeable_rects<span>)</span>
</span><span>        mergeable_rects <span>=</span> next_mergeable_rects
</span><span>
</span><span>    completed_rects<span>.</span>extend<span>(</span>mergeable_rects<span>)</span>
</span><span>    <span>return</span> <span>r&#34;\|&#34;</span><span>.</span>join<span>(</span>rect<span>.</span>to_vim_pattern<span>(</span><span>)</span> <span>for</span> rect <span>in</span> completed_rects<span>)</span>
</span><span>
</span></code></pre></details>
<p>So probably don’t read that. But the point is that it’s far from optimal <a>2</a>. For example, the code never looks more than one row ahead, so it discards merges that are a bad idea <em>now</em> but would work out well based on following rows.</p>
<div data-is-footnote="true"><div><div><div><p><span>2</span></p><p>it <em>was</em> really fun to write though</p></div></div></div></div>
<p>But I knew the code was naive when I wrote it - I just wanted to get something vaguely reasonable down to see how it’d perform. I generated search queries for each frame and wrote them to a file. And then I set up a simple vim animation test harness <a>3</a>, and found that the performance was fine! Well, in some cases.</p>
<div data-is-footnote="true"><div><div><div><p><span>3</span></p><p>we’ll talk about how this works in a second</p></div></div></div></div>
<h3 id="toc:pathological-cases">Pathological cases</h3>
<p>My naive algorithm worked really well in some cases and totally fell over in others. Many of the search strings were 500 - 2000 characters long, but the search string that it generates for this image is over 10,000 characters <a>4</a>!</p>
<div data-is-footnote="true"><div><div><div><p><span>4</span></p><p>Length of a search string is not a perfect proxy for performance, but I think it’s pretty good. Our search strings are just a bunch of patterns (of similar length) OR’d together. The longer a search string, the more patterns. And search time should scale with the number of patterns, since vim has to check each one before deciding that a search doesn’t match. </p></div></div></div></div>
<div><p><img alt="A vim window. A frame from bad apple is visible. A woman stands on a boat holding a scythe, visible from the side." loading="lazy" width="1942" height="1462" decoding="async" data-nimg="1" src="https://www.xtof.info/images/bad-apple-with-regex-in-vim/pathological.png"/></p><p>cool image tbh</p></div>
<p>These long search strings dramatically reduced frames per second - we went from around ~40 FPS to the single digits.</p>
<p>I hunted for optimizations <a>5</a>. I came up with a bunch of ideas for tweaks, but wasn’t confident that any of them would help much with the bad cases. And I didn’t have the time to find a good general-purpose algorithm: I was working on this the night before weekly presentations at the <a href="https://www.recurse.com/">Recurse Center</a> and I wanted to present it the next day!</p>
<div data-is-footnote="true"><div><div><div><p><span>5</span></p><p>My favorite rabbit hole was trying to improve <em>vim’s</em> search performance instead of my regexs. My setup for playing the video had multiple buffers open and the searches were ran over each buffer. I thought if I could prevent that (or prevent <em>highlighting</em> in other buffers) that might help. But I couldn’t get that to work.</p></div></div></div></div>
<p>So I pulled out one of my favorite tricks <a>6</a> - instead of trying to write one great algorithm, write several mediocre ones and use them all!</p>

<p>I wrote two more naive solutions:</p>
<ul>
<li>A version of my “build rects top to bottom” algorithm that went left to right instead</li>
<li>A simple <a href="https://en.wikipedia.org/wiki/Run-length_encoding">RLE</a> that only looked at individual rows</li>
</ul>
<p>And then I updated my code to run each frame through all three algorithms and pick the shortest search pattern generated!</p>
<p>This worked great. While each of these algorithms had pathological cases, they had <em>very different</em> pathological cases. So in (almost) all cases, at least one of them generated a search pattern that was good enough.</p>
<p>RLE ended up most often generating the “best” solution - although when it’s bad it’s really bad (which is why I avoided using it to start). And my original approach was used the least often! oops.</p>
<pre><code><span>
</span><span>original approach <span>(</span>top to bottom merging<span>)</span> - <span>1110</span>
</span><span>left to right merging                     - <span>2239</span>
</span><span>single-row RLE                            - <span>3300</span>
</span></code></pre>
<h2 id="toc:wait-so-how-do-you-actually-run-this-inside-vim">Wait, so how do you actually run this inside vim</h2>
<p>Yes, right, that’s a good question.</p>
<p>Here’s an image of the vim setup:</p>
<div><p><img alt="vim. There are 2 rows of windows - the first row contains a large window with an image from Bad Apple, flanked by two smaller empty buffers. The bottom row contains a single wide window with a lot of unreadable small text." loading="lazy" width="3020" height="1720" decoding="async" data-nimg="1" src="https://www.xtof.info/images/bad-apple-with-regex-in-vim/vimsetup.png"/></p><p>it&#39;s all clear now right?</p></div>
<p>The center window on the top is where we play the video. It’s a file that contains 90 lines of 120 spaces (remember that our images are 120x90); since we’re matching on rows and columns it doesn’t need to have any content. To its left and right are some empty buffers that are sized to center the image.</p>
<p>The bottom window is our list of search patterns! All ~6,500 of them.</p>
<p>To play the video we use a vim macro. If you haven’t seen vim macros, they’re a way to record a series of arbitrary keystrokes to be replayed later. They’re extremely powerful - since you do ~everything in vim via the keyboard, you can trivially record and replay <em>any</em> action. And if you set up your macro right (so that it ends with the cursor in the right spot for the next iteration) you can tell vim to run the macro many times in a row!</p>
<h3 id="toc:the-macro">The macro</h3>
<p>The macro is <code>&#34;ay$:let @/=@a^M+</code>. That is:</p>
<ul>
<li><code>&#34;a</code> Operate over register a</li>
<li><code>y$</code> Yank until the end of the line</li>
</ul>
<p><em>Vim has “named” registers that can hold text - ‘a’ now contains the current line</em></p>
<ul>
<li><code>:</code> Enter command mode</li>
<li><code>let @/=@a</code> set the contents of register <code>/</code> to the contents of register <code>a</code></li>
<li><code>^M</code> execute the command (<code>^M</code> represents the enter key)</li>
</ul>
<p><em>To reference a register in command mode you use <code>@</code> followed by the register name. Vim has special registers - the <code>/</code> register represents the current search. At this point vim is searching for the query that is on the current line</em></p>
<ul>
<li><code>+</code> move to the start of the next line</li>
</ul>
<p><em>This is what I meant by “if you set up your macro right you can make it replayable” - we’re prepared to execute our macro again because the cursor is now on the start of the next line!</em></p>
<p>This might look like nonsense to you - I’m pretty comfortable with macros because of the years that I’ve spent <a href="https://www.vimgolf.com/">vim golfing</a>. But it works!</p>
<p>The most interesting optimization is <code>let @/=@a</code> - an alternative is to do something like <code>/^Ra^M</code> (begin a search, pastes the output of register <code>a</code>, enter), but this is a problem because it requires directly pasting a query that is potentially thousands of characters long. This causes the search window to expand to fit the query, which creates a flickering effect and reduces framerate.</p>
<p>But now we can run <code>1500@q</code> (assuming we recorded the macro into register <code>q</code>) to play the macro 1500 times - meaning that we’ll run through 1500 frames as quickly as we can.</p>
<p>And that gives us this!</p>

<h2 id="toc:wrapping-up">Wrapping up</h2>
<p>This was really fun! I built this in a single day, but if I wanted to spend more time on it I might make a few tweaks:</p>
<ul>
<li>I think it’d be more magical if I had gone the “create a well-structured file that I can craft traditional regexs over” route instead of using vim’s line/col search feature. You might (reasonably) quibble that these aren’t real regexs!</li>
<li>I make no effort to keep a <em>stable</em> framerate, and the framerate definitely fluctuates a bit over the course of the video.</li>
</ul>
<p>But this was good enough for my purposes. And I think it’s neat that I’ve built most of a general-purpose solution for playing a video inside of vim using search queries. Someone suggested that I record a video of me running Bad Apple in vim and play <em>that</em> video in vim. So I guess I’ll get on that.</p>
<p>Beyond that, I made this in my first week of a new batch at <a href="https://recurse.com">The Recurse Center</a>, a place that offers something like a writers retreat but for programming. I presented it to folks there and got a lovely response. I really love Recurse, and if you love nonsense like this I bet you’d like it too. Consider <a href="https://recurse.com/apply">applying!</a>.</p>
<p>Finally, the code is super messy but if you want to poke around <a href="https://github.com/nolenroyalty/vim-badapple">you can see it here</a>.</p>
<p>And that’s all I’ve got. As always, I’ll be back with more nonsense soon.</p></article></div>
  </body>
</html>
