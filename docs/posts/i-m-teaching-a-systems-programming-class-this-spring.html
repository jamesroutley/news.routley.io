<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://iafisher.com/blog/2025/01/systems-programming-spring-2025">Original</a>
    <h1>I&#39;m teaching a systems programming class this spring</h1>
    
    <div id="readability-page-1" class="page"><div>
<h2 id="everything_on_the_main_thread_all_at_once">Everything, On the Main Thread, All at Once</h2>
<p>Arrays are in every web developer’s toolbox, and there are a dozen ways to iterate over them. Choose wrong, though, and all of that processing time will happen synchronously in one long, blocking task. The thing is, the most natural ways <em>are</em> the wrong ways. A simple <code>for..of</code> loop that processes each array item is synchronous by default, while Array methods like <code>forEach</code> and <code>map</code> can ONLY run synchronously. You almost certainly have a loop like this waiting to be optimized right now.</p>
<p>What’s the problem with long tasks, anyway? Every long task is a liability for an unresponsive user experience. If the user interacts with the page at just the right (or wrong) time, the browser won’t be able to handle that interaction until the task completes, which contributes to its input delay and slow Interaction to Next Paint (INP) performance. You can think of them like potholes on a road, forcing drivers to dodge them or risk damaging their cars—an unpleasant experience either way. Likewise, long tasks create unresponsive UIs, which can frustrate users and impact business metrics. They’re especially problematic when they’re not just coinciding with a user interaction, but in response to one. It’s no longer a matter of poor timing, because <em>every</em> click necessarily becomes a slow click.</p>
<p>Synchronously processing large arrays is one of the easiest ways to introduce long tasks. Even if the unit of work performed on each item in the array is reasonably fast, that time scales up linearly with the number of items. For example, if a CPU can complete one unit of work in 0.25 ms, and there are 1,000 units, the total processing time will be 250 ms, creating a long task and exceeding the threshold for a fast and responsive interaction. The key to breaking up the long task is to use the repetition to your advantage: each iteration of the loop is an opportunity to interrupt the processing and update the UI as needed.</p>
<h2 id="optimizing_interaction_responsiveness">Optimizing interaction responsiveness</h2>
<p>Interrupting a task to allow the event loop to continue turning is known as yielding. There are a few ways to yield, with the classic approach being <code>setTimeout</code> with a delay of 0 ms, or the more modern alternative: <code>scheduler.yield</code>. It’s not currently supported in all browsers, so production-ready use cases will need a polyfill or fall back to <code>setTimeout</code>. In both cases, the trick to making the loop asynchronous is to use async/await. But there’s a catch.</p>
<p>If you’re using an Array method like <code>forEach</code> or <code>map</code>, you’ll quickly realize that this doesn’t work:</p>
<pre>function handleClick() {
  items.forEach(async (item) =&gt; {
    await scheduler.yield();
    process(item);
  });
}
</pre>
<p><img decoding="async" title="" src="http://iafisher.com/images/2024/rick/image9.png" alt=""/></p>
<p><code>forEach</code> doesn’t care if your callback function is asynchronous, it will plow through every item in the array without awaiting the yield. And it doesn’t matter which approach you use <code>scheduler.yield</code> or <code>setTimeout</code>. Apparently, this trips up a lot of developers, with <a href="https://stackoverflow.com/q/37576685/1022333">this StackOverflow question</a> having been viewed 2.4 million times since it was asked in 2016. The solution is in the top answer: switch to using a <code>for..of</code> loop instead.</p>
<pre>async function handleClick() {
  for (const item of items) {
    await scheduler.yield();
    process(item);
  }
}
</pre>
<p><img decoding="async" title="" src="http://iafisher.com/images/2024/rick/image3.png" alt=""/></p>
<p>Instead of a monolithic long task blocking the click handler, now we’ve spread the work out into smaller tasks, responding to the interaction instantly. Problem solved, right?</p>
<p>Before we get into the major problem with this approach, you might have noticed the <a href="https://stackoverflow.com/a/49499491/1022333">third most upvoted answer</a> on that StackOverflow question, which recommends using the <code>reduce</code> method. In case you were tempted to cling to your functional programming tendencies and use <code>reduce</code> to break up the long task, think again.</p>
<pre>function handleClick() {
  items.reduce(async (promise, item) =&gt; {
    await promise;
    await scheduler.yield();
    process(item);
  }, Promise.resolve());
}
</pre>
<p><img decoding="async" title="" src="http://iafisher.com/images/2024/rick/image4.png" alt=""/></p>
<p>This approach passes a promise along from one iteration to the next, which we can await before processing the next item. However, the issue with this is that <code>reduce</code> still plows through the entire array, synchronously queuing up each microtask. It’s not until the promises are fulfilled that it starts processing the items. In other words, even though the actual processing happens asynchronously, the amount of overhead is still enough to make the click handler slow.</p>
<p>Yielding within a <code>for..of</code> loop seems like the best way to achieve responsive interactions, but the problem is that we’re yielding on EVERY iteration of the loop. Let’s see what happens in browsers that don’t support <code>scheduler.yield</code>:</p>
<pre>async function handleClick() {
  for (const item of items) {
    await Promise(resolve =&gt; setTimeout(resolve, 0));
    process(item);
  }
}
</pre>
<p><img decoding="async" title="" src="http://iafisher.com/images/2024/rick/image1.png" alt=""/></p>
<p>With <code>setTimeout</code>, the job takes over 2 minutes to complete! Compare that with <code>scheduler.yield</code>, which completes in about 1 second. The huge disparity comes down to the fact that these are <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout#reasons_for_delays_longer_than_specified">nested timeouts</a>. Unlike tasks deferred with <code>scheduler.yield</code>, browsers introduce a 4 ms gap between nested timeouts. But that’s not to say that using <code>scheduler.yield</code> on every iteration comes without a cost. Both approaches introduce some overhead, which can be mitigated with batching.</p>
<h2 id="optimizing_total_processing_time">Optimizing total processing time</h2>
<p>Batching is processing multiple iterations of the loop before yielding. The interesting problem is knowing when to yield. Let’s say you yield after processing every 100 items in the array. Did you solve the long task problem? Well, that depends on the CPU speed and how much time the average item takes to process, and both of those factors will vary depending on the client’s machine.</p>
<p>Rather than batching by number of items, a much better approach would be to batch items by the time it takes to process them. That way you can set a reasonable batch duration, say 50 ms, and yield only when it’s been at least that long since the last yield.</p>
<pre>const BATCH_DURATION = 50;
let timeOfLastYield = performance.now();

function shouldYield() {
  const now = performance.now();
  if (now - timeOfLastYield &gt; BATCH_DURATION) {
    timeOfLastYield = now;
    return true;
  }
  return false;
}

async function handleClick() {
  for (const item of items) {
    if (shouldYield()) {
      await scheduler.yield();
    }
    process(item);
  }
}
</pre>
<p><img fetchpriority="high" decoding="async" src="https://calendar.perfplanet.com/wp-content/uploads/2024/12/image9-1024x288.png" alt="" width="1024" height="288" srcset="https://calendar.perfplanet.com/wp-content/uploads/2024/12/image9-1024x288.png 1024w, https://calendar.perfplanet.com/wp-content/uploads/2024/12/image9-300x84.png 300w, https://calendar.perfplanet.com/wp-content/uploads/2024/12/image9-768x216.png 768w, https://calendar.perfplanet.com/wp-content/uploads/2024/12/image9-1536x432.png 1536w, https://calendar.perfplanet.com/wp-content/uploads/2024/12/image9.png 1892w" sizes="(max-width: 1024px) 100vw, 1024px"/></p>
<p>And here are the results with <code>setTimeout</code>:</p>
<p><img decoding="async" title="" src="http://iafisher.com/images/2024/rick/image5.png" alt=""/></p>
<p>The choice of batch duration is a tradeoff between minimizing the amount of time a user would spend waiting if they interacted with the page during the batch processing and the total time to process everything in the array. If you chunk up the work into 100 ms batches, that’s fewer interruptions and faster throughput, but at worst that’s also 100 ms of possible input delay, which is already half the budget for a fast interaction. On the other hand, with 10 ms batches, the worst case input delay is almost negligible, but more interruptions and slower throughput.</p>
<p>Your primary goal should be to unblock the interaction so that it feels responsive. That could just mean yielding so that you can update the UI with the first few items, or kicking off a loading animation. How often you yield during the rest of the processing time will depend on what your second priority is. Maybe nothing can be shown to the user until the entire array is processed, so your secondary goal should be to finish as quickly as possible. In that case you’ll want to go with a higher batch duration. Or maybe it’s ok to do the work in the background, but the UI should remain as smooth and responsive as possible. That lends itself to a smaller batch duration. When in doubt, 50 ms can be a good compromise, but it’s always a good idea to profile different approaches and pick what works best for your app.</p>
<p>We could stop there, but there’s one more thing that you might want to consider: frame rate. If you look closely at the screenshots above, you’ll notice thin green markers roughly corresponding to the paint cycle. These are custom timings using <code>performance.mark</code> to show when a <code>requestAnimationFrame</code> callback runs. There’s a curious difference in the frame rates of <code>scheduler.yield</code> and <code>setTimeout</code>.</p>
<h2 id="optimizing_smoothness">Optimizing smoothness</h2>
<p>To reiterate, if the work needs to be completed as quickly as possible, you should minimize the number of yields. But there are plenty of instances where it’s more important to provide visual feedback to the user that something is happening, like a progress indicator. Even if you’re not showing any progress to the user, you might still want to keep the frame rate reasonably fast to avoid janky animations or scrolling behavior. That’s where the preferential priority of <code>scheduler.yield</code> starts getting in the way.</p>
<p><img decoding="async" title="" src="http://iafisher.com/images/2024/rick/image6.png" alt=""/></p>
<p>Surprisingly, for batch durations under 100 ms, the frame rate is relatively flat around 10 FPS. However, <code>setTimeout</code> follows the expected curve, where more frames are painted as the batch duration decreases, approaching 60 FPS. Tasks scheduled with <code>scheduler.yield</code> are given preferential treatment, so even if you don’t do any batching at all, the browser will prioritize it over the next paint—but only up to a point.</p>
<p><img decoding="async" title="" src="http://iafisher.com/images/2024/rick/image2.png" alt=""/></p>
<p>With no batching, the average time between frames is 120 ms, far from the 16 ms you get with tasks scheduled with <code>setTimeout</code>. This means your frame rate will be a lame 8 FPS. If you’re cool with that, you can skip the rest of this section. But I know there are some people who can’t stand the thought of a laggy UI, so here are some tips.</p>
<pre>const BATCH_DURATION = 1000 / 30; // 30 FPS
let timeOfLastYield = performance.now();

function shouldYield() {
  const now = performance.now();
  if (now - timeOfLastYield &gt; BATCH_DURATION) {
    timeOfLastYield = now;
    return true;
  }
  return false;
}

async function handleClick() {
  for (const item of items) {
    if (shouldYield()) {
      await new Promise(requestAnimationFrame);
      await scheduler.yield();
    }
    process(item);
  }
}
</pre>
<p><img decoding="async" title="" src="http://iafisher.com/images/2024/rick/image7.png" alt=""/></p>
<p>First, change the batch duration to align with your desired frame rate. When it’s time to yield, before calling <code>scheduler.yield</code>, await a promise that resolves in a <code>requestAnimationFrame</code> callback. This effectively prevents any more work from happening until a frame is painted, ensuring a much smoother UI.</p>
<p>One gotcha is that the rAF callback won’t be fired as long as the tab is in the background. We can make a few adjustments to handle this edge case.</p>
<pre>const BATCH_DURATION = 1000 / 30; // 30 FPS
let timeOfLastYield = performance.now();

function shouldYield() {
  const now = performance.now();
  if (now - timeOfLastYield &gt; <span>(document.hidden ? </span><span>500</span><span> : BATCH_DURATION)</span>) {
    timeOfLastYield = now;
    return true;
  }
  return false;
}

async function handleClick() {
  for (const item of items) {
    if (shouldYield()) {
      if (document.hidden) {
        await new Promise(resolve =&gt; setTimeout(resolve, 1));
        timeOfLastYield = performance.now();
      } else {
        await Promise.race([
          new Promise(resolve =&gt; {
            timeoutId = setTimeout(() =&gt; {
              timeOfLastYield = performance.now();
              resolve();
            }, 100)
          }),
          new Promise(resolve =&gt; {
            requestAnimationFrame(() =&gt; {
              clearTimeout(timeoutId);
              resolve();
            });
          })
        ]);
        await scheduler.yield();
      }
    }
    process(item);
  }
}
</pre>
<p><img decoding="async" src="https://calendar.perfplanet.com/wp-content/uploads/2024/12/image10-1024x300.png" alt="" width="1024" height="300" srcset="https://calendar.perfplanet.com/wp-content/uploads/2024/12/image10-1024x300.png 1024w, https://calendar.perfplanet.com/wp-content/uploads/2024/12/image10-300x88.png 300w, https://calendar.perfplanet.com/wp-content/uploads/2024/12/image10-768x225.png 768w, https://calendar.perfplanet.com/wp-content/uploads/2024/12/image10-1536x450.png 1536w, https://calendar.perfplanet.com/wp-content/uploads/2024/12/image10.png 1768w" sizes="(max-width: 1024px) 100vw, 1024px"/></p>
<p>The first change is to the <code>shouldYield</code> function, which now checks the page visibility. If the document is hidden, we can afford to yield in larger batches of 500 ms. Even though there is no user to experience a slow interaction, this still introduces a long task that could block the page from becoming visible if the user returns before the work is completed. <code>document.hidden</code> will continue to be true until the visibilitychange event can be handled, so we still need to yield periodically.</p>
<p>The second change is to the way we yield when the document is visible. We need to make sure that we’re not dependent on the rAF callback, so we can race it against a 100 ms timeout, borrowing from Vercel’s <a href="https://vercel.com/blog/demystifying-inp-new-tools-and-actionable-insights#the-implementation"><code>await-interaction-response</code></a> approach. The 100 ms timeout will be throttled to 1000 ms while the tab is backgrounded, but after that, the timeout will fire and work can resume. Resetting the <code>timeOfLastYield</code> is good so that the first backgrounded batch can run for the full 500 ms. And even though we’re racing the promises, the timeout’s callback will fire anyway, so it’s helpful to clear it during the rAF.</p>
<p>The final change is to the way we yield when the document is hidden. We want the visibilitychange event to fire, but <code>scheduler.yield</code> will always preempt it, delaying the page from becoming visible until the work is completed. That might be worth more investigation because it feels like a bug, but we can work around it by switching to a timeout-based approach. As long as the document is hidden, work will be done in 500 ms batches with an additional 500 ms delay between each batch, adding up to the 1000 ms delay for throttled timeouts. That way, if the user returns before the work is completed, the visibility state will be updated and the regular batching logic will kick back in.</p>
<p>If all of this feels overly complicated, that’s probably because it is. If your application can withstand pausing array iteration while the tab is in the background, then you should skip this last part for the sake of simplicity. In any case, this was a fun exercise in pushing the limits of yielding.</p>
<h2 id="try_it_out">Try it out</h2>
<p>If you’d like to try out the different yielding strategies, you can use <a href="https://loop-yields.glitch.me/">this demo</a>. That’s also what I used to make the screenshots in this post.</p>
<p>Hopefully this was a useful overview of the “yield in a loop” problem and how I’d go about solving it. Feel free to let me know if I got something wrong, or if you know of a better way I’d love to hear about it. Good luck out there!</p>
</div></div>
  </body>
</html>
