<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ReeceGoding/Frustration-One-Year-With-R">Original</a>
    <h1>One Year with R</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Reece Goding</p>
<ul dir="auto">
<li><a href="#1-introduction">1 Introduction</a>
<ul dir="auto">
<li><a href="#11-length">1.1 Length</a></li>
<li><a href="#12-experience">1.2 Experience</a></li>
<li><a href="#13-ignorance">1.3 Ignorance</a></li>
<li><a href="#14-assumed-knowledge">1.4 Assumed Knowledge</a></li>
<li><a href="#15-disclaimer">1.5 Disclaimer</a></li>
</ul>
</li>
<li><a href="#2-general-feelings">2 General Feelings</a></li>
<li><a href="#3-what-r-does-right">3 What R Does Right</a>
<ul dir="auto">
<li><a href="#31-mathematics-and-statistics">3.1 Mathematics and Statistics</a></li>
<li><a href="#32-names-and-data-frames">3.2 Names and Data Frames</a></li>
<li><a href="#33-outstanding-packages">3.3 Outstanding Packages</a></li>
<li><a href="#34-vectorization">3.4 Vectorization</a></li>
<li><a href="#35-functional-programming">3.5 Functional Programming</a>
<ul dir="auto">
<li><a href="#351-first-class-functions">3.5.1 First-class Functions</a></li>
<li><a href="#352-first-class-environments">3.5.2 First-class
Environments</a></li>
<li><a href="#353-generic-functions">3.5.3 Generic Functions</a></li>
</ul>
</li>
<li><a href="#36-syntax">3.6 Syntax</a></li>
<li><a href="#37-miscellaneous-positives">3.7 Miscellaneous Positives</a></li>
</ul>
</li>
<li><a href="#4-what-r-does-wrong">4 What R Does Wrong</a>
<ul dir="auto">
<li><a href="#41-lists">4.1 Lists</a></li>
<li><a href="#42-strings">4.2 Strings</a></li>
<li><a href="#43-variable-manipulation">4.3 Variable Manipulation</a></li>
<li><a href="#44-switch">4.4 Switch</a></li>
<li><a href="#45-subsetting">4.5 Subsetting</a>
<ul dir="auto">
<li><a href="#451-combining-operators">4.5.1 Combining Operators</a></li>
<li><a href="#452-removing-dimensions">4.5.2 Removing Dimensions</a></li>
<li><a href="#453-dangers-of-">4.5.3 Dangers of $</a></li>
<li><a href="#454-indistinguishable-errors">4.5.4 Indistinguishable
Errors</a></li>
<li><a href="#455-named-atomic-vectors">4.5.5 Named Atomic Vectors</a></li>
<li><a href="#456-silence">4.5.6 Silence</a></li>
<li><a href="#457-subsetting-by-predicates">4.5.7 Subsetting by
Predicates</a></li>
</ul>
</li>
<li><a href="#46-vectorization-again">4.6 Vectorization Again</a></li>
<li><a href="#47-r-wont-help-you">4.7 R Won’t Help You</a>
<ul dir="auto">
<li><a href="#471-the-documentation">4.7.1 The Documentation</a></li>
<li><a href="#472-the-functions">4.7.2 The Functions</a></li>
<li><a href="#473-extended-example-matrices">4.7.3 Extended Example:
Matrices</a></li>
<li><a href="#474-the-error-messages">4.7.4 The Error Messages</a></li>
<li><a href="#475-mapply-challenge">4.7.5 Mapply Challenge</a></li>
<li><a href="#476-stealing-from-the-tidyverse">4.7.6 Stealing from the
Tidyverse</a></li>
</ul>
</li>
<li><a href="#48-the-community">4.8 The Community</a></li>
<li><a href="#49-generic-functions-again">4.9 Generic Functions Again</a>
<ul dir="auto">
<li><a href="#491-the-class-system">4.9.1 The Class System</a></li>
<li><a href="#492-existing-functions">4.9.2 Existing Functions</a></li>
<li><a href="#493-internal-generics">4.9.3 Internal Generics</a></li>
<li><a href="#494-s4">4.9.4 S4</a></li>
</ul>
</li>
<li><a href="#410-factor-variables">4.10 Factor Variables</a></li>
<li><a href="#411-syntactic-sugar">4.11 Syntactic Sugar</a>
<ul dir="auto">
<li><a href="#4111-sequences">4.11.1 Sequences</a></li>
<li><a href="#4112-non-standard-evaluation">4.11.2 Non-standard
Evaluation</a></li>
</ul>
</li>
<li><a href="#412-missing-features">4.12 Missing Features</a></li>
<li><a href="#413-miscellaneous-negatives">4.13 Miscellaneous Negatives</a></li>
</ul>
</li>
<li><a href="#5-the-tidyverse">5 The Tidyverse</a>
<ul dir="auto">
<li><a href="#51-dplyr">5.1 Dplyr</a></li>
<li><a href="#52-ggplot2">5.2 Ggplot2</a></li>
<li><a href="#53-lubridate">5.3 Lubridate</a></li>
<li><a href="#54-magrittr">5.4 Magrittr</a></li>
<li><a href="#55-purrr">5.5 Purrr</a></li>
<li><a href="#56-stringr-and-tibble">5.6 Stringr and Tibble</a></li>
</ul>
</li>
<li><a href="#6-conclusion">6 Conclusion</a></li>
</ul>

<p dir="auto">What follows is an account of my experiences from about one year of
roughly daily R usage. It started out as a list of things that I liked
and disliked about the language, but eventually grew to be something
huge. Once the list exceeded ten thousand words, I knew that it must be
published. By the time I was done, it had nearly tripled in length. It
took five months of weekends just to get it all in R Markdown.</p>
<p dir="auto">This isn’t an attack on R or a pitch for anything else. It is only an
account of what I’ve found to be right and wrong with the language.
Although the length of my list of what is wrong far exceeds that of what
is right, that may be my failing rather than R’s. I suspect that my list
of what R does right will grow as I learn other languages and begin to
miss some of R’s benefits. I welcome any attempts to correct this or any
other errors that you find. Some major errors will have slipped in
somewhere or other.</p>
<h2 dir="auto"><a id="user-content-11-length" aria-hidden="true" href="#11-length"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.1 Length</h2>
<p dir="auto">To start, I must issue a warning: This document is <strong>huge</strong>. I have
tried to keep everything contained in small sections, such that the
reader has plenty of points where they can pause and return to the
document later, but the word count is still far higher than I’m happy
with. I have tried to not be too petty, but every negative point in here
comes from an honest position of frustration. There are some things that
I really love about R, I’ve even devoted <a href="#3-what-r-does-right">an entire section to
them</a>. However, if there is one point that I
really want this document to get across, it’s that R is filled to the
brim with small madnesses. Although I can name a few major issues with
R, its ultimate problem is the sum of its little problems. This document
couldn’t be short.</p>
<p dir="auto">Also, on the topic of the sections in this document, watch out for all
of the internal links. Nothing in R Markdown makes them look distinct
from external ones, so you might lose your place if you don’t take care
to open all of your links in a new tab/window.</p>
<h2 dir="auto"><a id="user-content-12-experience" aria-hidden="true" href="#12-experience"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.2 Experience</h2>
<p dir="auto">Before I say anything nasty about R, a show of good faith is in order.
In my year with R, I have done the following:</p>
<ul dir="auto">
<li>Added almost 100 <a href="https://github.com/ReeceGoding/Rosetta-Code-Submissions">R
solutions</a>
to <a href="https://rosettacode.org/wiki/Rosetta_Code" rel="nofollow">Rosetta Code</a>.</li>
<li>Asked over 100 Stack Overflow R questions.</li>
<li>Read both editions of <a href="https://adv-r.hadley.nz/" rel="nofollow"><em>Advanced R</em></a> from
cover to cover. I didn’t do the exercises, but I’d recommend the
books to any serious R user.</li>
<li>Read <a href="https://r4ds.had.co.nz/" rel="nofollow"><em>R for Data Science</em></a> from cover to
cover. It’s a good enough non-technical introduction to the
Tidyverse and a handful of other popular parts of R’s ecosystem.
However, I can’t give it a strong recommendation for a variety of
reasons:
<ul dir="auto">
<li>A lot of the exercises didn’t specify what they wanted from your
answer. This made checking your solutions against anyone else’s
quite difficult.</li>
<li>It deliberately avoids the fundamentals of programming –
e.g. making functions, loops, and if statements – until the
second half. I therefore suspect that any non-novice would be
better off finding an introduction to the relevant packages with
their favourite search engine.</li>
<li>Despite my efforts, I can find no “<em>Tidyverse for Programmers</em>”
book. When one is inevitably written, it will make this book
redundant for many potential readers.</li>
</ul>
</li>
<li>Read <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a> and
some other well-known PDFs and manuals, such as <a href="https://pj.freefaculty.org/R/Rtips.html" rel="nofollow"><em>Rtips. Revival
2014!</em></a> and the official
<a href="https://cran.r-project.org/doc/manuals/r-release/R-intro.html" rel="nofollow"><em>An Introduction to
R</em></a>,
<a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html" rel="nofollow"><em>R Language
Definition</em></a>,
and <a href="https://cran.r-project.org/doc/FAQ/R-FAQ.html" rel="nofollow"><em>R FAQ</em></a>
manuals. Out of all of these, I must recommend <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a>. The
page count may be intimidating, but it’s a delightfully fast read
that mirrors many of my points. In many cases I have pointed the
reader straight to its relevant section. Its only true fault is its
age. I wish that I could claim that this document is a sequel to it,
but I’m writing to review rather than advise.</li>
<li>Made minor contributions to open source R projects.</li>
</ul>
<p dir="auto">At minimum, I can say with confidence that unless I happen to pick up an
R-focused statistics textbook – <a href="https://cran.r-project.org/doc/FAQ/R-FAQ.html#What-documentation-exists-for-R_003f" rel="nofollow">the <em>R FAQ</em> has some tempting
items</a>
– I’ve already done all of the R-related reading that I ever plan to do.
All that is left for me is to use the language more and more. I hope
that this section shows that I’ve given it a good chance before writing
this review of it.</p>
<h2 dir="auto"><a id="user-content-13-ignorance" aria-hidden="true" href="#13-ignorance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.3 Ignorance</h2>
<p dir="auto">I am not an R expert. I freely admit that I am lacking in the following
regards:</p>
<ul dir="auto">
<li>You can never have done enough statistics with R. I’ve mostly used R
as a programming language rather than a statistics tool. My
arguments would certainly be stronger if I had some published stats
work to back them up, even just blogs. I might correct this at some
point.</li>
<li>The above point makes me more ignorant of formulae objects
(e.g. expressions like <code>foo ~ log(bar) * bar^2</code>), the <code>plot()</code>
function, and factor variables than I ought to be. I saw a lot of
them during my degree, but have long since forgotten them and have
never needed to pick them back up. For similar reasons, I have
nothing to say on how hard it can sometimes be to read data in to R.</li>
<li>I haven’t used enough of the community’s favourite libraries. My
biggest regret is my near-total ignorance of <code>data.table</code>. From
<a href="https://atrebas.github.io/post/2019-03-03-datatable-dplyr/" rel="nofollow">what little I’ve
seen</a>,
it’s a real pleasure. More practice with <code>ggplot2</code>, the wider
Tidyverse, and R Markdown is also in order. If I continue to use R,
I will gradually master these. For now, it suffices to say that my
experience with base R far exceeds my knowledge of both the
Tidyverse and many other well-loved packages. If I’ve missed any
gems, let me know.</li>
<li>My experience with R’s competitors is minimal. In particular, I have
virtually no experience with Python or Julia. Most of my points on R
are about R on its own merits, rather than comparing it to its
competition. I plan to pick up Python soon, but Julia is in my
distant future.</li>
<li>Although I have used SQL professionally, how it compares to R has
rarely crossed my mind. This suggests that I’m missing something
about both languages.</li>
<li>R’s functional aspects make me wish that I knew more Lisp. I’m
slowly picking it up, but I’ve currently not got any further than
chapter 4 of <em>Structure and Interpretation of Computer Programs</em>.
R’s clear Scheme inspiration makes Lisp books a lot less fun to
read; It’s like I’ve already been spoiled on some of the best bits.</li>
<li>I haven’t done enough OOP in R. My only real experience of it is
with S3. S4 looks enough like CLOS that I expect that I will revisit
it at some point after picking up Common Lisp, but that will just be
to play around.</li>
<li>I have never made a package for R and have no experience with the
ecosystem surrounding that (e.g. <code>roxygen2</code>). I have no plans for
this.</li>
<li>I have no experience in developing large projects in R. This is
likely a part of why I have never felt the need to make significant
use of its OOP. I do not expect this to change.</li>
</ul>
<p dir="auto">The above list is unlikely to be exhaustive. I’m not against reading
another book about R as a programming language, but <a href="https://adv-r.hadley.nz/" rel="nofollow"><em>Advanced
R</em></a> seems to be the only one that anyone ever
mentions. For the foreseeable future, the main thing that I plan to do
to improve my evaluation of R is to learn Python. I’ll probably read a
book on it.</p>
<h2 dir="auto"><a id="user-content-14-assumed-knowledge" aria-hidden="true" href="#14-assumed-knowledge"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.4 Assumed Knowledge</h2>
<p dir="auto">You’d be a fool to read this without some experience of R. I don’t think
that I’ve written anything that requires an expert level of
understanding, but you’re unlikely to get much out of this document
without at least a basic idea of R. I’ve also mentioned the Tidyverse a
few times without giving it much introduction, particularly its <code>tibble</code>
package. If you care enough about R to consider reading this document,
then you really ought to be familiar with the most popular parts of the
Tidyverse. It’s rare for any discussion of R to go long without some
mention of <code>purrr</code>, <code>dplyr</code> or <code>magrittr</code>.</p>
<h2 dir="auto"><a id="user-content-15-disclaimer" aria-hidden="true" href="#15-disclaimer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1.5 Disclaimer</h2>
<p dir="auto">This document started out as personal notes that I had no intention of
publishing. There’s a good chance that I might have copy and pasted
someone’s example from somewhere and totally forgot that it wasn’t my
own. If you spot any plagiarism, let me know.</p>

<p dir="auto">My overall feelings about R are tough to quantify. As I mentioned near
the start, its ultimate problem is the sum of its little problems.
However, if I must speak generally, then I think that the problem with R
is that it’s always some mix of the following:</p>
<ol dir="auto">
<li>A statistics language with countless useful libraries and an
excellent collection of mathematical tools.</li>
<li>A Scheme-inspired language that tries to be functional while
maintaining a C-like syntax.</li>
<li>Decades of haphazard patches for S.</li>
<li>A collection of <a href="https://wiki.c2.com/?SemanticSemtex" rel="nofollow">semantic
semtex</a> that is powerful in the
hands of a master and crippling in the hands of a novice.</li>
</ol>
<p dir="auto">When it’s anything but #3, R is great. Statisticians and mathematicians
love it for #1 and programmers love it for #2 and #4. If it weren’t
for #3, R would be an amazing – albeit, domain-specific – language, but
#3 is such a big factor that it makes the language unpredictable,
inconsistent, and infuriating. Mixed with #4, it makes being an R
novice hellish. It gives me little doubt that R is not the ideal tool
for many of the jobs that it wants to do, but #1 and #2 leave me with
equally little doubt that R can be a very good tool.</p>

<p dir="auto">As a final show of good faith, here is what I think R does right. In
summary, along with having some great functional programming toys, R has
some domain-specific tools that can work excellently when they’re in
their element. Whatever the faults of R, it’s always going to be my
first choice for some problems.</p>
<h2 dir="auto"><a id="user-content-31-mathematics-and-statistics" aria-hidden="true" href="#31-mathematics-and-statistics"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.1 Mathematics and Statistics</h2>
<p dir="auto">R wants to be a mathematics and statistics tool. Many of its fundamental
design choices support this. For example, vectors are primitive types
and R isn’t at all shy about giving you a table or matrix as output.
Similarly, the base libraries are packed with maths and stats functions
that are usually a good combination of relevant, generic, and helpful.
Some examples:</p>
<ul dir="auto">
<li>
<p dir="auto">Lots of stats is made easy. Commands like <code>boxplot(data)</code> or
<code>quantile(data)</code> just work and there are lots of handy functions
like <code>colSums()</code>, <code>table()</code>, <code>cor()</code>, or <code>summary()</code>.</p>
</li>
<li>
<p dir="auto">R is <strong>the</strong> language of research-level statistics. If it’s stats, R
either has it built-in or has a library for it. It’s impossible to
visit a statistics Q&amp;A website and not see R code. For this reason
alone, R will never truly die.</p>
</li>
<li>
<p dir="auto">The generic functions in the base stats library work magic. Whenever
you try to print or summarise a model from there, you’re going to
get all of the details that you could ever realistically ask for and
you’re going to get them presented in a very helpful way. For
example</p>
<div data-snippet-clipboard-copy-content="model &lt;- lm(mpg ~ wt, data = mtcars)
print(model)
## 
## Call:
## lm(formula = mpg ~ wt, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt  
##      37.285       -5.344
summary(model)
## 
## Call:
## lm(formula = mpg ~ wt, data = mtcars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -4.5432 -2.3647 -0.1252  1.4096  6.8727 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  37.2851     1.8776  19.858  &lt; 2e-16 ***
## wt           -5.3445     0.5591  -9.559 1.29e-10 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 3.046 on 30 degrees of freedom
## Multiple R-squared:  0.7528,   Adjusted R-squared:  0.7446 
## F-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10"><pre><span>model</span> <span>&lt;-</span> lm(<span>mpg</span> <span>~</span> <span>wt</span>, <span>data</span> <span>=</span> <span>mtcars</span>)
print(<span>model</span>)
<span><span>#</span># </span>
<span><span>#</span># Call:</span>
<span><span>#</span># lm(formula = mpg ~ wt, data = mtcars)</span>
<span><span>#</span># </span>
<span><span>#</span># Coefficients:</span>
<span><span>#</span># (Intercept)           wt  </span>
<span><span>#</span>#      37.285       -5.344</span>
summary(<span>model</span>)
<span><span>#</span># </span>
<span><span>#</span># Call:</span>
<span><span>#</span># lm(formula = mpg ~ wt, data = mtcars)</span>
<span><span>#</span># </span>
<span><span>#</span># Residuals:</span>
<span><span>#</span>#     Min      1Q  Median      3Q     Max </span>
<span><span>#</span># -4.5432 -2.3647 -0.1252  1.4096  6.8727 </span>
<span><span>#</span># </span>
<span><span>#</span># Coefficients:</span>
<span><span>#</span>#             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span><span>#</span># (Intercept)  37.2851     1.8776  19.858  &lt; 2e-16 ***</span>
<span><span>#</span># wt           -5.3445     0.5591  -9.559 1.29e-10 ***</span>
<span><span>#</span># ---</span>
<span><span>#</span># Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span><span>#</span># </span>
<span><span>#</span># Residual standard error: 3.046 on 30 degrees of freedom</span>
<span><span>#</span># Multiple R-squared:  0.7528,   Adjusted R-squared:  0.7446 </span>
<span><span>#</span># F-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10</span></pre></div>
<p dir="auto">shows us plenty of useful information and works just as well even if
we change to another type of model. Your mileage may vary with
packages, but it usually works as expected. Other examples are easy
to come by, e.g. <code>plot(model)</code>.</p>
</li>
<li>
<p dir="auto">The rules for subsetting data, although requiring mastery, are
extremely expressive. Coupled with sub-assignment tricks like
<code>result[which(result &lt; 0.5)] &lt;- 0</code>, which often do exactly what you
think they will, you can really save yourself a lot of work. Being
able to demand precisely what parts of your data that you want to
see or change is a really great feature.</p>
</li>
<li>
<p dir="auto">The factor and ordered data types are definitely the sort of tools
that I want to have in a stats language. <a href="#410-factor-variables">They’re a bit
unpredictable</a>, but they’re great when they
work.</p>
</li>
<li>
<p dir="auto">It’s no surprise that an R terminal has fully replaced my OS’s
built-in calculator. It’s my first choice for any arithmetical task.
When checking a gaming problem, I once opened R and used
<code>(0.2 * seq(1000, 1300, 50) + 999) / seq(1000, 1300, 50)</code>. That
would’ve been several lines in many other languages. Furthermore, a
general-purpose language that was capable of the same would’ve had a
call to something long-winded like <code>math.vec.seq()</code> rather than just
<code>seq()</code>. I find the cumulative functions, e.g. <code>cumsum()</code> and
<code>cummax()</code>, similarly enjoyable.</p>
</li>
<li>
<p dir="auto">How many other language have matrix algebra fully built-in? Solving
systems of linear equations is just <code>solve()</code>.</p>
</li>
<li>
<p dir="auto">The <code>rep()</code> function is outstandingly versatile. I’d give examples,
but those found in its documentation are more than sufficient. Open
up R and run <code>example(rep)</code> if you want to see them. If tricks like
<code>cbind(rep(1:6, each = 6), rep(1:6, times = 6))</code> have yet to become
second nature, then you’re really missing out.</p>
</li>
<li>
<p dir="auto">On top of replacing your computer’s calculator, R can replace your
graphing calculator as well. Unless you need to tinker with the axes
or stop the asymptotes causing you problems – problems that your
graphing calculator would give you anyway – functions like
<code>curve(x / (x^3 + 9), -10, 10)</code> (output below) do exactly what you
would expect and exactly how.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/ReeceGoding/Frustration-One-Year-With-R/blob/master/Frustration-One-Year-With-R_files/figure-gfm/unnamed-chunk-3-1.png"><img src="https://www.youtube.com/ReeceGoding/Frustration-One-Year-With-R/raw/master/Frustration-One-Year-With-R_files/figure-gfm/unnamed-chunk-3-1.png" alt=""/></a></p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-32-names-and-data-frames" aria-hidden="true" href="#32-names-and-data-frames"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.2 Names and Data Frames</h2>
<p dir="auto">These seem like trivial features, but the language’s deep integration of
them is extremely beneficial for manipulating and presenting your data.
They assist subsetting, variable creation, plotting, printing, and even
<a href="#352-first-class-environments">metaprogramming</a>.</p>
<ul dir="auto">
<li>
<p dir="auto">The ability to name the components of vectors,
e.g. <code>c(Fizz=3, Buzz=5)</code>, is a nice trick for toy programs. The same
syntax is used to much greater effect with lists, data frames, and
S4 objects. However, it’s good to show how far you can get with even
the most basic case. Here’s my submission for a <a href="https://rosettacode.org/wiki/General_FizzBuzz" rel="nofollow">General
FizzBuzz</a> task:</p>
<div data-snippet-clipboard-copy-content="namedGenFizzBuzz &lt;- function(n, namedNums)
{
  factors &lt;- sort(namedNums)#Required by the task: We must go from least factor to greatest.
  for(i in 1:n)
  {
    isFactor &lt;- i %% factors == 0
    print(if(any(isFactor)) paste0(names(factors)[isFactor], collapse = &#34;&#34;) else i)
  }
}
namedNums &lt;- c(Fizz=3, Buzz=5, Baxx=7)#Notice that we can name our inputs without a function call.
namedGenFizzBuzz(105, namedNums)"><pre><span>namedGenFizzBuzz</span> <span>&lt;-</span> <span>function</span>(<span>n</span>, <span>namedNums</span>)
{
  <span>factors</span> <span>&lt;-</span> sort(<span>namedNums</span>)<span><span>#</span>Required by the task: We must go from least factor to greatest.</span>
  <span>for</span>(<span>i</span> <span>in</span> <span>1</span><span>:</span><span>n</span>)
  {
    <span>isFactor</span> <span>&lt;-</span> <span>i</span> <span>%%</span> <span>factors</span> <span>==</span> <span>0</span>
    print(<span>if</span>(any(<span>isFactor</span>)) paste0(names(<span>factors</span>)[<span>isFactor</span>], <span>collapse</span> <span>=</span> <span><span>&#34;</span><span>&#34;</span></span>) <span>else</span> <span>i</span>)
  }
}
<span>namedNums</span> <span>&lt;-</span> c(<span>Fizz</span><span>=</span><span>3</span>, <span>Buzz</span><span>=</span><span>5</span>, <span>Baxx</span><span>=</span><span>7</span>)<span><span>#</span>Notice that we can name our inputs without a function call.</span>
namedGenFizzBuzz(<span>105</span>, <span>namedNums</span>)</pre></div>
<p dir="auto">I’ve little doubt that an R guru could improve this, but the amount
of expressiveness in each line is already impressive. A lot of that
is owed to R’s love for names.</p>
</li>
<li>
<p dir="auto">Having a tabular data type in your base library – the data frame –
is very handy for when you want a nice way to present your results
without having to bother importing anything. Due to this and the
aforementioned ability to name vectors, my output in coding
challenges often looks nicer than most other people’s.</p>
</li>
<li>
<p dir="auto">I like how data frames are constructed. Even if you don’t know any R
at all, it’s pretty obvious what
<code>data.frame(who = c(&#34;Alice&#34;, &#34;Bob&#34;),  height = c(1.2, 2.3))</code>
produces and what adding the
<code>row.names = c(&#34;1st subject&#34;, &#34;2nd subject&#34;)</code> argument would do.</p>
</li>
<li>
<p dir="auto">As a non-trivial example of how far these features can get you, I’ve
had some good fun making alists out of syntactically valid
expressions and using only those alists to build a data frame where
both the expressions and their evaluated values are shown:</p>
<div data-snippet-clipboard-copy-content="expressions &lt;- alist(-x ^ p, -(x) ^ p, (-x) ^ p, -(x ^ p))
x &lt;- c(-5, -5, 5, 5)
p &lt;- c(2, 3, 2, 3)
output &lt;- data.frame(x,
                     p,
                     setNames(lapply(expressions, eval), sapply(expressions, deparse)),
                     check.names = FALSE)
print(output, row.names = FALSE)
##   x p -x^p -(x)^p (-x)^p -(x^p)
##  -5 2  -25    -25     25    -25
##  -5 3  125    125    125    125
##   5 2  -25    -25     25    -25
##   5 3 -125   -125   -125   -125"><pre><span>expressions</span> <span>&lt;-</span> alist(<span>-</span><span>x</span> <span>^</span> <span>p</span>, <span>-</span>(<span>x</span>) <span>^</span> <span>p</span>, (<span>-</span><span>x</span>) <span>^</span> <span>p</span>, <span>-</span>(<span>x</span> <span>^</span> <span>p</span>))
<span>x</span> <span>&lt;-</span> c(<span>-</span><span>5</span>, <span>-</span><span>5</span>, <span>5</span>, <span>5</span>)
<span>p</span> <span>&lt;-</span> c(<span>2</span>, <span>3</span>, <span>2</span>, <span>3</span>)
<span>output</span> <span>&lt;-</span> <span>data.frame</span>(<span>x</span>,
                     <span>p</span>,
                     setNames(lapply(<span>expressions</span>, <span>eval</span>), sapply(<span>expressions</span>, <span>deparse</span>)),
                     <span>check.names</span> <span>=</span> <span>FALSE</span>)
print(<span>output</span>, <span>row.names</span> <span>=</span> <span>FALSE</span>)
<span><span>#</span>#   x p -x^p -(x)^p (-x)^p -(x^p)</span>
<span><span>#</span>#  -5 2  -25    -25     25    -25</span>
<span><span>#</span>#  -5 3  125    125    125    125</span>
<span><span>#</span>#   5 2  -25    -25     25    -25</span>
<span><span>#</span>#   5 3 -125   -125   -125   -125</span></pre></div>
<p dir="auto">(stolen from my submission
<a href="https://rosettacode.org/wiki/Exponentiation_with_infix_operators_in_(or_operating_on)_the_base" rel="nofollow">here</a>).
Did you notice that the output knew the names of <code>x</code> and <code>p</code> without
being told them? Did you also notice that a similar thing happened
in after our call to <code>curve()</code> earlier on? Finally, did you notice
how easy it was to get such neat output?</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-33-outstanding-packages" aria-hidden="true" href="#33-outstanding-packages"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.3 Outstanding Packages</h2>
<p dir="auto"><a href="#13-ignorance">I’ve already admitted a great deal of ignorance of this
topic</a>, but there are some parts of R’s ecosystem that
I’m happy to call outstanding. The below are all things that I’m sure to
miss in other languages.</p>
<ul dir="auto">
<li><code>corrplot</code>: It has less than ten functions, but it only needed one
to blow my mind. Once you’ve even as much as read <a href="https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html" rel="nofollow">the
introduction</a>,
you will never try to read a correlation matrix again.</li>
<li><code>ggplot2</code>: I’m not experienced enough to know what faults it has,
but it’s fun to use. That single fact makes it blow any other
graphing software that I’ve used out of the water: <strong>It’s fun</strong>.</li>
<li><code>magrittr</code>: It sold me on pipes. I’d say that any package that makes
you consider changing your programming style is automatically
outstanding. However, the real reason why I love it is because
whenever I’ve run <code>bigLongExpression()</code> in my console and decided
that I really wanted <code>foo()</code> of it, it’s so much easier to press the
up arrow and type CTRL+SHIFT+M+“foo” than it is to do anything that
results in <code>foo(bigLongExpression())</code> appearing. Maybe there’s a
keyboard shortcut that I never learned, but this isn’t the only
reason why I love <code>magrittr</code>. <a href="#54-magrittr">I’ll say more about it much
later</a>.</li>
<li><code>R Markdown</code> has served me well in writing this document. It’s
buggier than I’d like, rarely has helpful error messages, and does
things that I can’t explain or fix even after setting a bounty on
Stack Overflow, but it’s still a great way to make a document
from R. It’s the closest thing that I know of to an R user’s LaTeX.
I had to wait on <a href="https://github.com/rstudio/rmarkdown/pull/2093" data-hovercard-type="pull_request" data-hovercard-url="/rstudio/rmarkdown/pull/2093/hovercard">this bug
fix</a> before I could
start numbering my sections. Hopefully it didn’t break anything.</li>
</ul>
<h2 dir="auto"><a id="user-content-34-vectorization" aria-hidden="true" href="#34-vectorization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.4 Vectorization</h2>
<p dir="auto"><a href="#46-vectorization-again">When it’s not causing you problems</a>, the
vectorization can be the best thing about the language:</p>
<ul dir="auto">
<li>
<p dir="auto">The vector recycling rules are powerful when mastered. Expressions
like <code>c(&#34;x&#34;, &#34;y&#34;)[rep(c(1, 2), times = 4)]</code> let you do a lot with
only a little work. My favourite ever FizzBuzz could well be</p>
<div data-snippet-clipboard-copy-content="x &lt;- paste0(rep(&#34;&#34;, 100), c(&#34;&#34;, &#34;&#34;, &#34;Fizz&#34;), c(&#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;Buzz&#34;))
cat(ifelse(x == &#34;&#34;, 1:100, x), sep = &#34;\n&#34;)"><pre><span>x</span> <span>&lt;-</span> paste0(rep(<span><span>&#34;</span><span>&#34;</span></span>, <span>100</span>), c(<span><span>&#34;</span><span>&#34;</span></span>, <span><span>&#34;</span><span>&#34;</span></span>, <span><span>&#34;</span>Fizz<span>&#34;</span></span>), c(<span><span>&#34;</span><span>&#34;</span></span>, <span><span>&#34;</span><span>&#34;</span></span>, <span><span>&#34;</span><span>&#34;</span></span>, <span><span>&#34;</span><span>&#34;</span></span>, <span><span>&#34;</span>Buzz<span>&#34;</span></span>))
cat(ifelse(<span>x</span> <span>==</span> <span><span>&#34;</span><span>&#34;</span></span>, <span>1</span><span>:</span><span>100</span>, <span>x</span>), <span>sep</span> <span>=</span> <span><span>&#34;</span><span>\n</span><span>&#34;</span></span>)</pre></div>
<p dir="auto">I wish that I could claim credit for that, but I stole it from an
old version of <a href="https://rosettacode.org/wiki/FizzBuzz#R" rel="nofollow">this page</a>
and improved it a little.</p>
</li>
<li>
<p dir="auto">Basically everything is a vector, so R comes with some really cool
vector-manipulation tools like <code>ifelse()</code> (as seen above) and makes
it very easy to use a function on an entire collection. Can you
believe that <code>mtcars / 20</code> actually works?</p>
</li>
<li>
<p dir="auto">Tricks like <code>array / seq_along(array)</code> save a lot of loop writing.</p>
</li>
<li>
<p dir="auto">Even simple things like being able to subtract a vector from a
constant (e.g. <code>10 - 1:5</code>) and get a sensible result are a gift when
doing mathematics.</p>
</li>
<li>
<p dir="auto">Vectorization of functions is sometimes very useful, particularly
when it lets you do what should’ve been two loops worth of work in
one line. You’d be amazed by how often you can get away with calling
<code>foo(1:100)</code> without needing to vectorize <code>foo()</code> yourself.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-35-functional-programming" aria-hidden="true" href="#35-functional-programming"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.5 Functional Programming</h2>
<p dir="auto">R’s done a good job of harnessing the power of functional languages
while maintaining a C-like syntax. It makes no secret of being inspired
by Scheme and has reaped many of its benefits.</p>
<h3 dir="auto"><a id="user-content-351-first-class-functions" aria-hidden="true" href="#351-first-class-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.5.1 First-class Functions</h3>
<p dir="auto">It’s impossible to not notice that functions are first-class in R.
You’re almost forced to learn functional programming idioms like mapping
functions, higher-order functions, and anonymous functions. This is a
good thing. Where else do you find a language with enough useful
higher-order functions for the community to be able to discourage new
users from writing loops? Some examples:</p>
<ul dir="auto">
<li>All of the functional programming toys that you could want are
easily found in R, e.g. closures, anonymous functions, and
higher-order functions like <code>Map()</code>, <code>Filter()</code>, and <code>Reduce()</code>.
Once you’re used to them, you can write some very expressive code.</li>
<li>The apply family of functions is basically a set of DSL mapping
functions for stats. Both <code>apply()</code> and <code>tapply()</code> can produce some
very concise code, as can related functions like <code>by()</code>.</li>
<li>Where else can you write functions that are both anonymous and
recursive? Not that you should, of course.</li>
<li>First-class functions sometimes interact with R’s vectorization
obsession in a very entertaining way. In how many other languages do
you see somebody take a list of functions and, in a single line,
call them all with a vector as a single argument to each function?
Code like <code>lapply(listOfFuns, function(f) f(1:10))</code> is entirely
valid. It calls each function in <code>listOfFuns</code> with the entire vector
<code>1:10</code> as their first argument.</li>
<li>Code like <code>Vectorize(foo)(1:100)</code> is not particularly hard to
understand, but I’d struggle to name another language that lets me
do the same thing with so much ease.</li>
</ul>
<h3 dir="auto"><a id="user-content-352-first-class-environments" aria-hidden="true" href="#352-first-class-environments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.5.2 First-class Environments</h3>
<p dir="auto">Not only are functions first-class in R, environments are too. You
therefore have lots of control over what environment an expression is
evaluated in. This is an amazing source of power that tends to scare off
beginners, but I cannot overstate how much of an asset it can be. If
you’re not familiar with the below, look it up. You will not regret it.</p>
<ul dir="auto">
<li>Because R’s environments are first-class, functions like <code>with()</code>
and <code>within()</code> can generate them on the fly. I’ve seen this called
“<em>data masking</em>”. <a href="https://adv-r.hadley.nz/translation.html" rel="nofollow"><em>Advanced R</em> has a whole chapter on
it</a>. It lets you do things
like “<em>treat this list of functions as if it were a namespace, so I
can write code that uses function names that I wouldn’t dare use
elsewhere</em>”. This can also be used with data. For example,
<code>tapply(mtcars$mpg, list(mtcars$cyl, mtcars$gear), mean)</code> uses
<code>mtcars</code> far too many times, but
<code>with(mtcars, tapply(mpg, list(cyl, gear), mean))</code> gives us an easy
fix. Ad-hoc namespaces are an amazing thing to have, particularly
when using functions that don’t have a <code>data</code> argument
(e.g. <code>plot()</code>).</li>
<li>Modelling functions like <code>lm()</code> use the data-masking facilities that
I’ve just described, as do handy functions like <code>subset()</code>. This
saves incredible amounts of typing and massively increases the
readability of your stats code. For example,
<code>aggregate(mpg ~ cyl + gear, mtcars, mean)</code> returns very similar
output to my above calls to <code>tapply()</code> without needing the
complexity of using <code>with()</code>. It also allows for ridiculously
concise code like <code>aggregate(. ~ cyl + gear, mtcars, mean)</code>.</li>
<li>You can write your own data-masking functions. Doing so relies on
controlling the non-standard evaluation of some of your arguments.
It’s the closest thing that R has to metaprogramming. The names
mechanisms do a lot to remove any ambiguity from your attempts at
this. Stealing an example from the documentation, do I even need to
explain what
<code>transform(airquality, new = -Ozone, Temp = (Temp-32)/1.8)</code> does?
Being able to do all of that in one line is outstanding. Without R
allowing developers to add new functions like this, the Tidyverse
would’ve been impossible.</li>
</ul>
<p dir="auto">You might have spotted a pattern by now. R often lets you do very much
with very little.</p>
<h3 dir="auto"><a id="user-content-353-generic-functions" aria-hidden="true" href="#353-generic-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.5.3 Generic Functions</h3>
<p dir="auto">Generic function OO is pretty nice to have, even if I wouldn’t use
anything more complicated than S3. Being able to call <code>foo(whatever)</code>
and be confident that it’s going to do what I mean is always nice. Some
positives of R’s approach are:</p>
<ul dir="auto">
<li>
<p dir="auto">As mentioned <a href="#31-mathematics-and-statistics">earlier on</a>, S3 is
used excellently in the base R stats library. Functions like
<code>print()</code>, <code>plot()</code>, and <code>summary()</code> almost always tell me
everything that I wanted to know and tell me them with great
clarity.</p>
</li>
<li>
<p dir="auto">When you’re not trapped by <a href="#49-generic-functions-again">the
technicalities</a>, S3 is an outstandingly
simple tool that does exactly what R needs it to do. Have a look at
all of the methods that the pre-loaded libraries define for <code>plot()</code></p>
<div data-snippet-clipboard-copy-content="methods(plot)
##  [1] plot.acf*           plot.data.frame*    plot.decomposed.ts*
##  [4] plot.default        plot.dendrogram*    plot.density*      
##  [7] plot.ecdf           plot.factor*        plot.formula*      
## [10] plot.function       plot.hclust*        plot.histogram*    
## [13] plot.HoltWinters*   plot.isoreg*        plot.lm*           
## [16] plot.medpolish*     plot.mlm*           plot.ppr*          
## [19] plot.prcomp*        plot.princomp*      plot.profile.nls*  
## [22] plot.raster*        plot.spec*          plot.stepfun       
## [25] plot.stl*           plot.table*         plot.ts            
## [28] plot.tskernel*      plot.TukeyHSD*     
## see &#39;?methods&#39; for accessing help and source code"><pre>methods(<span>plot</span>)
<span><span>#</span>#  [1] plot.acf*           plot.data.frame*    plot.decomposed.ts*</span>
<span><span>#</span>#  [4] plot.default        plot.dendrogram*    plot.density*      </span>
<span><span>#</span>#  [7] plot.ecdf           plot.factor*        plot.formula*      </span>
<span><span>#</span># [10] plot.function       plot.hclust*        plot.histogram*    </span>
<span><span>#</span># [13] plot.HoltWinters*   plot.isoreg*        plot.lm*           </span>
<span><span>#</span># [16] plot.medpolish*     plot.mlm*           plot.ppr*          </span>
<span><span>#</span># [19] plot.prcomp*        plot.princomp*      plot.profile.nls*  </span>
<span><span>#</span># [22] plot.raster*        plot.spec*          plot.stepfun       </span>
<span><span>#</span># [25] plot.stl*           plot.table*         plot.ts            </span>
<span><span>#</span># [28] plot.tskernel*      plot.TukeyHSD*     </span>
<span><span>#</span># see &#39;?methods&#39; for accessing help and source code</span></pre></div>
<p dir="auto">because a statistician often only need to dispatch on the type of
model being used, S3 is the perfect tool to make functions like
<code>plot()</code> easy to extend, meaning that it’s easy to make it give your
users exactly what they want. This isn’t just theoretical either.
The output for <code>methods(plot)</code> gets a lot longer if I go through my
list of packages and start loading some random number of them. Go
try it yourself!</p>
</li>
<li>
<p dir="auto">S3 generics and objects are very easy to write. The trade-off is
that they don’t do anything to protect you from yourself. However,
being able to tell R to shut up and do what I want it to a nice part
of S3.</p>
</li>
<li>
<p dir="auto">I like the idea of S3’s group generics, but I don’t like not being
able to make my own. However, I think that you can do it for S4.</p>
</li>
<li>
<p dir="auto">I have it on good authority that biology people often need to
dispatch on more than one type of model at a time. This means that
they shower the S4 object system with greater praise than what I’ve
just given S3. Apparently, the <code>bioconductor</code> package is the
outstanding example of their love of it.</p>
</li>
<li>
<p dir="auto">S4 has multiple inheritance and multiple dispatch. I’m not going to
say that multiple inheritance is a good thing, but it’s not always
found in other OOP systems.</p>
</li>
<li>
<p dir="auto">RC and the <code>R6</code> package are about as close as you’re ever going to
get to having Java-like OOP in a mostly function language.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-36-syntax" aria-hidden="true" href="#36-syntax"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.6 Syntax</h2>
<p dir="auto">Some of the syntax is nice:</p>
<ul dir="auto">
<li><a href="#4111-sequences">It can cause you problems</a>, but the <code>:</code> operator
is handy for things like <code>for(i in 1:20){...}</code>.</li>
<li>The <code>for</code> loop syntax is always the same:
<code>for(element in vector){...}</code>. This means that there is no
difference between the typical “<em>do n times</em>” case like
<code>for(i in 1:n)</code> and the “<em>for every member of this collection</em>” case
like <code>for(v in sample(20))</code>. I appreciate the consistency.</li>
<li>The <code>...</code> notation has a very nice “<em>do what I mean</em>” feel,
particularly when you’re playing around with anonymous functions.</li>
<li>Because of <code>repeat</code> loops, you never need to write <code>while(TRUE)</code>.</li>
<li><a href="#45-subsetting">Although I have major issues with them</a>, the rules
for accessing elements sometimes give nice results. For example
<code>array[c(i, j)] &lt;- array[c(j, i)]</code> swaps elements <code>i</code> and <code>j</code> in a
very clean way.</li>
<li>It’s nice to be able to do many variable assignments in one line
e.g. <code>Alice &lt;- Bob &lt;- &#34;Married&#34;</code>. The best examples are when you do
something like
<code>lastElement &lt;- output[lastIndex &lt;- lastIndex + 1] &lt;- foo</code>, letting
you avoid having to do anything twice.</li>
<li>The syntax for manipulating environments makes sense. You have to
learn the difference between <code>&lt;-</code> and <code>&lt;&lt;-</code> , but having
environments use a subset of the list syntax was a very good idea.
It was a similarly good idea to have a lot of R’s internals
(e.g. quoted function calls) be pairlists. This lets them be
manipulated in exactly the same way as lists. The similarities
between lists, pairlists, environments, and data frames go deeper
than you may expect. For example, the <code>eval()</code> function lets you
evaluate an expression in the specified environment, but it’s happy
to take any of the data types that I’ve just listed in place of an
environment. At times, R almost lets you forget that lists and
environments aren’t the same thing.</li>
<li>The function names for making and manipulating S4 objects and
functions are generally what you would expect them to be. For
example, once you know <code>setClass()</code> and <code>setGeneric()</code>, you can
probably guess what the corresponding function for methods is
called.</li>
</ul>
<h2 dir="auto"><a id="user-content-37-miscellaneous-positives" aria-hidden="true" href="#37-miscellaneous-positives"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3.7 Miscellaneous Positives</h2>
<ul dir="auto">
<li>The built-in vectors <code>letters</code> and <code>LETTERS</code> come in handy
surprisingly often. You’ll see me use them a lot.</li>
<li>The base library surprises me from time to time. It’s always worth
putting what you want in to a search engine; Sometimes, you’ll find
it. My most recent surprises were <code>findInterval()</code> and <code>cut()</code>.</li>
<li>The <code>na.print</code> argument to <code>print()</code>, trivial as it is, can be a
thing of beauty.</li>
<li>R’s condition handling and recovery system is build atop S3, making
it extremely customisable by letting you add and handle custom
metadata pretty much however you want. It also has some nice
built-in types of conditions like errors, warnings, and messages, as
well as having <code>finally</code> blocks in <code>tryCatch()</code>. The only real
oddity of the system is that its conditionals are treated as
functions of the error, meaning that you will have to write strange
code like
<code>tryCatch(code, error = function(unused) &#34;error&#34;, warning = function(unused) &#34;warning&#34;)</code>.
However, this is the price that you pay for being able to use code
like
<code>tryCatch(code, myError = function(e) paste0(e$message, &#34; was triggered by &#34;,e$call,&#34;. Try &#34;,e$suggestion)</code>.
As a final point of interest, I’ve heard that R’s condition handling
system is one of the best copies of Common Lisp’s, which I’ve heard
awesome things about.</li>
<li>Speaking of Lisp, <a href="https://en.wikipedia.org/wiki/XLispStat" rel="nofollow">statistical Lisps used to be a
thing</a>. I’ve heard rumours
of them still being used in Japan, but I can’t find anything to back
that up. Everything that I’ve found says that <a href="https://www.jstatsoft.org/article/view/v013i07/v13i07.pdf" rel="nofollow">R killed them
off</a>. As
far as I know, nobody’s tried to make another such Lisp since the
90’s. The fact that R can claim to have eradicated an entire
category of language design is a great point in its favour. It’s
also possible evidence that I’m correct to say that R resembling C
is to its benefit. However, I’d be overjoyed to hear of such Lisps
making a comeback. Imagine if we’re just one good Clojure library
away from R surrendering to its Scheme roots and birthing a modern
statistical Lisp.</li>
<li>Base R is quite stable. Breaking changes are almost unheard of. I
don’t agree that they should be trying so hard to maintain
compatibility with S, but this is an undeniable benefit of that
decision.</li>
<li>The fact that the Tidyverse is just an R library, rather than an
entirely separate language, is a testament to R’s metaprograming. I
like being able to define new infix operators and replacement
functions, but the Tidyverse went above and beyond. Where else do
you see an entire library of pipes? Until very recently, base R
didn’t even have pipes!</li>
<li>The Tidyverse is proof that people are trying to fix R. Although
that comes with the implication that R is broken, the fact that
people are both willing and able to fix it definitely says something
nice about R.</li>
<li>I generally like the RStudio IDE. When Emacs is the only alternative
that anyone takes seriously, you know that you’ve done a good job.</li>
<li>There is only one implementation of R that anyone’s ever heard of,
so you never need to worry about undefined behaviour.</li>
</ul>

<p dir="auto">This is where this documents starts to get long. Brace yourself. I
really don’t want to give off the impression that I hate R, but there
are just too many things wrong with it. Again, R’s ultimate problem is
the sum of its small madnesses. No language is perfectly consistent or
without compromises, but R’s choices of compromises and inconsistencies
are utterly unpredictable. I could deal with a handful of problems like
the many that will follow, but this is far more than a handful.</p>
<h2 dir="auto"><a id="user-content-41-lists" aria-hidden="true" href="#41-lists"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.1 Lists</h2>
<p dir="auto">We’ll start gentle. R’s list type is an unavoidable part of the
language, but it’s very strange. As the following examples show, it’s
frequently a special case that you can rarely avoid.</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="https://stackoverflow.com/questions/2050790/" rel="nofollow">https://stackoverflow.com/questions/2050790/</a> does a good job of
demonstrating that the list type is not like anything that another
language would prepare you for. It and its many answers are very
much worth a read.</p>
</li>
<li>
<p dir="auto">Lists are the parent class of data frames, which are mandatory for
anyone who wants to do stats in R, and most of the problems with
lists are inherited by data frames. This makes the oddities of lists
unavoidable.</p>
</li>
<li>
<p dir="auto">Particularly when extracting single elements of lists, you need to
be vigilant for whether R is going to give what you wanted or the
list containing what you wanted. Most of this comes down to learning
the distinction between <code>[</code> and <code>[[</code> and <code>sapply()</code> and <code>lapply()</code>.
It’s not too bad, but it’s a complication.</p>
</li>
<li>
<p dir="auto">Because they won’t attempt to coerce your inputs to a common type
and because, unless you count matrices, you cannot nest vectors
(e.g. <code>c(c(1, 2), c(3, 4))</code> is <code>1:4</code>), lists are what you’re most
likely to use when you want to put two or more vectors in one place.
A lot of your lists will therefore be nested structures. This is not
inherently a problem, but extracting elements from nested structures
is hard, both in a general sense and specifically for R’s lists. R
does little to help you with this. Give
<a href="https://stackoverflow.com/q/9624169/" rel="nofollow">https://stackoverflow.com/q/9624169/</a> and some of its answers a
read. Why does this simple question get seven different answers? Do
we really need libraries, anonymous functions, or knowing that <code>[</code>
is a function, just for what ought to be a commonplace operation?</p>
</li>
<li>
<p dir="auto">Some common R functions do not work properly with lists. Some
functions like <code>sort()</code> and <code>order()</code> will not work at all, even if
you list only contains numbers, and other will work but misbehave.
For example, what do you expect to get from
<code>c(someList, someVectorWithManyElements)</code>? You might expect a list
that is now one item longer. Instead, you get your original list
with every element of the vector appended to it in new slots, i.e. a
list that is <code>length(someVectorWithManyElements)</code> longer.</p>
<div data-snippet-clipboard-copy-content="c(list(1, 2, 3), LETTERS[1:5])
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
## 
## [[4]]
## [1] &#34;A&#34;
## 
## [[5]]
## [1] &#34;B&#34;
## 
## [[6]]
## [1] &#34;C&#34;
## 
## [[7]]
## [1] &#34;D&#34;
## 
## [[8]]
## [1] &#34;E&#34;"><pre>c(<span>list</span>(<span>1</span>, <span>2</span>, <span>3</span>), <span>LETTERS</span>[<span>1</span><span>:</span><span>5</span>])
<span><span>#</span># [[1]]</span>
<span><span>#</span># [1] 1</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span># [1] 2</span>
<span><span>#</span># </span>
<span><span>#</span># [[3]]</span>
<span><span>#</span># [1] 3</span>
<span><span>#</span># </span>
<span><span>#</span># [[4]]</span>
<span><span>#</span># [1] &#34;A&#34;</span>
<span><span>#</span># </span>
<span><span>#</span># [[5]]</span>
<span><span>#</span># [1] &#34;B&#34;</span>
<span><span>#</span># </span>
<span><span>#</span># [[6]]</span>
<span><span>#</span># [1] &#34;C&#34;</span>
<span><span>#</span># </span>
<span><span>#</span># [[7]]</span>
<span><span>#</span># [1] &#34;D&#34;</span>
<span><span>#</span># </span>
<span><span>#</span># [[8]]</span>
<span><span>#</span># [1] &#34;E&#34;</span></pre></div>
<p dir="auto">The same output is given by <code>append()</code>. To get
<code>list(1, 2, 3, LETTERS[1:5])</code>, you must do something like
<code>x &lt;- list(1, 2, 3); x[[4]] &lt;- LETTERS[1:5]</code>.</p>
</li>
<li>
<p dir="auto">Note the use of <code>[[4]]</code> and not <code>[4]</code> above. Using <code>[4]</code> gets you a
warning and the output <code>list(1, 2, 3, &#34;A&#34;)</code>. The <code>[</code> version is
intended for cases like <code>x[4:8] &lt;- LETTERS[1:5]</code>, which gives the
same output as <code>c()</code> did above. The <code>[</code>/<code>[[</code> distinction is a
beginner’s nightmare, as is R’s tendency to give you many ways to do
the same thing.</p>
</li>
<li>
<p dir="auto">Primarily due to the commonality of data frames, R has a handful of
functions that are essentially “<em>foo, but the list version</em>”.
<code>lapply()</code> is the most obvious example.</p>
</li>
<li>
<p dir="auto">A few functions, such as <code>strsplit()</code>, can catch you off guard by
returning a list when there’s no obvious reason why a vector or
matrix wouldn’t have done. For <code>strsplit()</code> in particular, I think
that the idea is that it’s designed to be used on character vectors
of lengths greater than one. However, in my experience, I almost
always want a length-one version. I’d far rather have that function
and <code>lapply()</code>/<code>sapply()</code>/whatever it as need be than have to
constantly use <code>strsplit(&#34;foo&#34;)[[1]]</code>. Similarly, some functions,
e.g. <code>merge()</code>, insist on returning data frames even when the inputs
were matrices. Coercing these unwanted outputs in to what you
actually wanted is often harder than it has any right to be.</p>
</li>
</ul>
<p dir="auto">I think that the ultimate problem with lists is that the right way to
use them is not easy to guess from your knowledge of the language’s
other constructs. If everything in R worked like lists do, or if lists
weren’t so common, then you wouldn’t really mind. As it is, you’ll often
make mistakes with lists and have to guess your way through correcting
them. This isn’t terrible. It’s just annoying.</p>
<h2 dir="auto"><a id="user-content-42-strings" aria-hidden="true" href="#42-strings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.2 Strings</h2>
<p dir="auto">R’s strings suck. The overarching problem is that because there is no
language-level distinction between characters vectors and their
individual elements, R’s vectorization means that almost everything that
you want to do with a string needs to be done by knowing the right
function to use (rather than by using R’s ordinary syntax). I find that
the correct functions can be hard to find and use. Although it doesn’t
fix many of these issues, the common sentiment of “<em>just use
<code>stringr</code>/<code>stringi</code></em>” is difficult to dismiss.</p>
<ul dir="auto">
<li>
<p dir="auto">Technically, R doesn’t even have a type for strings. You would want
a string to be a vector of characters, but R’s characters are
already vectors, so R can’t have a normal string type. Despite this,
the documentation often uses the word “<em>string</em>”. <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Vector-objects" rel="nofollow">The language
definition will tell you how to make sense of
that</a>,
but I don’t think that information is found anywhere in the sorts of
documentation that you’ll find in your IDE.</p>
</li>
<li>
<p dir="auto">It’s a pain to have to account for how R has two types of empty
string: <code>character(0)</code> and <code>&#34;&#34;</code>.</p>
</li>
<li>
<p dir="auto">Character vectors aren’t trivially split in to the characters that
make each element. For example, <code>&#34;dog&#34;[1]</code> is <code>&#34;dog&#34;</code> because
<code>&#34;dog&#34;</code> is a vector of length one. The idiomatic way to split up a
string in to its characters – <code>strsplit(&#34;dog&#34;, &#34;&#34;)</code> – returns a
list, so rather than just getting the <code>&#34;d&#34;</code> from <code>&#34;dog&#34;</code> by doing
<code>&#34;dog&#34;[1]</code>, you have to do something like
<code>unlist(strsplit(&#34;dog&#34;, &#34;&#34;))[1]</code> or <code>strsplit(&#34;dog&#34;, &#34;&#34;)[[1]][1]</code>.
The <code>substr()</code> function can serve you better for trivial jobs, but
you often need <code>strsplit()</code>.</p>
</li>
<li>
<p dir="auto">Here’s a challenge: Find the function that checks if <code>&#34;es&#34;</code> is in
<code>&#34;test&#34;</code>. You’ll be on for a while.</p>
</li>
<li>
<p dir="auto">Many of R’s best functions for handling strings expect you to know
regex and are all documented in the same place (grep {base}, titled
“<em>Pattern Matching and Replacement</em>”). If you don’t know regex –
exactly what I’d expect of R’s target audience – then you’re thrice
damned:</p>
<ul dir="auto">
<li>Firstly, you’re going to have a very hard time figuring out that
the functions in <code>?grep</code> are probably what you need. A glance at
their documentation suggests that they’re difficult materials
and therefore presumably not required for your task.</li>
<li>Secondly, you’re going to struggle to find the correct function
in that documentation because the information that you need is
surrounded by concepts that are not familiar to you. This
reinforces your initial impression that you’re in the wrong
place, letting you stumble over the first point again.</li>
<li>Thirdly and finally, the function names will be meaningless to
you – “<em>what the heck does <code>regexpr()</code> mean and how does it
relate to <code>regexec()</code>?</em>” – leaving you with no straws to clutch
at.</li>
</ul>
</li>
<li>
<p dir="auto">Even once you have found the right function for the job, it can be
tough to use. Compare the <code>stringr</code> answer to <a href="https://stackoverflow.com/questions/12427385/" rel="nofollow">this
question</a> to the base
R answers. Or better yet, use <code>gregexpr()</code> or <code>gregexec()</code> for any
task and then tell me with a straight face that you both understand
their outputs and find them easy to work with.</p>
<div data-snippet-clipboard-copy-content="gregexpr(&#34;a&#34;, c(&#34;greatgreat&#34;, &#34;magic&#34;, &#34;not&#34;))
## [[1]]
## [1] 4 9
## attr(,&#34;match.length&#34;)
## [1] 1 1
## attr(,&#34;index.type&#34;)
## [1] &#34;chars&#34;
## attr(,&#34;useBytes&#34;)
## [1] TRUE
## 
## [[2]]
## [1] 2
## attr(,&#34;match.length&#34;)
## [1] 1
## attr(,&#34;index.type&#34;)
## [1] &#34;chars&#34;
## attr(,&#34;useBytes&#34;)
## [1] TRUE
## 
## [[3]]
## [1] -1
## attr(,&#34;match.length&#34;)
## [1] -1
## attr(,&#34;index.type&#34;)
## [1] &#34;chars&#34;
## attr(,&#34;useBytes&#34;)
## [1] TRUE"><pre>gregexpr(<span><span>&#34;</span>a<span>&#34;</span></span>, c(<span><span>&#34;</span>greatgreat<span>&#34;</span></span>, <span><span>&#34;</span>magic<span>&#34;</span></span>, <span><span>&#34;</span>not<span>&#34;</span></span>))
<span><span>#</span># [[1]]</span>
<span><span>#</span># [1] 4 9</span>
<span><span>#</span># attr(,&#34;match.length&#34;)</span>
<span><span>#</span># [1] 1 1</span>
<span><span>#</span># attr(,&#34;index.type&#34;)</span>
<span><span>#</span># [1] &#34;chars&#34;</span>
<span><span>#</span># attr(,&#34;useBytes&#34;)</span>
<span><span>#</span># [1] TRUE</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span># [1] 2</span>
<span><span>#</span># attr(,&#34;match.length&#34;)</span>
<span><span>#</span># [1] 1</span>
<span><span>#</span># attr(,&#34;index.type&#34;)</span>
<span><span>#</span># [1] &#34;chars&#34;</span>
<span><span>#</span># attr(,&#34;useBytes&#34;)</span>
<span><span>#</span># [1] TRUE</span>
<span><span>#</span># </span>
<span><span>#</span># [[3]]</span>
<span><span>#</span># [1] -1</span>
<span><span>#</span># attr(,&#34;match.length&#34;)</span>
<span><span>#</span># [1] -1</span>
<span><span>#</span># attr(,&#34;index.type&#34;)</span>
<span><span>#</span># [1] &#34;chars&#34;</span>
<span><span>#</span># attr(,&#34;useBytes&#34;)</span>
<span><span>#</span># [1] TRUE</span></pre></div>
</li>
<li>
<p dir="auto">The most useful function for printing strings seem to
counter-intuitively be <code>cat()</code> rather than <code>print()</code> or <code>format()</code>.
For example, <code>print()</code> ignores your <code>\n</code> characters. The only time
where <code>print()</code> comes in really handy for string-related stuff is
when your inputs are either quoted or lists. In both cases,
<code>print()</code> accepts these but <code>cat()</code> does not. Without significant
coercion (mostly <code>deparse()</code>), I’ve yet to find a way to mix <code>\n</code>
with quoted input. Most of my attempts to do anything clever that
mixes printing and lists end with me giving up and using a data
frame.</p>
</li>
<li>
<p dir="auto"><a href="https://stackoverflow.com/q/4730551/" rel="nofollow">Without defining a new
operator</a>, you can’t add
strings in the way that other languages have taught you to,
i.e. <code>&#34;a&#34;+&#34;b&#34;</code>. <a href="https://www.stat.math.ethz.ch/pipermail/r-devel/2006-August/039004.html" rel="nofollow">John Chambers is against fixing
this</a>.
I’m not convinced that he’s wrong, but it is annoying.</p>
</li>
<li>
<p dir="auto">If you’re converting numbers to characters, or using a function like
<code>nchar()</code> that’s meant for characters but accepts numbers, a
shocking number of things will break when your numbers get big
enough for R to automatically start using scientific notation.</p>
<div data-snippet-clipboard-copy-content="nchar(10000)
## [1] 5
nchar(100000)
## [1] 5
a &lt;- 10000
nchar(a) == nchar(a * 100)
## [1] TRUE"><pre>nchar(<span>10000</span>)
<span><span>#</span># [1] 5</span>
nchar(<span>100000</span>)
<span><span>#</span># [1] 5</span>
<span>a</span> <span>&lt;-</span> <span>10000</span>
nchar(<span>a</span>) <span>==</span> nchar(<span>a</span> <span>*</span> <span>100</span>)
<span><span>#</span># [1] TRUE</span></pre></div>
<p dir="auto">You’re supposed to use <code>format()</code> to coerce these sorts of numbers
in to characters, but you won’t know about that until something
breaks and <code>nchar()</code>’s documentation doesn’t seem to mention it (try
<code>?as.character</code>). The <code>format()</code> function also has a habit of
requiring you to set the right flags to get what you want.
<code>trim = TRUE</code> comes up a lot. If you’re using a package or
unfamiliar function, you’re forced to check to see if the author
dealt with these issues before you use their work. I’d rather just
have a generic <code>nchar()</code>-like function that does what I mean. Would
you believe that <code>nchar()</code>’s documentation says it’s a generic? It’s
not lying and it later tells you that <code>nchar()</code> coerces
non-characters to characters, but R sure does know how to mess with
your expectations.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-43-variable-manipulation" aria-hidden="true" href="#43-variable-manipulation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.3 Variable Manipulation</h2>
<p dir="auto">R has some problems with its general facilities for manipulating
variables. Some of the following will be seen <strong>every</strong> time that you
use R.</p>
<ul dir="auto">
<li>
<p dir="auto">It lacks both <code>i++</code> and <code>x += i</code>. It also lacks anything that would
make these unnecessary, such as Python’s <code>enumerate</code>.</p>
</li>
<li>
<p dir="auto">One day, you’ll be tripped up by R’s hierarchy of how it likes to
simplify mixed types outside of lists. For example, <code>c(2, &#34;2&#34;)</code>
returns <code>c(&#34;2&#34;, &#34;2&#34;)</code>. <a href="https://adv-r.hadley.nz/vectors-chap.html#exercises-4" rel="nofollow">An exercise from <em>Advanced
R</em></a> presents
a few troubling cases:</p>
<ul dir="auto">
<li>“<em>Why is <code>1 == &#34;1&#34;</code> true?</em>”</li>
<li>“<em>Why is <code>-1 &lt; FALSE</code> true?</em>”</li>
<li>“<em>Why is <code>&#34;one&#34; &lt; 2</code> false?</em>”.</li>
</ul>
</li>
<li>
<p dir="auto">To get complete information about the typing and structure of
something, you will almost certainly need to call several functions.
For example, do any of the following tell you everything about <code>x</code>?</p>
<div data-snippet-clipboard-copy-content="x &lt;- diag(3)
x
##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1
typeof(x)
## [1] &#34;double&#34;
class(x)
## [1] &#34;matrix&#34; &#34;array&#34;
attributes(x)
## $dim
## [1] 3 3
str(x)
##  num [1:3, 1:3] 1 0 0 0 1 0 0 0 1"><pre><span>x</span> <span>&lt;-</span> diag(<span>3</span>)
<span>x</span>
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    0    0</span>
<span><span>#</span># [2,]    0    1    0</span>
<span><span>#</span># [3,]    0    0    1</span>
typeof(<span>x</span>)
<span><span>#</span># [1] &#34;double&#34;</span>
class(<span>x</span>)
<span><span>#</span># [1] &#34;matrix&#34; &#34;array&#34;</span>
attributes(<span>x</span>)
<span><span>#</span># $dim</span>
<span><span>#</span># [1] 3 3</span>
str(<span>x</span>)
<span><span>#</span>#  num [1:3, 1:3] 1 0 0 0 1 0 0 0 1</span></pre></div>
</li>
<li>
<p dir="auto">R likes to use “<em>double</em>” and “<em>numeric</em>” almost interchangeably.
You’ve just seen one such example (<code>str(x)</code> vs <code>typeof(x)</code>).</p>
</li>
<li>
<p dir="auto">Integers are almost second class. <code>?integer</code> suggests that they’re
mostly for talking to other languages, but the problem seems to go
deeper than that. It’s as if R tries to avoid integers unless you
tell it not to. For example, <code>4</code> is a double, not an integer. Why?
Unless you’re very careful, any integer that you give to R will
eventually be coerced in to a double.</p>
</li>
<li>
<p dir="auto">I don’t like how there’s no trivial way to express a condition like
1 &lt; x &lt; 5. In a maths language, I’d expect that exact syntax
to work. There’s probably a good reason why it doesn’t, and it’s not
at all hard to build an equivalent condition, but it still annoys me
from time to time. I suspect that the <code>&lt;-</code> syntax for variable
assignment is to blame.</p>
</li>
<li>
<p dir="auto">The distinction between <code>&lt;-</code> and <code>=</code> is something that you’d have to
look up. I’d try to explain the difference, but from what I’ve
gathered, the difference only matters when using <code>=</code> rather than
<code>&lt;-</code> causes bugs. Like most R users, I’ve picked up the habit of
“<em>use <code>=</code> only for the arguments of functions and use <code>&lt;-</code>
everywhere else</em>”.</p>
</li>
<li>
<p dir="auto"><code>&lt;-</code> was designed for keyboards that don’t exist any more. It’s a
pain to type on a modern system.</p>
</li>
<li>
<p dir="auto">The day that you accidentally have <code>&lt;</code> rather than <code>&lt;-</code> without it
throwing an error will be an awful one. The reverse can also happen.
For example, there are two things that you could have meant by
<code>if(x&lt;-2)</code>.</p>
</li>
<li>
<p dir="auto"><code>Y&lt;--2</code> is a terrible way to have to say “<em>set <code>Y</code> to be equal to
negative two</em>”. <code>Y&lt;&lt;--2</code> is even worse.</p>
</li>
<li>
<p dir="auto"><code>&lt;&lt;-</code> is probably the only good thing about the convention of using
<code>&lt;-</code>, but it’s only useful if you either know what a closure is and
have reason to use one or if you’re some sort of guru with R’s
first-class environments. You can sometimes use <code>&lt;&lt;-</code> to great
effect without deliberately writing a closure, but it always feels
like a hack because you’re implicitly using one. For example,
<code>replicate(5, x &lt;- x+1)</code> and <code>replicate(5, x &lt;&lt;- x+1)</code> are very
different, with the <code>&lt;&lt;-</code> case being a very cool trick,</p>
<div data-snippet-clipboard-copy-content="x &lt;- 1
replicate(5, x &lt;- x+1)
## [1] 2 2 2 2 2
x
## [1] 1
replicate(5, x &lt;&lt;- x+1)
## [1] 2 3 4 5 6
x
## [1] 6"><pre><span>x</span> <span>&lt;-</span> <span>1</span>
replicate(<span>5</span>, <span>x</span> <span>&lt;-</span> <span>x</span><span>+</span><span>1</span>)
<span><span>#</span># [1] 2 2 2 2 2</span>
<span>x</span>
<span><span>#</span># [1] 1</span>
replicate(<span>5</span>, <span>x</span> <span>&lt;&lt;-</span> <span>x</span><span>+</span><span>1</span>)
<span><span>#</span># [1] 2 3 4 5 6</span>
<span>x</span>
<span><span>#</span># [1] 6</span></pre></div>
<p dir="auto">but it only works because <code>replicate()</code> quietly wraps its second
argument in an anonymous function.</p>
</li>
<li>
<p dir="auto">The idiomatic way to add an item to the end of a collection is
<code>a[length(a) + 1] &lt;- &#34;foo&#34;</code>. This is rather verbose. It’s also <a href="#41-lists">a
bit unpredictable when adding a collection to a list</a>.</p>
</li>
<li>
<p dir="auto">A quote from <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Argument-evaluation" rel="nofollow">the language
definition</a>:
“<em>supplied arguments and default arguments are treated
differently</em>”. This usually doesn’t trip you up, but you’re certain
to discover it on the first day that you use <code>eval()</code>. It has
<code>parent.frame()</code> as one of its default arguments, but calling
<code>eval()</code> with that argument supplied manually will produce different
results than what you get from letting it be supplied by default.</p>
<div data-snippet-clipboard-copy-content="x &lt;- 1
(function(x) eval(quote(x + 1)))(100)
## [1] 101
(function(x) eval(quote(x + 1), envir = parent.frame()))(100)
## [1] 2"><pre><span>x</span> <span>&lt;-</span> <span>1</span>
(<span>function</span>(<span>x</span>) eval(quote(<span>x</span> <span>+</span> <span>1</span>)))(<span>100</span>)
<span><span>#</span># [1] 101</span>
(<span>function</span>(<span>x</span>) eval(quote(<span>x</span> <span>+</span> <span>1</span>), <span>envir</span> <span>=</span> parent.frame()))(<span>100</span>)
<span><span>#</span># [1] 2</span></pre></div>
<p dir="auto">An easier-to-discover example can be found in section 8.3.19 of
<a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a>.</p>
</li>
<li>
<p dir="auto">Variable names can be partially matched. See
<a href="https://rosettacode.org/wiki/Named_parameters\#R" rel="nofollow"></a><a href="https://rosettacode.org/wiki/Named_parameters%5C#R" rel="nofollow">https://rosettacode.org/wiki/Named_parameters\#R</a>
for some examples. I can’t tell if it’s disgusting or awesome, but
it’s definitely dangerous. If I called <code>f(n = 1)</code>, I probably didn’t
mean <code>f(nukeEarth = 1)</code>! At least it throws an error if it fails to
partially match (e.g. if there were multiple valid partial matches).
More on that <a href="#dangers-of-">when I cover the <code>$</code> operator</a>, which
usually has the same issue.</p>
</li>
<li>
<p dir="auto">The <code>...</code> argument doesn’t make its users throw errors when they’ve
been called with arguments that they don’t have or, even worse,
those that they do have, but you misspelled. <em>Advanced R</em> has a
great example in <a href="https://adv-r.hadley.nz/functions.html#exercises-17" rel="nofollow">its Functions
chapter</a>. Would
you have guessed that <code>sum(1, 2, 3, na.omit = TRUE)</code> returns <code>7</code>,
not <code>6</code>? Similarly, <a href="https://adv-r.hadley.nz/functionals.html#argument-names" rel="nofollow">the Functionals
chapter</a>
shows how this can lead to some baffling errors and what strange
things you have to do help your users avoid them.</p>
</li>
<li>
<p dir="auto">For many other examples, see section 8 of <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a>.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-44-switch" aria-hidden="true" href="#44-switch"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.4 Switch</h2>
<p dir="auto">R has some strange ideas about switch statements:</p>
<ul dir="auto">
<li>
<p dir="auto">It’s not a special form of any kind; Its syntax is that of a normal
function call. If I’m being consistent in my formatting, then I
should be calling it “<em>R’s <code>switch()</code> function</em>”.</p>
</li>
<li>
<p dir="auto">It’s only <a href="https://github.com/wch/r-source/blob/trunk/src/main/builtin.c#L1009">about 70 lines of C
code</a>,
suggesting that it can’t be all that optimised.</p>
</li>
<li>
<p dir="auto">R doesn’t have one switch statement, it has two. One where it
switches on a numeric input and another for characters. The numeric
version makes the strange assumption that the first argument
(i.e. the argument being switched on) can be safely translated to a
set of cases that must follow an ordering like “<em>if input is 1, do
the first option, if 2, do the second…</em>”. There is no flexibility
like letting you start at 2, having jumps higher than 1, or letting
you supply a default case. Reread that last one: R has a switch
without defaults! It’s frankly the worst switch that I’ve ever seen.
The other version, the one that switches on characters, is more
sensible. I’d give examples, but I don’t know how to demonstrate a
non-feature.</p>
</li>
<li>
<p dir="auto">As is a trend in R, both versions of switch are capable of silently
doing nothing. For example, these do nothing:</p>
<div data-snippet-clipboard-copy-content="switch(3, &#34;foo&#34;, &#34;bar&#34;)
switch(&#34;c&#34;, a = &#34;foo&#34;, b = &#34;bar&#34;)
print(switch(&#34;c&#34;, a = &#34;foo&#34;, b = &#34;bar&#34;)) #Showing off the return value.
## NULL"><pre><span>switch</span>(<span>3</span>, <span><span>&#34;</span>foo<span>&#34;</span></span>, <span><span>&#34;</span>bar<span>&#34;</span></span>)
<span>switch</span>(<span><span>&#34;</span>c<span>&#34;</span></span>, <span>a</span> <span>=</span> <span><span>&#34;</span>foo<span>&#34;</span></span>, <span>b</span> <span>=</span> <span><span>&#34;</span>bar<span>&#34;</span></span>)
print(<span>switch</span>(<span><span>&#34;</span>c<span>&#34;</span></span>, <span>a</span> <span>=</span> <span><span>&#34;</span>foo<span>&#34;</span></span>, <span>b</span> <span>=</span> <span><span>&#34;</span>bar<span>&#34;</span></span>)) <span><span>#</span>Showing off the return value.</span>
<span><span>#</span># NULL</span></pre></div>
<p dir="auto">and they do it silently, returning <code>NULL</code>. I’d expect a warning
message informing me of this, but there is no such thing. If you
want that behaviour, then you have to write it yourself by ending
each statement with a final unnamed branch that throws an error,
e.g. <code>switch(&#34;c&#34;, a = &#34;foo&#34;, b = &#34;bar&#34;, stop(&#34;Invalid input&#34;))</code> or
<code>switch(&#34;c&#34;, a = &#34;foo&#34;, b = &#34;bar&#34;, warning(&#34;Invalid input&#34;))</code>. Of
course, you can’t do that with the numeric version, because R has a
switch without defaults.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-45-subsetting" aria-hidden="true" href="#45-subsetting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.5 Subsetting</h2>
<p dir="auto">Now for the nasty stuff. R’s rules for selecting elements, deleting
elements, and any other sort of subsetting require mastery. They’re
extremely powerful once mastered, but until that point, they make using
R a nightmare. For a stats language, this is unforgivable. Before
mentioning any points that are best put in their own subsections, I’ll
cover some more general points:</p>
<ul dir="auto">
<li>
<p dir="auto">You never quite know whether you want to use <code>x</code>, the name of <code>x</code>,
or a function like <code>subset()</code>, <code>which()</code>, <code>Find()</code>, <code>Position()</code>, or
<code>match()</code>. R’s operators make this even more of mess. You either
want <code>$</code>, <code>[</code>, <code>@</code> or even <code>[[</code>. Making the wrong choice of <code>[x]</code>,
<code>[x,]</code>, <code>[,x]</code> or <code>[[x]]</code> is another frequent source of error. You
will get used to it eventually, but your hair will not survive the
journey. <a href="https://www.talyarkoni.org/blog/2012/06/08/r-the-master-troll-of-statistical-languages/" rel="nofollow">Similar
stories</a>
can be found about the apply family.</p>
</li>
<li>
<p dir="auto">The <code>[[</code> operator has been accused of inconsistent behaviour.
<a href="https://adv-r.hadley.nz/subsetting.html#subsetting-oob" rel="nofollow"><em>Advanced R</em> covers this better than I
could</a>. The
short version is that it sometimes returns <code>NULL</code> and other times
throws an error. Personally, I’ve never noticed these because I’ve
rarely tried to subset <code>NULL</code> and I don’t see any reason why you
would use <code>[[</code> on an atomic vector. As far as I know, <code>[</code> does the
same job. The only exception that I can think of is if your atomic
vector was named. For example:</p>
<div data-snippet-clipboard-copy-content="a &lt;- c(Alice = 1, Bob = 2)
a[&#34;Alice&#34;]
## Alice 
##     1
a[[&#34;Alice&#34;]]
## [1] 1"><pre><span>a</span> <span>&lt;-</span> c(<span>Alice</span> <span>=</span> <span>1</span>, <span>Bob</span> <span>=</span> <span>2</span>)
<span>a</span>[<span><span>&#34;</span>Alice<span>&#34;</span></span>]
<span><span>#</span># Alice </span>
<span><span>#</span>#     1</span>
<span>a</span>[[<span><span>&#34;</span>Alice<span>&#34;</span></span>]]
<span><span>#</span># [1] 1</span></pre></div>
</li>
<li>
<p dir="auto">When doing variable assignment on anything more than
one-dimensional, <code>object</code> and <code>object[]</code> behave differently when you
try to assign variables to them. Compare:</p>
<div data-snippet-clipboard-copy-content="(c &lt;- b &lt;- diag(3))
##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1
b[] &lt;- 5
c &lt;- 5
b
##      [,1] [,2] [,3]
## [1,]    5    5    5
## [2,]    5    5    5
## [3,]    5    5    5
c
## [1] 5"><pre>(<span>c</span> <span>&lt;-</span> <span>b</span> <span>&lt;-</span> diag(<span>3</span>))
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    0    0</span>
<span><span>#</span># [2,]    0    1    0</span>
<span><span>#</span># [3,]    0    0    1</span>
<span>b</span>[] <span>&lt;-</span> <span>5</span>
<span>c</span> <span>&lt;-</span> <span>5</span>
<span>b</span>
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    5    5    5</span>
<span><span>#</span># [2,]    5    5    5</span>
<span><span>#</span># [3,]    5    5    5</span>
<span>c</span>
<span><span>#</span># [1] 5</span></pre></div>
<p dir="auto">This kind of makes sense, but it will trip you up.</p>
</li>
<li>
<p dir="auto">The syntax for deleting elements of collections by index can be
rather verbose. You can’t just pop out an element, you have to write
<code>vect &lt;- vect[-index]</code> or <code>vect &lt;- vect[-c(index, nextIndex, ...)]</code>.</p>
</li>
<li>
<p dir="auto">R is 1-indexed, but accessing element 0 of a vector gives an empty
vector rather than an error. This probably makes sense considering
that index -1 deletes element 1, but it’s a clear source of major
errors.</p>
</li>
<li>
<p dir="auto">With the sole exception of environments, every named object in R is
allowed to have duplicate names. I guarantee that will one day break
your subsetting (e.g. see section 8.1.19 of <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a>).
Fortunately, the constructor for data frames has a <code>check.names</code>
argument that corrects duplicates by default. Unfortunately, it does
this silently, so you may not notice that some of your column names
have been changed. Another oddity is that many functions that work
on data frames, most notably <code>[</code>, will silently correct duplicated
names even if you told the original data frame to not do so. Why
even let me have duplicated names if you’re going to make it so hard
to keep them?</p>
<div data-snippet-clipboard-copy-content="data.frame(x = 1:3, x = 11:13)
##   x x.1
## 1 1  11
## 2 2  12
## 3 3  13
#Notice the x.1? You didn&#39;t ask for that. To get x twice, you need this:
correctNames &lt;- data.frame(x = 1:3, x = 11:13, check.names = FALSE)
correctNames
##   x  x
## 1 1 11
## 2 2 12
## 3 3 13
correctNames[1:3, ]#As expected.
##   x  x
## 1 1 11
## 2 2 12
## 3 3 13
correctNames[1:2]#What?
##   x x.1
## 1 1  11
## 2 2  12
## 3 3  13"><pre><span>data.frame</span>(<span>x</span> <span>=</span> <span>1</span><span>:</span><span>3</span>, <span>x</span> <span>=</span> <span>11</span><span>:</span><span>13</span>)
<span><span>#</span>#   x x.1</span>
<span><span>#</span># 1 1  11</span>
<span><span>#</span># 2 2  12</span>
<span><span>#</span># 3 3  13</span>
<span><span>#</span>Notice the x.1? You didn&#39;t ask for that. To get x twice, you need this:</span>
<span>correctNames</span> <span>&lt;-</span> <span>data.frame</span>(<span>x</span> <span>=</span> <span>1</span><span>:</span><span>3</span>, <span>x</span> <span>=</span> <span>11</span><span>:</span><span>13</span>, <span>check.names</span> <span>=</span> <span>FALSE</span>)
<span>correctNames</span>
<span><span>#</span>#   x  x</span>
<span><span>#</span># 1 1 11</span>
<span><span>#</span># 2 2 12</span>
<span><span>#</span># 3 3 13</span>
<span>correctNames</span>[<span>1</span><span>:</span><span>3</span>, ]<span><span>#</span>As expected.</span>
<span><span>#</span>#   x  x</span>
<span><span>#</span># 1 1 11</span>
<span><span>#</span># 2 2 12</span>
<span><span>#</span># 3 3 13</span>
<span>correctNames</span>[<span>1</span><span>:</span><span>2</span>]<span><span>#</span>What?</span>
<span><span>#</span>#   x x.1</span>
<span><span>#</span># 1 1  11</span>
<span><span>#</span># 2 2  12</span>
<span><span>#</span># 3 3  13</span></pre></div>
<p dir="auto">Not only is this behaviour inconsistent, it is <strong>silent</strong>; No
warnings or errors are thrown by the above code. Tibbles are much
better about this:</p>
<div data-snippet-clipboard-copy-content="library(tibble)
#We can&#39;t repeat our original first line, because tibble(x = 1:5, x = 11:15) throws an error:
## &gt; tibble(x = 1:5, x = 11:15)
## Error: Column name `x` must not be duplicated.
## Use .name_repair to specify repair.
#We follow the error&#39;s advice.
#The .name_repair argument provides a few useful options, so we must pick one.
correctNames &lt;- tibble(x = 1:5, x = 11:15, .name_repair = &#34;minimal&#34;)
correctNames
## # A tibble: 5 × 2
##       x     x
##   &lt;int&gt; &lt;int&gt;
## 1     1    11
## 2     2    12
## 3     3    13
## 4     4    14
## 5     5    15
correctNames[1:3,]#Good
## # A tibble: 3 × 2
##       x     x
##   &lt;int&gt; &lt;int&gt;
## 1     1    11
## 2     2    12
## 3     3    13
correctNames[1:2]#Still good!
## # A tibble: 5 × 2
##       x     x
##   &lt;int&gt; &lt;int&gt;
## 1     1    11
## 2     2    12
## 3     3    13
## 4     4    14
## 5     5    15"><pre>library(<span>tibble</span>)
<span><span>#</span>We can&#39;t repeat our original first line, because tibble(x = 1:5, x = 11:15) throws an error:</span>
<span><span>#</span># &gt; tibble(x = 1:5, x = 11:15)</span>
<span><span>#</span># Error: Column name `x` must not be duplicated.</span>
<span><span>#</span># Use .name_repair to specify repair.</span>
<span><span>#</span>We follow the error&#39;s advice.</span>
<span><span>#</span>The .name_repair argument provides a few useful options, so we must pick one.</span>
<span>correctNames</span> <span>&lt;-</span> tibble(<span>x</span> <span>=</span> <span>1</span><span>:</span><span>5</span>, <span>x</span> <span>=</span> <span>11</span><span>:</span><span>15</span>, <span>.name_repair</span> <span>=</span> <span><span>&#34;</span>minimal<span>&#34;</span></span>)
<span>correctNames</span>
<span><span>#</span># # A tibble: 5 × 2</span>
<span><span>#</span>#       x     x</span>
<span><span>#</span>#   &lt;int&gt; &lt;int&gt;</span>
<span><span>#</span># 1     1    11</span>
<span><span>#</span># 2     2    12</span>
<span><span>#</span># 3     3    13</span>
<span><span>#</span># 4     4    14</span>
<span><span>#</span># 5     5    15</span>
<span>correctNames</span>[<span>1</span><span>:</span><span>3</span>,]<span><span>#</span>Good</span>
<span><span>#</span># # A tibble: 3 × 2</span>
<span><span>#</span>#       x     x</span>
<span><span>#</span>#   &lt;int&gt; &lt;int&gt;</span>
<span><span>#</span># 1     1    11</span>
<span><span>#</span># 2     2    12</span>
<span><span>#</span># 3     3    13</span>
<span>correctNames</span>[<span>1</span><span>:</span><span>2</span>]<span><span>#</span>Still good!</span>
<span><span>#</span># # A tibble: 5 × 2</span>
<span><span>#</span>#       x     x</span>
<span><span>#</span>#   &lt;int&gt; &lt;int&gt;</span>
<span><span>#</span># 1     1    11</span>
<span><span>#</span># 2     2    12</span>
<span><span>#</span># 3     3    13</span>
<span><span>#</span># 4     4    14</span>
<span><span>#</span># 5     5    15</span></pre></div>
<p dir="auto">This may seem like an isolated example, but there’s more to this
than I’m really letting on. A related example is that the
<code>check.names</code> argument in <code>data.frame()</code> is very insistent on
silently doing things, even to the point of overruling arguments
that you explicitly set. For example, I’m pretty sure that these
column names aren’t what I asked for.</p>
<div data-snippet-clipboard-copy-content=" as.data.frame(list(1, 2, 3, 4, 5), col.names = paste(&#34;foo=bar&#34;, 6:10))
##   foo.bar.6 foo.bar.7 foo.bar.8 foo.bar.9 foo.bar.10
## 1         1         2         3         4          5
 as.data.frame(list(1, 2, 3, 4, 5), col.names = paste(&#34;foo=bar&#34;, 6:10), check.names = FALSE)
##   foo=bar 6 foo=bar 7 foo=bar 8 foo=bar 9 foo=bar 10
## 1         1         2         3         4          5"><pre> as.data.frame(<span>list</span>(<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>), <span>col.names</span> <span>=</span> paste(<span><span>&#34;</span>foo=bar<span>&#34;</span></span>, <span>6</span><span>:</span><span>10</span>))
<span><span>#</span>#   foo.bar.6 foo.bar.7 foo.bar.8 foo.bar.9 foo.bar.10</span>
<span><span>#</span># 1         1         2         3         4          5</span>
 as.data.frame(<span>list</span>(<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>), <span>col.names</span> <span>=</span> paste(<span><span>&#34;</span>foo=bar<span>&#34;</span></span>, <span>6</span><span>:</span><span>10</span>), <span>check.names</span> <span>=</span> <span>FALSE</span>)
<span><span>#</span>#   foo=bar 6 foo=bar 7 foo=bar 8 foo=bar 9 foo=bar 10</span>
<span><span>#</span># 1         1         2         3         4          5</span></pre></div>
<p dir="auto">As far as I can tell, it’s doing this in order to make the names
suitable for subsetting – subsetting with non-unique or
non-syntactic column names could be a pain – but the decision to not
inform the user of this correction is baffling. Even if you’re
fortunate enough to have noticed the silent change to your data, the
lack of a warning message will leave you with no idea how to correct
it. You could perhaps argue that duplicated names are the user’s
fault and they deserve what they get, but that argument falls apart
for non-syntactic names. Who hasn’t put a space or an equals sign in
their column names before? Mind, tibbles aren’t much better when it
comes to non-syntactic names. Neither <code>tibble(&#34;Example col&#34; = 4)</code>
nor <code>data.frame(&#34;Example col&#34; = 4)</code> warn you of the name change.</p>
</li>
<li>
<p dir="auto">For what I believe to be memory reasons, objects of greater than one
dimension are stored in column order rather than row order. Quick,
what output do you expect from <code>matrix(1:9, 3, 3)</code>?</p>
<div data-snippet-clipboard-copy-content="matrix(1:9, 3, 3)
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9"><pre><span>matrix</span>(<span>1</span><span>:</span><span>9</span>, <span>3</span>, <span>3</span>)
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    4    7</span>
<span><span>#</span># [2,]    2    5    8</span>
<span><span>#</span># [3,]    3    6    9</span></pre></div>
<p dir="auto">This gives us a matrix with first row <code>c(1, 4, 7)</code>. This goes
against the usual English convention of reading from left to right.
It is also inconsistent with functions like <code>apply()</code>, where
<code>MARGIN = 1</code> corresponds to their by-row version and <code>MARGIN = 2</code> is
for by-column (if R privileges columns, shouldn’t they be the <code>= 1</code>
case?). This means that you can never really be sure if R is working
in column order or row order. This is bad enough on its own, but it
can also be a source of subtle bugs when working with matrices. Many
mathematical functions don’t see any difference between a matrix and
its transpose.</p>
</li>
<li>
<p dir="auto">There is no nice way to access the last element of a vector. Of all
things, the idiomatic way is <code>x[length(x)]</code>. The only good part of
this is that <code>x[length(x) - 0:n]</code> is a very nice way to get the last
<code>n + 1</code> elements. You could use <code>tail()</code>, but Stack Overflow tells
me it’s very slow.</p>
</li>
<li>
<p dir="auto">The <code>sort()</code> and <code>order()</code> functions are the main ways to sort stuff
in R. If you’re trying to sort some data by a particular variable,
then R counter-intuitively wants you to use <code>order()</code> rather than
<code>sort()</code>. The syntax for <code>order()</code> doesn’t help matters. It returns
a permutation, so rather than <code>order(x, params)</code>, you will want
<code>x[order(params),]</code>. My only explanation for this is that it makes
<code>order()</code> much easier to use with the <code>with()</code> function. For
example, <code>data[with(data, order(col1, col2, col3)),]</code> is perhaps
more pleasant to write than the hypothetical
<code>order(data, data$col1, data$col2, data$col3)</code>. The Tidyverse’s
<code>dplyr</code> solves these problems:
<code>dplyr::arrange(data, col1, col2, col3)</code> does what you think. I’d
much rather use <code>arrange(mtcars, cyl, disp)</code> than
<code>mtcars[with(mtcars, order(cyl, disp)),]</code>.</p>
</li>
<li>
<p dir="auto">The <code>order()</code> case above illustrates another frequent annoyance with
subsetting. Rather than asking for what you want, you often need to
generate a vector that matches up to it. A collection of booleans (R
calls these “<em>logical vectors</em>”) is one of the most common ways to
do this, with <code>duplicated()</code> being a typical example.</p>
<div data-snippet-clipboard-copy-content="head(Nile)
## [1] 1120 1160  963 1210 1160 1160
duplicated(head(Nile))
## [1] FALSE FALSE FALSE FALSE  TRUE  TRUE
head(Nile)[duplicated(head(Nile))]
## [1] 1160 1160"><pre>head(<span>Nile</span>)
<span><span>#</span># [1] 1120 1160  963 1210 1160 1160</span>
duplicated(head(<span>Nile</span>))
<span><span>#</span># [1] FALSE FALSE FALSE FALSE  TRUE  TRUE</span>
head(<span>Nile</span>)[duplicated(head(<span>Nile</span>))]
<span><span>#</span># [1] 1160 1160</span></pre></div>
<p dir="auto">This means that you will usually be asking for <code>items[bools]</code> (and
maybe <code>[,bools]</code> or <code>[bools,]</code>…) in order to get the items that you
want. There is great power in being able to do this, but having to
do it is annoying and can catch you off guard. For example, what do
you expect <code>lower.tri()</code> to return when called on a matrix? What you
wanted from <code>lower.tri(mat)</code> is probably what you get from
<code>mat[lower.tri(mat)]</code>. Also, don’t expect a helpful error message if
your construction of <code>bools</code> is wrong. As I’ll discuss later on,
<a href="#46-vectorization-again">the vector recycling</a> rules will often
make an incorrect construction give sensible-looking output.</p>
</li>
<li>
<p dir="auto">For reasons that I cannot explain, <code>aperm(x, params)</code> is the correct
syntax, not <code>x[aperm(params)]</code> or anything like it. I think that
it’s trying to be consistent with R’s ideas of how to manipulate
matrices, but it’s yet another source of confusion: I don’t want to
have to think about if I’m treating my data like a matrix or like a
data frame.</p>
</li>
<li>
<p dir="auto">Good luck trying to figure out how to find a particular sequence of
elements within a vector. For example, try finding if/where the
unbroken vector <code>1:3</code> has occurred in
<code>sample(6, 100, replace = TRUE)</code>. You’re best off just writing the
<code>for</code> loop.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-451-combining-operators" aria-hidden="true" href="#451-combining-operators"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.5.1 Combining Operators</h3>
<p dir="auto">This one isn’t too bad, but it’s worth a mention. Combining operations
can lead to some counter-intuitive results:</p>
<ul dir="auto">
<li>
<p dir="auto">If <code>a &lt;- 1:5</code>, what do you expect to get from <code>a[-1] &lt;- 12:15</code>? Do
you expect <code>a[1]</code> to be removed or not? This is great once you know
how it works, but it’s confusing to a beginner.</p>
<div data-snippet-clipboard-copy-content="a &lt;- 1:5
a[-1] &lt;- 12:15
a
## [1]  1 12 13 14 15"><pre><span>a</span> <span>&lt;-</span> <span>1</span><span>:</span><span>5</span>
<span>a</span>[<span>-</span><span>1</span>] <span>&lt;-</span> <span>12</span><span>:</span><span>15</span>
<span>a</span>
<span><span>#</span># [1]  1 12 13 14 15</span></pre></div>
</li>
<li>
<p dir="auto">Because <code>data[-index]</code> can be used to remove elements and
<code>data[&#34;colName&#34;]</code> can be used to select elements, you might expect
<code>data[-&#34;colName&#34;]</code> or <code>data[-c(&#34;colName1&#34;, &#34;colName2&#34;)]</code> to work.
You would be wrong. Both throw errors.</p>
<div data-snippet-clipboard-copy-content="## &gt; mtcars[-&#34;wt&#34;]
## Error in -&#34;wt&#34; : invalid argument to unary operator"><pre><span><span>#</span># &gt; mtcars[-&#34;wt&#34;]</span>
<span><span>#</span># Error in -&#34;wt&#34; : invalid argument to unary operator</span></pre></div>
</li>
<li>
<p dir="auto">Attempting to remove both by index and by name at the same time will
never work. For example, <code>mtcars[-c(1, &#34;cyl&#34;)]</code> is an error and
<code>mtcars[c(1, &#34;cyl&#34;)] &lt;- NULL</code> will only remove the <code>cyl</code> variable.
Weirdly enough, I can’t actually show this
<code>mtcars[c(1, &#34;cyl&#34;)] &lt;- NULL</code> example. R is perfectly happy to show
it, but R Markdown isn’t. What happens is that <code>c(1, &#34;cyl&#34;)</code> is
coerced to <code>c(&#34;1&#34;, &#34;cyl&#34;)</code>. After this, R does not inform you that
there is no <code>1</code> column to remove.</p>
</li>
<li>
<p dir="auto">Selecting and deleting at the same time doesn’t work either. For
example, <code>data[c(-1, 5)]</code> is an error.</p>
<div data-snippet-clipboard-copy-content="## &gt; Nile[c(-1, 5)]
## Error in `[.default`(Nile, c(-1, 5)) : 
##   only 0&#39;s may be mixed with negative subscripts"><pre><span><span>#</span># &gt; Nile[c(-1, 5)]</span>
<span><span>#</span># Error in `[.default`(Nile, c(-1, 5)) : </span>
<span><span>#</span>#   only 0&#39;s may be mixed with negative subscripts</span></pre></div>
</li>
</ul>
<p dir="auto">Now for the serious stuff…</p>
<h3 dir="auto"><a id="user-content-452-removing-dimensions" aria-hidden="true" href="#452-removing-dimensions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.5.2 Removing Dimensions</h3>
<p dir="auto">This issue is notorious: R likes to remove unnecessary dimensions from
your data in ways that are not easily predicted, forcing you to waste
time preventing them. Rumour has it that this can be blamed on S being
designed as a calculator rather than as a programming language. I can’t
cite that, but it’s easy to believe. No programmer would include any of
the below in a programming language.</p>
<ul dir="auto">
<li>
<p dir="auto">Unless you add <code>, drop=FALSE</code> to all of your data selection/deletion
lines, you run the risk of having all of your code that expects your
data to have a particular structure unexpectedly break. This gives
no errors or warnings. Compare:</p>
<div data-snippet-clipboard-copy-content="(mat &lt;- cbind(1:4, 4:1))
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    3
## [3,]    3    2
## [4,]    4    1
mat[, -1]
## [1] 4 3 2 1
mat[, -1, drop=FALSE]
##      [,1]
## [1,]    4
## [2,]    3
## [3,]    2
## [4,]    1"><pre>(<span>mat</span> <span>&lt;-</span> cbind(<span>1</span><span>:</span><span>4</span>, <span>4</span><span>:</span><span>1</span>))
<span><span>#</span>#      [,1] [,2]</span>
<span><span>#</span># [1,]    1    4</span>
<span><span>#</span># [2,]    2    3</span>
<span><span>#</span># [3,]    3    2</span>
<span><span>#</span># [4,]    4    1</span>
<span>mat</span>[, <span>-</span><span>1</span>]
<span><span>#</span># [1] 4 3 2 1</span>
<span>mat</span>[, <span>-</span><span>1</span>, <span>drop</span><span>=</span><span>FALSE</span>]
<span><span>#</span>#      [,1]</span>
<span><span>#</span># [1,]    4</span>
<span><span>#</span># [2,]    3</span>
<span><span>#</span># [3,]    2</span>
<span><span>#</span># [4,]    1</span></pre></div>
<p dir="auto">and you will see that one of these is not a matrix. Data frames have
the same issue unless you do all of your subsetting in a 1D form.</p>
<div data-snippet-clipboard-copy-content="mat &lt;- cbind(1:4, 4:1)
(frame &lt;- as.data.frame(mat))
##   V1 V2
## 1  1  4
## 2  2  3
## 3  3  2
## 4  4  1
frame[, -1]
## [1] 4 3 2 1
frame[, -1, drop=FALSE]
##   V2
## 1  4
## 2  3
## 3  2
## 4  1
frame[-1]#1D subsetting
##   V2
## 1  4
## 2  3
## 3  2
## 4  1"><pre><span>mat</span> <span>&lt;-</span> cbind(<span>1</span><span>:</span><span>4</span>, <span>4</span><span>:</span><span>1</span>)
(<span>frame</span> <span>&lt;-</span> as.data.frame(<span>mat</span>))
<span><span>#</span>#   V1 V2</span>
<span><span>#</span># 1  1  4</span>
<span><span>#</span># 2  2  3</span>
<span><span>#</span># 3  3  2</span>
<span><span>#</span># 4  4  1</span>
<span>frame</span>[, <span>-</span><span>1</span>]
<span><span>#</span># [1] 4 3 2 1</span>
<span>frame</span>[, <span>-</span><span>1</span>, <span>drop</span><span>=</span><span>FALSE</span>]
<span><span>#</span>#   V2</span>
<span><span>#</span># 1  4</span>
<span><span>#</span># 2  3</span>
<span><span>#</span># 3  2</span>
<span><span>#</span># 4  1</span>
<span>frame</span>[<span>-</span><span>1</span>]<span><span>#</span>1D subsetting</span>
<span><span>#</span>#   V2</span>
<span><span>#</span># 1  4</span>
<span><span>#</span># 2  3</span>
<span><span>#</span># 3  2</span>
<span><span>#</span># 4  1</span></pre></div>
<p dir="auto">The Tidyverse, specifically <code>tibble</code>, does its best to remove this.</p>
<div data-snippet-clipboard-copy-content="library(tibble)
mat &lt;- cbind(1:4, 4:1)
(tib &lt;- as_tibble(mat))
## Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0.
## Using compatibility `.name_repair`.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.
## # A tibble: 4 × 2
##      V1    V2
##   &lt;int&gt; &lt;int&gt;
## 1     1     4
## 2     2     3
## 3     3     2
## 4     4     1
tib[, -1]
## # A tibble: 4 × 1
##      V2
##   &lt;int&gt;
## 1     4
## 2     3
## 3     2
## 4     1
tib[, -1, drop=FALSE]
## # A tibble: 4 × 1
##      V2
##   &lt;int&gt;
## 1     4
## 2     3
## 3     2
## 4     1
tib[-1]
## # A tibble: 4 × 1
##      V2
##   &lt;int&gt;
## 1     4
## 2     3
## 3     2
## 4     1
tib[, -1, drop=TRUE]
## [1] 4 3 2 1"><pre>library(<span>tibble</span>)
<span>mat</span> <span>&lt;-</span> cbind(<span>1</span><span>:</span><span>4</span>, <span>4</span><span>:</span><span>1</span>)
(<span>tib</span> <span>&lt;-</span> as_tibble(<span>mat</span>))
<span><span>#</span># Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0.</span>
<span><span>#</span># Using compatibility `.name_repair`.</span>
<span><span>#</span># This warning is displayed once every 8 hours.</span>
<span><span>#</span># Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.</span>
<span><span>#</span># # A tibble: 4 × 2</span>
<span><span>#</span>#      V1    V2</span>
<span><span>#</span>#   &lt;int&gt; &lt;int&gt;</span>
<span><span>#</span># 1     1     4</span>
<span><span>#</span># 2     2     3</span>
<span><span>#</span># 3     3     2</span>
<span><span>#</span># 4     4     1</span>
<span>tib</span>[, <span>-</span><span>1</span>]
<span><span>#</span># # A tibble: 4 × 1</span>
<span><span>#</span>#      V2</span>
<span><span>#</span>#   &lt;int&gt;</span>
<span><span>#</span># 1     4</span>
<span><span>#</span># 2     3</span>
<span><span>#</span># 3     2</span>
<span><span>#</span># 4     1</span>
<span>tib</span>[, <span>-</span><span>1</span>, <span>drop</span><span>=</span><span>FALSE</span>]
<span><span>#</span># # A tibble: 4 × 1</span>
<span><span>#</span>#      V2</span>
<span><span>#</span>#   &lt;int&gt;</span>
<span><span>#</span># 1     4</span>
<span><span>#</span># 2     3</span>
<span><span>#</span># 3     2</span>
<span><span>#</span># 4     1</span>
<span>tib</span>[<span>-</span><span>1</span>]
<span><span>#</span># # A tibble: 4 × 1</span>
<span><span>#</span>#      V2</span>
<span><span>#</span>#   &lt;int&gt;</span>
<span><span>#</span># 1     4</span>
<span><span>#</span># 2     3</span>
<span><span>#</span># 3     2</span>
<span><span>#</span># 4     1</span>
<span>tib</span>[, <span>-</span><span>1</span>, <span>drop</span><span>=</span><span>TRUE</span>]
<span><span>#</span># [1] 4 3 2 1</span></pre></div>
<p dir="auto">You can think of tibbles as having <code>drop=FALSE</code> as their default. I
can’t explain why base R doesn’t do the same. It’s got to either be
some sort of compromise for matrix algebra or for making working in
your console nicer.</p>
</li>
<li>
<p dir="auto">The <code>drop</code> argument is even stranger than I’m letting on. Its
defaults differ depending on whether there may only be one column
remaining or if there may only be one row. To quote the
documentation (<code>?&#34;[.data.frame&#34;</code>): “<em>The default is to drop if only
one column is left, but <strong>not</strong> to drop if only one row is left</em>”.
Unlike the previous point, I can sort of make sense of this. For
example, a single column can only ever be one type (even if that may
be a container for mixed types, such as a list) but a single row
could easily be a mix of types. Dropping on a row of mixed types
will just give you a really ugly list, so you’d much rather have a
data frame. With a column, it’s only with years of experience that
the community has realised that they probably still want the data
frame; It’s nowhere near as obvious that the vector is not
preferable.</p>
</li>
<li>
<p dir="auto">As you can tell by taking a close look at the documentation for <code>[</code>
and that of <code>[.data.frame</code>, the <code>drop</code> argument does not do the same
thing for arrays and matrices as it does for data frames. This means
that my earlier example could be dishonest. However, the confusion
that you would need to overcome in order to check for if I’ve been
dishonest is so great that it proves that there’s definitely
something wrong with the <code>drop</code> argument.</p>
</li>
<li>
<p dir="auto">You may think that <code>object</code> and <code>object[,]</code> are the same thing. They
are not. You would expect and get an error if <code>object</code> is
one-dimensional. However, if it’s a data frame or matrix with one of
its dimensions having size 1, then you do not get an error and both
<code>object</code> and <code>object[,]</code> are very different.</p>
<div data-snippet-clipboard-copy-content="library(tibble)
colMatrix &lt;- matrix(1:3)
colMatrix
##      [,1]
## [1,]    1
## [2,]    2
## [3,]    3
colMatrix[,]
## [1] 1 2 3
rowMatrix &lt;- matrix(1:3, ncol = 3)
rowMatrix
##      [,1] [,2] [,3]
## [1,]    1    2    3
rowMatrix[,]
## [1] 1 2 3
colFrame &lt;- as.data.frame(colMatrix)
colFrame
##   V1
## 1  1
## 2  2
## 3  3
colFrame[,]
## [1] 1 2 3
rowFrame &lt;- as.data.frame(rowMatrix)
rowFrame
##   V1 V2 V3
## 1  1  2  3
rowFrame[,]
##   V1 V2 V3
## 1  1  2  3
colTib &lt;- as_tibble(colMatrix)
colTib
## # A tibble: 3 × 1
##      V1
##   &lt;int&gt;
## 1     1
## 2     2
## 3     3
colTib[,]
## # A tibble: 3 × 1
##      V1
##   &lt;int&gt;
## 1     1
## 2     2
## 3     3
rowTib &lt;- as_tibble(rowMatrix)
rowTib
## # A tibble: 1 × 3
##      V1    V2    V3
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3
rowTib[,]
## # A tibble: 1 × 3
##      V1    V2    V3
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3"><pre>library(<span>tibble</span>)
<span>colMatrix</span> <span>&lt;-</span> <span>matrix</span>(<span>1</span><span>:</span><span>3</span>)
<span>colMatrix</span>
<span><span>#</span>#      [,1]</span>
<span><span>#</span># [1,]    1</span>
<span><span>#</span># [2,]    2</span>
<span><span>#</span># [3,]    3</span>
<span>colMatrix</span>[,]
<span><span>#</span># [1] 1 2 3</span>
<span>rowMatrix</span> <span>&lt;-</span> <span>matrix</span>(<span>1</span><span>:</span><span>3</span>, <span>ncol</span> <span>=</span> <span>3</span>)
<span>rowMatrix</span>
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    2    3</span>
<span>rowMatrix</span>[,]
<span><span>#</span># [1] 1 2 3</span>
<span>colFrame</span> <span>&lt;-</span> as.data.frame(<span>colMatrix</span>)
<span>colFrame</span>
<span><span>#</span>#   V1</span>
<span><span>#</span># 1  1</span>
<span><span>#</span># 2  2</span>
<span><span>#</span># 3  3</span>
<span>colFrame</span>[,]
<span><span>#</span># [1] 1 2 3</span>
<span>rowFrame</span> <span>&lt;-</span> as.data.frame(<span>rowMatrix</span>)
<span>rowFrame</span>
<span><span>#</span>#   V1 V2 V3</span>
<span><span>#</span># 1  1  2  3</span>
<span>rowFrame</span>[,]
<span><span>#</span>#   V1 V2 V3</span>
<span><span>#</span># 1  1  2  3</span>
<span>colTib</span> <span>&lt;-</span> as_tibble(<span>colMatrix</span>)
<span>colTib</span>
<span><span>#</span># # A tibble: 3 × 1</span>
<span><span>#</span>#      V1</span>
<span><span>#</span>#   &lt;int&gt;</span>
<span><span>#</span># 1     1</span>
<span><span>#</span># 2     2</span>
<span><span>#</span># 3     3</span>
<span>colTib</span>[,]
<span><span>#</span># # A tibble: 3 × 1</span>
<span><span>#</span>#      V1</span>
<span><span>#</span>#   &lt;int&gt;</span>
<span><span>#</span># 1     1</span>
<span><span>#</span># 2     2</span>
<span><span>#</span># 3     3</span>
<span>rowTib</span> <span>&lt;-</span> as_tibble(<span>rowMatrix</span>)
<span>rowTib</span>
<span><span>#</span># # A tibble: 1 × 3</span>
<span><span>#</span>#      V1    V2    V3</span>
<span><span>#</span>#   &lt;int&gt; &lt;int&gt; &lt;int&gt;</span>
<span><span>#</span># 1     1     2     3</span>
<span>rowTib</span>[,]
<span><span>#</span># # A tibble: 1 × 3</span>
<span><span>#</span>#      V1    V2    V3</span>
<span><span>#</span>#   &lt;int&gt; &lt;int&gt; &lt;int&gt;</span>
<span><span>#</span># 1     1     2     3</span></pre></div>
<p dir="auto">Can you guess why? It’s because the use of <code>[</code> makes R check if it
should be dropping dimensions. This makes <code>object</code> and
<code>object[,,drop=FALSE]</code> equivalent, whereas <code>object[,]</code> is a vector
rather than whatever it was originally. Tibbles, of course, don’t
have this issue.</p>
</li>
<li>
<p dir="auto">If you’ve struggled to read this section, then you’re probably now
aware of another point: It’s really easy to get the commas for
<code>drop=FALSE</code> mixed up. What do you think that you get if you try to
select <code>data[4, drop=FALSE]</code>? If <code>data</code> is a data frame, you get
column 4 and a warning that the <code>drop</code> argument was ignored. Did you
expect row 4? Whether you did or not, you should be able to see why
somebody may come to the opposite answer. Although I see no sensible
alternative, the <code>drop</code> argument needing its own comma is terrible
syntax for a language where a stray comma is the difference between
your data’s life and death. This is made even worse by the syntax
for <code>[</code> occasionally needing stray commas. Expressions like
<code>data[4,]</code> are commonplace in R, so it’s far too easy to forget that
you needed the extra comma for the <code>drop</code> argument.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-453-dangers-of-" aria-hidden="true" href="#453-dangers-of-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.5.3 Dangers of $</h3>
<p dir="auto">The <code>$</code> operator is both silently hazardous and redundant:</p>
<ul dir="auto">
<li>
<p dir="auto">As an S3 generic, you can never be certain that <code>$</code> does what you
want it to when you use it on a class from a package. For example,
it’s common knowledge that base R’s <code>$</code> and the Tidyverse’s <code>$</code> are
not the same thing. In fact, <code>$</code> does not even behave consistently
in base R. Compare the following partial matching behaviour:</p>
<div data-snippet-clipboard-copy-content="library(tibble)
list(Bob = 5, Dobby = 7)$B
## [1] 5
env &lt;- list2env(list(Bob = 5, Dobby = 7))
env$B
## NULL
data.frame(Bob = 5, Dobby = 7)$B
## [1] 5
tibble(Bob = 5, Dobby = 7)$B
## Warning: Unknown or uninitialised column: `B`.
## NULL"><pre>library(<span>tibble</span>)
<span>list</span>(<span>Bob</span> <span>=</span> <span>5</span>, <span>Dobby</span> <span>=</span> <span>7</span>)<span>$</span><span>B</span>
<span><span>#</span># [1] 5</span>
<span>env</span> <span>&lt;-</span> list2env(<span>list</span>(<span>Bob</span> <span>=</span> <span>5</span>, <span>Dobby</span> <span>=</span> <span>7</span>))
<span>env</span><span>$</span><span>B</span>
<span><span>#</span># NULL</span>
<span>data.frame</span>(<span>Bob</span> <span>=</span> <span>5</span>, <span>Dobby</span> <span>=</span> <span>7</span>)<span>$</span><span>B</span>
<span><span>#</span># [1] 5</span>
tibble(<span>Bob</span> <span>=</span> <span>5</span>, <span>Dobby</span> <span>=</span> <span>7</span>)<span>$</span><span>B</span>
<span><span>#</span># Warning: Unknown or uninitialised column: `B`.</span>
<span><span>#</span># NULL</span></pre></div>
<p dir="auto">For what it’s worth, replacing <code>Dobby</code> with <code>Bobby</code> gives more
consistent results.</p>
<div data-snippet-clipboard-copy-content="library(tibble)
list(Bob = 5, Bobby = 7)$B
## NULL
env &lt;- list2env(list(Bob = 5, Bobby = 7))
env$B
## NULL
data.frame(Bob = 5, Bobby = 7)$B
## NULL
tibble(Bob = 5, Bobby = 7)$B
## Warning: Unknown or uninitialised column: `B`.
## NULL"><pre>library(<span>tibble</span>)
<span>list</span>(<span>Bob</span> <span>=</span> <span>5</span>, <span>Bobby</span> <span>=</span> <span>7</span>)<span>$</span><span>B</span>
<span><span>#</span># NULL</span>
<span>env</span> <span>&lt;-</span> list2env(<span>list</span>(<span>Bob</span> <span>=</span> <span>5</span>, <span>Bobby</span> <span>=</span> <span>7</span>))
<span>env</span><span>$</span><span>B</span>
<span><span>#</span># NULL</span>
<span>data.frame</span>(<span>Bob</span> <span>=</span> <span>5</span>, <span>Bobby</span> <span>=</span> <span>7</span>)<span>$</span><span>B</span>
<span><span>#</span># NULL</span>
tibble(<span>Bob</span> <span>=</span> <span>5</span>, <span>Bobby</span> <span>=</span> <span>7</span>)<span>$</span><span>B</span>
<span><span>#</span># Warning: Unknown or uninitialised column: `B`.</span>
<span><span>#</span># NULL</span></pre></div>
<p dir="auto">In theory, I should note that <code>[</code> and <code>[[</code> are also S3 generics and
therefore should share this issue. In practice, I rarely notice such
misbehaviour.</p>
</li>
<li>
<p dir="auto">Consistency aside, partial matching is inherently dangerous.
<code>data$Pen</code> might give the <code>Penetration</code> column if you forgot that
you removed the <code>Pen</code> column. By default, R does not give you any
warnings when partial matches happen, so you won’t have any idea
that you got the wrong column.</p>
</li>
<li>
<p dir="auto">The documentation for <code>$</code> points out its redundancy in base R:
“<em><code>x$name</code> is equivalent to <code>x[[&#34;name&#34;, exact = FALSE]]</code></em>”. In other
words, even if I want the behaviour of <code>$</code>, I can get it with <code>[[</code>.
Another benefit of <code>[[</code> is that it will only partially match if you
tell it to (use <code>exact = FALSE</code>). That matters because…</p>
</li>
<li>
<p dir="auto">The partial matching of <code>$</code> can be even worse than I’ve just
described. If there are multiple valid partial matches, rather than
get any of them, you get <code>NULL</code>. This is what happened with the
Bob/Bobby example above. To give another example, <code>mtcars$di</code> and
<code>mtcars$dr</code> both give sensible output because there is only one
valid partial match, but <code>mtcars$d</code> is just <code>NULL</code>. I’m largely okay
with this behaviour, but you don’t even get a warning!</p>
<div data-snippet-clipboard-copy-content="mtcars$di
##  [1] 160.0 160.0 108.0 258.0 360.0 225.0 360.0 146.7 140.8 167.6 167.6 275.8
## [13] 275.8 275.8 472.0 460.0 440.0  78.7  75.7  71.1 120.1 318.0 304.0 350.0
## [25] 400.0  79.0 120.3  95.1 351.0 145.0 301.0 121.0
mtcars$dr
##  [1] 3.90 3.90 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 3.92 3.07 3.07 3.07 2.93
## [16] 3.00 3.23 4.08 4.93 4.22 3.70 2.76 3.15 3.73 3.08 4.08 4.43 3.77 4.22 3.62
## [31] 3.54 4.11
mtcars$d
## NULL"><pre><span>mtcars</span><span>$</span><span>di</span>
<span><span>#</span>#  [1] 160.0 160.0 108.0 258.0 360.0 225.0 360.0 146.7 140.8 167.6 167.6 275.8</span>
<span><span>#</span># [13] 275.8 275.8 472.0 460.0 440.0  78.7  75.7  71.1 120.1 318.0 304.0 350.0</span>
<span><span>#</span># [25] 400.0  79.0 120.3  95.1 351.0 145.0 301.0 121.0</span>
<span>mtcars</span><span>$</span><span>dr</span>
<span><span>#</span>#  [1] 3.90 3.90 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 3.92 3.07 3.07 3.07 2.93</span>
<span><span>#</span># [16] 3.00 3.23 4.08 4.93 4.22 3.70 2.76 3.15 3.73 3.08 4.08 4.43 3.77 4.22 3.62</span>
<span><span>#</span># [31] 3.54 4.11</span>
<span>mtcars</span><span>$</span><span>d</span>
<span><span>#</span># NULL</span></pre></div>
</li>
<li>
<p dir="auto">Tibbles try to fix the partial-matching issues of <code>$</code> by completely
disallowing partial matching. They will not partially match even if
you tell them to with <code>[[, exact=FALSE]]</code>. If you try to partially
match anyway, it will give you a warning and return <code>NULL</code>. I
sometimes wonder if it should be an error.</p>
<div data-snippet-clipboard-copy-content="library(tibble)
mtTib &lt;- as_tibble(mtcars)
mtTib$di
## Warning: Unknown or uninitialised column: `di`.
## NULL
mtTib$dr
## Warning: Unknown or uninitialised column: `dr`.
## NULL
mtTib$d
## Warning: Unknown or uninitialised column: `d`.
## NULL
mtcars[[&#34;d&#34;, exact = FALSE]]
## NULL
mtTib[[&#34;d&#34;, exact = FALSE]]
## Warning: `exact` ignored.
## NULL"><pre>library(<span>tibble</span>)
<span>mtTib</span> <span>&lt;-</span> as_tibble(<span>mtcars</span>)
<span>mtTib</span><span>$</span><span>di</span>
<span><span>#</span># Warning: Unknown or uninitialised column: `di`.</span>
<span><span>#</span># NULL</span>
<span>mtTib</span><span>$</span><span>dr</span>
<span><span>#</span># Warning: Unknown or uninitialised column: `dr`.</span>
<span><span>#</span># NULL</span>
<span>mtTib</span><span>$</span><span>d</span>
<span><span>#</span># Warning: Unknown or uninitialised column: `d`.</span>
<span><span>#</span># NULL</span>
<span>mtcars</span>[[<span><span>&#34;</span>d<span>&#34;</span></span>, <span>exact</span> <span>=</span> <span>FALSE</span>]]
<span><span>#</span># NULL</span>
<span>mtTib</span>[[<span><span>&#34;</span>d<span>&#34;</span></span>, <span>exact</span> <span>=</span> <span>FALSE</span>]]
<span><span>#</span># Warning: `exact` ignored.</span>
<span><span>#</span># NULL</span></pre></div>
</li>
<li>
<p dir="auto">On the base R side, there is a global option that you can set to
make <code>$</code> give you warnings whenever partial matching happens. It’s
disabled by default. Common sense suggests that it should be
otherwise.</p>
</li>
<li>
<p dir="auto">The <code>$</code> operator is another case of R quietly changing your data
structures. For example, I would call <code>mtcars$mpg</code> unreadable.</p>
<div data-snippet-clipboard-copy-content="mtcars$mpg
##  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
## [31] 15.0 21.4
typeof(mtcars$mpg)
## [1] &#34;double&#34;"><pre><span>mtcars</span><span>$</span><span>mpg</span>
<span><span>#</span>#  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4</span>
<span><span>#</span># [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7</span>
<span><span>#</span># [31] 15.0 21.4</span>
typeof(<span>mtcars</span><span>$</span><span>mpg</span>)
<span><span>#</span># [1] &#34;double&#34;</span></pre></div>
<p dir="auto">You probably wanted <code>mtcars[&#34;mpg&#34;]</code></p>
<div data-snippet-clipboard-copy-content="mtcars[&#34;mpg&#34;]
##                      mpg
## Mazda RX4           21.0
## Mazda RX4 Wag       21.0
## Datsun 710          22.8
## Hornet 4 Drive      21.4
## Hornet Sportabout   18.7
## Valiant             18.1
## Duster 360          14.3
## Merc 240D           24.4
## Merc 230            22.8
## Merc 280            19.2
## Merc 280C           17.8
## Merc 450SE          16.4
## Merc 450SL          17.3
## Merc 450SLC         15.2
## Cadillac Fleetwood  10.4
## Lincoln Continental 10.4
## Chrysler Imperial   14.7
## Fiat 128            32.4
## Honda Civic         30.4
## Toyota Corolla      33.9
## Toyota Corona       21.5
## Dodge Challenger    15.5
## AMC Javelin         15.2
## Camaro Z28          13.3
## Pontiac Firebird    19.2
## Fiat X1-9           27.3
## Porsche 914-2       26.0
## Lotus Europa        30.4
## Ford Pantera L      15.8
## Ferrari Dino        19.7
## Maserati Bora       15.0
## Volvo 142E          21.4
typeof(mtcars[&#34;mpg&#34;])
## [1] &#34;list&#34;"><pre><span>mtcars</span>[<span><span>&#34;</span>mpg<span>&#34;</span></span>]
<span><span>#</span>#                      mpg</span>
<span><span>#</span># Mazda RX4           21.0</span>
<span><span>#</span># Mazda RX4 Wag       21.0</span>
<span><span>#</span># Datsun 710          22.8</span>
<span><span>#</span># Hornet 4 Drive      21.4</span>
<span><span>#</span># Hornet Sportabout   18.7</span>
<span><span>#</span># Valiant             18.1</span>
<span><span>#</span># Duster 360          14.3</span>
<span><span>#</span># Merc 240D           24.4</span>
<span><span>#</span># Merc 230            22.8</span>
<span><span>#</span># Merc 280            19.2</span>
<span><span>#</span># Merc 280C           17.8</span>
<span><span>#</span># Merc 450SE          16.4</span>
<span><span>#</span># Merc 450SL          17.3</span>
<span><span>#</span># Merc 450SLC         15.2</span>
<span><span>#</span># Cadillac Fleetwood  10.4</span>
<span><span>#</span># Lincoln Continental 10.4</span>
<span><span>#</span># Chrysler Imperial   14.7</span>
<span><span>#</span># Fiat 128            32.4</span>
<span><span>#</span># Honda Civic         30.4</span>
<span><span>#</span># Toyota Corolla      33.9</span>
<span><span>#</span># Toyota Corona       21.5</span>
<span><span>#</span># Dodge Challenger    15.5</span>
<span><span>#</span># AMC Javelin         15.2</span>
<span><span>#</span># Camaro Z28          13.3</span>
<span><span>#</span># Pontiac Firebird    19.2</span>
<span><span>#</span># Fiat X1-9           27.3</span>
<span><span>#</span># Porsche 914-2       26.0</span>
<span><span>#</span># Lotus Europa        30.4</span>
<span><span>#</span># Ford Pantera L      15.8</span>
<span><span>#</span># Ferrari Dino        19.7</span>
<span><span>#</span># Maserati Bora       15.0</span>
<span><span>#</span># Volvo 142E          21.4</span>
typeof(<span>mtcars</span>[<span><span>&#34;</span>mpg<span>&#34;</span></span>])
<span><span>#</span># [1] &#34;list&#34;</span></pre></div>
<p dir="auto">and you definitely did not want <code>mtcars[, &#34;mpg&#34;]</code> or
<code>mtcars[[&#34;mpg&#34;]]</code>, which both give the same output as using <code>$</code>.</p>
<div data-snippet-clipboard-copy-content="mtcars[, &#34;mpg&#34;]
##  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
## [31] 15.0 21.4
mtcars[[&#34;mpg&#34;]]
##  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
## [31] 15.0 21.4"><pre><span>mtcars</span>[, <span><span>&#34;</span>mpg<span>&#34;</span></span>]
<span><span>#</span>#  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4</span>
<span><span>#</span># [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7</span>
<span><span>#</span># [31] 15.0 21.4</span>
<span>mtcars</span>[[<span><span>&#34;</span>mpg<span>&#34;</span></span>]]
<span><span>#</span>#  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4</span>
<span><span>#</span># [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7</span>
<span><span>#</span># [31] 15.0 21.4</span></pre></div>
<p dir="auto">Would you have guessed that? Tibbles share the above behaviour with
<code>$</code> and <code>[[</code>, but keep <code>[&#34;name&#34;]</code> and <code>[, &#34;name&#34;]</code> identical due to
their promise to not drop dimensions with <code>[</code>.</p>
</li>
<li>
<p dir="auto">The <code>$</code> operator does not have any uses beyond selection. For
example, there is no way to combine <code>$</code> with operators like <code>-</code> and
there’s no way to pass arguments like <code>drop=FALSE</code> to it.</p>
</li>
<li>
<p dir="auto"><code>$</code> is not allowed for atomic vectors like <code>c(fizz=3, buzz=5)</code>,
unlike <code>[</code> and <code>[[</code>. This is particularly annoying when dealing with
named matrices because you end up having to use <code>mat[, &#34;x&#34;]</code> where
<code>mat$x</code> should have done.</p>
</li>
<li>
<p dir="auto">Section 8.1.21 of <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a>:
There exists a <code>$&lt;-</code> operator. You hardly ever see it used. <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a>
points out that it does not do partial matching, even for lists,
unlike <code>$</code>. This is actually documented behaviour – in fact,
<code>?Extract</code> mentions it twice – but I challenge you to find it. I can
see why it would be difficult to make a <code>$&lt;-</code> with partial matching,
but making <code>$&lt;-</code> inconsistent with <code>$</code> is just laughable.</p>
</li>
</ul>
<p dir="auto">In conclusion, once you know the difference between <code>[&#34;colname&#34;]</code> and
<code>[, &#34;colname&#34;]</code>, <code>$</code> is only useful if it’s making your code cleaner,
saving you typing, or if you actually want the partial matching.
Personally, I’m uncomfortable with the inherent risks of partial
matching, so <code>$</code> is only really useful for interactive use and my IDE’s
auto-completion. That might even be its intended job. But if that is the
case, nobody warns you of it.</p>
<h3 dir="auto"><a id="user-content-454-indistinguishable-errors" aria-hidden="true" href="#454-indistinguishable-errors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.5.4 Indistinguishable Errors</h3>
<p dir="auto">When dealing with any sort of collection, any of the following mistakes
can give indistinguishable results. This can make your debugging so
messy that by the time that you’re done, you don’t know what was broken.</p>
<ul dir="auto">
<li>
<p dir="auto">Trying to select an incorrect sequence of elements. This can be
caused by <code>:</code> or <code>seq()</code> misbehaving or by simple user error. <a href="#4111-sequences">A
tiny bit more on that later</a></p>
</li>
<li>
<p dir="auto">The vector recycling rules silently causing the vector that you used
to select elements to be recycled in an undesired way. <a href="#46-vectorization-again">More on that
later</a>.</p>
</li>
<li>
<p dir="auto">Selecting an out-of-bounds value. You almost always don’t get any
error or warning when you do this. For example, both out-of-bounds
positive numbers and logical vectors that are longer than the vector
that you’re subsetting silently return <code>NA</code> for the inappropriate
values.</p>
<div data-snippet-clipboard-copy-content="length(LETTERS)
## [1] 26
LETTERS[c(1, 5, 20, 100)]
## [1] &#34;A&#34; &#34;E&#34; &#34;T&#34; NA
LETTERS[rep(TRUE, 100)]
##   [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;F&#34; &#34;G&#34; &#34;H&#34; &#34;I&#34; &#34;J&#34; &#34;K&#34; &#34;L&#34; &#34;M&#34; &#34;N&#34; &#34;O&#34; &#34;P&#34; &#34;Q&#34; &#34;R&#34;
##  [19] &#34;S&#34; &#34;T&#34; &#34;U&#34; &#34;V&#34; &#34;W&#34; &#34;X&#34; &#34;Y&#34; &#34;Z&#34; NA  NA  NA  NA  NA  NA  NA  NA  NA  NA 
##  [37] NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA 
##  [55] NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA 
##  [73] NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA 
##  [91] NA  NA  NA  NA  NA  NA  NA  NA  NA  NA"><pre>length(<span>LETTERS</span>)
<span><span>#</span># [1] 26</span>
<span>LETTERS</span>[c(<span>1</span>, <span>5</span>, <span>20</span>, <span>100</span>)]
<span><span>#</span># [1] &#34;A&#34; &#34;E&#34; &#34;T&#34; NA</span>
<span>LETTERS</span>[rep(<span>TRUE</span>, <span>100</span>)]
<span><span>#</span>#   [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;F&#34; &#34;G&#34; &#34;H&#34; &#34;I&#34; &#34;J&#34; &#34;K&#34; &#34;L&#34; &#34;M&#34; &#34;N&#34; &#34;O&#34; &#34;P&#34; &#34;Q&#34; &#34;R&#34;</span>
<span><span>#</span>#  [19] &#34;S&#34; &#34;T&#34; &#34;U&#34; &#34;V&#34; &#34;W&#34; &#34;X&#34; &#34;Y&#34; &#34;Z&#34; NA  NA  NA  NA  NA  NA  NA  NA  NA  NA </span>
<span><span>#</span>#  [37] NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA </span>
<span><span>#</span>#  [55] NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA </span>
<span><span>#</span>#  [73] NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA </span>
<span><span>#</span>#  [91] NA  NA  NA  NA  NA  NA  NA  NA  NA  NA</span></pre></div>
<p dir="auto">Again, as with many of the issues that we’ve mentioned recently,
<strong>this happens silently</strong>.</p>
</li>
<li>
<p dir="auto">Accessing/subsetting a collection in the wrong way. For example,
wrongly using any of <code>[c(x, y)]</code>, <code>[x, y]</code>, or <code>[cbind(x, y)]</code>,
selecting <code>[x]</code> rather than <code>[x, ]</code>, <code>[[x]]</code>, or <code>[, x]</code>, using the
wrong <code>rbind()/cbind()</code>, or an error in your call to anything like
<code>subset()</code> or <code>within()</code>.</p>
</li>
<li>
<p dir="auto">Selecting element 0.</p>
</li>
<li>
<p dir="auto">Any sort of off-by-one errors, e.g. a modulo mistake of any sort,
genuine off-by-one errors, or R’s 1-indexing causing you to trip up.</p>
</li>
<li>
<p dir="auto">Misuse of searching functions like <code>which()</code>, <code>duplicated()</code>, or
<code>match()</code>.</p>
</li>
</ul>
<p dir="auto">This list also reveals another issue with subsetting: There’s too many
ways to do it…</p>
<h3 dir="auto"><a id="user-content-455-named-atomic-vectors" aria-hidden="true" href="#455-named-atomic-vectors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.5.5 Named Atomic Vectors</h3>
<p dir="auto">…and they don’t all work everywhere. For example, there’s a wide range
of tools for using names to work with lists and data frames, but very
few of them work for named atomic vectors (which includes named
matrices).</p>
<ul dir="auto">
<li>
<p dir="auto">The <code>$</code> operator simply does not work.</p>
</li>
<li>
<p dir="auto">Although <code>namedVector[&#34;name&#34;]</code> can be used for subsetting and
subassignment, <code>namedVector[&#34;name&#34;] &lt;- NULL</code> throws an error. For a
list or data frame, this would have deleted the selected data
points.</p>
<div data-snippet-clipboard-copy-content="typeof(letters)
## [1] &#34;character&#34;
named &lt;- setNames(letters, LETTERS)
tail(named)
##   U   V   W   X   Y   Z 
## &#34;u&#34; &#34;v&#34; &#34;w&#34; &#34;x&#34; &#34;y&#34; &#34;z&#34;
named[&#34;Z&#34;]
##   Z 
## &#34;z&#34;
named[&#34;Z&#34;] &lt;- &#34;Super!&#34;
tail(named)
##        U        V        W        X        Y        Z 
##      &#34;u&#34;      &#34;v&#34;      &#34;w&#34;      &#34;x&#34;      &#34;y&#34; &#34;Super!&#34;
#So subsetting and subassignment work just fine. However, for NULL...
## &gt; named[&#34;Z&#34;] &lt;- NULL
## Error in named[&#34;Z&#34;] &lt;- NULL : replacement has length zero
#But for a data frame, this is just fine.
(data &lt;- data.frame(A = 1, B = 2, Z = 3))
##   A B Z
## 1 1 2 3
data[&#34;Z&#34;] &lt;- NULL
data
##   A B
## 1 1 2"><pre>typeof(<span>letters</span>)
<span><span>#</span># [1] &#34;character&#34;</span>
<span>named</span> <span>&lt;-</span> setNames(<span>letters</span>, <span>LETTERS</span>)
tail(<span>named</span>)
<span><span>#</span>#   U   V   W   X   Y   Z </span>
<span><span>#</span># &#34;u&#34; &#34;v&#34; &#34;w&#34; &#34;x&#34; &#34;y&#34; &#34;z&#34;</span>
<span>named</span>[<span><span>&#34;</span>Z<span>&#34;</span></span>]
<span><span>#</span>#   Z </span>
<span><span>#</span># &#34;z&#34;</span>
<span>named</span>[<span><span>&#34;</span>Z<span>&#34;</span></span>] <span>&lt;-</span> <span><span>&#34;</span>Super!<span>&#34;</span></span>
tail(<span>named</span>)
<span><span>#</span>#        U        V        W        X        Y        Z </span>
<span><span>#</span>#      &#34;u&#34;      &#34;v&#34;      &#34;w&#34;      &#34;x&#34;      &#34;y&#34; &#34;Super!&#34;</span>
<span><span>#</span>So subsetting and subassignment work just fine. However, for NULL...</span>
<span><span>#</span># &gt; named[&#34;Z&#34;] &lt;- NULL</span>
<span><span>#</span># Error in named[&#34;Z&#34;] &lt;- NULL : replacement has length zero</span>
<span><span>#</span>But for a data frame, this is just fine.</span>
(<span>data</span> <span>&lt;-</span> <span>data.frame</span>(<span>A</span> <span>=</span> <span>1</span>, <span>B</span> <span>=</span> <span>2</span>, <span>Z</span> <span>=</span> <span>3</span>))
<span><span>#</span>#   A B Z</span>
<span><span>#</span># 1 1 2 3</span>
<span>data</span>[<span><span>&#34;</span>Z<span>&#34;</span></span>] <span>&lt;-</span> <span>NULL</span>
<span>data</span>
<span><span>#</span>#   A B</span>
<span><span>#</span># 1 1 2</span></pre></div>
<p dir="auto">Incidentally, <code>anyAtomicVector[index] &lt;- NULL</code> is also an error.
e.g. <code>LETTERS[22] &lt;- NULL</code>.</p>
</li>
<li>
<p dir="auto">Sorry, did I say that <code>namedVector[&#34;name&#34;]</code> works for subsetting?</p>
<div data-snippet-clipboard-copy-content="a &lt;- diag(3)
colnames(a) &lt;- LETTERS[1:3]
a
##      A B C
## [1,] 1 0 0
## [2,] 0 1 0
## [3,] 0 0 1
a[&#34;A&#34;]
## [1] NA
a[&#34;Z&#34;]
## [1] NA"><pre><span>a</span> <span>&lt;-</span> diag(<span>3</span>)
colnames(<span>a</span>) <span>&lt;-</span> <span>LETTERS</span>[<span>1</span><span>:</span><span>3</span>]
<span>a</span>
<span><span>#</span>#      A B C</span>
<span><span>#</span># [1,] 1 0 0</span>
<span><span>#</span># [2,] 0 1 0</span>
<span><span>#</span># [3,] 0 0 1</span>
<span>a</span>[<span><span>&#34;</span>A<span>&#34;</span></span>]
<span><span>#</span># [1] NA</span>
<span>a</span>[<span><span>&#34;</span>Z<span>&#34;</span></span>]
<span><span>#</span># [1] NA</span></pre></div>
<p dir="auto">Long story short, named atomic vectors make a distinction between
names and colnames that data frames do not.</p>
<div data-snippet-clipboard-copy-content="a &lt;- diag(3)
colnames(a) &lt;- LETTERS[1:3]
colnames(a)
## [1] &#34;A&#34; &#34;B&#34; &#34;C&#34;
names(a)
## NULL
names(mtcars)
##  [1] &#34;mpg&#34;  &#34;cyl&#34;  &#34;disp&#34; &#34;hp&#34;   &#34;drat&#34; &#34;wt&#34;   &#34;qsec&#34; &#34;vs&#34;   &#34;am&#34;   &#34;gear&#34;
## [11] &#34;carb&#34;
colnames(mtcars)
##  [1] &#34;mpg&#34;  &#34;cyl&#34;  &#34;disp&#34; &#34;hp&#34;   &#34;drat&#34; &#34;wt&#34;   &#34;qsec&#34; &#34;vs&#34;   &#34;am&#34;   &#34;gear&#34;
## [11] &#34;carb&#34;
identical(names(mtcars), colnames(mtcars))
## [1] TRUE"><pre><span>a</span> <span>&lt;-</span> diag(<span>3</span>)
colnames(<span>a</span>) <span>&lt;-</span> <span>LETTERS</span>[<span>1</span><span>:</span><span>3</span>]
colnames(<span>a</span>)
<span><span>#</span># [1] &#34;A&#34; &#34;B&#34; &#34;C&#34;</span>
names(<span>a</span>)
<span><span>#</span># NULL</span>
names(<span>mtcars</span>)
<span><span>#</span>#  [1] &#34;mpg&#34;  &#34;cyl&#34;  &#34;disp&#34; &#34;hp&#34;   &#34;drat&#34; &#34;wt&#34;   &#34;qsec&#34; &#34;vs&#34;   &#34;am&#34;   &#34;gear&#34;</span>
<span><span>#</span># [11] &#34;carb&#34;</span>
colnames(<span>mtcars</span>)
<span><span>#</span>#  [1] &#34;mpg&#34;  &#34;cyl&#34;  &#34;disp&#34; &#34;hp&#34;   &#34;drat&#34; &#34;wt&#34;   &#34;qsec&#34; &#34;vs&#34;   &#34;am&#34;   &#34;gear&#34;</span>
<span><span>#</span># [11] &#34;carb&#34;</span>
identical(names(<span>mtcars</span>), colnames(<span>mtcars</span>))
<span><span>#</span># [1] TRUE</span></pre></div>
<p dir="auto">So what happens when you give an atomic vector plain old names
rather than colnames? For a non-matrix, it works fine (see the
<code>named &lt;- setNames(letters, LETTERS)</code> example above). For a matrix -
and presumably for any array, but let’s not get in to that
distinction - it’s a little bit more complicated. Look closely at
this output before reading further.</p>
<div data-snippet-clipboard-copy-content="a &lt;- diag(3)
(a &lt;- setNames(a, LETTERS[1:3]))
##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1
## attr(,&#34;names&#34;)
## [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; NA  NA  NA  NA  NA  NA
a[&#34;A&#34;]
## A 
## 1
a[&#34;Z&#34;]#For a data frame, this would be an error...
## &lt;NA&gt; 
##   NA"><pre><span>a</span> <span>&lt;-</span> diag(<span>3</span>)
(<span>a</span> <span>&lt;-</span> setNames(<span>a</span>, <span>LETTERS</span>[<span>1</span><span>:</span><span>3</span>]))
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    0    0</span>
<span><span>#</span># [2,]    0    1    0</span>
<span><span>#</span># [3,]    0    0    1</span>
<span><span>#</span># attr(,&#34;names&#34;)</span>
<span><span>#</span># [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; NA  NA  NA  NA  NA  NA</span>
<span>a</span>[<span><span>&#34;</span>A<span>&#34;</span></span>]
<span><span>#</span># A </span>
<span><span>#</span># 1</span>
<span>a</span>[<span><span>&#34;</span>Z<span>&#34;</span></span>]<span><span>#</span>For a data frame, this would be an error...</span>
<span><span>#</span># &lt;NA&gt; </span>
<span><span>#</span>#   NA</span></pre></div>
<p dir="auto">When you try to give an atomic vector ordinary names, R will only
try to name it element-by-element (even if said vector has
dimensions). Data frames, on the other hand, treat names as
colnames. R ultimately sees named matrices as named atomic vectors
that happen to have a second dimension. This means that you can
subset them with both <code>[&#34;name&#34;]</code> and <code>[, &#34;name&#34;]</code> and get different
results.</p>
<div data-snippet-clipboard-copy-content="a &lt;- setNames(diag(3), LETTERS[1:3])
colnames(a) &lt;- LETTERS[1:3]
a
##      A B C
## [1,] 1 0 0
## [2,] 0 1 0
## [3,] 0 0 1
## attr(,&#34;names&#34;)
## [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; NA  NA  NA  NA  NA  NA
a[&#34;A&#34;]
## A 
## 1
a[&#34;Z&#34;]
## &lt;NA&gt; 
##   NA
a[, &#34;A&#34;]
## [1] 1 0 0
#I&#39;d love to show a[, &#34;Z&#34;], but it throws the error &#34;Error in a[, &#34;Z&#34;] : subscript out of bounds&#34;.
#This is clearly consistent with a[&#34;Z&#34;] and my earlier bits on out-of-bounds stuff not throwing errors. "><pre><span>a</span> <span>&lt;-</span> setNames(diag(<span>3</span>), <span>LETTERS</span>[<span>1</span><span>:</span><span>3</span>])
colnames(<span>a</span>) <span>&lt;-</span> <span>LETTERS</span>[<span>1</span><span>:</span><span>3</span>]
<span>a</span>
<span><span>#</span>#      A B C</span>
<span><span>#</span># [1,] 1 0 0</span>
<span><span>#</span># [2,] 0 1 0</span>
<span><span>#</span># [3,] 0 0 1</span>
<span><span>#</span># attr(,&#34;names&#34;)</span>
<span><span>#</span># [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; NA  NA  NA  NA  NA  NA</span>
<span>a</span>[<span><span>&#34;</span>A<span>&#34;</span></span>]
<span><span>#</span># A </span>
<span><span>#</span># 1</span>
<span>a</span>[<span><span>&#34;</span>Z<span>&#34;</span></span>]
<span><span>#</span># &lt;NA&gt; </span>
<span><span>#</span>#   NA</span>
<span>a</span>[, <span><span>&#34;</span>A<span>&#34;</span></span>]
<span><span>#</span># [1] 1 0 0</span>
<span><span>#</span>I&#39;d love to show a[, &#34;Z&#34;], but it throws the error &#34;Error in a[, &#34;Z&#34;] : subscript out of bounds&#34;.</span>
<span><span>#</span>This is clearly consistent with a[&#34;Z&#34;] and my earlier bits on out-of-bounds stuff not throwing errors. </span></pre></div>
<p dir="auto">Of course, <code>[&#34;name&#34;]</code> and <code>[, &#34;name&#34;]</code> aren’t identical for data
frames either, but let’s not get back in to talking about the <code>drop</code>
argument. Starting to see what I mean about R being inconsistent?</p>
</li>
<li>
<p dir="auto">You cannot use named atomic vectors to generate environments. This
means that awesome tricks like
<code>within(data, remove(columnIDoNotWant, anotherColumn))</code> work for
lists and data frames but not for named atomic vectors.</p>
<div data-snippet-clipboard-copy-content="#Data frames are fine.
head(within(mtcars, remove(&#34;mpg&#34;)))
##                   cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4           6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag       6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710          4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive      6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant             6  225 105 2.76 3.460 20.22  1  0    3    1
#Named atmomic vectord are not.
## &gt; within(setNames(letters, LETTERS), remove(&#34;Z&#34;))
## Error in UseMethod(&#34;within&#34;) : 
##   no applicable method for &#39;within&#39; applied to an object of class &#34;character&#34;"><pre><span><span>#</span>Data frames are fine.</span>
head(within(<span>mtcars</span>, remove(<span><span>&#34;</span>mpg<span>&#34;</span></span>)))
<span><span>#</span>#                   cyl disp  hp drat    wt  qsec vs am gear carb</span>
<span><span>#</span># Mazda RX4           6  160 110 3.90 2.620 16.46  0  1    4    4</span>
<span><span>#</span># Mazda RX4 Wag       6  160 110 3.90 2.875 17.02  0  1    4    4</span>
<span><span>#</span># Datsun 710          4  108  93 3.85 2.320 18.61  1  1    4    1</span>
<span><span>#</span># Hornet 4 Drive      6  258 110 3.08 3.215 19.44  1  0    3    1</span>
<span><span>#</span># Hornet Sportabout   8  360 175 3.15 3.440 17.02  0  0    3    2</span>
<span><span>#</span># Valiant             6  225 105 2.76 3.460 20.22  1  0    3    1</span>
<span><span>#</span>Named atmomic vectord are not.</span>
<span><span>#</span># &gt; within(setNames(letters, LETTERS), remove(&#34;Z&#34;))</span>
<span><span>#</span># Error in UseMethod(&#34;within&#34;) : </span>
<span><span>#</span>#   no applicable method for &#39;within&#39; applied to an object of class &#34;character&#34;</span></pre></div>
</li>
<li>
<p dir="auto">When you want to work with the names of named atomic vectors, you
probably want to access their names directly and use expressions
like <code>namedVect[!names(namedVect) %in% c(&#34;remove&#34;, &#34;us&#34;)]</code>.</p>
<div data-snippet-clipboard-copy-content="namedVect &lt;- setNames(letters, LETTERS)
namedVect[!names(namedVect) %in% c(&#34;A&#34;, &#34;Z&#34;)]
##   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U 
## &#34;b&#34; &#34;c&#34; &#34;d&#34; &#34;e&#34; &#34;f&#34; &#34;g&#34; &#34;h&#34; &#34;i&#34; &#34;j&#34; &#34;k&#34; &#34;l&#34; &#34;m&#34; &#34;n&#34; &#34;o&#34; &#34;p&#34; &#34;q&#34; &#34;r&#34; &#34;s&#34; &#34;t&#34; &#34;u&#34; 
##   V   W   X   Y 
## &#34;v&#34; &#34;w&#34; &#34;x&#34; &#34;y&#34;"><pre><span>namedVect</span> <span>&lt;-</span> setNames(<span>letters</span>, <span>LETTERS</span>)
<span>namedVect</span>[<span>!</span>names(<span>namedVect</span>) <span>%in%</span> c(<span><span>&#34;</span>A<span>&#34;</span></span>, <span><span>&#34;</span>Z<span>&#34;</span></span>)]
<span><span>#</span>#   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U </span>
<span><span>#</span># &#34;b&#34; &#34;c&#34; &#34;d&#34; &#34;e&#34; &#34;f&#34; &#34;g&#34; &#34;h&#34; &#34;i&#34; &#34;j&#34; &#34;k&#34; &#34;l&#34; &#34;m&#34; &#34;n&#34; &#34;o&#34; &#34;p&#34; &#34;q&#34; &#34;r&#34; &#34;s&#34; &#34;t&#34; &#34;u&#34; </span>
<span><span>#</span>#   V   W   X   Y </span>
<span><span>#</span># &#34;v&#34; &#34;w&#34; &#34;x&#34; &#34;y&#34;</span></pre></div>
<p dir="auto">However, this is a bad habit for non-atomic vectors because, unless
you take the precautions <a href="#452-removing-dimensions">mentioned
earlier</a>, <code>[</code> likes to remove duplicated
names and unnecessary dimensions from your data.</p>
</li>
<li>
<p dir="auto">Don’t think that functional programming will save you from my
previous point. The base library’s higher-order functions don’t play
nice with the <code>names()</code> function. I think it’s got something to do
with <code>lapply()</code> using <code>X[[i]]</code> under the hood (see its
documentation).</p>
<div data-snippet-clipboard-copy-content="namedVect &lt;- setNames(letters, LETTERS)
Filter(function(x) names(x) == &#34;A&#34;, namedVect)
## named character(0)
head(lapply(namedVect, function(x) names(x) == &#34;A&#34;))
## $A
## logical(0)
## 
## $B
## logical(0)
## 
## $C
## logical(0)
## 
## $D
## logical(0)
## 
## $E
## logical(0)
## 
## $F
## logical(0)
head(sapply(namedVect, function(x) names(x) == &#34;A&#34;))
## $A
## logical(0)
## 
## $B
## logical(0)
## 
## $C
## logical(0)
## 
## $D
## logical(0)
## 
## $E
## logical(0)
## 
## $F
## logical(0)"><pre><span>namedVect</span> <span>&lt;-</span> setNames(<span>letters</span>, <span>LETTERS</span>)
Filter(<span>function</span>(<span>x</span>) names(<span>x</span>) <span>==</span> <span><span>&#34;</span>A<span>&#34;</span></span>, <span>namedVect</span>)
<span><span>#</span># named character(0)</span>
head(lapply(<span>namedVect</span>, <span>function</span>(<span>x</span>) names(<span>x</span>) <span>==</span> <span><span>&#34;</span>A<span>&#34;</span></span>))
<span><span>#</span># $A</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $B</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $C</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $D</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $E</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $F</span>
<span><span>#</span># logical(0)</span>
head(sapply(<span>namedVect</span>, <span>function</span>(<span>x</span>) names(<span>x</span>) <span>==</span> <span><span>&#34;</span>A<span>&#34;</span></span>))
<span><span>#</span># $A</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $B</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $C</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $D</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $E</span>
<span><span>#</span># logical(0)</span>
<span><span>#</span># </span>
<span><span>#</span># $F</span>
<span><span>#</span># logical(0)</span></pre></div>
<p dir="auto">Did you notice that <code>Filter</code> and <code>lapply</code>’s arguments are in
inconsistent orders? A little bit more on that <a href="#472-the-functions">much
later</a>.</p>
</li>
</ul>
<p dir="auto">From the above few points, you can see that it’s hard to find a way to
manipulate named atomic vectors by their names that is both safe for
them and for other named objects. The only one that comes to mind is to
use <code>[</code> with the aforementioned precautions. That’s bad enough on its
own – it makes R feel unsafe and inconsistent – but it also makes named
atomic vectors feel like an afterthought. I find that most of my code
that makes extended use of named atomic vectors comes out looking
disturbingly unidiomatic. A little bit more on that <a href="#473-extended-example-matrices">when I talk about
matrices</a>.</p>
<h3 dir="auto"><a id="user-content-456-silence" aria-hidden="true" href="#456-silence"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.5.6 Silence</h3>
<p dir="auto">I’ve already given a few examples of R either silently doing nothing or
silently doing what you don’t want. Let’s have a few more:</p>
<ul dir="auto">
<li>
<p dir="auto">Again, much of what I’ve listed in the <a href="#454-indistinguishable-errors">Indistinguishable
Errors</a> and <a href="#452-removing-dimensions">Removing
Dimensions</a> sections occur silently.</p>
</li>
<li>
<p dir="auto">As documented
<a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Indexing-by-vectors" rel="nofollow">here</a>,
negative out-of-bounds values are silently disregarded when deleting
elements. For example, if you have <code>x &lt;- 1:10</code>, then <code>x[-20]</code>
returns an unmodified version of <code>x</code> without warning or error.</p>
<div data-snippet-clipboard-copy-content="x &lt;- 1:10
x[20]
## [1] NA
x
##  [1]  1  2  3  4  5  6  7  8  9 10
x[-20]
##  [1]  1  2  3  4  5  6  7  8  9 10
identical(x, x[-20])
## [1] TRUE"><pre><span>x</span> <span>&lt;-</span> <span>1</span><span>:</span><span>10</span>
<span>x</span>[<span>20</span>]
<span><span>#</span># [1] NA</span>
<span>x</span>
<span><span>#</span>#  [1]  1  2  3  4  5  6  7  8  9 10</span>
<span>x</span>[<span>-</span><span>20</span>]
<span><span>#</span>#  [1]  1  2  3  4  5  6  7  8  9 10</span>
identical(<span>x</span>, <span>x</span>[<span>-</span><span>20</span>])
<span><span>#</span># [1] TRUE</span></pre></div>
<p dir="auto">Given that <code>x[20]</code> is <code>NA</code> – a questionable decision in of itself –
is this the behaviour that you expected?</p>
</li>
<li>
<p dir="auto">Subassigning <code>NULL</code> to a column that your data does not have does
not give a warning or error. For example, trying to access
<code>mtcars[&#34;weight&#34;]</code> is an error, but <code>mtcars[&#34;weight&#34;] &lt;- NULL</code>
silently does nothing. <code>$</code> and <code>$&lt;-</code> have the same issue.</p>
</li>
<li>
<p dir="auto">Using <code>within()</code> to remove unwanted columns from your data,
e.g. <code>within(data, rm(colName1, colName2))</code>, does nothing to any
columns with duplicated names. Again, no warning or error…</p>
<div data-snippet-clipboard-copy-content="dupe &lt;- cbind(mtcars, foo = 3, foo = 4)
head(dupe)
##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb foo foo
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   3   4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   3   4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   3   4
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   3   4
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   3   4
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   3   4
head(within(dupe, rm(carb, foo)))
##                    mpg cyl disp  hp drat    wt  qsec vs am gear foo foo
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4   4   4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4   4   4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4   4   4
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3   4   4
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3   4   4
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3   4   4"><pre><span>dupe</span> <span>&lt;-</span> cbind(<span>mtcars</span>, <span>foo</span> <span>=</span> <span>3</span>, <span>foo</span> <span>=</span> <span>4</span>)
head(<span>dupe</span>)
<span><span>#</span>#                    mpg cyl disp  hp drat    wt  qsec vs am gear carb foo foo</span>
<span><span>#</span># Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   3   4</span>
<span><span>#</span># Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   3   4</span>
<span><span>#</span># Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   3   4</span>
<span><span>#</span># Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   3   4</span>
<span><span>#</span># Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   3   4</span>
<span><span>#</span># Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   3   4</span>
head(within(<span>dupe</span>, rm(<span>carb</span>, <span>foo</span>)))
<span><span>#</span>#                    mpg cyl disp  hp drat    wt  qsec vs am gear foo foo</span>
<span><span>#</span># Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4   4   4</span>
<span><span>#</span># Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4   4   4</span>
<span><span>#</span># Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4   4   4</span>
<span><span>#</span># Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3   4   4</span>
<span><span>#</span># Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3   4   4</span>
<span><span>#</span># Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3   4   4</span></pre></div>
<p dir="auto">By the way, <code>cbind()</code> doesn’t silently correct duplicated column
names. By now, you probably expected otherwise. This is documented
behaviour, but I don’t think that anyone ever bothered to read the
docs for <code>cbind()</code>.</p>
</li>
<li>
<p dir="auto">Using <code>subset()</code> rather than <code>within()</code> is sometimes suggested for
operations like what I was trying to do in the previous point. For
example, you can remove columns with
<code>subset(data, select = -c(colName1, colName2))</code>. However, for
duplicated names, I’d argue that <code>subset()</code> is even weirder than
<code>within()</code>. With <code>subset()</code>, attempting to remove a duplicated
column by name will only remove the first such column and removing
any non-duplicated column will change the names of your duplicated
columns.</p>
<div data-snippet-clipboard-copy-content="#First, I&#39;ll show subset() working as normal and save us some space.
mtcars2 &lt;- subset(mtcars, mpg &gt; 25, select = -c(cyl, disp, hp, wt))
mtcars2
##                 mpg drat  qsec vs am gear carb
## Fiat 128       32.4 4.08 19.47  1  1    4    1
## Honda Civic    30.4 4.93 18.52  1  1    4    2
## Toyota Corolla 33.9 4.22 19.90  1  1    4    1
## Fiat X1-9      27.3 4.08 18.90  1  1    4    1
## Porsche 914-2  26.0 4.43 16.70  0  1    5    2
## Lotus Europa   30.4 3.77 16.90  1  1    5    2
dupe &lt;- cbind(mtcars2, foo = 3, foo = 4, foo = 5)
dupe
##                 mpg drat  qsec vs am gear carb foo foo foo
## Fiat 128       32.4 4.08 19.47  1  1    4    1   3   4   5
## Honda Civic    30.4 4.93 18.52  1  1    4    2   3   4   5
## Toyota Corolla 33.9 4.22 19.90  1  1    4    1   3   4   5
## Fiat X1-9      27.3 4.08 18.90  1  1    4    1   3   4   5
## Porsche 914-2  26.0 4.43 16.70  0  1    5    2   3   4   5
## Lotus Europa   30.4 3.77 16.90  1  1    5    2   3   4   5
subset(dupe, select = -foo)#Names have silently changed and only one foo was dropped.
##                 mpg drat  qsec vs am gear carb foo foo.1
## Fiat 128       32.4 4.08 19.47  1  1    4    1   4     5
## Honda Civic    30.4 4.93 18.52  1  1    4    2   4     5
## Toyota Corolla 33.9 4.22 19.90  1  1    4    1   4     5
## Fiat X1-9      27.3 4.08 18.90  1  1    4    1   4     5
## Porsche 914-2  26.0 4.43 16.70  0  1    5    2   4     5
## Lotus Europa   30.4 3.77 16.90  1  1    5    2   4     5
subset(dupe, select = -c(foo, foo))#Identical to previous.
##                 mpg drat  qsec vs am gear carb foo foo.1
## Fiat 128       32.4 4.08 19.47  1  1    4    1   4     5
## Honda Civic    30.4 4.93 18.52  1  1    4    2   4     5
## Toyota Corolla 33.9 4.22 19.90  1  1    4    1   4     5
## Fiat X1-9      27.3 4.08 18.90  1  1    4    1   4     5
## Porsche 914-2  26.0 4.43 16.70  0  1    5    2   4     5
## Lotus Europa   30.4 3.77 16.90  1  1    5    2   4     5
subset(dupe, select = -carb)#Foo&#39;s names have silently changed, despite us not touching foo!
##                 mpg drat  qsec vs am gear foo foo.1 foo.2
## Fiat 128       32.4 4.08 19.47  1  1    4   3     4     5
## Honda Civic    30.4 4.93 18.52  1  1    4   3     4     5
## Toyota Corolla 33.9 4.22 19.90  1  1    4   3     4     5
## Fiat X1-9      27.3 4.08 18.90  1  1    4   3     4     5
## Porsche 914-2  26.0 4.43 16.70  0  1    5   3     4     5
## Lotus Europa   30.4 3.77 16.90  1  1    5   3     4     5
subset(dupe, select = -c(carb, foo))#Names have silently changed and only one foo was dropped.
##                 mpg drat  qsec vs am gear foo foo.1
## Fiat 128       32.4 4.08 19.47  1  1    4   4     5
## Honda Civic    30.4 4.93 18.52  1  1    4   4     5
## Toyota Corolla 33.9 4.22 19.90  1  1    4   4     5
## Fiat X1-9      27.3 4.08 18.90  1  1    4   4     5
## Porsche 914-2  26.0 4.43 16.70  0  1    5   4     5
## Lotus Europa   30.4 3.77 16.90  1  1    5   4     5"><pre><span><span>#</span>First, I&#39;ll show subset() working as normal and save us some space.</span>
<span>mtcars2</span> <span>&lt;-</span> subset(<span>mtcars</span>, <span>mpg</span> <span>&gt;</span> <span>25</span>, <span>select</span> <span>=</span> <span>-</span>c(<span>cyl</span>, <span>disp</span>, <span>hp</span>, <span>wt</span>))
<span>mtcars2</span>
<span><span>#</span>#                 mpg drat  qsec vs am gear carb</span>
<span><span>#</span># Fiat 128       32.4 4.08 19.47  1  1    4    1</span>
<span><span>#</span># Honda Civic    30.4 4.93 18.52  1  1    4    2</span>
<span><span>#</span># Toyota Corolla 33.9 4.22 19.90  1  1    4    1</span>
<span><span>#</span># Fiat X1-9      27.3 4.08 18.90  1  1    4    1</span>
<span><span>#</span># Porsche 914-2  26.0 4.43 16.70  0  1    5    2</span>
<span><span>#</span># Lotus Europa   30.4 3.77 16.90  1  1    5    2</span>
<span>dupe</span> <span>&lt;-</span> cbind(<span>mtcars2</span>, <span>foo</span> <span>=</span> <span>3</span>, <span>foo</span> <span>=</span> <span>4</span>, <span>foo</span> <span>=</span> <span>5</span>)
<span>dupe</span>
<span><span>#</span>#                 mpg drat  qsec vs am gear carb foo foo foo</span>
<span><span>#</span># Fiat 128       32.4 4.08 19.47  1  1    4    1   3   4   5</span>
<span><span>#</span># Honda Civic    30.4 4.93 18.52  1  1    4    2   3   4   5</span>
<span><span>#</span># Toyota Corolla 33.9 4.22 19.90  1  1    4    1   3   4   5</span>
<span><span>#</span># Fiat X1-9      27.3 4.08 18.90  1  1    4    1   3   4   5</span>
<span><span>#</span># Porsche 914-2  26.0 4.43 16.70  0  1    5    2   3   4   5</span>
<span><span>#</span># Lotus Europa   30.4 3.77 16.90  1  1    5    2   3   4   5</span>
subset(<span>dupe</span>, <span>select</span> <span>=</span> <span>-</span><span>foo</span>)<span><span>#</span>Names have silently changed and only one foo was dropped.</span>
<span><span>#</span>#                 mpg drat  qsec vs am gear carb foo foo.1</span>
<span><span>#</span># Fiat 128       32.4 4.08 19.47  1  1    4    1   4     5</span>
<span><span>#</span># Honda Civic    30.4 4.93 18.52  1  1    4    2   4     5</span>
<span><span>#</span># Toyota Corolla 33.9 4.22 19.90  1  1    4    1   4     5</span>
<span><span>#</span># Fiat X1-9      27.3 4.08 18.90  1  1    4    1   4     5</span>
<span><span>#</span># Porsche 914-2  26.0 4.43 16.70  0  1    5    2   4     5</span>
<span><span>#</span># Lotus Europa   30.4 3.77 16.90  1  1    5    2   4     5</span>
subset(<span>dupe</span>, <span>select</span> <span>=</span> <span>-</span>c(<span>foo</span>, <span>foo</span>))<span><span>#</span>Identical to previous.</span>
<span><span>#</span>#                 mpg drat  qsec vs am gear carb foo foo.1</span>
<span><span>#</span># Fiat 128       32.4 4.08 19.47  1  1    4    1   4     5</span>
<span><span>#</span># Honda Civic    30.4 4.93 18.52  1  1    4    2   4     5</span>
<span><span>#</span># Toyota Corolla 33.9 4.22 19.90  1  1    4    1   4     5</span>
<span><span>#</span># Fiat X1-9      27.3 4.08 18.90  1  1    4    1   4     5</span>
<span><span>#</span># Porsche 914-2  26.0 4.43 16.70  0  1    5    2   4     5</span>
<span><span>#</span># Lotus Europa   30.4 3.77 16.90  1  1    5    2   4     5</span>
subset(<span>dupe</span>, <span>select</span> <span>=</span> <span>-</span><span>carb</span>)<span><span>#</span>Foo&#39;s names have silently changed, despite us not touching foo!</span>
<span><span>#</span>#                 mpg drat  qsec vs am gear foo foo.1 foo.2</span>
<span><span>#</span># Fiat 128       32.4 4.08 19.47  1  1    4   3     4     5</span>
<span><span>#</span># Honda Civic    30.4 4.93 18.52  1  1    4   3     4     5</span>
<span><span>#</span># Toyota Corolla 33.9 4.22 19.90  1  1    4   3     4     5</span>
<span><span>#</span># Fiat X1-9      27.3 4.08 18.90  1  1    4   3     4     5</span>
<span><span>#</span># Porsche 914-2  26.0 4.43 16.70  0  1    5   3     4     5</span>
<span><span>#</span># Lotus Europa   30.4 3.77 16.90  1  1    5   3     4     5</span>
subset(<span>dupe</span>, <span>select</span> <span>=</span> <span>-</span>c(<span>carb</span>, <span>foo</span>))<span><span>#</span>Names have silently changed and only one foo was dropped.</span>
<span><span>#</span>#                 mpg drat  qsec vs am gear foo foo.1</span>
<span><span>#</span># Fiat 128       32.4 4.08 19.47  1  1    4   4     5</span>
<span><span>#</span># Honda Civic    30.4 4.93 18.52  1  1    4   4     5</span>
<span><span>#</span># Toyota Corolla 33.9 4.22 19.90  1  1    4   4     5</span>
<span><span>#</span># Fiat X1-9      27.3 4.08 18.90  1  1    4   4     5</span>
<span><span>#</span># Porsche 914-2  26.0 4.43 16.70  0  1    5   4     5</span>
<span><span>#</span># Lotus Europa   30.4 3.77 16.90  1  1    5   4     5</span></pre></div>
<p dir="auto">I think that the worst example here is
<code>subset(dupe, select = -carb)</code>. I didn’t touch <code>foo</code>, so why change
it? I’d rather have <code>within()</code>’s silent inaction than <code>subset()</code>’s
silent sabotage.</p>
</li>
</ul>
<p dir="auto">Needless to say, there will be more examples of R silently misbehaving
later on in this document. This was just a good place to throw in a few
that are specific to subsetting.</p>
<h3 dir="auto"><a id="user-content-457-subsetting-by-predicates" aria-hidden="true" href="#457-subsetting-by-predicates"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.5.7 Subsetting by Predicates</h3>
<p dir="auto">This should be easy, shouldn’t it? Go through the data and only give me
the bits that have the property that I’m asking for. What could possibly
go wrong? Turns out, it’s quite a lot. Even predicates as simple as
“<em>does the element equal <code>x</code>?</em>” are a minefield. I understand why these
examples are the way that they are – really, I do – but how to delete
unwanted elements is one of the first things that you’re going to want
to learn in a stats language. For something that you’re going to want to
be able to do on day one of using R, there are far too many pitfalls.</p>
<ul dir="auto">
<li>
<p dir="auto">You might think that <code>setdiff()</code> is sufficient for removing data –
it’s certainly the first thing tool that a mathematician would reach
for – but it has the side-effect of removing duplicate entries from
the original vector and destroying your data structures by applying
<code>as.vector()</code> to them.</p>
<div data-snippet-clipboard-copy-content="Nile
## Time Series:
## Start = 1871 
## End = 1970 
## Frequency = 1 
##   [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020
##  [16]  960 1180  799  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840
##  [31]  874  694  940  833  701  916  692 1020 1050  969  831  726  456  824  702
##  [46] 1120 1100  832  764  821  768  845  864  862  698  845  744  796 1040  759
##  [61]  781  865  845  944  984  897  822 1010  771  676  649  846  812  742  801
##  [76] 1040  860  874  848  890  744  749  838 1050  918  986  797  923  975  815
##  [91] 1020  906  901 1170  912  746  919  718  714  740
setdiff(Nile, 1160)#Not a time series any more.
##  [1] 1120  963 1210  813 1230 1370 1140  995  935 1110  994 1020  960 1180  799
## [16]  958 1100 1150 1250 1260 1220 1030  774  840  874  694  940  833  701  916
## [31]  692 1050  969  831  726  456  824  702  832  764  821  768  845  864  862
## [46]  698  744  796 1040  759  781  865  944  984  897  822 1010  771  676  649
## [61]  846  812  742  801  860  848  890  749  838  918  986  797  923  975  815
## [76]  906  901 1170  912  746  919  718  714  740
setdiff(Nile, 0)#Hey, where did the other 1160s go?
##  [1] 1120 1160  963 1210  813 1230 1370 1140  995  935 1110  994 1020  960 1180
## [16]  799  958 1100 1150 1250 1260 1220 1030  774  840  874  694  940  833  701
## [31]  916  692 1050  969  831  726  456  824  702  832  764  821  768  845  864
## [46]  862  698  744  796 1040  759  781  865  944  984  897  822 1010  771  676
## [61]  649  846  812  742  801  860  848  890  749  838  918  986  797  923  975
## [76]  815  906  901 1170  912  746  919  718  714  740"><pre><span>Nile</span>
<span><span>#</span># Time Series:</span>
<span><span>#</span># Start = 1871 </span>
<span><span>#</span># End = 1970 </span>
<span><span>#</span># Frequency = 1 </span>
<span><span>#</span>#   [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020</span>
<span><span>#</span>#  [16]  960 1180  799  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840</span>
<span><span>#</span>#  [31]  874  694  940  833  701  916  692 1020 1050  969  831  726  456  824  702</span>
<span><span>#</span>#  [46] 1120 1100  832  764  821  768  845  864  862  698  845  744  796 1040  759</span>
<span><span>#</span>#  [61]  781  865  845  944  984  897  822 1010  771  676  649  846  812  742  801</span>
<span><span>#</span>#  [76] 1040  860  874  848  890  744  749  838 1050  918  986  797  923  975  815</span>
<span><span>#</span>#  [91] 1020  906  901 1170  912  746  919  718  714  740</span>
setdiff(<span>Nile</span>, <span>1160</span>)<span><span>#</span>Not a time series any more.</span>
<span><span>#</span>#  [1] 1120  963 1210  813 1230 1370 1140  995  935 1110  994 1020  960 1180  799</span>
<span><span>#</span># [16]  958 1100 1150 1250 1260 1220 1030  774  840  874  694  940  833  701  916</span>
<span><span>#</span># [31]  692 1050  969  831  726  456  824  702  832  764  821  768  845  864  862</span>
<span><span>#</span># [46]  698  744  796 1040  759  781  865  944  984  897  822 1010  771  676  649</span>
<span><span>#</span># [61]  846  812  742  801  860  848  890  749  838  918  986  797  923  975  815</span>
<span><span>#</span># [76]  906  901 1170  912  746  919  718  714  740</span>
setdiff(<span>Nile</span>, <span>0</span>)<span><span>#</span>Hey, where did the other 1160s go?</span>
<span><span>#</span>#  [1] 1120 1160  963 1210  813 1230 1370 1140  995  935 1110  994 1020  960 1180</span>
<span><span>#</span># [16]  799  958 1100 1150 1250 1260 1220 1030  774  840  874  694  940  833  701</span>
<span><span>#</span># [31]  916  692 1050  969  831  726  456  824  702  832  764  821  768  845  864</span>
<span><span>#</span># [46]  862  698  744  796 1040  759  781  865  944  984  897  822 1010  771  676</span>
<span><span>#</span># [61]  649  846  812  742  801  860  848  890  749  838  918  986  797  923  975</span>
<span><span>#</span># [76]  815  906  901 1170  912  746  919  718  714  740</span></pre></div>
<p dir="auto">It’s more safe if you’re dealing with names,
e.g. <code>data[setdiff(names(data), &#34;nameOfThingToDelete&#34;)]</code></p>
<div data-snippet-clipboard-copy-content="head(mtcars)
##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
head(mtcars[setdiff(names(mtcars), &#34;wt&#34;)])
##                    mpg cyl disp  hp drat  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 20.22  1  0    3    1"><pre>head(<span>mtcars</span>)
<span><span>#</span>#                    mpg cyl disp  hp drat    wt  qsec vs am gear carb</span>
<span><span>#</span># Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4</span>
<span><span>#</span># Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4</span>
<span><span>#</span># Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1</span>
<span><span>#</span># Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1</span>
<span><span>#</span># Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2</span>
<span><span>#</span># Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</span>
head(<span>mtcars</span>[setdiff(names(<span>mtcars</span>), <span><span>&#34;</span>wt<span>&#34;</span></span>)])
<span><span>#</span>#                    mpg cyl disp  hp drat  qsec vs am gear carb</span>
<span><span>#</span># Mazda RX4         21.0   6  160 110 3.90 16.46  0  1    4    4</span>
<span><span>#</span># Mazda RX4 Wag     21.0   6  160 110 3.90 17.02  0  1    4    4</span>
<span><span>#</span># Datsun 710        22.8   4  108  93 3.85 18.61  1  1    4    1</span>
<span><span>#</span># Hornet 4 Drive    21.4   6  258 110 3.08 19.44  1  0    3    1</span>
<span><span>#</span># Hornet Sportabout 18.7   8  360 175 3.15 17.02  0  0    3    2</span>
<span><span>#</span># Valiant           18.1   6  225 105 2.76 20.22  1  0    3    1</span></pre></div>
<p dir="auto">but anything that’s only sometimes safe doesn’t fill me with
confidence.</p>
</li>
<li>
<p dir="auto">Because <code>which()</code> is an extremely intuitive function for
extracting/changing subsets of your data and for dealing with
missing values (see <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a>,
section 8.1.12), it is one of the first things that a beginner will
learn about. However, although your intuition is screaming for you
to do it, you almost never want to use
<code>data &lt;- data[-which(data==thingToDelete)]</code>. The problem with this
is that when <code>which()</code> finds no matches, it evaluates to something
of length 0, so <code>data[-which(data==thingToDelete)]</code> also returns
something of length 0, deleting your data.</p>
<div data-snippet-clipboard-copy-content="Nile
## Time Series:
## Start = 1871 
## End = 1970 
## Frequency = 1 
##   [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020
##  [16]  960 1180  799  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840
##  [31]  874  694  940  833  701  916  692 1020 1050  969  831  726  456  824  702
##  [46] 1120 1100  832  764  821  768  845  864  862  698  845  744  796 1040  759
##  [61]  781  865  845  944  984  897  822 1010  771  676  649  846  812  742  801
##  [76] 1040  860  874  848  890  744  749  838 1050  918  986  797  923  975  815
##  [91] 1020  906  901 1170  912  746  919  718  714  740
Nile[-which(Nile==1160)]#This is fine.
##  [1] 1120  963 1210  813 1230 1370 1140  995  935 1110  994 1020  960 1180  799
## [16]  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840  874  694  940
## [31]  833  701  916  692 1020 1050  969  831  726  456  824  702 1120 1100  832
## [46]  764  821  768  845  864  862  698  845  744  796 1040  759  781  865  845
## [61]  944  984  897  822 1010  771  676  649  846  812  742  801 1040  860  874
## [76]  848  890  744  749  838 1050  918  986  797  923  975  815 1020  906  901
## [91] 1170  912  746  919  718  714  740
which(Nile==11600)
## integer(0)
Nile[-which(Nile==11600)]#This is not.
## numeric(0)"><pre><span>Nile</span>
<span><span>#</span># Time Series:</span>
<span><span>#</span># Start = 1871 </span>
<span><span>#</span># End = 1970 </span>
<span><span>#</span># Frequency = 1 </span>
<span><span>#</span>#   [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020</span>
<span><span>#</span>#  [16]  960 1180  799  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840</span>
<span><span>#</span>#  [31]  874  694  940  833  701  916  692 1020 1050  969  831  726  456  824  702</span>
<span><span>#</span>#  [46] 1120 1100  832  764  821  768  845  864  862  698  845  744  796 1040  759</span>
<span><span>#</span>#  [61]  781  865  845  944  984  897  822 1010  771  676  649  846  812  742  801</span>
<span><span>#</span>#  [76] 1040  860  874  848  890  744  749  838 1050  918  986  797  923  975  815</span>
<span><span>#</span>#  [91] 1020  906  901 1170  912  746  919  718  714  740</span>
<span>Nile</span>[<span>-</span>which(<span>Nile</span><span>==</span><span>1160</span>)]<span><span>#</span>This is fine.</span>
<span><span>#</span>#  [1] 1120  963 1210  813 1230 1370 1140  995  935 1110  994 1020  960 1180  799</span>
<span><span>#</span># [16]  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840  874  694  940</span>
<span><span>#</span># [31]  833  701  916  692 1020 1050  969  831  726  456  824  702 1120 1100  832</span>
<span><span>#</span># [46]  764  821  768  845  864  862  698  845  744  796 1040  759  781  865  845</span>
<span><span>#</span># [61]  944  984  897  822 1010  771  676  649  846  812  742  801 1040  860  874</span>
<span><span>#</span># [76]  848  890  744  749  838 1050  918  986  797  923  975  815 1020  906  901</span>
<span><span>#</span># [91] 1170  912  746  919  718  714  740</span>
which(<span>Nile</span><span>==</span><span>11600</span>)
<span><span>#</span># integer(0)</span>
<span>Nile</span>[<span>-</span>which(<span>Nile</span><span>==</span><span>11600</span>)]<span><span>#</span>This is not.</span>
<span><span>#</span># numeric(0)</span></pre></div>
<p dir="auto">What you probably expected was <code>which()</code> leaving your data unchanged
when it has not found a match. You might also have expected a
warning or error, but surely you’ve learned your lesson by now?
Anyway, section 8.1.13 of <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a>
offers some ways to get this behaviour, but the only
practical-looking suggestion is <code>data[!(data %in% thingToDelete)]</code>.
I think that you can get away with removing the curly brackets
there.</p>
<div data-snippet-clipboard-copy-content="Nile[!Nile %in% 1160]
##  [1] 1120  963 1210  813 1230 1370 1140  995  935 1110  994 1020  960 1180  799
## [16]  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840  874  694  940
## [31]  833  701  916  692 1020 1050  969  831  726  456  824  702 1120 1100  832
## [46]  764  821  768  845  864  862  698  845  744  796 1040  759  781  865  845
## [61]  944  984  897  822 1010  771  676  649  846  812  742  801 1040  860  874
## [76]  848  890  744  749  838 1050  918  986  797  923  975  815 1020  906  901
## [91] 1170  912  746  919  718  714  740
Nile[!Nile %in% 11600]
##   [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020
##  [16]  960 1180  799  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840
##  [31]  874  694  940  833  701  916  692 1020 1050  969  831  726  456  824  702
##  [46] 1120 1100  832  764  821  768  845  864  862  698  845  744  796 1040  759
##  [61]  781  865  845  944  984  897  822 1010  771  676  649  846  812  742  801
##  [76] 1040  860  874  848  890  744  749  838 1050  918  986  797  923  975  815
##  [91] 1020  906  901 1170  912  746  919  718  714  740"><pre><span>Nile</span>[<span>!</span><span>Nile</span> <span>%in%</span> <span>1160</span>]
<span><span>#</span>#  [1] 1120  963 1210  813 1230 1370 1140  995  935 1110  994 1020  960 1180  799</span>
<span><span>#</span># [16]  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840  874  694  940</span>
<span><span>#</span># [31]  833  701  916  692 1020 1050  969  831  726  456  824  702 1120 1100  832</span>
<span><span>#</span># [46]  764  821  768  845  864  862  698  845  744  796 1040  759  781  865  845</span>
<span><span>#</span># [61]  944  984  897  822 1010  771  676  649  846  812  742  801 1040  860  874</span>
<span><span>#</span># [76]  848  890  744  749  838 1050  918  986  797  923  975  815 1020  906  901</span>
<span><span>#</span># [91] 1170  912  746  919  718  714  740</span>
<span>Nile</span>[<span>!</span><span>Nile</span> <span>%in%</span> <span>11600</span>]
<span><span>#</span>#   [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020</span>
<span><span>#</span>#  [16]  960 1180  799  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840</span>
<span><span>#</span>#  [31]  874  694  940  833  701  916  692 1020 1050  969  831  726  456  824  702</span>
<span><span>#</span>#  [46] 1120 1100  832  764  821  768  845  864  862  698  845  744  796 1040  759</span>
<span><span>#</span>#  [61]  781  865  845  944  984  897  822 1010  771  676  649  846  812  742  801</span>
<span><span>#</span>#  [76] 1040  860  874  848  890  744  749  838 1050  918  986  797  923  975  815</span>
<span><span>#</span>#  [91] 1020  906  901 1170  912  746  919  718  714  740</span></pre></div>
<p dir="auto">That’s mostly okay. However,
<code>identical(Nile, Nile[!Nile %in% 11600])</code> is <code>FALSE</code>. Can you guess
why? It’s like R has no always safe ways to subset.</p>
</li>
<li>
<p dir="auto">At least removing elements that are equal to a particular number is
simple for vectors. Even for lists, it’s just <code>data[data!=x]</code>. It’s
maybe not what a beginner would guess (“<em>I have to write <code>data</code>
twice?</em>”), but it’s simple enough.</p>
</li>
<li>
<p dir="auto">For removing a vector from a list of vectors, you’re going to want
to learn some functional programming idioms. Not hard if you’re a
programmer, but shouldn’t this be easier in a stats and maths tool?
Anyway, you probably want
<code>Filter(function(x) all(x!=vectorToDelete), data)</code>. You can also do
it with the apply family, but I don’t see why you would.</p>
</li>
<li>
<p dir="auto">Removing what you don’t want from a data frame largely comes down to
mastering the subsetting rules, a nightmare that I’ve spent the
previous few thousand words covering. I often end up with very ugly
lines like
<code>outcomes[outcomes$playerChoice == playerChoice &amp; outcomes$computerChoice == computerChoice, &#34;outcome&#34;]</code></p>
</li>
<li>
<p dir="auto">Before you ask, <code>subset()</code>, <code>with()</code>, and <code>within()</code> aren’t good
enough either. I’ve already mentioned some of their issues, but
<a href="#4112-non-standard-evaluation">more on them later</a>.</p>
</li>
</ul>
<p dir="auto">Overall, it’s like R has no safe ways to subset. What is safe for one
job is often either unsafe, invalid, or inconsistent for another. R’s
huge set of subsetting tools is useful – maybe even good – once
mastered, but until then you’re forced to adopt a guess-and-check style
of programming and pray that you get a useful error/warning message when
you get something wrong. Worse still, these prayers are rarely answered
and, in the cases where R silently does something that you didn’t want,
they’re outright mocked. Do you understand how damning that is for a
stats language? I can’t stress this point enough. Subsetting in R should
be easy and intuitive. Instead, it’s something that I’ve managed to
produce thousands of words of complaints about and it still trips me up
with alarming regularity, despite my clear knowledge of the correct way
to do things. If I want a vector of consonants, you can bet that I’m
going to write <code>letters[-c(&#34;a&#34;, &#34;e&#34;, &#34;i&#34;, &#34;o&#34;, &#34;u&#34;)]</code>,
<code>letters[-which(letters == c(&#34;a&#34;, &#34;e&#34;, &#34;i&#34;, &#34;o&#34;, &#34;u&#34;))]</code>, and
<code>letters[c(&#34;a&#34;, &#34;e&#34;, &#34;i&#34;, &#34;o&#34;, &#34;u&#34;) %in% letters]</code> before remembering
the right way to do it. If I’m still making those mistakes for something
simple, then I can only imagine what it’s like for a true beginner doing
something complicated.</p>
<h2 dir="auto"><a id="user-content-46-vectorization-again" aria-hidden="true" href="#46-vectorization-again"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.6 Vectorization Again</h2>
<p dir="auto"><a href="#34-vectorization">You’ve heard the good</a>, now for the bad. R’s
vectorization is probably the best thing about the language and it will
work miracles when you’re wanting to do mathematics. However, it will
trip you up in other areas. A lot of these points are minor, but when
they cause you problems their source can be tough to track down. This is
because R is working as intended and therefore not giving you any
warnings or errors (spotting a pattern?). Furthermore, if you have
correctly identified that you have a vectorization problem, then pretty
much any function in R could be to blame, because most of R’s functions
are vectorized.</p>
<ul dir="auto">
<li>
<p dir="auto">The commonality of vectors leads to some new syntax that must be
memorised. For example, <code>if(x|y)</code> and <code>if(x||y)</code> are very different
and using <code>&amp;&amp;</code> rather than <code>&amp;</code> can be fatal. Compare the following:</p>
<div data-snippet-clipboard-copy-content="mtcars[mtcars$mpg &lt; 20 &amp;&amp; mtcars$hp &gt; 150,]
##  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
## &lt;0 rows&gt; (or 0-length row.names)
mtcars[mtcars$mpg &lt; 20 &amp; mtcars$hp &gt; 150,]
##                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
## Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
## Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
## Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
## Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
## Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
## Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
## Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
## Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
## Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
## Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
## Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
## Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8"><pre><span>mtcars</span>[<span>mtcars</span><span>$</span><span>mpg</span> <span>&lt;</span> <span>20</span> <span>&amp;&amp;</span> <span>mtcars</span><span>$</span><span>hp</span> <span>&gt;</span> <span>150</span>,]
<span><span>#</span>#  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb</span>
<span><span>#</span># &lt;0 rows&gt; (or 0-length row.names)</span>
<span>mtcars</span>[<span>mtcars</span><span>$</span><span>mpg</span> <span>&lt;</span> <span>20</span> <span>&amp;</span> <span>mtcars</span><span>$</span><span>hp</span> <span>&gt;</span> <span>150</span>,]
<span><span>#</span>#                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb</span>
<span><span>#</span># Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2</span>
<span><span>#</span># Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4</span>
<span><span>#</span># Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3</span>
<span><span>#</span># Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3</span>
<span><span>#</span># Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3</span>
<span><span>#</span># Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4</span>
<span><span>#</span># Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4</span>
<span><span>#</span># Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4</span>
<span><span>#</span># Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4</span>
<span><span>#</span># Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2</span>
<span><span>#</span># Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4</span>
<span><span>#</span># Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6</span>
<span><span>#</span># Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8</span></pre></div>
<p dir="auto">Personally, I find that it’s easy to remember to use <code>&amp;</code> for <code>if</code>
but I often forget to use <code>&amp;</code> for subsetting.</p>
</li>
<li>
<p dir="auto">The <code>if</code> statements accept vectors of length greater than 1 as their
predicate, but will only pay attention to the very first element.
This throws a warning and there is a global option to make it an
error instead, but I can’t see why R accepts such predicates at all.
Why would I ever use <code>if(c(TRUE, FALSE))</code> to mean “<em>if the first
element of my vector is true, then…</em>”? This is also what the <code>&amp;&amp;</code>
and <code>||</code> syntax is for (e.g. <code>c(TRUE, FALSE) &amp;&amp; c(TRUE, FALSE)</code> is
<code>TRUE</code>), but I still don’t see why anyone would use several logical
vectors and only be interested in their first elements.</p>
</li>
<li>
<p dir="auto">When dealing with anything 2D, you need to be very careful to not
mix up any of <code>length()</code>, <code>lengths()</code>, <code>nrow()</code>, or <code>ncol()</code>. In
particular, <code>length()</code> is so inconsistent that I’m unsure why they
let it work for 2D structures (<a href="#493-internal-generics">probably something to do with it
being an internal generic</a>). For example,
the length of a data frame is its number of columns and the length
of a matrix is its number of elements.</p>
<div data-snippet-clipboard-copy-content="(a &lt;- diag(4))
##      [,1] [,2] [,3] [,4]
## [1,]    1    0    0    0
## [2,]    0    1    0    0
## [3,]    0    0    1    0
## [4,]    0    0    0    1
(b &lt;- as.data.frame(a))
##   V1 V2 V3 V4
## 1  1  0  0  0
## 2  0  1  0  0
## 3  0  0  1  0
## 4  0  0  0  1
length(a)
## [1] 16
length(b)
## [1] 4"><pre>(<span>a</span> <span>&lt;-</span> diag(<span>4</span>))
<span><span>#</span>#      [,1] [,2] [,3] [,4]</span>
<span><span>#</span># [1,]    1    0    0    0</span>
<span><span>#</span># [2,]    0    1    0    0</span>
<span><span>#</span># [3,]    0    0    1    0</span>
<span><span>#</span># [4,]    0    0    0    1</span>
(<span>b</span> <span>&lt;-</span> as.data.frame(<span>a</span>))
<span><span>#</span>#   V1 V2 V3 V4</span>
<span><span>#</span># 1  1  0  0  0</span>
<span><span>#</span># 2  0  1  0  0</span>
<span><span>#</span># 3  0  0  1  0</span>
<span><span>#</span># 4  0  0  0  1</span>
length(<span>a</span>)
<span><span>#</span># [1] 16</span>
length(<span>b</span>)
<span><span>#</span># [1] 4</span></pre></div>
</li>
<li>
<p dir="auto">Vectors are collections and therefore inherit the previous section’s
issues about selecting elements.</p>
</li>
<li>
<p dir="auto">Because virtually everything is already a vector, you never know
what to use when you want a collection or anything nested. Lists?
Arrays? <code>c()</code>? Data frames? One of <code>cbind()</code>/<code>rbind()</code>? Matrices?
You get used to it eventually, but it takes a while to understand
the differences.</p>
</li>
<li>
<p dir="auto">Some functions are vectorized in such a way that you’re forced to
remember the difference between how they behave for n length-one
vectors and and how they behave for the corresponding single vector
of length n. For example, <code>paste(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;)</code> is not
the same as <code>paste(c(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;))</code>.</p>
<div data-snippet-clipboard-copy-content="paste(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;)
## [1] &#34;Alice Bob Charlie&#34;
paste(c(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;))
## [1] &#34;Alice&#34;   &#34;Bob&#34;     &#34;Charlie&#34;
paste(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;, collapse = &#34;&#34;)
## [1] &#34;Alice Bob Charlie&#34;
paste(c(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;), collapse = &#34;&#34;)
## [1] &#34;AliceBobCharlie&#34;"><pre>paste(<span><span>&#34;</span>Alice<span>&#34;</span></span>, <span><span>&#34;</span>Bob<span>&#34;</span></span>, <span><span>&#34;</span>Charlie<span>&#34;</span></span>)
<span><span>#</span># [1] &#34;Alice Bob Charlie&#34;</span>
paste(c(<span><span>&#34;</span>Alice<span>&#34;</span></span>, <span><span>&#34;</span>Bob<span>&#34;</span></span>, <span><span>&#34;</span>Charlie<span>&#34;</span></span>))
<span><span>#</span># [1] &#34;Alice&#34;   &#34;Bob&#34;     &#34;Charlie&#34;</span>
paste(<span><span>&#34;</span>Alice<span>&#34;</span></span>, <span><span>&#34;</span>Bob<span>&#34;</span></span>, <span><span>&#34;</span>Charlie<span>&#34;</span></span>, <span>collapse</span> <span>=</span> <span><span>&#34;</span><span>&#34;</span></span>)
<span><span>#</span># [1] &#34;Alice Bob Charlie&#34;</span>
paste(c(<span><span>&#34;</span>Alice<span>&#34;</span></span>, <span><span>&#34;</span>Bob<span>&#34;</span></span>, <span><span>&#34;</span>Charlie<span>&#34;</span></span>), <span>collapse</span> <span>=</span> <span><span>&#34;</span><span>&#34;</span></span>)
<span><span>#</span># [1] &#34;AliceBobCharlie&#34;</span></pre></div>
<p dir="auto">I’m not saying that this doesn’t make sense, but it is a source of
unpredictability.</p>
</li>
<li>
<p dir="auto">Another unpredictable example: What does
<code>max(100:200, 250:350, 276)</code> return? You might be surprised to
discover that the output is the single number <code>350</code>, rather than a
vector of many outputs.</p>
<div data-snippet-clipboard-copy-content="max(100:200, 250:350, 276)
## [1] 350"><pre>max(<span>100</span><span>:</span><span>200</span>, <span>250</span><span>:</span><span>350</span>, <span>276</span>)
<span><span>#</span># [1] 350</span></pre></div>
<p dir="auto">The fix for this isn’t some <code>collapse</code>-like argument like it is for
<code>paste()</code>, it’s an entirely different function: <code>pmax()</code>. Why?</p>
<div data-snippet-clipboard-copy-content="pmax(100:200, 250:350, 276)
##   [1] 276 276 276 276 276 276 276 276 276 276 276 276 276 276 276 276 276 276
##  [19] 276 276 276 276 276 276 276 276 276 277 278 279 280 281 282 283 284 285
##  [37] 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303
##  [55] 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321
##  [73] 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339
##  [91] 340 341 342 343 344 345 346 347 348 349 350"><pre>pmax(<span>100</span><span>:</span><span>200</span>, <span>250</span><span>:</span><span>350</span>, <span>276</span>)
<span><span>#</span>#   [1] 276 276 276 276 276 276 276 276 276 276 276 276 276 276 276 276 276 276</span>
<span><span>#</span>#  [19] 276 276 276 276 276 276 276 276 276 277 278 279 280 281 282 283 284 285</span>
<span><span>#</span>#  [37] 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303</span>
<span><span>#</span>#  [55] 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321</span>
<span><span>#</span>#  [73] 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339</span>
<span><span>#</span>#  [91] 340 341 342 343 344 345 346 347 348 349 350</span></pre></div>
</li>
<li>
<p dir="auto">A further annoyance comes from how many things behave differently on
vectors of length one. For example, <code>sample(1:5)</code> is exactly the
same as <code>sample(5)</code>, which is bound to give you bugs when you use
<code>sample(5:n)</code> for changing <code>n</code>.</p>
</li>
<li>
<p dir="auto">R has rules for recycling vector elements when you try to get it to
do something with several vectors that don’t all have the same
length. You saw this abused when I gave the
<code>x &lt;- paste0(rep(&#34;&#34;, 100), c(&#34;&#34;, &#34;&#34;, &#34;Fizz&#34;), c(&#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;Buzz&#34;))</code>
FizzBuzz example. When recycling occurs, R only throws a warning if
the longest vector’s length is not a multiple of the others. For
example, neither <code>Map(sum, 1:6, 1:3)</code> nor that FizzBuzz line warn
you that recycling has occurred, but <code>Map(sum, 1:6, 1:4)</code> will.</p>
<div data-snippet-clipboard-copy-content="Map(sum, 1:6, 1:3)
## [[1]]
## [1] 2
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 6
## 
## [[4]]
## [1] 5
## 
## [[5]]
## [1] 7
## 
## [[6]]
## [1] 9
Map(sum, 1:6, 1:4)
## Warning in mapply(FUN = f, ..., SIMPLIFY = FALSE): longer argument not a
## multiple of length of shorter
## [[1]]
## [1] 2
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 6
## 
## [[4]]
## [1] 8
## 
## [[5]]
## [1] 6
## 
## [[6]]
## [1] 8"><pre>Map(<span>sum</span>, <span>1</span><span>:</span><span>6</span>, <span>1</span><span>:</span><span>3</span>)
<span><span>#</span># [[1]]</span>
<span><span>#</span># [1] 2</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span># [1] 4</span>
<span><span>#</span># </span>
<span><span>#</span># [[3]]</span>
<span><span>#</span># [1] 6</span>
<span><span>#</span># </span>
<span><span>#</span># [[4]]</span>
<span><span>#</span># [1] 5</span>
<span><span>#</span># </span>
<span><span>#</span># [[5]]</span>
<span><span>#</span># [1] 7</span>
<span><span>#</span># </span>
<span><span>#</span># [[6]]</span>
<span><span>#</span># [1] 9</span>
Map(<span>sum</span>, <span>1</span><span>:</span><span>6</span>, <span>1</span><span>:</span><span>4</span>)
<span><span>#</span># Warning in mapply(FUN = f, ..., SIMPLIFY = FALSE): longer argument not a</span>
<span><span>#</span># multiple of length of shorter</span>
<span><span>#</span># [[1]]</span>
<span><span>#</span># [1] 2</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span># [1] 4</span>
<span><span>#</span># </span>
<span><span>#</span># [[3]]</span>
<span><span>#</span># [1] 6</span>
<span><span>#</span># </span>
<span><span>#</span># [[4]]</span>
<span><span>#</span># [1] 8</span>
<span><span>#</span># </span>
<span><span>#</span># [[5]]</span>
<span><span>#</span># [1] 6</span>
<span><span>#</span># </span>
<span><span>#</span># [[6]]</span>
<span><span>#</span># [1] 8</span></pre></div>
<p dir="auto">The first case – where no warnings are given – can be an unexpected
source of major error. <a href="https://r4ds.had.co.nz/vectors.html#scalars-and-recycling-rules" rel="nofollow">The authors of the Tidyverse seem to agree
with
me</a>.
For example, you’re only allowed to recycle vectors of length 1 when
constructing a tibble, so <code>tibble(1:4, 1:2)</code> will throw a clear
error message whereas <code>data.frame(1:4, 1:2)</code> silently recycles the
second argument. Similarly, <code>map2(1:6, 1:3, sum)</code> is an error, but
<code>map2(1:6, 1, sum)</code> is not.</p>
<div data-snippet-clipboard-copy-content="library(tibble)
## &gt; tibble(1:4, 1:2)
## Error: Tibble columns must have compatible sizes.
## * Size 4: Existing data.
## * Size 2: Column at position 2.
## ℹ Only values of size one are recycled.
## Run `rlang::last_error()` to see where the error occurred.
data.frame(1:4, 1:2)
##   X1.4 X1.2
## 1    1    1
## 2    2    2
## 3    3    1
## 4    4    2
library(purrr)
## &gt; map2(1:6, 1:3, sum)
## Error: Mapped vectors must have consistent lengths:
## * `.x` has length 6
## * `.y` has length 3
map2(1:6, 1, sum)
## [[1]]
## [1] 2
## 
## [[2]]
## [1] 3
## 
## [[3]]
## [1] 4
## 
## [[4]]
## [1] 5
## 
## [[5]]
## [1] 6
## 
## [[6]]
## [1] 7"><pre>library(<span>tibble</span>)
<span><span>#</span># &gt; tibble(1:4, 1:2)</span>
<span><span>#</span># Error: Tibble columns must have compatible sizes.</span>
<span><span>#</span># * Size 4: Existing data.</span>
<span><span>#</span># * Size 2: Column at position 2.</span>
<span><span>#</span># ℹ Only values of size one are recycled.</span>
<span><span>#</span># Run `rlang::last_error()` to see where the error occurred.</span>
<span>data.frame</span>(<span>1</span><span>:</span><span>4</span>, <span>1</span><span>:</span><span>2</span>)
<span><span>#</span>#   X1.4 X1.2</span>
<span><span>#</span># 1    1    1</span>
<span><span>#</span># 2    2    2</span>
<span><span>#</span># 3    3    1</span>
<span><span>#</span># 4    4    2</span>
library(<span>purrr</span>)
<span><span>#</span># &gt; map2(1:6, 1:3, sum)</span>
<span><span>#</span># Error: Mapped vectors must have consistent lengths:</span>
<span><span>#</span># * `.x` has length 6</span>
<span><span>#</span># * `.y` has length 3</span>
map2(<span>1</span><span>:</span><span>6</span>, <span>1</span>, <span>sum</span>)
<span><span>#</span># [[1]]</span>
<span><span>#</span># [1] 2</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span># [1] 3</span>
<span><span>#</span># </span>
<span><span>#</span># [[3]]</span>
<span><span>#</span># [1] 4</span>
<span><span>#</span># </span>
<span><span>#</span># [[4]]</span>
<span><span>#</span># [1] 5</span>
<span><span>#</span># </span>
<span><span>#</span># [[5]]</span>
<span><span>#</span># [1] 6</span>
<span><span>#</span># </span>
<span><span>#</span># [[6]]</span>
<span><span>#</span># [1] 7</span></pre></div>
</li>
<li>
<p dir="auto">Section 8.1.6 of <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a>: The
recycling of vectors lets you attempt to do things that look correct
to a novice and make sense to a master, but are almost certainly not
what was wanted. For example, <code>c(4, 6) == 1:10</code> is <code>TRUE</code> only in
its sixth element. The recycling rules turn it in to
<code>c(4, 6, 4, 6, 4, 6, 4, 6, 4, 6) == 1:10</code>. Again, there is no
warning given to the user unless the longest vector’s length is not
a multiple of the other’s. In this case, what you wanted was
probably <code>c(4, 6) %in% 1:10</code>, maybe with a call to <code>all()</code>.</p>
<div data-snippet-clipboard-copy-content="c(4, 6) == 1:10
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
c(4, 6, 4, 6, 4, 6, 4, 6, 4, 6) == 1:10
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
c(4, 6) %in% 1:10
## [1] TRUE TRUE
all(c(4, 6) %in% 1:10)
## [1] TRUE"><pre>c(<span>4</span>, <span>6</span>) <span>==</span> <span>1</span><span>:</span><span>10</span>
<span><span>#</span>#  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE</span>
c(<span>4</span>, <span>6</span>, <span>4</span>, <span>6</span>, <span>4</span>, <span>6</span>, <span>4</span>, <span>6</span>, <span>4</span>, <span>6</span>) <span>==</span> <span>1</span><span>:</span><span>10</span>
<span><span>#</span>#  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE</span>
c(<span>4</span>, <span>6</span>) <span>%in%</span> <span>1</span><span>:</span><span>10</span>
<span><span>#</span># [1] TRUE TRUE</span>
all(c(<span>4</span>, <span>6</span>) <span>%in%</span> <span>1</span><span>:</span><span>10</span>)
<span><span>#</span># [1] TRUE</span></pre></div>
</li>
<li>
<p dir="auto">Some functions don’t recycle in the way that you would expect. For
example, read the documentation for <code>strsplit()</code> and ask yourself if
you expect <code>strsplit(&#34;Alice&#34;, c(&#34;l&#34;, &#34;c&#34;))</code> and
<code>strsplit(&#34;Alice&#34;, &#34;l&#34;)</code> to give the same output. If you think that
they don’t, you’re wrong. If you expected the first option to warn
you about the <code>&#34;c&#34;</code> part not being used, you’re sane, but wrong. If
you want to see how the second argument is supposed to work, re-run
the earlier code with <code>c(&#34;Alice&#34;, &#34;Boblice&#34;)</code> as your first
argument.</p>
<div data-snippet-clipboard-copy-content="strsplit(&#34;Alice&#34;, c(&#34;l&#34;, &#34;c&#34;))
## [[1]]
## [1] &#34;A&#34;   &#34;ice&#34;
strsplit(&#34;Alice&#34;, &#34;l&#34;)
## [[1]]
## [1] &#34;A&#34;   &#34;ice&#34;
strsplit(c(&#34;Alice&#34;, &#34;Boblice&#34;), c(&#34;l&#34;, &#34;c&#34;))
## [[1]]
## [1] &#34;A&#34;   &#34;ice&#34;
## 
## [[2]]
## [1] &#34;Bobli&#34; &#34;e&#34;"><pre>strsplit(<span><span>&#34;</span>Alice<span>&#34;</span></span>, c(<span><span>&#34;</span>l<span>&#34;</span></span>, <span><span>&#34;</span>c<span>&#34;</span></span>))
<span><span>#</span># [[1]]</span>
<span><span>#</span># [1] &#34;A&#34;   &#34;ice&#34;</span>
strsplit(<span><span>&#34;</span>Alice<span>&#34;</span></span>, <span><span>&#34;</span>l<span>&#34;</span></span>)
<span><span>#</span># [[1]]</span>
<span><span>#</span># [1] &#34;A&#34;   &#34;ice&#34;</span>
strsplit(c(<span><span>&#34;</span>Alice<span>&#34;</span></span>, <span><span>&#34;</span>Boblice<span>&#34;</span></span>), c(<span><span>&#34;</span>l<span>&#34;</span></span>, <span><span>&#34;</span>c<span>&#34;</span></span>))
<span><span>#</span># [[1]]</span>
<span><span>#</span># [1] &#34;A&#34;   &#34;ice&#34;</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span># [1] &#34;Bobli&#34; &#34;e&#34;</span></pre></div>
</li>
<li>
<p dir="auto">Remember what I said about needing to generate the correct logical
vector when you want to subset a collection? Logical vectors are
also recycled when subsetting collections. Because this vector
recycling does not always throw warnings or errors, it’s a new Hell.
I’m honestly not sure if the exact rules for when this does/doesn’t
throw warnings/errors are documented anywhere. <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Indexing-by-vectors" rel="nofollow">The language
definition</a>
claims that using a logical vector to subset a longer vector follows
the same rules as when you’re using two such vectors for arithmetic
(i.e. you get a warning if the larger of the two’s length isn’t a
multiple of the smaller’s). However, I know this to be false.</p>
<div data-snippet-clipboard-copy-content="a &lt;- 1:10
a + rep(1, 9) #Arithmetic; Gives a warning.
## Warning in a + rep(1, 9): longer object length is not a multiple of shorter
## object length
##  [1]  2  3  4  5  6  7  8  9 10 11
a[rep(TRUE, 9)] #Logical subsetting; 10 results without warning.
##  [1]  1  2  3  4  5  6  7  8  9 10
a[c(TRUE, FALSE, TRUE)] #Again, 10 results. Shouldn&#39;t it be either 10 with a warning or just 3?
## [1]  1  3  4  6  7  9 10"><pre><span>a</span> <span>&lt;-</span> <span>1</span><span>:</span><span>10</span>
<span>a</span> <span>+</span> rep(<span>1</span>, <span>9</span>) <span><span>#</span>Arithmetic; Gives a warning.</span>
<span><span>#</span># Warning in a + rep(1, 9): longer object length is not a multiple of shorter</span>
<span><span>#</span># object length</span>
<span><span>#</span>#  [1]  2  3  4  5  6  7  8  9 10 11</span>
<span>a</span>[rep(<span>TRUE</span>, <span>9</span>)] <span><span>#</span>Logical subsetting; 10 results without warning.</span>
<span><span>#</span>#  [1]  1  2  3  4  5  6  7  8  9 10</span>
<span>a</span>[c(<span>TRUE</span>, <span>FALSE</span>, <span>TRUE</span>)] <span><span>#</span>Again, 10 results. Shouldn&#39;t it be either 10 with a warning or just 3?</span>
<span><span>#</span># [1]  1  3  4  6  7  9 10</span></pre></div>
<p dir="auto">I’ll take this chance to repeat my claim that this is extremely
powerful if used correctly, but the potential for errors slipping
through unnoticed is huge. This toy example isn’t so bad, but wait
until these errors creep in to your dataset with 50 rows and
columns, leaving you with no damn idea where it all went wrong. The
first time where this really caught me out was when I used the same
logical vector for two similar datasets of slightly different sizes.
I had hoped that if anything went wrong, I’d get an error. Because I
didn’t, I continued on without knowing that half of my data was now
ruined.</p>
</li>
<li>
<p dir="auto">Logical vectors also recycle <code>NA</code> without warning. I can’t point to
any documentation that contradicts this, but it will always catch
you off guard. On the bright side, this is consistent with the
addition and subsetting rules for numeric vectors with <code>NA</code>s.</p>
<div data-snippet-clipboard-copy-content="arithmetic &lt;- c(2, NA)
arithmetic + c(11, 12, 13, 14) #Keeps NA and recycles.
## [1] 13 NA 15 NA
logic &lt;- c(TRUE, FALSE, TRUE, NA)
LETTERS[logic]
##  [1] &#34;A&#34; &#34;C&#34; NA  &#34;E&#34; &#34;G&#34; NA  &#34;I&#34; &#34;K&#34; NA  &#34;M&#34; &#34;O&#34; NA  &#34;Q&#34; &#34;S&#34; NA  &#34;U&#34; &#34;W&#34; NA  &#34;Y&#34;
LETTERS[arithmetic] #Keeps NA and recycling is not expected.
## [1] &#34;B&#34; NA"><pre><span>arithmetic</span> <span>&lt;-</span> c(<span>2</span>, <span>NA</span>)
<span>arithmetic</span> <span>+</span> c(<span>11</span>, <span>12</span>, <span>13</span>, <span>14</span>) <span><span>#</span>Keeps NA and recycles.</span>
<span><span>#</span># [1] 13 NA 15 NA</span>
<span>logic</span> <span>&lt;-</span> c(<span>TRUE</span>, <span>FALSE</span>, <span>TRUE</span>, <span>NA</span>)
<span>LETTERS</span>[<span>logic</span>]
<span><span>#</span>#  [1] &#34;A&#34; &#34;C&#34; NA  &#34;E&#34; &#34;G&#34; NA  &#34;I&#34; &#34;K&#34; NA  &#34;M&#34; &#34;O&#34; NA  &#34;Q&#34; &#34;S&#34; NA  &#34;U&#34; &#34;W&#34; NA  &#34;Y&#34;</span>
<span>LETTERS</span>[<span>arithmetic</span>] <span><span>#</span>Keeps NA and recycling is not expected.</span>
<span><span>#</span># [1] &#34;B&#34; NA</span></pre></div>
</li>
<li>
<p dir="auto">You sometimes have to tell R that you wanted to work on the entire
vector rather than its elements. For example,
<code>rep(matrix(1:4, nrow = 2, ncol = 2), 5)</code> will not repeat the matrix
5 times, it will repeat its elements 5 times. The fix is to use
<code>rep(list(matrix(1:4, nrow = 2, ncol = 2)), 5)</code> instead.</p>
<div data-snippet-clipboard-copy-content="m &lt;- matrix(1:4, nrow = 2, ncol = 2)
rep(m, 5)
##  [1] 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4
rep(list(m), 5)
## [[1]]
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## [[2]]
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## [[3]]
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## [[4]]
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## [[5]]
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4"><pre><span>m</span> <span>&lt;-</span> <span>matrix</span>(<span>1</span><span>:</span><span>4</span>, <span>nrow</span> <span>=</span> <span>2</span>, <span>ncol</span> <span>=</span> <span>2</span>)
rep(<span>m</span>, <span>5</span>)
<span><span>#</span>#  [1] 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4</span>
rep(<span>list</span>(<span>m</span>), <span>5</span>)
<span><span>#</span># [[1]]</span>
<span><span>#</span>#      [,1] [,2]</span>
<span><span>#</span># [1,]    1    3</span>
<span><span>#</span># [2,]    2    4</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span>#      [,1] [,2]</span>
<span><span>#</span># [1,]    1    3</span>
<span><span>#</span># [2,]    2    4</span>
<span><span>#</span># </span>
<span><span>#</span># [[3]]</span>
<span><span>#</span>#      [,1] [,2]</span>
<span><span>#</span># [1,]    1    3</span>
<span><span>#</span># [2,]    2    4</span>
<span><span>#</span># </span>
<span><span>#</span># [[4]]</span>
<span><span>#</span>#      [,1] [,2]</span>
<span><span>#</span># [1,]    1    3</span>
<span><span>#</span># [2,]    2    4</span>
<span><span>#</span># </span>
<span><span>#</span># [[5]]</span>
<span><span>#</span>#      [,1] [,2]</span>
<span><span>#</span># [1,]    1    3</span>
<span><span>#</span># [2,]    2    4</span></pre></div>
<p dir="auto">Similarly, you might think that <code>vect %in% listOfVectors</code> will work,
but it will instead check if the elements of <code>vect</code> are elements of
<code>listOfVectors</code>. Again, the solution is to wrap the vector in a
list. For example, you want <code>list(1:4) %in% list(5:10, 10:15, 1:4)</code>
not <code>1:4 %in% list(5:10, 10:15, 1:4)</code>.</p>
<div data-snippet-clipboard-copy-content="list(1:4) %in% list(5:10, 10:15, 1:4)
## [1] TRUE
1:4 %in% list(5:10, 10:15, 1:4)
## [1] FALSE FALSE FALSE FALSE"><pre><span>list</span>(<span>1</span><span>:</span><span>4</span>) <span>%in%</span> <span>list</span>(<span>5</span><span>:</span><span>10</span>, <span>10</span><span>:</span><span>15</span>, <span>1</span><span>:</span><span>4</span>)
<span><span>#</span># [1] TRUE</span>
<span>1</span><span>:</span><span>4</span> <span>%in%</span> <span>list</span>(<span>5</span><span>:</span><span>10</span>, <span>10</span><span>:</span><span>15</span>, <span>1</span><span>:</span><span>4</span>)
<span><span>#</span># [1] FALSE FALSE FALSE FALSE</span></pre></div>
<p dir="auto">You might be surprised that the last result was entirely <code>FALSE</code>.
After all, some of <code>1:4</code> is in the last element of the list. I’ll
leave that one to you.</p>
</li>
</ul>
<p dir="auto">Again, for the most part, these aren’t major issues. I don’t
particularly like the inconsistency between functions like <code>paste()</code> and
<code>max()</code>, but the only true minefield is the vector recycling rules. When
they silently do things that you don’t want, you’re screwed.</p>
<h2 dir="auto"><a id="user-content-47-r-wont-help-you" aria-hidden="true" href="#47-r-wont-help-you"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.7 R Won’t Help You</h2>
<p dir="auto">R makes no secret of being essentially half a century of patches for S.
Many things disagree, lack any clear conventions, or are just plain bad,
but show no signs of changing. Because so many packages depend on these
inconsistencies, I don’t think that they will ever be removed from base
R. R could be salvaged if its means of helping you manage the
inconsistency were up to scratch – e.g. the documentation, the
function/argument names, or the warning/error messages – but they’re
not. It’s therefore hard to guess about anything or to help yourself
when you’ve guessed wrong. These sounds like minor complaints, but R can
be so poor in these regards that it becomes a deal-breaker for the
entire language. If there’s one thing that will make you quit R forever,
it’s this. It may sound like I’m being harsh, but I’m not alone in
saying it. Both <em>Advanced R</em> and <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a> can
barely go a section without pointing out an inconsistency in R.</p>
<p dir="auto">Really, this is R’s biggest issue. You can get used to the arcane laws
powering R’s subsetting and vectorization, the abnormalities of its
variable manipulations, and it’s tendency to do dangerous things without
warning you. However, this is the one thing that you can never learn to
live with. R is openly, dangerously, and eternally inconsistent and also
does a poor job of helping you live with that. In the very worst cases,
you can’t find the relevant documentation, the thing that’s conceptually
close to what you’re after doesn’t link to it, the examples are as poor
as they are few, the documentation is simultaneously incomplete and
filled with irrelevant information while assuming familiarity with
something alien, the error messages don’t tell you what line threw the
errors that your inevitable misunderstandings caused, the dissimilarity
between what you’re working with and the rest of the language makes it
impossible to guess where you’ve slipped up, there’s undocumented
behaviour that you need to look at the C code to discover, and you know
that none of this will ever be fixed!</p>
<p dir="auto">These issues tend to overlap, but I’ve done my best to split this up in
to sections that cover each aspect of this problem. All in all, this
section came out to be shorter than I expected. However, I hope that I
have made the magnitude of some of these points clear.</p>
<h3 dir="auto"><a id="user-content-471-the-documentation" aria-hidden="true" href="#471-the-documentation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.7.1 The Documentation</h3>
<p dir="auto">If R had outstanding documentation, then I could live with its
inconsistencies. Sadly, it doesn’t. The documentation does almost
nothing to help you in this regard and has more than its fair share of
issues:</p>
<ul dir="auto">
<li>
<p dir="auto">Some of the docs are ancient and therefore have examples that are
either terrible, few in number, or non-existent. The references in
these docs suggests that this is a disease inherited from S, but
sometimes it’s really unforgivable:</p>
<ul dir="auto">
<li>The Examples section in the documentation for control flow shows
no examples of how to use <code>if</code>, <code>while</code>, <code>repeat</code>, <code>break</code>, or
<code>next</code>. They’re explained in the actual text, but I expect the
Examples section to give examples!</li>
<li>The documentation for the list data type has five examples, many
of which are for the other seven functions that it shares it
documentation with, despite it being an absolutely fundamental
data type. For some reason, that documentation also includes a
library call. And yes, that does mean that some of the functions
don’t have examples.</li>
<li>For stats functions, we typically see documentation for a set of
algorithms. However, said documentation will often have far
fewer examples than there are members in said set. The
<code>quantile()</code> function’s docs are an extreme examples of this. A
similar sin can be found in the docs for <code>lm()</code> and <code>glm()</code>.
However, their See Also sections link to a lot of functions that
use them in their own examples, so I can just barely forgive
this.</li>
</ul>
<p dir="auto">The Tidyverse seems to be far better in this regard, with the
examples often taking up almost as much room as the actual
documentation. However, I don’t like how its docs often don’t have a
Value section, like a lot of base R’s docs do.</p>
</li>
<li>
<p dir="auto">Some of the docs have no examples at all e.g. <code>UseMethod()</code>,
<code>vcov()</code>, and <code>xtfrm()</code>.</p>
</li>
<li>
<p dir="auto">Some of the docs will document many seemingly identical things and
not tell you how they differ. For example, can you tell from the
documentation if there’s a difference between <code>rm()</code> and <code>remove()</code>?
An even worse case is trying to figure out the difference between
<code>resid()</code> and <code>residuals()</code>. The documentation correctly tells you
that one is an alias for another, but then it tells you that
<code>resid()</code> is intended to encourage you to not do a certain thing.
This implies that <code>residuals()</code> does not have that same intention,
incorrectly hinting that they might have different behaviour.</p>
</li>
<li>
<p dir="auto">In some of the standard libraries, you can find functions without
any documentation. For example, <code>MASS::as.fraction()</code> is totally
undocumented.</p>
</li>
<li>
<p dir="auto">The <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html" rel="nofollow"><em>R Language
Definition</em></a>
is incomplete. I imagine that this will really bother some people on
principle alone. Personally, I would be satisfied if it were
incomplete in the sense of “<em>each section is complete and correct,
but the document is missing many key sections</em>”. However, it’s
really more like a rough draft. It has <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Inheritance" rel="nofollow">sentences that stop
mid-word</a>,
<a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Propagation-of-names" rel="nofollow">prompts for where to write something
latter</a>,
and lots of information that is either clearly incomplete or very
out of date.</p>
</li>
<li>
<p dir="auto">A lot of R’s base functions are not written in R, so if you really
want to understand how an R function works, you need to learn an
extra language. I find that a lot of the power users have gotten
used to reading the C source code for a lot of R. That wouldn’t be
so bad, but…</p>
</li>
<li>
<p dir="auto">For a long time, I didn’t know why many of my technical questions on
Stack Overflow were answered by direct reference to R’s code,
without any mention of its documentation. I eventually learned that
R’s functions occasionally have undocumented behaviour, meaning that
you can’t trust anything other than the code. For example:</p>
<ul dir="auto">
<li>
<p dir="auto">Where do the docs tell you that the <code>expr</code> argument in
<code>replicate()</code> gets wrapped in an anonymous function, meaning
that you can’t use it to do <code>&lt;-</code> variable assignment to its
calling environment (e.g. code like
<code>n &lt;- 0; replicate(5, n &lt;- n + 1)</code> does not change <code>n</code>)? You
might just spot this if you check the R code, but even then it’s
not clear.</p>
<div data-snippet-clipboard-copy-content="  replicate
## function (n, expr, simplify = &#34;array&#34;) 
## sapply(integer(n), eval.parent(substitute(function(...) expr)), 
##     simplify = simplify)
## &lt;bytecode: 0x559970311690&gt;
## &lt;environment: namespace:base&gt;"><pre>  <span>replicate</span>
<span><span>#</span># function (n, expr, simplify = &#34;array&#34;) </span>
<span><span>#</span># sapply(integer(n), eval.parent(substitute(function(...) expr)), </span>
<span><span>#</span>#     simplify = simplify)</span>
<span><span>#</span># &lt;bytecode: 0x559970311690&gt;</span>
<span><span>#</span># &lt;environment: namespace:base&gt;</span></pre></div>
</li>
<li>
<p dir="auto">Where do <code>rep()</code>’s docs tell you that it’s a special kind of
generic where your extensions to it won’t dispatch properly?
Even the R code – <code>function (x, ...)  .Primitive(&#34;rep&#34;)</code> – won’t
help you here.</p>
</li>
<li>
<p dir="auto">Where do <code>lapply()</code> and <code>Filter()</code>’s docs tell you that they
don’t play nice with the <code>names()</code> function? Again, even the R
code won’t help here.</p>
<div data-snippet-clipboard-copy-content="  lapply
## function (X, FUN, ...) 
## {
##     FUN &lt;- match.fun(FUN)
##     if (!is.vector(X) || is.object(X)) 
##         X &lt;- as.list(X)
##     .Internal(lapply(X, FUN))
## }
## &lt;bytecode: 0x55996db63f10&gt;
## &lt;environment: namespace:base&gt;"><pre>  <span>lapply</span>
<span><span>#</span># function (X, FUN, ...) </span>
<span><span>#</span># {</span>
<span><span>#</span>#     FUN &lt;- match.fun(FUN)</span>
<span><span>#</span>#     if (!is.vector(X) || is.object(X)) </span>
<span><span>#</span>#         X &lt;- as.list(X)</span>
<span><span>#</span>#     .Internal(lapply(X, FUN))</span>
<span><span>#</span># }</span>
<span><span>#</span># &lt;bytecode: 0x55996db63f10&gt;</span>
<span><span>#</span># &lt;environment: namespace:base&gt;</span></pre></div>
</li>
</ul>
<p dir="auto">You can sometimes find parts of the documentation that very vaguely
hint to this misbehaviour, but such things are rarely specific or
said at a non-expert level: Their meaning is only obvious in
retrospect. On the rare occasion that the documentation is specific
about the misbehaviour, it can be incomplete. For example, the
documentation for <code>choose()</code> tells you that it behaves differently
for small <code>k</code>, but what is “<em>small <code>k</code></em>”? I think that it’s 29 or
less, but that assumes that I’ve found the correct C code (I think
it’s
<a href="https://github.com/wch/r-source/blob/trunk/src/nmath/choose.c">this</a>?)
and read it correctly.</p>
</li>
<li>
<p dir="auto">In the same vein to the <code>choose()</code> example, functions in the base
stats library do not always tell you which calculation method they
used. This can make you falsely assume that a figure was calculated
exactly. For example, <code>prop.test()</code> computes an approximation, but
the only mention of this in its documentation is the See Also
section saying “<em><code>binom.test()</code> for an exact test of a binomial
hypothesis</em>”. Not only is this in a terrible place, it only suggests
that an approximation has been used in <code>prop.test()</code>. The details of
the approximation are left for the reader to guess.</p>
</li>
<li>
<p dir="auto">Some functions act very strangely because they’re designed with S
compatibility in mind. This issue goes on to damage the
documentation for said functions. For example, have a look at the
docs for the <code>seq()</code> function. It won’t tell you what <code>seq_along()</code>
does, but it will tell you what to use <code>seq_along()</code> instead of!
I’ll let <a href="https://stackoverflow.com/questions/59378862/" rel="nofollow">Stack
Overflow</a> explain
<code>seq.int()</code>’s documentation issues. Said documentation is so poor
that I’ve been scared out of using the function. I really don’t know
why R pays this price: Who is still using S? Another example is the
<code>**</code> function. I’ll let the Arithmetic Operators documentation (try
<code>?&#39;**&#39;</code>) speak for itself on that one. Its three sentences on the
topic are <code>**</code>’s only documentation. Given that you shouldn’t ever
really use it, it would be harsh of me to say more or point out its
oddities. For further reading, I will only give
<a href="https://rosettacode.org/wiki/Exponentiation_order#R" rel="nofollow">this</a>.</p>
</li>
<li>
<p dir="auto">As the previous example shows, backwards compatibility is a priority
for R. This means that its inconsistencies will almost certainly
never be fixed. Things would be better if the docs did a better job
of helping you, but this section demonstrates ad nauseam that they
do not. One wonders if there’s ever been any real interest in fixing
it.</p>
</li>
<li>
<p dir="auto">Some docs assume stats knowledge even when there should be no need
to. If you don’t know what “<em>sweeping out</em>” is, you will never
understand the docs for <code>sweep()</code>. I find <code>rmultinom()</code>’s docs to be
similarly lacking. It talks about “<em>the typical multinomial
experiment</em>” as if you’ll know what that is. Its Details section
tells you the mathematical technicalities, but if I wanted that then
I would’ve went to Wikipedia. All that they had to do was give an
example about biased die and that would’ve told the reader all that
they will need to know. A similar case can be made about <code>rbinom()</code>,
but I can forgive that on the grounds of “<em>who uses R without
knowing at least that much stats?</em>”.</p>
</li>
<li>
<p dir="auto">The docs often do a bad job of linking to other relevant functions.
For example, <code>match()</code>’s doesn’t tell you about <code>Position()</code>,
<code>subset()</code>, <code>which()</code>, or the various grep things, <code>mapply()</code>’s
doesn’t tell you about <code>Map()</code>, and <code>rbinom()</code>’s doesn’t tell you
about <code>rmultinom()</code>.</p>
</li>
<li>
<p dir="auto">I sometimes can’t understand how to search for functions in the
documentation. For example, <code>Filter()</code>’s docs are in the “<em>funprog
{base}</em>” category, but putting <code>?funprog</code> in to R won’t return those
docs. Another oddity is that it’s sometimes case sensitive. For
example, <code>?Extract</code> works but <code>?extract</code> doesn’t. In case you missed
it, there is no <code>Extract()</code> or <code>extract()</code> function.</p>
</li>
<li>
<p dir="auto">I find that the documentation tries to cover too many functions at
once. For example, in order to understand any particular function in
the funprog or grep documentation, you’re probably going to have to
go as far as understanding all of them. The worst case is the
Condition Handling and Recovery documentation (<code>?tryCatch</code>), which
lists about 30 functions, forever dooming me to never really
understand any more of R’s exception system than <code>stop()</code> and
<code>stopifnot()</code>. A much smaller example is that both <code>abs()</code> and
<code>sqrt()</code> are documented in the same place, despite barely having
anything in common and not sharing this documentation with anything
else. This issue also compromises the quality of the examples that
are given. For example, the funprog documentation gives no examples
of how to use <code>Map()</code>, <code>Find()</code>, or <code>Position()</code>, something that
never would have happened if they were alone in their own
documentation pages. Then again, <code>which()</code> and <code>arrayInd()</code> are the
only functions in their documentation, and <code>arrayInd()</code>has no
examples, so maybe I’m giving R too much credit. After all, like I
hinted at earlier, even totally fundamental stuff like lists have
more functions in their documentation than examples.</p>
</li>
<li>
<p dir="auto">The docs sometimes spend a distracting amount of time comparing
their subjects to other languages that you might not know. The best
example is the funprog docs, which are needlessly cluttered with
mentions of Common Lisp. A close second to this is the documentation
for pairlists, which even in <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Pairlist-objects" rel="nofollow">the language
definition</a>
have little more description than “<em>Pairlist objects are similar to
Lisp’s dotted-pair lists</em>”. My favourite example is probably
“<em>regexpr and gregexpr with perl = TRUE allow Python-style named
captures</em>”, if only because it manages to mention two languages in a
totally unexpected way. I should also mention that I’ve already
complained about how some functions are so obsessed with S
compatibility that both their documentation and functionality are
compromised. As a final but forgiveable case, <code>sprintf()</code> is
deliberately about C-style stuff and therefore never shuts up about
C, making the R documentation pretty difficult for anyone who
doesn’t know C.</p>
</li>
<li>
<p dir="auto">If pairlists are not really intended for use by normal users, why
are they documented in the exact same place as normal lists, which
are critical to normal R usage?</p>
</li>
<li>
<p dir="auto">Guidelines for unusual operators, such as using <code>[</code> as a function,
are rather hard to find in the documentation. One example that I
found particularly annoying is in the <code>names()</code> documentation. It
can’t make its mind up about whether it wants to talk about the
<code>names(x) &lt;- value</code> version or the <code>&#34;names&lt;-&#34;(x, value)</code> version.
The only place where it’s apparent that there’s a meaningful
difference between the two is in the second part of the Values
section, which says:</p>
<ul dir="auto">
<li>“<em>For <code>names&lt;-</code>, the updated object. (Note that the value of
<code>names(x) &lt;- value</code> is that of the assignment, <code>value</code>, not the
return value from the left-hand side.)</em>”</li>
</ul>
<p dir="auto">…Wasn’t that helpful? You’ll only really be able to understand it if
you understand the abstract notion of R’s replacement functions, but
nowhere in the <code>names()</code> documentation will point you to that. In
fact, unless you find the correct section of the language
definition, you’re never going to find it at all (I’m not linking to
that, go prove my point and find it yourself!).</p>
</li>
</ul>
<p dir="auto">Don’t get me wrong, R’s documentation isn’t terrible. Its primary issue
is that it does a poor job of helping you navigate R’s inconsistencies.
If the examples were plentiful and the docs for each function linked to
plenty of other related functions without themselves being cluttered
with mentions of other functions and languages, then it would go a long
way towards stopping R from tripping people up.</p>
<h3 dir="auto"><a id="user-content-472-the-functions" aria-hidden="true" href="#472-the-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.7.2 The Functions</h3>
<p dir="auto">There are several inconsistencies in R’s functions and how you use them.
This means that you either have to adopt a guess-and-check style of
coding or constantly double-check the documentation before using a lot
of R’s functions. Neither are satisfactory.</p>
<ul dir="auto">
<li>
<p dir="auto">There are a few too many functions that have names synonymous with
“<em>do more than once</em>”. There’s <code>replicate()</code>, <code>repeat</code> loops, and
<code>rep()</code>. Good luck remembering which does what.</p>
</li>
<li>
<p dir="auto">Why do we have both <code>structure()</code> and <code>str()</code> or <code>seq()</code> and
<code>sequence()</code>, all of which are different, while having
<code>rm()</code>/<code>remove()</code> and <code>residuals()</code>/<code>resid()</code>, which are not? The
potential for confusion is obvious: If I were to write a new
function, <code>Pos()</code>, should you or should you not assume that it’s an
alias for <code>Position()</code>?</p>
</li>
<li>
<p dir="auto">There is no consistent convention for function names in the base
libraries, even for related functions. I struggle to think of a
function-naming scheme that isn’t found somewhere in R. For example,
the documentation for <code>mean()</code> links to both <code>colMeans()</code> and
<code>weighted.mean()</code>. Similarly, the <code>seq()</code> documentation contains
both <code>seq.int()</code> and <code>seq_len()</code>. I also don’t like how there’s both
<code>readline()</code> and <code>readLines()</code> or <code>nrow()</code> and <code>NROW()</code>. Or how
about <code>all.equal()</code> and <code>anyDuplicated()</code>? There’s even all of those
functions with leading capitals like <code>Vectorize()</code> or the funprog
stuff. I could go on…</p>
</li>
<li>
<p dir="auto">The above issue gets even worse if we discuss functions that you’d
expect to exist but don’t. For example, we have <code>write()</code> but not
<code>read()</code> (the equivalent is probably <code>scan()</code>).</p>
</li>
<li>
<p dir="auto">Argument names are also inconsistent. Most of the apply family calls
its function argument <code>FUN</code>, but <code>rapply()</code> and the funprog stuff
use <code>f</code>.</p>
</li>
<li>
<p dir="auto">Related functions sometimes expect their arguments to be given in a
different order. For example, except for <code>mapply()</code>, the entire
apply family wants the data to come before the function, whereas all
of the funprog functions (e.g. <code>Map()</code>, <code>Filter()</code>, etc), want the
reverse. When you realise that you picked the wrong function for a
job, this makes rewriting your code infuriating.</p>
</li>
<li>
<p dir="auto">Functions that should be related in theory are not always related in
practice. For example, <code>subset()</code> is not documented with the Set
Operations (<code>union()</code>, <code>setdiff()</code>, etc) and works on completely
different principles. The Set Operations are the extremely dangerous
functions that remove duplicates from their inputs and apply
<code>as.vector()</code> to them. The <code>subset()</code> function is a non-standard
evaluation tool like <code>within()</code>, making it completely different and
<a href="#4112-non-standard-evaluation">dangerous in a different way</a>.
Finally, despite it being documented with the Set Operations, none
of these warnings apply for <code>is.element()</code>. I regret every time that
I wrote off someone’s advice to use <code>subset()</code> because of my
(entirely reasonable!) assumption that it would be a (dangerous) Set
Operation.</p>
</li>
<li>
<p dir="auto">Functions with related names sometimes have different effects. For
example, here is a damning quote from <a href="https://adv-r.hadley.nz/vectors-chap.html#testing-and-coercion" rel="nofollow">section 3.2.4 of <em>Advanced
R</em></a>:</p>
<ul dir="auto">
<li>“<em>Generally, you can test if a vector is of a given type with an
<code>is.*()</code> function, but these functions need to be used with
care. <code>is.logical()</code>, <code>is.integer()</code>, <code>is.double()</code>, and
<code>is.character()</code> do what you might expect: they test if a vector
is a character, double, integer, or logical. Avoid
<code>is.vector()</code>, <code>is.atomic()</code>, and <code>is.numeric()</code>: they don’t
test if you have a vector, atomic vector, or numeric vector;
you’ll need to carefully read the documentation to figure out
what they actually do.</em>”</li>
</ul>
<p dir="auto">Another example is that <code>any()</code>, <code>all()</code>, and <code>identical()</code> are all
predicate functions, but <code>all.equal()</code> and <code>anyDuplicated()</code> are
definitely not.</p>
</li>
<li>
<p dir="auto">Similar to the above, from <a href="https://advanced-r-solutions.rbind.io/vectors.html#lists" rel="nofollow">the solutions to <em>Advanced
R</em></a>:</p>
<ul dir="auto">
<li>“<em>Note that <code>as.vector()</code> and <code>is.vector()</code> use different
definitions of &#34;vector!&#34;</em>”.</li>
</ul>
<p dir="auto">The above quote is then followed by showing that
<code>is.vector(as.vector(mtcars))</code> returns <code>FALSE</code>. I’ve found similar
issues with <code>as.matrix()</code> and <code>is.matrix()</code>.</p>
</li>
<li>
<p dir="auto">The language can’t really decide if it wants you to be using lambdas
or not. For example, the apply family has arguments like <code>...</code> and
<code>MoreArgs</code> to make it so you don’t always have to make an anonymous
function, but the funprog stuff gives you no such choice. The sad
thing is, I almost always find that I want the lambdas anyway, so
the apply family’s tools to help you avoid them only serve to
complicate the documentation.</p>
</li>
<li>
<p dir="auto">As an enjoyable example of how these inconsistencies can ruin your
time with R, read the documentation for <code>Vectorize()</code>. It’s packed
with tips for avoiding these pitfalls.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-473-extended-example-matrices" aria-hidden="true" href="#473-extended-example-matrices"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.7.3 Extended Example: Matrices</h3>
<p dir="auto">Let’s talk about matrices. I’ve already discussed some oddities like how
functions like <code>[</code>, <code>$</code> and <code>length()</code> treat them in ways that seem
inconsistent with either the rest of the language or your expectations,
but let’s go deeper:</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="#455-named-atomic-vectors">As covered earlier</a>, matrices want to
have rownames and colnames rather than names. This gives us a few
more inconsistencies to deal with that I didn’t mention at the time.
The rest of the language has trained you to use
<code>setNames(data, names)</code>. When you do this, <code>data</code> is returned with
its column names changed without any changes to <code>data</code>. However,
matrices want <code>colnames(data) &lt;- names</code> and the obvious equivalent
for <code>rownames()</code>. This modifies <code>data</code> and does not return it.</p>
<div data-snippet-clipboard-copy-content="a &lt;- b &lt;- diag(3)
(colnames(a) &lt;- c(&#34;I&#34;, &#34;Return&#34;, &#34;Me&#34;))
## [1] &#34;I&#34;      &#34;Return&#34; &#34;Me&#34;
a#Changed
##      I Return Me
## [1,] 1      0  0
## [2,] 0      1  0
## [3,] 0      0  1
setNames(b, c(&#34;I&#34;, &#34;Return&#34;, &#34;b&#34;))
##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1
## attr(,&#34;names&#34;)
## [1] &#34;I&#34;      &#34;Return&#34; &#34;b&#34;      NA       NA       NA       NA       NA      
## [9] NA
b#Not changed
##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1"><pre><span>a</span> <span>&lt;-</span> <span>b</span> <span>&lt;-</span> diag(<span>3</span>)
(colnames(<span>a</span>) <span>&lt;-</span> c(<span><span>&#34;</span>I<span>&#34;</span></span>, <span><span>&#34;</span>Return<span>&#34;</span></span>, <span><span>&#34;</span>Me<span>&#34;</span></span>))
<span><span>#</span># [1] &#34;I&#34;      &#34;Return&#34; &#34;Me&#34;</span>
<span>a</span><span><span>#</span>Changed</span>
<span><span>#</span>#      I Return Me</span>
<span><span>#</span># [1,] 1      0  0</span>
<span><span>#</span># [2,] 0      1  0</span>
<span><span>#</span># [3,] 0      0  1</span>
setNames(<span>b</span>, c(<span><span>&#34;</span>I<span>&#34;</span></span>, <span><span>&#34;</span>Return<span>&#34;</span></span>, <span><span>&#34;</span>b<span>&#34;</span></span>))
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    0    0</span>
<span><span>#</span># [2,]    0    1    0</span>
<span><span>#</span># [3,]    0    0    1</span>
<span><span>#</span># attr(,&#34;names&#34;)</span>
<span><span>#</span># [1] &#34;I&#34;      &#34;Return&#34; &#34;b&#34;      NA       NA       NA       NA       NA      </span>
<span><span>#</span># [9] NA</span>
<span>b</span><span><span>#</span>Not changed</span>
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    0    0</span>
<span><span>#</span># [2,]    0    1    0</span>
<span><span>#</span># [3,]    0    0    1</span></pre></div>
<p dir="auto">Not only are the function names inconsistent (why not
<code>colNames()</code>?), the syntax is wildly so. Furthermore, take a look at
the incomprehensible error message that <code>colnames()</code> gives if you
use <code>diag(3)</code> directly rather than assigning it to a variable before
calling <code>colnames()</code>.</p>
<div data-snippet-clipboard-copy-content="a &lt;- diag(3)
colnames(a) &lt;- c(&#34;Not&#34;, &#34;A&#34;, &#34;Problem&#34;)
 ## &gt; colnames(diag(3)) &lt;- c(&#34;Big&#34;, &#34;Bad&#34;, &#34;Bug&#34;)
 ## Error in colnames(diag(3)) &lt;- c(&#34;Big&#34;, &#34;Bad&#34;, &#34;Bug&#34;) : 
 ##  target of assignment expands to non-language object
 ## &gt; colnames(a &lt;- diag(3)) &lt;- c(&#34;Has&#34;, &#34;Similar&#34;, &#34;Problem&#34;)
 ## Error in colnames(a &lt;- diag(3)) &lt;- c(&#34;Has&#34;, &#34;Similar&#34;, &#34;Problem&#34;) : 
 ##  object &#39;a&#39; not found"><pre><span>a</span> <span>&lt;-</span> diag(<span>3</span>)
colnames(<span>a</span>) <span>&lt;-</span> c(<span><span>&#34;</span>Not<span>&#34;</span></span>, <span><span>&#34;</span>A<span>&#34;</span></span>, <span><span>&#34;</span>Problem<span>&#34;</span></span>)
 <span><span>#</span># &gt; colnames(diag(3)) &lt;- c(&#34;Big&#34;, &#34;Bad&#34;, &#34;Bug&#34;)</span>
 <span><span>#</span># Error in colnames(diag(3)) &lt;- c(&#34;Big&#34;, &#34;Bad&#34;, &#34;Bug&#34;) : </span>
 <span><span>#</span>#  target of assignment expands to non-language object</span>
 <span><span>#</span># &gt; colnames(a &lt;- diag(3)) &lt;- c(&#34;Has&#34;, &#34;Similar&#34;, &#34;Problem&#34;)</span>
 <span><span>#</span># Error in colnames(a &lt;- diag(3)) &lt;- c(&#34;Has&#34;, &#34;Similar&#34;, &#34;Problem&#34;) : </span>
 <span><span>#</span>#  object &#39;a&#39; not found</span></pre></div>
<p dir="auto"><code>setNames()</code> has no such issue.</p>
<div data-snippet-clipboard-copy-content="setNames(diag(3), c(&#34;Works&#34;, &#34;Just&#34;, &#34;Fine&#34;))
##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1
## attr(,&#34;names&#34;)
## [1] &#34;Works&#34; &#34;Just&#34;  &#34;Fine&#34;  NA      NA      NA      NA      NA      NA
setNames(a &lt;- diag(3), c(&#34;Works&#34;, &#34;Just&#34;, &#34;Fine&#34;))
##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1
## attr(,&#34;names&#34;)
## [1] &#34;Works&#34; &#34;Just&#34;  &#34;Fine&#34;  NA      NA      NA      NA      NA      NA"><pre>setNames(diag(<span>3</span>), c(<span><span>&#34;</span>Works<span>&#34;</span></span>, <span><span>&#34;</span>Just<span>&#34;</span></span>, <span><span>&#34;</span>Fine<span>&#34;</span></span>))
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    0    0</span>
<span><span>#</span># [2,]    0    1    0</span>
<span><span>#</span># [3,]    0    0    1</span>
<span><span>#</span># attr(,&#34;names&#34;)</span>
<span><span>#</span># [1] &#34;Works&#34; &#34;Just&#34;  &#34;Fine&#34;  NA      NA      NA      NA      NA      NA</span>
setNames(<span>a</span> <span>&lt;-</span> diag(<span>3</span>), c(<span><span>&#34;</span>Works<span>&#34;</span></span>, <span><span>&#34;</span>Just<span>&#34;</span></span>, <span><span>&#34;</span>Fine<span>&#34;</span></span>))
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    0    0</span>
<span><span>#</span># [2,]    0    1    0</span>
<span><span>#</span># [3,]    0    0    1</span>
<span><span>#</span># attr(,&#34;names&#34;)</span>
<span><span>#</span># [1] &#34;Works&#34; &#34;Just&#34;  &#34;Fine&#34;  NA      NA      NA      NA      NA      NA</span></pre></div>
<p dir="auto">In truth, I don’t mind either <code>colnames()</code> or <code>setNames()</code>. I just
wish that R would pick one way of handling names and stick to it.</p>
</li>
<li>
<p dir="auto">Unlike anything else in R that I can think of, matrices are happy to
let you work by row and even have dedicated functions for it, with
<code>rowSums()</code> and <code>apply(..., MARGIN = 1)</code> being the obvious examples.
There is a good reasons for this difference – matrices are always
one type, unlike things like data frames – but it’s still an
inconsistency. Said inconsistently leads to code that is tough to
justify. For instance, I frequently find that I want to treat the
output of <code>expand.grid()</code> as a matrix.
<code>unique(t(apply(expand.grid(1:4, 1:4, 1:4, 1:4), 1, sort)))</code> is one
of my recent examples. This isn’t too bad, but I honestly have no
idea why I needed the <code>t()</code>. Experience has taught me not to
question it, which is pretty bad in of itself. R’s inconsistencies
eventually makes you either fall in to the habit of not questioning
sudden transformations of your data or forces you to become
completely paralysed when trying to understand what ought to be
trivial operations in your code. Doubts like “<em>is there really no
better way? R is supposed to be good with this sort of stuff</em>”
become frequent when wanting to work by row.</p>
</li>
<li>
<p dir="auto">So what happens if, when manipulating a matrix, you try to write the
<code>sapply()</code> that the rest of the language has taught you to expect?
It typically gets treated like a vector in column-order.</p>
<div data-snippet-clipboard-copy-content="(mat &lt;- matrix(1:9, nrow = 3, byrow = TRUE))
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9
sapply(mat, sum)
## [1] 1 4 7 2 5 8 3 6 9
sapply(mat, max)
## [1] 1 4 7 2 5 8 3 6 9"><pre>(<span>mat</span> <span>&lt;-</span> <span>matrix</span>(<span>1</span><span>:</span><span>9</span>, <span>nrow</span> <span>=</span> <span>3</span>, <span>byrow</span> <span>=</span> <span>TRUE</span>))
<span><span>#</span>#      [,1] [,2] [,3]</span>
<span><span>#</span># [1,]    1    2    3</span>
<span><span>#</span># [2,]    4    5    6</span>
<span><span>#</span># [3,]    7    8    9</span>
sapply(<span>mat</span>, <span>sum</span>)
<span><span>#</span># [1] 1 4 7 2 5 8 3 6 9</span>
sapply(<span>mat</span>, <span>max</span>)
<span><span>#</span># [1] 1 4 7 2 5 8 3 6 9</span></pre></div>
<p dir="auto">The trick for avoiding this is to use numbers as your data argument
and let subsetting be the function.</p>
<div data-snippet-clipboard-copy-content="mat &lt;- matrix(1:9, nrow = 3, byrow = TRUE)
sapply(1:3, function(x) sum(mat[x, ]))
## [1]  6 15 24
sapply(1:3, function(x) max(mat[x, ]))
## [1] 3 6 9"><pre><span>mat</span> <span>&lt;-</span> <span>matrix</span>(<span>1</span><span>:</span><span>9</span>, <span>nrow</span> <span>=</span> <span>3</span>, <span>byrow</span> <span>=</span> <span>TRUE</span>)
sapply(<span>1</span><span>:</span><span>3</span>, <span>function</span>(<span>x</span>) sum(<span>mat</span>[<span>x</span>, ]))
<span><span>#</span># [1]  6 15 24</span>
sapply(<span>1</span><span>:</span><span>3</span>, <span>function</span>(<span>x</span>) max(<span>mat</span>[<span>x</span>, ]))
<span><span>#</span># [1] 3 6 9</span></pre></div>
<p dir="auto">Better yet, just use <code>apply()</code>.</p>
<div data-snippet-clipboard-copy-content="mat &lt;- matrix(1:9, nrow = 3, byrow = TRUE)
apply(mat, MARGIN = 1, sum)
## [1]  6 15 24
 apply(mat, MARGIN = 1, max)
## [1] 3 6 9"><pre><span>mat</span> <span>&lt;-</span> <span>matrix</span>(<span>1</span><span>:</span><span>9</span>, <span>nrow</span> <span>=</span> <span>3</span>, <span>byrow</span> <span>=</span> <span>TRUE</span>)
apply(<span>mat</span>, <span>MARGIN</span> <span>=</span> <span>1</span>, <span>sum</span>)
<span><span>#</span># [1]  6 15 24</span>
 apply(<span>mat</span>, <span>MARGIN</span> <span>=</span> <span>1</span>, <span>max</span>)
<span><span>#</span># [1] 3 6 9</span></pre></div>
<p dir="auto">But why did we have the learn any of this in the first place?</p>
</li>
<li>
<p dir="auto">Your turn: What does <code>seq_along(diag(3))</code> return? <code>1:3</code> or <code>1:9</code>?
What if you added a row? What if you added a column? Or is the name
of that function <code>seq.along()</code>? Are you sure? Tempted to check the
docs? Which docs? Feeling helpless? You should!</p>
</li>
<li>
<p dir="auto">Many functions that are designed for matrices should be forgotten
about everywhere else. Several guides warn against using <code>apply()</code>
on non-matrices and I wouldn’t dare use <code>t()</code> on a non-matrix (try
<code>t(iris)</code>).</p>
</li>
<li>
<p dir="auto">On a similar note, I always expect <code>c()</code> of a matrix to work in
row-order. It doesn’t. However, that’s probably more the fault of
<code>c()</code> and I than it is of matrices. There are times when I can’t
explain <code>c(mtcars)</code> to myself.</p>
</li>
<li>
<p dir="auto">Named matrices are named atomic vectors, so they break in the ways
<a href="#455-named-atomic-vectors">discussed earlier</a>. This puts you in a
dilemma when you’re using data that’s essentially only one type: Do
you keep it as a matrix and lose the awesome subsetting powers of a
data frame? Or do you make it in to a data frame and lose the power
to work by row that matrices give you? At times, I’m tempted to
forget that I named the matrix in the first place and just
manipulate it like a mathematician. None of these solutions are
good.</p>
</li>
</ul>
<p dir="auto">Overall, matrices are so inconsistent with the rest of the language that
your matrix-manipulation code never looks right. It leaves you with an
awful sense of unease.</p>
<h3 dir="auto"><a id="user-content-474-the-error-messages" aria-hidden="true" href="#474-the-error-messages"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.7.4 The Error Messages</h3>
<p dir="auto">Something to mention while we’ve still got some bad error messages fresh
in our minds: People often say that R’s error messages aren’t very good
and I’m starting to agree. Errors like “<em><code>dim(X)</code> must have a positive
length</em>” are useless when you’re not told which function in the line
that threw the error had that error, what <code>X</code> is, or in the very worst
cases, what line the error was even in. This means that almost any error
that R throws is going to require you looking through both the result of
<code>traceback()</code> (to find where the error happened) and the documentation
(to identify the problematic argument). It seems that this issue gets
even worse when you try to do statistics. Warnings like “<em>Warning
message: In <code>ks.test(foo, bar)</code> : ties should not be present for the
Kolmogorov-Smirnov test</em>” don’t even tell you where the tie was. Was it
in one of my arguments? Is it some technical detail of the test? It is
somewhere safe to ignore? You don’t know and R won’t tell you unless you
study the documentation. Worst come to worst, you have to read the code
or learn the secret for getting <code>traceback()</code> to work on warning
messages. And yes, that last bit is something that you have to learn. It
makes warnings messages a lot harder to debug than errors.</p>
<p dir="auto">Of course, the more worrying issue is when R gives you no
warnings/errors at all. I’d much rather have a bad error message than
none at all, but a bad error message is still annoying.</p>
<h3 dir="auto"><a id="user-content-475-mapply-challenge" aria-hidden="true" href="#475-mapply-challenge"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.7.5 Mapply Challenge</h3>
<p dir="auto">Maybe you think I’m clutching at straws? I admit, I do sometimes wonder
if my outrage is unjustified. Let’s settle this with a challenge. If you
win, then by all means close this document and write me off as a madman.
If you lose, then maybe I’ve got a point. Okay, here’s your challenge:</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CHALLENGE</strong></td>
</tr>
<tr>
<td>Taking in to account R’s vector recycling rules, figure out how <code>mapply()</code>’s <code>MoreArgs</code> and <code>...</code> arguments differ and when you would want to pass something as a <code>MoreArgs</code> argument rather than in the <code>...</code> argument. No cheating by going online (trust me, it won’t help much anyway). Solve this without leaving your R IDE. You’re encouraged to check the documentation.</td>
</tr>
</tbody>
</table>
<p dir="auto">If my criticisms are true, you will find that <code>mapply()</code>’s documentation
is of little help and that your confidence in your R knowledge is too
small to make an educated guess.</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>HINT 1</strong></td>
</tr>
<tr>
<td>Don’t try to cheat by looking at <code>mapply()</code>’s code; Most of it is in C and therefore will be of no help to you.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>HINT 2</strong></td>
</tr>
<tr>
<td>You might think that the documentation for <code>sapply()</code> will help you, but it’ll actually mislead you because <code>mapply()</code>’s <code>...</code> is essentially <code>sapply()</code>’s <code>X</code> and <code>sapply()</code>’s <code>...</code> is most like <code>mapply()</code>’s <code>MoreArgs</code>.</td>
</tr>
</tbody>
</table>
<p dir="auto">Solution below. Time to stop scrolling.</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SOLUTION</strong></td>
</tr>
<tr>
<td>.</td>
</tr>
<tr>
<td>.</td>
</tr>
<tr>
<td>.</td>
</tr>
<tr>
<td>.</td>
</tr>
<tr>
<td>.</td>
</tr>
<tr>
<td>.</td>
</tr>
<tr>
<td>.</td>
</tr>
<tr>
<td><strong>How do <code>MoreArgs</code> and <code>...</code> differ?</strong></td>
</tr>
<tr>
<td>It’s tough to explain. <code>mapply()</code> uses the default vector recycling rules for the <code>...</code> arguments but reuses every element of <code>MoreArgs</code> for each call. Because the <code>MoreArgs</code> argument must be a list and R recycles the elements of lists (e.g. using a length 1 list as a <code>...</code> argument will have the element of that list reused for each call), the difference is subtle to the point of near invisibility. Ultimately, <code>MoreArgs = list(a, b, c)</code> is equivalent to using <code>list(a)</code>, <code>list(b)</code>, and <code>list(c)</code> as three separate <code>...</code> arguments. The answer is therefore that <code>MoreArgs</code> only exists as syntactic sugar for this <code>...</code> case.</td>
</tr>
<tr>
<td><strong>When use <code>MoreArgs</code> rather than <code>...</code>?</strong></td>
</tr>
<tr>
<td>Beyond what I’ve already said, I barely have any idea. If you want to keep some function arguments fixed for each call, then just use an anonymous function. I struggle to invent a useful example of where I’d even consider using <code>MoreArgs</code>, never mind one that doesn’t look tailor-made to make the anonymous function option look better. The one and only example that the documentation gives for using <code>MoreArgs</code> does not help here. Their example of <code>mapply(rep, times = 1:4, MoreArgs = list(x = 42))</code> is identical to <code>mapply(rep, times = 1:4, list(x = 42))</code>. Read that again: <strong>You can get identical functionality by deleting the thing that they’re trying to demonstrate!</strong></td>
</tr>
<tr>
<td><strong>Bonus</strong></td>
</tr>
<tr>
<td>Did you notice that the documentation for <code>mapply()</code> has a notable omission? It doesn’t mention this, but you can call <code>mapply()</code> without the <code>...</code> argument, e.g. <code>mapply(rep, MoreArgs = list(1:4))</code>. You won’t get sensible output, but you also don’t get any warnings or errors.</td>
</tr>
</tbody>
</table>
<p dir="auto">If I’ve won this challenge, then allow me to take a victory lap by
making the following point: By giving you the options of using <code>...</code>,
<code>MoreArgs</code>, or an anonymous function to do the same task, R gives you
plenty of room to confuse yourself without providing any help in its
documentation. Either provide fewer options, document them better, or
make them so commonplace and consistent within the language that I only
need to understand it once in order to understand it everywhere!</p>
<h3 dir="auto"><a id="user-content-476-stealing-from-the-tidyverse" aria-hidden="true" href="#476-stealing-from-the-tidyverse"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.7.6 Stealing from the Tidyverse</h3>
<p dir="auto">On top of many of the things that I’ve already said about the apply
family, fans of the Tidyverse, particularly <code>purrr</code>, often point out of
the following inconsistencies. They’ve never bothered me, but they’re
undeniably correct. It makes me wonder why we can’t just give all of the
apply family a <code>simplify</code> argument that takes either <code>TRUE</code>, <code>FALSE</code>, or
whatever <code>vapply()</code> would consider a valid <code>FUN.VALUE</code> argument.</p>
<ul dir="auto">
<li>Probably due to its use of <code>as.vector()</code>, <code>apply()</code> has no
<code>simplify</code> argument. Version 4.0.6 did something about this, but
I’ve yet to get my head around it.</li>
<li>There is no equivalent to <code>vapply()</code> for any member of the apply
family other than <code>sapply()</code>. Among others, neither <code>tapply()</code> nor
<code>mapply()</code> have one.</li>
<li>You can argue that some functions are missing in base R. For
example, if we think of <code>lapply()</code> as “<em>list in, data frame out</em>”
and <code>by()</code> as “<em>data frame in, list out</em>”, and so on for <code>sapply()</code>
and others, then where is the “<em>array in, list out</em>” function?</li>
<li>This might be a repeat of my complaints about the documentation, but
there are several apply family functions that hardly anyone uses or
understands. Few understand <code>eapply()</code> and even fewer use it. Just
about everyone who uses R for stats has had to invest a few hours
getting their head around <code>tapply()</code>, but at least that’s worth it.
As for the other obscure ones – e.g. <code>simplify2array()</code>, <code>rapply()</code>
– I honestly cannot recall ever using them or seeing them used.</li>
</ul>
<h2 dir="auto"><a id="user-content-48-the-community" aria-hidden="true" href="#48-the-community"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.8 The Community</h2>
<p dir="auto">There are some community issues that make R harder to learn and work
with. Put together with the earlier issues, it means that help can often
neither be found inside nor outside of R.</p>
<ul dir="auto">
<li>The community can’t agree on if we should be using base R’s data
frames, the Tidyverse’s tibbles, or the <code>data.table</code> package. Even
if you find one that you like, you can bet that you will someday
want to use a package that requires another. For example, if your
friendly neighbourhood package author made use of the default
<code>drop = TRUE</code> argument when manipulating data frames, you’re not
going to be allowed to use tibbles. Protecting the user from this
isn’t easy, because both data.tables and tibbles will return <code>TRUE</code>
for <code>is.data.frame()</code>.</li>
<li>Much like the data frame point, the community is also split on which
OOP system it should use. For example, <code>R6</code> gets about as much
mention as RC, even though they both do the same job. Depending on
when they were made, you also see some popular libraries that are
fully committed to some particular OOP system. For example, you will
see a lot of S3 in base R, but the <code>Bioconductor</code> package sticks to
S4. Fortunately, all of this only becomes a problem when you want to
contribute to these packages. If all goes well, you will never
really notice which OOP system has been used; You will just have
polymorphic code and not need to question it.</li>
<li>A lot of people seem to treat R as secondary to the Tidyverse
packages. Many books essentially ignore base R or go out of their
way to tell you why the Tidyverse is better – <em>Advanced R</em> is a good
example of the latter, particularly the second edition, so much so
that I needed to read both editions – and many R Q&amp;A sites will give
you a Tidyverse solution to pretty much any problem, even if it can
be solved almost as well in base R. You sometimes see the same with
<code>data.table</code>, but it’s much less common.</li>
<li>The popularity of the Tidyverse is a major blow to your motivation
to learn R. Why would anyone want to learn a language that is
treated as secondary to some packages? Worse still, if that turns
out to be the best way to use R, then you’re forced to admit that R
is a polished turd with a fragmented community. Why would you ever
knowingly use a polished turd? The popularity of the Tidyverse is
possibly the strongest piece of evidence that not only does R suck,
the community knows it.</li>
<li>If base R is best ignored in favour of packages, or at least if the
community thinks so, then how are you expected to actually learn R?
When do you stop learning the base library and move on?</li>
<li>Data science people have a strong preference for Python, so a lot of
good tutorials that should be in R are only available in Python.
I’ve also noticed at least one case where the R package
documentation is clearly inferior to the Python equivalent, despite
the gap in functionality not being as wide.</li>
<li>R’s functional programming aspects are so strong that loops,
particularly <code>for</code> loops, are considered a code smell. This goes
double in the Tidyverse, with the <em>R for Data Science</em> book not even
introducing them until chapter 21 (of 30). There are practical
reasons for this, mostly in relation to the apply family’s code
being written in C and therefore being faster than most R loops.
However, it encourages you to do some silly things. For example, you
have to make a judgement call between writing a <code>for</code> loop that is
inherently fast but slowed down by being written in R or writing an
<code>sapply()</code> that ought to be slow but is speeded up due to <code>sapply()</code>
calling C code. This issue also affects how you present your code.
Calls to the apply family are inherently one-liners, so it’s
difficult to find the right way to present/comment them when they
become complex. You either end up introducing unnecessary variables
in to your code or indenting it in unconventional ways. The
Tidyverse’s solution – piping – often does the trick, but it openly
admits to not being a universal solution. The new <code>|&gt;</code> base R pipe
doesn’t do the trick either. As any advocate of the Tidyverse will
tell you, base R just isn’t designed for piping.</li>
</ul>
<h2 dir="auto"><a id="user-content-49-generic-functions-again" aria-hidden="true" href="#49-generic-functions-again"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.9 Generic Functions Again</h2>
<p dir="auto">R’s generic function OOP systems are yet another source unpredictability
and internal inconsistency. <a href="#353-generic-functions">They’re very cool</a>
and I must admit that I’ve not used them much, but what I’ve seen when
trying to use them has discouraged me. Most of what I’m about to say is
about S3, but you’ll rarely find much said about R’s OOP systems at all.
It’s not really any surprise. S3, S4, RC, and any of the OOP systems
that come from packages are all openly admitted to being bolted-on to R
rather than something that was part of its design from the early days.
Points like the below make discovering this fact unavoidable.
Presumably, this is what the Julia fans are talking about when they say
that they’re the only ones who have a generic function OOP system that
is baked-in to their language. I’ve never used Julia or enough S4 or RC
to be able to really comment, but I bet they’re right.</p>
<h3 dir="auto"><a id="user-content-491-the-class-system" aria-hidden="true" href="#491-the-class-system"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.9.1 The Class System</h3>
<p dir="auto">The class system is a mess and the docs do a poor job of explaining it.
Good luck understanding it without a book like <em>Advanced R</em> and a
package like <code>sloop</code>. I believe that this problem is mostly isolated to
S3, but I’ve not used enough S4 to be able to say that with any
certainty. Here are some problems that you’re likely to encounter early
on:</p>
<ul dir="auto">
<li>
<p dir="auto">Functions like <code>mode()</code> and <code>storage.mode()</code> exist only for
compatibility with S. As an R user, they exist only to increase your
confusion. This is particularly common when reading the language
definition; It never shuts up about the modes of things.</p>
</li>
<li>
<p dir="auto"><em>Advanced R</em> makes <a href="https://adv-r.hadley.nz/base-types.html#numeric-type" rel="nofollow">a strong
case</a> for
<code>is.numeric()</code> being inconsistent, particularly regarding its
interaction with S3.</p>
</li>
<li>
<p dir="auto">The documentation for <code>class()</code> uses vague statements like “<em>method
dispatch may use more classes than are returned by <code>class(x)</code></em>”.
May? <strong>MAY???</strong> What am I supposed to do with that? Where do I look
for more info? It mentions <code>.class2()</code>, but warns you against using
it. Why? It doesn’t say! Did you think that <code>.class2()</code> would have
its own documentation somewhere else? It doesn’t! All of the
documentation for <code>.class2()</code> is in the docs for <code>class()</code> and most
of that is a warning to not use it!</p>
</li>
<li>
<p dir="auto">Call <code>class()</code> on a matrix and you will see that they have a few
classes. However, <code>is.object()</code>, which has docs that correctly state
that it will return <code>TRUE</code> for anything with a class attribute,
returns <code>FALSE</code>.</p>
<div data-snippet-clipboard-copy-content="a &lt;- diag(3)
class(a)
## [1] &#34;matrix&#34; &#34;array&#34;
is.object(a)
## [1] FALSE"><pre><span>a</span> <span>&lt;-</span> diag(<span>3</span>)
class(<span>a</span>)
<span><span>#</span># [1] &#34;matrix&#34; &#34;array&#34;</span>
is.object(<span>a</span>)
<span><span>#</span># [1] FALSE</span></pre></div>
<p dir="auto">Why? Because <code>class()</code> also returns implicit classes – as detailed
in its docs – which <code>is.object()</code> ignores because implicit classes
aren’t part of the class attribute. The documentation for
<code>is.object()</code> does not mention this fact and the <code>class()</code>
function’s output does not tell you which classes are implicit. Can
you see the potential for confusion? The docs never lied or even
mislead, but they make naivety fatal. Maybe that’s starting to
become a theme.</p>
</li>
<li>
<p dir="auto">So what base R function actually returns the non-implicit classes? I
think that you have to use <code>attr(foo, &#34;class&#34;)</code>. I say “<em>I think</em>”
because the documentation for <code>class()</code> does not offer any help.</p>
</li>
<li>
<p dir="auto">Don’t ask what determines the implicit classes of an object or how
S3 dispatch occurs with them. It’s far too complicated and not
clearly documented in any place that I know of. It’s also what’s
used for dispatching on anything without a class attribute, such as
matrices. Good luck with that!</p>
</li>
<li>
<p dir="auto">Don’t ask what an object is either. The community will tell you that
<code>is.object()</code> is poorly named and the language definition will tell
you that pretty much everything in R is an object. However, there
are functions like <code>names(x)&lt;-</code> that will not work on several types
of objects (e.g. anything anonymous) despite their documentation
saying that <code>x</code> can be “<em>an R object</em>”. I’d give examples, but you
really don’t want to think too hard about this.</p>
</li>
<li>
<p dir="auto">The <code>[</code> and <code>[[</code> functions like to drop the attributes from your S3
objects, meaning that you almost always have to write a <code>[</code> and <code>[[</code>
method for them. On the bright side, this is documented behaviour.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-492-existing-functions" aria-hidden="true" href="#492-existing-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.9.2 Existing Functions</h3>
<p dir="auto">The generic functions that you’ll find in the base and other common
libraries have a few surprises:</p>
<ul dir="auto">
<li>Some functions appear to be generic, but aren’t. For example, both
<code>abline()</code> and <code>sample()</code> can behave differently depending on what
sort of input you gave them, but that’s because they’re hard-coded
to do so. If you expect to find some <code>abline.lm()</code> function or be
able to write your own <code>abline.myClass()</code> method, you’ll be
disappointed.</li>
<li>In stats libraries, I’ve seen the ability to overload function names
abused. For example, why is the function to return a one-hot encoded
dataset in the caret library <code>predict()</code>? I’m pretty sure that my
Bayesian Statistics lecturer also showed me a few cases where
<code>anova()</code> definitely does not do an ANOVA. I’m out of practice, but
I think that the R FAQ gives <a href="https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-does-the-output-from-anova_0028_0029-depend-on-the-order-of-factors-in-the-model_003f" rel="nofollow">one such
example</a>.</li>
<li>Although you can usually write your own functions to fix this, it’s
annoying when you expect a generic function to behave in a sensible
way on your input, only to discover that it has no special case for
your type of input and treats it like any other vector. To repeat an
earlier example, why does <code>rep(matrix(1:4, nrow = 2, ncol = 2), 5)</code>
treat the input matrix like it’s a normal vector? I can’t imagine
anyone calling <code>rep()</code> on a matrix and wanting to work
element-by-element rather than repeating the matrix.</li>
<li>Because of S3, it’s now considered bad practice to write function
names in the form <code>foo.bar()</code> because they look like extensions to
<code>foo()</code>. Open up any standard R library and you will see countless
functions written in this form that are not extensions to anything.
<code>t()</code> and <code>t.test()</code> are the most cited example.</li>
</ul>
<h3 dir="auto"><a id="user-content-493-internal-generics" aria-hidden="true" href="#493-internal-generics"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.9.3 Internal Generics</h3>
<p dir="auto">This is tough to explain, but I’ll try. If you consult
<code>?&#34;internal generic&#34;</code>, you will find a big list of functions that you
cannot extend properly with S3. Specifically, anything on that list
cannot be extended to dispatch on any type of object for which
<code>is.object()</code> returns <code>FALSE</code>. For example, writing a <code>rep.matrix()</code>
function that does what my earlier example wanted is easy, but because
<code>rep()</code> is on that list and matrices are not objects in this sense,
<code>rep()</code> will not dispatch to <code>rep.matrix()</code> when given a matrix. The
documentation for <code>rep()</code> and other functions that share this
misbehaviour do not do much to help the reader discover this fact.
<em>Advanced R</em> has the only good explanation that I’ve found for this, but
it’s the sort of thing where you either have to read
<a href="https://adv-r.hadley.nz/base-types.html" rel="nofollow">two</a>
<a href="https://adv-r.hadley.nz/s3.html" rel="nofollow">chapters</a> or the first edition’s <a href="http://adv-r.had.co.nz/OO-essentials.html" rel="nofollow">OO
Field Guide</a>. The short
explanation is “<em>internal generics are written in C and therefore only
understand non-implicit classes and whatever internal R type the C code
ultimately gets fed</em>”.</p>
<ul dir="auto">
<li>
<p dir="auto">Did you notice that <code>length()</code> is on the list mentioned above? This
explains the inconsistency in how it behaves on data frames and
matrices. You cannot properly extend internal generics with S3, so
you cannot change how <code>length()</code> behaves on implicitly classed
input. Data frames are non-implicitly lists and matrices are
non-implicitly atomic vectors, so that’s how <code>length()</code> treats them.
This issue isn’t unique to just data frames and matrices. <em>Advanced
R</em> has <a href="https://adv-r.hadley.nz/s3.html#object-styles" rel="nofollow">a comical example in its S3
chapter</a>: Linear
models, which are non-implicitly lists, have a length of about 12!
My personal favourite is giving it quoted input:</p>
<div data-snippet-clipboard-copy-content="length(quote(5^30))
## [1] 3
length(quote(5^30 + 1))
## [1] 3
length(quote(5^30 + 12))
## [1] 3
length(quote(1))
## [1] 1
length(quote(length(1)))
## [1] 2"><pre>length(quote(<span>5</span><span>^</span><span>30</span>))
<span><span>#</span># [1] 3</span>
length(quote(<span>5</span><span>^</span><span>30</span> <span>+</span> <span>1</span>))
<span><span>#</span># [1] 3</span>
length(quote(<span>5</span><span>^</span><span>30</span> <span>+</span> <span>12</span>))
<span><span>#</span># [1] 3</span>
length(quote(<span>1</span>))
<span><span>#</span># [1] 1</span>
length(quote(length(<span>1</span>)))
<span><span>#</span># [1] 2</span></pre></div>
<p dir="auto">You will find issues like this – i.e. unexpected and tough to
explain output – whenever using or extending most internal generics;
<code>length()</code> is just the easiest example to show.</p>
</li>
<li>
<p dir="auto">Did you notice that I lied about data frames? The careful reader
will notice that, because they have the real <code>data.frame</code> class,
data frames don’t have any implicit classes. That’s a thing, by the
way, having a real class means not having implicit classes.</p>
<div data-snippet-clipboard-copy-content="attr(mtcars, &#34;class&#34;)
## [1] &#34;data.frame&#34;
class(mtcars)
## [1] &#34;data.frame&#34;
is.object(mtcars)
## [1] TRUE"><pre>attr(<span>mtcars</span>, <span><span>&#34;</span>class<span>&#34;</span></span>)
<span><span>#</span># [1] &#34;data.frame&#34;</span>
class(<span>mtcars</span>)
<span><span>#</span># [1] &#34;data.frame&#34;</span>
is.object(<span>mtcars</span>)
<span><span>#</span># [1] TRUE</span></pre></div>
<p dir="auto">This means that <code>length(someDataFrame)</code> cannot possibly dispatch to
some <code>length.list()</code> internal method. Further inspection reveals
that there is no S3 (i.e. non-internal) <code>length.data.frame()</code>
method. What actually happens is that R tries to find
<code>length.data.frame()</code>, fails, and then tries to find
<code>length.default()</code>, only to fail again and get pointed to the
internal C code that presumably treats data frames just like lists.
This happens even though data frames do not have implicit classes.
Enjoying the complexity?</p>
</li>
<li>
<p dir="auto">So what happens if you try to write a <code>length.data.frame()</code> method –
something that is totally allowed because data frames return <code>TRUE</code>
for <code>is.object()</code> and <code>length()</code> is an internal generic function –
and have <code>length()</code> dispatch to it? You’ll probably break R. I once
redefined the length of a data frame to be its number of rows and I
got a stack usage error. Please, take a few seconds to appreciate
all of the complexity that we’ve just had to work with just for R’s
most basic object system.</p>
</li>
</ul>
<p dir="auto">Much of the above examples makes the class system – and therefore S3
dispatch – impossible to clearly explain. Any real explanation would be
so full of exceptions that it would become incomprehensible. The only
way to explain it is to ignore the contradictions for as long as
possible, meaning that you must be given incorrect information until
you’re ready to read about the exceptions. This ultimately means that
you cannot even find a good reference manual for the class system,
because you never know if you’re reading the whole truth or not.
Furthermore, if this is at all representative of the complexity of S3,
how can anyone be expected to have the patience to even begin learning
S4? I know that it’s dishonest to blame S4 for the sins of S3, but I
wouldn’t blame any newcomer to R’s OOP for doing so.</p>
<h3 dir="auto"><a id="user-content-494-s4" aria-hidden="true" href="#494-s4"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.9.4 S4</h3>
<p dir="auto">Okay then, let’s talk about S4. I promise that this will be an easier
read than the earlier sections. I’m quite ignorant of S4, as I’ve
already admitted to, so I’ve got very little to say. Regardless, the
following seems clear:</p>
<ul dir="auto">
<li>
<p dir="auto">Everything that I’ve read about S4 gives me the impression that it
has far fewer stupid technicalities than S3. If I’m right, then I
find that laughable. How have we managed to make S3 more complicated
than S4? S3 should be extremely simple, but the technicalities of
the previous few sections are too easy to stumble upon.</p>
</li>
<li>
<p dir="auto">If <a href="https://adv-r.hadley.nz/s4.html" rel="nofollow"><em>Advanced R’s</em> chapter on S4</a>
is to be trusted, then the official documentation for S4 contains a
lot of bad advice. I’ve not looked closely, but I have noticed that
it shares R’s tendency to put many functions in one page of
documentation and then not give examples for many of them. For
example, <code>?getMethod</code> documents five functions, but only gives
examples for two. Similarly, <code>@</code> has no examples in its
documentation.</p>
</li>
<li>
<p dir="auto">S4 has some strange semantics. Why call something that is sometimes
not a predicate function <code>is()</code>? Why does it use an <code>@</code> operator to
do what the rest of R would use <code>$</code> for?</p>
<div data-snippet-clipboard-copy-content="is(mtcars)
## [1] &#34;data.frame&#34; &#34;list&#34;       &#34;oldClass&#34;   &#34;vector&#34;"><pre>is(<span>mtcars</span>)
<span><span>#</span># [1] &#34;data.frame&#34; &#34;list&#34;       &#34;oldClass&#34;   &#34;vector&#34;</span></pre></div>
</li>
<li>
<p dir="auto">As far as I can tell, S4 doesn’t inform you if there was some
ambiguity in your dispatch, such as if it had to pick one option
from two equally appropriate potential dispatches. I think that
unless there is no appropriate method to dispatch to, it has some
internal rules that silently handle these cases, meaning that there
is no ambiguity even when there probably should be. In other words,
it may misbehave by silently resolving the developer’s ambiguities.
Without being too spiteful, by now I find it quite easy to believe
that R has an OOP system that silently misbehaves.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-410-factor-variables" aria-hidden="true" href="#410-factor-variables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.10 Factor Variables</h2>
<p dir="auto">Section 8.2 of <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a> calls
the factor and ordered variables “<em>chimeras</em>”. This is exactly the right
criticism. Under the hood, they’re S3 objects with integers as their
base type and a character vector – the levels – as an attribute. When
using these variables, it is difficult to predict if R will treat them
as their integer base type, as their character vector levels attribute,
or as a factor object. And that’s not even mentioning how the labels
come in to it. <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a> has said
more than I will and gives some examples of their unpredictable
behaviour, but here are some points from my own experience:</p>
<ul dir="auto">
<li>
<p dir="auto">There is no base R function for extracting the original object from
its corresponding factor. To extract your original set of numbers
(assuming that they were numbers, if not, you get nonsense) from a
factor variable called <code>f</code>, the documentation tells you to use
either <code>as.numeric(levels(f))[f]</code> or the slower
<code>as.numeric(as.character(f))</code>. Let’s use a bit more code than usual
and show off what each of these functions do before and after
composition:</p>
<div data-snippet-clipboard-copy-content="  (withoutLabels &lt;- factor(rep(seq(from = 2, by = 2, to = 10), 3)))
##  [1] 2  4  6  8  10 2  4  6  8  10 2  4  6  8  10
## Levels: 2 4 6 8 10
  (withLabels &lt;- factor(rep(seq(from = 2, by = 2, to = 10), 3), labels = LETTERS[1:5]))
##  [1] A B C D E A B C D E A B C D E
## Levels: A B C D E
  fList &lt;- list(withoutLabels, withLabels)
  #Just to make sure that we&#39;re on the same page, here&#39;s the output of str().
  #The internal integers are in plain site.
  lapply(fList, str)
##  Factor w/ 5 levels &#34;2&#34;,&#34;4&#34;,&#34;6&#34;,&#34;8&#34;,..: 1 2 3 4 5 1 2 3 4 5 ...
##  Factor w/ 5 levels &#34;A&#34;,&#34;B&#34;,&#34;C&#34;,&#34;D&#34;,..: 1 2 3 4 5 1 2 3 4 5 ...
## [[1]]
## NULL
## 
## [[2]]
## NULL
  #Nothing surprising to start:
  lapply(fList, levels)
## [[1]]
## [1] &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34;
## 
## [[2]]
## [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34;
  #as.character() returns the non-attribute part of what you get when you print the factor
  #i.e. the result of mapping its internal integers to its character vector of levels.
  #Notice that these are characters. It&#39;s not obvious from printing your factors that
  #the non-attribute part becomes a character.
  lapply(fList, as.character)
## [[1]]
##  [1] &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34; &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34; &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34;
## 
## [[2]]
##  [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34;
  #Calling `as.numeric()` on a factor does not return the original numbers.
  #It returns the underlying integers.
  #Why would you ever want or expect these?
  lapply(fList, as.numeric)
## [[1]]
##  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5
## 
## [[2]]
##  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5
  #Subsetting with factors always treats them as their integer base type.
  #If the factor fundamentally has nothing to do with integers
  #(e.g. if you made the factor from something that was originally a set of characters),
  #then you can expect nonsense.
  #If the factor did originally have something to do with integers,
  #then you&#39;re probably going to be very confused because it hasn&#39;t subsetted with
  #the numbers that you get from printing the factor.
  #In short, it&#39;s almost never a good idea, but R lets you do it anyway.
  #Now ask yourself: What is the point of having a categorical data type if
  #it&#39;s not practical to subset with?
  lapply(fList, function(f) levels(f)[f])
## [[1]]
##  [1] &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34; &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34; &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34;
## 
## [[2]]
##  [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34;
  lapply(fList, function(f) as.numeric(levels(f))[f])
## Warning in FUN(X[[i]], ...): NAs introduced by coercion
## [[1]]
##  [1]  2  4  6  8 10  2  4  6  8 10  2  4  6  8 10
## 
## [[2]]
##  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
  lapply(fList, function(f) as.numeric(as.character(f)))
## Warning in FUN(X[[i]], ...): NAs introduced by coercion
## [[1]]
##  [1]  2  4  6  8 10  2  4  6  8 10  2  4  6  8 10
## 
## [[2]]
##  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA"><pre>  (<span>withoutLabels</span> <span>&lt;-</span> <span>factor</span>(rep(seq(<span>from</span> <span>=</span> <span>2</span>, <span>by</span> <span>=</span> <span>2</span>, <span>to</span> <span>=</span> <span>10</span>), <span>3</span>)))
<span><span>#</span>#  [1] 2  4  6  8  10 2  4  6  8  10 2  4  6  8  10</span>
<span><span>#</span># Levels: 2 4 6 8 10</span>
  (<span>withLabels</span> <span>&lt;-</span> <span>factor</span>(rep(seq(<span>from</span> <span>=</span> <span>2</span>, <span>by</span> <span>=</span> <span>2</span>, <span>to</span> <span>=</span> <span>10</span>), <span>3</span>), <span>labels</span> <span>=</span> <span>LETTERS</span>[<span>1</span><span>:</span><span>5</span>]))
<span><span>#</span>#  [1] A B C D E A B C D E A B C D E</span>
<span><span>#</span># Levels: A B C D E</span>
  <span>fList</span> <span>&lt;-</span> <span>list</span>(<span>withoutLabels</span>, <span>withLabels</span>)
  <span><span>#</span>Just to make sure that we&#39;re on the same page, here&#39;s the output of str().</span>
  <span><span>#</span>The internal integers are in plain site.</span>
  lapply(<span>fList</span>, <span>str</span>)
<span><span>#</span>#  Factor w/ 5 levels &#34;2&#34;,&#34;4&#34;,&#34;6&#34;,&#34;8&#34;,..: 1 2 3 4 5 1 2 3 4 5 ...</span>
<span><span>#</span>#  Factor w/ 5 levels &#34;A&#34;,&#34;B&#34;,&#34;C&#34;,&#34;D&#34;,..: 1 2 3 4 5 1 2 3 4 5 ...</span>
<span><span>#</span># [[1]]</span>
<span><span>#</span># NULL</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span># NULL</span>
  <span><span>#</span>Nothing surprising to start:</span>
  lapply(<span>fList</span>, <span>levels</span>)
<span><span>#</span># [[1]]</span>
<span><span>#</span># [1] &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34;</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span># [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34;</span>
  <span><span>#</span>as.character() returns the non-attribute part of what you get when you print the factor</span>
  <span><span>#</span>i.e. the result of mapping its internal integers to its character vector of levels.</span>
  <span><span>#</span>Notice that these are characters. It&#39;s not obvious from printing your factors that</span>
  <span><span>#</span>the non-attribute part becomes a character.</span>
  lapply(<span>fList</span>, <span>as.character</span>)
<span><span>#</span># [[1]]</span>
<span><span>#</span>#  [1] &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34; &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34; &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34;</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span>#  [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34;</span>
  <span><span>#</span>Calling `as.numeric()` on a factor does not return the original numbers.</span>
  <span><span>#</span>It returns the underlying integers.</span>
  <span><span>#</span>Why would you ever want or expect these?</span>
  lapply(<span>fList</span>, <span>as.numeric</span>)
<span><span>#</span># [[1]]</span>
<span><span>#</span>#  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span>#  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5</span>
  <span><span>#</span>Subsetting with factors always treats them as their integer base type.</span>
  <span><span>#</span>If the factor fundamentally has nothing to do with integers</span>
  <span><span>#</span>(e.g. if you made the factor from something that was originally a set of characters),</span>
  <span><span>#</span>then you can expect nonsense.</span>
  <span><span>#</span>If the factor did originally have something to do with integers,</span>
  <span><span>#</span>then you&#39;re probably going to be very confused because it hasn&#39;t subsetted with</span>
  <span><span>#</span>the numbers that you get from printing the factor.</span>
  <span><span>#</span>In short, it&#39;s almost never a good idea, but R lets you do it anyway.</span>
  <span><span>#</span>Now ask yourself: What is the point of having a categorical data type if</span>
  <span><span>#</span>it&#39;s not practical to subset with?</span>
  lapply(<span>fList</span>, <span>function</span>(<span>f</span>) levels(<span>f</span>)[<span>f</span>])
<span><span>#</span># [[1]]</span>
<span><span>#</span>#  [1] &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34; &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34; &#34;2&#34;  &#34;4&#34;  &#34;6&#34;  &#34;8&#34;  &#34;10&#34;</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span>#  [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34; &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;D&#34; &#34;E&#34;</span>
  lapply(<span>fList</span>, <span>function</span>(<span>f</span>) as.numeric(levels(<span>f</span>))[<span>f</span>])
<span><span>#</span># Warning in FUN(X[[i]], ...): NAs introduced by coercion</span>
<span><span>#</span># [[1]]</span>
<span><span>#</span>#  [1]  2  4  6  8 10  2  4  6  8 10  2  4  6  8 10</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span>#  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA</span>
  lapply(<span>fList</span>, <span>function</span>(<span>f</span>) as.numeric(as.character(<span>f</span>)))
<span><span>#</span># Warning in FUN(X[[i]], ...): NAs introduced by coercion</span>
<span><span>#</span># [[1]]</span>
<span><span>#</span>#  [1]  2  4  6  8 10  2  4  6  8 10  2  4  6  8 10</span>
<span><span>#</span># </span>
<span><span>#</span># [[2]]</span>
<span><span>#</span>#  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA</span></pre></div>
</li>
<li>
<p dir="auto">As you’ve probably noticed by now, factor variables are inherently
complex enough that they need you to either carefully read their
documentation or be an R master before you can use them with
confidence. You cannot tell me that <code>as.numeric(levels(f))[f]</code> made
perfect sense when you read it or that you would have come up with
it yourself. It’s arcane. Half of the reason why I let the code
speak for itself above, rather than adopting my usual bullet point
style, is because I hardly even trust myself to describe them. In
fact, even whoever wrote the R FAQ seems to have not mastered the
art. In <a href="https://cran.r-project.org/doc/FAQ/R-FAQ.html#How-do-I-convert-factors-to-numeric_003f" rel="nofollow">section
7.10</a>,
they suggest <code>as.numeric(levels(f))[as.integer(f)]</code> for the same
task as what we’ve covered above. Can you see the redundant function
call?</p>
</li>
<li>
<p dir="auto">When writing example code, factors want to be called <code>f</code>, just like
functions do. This offends me.</p>
</li>
<li>
<p dir="auto">On the bright side, it looks like R version 4 is steadily trying to
fix factors. Every few updates, we see a minor change. For example,
before version 4, you had to pass <code>stringsAsFactors = FALSE</code> to a
lot of functions. This was to stop R creating factor when you hadn’t
asked for them. It was widely considered extremely annoying because
there is nothing in the way that data frames print that signals to
the reader that they’re looking at a factor variable. For all you
knew, you were looking at a character vector. You often would not
discover your mistake until you had a serious error.</p>
</li>
</ul>
<p dir="auto">Personally, I’m afraid to use factor variables. Their unpredictability
makes any code that uses them dramatically more complex, even if you’re
confident that you know their rules.</p>
<h2 dir="auto"><a id="user-content-411-syntactic-sugar" aria-hidden="true" href="#411-syntactic-sugar"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.11 Syntactic Sugar</h2>
<p dir="auto">The syntactic sugar is a source of problems, often to such a great
degree that your best solution is to completely avoid the sugar. I’ll
start with some small cases before splitting some of the bigger ones in
to sections.</p>
<ul dir="auto">
<li>
<p dir="auto">You usually only see this when dealing with <code>names()</code>, but having a
function that is both a setter and getter is a guaranteed source of
confusion and found more than once in R. For example,
<code>names(output)</code> will give you the names of <code>output</code>, but
<code>names(output) &lt;- c(&#34;Alice&#34;, &#34;Bob&#34;)</code> will change <code>output</code>’s names
(it’s sugar for some complicated <code>&#34;names&lt;-&#34;</code> nonsense).</p>
<div data-snippet-clipboard-copy-content="names(mtcars)
##  [1] &#34;mpg&#34;  &#34;cyl&#34;  &#34;disp&#34; &#34;hp&#34;   &#34;drat&#34; &#34;wt&#34;   &#34;qsec&#34; &#34;vs&#34;   &#34;am&#34;   &#34;gear&#34;
## [11] &#34;carb&#34;
names(mtcars) &lt;- LETTERS[1:11]
head(mtcars, 2)
##                A B   C   D   E     F     G H I J K
## Mazda RX4     21 6 160 110 3.9 2.620 16.46 0 1 4 4
## Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4"><pre>names(<span>mtcars</span>)
<span><span>#</span>#  [1] &#34;mpg&#34;  &#34;cyl&#34;  &#34;disp&#34; &#34;hp&#34;   &#34;drat&#34; &#34;wt&#34;   &#34;qsec&#34; &#34;vs&#34;   &#34;am&#34;   &#34;gear&#34;</span>
<span><span>#</span># [11] &#34;carb&#34;</span>
names(<span>mtcars</span>) <span>&lt;-</span> <span>LETTERS</span>[<span>1</span><span>:</span><span>11</span>]
head(<span>mtcars</span>, <span>2</span>)
<span><span>#</span>#                A B   C   D   E     F     G H I J K</span>
<span><span>#</span># Mazda RX4     21 6 160 110 3.9 2.620 16.46 0 1 4 4</span>
<span><span>#</span># Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4</span></pre></div>
<p dir="auto">Now what do you think <code>names(foo) &lt;- names(bar)</code> does? Seriously,
can you guess? I can think of roughly four realistic guesses. Is it
even valid syntax? Here’s the truth:</p>
<div data-snippet-clipboard-copy-content="names(mtcars) &lt;- LETTERS[1:11]
a &lt;- rep(c(&#34;example&#34;, &#34;text&#34;), length.out = 11)
names(a) &lt;- LETTERS[12:22]
a
##         L         M         N         O         P         Q         R         S 
## &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; 
##         T         U         V 
## &#34;example&#34;    &#34;text&#34; &#34;example&#34;
names(a) &lt;- names(mtcars)
a
##         A         B         C         D         E         F         G         H 
## &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; 
##         I         J         K 
## &#34;example&#34;    &#34;text&#34; &#34;example&#34;"><pre>names(<span>mtcars</span>) <span>&lt;-</span> <span>LETTERS</span>[<span>1</span><span>:</span><span>11</span>]
<span>a</span> <span>&lt;-</span> rep(c(<span><span>&#34;</span>example<span>&#34;</span></span>, <span><span>&#34;</span>text<span>&#34;</span></span>), <span>length.out</span> <span>=</span> <span>11</span>)
names(<span>a</span>) <span>&lt;-</span> <span>LETTERS</span>[<span>12</span><span>:</span><span>22</span>]
<span>a</span>
<span><span>#</span>#         L         M         N         O         P         Q         R         S </span>
<span><span>#</span># &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; </span>
<span><span>#</span>#         T         U         V </span>
<span><span>#</span># &#34;example&#34;    &#34;text&#34; &#34;example&#34;</span>
names(<span>a</span>) <span>&lt;-</span> names(<span>mtcars</span>)
<span>a</span>
<span><span>#</span>#         A         B         C         D         E         F         G         H </span>
<span><span>#</span># &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; &#34;example&#34;    &#34;text&#34; </span>
<span><span>#</span>#         I         J         K </span>
<span><span>#</span># &#34;example&#34;    &#34;text&#34; &#34;example&#34;</span></pre></div>
<p dir="auto">This is probably the result that you guessed, but syntax shouldn’t
leave you guessing. Where possible, I try to stick to <code>setNames()</code>.</p>
</li>
<li>
<p dir="auto">The syntactic sugar sometimes leads to surprising syntax. For
example <code>names(output[2]) &lt;- &#34;foo&#34;</code> doesn’t work, but
<code>names(output)[2] &lt;- &#34;foo&#34;</code> does.</p>
</li>
<li>
<p dir="auto">As is extremely well documented, <code>T</code> and <code>F</code> can be used in place of
<code>TRUE</code> and <code>FALSE</code>, but you should never do this because <code>T</code> and <code>F</code>
are just variables that can be overwritten in your code. Why let us
do something that we never should? To my surprise, there’s actually
a sensible answer. <a href="https://cran.r-project.org/doc/FAQ/R-FAQ.html#Others" rel="nofollow">Section 3.3.3 of the R
FAQ</a> says that
S had <code>T</code> and <code>F</code> as reserved words, but R changed that to allow
variables called <code>&#34;T&#34;</code> and <code>&#34;F&#34;</code> to appear in your datasets. I can
see the reasoning behind both S’s approach and R’s change to it, but
I still think that R’s approach of “<em>you can do this, but never do</em>”
is obviously wrong. My suspicion is that the third option of “<em>just
make <code>T</code> and <code>F</code> not mean anything until they’re assigned to</em>” will
never be taken, because the current (and dangerous) approach helps
with backwards compatibility. I don’t think that it’s a good trade.</p>
</li>
<li>
<p dir="auto">Although I like R’s many functional programming tools, the
temptation to try to use them to solve every problem is very strong.
I’ve wasted countless hours trying to pick the right one of
<code>sapply()</code>/<code>lapply()</code>/<code>mapply()</code>/<code>Filter()</code>/<code>Map()</code>… (not to mention
their various arguments) when I really should’ve just written the
<code>for</code> loop. This is more my fault than it is R’s, but it’s a curse
that every intermediate R user will suffer from. It’s a price that
any R expert will tell you was worth it in the end. However, it’s
still a price that I don’t enjoy paying. It wouldn’t be so bad if R
had less such functions, better error messages, or more consistency
between these functions, but we’ve already discussed that can of
worms. Don’t think that I’m advocating for <code>purrr</code> here. It has so
many functional programming tools that it arguably makes the
situation worse. I’ll cover its costs and benefits
<a href="#55-purrr">later</a>.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-4111-sequences" aria-hidden="true" href="#4111-sequences"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.11.1 Sequences</h3>
<p dir="auto">The <code>:</code> operator is absolutely lovely… until it screws you. The solution
is to prefer the <code>seq()</code> functions to using <code>:</code>. Some quick examples:</p>
<ul dir="auto">
<li>
<p dir="auto">Stuff like <code>i in 1:n</code> is great, but if you accidentally have
<code>n &lt;= 0</code>, it silently gives behaviours that you probably don’t want.</p>
<div data-snippet-clipboard-copy-content="1:2
## [1] 1 2
1:1
## [1] 1
1:0
## [1] 1 0
1:-1
## [1]  1  0 -1"><pre><span>1</span><span>:</span><span>2</span>
<span><span>#</span># [1] 1 2</span>
<span>1</span><span>:</span><span>1</span>
<span><span>#</span># [1] 1</span>
<span>1</span><span>:</span><span>0</span>
<span><span>#</span># [1] 1 0</span>
<span>1</span><span>:</span><span>-</span><span>1</span>
<span><span>#</span># [1]  1  0 -1</span></pre></div>
<p dir="auto"><code>seq_len()</code> is better behaved, so I try to stick to it.</p>
<div data-snippet-clipboard-copy-content="seq_len(2)
## [1] 1 2
seq_len(1)
## [1] 1
seq_len(0)
## integer(0)
#seq_len(-1) is an error."><pre>seq_len(<span>2</span>)
<span><span>#</span># [1] 1 2</span>
seq_len(<span>1</span>)
<span><span>#</span># [1] 1</span>
seq_len(<span>0</span>)
<span><span>#</span># integer(0)</span>
<span><span>#</span>seq_len(-1) is an error.</span></pre></div>
</li>
<li>
<p dir="auto"><code>:</code> has operator precedence issues. You might expect stuff like
<code>-6/2:3</code> to generate <code>(-(6/2)):3</code> i.e. <code>-3:3</code>. It doesn’t.</p>
<div data-snippet-clipboard-copy-content="-6/2:3 #Treated as -6/(2:3)
## [1] -3 -2"><pre><span>-</span><span>6</span><span>/</span><span>2</span><span>:</span><span>3</span> <span><span>#</span>Treated as -6/(2:3)</span>
<span><span>#</span># [1] -3 -2</span></pre></div>
<p dir="auto">I’ll leave <code>-6/2:6/2</code> as an exercise for the reader. I’d like to
keep things simple and say that the trick is that <code>:</code> is always
evaluated first, but that’s actually not true. Even if we’re only
talking about arithmetical operations, exponentiation is done before
<code>:</code> is applied.</p>
<div data-snippet-clipboard-copy-content="3^1:5 #Treated as (3^1):5
## [1] 3 4 5"><pre><span>3</span><span>^</span><span>1</span><span>:</span><span>5</span> <span><span>#</span>Treated as (3^1):5</span>
<span><span>#</span># [1] 3 4 5</span></pre></div>
</li>
<li>
<p dir="auto">Can you guess what <code>data[-1:5]</code> returns? I can’t either, so don’t
ever try it. If you must know, it’s actually an error.</p>
</li>
</ul>
<p dir="auto">As I’ve said, <code>seq()</code> and its related functions usually fix this issue.
The only real disappointment with <code>seq()</code> itself is that its
documentation warns against not naming its arguments, so you’re forced
to write the long-winded <code>seq(from = 0, to = 100, by = 6)</code> rather than
just <code>seq(0, 100, 6)</code>.</p>
<h3 dir="auto"><a id="user-content-4112-non-standard-evaluation" aria-hidden="true" href="#4112-non-standard-evaluation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.11.2 Non-standard Evaluation</h3>
<p dir="auto">The documentation for several functions with non-standard evaluation,
e.g. <code>with()</code> and <code>subset()</code>, explicitly warns the user to not use them
when programming. This is a source of a number of problems, both
practically and in a meta sense:</p>
<ul dir="auto">
<li>
<p dir="auto">First of all, the existence of functions that are not for
programming use is abhorrent.</p>
</li>
<li>
<p dir="auto">They’re excellent syntactic sugar, so I hate not being able to use
them! For example, I’d argue that
<code>within(data, rm(colName1, colName2))</code> is the best way to remove
unwanted columns from my data: It does not require me to quote or
escape my column names, does not require me to put <code>data$</code> before
everything, does not require me to pass that annoying <code>drop = FALSE</code>
argument, warns me if I am trying to remove a column that is not in
my data, and reads almost like English. All in all, that’s some
major advantages over using <code>[</code>. They both have some misbehaviour if
your column names are duplicated, but that’s not very relevant here.</p>
</li>
<li>
<p dir="auto">The documentation for a lot of the functions that use non-standard
evaluation warn you to take care with them, but they do very little
to tell you how or why. I’ve searched high and low, but I sincerely
believe that there is almost nothing in R’s documentation that tells
you what can go wrong with these functions. Seriously, if you can
find it, let me know. I’ve even read the <a href="https://developer.r-project.org/nonstandard-eval.pdf" rel="nofollow">Thomas Lumley
article</a> that
some of the docs tell you to check and I still can’t find much of
relevance. As with <code>.class2()</code>, I find R’s habit of putting
unexplained warnings in its documentation deeply maddening.</p>
</li>
<li>
<p dir="auto">Because you don’t know when it’s safe to use these functions and
when it isn’t, you feel incredible anger when the perfect solution
to your problem is to use one of them. You get in situations like
“<em>I could either easily do this with <code>with()</code> or write out an
<code>mapply()</code> with a long-winded anonymous function…</em>” and always have
to choose to do things the hard way. It makes you want to never use
R outside of the REPL. This is one part where the Tidyverse
completely destroys base R.</p>
</li>
<li>
<p dir="auto">So what can actually go wrong with them? To be honest, I don’t
really know. A lot of these functions internally rely on a function
called <code>substitute()</code>, which has special behaviour when it tries to
interact with anything defined in the global environment, so it’s
slightly difficult to invent easy-to-type examples of these
functions misbehaving. All that I’ve managed to find is:</p>
<ul dir="auto">
<li>I’ve been told that if something exists in the calling
environment of your function with non-standard evaluation, but
not in the data that you’re trying to work on, then you’re in
trouble. I’ve yet to be able to invent an example that shows
unexpected behaviour.</li>
<li>Code like <code>subset(data, exampleCol &gt; x)</code> will misbehave if <code>x</code>
is a column in <code>data</code> but you intended it to come from the
calling environment.</li>
</ul>
<div data-snippet-clipboard-copy-content="head(airquality)
##   Ozone Solar.R Wind Temp Month Day
## 1    41     190  7.4   67     5   1
## 2    36     118  8.0   72     5   2
## 3    12     149 12.6   74     5   3
## 4    18     313 11.5   62     5   4
## 5    NA      NA 14.3   56     5   5
## 6    28      NA 14.9   66     5   6
head(subset(airquality, Wind * 5 &gt; Temp))
##    Ozone Solar.R Wind Temp Month Day
## 5     NA      NA 14.3   56     5   5
## 6     28      NA 14.9   66     5   6
## 8     19      99 13.8   59     5   8
## 9      8      19 20.1   61     5   9
## 15    18      65 13.2   58     5  15
## 18     6      78 18.4   57     5  18
Temp &lt;- 90000000
head(subset(airquality, Wind * 5 &gt; Temp))#Identical to the previous call.
##    Ozone Solar.R Wind Temp Month Day
## 5     NA      NA 14.3   56     5   5
## 6     28      NA 14.9   66     5   6
## 8     19      99 13.8   59     5   8
## 9      8      19 20.1   61     5   9
## 15    18      65 13.2   58     5  15
## 18     6      78 18.4   57     5  18"><pre>head(<span>airquality</span>)
<span><span>#</span>#   Ozone Solar.R Wind Temp Month Day</span>
<span><span>#</span># 1    41     190  7.4   67     5   1</span>
<span><span>#</span># 2    36     118  8.0   72     5   2</span>
<span><span>#</span># 3    12     149 12.6   74     5   3</span>
<span><span>#</span># 4    18     313 11.5   62     5   4</span>
<span><span>#</span># 5    NA      NA 14.3   56     5   5</span>
<span><span>#</span># 6    28      NA 14.9   66     5   6</span>
head(subset(<span>airquality</span>, <span>Wind</span> <span>*</span> <span>5</span> <span>&gt;</span> <span>Temp</span>))
<span><span>#</span>#    Ozone Solar.R Wind Temp Month Day</span>
<span><span>#</span># 5     NA      NA 14.3   56     5   5</span>
<span><span>#</span># 6     28      NA 14.9   66     5   6</span>
<span><span>#</span># 8     19      99 13.8   59     5   8</span>
<span><span>#</span># 9      8      19 20.1   61     5   9</span>
<span><span>#</span># 15    18      65 13.2   58     5  15</span>
<span><span>#</span># 18     6      78 18.4   57     5  18</span>
<span>Temp</span> <span>&lt;-</span> <span>90000000</span>
head(subset(<span>airquality</span>, <span>Wind</span> <span>*</span> <span>5</span> <span>&gt;</span> <span>Temp</span>))<span><span>#</span>Identical to the previous call.</span>
<span><span>#</span>#    Ozone Solar.R Wind Temp Month Day</span>
<span><span>#</span># 5     NA      NA 14.3   56     5   5</span>
<span><span>#</span># 6     28      NA 14.9   66     5   6</span>
<span><span>#</span># 8     19      99 13.8   59     5   8</span>
<span><span>#</span># 9      8      19 20.1   61     5   9</span>
<span><span>#</span># 15    18      65 13.2   58     5  15</span>
<span><span>#</span># 18     6      78 18.4   57     5  18</span></pre></div>
<p dir="auto">I think that this is the case that <code>with()</code>’s documentation is
trying to warn you about. <code>subset()</code>’s documentation does not appear
to contain any such warning, unless you’re generous enough to count
“<em>the non-standard evaluation of argument subset can have
unanticipated consequences</em>”. How hard would it have been to give an
example like the one that I’ve just given?</p>
<ul dir="auto">
<li><a href="https://adv-r.hadley.nz/evaluation.html#base-evaluation" rel="nofollow"><em>Advanced R</em> tries to explain some other
issues</a>,
but the extent of them has never been completely clear to me.</li>
</ul>
</li>
</ul>
<p dir="auto">Of all the problems that I’ve written about, this section’s probably
bother me the most. So many of R’s problems could be sidestepped if we
could fearlessly use <code>with()</code> and <code>subset()</code> at all times, but R’s nasty
habit of not explaining the dangers that it warms you of leaves me in
constant paranoia.</p>
<h2 dir="auto"><a id="user-content-412-missing-features" aria-hidden="true" href="#412-missing-features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.12 Missing Features</h2>
<p dir="auto">Some things seems obviously missing from R:</p>
<ul dir="auto">
<li>
<p dir="auto">For a Scheme-inspired language, the lack of any tail call
optimisation or any macro system is strange. Then again, being a
heavily functional language that looks like C is one of the best
things about R. If it had tail call optimisation or Lisp-like
macros, it’d probably start to look more like a weird statistical
version of Lisp.</p>
</li>
<li>
<p dir="auto">You can only break out of the innermost loop. Unless you refactor,
there’s no way to be many loops deep and break out of them all with
one command.</p>
</li>
<li>
<p dir="auto">R has no <code>do-while</code> loop. It’s never bothered me, but I think that’s
because I’ve never used one in any language. I can see it bothering
others, but if I need one, then I’m pretty sure that they’re trivial
to make from a <code>repeat</code> loop.</p>
</li>
<li>
<p dir="auto">Without crude <code>if(FALSE){}</code> workarounds, there’s no way to comment
out blocks.</p>
</li>
<li>
<p dir="auto">Outside of packages, R lacks any real dictionary, associative array,
or linked list type. The closest that we can get is matching
elements to their names <a href="https://adv-r.hadley.nz/subsetting.html#lookup-tables" rel="nofollow">like
this</a>. I’ve
always thought that it seems like a hacky way to get what other
languages have built in. You can also do it with environments, which
apparently has O(1) lookup, but I’ve never seen anyone do it. That
may have something to do with how the base R syntax for creating
environments from scratch isn’t as nice as its syntax for creating
lists. You have to name and assign each element individually,
e.g. <code>e &lt;- new.env(); e$a &lt;- 1;  e$b &lt;- 2;  e$c &lt;- 3</code>, rather than
just <code>l &lt;- list(a = 1, b = 2, c = 3)</code>. And if you’re going to use a
package to fix this syntax issue, then you might as well just use
one that gives you actual hash tables.</p>
</li>
<li>
<p dir="auto">Given that R is a maths/stats language, I find the follow omissions
surprising:</p>
<ul dir="auto">
<li>There’s no base function for counting the number of possible
permutations of a collection of objects.</li>
<li>Despite there being a function for finding the combinations that
you can make from the elements of a vector, there’s no function
that does that with repetitions. For example, <code>combn(1:3, 2)</code>
can’t be convinced to include <code>c(1, 1)</code>, <code>c(2, 2)</code>, and
<code>c(3, 3)</code>.</li>
<li>There’s no built-in big integer class.</li>
<li>Despite supporting equations, R offers no obvious way to
simplify them.</li>
<li>Although R has some matrix functionality built in, there’s no
<code>is.square()</code> function.</li>
<li>There is no base R function to check if a number is a whole
number. <code>is.integer()</code> checks for integer typing rather than if
the input is in of itself an integer. The docs even show that
<code>is.integer(1)</code> is <code>FALSE</code>. Worse still, these docs actually
show you the code for a good <code>is.wholenumber()</code> function! Why
couldn’t that be in the base library?</li>
</ul>
</li>
<li>
<p dir="auto">Once you’re aware of it, the previous issue starts coming up in
weird places. This suggests that R’s missing something in its error
checks. Take a look:</p>
<div data-snippet-clipboard-copy-content="seq_len(4.8) #Not an error
## [1] 1 2 3 4
1:4.8
## [1] 1 2 3 4
a &lt;- 1:10
a[4.8]
## [1] 4
a[-4.8]
## [1]  1  2  3  5  6  7  8  9 10
sample(4.8)
## [1] 4 1 3 2"><pre>seq_len(<span>4.8</span>) <span><span>#</span>Not an error</span>
<span><span>#</span># [1] 1 2 3 4</span>
<span>1</span><span>:</span><span>4.8</span>
<span><span>#</span># [1] 1 2 3 4</span>
<span>a</span> <span>&lt;-</span> <span>1</span><span>:</span><span>10</span>
<span>a</span>[<span>4.8</span>]
<span><span>#</span># [1] 4</span>
<span>a</span>[<span>-</span><span>4.8</span>]
<span><span>#</span># [1]  1  2  3  5  6  7  8  9 10</span>
sample(<span>4.8</span>)
<span><span>#</span># [1] 4 1 3 2</span></pre></div>
<p dir="auto">The pattern is that <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Indexing-by-vectors" rel="nofollow">R silently truncates the numeric index of
choice towards
0</a>.</p>
</li>
</ul>
<p dir="auto">Admittedly, few if any of these are major, but they’re a bit annoying.</p>
<h2 dir="auto"><a id="user-content-413-miscellaneous-negatives" aria-hidden="true" href="#413-miscellaneous-negatives"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4.13 Miscellaneous Negatives</h2>
<p dir="auto">And now for everything that I’ve got left in the bag.</p>
<ul dir="auto">
<li>
<p dir="auto">The two language problem: Sooner or later, you’ll run in to a memory
issue, go to Stack Overflow, and be told that the solution is to use
a package that lets R talk to C++. Julia claims to have solved this.
I don’t know if I believe it.</p>
</li>
<li>
<p dir="auto">The index in a <code>for</code> loop uses the same environment as its caller,
so loops like <code>for(i in 1:10)</code> will overwrite any variable called
<code>i</code> in the parent environment and set it to <code>10</code> when the loop
finishes.</p>
<div data-snippet-clipboard-copy-content="i &lt;- 2000
for(i in 1:10){}
i
## [1] 10"><pre><span>i</span> <span>&lt;-</span> <span>2000</span>
<span>for</span>(<span>i</span> <span>in</span> <span>1</span><span>:</span><span>10</span>){}
<span>i</span>
<span><span>#</span># [1] 10</span></pre></div>
<p dir="auto">This sounds awful, but I’ve never encountered it in practice. After
all, it sounds like bad practice to use the same variable name for
two different things. Apparently the <code>for</code> loops also like to strip
attributes, breaking S3 objects, but again, I’ve never encountered
this. After all, idiomatic R it to prefer functions like <code>sapply()</code>
to <code>for</code> loops.</p>
</li>
<li>
<p dir="auto"><em>Advanced R</em> claims that R is a great language to metaprogram. I
cannot deny that the Tidyverse is very strong evidence for that, but
who would dare metaprogram a language as poorly documented and as
inconsistent as I’ve claimed R is? Certainly not me. I can’t even
predict R’s behaviour when I’m programming it, never mind
metaprogramming! I’ve regretted most of my attempts at doing so. I
usually get tripped up by some quirk of R’s string-manipulation
facilities and how the strings get parsed as expressions.</p>
</li>
<li>
<p dir="auto">For a language that was inspired by Scheme, R’s metaprogramming
feels very limited. As far as I can tell, aside from the typical
operation of building code from text that I’d expect any language to
be capable of, it is only used to facilitate the creation of
functions that evaluate their arguments in a non-standard way.
Usually, this doesn’t go any further than creating an ad-hoc
environment where the function’s arguments make sense, despite said
arguments having no meaning in the calling environment. Typical
examples are <code>with()</code> and modelling functions like <code>lm()</code>, which let
you write code like <code>lm(mpg ~ wt, mtcars)</code>. Being able to say “<em>let
me tell you what data I want you to treat like an environment, so I
can refer to its variables as if they were objects in the calling
environment</em>” is great, but it’s nowhere near what a Lisp user would
expect.</p>
</li>
<li>
<p dir="auto">The <code>plot()</code> function has some strange defaults. For example, you
need to have a plot before you can plot points, and it often doesn’t
know what to do in terms of how long/wide its axes should be. I also
don’t like how “<em>predict <code>mpg</code> from <code>wt</code></em>” is <code>foo(mpg~wt)</code>, but
“<em>plot <code>mpg</code> on the y-axis and <code>wt</code> on the x-axis</em>” is
<code>plot(wt, mpg)</code>. I understand why both options are the way that they
are, but it creates unpredictability.</p>
</li>
<li>
<p dir="auto">I seem to have terrible luck with the documentation for R’s
libraries. Even when using popular packages that have been around
for years, I often find documentation errors that are so basic that
I can’t explain how they’ve gone unnoticed. I’ve seen documentation
that reports the wrong return types, imports unnecessary libraries
in its example code, and completely fails to mention significant
parameters! I try to fix these when I find them, so I can no longer
name names, but it’s a source of significant annoyance.</p>
</li>
<li>
<p dir="auto"><em>Advanced R</em> points out that <a href="https://adv-r.hadley.nz/introduction.html#why-r" rel="nofollow">good R code is
rare</a>, but I have a
different take on it that I think explains my poor luck with R
libraries: Statisticians don’t want to write code or learn GitHub
and programmers don’t want to use any more R than they strictly need
to. This means that nobody is really doing any bug fixing or even
reporting. On the bright side, this makes it very easy to improve
other people’s R code and get accepted pull requests.</p>
</li>
</ul>

<p dir="auto">As I’ve already admitted, my knowledge of the Tidyverse is much less
than my knowledge of base R. However, no critique of R is complete
without at least giving this a mention. Its popularity, along with R
version 4.0.6. adopting some its ideas (pipes and a shorter anonymous
function syntax), are clear evidence that it’s on to something. Before
going in to the specific libraries, I’ll give some general thoughts:</p>
<ul dir="auto">
<li>I can’t back down from the “<em>polished turd</em>” point that I <a href="#48-the-community">made
earlier</a>. No matter how good the Tidyverse is,
any attempt to fix R’s inconsistencies by making new libraries is
doomed to fail. Base R is inconsistent, so the only way to be
consistent with it is to be inconsistent. For example, <code>as.foo()</code> is
inconsistent with R’s S3 system, but it’s what I’d expect to find
with a new class called <code>foo</code> in a library. The only solution to
this problem is to somehow write code that completely ignores base
R, but that becomes impossible as soon as you try to load anyone
else’s packages.</li>
<li>I’m sure that I’ve seen the main author of the Tidyverse quoted as
saying that he didn’t want it to be a monolith. However, it
undeniably is one. Tidyverse packages will throw errors with
<code>rlang</code>, be made specifically to work with other Tidyverse packages
(see the <a href="https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html" rel="nofollow">first paragraph of the
manifesto</a>),
and depreciate their own functions in favour of functions from
different Tidyverse packages.</li>
<li>For <a href="#43-variable-manipulation">the reasons explained earlier</a>, the
authors are very scared of the <code>...</code> argument’s ability to pass
arguments to where they should not have gone. To counter this, most
of the Tidyverse functions use names that you would never type. This
means that without an IDE prompting you, you’re going to get a lot
of the argument names wrong. I’ve slipped up with <code>tibble</code>’s
<code>.name_repair</code> argument a few times. Get it wrong and R probably
won’t let you know!</li>
<li>I really understand the “<em>consistent interface</em>” selling point of
the Tidyverse. Because of the <code>[x]</code>/<code>[x,]</code>/<code>[,x]</code> business, I often
guess wrong with functions like <code>base::order()</code>, but I almost never
guess wrong with <code>dplyr::arrange()</code>.</li>
<li>The API of the Tidyverse is rarely stable; It constantly depreciates
functions and <a href="https://cran.r-project.org/web/packages/tidyverse/vignettes/paper.html" rel="nofollow">owns up to its willingness to do
so</a>.
I understand the value of not being tied to your past mistakes – see
my many complaints about base R’s interest in supporting S – but
it’s rare that I look through the documentation for a Tidyverse
package and not see a note saying that something either is
depreciated or soon will be. It’s even worse when I see a Stack
Overflow answer with just the function that I need, only to find
that my newer version of the package doesn’t even have the old
function. However, the worst example by far is when the <em>R for Data
Science</em> book can’t keep up with the depreciation. For example, when
I read chapter 25, the code in the book was spitting out warnings
about the <code>.drop</code> argument to <code>unnest()</code> being deprecated. Importing
a package when making your own package is already a risky
proposition, but <strong>issues like this would have me do all of my work
in base R even if there was a perfect Tidyverse function for the
job</strong>.</li>
<li>The Tidyverse is undeniably designed around piping (see the <a href="https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html" rel="nofollow">second
point of the
manifesto</a>).
It’s not obvious that piping is a good framework to build around. To
keep pipes simple, you must build functions that are easy to
compose. This means that you will design your functions to have the
minimum number of arguments that you can get away with. If you need
more arguments, then you will instead make more functions wherever
possible. This is a significant increase in complexity. Surely
arguments are less complicated than functions? I dread to think what
it takes to replicate a function like <code>aggregate()</code> in the
Tidyverse. Even something as simple as <code>dplyr::select()</code> has about
10 helper functions in its documentation. I’m willing to be proven
wrong here, but everything that I’ve just said strikes me as
obviously true to anyone who has used <code>dplyr</code> or <code>purrr</code>.</li>
</ul>
<p dir="auto">Overall, I’m more than happy to use Tidyverse functions when I’m writing
some run-once code or messing around in the REPL, but the unstable API
point is a real killer for anything else. In terms of how it compares to
base R, I’d rather use quite a few of its packages than their base R
equivalents. However, that doesn’t mean that it can actually replace
base R. I see it as nothing more than a handy set of libraries.</p>
<p dir="auto">Now for the specific libraries. Assume that I’m ignorant of any that
I’ve skipped.</p>
<h2 dir="auto"><a id="user-content-51-dplyr" aria-hidden="true" href="#51-dplyr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5.1 Dplyr</h2>
<ul dir="auto">
<li>I don’t like how it has name conflicts with the base R stats
library. It just seems rude.</li>
<li>Remember all of my complaints about <a href="#45-subsetting">base R’s
subsetting</a> and how I’d rather use the <a href="#4112-non-standard-evaluation">non-standard
evaluation</a> functions if it weren’t
for all of their vague warnings? <code>dplyr</code> completely nullifies most
of these complains, for data frames at least. This is a huge win for
the Tidyverse.</li>
<li>R’s <a href="#410-factor-variables">factor variables are scary</a>.
<code>dplyr::group_by()</code> takes a more SQL-like approach to the problem
and feels a lot safer to work with.</li>
<li>Compared to base R, the knowledge that <code>dplyr</code> will only output a
tibble is a relief. There’s no need to consider if I need
<code>tapply()</code>, <code>by()</code>, or <code>aggregate()</code> for a job or if I need to
coerce my input in order to go in/out of functions like <code>table()</code>. I
therefore need to do a lot less guessing. <a href="https://gist.github.com/hadley/c430501804349d382ce90754936ab8ec">This
link</a>
demonstrates it better than I can, although the formula solution
with <code>aggregate()</code> is in base R’s favour.</li>
<li><code>dplyr::mutate()</code> is just plain better than base R’s <code>transform()</code>.
In particular, it allow you to refer to columns that you’ve just
created.</li>
<li><a href="https://cran.r-project.org/web/packages/dplyr/vignettes/base.html" rel="nofollow">This
link</a>
shows a comparison between base R and <code>dplyr</code>. It’s rather
persuasive. In particular, it gives you the sense that you can make
safe guesses about the <code>dplyr</code> functions.</li>
<li>I don’t like how the <code>dplyr</code> functions only accept data frame or
objects derived from them. If I’m doing some work with something
like <code>stringr</code>, I instinctively want to use a Tidyverse solution to
problems like subsetting my inputs. However, if I reach for
<code>dplyr::filter()</code>, I get errors due to character vector not being
data frames.</li>
</ul>
<h2 dir="auto"><a id="user-content-52-ggplot2" aria-hidden="true" href="#52-ggplot2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5.2 Ggplot2</h2>
<ul dir="auto">
<li>To repeat my earlier praise for this library, it’s fun. That’s a
huge win.</li>
<li>It has amazingly sane defaults. Whenever I make the same graph in
both this and base R’s <code>plot()</code>, <code>ggplot2</code>’s is much better. You can
tell R to do stuff like include a useful legend or grid, but
<code>ggplot2</code> does it by default.</li>
<li>I like how graphs are made by what amounts to composing functions.
It makes it very easy to focus on one specific element of your plots
at a time. I’d even go as far as say that it’s fun to see what
happens when you replace a component with another valid but strange
one. You can discover entirely new categories of graphs by accident.</li>
<li>I miss the genericness of base R’s <code>plot()</code>. When I can’t be
bothered to think about what sort of plot I need, <code>plot()</code> can save
me the trouble by making a correct guess. There is no such facility
in <code>ggplot2</code>.</li>
</ul>
<h2 dir="auto"><a id="user-content-53-lubridate" aria-hidden="true" href="#53-lubridate"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5.3 Lubridate</h2>
<p dir="auto">I don’t use dates much, so I don’t have much to say. In fact, I don’t
think that I’ve mentioned them before now. <code>lubridate</code> appears to be
much easier to use than base R dates and times, but I know neither very
well. I don’t like how base R seems to force you to do any time
arithmetic in seconds and date arithmetic in days. I also don’t like how
it’s hard to do arithmetic with times in base R without a date being
attached. However, I could be wrong about all of that. I really don’t
know any of them too well and I’ve never found much reason to learn. I’d
really like to see
<a href="https://rosettacode.org/wiki/Convert_seconds_to_compound_duration" rel="nofollow">https://rosettacode.org/wiki/Convert_seconds_to_compound_duration</a>
solved in both base R and <code>lubridate</code>. I’m not saying that it would be
hard, but I’d love to see the comparison. Overall, all that I can really
say for certain is that experience has shown that when the day comes,
I’ll have a much easier time learning this package than what base R
offers for the same jobs.</p>
<h2 dir="auto"><a id="user-content-54-magrittr" aria-hidden="true" href="#54-magrittr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5.4 Magrittr</h2>
<p dir="auto">Pipes come in very handy, but I’ve never been completely sold on them,
even when viewing teaching examples that are supposed to demonstrate
their superiority. I’ll admit that there is a time and a place for them
– e.g. printing and graphing code – but I think that they only really
shine when you’ve abandoned base R in favour of <code>purrr</code>. After all, base
R wasn’t built for pipes. I’d even go as far as to say that the people
who swear by <code>magrittr</code> and <code>purrr</code> have adopted a completely different
paradigm to those who don’t, so they end up using totally different
tools. For example, a master of the Tidyverse finds <a href="https://adv-r.hadley.nz/functionals.html" rel="nofollow"><em>Advanced R</em>
chapter nine’s</a></p>
<div data-snippet-clipboard-copy-content="by_cyl %&gt;% 
  map(~ lm(mpg ~ wt, data = .x)) %&gt;% 
  map(coef) %&gt;% 
  map_dbl(2)"><pre><span>by_cyl</span> %<span>&gt;</span>% 
  map(<span>~</span> lm(<span>mpg</span> <span>~</span> <span>wt</span>, <span>data</span> <span>=</span> <span>.x</span>)) %<span>&gt;</span>% 
  map(<span>coef</span>) %<span>&gt;</span>% 
  map_dbl(<span>2</span>)</pre></div>
<p dir="auto">just as informative as my
<code>lapply(by_cyl, function(x) lm(mpg ~ wt, data = x)$coef[[2]])</code> (or its
equivalent <code>sapply()</code> or <code>vapply()</code>, if you really insist). Overall, I
think that I can’t evaluate <code>magrittr</code> without also evaluating <code>purrr</code>.</p>
<p dir="auto">As a side-note, the claim that <code>foo %&gt;% bar()</code> is equivalent to
<code>bar(foo)</code> appears to be a white lie. Try it with a plotting function
that cares about the variable name of its argument. Spot the difference:</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/ReeceGoding/Frustration-One-Year-With-R/blob/master/Frustration-One-Year-With-R_files/figure-gfm/unnamed-chunk-88-1.png"><img src="https://www.youtube.com/ReeceGoding/Frustration-One-Year-With-R/raw/master/Frustration-One-Year-With-R_files/figure-gfm/unnamed-chunk-88-1.png" alt=""/></a></p>
<div data-snippet-clipboard-copy-content="library(magrittr)
## 
## Attaching package: &#39;magrittr&#39;
## The following object is masked from &#39;package:purrr&#39;:
## 
##     set_names
Nile %&gt;% plot()"><pre>library(<span>magrittr</span>)
<span><span>#</span># </span>
<span><span>#</span># Attaching package: &#39;magrittr&#39;</span>
<span><span>#</span># The following object is masked from &#39;package:purrr&#39;:</span>
<span><span>#</span># </span>
<span><span>#</span>#     set_names</span>
<span>Nile</span> %<span>&gt;</span>% plot()</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/ReeceGoding/Frustration-One-Year-With-R/blob/master/Frustration-One-Year-With-R_files/figure-gfm/unnamed-chunk-88-2.png"><img src="https://www.youtube.com/ReeceGoding/Frustration-One-Year-With-R/raw/master/Frustration-One-Year-With-R_files/figure-gfm/unnamed-chunk-88-2.png" alt=""/></a></p>
<div data-snippet-clipboard-copy-content="Nile |&gt; plot() #The same as plot(Nile)"><pre><span>Nile</span> <span>|</span><span>&gt;</span> plot() <span><span>#</span>The same as plot(Nile)</span></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/ReeceGoding/Frustration-One-Year-With-R/blob/master/Frustration-One-Year-With-R_files/figure-gfm/unnamed-chunk-88-3.png"><img src="https://www.youtube.com/ReeceGoding/Frustration-One-Year-With-R/raw/master/Frustration-One-Year-With-R_files/figure-gfm/unnamed-chunk-88-3.png" alt=""/></a></p>
<p dir="auto">Don’t get me wrong, I like pipes a lot. When you’re dealing with data,
there’s sometimes no way to avoid “<em>do <code>foo()</code> to my data and then do
<code>bar()</code></em>” code. However, you’d be mad to use them all of the time. For
people that do use them, all that I can say is that you should take the
time to learn all of them and that said time really isn’t much. None of
them are much more complicated than <code>%&gt;%</code> and <code>%$%</code> is a handy
replacement for <code>with()</code>.</p>
<p dir="auto">As a final point, I don’t like how much trouble base R’s new <code>|&gt;</code> pipe
causes me. You can’t do <code>x |&gt; foo</code>. You instead need <code>x |&gt; foo()</code>. Also,
to use a function where the target argument isn’t first, you need to use
some nonsense like <code>x |&gt; (function(x) foo(bar, x))()</code>. For example,
<code>mtcars |&gt; (function(x) Map(max, x))()</code>. I don’t like all of those extra
brackets. <code>magrittr</code> can do it with just
<code>mtcars %&gt;% (function(x) Map(max, x))</code> or even <code>mtcars %&gt;% Map(max, .)</code>.</p>
<h2 dir="auto"><a id="user-content-55-purrr" aria-hidden="true" href="#55-purrr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5.5 Purrr</h2>
<p dir="auto">Unlike base R, where I can point to a specific example and explain to
you why it’s silly, my objections to <code>purrr</code> are mostly philosophical.
It certainly does some things much better than base R. For example, I
really like the consistency in the map functions. They’re a breath of
fresh air compared to base R’s apply family vs funprog mess. My code
would probably be a lot easier to read and modify if I replaced all of
my apply family and funprog calls with their <code>purrr</code> equivalents.
However, when writing the code in the first place, I’d much rather have
the flexibility that the base R functions offer. I also like <code>pluck()</code>
and it being built in to the map functions, but I’ve yet to get used to
it. Overall, I wouldn’t mind using <code>purrr</code>, but I have some major
objections:</p>
<ul dir="auto">
<li>It takes the idea of “<em>a function should only do one thing</em>” to a
pathological level. I see no reason why <code>map_lgl()</code>, <code>map_int()</code>,
<code>map_dbl()</code>, and <code>map_chr()</code> are separate functions. They do exactly
the same thing, but will throw an error if they don’t get the return
type in their name. Why isn’t this the job of some general mapping
function that takes the desired output type as an argument
(e.g. like base R’s <code>vapply()</code>)? This same issue is found in the
entire library. There is no need for the <code>map2()</code> and <code>pmap()</code>
functions or their countless _type variants. Just make a general
<code>map()</code> function! To steal a point from the <a href="https://github.com/matloff/TidyverseSkeptic/blob/master/READMEFull.md">TidyverseSkeptic
essay</a>,
<code>purrr</code> has 178 functions, and 52 are maps. What would you rather
learn: a handful of complex map functions (like base R) or 52 simple
ones? The only defences that I’ve seen for the <code>purrr</code> approach is
that base R can be a bit verbose, e.g. <code>vapply()</code>’s arguments like
<code>FUN.VALUE = logical(1)</code>, and that using the most restrictive
possible tool for any given job increases the readability of your
code.</li>
<li>It makes base R’s <code>~</code> operator able to form anonymous functions, at
least within <code>purrr</code> (it’s some funky parsing). I could get used to
it, but I don’t like how it robs the user of the ability to give the
arguments to their anonymous function any meaningful names. This is
because the <code>purrr</code> authors thought that the normal anonymous
function syntax was too verbose, but I’d argue that they’ve gone too
far and made their syntax too terse.
<code>Map(function(x) runif(1), 1:3)</code> is not long or particularly
obscure, but <code>map(1:3, ~ runif(1))</code> crosses the line for me, as does
<code>map(data, ~ .x * 2)</code>. My example in the previous section, which
included <code>map(~ lm(mpg ~ wt, data = .x))</code>, demonstrates another
problem: It overloads the <code>~</code> operator in a dangerous way. The <code>~</code>
inside the <code>map()</code> is very different from the <code>~</code> in the call to
<code>lm()</code>.</li>
<li>I suspect that my above two points interact. Could it be that
<code>purrr</code> users don’t use a generalised map function because they’ve
written off base R’s anonymous function syntax and replaced it with
a variant that is so terse that their code becomes unreadable
without the names of their functions telling the reader what they’re
doing?</li>
</ul>
<p dir="auto">Overall, I could probably be convinced that <code>purrr</code>’s way is better than
base R’s, but I doubt that <code>purrr</code>’s way is the best way.</p>
<h2 dir="auto"><a id="user-content-56-stringr-and-tibble" aria-hidden="true" href="#56-stringr-and-tibble"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5.6 Stringr and Tibble</h2>
<p dir="auto">For me, these both fall in to the same box. They’re not particularly
outstanding, but they’re clearly much better than their base R
equivalents. I’ve praised <code>tibble</code> enough already and have said plenty
about <a href="#42-strings">the state of R’s strings</a>. The only thing that I’ve
got left to say is that once you’ve noticed that tibbles let you use the
columns that you’ve just defined to define other columns, you really
start to hate how many extra lines of code you have to write when using
data frames for the same task.</p>

<p dir="auto">If I were being generous, I would say that R teaches you some great
lessons about functional programming while being a useful DSL and that
its biggest fault is that it tries to do too much, ultimately becoming
brutally inconsistent. I’d also say that the Tidyverse is a useful set
of packages that, while unable to fix R and certainly not a panacea, do
a lot to improve it within their specific domains. However, I’m not that
generous.</p>
<p dir="auto">The most damning thing about R is that much of <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a> still
holds true. The fact that a nearly decade-old document that credibly
compared R to a journey in to Hell is still a useful reference manual
speaks volumes about the language’s attitude to change. To put it
plainly, <strong>R won’t change</strong>. If something about R frustrates you today,
<strong>it always will</strong>. That’s what kills the language for me. The
popularity of the Tidyverse proves that R is broken and the continuing
validity of the <a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf" rel="nofollow"><em>The R
Inferno</em></a> proves
that it will stay that way. You may be able to put a blanket of sanity
on top of it, as the best packages try to, but you won’t fix it. Unless
you find said packages so useful that they make R worth it, I find it
impossible to argue against jumping ship. My ultimate conclusion on R is
that it’s good, but doomed by the unshifting weight of the countless
little problems that I’ve documented here. Personally, I’m going to give
Python a shot and I wouldn’t blame you for doing the same. Let’s hope
that I don’t end up writing a document of this size complaining about
that.</p>
<p dir="auto">All that being said, I have no intention of uninstalling R or going out
of my way to avoid it. I’d gladly use it professionally and I’ve learned
enough of its semantic semtex to get really damn good at using R to do
in few lines what other languages would do in many. I wasn’t joking when
I said that it’s the best desktop calculator that I’ve ever used. But
would I recommend learning it to anyone else? Absolutely not. We can do
so much better.</p>
</article>
          </div></div>
  </body>
</html>
