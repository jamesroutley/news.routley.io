<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://leanrada.com/notes/css-only-lqip/">Original</a>
    <h1>Minimal CSS-only blurry image placeholders</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>Here’s a CSS technique that produces blurry image placeholders (LQIPs) without cluttering up your markup — <em>Only a single custom property needed!</em></p>

<card-box>
  <code-block language="html">
    <pre><code>&lt;img src=&#34;…&#34; style=&#34;--lqip:192900&#34;&gt;</code></pre>
  </code-block>

  <p>The custom property above gives you this image:</p>

  
  

  <label>
    Try changing the property’s value <strong>(WARNING: FLASHING)</strong>
    
  </label>
  
</card-box>

<p>Granted, it’s a <em>very blurry</em> placeholder especially in contrast to other leading solutions. But the point is that it’s minimal and non-invasive! No need for wrapper elements or attributes with long strings of data, or JavaScript at all.</p>

<box-note>Note for RSS readers / ‘Reader’ mode clients: This post makes heavy use of CSS-based images. Your client may not support it.</box-note>

<h2>Example images</h2>

<lqip-examples>
  <img src="https://leanrada.com/notes/css-only-lqip/gallery/aj-McsNra2VRQQ-unsplash.jpg" loading="lazy" width="300" height="199"/>
  <img src="https://leanrada.com/notes/css-only-lqip/gallery/henry-co-3JFVNo4ukKQ-unsplash.jpg" loading="lazy" width="300" height="200"/>
  <img src="https://leanrada.com/notes/css-only-lqip/gallery/tienko-dima-uYoVf9I6ANI-unsplash.jpg" loading="lazy" width="300" height="196"/>
  
    Toggle images
  
</lqip-examples>

<card-box>
  <a href="https://leanrada.com/notes/css-only-lqip/gallery/" target="_blank">Check out the LQIP gallery for examples!</a>
</card-box>

<h2>Survey of LQIP approaches</h2>

<p>There have been many different techniques to implement LQIPs (low quality image placeholders), such as a very low
  resolution WebP or JPEG (<a href="https://engineering.fb.com/2015/08/06/android/the-technology-behind-preview-photos/" target="_blank">beheaded JPEGs</a> even), optimised SVG shape placements (<a href="https://github.com/axe312ger/sqip" target="_blank">SQIP</a>), and directly applying a discrete cosine
  transform (<a href="https://blurha.sh/" target="_blank">BlurHash</a>). Don’t forget good old progressive JPEGs and interlaced
  PNGs!</p>

<figure>
  <img src="https://leanrada.com/notes/css-only-lqip/solid-colour.png" loading="lazy" alt="image gallery with solid colour placeholders" width="1368" height="832"/>
  <figcaption>Canva and Pinterest use solid colour placeholders.</figcaption>
</figure>

<p>At the other end of the spectrum, we have low tech solutions such as a simple solid fill of the image’s average colour.</p>
  
<p>Pure inline CSS solutions have the advantage rendering immediately — even a <code>background-image: url(…a data URL)</code> would be fine!</p>

<figure>
  <img src="https://leanrada.com/notes/css-only-lqip/gradient-css.png" loading="lazy" alt="image gallery with gradient placeholders" width="1368" height="832"/>
  <figcaption><a href="https://github.com/fraser-hemp/gradify" target="_blank">Gradify</a> generates linear-gradients
    that very roughly approximate the full image.</figcaption>
</figure>

<p>The big disadvantage of pure CSS approaches is that you typically litter your markup with lengthy inline styles or obnoxious data URLs. My handcoded site with no build step would be extra incompatible with this approach!</p>

<code-block language="html">
  <pre><code>&lt;!-- typical gradify css --&gt;
&lt;img width=&#34;200&#34; height=&#34;150&#34; style=&#34;
  background: linear-gradient(45deg, #f4a261, transparent),
    linear-gradient(-45deg, #e76f51, transparent),
    linear-gradient(90deg, #8ab17d, transparent),
    linear-gradient(0deg, #d62828, #023047);
&#34;&gt;
</code></pre>
</code-block>

<p><strong><a href="https://blurha.sh/">BlurHash</a></strong> is a solution that minimises markup by compressing image
  data into a
  <strong>short base-83 string</strong>, but decoding and rendering that data requires additional JS…
</p>

<code-block language="html">
  <pre><code>&lt;!-- a blurhash markup --&gt;
&lt;img width=&#34;200&#34; height=&#34;150&#34; src=&#34;…&#34;
  data-blurhash=&#34;LEHV6nWB2yk8pyo0adR*.7kCMdnj&#34;&gt;</code></pre>
</code-block>

<figure>
  <img src="https://leanrada.com/notes/css-only-lqip/blurhash.png" loading="lazy" width="276" height="171"/>
  <figcaption>BlurHash example</figcaption>
</figure>

<p>Is it possible to decode a blur hash in CSS instead?</p>

<h2>Decoding in pure CSS</h2>

<p>Unlike BlurHash, we can’t use a string encoding because there are very few if any string manipulation
  functions in CSS (2025), so strings are out.</p>

<p>In the end, I came up with my own hash / encoding, and the <b>integer</b> type was the best vessel for it.</p>

<p>The usual way to encode stuff in a single integer is by <a href="https://en.wikipedia.org/wiki/Bit_manipulation" target="_blank"><strong>bit packing</strong></a>, where you pack multiple numbers in an integer as bits. Amazingly, we can unpack them in pure CSS!</p>

<p>To unpack bits, all you need is bit shifting and bit masking. <strong>Bit shifting</strong> can be done by division and floor operations — <code>calc(x / y)</code> and <code>round(down,n)</code> — and <strong>bit masking</strong> via the modulo function <code>mod(a,b)</code>.</p>

<code-block language="css">
  <pre><code>* {
/* Example packed int: */
/* 0b11_00_001_101 */
--packed-int: 781;
--bits-9-10: mod(round(down, calc(var(--packed-int) / 256)), 4); /* 3 */
--bits-7-8: mod(round(down, calc(var(--packed-int) / 64)), 4); /* 0 */
--bits-4-6: mod(round(down, calc(var(--packed-int) / 8)), 8); /* 1 */
--bits-0-3: mod(var(--packed-int), 8); /* 5 */
}</code></pre>
</code-block>

<p>Of course, we could also use <code>pow(2,n)</code> instead of hardcoded powers of two.</p>

<p>So, a <strong>single CSS integer value</strong> was going to be the encoding of the “hash” of my CSS-only blobhash
  (that’s what I’m calling it now). But how much information can we pack in a single CSS int?</p>

<h2>Side quest: Limits of CSS values</h2>

<p>The spec doesn’t say anything about the allowed range for int values, leaving the fate of my shenanigans to browser vendors.</p>

<p>From my experiments, apparently you can only use integers from <strong>-999,999 up to 999,999</strong> in custom
  properties before you lose precision. Just beyond that limit, we start getting values rounded to tens —
  1,234,56<del>7</del> becomes 1,234,56<ins>0</ins>. Which is weird (precision is counted in decimal places!?), but I
  bet it’s due to historical, Internet Explorer-esque reasons.</p>

<p>Anyway, within the range of [-999999, 999999] there are <strong>1,999,999</strong> values. This meant that with a
  single integer hash, almost two million LQIP configurations could be described. To make calculation
  easier, I reduced it to the nearest power of two down which is 2<sup>20</sup>.</p>

<card-box>
  <code>2<sup>20</sup> = 1,048,576 &lt; 1,999,999 &lt; 2,097,152 = 2<sup>21</sup></code>
</card-box>

<p><strong>In short, I had 20 bits of information to encode the CSS-based LQIP hash.</strong></p>

<box-note><strong>Why is it called a “hash”?</strong> Because it’s a mapping from an any-size data to a fixed-size
  value. In this case, there are an infinite number of images of arbitrary sizes, but only 1,999,999 possible hash
  values.</box-note>

<h2>The Scheme</h2>

<p>With only 20 bits, the LQIP image must be a very simplified version of the full image. I ended up with this scheme:
  a single base colour + 6 brightness components, to be overlaid on top of the base colour in a 3×2 grid. A
  rather extreme version of <a href="https://en.wikipedia.org/wiki/Chroma_subsampling" target="_blank">chroma
    subsampling</a>.</p>

<img src="https://leanrada.com/notes/css-only-lqip/scheme.png" loading="lazy" alt="illustration of encoded components" width="600" height="500"/>

<p>This totals <strong>9 numbers</strong> to pack into the 20-bit integer:</p>

<p>The <strong>base colour</strong> is encoded in the <strong>lower 8 bits</strong> in the <a href="https://en.wikipedia.org/wiki/Oklab_color_space" target="_blank">Oklab colour space</a>. 2 bits for luminance, and 3 bits for each of the a and b coordinates. I’ve found Oklab to give subjectively balanced results, but RGB should work just as well.</p>

<p>The <strong>6 greyscale components</strong> are encoded in the <strong>higher 12 bits</strong> — 2 bits each.</p>

<p>An offline script was created to compress any given image into this integer format. The script was quite simple: Get the average
  or dominant colour — there are a lot of libraries that can do that — then resize the image down to
  3×2 pixels and get the greyscale values. <a href="https://github.com/Kalabasa/leanrada.com/blob/7b6739c7c30c66c771fcbc9e1dc8942e628c5024/main/scripts/update/lqip.mjs#L118-L159" target="_blank">Here’s my script.</a></p>

<box-note>I even tried a <a href="https://blog.4dcu.be/programming/2020/01/12/Genetic-Art-Algorithm.html" target="_blank">genetic algorithm</a> to optimise the LQIP bits, but the fitness function was hard to establish. Ultimately, I would’ve needed an offline CSS renderer for this to work accurately. Maybe a future iteration could use some headless Chrome solution to automatically compare real renderings of the LQIP against the source image.</box-note>

<p>Once encoded, it’s set as the value of <code>--lqip</code> via the style attribute in the target element. It could then be decoded in CSS. Here’s the actual code I used for decoding:</p>

<code-block language="css">
<pre><code>[style*=&#34;--lqip:&#34;] {
--lqip-ca: mod(round(down, calc((var(--lqip) + pow(2, 19)) / pow(2, 18))), 4);
--lqip-cb: mod(round(down, calc((var(--lqip) + pow(2, 19)) / pow(2, 16))), 4);
--lqip-cc: mod(round(down, calc((var(--lqip) + pow(2, 19)) / pow(2, 14))), 4);
--lqip-cd: mod(round(down, calc((var(--lqip) + pow(2, 19)) / pow(2, 12))), 4);
--lqip-ce: mod(round(down, calc((var(--lqip) + pow(2, 19)) / pow(2, 10))), 4);
--lqip-cf: mod(round(down, calc((var(--lqip) + pow(2, 19)) / pow(2, 8))), 4);
--lqip-ll: mod(round(down, calc((var(--lqip) + pow(2, 19)) / pow(2, 6))), 4);
--lqip-aaa: mod(round(down, calc((var(--lqip) + pow(2, 19)) / pow(2, 3))), 8);
--lqip-bbb: mod(calc(var(--lqip) + pow(2, 19)), 8);</code></pre>
</code-block>

<p>Before rendering the decoded values, the raw number data values need to be converted to CSS colours. It’s fairly
  straightforward, just a bunch linear interpolations into colour constructor functions.</p>

<code-block language="css">
<pre><code>/* continued */
--lqip-ca-clr: hsl(0 0% calc(var(--lqip-ca) / 3 * 100%));
--lqip-cb-clr: hsl(0 0% calc(var(--lqip-cb) / 3 * 100%));
--lqip-cc-clr: hsl(0 0% calc(var(--lqip-cc) / 3 * 100%));
--lqip-cd-clr: hsl(0 0% calc(var(--lqip-cd) / 3 * 100%));
--lqip-ce-clr: hsl(0 0% calc(var(--lqip-ce) / 3 * 100%));
--lqip-cf-clr: hsl(0 0% calc(var(--lqip-cf) / 3 * 100%));
--lqip-base-clr: oklab(
  calc(var(--lqip-ll) / 3 * 0.6 + 0.2)
  calc(var(--lqip-aaa) / 8 * 0.7 - 0.35)
  calc((var(--lqip-bbb) + 1) / 8 * 0.7 - 0.35)
);
}</code></pre>
</code-block>

<card-box>
  <strong>Time for another demo!</strong>
  <label>
    Try different values of <code>--lqip</code> to decode
    
  </label>
  
  
  

  You can see here how each component variable maps to the LQIP image. E.g. the <code>cb</code> value corresponds to
  the relative brightness of the top middle area. <em>Fun fact: The above preview content is implemented in pure
    CSS!</em>
</card-box>

<h2>Rendering it all</h2>

<p>Finally, rendering the LQIP. I used multiple <strong>radial gradients</strong> to render the greyscale components,
  and a flat base colour at the bottom.</p>

<code-block language="css">
<pre><code>[style*=&#34;--lqip:&#34;] {
background-image:
  radial-gradient(50% 75% at 16.67% 25%, var(--lqip-ca-clr), transparent),
  radial-gradient(50% 75% at 50% 25%, var(--lqip-cb-clr), transparent),
  radial-gradient(50% 75% at 83.33% 25%, var(--lqip-cc-clr), transparent),
  radial-gradient(50% 75% at 16.67% 75%, var(--lqip-cd-clr), transparent),
  radial-gradient(50% 75% at 50% 75%, var(--lqip-ce-clr), transparent),
  radial-gradient(50% 75% at 83.33% 75%, var(--lqip-cf-clr), transparent),
  linear-gradient(0deg, var(--lqip-base-clr), var(--lqip-base-clr));
}</code></pre>
</code-block>

<p>The above is a simplified version of the full renderer for illustrative purposes. <small>The real one has doubled layers, smooth gradient falloffs, and blend modes.</small></p>

<p>As you might expect, the radial gradients are arranged in a 3×2 grid. You can see it in this interactive deconstructor view!</p>

<card-box>
  <strong>LQIP deconstructor!</strong>
  <label>
    Reveal the individual layers using this slider!
    
    Change the <code>--lqip</code> value,
    
  </label>
  
  
  
</card-box>

<p>These radial gradients are the core of the CSS-based LQIP. The position and radius of the gradients are an important detail that would determine how well these can approximate real images. Besides that, another requirement is that these individual radial gradients must be seamless when combined together.</p>

<p>I implemented smooth gradient falloffs to make the final result look seamless. It took special care to make the gradients extra smooth, so let’s dive into it…</p>

<h2>Bilinear interpolation approximation with radial gradients</h2>

<p>Radial gradients use linear interpolation by default. Interpolation refers to how it maps the in-between colours from the start colour to the end colour. And linear interpolation, the most basic interpolation, well…</p>

<figure>
  <interpolation-example></interpolation-example>
  <figcaption>CSS radial-gradients with linear interpolation</figcaption>
</figure>

<p>It doesn’t look good. It gives us these hard edges (highlighted above). You could almost see the elliptical edges of each radial gradient and their centers.</p>

<p>In real raster images, we’d use <a href="https://harmoniccode.blogspot.com/2011/04/bilinear-color-interpolation.html" target="_blank">bilinear interpolation</a> at the very least when scaling up low resolution images. <a href="https://blog.demofox.org/2015/08/15/resizing-images-with-bicubic-interpolation/" target="_blank">Bicubic interpolation is even better.</a></p>

<p>One way to simulate the smoothness of bilinear interpolation in an array of CSS radial-gradients is to use <strong>‘quadratic easing’</strong> to control the gradation of opacity.</p>

<p>This means the opacity falloff of the gradient would be smoother around the center and the edges. Each gradient would get feathered edges, smoothening the overall composite image.</p>

<prose-bleed>
  <fixed-grid>
    <figure>
      <interpolation-example></interpolation-example>
      <figcaption>
        <strong>CSS radial-gradients:</strong>
        Quadratic interpolation <em>(touch to see edges)</em>
      </figcaption>
    </figure>
    <figure>
      <interpolation-example></interpolation-example>
      <figcaption>
        <strong>CSS radial-gradients:</strong>
        Linear interpolation <em>(touch to see edges)</em>
      </figcaption>
    </figure>
    <figure>
      <img loading="lazy" src="https://leanrada.com/notes/css-only-lqip/interpolation-bilinear.png" width="900" height="600"/>
      <figcaption>Image: Bilinear interpolation</figcaption>
    </figure>
    <figure>
      <img loading="lazy" src="https://leanrada.com/notes/css-only-lqip/interpolation-bicubic.png" width="900" height="600"/>
      <figcaption>Image: Bicubic interpolation</figcaption>
    </figure>
    <figure>
      <img loading="lazy" src="https://leanrada.com/notes/css-only-lqip/interpolation-pixels.png" width="3" height="2"/>
      <figcaption>Image: Your browser’s native interpolation</figcaption>
    </figure>
    <figure>
      <img loading="lazy" src="https://leanrada.com/notes/css-only-lqip/interpolation-pixels.png" width="3" height="2"/>
      <figcaption>Image: No interpolation</figcaption>
    </figure>
  
</fixed-grid></prose-bleed>



<p>However, CSS gradients <a href="https://github.com/w3c/csswg-drafts/issues/1332" target="_blank">don’t support nonlinear interpolation of opacity yet as of writing</a> (not to be confused with colour space interpolation, which browsers do support!). The solution for now is to add more points in the gradient to get a smooth opacity curve based on the quadratic formula.</p>

<code-block language="css"><pre><code>radial-gradient(
  &lt;position&gt;,
  rgb(82 190 240 / 100%) 0%,
  rgb(82 190 204 / 98%) 10%,
  rgb(82 190 204 / 92%) 20%,
  rgb(82 190 204 / 82%) 30%,
  rgb(82 190 204 / 68%) 40%,
  rgb(82 190 204 / 32%) 60%,
  rgb(82 190 204 / 18%) 70%,
  rgb(82 190 204 / 8%) 80%,
  rgb(82 190 204 / 2%) 90%,
  transparent 100%
)</code></pre></code-block>

<figure>
  <img src="https://leanrada.com/notes/css-only-lqip/interpolation-graph.png" loading="lazy" width="1024" height="768"/>
  <figcaption>The quadratic interpolation is based on two quadratic curves (parabolas), one for each half of the gradient — one upward and another downward.</figcaption>
</figure>

<p>The quadratic easing blends adjacent radial gradients together, mimicking the smooth bilinear (or even bicubic) interpolation. It’s almost like a fake blur filter, thus achieving the ‘blur’ part of this BlurHash alternative.</p>

<card-box>
  <a href="https://leanrada.com/notes/css-only-lqip/gallery/">Check out the gallery for a direct comparison to BlurHash.</a>
</card-box>

<lqip-examples>
  <img loading="lazy" src="https://leanrada.com/notes/css-only-lqip/gallery/karsten-winegeart-613pTZEFf2U-unsplash.jpg" width="300" height="208"/>
  <img loading="lazy" src="https://leanrada.com/notes/css-only-lqip/gallery/fahrul-azmi-Q1l1ofdVYl4-unsplash.jpg" width="225" height="300"/>
  <img loading="lazy" src="https://leanrada.com/notes/css-only-lqip/gallery/esma-melike-sezer-9NRRCTGKYS4-unsplash.jpg" width="191" height="300"/>
  <img loading="lazy" src="https://leanrada.com/notes/css-only-lqip/gallery/daniel-b-herrmann-squbLwpQRQ8-unsplash.jpg" width="240" height="300"/>
  
    Toggle images
  
</lqip-examples>

<h2>Appendix: Alternatives considered</h2>

<h3>Four colours instead of monochromatic preview</h3>

<p>Four 5-bit colours, where each <b>R</b> is 2 bits, <b>G</b> is 2 bits, and <b>B</b> is just a zero or one.</p>

<p>The four colours would map to the four corners of the image box, rendered as radial gradients</p>

<p>This was my first attempt, and I fiddled with this for a while, but mixing four colours properly require proper bilinear interpolation and probably a shader. Just layering gradients resulted in muddiness (just like mixing too many watercolour pigments), and there was no CSS blend mode that could fix it. So I abandoned it, and moved on to a monochromatic approach.</p>

<h3>Single solid colour</h3>

<p>This was what I used on this website before. It’s simple and effective. A clean-markup approach could still use the custom <code>--lqip</code> variable:</p>

<code-block language="html">
  <pre><code>&lt;img src=&#34;…&#34; style=&#34;--lqip:#9bc28e&#34;&gt;

&lt;style&gt;
/* we save some bytes by ‘aliasing’ this property */
* { background-color: var(--lqip) }
&lt;/style&gt;</code></pre>
</code-block>

<h3>HTML attribute instead of CSS custom property</h3>

<p>We can use HTML attributes to control CSS soon! Here’s what the LQIP markup would look like in the future:</p>

<code-block language="html">
  <pre><code>&lt;img src=&#34;…&#34; lqip=&#34;192900&#34;&gt;</code></pre>
</code-block>

<p>Waiting for <a href="https://developer.chrome.com/blog/advanced-attr" target="_blank"><code>attr()</code> Level 5</a> for this one. It’s nicer and shorter, fewer weird punctuations in markup <small>(who came up with the double dash for CSS vars anyway?)</small>. The value can then be referenced in CSS with <code>attr(lqip type(&lt;number&gt;))</code> instead of <code>var(--lqip)</code>.</p>

<p>For extra safety, a <code>data-</code> prefix could be added to the attribute name.</p>

<p>Can’t wait for this to get widespread adoption. I also want it for my <a href="https://jordanbrennan.hashnode.dev/tac-a-new-css-methodology" target="_blank">TAC components</a>.</p>

</div></div>
  </body>
</html>
