<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://typesanitizer.com/blog/errors.html">Original</a>
    <h1>An epic treatise on error models for systems programming languages</h1>
    
    <div id="readability-page-1" class="page"><article>
          <section>
	          
<p><strong>Target audience</strong>: Practitioners interested in programming language design
and familiar with representations of errors in at least a few different languages
such as error codes, checked/unchecked exceptions, tagged unions,
polymorphic variants etc.</p>
<p><strong>Estimated reading time</strong>: 60 to 90 mins.</p>
<p>In research papers on programming languages,
there is often a focus on sophisticated
type system features to rule out certain classes of errors,
whereas <em>error handling itself</em> receives
relatively little attention, despite its importance.<span><label for="sn-0"></label><span>This doesn’t seem too dissimilar to problems in the database community/literature, where less “cool” topics like better representation for strings receive relatively little attention compared to their importance. See also: <a href="http://databasearchitects.blogspot.com/2024/12/what-are-important-data-systems.html">What are important data systems problems, ignored by research?</a> and DuckDB creator Hannes Mühleisen’s <a href="https://www.youtube.com/watch?v=dv4A2LIFG80">CIDR 2023 keynote</a> on Developing Systems in Academia for related discussion.</span></span>
For example, in
<a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf">Simple testing can prevent most critical failures [PDF]</a><span><label for="sn-1"></label><span>Readers in a rush can skim sections 1 and 2 and read the ‘Findings’ in bold in section 4.</span></span> , Yuan et al.
found that in the context of distributed data-intensive systems:</p>
<ul>
<li><p>“Almost all catastrophic failures (92%) are the result of
incorrect handling of non-fatal errors explicitly signaled in software”
(Finding 10, p256)</p>
<ul>
<li>Out of these “35% [..] are caused by trivial mistakes in error
handling logic — ones that simply violate best programming practices;
and that can be detected without system specific knowledge.”
(Finding 11, p256)</li>
</ul></li>
</ul>
<p>In contrast, there is some excellent long-form writing on error models out
there by practitioners.</p>
<ul>
<li>Joe Duffy’s blog post on <a href="https://joeduffyblog.com/2016/02/07/the-error-model">the error model in Midori</a>:
This describes a variant of C# used to write a microkernel, drivers,
and a large amount of user code. Duffy describes a two-pronged error
model – “abandonment” (fail-fast error handling)
and a variation on checked exceptions (utilizing class hierarchies).</li>
<li><a href="https://github.com/swiftlang/swift/blob/main/docs/ErrorHandlingRationale.md">The design doc for Swift’s error model</a>: This discusses the pros and cons of error models in several
different languages.</li>
<li>The TigerBeetle docs on <a href="https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/TIGER_STYLE.md#safety">“Tiger Style”</a>:
This describes how the TigerBeetle database tries to ensure various
forms of safety. The discussion on assertions in the Safety section
is particularly worth reading.</li>
<li><a href="https://rust-lang.github.io/rfcs/0236-error-conventions.html">Rust RFC 236 - Error conventions</a>:
This describes conventions for how Rust libraries
should use different error handling mechanisms
in different situations.</li>
<li>Joe Armstrong’s talk <a href="https://youtu.be/TTM_b7EJg5E?si=J321vwBsKhKwgy1s&amp;t=1293">The Do’s and Don’ts of Error Handling</a>:
Armstrong covers the key requirements for handling and recovering
from errors in distributed systems, based on his
<a href="https://erlang.org/download/armstrong_thesis_2003.pdf">PhD thesis from 2003</a> (PDF).<span><label for="sn-2"></label><span>By this point in time, Armstrong was about 52 years old, and had 10+ years of experience working on Erlang at Ericsson.</span></span></li>
</ul>
<p>Out of the above, Armstrong’s thesis is probably the most holistic,
but it’s grounding in Erlang means that it also does not take into
account one of the most widespread forms of static analysis we have today
– type systems. Here’s an excerpt from page 209:</p>
<blockquote>
<p>We can impose a type system on our programming language,
or we can impose a contract checking mechanism between any
two components in a message passing system. Of these two methods I
prefer the use of a contract checker</p>
</blockquote>
<p>In this post, I want to approach error models in a way that is both
<em>holistic</em> and <em>geared towards ecosystems of systems PLs</em>.</p>
<p>By <em>holistic</em>, I mean that I will approach error models from several different perspectives:</p>
<ul>
<li>From a “product” perspective: What are the core assumptions,
what are all the requirements and how are they informed by practical use cases.</li>
<li>From a type systems perspective: How can the type system assist
the programmer to accomplish what they want.</li>
<li>From a language design perspective: How API design guidelines,
conventions and tooling can be combined with type system features
to enable people to write more robust applications.</li>
</ul>
<p>By <em>geared towards ecosystems of systems PLs</em>,<span><label for="sn-3"></label><span>The term “systems programming language” inevitably seems to trigger people into rehashing the same “arguments” in comment sections – many people seem to like using it as a term for excluding other languages because they use reference counting or tracing GC as the default memory management strategy. I’m picking a definition here for the sake of this post. If you dislike this definition, you can either mentally replace all usages of “systems PL” with “language with XYZ memory management strategy” or you can stop reading the post.</span></span> I mean that the error
model must take into account the following needs:</p>
<ul>
<li>Graceful degradation in the presence of errors,
because the underlying platform and/or acceptance criteria
may offer limited recovery capabilities.</li>
<li>Optimizability – either by the compiler, the programmer or both
– as performance bottlenecks arise <em>within</em> the system
rather than from external sources.
This may involve trading off flexibility in error handling
for performance.</li>
<li>Facilitation of interoperability between and co-evolution of
libraries and applications.</li>
</ul>
<p>Some examples of such software include databases,
high-performance web servers, and interpreters.
I will be ignoring use cases
such as small-scale scripting for one-off tasks,
interactive data exploration etc.
I will also be ignoring ABI considerations, because
those can largely be resolved
by varying levels of indirection
in the run-time representation (e.g. see Swift).</p>
<p>The structure of this <del>thesis</del> blog post is as follows:</p>
<ul>
<li><a href="#section-1-key-definitions">Section 1</a> discusses definitions for important terms such as ‘error’,
‘error model’ etc.</li>
<li><a href="#section-2-key-theses">Section 2</a> goes over the primary theses about errors and how people reason
about them, along with examples.</li>
<li><a href="#section-3-key-criteria-for-an-error-model">Section 3</a> covers the key requirements for an error model,
and how these are justified based on the theses in Section 2.</li>
<li><a href="#section-4-an-immodest-proposal">Section 4</a> describes a hypothetical programming language Everr
and its error model.<span><label for="sn-4"></label><span>The reason for introducing a fake language
for the sake of discussion, instead of say proposing extensions
to an existing language, is that it offers a clean slate for combining
ideas across different existing languages without having to
worry about things like compatibility with existing
language features and/or idioms.</span></span></li>
<li><a href="#section-5-error-models-in-the-wild">Section 5</a> describes the error models of various existing
and upcoming programming languages.</li>
<li><a href="#section-6-everr-vs-the-world">Section 6</a> compares Everr with other languages based on the
requirements laid out in Section 3.</li>
<li><a href="#section-7-closing-thoughts">Section 7</a> concludes with some questions for you, an unorthodox choice
to introduce two new terms, a potpourri of metaphors, and some fluffy exhortations.</li>
</ul>
<p>For the die-hard <del>fans</del> readers, there is also an <a href="#appendix">Appendix</a> with 7 sections.</p>
<p>To this end, this post is fairly large, clocking in at 15K+ words
at the time of writing. You have been warned.</p>
<p>Still here? Let’s get started.</p>
<h2 id="section-1-key-definitions">Section 1: Key definitions</h2>
<p>For the sake of this post, I’m going to use the following definitions:</p>
<p><strong>Error</strong>: I’ll use this term in two ways:</p>
<ul>
<li>A program state that is undesirable or non-ideal in some way.</li>
<li>A value reifying an undesirable program state into something
that can be operated upon by the language’s constructs.
For example, errors may be represented as error codes (in C),
exceptions (in Java), <code>error</code> values (in Go), a <code>Result::Err</code> case
(in Rust) and so on. This value may or may not have some
<strong>metadata</strong> attached, such as a stack trace or some indicator
of progress made before hitting the error.</li>
</ul>
<p><strong>Error propagation</strong>: The act of passing an error received from
a function that was called to one’s own caller. During error propagation
one might want to attach more metadata, release some resources etc.</p>
<p><strong>Error handling</strong>: The act of inspecting an error value
and/or its metadata, and making some decision based on that.
For example, one might decide to log the error, propagate it,
discard it, or convert it to a different form.</p>
<p><strong>Error model</strong>: The overall system for representing, creating,
propagating, and handling errors in a programming language,
including best practices and common idioms.</p>
<p>In common parlance, this is just called “error handling”,
but it’s always felt a bit weird to me that seemingly very
different actions like declaring, propagating and inspecting
errors would get lumped together under “handling”. So I’m
borrowing this term from Duffy’s blog post instead.</p>
<p><strong>Exhaustive</strong>: An error (type) is said to be exhaustive when all
the possible data for that error is known up-front.
For example, conversion from an <code>Int64</code> value to a <code>UInt32</code>
value will only fail in a couple of ways: either the
value is negative, or it exceeds <code>2<sup>32</sup> - 1</code>.
Thus, such a conversion operation supports recording
an exhaustive error in case of failure.
In contrast, errors types from external systems,
such as third-party APIs, are typically non-exhaustive.</p>
<p>Exhaustiveness has two axes: fields and cases.<span><label for="sn-5"></label><span>I’m deliberately avoiding a discussion on records vs variants (or structs vs enums/tagged unions, or classes vs case classes) here; more on that in later sections.</span></span></p>
<hr/>
<p>Hopefully, none of the above are too controversial.
Let’s keep moving.</p>
<h2 id="section-2-key-theses">Section 2: Key theses</h2>
<p>The rest of this post is going to be based on a few key theses:</p>
<ol type="1">
<li>Whether a program state is an error or not is contextual.</li>
<li>Whether an error can be recovered from or not is sometimes contextual.</li>
<li>Errors need to be able to carry metadata.</li>
<li>Robust error handling sometimes requires detailed understanding of possible error cases.</li>
<li>Errors and metadata in unstructured form are difficult to handle reliably.</li>
<li>Programs typically need to handle both exhaustive and non-exhaustive errors.</li>
<li>Programmers mostly operate with incomplete knowledge about errors.</li>
</ol>
<p>Let’s dig in to each of these one-by-one.</p>
<h3 id="thesis-1-whether-a-program-state-is-an-error-or-not-is-contextual">Thesis 1: Whether a program state is an error or not is contextual</h3>
<p>Let’s consider the classic example of opening a file.
You have some code trying to open a file and that file is not found.
Is that an error? Well, it depends!</p>
<p>For example, say you are writing a CLI application
that is doing a recursive lookup for a configuration file in ancestor
directories from the working directory.</p>
<p>Instead of first checking if the file exists
(e.g. using <a href="https://man7.org/linux/man-pages/man2/stat.2.html"><code>stat(2)</code></a> on Linux)
and then opening the file,
you write your code to open the file directly.<span><label for="sn-6"></label><span>You do this because the existence check + open strategy can still fail at the open stage with a ‘File not found’ error if some other process deleted the file in the middle of your operations.</span></span>
However, in this case, the file opening operation not succeeding
with a ‘File not found’ is not undesirable or incorrect in some way,
i.e., it is not an error, but it is part of normal operation.</p>
<p>Now consider the situation where the path to the
configuration file is obtained via a command-line argument.
In this case, if you get a ‘File not found’ error when opening the file,
it’s likely that the user made a mistake when providing
the command-line argument, so it would make sense to surface
the ‘File not found’ to the user.</p>
<h3 id="thesis-2-whether-an-error-can-be-recovered-from-or-not-is-sometimes-contextual">Thesis 2: Whether an error can be recovered from or not is sometimes contextual</h3>
<p>Some common examples of programming bugs that are often considered
as non-recoverable in the context of application languages
are out-of-bounds array accesses, unwrapping optionals
(or nil/null dereference) and out-of-memory – these are all
listed in the Swift docs and Joe Duffy’s blog post as examples.</p>
<p>Rust RFC 236 categorizes errors into three distinct types:
catastrophic errors, contract violations and obstructions.
Out of these, out-of-memory is considered as a catastrophic error,
whereas index out of bounds is considered a contract violation.<span><label for="sn-7"></label><span>Yes, I understand that this is a conventions RFC and that individual libraries may deviate from the conventions if they have a different set of needs. However, conventions strongly affect the design of language features and standard library APIs, so I think it’s worth discussing this here as well.</span></span>
For both of these, the RFC states that
“The basic principle of the conventions is that:
Catastrophic errors and programming errors (bugs) can and should only
be recovered at a coarse grain, i.e. a task boundary.”</p>
<p>I think it’s important to recognize that even for these errors,
the recoverability is contextual.
For example, in video game code, if there is an off-by-one error
in some rare cases in collision detection or lighting,
it’s possible that the game still works mostly fine,
and that’s good enough.</p>
<p>For out-of-memory in a web server, you may want to limit
the amount of memory a single task can consume,
to prevent the whole server from being terminated
when the server process runs out of memory.</p>
<p>Even if you don’t have per-request limits,
it’s possible that you breach the process-wide memory limit
<em>outside</em> of the context of a particular
task handling some request or background work.
If the server has the opportunity to recover from this,
it might be OK to shed load by
terminating the tasks for a few requests
(e.g. if they don’t use global state,
or only use it in a limited way that allows cleanup)
instead of terminating the entire process.</p>
<p>To be clear, I’m not saying that such examples represent
the majority of cases.
However, my point is that even for cases which <em>seem</em>
relatively cut-and-dry, there are situations where
the classification of an error into recoverable/non-recoverable
is not clear cut.</p>
<h3 id="thesis-3-errors-need-to-be-able-to-carry-metadata">Thesis 3: Errors need to be able to carry metadata</h3>
<p>Once code grows beyond a certain scale, understanding errors requires
collecting metadata about where/what/when/how/why. For example,
in a web server, you might care about tracking the following:</p>
<ul>
<li>A stack trace for the place where the error was originally created.</li>
<li>Severity of the error.</li>
<li>For data validation errors such as in validating JSON,
some ‘path’ within the larger structure
(at the time of the error),
as well as the value of the unexpected portion.</li>
<li>Retryability of operations, such as DB transactions or
<a href="https://grpc.io/docs/guides/retry/">RPC calls</a> in a framework like gRPC.</li>
</ul>
<p>Additionally, one needs to be able to have some logic
that can make use of this metadata (e.g. as methods on an error type,
if the language supports methods in some form),
such as something for generating key-value pairs for observability,
computing equality/hashes for checking sameness etc.</p>
<p><strong>Corollary</strong>: Error codes as the primary language-supported way
of error handling are inadequate for many use cases
(see also: <a href="https://github.com/ziglang/zig/issues/2647">Zig issue #2647 - Allow returning a value with an error</a>).</p>
<h3 id="thesis-4-robust-error-handling-sometimes-requires-detailed-understanding-of-possible-error-cases">Thesis 4: Robust error handling sometimes requires detailed understanding of possible error cases</h3>
<p>In <a href="https://dataintensive.net/"><em>Designing Data-Intensive Applications</em></a>, Martin Kleppman gives an excellent example of database transactions and retryability:</p>
<blockquote>
<p>popular object-relational-mapping (ORM) frameworks [..] don’t retry aborted transactions [..]. This is a shame, because the whole point of aborts is to enable safe retries.</p>
<p>Although retrying an aborted transaction is a simple and effective error handling mechanism, it isn’t perfect:</p>
<ul>
<li>If the transaction actually succeeded, but the network failed while the server tried to acknowledge the successful commit to the client [..], then retrying the transaction [is unsound without extra app-level de-duplication]</li>
<li>If the error is due to overload, retrying the transaction will make the problem worse [..]</li>
<li>It is only worth retrying after transient errors ([..] deadlock, isolation violation, temporary network interruptions, and failover); after a permanent error (e.g. constraint violation) a retry would be pointless</li>
</ul>
</blockquote>
<p>For a library or framework which provides APIs for interacting with a SQL database,
it is necessary to be able to distinguish the various cases of network errors and database errors
if it wants to support automatic retries for aborted transactions.</p>
<p>Of course, not all error handling needs this level of rigor in analyzing the various cases.
Depending on the context,
it might be OK to just log an error and keep going
if one is confident that
it won’t negatively impact the overall system.</p>
<p><strong>Corollary</strong>: An API specification language should probably
discourage hiding error information from return values
(see also: GraphQL’s <a href="https://graphql.org/learn/response/#request-errors">default machinery for error handling</a>).</p>
<h3 id="thesis-5-errors-and-metadata-in-unstructured-form-are-difficult-to-handle-reliably">Thesis 5: Errors and metadata in unstructured form are difficult to handle reliably</h3>
<p><img src="https://i.imgflip.com/9m5w3n.jpg" alt="Anakin and Padme meme. Anakin: I like using domain-specific types for return values. Padme: (smiling) For both success and failure, right? Anakin gives a blank stare. Padme (concerned): For both succcess and failure, right?"/></p>
<p>I imagine this point is probably the least controversial.</p>
<p>Stuffing error case information and metadata into strings
makes an API harder to use for a client which cares about
error handling.</p>
<p>If you expose an API where the only way a conscentious user
can extract more data for an error is by parsing a string,
they’re going to write that error parser,
and all the options when you want to
change that error message are going to suck.
(see also: <a href="https://www.hyrumslaw.com/">Hyrum’s Law</a>).</p>
<p><strong>Corollary</strong>: A standard library should probably not encourage
people to easily attach arbitrary data to errors in a way that
cannot be recovered later (see also: Go’s <a href="https://pkg.go.dev/fmt#Errorf"><code>fmt.Errorf</code></a>
function which implicitly encourages users to create unstructured errors**.</p>
<h3 id="thesis-6-programs-typically-need-to-manage-both-exhaustive-and-non-exhaustive-errors">Thesis 6: Programs typically need to manage both exhaustive and non-exhaustive errors</h3>
<p>When a part of a program does not interact with any external systems,
but behaves like a pure function with a
well-understood set of possible behaviors,
using exhaustive error types allows one to model this certainty.</p>
<p>On the other hand, when interacting with external systems which
may change in the future, such as third-party APIs across a network,
OS APIs, databases etc., the program needs a way to model
and handle errors where all the cases and fields are not known up front.
In such situations, ideally, the addition of new error cases and/or fields
should not break existing third-party clients at a source level,
and lead to some reasonable dynamic behavior.</p>
<h3 id="thesis-7-programmers-mostly-operate-with-incomplete-knowledge-about-errors">Thesis 7: Programmers mostly operate with incomplete knowledge about errors</h3>
<p>Outside of safety critical contexts,
I think it’s fair to say that for most production systems,
most people working on them (myself included) have a fairly limited
picture of all the different things that could go wrong.</p>
<p>I suspect this is probably true even if one limits the scope
to just the situations where the underlying APIs are written
by oneself and just involve pure (but complex) computation,
as well as situations where all the inputs and system parameters
are within “acceptable” ranges.</p>
<p>To be clear, I mean this as an observation and not as a value judgement
– I think there are various contributing reasons for this;
competing priorities, high system complexity, poor docs,
minimal language/tooling support and perhaps even optimism.<span><label for="sn-8"></label><span>For more discussion on optimism specifically, see <a href="#appendix-a7-optimism">Appendix A7</a>.</span></span>
Discussing this more would probably take a full blog post or more by itself,
so I’m going to stop there.</p>
<h2 id="section-3-key-criteria-for-an-error-model">Section 3: Key criteria for an error model</h2>
<p>Based on the above theses and my personal experience, I believe
that an error model should be judged based on how well it
satisfies the following key criteria.<span><label for="sn-9"></label><span>If these sound a bit too abstract, I’ll be discussing them in more detail shortly.</span></span></p>
<ul>
<li><p>Error declarations must support:</p>
<ul>
<li><p><strong>Exhaustiveness annotation</strong>: The ability to mark a declaration
as being exhaustive (or not). This must support both axes: fields and cases.</p></li>
<li><p><strong>Case extension</strong>: The ability to extend errors with new cases
(at the declaration site itself) in a backward-compatible way,
if the error was declared to be non-exhaustive in terms of cases.</p></li>
<li><p><strong>Field extension</strong>: Analogous to the above but for fields.</p></li>
<li><p><strong>Case refinement</strong>: The ability to refine previously defined cases
into more fine-grained cases over time
(at the declaration site itself) in a backward-compatible way.</p></li>
</ul></li>
<li><p>Error propagation must support:</p>
<ul>
<li><p><strong>Explicit marking</strong>: The ability<span><label for="sn-10"></label><span>The choice of the word “ability” is intentional. Using an explicit marking discipline may or may not be the default, and may or may not be conventional, but following it must be possible.</span></span> to force code to be written
in a way such that:</p>
<ol type="1">
<li>Possible errors from primitive operations are indicated with explicit marks.</li>
<li>Propagating errors from an invoked operation to one’s own caller requires
an explicit mark.</li>
</ol>
<p>The absence of explicit marks must cause a localized static error.</p></li>
<li><p><strong>Structured metadata attachment</strong>: The ability to attach structured metadata
to an error. Attaching metadata must preserve the fact that the error
is still an error.</p></li>
<li><p><strong>Error combination</strong>: The ability to combine errors into a larger error.</p></li>
<li><p><strong>Erasure</strong>: The ability to abstract fine-grained errors into more
coarse-grained errors.</p></li>
</ul></li>
<li><p>Error handling must support:</p>
<ul>
<li><p><strong>Exhaustiveness checking</strong>:<span><label for="sn-11"></label><span>This needs to correctly account for access control rules. For example, in Rust, the <a href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> attribute has no effect within the same crate.</span></span> For errors declared to be exhaustive,
the ability to match exhaustively against all cases.</p>
<p>Non-exhaustive matches for exhaustive errors must be diagnosed statically.</p>
<p>Additionally, for non-exhaustive errors, attempting an exhaustive match
against the known cases must be diagnosed statically.</p></li>
<li><p><strong>Structured metadata extraction</strong>: The ability to extract structured metadata
attached to an error (the dual of Structured metadata attachment).</p></li>
<li><p><strong>Error projection</strong>: The ability to inspect individual sub-errors out of a combined error (the dual of Error combination).</p></li>
<li><p><strong>Unerasure</strong>: The ability to unerase fine-grained information out of coarse-grained errors (the dual of Erasure).</p></li>
</ul></li>
</ul>
<ul>
<li><p>Criteria for error conventions:</p>
<ul>
<li><p><strong>Error category definitions</strong>: Different categories of errors
must be documented, so that the ecosystem can rely on centralized definitions.
These must be accompanied by examples of
when an error should be put in a certain category,
and when it may be considered as part of another category.</p></li>
<li><p><strong>Guidelines on error definitions</strong>: These should cover what ought to be
documented, which annotations should be considered and/or avoided,
as well as considerations for downstream users of libraries.</p></li>
<li><p><strong>Guidelines on error propagation</strong>: These should cover when it is appropriate
to return errors that are erased vs unerased.</p></li>
<li><p><strong>Guidelines on error handling</strong>: These should cover when it is and
is not appropriate to handle errors within and across library boundaries.</p></li>
</ul>
<p>Guidelines should generally be accompanied by rationale, as well as curated lists
of potential reasons to deviate from the guidelines.</p></li>
<li><p>Criteria for tooling:</p>
<ul>
<li><p><strong>Lint support</strong>: Certain classes of errors are likely best avoided through
lints/style checkers, rather than type system features.</p>
<ol type="1">
<li><p>(Important) A lint that prevents error values from being discarded using
standard shorthands (e.g. <code>_ = &lt;expr&gt;</code>), without an explicit annotation,
such as a comment or a call to an earmarked function
(to allow for ‘Find references’) etc.</p></li>
<li><p>(Nice-to-have) If exhaustiveness of cases/fields is the default at the
language level, then a lint to require manual exhaustiveness annotations
on every type.</p></li>
<li><p>(Nice-to-have) A lint for enforcing that fields and cases of error types
must be documented.</p></li>
</ol></li>
<li><p><strong>Editing support</strong>:</p>
<ol type="1">
<li>(Important) A structured flow for adding new error cases and fields.
The editing environment should identify locations which potentially
need changes – these will generally be locations which materialize
or handle errors of the same type.</li>
</ol></li>
</ul></li>
</ul>
<p>For each of these criteria, the following sub-sections
describe why they are useful.</p>
<h3 id="criteria-for-error-declarations">Criteria for error declarations</h3>
<p>Exhaustiveness annotation is necessary because of <a href="#thesis-6-programs-typically-need-to-manage-both-exhaustive-and-non-exhaustive-errors">Thesis 6</a> -
typical programs need to work with both exhaustive and non-exhaustive errors.
This should probably take the form of an <em>annotation</em> or similar, rather than two
entirely different type system features (e.g. subclasses for the non-exhaustive case
vs standard sum types for the exhaustive case), because:</p>
<ol type="1">
<li>It is possible for a non-exhaustive error to become exhaustive (if the underlying API stops evolving)</li>
<li>The small “conceptual diff” would probably be best reflected as a small syntax diff in code, rather than an entirely different way of organizing the program.</li>
</ol>
<p>Once one accepts that non-exhaustive errors are permitted,
for such errors to be usable across project boundaries,
it naturally follows that the language must support
adding new cases and fields to a non-exhaustive error type
without breaking source-level backward compatibility.</p>
<p>Lastly, when an API developer gains more knowledge<span><label for="sn-12"></label><span>Recall <a href="#thesis-7-programmers-mostly-operate-with-incomplete-knowledge-about-errors">Thesis 7</a> - Programmers mostly operate with incomplete knowledge about errors.</span></span> about a previously
broad error case, they need a way of communicating that to new clients without breaking
existing clients. This requires some way of expressing “this one case is now actually N other cases, where N &gt;= 2”
which is exactly how I described case refinement.</p>
<h3 id="criteria-for-error-propagation">Criteria for error propagation</h3>
<p>The ability to force code to be written using explicit marks for error
handling is valuable because it enables modular reasoning about control
flow and error handling, one function at a time.</p>
<p>Even if a programmer is able to magically keep track of which functions
can silently return which errors in their head,
they may stop working on the codebase,
and the next programmer working on the code
will need assistance in gradually assembling
a <a href="https://ingenieria-de-software-i.github.io/assets/bibliografia/programming-as-theory-building.pdf">new theory of the codebase</a>
they’ve inherited.</p>
<p>The ability to attach structured metadata is valuable because not all
errors can be described by simple primitive values,
and often, it is necessary to have contextual information
in order to debug why an error occurred
(e.g. where in the JSON file is there a missing <code>,</code> again, goddammit).</p>
<p>The ability to combine errors is valuable in the same way
that collections like arrays, sets and maps are valuable.</p>
<p>The ability to erase errors is valuable since not all code cares about
the details of an error. For example, code inside a supervisor task/process
might potentially only care about how to log an error.</p>
<h3 id="criteria-for-error-handling">Criteria for error handling</h3>
<p>Exhaustiveness checking is valuable because it provides clarity
that all cases have been handled. However, in some cases,
it is impossible to have that clarity, since:</p>
<ul>
<li>One might not have sufficient time to understand and analyze
all the cases.</li>
<li>If the error comes from a dependency:
<ul>
<li>One might be unable to change the code in the dependency</li>
<li>One might be unable to replace the dependency</li>
<li>One might not want to (or potentially, cannot)
lock to a certain version of the dependency.</li>
</ul></li>
</ul>
<p>This means that non-exhaustive errors must also get proper
treatment during exhaustiveness checking.</p>
<p>Features like structured metadata extraction,
error projection, and recovery are needed because
their corresponding duals only make sense when used
in concert with them.</p>
<hr/>
<p>Now that we’ve covered a fair bit of ground related to error models themselves,
let’s switch gears and talk about what a language design
grounded in these observations could look like.</p>
<h2 id="section-4-an-immodest-proposal">Section 4: An immodest proposal</h2>
<p>I’m going to describe an error model in terms of a hypothetical
systems language Everr (“<strong>Ev</strong>olving <strong>err</strong>ors”)
and its ecosystem.
I’ll demonstrate Everr using examples.<span><label for="sn-13"></label><span>Normally, I’d hope that this is understood, but since this is the internet, I’m going to spell this out explicitly; the concrete syntax being used here is not the point. This is a language I literally just made up to illustrate some concepts.</span></span>
After that, we’ll see how well Everr’s error model compares
to existing mainstream languages with respect to the criteria
outlined in the previous section.</p>
<p>Here’s a rough summary of Everr’s core language constructs:</p>
<ul>
<li>Everr supports semantic attributes on declarations, similar to C++, Rust, Swift etc.</li>
<li>Everr supports structs (a.k.a. records / product types) and enums (a.k.a. variants / sum types).
These can be exhaustive or non-exhaustive.
<ul>
<li>Enums are second-class, like <a href="https://capnproto.org/language.html">Cap’n Proto</a>’s (tagged) union types.
However, they support dedicated sugar making them feel essentially first-class.</li>
</ul></li>
<li>Everr supports style pattern matching using a minor variation of
Cheng and Parreaux’s <a href="https://dl.acm.org/doi/10.1145/3689746">“Ultimate Conditional Syntax”</a>.</li>
<li>Everr has simple namespaces for grouping things,
similar to namespaces in C++ and modules in Rust.
Types themselves are not namespaces.<span><label for="sn-14"></label><span>This is largely for simplifying the description here. If types were allowed to function as namespaces, (or alternately, if namespaces were allowed to have type parameters), that would necessitate different syntax for referring to “outer” generic parameters vs introducing fresh generic parameters, and we’d end up going into the weeds.</span></span></li>
<li>Everr supports union types,<span><label for="sn-15"></label><span>When I say “union types”, I mean it in the type-theoretic sense, not in the sense of untagged unions as in C, C++ etc.</span></span> but only with a mandatory upper bound.
For brevity, I’ll refer to these as “bounded union types”.
Bounded union types come in two flavors – exhaustive and non-exhaustive.</li>
<li>Everr supports a Rust-like trait mechanism as well as a trait deriving mechanism.<span><label for="sn-16"></label><span>The exact mechanism powering trait derivations – whether they be hard-coded in the compiler, be implemented as macros, compiler plugins etc. – is not terribly important for this post, so I will ignore it.</span></span></li>
<li>Everr supports a delegation mechanism for field accesses
and method calls from one type to another.</li>
</ul>
<p>First, let’s do a tour of these core language features.
After that, I’ll describe Everr’s error model.</p>
<h3 id="a-tour-of-everr">A tour of Everr</h3>
<p>Everr has an <code>Optional</code> type for representing optional values:</p>
<pre><code>@exhaustive
enum Optional[A] {
    | None {}
    | Some { value: A }
}</code></pre>
<p>This is syntax sugar for the following code:</p>
<pre><code>namespace Optional {
    // ↓ None will never have new fields
    @exhaustive(fields)
    struct None {}

    // ↓ Some will never have new fields
    @exhaustive(fields)
    struct Some[A] { value: A }
}

// ↓ Optional will never have new fields
@exhaustive(fields)
struct Optional[A] {
    // ↓ Actual enum syntax, without the sugar
    case: @exhaustive(cases) enum {
        | type Optional.None
          // ↑ refers to struct None
        | type Optional.Some[A]
          // ↑ refers to struct Some[A]
    }
}</code></pre>
<p>So <code>Some</code> and <code>None</code> represent first-class types,<span><label for="sn-17"></label><span>For comparisons with Scala’s case classes and Rust’s proposed <a href="https://github.com/rust-lang/lang-team/issues/122">enum variant types</a>, see <a href="#appendix-a1-everr-type-system-discussion">Appendix A1</a>.</span></span>
not just cases of <code>Optional</code>.<span><label for="sn-18"></label><span>This kind of design does not preclude <a href="https://www.0xatticus.com/posts/understanding_rust_niche/">niche optimizations</a>, see <a href="#appendix-a2-niche-optimizations-with-second-class-enums">Appendix A2</a>.</span></span></p>
<p><code>Optional</code> values support pattern matching:</p>
<pre><code>fn demo0(x: Optional[Str]) -&gt; Str {
    if x.case is {
       Optional.None {} -&gt; return &#34;Got None&#34;
       // _ represents a value being discarded
       Optional.Some { value: _ } -&gt; return &#34;Got Some&#34;
    } // Compiler checks exhaustiveness for:
      // 1. Cases of Optional
      // 2. Fields of None
      // 3. Fields of Some
}</code></pre>
<p>Even though pattern matching <em>looks</em> like it happens against types directly,
internally it works like tagged union types in other languages,
so exhaustiveness checking is supported,
unlike pattern matching with open class hierarchies.</p>
<p>To reduce verbosity, Everr has some syntax sugar for pattern matching.</p>
<ul>
<li>Everr supports implicit projection of the field
named <code>case</code> to provide a more familiar syntax.<span><label for="sn-19"></label><span>This is the only special case (ahem) where Everr inserts a field projection operation implicitly.</span></span></li>
<li>To allow the user to omit the type name in common cases,
Everr supports looking up namespaces
with the same name as the type, so one can use “leading dot syntax”,
similar to Swift etc.</li>
</ul>
<p>Rewriting the code using the above sugar:</p>
<pre><code>fn demo1(x: Optional[Str]) -&gt; Str {
    if x is {
        .None {} -&gt; return &#34;Got None&#34;
        .Some { value: _ } -&gt; return &#34;Got Some&#34;
    }
}</code></pre>
<p>Neat! 😃 Things get more interesting
when Everr’s non-exhaustive enums come into the mix.</p>
<pre><code>@non-exhaustive
enum Dessert {
    | Cake { icing : Str }
    | IceCream {}
}</code></pre>
<p>The above type declaration desugars to:</p>
<pre><code>namespace Dessert {
    @non-exhaustive(fields)
    struct Cake { icing : Str }

    @non-exhaustive(fields)
    struct IceCream {}
}

@non-exhaustive(fields)
struct Dessert {
    case: @non-exhaustive(cases) enum {
        | type Dessert.IceCream
        | type Dessert.Cake
    }
}</code></pre>
<p>Here’s how one might write some string conversion functions
for these types in a different project.<span><label for="sn-20"></label><span>Everr’s rules around mandatory handling of future cases and fields are similar to the behavior of Rust’s <code>#[non_exhaustive]</code> – they only apply across access control boundaries.</span></span></p>
<pre><code>fn cake_to_str(cake: Dessert.Cake) -&gt; Str {
    if cake is Dessert.Cake { icing: i, !__ } {
        i.append(&#34; cake&#34;);
        return i
    }
}</code></pre>
<p>There are two sigils here: <code>!</code> and <code>__</code>.</p>
<p><code>__</code> means “ignore any label-value pairs, if present”.
Since <code>Cake</code> has a <code>@non-exhaustive(fields)</code> annotation,
the <code>__</code> is mandatory, similar to mandatory catch-all
clauses for cases of an enum.</p>
<p><code>!</code> means “if the next identifier matches one or more known label-value pairs,
or one or more cases, please issue a warning”.<span><label for="sn-21"></label><span>This is a generalized version of <code>@unknown</code> in Swift (<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/statements#Switching-Over-Future-Enumeration-Cases">docs for <span data-cites="unknown">@unknown</span></a>).</span></span>
Since <code>Cake</code> has a <code>@non-exhaustive(fields)</code> annotation, if a new field is
added to it in the future, then a warning will be issued inside
<code>cake_to_str</code>.</p>
<p>This design allows the author of the type to add new
fields without breaking source-level backward compataibility,
while still allowing the user of the type to opt-in to a “notification”
when the type definition changes.</p>
<p>Using the above function, one can write a function to convert
a <code>Dessert</code> to a string.</p>
<pre><code>fn dessert_to_str(d: Dessert) -&gt; Optional[Str] {
    if d is Dessert { case: dcase, !__ }
       and dcase is {                        // (1)
        .Cake c -&gt;
            return .Some { value: cake_to_str(c) }
        .IceCream { __ } -&gt;
            return .Some{value: &#34;ice cream&#34;} // (2)
        !_ -&gt; return .None{}                 // (3)
    }
}</code></pre>
<p>I know there’s a lot going on in the above code example,
so let’s take it step-by-step.</p>
<pre><code>    if d is Dessert { case: dcase, !__ }
       and dcase is {                        // (1)</code></pre>
<p>There are a few things going on here:</p>
<ul>
<li><p><code>dcase</code> is a new binding for the <code>case</code> field of <code>d</code>.
It is immediately matched on again after <code>and</code>,
using the aforementioned Ultimate Conditional Syntax.</p></li>
<li><p>The <code>__</code> matches the rest of the fields not covered by the pattern,
and their values are ignored.
Omitting <code>__</code> would trigger a compiler error,
since <code>Dessert</code> is a non-exhaustive struct.</p>
<p>Alternately, if one didn’t care about a new field being
added to <code>Dessert</code>, then one could directly use <code>if d.case is</code>.</p></li>
<li><p>Due to the <code>!</code>, the compiler will issue a warning
if the <code>__</code> matches one or more fields,
similar to the logic in <code>cake_to_str</code>.</p></li>
</ul>
<p>Let’s look at the branch (2):</p>
<pre><code>        .IceCream { __ } -&gt;
            return .Some{value: &#34;ice cream&#34;} // (2)</code></pre>
<p>Here again, <code>__</code> means that future fields are being ignored.
The absence of <code>!</code> means that this code will not issue any
warnings if the <code>IceCream</code> type has new fields in the future.</p>
<p>Lastly, since <code>d.case</code> has a non-exhaustive enum type,
a catch-all pattern is mandatory:</p>
<pre><code>        !_ -&gt; return .None{}                 // (3)</code></pre>
<p><code>_</code> means “ignore a single value” similar to other languages.
Due to the <code>!</code>, this line will trigger a compiler warning
if one or more new cases are added to <code>Dessert</code>.</p>
<p>Whew, that was a lot! Here’s an XKCD for a short break.</p>
<p><img src="https://imgs.xkcd.com/comics/in_the_trees.jpg"/></p>
<p>Let’s continue. Suppose we have two people Alice and Bob
and we want to write two functions to describe which desserts
they like, in the same project as <code>Dessert</code>.<span><label for="sn-22"></label><span>If it were in a different project, the initialization syntax would not be available for non-exhaustive types.</span></span>
Here are their preferences:</p>
<ul>
<li>Alice likes cake with ganache on top, and also ice cream, but Alice is not open
to trying new desserts.</li>
<li>Bob likes cake with buttercream on top not ice cream. However,
Bob is open to trying new desserts if there are more options in the future.</li>
</ul>
<p>These preferences can be modeled using Everr’s bounded union types.</p>
<p>First, let’s model Alice’s preference.</p>
<pre><code>pub fn alice_likes() -&gt; Array[Dessert:union[.Cake | .IceCream]] {
    return Array.new(
        .Cake{icing: &#34;ganache&#34;},
        .IceCream{},
    )
}</code></pre>
<p>Here, <code>Dessert:union[.Cake | .IceCream]</code> represents an exhaustive (bounded) union type. It implies that values of types <code>Cake</code> and <code>IceCream</code> are allowed, and in the future, even if <code>Dessert</code> gains new cases, those will not be returned. Similar to exhaustive enums, if a caller tries to pattern match on the union value, they can match exhaustively, without needing a catch-all pattern.</p>
<p>Now let’s model Bob’s preference.</p>
<pre><code>pub fn bob_likes() -&gt; Array[Dessert:union+[.Cake]] {
    return Array.new(.Cake{icing: &#34;buttercream&#34;})
}
</code></pre>
<p>Here <code>Dessert:union+[.Cake]</code> represents a non-exhaustive (bounded) union type. It implies that only values of type <code>Cake</code> are allowed, but in the future, other cases of the top type – in this case, <code>Dessert</code> – may also appear. Similar to non-exhaustive enums, if a caller tries to pattern match on the union value, they must account for new cases being added (including <code>IceCream</code> if Bob changes his mind).</p>
<p>The exhaustiveness of a union type only applies to its cases. When pattern matching, one still needs to be explicit about handling unknown fields (using <code>__</code> or <code>!__</code>) since both <code>Cake</code> and <code>IceCream</code> have <code>@non-exhaustive(fields)</code>.</p>
<hr/>
<p>Since enum cases have first-class struct types, different enums can share cases.</p>
<pre><code>enum BakeryItem {
    | Bread {}
    | type Dessert.Cake // OK
}</code></pre>
<p>This allows reuse of case types without needing to copy the case definition.</p>
<hr/>
<p>Everr supports traits and trait derivations.
Everr has a built-in <code>UpCast</code> trait meant to represent O(1) conversions
from enum cases to a type containing the enum.</p>
<pre><code>trait UpCast[From, To] {
    fn up_cast(_: From) -&gt; To
}</code></pre>
<p>This trait is automatically implemented for enum cases.
So you’d have:</p>
<pre><code>impl UpCast[Dessert.Cake, Dessert] { ... }
impl UpCast[Dessert.IceCream, Dessert] { ... }

impl UpCast[BakeryItem.Bread, BakeryItem] { ... }
impl UpCast[Dessert.Cake, BakeryItem] { ... }</code></pre>
<p>Similar to interfaces in other languages, these can also be implemented by hand.</p>
<hr/>
<p>Lastly, Everr supports a delegation mechanism across types.
For example, if you have code like:</p>
<pre><code>struct BakeryProduct {
    @delegate
    base: BakeryItem
    ingredients: Array[Ingredient]
    price: Money
}</code></pre>
<p>At usages of the <code>.</code> operator for field access and method calls
on a <code>BakeryProduct</code> value, the compiler first checks if
<code>BakeryProduct</code> has the field or method, and if not,
checks if <code>BakeryItem</code> has the field or method.</p>
<p>At most one field can have a <code>@delegate</code> annotation to maintain
predictability in the face of field re-ordering without needing
ad-hoc tie-breaking rules.</p>
<p>Because cases are represented through a special <code>.case</code> field,
pattern matching directly on a <code>BakeryProduct</code> value will work,
because <code>BakeryItem</code> has a <code>.case</code> field which allows pattern-matching.</p>
<hr/>
<p>Okay, that concludes the tour of Everr’s core language features!
Now let’s talk about Everr’s error model.</p>
<h3 id="everrs-error-model---overview">Everr’s error model - Overview</h3>
<p>Everr’s error model is based on the core observation that the
handling and recovery from different errors is generally
context-dependent, so it provides flexibility and broad mechanisms
for different error handling strategies in different contexts.</p>
<p>There are two modes for error propagation and handling.</p>
<ul>
<li>Fail-slow error handling: This is done using the standard <code>Result</code> type,
which is an exhaustive enum equivalent to that in Rust and Swift.</li>
<li>Fail-fast error handling: This comes in two flavors:
<ul>
<li>Recoverable: This is done using <code>panic</code> and <code>catch panic</code>
primitives, similar to <code>panic</code>/<code>recover</code> in Go and
<code>panic!</code>/<code>catch_unwind</code> in Rust. Panicking and panic catching themselves
use memory pre-allocated at program startup to avoid out-of-memory
in the middle of a panic,
while accepting the risk of potentially needing to discard
some relevant data.</li>
<li>Non-recoverable, i.e. program termination. This is done using an
<code>exit</code> primitive.</li>
</ul></li>
</ul>
<p>OS signals are handled using callbacks and potentially
manifested using one of the above depending on the exact signal
and configuration.</p>
<p>Notably, there is no support for asynchronous termination of non-cooperative tasks
via asynchronous exceptions, such as that in Haskell, OCaml or Erlang.</p>
<p>For primitive operations, the defaults are as follows:</p>
<ul>
<li>Numeric operations on bounded integer types panic on failure,
prioritizing safety over performance.</li>
<li>Assertion failures trigger a panic.</li>
<li>Out-of-memory for the heap aborts the program.</li>
<li>Stack overflow aborts the program.</li>
</ul>
<p>However, these can be customized; more details on each of them soon.</p>
<p>One important aspect on how Everr code negotiates what is and is not allowed,
is through the designation of certain core language features as <em>capabilities</em>.
Examples of capabilities include heap allocation, panicking,
program termination and foreign function interface (FFI) usage.</p>
<p>Capabilities manifest at the boundaries of packages,
which are Everr’s units of distribution.
Each package has a manifest file, which supports specifying:</p>
<ul>
<li><p>The capabilities used by the given package, in addition to the defaults.
Each capability has three levels (other than <strong>Unavailable</strong>):</p>
<ul>
<li><p><strong>Implicit</strong>: All code is granted access to the capability, without needing
any annotation.</p></li>
<li><p><strong>Explicit</strong>: Code which uses the capability must have an explicit annotation.</p></li>
<li><p><strong>Binding</strong>: Code which uses the capability must have an explicit annotation,
and this annotation is considered part of the API contract;
weakening the annotation is considered a breaking change.</p>
<p>One can optionally configure the standard linter to enforce that
functions which do not use the capability also have an explicit annotation
indicating that the function is guaranteed to not use the capability
in the future or that it reserves the right to use the capability later on.</p></li>
</ul></li>
<li><p>The capabilities permitted for different dependencies.</p></li>
</ul>
<p>If that sounds a bit too abstract, don’t worry,
I’ll explain the capability system later with examples.</p>
<p>First, let’s discuss fail-slow and fail-fast error handling.</p>
<h3 id="fail-slow-error-handling">Fail-slow error handling</h3>
<p>For very basic operations where only a single failure is possible,
(e.g. a map lookup), the failure is exposed using the standard <code>Optional</code> type.
In most other cases, either the <code>Result</code> or <code>Hurdle</code> types are used.<span><label for="sn-23"></label><span><code>Result</code> and <code>Hurdle</code> are recognized specially by the standard Everr
linter, which issues warnings if <code>_</code> is used to ignore the <code>Fail</code> case the <code>problem</code> field.</span></span></p>
<pre><code>// Result represents computations where errors block progress.
//
// Most commonly used for short-circuiting logic.
@exhaustive
enum Result[A, E] {
    | Pass { value: A }
    | Fail { error: E }
}

// Hurdle represents computations where problems do not
// block progress, but they still need to be bubbled up,
// such as in the form of warnings.
@exhaustive
struct Hurdle[A, E] {
    data: A
    problem: E
}</code></pre>
<p>For the <code>E</code> type parameter, Everr programmers are recommended
to use domain-specific struct and enum types which define errors.
Since both enums and structs support exhaustiveness annotations,
it is easy to mark error types for future evolution.</p>
<p>Since enums are desugared to structs:</p>
<ul>
<li>It is possible to add a field common to all cases of an enum,
without breaking source-level backward compatibility.</li>
<li>It is possible to refine a coarse case into multiple sub-cases
by adding a <code>case: enum { ... }</code> field to the corresponding case.</li>
</ul>
<p>For example, say one has a float parsing function which returned
an error with the following type:</p>
<pre><code>@exhaustive(cases)
enum FloatParseError {
    | UnexpectedChar { byte_offset: UInt64 }
    | NotRepresentable {}
}</code></pre>
<p>Since this is marked specifically as being <code>@exhaustive(cases)</code>,
it means that adding new fields is allowed without it being
considered a breaking change.</p>
<p>One could add a field to the <code>NotRepresentable</code> case, and refine it,
without breaking backward compatibility:</p>
<pre><code>@exhaustive(cases)
enum FloatParseError {
    | UnexpectedChar { byte_offset: UInt64 }
    | NotRepresentable {
        // Represents the lower bound on the number of bits
        // that would be needed for a floating point type
        // to be able to represent the given value.
        min_bits_needed: UInt64
        case: @exhaustive enum {
            | TooSmall {}
            | TooLarge {}
        }
    }
}</code></pre>
<p>Once the type is refined, both of these forms of pattern-matching work.</p>
<pre><code>if err is {
    .UnexpectedChar { .. } -&gt; ..
    .NotRepresentable { __ } -&gt; ..
}
// or more fine-grained
if err is {
    .UnexpectedChar { .. } -&gt; ..
    .NotRepresentable nr and nr is {
        .TooSmall {} -&gt; ..
        .TooLarge {} -&gt; ..
    }
}</code></pre>
<p>Case refinement in Everr provides optionality without a-priori
factoring out enum definitions into separate enum and case struct
definitions, unlike typical languages in the ML family.
The cost of additional verbosity is paid when refinements are introduced.</p>
<hr/>
<p>Errors can be propagated using a <code>try</code> operator,
which can be used at different granularities.
– it can be used for one-or-more statements,
or for a specific (tree of) expressions,
including individual call expressions.</p>
<pre><code>enum ABCError {
    | type SubError1
    | type SubError2
    | type SubError3
    | type SubError4
}

fn abc() -&gt; Result&lt;Int, ABCError&gt; {
    try {
        sub_op1(...)
        sub_op2(...)
    }
    let a = try sub_op3(...).some_method(...)
    let b = sub_op4(a).@try
    return ok(b.other_method())
}</code></pre>
<p><code>try</code> allows for a single level of automatic conversion of errors,
via the previously mentioned <code>UpCast</code> trait.
This is similar to <code>?</code> and <code>Try</code> in Rust.</p>
<p>Everr programmers are encouraged to define and use structured error types,
and attach metadata to errors by defining new struct fields.
Structs can be easily serialized
using the same mechanism as for trait derivation,
with minimal boilerplate.
This integrates well with observability libraries such as those
providing APIs for structured logging and tracing.</p>
<p>The Everr language server has a code action for defining error types for a given
function based on the error types of the functions that are called.
It also can intelligently suggest modifications to error cases
as the function body evolves over time, taking contextual rules such
as access control into consideration.</p>
<p>The Everr standard library exposes a standard type for call traces.<span><label for="sn-24"></label><span>A call trace covers different kinds of traces such as a stack trace, <a href="https://ziglang.org/documentation/master/#Error-Return-Traces">Zig-style error return trace</a>, as well as <a href="https://rust-lang.github.io/wg-async/design_docs/async_stack_traces.html">async stack traces</a>. While these are all recorded differently, they fall under the same concept (sequence of source code locations which describe “how did we get here”).</span></span></p>
<p>Even though the use of structured errors is encouraged,
the Everr standard library provides APIs for working
with unstructured errors.</p>
<ul>
<li>An <code>AnyErrorContext</code> type which exposes convenient APIs for:
<ul>
<li>Attaching key-value pairs.</li>
<li>Capturing and recording call traces.</li>
</ul></li>
<li>An <code>AnyError</code> type which pairs an error value along with an <code>AnyErrorContext</code> and zero-or-more child <code>AnyError</code> values (similar to <code>error</code> in Go). This exposes convenient APIs for:
<ul>
<li>Initialization from a specific struct/enum error type.</li>
<li>Merging several sub-errors into a larger error.</li>
<li>Tree traversal and inspection.</li>
</ul></li>
</ul>
<h3 id="fail-fast-error-handling">Fail-fast error handling</h3>
<p>Recoverable fail-fast error handling is done via panics,
which are similar to unchecked exceptions in languages like Java and C++.</p>
<p>Function declarations and types can optionally be annotated with a
<code>@panics</code> attribute which covers whether the function might panic,
it might panic when compiled in development mode
(but never in release mode), or never at all.</p>
<p>Panicking is a capability.
The default capability level for panicking is Implicit, so most
packages do not use <code>@panics</code> annotations.</p>
<p>For packages compiled with Explicit or Binding level for panic marking,
the Everr compiler checks if a function’s <code>@panics</code> annotation
(or lack thereof) matches with the annotations on other
functions that are called by it.</p>
<p>The standard linter recognizes functions with <code>@panics</code> annotations
and recommends adding a section to the function’s API docs
describing when the function might panic.</p>
<p>For the Binding level in particular, the standard linter
has an optional lint requires explicit <code>@panics(maybe)</code>
or <code>@panics(never)</code> annotations on all functions,
to avoid accidental API additions without <code>@panics</code>
annotations (which would prevent the implementation
from using assertions).</p>
<p>The Everr core libraries, including the standard library, use Explicit
panic marking.</p>
<p>A small portion of the Everr ecosystem, chiefly some minimal alternatives
to the standard library and related packages meant to be used in the
context of embedded systems, default to using the Binding level for panic marking.</p>
<p>Similar to panicking, program termination using the <code>exit</code> primitive
is treated as a capability; it has a matching <code>@exits</code> attribute.</p>
<p>However, unlike panicking, the default level for the termination capability
is Explicit, as it is fairly rare to require it in library code.</p>
<h3 id="primitives---bounded-integer-operations">Primitives - Bounded integer operations</h3>
<p>In Everr, numeric operations on bounded integer types panic on overflow.</p>
<p>One can opt-in to alternate behavior on overflow (commonly wrapping)
at the granularity of a package, one or more statements,
or an expression. Similar to <code>try</code>, this operates at a syntactic level.</p>
<pre><code>    let sum_plus_one = @math.wrap { 1 + vec.sum() }
    // Addition semantics in the sum() call itself are unaffected.</code></pre>
<p>When overflow behavior is overriden at the package level,
the Everr language server supports showing inlay hints
for the overflow behavior at function granularity.</p>
<h3 id="primitives---assertions">Primitives - Assertions</h3>
<p>Everr’s assertions are customizable.<span><label for="sn-25"></label><span>I’m deliberately not describing the exact APIs for assertions here as there is some room for building interesting APIs, such as <a href="https://antithesis.com/docs/best_practices/sometimes_assertions/">sometimes assertions</a>.</span></span>
By default, an assertion failure triggers a <code>panic</code>.
However, a binary package can customize the semantics of assertions,<span><label for="sn-26"></label><span>This customizability introduces some more complexity when considering the interaction with default capability levels and capability checking. I’ve not fully thought through the ramifications, but my gut feeling is that this is a solvable problem.</span></span>
by specifying an “assertion overlay” in its package manifest.
This acts as an override for the default assertion related APIs,
so every package in the dependency graph ends
up using one’s custom implementation of assertions.</p>
<p>The two most commonly used assertion overlays are:</p>
<ul>
<li>Profiling overlay: This helps collect metrics related to individual
assertions in production.</li>
<li>Toggling overlay: This helps disable assertions in dependencies,
either statically or dynamically.</li>
</ul>
<h3 id="out-of-memory-handling">Out-of-memory handling</h3>
<p>By default, out-of-memory for the heap results in program termination.</p>
<p>Heap usage is a capability, with the default level of Implicit.</p>
<p>Primitives which utilize heap allocation have fallible alternatives,
making it possible<span><label for="sn-27"></label><span>The design of ergonomic and performant APIs for using custom allocators while maintaining memory safety (or, at least, trying to reduce the number of footguns) is an open problem with several competing approaches. For more details, see Section 6 and Appendix A4.</span></span> to build APIs on top without having to rely on
heap allocation always being successful.</p>
<h3 id="stack-overflow-handling">Stack overflow handling</h3>
<p>By default, stack overflow results in program termination.</p>
<p>Recursion and usage of indirect calls are both considered capabilities,
with the default level of Implicit.</p>
<p>Code which cannot afford to have a stack overflow,
such as code following
<a href="https://en.wikipedia.org/wiki/The_Power_of_10:_Rules_for_Developing_Safety-Critical_Code">NASA’s rules for safety-critical code</a>,
can easily disable both of these features,
allowing the potential call graph of the program to be statically computed.</p>
<p>This allows computing the total stack usage of the program at the time
of compilation.</p>
<p>Stack usage is not guaranteed to be stable across minor or patch versions
of the Everr compiler, but since qualifying the compiler for safety-critical code
tends to be a time-consuming affair that is less frequent than compiler
releases, this is considered an acceptable trade-off.</p>
<p>For an alternative design which allows for more expressivity at the cost
of more implementation complexity, see Appendix A5.</p>
<h2 id="section-5-error-models-in-the-wild">Section 5: Error models in the wild</h2>
<p>The <a href="https://github.com/swiftlang/swift/blob/main/docs/ErrorHandlingRationale.md#survey">Swift Error Handling Rationale and Proposal</a>
doc I linked earlier covers the error model followed in
C, C++, Objective-C, Java, C#, Go, Rust and Haskell,
so I will not elaborate on those much more here.</p>
<p>Some older statically typed languages missing from that list include
D, OCaml and Ada. Some newer languages understandably missing include
Pony, Nim, Zig, Odin, Roc, Jai and Hare.</p>
<p>Scala does not market itself as a systems programming language,
but it’s type system offers interesting ways of expressing errors,
so it is included below. Other languages such as Dart, Kotlin,
Gleam and Unison are excluded because
I did not see any unusual or interesting ideas related to error
handling in their docs, and they seem to be more targeted towards
applications with less stringent performance requirements.</p>
<p>I’m going to try to summarize the error models very quickly here,
based on the language’s own docs. My summaries should not be considered
authoritiative, especially for pre-1.0 languages where conventions
are probably still in flux, and docs are perhaps more likely to be
out-of-date.</p>
<h3 id="d">D</h3>
<p>As of Feb 2025, the <a href="https://dlang.org/spec/errors.html">official D docs</a>
recommend using unchecked exceptions as the primary way of communicating errors.</p>
<p>However, <a href="https://youtu.be/XQHAIglE9CU?si=iYYy8R9GOEylPR6P&amp;t=1354">at DConf 2020</a>,
Walter Bright, the creator of D, stated that he thinks that
exceptions are obsolete.</p>
<p>Other noteworthy aspects:</p>
<ul>
<li>Functions can be marked <a href="https://dlang.org/spec/function.html#nothrow-functions">nothrow</a>.</li>
<li>The type <a href="https://dlang.org/phobos/object.html#.Exception">Exception</a>
is the base class for all “errors that are safe to catch and handle”.
Throwing an <code>Exception</code> is not allowed in <code>nothrow</code> functions.</li>
<li>The type <a href="https://dlang.org/phobos/object.html#.Error">Error</a>
is the base class of “all unrecoverable runtime errors”.
Throwing an <code>Error</code> is allowed in <code>nothrow</code> functions.</li>
<li>The default <code>assert</code> function/built-in throws an <code>Error</code>.</li>
</ul>
<h3 id="ocaml">OCaml</h3>
<p>Error propagation in OCaml comes in several flavors:</p>
<ul>
<li>Unchecked exceptions - These are widely used by the standard library.
Notably, assertion failures get converted to exceptions.</li>
<li>option and result types - Increasingly more library APIs have alternate
variants which return <code>option</code> or <code>result</code> in the failure case
rather than an exception.</li>
<li>Async exceptions are used for out-of-memory, stack overflow and
for OS signals like SIGINT.</li>
</ul>
<p>Additionally, OCaml supports <a href="https://ocaml.org/manual/5.3/bindingops.html">syntax sugar</a>
for short-circuiting evaluation/chaining of operations using <code>option</code> and <code>result</code>.</p>
<p>The <a href="https://ocaml.org/docs/error-handling">official OCaml docs</a> are probably
best described as being somewhat neutral in terms of prescribing a particular
error propagation strategy, but they do state:</p>
<blockquote>
<p>It tends to be considered good practice nowadays when a function can fail
in cases that are not bugs (i.e., not assert false, but network failures,
keys not present, etc.) to return type such as ’a option or (’a, ’b)
result (see next section) rather than throwing an exception.</p>
</blockquote>
<p>The book <a href="https://dev.realworldocaml.org/error-handling.html">Real World OCaml</a>
recommends using the <code>Base</code> library by Jane Street
in addition to the standard library. This library includes additional
helper types such as <code>Error.t</code> – a lazy string with various helper functions
for ease of construction – and helper functions such as <code>Or_Error.try_with</code>
to convert an exception throwing computation to a <code>result</code>.</p>
<p>Real World OCaml concludes:</p>
<blockquote>
<p>If you’re writing a rough-and-ready program where getting it done quickly is key and failure is not that expensive, then using exceptions extensively may be the way to go. If, on the other hand, you’re writing production software whose failure is costly, then you should probably lean in the direction of using error-aware return types.</p>
<p>[..] If an error occurs sufficiently rarely, then throwing an exception is often the right behavior.</p>
<p>Also, for errors that are omnipresent, error-aware return types may be overkill. A good example is out-of-memory errors, which can occur anywhere, and so you’d need to use error-aware return types everywhere to capture those.</p>
</blockquote>
<h3 id="ada">Ada</h3>
<p>Ada supports unchecked exceptions using values of a specific
type <code>exception</code> that can optionally carry a string payload.
If I understand correctly, exceptions have a notion of identity that is separate from the string payload.</p>
<p>The <a href="https://learn.adacore.com/courses/intro-to-ada/chapters/exceptions.html#predefined-exceptions">pre-defined exceptions</a> include:</p>
<ul>
<li><code>Constraint_Error</code> of out-of-bounds accesses, overflow, null dereference etc.</li>
<li><code>Storage_Error</code> for allocation failure and stack exhaustion</li>
</ul>
<p>In <a href="https://stackoverflow.com/q/63037858/2682729">one Stack Overflow discussion</a>, I found two different practitioners stating:</p>
<ul>
<li>“The reason for [not having a way to chain exceptions] is that the language has been designed for exceptions to be used scarcely”</li>
<li>“Ada exceptions are expected to be used for truly exceptional problems.”</li>
</ul>
<p>However, the <a href="https://en.wikibooks.org/wiki/Ada_Style_Guide/Program_Structure#Using_Exceptions_to_Help_Define_an_Abstraction">Ada style guide</a>
on Wikibooks has a guideline “Use Exceptions to Help Define an Abstraction”.
One of the code examples in this section is a stack where the <code>Pop</code> operation
raises an exception when the stack is empty.</p>
<p>I/O operations in the Ada standard library pervasively use exceptions.
I was not able to verify if there are other widely used standard library alternatives.</p>
<p>GNAT (Ada compiler toolchain in GCC) supports several settings for
restricting exception usage such as
<a href="https://docs.adacore.com/gnat_rm-docs/html/gnat_rm/gnat_rm/standard_and_implementation_defined_restrictions.html#no-exception-handlers"><code>No_Exception_Handlers</code></a>,
<a href="https://docs.adacore.com/gnat_rm-docs/html/gnat_rm/gnat_rm/standard_and_implementation_defined_restrictions.html#no-exception-propagation"><code>No_Exception_Propagation</code></a>,
and <a href="https://docs.adacore.com/gnat_rm-docs/html/gnat_rm/gnat_rm/standard_and_implementation_defined_restrictions.html#no-exceptions"><code>No_Exceptions</code></a>.
For example, <code>No_Exception_Propagation</code> requires functions to handle exceptions in callees.</p>
<h3 id="scala">Scala</h3>
<p>Scala 3 supports using <a href="https://www.scala-lang.org/api/3.x/scala/util/control/Exception$.html">unchecked exceptions</a>
as well as a tagged union type <a href="https://www.scala-lang.org/api/3.x/scala/util/Try.html">Try</a>
which enables easily catching exceptions and converting them to a sum type representation.</p>
<p>Some popular libraries such as Li Haoyi’s libraries for IO use exceptions
for errors such as a file not being found.</p>
<p>I’m guessing the more FP-oriented parts of the ecosystem probably use
case classes and/or Result to a greater extent, but I was not able to validate
this within 5~10 minutes of searching.</p>
<h3 id="nim">Nim</h3>
<p>Based on a quick skim of the Nim docs, I surmised the following:</p>
<ul>
<li>Nim supports <a href="https://nim-lang.org/docs/manual.html#effect-system-exception-tracking">exception handling</a>,
and this is used by standard library APIs such as for opening files.</li>
<li>Nim supports <code>raises</code> annotations on functions which indicate the types of
exceptions a function may throw (e.g. <code>{.raises: [ParseError]}</code>).</li>
<li>Nim supports a way to mandate explicit <code>raises</code> annotations across a module,
by putting <code>{.push raises: [].}</code> at the start of a module.
This setting ignores exceptions which inherit from <code>system.Defect</code>,
which is Nim’s way of signaling errors such as division by zero
and assertion failure.</li>
<li>Nim also has optional and result types.</li>
</ul>
<p>The <a href="https://nim-lang.org/docs/tut2.html#exceptions">Nim tutorial section on exceptions</a> states that</p>
<blockquote>
<p>A convention is that exceptions should be raised in exceptional cases,
they should not be used as an alternative method of control flow.</p>
</blockquote>
<p>The rest of the tutorial is descriptive –
it covers how to use different language features related to exceptions.</p>
<p>This <a href="https://status-im.github.io/nim-style-guide/errors.result.html">unofficial Nim style guide</a>
has more detailed recommendations on modeling and handling errors.
I was unable to find similar prescriptive language in
the official Nim docs.</p>
<hr/>
<p>The below languages are pre-1.0 as of March 2025.<span><label for="sn-28"></label><span>The exception is Odin which currently uses date-based versioning. I’m assuming that as being equivalent to pre-1.0 in terms of stability guarantees given that Odin is less than 10 years old.</span></span></p>
<h3 id="pony">Pony</h3>
<p>The Pony tutorial has <a href="https://tutorial.ponylang.io/expressions/errors.html">a page on the <code>error</code> expression</a>,
which allows a function to abort execution until the enclosing <code>try</code> block.
All partial functions must be annotated with <code>?</code>.</p>
<p>As far as I can tell, there is no way to attach any data
when using the <code>error</code> statement.
If that is correct,
it means that the <code>error</code> primitive is similar
to an optional type which must be explicitly unwrapped.</p>
<p>Looking at unofficial sources,
based on <a href="https://journal.infinitenegativeutility.com/pony-errors-and-logging">this blog post</a>
and <a href="https://stackoverflow.com/questions/42845484/distinguishing-between-different-types-of-error-in-pony">StackOverflow discussion on distinguishing between different types of errors</a>,
it seems like the most common way is to do
error handling in Pony is using union types (e.g. <code>Int64 | OverflowError</code>).</p>
<p>As of Feb 2025, I could not find any official docs
further explaining how errors ought to be modeled and
how error handling should to be done, outside of the
<a href="https://www.ponylang.io/use/performance/pony-performance-cheat-sheet">performance cheat sheet</a>
which recommends avoiding <code>error</code>
and union types in performance-sensitive code,
both for different reasons.</p>
<p>Based on the docs, it looks like union types are compiled
using a <a href="https://tutorial.ponylang.io/expressions/match.html#matching-on-type-and-value">type ID pointer as the tag</a>
plus <a href="https://www.ponylang.io/use/performance/pony-performance-cheat-sheet/#boxing-machine-words">implicit boxing for the value</a>.<span><label for="sn-29"></label><span>This makes sense, as it allows implementing the natural subtyping relationship <code>T &lt;: (T | U)</code> to be implemented with zero run-time cost.</span></span></p>
<h3 id="zig">Zig</h3>
<p>The official Zig way to do error handling is by <a href="https://ziglang.org/documentation/master/#Error-Set-Type">defining “error sets”</a>:</p>
<pre><code>const FileOpenError = error{
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};</code></pre>
<p>Error sets are structurally typed – identically named cases in different <code>error{...}</code>
declarations in different files are interchangeable.<span><label for="sn-30"></label><span>I’m curious to see how this decision pans out over time as the Zig ecosystem grows. Will library authors eventually start adding unique prefixes to library-specific errors, similar to prefixes in C and Objective-C, to avoid collisions?</span></span> This allows coercion of errors
from a subset to a superset, as well as merging using a <code>||</code> operator.</p>
<p><a href="https://github.com/ziglang/zig/issues/2647">Errors cannot not carry payloads</a>.
As a substitute, people use different patterns such as out parameters
and avoiding the standard error handling machinery.</p>
<p>Functions may write or omit the various error cases returned.</p>
<pre><code>// Inferred error set
pub fn parse_f32(...) !f32 { ... }

// Explicit error set
pub fn parse_f32(...) FloatParseError!f32 { ... }</code></pre>
<p>Here <code>FloatParseError!f32</code> is an <a href="https://ziglang.org/documentation/master/#Error-Union-Type">“error union type”</a>.</p>
<p>For handling an error union value returned from a function,
one can use <code>catch</code> keyword along with a default value or a code block.</p>
<p>Zig supports <code>try</code> as a shortcut for error propagation, which amounts
to being sugar for <code>catch |err| return err</code>.</p>
<p>Zig supports <a href="https://ziglang.org/documentation/master/#Non-exhaustive-enum">non-exhaustive enums</a>.
The docs do not explicitly mention support for non-exhaustive errors and structs
(but they do state that “An error set is like an enum”).</p>
<p>Zig programs are able to use a bevy of compile-time introspection facilities,
such as compile-time iteration over the fields of a struct.
The Zig docs do not state how compile-time introspection
interacts with non-exhaustive enums.</p>
<p>Zig uses whole program compilation. During this:</p>
<ul>
<li><p>Unique integer values are picked for different error cases.</p></li>
<li><p>The maximum height of the call graph is computed (recursion is capped to height 2),
and that is used for pre-allocating a buffer for <a href="https://ziglang.org/documentation/master/#Implementation-Details">error return traces</a>
in the Debug and ReleaseSafe modes.</p>
<ul>
<li>Return traces are implemented using a hidden function parameter.</li>
<li><code>catch</code> and <code>try</code> are integrated with return traces.</li>
</ul></li>
</ul>
<p>Zig has a <code>defer</code> statement for resource cleanup.
It also has an <code>errdefer</code> statement which runs a cleanup operation
only if the enclosing function returns an error.</p>
<p>Zig supports a customizable <code>@panic</code> operation.
By default, the implementation <a href="https://sourcegraph.com/github.com/ziglang/zig/-/blob/lib/std/debug.zig?L571">prints a stack trace and terminates the program</a>.
However, the “root file” (the one containing <code>main</code>) can
be used to override this implementation to do something else.</p>
<h3 id="odin">Odin</h3>
<p>Odin <a href="https://odin-lang.org/docs/overview/#unions">supports sum types</a> using the <code>union</code> keyword,
and C-style enums using the <code>enum</code> keyword.</p>
<p>The Odin docs do not have a dedicated section on the error model,
but the <a href="https://odin-lang.org/docs/overview/#union-tags">code examples in the docs</a>
showcase the usage of sum types for errors.</p>
<pre><code>Error :: union #shared_nil {
	File_Error,
	Memory_Error,
}

File_Error :: enum {
	None = 0,
	File_Not_Found,
	Cannot_Open_File,
}

Memory_Error :: enum {
	None = 0,
	Allocation_Failed,
	Resize_Failed,
}</code></pre>
<p>Similar to Go, all types in Odin have a <a href="https://odin-lang.org/docs/overview/#zero-values">zero value</a>.
Generally, <code>nil</code> is a valid value for sum types.<span><label for="sn-31"></label><span>This can be overriden with a <code>#no_nil</code> annotation on the declaration, in which case the sum type must have a default value.</span></span>
The <code>nil</code> values for the types for individual cases can be merged
using the <code>#shared_nil</code> keyword, which is used in the above example.</p>
<p>In 2018, the creator of Odin wrote a blog post
<a href="https://www.gingerbill.org/article/2018/09/05/exceptions-and-why-odin-will-never-have-them/">Exceptions — And Why Odin Will Never Have Them</a>.</p>
<blockquote>
<p>One of the consequences of exceptions is that errors can be raised anywhere and caught anywhere.
This means that the culture of pass the error up the stack for “someone else” to handle.
I hate this culture and I do not want to encourage it at the language level.
Handle errors there and then and don’t pass them up the stack.
You make your mess; you clean it.</p>
</blockquote>
<p>The Odin docs do not mention non-exhaustive structs or unions.</p>
<h3 id="roc">Roc</h3>
<p>Roc’s sum types are structural.</p>
<p>For error handling, Roc recommends the standard <code>Result</code> sum type,
and standard algebraic types for errors.</p>
<p>I searched for a bit, but could not tell if Roc supports some way
of representing non-exhaustive structs and enums.</p>
<p>Roc <a href="https://www.roc-lang.org/faq.html#option-type">deliberately does not define an <code>Optional</code> type</a>
and recommends the consistent use of <code>Result</code> for error handling instead.</p>
<p>Integer overflow in Roc translates to an irrecoverable program crash,
similar to Swift.</p>
<h3 id="jai">Jai</h3>
<p>I watched some of Jonathan Blow’s videos a few years back
and do not recall any particular discussion on the error model.</p>
<p>The <a href="https://pixeldroid.com/jailang/">unofficial Jai docs</a> do not
have any notable mentions of error handling.</p>
<h3 id="hare">Hare</h3>
<p>Hare supports declaring <a href="https://harelang.org/tutorials/introduction#user-defined-types">anonymous tagged union types</a> with implicit tags using <code>|</code>.</p>
<pre><code>type index = size;
type offs = size;

export fn main() void = {
	let z: (index | offs) = 1337: offs;
	assert(z is offs);
};</code></pre>
<p>Based on my reading of the docs, the <code>type A = B</code> syntax introduces
a <em>newtype</em> in Haskell-speak, not a type alias
unlike most other languages that I know of
using the same syntax (e.g. Rust, Go, Swift, Haskell, OCaml).<span><label for="sn-32"></label><span>In most languages, substitution of type aliases is expected to not affect program semantics. Recursive type aliases are also usually not permitted.</span></span></p>
<p>Hare’s tagged union types actually implement <em>union type</em> semantics
in the type-theoretic sense, not sum type semantics.
For more discussion, see Appendix A3.</p>
<p><a href="https://harelang.org/tutorials/introduction#defining-new-error-types">Error types in Hare</a>
can be declared using a prefix <code>!</code>.</p>
<pre><code>type error = !(io::error | invalid | unexpectedeof);</code></pre>
<p>Such an error type can be handled using <code>match</code>,
and supports implicit injection from individual component types.</p>
<p>For functions returning errors, apart from pattern matching,
the error can be propagated to the caller using post-fix <code>?</code>
and used to trigger a crash with post-fix <code>!</code>.</p>
<p>The Hare docs do not mention non-exhaustiveness for fields or cases.</p>
<h2 id="section-6-everr-vs-the-world">Section 6: Everr vs the World</h2>
<blockquote>
<p>The limits of my language mean the limits of my world.</p>
<p>– Ludwig Wittgenstein</p>
</blockquote>
<p>In this section, I’m going to compare Everr
against other existing programming languages
based on the key criteria outlined in Section 3.</p>
<p>I will be focused on <em>native support</em>, i.e. whether a language
supports a direct way of expressing a particular construct,
not whether it can be emulated using other constructs.</p>
<p>I recognize that some language prefer minimizing in-language
complexity in favor of pushing it out into libraries
and/or applications (e.g. by offering general purpose mechanisms
such as macros, compile-time reflection etc.).
However, as a trend, natively supported features
generally get special treatment in terms of syntax sugar,
recognition by tooling and dedicated error messages,
as well as more mentions in official documentation,
so it makes sense to focus on native support.</p>
<p>As the saying goes, “In theory, there is no difference
between theory and practice. In practice, there is.”
This is going to be a bit of an apples-to-wax apple comparison<span><label for="sn-33"></label><span>By “wax apple”, I mean an inedible apple-lookalike made out of wax, not the <a href="https://en.wikipedia.org/wiki/Syzygium_samarangense">wax apple</a> fruit.</span></span>
because there is no implementation of Everr,
so there is no real world evidence that these ideas
are workable without major changes.
All I have to offer is indirect evidence of “success” in
the form of usage of all the languages that Everr
<del>shamelessly copies</del> borrows ideas from.</p>
<p>With that big caveat, let’s proceed.</p>
<h3 id="error-declarations">Error declarations</h3>
<p>Languages using exceptions as the primary mode of error handling
generally lack a native way to enable exhaustiveness checking:
idiomatic error handling is non-exhaustive by construction.</p>
<p>In contrast, newer pre-1.0 languages such as Zig, Roc, Hare etc.
lack native support for non-exhaustive errors.</p>
<p>Older languages with algebraic data types such as Haskell and OCaml
do not have native support for non-exhaustiveness annotations
on data types.</p>
<p>Swift supports marking structs and enums as non-exhaustive,
but this is <a href="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0192-non-exhaustive-enums.md#non-frozen-swift-enums-outside-the-standard-library">coupled to ‘Library Evolution’</a>,
which is Swift’s overarching feature
for maintaining ABI-compatibility guarantees.</p>
<p>Rust supports marking structs and enums as non-exhaustive,
and extending them with fields and cases respectively when
these annotations are used.
However, case refinement requires a-priori defining separate
structs for individual enum cases.</p>
<p>In languages with native support for algebraic data types,
generally sum types and product types are both first-class,
and sum types cannot carry shared fields.
This sometimes leads to soft recommendations of using
single-field structs instead of native enums to maintain
optionality in case one wants to ever add a field common
to all cases without breaking backward compatibility.</p>
<p>Scala should technically support case refinement very well
because case classes are first-class types that can be inherited from.
However, my understanding is that this is <a href="https://gist.github.com/chaotic3quilibrium/58e78a2e21ce43bfe0042bbfbb93e7dc">highly</a> <a href="https://users.scala-lang.org/t/simple-naive-and-wrong-more-than-you-wanted-to-know-about-case-classes/8300">frowned upon</a>.</p>
<p>Scala supports exhaustiveness annotations
along the cases axis using the <code>sealed</code> keyword.
However, the Scala docs do not mention support for non-exhaustiveness
annotations for fields of a case class.</p>
<p>Like Rust, Everr supports exhaustiveness annotations for fields and cases.</p>
<p>Like Cap’n Proto, Everr allows evolving a non-exhaustive enum to a
struct by adding shared fields without a source-level breaking change.</p>
<p>Everr supports case refinement, because cases are represented using
structs, and exhaustivity annotations from the outer type are propagated
to the structs for individual cases,
which allows addition of sub-cases using a <code>case</code> field.</p>
<h3 id="error-propagation---explicit-marking">Error propagation - Explicit marking</h3>
<p>Earlier, in the first sub-point under the bullet for ‘Error propagation’, I wrote:</p>
<blockquote>
<ul>
<li><strong>Explicit marking</strong>: The ability to force code to be written
in a way such that:
<ol type="1">
<li>Possible errors from primitive operations are indicated with explicit marks.</li>
<li>Propagating errors from an invoked operation to one’s own caller requires
an explicit mark.</li>
</ol>
The absence of explicit marks must cause a localized static error.</li>
</ul>
</blockquote>
<p>Let’s discuss the second bit first.</p>
<p>When exceptions are used for error handling, the most common
approach is that exceptions are silently propagated,
and that nearly any function may throw any exception.
This approach relies on programmers’ diligence
in reading, writing and maintaining doc comments.</p>
<p>Some languages which support finer control over exception propagation
are Java, D, Ada, Nim and C++.</p>
<p>My understanding is that the usage of checked exceptions in Java
is uncommon due to the added syntactic overhead, and the inability
to change code over time to return new error cases without jumping
through extra hoops.</p>
<p>Go and Rust have a panicking mechanism which is similar to exceptions,
and the typical recommendation is that these should only be used
for “exceptional” or “catastrophic” situations.</p>
<p>The Rust ecosystem has a <a href="https://blog.reverberate.org/2025/02/03/no-panic-rust.html">well-known “linker hack”</a>
which allows static enforcement over panic propagation
in optimized builds.</p>
<p>Swift, Pony, Zig, Roc and Odin do not have native support for any exception-like mechanism,
and require explicit propagation of errors (or crashing the program).</p>
<p>Rust, Swift and Zig have dedicated syntax for explicit error propagation.</p>
<ul>
<li>Rust has a post-fix <code>?</code> operator for short-circuiting control flow;
this is primarily used for error propagation.
Rust has an unstable feature <a href="https://doc.rust-lang.org/beta/unstable-book/language-features/try-blocks.html"><code>try_blocks</code></a>
to limit the scope of <code>?</code>.</li>
<li>Swift has a prefix <code>try</code> keyword which will bubble any errors
out of the enclosing function. This works at the level of
individual statements as well as sub-expressions.
Swift also supports <code>try?</code> for converting an error to <code>nil</code>
(an <code>Optional</code>), as well as <code>try!</code> for triggering a program crash
on encountering an error.</li>
<li>Zig has the <code>catch</code> and <code>try</code> keywords as explained earlier.</li>
</ul>
<p>Haskell’s <code>do</code> notation also provides similar functionality,
but it can require additional boilerplate depending on way effects
are being propagated (e.g. using effect types or monad transformers).</p>
<p>Some languages have on-going or recent work in a similar vein:</p>
<ul>
<li>Go has a <a href="https://github.com/golang/go/discussions/71460">on-going proposal</a>
for dedicated postfix <code>?</code> sugar for error propagation.
Apart from the sugar, programmers are recommended
to explicitly attach context to errors using
various standard library functions.</li>
<li>The OCaml docs note the trend towards increased use of explicit propagation.
The OCaml standard library also offers more APIs now with explicit errors.</li>
<li>OCaml’s sugar for error propagation helps in writing complex
logic without needing repeated explicit pattern matching.</li>
<li>C++23 added support for <code>std::expected</code>, analogous to Result in other languages.</li>
</ul>
<p>Error propagation in Everr is in some sense a blend of existing languages:</p>
<ul>
<li>It is flexible in allowing <code>try</code> in different places, like Swift.</li>
<li>It offers a third choice between function-wise propagation and
program termination, similar to exceptions.</li>
<li>It allows marking code as “cannot panic” like C++’s <code>noexcept</code>.</li>
</ul>
<p>Additionally, panicking being a capability, and capabilities supporting
different levels means that different levels of rigor can be used in
different contexts.</p>
<h3 id="error-propagation---primitive-operations">Error propagation - Primitive operations</h3>
<p>For overflow errors in integer operations, languages that tend
to offer control do so in the form of compiler flags and
standard library APIs rather than dedicated syntax.</p>
<p>Most languages use wrapping semantics for integer overflow,
with alternate semantics provided through standard library functions,
built-ins and/or types, if at all.</p>
<p>Some notable exceptions:</p>
<ul>
<li>Swift and Roc trigger a crash on overflow.</li>
<li>Rust triggers a panic on overflow in debug mode. This can be overriden
using compiler flags.</li>
<li>C++ treats signed integer overflow as undefined behavior – this can
be overriden to wrapping/trapping semantics using compiler flags.</li>
<li>In Zig, integer overflow triggers:
<ul>
<li>Undefined behavior in the <code>ReleaseFast</code> and <code>ReleaseSmall</code> build modes.</li>
<li>A panic in the <code>Debug</code> and <code>ReleaseSafe</code> build modes
(i.e. crash by default, but overridable).</li>
</ul></li>
</ul>
<p>Everr is somewhere between Swift and Rust in some sense;
it always triggers a panic, regardless of build mode.</p>
<hr/>
<p>For heap allocation, most languages do not offer any reasonable
way of dealing with heap exhaustion apart from program termination.<span><label for="sn-34"></label><span>I recognize that on a shared system, the operating system is free to kill a process for consuming too much memory, and how much memory is “too much” can only be determined dynamically. However, at least in some contexts, such as servers, one often knows the amount of memory available at build time or program initialization time.</span></span></p>
<p>Zig and Odin are different from other languages here; allocators
are passed down ~everywhere as parameters (explicitly in Zig, and often
implicitly in Odin using the hidden <code>context</code> parameter).
This allows handling allocation failure at various levels.<span><label for="sn-35"></label><span>It would be interesting to examine what fraction of applications written in Zig and Odin actually have code paths for dedicated handling for out-of-memory errors, instead of just propagating it up the call stack and terminating the program. It would also be interesting to know what sub-fraction of that group has tests for the out-of-memory error handling code path, and how good that test coverage is.</span></span></p>
<p>Zig and Odin do not have any standard source-level markers for code
that is known to be memory safe vs code that is not.</p>
<p>Such discipline is possible in C++, Rust and other languages
to varying extents, but is less common.</p>
<ul>
<li>C++ standard types such as <code>std::string</code> and <code>std::vector</code> take
an optional type parameter for customizing the allocator.</li>
<li>Rust has an <a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html">unstable allocator_api</a> feature,
where the discussion <a href="https://github.com/rust-lang/rust/issues/32838">originally started in 2016</a>.
Rust also has a competing <a href="https://internals.rust-lang.org/t/pre-rfc-storage-api/18822">storage API</a>
proposal.</li>
</ul>
<p>Ada is somewhat unusual in that it allows returning
dynamically sized data through a secondary stack,
which can avoid the need for heap allocation in certain cases.</p>
<p>Older languages using tracing GCs have evolved to have features
which make it easier to write code free of heap allocations.
Unboxed types are now available to varying extents in Java,
C#, Haskell, OCaml etc.</p>
<p>Since I have not specified neither the memory management strategy
nor the type system for Everr, it doesn’t make sense to perform
a comparison of Everr with other languages for this particular point.</p>
<p>I believe Rust’s current approach of requiring you to use different
collection types
(e.g. <code>Vec</code>, <a href="https://docs.rs/bumpalo/latest/bumpalo/collections/vec/struct.Vec.html"><code>bumpalo::Vec</code></a>,
<a href="https://docs.rs/smallvec/latest/smallvec/struct.SmallVec.html"><code>smallvec::SmallVec</code></a>)
provides an OK sweet spot by putting the complexity
of dealing with different memory management strategies
onto users which need them, rather than on everyone.</p>
<p>See Appendix A4 for more details on some
interesting research in this space.</p>
<hr/>
<p>I do not know of any non-research language which can statically
guarantee the absence of stack overflow.</p>
<p>The GNAT compiler for Ada supports
<a href="https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_and_program_execution.html#static-stack-usage-analysis">static stack usage analysis</a>,
which allows gathering stack usage data.
Based on some searching, it is not clear if SPARK
can statically guarantee the absence of stack overflow.</p>
<p>Technically, one can employ techniques such as dynamic stack probing,
and then growing the stack using the heap
if it’s likely that one might need more space.
This approach is taken by the Rust <a href="https://github.com/rust-lang/stacker">stacker</a> crate.</p>
<p>Using the capability mechanism, by marking recursion
and indirect calls as capabilities, Everr can reduce
the risk of stack overflow, likely significantly so.
Similar to Ada, an Everr compiler can thus provide
concrete upper bounds on stack usage for functions
where these capabilities are turned off or not used.</p>
<p>See Appendix A5 for one potential idea on how a language
can rule out stack overflow statically while maintaining modularity.</p>

<p>Strictly speaking, structured metadata attachment, error combination and erasure
can be achieved in any mainstream language,
the question is really about how much boilerplate is needed.</p>
<p>For structured metadata attachment, in a language without inheritance,
adding more data to a type requires:</p>
<ol type="1">
<li>Duplicating the original type definition.</li>
<li>Updating the duplicate type definition to add a new field (or case).</li>
<li>Writing a conversion function from the old type to the new type.</li>
</ol>
<p>Depending on which type-aware compile-time metaprogramming facilities are available,
it should be possible to cut down on boilerplate for these kinds of operations
significantly. Languages such as Zig and Nim fall into this bucket.</p>
<p>When using metaprogramming for extending the types, programmers may
encounter difficulties in debugging metaprograms.
Metaprogramming also poses language design challenges by
requiring a clear design for how metaprograms interact with abstraction boundaries.
For example:</p>
<ul>
<li>Are private fields possible? As of Mar 2025, <a href="https://github.com/ziglang/zig/issues/9909">Zig says no</a> whereas Nim says yes.</li>
<li>If private fields are possible, is the metaprogram allowed to inspect private fields?
<ul>
<li>If the metaprogram can inspect private fields, how can the owner of the type definition
retain the ability to remove the private field?</li>
<li>If the metaprogram cannot inspect private fields, then how can it duplicate a type definition?</li>
</ul></li>
</ul>
<p>In theory, support for extensible records (similar to TypeScript and Elm) would
solve this problem cleanly. However, naively using structural extensible records
introduces compatibility hazards across library boundaries,
requires exposing the full structure
in type signatures (against encapsulation),
and increases type system complexity.</p>
<p>In Everr, you can “extend” a sum type defined in an upstream context such as:</p>
<pre><code>@exhaustive
enum ImageProcessingError {
    | DownloadingError { ... }
    | ProcessingError { ... }
    | StoringError { dbError: PgError }
      // Suppose &#39;PgError&#39; represents a Postgres error which is a complex
      // data type with many fields and methods
}</code></pre>
<p>by defining a new type with specific information of interest:</p>
<pre><code>@exhaustive
struct DetailedStoringError {
    @delegate
    base: ImageProcessingError.StoringError,
    dbName: Str,
    dbURL: URL,
}</code></pre>
<p>and creating a replacement for the outer enum type:</p>
<pre><code>@exhaustive
enum DetailedImageProcessingError {
    | type ImageProcessingError.DownloadingError
    | type ImageProcessingError.ProcessingError
    | type DetailedStoringError
}</code></pre>
<p>this still requires duplicating the cases from the full <code>enum</code> definition,
but not any inline fields specified in it.<span><label for="sn-36"></label><span>Remapping the shared cases
still needs to be done “by hand” in a separate function or relying
on implicit injection from <code>T</code> to <code>A:union[.T | ...]</code>.</span></span></p>
<p>This relies on:</p>
<ul>
<li>The ability to share case types across enums.</li>
<li>The delegation mechanism to avoid duplicating the type definition
as well as explicit forwarding of methods.</li>
</ul>
<p>In languages with support for both union types and delegation
(e.g. via inheritance), such as Scala and Pony,
the same could be achieved with similar or less boilerplate.</p>
<p>Everr’s modeling can be copied over exactly to Odin,
because its tagged unions build on top of structs,
and it <a href="https://odin-lang.org/docs/overview/#using-statement-with-structs">supports delegation</a>.</p>
<p>In a language with sum types but without first-class enum case types
(e.g. Rust, Swift etc.) this requires making sure that you’re
defining dedicated structs for each enum case instead of
defining fields inline.</p>
<p>One way to get a fully static native solution with minimal boilerplate
would be to add support for defining new types using “diffs” from existing types.
While this would be independently useful
(e.g. simultaneously supporting multiple versions of a data format or API),
this introduces more complexities of its own,
and so I’ve chosen to omit that from this presentation.
For a sketch of how that could look like, and the complexities
such a system would have to deal with, see <a href="#appendix-a6-defining-new-types-using-diffs">Appendix A6</a>.</p>
<h3 id="error-handling">Error handling</h3>
<p>Error handling has four sub-criteria: exhaustiveness checking,
structured metadata extraction, error projection, and unerasure.</p>
<p>The latter three essentially amount to specific library calls
and support for field projection and method call syntax, which
are supported by ~most languages nowadays, including languages
which don’t identify themselves as “object-oriented”.</p>
<p>For exhaustiveness checking, most newer languages support it
in some form. The flexibility of pattern matching syntax
(or “switching” syntax) varies heavily based on language.
Depending on the language, the following features
may have varying levels of support:</p>
<ul>
<li>Nested patterns</li>
<li>Or patterns</li>
<li>Pattern guards (i.e. using arbitrary functions in a branch)</li>
</ul>
<p>Everr’s use of the the <a href="https://dl.acm.org/doi/10.1145/3689746">Ultimate Conditional Syntax</a> generalizes
all of these mechanisms, as well as allows more compact expression
of pattern matching by:</p>
<ul>
<li>Reducing the need for explicit temporaries by supporting “splits”</li>
<li>Allowing immediate inline use of bindings following <code>and</code>, without nesting,
generalizing <code>if let</code> style bindings in Rust and Swift.</li>
</ul>
<h3 id="error-conventions">Error conventions</h3>
<blockquote>
<p>Software development can be reduced to a single, iterative action. Almost everything we do in the course of a day — the pull requests, the meetings, the whiteboard diagrams, the hallway conversations — is an explanation. Our job is to explain, over and over, the meaning of our software: what it is, and what we expect it to become.</p>
<p>– Zach Tellman, <a href="https://explaining.software/archive/the-anatomy-of-an-explanation/">Explaining Software</a></p>
</blockquote>
<p>Language documentation generally takes a <em>descriptive</em> position on
error handling, describing all the different ways in which
error handling can be done, but avoids being prescriptive.</p>
<p>This means that projects often tend to follow either
(1) the path the standard library does OR
(2) the path which requires the least boilerplate.
Sometimes, these are the same.</p>
<p>The responsibility of <em>prescribing</em> error conventions for different
situations is generally left to style guides, managed by third parties.</p>
<p>Here’s a short, non-exhaustive list of plausible reasons for this phenomenon:</p>
<ul>
<li>Prescribing approaches is perceived to be “messy” as it requires deeply
understanding and taking into account many different contexts of usage.</li>
<li>Consensus building is both time-consuming and challenging, requiring
strong communication skills and high emotional energy.</li>
<li>Writing documentation is generally under-valued in practice compared
to programming. For example, language release notes typically mention
new features and APIs, not new docs.</li>
</ul>
<p>As ecosystems evolve over time, introducing conventions later in time
is more likely to face opposition, unless these conventions simply
codify existing practices as “best practice.”
This can be true even when evidence is presented in favor of newer conventions,
due to various <a href="https://en.wikipedia.org/wiki/Category:Cognitive_biases">cognitive biases</a>.</p>
<p>I belie
ve there is much more room for languages to provide clearer guidance
on appropriate contexts for using specific ways of defining, propagating
and handling errors.</p>
<p>I further believe that it is valuable to provide prescriptive guidance
earlier in a language’s lifespan than is common,
and to encourage thinking about guidance as an evolving artifact
grounded in evidence. For example, guidance can be accompanied by
short summaries of past evidence showing positive/zero/negative results
in relation to the guidance,
as well as explicit invitations for collecting further evidence.</p>
<h3 id="tooling">Tooling</h3>
<p>In principle, given sufficient resources, almost any kind of tooling can be
built for any language. The problem is that in practice,
“resources” are generally never “sufficient”, so it makes
sense to try to make it as easy as possible to build correct tools.</p>
<p>For this specific point,
I believe the Go ecosystem is a good example,<span><label for="sn-37"></label><span>Perhaps the point about “necessity is the mother of invention” applies here? From what I’ve heard, Java has excellent tools for heap profiling, whereas tooling for languages like Rust and C++ is much more lacking in comparison.</span></span>
where even though several bits of functionality considered
table-stakes in other ecosystems – such as exhaustiveness checking
– are not natively supported by the Go compiler,
it is easy to <a href="https://github.com/nishanths/exhaustive">create new linters</a>,
and then <a href="https://github.com/golangci/golangci-lint">integrate them with other linters</a>
and <a href="https://github.com/bazel-contrib/rules_go/blob/master/go/nogo.rst">build systems like Bazel</a>.</p>
<p>Standardizing on error propagation mechanisms in particular
across an ecosystem can also help motivate investment into
deterministic refactorings for simplifying repetitive tasks.
For example, in Everr, the language server could offer a refactoring
to attach metadata to an error by handling the boilerplate
of defining new error types etc.</p>
<hr/>
<p>That’s the end of the comparison between the error models of
Everr and that of other languages.</p>
<p>While many languages offer different mechanisms for defining, propagating
and handling errors, there is not a language which is “strictly superior”
than the other ones along all of these axes.</p>
<p>I believe a design similar to that of Everr can potentially help
programmers express the different possibilities of error cases,
and how to handle them,
in a way that matches or improves upon most languages along most axes,
while preserving the ability to maintain code over long periods of time.</p>
<p>The next section is more philosophical than all the ones so far,
so if that’s not your cup of tea, you can stop reading here, no judgement. 😆</p>
<h2 id="section-7-closing-thoughts">Section 7: Closing thoughts</h2>
<p>In this section, I want to do something a bit different.
Before sharing my own thoughts, let me ask you some questions.</p>
<h3 id="questions-for-you">Questions for you</h3>
<p>Programmers accustomed to statically typed programming languages
are likely to raise an eyebrow if they encounter a codebase in the
same language where all functions return <code>Any</code> (or equivalent) upon success.</p>
<p>And yet, the use of untyped errors along with need for down-casting is widespread across languages.
For example, in Rust, a common recommendation is to use the <code>anyhow</code> crate in applications,
and in Go, functions which may fail return an <code>error</code> interface in the vast majority of cases.</p>
<p>Q: Why do you think this discrepancy exists?</p>
<hr/>
<p>Much of the discourse around what consists of “good code” often avoids any detailed discussion of errors altogether. For example, in <em>A Philosophy of Software Design</em>,<span><label for="sn-38"></label><span>I’m discussing an example from <em>A Philosophy of Software Design</em> here because I’ve seen it widely recommended on forums such as Hacker News and Lobsters.</span></span> John Ousterhout writes:</p>
<blockquote>
<p>A module’s interface represents the complexity that the module imposes on the rest of the system: the smaller and simpler the interface, the less complexity that it introduces. [..]</p>
<p>The mechanism for file I/O provided by the Unix operating system and its descendants, such as Linux, is a beautiful example of a deep interface. There are only five basic system calls for I/O, with simple signatures:</p>
<pre><code>int open(const char *path, int flags, mode_t permissions);
ssize_t read(int fd, const void* buffer, size_t count);
ssize_t write(int fd, const void* buffer, size_t count);
off_t lseek(int fd, off_t offset, int referencePosition);
int close(int fd);</code></pre>
<p>[..] A modern implementation of the Unix I/O interface requires hundreds of thousands
of lines of code, which address complex issues [..] Deep modules such as Unix I/O
and garbage collectors provide powerful abstractions because they are easy to use,
yet they hide significant implementation complexity.</p>
<p>[..] If an interface has many features, but most developers only need to be
aware of a few of them, the effective complexity of that interface is just
the complexity of the commonly used features.</p>
</blockquote>
<p>One of the elephants in the room<span><label for="sn-39"></label><span>I have a deeper critique of the Unix file I/O API, but there is not enough space in this margin to write it. I may write a more detailed review of Ousterhout’s book some time later this year.</span></span> that Ousterhout ignores here is errors.
Let’s just consider <code>open</code>. If you look at man7.org, <code>open</code> can have the following different
error cases:</p>
<pre><code>EACCES, EBADF, EBUSY, EDQUOT,
EEXIST, EFAULT, EFBUBG, EINTR,
EINVAL, EISDIR, ELOOP, EMFILE,
ENAMETOOLONG, ENFILE, ENODEV, ENOENT,
ENOMEM, ENOSPC, ENOTDIR, ENXIO,
EOPNOTSUPP, EOVERFLOW, EPERM, EROFS,
ETXTBUSY, EWOULDBLOCK</code></pre>
<p>That’s 26 different error cases. Out of these, let’s look at when <code>EACCES</code> can be hit:</p>
<blockquote>
<p>The requested access to the file is not allowed, or search
permission is denied for one of the directories in the path
prefix of pathname, or the file did not exist yet and write
access to the parent directory is not allowed. (See also path_resolution(7).)</p>
<p>Where O_CREAT is specified, the <code>protected_fifos</code> or
<code>protected_regular sysctl</code> is enabled, the file already
exists and is a FIFO or regular file, the owner of the file
is neither the current user nor the owner of the containing
directory, and the containing directory is both world- or
group-writable and sticky. For details, see the
descriptions of <code>/proc/sys/fs/protected_fifos</code> and
<code>/proc/sys/fs/protected_regular</code> in <code>proc_sys_fs(5)</code>.</p>
</blockquote>
<p>If a kernel needs to return an <code>EACCES</code> error for any of these problems, it must detect them. Which means, at the time of detecting the error, it must have some contextual information about what failed. However, because of the API signature, the kernel cannot return this information to the caller. This means that either the kernel and caller need to separately cooperate on having a “side channel” for passing extra metadata, or the kernel can just drop the information.</p>
<p>Q: Have you ever hit an <code>EACCES</code> error when opening a file? What did you do to debug it the first time you hit it? What if you could go back to your past self, in the middle of debugging this for the first time, and tell them that a well-regarded book called <em>A Philosophy of Software Design</em> considers that as a “beautiful example of a deep API”, what do you think your past self’s reaction would be? How much does that matter?</p>
<h3 id="the-aesthetics-and-pragmatics-of-pl-design">The aesthetics and pragmatics of PL design</h3>
<blockquote>
<p>There are five essential components to learning a language:</p>
<ul>
<li>Syntax: [..]</li>
<li>Semantics: By semantics, we mean the rules that define the behavior of programs. [..] The dynamic semantics define the run-time behavior of a program as it is executed or evaluated. The static semantics define the compile-time checking that is done to ensure that a program is legal, beyond any syntactic requirements. The most important kind of static semantics is probably type checking: the rules that define whether a program is well typed or not.</li>
<li>Idioms: [..]</li>
<li>Libraries: [..]</li>
<li>Tools: [..]</li>
</ul>
<p>– Cornell CS 3110 <a href="https://www.cs.cornell.edu/courses/cs3110/2018sp/l/02-fun/notes.html">program course notes</a></p>
</blockquote>
<p>In some sense, program semantics has a sense of timelessness – they talk about <em>a program</em> and <em>a semantics</em>. But our programs (and their semantics) do change over time!</p>
<p>This leads to two different notions, which I’m going to call <em>evolution semantics</em> and <em>migration semantics</em> respectively.<span><label for="sn-40"></label><span>I believe there are no standard terms for these in the literature but happy to be corrected!</span></span> Here are some loose definitions:</p>
<ul>
<li><p>Evolution semantics: This covers the <em>interoperability</em> (or lack thereof) between program fragments and their static semantics as they evolve over time (e.g. as different versions). Some examples of work which would fall in this bucket:</p>
<ul>
<li><a href="https://github.com/obi1kenobi/cargo-semver-checks">cargo-semver-checks</a> which programmatically analyzes Rust crates for SemVer violations.</li>
<li><a href="https://github.com/swiftlang/swift/blob/main/docs/LibraryEvolution.rst">Swift’s Library Evolution feature</a>.</li>
<li><a href="https://research.swtch.com/vgo">Russ Cox’s writing on Go &amp; versioning</a>.</li>
</ul></li>
<li><p>Migration semantics: This covers the <em>interoperation</em> (or lack thereof) of running program fragments and their dynamic semantics as they evolve over time (e.g. as different versions). Some examples of work which would fall in this bucket:</p>
<ul>
<li>Various SQL constructs such as <a href="https://www.postgresql.org/docs/current/sql-altertable.html">ALTER TABLE</a>, and more generally, database migrations.</li>
<li>Debuggers which allow modification of control flow and/or data.</li>
<li>Hot reloading functionality found in many game and UI frameworks, and natively supported in Erlang.</li>
</ul></li>
</ul>
<p>I believe both of these areas are worth studying in their own right,
because reasoning about time is hard,
but reasoning about programs and their data over time
is increasingly important as our codebases and databases
grow older and larger.</p>
<p>“That’s all well and good,” you say, “but what does time have to do with error models?”
Please hold that thought for a moment.</p>
<hr/>
<p>Perhaps while you’ve been reading this post, you might’ve had
the reaction that there is something unaesthetic, perhaps deeply so, about
Everr’s choice to make product types first-class and sum types second-class.</p>
<p>On the other hand, you might think of ML family languages as being more aesthetic,
putting sum types and product types on equal footing, mostly.<span><label for="sn-41"></label><span>I have to say “mostly” because a purist version of this would prevent inline record syntax for the cases of a sum type, such as in <a href="https://ocaml.org/manual/4.11/inlinerecords.html">pre-4.03 OCaml</a>.</span></span></p>
<p>I get that. To be honest, I had a similar reaction
when I first read about Cap’n Proto’s decision
to make records first-class and (tagged) union types second-class
(🧠: “Surely, there has to be a better way!”).
I also had a similar reaction when I first learnt
about the support for <code>IF EXISTS</code> in various SQL DDL
commands (🧠: “You can’t just extend syntax in ad-hoc ways like that!
That doesn’t seem orthogonal to other features!”).</p>
<p>There’s also something unaesthetic about having
implicit projection for a special field name <code>case</code>
(🧠: “Why should one field name be privileged over others!”).</p>
<p>The bounded union type syntax also has an unaesthetic quality
(🧠: “The presence of the type name ruins the symmetry present in typical union type syntax!”).
If we accept the frame of “programmers should be able to
read/write Everr code in their favourite editing environments,
which have text editing at the heart” as a premise,
then there needs to be some way of representing type syntax using ASCII characters,
and I do not have the audacity to suggest
that programmers write something like:</p>
<pre><code>       Dessert
 /----- union -----\
  .Cake | .IceCream</code></pre>
<p>Each of these decisions fulfills specific needs,
but many of them <em>still feel weird</em>,
perhaps with the exception of the Ultimate Conditional Syntax
(which I take zero credit for, because I literally just copied it from a paper).</p>
<p>Perhaps moreso than these individual decisions, you might’ve felt
an overall unaesthetic quality about the <em>kind of reasoning</em> used
throughout this post. Much of the reasoning is by case analysis,
instead of using induction or by providing a handful of core primitives
and combining them in elegant ways to address every challenge posed.</p>
<p>Everr’s language design itself reflects a pattern of accreting up and sanding down,
more like seeing an igloo or a sand castle being built over time,
and less like walking into a museum and having a Michelangelo sculpture come into view.</p>
<p>Can an igloo built by a novice be as beautiful as a Michelangelo sculpture?
Does the answer to that depend on whether you’re looking for shelter from an on-going blizzard?</p>
<hr/>
<p>I believe the “lumpiness” in the landscape of computing –
be it heterogeneity in hardware,
the variations in the lifecycles of packages and the
interpersonal dynamics of package maintainers,
or all the “weird error cases” which defy easy classification
– is a omnipresent backdrop for the design for general-purpose PLs.</p>
<p>Which parts of this lumpy backdrop should be treated as a canvas to paint on
and which parts should be treated as something to be smoothened over
– that is a question of both one’s emotions and one’s values.</p>
<p>If we would like to paint certain parts of this canvas that are high up in the clouds,
and time is of the essence, perhaps, we need to be willing to stand on the shoulders
of Giants rather than insisting on climbing our way up all by ourselves.
Perhaps, it makes sense to befriend as many Giants as possible and try to cajole them into forming a Giant pyramid<span><label for="sn-42"></label><span>Grammar note: A Giant pyramid is necessarily a giant pyramid, because Giants are giant by definition, but a giant pyramid may not be a Giant pyramid, because it may be made of many individually small objects.</span></span> we can climb on.</p>
<p>Two such Giants which I believe are under-utilized in PL design today are:</p>
<ul>
<li>Special-purpose languages such as Cap’n Proto, where the design involves a fair number of considerations around time and evolution.</li>
<li>Tools which can help us formally reason about complex systems, such as:
<ul>
<li>Model checkers such as Alloy and TLA+. In particular, my initial experiments with Alloy makes me believe that Alloy can help with <a href="https://x.com/typesanitizer/status/1551575106194878464">modeling complex relationships across packages</a>, and potentially across time, without writing code.</li>
<li>Proof assistants.</li>
<li>Special-purpose tools such as <a href="https://www.ccs.neu.edu/home/stchang/pubs/cbtb-popl2020.pdf">Turnstile(+)</a> for type-checking and <a href="https://github.com/herd/herdtools7/">herdtools</a> for memory models.</li>
</ul></li>
</ul>
<p>While many of these tools are academic in origin, and thus have a steep usability curve, I think there is value in exploring them, as well as coming up with more user-friendly versions of them.</p>
<p>If you want to start somewhere and have a design problem, I think Alloy is likely a good place to start. Its syntax is easy to understand, and it comes with a visualizer out-of-the-box. You can also save the raw XML for counter-examples somewhere and visualize it using your own code.</p>
<p>Zooming back in to errors specifically, we now arrive at the final question.</p>
<h3 id="what-are-we-to-do">What are we to do?</h3>
<blockquote>
<p>All happy families are alike; each unhappy family is unhappy in its own way.</p>
<p>– Leo Tolstoy, Anna Karenina</p>
</blockquote>
<p>Pithy statements such as “only use exceptions for exceptional cases”
or <a href="https://wiki.c2.com/?LetItCrash">Let it crash</a>,
while catchy, do not do justice to the complexities
that programmers need to deal with when deciding how
to define, propagate, handle and reason about errors.</p>
<p>The fundamental nature of errors is that they are often multi-faceted,
and complex to reason about by virtue of being multi-faceted.
The wide variety of socio-technical contexts that software is created,
delivered and used in add further complexity.</p>
<p>It is important that we are able to reason about how software works,
but also about how it doesn’t quite work.
Reasoning enables better decision-making when we’re making a choice
on whether we should tweak, fix, disable or delete the software,
or maybe even just keep it as-is.</p>
<p>If we are to reason about and debug software
when it doesn’t work as expected,
our languages must empower us to do so.
While a programming language cannot magically help
fix all software issues at any scale,
I believe they can help move the needle,
by changing the often-implicit frame of reference
about how we think about errors.</p>
<p>I believe that it behooves us as an industry
to try to move the needle,
as increasingly more parts of the world
rely on software working correctly.</p>
<h2 id="appendix">Appendix</h2>
<h3 id="appendix-a1-everr-type-system-discussion">Appendix A1: Everr type system discussion</h3>
<p>Everr’s enums are closer to Scala’s case classes
rather than enums/sum types in languages like Rust, Swift,
Haskell and OCaml.</p>
<p>Similar to union types in other languages like Scala, Pony and TypeScript,
Everr’s union types (both the exhaustive and non-exhaustive variants)
satisfy commutativity, associativity and idempotence.
Additionally, an exhaustive union type is a subtype of the corresponding
non-exhaustive union type.</p>
<p>However, unlike Scala, Pony and TypeScript, Everr’s union types are more limited.
The elements of the union with a certain top type must either be:</p>
<ul>
<li>Base case: A type representing a case of the top type.</li>
<li>Recursive case: Another union type with the same top type
(interpreted via coalescing cases).</li>
</ul>
<p>Since Everr has no universal top type, arbitrary types cannot be unioned
together. This allows for an efficient run-time representation
(the same as enums) without needing whole-program analysis or a JIT,
while still providing the benefits of being able to deal with arbitrary subsets.</p>
<hr/>
<p>Everr’s choice of making enum cases first-class and enums themselves second-class
is distinct from Rust’s proposed <a href="https://github.com/rust-lang/lang-team/issues/122">enum variant types</a>,
where enums continue to stay first-class but enum cases have second-class status.</p>
<p>Here are the major differences:</p>
<ul>
<li>In Everr, enum cases can separately carry type parameters, but Rust’s
enum variant types cannot.</li>
<li>In Everr, enum cases can separately implement different traits,
but Rust’s enum variant types cannot.</li>
<li>Going from an individual case type to the enum type requires attaching
a tag in Everr (but the <code>T:union[]</code> form shares the same layout as the enum).
In Rust, the enum variant type shares the same layout as the enum.</li>
<li>Everr supports arbitrary subsets of cases;
the initial Rust proposal does not support this. However, adding this would
be compatible with the Rust proposal.</li>
<li>Everr’s design allows composition of cases across enums, but Rust does not.</li>
</ul>
<hr/>
<p>Everr’s delegation mechanism is similar to inheritance,
but without any association with subtyping,
and correspondingly there is no notion of up-casting or down-casting.</p>
<p>Imperative languages such as Go and Rust provide similar
functionality using different techniques: Go has <a href="https://gobyexample.com/struct-embedding">struct embedding</a>, and Rust has <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-coercion">Deref coercions</a>.</p>
<h3 id="appendix-a2-niche-optimizations-with-second-class-enums">Appendix A2: Niche optimizations with second-class enums</h3>
<p>Rust can do type layout optimization (also called “niche optimization”) by
considering excluded states. For example, the type: <code>Option&lt;NonZeroU8&gt;</code>
will take 8 bits, because the 0 state is reused by <code>None</code>.</p>
<p>In Everr, going from a type <code>MyEnum.MyCase</code> to <code>MyEnum:union[.MyCase]</code>
with zero or more other cases requires the compiler to generate
a function which attaches the corresponding enum tag.
For the <code>Optional</code> type discussed, one needs two such functions
for the two different cases, which will have the following signatures:</p>
<pre><code>fn _none_to_union[A](v: Optional.None) -&gt; Optional[A]:union[.None] {
    // implementation elided
}

fn _some_to_union[A](v: Optional.Some[A]) -&gt; Optional[A]:union[.Some[A]] {
    // implementation elided
}</code></pre>
<p>Since the generation of these functions is entirely under the compiler’s
control, it is possible for the compiler to directly generate specialized
versions of these functions for different types with different niches
during monomorphization, instead of attempting to generate one version.</p>
<p>This means that when a compiler sees an implicit conversion<span><label for="sn-43"></label><span>This is syntax-directed implicit conversion rather than being a subtyping rule, because it requires a change to the run-time representation. If it were a subtyping rule, and Everr were to support covariant and contravariant type parameters, that would require potentially-arbitrarily-expensive bridging conversions, <a href="https://forums.swift.org/t/generalization-of-implicit-conversions/51344">like Swift</a>.</span></span> from
<code>None</code> to <code>Optional[A]:union[.None]</code>, it can specialize the conversion
based on what <code>A</code> is instantiated to.</p>
<h3 id="appendix-a3-hare-type-system-discussion">Appendix A3: Hare type system discussion</h3>
<p>The Hare docs state that tagged union types are “commutative, associative, and reductive”
and that “the order of types, inclusion of the same type more than once,
or use of nested tagged unions has no effect on the final type.”</p>
<p>So Hare’s tagged unions implement <em>union types</em> in the type-theoretic sense,
not sum types, unlike most other languages with tagged unions.
<a href="https://harelang.org/documentation/faq.html#why-doesn-t-hare-have-generics">Hare does not support parametric polymorphism</a>,
so the choice to implement union type semantics via tagged unions:</p>
<ul>
<li>Offers a high degree of flexibility, like Scala, Pony and TypeScript,
by not requiring upper bounds (unlike Everr)
and allowing the union of arbitrary types (unlike Everr).</li>
<li>Does not require a uniform representation,
like Everr but unlike Scala, Pony and TypeScript.</li>
<li>Does not increase type system complexity significantly, because
there is no need for subtyping rules involving type inference
and polymorphism.</li>
</ul>
<h3 id="appendix-a4-safe-and-modular-memory-management">Appendix A4: Safe and modular memory management</h3>
<p>The research work on Verona has surfaced one potential direction
<a href="https://dl.acm.org/doi/pdf/10.1145/3622846">Reference Capabilities for Flexible Memory Management</a>:</p>
<blockquote>
<p>Verona is a concurrent object-oriented programming language
that organises all the objects in a program
into a forest of isolated regions.
Memory is managed locally for each region,
so programmers can control a program’s memory use by
adjusting objects’ partition into regions,
and by setting each region’s memory management strategy.</p>
</blockquote>
<p>The overall type system is more flexible than Rust’s in some ways,
but if you look closely, the paper points out that
field accesses may throw an exception if the region
corresponding to the field is already open. If I understand
correctly, this is similar to Rust’s <code>Cell</code> type which
does dynamic borrow-checking.</p>
<blockquote>
<p>Entering a region borrows and/or buries the variable
or field referencing the bridge object.
In the case of a stack variable,
the variable is buried to prevent the region from being multiply opened</p>
<p>In the case of a field, we instead resort to a dynamic check of the region’s state.</p>
</blockquote>
<p>I have not been able to absorb the paper deeply,
but such a design seems potentially concerning.</p>
<p>Technically, this could be replaced with a more local form of
returning an error, but it’s unclear how widespread the need
for this would be in typical programs.</p>
<h3 id="appendix-a5-modular-static-analysis-for-stack-usage">Appendix A5: Modular static analysis for stack usage</h3>
<p>I believe it should be possible to support modular static analysis
for controlling stack usage without requiring eliminating indirect calls,
which can be useful with basic operations like <code>map</code>, <code>filter</code> etc.</p>
<p>The problem with an indirect call is that the stack usage for it will
be unknown. So the most direct “fix” is to equip calls with stack usage information.</p>
<p>Specifically, function types could be equipped with two kinds of stack usage budgets:</p>
<ul>
<li>Self budget: The maximum memory the function is allowed to use for temporaries.</li>
<li>Calls budget: The maximum stack usage for calls inside the function.</li>
</ul>
<p>When a function body is lowered to an IR
which makes temporaries explicit,
after some set of relatively stable baseline optimizations
(e.g. sparse conditional constant propagation and copy propagation, but no inlining),
a compiler can check the following:</p>
<ul>
<li>Does the self budget exceed the sum of stack usage for all temporaries assuming
no lifetime contraction/further optimization.</li>
<li>Does the calls budget exceed the total stack usage budget for each called function
(these calls may be indirect)</li>
</ul>
<p>Finally, after inlining and other optimizations but before generating assembly,
one could perform a validation check only for the total budget
(but not for the self and calls budgets, because of inlining).</p>
<p>In such a system, if you annotate <code>main</code> with a stack budget,
then you’d essentially trigger errors for each function call inside <code>main</code>
and so on until you’ve added stack budgets
for every function in the call graph.
Yes, this would necessitate writing your own
stack usage aware minimal standard library.</p>
<p>I believe such a system should be “workable” in practice in the limited
sense that compiler optimizations typically do not increase stack usage
of call trees, and the number of temporaries generally goes down
as the optimization crank is turned more. So I suspect that the final
validation check should fail not too often.</p>
<hr/>
<p>Depending on the desired properties about where errors should be handled
(e.g. is it OK to emit errors after monomorphization?),
and which language features need to be supported in concert with stack budgets
(e.g. is it OK to only allow setting budgets on monomorphic functions?), one could:</p>
<ul>
<li>Potentially have the budget checks run on a polymorphic IR instead of
the post-monomorphization IR</li>
<li>Allow the budget to not just be an integer, but a more general expression,
allowing references to stack budgets of parameters, some basic numeric operations
like <code>+</code> etc.</li>
</ul>
<hr/>
<p>I suspect that it’s not really possible to have a much simpler solution than
what I’ve described above <em>unless</em> one is willing to give up on (1) modularity
or (2) move the check to be dynamic.</p>
<p>Of course, one might ask: is this much complexity worth it “just” for statically
preventing stack overflows in a modular fashion?</p>
<p>For that, the answer is I don’t know.
If we believe existing languages,
the answer seems to largely be No.</p>
<h3 id="appendix-a6-defining-new-types-using-diffs">Appendix A6: Defining new types using diffs</h3>
<p>Say Everr supported type diffs. This could help reduce the boilerplate
involved in extending a type defined upstream from:</p>
<pre><code>@exhaustive
struct DetailedStoringError {
    @delegate
    base: ImageProcessingError.StoringError,
    dbName: Str,
    dbURL: URL,
}

@exhaustive
enum DetailedImageProcessingError {
    | type ImageProcessingError.DownloadingError
    | type ImageProcessingError.ProcessingError
    | type DetailedStoringError
}</code></pre>
<p>to something like:</p>
<pre><code>@exhaustive
enum DetailedImageProcessingError diff ImageProcessingError {
      | ...
    * | base: StoringError -&gt; DetailedStoringError {
          ...,
          + dbName: Str,
          + dbURL: URL,
        }
}</code></pre>
<p>Specifics of concrete syntax aside, it would technically be possible
to parse the syntax below and desugar it to
the one above. This may be particularly useful if there are lots of cases
in the upstream type being extended.</p>
<p>The Everr language server could show the desugared version as a large multi-line
“inlay hint” inside the editor.<span><label for="sn-44"></label><span>However, this runs into the further issue of how to represent the upstream type if the package containing the definition of the upstream type is not pinned to a specific version.</span></span></p>
<p>However, because this implicitly adds a <code>@delegate</code> attribute to preserve
the ability to do field projections and method calls,
chaining such type definitions makes it easy
to have multiple levels of delegation,
which can be confusing to debug (similar to deep inheritance hierarchies).
The interaction with the implicit project for <code>.case</code> also needs
to be thought through, and may be confusing.</p>
<p>On the other hand, forbidding multiple levels of definitions of
type diffs may be too restrictive if the target use case also needs
to cover code which needs to support 3+ versions of a data type over time.</p>
<p>This is only considering additive diffs. Subtractive diffs are likely
simpler – because <code>@delegate</code> cannot be involved without breaking abstraction
– but also less useful, since it’s more common to want
to create extended versions of third-party types in practice.</p>
<h3 id="appendix-a7-optimism">Appendix A7: Optimism</h3>
<p>Recently at work, I discovered that my assumption
that our DBs was configured so that queries which
are running fast would continue running fast
was proven wrong as the DBs went through a Postgres major version upgrade,
and the loss of statistics
– despite having <a href="https://www.postgresql.org/docs/current/runtime-config-autovacuum.html#GUC-AUTOVACUUM">autovacuum</a> turned on
– contributed to an incident.</p>
<p>The incident was resolved late on a Thursday night;
I was due to go on vacation the subsequent week.
When on vacation, when I had some time to kill,
I spent digging around mailing list threads,
Postgres source code, blog posts and asking Claude,
attempting to answer the question
“What are all the different possible situations
under which Postgres can have statistics that are
woefully out-of-date despite autovacuum being turned on,
and how can those be detected?”</p>
<p>When I came back, I noticed that nobody had really asked the same question,
at least in public. At first, I was puzzled,
“Surely, people are not just hoping that
this doesn’t happen again, right?”
Then I realized I was operating with a different mental model
altogether. My trust in Postgres’s ability to maintain
statistics had gone from confident to low (and the scarce
documentation did nothing to allay that fear),
whereas my colleagues were believing that
this was likely a one-off issue specific to major version upgrades.</p>
<p>Both of these beliefs make some sense in different ways.</p>
<ul>
<li><p>The more optimistic point-of-view assumes
that given that we did not have any such statistics related
issues earlier when running Postgres 12,
and that Postgres upgrades generally bring improvements,
it was likely that autovacuum in Postgres 16 is
at least as good and less buggy than Postgres 12.</p></li>
<li><p>The more pessimistic point-of-view assumes given the presence
of one undesirable behavior in the autovacuum daemon that
hadn’t yet been fixed despite Postgres being one of the most
mature and widely used DB systems in existence,
it was possible that more undesirable
behaviors in the same area were still lurking,
just waiting to be hit.</p></li>
</ul>
<p>When I was thinking about this, I was reminded of
<em>The Mythical Man Month</em>, where in the titular chapter,
Brooks devotes the very first section to discussing
programmers’ optimism.</p>
<blockquote>
<p>All programmers are optimists. [..]</p>
<p>In a single task, the assumption all will go well has
a probabilistic efect on the schedule. It might indeed go
as planned, for there is a probability distribution for
the delay that will be encountered, and “no delay” has a
fine probability. A large programming effort, however,
consists of many tasks, some chained end-to-end.
The probability that each will go well becomes vanishingly small.</p>
</blockquote>
<p>Here, Brooks is discussing optimism it in the context of planning.
Overall, the section is largely anecdotal and speculative about causes.
This point about optimism in the context of planning has been
<a href="https://blog.codinghorror.com/defeating-optimism/">repeated by Kent Beck and Jeff Atwood</a>.</p>
<p>However, the <a href="https://web.mit.edu/curhan/www/docs/Articles/biases/67_J_Personality_and_Social_Psychology_366,_1994.pdf">planning fallacy is common across professions</a>.</p>
<p>I’m curious: is there research showing programmers tend to be more optimistic than other professions? (🧠: “Am I the weird one?”)
And does this optimism apply when reasoning about error cases, and how programmers adjust their trust levels in particular bits of code as they discover bugs? I searched for a bit but didn’t get much, but if you’re reading this and know some research in this area, please let me know. 😃</p>
          </section>
        </article></div>
  </body>
</html>
