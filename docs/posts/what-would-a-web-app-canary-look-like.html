<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/web-app-canaries/">Original</a>
    <h1>What would a web app canary look like?</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p><strong>Monday, October  2, 2023</strong></p>

  <p>Recently, I listened to an <a href="https://changelog.com/podcast/557">interview with Haroon Meer</a>, the founder of a company focused on honeypots.
Honeypots (also known as canaries or tripwires) are used to detect network intrusions and people nosing around at things they&#39;re not supposed to.
They are an essential component of modern network security.</p>
<p>It got me thinking: These are part of network security, so could we use this same concept for application security?
What would it look like to setup a honeypot in a web app?
How much can I make our pentesters personally <em>loathe me</em>?</p>

<p>The main concept behind a honeypot is that you deploy something that looks like an attractive target and monitor it for attempts to access it.
Employees and legitimate users know where they&#39;re supposed to go, but attackers have to do some discovery, so they&#39;re likely to stumble across it.
When access to the honeypot is detected, you can then respond however you&#39;d like.
Typically you will alert people to the honeypot access.</p>
<p>We could do this within our web applications, too.
A component of penetration tests can include attempts to escalate privileges, or to access data you are not supposed to have access to.
There are least a few diferent sorts of honeypots we could use.</p>
<p>But first, we need to think about what we want to protect against.
Here, I&#39;m going to consider two classes of bad actors.
The first is <em>malicious users</em>, who try to use their legitimate access as a user of the application to gain access to information or resources they&#39;re not supposed to have access to.
The second is <em>insider threats</em>, people who have high levels of privilege due to their role working on the application.
Honeypots can be useful for both of these scenarios, but they have different considerations.</p>

<p>The concept of a honeypot is nice and simple.
What does it look like in a web app?
There are a few obvious ideas that are also pretty easy to implement.</p>
<p><strong>Tripwires on well-known values.</strong>
There are some values which you know may be tried if someone is just nosing around.
If you use integers for IDs, you could put a tripwire on 0 and powers of 2 (while ensuring these aren&#39;t used by the application).
This would let you detect enumeration attacks: since these values wouldn&#39;t be legitimately used, attempts to access them are a sign someone is being naughty.
<em>Protects against malicious users; doesn&#39;t help with insider threats.</em></p>
<p><strong>Decoy records in the admin interface.</strong>
You can make fake records in your database which are real in one sense (they exist in the DB) but fake in that they are not for legitimate users.
Then, you can monitor for access to these through various internal facing tools.
If someone accesses these, that means that they&#39;re accessing records they have no legitimate business purpose to access (probably).
<em>Protects some against insider threats, and malicious users who escalated privilege.</em></p>
<p><strong>Extraneous IDs embedded in pages and responses.</strong>
There&#39;s no law that says that everything you return in a response has to be legitimate.
You can populate extra fields with fake data if you know that the client using it is not going to do anything with that data.
(This only really works if you control the client, otherwise you&#39;re setting up your users for failure.)
If you receive requests with this fake data (decoy IDs or decoy endpoints) then you&#39;ll know someone was poking around for access to more things.
This could be an attack, but it could also just be a curious dev who&#39;s using your product.
<em>Protects against malicious users, punishes curious users.</em></p>
<p><strong>Tripwires on common URL paths.</strong>
There are some common paths which many web apps use, like <code>/admin</code> or <code>/wp-admin</code>.
If your application does <em>not</em> use these, you can place a honeypot on that URL.
Then, if you get requests on that URL, you&#39;ll know that someone is nosing around a little.
This is likely to be noisy; since these are common, you&#39;ll get a lot of random traffic on them hoping you&#39;ve got an outdated WordPress installation.
But, it can provide valuable signal, and if you get a request on this from a <em>logged in</em> user... yikes.
<em>Protects against malicious users, annoys whoever gets paged.</em></p>
<p>The possibilities here are almost endless!
Some are good ideas, some are bad.
But what&#39;s clear is that it&#39;s doable.</p>
<p>If you can think of any other ideas that will make a pentester&#39;s life absolutely miserable when testing a web app, please let me know!</p>


  <hr/>
  <p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, subscribe to the <a href="https://blog.meain.io/newsletter">newsletter</a> or use the <a href="https://blog.meain.io/atom.xml">RSS feed</a>.
  </p>
  <p>
  <i></i> Want to become a better programmer?
  <a href="https://www.recurse.com/scout/click?t=c9a1a9e2e7a2ffefd4af20020b4af1e6">Join the Recurse Center!</a>
</p>


</div></div>
  </body>
</html>
