<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mattritter.me/?p=398">Original</a>
    <h1>Postgres, Kafka, and a mysterious 100 GB</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="mainContentOfPage">
		
<p>Lately I’ve been trying to learn more about Amazon Web Services (AWS) and some other popular technologies. Since I work at a large tech company, I spend a lot of my professional time using proprietary software that is analogous to but very different from what most folks would use for the same task.</p>



<p>In this post, I’ll talk about a surprising challenge I encountered setting up an event-driven architecture proof-of-concept on AWS and how I debugged it. I think the experience shows that PoCs using “production infrastructure” can expose pitfalls that might appear in a real implementation. Please read on if you’re interested in hearing about how I accidentally paid AWS too much money and desperately tried to expose a nonexistent hacker.</p>



<p>In particular, I got interested in learning more about <a href="https://en.wikipedia.org/wiki/Apache_Kafka">Apache Kafka</a>, since it seemed like an effective way to communicate between micro-services. It turns out that Apache Kafka is offered on AWS as a managed service called <a href="https://aws.amazon.com/msk/">MSK</a>. And, since I learned that Kafka can siphon events from changes to a database via <a href="https://docs.confluent.io/home/connect/kafka_connectors.html">Kafka Connect</a>, I decided to try the following setup:</p>



<ul><li>Deploy an AWS RDS Postgres instance</li><li>Deploy an AWS MSK instance</li><li>Deploy a Kafka Connector that would send database change events to Kafka</li><li>Deploy a Kafka consumer ready to read database change events</li><li>Finally, observe that inserts to a database table result in events for the consumer</li></ul>



<p>This seems like a lot of machinery, but an architecture diagram shows that it is relatively simple:</p>



<figure><a href="https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?ssl=1"><img loading="lazy" src="https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?resize=700%2C245&amp;ssl=1" alt="" width="700" height="245" srcset="https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?resize=1024%2C358&amp;ssl=1 1024w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?resize=300%2C105&amp;ssl=1 300w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?resize=768%2C269&amp;ssl=1 768w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?resize=1536%2C537&amp;ssl=1 1536w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?resize=2048%2C716&amp;ssl=1 2048w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?resize=700%2C245&amp;ssl=1 700w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?w=1400&amp;ssl=1 1400w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Kafka-Database-Change-Detector.png?w=2100&amp;ssl=1 2100w" sizes="(max-width: 700px) 100vw, 700px" data-recalc-dims="1"/></a></figure>



<p>Note that MSK actually comes with <a href="https://docs.aws.amazon.com/msk/latest/developerguide/msk-connect-connectors.html">Managed Connectors</a>, but I had a hard time getting this to work (and it is significantly more expensive than running your own connector). So, I decided to use an open-source connector called <a href="https://debezium.io/documentation/reference/1.6/connectors/postgresql.html">Debezium</a>, which supports Postgres out of the box.</p>



<p>After slapping together some tutorials, I had a local version of this architecture running (using <a href="https://docs.docker.com/compose/">Docker Compose</a> to manage each of the containerized components). Then, I was able to create the same environment on AWS, as described in the diagram. Finally, in preparation for the Thanksgiving holiday, I turned down my ECS Services so that I could reduce charges. I left MSK and RDS up, since they took some time to configure properly.</p>



<h2>The Problem Starts</h2>



<p>I returned a few days later, located my saved CLI commands for turning up the ECS services, and started to pick up where I left off. Unfortunately, I noticed that the service tasks were failing because they could not connect to the database. I also observed that I could no longer connect to the database locally, so I went to the RDS dashboard. There, I discovered that my instance was in a non-responsive mode called “STORAGE_FULL”.</p>



<p>STORAGE_FULL meant that I had somehow filled up (and was currently paying for) 100 GB of disk space. I started to sweat, thinking that I had probably been hacked by hooligans who were <a href="https://unit42.paloaltonetworks.com/pgminer-postgresql-cryptocurrency-mining-botnet/">turning my instance into some crypto mining machine</a>. These hackers must have been pretty good, since my instance was in a Security Group that only allowed traffic from my IP address. But despite this precaution, I did find evidence of write traffic to the database during my break!</p>



<figure><a href="https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/postgres-write-throughput.png?ssl=1"><img loading="lazy" width="700" height="435" src="https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/postgres-write-throughput.png?resize=700%2C435&amp;ssl=1" alt="" srcset="https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/postgres-write-throughput.png?w=868&amp;ssl=1 868w, https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/postgres-write-throughput.png?resize=300%2C187&amp;ssl=1 300w, https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/postgres-write-throughput.png?resize=768%2C478&amp;ssl=1 768w, https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/postgres-write-throughput.png?resize=700%2C435&amp;ssl=1 700w" sizes="(max-width: 700px) 100vw, 700px" data-recalc-dims="1"/></a></figure>



<p>The next step was to inspect the instance itself and try to see if anything weird was there. It’s actually not even possible to check the instance until it has enough storage to get out of STORAGE_FULL mode. An <a href="https://aws.amazon.com/premiumsupport/knowledge-center/diskfull-error-rds-postgresql/">AWS Support doc</a> helped me get my database enough memory to log on and pointed me in the right direction of the culprit: <strong>the transaction logs</strong>. The corresponding graph clearly showed that my memory had been steadily eaten up by growing transaction logs.</p>



<figure><a href="https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/transaction_logs.png?ssl=1"><img loading="lazy" width="700" height="443" src="https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/transaction_logs.png?resize=700%2C443&amp;ssl=1" alt="" srcset="https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/transaction_logs.png?w=865&amp;ssl=1 865w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/transaction_logs.png?resize=300%2C190&amp;ssl=1 300w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/transaction_logs.png?resize=768%2C487&amp;ssl=1 768w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/transaction_logs.png?resize=700%2C443&amp;ssl=1 700w" sizes="(max-width: 700px) 100vw, 700px" data-recalc-dims="1"/></a></figure>



<p>The AWS docs go on to say that such an increase can be caused by <em><a href="https://www.postgresql.org/docs/10/logicaldecoding-explanation.html#LOGICALDECODING-REPLICATION-SLOTS">replication slots</a></em>, which<em> “retain the WAL files until the files are externally consumed by a consumer”</em> (more on WAL logs soon). And then, their suggested query to reveal the source of the logs increase showed something very suspicious:</p>



<figure><a href="https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-10.14.02-AM.png?ssl=1"><img loading="lazy" width="700" height="87" src="https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-10.14.02-AM.png?resize=700%2C87&amp;ssl=1" alt="" srcset="https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-10.14.02-AM.png?resize=1024%2C127&amp;ssl=1 1024w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-10.14.02-AM.png?resize=300%2C37&amp;ssl=1 300w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-10.14.02-AM.png?resize=768%2C96&amp;ssl=1 768w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-10.14.02-AM.png?resize=700%2C87&amp;ssl=1 700w, https://i1.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-10.14.02-AM.png?w=1077&amp;ssl=1 1077w" sizes="(max-width: 700px) 100vw, 700px" data-recalc-dims="1"/></a></figure>



<p>At this point, I could reasonably conclude that rather than hackers, my misuse of Debezium led to this issue. And, since the problem was ongoing, it would probably even fill the new storage I have allocated to the database. So, I had to move from discovering the issue to understanding it.</p>



<h2>Why Was This Happening?</h2>



<p>To understand why something related to Debezium was using up all of my storage for a replication slot, we need to take a step back and learn a little how more about how the connection between Postgres and Debezium works.</p>



<p>Debezium gets Postgres change events by reading the <a href="https://www.postgresql.org/docs/9.1/wal-intro.html">Write-Ahead Log</a> (WAL), a file that contains all recent changes to the data. This WAL allows the database to recover from failure, since any changes to the data are only written after they have been successfully captured in the WAL. By default, the WAL does not grow larger forever. Instead, Postgres intelligently recycles WAL segments after they have been included in a <em><a href="https://www.postgresql.org/docs/9.2/sql-checkpoint.html">checkpoint</a></em> (and using a number of other configurable factors described in <a href="https://www.postgresql.org/docs/9.5/wal-configuration.html">WAL Configuration</a>).</p>



<p>In order for Kafka to guarantee that is processes every event, it requires WAL events to persist until they are consumed by the Kafka Connector. Otherwise, the Kafka Connector could fall so far behind that it would permanently lose certain events. These events waiting to be consumed are placed in a <em>replication slot</em> specific to the connector. So, doing something like turning off your Kafka Connector forever could result in your WAL events sadly piling up in the replication slot, hoping to one day be consumed…</p>



<p>And yet, why were new events getting added to the WAL at all, since the database was unused? And what was causing that mysterious write traffic? Fortunately, I found the answer to this final question after I carefully read Debezium’s section on <a href="https://debezium.io/documentation/reference/1.1/connectors/postgresql.html#postgresql-wal-disk-space">WAL Disk Consumption</a>. There, at the bottom of the section, was a very special quote inscribed in a “tip” box:</p>



<figure><a href="https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.52.29-PM.png?ssl=1"><img loading="lazy" width="700" height="128" src="https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.52.29-PM.png?resize=700%2C128&amp;ssl=1" alt="" srcset="https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.52.29-PM.png?resize=1024%2C187&amp;ssl=1 1024w, https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.52.29-PM.png?resize=300%2C55&amp;ssl=1 300w, https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.52.29-PM.png?resize=768%2C140&amp;ssl=1 768w, https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.52.29-PM.png?resize=1536%2C280&amp;ssl=1 1536w, https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.52.29-PM.png?resize=700%2C128&amp;ssl=1 700w, https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.52.29-PM.png?w=1546&amp;ssl=1 1546w, https://i0.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.52.29-PM.png?w=1400&amp;ssl=1 1400w" sizes="(max-width: 700px) 100vw, 700px" data-recalc-dims="1"/></a></figure>



<p>Just for confirmation, looking at my database traffic with one-minute granularity does reveal constant, small traffic every 5 minutes.</p>



<figure><a href="https://i2.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.54.44-PM.png?ssl=1"><img loading="lazy" width="700" height="401" src="https://i2.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.54.44-PM.png?resize=700%2C401&amp;ssl=1" alt="" srcset="https://i2.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.54.44-PM.png?resize=1024%2C586&amp;ssl=1 1024w, https://i2.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.54.44-PM.png?resize=300%2C172&amp;ssl=1 300w, https://i2.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.54.44-PM.png?resize=768%2C440&amp;ssl=1 768w, https://i2.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.54.44-PM.png?resize=1536%2C879&amp;ssl=1 1536w, https://i2.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.54.44-PM.png?resize=700%2C401&amp;ssl=1 700w, https://i2.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.54.44-PM.png?w=1684&amp;ssl=1 1684w, https://i2.wp.com/www.mattritter.me/wp-content/uploads/2021/12/Screen-Shot-2021-12-04-at-7.54.44-PM.png?w=1400&amp;ssl=1 1400w" sizes="(max-width: 700px) 100vw, 700px" data-recalc-dims="1"/></a></figure>



<p>At last, we have complete information:</p>



<ul><li>AWS RDS periodically writes to the database at all times</li><li>By default, a replication slot continues to grow until its contents are consumed by a client</li><li>Debezium requires a replication slot for getting events into Kafka</li><li>When Debezium goes down, the replication slot endlessly grows in size</li></ul>



<h2>The Fix</h2>



<p>So now that we know the problem, how can we fix it? Clearly, we do not want to live in a world where a failed Kafka Connector can result in a complete outage of our database. This could be a significant risk for a production application.</p>



<h4>Stopping the Bleeding</h4>



<p>In the short term, I needed to get that disk space back. This is as straightforward as simply dropping the huge replication slot:</p>



<pre><code>psql=&gt;select pg_drop_replication_slot(&#39;debezium&#39;);</code></pre>



<p>Note that turning Debezium back on and letting it catch up could also reduce the size of the slot.</p>



<h4>Preventing A Recurrence</h4>



<p>At a certain point, we have to be comfortable with the fact that if Debezium is down for long enough, then it will permanently miss some events. This is certainly better than bringing the whole database down instead. To do that, we can put a ceiling on our replication slot size using <a href="https://www.postgresql.org/docs/13/runtime-config-replication.html">max_slot_wal_keep_size</a>. This was the solution I came up with after searching through all RDS params with “wal” in them, but it is also endorsed by a few <a href="https://medium.com/cermati-tech/practical-notes-in-change-data-capture-with-debezium-and-postgres-fe31bb11ab78#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjkzNDFhYmM0MDkyYjZmYzAzOGU0MDNjOTEwMjJkZDNlNDQ1MzliNTYiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2Mzg2MzA4MzgsImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjEwMDM5OTEzOTU1NDk3NDQ4MzU5MSIsImVtYWlsIjoibXJpdHRlcjEyM0BnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXpwIjoiMjE2Mjk2MDM1ODM0LWsxazZxZTA2MHMydHAyYTJqYW00bGpkY21zMDBzdHRnLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwibmFtZSI6Ik1hdHRoZXcgUml0dGVyIiwicGljdHVyZSI6Imh0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9hLS9BT2gxNEdnZ25OejVqSnlnVVZIaHQ2MUg2aTZva1JNWThKN0JXdGZBa1V0ZWFBPXM5Ni1jIiwiZ2l2ZW5fbmFtZSI6Ik1hdHRoZXciLCJmYW1pbHlfbmFtZSI6IlJpdHRlciIsImlhdCI6MTYzODYzMTEzOCwiZXhwIjoxNjM4NjM0NzM4LCJqdGkiOiIwNDI2ODZkMTI4MTEyM2Y4ZTFmNWQwY2ZhNTRmOTM4OTVjNmY5N2I0In0.BbVICNCxhvZVSVIEGmRuROcK9L9t93SFq4RBdDIVaocafRV1E2j8tSwjLsLgbIGgVvvQE5o6WGetXoe0ZmUjoRT6jO_E9ZcW44MByd0Pb44wzeUPUUZPqSBdvP9FKpV_f9GlAtQopArMYfzx_rXD6mT1SyVOOsZpjhM6ICqirmTik2o8gtnlQ06LYXLmo3To-jJdWlDKNLFfYDfgIkz6MYuk1hrqfjqXH1smDjdzbnYYz7kCp1Ex3ZhfnsSHfBAk1di35tkfg_G52gDoyiiDy5pbEYS7iN6TEQstVhySCf42L0gL4nouUHLYZ9qCsKPe9x2XZ1xjzEW1mVtheo1xdQ">other</a> <a href="https://www.2ndquadrant.com/en/blog/pg13-slot-size-limit/">sources</a>.</p>



<p>Finally, we could also bolster our defenses by setting an alert for whenever the transaction logs grow too large. This is described in more detail in <a href="https://debezium.io/blog/2020/02/25/lessons-learned-running-debezium-with-postgresql-on-rds/">this post</a>.</p>



<h2>Concluding Thoughts</h2>



<p>I’m glad I went through this exercise because it helped me scratch the surface of maintaining production infrastructure for Postgres and Kafka. These systems are definitely not meant to be intermittently used during development. Instead, they expect to be hyperactive and online, as they should!</p>



<p>I was also reminded of the fact that any cloud provider always introduces an extra layer of complexity between the developer and the underlying technology. In this case, a special RDS property broke some assumptions I had about the database’s usage. This is often the case with managed services, where some management layer does not behave as you would expect.</p>



<p>Nonetheless, I would still use these technologies in a real application. They’re certainly robust, the debugging was not so hard, and neither was the proof-of-concept setup. </p>

		
									</div></div>
  </body>
</html>
