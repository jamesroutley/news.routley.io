<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/postgres-crdt">Original</a>
    <h1>Show HN: Pg_CRDT – an experimental CRDT extension for Postgres</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>Today we’re open-sourcing an EXPERIMENTAL extension for CRDTs, <code>pg_crdt</code>. The GitHub repo is <a href="https://github.com/supabase/pg_crdt">here</a>. There are <a href="https://github.com/supabase/pg_crdt#installation">instructions</a> for running it locally in the README.</p>
<p>When we released the new <a href="https://supabase.com/blog/supabase-realtime-multiplayer-general-availability">multiplayer features</a> for our Realtime engine,
it took 30 minutes for someone to ask if we’d add CRDT support.</p>
<blockquote>
<p><em>Anyone from Supabase here, do you have any plans to build in support for CRDT toolkits such as Yjs or AutoMerge for these features? It would make working with them so much easier if there was a plug and play backend.</em></p>
</blockquote>
<p><small><i>@samwillis on <a href="https://news.ycombinator.com/item?id=32510820">HackerNews</a></i></small></p><p>pg_crdt has not been released onto the Supabase platform (and it may never be). We’re considering many options for offline-sync/support and, while CRDTs will undoubtedly factor in, we’re not sure if this is the <em>right</em> approach. Hopefully this release generates a healthy discussion about the various ways we can do it at Supabase.</p>
<h2 id="whats-a-crdt">What’s a CRDT?</h2>
<p>A CRDT (Conflict-free Replicated Data Type) is a data structure. More accurately, a family of data structures. They enable collaborative apps like <a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/">Figma</a>.</p>
<p>You already know what a “data structure” is: an Array is a good example. CRDTs are a <em>special</em> type of data structure designed to solve a specific problem: they can merge changes in a way that the final state of the data will be the same, no matter the order in which the updates were applied.</p>
<p>In simple terms, a CRDT allows multiple users to make changes to the same data without the need for a central authority to coordinate their actions.</p>
<p>Let’s use our Array example to demonstrate the problem they solve. Imagine you have an array (which is not a CRDT):</p>

<p>Now imagine you have 2 developers updating this array on their local computers. They both want to replace the fruit at the start of the array. The first user, let’s call her “Jenny”, does this:</p>

<p>The developer sitting next to her, let’s call him “Jonny”, does the same:</p>

<p>And now, since they are both developing on different machines, they push their changes to a remote server. When the updates land on the remote system, what will <code>fruit[0]</code> be? “Grape” or “Mango”?</p>
<p><span><span><img alt="Array - which will be saved?" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>Since this is one of those <em>basic</em> arrays, the answer is &#34;the fruit array that arrives last”.</p>
<ol>
<li>If Jonny’s fruit array arrives first, it will be saved.</li>
<li>After that, Jenny’s fruit arrived and overwrites Jonny’s changes.</li>
</ol>
<p>But therein lies the problem: Jonny was the last developer to change his array of fruit, shouldn’t his changes be the ones that are saved?</p>
<p>That’s one of the things that CRDTs solve. There is an “array CRDT” which, when merged, will always have the same result. It doesn’t matter if Jonny’s array arrives first, or if Jenny’s arrives first - every time you merge them they would be able to determine that the Jonny’s was the last change the fruit array.</p>
<p>How does it do that? Some sort of algorithm, but you can ask ChatGPT to explain that one.</p>
<h2 id="offline-philosophy">Offline philosophy</h2>
<p>Collaborative apps are becoming more prolific as legacy software is rebuilt within a browser environment.</p>
<p>Collaboration is largely a data problem - how do we get one user’s changes (data) to merge with another user’s changes (data)? As a database provider it’s natural fit for Supabase to provide the tooling for developers to build collaborative apps.</p>
<p>Before going too far down the “solution” rabbit hole at Supabase, we try to think about the long-term implications of adopting any technology. We’re pretty boring - we don’t make bets on technologies unless we think they will exist in 20 years.</p>
<p>I personally believe CRDTs are the future. For <em>some things</em>. If databases were invented today, I’m certain most of the effort would be spent developing CRDT databases or something with “offline algorithms” built-in. But tech is a real-world demonstration of the Lindy affect: the longer something has existed, the longer it’s likely to exist in the future. That’s why we bet on Postgres - with more than 30 years history, it’s here to stay.</p>
<p>Faced with this reality, we should consider how to solve <em>offline with Postgres</em> and where CRDTs might fit into that picture.</p>
<p>For a long time I thought there could be a way to shoehorn Postgres row-level data into a CRDT, to give <em>truly</em> offline support. This may even still be <a href="https://electric-sql.com/">possible</a>, and it’s one of the ideas we’ll continue to pursue. But Postgres is a rich and evolving ecosystem, and I don’t know whether it will be possible to -</p>
<p>a) find a merge strategy for an entire row, while simultaneously:</p>
<p>b) finding a merge strategy for every data type <em>within</em> that row (especially with the number of data types available through extensions)</p>
<p>It’s possible that developers will need to be selective about their “level” of offline support, at least if they plan to use an “incumbent” databases. For the cases, a simple “last write wins” strategy is probably acceptable (see the excellent <a href="https://doc.replicache.dev/examples/repliear">Replicache</a> and <a href="https://nozbe.github.io/WatermelonDB/">Watermelon</a> libraries), but there will be important pieces of their application where it is not.</p>
<p>Take this table of blog posts as an example:</p>

<p>Perhaps it’s not that important if the <code>title</code> has a “last write wins” strategy, because it’s rarely updated and less likely to have a merge conflict. But it is critical to use a smarter algorithm for the <code>content</code> of the blog post, especially in a team where multiple users are editing a blog post at the same time.</p>
<p>That’s a lot of background to get to what you probably want to know about:</p>
<h2 id="postgres-crdt-extension">Postgres CRDT extension</h2>
<p><code>pg_crdt</code> is an extension which adds CRDT support to Postgres as a data type. For example, using our table from above:</p>

<p>The <code>content</code> column is now a <a href="https://docs.yjs.dev/api/y.doc">Yjs Doc</a>. Updates to this column are <em>commutative</em> and <em>idempotent</em>. This means that they can be applied in any order and multiple times, and the result will always be the same. Two people can edit the blog content at the same time, and they won’t have any issues when their changes are saved in the database.</p>
<h3 id="support-for-yjs-automerge-and-beyond">Support for Yjs, Automerge, and beyond</h3>
<p>The Yjs and Automerge teams have done some excellent work to create Rust libraries for their CRDTs implementations. It was relatively trivial to wrap the libraries into a Postgres extension using the <a href="https://github.com/tcdi/pgx">pgx</a> framework.</p>
<p>At this stage it makes sense to give developers as many choices as possible in one extension. The CRDT space is nascent the algorithms are rapidly changing.</p>
<p>Importantly, both Yjs and Automerge have <em>JavaScript</em> and Rust implementations, which means they work natively in both a browser and a Postgres environment. Since collaborative applications are largely a client-side problem, CRDTs are more useful for developers if they have robust JavaScript libraries. In the future, if this extension becomes the approach we take, then Supabase will focus some resources on building Yjs/Automerge libraries for mobile devices too (Swift for iOS, Kotlin for Android).</p>
<h2 id="why-not-build-this-into-realtime">Why not build this into Realtime?</h2>
<p>An alternative approach for CRDT support in Supabase is to build support directly into <a href="https://github.com/supabase/realtime">Realtime</a> and use it as an Authoritative server. In this scenario, Realtime would serialize the CRDT and save it to Postgres (probably as a <code>bytea</code> data type). Yjs has the concept of <a href="https://github.com/yjs/yjs#providers">Providers</a> which would facilitate this. You can see the difference between the approaches in the diagram below - on the left, Realtime acts as the “middleman” for saving the CRDT in the database, whereas on the right the CRDT is pushed directly to the database, and Realtime receives updates from Postgres. (Note also that clients can send peer-to-peer updates.)</p>
<p><span><span><img alt="Realtime as an authority" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>This might still be our best option, but it should not be our first attempt. If we make Realtime the authority, it strongly couples developers to the Supabase infrastructure. By placing the CRDT into the database, it simplifies the architecture, enables other tools (like Debezium), and provides the possibility to update the database directly (for semi-realtime events like counters or page-views).</p>
<p><span><span><img alt="External providers" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>The Realtime engine seems like a great <em>compliment</em> for <code>pg_crdt</code>, but before we put it into production we need to solve a few (major) limitations.</p>
<h2 id="limitations">Limitations</h2>
<p>These are a few of the <em>known</em> limitations:</p>
<ul>
<li>Realtime broadcasts database changes from the Postgres write ahead log (WAL). The WAL includes a complete copy of the the underlying data so small updates cause the entire document to broadcast to all collaborators</li>
<li>Frequently updated CRDTs produce a lot of WAL and dead tuples</li>
<li>Large CRDT types in Postgres generate significant serialization/deserialization overhead on-update.</li>
</ul>
<p>We’re likely to discover more (no doubt from a few friendly HN comments).</p>
<h2 id="next-steps">Next steps</h2>
<p>If you want to help with <code>pg_crdt</code> the best way is to get involved in the GitHub repo. We have enabled <a href="https://github.com/supabase/pg_crdt/discussions">Discussions</a> for any and all ideas. If you have experience with CRDTs and you like this approach, don’t hesitate to contact one of the team.</p></div></article></div>
  </body>
</html>
