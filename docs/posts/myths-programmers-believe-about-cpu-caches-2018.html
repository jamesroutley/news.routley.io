<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://software.rajivprab.com/2018/04/29/myths-programmers-believe-about-cpu-caches/">Original</a>
    <h1>Myths Programmers Believe about CPU Caches (2018)</h1>
    
    <div id="readability-page-1" class="page"><div>
		<div>
<figure><a href="http://tutorials.jenkov.com/java-performance/modern-hardware.html" target="_blank" rel="noreferrer noopener"><img data-attachment-id="169" data-permalink="https://software.rajivprab.com/cache/" data-orig-file="https://software.rajivprab.com/wp-content/uploads/2019/07/cache.png" data-orig-size="463,544" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="cache" data-image-description="" data-image-caption="" data-medium-file="https://software.rajivprab.com/wp-content/uploads/2019/07/cache.png?w=255" data-large-file="https://software.rajivprab.com/wp-content/uploads/2019/07/cache.png?w=463" src="https://software.rajivprab.com/wp-content/uploads/2019/07/cache.png" alt="" width="347" height="408" srcset="https://software.rajivprab.com/wp-content/uploads/2019/07/cache.png?w=347&amp;h=408 347w, https://software.rajivprab.com/wp-content/uploads/2019/07/cache.png?w=128&amp;h=150 128w, https://software.rajivprab.com/wp-content/uploads/2019/07/cache.png?w=255&amp;h=300 255w, https://software.rajivprab.com/wp-content/uploads/2019/07/cache.png 463w" sizes="(max-width: 347px) 100vw, 347px"/></a></figure></div>


<p><span>As a computer engineer who has spent half a decade working with caches at Intel and Sun, I’ve learnt a thing or two about <a href="https://en.wikipedia.org/wiki/Cache_coherence" target="_blank" rel="noopener">cache-coherency</a>. This was one of the hardest concepts to learn back in college – but once you’ve truly understood it, it gives you a great appreciation for system design principles.</span></p>



<p><span>You might be wondering why you as a software developer should care about CPU cache-design. For one thing, many of the concepts learnt in cache-coherency are directly applicable to </span><a href="https://en.wikipedia.org/wiki/Distributed_computing" target="_blank" rel="noopener">distributed-system-architecture</a><span> and </span><a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels" target="_blank" rel="noopener">database-isolation-levels</a><span> as well. For instance, understanding how coherency is implemented in hardware caches, can help in better understanding </span><a href="https://hackernoon.com/eventual-vs-strong-consistency-in-distributed-databases-282fdad37cf7" target="_blank" rel="noopener">strong-vs-eventual consistency</a><span>. It can spur ideas on how to better enforce consistency in distributed systems, using the same research and principles applied in hardware.</span></p>



<p><span>For another thing, misconceptions about caches often lead to false assertions, especially when it comes to concurrency and race conditions. For example, the common refrain that concurrent programming is hard because </span><span><i>“different cores can have different/stale values in their individual caches”</i></span><span>. Or that the reason we need </span><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html" target="_blank" rel="noopener">volatiles</a><span> in languages like Java, is to </span><span><i>“prevent shared-data from being cached locally”</i></span><span>, and force them to be </span><span><i>“</i></span><a href="http://tutorials.jenkov.com/java-concurrency/volatile.html" target="_blank" rel="noopener">read/written all the way to main memory</a><span><i>”</i></span><span>.</span></p>



<p><span>Such misconceptions are mostly harmless (and maybe even helpful), but can also lead to bad design decisions. For instance, developers can start to believe that they are insulated from the above concurrency bugs, when working with single-core-systems. In reality, </span><a href="https://stackoverflow.com/questions/23593061/volatile-keyword-in-multicore-vs-single-processor" target="_blank" rel="noopener">even single-core systems are at risk of concurrency bugs</a><span>, if the appropriate concurrency constructs aren’t used.</span></p>



<p><span>For another, if volatile variables were truly written/read from main-memory every single time, they would be horrendously slow – </span><a href="https://gist.github.com/jboner/2841832" target="_blank" rel="noopener">main-memory references are 200x slower than L1 cache references</a><span>. In reality, </span><a href="https://stackoverflow.com/questions/4633866/is-volatile-expensive" target="_blank" rel="noopener">volatile-reads (in Java) can often be just as cheap as a L1 cache reference</a><span>, putting to rest the notion that volatile forces reads/writes all the way to main memory. If you’ve been avoiding the use of volatiles because of performance concerns, you might have been a victim of the above misconceptions.</span></p>



<h2><span>The Importance of Being Coherent</span></h2>



<p><span>But if different cores each have their own private cache, storing copies of the same data, wouldn’t that naturally lead to data mismatches as they start issuing writes? The answer: hardware caches on modern x86 CPUs like Intel’s, are kept in-sync with one another. These caches aren’t just dumb memory storage units, as many developers seem to think. Rather, there are very intricate protocols and logics, embedded in every cache, communicating with other caches, enforcing coherency across all threads. And all this is happening at the hardware level, meaning that we as software/compiler/systems developers don’t have to deal with it.</span></p>



<p><span>A quick word about what I mean when I say that caches are </span><span><i>“in sync”</i></span><span>. There is a </span><a href="https://en.wikipedia.org/wiki/Consistency_model" target="_blank" rel="noopener">great wealth of nuance</a><span> in this topic, but to simplify greatly, we mean the following: If 2 different threads, anywhere in the system, read from the <em>same</em> memory address, they should never</span><span><i> simultaneously</i></span><span> read different values.</span></p>



<p><span>For a quick example of how non-coherent caches can violate the above rule, simply refer to the first section of </span><a rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/volatile.html" target="_blank">this tutorial</a><span>. No modern x86 CPU behaves the way the tutorial describes it, but a buggy processor certainly can. Everything discussed here is a means towards one simple end: preventing such data-mismatches from happening.</span></p>



<p><span>A widely used protocol used to enforce coherency amongst caches, is known as the </span><a rel="noopener" href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank">MESI protocol</a><span>. The details of this protocol are entirely abstracted away from software, which gives CPU architects tremendous flexibility to experiment and innovate on its nuances with every new product or iteration. If you peek under the covers you’ll find that every CPU has its own variant of MESI, with its own unique benefits, tradeoffs and potential for unique bugs. However, these variants all share a great deal in common. And that’s the following: each line of data sitting in a cache, is tagged with one of the following states:</span></p>



<ol>
<li><span>Modified (M) </span>
<ol>
<li><span>This data has been modified, and differs from main memory</span></li>



<li><span>This data is the source-of-truth, and all other data elsewhere is stale</span></li>
</ol>
</li>



<li><span>Exclusive (E)</span>
<ol>
<li><span>This data has not been modified, and is in sync with the data in main memory</span></li>



<li><span>No other sibling cache has this data</span></li>
</ol>
</li>



<li><span>Shared (S)</span>
<ol>
<li><span>This data has not been modified, and is in sync with the data elsewhere</span></li>



<li><span>There are other sibling caches that (may) also have this same data</span></li>
</ol>
</li>



<li><span>Invalid (I)</span>
<ol>
<li><span>This data is stale, and should never ever be used</span></li>
</ol>
</li>
</ol>



<p><span>Cache coherency can now be accomplished as long as we enforce and update the above states. Let’s look at a few examples for a CPU with 4 cores, each of which has its own L1 cache, along with a global on-chip L2 cache.</span></p>



<h2><span>Memory Write</span></h2>



<p><span>Suppose a thread on core-1 wants to write to address 0xabcd. The following are some possible sequence of events.</span></p>



<h3><span>Cache Hit</span></h3>



<ol>
<li><span>L1-1 has the data in E or M state </span></li>



<li><span>L1-1 performs the write. All done</span>
<ol>
<li><span>No other cache has the data, so it is safe to write to it immediately</span></li>



<li>The state of the cache-line is set to M, since it is now modified</li>
</ol>
</li>
</ol>



<h3><span>Local Cache Miss, Sibling Cache Hit</span></h3>



<ol>
<li><span>L1-1 has the data in S state</span>
<ol>
<li><span>This implies that another sibling cache might have the data</span></li>



<li><span>This same flow is also used if L1-1 doesn’t have the data at all</span></li>
</ol>
</li>



<li><span>L1-1 sends a Request-For-Ownership to the L2 cache</span></li>



<li><span>L2 looks up its directory and sees that L1-2 currently has the data in S state</span></li>



<li><span>L2 sends a snoop-invalidate to L1-2</span></li>



<li><span>L1-2 marks its data as being Invalid (I)</span></li>



<li><span>L1-2 sends an Ack to L2</span></li>



<li><span>L2 sends an Ack, along with the latest data, to L1-1</span>
<ol>
<li><span>L2 keeps track of the fact that L1-1 has the data for this address in E state</span></li>
</ol>
</li>



<li><span>L1-1 now has the latest data, as well as permission to enter E state</span></li>



<li><span>L1-1 performs the write, and changes the state of that data to M</span></li>
</ol>



<h2><span>Memory Read</span></h2>



<p><span>Now suppose a thread on core-2 wants to read from address 0xabcd. The following are some possible sequences of events.</span></p>



<h3><span>Cache Hit</span></h3>



<ol>
<li><span>L1-2 has the data in S or E or M state</span></li>



<li><span>L1-2 reads the data and returns it to the thread. All done</span></li>
</ol>



<h3><span>Local Cache Miss, Parent Cache Miss</span></h3>



<ol>
<li><span>L1-2 has the data in I (invalid) state, meaning it’s not allowed to use it</span></li>



<li><span>L1-2 sends a Request-for-Share to the L2 cache</span></li>



<li><span>L2 does not have the data either. It reads the data from memory</span></li>



<li><span>L2 gets back the data from memory</span></li>



<li><span>L2 sends this data to L1-2, along with permission to enter S state</span>
<ol>
<li><span>L2 keeps track of the fact that L1-2 has this data in S-state</span></li>
</ol>
</li>



<li><span>L1-2 gets the data, stores it in its cache, and sends it to the thread</span></li>
</ol>



<h3><span>Local Cache Miss, Parent Cache Hit</span></h3>



<ol>
<li><span>L1-2 has the data in I state</span></li>



<li><span>L1-2 sends a Request-for-S to the L2 cache</span></li>



<li><span>L2 sees that L1-1 has the data in S state</span></li>



<li><span>L2 sends an Ack to L1-2, along with the data, and permission to enter S state</span></li>



<li><span>L1-2 gets the data, stores it in its cache, and sends it to the thread</span></li>
</ol>



<h3><span>Local Cache Miss, Sibling Cache Hit</span></h3>



<ol>
<li><span>L1-2 has the data in I state</span></li>



<li><span>L1-2 sends a Request-for-S to the L2 cache</span></li>



<li><span>L2 sees that L1-1 has the data in E (or M) state</span></li>



<li><span>L2 sends a snoop-share to L1-1</span></li>



<li><span>L1-1 downgrades its state to an S</span></li>



<li><span>L1-1 sends an Ack to L2, along with the modified data if applicable</span></li>



<li><span>L2 sends an Ack to L1-2, along with the data, and permission to enter S state</span></li>



<li><span>L1-2 gets the data, stores it in its cache, and sends it to the thread</span></li>
</ol>



<h2><span>Variations</span></h2>



<p><span>The above are just some of the possible scenarios that can occur. In reality, there are numerous variations of the above design, and no 2 implementations are the same. For example, some </span><a href="https://en.wikipedia.org/wiki/MESIF_protocol" target="_blank" rel="noopener">designs have an O/F state</a><span>. Some have </span><a href="https://stackoverflow.com/questions/27087912/write-back-vs-write-through" target="_blank" rel="noopener">write-back caches, whereas others use write-through</a><span>. Some use snoop-broadcasts, while others use a </span><a href="https://en.wikipedia.org/wiki/Bus_snooping#Snoop_filter" target="_blank" rel="noopener">snoop-filter</a><span>. Some have </span><a href="https://en.wikipedia.org/wiki/Cache_inclusion_policy" target="_blank" rel="noopener">inclusive caches and others have exclusive caches</a><span>. The variations are endless, and we haven’t even discussed </span><a href="https://stackoverflow.com/questions/11105827/what-is-a-store-buffer" target="_blank" rel="noopener">store-buffers</a><span>!</span></p>



<p><span>The above example also considers a simple processor with only 2 levels of caching, but note that this same protocol can also be applied recursively. You could easily add an L3 cache, which in turn coordinates multiple L2s, using the exact same protocol as above. You can also have a </span><a href="https://software.intel.com/en-us/articles/how-memory-is-accessed" target="_blank" rel="noopener">multi-processor system</a><span>, with “Home Agents” that coordinate across multiple L3 caches on completely different chips.</span></p>



<p><span>In each scenario, each cache only needs to communicate with its parent (to get data/permissions), and its children (to grant/revoke data/permissions). And all this can be accomplished in a manner that’s invisible to the software thread. From the perspective of the software application, the memory subsystem appears to be a single, coherent, monolith … with <i>very</i></span><span> variable latencies.</span></p>



<h2><span>Why Synchronization Still Matters</span></h2>



<p><span>One final word, now that we’ve discussed the awesome power and coherency of your computer’s memory system. If caches are so in-sync with one another, why do we need volatiles at all <a rel="noopener" href="https://componenthouse.com/2016/12/28/comparing-the-volatile-keyword-in-java-c-and-cpp/" target="_blank">in languages like Java</a>? </span></p>



<p><span>That’s a very complicated question that’s </span><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">better answered elsewhere</a><span>, but let me just drop one partial hint. Data that’s read into </span><a href="https://en.wikipedia.org/wiki/Processor_register" target="_blank" rel="noopener">CPU registers</a><span>, is </span><span><i>not</i></span><span> kept in sync with data in cache/memory. The software compiler makes all sorts of optimizations when it comes to </span><a href="https://www.inf.ed.ac.uk/teaching/courses/copt/lecture-7.pdf" target="_blank" rel="noopener">loading data into registers, writing it back to the cache</a><span>, and even </span><a href="https://stackoverflow.com/questions/22106843/gccs-reordering-of-read-write-instructions" target="_blank" rel="noopener">reordering of instructions</a><span>. This is all done assuming that the code will be run single-threaded. Hence why any data that is at risk of race-conditions, needs to be manually protected through concurrency algorithms and language constructs such as atomics and volatiles.</span></p>



<p><span>In the case of Java volatiles, part of the solution is to force all reads/writes to bypass the local registers, and </span><a rel="noopener" href="https://stackoverflow.com/questions/4633866/is-volatile-expensive" target="_blank">immediately trigger cache reads/writes instead</a><span>. As soon as the data is read/written to the L1 cache, the hardware-coherency protocol takes over and provides guaranteed coherency across all global threads. Thus ensuring that if multiple threads are reading/writing to the same variable, they are all kept in sync with one another. And this is how you can achieve inter-thread coordination in as little as 1ns.</span></p>



<hr/>



<p><em><a rel="noreferrer noopener" aria-label="Discussion thread on Hacker News (opens in a new tab)" href="https://news.ycombinator.com/item?id=17670095" target="_blank">Hacker News – 2018/08</a></em></p>
	</div></div>
  </body>
</html>
