<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alanilling.medium.com/exiting-the-vietnam-of-programming-our-journey-in-dropping-the-orm-in-golang-3ce7dff24a0f">Original</a>
    
    <div id="readability-page-1" class="page"><section><div><div><p id="2139">While at <a href="https://2021.djangocon.us/" target="_blank" rel="noopener ugc nofollow">DjangoCon</a> around 2010 someone told me that using an ORM is like the U.S. going to war in Vietnam. That comment was in reference to <a href="http://blogs.tedneward.com/" target="_blank" rel="noopener ugc nofollow">Ted Neward</a> coining the term and formalizing his comparison in his 2006 blog post titled <a href="http://blogs.tedneward.com/post/the-vietnam-of-computer-science/" target="_blank" rel="noopener ugc nofollow">The Vietnam of Computer Science</a>.</p><p id="e8a0">The comparison reso<span id="rmm"><span id="rmm">n</span></span>ated with me but I never considered abandoning the ORM. Drawing the completely wrong lessons from the analogy I spent several years looking for the perfect ORM and either through my own decision making or someone else’s I’ve been exposed to a veritable tour de France: Django and SQLAlchemy in Python, Active Record, Linq, Hibernate, Entity Framework, and most recently, Gorm in our Golang-powered backend at Bridge Financial Technology.</p><p id="af6e">When we find pain in software development it’s important to lean into it. Make it hurt until you can’t stand it anymore. The more acute the pain the better you’ll be able to describe and identify where the pain comes from. Our pain caused me to reevaluate the so-called Vietnam Problem and question whether ORMs make sense at all. I won’t go until a full analysis of the mismatch between the object-oriented and relational world. For that I recommend reading Ted Neward’s timeless post. But I will summarize the important takeaways.</p><h2 id="2dc9">Vietnam: The Object-Relational Mismatch</h2><p id="a68e">I begin by oversimplifying the Vietnam war the way most historians see it today. The Vietnamese were fighting a civil war to unify their country. The United States was engaged in a proxy war with the Soviet Union and communism itself to prevent it from spreading. That is, the Vietnamese saw it as a north/south issue while the U.S. saw it as an east/west issue.</p><p id="9f62">And the whole thing wasn’t worth it. Vietnam is a united communist country today (the Vietcong got what it wanted) without witnessing the spread of communist doctrine throughout Asia beyond China, which became a communist country in 1949 (the U.S. got what it wanted). And yet it spanned nearly 15 years, 3 presidential administrations and over a million casualties (across the U.S., North and South Vietnamese, allies on both sides and military and civilian personnel). The better strategy, ostensibly at any point, would have been to disengage entirely.</p><p id="8686">Shifting to software development: objects and relations are likewise fundamentally different things. They come from different places with different goals, and neither is wrong or bad. Of course technologies can be stack-ranked within these worlds and you’ll get more mileage using a stack that your team knows, respects and trusts. For us, we believe Postgres is the best-in-class implementation of a relational database (better than say, MySQL or SQL Server). Likewise we like and admire Go, particularly that it doesn’t implement object oriented design goals through inheritance. If you struggle with either your database or programming language I recommend fixing that problem first before solving problems at the intersection, or at least was our trajectory and we’re happy with the results. To flesh out the analogy below is an overview of these “sides”: objects, relations, the differences and problems encountered when they interact with each other.</p><h2 id="b6fa">Object Orientation Principles</h2><p id="3481">An object oriented system aims to provide:</p><ul><li id="8e1f">Identity management: making a separation between the equivalence of state and the objects themselves. Object equivalence occurs when the values of two objects are the same, while identity equivalence occurs when two objects are the same, which is to say, they both point to the same location in memory.</li><li id="5005">State management: the ability to correlate several primitives into a larger bundle that represents something about the world or problem.</li><li id="f767">Behaviors: a collection of operations to manipulate said state.</li><li id="38fa">Encapsulation: the ability to define a simplified, exported surface area of the object to the rest of the system thereby hiding unnecessary details.</li><li id="6911">Polymorphism: the ability to treat different objects homogeneously that can react in similar ways, despite being different things.</li></ul><p id="d3cf">Most programming languages achieve these principles with an inheritance model. But it’s worth noting that many highly successful languages are indeed object oriented without inheritance: notably, Go, Erlang and Rust.</p><h2 id="679a">Relational Principles</h2><p id="ba4a">A relational storage engine seeks to normalize data and document facts of the world. SQL provides operations to interact with data built up around set theory to ensure mathematical correctness and achieve properties during the mutability of the data; namely, <a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener ugc nofollow">ACID compliance</a>. SQL operations executed within a transaction are atomic, consistent, isolated and durable. Normalization is typically achieved through proper design, the gold standard being <a href="https://en.wikipedia.org/wiki/Third_normal_form" target="_blank" rel="noopener ugc nofollow">third-normal, or Boyce-Codd, form</a>.</p><h2 id="ac53">(Some) Differences</h2><p id="8036">These are completely different systems. Some of their differences include:</p><ul><li id="9dcc">Objects make sense with aggregated state, while relations seek to fragment it into multiple tables.</li><li id="4887">Data mutability concerns in the object world are around concerns of accidental overwrite in a concurrent system and protected through encapsulation. Mutability in the relational world requires a transaction to guarantee correctness when state has been altered. There’s less concern to obtain correctness in mutating object state until the data is persisted.</li><li id="34ad">A collection of objects exists to enable behaviors across those objects, while a collection of relations exists to establish facts about the world.</li></ul><h2 id="a82e">Conceptual Problems</h2><p id="a8fd">Below is a list of problems that stem from these differences.</p><p id="284c"><strong>The mapping problem</strong>. It’s difficult to map tables to objects using any mapper because of the following problems:</p><ul><li id="db1c">An object relationship will be represented by composing one object with another. However, related objects rely on an implicit <code>JOIN</code> operation in SQL, otherwise related objects won’t be initialized with data.</li><li id="bed7">A many to many table in a relational engine involves 3 tables: the two sources of data and a third join table. However such a relationship only requires two objects with a list of the other.</li><li id="4955">If your programming language supports inheritance, it may be tempting to model objects in that way, but there’s no IS-A type of relation within databases.</li></ul><p id="a2f1"><strong>Who / what owns the schema definition?</strong> The programming language, and as such the the application developers, or the DDL of the database, and as such the DBAs? Even if you don’t have a distinction between these roles in your organization you’ll still have this problem, known as slaving the “O” to the “R” or vice-versa.</p><p id="1481"><strong>Where does metadata go? </strong>Most fields will naturally have a 1:1 correspondence. For example, integers, booleans, etc. will have well known types in the database and your programming language. But what about enumerables? Likely these are strings or ints in either with a limited number of options, and both the database and programming language can enforce constraints. So where do you place such metadata? The application? The database? Both?</p><p id="796e">All of these problems need a resolution by declaring one side (objects or relations) as the definitive authority. And that leads to a classification of ORMs- what is it’s opinion on that authority? Objects or relations?</p><h2 id="c826">Understanding and Classifying ORMs</h2><p id="2710">In reality you can’t simply “exit” and disengage from the problem. The title of this post is somewhat marketing-motivated. After all, you’re not going to persist objects to flat files and call it a “database” and you’re not going to build applications in SQL. These things must meet at some point. But I argue that the common approach many ORMs have taken is limited and largely motivated by convenience, usually at the expense of one side.</p><p id="9539">Broadly, there are two types of ORMs: code-first and database-first.</p><ul><li id="bd59">In the <strong>code-first approach</strong> you define object model definitions as classes or types that will map to database entities (one or more tables). This approach generates SQL on the fly and makes heavy use of reflection. An example in the Go community is <a href="https://gorm.io/index.html" target="_blank" rel="noopener ugc nofollow">gorm</a>.</li><li id="91e5">The <strong>database-first approach</strong> typically relies on generating object definition code from your database definition language (DDL). A Golang example is <a href="https://github.com/volatiletech/sqlboiler" target="_blank" rel="noopener ugc nofollow">SQLBoiler</a>.</li></ul><p id="a837">You’ll probably have an intuitive and gut reaction to one of these. And that view can be stubbornly-held. Personally, I always prioritized objects over relations and went with code-first ORMs. But ultimately I switched my thinking to prioritizing the database. That decision precipitated dropping the ORM all together by <em>generating</em> the code used to interact with the database.</p><p id="2590">The above points are all theoretical. Our journey begins with the practical pain and problems we started feeling from our ORM, Gorm.</p><h2 id="d38e">Problem 1: Wrapped API</h2><p id="8965">An early facepalm moment came from updating some records in the database. The SQL for doing this is:</p><pre><span id="8dff">UPDATE &lt;table&gt;</span></pre><p id="12ad">But the Gorm API changes the order in which values and conditions are accepted.</p><pre><span id="d066">// intended</span><span id="21f8">// updates the whole table, ignoring conditions</span></pre><p id="65c8">We learned the hard way that getting this wrong has disastrous consequences. The ORM’s API is chainable but it’s not entirely lazy. Certain statements are finalizing, including the Update. If you reverse the order the updates will apply without the Where conditions taking effect, meaning you’ve updated everything in the model.</p><p id="d133">Now you can argue that SQL has this backwards and the ORM is simply making a correction to what the API should really be. And you can argue our team should have known better. Or that the API could have been better documented. Whatever the argument the result is the same: we had a bad day. And the broader point is this: an ORM is effectively a wrapper on SQL.</p><p id="ab8d">Early in my career an engineering manager taught me to be skeptical of wrappers, as they only add layers of cognitive load to the workload. I pushed back, arguing that, taken to its logical conclusion, he’d have all code written in assembly. Neither extreme is correct: abstraction is about achieving a balancing act. But as my career progresses the more I place the ORM in the unnecessary wrapper camp. Why are we dealing with a middleware that reverses the super stable and well known ANSI SQL API that all virtually all developers are trained on? Every developer knows how to update records in a table using SQL (or could easily Google it) and can expect an error when they get it wrong. Not every developer, in fact very few developers, know Gorm’s abstraction. And the same is true (among new hires) for whatever ORM you’re using; you’ll constantly be training people on a mission-critical section of the stack.</p><h2 id="306d">Problem 2: Performance and Excessive Memory Consumption</h2><p id="2888">Our backend runs on a serverless stack (AWS Fargate) with limited memory capacity. Over time we kept having to increase the memory capacity of our instances, eventually reaching the maximum and then watching our containers die. As the data volume grew we saw the number of containers grow in somewhat linear fashion. One would hope the backend would instead scale sublinearly.</p><p id="292d">The ORM was a natural culprit: it’s easy to see that many ORMs will make use of object introspection to build SQL statements, hydrate results, or both. Gorm’s memory footprint is extreme although sadly not uncommon. Bridge started with Python on the backend and we used Django’s ORM to interact with the database which had similar problems.</p><p id="9839">We didn’t realize the extent of the problem until we ultimately removed it from our stack to give us a comparison point. The details are included in the next section, but as a preview: we increased execution performance by about 2x and reduced our memory footprint by nearly 10x.</p><h2 id="84e8">Problem 3: Understanding our I/O Profile</h2><p id="dbbe">Over time we noticed ourselves consuming database logging tools to understand our own use cases and recognized it as a mismatch. We had setup <a href="https://aws.amazon.com/rds/performance-insights/" target="_blank" rel="noopener ugc nofollow">RDS Performance Insights</a> on AWS and <a href="https://pganalyze.com/" target="_blank" rel="noopener ugc nofollow">pganalyze</a> to identify bottlenecks in the database. These tools proved their value early on and we ended up using them to learn about the ways in which we interacted with the database. Do we over-fetch columns? Are we running unindexed queries?</p><p id="223d">Of course these questions have known, definitive answers. The fact that we need an outside tool to shed light on the matter is an obvious structural flaw in the code. To me the underlying problem is that the ORM made it too easy to interact with the database. The code wasn’t centralized or modularized to a middleware layer in the codebase. Instead it was spaghettified throughout. Understanding our database interactivity required extensive code audits and reviews of stuff that had more to do with business logic than reads and writes.</p><h2 id="a6a6">Alternatives</h2><p id="37c8">The alternative to having an ORM seem fairly limited: use a low-level database driver, build SQL queries at runtime and map the results back into objects yourself. Of course an ORM does all these things in automated fashion, so going this route would be a huge sacrifice to maintainability. Our team concluded (fairly easily and without much decision making) that whatever benefits here, the costs are simply too high to consider it.</p><p id="4ae0">There is a third route, however: employing code generators to automate these steps. We bucketed projects in the Go community along two lines:</p><ul><li id="d69c">Code-generating SQL at runtime (example: <a href="https://github.com/Masterminds/squirrel" target="_blank" rel="noopener ugc nofollow">squirrel</a>)</li><li id="b440">Generating application code at compile time(examples: <a href="https://github.com/go-jet/jet" target="_blank" rel="noopener ugc nofollow">jet</a>, <a href="https://github.com/kyleconroy/sqlc" target="_blank" rel="noopener ugc nofollow">sqlc</a>)</li></ul><p id="3f25">Generating SQL code is an interesting idea, and requires less tooling and commitment than generating application code. However we felt it would be a lateral move in the maintainability of our code. SQL generation will require string interpolation, which means auditing the code as database migrations are applied, a labor-intensive and exhausting process we wanted to end.</p><h2 id="5048">Baby in the Bathwater?</h2><p id="5ade">We thought long and hard about whether we were throwing out the baby with the bathwater. Perhaps the problem isn’t ORMs per se, but only the code-first subset. In the Go community <a href="https://github.com/volatiletech/sqlboiler" target="_blank" rel="noopener ugc nofollow">sqlboiler</a> is an <a href="https://www.youtube.com/watch?v=y5utRS9axfg" target="_blank" rel="noopener ugc nofollow">interesting</a> project that generates model definitions from your DDL.</p><p id="5e60">We decided against using this project, for the following reasons:</p><ul><li id="6080">There is such a thing as too much code generation. Generated code requires flexible configuration to control the output, which is a fine line to walk. On the one hand you don’t want to swap code for configuration and drop huge yaml or toml files in your codebase that require its own set of maintenance issues. At the other extreme if there’s something that you want to control or customize about the generated code that isn’t exposed in configuration, you’re out of luck.</li><li id="bf0f">Sqlboiler is largely inspired by Active Record which we feel overly abstracts the database. We sought to embrace the database because, culturally, we’re a data-centric organization and wanted our database to be more transparent within our application and API.</li></ul><h2 id="2ca0">Selecting a Code Generator</h2><p id="3f30">We looked closely at two code generators: <a href="https://github.com/go-jet/jet" target="_blank" rel="noopener ugc nofollow">jet</a> and <a href="https://github.com/kyleconroy/sqlc" target="_blank" rel="noopener ugc nofollow">sqlc</a>, ultimately selecting sqlc. With jet you write SQL within your application as a DSL. But because it generates code it goes a step beyond what a runtime SQL generator like squirrel offers. Models and fields and are first-class referenceable types, rather than requiring string interpolation, which avoids the need to grep through code in an audit process when you want to make changes.</p><p id="c5c6">Even more appealing, it offers a way to aggregate, or de-normalize data in a database. Whereas an ORM’s goal is to make relationship traversal easy, Jet’s goal is to provide a package of data in a complete and well-typed struct that clearly advertises what’s available within it. Here’s an example:</p><pre><span id="bdd0">stmt := SELECT(</span><span id="81aa">var dest []struct {</span><span id="9673">    Films []struct {</span><span id="1172">        Language   model.Language</span><span id="85b3">// Execute query and store result</span></pre><p id="40d6">There’s a lot of data aggregation going on here. The application-side model being built up is an actor with all the films they’ve been in, the language the film is featured in and the categories its classified under.</p><p id="d09d">We were initially attracted to this design, but after experimenting a bit it didn’t quite feel right. In this example the query is driving the data model within the application, rather than the other way around and we feared this approach would lead to a lot of throw-away aggregate models. Our objective was to promote reusable models with lots of business logic and mutability captured in methods on their types.</p><p id="735b">Moreover our preference was to move SQL out of code entirely. The problem here is that any developer can simply query the database however they wish. While this is an initial productivity win, it’s at the cost of long-term maintainability of both the code and runtime performance. What if a developer queries the database sub-optimally, without using an index? That risk is high as the data model becomes larger and complex since it’s a step removed from the SQL. And while the DSL is appreciated, we still felt it was wrapper-like in the end.</p><h2 id="23e0">The Answer: sqlc</h2><p id="b4fb">We decided to use <a href="https://github.com/kyleconroy/sqlc" target="_blank" rel="noopener ugc nofollow">sqlc</a>, a <a href="https://docs.sqlc.dev/en/stable/reference/config.html" target="_blank" rel="noopener ugc nofollow">configurable</a> opt-in sql compiler. The approach resonated with us; we like that it doesn’t generate things you don’t ask for, and the resulting generated code can be tailored to the types and tags we’ve defined. It makes the code feel like ours while providing an obvious path to migrate our current implementation. I’ll elaborate on the details of how we made sqlc work for us in a future post.</p></div></div></section><section><div><div><p id="ee8e">This project was a huge undertaking, requiring not only commitment from our developers, but our product team and the company at large. We’ve had feature freezes, headaches around running our ORM side-by-side with generated code, and had to plan our migrations and deployment path carefully. All of this in the context of a small (but growing) company with limited resources. With all this cost, the benefits had better be significant, and indeed they are. Among them, we’re realizing better performance and scalability in our backend runtime, better maintainability of our codebase, less dependency on database logs to understand our data I/O profile, a more cloud-native implementation and transparency in our backend data model to all our developers regardless of their day to day proximity to the database in the stack.</p><h2 id="c1f6">Performance and Scale</h2><p id="0c38">If your ORM is dynamic, without the using generated code or consuming generic types or interfaces, then it’s probably doing some level of reflection behind the scenes. In our case, Gorm makes heavy use of reflection since Go doesn’t support generics, and Gorm doesn’t define many interfaces, beyond requiring you to declare the table name that corresponds to an application model. So we expected large benefits here, but when we started benchmarking our system we were happily impressed.</p><p id="8c2c"><strong>Performance</strong> is about achieving low runtime execution. We benchmarked the results by identifying various workloads that are typical in our backend, either because the API is executing them or due to an offline or batched process that’s causing heavy I/O against the database. In the graph below we have use-cases on the horizontal axis; blue indicates our sqlc-driven data interaction layer and the red indicates our current latency with the Gorm ORM. Lower is better.</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*e-TiJQM9eRB47qbp6TlFLA.png?q=20" width="700" height="432" role="presentation"/></p><p><img alt="" width="700" height="432" role="presentation"/></p></div></div></div></div><figcaption>Runtime performance is 52% faster without the ORM</figcaption></figure><p id="84e6">Across our workloads we’re enjoying approximately a 2x speedup in execution performance. Happily, this number tends to be even higher when the workloads fetch more data.</p><p id="e610"><strong>Scalability</strong> is about consuming the least amount of memory possible, which is particularly important for us since we run all our workloads on a serverless backend (AWS Fargate), so we’re better suited to scale-out than up. The less memory we’re using on each instance means fewer instances need to come online to achieve a result, which translates to lower cost and an overall better utilization of the fleet. Put differently, if you need half the number of instances than you’re current using (which are budgeted) you should be able to process double the amount of data without having to talk to your CFO.</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*kZCZCA6rUNiqtw2C9fjYRg.png?q=20" width="700" height="381" role="presentation"/></p><p><img alt="" width="700" height="381" role="presentation"/></p></div></div></div></div><figcaption>Memory consumption is 78% less without the ORM</figcaption></figure><p id="9b0d">We’ve reduced our memory consumption on average by 78%. Now you could argue that perhaps Gorm is doing something excessively inefficient here, and other ORMs may fare better, but fundamentally most mappers will have a need for type introspection which will lead to a bad memory profile.</p><p id="5ba9">Both of these improvements are driven by the fewer number of allocations that need to happen per operation, which we’ve benchmarked to the tune of another 80% drop:</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*KdV8ECyxveeYAerWZyq1Pg.png?q=20" width="700" height="432" role="presentation"/></p><p><img alt="" width="700" height="432" role="presentation"/></p></div></div></div></div><figcaption>Allocations per operation is 80% less without the ORM</figcaption></figure><h2 id="aa3d">Code Maintainability</h2><p id="a334">I consider all the code that interacts with your data layer as <em>middleware</em>. Of course if you’re using an ORM you might not have this middleware explicitly boxed up into a package or set of functions, which I would argue makes you worse off: the middleware is still there but it’s not isolated. Instead, the database interactivity is spaghettified throughout the codebase.</p><p id="fe5e">When we want to retrieve, update, create or delete data we invoke functions that do that for us:</p><pre><span id="bf74">q.GetAccounts(ctx, ids)</span><span id="cd3e">// more complex queries take a generated &lt;X&gt;Params type</span></pre><p id="8ca6">And our endpoints don’t even do this; they abstract the details by invoking an interface:</p><pre><span id="0d1d">result, err := fetch.Page(ctx, fetch.PageParams{</span></pre><h2 id="7f66">Understanding our Data I/O Profile</h2><p id="5050">When you have an ORM you’re inviting all software developers in your organization to hit the database in potentially unaccounted ways. Despite best efforts to train your team on what indexes are available or setup DBA roles, ultimately you’ll have database interaction code that can’t be accounted for without a code review. Which inevitably leads one to turn to database logs and monitoring solutions to understand how the database is being accessed. These tools are a welcome addition to any process reviewing runtime performance and achieving SLAs, but if you’re using them to understand how your database is accessed it’s already too late.</p><p id="1806">We still use tools like <a href="https://aws.amazon.com/rds/performance-insights/" target="_blank" rel="noopener ugc nofollow">RDS Performance Insights</a> and <a href="https://pganalyze.com/" target="_blank" rel="noopener ugc nofollow">pganalyze</a> but we’re no longer reliant on them for understanding the general profile, or worry whether we’re consuming an index or not. This work has been shifted to our centralized repository that acts as a middleware for all our database I/O, which we simply call the <em>data repo</em>.</p><p id="1377">It’s not without process, but now it’s a <em>managed</em> process. When an application developer needs a new query she needs to open a PR in the data repo which will come with a code review where people can ask whether an index or transaction is being employed. True, such code review standards should applied to all repositories, but database I/O is going to be just one bullet point in a downstream application. Our data repo is focused on one thing and one thing only: managed database interaction. Moreover it’s easy to conduct code audits after the fact. The DDL and SQL queries are all side by side, making it easy to know whether a query is properly consuming an index or not.</p><h2 id="c51a">More Cloud Native Implementation</h2><p id="186a">Your mileage may vary, but the two ORMs we used (Gorm and Django) both wrapped the database connection, causing two problems. First, in both cases, the wrapped object exposed less functionality than what was available in the underlying driver. And as databases and drivers update to address specific needs this can become quite frustrating.</p><p id="3ce4">Second, particularly in the case of Django, it moved us away from a cloud-native design. One aspect in particular that we struggled with is accessing data from within our Lambda functions. Function-as-a-service platforms such as Lambda will want you to define your database connection as a global variable so that it’s <a href="https://www.jeremydaly.com/reuse-database-connections-aws-lambda/" target="_blank" rel="noopener ugc nofollow">freezable</a>. This task was basically impossible on Django. Although we had less trouble with this problem in Gorm, we had other problems around obtaining the connection pooling characteristics we wanted, even on long-lived compute layers in the cloud.</p><p id="56fe">Ultimately being able to implement a cloud-native design comes down to the database driver you’ve selected, and you need to make sure your ORM supports that driver. We’re lucky to use Postgres and more lucky that the Go community has a specialized driver solely for it: <a href="https://github.com/jackc/pgx" target="_blank" rel="noopener ugc nofollow">jackc/pgx</a>. Being able to utilize this driver directly without the ORM has given us more flexibility on cloud-native design and the ability to take advantage of Postgres-specific features that are often left out of other drivers that prioritize broad, cross-db support.</p><h2 id="87b0">Data Model Transparency</h2><p id="806d">Finally, and perhaps greatest of all, dropping our ORM has changed our engineering culture to be more data-centric by promoting the transparency of our data model. Bridge is a data processing company. We do the unsexy work of normalizing and enriching financial data for registered investment advisors, enterprises and other fintech platforms.</p><p id="6de7">We value integrity, accuracy and consistency in our data to deliver on these goals, and we can’t do that unless everyone feels they understand the data model. Many ORMs are philosophically built around hiding or abstracting away the database from the development process, which will ultimately lead your team to pay close attention to “the O” and deprioritizing “the R”. And the “the O” is locked up in individual repositories that any single person may or may not have knowledge of. But everyone can get behind the structural arrangement of a database: the organization into schemas, DDL, E/R diagrams, etc.</p><p id="0ca4">For us, our database is more than just a container of information that we read and write into. It’s the expression of our ideas; how we simplify and model the complexity of industry challenges. Removing the ORM has put all those details front-end-center in people’s minds, created more ownership over both the data model and Postgres with less throw-it-over-the-fence mentality. And that’s perhaps the best gain of all.</p></div></div></section></div>
  </body>
</html>
