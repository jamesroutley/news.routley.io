<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://borretti.me/article/shells-are-two-things">Original</a>
    <h1>Shells are two things</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
  <header>
    
  </header>
  <article>
    <p>The fundamental problem of shells is they are required to be two things.</p>

<ol>
  <li><strong>A high-frequency REPL</strong>, which requires terseness, short command names,
little to no syntax, implicit rather than explicit, so as to minimize the duration of REPL cycles.</li>
  <li><strong>A programming language</strong>, which requires readable and maintainable syntax,
static types, modules, visibility, declarations, explicit configuration rather
than implicit conventions.</li>
</ol>

<p>And you can’t do both. You can’t be explicit and implicit, you can’t be terse
and readable, you can’t be flexible and robust.</p>

<p>Shells optimize the former case, so that you can write <code>cat beef.txt | grep
&#34;lasagna&#34; | sort -n | uniq</code> instead of:</p>

<div><div><pre><code><span>with</span> <span>open</span><span>(</span><span>Path</span><span>(</span><span>&#34;beef.txt&#34;</span><span>))</span> <span>as</span> <span>stream</span><span>:</span>
    <span>lines</span> <span>=</span> <span>filter</span><span>(</span>
        <span>stream</span><span>.</span><span>readlines</span><span>(),</span>
        <span>lambda</span> <span>line</span><span>:</span> <span>re</span><span>.</span><span>match</span><span>(</span><span>line</span><span>,</span> <span>&#34;lasagna&#34;</span><span>)</span> <span>is</span> <span>not</span> <span>None</span>
    <span>)</span>
    <span>print</span><span>(</span><span>set</span><span>(</span><span>reverse</span><span>(</span><span>sorted</span><span>(</span><span>lines</span><span>))))</span>
</code></pre></div></div>

<p>Which does not spark joy.</p>

<p>So the programming language aspect suffers: shell scripts are an unreadable
nightmare of stringly-typed code resembling cyphertext.</p>

<p>Of course No True Scotsman would write a large and complex program as a shell
script, but according to this lovely seven-line one-liner:</p>

<div><div><pre><code>find / <span>-type</span> f <span>-exec</span> <span>awk</span> <span>&#39;/^#!.*sh/{print FILENAME}&#39;</span> <span>{}</span> + <span>\</span>
  | xargs file <span>\</span>
  | <span>awk</span> <span>&#39;!/ASCII text/{next} {print}&#39;</span> <span>\</span>
  | <span>cut</span> <span>-d</span>: <span>-f1</span> <span>\</span>
  | xargs <span>-I</span> <span>{}</span> <span>wc</span> <span>-l</span> <span>{}</span> <span>\</span>
  | <span>sort</span> <span>-n</span> <span>\</span>
  | <span>uniq</span>
</code></pre></div></div>

<p>There are 5,635 shell scripts on my humble Ubuntu box. Of these, 79 are over one
thousand lines of text, the largest being <code>/usr/share/libtool/configure</code><sup id="fnref:config" role="doc-noteref"><a href="#fn:config" rel="footnote">1</a></sup>,
a 16,394-line shell script the devil wrote<sup id="fnref:lines" role="doc-noteref"><a href="#fn:lines" rel="footnote">2</a></sup>. In total, there are 726,938
lines of stringly-typed shell script on my machine. This is more than I am
comfortable with.</p>

<p>And the solution is obvious, but hard to implement because preserving backwards
compatibility would require a great deal of elbow grease.</p>

<p>The solution is that we have one tool, but there are two things, and so there
should be two tools. Shells should be terse, fast, interactive, and not too scriptable. Programs should export the terse command-line interface for use in the shell:</p>

<div><div><pre><code>pandoc <span>-t</span> latex <span>\</span>
       <span>-f</span> markdown <span>\</span>
       <span>--pdf-engine</span><span>=</span>xelatex <span>\</span>
       <span>--table-of-contents</span> <span>\</span>
       <span>--toc-depth</span><span>=</span>2 <span>\</span>
       <span>--resource-path</span><span>=</span><span>.</span> <span>\</span>
       <span>--standalone</span> <span>\</span>
       input.md <span>\</span>
       <span>-o</span> output.pdf
</code></pre></div></div>

<p>And the typed interface, for use in a more scalable programming language:</p>

<div><div><pre><code>Pandoc(
    input = (Path(&#34;input.md&#34;), MD),
    output = (Path(&#34;output.pdf&#34;), PDF),
    pdfEngine = XELATEX,
    resourcePath=Path(&#34;.&#34;),
    completenessMode=STANDALONE,
)
</code></pre></div></div>

<p>And the former can be derived from the latter, because it is a strict weakening
of the typed interface.</p>

<p>The challenge is how to fit this into the POSIX universe where the sole
entrypoint to a program is an array of strings. Historically, operating systems
that have fanciful structured interfaces between programs have been left in the
dust by Unix, because Unix maximizes flexibility by favoring the
lowest-common-denominator interface, which is the string.</p>





  </article>
</div>

  </div></div>
  </body>
</html>
