<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.atuin.sh/introducing-the-new-runbook-execution-engine/">Original</a>
    <h1>Atuinâ€™s New Runbook Execution Engine</h1>
    
    <div id="readability-page-1" class="page"><section>
            <p>We&#39;re excited to announce a major architectural improvement to Atuin Desktop: <strong>a completely redesigned runbook execution engine</strong>.</p><p>This is a huge change, the first big step toward making runbooks a core automation primitive. </p><p>If youâ€™ve ever hit flaky context, disappearing state, or inconsistent execution, this release fixes it. Runbooks now keep their state, behave predictably, and donâ€™t require constant re-running just to get back to where you were. We&#39;re laying the foundation for enhanced real-time collaboration and CLI-based execution.</p><figure><img src="https://blog.atuin.sh/content/images/2025/11/Atuin-ZoomZoom-01-1.png" alt="Zoooooooom" loading="lazy" width="400" height="282"/></figure><div data-layout="immersive">
            
            <div>
                
                
                    <div>
                    
                        <p><span>Runbooks should run. Workflows shouldn&#39;t live in someone&#39;s head. Docs shouldn&#39;t rot the moment you write them.</span></p>
                    
                    
                        <p><a href="https://github.com/atuinsh/desktop/releases/latest?ref=blog.atuin.sh">
                            Download Atuin Desktop
                        </a>
                        
                    </p></div>
                
            </div>
        </div><h2 id="whats-new">What&#39;s New?</h2><h3 id="persistent">Persistent</h3><p><em>Runbooks stay how you left them. No rebuilds. No re-running blocks. No friction.</em></p><p>Previously, when you closed a tab or restarted Atuin Desktop, all execution state was lost. With the new execution engine, your runbook&#39;sÂ <em>context</em>Â - which stores all of the execution-related state - now persists across app restarts and tab closures.</p><p>In practice, this means that if you run a command likeÂ <code>mktemp -d</code>Â to create a tempflorary directory and save it to a template variable, that output is now saved locally along with your runbook. Close the tab or restart the app, and the context is still there - no need to re-execute blocks to rebuild your working environment.</p><h3 id="reproducible">Reproducible</h3><p><em>Runbooks behave the way you expect, every time.</em></p><p>The new engine establishes a clear, predictable flow of context through your runbooks. Each block in your document can only influence the blocks below it. This means that, for example, setting a template variable in a block will not affect that same variable&#39;s usage in any blocks above it.</p><figure><img src="https://blog.atuin.sh/content/images/2025/11/image-1.png" alt="" loading="lazy" width="2000" height="428" srcset="https://blog.atuin.sh/content/images/size/w600/2025/11/image-1.png 600w, https://blog.atuin.sh/content/images/size/w1000/2025/11/image-1.png 1000w, https://blog.atuin.sh/content/images/size/w1600/2025/11/image-1.png 1600w, https://blog.atuin.sh/content/images/2025/11/image-1.png 2066w" sizes="(min-width: 720px) 720px"/><figcaption><span>A blockâ€™s context only affects blocks below it</span></figcaption></figure><p>With the fundamentals fixed, we pushed the template system further:</p><h3 id="templates-everywhere">Templates Everywhere</h3><p>We now run all user input through ourÂ <a href="https://man.atuin.sh/templating/?ref=blog.atuin.sh" rel="noopener noreferrer nofollow">template system</a>. This means you can use templates in variable names, context blocks like directory and SSH, and any other block that accepts input. </p><p>If you find any input that doesnâ€™t behave this way, itâ€™s a bug andÂ <a href="https://github.com/atuinsh/desktop/issues/new/choose?ref=blog.atuin.sh" rel="noopener noreferrer nofollow">weâ€™d love to know about it</a>!</p><h3 id="self-referential-variables">Self-Referential Variables</h3><p>Since all inputs run through the template system and variables donâ€™t affect context above them, itâ€™s possible for a variable to refer to itself. For example, you could trim the newline off a variable namedÂ <code>output</code>Â by usingÂ <code>{{ var.output | trim }}</code>Â and assigning it back toÂ <code>output</code>Â again. You can get as deep as you want with variable metaprogramming:</p><figure><img src="https://blog.atuin.sh/content/images/2025/11/image-2.png" alt="" loading="lazy" width="2000" height="774" srcset="https://blog.atuin.sh/content/images/size/w600/2025/11/image-2.png 600w, https://blog.atuin.sh/content/images/size/w1000/2025/11/image-2.png 1000w, https://blog.atuin.sh/content/images/size/w1600/2025/11/image-2.png 1600w, https://blog.atuin.sh/content/images/2025/11/image-2.png 2098w" sizes="(min-width: 720px) 720px"/><figcaption><span>We heard you like variables</span></figcaption></figure><h3 id="two-types-of-execution-context">Two Types of Execution Context</h3><p>The new engine introduces two types of context:</p><p><strong>Passive Context</strong>Â is set automatically when your document updates. This includes:</p><ul><li>Working directory changes</li><li>Environment variable definitions</li><li>SSH host connections</li><li>Explicit template variable assignments</li></ul><p>This context persists even when you&#39;re not actively running blocks.</p><p><strong>Active Context</strong>Â is set during block execution and represents the output and runtime state of actively running blocks. When you re-run a block, its active context is cleared and rebuilt.</p><p>The active context contains the data we store locally with your runbook, and persists across app restarts. A new button in the runbook header allows you to clear all active context for a runbook, in case you want to start with a clean slate.</p><figure><img src="https://blog.atuin.sh/content/images/2025/11/image-3.png" alt="" loading="lazy" width="770" height="160" srcset="https://blog.atuin.sh/content/images/size/w600/2025/11/image-3.png 600w, https://blog.atuin.sh/content/images/2025/11/image-3.png 770w" sizes="(min-width: 720px) 720px"/><figcaption><span>Reset your runbookâ€™s execution state at any time</span></figcaption></figure><h3 id="foundation-for-future-collaboration">Foundation for Future Collaboration</h3><p>Atuin Desktop already supports real-time collaboration for editing runbook content, but the new architecture lays the groundwork to take this even further, setting us up for real collaborative execution. Imagine sharing not just the document, but the entire running environment - including environment setup, terminal output, and database query results - all in real time!</p><h2 id="whats-changed">What&#39;s Changed?</h2><h3 id="no-more-global-context">No More Global Context</h3><p>Because this update changes the way blocks can affect one another, you may need to adjust any runbooks that relied on the old, global context (for example, setting a template variable in a block and using that variable in a blockÂ <em>above</em>Â the block that set it).</p><h3 id="editor-variable-sync">Editor Variable Sync</h3><p>In the old execution system, the editor block contained a toggle that kept the value in the editor in sync with a variable in the context. Whenever the variable changed anywhere in the document, the editor would update to reflect that change.</p><p>This behavior doesn&#39;t work well with the new architecture, where context is no longer global. For this reason, we&#39;ve removed the toggle, and replaced it with a UI element that allows you to manually set the editor content to the value of any defined template variable.</p><figure><img src="https://blog.atuin.sh/content/images/2025/11/image-4.png" alt="" loading="lazy" width="2000" height="538" srcset="https://blog.atuin.sh/content/images/size/w600/2025/11/image-4.png 600w, https://blog.atuin.sh/content/images/size/w1000/2025/11/image-4.png 1000w, https://blog.atuin.sh/content/images/size/w1600/2025/11/image-4.png 1600w, https://blog.atuin.sh/content/images/2025/11/image-4.png 2066w" sizes="(min-width: 720px) 720px"/><figcaption><span>Update an editor block&#39;s content to match the value of any available variable</span></figcaption></figure><h3 id="no-standard-error-in-script-variables">No Standard Error in Script Variables</h3><p>Script output variables now capture only stdout, not stderr. This prevents error messages and diagnostics from mixing with your actual output data, making variables cleaner and more reliable. You&#39;ll still see both stdout and stderr in the block&#39;s terminal output.</p><h3 id="under-the-hood">Under the Hood</h3><p>For those interested in the technical details, this update involved rewriting our entire block execution system, migrating it from our old front-end system written in TypeScript to the existing Rust backend. We&#39;ve migrated every block to the new system, making every block&#39;s execution more portable and reliable.</p><p>Each block implements aÂ <code>BlockBehavior</code>Â trait, defining a couple key methods:</p><ul><li><code>passive_context</code>Â - returns any context that should be set passively any time the document changes</li><li><code>execute</code>Â - executes the block, sending messages to the client to update active context and any other relevant data</li></ul><p>There are other useful traits, such asÂ <code>QueryBlockBehavior</code>, which allows quickly defining a block that queries a data source and returns a table of results.</p><p>Combined with traits likeÂ <code>MessageChannel</code>Â (to facilitate sending messages to the client) andÂ <code>BlockContextStorage</code>Â (to save and load context data), the new architecture has allowed us to completely extract the runtime system from the desktop application, paving the way for executing runbooks in any environment.</p><p>For all the juicy details, check outÂ <a href="https://github.com/atuinsh/desktop/blob/main/dev/docs/EXECUTION_SYSTEM.md?ref=blog.atuin.sh" rel="noopener noreferrer nofollow">the execution system docs in the repository</a>.</p><h2 id="whats-next">What&#39;s Next?</h2><h3 id="cli-runner">CLI Runner</h3><p>Run your runbooks from any terminal, even if Atuin Desktop isn&#39;t installed. The new runtime is designed to be environment-agnostic, making it possible to execute runbooks in CI/CD pipelines, deployment scripts, or automated workflows.</p><figure><img src="https://blog.atuin.sh/content/images/2025/11/Imgur-Magic-1.gif" alt="" loading="lazy" width="1080" height="608" srcset="https://blog.atuin.sh/content/images/size/w600/2025/11/Imgur-Magic-1.gif 600w, https://blog.atuin.sh/content/images/size/w1000/2025/11/Imgur-Magic-1.gif 1000w, https://blog.atuin.sh/content/images/2025/11/Imgur-Magic-1.gif 1080w" sizes="(min-width: 720px) 720px"/><figcaption><span>Itâ€™s shells all the way down</span></figcaption></figure><h3 id="improved-serial-execution">Improved Serial Execution</h3><p>Running a runbook from top-to-bottom - which we call &#34;serial execution&#34; - currently depends on the runbook being open in your editor. Thanks to the new runtime, we&#39;ll be able to remove this constraint, and introduce improved tooling for monitoring and controlling runbook executions both inside and outside the app.</p><h3 id="secrets-management">Secrets Management</h3><p>Secrets are one of the most critical aspects of infrastructure management, and runbooks are no exception. We&#39;ll be adding first-class support for storing and retrieving secrets both locally and in the cloud, encrypted end-to-end.</p><h3 id="markdown-based-runbooks">Markdown-Based Runbooks</h3><p>Markdown is ubiquitous in modern development. It&#39;s lightweight, easy to read, and can be edited in any text editor. We&#39;re working on storing runbooks as pure markdown files with embedded metadata, making them more portable and easier to write, review, and version control.</p><div><p>ðŸ’¬</p><p>Got thoughts about terminals or runbooks? Grab a slot <a href="https://cal.com/ellieh/atuin-chat?ref=blog.atuin.sh" rel="noreferrer">here</a></p></div><h2 id="try-it-out">Try It Out</h2><p>The new execution engine is available now <a href="https://github.com/atuinsh/desktop/releases/tag/v0.2.0?ref=blog.atuin.sh" rel="noreferrer">in v0.2.0</a>. Update your Atuin Desktop installation and experience the difference yourself.</p><p>Discord:Â <a href="https://discord.gg/Fq8bJSKPHh?ref=blog.atuin.sh" rel="noopener noreferrer nofollow">Discord</a></p><p>Forum:Â <a href="https://forum.atuin.sh/?ref=blog.atuin.sh" rel="noopener noreferrer nofollow">Forum</a></p>
        </section></div>
  </body>
</html>
