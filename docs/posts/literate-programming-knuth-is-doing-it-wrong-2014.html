<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://akkartik.name/post/literate-programming">Original</a>
    <h1>Literate programming: Knuth is doing it wrong (2014)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Oct 3, 2014</p>
<p><b>Literate programming: Knuth is doing it wrong</b></p><p>
Literate programming advocates this: <em>Order your code for others to read,
not for the compiler. Beautifully typeset your code so one can curl up in bed
to read it like a novel. Keep documentation in sync with code.</em> What&#39;s not
to like about this vision? I have two beefs with it: the ends are insufficiently
ambitious by focusing on a passive representation; and the means were insufficiently
polished, by over-emphasizing typesetting at the cost of prose quality.
Elaboration, in reverse order:
</p><center><em>Canonizing typesetting over organization</em></center>
<p>
When I look around at the legacy of literate programming, systems to do
so-called semi- or quasi-literate programming dominate. These are systems that
focus on generating beautifully typeset documentation without allowing the
author to arbitrarily order code. I think this is exactly backwards; codebases
are easy to read primarily due to the author&#39;s efforts to orchestrate the
presentation, and only secondarily by typesetting improvements. As a concrete
example, just about every literate program out there begins with cruft like
this:<sup><a href="#f1">1</a></sup>
</p><pre><span>// Some #includes</span>
</pre>
<p>
or:
</p><pre><span>-- Don&#39;t mind these imports.</span>
</pre>
<p>
I used to think people just didn&#39;t understand Knuth&#39;s vision. But then I went
and looked at his literate programs. Boom, #includes:
</p><p>
<a href="http://www-cs-faculty.stanford.edu/~uno/programs/advent.w.gz">
<img src="http://akkartik.name/images/literate-programming/adventure.png"/></a>
<br clear="both"/>
</p><p>
The example Pascal program in <a href="http://www.literateprogramming.com/knuthweb.pdf">Knuth&#39;s
original paper</a> didn&#39;t have any imports at all. But when it comes to
organizing larger codebases, we&#39;ve been putting imports thoughtlessly at the
top. Right from day one.
</p><p>
Exhibit 2:
</p><p>
<a href="http://www-cs-faculty.stanford.edu/~uno/programs/sat12.w">
<img src="http://akkartik.name/images/literate-programming/sat12.png"/></a>
<br clear="both"/>
</p><p>
<em>“Skip ahead if you are impatient to see the interesting stuff.”</em>
Well gee, if only we had, you know, a tool to put the interesting stuff up
front.
</p><p>
Exhibit 3:
</p><p>
<a href="http://www-cs-faculty.stanford.edu/~uno/programs/sham.w">
<img src="http://akkartik.name/images/literate-programming/sham.png"/></a>
<br clear="both"/>
</p><p>
This is the start of the piece. There&#39;s a sentence of introduction, and then
this:
</p><div>
<p><span>“</span>We use a utility field to record
the vertex degrees.
</p><p>
#define deg u.I
</p>
</div>
<p>
That&#39;s a steep jump across several levels of abstraction. Literally the first
line of code shown is a macro to access a field for presumably a struct whose
definition — whose <em>very type name</em> — we haven&#39;t even seen
yet. (The variable name for the struct is also hard-coded in; but I&#39;ll stop
nit-picking further.)
</p><p>
Exhibit 4: Zoom out just a little bit on the previous example:
</p><p>
<a href="http://www-cs-faculty.stanford.edu/~uno/programs/sham.w">
<img src="http://akkartik.name/images/literate-programming/sham2.png"/></a>
<br clear="both"/>
</p><p>
Again, there&#39;s #includes at the top but I won&#39;t belabor that. Let&#39;s look at
what&#39;s in these #includes. &#34;GraphBase data structures&#34; seems kinda relevant to
the program. Surely the description should inline and describe the core data
structures the program will be using. In the immortal words of <a href="http://en.wikiquote.org/wiki/Fred_Brooks">Fred
Brooks</a>:
</p><p><span>“</span>Show me your flowcharts [code]
and conceal your tables [data types], and I shall continue to be
mystified. Show me your tables, and I won’t usually need your flowcharts;
they’ll be obvious.&#34;
</p>
<p>
Surely a system to optimize order for exposition shouldn&#39;t be stymied by
<em>code in a different file</em>.
</p><p>
On the whole, people have failed to appreciate the promise of literate
programming because the early examples are just not that good, barring the
small program in Knuth&#39;s original paper. The programs jump across abstraction
layers. Problems are ill-motivated. There&#39;s a pervasive mindset of top-down
thinking, of starting from <span>main</span>, whether or not that&#39;s easiest to read. The
ability to change order is under-used, perhaps because early literate tools
made debugging harder, but mostly I think because of all the emphasis —
<a href="http://www.literateprogramming.com/knuthweb.pdf">right from the
start</a> — on just how <em>darn cool</em> the typesetting was.<sup><a href="#f2">2</a></sup>
</p><p>
All this may seem harsh on Knuth, but I figure Knuth can take it. He&#39;s, well,
Knuth, and I&#39;m nobody. He came up with literate programming as the successor
to structured programming, meaning that he was introducing ordering considerations
at a time when most people were still using <em>gotos</em> as a matter of
course. There was no typesetting for programmers or academics, no internet, no
hyperlinking. No, these early examples are fine for what they are. They
haven&#39;t developed because <em>we programmers</em> have failed to develop them
over time. We&#39;ve been too quick to treat them as sacred cows to be merely
interpreted (not noticing the violence our interpretations do to the original
idea anyway). I speculate that nobody has actually read anybody else&#39;s
literate programs in any sort of detail. And so nobody has been truly inspired
to do better. We&#39;ve been using literate programming, like the vast majority of
us use <a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>,
as a signalling device to show that we are hip to what&#39;s cool. (If you have
spent time reading somebody else&#39;s literate programs, I want to hear about
your experiences!)
</p><center><em>Canonizing passive reading over interactive feedback</em></center>
<p>
I&#39;ve been indirectly maligning typesetting, but it&#39;s time to aim squarely at
it. There&#39;s a fundamental problem with generating a beautifully typeset
document for a codebase: it&#39;s dead. It can&#39;t render inside just about any
actual programming environment (editor or IDE) on this planet, and so we can&#39;t
make changes to it while we work on the codebase. Everybody reads a pdf about
a program at most once, when they first encounter it. After that, re-rendering
it is a pain, and proof-reading the rendered document, well forget about it.
That dooms generated documentation to be an after-thought, forever at risk of
falling stale, or at least rendering poorly.
</p><p>
You can&#39;t work with it, you can&#39;t try to make changes to it to see what
happens, and you certainly can&#39;t run it interactively. All you can do,
literally, is curl up with it in bed. And promptly fall asleep. I mean, who
reads code in bed without a keyboard?!
</p><p>
What&#39;s the alternative? In the spirit of presenting a target of my own for
others to attack, I&#39;ll point you at some literate code I wrote <a href="http://akkartik.name/post/wart-layers">last
year</a> for a simple interpreter. A sample of what it looks like:
</p><pre> <span>// Programs are run in two stages:</span>
 <span>//  a) _read_ the text of the program into a tree of cells</span>
 <span>//  b) _evaluate_ the tree of cells to yield a result</span>
 cell* run(istream&amp; in) {
   cell* result = nil;
   do {
       <span>// TEMP and &#39;update&#39; help recycle cells after we&#39;re done with</span>
       <span>// them.</span>
       <span>// Gotta pay attention to this all the time; see the &#39;memory&#39;</span>
       <span>// layer.</span>
       TEMP(form, read(in));
       update(result, eval(form));
   } while (!eof(in));
   return result;
 }
 
 cell* run(string s) {
   stringstream in(s);
   return run(in);
 }
 
 <span>:(scenarios run)</span>
 <span>:(scenario examples)</span>
 <span># function call; later we&#39;ll support a more natural syntax for</span>
 <span># arithmetic</span>
 (+ 1 1)
 <span>=&gt;</span> 2
 
 <span># assignment</span>
 (&lt;- x 3)
 x
 <span>=&gt;</span> 3
 
 <span># list; deliberately looks just like a function call</span>
 &#39;(1 2 3)
 <span>=&gt;</span> (1 2 3)
 
 <span># the function (fn) doesn&#39;t have to be named</span>
 ((fn (a b)  <span># parameters (params)</span>
     (+ a b))  <span># body</span>
    3 4)  <span># arguments (args) that are bound to params inside this call</span>
 <span>=&gt;</span> 7
</pre>
<p>
A <a href="http://akkartik.name/post/wart-layers">previous post</a> describes
the format, but we won&#39;t need more details for this example. Just note that it
is simple plaintext that will open up in your text editor. There is minimal
prose, because just the order of presentation does so much heavy lifting.
Comments are like code: the less you write, the less there is to go bad. I&#39;m
paying the cost of ‘<span>//</span>’
to delineate comments because I haven&#39;t gotten around to fixing it, because
it&#39;s just not that important to clean it up. You can&#39;t see it in this sample,
but the program at large organizes features in self-contained layers, with
later features hooking into the code for earlier ones. Here&#39;s <a href="http://akkartik.name/images/wart-layers/test.html">a
test harness</a>. (With, I can&#39;t resist pointing out, the includes at the
bottom.) Here&#39;s a <a href="http://akkartik.name/images/wart-layers/memory.html">garbage
collector</a>. <a href="https://github.com/akkartik/wart/blob/master/literate/030scope">Here</a>
I replace a flat namespace of bindings with dynamic scope. In each case, code
is freely intermingled with tests to exercise it (like the <span>scenarios</span>
above), tests that can be run from the commandline.
</p><pre> <span>$</span> build_and_test_until 029  <span># exercises the core interpreter</span>
 <span>$</span> build_and_test_until 030  <span># exercises dynamic scope</span>
 ...
</pre>
<p>
Having built the program with just a subset of layers, you&#39;re free to poke at
it and run what-if experiments. <em>Why did Kartik write this line like
so?</em> Make a change, run the tests. <em>Oh, that&#39;s why.</em> You can add
logging to trace through execution, and you can use a debugger, because you&#39;re
sitting at your workstation like a reasonable programmer, not curled up in
bed.
</p><p>
Eventually I&#39;d like to live in a world where our systems for viewing live,
modifiable, interactive code are as adept at typesetting as our publishing
systems are. But until that day, I&#39;ll choose simple markdown-like plain-text
documentation that the author labored over the structure of. Every single
time.
</p><center><em>footnotes</em></center>
<p>
<a name="f1">1.</a> Literate Haskell and CoffeeScript to a lesser extent allow
very flexible ordering in the language, which mitigates this problem. But then
we have their authors <a href="http://jashkenas.github.io/docco">telling
us</a> that their tools can be used with any language, blithely ignoring the
fact that other languages may need better tools. Everybody&#39;s selling mechanisms,
nobody&#39;s inculcating the right <a href="http://en.wikipedia.org/wiki/Separation_of_mechanism_and_policy">policies</a>.
</p><p>
<a name="f2">2.</a> We&#39;ve all had the little endorphin rush of seeing our
crappy little papers or assignments magically improved by sprinkling a little
typesetting. And we tend to take well-typeset documents <a href="http://headrush.typepad.com/creating_passionate_users/2006/12/dont_make_the_d.html">more
seriously</a>. The flip side to this phenomenon: if it looks done <a href="http://blog.42floors.com/thirty-percent-feedback">you
won&#39;t get as much feedback on it</a>.



  </p>
  
</div></div>
  </body>
</html>
