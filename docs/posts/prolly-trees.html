<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dolthub.com/blog/2024-03-03-prolly-trees/">Original</a>
    <h1>Prolly Trees</h1>
    
    <div id="readability-page-1" class="page"><div data-cy="blog-post-text"><p>&#34;Prolly Tree&#34; is short for <a href="https://github.com/attic-labs/noms/blob/master/doc/intro.md#prolly-trees-probabilistic-b-trees">&#34;Probabilistic B-tree&#34;</a>. &#34;Prolly Tree&#34; was coined by the good folks who built <a href="https://github.com/attic-labs/noms">Noms</a>, who as far as we can tell invented the data structure. We here at <a href="https://www.dolthub.com">DoltHub</a> have immense respect for their pioneering work, without which <a href="https://www.doltdb.com">Dolt</a> would not exist.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/03acbdf5ef41c160e10a3fee0c578945/913a1/tim-prolly-tree-example.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree" title="" src="https://www.dolthub.com/blog/static/03acbdf5ef41c160e10a3fee0c578945/ad12c/tim-prolly-tree-example.png" srcset="/blog/static/03acbdf5ef41c160e10a3fee0c578945/a48b3/tim-prolly-tree-example.png 214w,
/blog/static/03acbdf5ef41c160e10a3fee0c578945/47730/tim-prolly-tree-example.png 428w,
/blog/static/03acbdf5ef41c160e10a3fee0c578945/ad12c/tim-prolly-tree-example.png 856w,
/blog/static/03acbdf5ef41c160e10a3fee0c578945/7a18f/tim-prolly-tree-example.png 1284w,
/blog/static/03acbdf5ef41c160e10a3fee0c578945/913a1/tim-prolly-tree-example.png 1476w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>A Prolly Tree is a data structure closely related to a <a href="https://en.wikipedia.org/wiki/B-tree">B-tree</a>. Prolly Trees are generally useful but have proven particularly effective as the basis of <a href="https://docs.dolthub.com/architecture/storage-engine">the storage engine</a> for <a href="https://www.dolthub.com/blog/2022-08-04-database-versioning/">version controlled databases</a>. This article explains Prolly Trees in detail.</p>

<p>Let&#39;s say you need a data structure with the following properties:</p>
<ol>
<li><strong>B-tree like performance</strong> - Specifically on reads and writes.</li>
<li><strong>Fast Diffs</strong> - The ability to compare two versions efficiently.</li>
<li><strong>Structural Sharing</strong> - Any given portion of the data shared between versions is only stored once.</li>
</ol>
<p>A Prolly Tree delivers these properties.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>B-Trees</th>
<th>Prolly Trees</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 Random Read</td>
<td>log<sub>k</sub>(n)</td>
<td>log<sub>k</sub>(n)</td>
</tr>
<tr>
<td>1 Random Write</td>
<td>log<sub>k</sub>(n)</td>
<td>(1+k/w)*log<sub>k</sub>(n)</td>
</tr>
<tr>
<td>Ordered scan of one item with size z</td>
<td>z/k</td>
<td>z/k</td>
</tr>
<tr>
<td>Calculate diff of size d</td>
<td>n</td>
<td>d</td>
</tr>
<tr>
<td>Structural sharing</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p><strong>n</strong>: total leaf data in tree, <strong>k</strong>: average block size, <strong>w</strong>: window width</p>
<p>As you can see a Prolly Tree approximates B-tree performance on reads and writes while also offering the ability to compute differences in time proportional to the size of differences rather than the total size of the data. Prolly Trees can also structurally share portions of the tree between versions due to the content-addressed nature of their intermediary storage.</p>
<p>Let&#39;s dive a bit deeper and show you how.</p>

<p>Prolly Trees are a variant of B-trees so let&#39;s first review some key B-tree concepts and then dive into how Prolly Trees work in light of those concepts.</p>
<h2 id="b-tree-review"><a href="#b-tree-review" aria-label="b tree review permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>B-tree Review</h2>
<p>A B-tree is data structure that maps keys to values. A B-tree stores key-value pairs in leaf nodes in sorted order. Internal nodes of a B-tree store pointers to children nodes and key delimiters; everything reachable from a pointer to a child node falls within a range of key values corresponding to the key delimiters before and after that pointer within the internal node.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/d3d5dbbb575eba79ec447ecce160be48/d0ab7/tim-b-tree-example.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="B-tree Example" title="" src="https://www.dolthub.com/blog/static/d3d5dbbb575eba79ec447ecce160be48/ad12c/tim-b-tree-example.png" srcset="/blog/static/d3d5dbbb575eba79ec447ecce160be48/a48b3/tim-b-tree-example.png 214w,
/blog/static/d3d5dbbb575eba79ec447ecce160be48/47730/tim-b-tree-example.png 428w,
/blog/static/d3d5dbbb575eba79ec447ecce160be48/ad12c/tim-b-tree-example.png 856w,
/blog/static/d3d5dbbb575eba79ec447ecce160be48/7a18f/tim-b-tree-example.png 1284w,
/blog/static/d3d5dbbb575eba79ec447ecce160be48/d0ab7/tim-b-tree-example.png 1532w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>A B-tree is optimized for a tradeoff between write and read performance. It&#39;s more expensive to maintain than dropping tuples into a heap without any ordering constraints, but when data is stored in a B-tree it&#39;s much quicker to seek to a given key and to do an in-order traversal of the keys with their values.</p>
<p>However, finding the differences between two B-trees requires scanning both trees and comparing all values, an operation that scales with the size of the tree. This operation is slow for large trees.</p>
<p>Also, writes to B-trees are not history independent, the order of the writes internally changes the structure of the tree. Thus, storage cannot be easily shared between two versions of the same tree.</p>
<h2 id="building-a-prolly-tree"><a href="#building-a-prolly-tree" aria-label="building a prolly tree permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Building a Prolly Tree</h2>
<p>The easiest way to understand Prolly trees is to walk through, step-by-step, how we build one. You start with a map of keys to values. Using the above B-tree example, we have keys between 1 and 21. The values don&#39;t really matter. Just imagine them dangling off the keys.</p>
<ol>
<li><strong>Sort</strong>: Sort the map by its key value, so that it is laid out in order.</li>
</ol>
<p><span>
      <a href="https://www.dolthub.com/blog/static/5f1112d51bfc6477b813c7114aa25479/e17e5/tim-prolly-tree-step-1.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Building a Prolly-Tree, Step 1" title="" src="https://www.dolthub.com/blog/static/5f1112d51bfc6477b813c7114aa25479/e17e5/tim-prolly-tree-step-1.png" srcset="/blog/static/5f1112d51bfc6477b813c7114aa25479/a48b3/tim-prolly-tree-step-1.png 214w,
/blog/static/5f1112d51bfc6477b813c7114aa25479/e17e5/tim-prolly-tree-step-1.png 400w" sizes="(max-width: 400px) 100vw, 400px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<ol start="2">
<li><strong>Determine Chunk Boundaries</strong>: Use a seed, the size of the current chunk, the key value, and a strong hash function to calculate whether this current entry represents a new chunk boundary. Any time the hash value is below a target value, form a chunk boundary and start a new block. Here&#39;s the chunking step on our leaf nodes:</li>
</ol>
<p><span>
      <a href="https://www.dolthub.com/blog/static/5e757de8a6e0e176143472d913c22cf4/e17e5/tim-prolly-tree-step-2.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Building a Prolly-tree, Step 2" title="" src="https://www.dolthub.com/blog/static/5e757de8a6e0e176143472d913c22cf4/e17e5/tim-prolly-tree-step-2.png" srcset="/blog/static/5e757de8a6e0e176143472d913c22cf4/a48b3/tim-prolly-tree-step-2.png 214w,
/blog/static/5e757de8a6e0e176143472d913c22cf4/e17e5/tim-prolly-tree-step-2.png 400w" sizes="(max-width: 400px) 100vw, 400px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<ol start="3">
<li><strong>Hash each Chunk</strong>: You now have the leaf nodes of the Prolly Tree. Compute the content address of each block by applying a strong hash function to its contents. You store the contents in a content addressed block store. Here our blocks have been addressed and stored in the block store:</li>
</ol>
<p><span>
      <a href="https://www.dolthub.com/blog/static/eee93a1e9dd84c149200051c74bdd0da/e17e5/tim-prolly-tree-step-3.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Building a Prolly-tree, Step 3" title="" src="https://www.dolthub.com/blog/static/eee93a1e9dd84c149200051c74bdd0da/e17e5/tim-prolly-tree-step-3.png" srcset="/blog/static/eee93a1e9dd84c149200051c74bdd0da/a48b3/tim-prolly-tree-step-3.png 214w,
/blog/static/eee93a1e9dd84c149200051c74bdd0da/e17e5/tim-prolly-tree-step-3.png 400w" sizes="(max-width: 400px) 100vw, 400px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<ol start="4">
<li>
<p><strong>Finished?</strong>: If the length of your list of content addresses is 1, then you are done. This is the content address of your tree.</p>
</li>
<li>
<p><strong>Build a New Map</strong> Otherwise, form the next layer of your Prolly Tree by creating a map of the highest key value in the chunk and the content address of the chunk. Here&#39;s what the entries for the first internal level of the tree would look like for our example:</p>
</li>
</ol>
<p><span>
      <a href="https://www.dolthub.com/blog/static/d355a63904febe9c252378ed623202c3/69538/tim-prolly-tree-step-5.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Building a Prolly-tree, Step 5" title="" src="https://www.dolthub.com/blog/static/d355a63904febe9c252378ed623202c3/69538/tim-prolly-tree-step-5.png" srcset="/blog/static/d355a63904febe9c252378ed623202c3/69538/tim-prolly-tree-step-5.png 160w" sizes="(max-width: 160px) 100vw, 160px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<ol start="6">
<li><strong>Return to Step 2</strong>: Use the sorted key value pairs for this new map as input to step 2. The algorithm terminates when step 4&#39;s condition is reached.</li>
</ol>
<p>Following these steps results in the following Prolly Tree.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/03acbdf5ef41c160e10a3fee0c578945/913a1/tim-prolly-tree-example.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree" title="" src="https://www.dolthub.com/blog/static/03acbdf5ef41c160e10a3fee0c578945/ad12c/tim-prolly-tree-example.png" srcset="/blog/static/03acbdf5ef41c160e10a3fee0c578945/a48b3/tim-prolly-tree-example.png 214w,
/blog/static/03acbdf5ef41c160e10a3fee0c578945/47730/tim-prolly-tree-example.png 428w,
/blog/static/03acbdf5ef41c160e10a3fee0c578945/ad12c/tim-prolly-tree-example.png 856w,
/blog/static/03acbdf5ef41c160e10a3fee0c578945/7a18f/tim-prolly-tree-example.png 1284w,
/blog/static/03acbdf5ef41c160e10a3fee0c578945/913a1/tim-prolly-tree-example.png 1476w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h2 id="modifying-a-prolly-tree"><a href="#modifying-a-prolly-tree" aria-label="modifying a prolly tree permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modifying a Prolly Tree</h2>
<p>The magic of Prolly Trees is not seen on construction, but on modification. As you&#39;ll see, modifying a Prolly Tree changes the minimal amount of content addresses. Minimal modification means more structural sharing of contents because fewer content addresses change. It is also the basis of fast diff which is accomplished by comparing content addresses.</p>
<h3 id="update-a-value"><a href="#update-a-value" aria-label="update a value permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Update a Value</h3>
<p>If we update a value, we walk the tree by key to the leaf node holding the value. We then create the new leaf chunk by directly modifying the existing value in a copy of the existing chunk (ie. <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy on write</a>). After the edit, we recalculate the content address of the chunk. We then walk up the tree recalculating each internal content address up to the root of the tree.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/ad1ff2c1ba7b835a0fd5d583ec321abb/9c701/prolly-tree-update-value.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree Value Update" title="" src="https://www.dolthub.com/blog/static/ad1ff2c1ba7b835a0fd5d583ec321abb/ad12c/prolly-tree-update-value.png" srcset="/blog/static/ad1ff2c1ba7b835a0fd5d583ec321abb/a48b3/prolly-tree-update-value.png 214w,
/blog/static/ad1ff2c1ba7b835a0fd5d583ec321abb/47730/prolly-tree-update-value.png 428w,
/blog/static/ad1ff2c1ba7b835a0fd5d583ec321abb/ad12c/prolly-tree-update-value.png 856w,
/blog/static/ad1ff2c1ba7b835a0fd5d583ec321abb/7a18f/prolly-tree-update-value.png 1284w,
/blog/static/ad1ff2c1ba7b835a0fd5d583ec321abb/56caf/prolly-tree-update-value.png 1712w,
/blog/static/ad1ff2c1ba7b835a0fd5d583ec321abb/9c701/prolly-tree-update-value.png 1774w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Note, this is only true for fixed-size value updates. If you change the length of a value, then we do have to re-chunk. Changes to NULL values or strings are not fixed length updates.</p>
<h3 id="insert-keys"><a href="#insert-keys" aria-label="insert keys permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Insert Keys</h3>
<p>We can insert keys at the beginning, middle, or end of the key space. It&#39;s helpful to visualize each type of insert.</p>
<p>When we insert a key, we walk the tree by key to the leaf node where the key belongs. We then edit the chunk, calculate whether to split the chunk or not, and then recalculate the content address. Note, a key insert or a delete has a small probability of changing an existing chunk boundary. If the computed hash values for the keys, combined with the size of chunk at those keys, happens to choose a different chunk boundary, the chunk will be split at the new boundary. Finally, we walk up the tree recalculating each content address up to the root of the tree.</p>
<p>In Dolt&#39;s Prolly Tree implementation, chunks are set to be on average 4 kilobytes. This means that you can imagine a probability of 1/4096 or 0.02% of triggering a chunk boundary shift when changing a single byte. In practice, it&#39;s quite a bit more complicated. As we&#39;ll discuss later, the size of the chunk is considered when computing a chunk boundary split. So, the larger the chunk, the greater the probability the chunk will be split on the addition of a new key. Conversely, for small chunks, the probability of a chunk split is very small. This means that every edit to a table in Dolt is a minimum of 4Kb multiplied by the depth of the tree with some small probability of writing multiple chunks.</p>
<h4 id="at-the-beginning"><a href="#at-the-beginning" aria-label="at the beginning permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>At the Beginning</h4>
<p>When you insert a key at the beginning of the key space, the tree is modified along the left edge.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/bc6f77b81975068dd8eb5f43057231e0/9c701/prolly-tree-front-insert.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree Beginning Insert" title="" src="https://www.dolthub.com/blog/static/bc6f77b81975068dd8eb5f43057231e0/ad12c/prolly-tree-front-insert.png" srcset="/blog/static/bc6f77b81975068dd8eb5f43057231e0/a48b3/prolly-tree-front-insert.png 214w,
/blog/static/bc6f77b81975068dd8eb5f43057231e0/47730/prolly-tree-front-insert.png 428w,
/blog/static/bc6f77b81975068dd8eb5f43057231e0/ad12c/prolly-tree-front-insert.png 856w,
/blog/static/bc6f77b81975068dd8eb5f43057231e0/7a18f/prolly-tree-front-insert.png 1284w,
/blog/static/bc6f77b81975068dd8eb5f43057231e0/56caf/prolly-tree-front-insert.png 1712w,
/blog/static/bc6f77b81975068dd8eb5f43057231e0/9c701/prolly-tree-front-insert.png 1774w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h4 id="at-the-end"><a href="#at-the-end" aria-label="at the end permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>At the end</h4>
<p>When you insert a key at the end of the key space, the tree is modified along the right edge.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/bad97586489c3529d206ef0513de2c4d/9c701/prolly-tree-back-insert.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree End Insert" title="" src="https://www.dolthub.com/blog/static/bad97586489c3529d206ef0513de2c4d/ad12c/prolly-tree-back-insert.png" srcset="/blog/static/bad97586489c3529d206ef0513de2c4d/a48b3/prolly-tree-back-insert.png 214w,
/blog/static/bad97586489c3529d206ef0513de2c4d/47730/prolly-tree-back-insert.png 428w,
/blog/static/bad97586489c3529d206ef0513de2c4d/ad12c/prolly-tree-back-insert.png 856w,
/blog/static/bad97586489c3529d206ef0513de2c4d/7a18f/prolly-tree-back-insert.png 1284w,
/blog/static/bad97586489c3529d206ef0513de2c4d/56caf/prolly-tree-back-insert.png 1712w,
/blog/static/bad97586489c3529d206ef0513de2c4d/9c701/prolly-tree-back-insert.png 1774w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h4 id="in-the-middle"><a href="#in-the-middle" aria-label="in the middle permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>In the middle</h4>
<p>When you insert a key in the middle of the key space, the tree is modified along a spline.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/3c2a860686f122d7848affd0eb3a5082/9c701/prolly-tree-middle-insert.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree Middle Insert" title="" src="https://www.dolthub.com/blog/static/3c2a860686f122d7848affd0eb3a5082/ad12c/prolly-tree-middle-insert.png" srcset="/blog/static/3c2a860686f122d7848affd0eb3a5082/a48b3/prolly-tree-middle-insert.png 214w,
/blog/static/3c2a860686f122d7848affd0eb3a5082/47730/prolly-tree-middle-insert.png 428w,
/blog/static/3c2a860686f122d7848affd0eb3a5082/ad12c/prolly-tree-middle-insert.png 856w,
/blog/static/3c2a860686f122d7848affd0eb3a5082/7a18f/prolly-tree-middle-insert.png 1284w,
/blog/static/3c2a860686f122d7848affd0eb3a5082/56caf/prolly-tree-middle-insert.png 1712w,
/blog/static/3c2a860686f122d7848affd0eb3a5082/9c701/prolly-tree-middle-insert.png 1774w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h3 id="delete-a-key"><a href="#delete-a-key" aria-label="delete a key permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Delete a key</h3>
<p>When you delete a key, the tree is modified under the same rules as an insert.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/d9acfc182a1485780483e91cc2972d8f/9c701/prolly-tree-delete.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree Delete Key" title="" src="https://www.dolthub.com/blog/static/d9acfc182a1485780483e91cc2972d8f/ad12c/prolly-tree-delete.png" srcset="/blog/static/d9acfc182a1485780483e91cc2972d8f/a48b3/prolly-tree-delete.png 214w,
/blog/static/d9acfc182a1485780483e91cc2972d8f/47730/prolly-tree-delete.png 428w,
/blog/static/d9acfc182a1485780483e91cc2972d8f/ad12c/prolly-tree-delete.png 856w,
/blog/static/d9acfc182a1485780483e91cc2972d8f/7a18f/prolly-tree-delete.png 1284w,
/blog/static/d9acfc182a1485780483e91cc2972d8f/56caf/prolly-tree-delete.png 1712w,
/blog/static/d9acfc182a1485780483e91cc2972d8f/9c701/prolly-tree-delete.png 1774w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>

<h2 id="history-independence"><a href="#history-independence" aria-label="history independence permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>History Independence</h2>
<p>A key property of a Prolly tree that enables fast diff and structural sharing is history independence. No matter which order you insert, update, or delete values, the Prolly tree is the same. This is best seen through example.</p>
<p>Consider a map with 4 integer keys, <code>(1, 2, 3, 4)</code> pointing at the same values. Before hand we know the combination of keys <code>(1, 2)</code> will trigger a chunk boundary. We can know this beforehand because chunk boundaries are based on the size of the chunk and its contents. No matter which order we insert, update, or delete, if we will end up with a tree with two leaf nodes <code>(1, 2)</code>, and <code>(3,4)</code>. This also happens to be true if the keys have different values. The tree will be the same but the the chunks will have different addresses.</p>
<p>Let&#39;s say we insert the chunks in sequential order.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/f7d857b8966db68bf6bd00b2f484f64d/cea38/prolly-tree-history-independence-1.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree History Independence" title="" src="https://www.dolthub.com/blog/static/f7d857b8966db68bf6bd00b2f484f64d/ad12c/prolly-tree-history-independence-1.png" srcset="/blog/static/f7d857b8966db68bf6bd00b2f484f64d/a48b3/prolly-tree-history-independence-1.png 214w,
/blog/static/f7d857b8966db68bf6bd00b2f484f64d/47730/prolly-tree-history-independence-1.png 428w,
/blog/static/f7d857b8966db68bf6bd00b2f484f64d/ad12c/prolly-tree-history-independence-1.png 856w,
/blog/static/f7d857b8966db68bf6bd00b2f484f64d/7a18f/prolly-tree-history-independence-1.png 1284w,
/blog/static/f7d857b8966db68bf6bd00b2f484f64d/cea38/prolly-tree-history-independence-1.png 1644w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Then, let&#39;s say we insert the keys in reverse order.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/9a295236ddf874fb0289405d9dc711cf/cea38/prolly-tree-history-independence-2.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree History Independence" title="" src="https://www.dolthub.com/blog/static/9a295236ddf874fb0289405d9dc711cf/ad12c/prolly-tree-history-independence-2.png" srcset="/blog/static/9a295236ddf874fb0289405d9dc711cf/a48b3/prolly-tree-history-independence-2.png 214w,
/blog/static/9a295236ddf874fb0289405d9dc711cf/47730/prolly-tree-history-independence-2.png 428w,
/blog/static/9a295236ddf874fb0289405d9dc711cf/ad12c/prolly-tree-history-independence-2.png 856w,
/blog/static/9a295236ddf874fb0289405d9dc711cf/7a18f/prolly-tree-history-independence-2.png 1284w,
/blog/static/9a295236ddf874fb0289405d9dc711cf/cea38/prolly-tree-history-independence-2.png 1644w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>As you can see, we end up with the same Prolly Tree no matter which order we insert the values. It&#39;s a fun exercise to try and come up with a sequence of inserts, updates, and deletes that result in a different tree containing the same values. It&#39;s fun because you can&#39;t. The Prolly Tree algorithm always spits out the same tree.</p>
<h2 id="fast-diff"><a href="#fast-diff" aria-label="fast diff permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fast Diff</h2>
<p>Given history independence, the Prolly Tree difference calculation becomes quite simple. If the hash of the root chunk is the same the entire subtree is the same. Thus, to calculate differences, one must walk the tree down to the leaves, ignoring hashes that are equal. Hashes that are different represent the difference.</p>
<p>Let&#39;s see how this algorithm works in practice. Recall the Prolly Tree where I updated the value in key 9. Let&#39;s compare it to our originally built Prolly Tree.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/033d15981be0d43c77ac3204611820d6/3126c/prolly-tree-diff-step-1.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree Diff Step 1" title="" src="https://www.dolthub.com/blog/static/033d15981be0d43c77ac3204611820d6/ad12c/prolly-tree-diff-step-1.png" srcset="/blog/static/033d15981be0d43c77ac3204611820d6/a48b3/prolly-tree-diff-step-1.png 214w,
/blog/static/033d15981be0d43c77ac3204611820d6/47730/prolly-tree-diff-step-1.png 428w,
/blog/static/033d15981be0d43c77ac3204611820d6/ad12c/prolly-tree-diff-step-1.png 856w,
/blog/static/033d15981be0d43c77ac3204611820d6/7a18f/prolly-tree-diff-step-1.png 1284w,
/blog/static/033d15981be0d43c77ac3204611820d6/56caf/prolly-tree-diff-step-1.png 1712w,
/blog/static/033d15981be0d43c77ac3204611820d6/3126c/prolly-tree-diff-step-1.png 1876w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Start by comparing the root hashes. They are necessarily different.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/9deba4fa9ee7b23dfff5ac039ce314d7/3126c/prolly-tree-diff-step-2.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree Diff Step 2" title="" src="https://www.dolthub.com/blog/static/9deba4fa9ee7b23dfff5ac039ce314d7/ad12c/prolly-tree-diff-step-2.png" srcset="/blog/static/9deba4fa9ee7b23dfff5ac039ce314d7/a48b3/prolly-tree-diff-step-2.png 214w,
/blog/static/9deba4fa9ee7b23dfff5ac039ce314d7/47730/prolly-tree-diff-step-2.png 428w,
/blog/static/9deba4fa9ee7b23dfff5ac039ce314d7/ad12c/prolly-tree-diff-step-2.png 856w,
/blog/static/9deba4fa9ee7b23dfff5ac039ce314d7/7a18f/prolly-tree-diff-step-2.png 1284w,
/blog/static/9deba4fa9ee7b23dfff5ac039ce314d7/56caf/prolly-tree-diff-step-2.png 1712w,
/blog/static/9deba4fa9ee7b23dfff5ac039ce314d7/3126c/prolly-tree-diff-step-2.png 1876w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Then walk both chunks identifying the subtree hashes that are different. In this case, a single hash is different.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/cac7150e92e24f5a3910d9feb1aa9a75/3126c/prolly-tree-diff-step-3.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree Diff Step 3" title="" src="https://www.dolthub.com/blog/static/cac7150e92e24f5a3910d9feb1aa9a75/ad12c/prolly-tree-diff-step-3.png" srcset="/blog/static/cac7150e92e24f5a3910d9feb1aa9a75/a48b3/prolly-tree-diff-step-3.png 214w,
/blog/static/cac7150e92e24f5a3910d9feb1aa9a75/47730/prolly-tree-diff-step-3.png 428w,
/blog/static/cac7150e92e24f5a3910d9feb1aa9a75/ad12c/prolly-tree-diff-step-3.png 856w,
/blog/static/cac7150e92e24f5a3910d9feb1aa9a75/7a18f/prolly-tree-diff-step-3.png 1284w,
/blog/static/cac7150e92e24f5a3910d9feb1aa9a75/56caf/prolly-tree-diff-step-3.png 1712w,
/blog/static/cac7150e92e24f5a3910d9feb1aa9a75/3126c/prolly-tree-diff-step-3.png 1876w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Follow the pointer to the next layer and compare those chunks, finding the hashes that are different. If you are in a leaf node, produce the values that are different.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/6c8a9c9db9fe33dc23db6c07ad2b1c97/3126c/prolly-tree-diff-step-4.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Prolly Tree Diff Step 4" title="" src="https://www.dolthub.com/blog/static/6c8a9c9db9fe33dc23db6c07ad2b1c97/ad12c/prolly-tree-diff-step-4.png" srcset="/blog/static/6c8a9c9db9fe33dc23db6c07ad2b1c97/a48b3/prolly-tree-diff-step-4.png 214w,
/blog/static/6c8a9c9db9fe33dc23db6c07ad2b1c97/47730/prolly-tree-diff-step-4.png 428w,
/blog/static/6c8a9c9db9fe33dc23db6c07ad2b1c97/ad12c/prolly-tree-diff-step-4.png 856w,
/blog/static/6c8a9c9db9fe33dc23db6c07ad2b1c97/7a18f/prolly-tree-diff-step-4.png 1284w,
/blog/static/6c8a9c9db9fe33dc23db6c07ad2b1c97/56caf/prolly-tree-diff-step-4.png 1712w,
/blog/static/6c8a9c9db9fe33dc23db6c07ad2b1c97/3126c/prolly-tree-diff-step-4.png 1876w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>As you can see this algorithm scales with the size of the differences, not the size of the tree. This makes finding small differences in even large trees very fast.</p>
<h2 id="structural-sharing"><a href="#structural-sharing" aria-label="structural sharing permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Structural Sharing</h2>
<p>Recall that Prolly trees are stored in a content addressed block store where the content address forms the lookup key for the block.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/eee93a1e9dd84c149200051c74bdd0da/e17e5/tim-prolly-tree-step-3.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Content Addressed Block Store" title="" src="https://www.dolthub.com/blog/static/eee93a1e9dd84c149200051c74bdd0da/e17e5/tim-prolly-tree-step-3.png" srcset="/blog/static/eee93a1e9dd84c149200051c74bdd0da/a48b3/tim-prolly-tree-step-3.png 214w,
/blog/static/eee93a1e9dd84c149200051c74bdd0da/e17e5/tim-prolly-tree-step-3.png 400w" sizes="(max-width: 400px) 100vw, 400px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Thus, any blocks that share the same content address are only stored in the block store once. When they need to be retrieved they are retrieved via content address. This means that any blocks shared across versions will only be in the block store once.</p>
<p>As noted earlier, in Dolt&#39;s Prolly Tree implementation, the block size is set to be on average 4 kilobytes. Thus, a single change will cause a change in the block store of 4 kilobytes times the size of the tree on average.</p>

<p>Now that you have the general details, let&#39;s dive into some details highlighting some of the things we learned iterating on the Noms implementation of Prolly Trees and finally landing on Dolt&#39;s stable Prolly Tree implementation.</p>
<h2 id="controlling-chunk-size"><a href="#controlling-chunk-size" aria-label="controlling chunk size permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Controlling Chunk Size</h2>
<p>The original Noms implementation of Prolly Trees was susceptible to a chunk size problem. You would end up with many small chunks and a few large ones. The chunk size was a geometric distribution with an average size of 4 kilobytes.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/6d2f046fee7d2fbf73da6c92dcae69bd/477c9/chunk-distribution-static-pattern.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Chunk Size Geometric" title="" src="https://www.dolthub.com/blog/static/6d2f046fee7d2fbf73da6c92dcae69bd/477c9/chunk-distribution-static-pattern.png" srcset="/blog/static/6d2f046fee7d2fbf73da6c92dcae69bd/a48b3/chunk-distribution-static-pattern.png 214w,
/blog/static/6d2f046fee7d2fbf73da6c92dcae69bd/477c9/chunk-distribution-static-pattern.png 288w" sizes="(max-width: 288px) 100vw, 288px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>This is the pattern one would expect from repeated rolls of a rolling hash function. Let&#39;s imagine you have a six-sided die. You walk along the road picking up pebbles. For each pebble, you put it in a bag and roll the die. If the die shows 6 you get a new bag. The average number of pebbles you have in each bag is 3.5 but you will mostly have bags with one pebble and a few bags with &gt;10 pebbles. The pebbles in the Noms case was the key-value byte stream and the dice was the rolling hash function.</p>
<p>Large chunks create a particular problem, especially on the read path, because you are more likely to be reading from large chunks. Within each chunk a binary search is performed to find the key you want. The larger the chunk the slower this is at log<sub>2</sub>(n) chunk size. So, you really want to keep a normally distributed chunk size.</p>
<p>To fix this, Dolt&#39;s Prolly Tree implementation considers the chunk size when deciding whether to make a boundary. Given a target probability distribution function (PDF), Dolt uses its associated cumulative distribution function (CDF) to decide the probability of splitting a chunk of size x. Specifically, we use the formula <code>(CDF(end) - CDF(start)) / (1 - CDF(start))</code> to calculate the target probability. So, if the current chunk size is 2000 bytes the probability of triggering a boundary by appending a 64 byte key-value pair is <code>(CDF(2064) - CDF(2000) / 1 - CDF(2000)</code>. In Dolt, we want our chunk size normally distributed around 4 kilobytes and by using the above approach, we get that.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/38d7bd480fa152b3248068e5026fb9c2/477c9/chunk-distribution-dynamic-pattern.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Chunk Size Normal" title="" src="https://www.dolthub.com/blog/static/38d7bd480fa152b3248068e5026fb9c2/477c9/chunk-distribution-dynamic-pattern.png" srcset="/blog/static/38d7bd480fa152b3248068e5026fb9c2/a48b3/chunk-distribution-dynamic-pattern.png 214w,
/blog/static/38d7bd480fa152b3248068e5026fb9c2/477c9/chunk-distribution-dynamic-pattern.png 288w" sizes="(max-width: 288px) 100vw, 288px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h2 id="only-consider-keys"><a href="#only-consider-keys" aria-label="only consider keys permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Only Consider Keys</h2>
<p>Noms original Prolly Tree implementation considered keys and values when deciding when to make a chunk boundary. Dolt&#39;s implementation only considers keys.</p>
<p>Dolt&#39;s Prolly Trees have the advantage of backing a SQL database. SQL databases define schema with fixed types. Fixed types have maximum sizes. Thus, any updates to values can be done in place because the values will be the same size. If we compute the hash of contents using only keys, any fixed size update to values is guaranteed not to shift the chunk boundary. This is a desirable property that improves update performance.</p>
<p>Moreover, Noms rolling hash function, <a href="https://github.com/silvasur/buzhash">buzhash</a>, performed poorly for byte streams with low entropy. Tables with ordered keys, specifically time series data where very little changes at each sample, were problematic. This would again lead to very large chunks. No chunk boundary was triggered on inserts because most of the byte stream considered by the rolling hash function was the same. By considering only keys, which again are necessarily unique, Dolt&#39;s hash function created chunk boundaries more normally.</p>
<p>One subtlety of this change is that Dolt now chunks to an average number of key-value pairs rather than an average size of 4 kilobytes, but this difference disappears when used in concert with chunk size consideration in the probability of creating chunk boundaries.</p>
<h2 id="less-flexible-block-store"><a href="#less-flexible-block-store" aria-label="less flexible block store permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Less Flexible Block Store</h2>
<p>Prolly Trees themselves are block store agnostic. So if you only care about the Prolly Tree data structure, you can skip this section.</p>
<p>Noms block store encoded the types of the data in the store. Dolt&#39;s block store is built for a SQL database with fixed schema. Thus, type information is stored out of band of the block store and a <a href="https://www.dolthub.com/blog/2022-05-20-new-format-alpha/">more specific, less flexible layout of data on disk is used</a>. This new, type-less layout improves Dolt read and write performance.</p>

<p>Recall this table:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>B-Trees</th>
<th>Prolly Trees</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 Random Read</td>
<td>log<sub>k</sub>(n)</td>
<td>log<sub>k</sub>(n)</td>
</tr>
<tr>
<td>1 Random Write</td>
<td>log<sub>k</sub>(n)</td>
<td>(1+k/w)*log<sub>k</sub>(n)</td>
</tr>
<tr>
<td>Ordered scan of one item with size z</td>
<td>z/k</td>
<td>z/k</td>
</tr>
<tr>
<td>Calculate diff of size d</td>
<td>n</td>
<td>d</td>
</tr>
<tr>
<td>Structural sharing</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p><strong>n</strong>: total leaf data in tree, <strong>k</strong>: average block size, <strong>w</strong>: window width</p>
<p>We now understand what <code>n</code>, <code>k</code>, and <code>w</code> are in the context of B-Trees and Prolly Trees. As you can see, B-Trees and Prolly Trees offer similar read performance. Prolly Trees pay a slight performance penalty on writes due to the small probability of a chunk split. However, Prolly Trees can produce differences in time proportional to the size of the differences, rather than the size of the tree.</p>
<p>Note, the additional complexity for one random write is because of chunk splits. In Noms, the probability of a chunk split was <code>k/w</code>. Thus, you multiply one plus that probability in the big 0 complexity calculation. Dolt no longer relies on average block size and window size to split chunks. So, in Dolt&#39;s Prolly Tree implementation, there is still a small complexity burden on write but the complexity is harder to calculate.</p>

<p>In Dolt, <a href="https://docs.dolthub.com/architecture/storage-engine#commit-graph">all data in the database is stored in Prolly Trees</a>.</p>
<p>For table data, a map of primary key to data columns is stored in a Prolly Tree. Similarly, secondary indexes are maps of index values to the primary key identifying each row. Schemas are stored as Prolly trees to make calculating the root of the database easy. Keyless tables are implemented as every column is a primary key with a count of the number of duplicate rows as the value.</p>

<p>This all looks good on paper. How do Prolly Trees work in practice? On a standard suite of <code>sysbench</code> performance tests, Dolt is approximately <a href="https://docs.dolthub.com/sql-reference/benchmarks/latency">2X slower than MySQL</a>.</p>
<p>Upon profiling, we find most of the performance difference to be unrelated to Prolly Trees. The performance difference comes from:</p>
<ol>
<li>Dolt is implemented in Golang. MySQL is implemented in C.</li>
<li>MySQL&#39;s SQL analyzer is faster than Dolt&#39;s because it is more mature.</li>
<li>MySQL does fewer transformations on data than Dolt to get it into the necessary wire format.</li>
</ol>
<p>Dolt can <a href="https://www.dolthub.com/blog/2022-06-03-dolt-diff-vs-sqlite-diff/">compute diffs in time proportional to the size of the differences</a>. Dolt structurally shares <a href="https://www.dolthub.com/blog/2023-12-06-sizing-your-dolt-instance/#version-storage">data across versions</a>.</p>

<p>As you can see, Prolly Trees are an ideal data structure to back a version controlled database. Dolt uses Prolly Tree backed storage. Curious to learn more? Come by <a href="https://discord.gg/gqr7K4VNKe">our Discord</a> and ask us some questions.</p></div></div>
  </body>
</html>
