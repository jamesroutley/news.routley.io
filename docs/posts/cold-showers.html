<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/hwayne/awesome-cold-showers">Original</a>
    <h1>Cold Showers</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">It&#39;s great when people get excited about things, but sometimes they get a little <em>too</em> excited. This an awesome (rigorous and respectful) and curated (I read every suggestion and make judgement calls) list of cold showers on overhyped topics. This does <strong>not</strong> mean the enthusiasm is bad or wrong: we&#39;re just reminding people to stay grounded. Feel free to submit your favorites!</p>
<h4 dir="auto"><a id="user-content-verification-techniques-pdf" aria-hidden="true" href="#verification-techniques-pdf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://web.archive.org/web/20170214231046/https://www.cypherpunks.to/~peter/04_verif_techniques.pdf" rel="nofollow">Verification Techniques</a> (PDF)</h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> &#34;Formal Verification is a great way to write software. We should prove all of our code correct.&#34;</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> Extensive literature review showing that formal methods are hard to learn, extremely expensive to apply, and often miss critical bugs.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> Written in 2000 and doesn&#39;t cover modern tools/techniques, such as TLA+ or dependent typing.</p>
</li>
<li>
<p dir="auto"><strong>Notes:</strong> Part of <a href="https://www.cs.auckland.ac.nz/~pgut001/" rel="nofollow">Peter Gutmann</a>&#39;s thesis, &#34;The Design and Verification of a Cryptographic Security Architecture&#34;. The whole thesis can be found <a href="https://archive.org/details/springer_10.1007-b97264/mode/2up" rel="nofollow">here</a>.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-static-vs-dynamic-typing-a-literature-review" aria-hidden="true" href="#static-vs-dynamic-typing-a-literature-review"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://danluu.com/empirical-pl/" rel="nofollow">Static vs Dynamic Typing: a literature review</a></h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> &#34;Static Typing reduces bugs.&#34;</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> A review of all the available literature (up to 2014), showing that the solid research is inconclusive, while the conclusive research had methodological issues.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> Does not cover other possible benefits of static typing, like documentation. Does not address research on gradual type systems, like mypy or Typescript.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-scalability-but-at-what-cost" aria-hidden="true" href="#scalability-but-at-what-cost"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="http://www.frankmcsherry.org/graph/scalability/cost/2015/01/15/COST.html" rel="nofollow">Scalability! but at what COST?</a></h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> &#34;We need big data systems to handle big data.&#34;</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> Benchmarking cutting-edge graph-processing algorithms running on 128-core clusters against a single-threaded 2014 Macbook Pro. The laptop consistently wins, sometimes by an order of magnitude.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> McSherry is really good at optimizing his algorithms and has skills the average data scientist does not. Big data systems might be better if you have ad-hoc queries and don&#39;t want to take the time to optimize them.</p>
</li>
<li>
<p dir="auto"><strong>Notes:</strong> &#34;If you are going to use a big data system for yourself, see if it is faster than your laptop. If you are going to build a big data system for others, see that it is faster than my laptop.&#34;</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-web-framework-benchmarks" aria-hidden="true" href="#web-framework-benchmarks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://www.techempower.com/benchmarks/" rel="nofollow">Web Framework Benchmarks</a></h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> Anything about performance or scalability of various languages/web frameworks/databases.</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> Actual hard data of various combinations of solutions under various tasks.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> Raw data you have to interpret yourself. <del>Does not provide a complete dump of the raw data for your own analysis.</del> Raw data can now be found <a href="http://tfb-logs.techempower.com/" rel="nofollow">here</a></p>
</li>
<li>
<p dir="auto"><strong>Notes:</strong> <a href="https://tfb-status.techempower.com/" rel="nofollow">Continually updating</a> with new benchmarks. All implementations are public and you can improve them with a PR.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-agile-methods-the-good-the-hype-and-the-ugly-video" aria-hidden="true" href="#agile-methods-the-good-the-hype-and-the-ugly-video"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://www.youtube.com/watch?v=ffkIQrq-m34" rel="nofollow">Agile Methods: The Good, the Hype and the Ugly</a> (Video)</h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> &#34;We should develop software using Agile.&#34;</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> Review of all the different styles of Agile and how some of the practices (particularly replacing requirements with user stories and the lack of proper specification) are harmful in the long run.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> While Meyer calls out some problems, overall he&#39;s very positive about Agile and recommends it as a good (but imperfect) methodology.</p>
</li>
<li>
<p dir="auto"><strong>Notes:</strong> Starts at <a href="https://youtu.be/ffkIQrq-m34?t=3m30s" rel="nofollow">3:30</a>. There&#39;s a <a href="https://www.youtube.com/watch?v=Q_9k6ym5BZU" rel="nofollow">followup video</a> where he answers audience questions.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-an-empirical-study-on-the-correctness-of-formally-verified-systems-pdf" aria-hidden="true" href="#an-empirical-study-on-the-correctness-of-formally-verified-systems-pdf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://homes.cs.washington.edu/~pfonseca/papers/eurosys2017-dsbugs.pdf" rel="nofollow">An Empirical Study on the Correctness of Formally Verified Systems</a> (PDF)</h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> &#34;If I formally verify my code, I don&#39;t need to test it!&#34;</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> Researchers looked at three formally verified systems, and found critical correctness bugs in all three. The bugs were from &#34;a wide range of mismatched assumptions&#34; and caused servers to crash or produce wrong data.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> Most bugs were at the system boundaries; none were found in the implemented protocols. Formally verified systems, while not perfect, were considerably less buggy than unverified systems.</p>
</li>
<li>
<p dir="auto"><strong>Notes:</strong>  Systems were verified with Coq and Z3. Further discussion at <a href="https://blog.acolyer.org/2017/05/29/an-empirical-study-on-the-correctness-of-formally-verified-distributed-systems/" rel="nofollow">The Morning Paper</a>.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-fixing-faults-in-c-and-java-source-code-abbreviated-vs-full-word-identiﬁer-names-pdf" aria-hidden="true" href="#fixing-faults-in-c-and-java-source-code-abbreviated-vs-full-word-identiﬁer-names-pdf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="http://www2.unibas.it/gscanniello/Giuseppe_Scanniello%40unibas/Home_files/TOSEM.pdf" rel="nofollow">Fixing Faults in C and Java Source Code: Abbreviated vs. Full-word Identiﬁer Names</a> (PDF)</h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> &#34;Identifiers should be self-documenting! Use full names, not abbreviations.&#34;</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> Researchers had programmers fix bugs in a codebase, either with all of the identifiers were abbreviated, or where all of the identifiers were full-words. They found no difference in time taken or quality of debugging.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> Only applies to fixing bugs. Otherwise watertight. This is honestly one of the most rigorous and comprehensive papers I&#39;ve ever read.</p>
</li>
<li>
<p dir="auto"><strong>Notes:</strong> Includes ethnography on how programmers debug abbreviated code. Link is to the author preprint.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-microservices---please-dont" aria-hidden="true" href="#microservices---please-dont"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="http://basho.com/posts/technical/microservices-please-dont/" rel="nofollow">Microservices - Please, don&#39;t</a></h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> &#34;Microservices! Microservices!&#34;</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> Presents five fallacies of &#34;why microservices solve problems monoliths have&#34; and shows how either monoliths don&#39;t actually have those problems or that microservices make the problem even worse.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> Abstract arguments and experience, no case studies or examples.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-vm-warmup-blows-hot-and-cold" aria-hidden="true" href="#vm-warmup-blows-hot-and-cold"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://arxiv.org/abs/1602.00602" rel="nofollow">VM Warmup Blows Hot and Cold</a></h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype</strong>: Your favourite programming language has been updated. The new
version makes impressive performance improvement claims.</p>
</li>
<li>
<p dir="auto"><strong>Shower</strong>: Benchmarking modern programming languages under near-ideal
circumstances, just for longer than before, suggests that we have not been
benchmarking language implementations as accurately as we might wish. Many
benchmarks slow down over time. Some never stabilise. Many benchmarking
experiments will not be repeatable due to non-determinism. Warmup time is
important, but is usually either ignored, or reported inaccurately.</p>
</li>
<li>
<p dir="auto"><strong>Caveats</strong>: Only evaluates the x86_64 architecture, and for only two
operating systems (Linux and OpenBSD). Experiment conducted in 2017 (prior to
meltdown patching). Evaluates mainly JITted language implementations
(although C benchmarks were included).</p>
</li>
<li>
<p dir="auto"><strong>Notes</strong>: The experiment and the benchmark runner are published under an
open source license. <a href="https://github.com/softdevteam/warmup_experiment">Start here</a>.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-scaling-sqlite-to-4m-qps-on-a-single-server" aria-hidden="true" href="#scaling-sqlite-to-4m-qps-on-a-single-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://blog.expensify.com/2018/01/08/scaling-sqlite-to-4m-qps-on-a-single-server/" rel="nofollow">Scaling SQLite to 4M QPS on a Single Server</a></h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> &#34;Scaling out is better than scaling up. Cloud is more scalable than bare metal.&#34;</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> Expensify found that running a single bare-metal server was both faster and cheaper than using a x1e.32xlarge EC2 instance. By using one server, they could avoid sharding their data.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> Does not cover if scaling out bare metal has the same advantages over scaling out EC2 (assuming you can afford sharding). Can&#39;t really compare how much cheaper the bare metal is because they don&#39;t list the cost. I&#39;m guessing their servers are 100k each? No basis for that guess though.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-understanding-real-world-concurrency-bugs-in-go-pdf" aria-hidden="true" href="#understanding-real-world-concurrency-bugs-in-go-pdf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><a href="https://songlh.github.io/paper/go-study.pdf" rel="nofollow">Understanding Real-World Concurrency Bugs in Go (PDF)</a></h4>
<ul dir="auto">
<li>
<p dir="auto"><strong>Hype:</strong> Compared to other languages, Go&#39;s concurrency system of goroutines and channels is easier to understand, easier to use, and is less prone to bugs and memory leaks.</p>
</li>
<li>
<p dir="auto"><strong>Shower:</strong> According to an empirical study by Tu, <em>et al</em>, there are plenty of concurrency-related bugs related to the difficulty in understanding and following the concurrency features and patterns provided by Go.</p>
</li>
<li>
<p dir="auto"><strong>Caveats:</strong> This study is specific to Go. Though other languages provide similar facilities, they are not covered in this article. Also, the types of bugs seen with channels and shared memory are different. Channels lead to more blocking bugs (deadlocks, dangling channels) while shared-memory lead to more nonblocking bugs (race conditions, dirty reads).</p>
</li>
<li>
<p dir="auto"><strong>Notes:</strong> &#34;We studied six popular Go software including Docker, Kubernetes, and gRPC. We analyzed 171 concurrency bugs in total, with more than half of them caused by non-traditional, Go-specific problems&#34;</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-plug" aria-hidden="true" href="#plug"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Plug</h2>
<p dir="auto">You can find my general ravings on my <a href="https://hillelwayne.com" rel="nofollow">website</a> or <a href="https://twitter.com/Hillelogram" rel="nofollow">twitter</a>.</p>
</article>
          </div></div>
  </body>
</html>
