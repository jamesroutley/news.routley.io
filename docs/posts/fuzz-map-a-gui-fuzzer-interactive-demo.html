<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fuzzmap.io/?welcome=1">Original</a>
    <h1>Show HN: Fuzz Map – a GUI fuzzer, interactive demo</h1>
    
    <div id="readability-page-1" class="page"><div id="welcome-modal-text">
          
          <p>
            <em>Fuzz Map</em> is a fuzzer for GUIs that automatically identifies states using code
            coverage and builds a visual map. Ideally, the map is useful even to people who&#39;d prefer
            not to read code.
          </p>
          <p>
            Behind this window is a interactive local demo.
            Hide this introduction then click
            <span>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <title>fuzz</title>
                <path d="M9 9a2 2 0 114 0 2 2 0 01-4 0z"></path>
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.415l2.261-2.261A4 4 0 1011 5z" clip-rule="evenodd"></path>
              </svg>
              Fuzz</span>
            to start fuzzing. To show this introduction again, click the
            <span>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <title>information</title>
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
              </svg>
              Information</span>
            button.
          </p>
          <p>
            Here&#39;s a 5-second video of real-time fuzzing on my laptop. Every state or arrow in the
            map corresponds to one or more codepaths discovered by the fuzzer:
          </p>
          
          <p>
            The <em>sandbox</em> renders the React code in the <em>editor</em> (specifically, it
            renders <code>&lt;App /&gt;</code>). Click
            <span>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <title>compile</title>
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path>
              </svg>
              Compile</span>
            to update the sandbox, and click the
            <span>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <title>refresh</title>
                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path>
              </svg>
              Reset</span>
            button to reset it. The map supports pan and zoom.
          </p>

          <p>Keep reading for more information. But first:</p>

          <div id="call-to-action">
            <p>
              If you could use an industrial-strength version of Fuzz Map for your project, please
              send me an email at
              <a href="mailto:human@fuzzmap.io">human@fuzzmap.io</a>! I&#39;m looking for pilot
              customers.
            </p>
            <p>
              In the short term, I&#39;d like to make a plug-and-play version of Fuzz Map that supports
              end-to-end React fuzzing. You <em>won&#39;t</em> have to change your build process or use
              a special browser—just run <code>./fuzzmap localhost:8080 -p 9090</code> and
              start fuzzing or live programming! A reverse proxy will add instrumentation on the
              fly.
            </p>
            <p>
              Depending on feedback, a future version of Fuzz Map might also run in CI when a pull
              request is opened, or support sharing links to annotated maps.
            </p>
            <p>
              I&#39;m also considering porting Fuzz Map to a platform other than React, e.g. iOS or Ruby
              on Rails. As I&#39;ll discuss later in the technical writeup, the instrumentation is
              mostly platform-independent.
            </p>
            <div><p>
              If you&#39;d like to be notified when a beta release of Fuzz Map becomes generally
              available, you can use this form:
              </p>
            </div>
          </div>

          <p>
            The beginning of this writeup will focus on features. If, instead, you&#39;re primarily
            interested in how Fuzz Map works, you can skip ahead to the part about
            <a href="#how-it-works">how it works</a>. There&#39;s some fun trivia, e.g. why
            <code>a &amp;&amp; b</code> <em>can&#39;t</em> be transformed into
            <code>(a &amp;&amp; (h1, true)) || (h2, b)</code>.
          </p>

          <p>
            By the way, everything in this research prototype runs in your browser. No data is
            uploaded to a server.
          </p>

          <h2>Live programming</h2>
          <p>
            Fuzzing an application might reveal an unexpected state or crash in the map. After
            updating the application&#39;s code, you can fuzz the application a second time. Checking
            the new map helps to verify that the effects of the change are what you expected.
          </p>
          <p>
            In Fuzz Map, fuzzing the second time normally goes much faster than it did the first
            time around. This is because inputs are saved for reuse after recompiling. Inputs are
            typically reusable without manual annotation because Fuzz Map uses the event handler&#39;s
            inline declaration to identify it. For example, if you make a button with an
            <code>onClick</code> event handler:
          </p>
          <pre>function App(...) {
  const handleClick = ...;
  return &lt;button onClick={handleClick} /&gt;;
}</pre>
          <p>
            then the event handler will be identified using the text <code>&#34;handleClick&#34;</code>.
            This means that even if the <em>definition</em> of <code>handleClick</code> is changed,
            click events will still be reusable. If necessary, you can disambiguate further by
            defining the <code>data-fuzzmap-key</code> HTML attribute.
          </p>
          <h2>Errors</h2>
          <p>
            Errors can occur while rendering a state or while handling an event. Fuzz Map detects
            errors and displays them in the map.
          </p>
          <p>
            Here&#39;s a potential bug in the Checkout example. Suppose an order contains zero items.
            The code for computing the order subtotal has a
            <code>reduce</code> call:
          </p>
          <pre>const subtotal = sortedItems
  .map(([_code, item]) =&gt; item.quantity * item.price)
  .reduce((a, b) =&gt; a + b, 0);</pre>
          <p>
            If the second argument to <code>reduce</code> is forgotten, then removing all of the
            items from the order by decreasing their quantities to zero results in the following
            map:
          </p>
          <p><img width="1648" height="728" src="https://jyc-static.com/a8ae38d4673b62a50982cb85907ed112fc3f43ae35362eff1499ece5bb591826"/></p><p>
            Errors can also occur in event handlers. Inserting an error into
            <code>onClickContinue</code> results in this map:
          </p>
          <p><img width="1581" height="1735" src="https://jyc-static.com/da5984075f7237f332b0f71504bd0d473137e10237cb9f3c6d7e136f9b8c07a7"/>
          </p>
          <p>Hover over the error icon to reveal the error:</p>
          <p><img width="1122" height="1348" src="https://jyc-static.com/0e0ac2fcc00e4c7220878b974893f3875dd87018bca28416e3bb00a821ac0acf"/>
          </p>

          <h2>Before/After</h2>
          <p>
            A single event handler can have many different cases, each corresponding to a distinct
            codepath. Fuzz Map lists out the cases for an input in the Before/After view.
          </p>
          <p>
            Suppose we use the following modified code to handle changes to item quantities in
            <code>onChangeQuantity</code>:
          </p>
          <pre>const quantity = e.target.valueAsNumber;
const items = new Map(oldItems);
if (quantity === 0) {
  items.delete(code);
} else {
  const item = items.get(code);
  items.set(code, { ...item, quantity });
}
return items;</pre>
          <p>
            After fuzzing, there will be an arrow from the initial state to the initial state with a
            name like “change &#39;House Wine&#39;” or “change &#39;Double-Shot
            Espresso&#39;”. The name could be different because changing the quantity of any item
            is handled by the same code.
          </p>
          <p><img width="1209" height="1322" src="https://jyc-static.com/93722005dafcd9e57c2acc0a488370dc564d431cbafdb81ea8bfcc3c7a05424e"/>
          </p>
          <p>
            Click on the label to switch to the Before/After view, which lists the different cases
            for changing an item quantity.
          </p>
          <p><img width="1712" height="2115" src="https://jyc-static.com/e3484a93b59571159498cf4c3d2d7df24f1e54e4ec0f1bfe9fe8bb27da73401f"/></p><p>
            The modified code doesn&#39;t properly handle “Case 2. change &#39;House Wine&#39; to
            &#39;&#39;”. When the item&#39;s quantity is changed to the empty string,
            <code>e.target.valueAsNumber</code> evaluates to <code>NaN</code>, and the subtotal
            calculation goes wrong.
          </p>
          <p>
            Click
            <span>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <title>Show code</title>
                <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd"></path>
              </svg>
              Show code</span>
            to highlight the event handler&#39;s declaration:
          </p>
          <p><img width="1570" height="1502" src="https://jyc-static.com/572fd9bed037944c5788bba8b130196f74ec3e1463f82049e60761ad1f60d312"/>
          </p>
          <p>
            A future version of Fuzz Map could use the information it already has to highlight the
            lines of code that executed for each case. You could select two cases to reveal which
            branches executed differently. This could be used to debug unexpected states.
          </p>

          <h2><a id="how-it-works">How it works</a></h2>
          <p>
            The main idea behind Fuzz Map is to distinguish between GUI states using code coverage
            and to render these states as a simplified map. Coverage-guided fuzzing has been applied
            with great success for more than a decade. A complete survey is beyond the scope of this
            writeup; see
            <a href="https://arxiv.org/abs/1812.00140">Manes et al. (2018)</a> for an overview,
            including a fuzzer genealogy.
          </p>
          <p>
            A visual map is especially useful for GUI development, where bugs are often obvious to
            humans but difficult for computers to check. It&#39;s almost certainly a bug if a program
            crashes or reads memory it shouldn&#39;t. But what if a button sends the user to the wrong
            screen, or the interface just looks strange under unexpected circumstances? People
            already use whiteboards or prototyping software to explain an application&#39;s behavior to
            themselves, or to review it with colleagues. Fuzz Map tries to create the same kind of
            map automatically.
          </p>

          <h2>The state graph</h2>
          <p>
            While Fuzz Map fuzzes, it builds a <em>state graph</em>. Each node in the graph
            represents an application state. Each edge represents an input processed by an event
            handler. Every state and event is identified by a <em>hit vector</em> which describes
            the branches that executed while the application rendered or handled the event. The
            following program contains two branches:
          </p>
          <pre>const name = ...;
if (name !== null) {
  return `Hello, ${name}!`;
} else {
  throw new Error(&#34;TODO&#34;);
}</pre>
          <p>
            If the program runs one time and <code>name</code> is not null, then the hit vector will
            be \( (1, 0) \). If the program runs two times, and both times <code>name</code> is
            null, then the hit vector will be \( (0, 2) \).
          </p>
          <p>
            A hit vector is a coarse representation of an application state: many different states
            can correspond to the same hit vector. This simplification is typically useful for Fuzz
            Map. The actual program being fuzzed (approximately a Turing machine) is always much
            more complicated than the map that Fuzz Map displays (approximately a finite automaton).
            Note that this simplification means that it&#39;s possible, albeit unlikely, to have two
            different states with the same hit vector where only one exhibits a bug.
          </p>
          <p>
            Bugs in an application generally correspond to untested codepaths or interactions
            between codepaths. Two states that execute very different code might render the same
            HTML. But if a program executes the same code when rendering two screens, then any bug
            in the code will generally occur in both cases. Because Fuzz Map uses hit vectors to
            identify states, it will only show two states in the map for the previous example: one
            where
            <code>name</code> is non-null, and another where <code>name</code> is null.
          </p>

          <h2>Random fuzzing</h2>
          <p>
            The state graph helps Fuzz Map to explore states efficiently. The graph keeps track of
            the states the fuzzer has seen and the shortest paths between them. Instead of building
            a graph, Fuzz Map could randomly generate long sequences of inputs. This is surprisingly
            inefficient. Efficiency is especially important for fuzzing GUIs, which process inputs
            much more slowly than typical fuzzer targets like parsers or protocols.
          </p>
          <p>
            To illustrate how random fuzzing can be inefficient, consider an application with a
            sequence of screens, e.g. for checking out items from an online store. In screen \( 1
            \), colored blue, you can only go to the next state, and in screens \( 2 \) through \( n
            - 1 \) you can go to either the previous or next screen.
          </p>
          <p><img width="844" height="120" src="https://jyc-static.com/f32cdc0b6d8f4045de8e2a9ef36292f9d79a20975f8288c3e2b7b547e660d922"/>
          </p>
          <p>
            How long will it take a random fuzzer to find the final screen \( n \), colored orange?
            If this is the
            <a href="https://en.wikipedia.org/wiki/Coupon_collector%27s_problem">coupon collector&#39;s problem</a>, we&#39;d expect it to take around \( n \log n \) inputs. But because each screen can only
            be accessed through its adjacent screens, this is actually an instance of the
            <a href="https://en.wikipedia.org/wiki/Gambler%27s_ruin">gambler&#39;s ruin</a> problem. It
            will take random fuzzing around \( n^2 \) inputs to find the final orange screen! And
            the structure of a real GUI is normally even worse for fuzzers. Most GUIs also have many
            cycles and dead ends; these only make it more likely for the fuzzer to get stuck.
          </p>
          <p>
            Because Fuzz Map uses code coverage to recognize states it has already seen, it only
            takes around \( n \) inputs in this case.
          </p>
          <p>
            For the math behind the \( n^2 \) estimate, see
            <a href="https://math.stackexchange.com/a/3970622">angryavian&#39;s answer</a> to an
            equivalent problem on Math StackExchange. For the general case, see the chapter
            “Random Walk and Ruin Problems” in
            <em>An Introduction to Probability Theory and Its Applications, Vol. 1</em> by Feller.
            The amazing Internet Archive has an
            <a href="https://archive.org/details/introductiontopr00fell/page/317">online copy you can borrow</a>, where the analysis starts on page 317.
          </p>
          <p>
            By the way, if you think it&#39;s inconvenient that only one person can borrow the book per
            hour, book publishers disagree—they think it should be even harder! At the time of
            writing, Hachette, HarperCollins, Wiley, and Penguin Random House are suing the Internet
            Archive. The Internet Archive is being
            <a href="https://www.eff.org/cases/hachette-v-internet-archive">defended by the EFF</a>.
          </p>

          <h2>Exploring the state graph</h2>
          <p>
            Whenever Fuzz Map <em>first</em> sees a state, identified by its hit vector \( \vec s
            \), it generates all the possible inputs for that state. For example, one input \( i \)
            might be “change the value of &#39;Pickup time&#39; to &#39;1:24 AM&#39;”. Then it places
            all of these inputs into a <em>fuzzing queue</em>. The items in the queue are pairs \(
            (\vec s, i) \).
          </p>
          <p>
            Fuzzing takes place in a loop. In each iteration, Fuzz Map dequeues a pair \( (\vec s,
            i) \) then applies it. If \( \vec s \) does not match the current state, then Fuzz Map
            <em>travels</em> before applying \( i \). It does this by applying the shortest sequence
            of inputs it previously recorded as having led to \( \vec s \). A minified set of these
            shortest paths is also saved for reuse after recompiling to make subsequent fuzzing runs
            faster. This set is comparable to the <em>seed pool</em> of a conventional fuzzer.
          </p>
          <p>
            Fuzz Map uses a few simple scheduling heuristics for dequeuing items. When possible,
            Fuzz Map dequeues an item whose state equals the current state. This is because it is
            typically more expensive to reset a GUI than to apply an additional input. Otherwise,
            Fuzz Map will alternate between selecting a random item from the queue and selecting an
            item with the smallest hit vector.
          </p>
          <p>
            Fuzz Map dequeues a random item rather than always dequeuing the next item to to try
            avoid getting stuck in a clique of states that all lead to each other. Dequeuing the
            item with the smallest hit vector helps to expose behavior that occurs only when a loop
            does not execute.
          </p>
          <p>
            These are just heuristics, and future versions of Fuzz Map could be much more
            sophisticated. Consider an application which only shows some state if
            <code>password == &#34;please&#34;</code>. Fuzz Map knows through branch coverage that isn&#39;t
            guessing correctly, but it doesn&#39;t currently analyze the program to determine what the
            correct password is. A more realistic example for a GUI might be an event handler that
            checks whether <code>event.touches.length == 2</code>. One technique for generating
            inputs using program analysis is
            <a href="https://en.wikipedia.org/wiki/Concolic_testing">concolic testing</a>.
          </p>
          <p>
            <iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/RfiQYRn7fBg" title="Samuel L. Jackson&#39;s character in Jurassic Park tries to access a hacked computer system, but doesn&#39;t know the password. The system taunts Samuel L. Jackson by saying &#39;Ah ah ah! You didn&#39;t say the magic word!&#39;" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
          </p>

          <h2>Branch coverage</h2>
          <p>
            To record branch coverage and obtain hit vectors for nodes (render states) and edges
            (event handlers), Fuzz Map uses compile-time instrumentation.
          </p>
          <p>
            Tangentially, Fuzz Map does some things with compile-time instrumentation which could
            just as well be done at by patching the application runtime, e.g. associating event
            handlers with their elements. It would have been feasible to patch React or the browser,
            but it will be much harder to patch other platforms&#39; runtimes. iOS is an obvious
            example, but another scenario is a corporate environment where you are only allowed to
            deploy JARs.
          </p>
          <p>Instrumentation is applied in a compiler pass. When Fuzz Map encounters this code:</p>
          <pre>return isLoading ? &#34;Loading...&#34; : &#34;Done!&#34;;</pre>
          <p>it adds instrumentation and outputs the following:</p>
          <pre>return isLoading ? (hit(65), &#34;Loading...&#34;) : (hit(66), &#34;Done!&#34;);</pre>
          <p>
            The comma denotes a <em>sequence expression</em>. When the expression
            <code>a, b</code> is evaluated, first <code>a</code> is evaluated, then <code>b</code>.
            Finally, the entire expression evaluates to the result of <code>b</code>. Here it&#39;s used
            to insert the hit counter into the ternary expression without changing its value. There
            are weirder tricks for this which will appear later in this section.
          </p>
          <p>
            <code>hit(n)</code> increments the <em>hit counter</em> with ID <code>n</code> in a
            global map. The hit counter IDs in this example are \( 65 \) and \( 66 \) because Fuzz
            Map packs both a branch ID and a target ID into the hit counter ID. The branch ID in
            this case is \( 1 \), and the second branch target has ID \( 2 \), so \( 66 = (1 \ll 6)
            + 2 \). Fuzz Map also uses the most significant bit to record whether a hit counter ID
            corresponds to a “high detail” branch; currently these are just function
            entry points. The extra information packed into the hit counter ID is used during map
            graph generation, discussed later.
          </p>
          <p><img width="1924" height="192" src="https://jyc-static.com/cd9227aba935fd66f6fd308fc78b4e856ca35da68df16b0c2128f91303032949"/></p><h2>Short-circuiting expressions</h2>
          <p>
            You probably know that the Boolean operators in JavaScript <em>short-circuit</em>
            and evaluate to the first sub-expression that determines their value, as they do in most
            (or all?) languages in the C family. Short-circuiting means that
            <code>false &amp;&amp; alert(&#34;boo!&#34;)</code> and <code>true || alert(&#34;boo!&#34;)</code> never alert.
            But unless you are familiar with React and JSX, you might not know that short-circuiting
            is often used
            <a href="https://reactjs.org/docs/conditional-rendering.html#inline-if-with-logical--operator">idiomatically</a>. Here&#39;s some code from the Checkout example:
          </p>
          <pre>{screen === &#34;OrderConfirmed&#34; &amp;&amp; (
  &lt;&gt;
    &lt;h2&gt;Order confirmed&lt;/h2&gt;
    &lt;div className=&#34;screenContents&#34;&gt;
      &lt;p&gt;Your order is confirmed!&lt;/p&gt;
      &lt;p&gt;{STORE_NAME} is preparing your order.&lt;/p&gt;
      ...
    &lt;/div&gt;
  &lt;/&gt;
)}</pre>
          <p>
            When the “Order Confirmed” screen is not being shown,
            <code>screen === &#34;OrderConfirmed&#34;</code> evaluates to <code>false</code>, so the entire
            expression evaluates to <code>false</code>. React doesn&#39;t render <code>false</code>, so
            the screen doesn&#39;t show.
          </p>
          <p>
            The frequent use of short-circuiting in React made it more important for this demo to
            instrument it. If the demo worked on C programs compiled to WASM instead, this might
            have been less important.
          </p>
          <p>
            As an aside, WASM would have made some things easier. Instead of having to write the
            instrumentation for each branching operation separately, I could have just instrumented
            the less numerous
            <a href="https://webassembly.github.io/spec/core/syntax/instructions.html">control instructions</a>
            in WASM. Rewriting a WASM binary is a lot easier than rewriting e.g. an x86 binary
            because WASM does not allow jumps to arbitrary addresses; for the difficulties that
            creates, see e.g.
            <a href="https://www.youtube.com/watch?v=iRvC5hgN1VY">Bauman et al (2018)</a>. More
            generally, it would be nifty to have the ability to write a compiler pass that operates
            on a lower-level representation, and to then have the compiler automatically transform
            this pass into one that operates on a higher-level representation, preserving the
            original structure of the program whenever possible. I don&#39;t know of other applications
            for this, though; maybe it could be used to implement diff/patch not based on lines.
          </p>
          <p>
            Because we don&#39;t have this ability, here are the separate transformations for
            <code>a || b</code> and <code>a ?? b</code> (the
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator">nullish coalescing operator</a>):
          </p>
          <ul>
            <li>
              <code>a || b</code>
              becomes
              <pre>((a, b) =&gt; ((x) =&gt; x ? (hit(1), x) : (hit(2), b))(a)</pre>
            </li>
            <li>
              <code>a ?? b</code>
              becomes
              <pre>((a, b) =&gt; ((x) =&gt; (x === null || x === undefined) ? (hit(2), b) : (hit(1), x))(a)</pre>
            </li>
          </ul>
          <p>
            Any expression can be replaced by an
            <a href="https://en.wikipedia.org/wiki/Immediately_invoked_function_expression">immediately-invoked function expression</a>
            containing a conditional expression. It&#39;s necessary because we need to bind the value of
            the expression <code>a</code> so we can use it multiple times while evaluating it only
            once. For example, to evaluate <code>a ?? b</code>, first we compare the value of
            <code>a</code> with <code>null</code> and <code>undefined</code>, then we return it.
          </p>
          <p>
            I previously tried to be clever and transform <code>a || b</code> to
            <code>(a &amp;&amp; (h1, true)) || (h2, b)</code>. This works unless <code>a</code> is only
            <em>truthy</em>, not true, and the result of the expression is not used as a Boolean.
            Then the transformed expression evaluates to <code>true</code> when the original
            expression would have evaluated to e.g. <code>1</code>.
          </p>
          <p>
            If this section didn&#39;t bore you out of your mind, you might enjoy the game
            <a href="https://alf.nu/ReturnTrue?world=true&amp;level=id">return true to win</a> by
            <a href="https://twitter.com/steike">@steike</a>.
          </p>

          <h2>The map graph</h2>
          <p>
            The state graph is already a simplified version of the program being tested. But
            typically it&#39;ll still be humongous, even for a simple application. When rendered it is
            almost unreadable. So before layout and rendering, Fuzz Map <em>simplifies</em> the
            state graph into a <em>map graph</em>. Each node or edge in the map graph corresponds to
            one or more nodes and edges in the state graph. As a final step, Fuzz Map uses
            <a href="https://github.com/kieler/elkjs">elkjs</a> to create a <em>layout</em> where
            each node and edge in the map graph has been assigned a position on the screen.
          </p>
          <p>
            Why is the state graph so large? First, there are many ways that different parts of the
            program can interact with each other. If one branch is added to the program that is
            independent from the other branches in the program, it more than doubles the number of
            possible states. In other words, even when each entry of the hit vector is clamped to \(
            [0, 1] \), a program with \( n \) branches still has \( 2^n \) possible hit vectors.
          </p>
          <p>
            Second, each iteration of a loop increments each hit counter it contains. So each loop
            iteration creates an entirely new state.
          </p>
          <p>
            During fuzzing, it&#39;s useful for the state graph to be large. Recall that each item \(
            (\vec s, i) \) in the fuzzing queue contains a hit vector \( \vec s \) that identifies
            the state to which the input \( i \) should be applied. So the more precisely the hit
            vector \( \vec s \) describes the application state, the more likely we are to
            successfully apply input \( i \) when we travel to that state again during fuzzing.
            Suppose we used clamped hit vectors to identify application states. Then we might try to
            apply an input \( i \) that only works in states where a list has 3 elements to a state
            where that list has only 2 elements.
          </p>
          <p>
            It&#39;s still possible for us to fail to apply an input \( i \). A hit vector \( \vec s \)
            might correspond to two states, and \( i \) might apply in only one of them. What if we
            instead identified each state using the application&#39;s actual memory, instead of using
            hit vectors? This would guarantee that \( i \) would apply, but might make the fuzzer
            slower. Obviously, we would use much more memory to represent each state.
          </p>
          <p>
            More subtly, we would apply many redundant operations during fuzzing. Suppose the
            application behaves exactly the same no matter what a user&#39;s name is, so long as they
            have a name. Then unless we have a way to determine that the difference between two
            states with different names is insignificant, every different name
            <em>multiplies</em> the number of items in the fuzzing queue.
          </p>

          <h2>Simplification</h2>
          <p>
            The map graph is created by combining nodes and edges in the state graph. This process
            repeats until no more combinations are possible. Fuzz Map uses a few simple heuristics
            for simplification. The simplest—but most impactful—is
            <em>clamping</em>: each entry of a hit vector is clamped to at most \( 1 \). Another
            heuristic, <em>branch collapsing</em>, is to treat two branch targets as identical when
            we&#39;ve seen a state where both were hit. Branch collapsing helps with GUIs which perform
            processing for each item in a list, like the Checkout example.
          </p>
          <p>
            This diagram shows an example of clamping during simplification. The two blue nodes in
            the state graph are combined into one node in the map graph:
          </p>
          <p><img width="993" height="258" src="https://jyc-static.com/b37bd9d1850bdf516755d5a40a6d6b266ac9d139f787d01976316aef905dc7fe"/></p><p>
            Initially the two blue nodes have different hit vectors, \( (1, 0, 2) \) and \( (3, 0,
            1) \). But both hit vectors are equivalent after clamping to \( (1, 0, 1) \), so the two
            nodes are combined. This causes the edge from one blue node to the other to become a
            loop. Simplification operates on edges as well.
          </p>
          <p>
            There&#39;s a lot more that could be said about map graph simplification. In fact,
            simplification was the largest source of novelty and complexity in this project. Without
            simplification, interesting parts of the map are drowned out by exponentially more
            uninteresting parts. Simplification is the key to making the map visualization possible.
          </p>
          <p>
            Clamping is essentially <em>local</em> in that it acts on each hit vector independently.
            Branch collapsing is slightly less local. The next step is to explore
            <em>global</em> analyses, e.g. identifying when a state differs significantly from
            others.
          </p>

          <h2>Applying inputs</h2>
          <p>
            Changing tack: it&#39;s often possible for Fuzz Map to apply inputs even after the program
            has been modified. The <em>input path</em>s that Fuzz Map uses to identify input targets
            contain the event handler&#39;s inline declaration. For example, if you render a list of
            buttons:
          </p>
          <pre>function App(...) {
  ...
  return list.map((name) =&gt; &lt;button onClick={handleClick(name)} /&gt;);
}
</pre>
          <p>each button&#39;s <code>onClick</code> handler gets an input path:</p>
          <pre>{ subtree: ?, eventName: &#39;click&#39;, handler: &#39;App_handleClick_name&#39;, index: 1 }</pre>
          <p>
            where <code>index: 1</code> means this handler was the second among its siblings in the
            DOM with this handler. Fuzz Map uses the event handler&#39;s inline declaration because it&#39;s
            already common practice not to define event handlers entirely inline. This means most
            input paths will be stable without any extra work.
          </p>
          <p>
            Fuzz Map was designed to work without manual annotation whenever feasible. But if you
            need to more precisely identify an element, you can set the
            <code>data-fuzzmap-key</code> HTML attribute on the element or its ancestors. The
            <code>subtree</code> field in the input path is a list of
            <code>(key, index)</code> pairs. If you want, you can give each element a totally unique
            <code>data-fuzzmap-key</code>. Many testing systems either require this for <em>all</em>
            interactive elements or fall back to guessing based on style or content.
          </p>
          <p>
            A heuristic is used to minimize the size of the seed input set: if one seed input
            sequence is exactly contained in another, then the smaller one is removed. For many
            applications, it is more expensive to reset the sandbox than to extend an existing input
            sequence with additional inputs, e.g. when resetting the sandbox requires resetting a
            database. A more optimal approach would be to compute a minimal path cover.
          </p>

          <h2>Limitations and future work</h2>
          <p>
            There are many limitations in the current version of Fuzz Map—hence the
            <em>alpha</em> label. I&#39;ll mention a few of them below. All of these will be addressed
            in future versions.
          </p>
          <p>
            Fuzz Map does not generate complex values for inputs. This is the exact opposite of most
            commonly-used fuzzers! That is also exactly why this wasn&#39;t a focus of the demo. Instead
            of reinventing the wheel, a future version of Fuzz Map will integrate established
            fuzzers for generating e.g. the text in inputs.
          </p>
          <p>
            Fuzz Map&#39;s state and event model is extensible. The demo does not currently handle
            asynchronous events like <code>setTimeout</code> and <code>fetch</code> calls. But in a
            future version of Fuzz Map, edges will correspond not just to DOM event handlers, but
            also to event handlers attached to browser APIs. It will be straightforward to extend
            Fuzz Map to instrument and replay these in the same way that it already instruments DOM
            events. Here&#39;s a quick mockup:
          </p>
          <p><img width="1567" height="1982" src="https://jyc-static.com/315ef928645072563116f42c9654d6ac5299d05a732c370d2f45c34b860a07a6"/></p><p>
            Fuzz Map does not handle event handlers that are defined at runtime. Only
            <a href="https://reactjs.org/docs/forms.html#controlled-components">controlled components</a>
            are fuzzed.
          </p>
          <p>
            I was lazy and didn&#39;t handle more exotic branching operations like <code>??=</code> and
            <code>?.</code>.
          </p>

          <h2>Special acknowledgment</h2>
          <p>
            I&#39;d like to especially acknowledge the authors of
            <a href="https://github.com/kieler/elkjs">elkjs</a> and the
            <a href="https://www.eclipse.org/elk/">ELK layout library</a>. Of all the libraries I
            used for this demo, ELK punched the most above its weight. ELK generates the layout used
            to render the map graph. A similar program is the classic
            <a href="https://graphviz.org/">Graphviz</a>.
          </p>

          
        </div></div>
  </body>
</html>
