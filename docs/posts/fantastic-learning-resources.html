<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2023/08/06/fantastic-learning-resources.html">Original</a>
    <h1>Fantastic Learning Resources</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>

    
<p><span>People sometimes ask me: </span>“<span>Alex, how do I learn X?</span>”<span>. This article is a compilation of advice I</span>
<span>usually give. This is </span>“<span>things that worked for me</span>”<span> rather than </span>“<span>the most awesome things on earth</span>”<span>. I</span>
<span>do consider every item on the list to be fantastic though, and I am forever grateful to people</span>
<span>putting these resources together.</span></p>
<section id="Learning-to-Code">

    <h2>
    <a href="#Learning-to-Code"><span>Learning to Code</span> </a>
    </h2>
<p><span>I don</span>’<span>t think I have any useful advice on how to learn programming from zero. The rest of the post</span>
<span>assumes that you at least can, given sufficient time, write simple programs. E.g., a program that</span>
<span>reads a list of integers from an input textual file, sorts them using a quadratic algorithm, and</span>
<span>writes the result to a different file.</span></p>
</section>
<section id="Project-Euler">

    <h2>
    <a href="#Project-Euler"><span>Project Euler</span> </a>
    </h2>
<p><a href="https://projecteuler.net/archives">https://projecteuler.net/archives</a><span> is fantastic. The first 50 problems or so are a perfect </span>“<span>drill</span>”
<span>to build programming muscle, to go from </span>“<span>I can write a program to sort a list of integers</span>”<span> to </span>“<span>I can</span>
<em><span>easily</span></em><span> write a program to sort a list of integers</span>”<span>.</span></p>
<p><span>Later problems are very heavily math based. If you are mathematically inclined, this is perfect </span>—
<span>you got to solve fun puzzles while also practicing coding. If advanced math isn</span>’<span>t your cup of tea,</span>
<span>feel free to stop doing problems as soon as it stops being fun.</span></p>
</section>
<section id="Modern-Operating-System">

    <h2>
    <a href="#Modern-Operating-System"><span>Modern Operating System</span> </a>
    </h2>
<p><a href="https://en.wikipedia.org/wiki/Modern_Operating_Systems">https://en.wikipedia.org/wiki/Modern_Operating_Systems</a><span> is fantastic. A </span><a href="https://en.wikipedia.org/wiki/Operating_Systems:_Design_and_Implementation"><span>version of the</span>
<span>book</span></a><span> was the first</span>
<span>thick programming related tome I devoured. It gives a big picture of the inner workings of software</span>
<span>stack, and was a turning point for me personally. After reading this book I realized that I want to</span>
<span>be a programmer.</span></p>
</section>
<section id="Nand-to-Tetris">

    <h2>
    <a href="#Nand-to-Tetris"><span>Nand to Tetris</span> </a>
    </h2>
<p><a href="https://www.nand2tetris.org">https://www.nand2tetris.org</a><span> is fantastic. It plays a similar </span>“<span>big picture</span>”<span> role as MOS,</span>
<span>but this time you are the painter. In this course you build a whole computing system yourself,</span>
<span>starting almost from nothing. It doesn</span>’<span>t teach you how the real software/hardware stack works, but</span>
<span>it thoroughly dispels any magic, and is extremely fun.</span></p>
</section>
<section id="CSES-Problem-Set">

    <h2>
    <a href="#CSES-Problem-Set"><span>CSES Problem Set</span> </a>
    </h2>
<p><a href="https://cses.fi/problemset/">https://cses.fi/problemset/</a><span> is fantastic. This is a list of algorithmic problems, which is</span>
<span>meticulously crafted to cover all the standard topics to a reasonable depth. This is by far the best</span>
<span>source for practicing algorithms.</span></p>
</section>
<section id="Programming-Languages">

    <h2>
    <a href="#Programming-Languages"><span>Programming Languages</span> </a>
    </h2>
<p><a href="https://www.coursera.org/learn/programming-languages">https://www.coursera.org/learn/programming-languages</a><span> is fantastic. This course is a whirlwind tour</span>
<span>across several paradigms of programming, and makes you really </span><em><span>get</span></em><span> what programming languages are</span>
<span>about (and variance).</span></p>
</section>
<section id="Compilers">

    <h2>
    <a href="#Compilers"><span>Compilers</span> </a>
    </h2>
<p><a href="http://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=Compilers">http://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=Compilers</a><span> is fantastic. In this</span>
<span>course, you implement a working compiler for a simple, but real programming language. Note that you</span>
<span>can implement your compiler in any language.</span></p>
</section>
<section id="Software-Architecture">

    <h2>
    <a href="#Software-Architecture"><span>Software Architecture</span> </a>
    </h2>
<p><a href="https://www.tedinski.com/archive/">https://www.tedinski.com/archive/</a><span> is fantastic. Work through the whole archive in chronological</span>
<span>order. This is by far the best resource on </span>“<span>programming in the large</span>”<span>.</span></p>
</section>
<section id="Random-Bits-of-Advice">

    <h2>
    <a href="#Random-Bits-of-Advice"><span>Random Bits of Advice</span> </a>
    </h2>
<p><span>What follows are some things I</span>’<span>ve learned for myself. Take with a pinch of salt!</span></p>
<section id="On-Mentorship">

    <h3>
    <a href="#On-Mentorship"><span>On Mentorship</span> </a>
    </h3>
<p><span>Having a great mentor is fantastic, but mentors are not always available. Luckily, programming can</span>
<span>be mastered without a mentor, if you got past the initial learning step. When you code, you get </span><em><span>a</span>
<span>lot</span></em><span> of feedback, and, through trial and error, you can process the feedback to improve your skills.</span>
<span>In fact, the hardest bit is actually finding the problems to solve (and this article suggests many).</span>
<span>But if you have the problem, you can self-improve noticing the following:</span></p>
<ul>
<li>
<span>How you verify that the solution works.</span>
</li>
<li>
<span>Common bugs and techniques to avoid them in the future.</span>
</li>
<li>
<span>Length of the solution: can you solve the problem using shorter, simpler code?</span>
</li>
<li>
<span>Techniques </span>—<span> can you apply anything you</span>’<span>ve read about this week? How would the problem be solved</span>
<span>in Haskell? Could you apply pattern from language X in language Y?</span>
</li>
</ul>
<p><span>In this context it is important to solve the same problem repeatedly. E.g., you could try solving</span>
<span>the same model problem in all languages you know, with a month or two break between attempts.</span>
<span>Repeatedly doing the same thing and noticing differences and similarities between tries is the</span>
<span>essence of self-learning.</span></p>
</section>
<section id="On-Programming-Languages">

    <h3>
    <a href="#On-Programming-Languages"><span>On Programming Languages</span> </a>
    </h3>
<p><span>Learning your first programming language is a nightmare, because you are learning your editing</span>
<span>environment (PyScripter, IntelliJ IDEA, VS Code) first, simple algorithms second, and the language</span>
<span>itself third. It gets much easier afterwards!</span></p>
<p><span>Learning different programming languages is one of the best way to improve your programming skills.</span>
<span>By seeing what</span>’<span>s similar, and what</span>’<span>s different, you deeper learn how the things work under the hood.</span>
<span>Different languages put different idioms to the forefront, and learning several expands your</span>
<span>vocabulary considerably. As a bonus, after learning N languages, learning N+1st becomes a question</span>
<span>of skimming through the official docs.</span></p>
<p><span>In general, you want to cover big families of languages: Python, Java, Haskell, C, Rust, Clojure</span>
<span>would be a good baseline. Erlang, Forth, and Prolog would be good additions afterwards.</span></p>
</section>
<section id="On-Algorithms">

    <h3>
    <a href="#On-Algorithms"><span>On Algorithms</span> </a>
    </h3>
<p><span>There are three levels of learning algorithms</span></p>
<dl>
<dt><span>Level 1</span></dt>
<dd>
<p><span>You are not actually learning algorithms, you are learning programming. At this stage, it doesn</span>’<span>t</span>
<span>matter how long your code is, how pretty it is, or how efficient it is. The only thing that</span>
<span>matters is that it solve the problem. Generally, this level ends when you are fairly comfortable</span>
<span>with recursion. Few first problems from Project Euler are a great resource here.</span></p>
</dd>
<dt><span>Level 2</span></dt>
<dd>
<p><span>Here you learn algorithms proper. The goal here is mostly encyclopedic knowledge of common</span>
<span>techniques. There are quite a few, but not too many of those. At this stage, the most useful thing</span>
<span>is understanding the math behind the algorithms </span>—<span> being able to explain algorithm using</span>
<span>pencil&amp;paper, prove its correctness, and analyze Big-O runtime. Generally, you want to learn the</span>
<span>name of algorithm or technique, read and grok the full explanation, and then implement it.</span></p>
<p><span>I recommend doing an abstract implementation first (i.e., not </span>“<span>HashMap to solve problem X</span>”<span>, but</span>
“<span>just HashMap</span>”<span>). Include tests in your implementation. Use randomized testing (e.g., when testing</span>
<span>sorting algorithms, don</span>’<span>t use a finite set of example, generate a million random ones).</span></p>
<p><span>It</span>’<span>s OK and even desirable to implement the same algorithm multiple times. When solving problems,</span>
<span>like CSES, you </span><em><span>could</span></em><span> abstract your solutions and re-use them, but it</span>’<span>s better to code everything</span>
<span>from scratch every time, until you</span>’<span>ve fully internalized the algorithm.</span></p>
</dd>
<dt><span>Level 3</span></dt>
<dd>
<p><span>One day, long after I</span>’<span>ve finished my university, I was a TA for an algorithms course. The lecturer</span>
<span>for the course was the person who originally taught me to program, through a similar algorithms</span>
<span>course. And, during one coffee break, he said something like</span></p>

<figure>
<blockquote><p><span>We don</span>’<span>t teach algorithms so that students can code Dijkstra with their eyes closed on the job.</span>
<span>They probably won</span>’<span>t have to code any fancy algorithms themselves.</span></p>
<p><span>We teach algorithms so that students learn to think about invariants and properties when writing</span>
<span>code. Real-life code is usually simple enough that it mostly works if you just throw spaghetti</span>
<span>onto the wall. But it doesn</span>’<span>t always work. To write correct, robust code at work, you need to</span>
<span>think about invariants.</span></p>
<p><span>The trick with algorithms is that coding them is hard. The only way to avoid bugs is to force</span>
<span>yourself to think in terms of invariants.</span></p>
</blockquote>

</figure>
<p><span>I was thunderstruck! I didn</span>’<span>t realize that</span>’<span>s the reason why I am learning (well, teaching at that</span>
<span>point) algorithms! Before, I always muddled through my algorithms by randomly tweaking generally</span>
<span>correct stuff until it works. E.g., with a binary search, just add </span><code>+1</code><span> somewhere until it doesn</span>’<span>t</span>
<span>loop on random arrays. After hearing this advice, I went home and wrote my millionth binary</span>
<span>search, but this time I actually added comments with loop invariants, and it worked from the first</span>
<span>try! I applied similar techniques for the rest of the course, and since then my subjective</span>
<span>perception of bug rate (for normal work code) went down dramatically.</span></p>
<p><span>So this is the third level of algorithms </span>—<span> you hone your coding skills to program without bugs.</span>
<span>If you are already fairly comfortable with algorithms, try doing CSES again. But this time, spend</span>
<span>however much you need double-checking the code </span><em><span>before</span></em><span> submission, but try to get everything</span>
<span>correct on the first try.</span></p>
</dd>
</dl>
</section>
<section id="On-Algorithm-Names">

    <h3>
    <a href="#On-Algorithm-Names"><span>On Algorithm Names</span> </a>
    </h3>
<p><span>Here</span>’<span>s the list of things you might want to be able to do, algorithmically. You don</span>’<span>t need to be</span>
<span>able to code everything on the spot. I think it would help if you know what each word is about, and</span>
<span>have implemented the thing at least once in the past.</span></p>
<p><span>Linear search, binary search, quadratic sorting, quick sort, merge sort, heap sort, binary heap,</span>
<span>growable array (aka ArrayList, vector), doubly-linked list, binary search tree, avl tree, red-black</span>
<span>tree, B-tree, splay tree, hash table (chaining and open addressing), depth first search, breadth first</span>
<span>search, topological sort, strongly connected components, minimal spanning tree (Prim &amp; Kruskal),</span>
<span>shortest paths (bfs, Dijkstra, Floyd–Warshall, Bellman–Ford), substring search (quadratic,</span>
<span>Rabin-Karp, Boyer-Moore, Knuth-Morris-Pratt), trie, Aho-Corasick, dynamic programming (longest</span>
<span>common subsequence, edit distance).</span></p>
</section>
<section id="On-Larger-Programs">

    <h3>
    <a href="#On-Larger-Programs"><span>On Larger Programs</span> </a>
    </h3>
<p><span>A very powerful exercise is coding a medium-sized project from scratch. Something that takes more</span>
<span>than a day, but less than a week, and has a meaningful architecture which can be just right, or</span>
<span>messed up. Here are some great projects to do:</span></p>
<dl>
<dt><span>Ray Tracer</span></dt>
<dd>
<p><span>Given an analytical description of a 3D scene, convert it to a colored 2D image, by simulating a</span>
<span>path of a ray of light as it bounces off objects.</span></p>
</dd>
<dt><span>Software Rasterizer</span></dt>
<dd>
<p><span>Given a description of a 3D scene as a set of triangles, convert it to a colored 2D image by</span>
<span>projecting triangles onto the viewing plane and drawing the projections in the correct order.</span></p>
</dd>
<dt><span>Dynamically Typed Programming Language</span></dt>
<dd>
<p><span>An </span><em><span>interpreter</span></em><span> which reads source code as text, parses it into an AST, and directly executes the</span>
<span>AST (or maybe converts AST to the byte code fore some speed up)</span></p>
</dd>
<dt><span>Statically Typed Programming Language</span></dt>
<dd>
<p><span>A </span><em><span>compiler</span></em><span> which reads source code as text, and spits out a binary (WASM would be a terrific</span>
<span>target).</span></p>
</dd>
<dt><span>Relational Database</span></dt>
<dd>
<p><span>Several components:</span></p>
<ul>
<li>
<span>Storage engine, which stores data durably on disk and implements on-disk ordered data structures</span>
<span>(B-tree or LSM)</span>
</li>
<li>
<span>Relational data model which is implemented on top of primitive ordered data structures.</span>
</li>
<li>
<span>Relational language to express schema and queries.</span>
</li>
<li>
<span>Either a TCP server to accept transactions as a database server, or an API for embedding for an</span>
<span>in-processes </span>“<span>embedded</span>”<span> database.</span>
</li>
</ul>
</dd>
<dt><span>Chat Server</span></dt>
<dd>
<p><span>An exercise in networking and asynchronous programming. Multiple client programs connect to a</span>
<span>server program. A client can send a message either to a specific different client, or to all other</span>
<span>clients (broadcast). There are many variations on how to implement this: blocking read/write</span>
<span>calls, </span><code>epoll</code><span>, </span><code>io_uring</code><span>, threads, callbacks, futures, manually-coded state machines.</span></p>
</dd>
</dl>
<p><span>Again, it</span>’<span>s more valuable to do the same exercise six times with variations, than to blast through</span>
<span>everything once.</span></p>
</section>
</section>
</article>
  </div></div>
  </body>
</html>
