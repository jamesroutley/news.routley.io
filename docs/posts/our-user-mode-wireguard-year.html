<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/our-user-mode-wireguard-year/">Original</a>
    <h1>Our User-Mode WireGuard Year</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/public/images/thomas.jpg" alt="Thomas Ptacek" srcset=""/> <dl> <dt>Name</dt> <dd> Thomas Ptacek </dd> <dt>Twitter</dt> <dd> <a href="https://twitter.com/tqbf" target="_blank"> @tqbf </a> </dd> </dl> </dd> </dl> <section> <img src="https://fly.io/blog/2022-02-09/danger!.jpg" alt=""/> <p> We’re <a href="http://Fly.io">Fly.io</a>. We run container images on our hardware around the world, linked to our Anycast network with a WireGuard mesh. It’s pretty neat, and you <a href="https://fly.io/docs/speedrun/">should check it out</a>. You can be up and running on Fly.io in single-digit minutes. That&#39;s the last thing we&#39;re going to say about how great Fly.io is in this post.</p><p>WireGuard is fundamental to how <a href="http://Fly.io">Fly.io</a> works. </p> Practically everything that talks to anything else at <a href="http://Fly.io">Fly.io</a> does so over WireGuard. <p>That goes for users, too. F’rinstance: to SSH into an instance of an app running on <a href="http://Fly.io">Fly.io</a>, you bring up a WireGuard peer to one of our gateways and SSH to an <a href="https://fly.io/blog/ipv6-wireguard-peering/">IPv6 private network address</a> reachable only over that WireGuard session.</p> <p>This kind of stuff is mostly hidden by <code>flyctl</code>, our command-line interface, which is how users interact with their apps on <a href="http://Fly.io">Fly.io</a>. On most platforms, “how do you SSH to an instance” is a boring detail. But <code>flyctl</code> isn’t boring.</p> <p>I’m about to explain why, for better and worser, <code>flyctl</code> is exciting. But first, a disclaimer. In the ordinary course, a company writes a blog post such as this to crow about some achievement or “unique selling proposition”. This post is not that. This is an exercise in radical candor.</p> <h2 id="a-houdini-with-the-manacles-of-sound-engineering"><a href="#a-houdini-with-the-manacles-of-sound-engineering" aria-label="Anchor"></a>A Houdini With The Manacles Of Sound Engineering</h2><p>Recap: It’s February 2021, and you can deploy a Docker container to <a href="http://Fly.io">Fly.io</a>, with <code>flyctl</code>, and our platform <a href="https://fly.io/blog/docker-without-docker/">will dutifully convert it to a Firecracker VM running on a worker in our network</a> and connected (again, via WireGuard) to our Anycast proxy network so that your customers can reach it on the Internet.</p> <p>What you couldn’t do is easily log into that VM to <code>monkey around with it</code>.</p> <p>That wouldn’t do; what’s the point of having a fleet of VMs if you can’t <code>monkey with them</code>? The team agreed, being able to pop a shell on a running app was table-stakes for the platform.</p> <p>We noodled a bit about how to do it. For awhile, we thought about building a remote-access channel into our Rust Anycast proxies. But we’d just rolled out <a href="https://fly.io/docs/reference/private-networking/">6PN private networking,</a> making it easy for <a href="http://Fly.io">Fly.io</a> apps to talk to each other. SSH seemed like an obvious example of a service you might run over a private network.</p> <p>The trick was how to get users access to 6PN networks from their laptops. It was pretty easy to build an SSH server to run on our VMs, and APIs for <a href="https://engineering.fb.com/2016/09/12/security/scalable-and-secure-access-with-ssh/">certificate-based access control</a> and building WireGuard peers for 6PN networks. But the client side is tricky: WireGuard changes your network configuration, and mainstream operating systems won’t let you do that without privileges. It wouldn’t do to require root access to run <code>flyctl</code>, and having to do a bunch of system administration to set up system WireGuard before you could run <code>flyctl</code> wasn’t attractive either.</p> <p>So we came up with a goofy idea. You have to be root to add a network interface, but any old user can speak the WireGuard protocol, and once you’ve got a WireGuard session, TCP/IP networking is just building and shuttling a bunch of packet buffers around. Your operating system doesn’t even have to know you’re doing it. All you need is a TCP stack that can run in userland.</p> <p>I said this within earshot of <a href="https://twitter.com/zx2c4?lang=en">Jason Donenfeld</a>. The next morning, he had a <a href="https://github.com/WireGuard/wireguard-go/tree/master/tun/netstack">working demo.</a> As it turns out, the <a href="https://fly.io/blog/sandboxing-and-workload-isolation/#emulation">gVisor project</a> had exactly the same user-mode TCP/IP problem, and <a href="https://pkg.go.dev/inet.af/netstack">built a pretty excellent TCP stack in Golang</a>. Jason added bindings to <a href="https://git.zx2c4.com/wireguard-go">wireguard-go</a>, and an enterprising soul (<a href="https://benburkert.com/">Ben Burkert</a>, pay him all your moneys, he’s fantastic) offered to build the feature into <code>flyctl</code>. We were off to the races: you could <code>flyctl ssh console</code> into any <a href="http://Fly.io">Fly.io</a> app, with no client configuration beyond just installing <code>flyctl</code>.</p> <p>I want to pause a second here and make sure <a href="https://fly.io/blog/ssh-and-user-mode-ip-wireguard/">what we ended up doing</a> makes sense to you, because it still seems batshit to me a year later. Want to SSH into a <a href="http://Fly.io">Fly.io</a> app instance you started? Sure. Just run <code>flyctl ssh console</code>, and it will:</p> <ol> <li>Kick off a WireGuard VPN session from within <code>flyctl</code>, using the <a href="https://git.zx2c4.com/wireguard-go">wireguard-go</a> library. </li><li>Run an entire TCP/IP stack, in userland, inside <code>flyctl</code>, to make an IPv6 TCP connection over that WireGuard connection. </li><li>Using the <a href="https://pkg.go.dev/golang.org/x/crypto/ssh">golang.org/x/crypto/ssh</a> library, run an SSH session over that synthetic TCP connection. </li></ol> <p>And this works! You can do it right now! Why am I the only person that thinks it’s bananas that this works?</p> <p><strong>It Is Bananas That This (Mostly) Works</strong></p> <p>Alright, radical candor.</p> <p>The nerd quotient on <code>flyctl ssh console</code> is extreme, which is a strong argument in favor of it. But there are countervailing reasons, and we ran into them.</p> <p>Here’s a simple problem. When you tell <code>flyctl ssh console</code> to bring up a WireGuard session like this, that running instance of <code>flyctl</code> on your machine — you know, the one that shows up in <code>ps</code> — is effectively another computer on the Internet. It has an IPv6 address. It is the only machine on the Internet that can have that IPv6 address. So what happens when you open up an SSH session in one window, and then another session in a different window?</p> <p>In March of 2021, the answer was “it knocked the first SSH session off the Internet”. That’s how WireGuard works! Your peer keeps track of the source socket address that’s talking to it, and when a new source appears, that’s the host it starts talking to. It’s one of the great things about WireGuard, and why you can bring up a WireGuard connection, close your Macbook, walk to the coffee shop, open your Macbook back up, and still be connected to WireGuard.</p> <p>I tried to rationalize this “one SSH session at a time” behavior for a couple weeks, but, come on.</p> <p>There were two paths we could have taken to address this problem. The easy-seeming way would be to have each <code>flyctl</code> instance make a new WireGuard peer, each with its own IPv6 address and public key pair. There were things I didn’t like about that, like the fact that it would crud our WireGuard gateways up with zillions of random ephemeral WireGuard sessions. But the dealbreaker in Spring 2021 was that creating a new WireGuard peer configuration was slow. We will return to this point shortly.</p> <p>The other way forward was to not have multiple instances of <code>flyctl</code> speaking WireGuard. Instead, when you made a WireGuard connection, we’d spawn a background process — the <code>flyctl agent</code>. <code>flyctl ssh console</code> runs would come and go, each talking to the agent, which would stick around holding open WireGuard sessions. Sure, why not!</p> <p>I know how much you all love random background agent processes. I’m here to tell you that my Spring 2021  <code>flyctl agent</code> was all you could have imagined it would be. It only worked on Unix. Concurrency management? Try to start a new agent, and it’ll just ask the old one to die over that same socket, and then take over. Configuration changes? I’m just a simple unfrozen caveman agent, what changes would I need to know about?</p> <p>Fortunately for everyone else, I&#39;m not the only developer on this team, and the agent got some professional help. The team got Unix domain sockets working on Windows. They wrote a new DNS resolver that worked on Windows as well. The agent will only run one of itself at a time. It notices configuration changes after it starts, and doesn&#39;t get out of sync and stale. If you use <code>flyctl</code> today, you&#39;re missing a whole lot of debugging fun.</p> <h2 id="doubling-down-on-banana-futures"><a href="#doubling-down-on-banana-futures" aria-label="Anchor"></a>Doubling Down On Banana Futures</h2><p>User-mode WireGuard and TCP/IP via IPC with a background agent is an awful lot of mechanism just to run an SSH session. A lesser engineer might look at this and say “the thing to do here is to get rid of some of this mechanism”. We chose instead “do more stuff with that mechanism”. I mean, I say “we chose”. But I was the last to know; I arose from a long slumber at some point in the middle of the year to find that our deploys were running over user-mode WireGuard.</p> <p>Here’s another challenge users run into when deploying Docker apps on <a href="http://Fly.io">Fly.io</a>: they’re often not running Docker. An engineer of limited imagination such as myself would look at this as a documentation problem, the solution to which would be an instruction to users to “install Docker”. But we’re a clever lot, we is.</p> <p>Flip back to that 1-2-3 process for popping a shell over user-mode WireGuard. Here’s a new problem: “from a directory with a Dockerfile, deploy a Docker image on <a href="http://Fly.io">Fly.io</a> if you’re not running Docker locally”. Here’s what you do:</p> <ol> <li>Use our GraphQL API to tell <a href="http://Fly.io">Fly.io</a> to boot up a “builder” instance that does almost nothing but run Docker, because, hammer, nail, only tool, &amp;c.  </li><li>Kick off a WireGuard VPN session from within <code>flyctl</code>, using the wireguard-go library. </li><li>Run an entire TCP/IP stack, in userland, inside <code>flyctl</code>, to make an IPv6 TCP connection over that WireGuard connection. </li><li>Using the <a href="https://pkg.go.dev/github.com/docker/docker/client">github.com/docker/docker/client</a> libraries, build a Docker container on the remote builder instance (which really just means connecting to a random IPv6 address rather than <code>127.0.0.1</code>).  </li><li>Tell the builder to push the image to our Docker registry, and our API to deploy it. </li></ol> <p>It’s just 5 steps! It all happens in the background; you just run <code>flyctl deploy</code>! What could go wrong?</p> <p> This pattern repeats. The horror of user-mode WireGuard and TCP/IP is that it is a whole lot of mechanism. But the beauty of it is that it’s mind-bogglingly flexible. A little later in the year, we launched <a href="https://fly.io/blog/globally-distributed-postgres/">Fly.io Postgres</a>. Want to bring up a <code>psql</code> shell on your database? <code>flyctl pg connect</code>. Do I need to rattle off the 1-2-3 of that? For that matter, what if you have a cool client like <a href="https://eggerapps.at/postico/">Postico</a> you want to use? No problem! <code>flyctl proxy 5432:5432</code>. A proxy isn’t even 3 whole steps!</p><p><strong>Here’s where shit gets real.</strong> One can rationalize the occasional SSH connection janking out. SSH wasn’t even a feature we had at the beginning of the year. But deploys? Deploys have to work.</p> <h2 id="the-deploys-they-were-not-always-working"><a href="#the-deploys-they-were-not-always-working" aria-label="Anchor"></a>The Deploys, They Were Not Always Working</h2><p>More radical candor.</p> <p>We have some good ideas on what made remote builds over WireGuard shaky, and builds have gotten a lot better. But I can’t tell you we’ve nailed down every failure mode. Here are two big ones.</p> <p>First: bringing up new WireGuard peers was slow. Real, real slow.</p> <p>It’s Fall of 2021 and here’s what happened when you asked us to create a new WireGuard peer:</p> <ol> <li>You’d trigger a mutation in our <a href="https://api.fly.io/graphql">GraphQL API</a> to add a WireGuard peer. </li><li>Our API would generate a WireGuard configuration and send it back to you. </li><li>Meanwhile, it’d trigger a <a href="https://www.consul.io/docs/dynamic-app-config/kv">Consul KV</a> write, adding the configuration to a KV tree that I did not expect to get as big as it got. </li><li>The Consul cluster would hold an Entmoot. </li><li>45-95 seconds later, <code>consul-templaterb</code> on our gateway would get wind of a KV change, and download every single peer that had ever been configured for the gateway. </li><li>About 10 seconds earlier, your <code>flyctl</code> command gave up trying to bring up a connection to a WireGuard peer that did not yet exist on the gateway. </li><li><code>consul-templaterb</code> would write <code>wg1.conf</code> and then run a shell program that would resync the WireGuard configuration and then re-install routes for each one of the tens of thousands of WireGuard peers for that gateway. </li><li>10 seconds later, you’re good to go! Wait, where’d you go? </li></ol> <p><strong>This is very bad.</strong> It only happens the first time you use WireGuard on a machine; the next time you go light up that WireGuard peer, it’ll come right up, because it’s already installed. But guess who’s making a WireGuard connection with <code>flyctl</code> for the first time? That’s right: someone who just decided to try out <a href="http://Fly.io">Fly.io</a> and followed our <a href="https://fly.io/docs/speedrun/">Speedrun instructions</a>. No fair! It looks like all of <a href="http://Fly.io">Fly.io</a> isn’t working, when in fact the only part of <a href="http://Fly.io">Fly.io</a> that isn’t working is the part that allows you to use it.</p> <p>There was low-hanging fruit to pick here. For instance, Will took one look at our WireGuard resync shell script and cut its runtime from 10 seconds to a few dozen milliseconds. But <code>consul-templaterb</code> — well, it is what it is. “Things will go as they will, and there’s no need to hurry to meet them”, it says. “I am on nobody’s side, because nobody is on my side, little orc.”</p> <p>We have, in our prod infrastructure, two basic ways of communicating state changes: Consul and <a href="https://nats.io/">NATS</a>. Consul is slow and “reliable”; NATS is fast, but doesn&#39;t guarantee delivery. A few weeks ago, we switched from <code>consul-templaterb</code> to a system we call <code>attache</code>, which, among other things, does NATS transactions to update WireGuard peers. In the new system, creating a new WireGuard peer looks like this:</p> <ol> <li>You trigger a mutation in our GraphQL API to add a WireGuard peer. </li><li>Our API generates a WireGuard configuration and sends it to <code>attache</code> on the gateway. </li><li>A couple dozen milliseconds later, the gateway has installed the new WireGuard peer, and acknowledges the update to our API. </li><li>The API replies to your GraphQL request with the WireGuard configuration </li><li>Your <code>flyctl</code> connects to the WireGuard peer, which works, because you receiving the configuration means it’s installed on the gateway. </li></ol> <p>The whole process might take a second or two. It’s fast enough that you could imagine revisiting the decision to have a <code>flyctl</code> agent; with a little bit of caching, you could just make new WireGuard peers whenever you need them, and we could garbage collect the old ones.</p> <div> <p><strong>There Is A More Ominous Problem I Don’t Like Talking About</strong></p> <p>The remote builds, they’re way better. You can stick <code>flyctl</code> in your Github actions for CI and it’ll work.</p> <p>But I have a nagging feeling it can’t be working perfectly for everybody, because it involves running WireGuard, and, as you may already know, WireGuard doesn’t run over 443/tcp.</p> <p>If you’re on a corporate network with a proxy firewall, or on a janky VPN, or some random CI VM, 51820/udp might be blocked. In fact, for all we know, all UDP might be blocked. I’ve tried telling Kurt “that’s their problem”, but I haven’t won the argument.</p> <p>There is, in the Github project for <code>flyctl</code>, <a href="https://github.com/superfly/flyctl/pull/566">a branch that addresses this problem</a>. Our WireGuard gateways all run a program called <code>wgtcpd</code>. It is as elegant as it is easy to pronounce. It runs an HTTPS server (with a self-signed certificate, natch!) with a single endpoint that upgrades to WebSockets and proxies WireGuard. The <code>flyctl</code> <code>tcp-proxy</code> branch will run WireGuard over that, instead of UDP.</p> <p>I’m here to tell you that for all the nattering about how problematic UDP-only WireGuard is, it turns out not to involve a lot of code to fix; the WebSockets protocol for this is just “send a length, then send a packet, read a length, then read a packet”.</p> <p>We could do something even more clever here; for instance, our friends/archnemeses at Tailscale run a global network of something they call “<a href="https://pkg.go.dev/tailscale.com/derp">DERP</a>”, which is part of their <a href="https://tailscale.com/blog/how-nat-traversal-works/">NAT-traversal proxy system</a>; we could have our gateways connect to their DERP servers and register our public keys, and then you’d be able to connect to the same DERP servers and talk to us, and that seems like a fun project because there’s apparently nothing they can do to stop us.</p> <p>But we’re still in denial about this problem and waiting for it to smack us in the face; we haven’t even merged the WebSockets branch of <code>flyctl</code>, because maybe it’s just not an issue? We only just solved the peer creation lag problem, and we’re waiting for things to even out. But if you needed to, you could run a WebSockets build of <code>flyctl</code> today.</p></div><h2 id="where-this-leaves-us"><a href="#where-this-leaves-us" aria-label="Anchor"></a>Where This Leaves Us</h2><p>I’ve painted a picture here, and you might infer from it that I regret user-mode WireGuard and TCP/IP. But the truth is, I love it very much; it is one of those <a href="http://Fly.io">Fly.io</a> architectural features that makes me happy to work here. I’d say that for the first half of 2021, it probably wasn’t paying its way in complexity and operational cost, but that it’s opened up a bunch of possibilities for us that will let us build other bananas features without having to change anything in our prod infrastructure.</p> <p>There’s a fun side to <code>flyctl</code> WireGuard. For instance, it has <a href="https://fly.io/docs/flyctl/dig/">its own dig command</a>, which talks directly to our private <code>.internal</code> nameservers. What’s that, you say? The same feature would be a couple dozen lines of Ruby in a GraphQL API? Shut up!</p> <p>Or, how about this: <a href="https://git.zx2c4.com/wireguard-go/commit/?id=b9669b734e30e717835ed44ea01f7ee7cdce5563">you can ping things now.</a> Ping! Of all things! You can <code>flyctl ping</code> <code>my-app.internal</code> and we’ll ping each instance of my-app for you. I know how much you love pinging things. And what’s the fun of using a hosting platform if you don’t get to pilot Howl’s Moving Castle Of Weird Network Engineering to check the latency on your app instances?</p> <p>As I said at the top, this is one of those posts that isn’t trying to sell <a href="http://Fly.io">Fly.io</a>, but just provide a somewhat honest accounting of the experience of building it, and a peek into the way we think about stuff. Having said all that: you should take <a href="http://Fly.io">Fly.io</a> for a spin, because when <code>flyctl ssh console</code> is working — and it’s working pretty much all the time now — it is slick as hell.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/blog/new-turboku/"> Turbocharge your Heroku Apps with New Turboku </a> </dd> </dl> </article></div>
  </body>
</html>
