<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tavianator.com/2023/irregex.html">Original</a>
    <h1>Irregular Expressions</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
                    <main>
                        
<p><i></i> <time datetime="2023-03-07">2023-03-07</time>
<i></i> Tavian Barnes
<a href="https://github.com/tavianator/irregex"><i></i> GitHub</a></p>
<p><a href="https://en.wikipedia.org/wiki/Regular_expression">Regular expressions</a> are fascinating to me.
On one hand, they can be extremely succinct, expressive, and efficient.
On the other hand, they can be basically <a href="https://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html">write-only</a>.
They come with a simple but powerful <a href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">theory</a> that leads to efficient implementations.
Sadly, many implementations ignore the theory in order to offer <a href="https://en.wikipedia.org/wiki/Regular_expression#Patterns_for_non-regular_languages">additional features</a>, at the cost of <a href="https://swtch.com/~rsc/regexp/regexp1.html">worst-case exponential complexity</a>.</p>
<p><del>It is possible, however, to implement some of those additional features, and still operate in worst-case linear time.</del>
<ins>It was pointed out to me by <a href="https://twitter.com/geofflangdale/status/1633304188234104834">Geoff Langdale</a> and <a href="https://github.com/tavianator/irregex/issues/1">Evgeny Kapun</a> that my implementation of those additional features is incorrect.  I&#39;ve hidden the wrong implementations for now.</ins>
The implementation (~400 lines of Rust) even fits in a single blog post!
The full code is on <a href="https://github.com/tavianator/irregex/blob/main/src/lib.rs">GitHub</a>, and the <a href="https://github.com/tavianator/irregex/commits/main">commit history</a> lines up with the blog post if you want to follow along.</p>
<h2 id="state-machines"><a href="#state-machines">State machines</a></h2>
<p>The key to worst-case linear running time is to use <a href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">Nondeterministic Finite Automata (NFAs)</a>.
An NFA is basically a flow chart for deciding whether to accept or reject a string.
The N in NFA means that multiple states can be active at the same time.</p>
<figure>
  <svg width="320" viewBox="-60 -100 320 130">
    <text x="100" y="-80" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">
      <tspan>a<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></tspan><!--
      --><tspan>b<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></tspan><!--
      --><tspan>a<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></tspan><!--
      --><tspan>c<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></tspan><!--
      --><tspan>u<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></tspan><!--
      --><tspan>s<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate></tspan>
    </text>
    <line x1="-50" y1="0" x2="-20" y2="0" stroke="var(--fg)" stroke-dasharray="30"><animate attributeName="stroke-dashoffset" values="0;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;2;1;1;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="-20,0 -30,-4, -30,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="0" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;3;3;3;3;3;3;3;3;3;3;3;3;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <path d="M 14.1421 -14.1421 A 25 25 0 1 0 -14.1421 -14.1421" stroke="var(--fg)" stroke-dasharray="127.0213623046875" fill="none"><animate attributeName="stroke-dashoffset" values="0;0;0;-254;-254;-508;-508;-762;-762;-1016;-1016;-1270;-1270;-1524;-1524" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;2;1;2;1;2;1;2;1;2;1;2;1" dur="15s" repeatCount="indefinite"></animate></path>
    <polygon points="0,0 -10,-5, -10,5" transform="translate(-14.1421 -14.1421) rotate(45)" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="0" y="-70" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">.<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <line x1="20" y1="0" x2="80" y2="0" stroke="var(--fg)" stroke-dasharray="60"><animate attributeName="stroke-dashoffset" values="0;0;0;-120;-120;-120;-120;-240;-240;-240;-240;-240;-240;-240;-240" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;2;1;1;1;2;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="80,0 70,-4, 70,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="50" y="-15" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">a<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="100" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;3;2;2;2;3;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <line x1="120" y1="0" x2="180" y2="0" stroke="var(--fg)" stroke-dasharray="60"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;0;0;0;0;-120;-120;-120;-120;-120;-120" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;1;1;1;1;2;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="180,0 170,-4, 170,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="150" y="-15" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">c<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="200" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;2;3;3;3;3;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="200" cy="0" r="16" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;2;3;3;3;3;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <g transform="translate(200 0)">
      <path d="M 14.1421 -14.1421 A 25 25 0 1 0 -14.1421 -14.1421" stroke="var(--fg)" stroke-dasharray="127.0213623046875" fill="none"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;0;0;0;0;0;0;-254;-254;-508;-508" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;1;1;1;1;1;1;2;1;2;1" dur="15s" repeatCount="indefinite"></animate></path>
      <polygon points="0,0 -10,-5, -10,5" transform="translate(-14.1421 -14.1421) rotate(45)" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
      <text x="0" y="-70" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">.<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    </g>
  </svg>
</figure>

<p>Before actually implementing NFAs, it&#39;s nice to start with an interface for them:</p>
<pre><code>/// A regular expression matcher.
trait Matcher {
    /// Activate this matcher&#39;s *start* state.
    fn start(&amp;mut self) -&gt; bool;

    /// Process a character from the string we&#39;re matching against.
    fn push(&amp;mut self, c: char) -&gt; bool;
}</code></pre>
<p>A <code>Matcher</code> starts out with no active states.
<code>Matcher::start()</code> activates the start state, and returns whether the matcher is currently in an accepting state (which could happen if, for example, the regex matches an empty string).
To test if a string matches, you feed its characters one-by-one to <code>Matcher::push()</code>, or just call this helper method to do it for you:</p>
<pre><code>trait Matcher {
    ...
    /// Test if a string matches.
    fn matches(&amp;mut self, text: &amp;str) -&gt; bool {
        text.chars().fold(self.start(), |_, c| self.push(c))
    }
}</code></pre>

<div>
<h2 id="much-ado-about-nothing"><a href="#much-ado-about-nothing">Much ado about nothing</a></h2>
<p><a href="https://github.com/tavianator/irregex/commit/346711c2777f957805f7b8788c637976b005f831"><i></i> Commit</a></p>
</div>
<p>The simplest regex is the empty regex, so let&#39;s start with that.</p>
<pre><code>/// A regular expression.
enum Regex {
    /// The empty regex.
    Empty,
}</code></pre>
<p>The empty matcher has only one state.</p>

<div>
<figure>
  <svg width="120" viewBox="-60 -40 120 80">
    <line x1="-50" y1="0" x2="-20" y2="0" stroke="var(--fg)" stroke-dasharray="30"><animate attributeName="stroke-dashoffset" values="0;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;2;1;1;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="-20,0 -30,-4, -30,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="0" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;3;2;2;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="0" cy="0" r="16" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;3;2;2;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
  </svg>
</figure>
<pre><code>/// Matcher for Regex::Empty.
#[derive(Default)]
struct Empty {
    matched: bool,
}

impl Matcher for Empty {
    fn start(&amp;mut self) -&gt; bool {
        self.matched = true;
        true
    }

    fn push(&amp;mut self, _: char) -&gt; bool {
        self.matched = false;
        false
    }
}</code></pre>
</div>
<p>It would be convenient if we could parse regexes instead of having to write things like <code>Regex::Empty</code> explicitly.
We can use <a href="https://crates.io/crates/nom">nom</a> to build a parser, starting with a simple grammar.</p>
<div>
<figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Eᴍᴘᴛʏ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mi>ε</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Gʀᴏᴜᴘ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">(</mtext><mtext>  </mtext><mtext>Rᴇɢᴇx</mtext><mtext>  </mtext><mtext mathvariant="monospace">)</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Rᴇɢᴇx</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Gʀᴏᴜᴘ</mtext><mo>∣</mo><mtext>Eᴍᴘᴛʏ</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{Eᴍᴘᴛʏ} &amp; \rarr \varepsilon \\[2pt]
\text{Gʀᴏᴜᴘ} &amp; \rarr \texttt{(} \; \text{Rᴇɢᴇx} \; \texttt{)} \\[2pt]
\text{Rᴇɢᴇx} &amp; \rarr \text{Gʀᴏᴜᴘ} \mid \text{Eᴍᴘᴛʏ} \\
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>Eᴍᴘᴛʏ</span></span></span></span><span><span></span><span><span><span>Gʀᴏᴜᴘ</span></span></span></span><span><span></span><span><span><span>Rᴇɢᴇx</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>→</span><span></span><span>ε</span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>(</span></span><span></span><span><span>Rᴇɢᴇx</span></span><span></span><span><span>)</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Gʀᴏᴜᴘ</span></span><span></span><span>∣</span><span></span><span><span>Eᴍᴘᴛʏ</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
</figure>
<pre><code>/// Parser implementation.
fn regex(pattern: &amp;str) -&gt; IResult&lt;&amp;str, Regex&gt; {
    let empty = success(Regex::Empty);

    let group = delimited(char(&#39;(&#39;), regex, char(&#39;)&#39;));

    alt((group, empty))
        .parse(input)
}</code></pre>
</div>
<div>
<h2 id="dot-dot-dot"><a href="#dot-dot-dot">Dot dot dot</a></h2>
<p><a href="https://github.com/tavianator/irregex/commit/91a5c86122d7abd6584d3ff012a0a58481e2d97f"><i></i> Commit</a></p>
</div>
<p>The next-simplest regex is the <code>.</code> metacharacter, which matches any character.</p>
<pre><code>enum Regex {
    ...
    /// Matches any one character.
    Dot,
}</code></pre>
<p>The matcher for <code>.</code> has two states.</p>
<div>
<figure>
  <svg width="220" viewBox="-60 -40 220 80">
    <line x1="-50" y1="0" x2="-20" y2="0" stroke="var(--fg)" stroke-dasharray="30"><animate attributeName="stroke-dashoffset" values="0;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;2;1;1;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="-20,0 -30,-4, -30,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="0" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;3;2;2;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <line x1="20" y1="0" x2="80" y2="0" stroke="var(--fg)" stroke-dasharray="60"><animate attributeName="stroke-dashoffset" values="0;0;0;-120;-120;-120;-120;-120;-120;-120;-120;-120;-120;-120;-120" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;2;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="80,0 70,-4, 70,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="50" y="-15" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">.<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="100" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;3;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="100" cy="0" r="16" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;3;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
  </svg>
</figure>
<pre><code>/// Matcher for Regex::Dot.
#[derive(Default)]
struct Dot {
    started: bool,
    matched: bool,
}

impl Matcher for Dot {
    fn start(&amp;mut self) -&gt; bool {
        self.started = true;
        self.matched
    }

    fn push(&amp;mut self, _: char) -&gt; bool {
        self.matched = self.started;
        self.started = false;
        self.matched
    }
}</code></pre>
</div>
<p>It&#39;s a small addition to the parser as well.</p>
<div>
<figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Dᴏᴛ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">.</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Rᴇɢᴇx</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Dᴏᴛ</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{Dᴏᴛ} &amp; \rarr \texttt{.} \\[2pt]
\text{Rᴇɢᴇx} &amp; \rarr \text{Dᴏᴛ}
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>Dᴏᴛ</span></span></span></span><span><span></span><span><span><span>Rᴇɢᴇx</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>.</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Dᴏᴛ</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
</figure>
<pre><code>fn regex(pattern: &amp;str) -&gt; IResult&lt;&amp;str, Regex&gt; {
    ...
    let dot = char(&#39;.&#39;).map(|_| Regex::Dot);

    alt((dot, group, empty))
        .parse(input)
}</code></pre>
</div>
<div>
<h2 id="literally-me"><a href="#literally-me">Literally me</a></h2>
<p><a href="https://github.com/tavianator/irregex/commit/48604737308076ff7bace3d852b53a480580d891"><i></i> Commit</a></p>
</div>
<p>The next regex to support is character literals like <code>c</code> that match only themselves.</p>
<pre><code>enum Regex {
    ...
    /// Matches a literal character.
    Literal(char),
}</code></pre>
<p>The matcher for literals is very similar to <code>Dot</code>.</p>
<div>
<figure>
  <svg width="220" viewBox="-60 -40 220 80">
    <line x1="-50" y1="0" x2="-20" y2="0" stroke="var(--fg)" stroke-dasharray="30"><animate attributeName="stroke-dashoffset" values="0;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;2;1;1;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="-20,0 -30,-4, -30,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="0" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;3;2;2;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <line x1="20" y1="0" x2="80" y2="0" stroke="var(--fg)" stroke-dasharray="60"><animate attributeName="stroke-dashoffset" values="0;0;0;-120;-120;-120;-120;-120;-120;-120;-120;-120;-120;-120;-120" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;2;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="80,0 70,-4, 70,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="50" y="-15" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">c<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="100" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;3;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="100" cy="0" r="16" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;3;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
  </svg>
</figure>
<pre><code>/// Matcher for Regex::Literal.
struct Literal {
    c: char,
    started: bool,
    matched: bool,
}

impl Matcher for Literal {
    fn start(&amp;mut self) -&gt; bool {
        self.started = true;
        self.matched
    }

    fn push(&amp;mut self, c: char) -&gt; bool {
        self.matched = self.started &amp;&amp; c == self.c;
        self.started = false;
        self.matched
    }
}</code></pre>
</div>
<p>The parser is extended with support for literals, as well as escape sequences like <code>\.</code> to allow matching metacharacters literally.</p>
<div>
<figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Mᴇᴛᴀ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">\</mtext><mo>∣</mo><mtext mathvariant="monospace">(</mtext><mo>∣</mo><mtext mathvariant="monospace">)</mtext><mo>∣</mo><mtext mathvariant="monospace">.</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Lɪᴛᴇʀᴀʟ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>any non-Mᴇᴛᴀ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mpadded height="0px" depth="0px"><mphantom><mrow></mrow><mo>→</mo><mrow></mrow></mphantom></mpadded><mtext>character</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Esᴄᴀᴘᴇ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">\</mtext><mtext>  </mtext><mtext>Mᴇᴛᴀ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Rᴇɢᴇx</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Lɪᴛᴇʀᴀʟ</mtext><mo>∣</mo><mtext>Esᴄᴀᴘᴇ</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{Mᴇᴛᴀ} &amp; \rarr \texttt{\textbackslash} \mid \texttt{(} \mid \texttt{)} \mid \texttt{.} \\[2pt]
\text{Lɪᴛᴇʀᴀʟ} &amp; \rarr \text{any non-Mᴇᴛᴀ} \\
&amp; \hphantom{{}\rarr{}} \text{character} \\[2pt]
\text{Esᴄᴀᴘᴇ} &amp; \rarr \texttt{\textbackslash} \; \text{Mᴇᴛᴀ} \\[2pt]
\text{Rᴇɢᴇx} &amp; \rarr \text{Lɪᴛᴇʀᴀʟ} \mid \text{Esᴄᴀᴘᴇ} \\
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>Mᴇᴛᴀ</span></span></span></span><span><span></span><span><span><span>Lɪᴛᴇʀᴀʟ</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>Esᴄᴀᴘᴇ</span></span></span></span><span><span></span><span><span><span>Rᴇɢᴇx</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>\</span></span><span></span><span>∣</span><span></span><span><span>(</span></span><span></span><span>∣</span><span></span><span><span>)</span></span><span></span><span>∣</span><span></span><span><span>.</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>any non-Mᴇᴛᴀ</span></span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span></span><span></span><span>→</span><span></span><span></span></span></span></span></span></span></span></span><span><span>character</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>\</span></span><span></span><span><span>Mᴇᴛᴀ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Lɪᴛᴇʀᴀʟ</span></span><span></span><span>∣</span><span></span><span><span>Esᴄᴀᴘᴇ</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
</figure>
<pre><code>fn regex(pattern: &amp;str) -&gt; IResult&lt;&amp;str, Regex&gt; {
    ...
    let meta = r&#34;\().&#34;;

    let literal = none_of(meta).map(Regex::Literal);

    let escape = preceded(char(&#39;\\&#39;), one_of(meta))
        .map(Regex::Literal);

    alt((literal, escape, dot, group, empty))
        .parse(input)
}</code></pre>
</div>
<div>
<h2 id="a-star-is-born"><a href="#a-star-is-born">A star is born</a></h2>
<p><a href="https://github.com/tavianator/irregex/commit/36a2c9fb40b098f67a15d0775e95ed36b1d1c3fc"><i></i> Commit</a></p>
</div>
<p>So far our regexes can only match up to a single character.
The next step is to support the <a href="https://en.wikipedia.org/wiki/Kleene_star">Kleene star</a> operator <code>*</code>, for regexes like <code>a*</code> that match <code>&#34;&#34;</code>, <code>&#34;a&#34;</code>, <code>&#34;aa&#34;</code>, <code>&#34;aaa&#34;</code>, etc.</p>
<pre><code>enum Regex {
    ...
    /// Matches zero or more repetitions.
    Star(Box&lt;Regex&gt;),
}</code></pre>
<p>The NFA for the <code>*</code> operator adds a loop with <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ε</span></span></span></span></span>-transitions to let the pattern match multiple times.
It doesn&#39;t even need any states of its own.</p>
<div>
<figure>
  <svg width="220" viewBox="-60 -105 220 210">
    <ellipse cx="50" cy="0" rx="90" ry="50" stroke="var(--fg)" stroke-width="2" fill="var(--theme-hover)"></ellipse>
    <text x="50" y="-25" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">A<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <line x1="-50" y1="0" x2="-20" y2="0" stroke="var(--fg)" stroke-dasharray="30"><animate attributeName="stroke-dashoffset" values="0;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;2;1;1;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="-20,0 -30,-4, -30,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="0" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;3;3;3;3;3;2;2;2;2;3;3;3;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <line x1="20" y1="0" x2="80" y2="0" stroke="var(--fg)" stroke-dasharray="5"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;0;0;-10;-20;-20;-20;-20;-20;-20;-20" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;1;1;2;2;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="80,0 70,-4, 70,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="100" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;3;3;3;2;2;3;3;3;3;3;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="100" cy="0" r="16" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;3;3;3;2;2;3;3;3;3;3;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <path d="M 0 20 A 60 120 0 0 0 98 22" stroke="var(--fg)" stroke-dasharray="149.77947998046875" fill="none"><animate attributeName="stroke-dashoffset" values="0;0;0;-298;-298;-298;-298;-298;-298;-298;-298;-298;-596;-596;-596" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;2;1;1;1;1;1;1;1;1;2;1;1" dur="15s" repeatCount="indefinite"></animate></path>
    <polygon points="0,0 -10,-5, -10,5" transform="translate(99 20) rotate(-70)" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="50" y="95" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">ε<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <path d="M 100 -20 A 60 120 0 0 0 2 -22" stroke="var(--fg)" stroke-dasharray="149.77947998046875" fill="none"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;-298;-298;-298;-298;-298;-596;-596;-596;-596;-596" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;2;1;1;1;1;2;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></path>
    <polygon points="0,0 -10,-5, -10,5" transform="translate(1 -20) rotate(110)" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="50" y="-85" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">ε<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
  </svg>
</figure>
<pre><code>/// Matcher for Regex::Star.
struct Star&lt;A&gt;(A);

impl&lt;A: Matcher&gt; Matcher for Star&lt;A&gt; {
    fn start(&amp;mut self) -&gt; bool {
        self.0.start() || true
    }

    fn push(&amp;mut self, c: char) -&gt; bool {
        self.0.push(c) &amp;&amp; self.start()
    }
}</code></pre>
</div>
<p>To parse the <code>*</code> operator properly we have to shuffle some grammar rules around.</p>
<div>
<figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Mᴇᴛᴀ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">*</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Aᴛᴏᴍ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Lɪᴛᴇʀᴀʟ</mtext><mo>∣</mo><mtext>Esᴄᴀᴘᴇ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Dᴏᴛ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Gʀᴏᴜᴘ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Rᴇᴘᴇᴀᴛ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Aᴛᴏᴍ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Rᴇᴘᴇᴀᴛ</mtext><mtext>  </mtext><mtext mathvariant="monospace">*</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Rᴇɢᴇx</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Rᴇᴘᴇᴀᴛ</mtext><mo>∣</mo><mtext>Eᴍᴘᴛʏ</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{Mᴇᴛᴀ} &amp; \rarr \texttt{*} \\[2pt]
\text{Aᴛᴏᴍ} &amp; \rarr \text{Lɪᴛᴇʀᴀʟ} \mid \text{Esᴄᴀᴘᴇ} \\
&amp; \rarr \text{Dᴏᴛ} \\
&amp; \rarr \text{Gʀᴏᴜᴘ} \\[2pt]
\text{Rᴇᴘᴇᴀᴛ} &amp; \rarr \text{Aᴛᴏᴍ} \\
&amp; \rarr \text{Rᴇᴘᴇᴀᴛ} \; \texttt{*} \\[2pt]
\text{Rᴇɢᴇx} &amp; \rarr \text{Rᴇᴘᴇᴀᴛ} \mid \text{Eᴍᴘᴛʏ} \\
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>Mᴇᴛᴀ</span></span></span></span><span><span></span><span><span><span>Aᴛᴏᴍ</span></span></span></span><span><span></span><span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>Rᴇᴘᴇᴀᴛ</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>Rᴇɢᴇx</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>*</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Lɪᴛᴇʀᴀʟ</span></span><span></span><span>∣</span><span></span><span><span>Esᴄᴀᴘᴇ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Dᴏᴛ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Gʀᴏᴜᴘ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Aᴛᴏᴍ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Rᴇᴘᴇᴀᴛ</span></span><span></span><span><span>*</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Rᴇᴘᴇᴀᴛ</span></span><span></span><span>∣</span><span></span><span><span>Eᴍᴘᴛʏ</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
</figure>
<pre><code>fn regex(pattern: &amp;str) -&gt; IResult&lt;&amp;str, Regex&gt; {
    ...
    let meta = r&#34;\().*&#34;;
    ...
    let atom = alt((literal, escape, dot, group));

    let repeat = flat_map(atom, |r| fold_many0(
        char(&#39;*&#39;),
        move || r.clone(),
        |r, _| r.star(),
    ));

    alt((repeat, empty))
        .parse(input)
}</code></pre>
</div>
<div>
<h2 id="one-is-the-loneliest-number"><a href="#one-is-the-loneliest-number">One is the loneliest number</a></h2>
<p><a href="https://github.com/tavianator/irregex/commit/590470a431e4d04455e83ce257f97716031e3137"><i></i> Commit</a></p>
</div>
<p>It&#39;s a bit sad that our regexes can currently only have one (non-meta) character.
We can handle <code>a</code>, <code>a*</code>, and even the questionably-useful <code>a**</code>, but in order to support regexes like <code>ab*c</code>, we need our first binary operator: concatenation.</p>
<pre><code>enum Regex {
    ...
    /// Matches two patterns in a row.
    Concat(Box&lt;Regex&gt;, Box&lt;Regex&gt;),
}</code></pre>
<p>The matcher for concatenated patterns connects the accept state of the first to the start state of the second.</p>

<div>
<figure>
  <svg width="420" viewBox="40 -70 420 140">
    <ellipse cx="150" cy="0" rx="90" ry="50" stroke="var(--fg)" stroke-width="2" fill="var(--theme-hover)"></ellipse>
    <line x1="50" y1="0" x2="80" y2="0" stroke="var(--fg)" stroke-dasharray="30"><animate attributeName="stroke-dashoffset" values="0;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;2;1;1;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="80,0 70,-4, 70,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="150" y="-25" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">L<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="100" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;3;2;2;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <line x1="120" y1="0" x2="180" y2="0" stroke="var(--fg)" stroke-dasharray="5"><animate attributeName="stroke-dashoffset" values="0;0;0;-10;-20;-20;-20;-20;-20;-20;-20;-20;-20;-20;-20" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;2;2;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="180,0 170,-4, 170,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="200" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;3;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="200" cy="0" r="16" stroke="var(--fg)" stroke-width="2" stroke-dasharray="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;3;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <ellipse cx="350" cy="0" rx="90" ry="50" stroke="var(--fg)" stroke-width="2" fill="var(--theme-hover)"></ellipse>
    <line x1="220" y1="0" x2="280" y2="0" stroke="var(--fg)" stroke-dasharray="60"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;0;-120;-120;-120;-120;-120;-120;-120;-120;-120" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;1;2;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="280,0 270,-4, 270,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="250" y="-15" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">ε<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="300" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;3;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <text x="350" y="-25" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">R<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <line x1="320" y1="0" x2="380" y2="0" stroke="var(--fg)" stroke-dasharray="5"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;0;0;0;-10;-20;-20;-20;-20;-20;-20" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;1;1;1;2;2;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="380,0 370,-4, 370,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="400" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;2;3;3;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="400" cy="0" r="16" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;2;3;3;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
  </svg>
</figure>
<figure>
  <svg width="140" viewBox="-70 40 140 420">
    <g transform="rotate(90)">
    <ellipse cx="150" cy="0" rx="90" ry="50" stroke="var(--fg)" stroke-width="2" fill="var(--theme-hover)"></ellipse>
    <line x1="50" y1="0" x2="80" y2="0" stroke="var(--fg)" stroke-dasharray="30"><animate attributeName="stroke-dashoffset" values="0;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;2;1;1;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="80,0 70,-4, 70,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="150" y="-25" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">L<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="100" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;3;2;2;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <line x1="120" y1="0" x2="180" y2="0" stroke="var(--fg)" stroke-dasharray="5"><animate attributeName="stroke-dashoffset" values="0;0;0;-10;-20;-20;-20;-20;-20;-20;-20;-20;-20;-20;-20" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;2;2;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="180,0 170,-4, 170,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="200" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;3;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="200" cy="0" r="16" stroke="var(--fg)" stroke-width="2" stroke-dasharray="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;3;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <ellipse cx="350" cy="0" rx="90" ry="50" stroke="var(--fg)" stroke-width="2" fill="var(--theme-hover)"></ellipse>
    <line x1="220" y1="0" x2="280" y2="0" stroke="var(--fg)" stroke-dasharray="60"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;0;-120;-120;-120;-120;-120;-120;-120;-120;-120" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;1;2;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="280,0 270,-4, 270,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="250" y="-15" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">ε<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="300" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;3;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <text x="350" y="-25" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">R<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <line x1="320" y1="0" x2="380" y2="0" stroke="var(--fg)" stroke-dasharray="5"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;0;0;0;-10;-20;-20;-20;-20;-20;-20" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;1;1;1;2;2;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="380,0 370,-4, 370,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="400" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;2;3;3;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="400" cy="0" r="16" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;2;3;3;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    </g>
  </svg>
</figure>
<pre><code>/// Matcher for Regex::Concat.
struct Concat&lt;L, R&gt; {
    left: L,
    right: R,
    right_started: bool,
}

impl&lt;L: Matcher, R: Matcher&gt; Matcher for Concat&lt;L, R&gt; {
    fn start(&amp;mut self) -&gt; bool {
        if self.left.start() {
            self.right_started = true;
            self.right.start();
        } else {
            false
        }
    }

    fn push(&amp;mut self, c: char) -&gt; bool {
        let mut ret = false;

        if self.right_started {
            ret |= self.right.push(c);
        }

        if self.left.push(c) {
            self.right_started = true;
            ret |= self.right.start();
        }

        ret
    }
}</code></pre>
</div>
<p>Just one more grammar rule is all we need to parse concatenations.</p>
<div>
<figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Wᴏʀᴅ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Rᴇᴘᴇᴀᴛ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Wᴏʀᴅ</mtext><mtext>  </mtext><mtext>Rᴇᴘᴇᴀᴛ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Rᴇɢᴇx</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Wᴏʀᴅ</mtext><mo>∣</mo><mtext>Eᴍᴘᴛʏ</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{Wᴏʀᴅ} &amp; \rarr \text{Rᴇᴘᴇᴀᴛ} \\
&amp; \rarr \text{Wᴏʀᴅ} \; \text{Rᴇᴘᴇᴀᴛ} \\[2pt]
\text{Rᴇɢᴇx} &amp; \rarr \text{Wᴏʀᴅ} \mid \text{Eᴍᴘᴛʏ} \\
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>Wᴏʀᴅ</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>Rᴇɢᴇx</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Rᴇᴘᴇᴀᴛ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Wᴏʀᴅ</span></span><span></span><span><span>Rᴇᴘᴇᴀᴛ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Wᴏʀᴅ</span></span><span></span><span>∣</span><span></span><span><span>Eᴍᴘᴛʏ</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
</figure>
<pre><code>fn regex(pattern: &amp;str) -&gt; IResult&lt;&amp;str, Regex&gt; {
    ...
    let word = many1(repeat)
        .map(|v| reduce(v, Regex::concat));

    alt((word, empty))
        .parse(input)
}</code></pre>
</div>
<div>
<h2 id="this-or-that"><a href="#this-or-that">This or that</a></h2>
<p><a href="https://github.com/tavianator/irregex/commit/40c116469867941ca6ef7f5cfec3c32bda1da0ca"><i></i> Commit</a></p>
</div>
<p>Our next feature is the alternation operator <code>|</code>, which lets us match either (or both) of two patterns.</p>
<pre><code>enum Regex {
    ...
    /// Matches either of two patterns.
    Or(Box&lt;Regex&gt;, Box&lt;Regex&gt;),
}</code></pre>
<p>The matcher for alternations joins both patterns together with <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>ε</span></span></span></span></span>-transitions.</p>
<div>
<figure>
  <svg width="340" viewBox="-30 -120 340 240">
    <line x1="-20" y1="0" x2="10" y2="0" stroke="var(--fg)" stroke-dasharray="30"><animate attributeName="stroke-dashoffset" values="0;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60;-60" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;2;1;1;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="10,0 0,-4, 0,4" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="30" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;3;3;3;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <ellipse cx="150" cy="-60" rx="90" ry="50" stroke="var(--fg)" stroke-width="2" fill="var(--theme-hover)"></ellipse>
    <line x1="44.1421" y1="-14.1421" x2="85.858" y2="-45.858" stroke="var(--fg)" stroke-dasharray="52.403385162353516"><animate attributeName="stroke-dashoffset" values="0;0;0;-104;-104;-104;-104;-104;-104;-104;-104;-104;-104;-104;-104" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;2;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="0,0 -10,-5, -10,5" transform="translate(85.858 -45.858) rotate(-40)" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="45" y="-35" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">ε<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <text x="150" y="-85" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">A<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="100" cy="-60" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;3;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <line x1="120" y1="-60" x2="180" y2="-60" stroke="var(--fg)" stroke-dasharray="5"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;-10;-20;-20;-20;-20;-20;-20;-20;-20;-20" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;2;2;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="180,-60 170,-64, 170,-56" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <circle cx="200" cy="-60" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;3;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="200" cy="-60" r="16" stroke="var(--fg)" stroke-width="2" stroke-dasharray="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;3;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="270" cy="0" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;3;3;3;3;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="270" cy="0" r="16" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;3;3;3;3;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <line x1="214.1421" y1="-45.858" x2="255.858" y2="-14.142" stroke="var(--fg)" stroke-dasharray="52.403385162353516"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;0;0;0;-104;-104;-104;-104;-104;-104;-104" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;1;1;1;2;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="0,0 -10,-5, -10,5" transform="translate(255.858 -14.142) rotate(40)" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="250" y="-35" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">ε<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <ellipse cx="150" cy="60" rx="90" ry="50" stroke="var(--fg)" stroke-width="2" fill="var(--theme-hover)"></ellipse>
    <line x1="44.1421" y1="14.1421" x2="85.858" y2="45.858" stroke="var(--fg)" stroke-dasharray="52.403385162353516"><animate attributeName="stroke-dashoffset" values="0;0;0;-104;-104;-104;-104;-104;-104;-104;-104;-104;-104;-104;-104" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;2;1;1;1;1;1;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="0,0 -10,-5, -10,5" transform="translate(85.858 45.858) rotate(40)" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="45" y="40" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">ε<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="100" cy="60" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;3;2;2;2;2;2;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <text x="150" y="35" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">B<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <line x1="120" y1="60" x2="180" y2="60" stroke="var(--fg)" stroke-dasharray="5"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;-10;-20;-30;-40;-40;-40;-40;-40;-40;-40" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;2;2;2;2;1;1;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="180,60 170,56, 170,64" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <line x1="214.1421" y1="45.858" x2="255.858" y2="14.142" stroke="var(--fg)" stroke-dasharray="52.403385162353516"><animate attributeName="stroke-dashoffset" values="0;0;0;0;0;0;0;0;0;0;-104;-104;-104;-104;-104" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="1;1;1;1;1;1;1;1;1;1;2;1;1;1;1" dur="15s" repeatCount="indefinite"></animate></line>
    <polygon points="0,0 -10,-5, -10,5" transform="translate(255.858 14.142) rotate(-40)" fill="var(--fg)"><animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></polygon>
    <text x="250" y="40" text-anchor="middle" fill="var(--fg)" font-family="var(--mono-font)">ε<animate attributeName="fill" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate></text>
    <circle cx="200" cy="60" r="20" stroke="var(--fg)" stroke-width="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;3;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
    <circle cx="200" cy="60" r="16" stroke="var(--fg)" stroke-width="2" stroke-dasharray="2" fill="none"><animate attributeName="stroke" values="var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg);var(--sidebar-active);var(--fg);var(--fg);var(--fg);var(--fg);var(--fg)" dur="15s" repeatCount="indefinite"></animate><animate attributeName="stroke-width" values="2;2;2;2;2;2;2;2;2;3;2;2;2;2;2" dur="15s" repeatCount="indefinite"></animate></circle>
  </svg>
</figure>
<pre><code>/// Matcher for Regex::Or.
struct Or&lt;A, B&gt;(A, B);

impl&lt;A, B&gt; Matcher for Or&lt;A, B&gt;
where
    A: Matcher,
    B: Matcher,
{
    fn start(&amp;mut self) -&gt; bool {
        self.0.start() | self.1.start()
    }

    fn push(&amp;mut self, c: char) -&gt; bool {
        self.0.push(c) | self.1.push(c)
    }
}</code></pre>
</div>
<p>A couple more grammar rules are all we need.</p>
<div>
<figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Mᴇᴛᴀ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">|</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Cʜᴜɴᴋ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Wᴏʀᴅ</mtext><mo>∣</mo><mtext>Eᴍᴘᴛʏ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Rᴇɢᴇx</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Cʜᴜɴᴋ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Rᴇɢᴇx</mtext><mtext>  </mtext><mtext mathvariant="monospace">|</mtext><mtext>  </mtext><mtext>Cʜᴜɴᴋ</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{Mᴇᴛᴀ} &amp; \rarr \texttt{|} \\[2pt]
\text{Cʜᴜɴᴋ} &amp; \rarr \text{Wᴏʀᴅ} \mid \text{Eᴍᴘᴛʏ} \\[2pt]
\text{Rᴇɢᴇx} &amp; \rarr \text{Cʜᴜɴᴋ} \\
&amp; \rarr \text{Rᴇɢᴇx} \; \texttt{|} \; \text{Cʜᴜɴᴋ} \\
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>Mᴇᴛᴀ</span></span></span></span><span><span></span><span><span><span>Cʜᴜɴᴋ</span></span></span></span><span><span></span><span><span><span>Rᴇɢᴇx</span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>|</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Wᴏʀᴅ</span></span><span></span><span>∣</span><span></span><span><span>Eᴍᴘᴛʏ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Cʜᴜɴᴋ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Rᴇɢᴇx</span></span><span></span><span><span>|</span></span><span></span><span><span>Cʜᴜɴᴋ</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
</figure>
<pre><code>fn regex(pattern: &amp;str) -&gt; IResult&lt;&amp;str, Regex&gt; {
    ...
    let meta = r&#34;\().*|&#34;;
    ...
    let chunk = alt((word, empty));

    separated_list1(char(&#39;|&#39;), chunk)
        .map(|v| reduce(v, Regex::or))
        .parse(pattern)
}</code></pre>
</div>
<div>
<h2 id="feature-complete"><a href="#feature-complete">Feature-complete</a></h2>
<p><a href="https://github.com/tavianator/irregex/commit/5b9f5f8f2f8a18661a5999bc4e8c6610387f5f7e"><i></i> Commit</a>,
<a href="https://github.com/tavianator/irregex/commit/1c97b9459bf633c8f221cd6544bd3c620cd90ee6">commit</a></p>
</div>
<p>The features we implemented so far are enough to express every <a href="https://en.wikipedia.org/wiki/Regular_language">regular language</a>—in other words, to match anything that could be matched by a regular expression.
Actually, we didn&#39;t even need <code>.</code>, though it would be very inconvenient to have to write</p>
<p>
<code>(a|b|c|...|A|B|C|...|0|1|2|...|!|@|#|...)</code>
</p>
<p>instead.</p>
<p>There are still a few other features that regex engines commonly provide, such as the <code>+</code> (repeat 1 or more times) and <code>?</code> (match 0 or 1 times) operators, that we could easily implement.</p>
<pre><code>enum Regex {
    ...
    /// Matches one or more repetitions.
    Plus(Box&lt;Regex&gt;),
    /// Matches zero or one times.
    Maybe(Box&lt;Regex&gt;),
}</code></pre>
<div>
<figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Mᴇᴛᴀ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">+</mtext><mo>∣</mo><mtext mathvariant="monospace">?</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Rᴇᴘᴇᴀᴛ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Rᴇᴘᴇᴀᴛ</mtext><mtext>  </mtext><mtext mathvariant="monospace">+</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Rᴇᴘᴇᴀᴛ</mtext><mtext>  </mtext><mtext mathvariant="monospace">?</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{Mᴇᴛᴀ} &amp; \rarr \texttt{+} \mid \texttt{?} \\[2pt]
\text{Rᴇᴘᴇᴀᴛ} &amp; \rarr \text{Rᴇᴘᴇᴀᴛ} \; \texttt{+} \\
&amp; \rarr \text{Rᴇᴘᴇᴀᴛ} \; \texttt{?} \\
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>Mᴇᴛᴀ</span></span></span></span><span><span></span><span><span><span>Rᴇᴘᴇᴀᴛ</span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>+</span></span><span></span><span>∣</span><span></span><span><span>?</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Rᴇᴘᴇᴀᴛ</span></span><span></span><span><span>+</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Rᴇᴘᴇᴀᴛ</span></span><span></span><span><span>?</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
</figure>
<pre><code>fn regex(pattern: &amp;str) -&gt; IResult&lt;&amp;str, Regex&gt; {
    ...
    let meta = r&#34;\().*|+?&#34;;
    ...
    let repeat = flat_map(atom, |r| fold_many0(
        one_of(&#34;*+?&#34;),
        move || r.clone(),
        |r, c| match c {
            &#39;*&#39; =&gt; r.star(),
            &#39;+&#39; =&gt; r.plus(),
            &#39;?&#39; =&gt; r.maybe(),
            _ =&gt; unreachable!(),
        },
    ));
    ...
}</code></pre>
</div>
<p>We don&#39;t even need any new matchers; we can just re-use existing ones.</p>
<pre><code>impl Regex {
    /// Compile a regular expression.
    fn matcher(&amp;self) -&gt; Box&lt;dyn Matcher&gt; {
        match self {
            ...
            Self::Plus(a) =&gt; Box::new(
                // A+ is the same as AA*
                a.matcher().concat(a.matcher().star())
            ),
            Self::Maybe(a) =&gt; Box::new(
                // A? is the same as (A|)
                a.matcher().or(Empty::default())
            ),
        }
    }
}</code></pre>
<p>We&#39;re also missing character classes like <code>[a-z]</code>, but this post is already long enough without them.
They could be handled like <code>Regex::Literal</code> but with a list of ranges instead of a single <code>char</code>.</p>
<hr/>
<details>
<summary>Everything below this point is actually incorrect.  Click to show it anyway.</summary>
<div>
<h2 id="not-doing-the-work"><a href="#not-doing-the-work">Not doing the work</a></h2>
<p><a href="https://github.com/tavianator/irregex/commit/425b3cf19554dfa451215f6ce82310c4c253a1f0"><i></i> Commit</a></p>
</div>
<p>Regular languages are <a href="https://en.wikipedia.org/wiki/Regular_language#Closure_properties">closed under complement</a>, which means that for every regex there is another that matches the exact opposite set of strings.
Unfortunately, this complementary regex can be pretty ugly.
Even a simple one like <code>hello</code> has a pretty terrible complement:</p>
<p>
<code>|([^h]|h[^e]|he[^l]|hel[^l]|hell[^o]|hello.).*</code>
</p>
<p>Typically, users negate their matches on a layer above the regex syntax itself, like with <code>grep -v</code> or <code>if !regex.matches(text)</code>.
But sometimes it would be useful to have dedicated syntax for inverting a regex, especially just part of a regex.
We can invent a <code>!</code> operator to express this.</p>
<pre><code>enum Regex {
    ...
    /// Matches the opposite of a pattern.
    Not(Box&lt;Regex&gt;),
}</code></pre>
<div>
<figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Mᴇᴛᴀ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">!</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>NᴏᴛWᴏʀᴅ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Wᴏʀᴅ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">!</mtext><mtext>  </mtext><mtext>NᴏᴛWᴏʀᴅ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Cʜᴜɴᴋ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>NᴏᴛWᴏʀᴅ</mtext><mo>∣</mo><mtext>Eᴍᴘᴛʏ</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{Mᴇᴛᴀ} &amp; \rarr \texttt{!} \\[2pt]
\text{NᴏᴛWᴏʀᴅ} &amp; \rarr \text{Wᴏʀᴅ} \\
&amp; \rarr \texttt{!} \; \text{NᴏᴛWᴏʀᴅ} \\[2pt]
\text{Cʜᴜɴᴋ} &amp; \rarr \text{NᴏᴛWᴏʀᴅ} \mid \text{Eᴍᴘᴛʏ} \\
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>Mᴇᴛᴀ</span></span></span></span><span><span></span><span><span><span>NᴏᴛWᴏʀᴅ</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>Cʜᴜɴᴋ</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>!</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Wᴏʀᴅ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>!</span></span><span></span><span><span>NᴏᴛWᴏʀᴅ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>NᴏᴛWᴏʀᴅ</span></span><span></span><span>∣</span><span></span><span><span>Eᴍᴘᴛʏ</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
</figure>
<pre><code>fn regex(pattern: &amp;str) -&gt; IResult&lt;&amp;str, Regex&gt; {
    ...
    let meta = r&#34;\().*|+?!&#34;;
    ...
    let not_word = many0_count(char(&#39;!&#39;))
        .and(word)
        .map(|(n, r)| {
            (0..n).fold(r, |r, _| r.not())
        });

    let chunk = alt((not_word, empty));
    ...
}</code></pre>
</div>
<p>Now we can write the opposite of <code>hello</code> much more simply: <code>!hello</code>.</p>
<p>Finding the complement of an arbitrary NFA is expensive: you first <a href="https://en.wikipedia.org/wiki/Powerset_construction">convert the NFA to a DFA</a>, which can blow up its size exponentially, and then flip the accepting/rejecting states.
Lucky for us, we don&#39;t have to.</p>
<pre><code>/// Matcher for Regex::Not.
struct Not&lt;A&gt;(A);

impl&lt;A: Matcher&gt; Matcher for Star&lt;A&gt; {
    fn start(&amp;mut self) -&gt; bool {
        !self.0.start()
    }

    fn push(&amp;mut self, c: char) -&gt; bool {
        !self.0.push(c)
    }
}</code></pre>
<p><strong>This is the key insight of the whole post:</strong> rather than actually finding the complement of an NFA, we can just write a <code>Matcher</code> implementation that acts like it.
The <code>!</code> operator lets us easily match things like &#34;lines that don&#39;t contain hello&#34;, but it also opens the door to another more useful feature.</p>
<div>
<h2 id="yes-and"><a href="#yes-and">Yes, and</a></h2>
<p><a href="https://github.com/tavianator/irregex/commit/d6c6d42fab7482715d279fccd0bf20764ee531f3"><i></i> Commit</a></p>
</div>
<p>Sometimes we might have two patterns and want <em>both</em> of them to match.
For example, we might want to find lines that contain both <code>hello</code> and <code>world</code>.
Regular languages are also <a href="https://en.wikipedia.org/wiki/Regular_language#Closure_properties">closed under intersection</a>, so we should be able to write such a regex.
Again, though, it might be pretty long.</p>
<p>
<code>.*hello.*world.*|.*world.*hello.*</code>
</p>
<p>This quickly gets out of hand with more than two patterns.
But with the <code>!</code> operator, we can use one of <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan&#39;s laws</a>,</p>
<p>
<code>(A &amp;&amp; B) == !(!A || !B)</code>
</p>
<p>to do the same thing without repeating ourselves:</p>
<p>
<code>!(!(.*hello.*)|!(.*world.*))</code>
</p>
<p>This is still not the easiest regex to read (<em>strings that don&#39;t (not contain <code>hello</code>) or (not contain <code>world</code></em>)), so let&#39;s add an <code>&amp;</code> operator to express the concept more directly:</p>
<p>
<code>(.*hello.*)&amp;(.*world.*)</code>
</p>
<pre><code>enum Regex {
    ...
    /// Matches the intersection of two patterns.
    And(Box&lt;Regex&gt;, Box&lt;Regex&gt;),
}</code></pre>
<div>
<figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Mᴇᴛᴀ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext mathvariant="monospace">&amp;</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Cʟᴀᴜsᴇ</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Cʜᴜɴᴋ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Cʟᴀᴜsᴇ</mtext><mtext>  </mtext><mtext mathvariant="monospace">&amp;</mtext><mtext>  </mtext><mtext>Cʜᴜɴᴋ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>Rᴇɢᴇx</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Cʟᴀᴜsᴇ</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mtext>Rᴇɢᴇx</mtext><mtext>  </mtext><mtext mathvariant="monospace">|</mtext><mtext>  </mtext><mtext>Cʟᴀᴜsᴇ</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{Mᴇᴛᴀ} &amp; \rarr \texttt{\&amp;} \\[2pt]
\text{Cʟᴀᴜsᴇ} &amp; \rarr \text{Cʜᴜɴᴋ} \\
&amp; \rarr \text{Cʟᴀᴜsᴇ} \; \texttt{\&amp;} \; \text{Cʜᴜɴᴋ} \\[2pt]
\text{Rᴇɢᴇx} &amp; \rarr \text{Cʟᴀᴜsᴇ} \\
&amp; \rarr \text{Rᴇɢᴇx} \; \texttt{|} \; \text{Cʟᴀᴜsᴇ} \\
\end{aligned}
</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>Mᴇᴛᴀ</span></span></span></span><span><span></span><span><span><span>Cʟᴀᴜsᴇ</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>Rᴇɢᴇx</span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>&amp;</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Cʜᴜɴᴋ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Cʟᴀᴜsᴇ</span></span><span></span><span><span>&amp;</span></span><span></span><span><span>Cʜᴜɴᴋ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Cʟᴀᴜsᴇ</span></span></span></span><span><span></span><span><span></span><span></span><span>→</span><span></span><span><span>Rᴇɢᴇx</span></span><span></span><span><span>|</span></span><span></span><span><span>Cʟᴀᴜsᴇ</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
</figure>
<pre><code>fn regex(pattern: &amp;str) -&gt; IResult&lt;&amp;str, Regex&gt; {
    ...
    let meta = r&#34;\().*|&amp;&#34;;
    ...
    let clause = separated_list1(char(&#39;&amp;&#39;), chunk)
        .map(|v| reduce(v, Regex::and));

    separated_list1(char(&#39;|&#39;), clause)
        .map(|v| reduce(v, Regex::or))
        .parse(pattern)
}</code></pre>
</div>
<p>We don&#39;t even need a new matcher,</p>
<pre><code>impl Regex {
    /// Compile a regular expression.
    fn matcher(&amp;self) -&gt; Box&lt;dyn Matcher&gt; {
        match self {
            ...
            Self::And(a, b) =&gt; Box::new(
                a.matcher().not()
                    .or(b.matcher().not())
                    .not()
            ),
        }
    }
}</code></pre>
<p>but it&#39;s not hard to write one anyway.</p>
<pre><code>/// Matcher for Regex::And.
struct And&lt;A, B&gt;(A, B);

impl&lt;A: Matcher, B: Matcher&gt; Matcher for And&lt;A, B&gt; {
    fn start(&amp;mut self) -&gt; bool {
        self.0.start() &amp; self.1.start()
    }

    fn push(&amp;mut self, c: char) -&gt; bool {
        self.0.push(c) &amp; self.1.push(c)
    }
}</code></pre>
<h2 id="looking-around"><a href="#looking-around">Looking around</a></h2>
<p>As far as I know, our <code>!</code> and <code>&amp;</code> operators are not features of any major regex implementation.
But a similar feature called <a href="https://www.regular-expressions.info/lookaround.html">lookaround</a> or positive/negative lookahead/lookbehind is found in many regex engines.</p>
<div><table><thead><tr><th>Feature</th><th>Syntax</th><th>Irregex equivalent</th></tr></thead><tbody>
<tr><td>Positive lookahead</td><td><code>A(?=B)C</code></td><td><code>A((B.*)&amp;C)</code></td></tr>
<tr><td>Negative lookahead</td><td><code>A(?!B)C</code></td><td><code>A((!B.*)&amp;C)</code></td></tr>
<tr><td>Positive lookbehind</td><td><code>A(?&lt;=B)C</code></td><td><code>(A&amp;(.*B))C</code></td></tr>
<tr><td>Negative lookbehind</td><td><code>A(?&lt;!B)C</code></td><td><code>(A&amp;(!.*B))C</code></td></tr>
</tbody></table>
</div>
<p>As far as I know, this feature is only provided by regex engines that have <a href="https://swtch.com/~rsc/regexp/regexp1.html">worst-case exponential complexity</a>.
The two major worst-case linear regex engines that I&#39;m aware of, <a href="https://github.com/google/re2/">RE2</a> and Rust&#39;s <a href="https://crates.io/crates/regex">regex</a> crate, don&#39;t support it.</p>
<blockquote>
<p><em>As a matter of principle, RE2 does not support constructs for which only backtracking solutions are known to exist.
Thus, backreferences and look-around assertions are not supported.</em></p>
<p>— <a href="https://github.com/google/re2/issues/156">https://github.com/google/re2/issues/156</a></p>
</blockquote>
<blockquote>
<p><em>Notably, backreferences and arbitrary lookahead/lookbehind assertions are not provided.
In return, regular expression searching provided by this package has excellent worst-case performance.</em></p>
<p>— <a href="https://github.com/rust-lang/regex/issues/127">https://github.com/rust-lang/regex/issues/127</a></p>
</blockquote>
<p>But as this post shows, it is certainly possible to support lookaround (not backreferences!) in linear time.
There are some unanswered questions (what about capture groups?), but I&#39;m curious if this implementation strategy would be workable in a production-quality regex engine.</p>
</details>

                    </main>

                    
                </div></div>
  </body>
</html>
