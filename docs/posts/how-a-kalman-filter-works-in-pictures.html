<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/">Original</a>
    <h1>How a Kalman filter works, in pictures</h1>
    
    <div id="readability-page-1" class="page"><div>
			<p>I have to tell you about the Kalman filter, because what it does is pretty damn amazing.</p>
<p>Surprisingly few software engineers and scientists seem to know about it, and that makes me sad because it is such a general and powerful tool for <strong>combining information</strong> in the presence of uncertainty. At times its ability to extract accurate information seems almost magical— and if it sounds like I’m talking this up too much, then take a look at <a href="https://www.bzarg.com/p/improving-imu-attitude-estimates-with-velocity-data">this previously posted video</a> where I demonstrate a Kalman filter figuring out the <em>orientation</em> of a free-floating body by looking at its <em>velocity</em>. Totally neat!</p>

<p>You can use a Kalman filter in any place where you have <strong>uncertain information</strong> about some dynamic system, and you can make an <strong>educated guess</strong> about what the system is going to do next. Even if messy reality comes along and interferes with the clean motion you guessed about, the Kalman filter will often do a very good job of figuring out what actually happened. And it can take advantage of correlations between crazy phenomena that you maybe wouldn’t have thought to exploit!</p>
<p>Kalman filters are ideal for systems which are <strong>continuously changing</strong>. They have the <span id="more-491"></span>advantage that they are light on memory (they don’t need to keep any history other than the previous state), and they are very fast, making them well suited for real time problems and embedded systems.</p>
<p>The math for implementing the Kalman filter appears pretty scary and opaque in most places you find on Google. That’s a bad state of affairs, because the Kalman filter is actually super simple and easy to understand if you look at it in the right way. Thus it makes a great article topic, and I will attempt to illuminate it with lots of clear, pretty pictures and colors. The prerequisites are simple; all you need is a basic understanding of probability and matrices.</p>
<p>I’ll start with a loose example of the kind of thing a Kalman filter can solve, but if you want to get right to the shiny pictures and math, feel free to <a href="#mathybits">jump ahead</a>.</p>

<p>Let’s make a toy example: You’ve built a little robot that can wander around in the woods, and the robot needs to know exactly where it is so that it can navigate.</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/robot_forest-300x160.png" alt="Your little robot" width="300" height="160" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/robot_forest-300x160.png 300w, https://www.bzarg.com/wp-content/uploads/2015/08/robot_forest.png 553w" sizes="(max-width: 300px) 100vw, 300px"/></p>
<p>We’ll say our robot has a state \( \vec{x_k} \), which is just a position and a velocity:</p>
<p>\(\vec{x_k} = (\vec{p}, \vec{v})\)</p>
<p>Note that the state is just a list of numbers about the underlying configuration of your system; it could be anything. In our example it’s position and velocity, but it could be data about the amount of fluid in a tank, the temperature of a car engine, the position of a user’s finger on a touchpad, or any number of things you need to keep track of.</p>
<p>Our robot also has a GPS sensor, which is accurate to about 10 meters, which is good, but it needs to know its location more precisely than 10 meters. There are lots of gullies and cliffs in these woods, and if the robot is wrong by more than a few feet, it could fall off a cliff. So GPS by itself is not good enough.</p>
<p><a href="https://www.bzarg.com/wp-content/uploads/2015/08/robot_ohnoes.png"><img src="https://www.bzarg.com/wp-content/uploads/2015/08/robot_ohnoes-300x283.png" alt="Oh no." width="300" height="283" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/robot_ohnoes-300x283.png 300w, https://www.bzarg.com/wp-content/uploads/2015/08/robot_ohnoes.png 403w" sizes="(max-width: 300px) 100vw, 300px"/></a></p>
<p>We might also know something about how the robot moves: It knows the commands sent to the wheel motors, and its knows that if it’s headed in one direction and nothing interferes, at the next instant it will likely be further along that same direction. But of course it doesn’t know everything about its motion: It might be buffeted by the wind, the wheels might slip a little bit, or roll over bumpy terrain; so the amount the wheels have turned might not exactly represent how far the robot has actually traveled, and the prediction won’t be perfect.</p>
<p>The GPS <strong>sensor</strong> tells us something about the state, but only indirectly, and with some uncertainty or inaccuracy. Our <strong>prediction</strong> tells us something about how the robot is moving, but only indirectly, and with some uncertainty or inaccuracy.</p>
<p>But if we use all the information available to us, can we get a better answer than <strong>either estimate would give us by itself</strong>? Of course the answer is yes, and that’s what a Kalman filter is for.</p>


<p>Let’s look at the landscape we’re trying to interpret. We’ll continue with a simple state having only position and velocity. $$</p>
<p>We don’t know what the <em>actual</em> position and velocity are; there are a whole range of possible combinations of position and velocity that might be true, but some of them are more likely than others:</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_0.png" alt="gauss_0" width="310" height="325" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_0.png 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_0-287x300.png 287w" sizes="(max-width: 310px) 100vw, 310px"/></p>
<p>The Kalman filter assumes that both variables (postion and velocity, in our case) are random and <em>Gaussian distributed.</em> Each variable has a <strong>mean</strong> value \(\mu\), which is the center of the random distribution (and its most likely state), and a <strong>variance</strong> \(\sigma^2\), which is the uncertainty:</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_1.png" alt="gauss_1" width="310" height="276" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_1.png 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_1-300x267.png 300w" sizes="(max-width: 310px) 100vw, 310px"/></p>
<p>In the above picture, position and velocity are <strong>uncorrelated</strong>, which means that the state of one variable tells you nothing about what the other might be.</p>
<p>The example below shows something more interesting: Position and velocity are <strong>correlated</strong>. The likelihood of observing a particular position depends on what velocity you have:</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_3.png" alt="gauss_3" width="310" height="286" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_3.png 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_3-300x276.png 300w" sizes="(max-width: 310px) 100vw, 310px"/>This kind of situation might arise if, for example, we are estimating a new position based on an old one. If our velocity was high, we probably moved farther, so our position will be more distant. If we’re moving slowly, we didn’t get as far.</p>
<p>This kind of relationship is really important to keep track of, because it gives us <strong>more information: </strong>One measurement tells us something about what the others could be. And that’s the goal of the Kalman filter, we want to squeeze as much information from our uncertain measurements as we possibly can!</p>
<p>This correlation is captured by something called a <a href="https://en.wikipedia.org/wiki/Covariance_matrix">covariance matrix</a>. In short, each element of the matrix \(\Sigma_{ij}\) is the degree of correlation between the <em>ith</em> state variable and the <em>jth</em> state variable. (You might be able to guess that the covariance matrix is <a href="https://en.wikipedia.org/wiki/Symmetric_matrix">symmetric</a>, which means that it doesn’t matter if you swap <em>i</em> and <em>j</em>). Covariance matrices are often labelled “\(\mathbf{\Sigma}\)”, so we call their elements “\(\Sigma_{ij}\)”.</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_2.png" alt="gauss_2" width="310" height="286" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_2.png 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_2-300x276.png 300w" sizes="(max-width: 310px) 100vw, 310px"/></p>

<p>We’re modeling our knowledge about the state as a Gaussian blob, so we need two pieces of information at time \(k\): We’ll call our best estimate \(\mathbf{\hat{x}_k}\) (the mean, elsewhere named \(\mu\) ), and its covariance matrix \(\mathbf{P_k}\). $$</p>
<p>(Of course we are using only position and velocity here, but it’s useful to remember that the state can contain any number of variables, and represent anything you want).</p>
<p>Next, we need some way to look at the <span><strong>current state</strong></span> (at time <span><strong>k-1</strong></span>) and <strong>predict the <span>next state</span></strong> at time <span><strong>k</strong></span>. Remember, we don’t know which state is the “real” one, but our prediction function doesn’t care. It just works on <em>all of them</em>, and gives us a new distribution:</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_7.jpg" alt="gauss_7" width="310" height="286" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_7.jpg 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_7-300x276.jpg 300w" sizes="(max-width: 310px) 100vw, 310px"/>We can represent this prediction step with a matrix, \(\mathbf{F_k}\):</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_8.jpg" alt="gauss_8" width="310" height="286" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_8.jpg 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_8-300x276.jpg 300w" sizes="(max-width: 310px) 100vw, 310px"/>It takes <em>every point</em> in our original estimate and moves it to a new predicted location, which is where the system would move if that original estimate was the right one.</p>
<p>Let’s apply this. How would we use a matrix to predict the position and velocity at the next moment in the future? We’ll use a really basic kinematic formula:$$</p>
<p>We now have a <strong>prediction matrix</strong> which gives us our next state, but we still don’t know how to update the covariance matrix.</p>
<p>This is where we need another formula. If we multiply every point in a distribution by a matrix \(\color{firebrick}{\mathbf{A}}\), then what happens to its covariance matrix \(\Sigma\)?</p>
<p>Well, it’s easy. I’ll just give you the identity:$$</p>
<p>So combining \(\eqref{covident}\) with equation \(\eqref{statevars}\):$$</p>
<h2>External influence</h2>
<p>We haven’t captured everything, though. There might be some changes that <strong>aren’t related to the state</strong> itself— the outside world could be affecting the system.</p>
<p>For example, if the state models the motion of a train, the train operator might push on the throttle, causing the train to accelerate. Similarly, in our robot example, the navigation software might issue a command to turn the wheels or stop. If we know this additional information about what’s going on in the world, we could stuff it into a vector called \(\color{darkorange}{\vec{\mathbf{u}_k}}\), do something with it, and add it to our prediction as a correction.</p>
<p>Let’s say we know the expected acceleration \(\color{darkorange}{a}\) due to the throttle setting or control commands. From basic kinematics we get: $$</p>
<p>\(\mathbf{B}_k\) is called the <strong>control matrix</strong> and \(\color{darkorange}{\vec{\mathbf{u}_k}}\) the <strong>control vector.</strong> (For very simple systems with no external influence, you could omit these).</p>
<p>Let’s add one more detail. What happens if our prediction is not a 100% accurate model of what’s actually going on?</p>
<h2>External uncertainty</h2>
<p>Everything is fine if the state evolves based on its own properties. Everything is <em>still </em>fine if the state evolves based on external forces, so long as we know what those external forces are.</p>
<p>But what about forces that we <em>don’t </em>know about? If we’re tracking a quadcopter, for example, it could be buffeted around by wind. If we’re tracking a wheeled robot, the wheels could slip, or bumps on the ground could slow it down. We can’t keep track of these things, and if any of this happens, our prediction could be off because we didn’t account for those extra forces.</p>
<p>We can model the uncertainty associated with the “world” (i.e. things we aren’t keeping track of) by adding some new uncertainty after every prediction step:</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_9.jpg" alt="gauss_9" width="310" height="286" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_9.jpg 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_9-300x276.jpg 300w" sizes="(max-width: 310px) 100vw, 310px"/></p>
<p>Every state in our original estimate could have moved to a <em>range</em> of states. Because we like Gaussian blobs so much, we’ll say that each point in \(\color{royalblue}{\mathbf{\hat{x}}_{k-1}}\) is moved to somewhere inside a Gaussian blob with covariance \(\color{mediumaquamarine}{\mathbf{Q}_k}\). Another way to say this is that we are treating the untracked influences as <strong>noise</strong> with covariance \(\color{mediumaquamarine}{\mathbf{Q}_k}\).</p>
<p><a href="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_10a.jpg"><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_10a.jpg" alt="gauss_10a" width="310" height="310"/></a>This produces a new Gaussian blob, with a different covariance (but the same mean):</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_10b.jpg" alt="gauss_10b" width="310" height="310" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_10b.jpg 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_10b-150x150.jpg 150w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_10b-300x300.jpg 300w" sizes="(max-width: 310px) 100vw, 310px"/></p>
<p>We get the expanded covariance by simply <strong>adding</strong> \({\color{mediumaquamarine}{\mathbf{Q}_k}}\), giving our complete expression for the <strong>prediction step</strong>: $$</p>
<p>In other words, the <span><strong>new best estimate</strong></span> is a <strong>prediction</strong> made from<span><strong> previous best estimate</strong></span>, plus a <strong>correction</strong> for <span><strong>known external influences</strong></span>.</p>
<p>And the <span><strong>new uncertainty</strong></span> is <strong>predicted</strong> from the <span><strong>old uncertainty</strong></span>, with some <span><strong>additional uncertainty from the environment</strong></span>.</p>
<p>All right, so that’s easy enough. We have a fuzzy estimate of where our system might be, given by \(\color{deeppink}{\mathbf{\hat{x}}_k}\) and \(\color{deeppink}{\mathbf{P}_k}\). What happens when we get some data from our sensors?</p>

<p>We might have several sensors which give us information about the state of our system. For the time being it doesn’t matter what they measure; perhaps one reads position and the other reads velocity. Each sensor tells us something <strong>indirect</strong> about the state— in other words, the sensors operate on a state and produce a set of <strong>readings</strong>.</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_12.jpg" alt="gauss_12" width="621" height="286" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_12.jpg 1242w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_12-300x138.jpg 300w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_12-1024x472.jpg 1024w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_12-624x287.jpg 624w" sizes="(max-width: 621px) 100vw, 621px"/>Notice that the units and scale of the reading might not be the same as the units and scale of the state we’re keeping track of. You might be able to guess where this is going: We’ll model the sensors with a matrix, \(\mathbf{H}_k\).</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_13.jpg" alt="gauss_12" width="621" height="286"/></p>
<p>We can figure out the distribution of sensor readings we’d expect to see in the usual way: $$</p>
<p>One thing that Kalman filters are great for is dealing with <em>sensor noise</em>. In other words, our sensors are at least somewhat unreliable, and every state in our original estimate might result in a <em>range</em> of sensor readings. <img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_14.jpg" alt="gauss_12" width="621" height="286"/></p>
<p>From each reading we observe, we might guess that our system was in a particular state. But because there is uncertainty, <strong>some states are more likely than others</strong> to have have produced the reading we saw:<img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_11.jpg" alt="gauss_11" width="310" height="286" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_11.jpg 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_11-300x276.jpg 300w" sizes="(max-width: 310px) 100vw, 310px"/></p>
<p>We’ll call the <strong>covariance</strong> of this uncertainty (i.e. of the sensor noise) \(\color{mediumaquamarine}{\mathbf{R}_k}\). The distribution has a <strong>mean</strong> equal to the reading we observed, which we’ll call \(\color{yellowgreen}{\vec{\mathbf{z}_k}}\).</p>
<p>So now we have two Gaussian blobs: One surrounding the mean of our transformed prediction, and one surrounding the actual sensor reading we got.</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_4.jpg" alt="gauss_4" width="310" height="286" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_4.jpg 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_4-300x276.jpg 300w" sizes="(max-width: 310px) 100vw, 310px"/></p>
<p>We must try to reconcile our guess about the readings we’d see based on the <strong>predicted state</strong> (<span><strong>pink</strong></span>) with a <em>different</em> guess based on our <strong>sensor readings</strong> (<span><strong>green</strong></span>) that we actually observed.</p>
<p>So what’s our new most likely state? For any possible reading \((z_1,z_2)\), we have two associated probabilities: <span>(1)</span> The probability that our sensor reading \(\color{yellowgreen}{\vec{\mathbf{z}_k}}\) is a (mis-)measurement of \((z_1,z_2)\), and <span>(2)</span> the probability that our previous estimate thinks \((z_1,z_2)\) is the reading we should see.</p>
<p>If we have two probabilities and we want to know the chance that <em>both </em>are true, we just multiply them together. So, we take the two Gaussian blobs and multiply them:</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_6a.png" alt="gauss_5" width="310" height="286"/></p>
<p>What we’re left with is the <strong>overlap</strong>, the region where <em>both</em> blobs are bright/likely. And it’s a lot more precise than either of our previous estimates. The mean of this distribution is the configuration for which <strong>both estimates are most likely</strong>, and is therefore the <strong>best guess</strong> of the true configuration given all the information we have.</p>
<p>Hmm. This looks like another Gaussian blob.</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_6.png" alt="gauss_6" width="310" height="286" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_6.png 621w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_6-300x276.png 300w" sizes="(max-width: 310px) 100vw, 310px"/></p>
<p>As it turns out, when you multiply two Gaussian blobs with separate means and covariance matrices, you get a <em>new</em> Gaussian blob with its <strong>own</strong> mean and covariance matrix! Maybe you can see where this is going: There’s got to be a formula to get those new parameters from the old ones!</p>

<p>Let’s find that formula. It’s easiest to look at this first in <strong>one dimension</strong>. A 1D Gaussian bell curve with variance \(\sigma^2\) and mean \(\mu\) is defined as: $$</p>
<p>We want to know what happens when you multiply two Gaussian curves together. The blue curve below represents the (unnormalized) intersection of the two Gaussian populations:</p>
<p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_joint.png" alt="Multiplying Gaussians" width="589" height="381" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_joint.png 589w, https://www.bzarg.com/wp-content/uploads/2015/08/gauss_joint-300x194.png 300w" sizes="(max-width: 589px) 100vw, 589px"/></p>
<p>$$\begin{equation} \label{gaussequiv}</p>
<p>You can substitute equation \(\eqref{gaussformula}\) into equation \(\eqref{gaussequiv}\) and do some algebra (being careful to renormalize, so that the total probability is 1) to obtain: $$</p>
<p>We can simplify by factoring out a little piece and calling it \(\color{purple}{\mathbf{k}}\): $$</p>
<p>Take note of how you can take your previous estimate and <strong>add something</strong> to make a new estimate. And look at how simple that formula is!</p>
<p>But what about a matrix version? Well, let’s just re-write equations \(\eqref{gainformula}\) and \(\eqref{update}\) in matrix form. If \(\Sigma\) is the covariance matrix of a Gaussian blob, and \(\vec{\mu}\) its mean along each axis, then: $$</p>
<p>\(\color{purple}{\mathbf{K}}\) is a matrix called the <strong>Kalman gain</strong>, and we’ll use it in just a moment.</p>
<p>Easy! We’re almost finished!</p>

<p>We have two distributions: The predicted measurement with \( (\color{fuchsia}{\mu_0}, \color{deeppink}{\Sigma_0}) = (\color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k}, \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T}) \), and the observed measurement with \( (\color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\Sigma_1}) = (\color{yellowgreen}{\vec{\mathbf{z}_k}}, \color{mediumaquamarine}{\mathbf{R}_k})\). We can just plug these into equation \(\eqref{matrixupdate}\) to find their overlap: $$</p>
<p>And that’s it! \(\color{royalblue}{\mathbf{\hat{x}}_k’}\) is our new best estimate, and we can go on and feed it (along with \( \color{royalblue}{\mathbf{P}_k’} \) ) back into another round of <strong>predict </strong>or <strong>update</strong> as many times as we like.</p>
<p><a href="https://www.bzarg.com/wp-content/uploads/2015/08/kalflow.png"><img src="https://www.bzarg.com/wp-content/uploads/2015/08/kalflow.png" alt="Kalman filter information flow diagram" width="850" height="1100" srcset="https://www.bzarg.com/wp-content/uploads/2015/08/kalflow.png 850w, https://www.bzarg.com/wp-content/uploads/2015/08/kalflow-232x300.png 232w, https://www.bzarg.com/wp-content/uploads/2015/08/kalflow-791x1024.png 791w, https://www.bzarg.com/wp-content/uploads/2015/08/kalflow-624x808.png 624w" sizes="(max-width: 850px) 100vw, 850px"/></a></p>

<p>Of all the math above, all you need to implement are equations \(\eqref{kalpredictfull}, \eqref{kalupdatefull}\), and \(\eqref{kalgainfull}\). (Or if you forget those, you could re-derive everything from equations \(\eqref{covident}\) and \(\eqref{matrixupdate}\).)</p>
<p>This will allow you to model any linear system accurately. For nonlinear systems, we use the <strong>extended Kalman filter</strong>, which works by simply linearizing the predictions and measurements about their mean. (I may do a second write-up on the EKF in the future).</p>
<p>If I’ve done my job well, hopefully someone else out there will realize how cool these things are and come up with an unexpected new place to put them into action.</p>
<hr/>

<p>Some credit and referral should be given to <a href="http://www.cl.cam.ac.uk/~rmf25/papers/Understanding%20the%20Basis%20of%20the%20Kalman%20Filter.pdf">this fine document</a>, which uses a similar approach involving overlapping Gaussians. More in-depth derivations can be found there, for the curious.</p>

<!-- Simple Share Buttons Adder (7.6.21) simplesharebuttons.com -->					</div></div>
  </body>
</html>
