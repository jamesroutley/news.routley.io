<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gilesthomas.com/2025/03/llm-from-scratch-10-dropout">Original</a>
    <h1>Writing an LLM from scratch, part 10 – dropout</h1>
    
    <div id="readability-page-1" class="page"><div>
            

            <div data-current-dropdown="" hx-on="click:
                    if (event.target.closest(&#39;.dropdown&#39;)) {
                        let targetId = event.target.closest(&#39;.dropdown&#39;).dataset.target;
                        this.dataset.currentDropdown = (this.dataset.currentDropdown === targetId) ? &#39;&#39; : targetId;
                        event.stopPropagation();
                    }">

                

                <div>
                    
                        <p>
                            Archives <span></span>
                        </p>
                    
                    
                        <p>
                            Categories <span></span>
                        </p>
                    
                    <p>
                        Blogroll <span></span>
                    </p>
                </div>

                
                
                
            </div>

            

    

    

    <p>I&#39;m still chugging through chapter 3 of
<a href="https://sebastianraschka.com/">Sebastian Raschka</a>&#39;s
&#34;<a href="https://www.manning.com/books/build-a-large-language-model-from-scratch">Build a Large Language Model (from Scratch)</a>&#34;.
Last time I covered <a href="https://www.gilesthomas.com/2025/03/llm-from-scratch-9-causal-attention">causal attention</a>,
which was pretty simple when it came down to it.  Today it&#39;s another
quick and easy one -- dropout.</p>

<p>The concept is pretty simple: you want knowledge to be spread broadly across your
model, not concentrated in a few places.  Doing that means that all
of your parameters are pulling their weight, and you don&#39;t have a bunch of them
sitting there doing nothing.</p>

<p>So, while you&#39;re training (but, importantly, not during inference)
you randomly ignore certain parts -- neurons, weights, whatever -- each time
around, so that their &#34;knowledge&#34; gets spread over to other bits.</p>

<p>Simple enough!  But the implementation is a little more fun, and there were a
couple of oddities that
I needed to think through.</p>


    
        <p>Code-wise, it&#39;s really easy: PyTorch
provides a useful <code>torch.nn.Dropout</code> class that you create with the dropout rate
that you want -- 0.5 in the example in the book -- and if you call it as a function on a
matrix, it will zero out that proportion of the values.  Raschka mentions
that the dropout of 0.5 -- that is, half of the attention scores
are ignored -- is an example, and says that 0.1 - 0.2 would be more typical in a real-world
training run.  That seemed surprisingly high to me, but Claude agrees:</p>

<blockquote>
  <p>For training large language models (LLMs), a typical dropout rate for attention
  scores usually falls in the range of 10-15%.</p>
</blockquote>

<p>So there you go!  If the LLMs agree, it must be true...</p>

<p>So how do you use it?  With a normal neural network, you might ignore
a subset of your neurons during one batch of your training run, then a different
subset the next time.  So you&#39;d
call the dropout function on the activations from each layer, zeroing out some at random
so that they don&#39;t contribute to the &#34;downstream&#34;
calculations.  (As I understand it, this means that they are also not adjusted during
back-propagation -- if nothing else, it would be terribly <em>unfair</em> to the poor ignored
neurons to have their weights changed when they didn&#39;t contribute to the error.)</p>

<p>For LLMs like the one we&#39;re working on in this book, we can either run the dropout
function on the attention weights
or &#34;after applying the attention weights to the value vectors&#34;.  I was a bit confused by
the latter, but after a bit of research (I asked Claude, ChatGPT and Grok 3 again ;-)
it turns out that it just means that you run dropout on the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>Z</mi></mrow></math> matrix -- the one
that has one row per input token, each row being that token&#39;s context vector -- with
random elements in the context vector being zeroed out for each token.</p>

<p>The book uses the example of doing dropout on the attention weights, and the code
was simple enough.  But one thing that did confuse me was the way it rebalances the matrix
post-dropout.  Let&#39;s start with this causal attention weight matrix:</p>

<table>
<thead>
<tr>
  <th>Token</th>
  <th>A(&#34;The&#34;)</th>
  <th>A(&#34;fat&#34;)</th>
  <th>A(&#34;cat&#34;)</th>
  <th>A(&#34;sat&#34;)</th>
  <th>A(&#34;on&#34;)</th>
  <th>A(&#34;the&#34;)</th>
  <th>A(&#34;mat&#34;)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>The</td>
  <td>1.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>fat</td>
  <td>0.4633</td>
  <td>0.5367</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>cat</td>
  <td>0.3221</td>
  <td>0.3324</td>
  <td>0.3454</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>sat</td>
  <td>0.2355</td>
  <td>0.2334</td>
  <td>0.2613</td>
  <td>0.2698</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>on</td>
  <td>0.1893</td>
  <td>0.1910</td>
  <td>0.1974</td>
  <td>0.2031</td>
  <td>0.2192</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>the</td>
  <td>0.1613</td>
  <td>0.1613</td>
  <td>0.1613</td>
  <td>0.1613</td>
  <td>0.1630</td>
  <td>0.1918</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>mat</td>
  <td>0.1344</td>
  <td>0.1344</td>
  <td>0.1369</td>
  <td>0.1489</td>
  <td>0.1463</td>
  <td>0.1440</td>
  <td>0.1551</td>
</tr>
</tbody>
</table>

<p>After a 50% dropout it might look like this:</p>

<table>
<thead>
<tr>
  <th>Token</th>
  <th>A(&#34;The&#34;)</th>
  <th>A(&#34;fat&#34;)</th>
  <th>A(&#34;cat&#34;)</th>
  <th>A(&#34;sat&#34;)</th>
  <th>A(&#34;on&#34;)</th>
  <th>A(&#34;the&#34;)</th>
  <th>A(&#34;mat&#34;)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>The</td>
  <td>1.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>fat</td>
  <td>0.4633</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>cat</td>
  <td>0.0000</td>
  <td>0.3324</td>
  <td>0.3454</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>sat</td>
  <td>0.2355</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.2698</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>on</td>
  <td>0.0000</td>
  <td>0.1910</td>
  <td>0.0000</td>
  <td>0.2031</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>the</td>
  <td>0.0000</td>
  <td>0.1613</td>
  <td>0.0000</td>
  <td>0.1613</td>
  <td>0.0000</td>
  <td>0.1918</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>mat</td>
  <td>0.1344</td>
  <td>0.1344</td>
  <td>0.0000</td>
  <td>0.1489</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.1551</td>
</tr>
</tbody>
</table>

<p>So far we&#39;ve treated it as super-important that every row sums up to 1.  But the <code>Dropout</code>
class doesn&#39;t know anything about that -- indeed, it knows nothing about what the
structure of the matrix is.  It just zeros out random values.</p>

<p>But after that, it has to do <em>something</em> to rebalance the matrix -- so it divides what&#39;s left
by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>1</mn><mo>−</mo><mi>d</mi></mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi></mrow></math> is the dropout value.  That&#39;s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>1</mn><mo>−</mo><mn>0.5</mn><mo>=</mo><mn>0.5</mn></mrow></math> in this
case, so that means that the remaining numbers are all
doubled, like this:</p>

<table>
<thead>
<tr>
  <th>Token</th>
  <th>A(&#34;The&#34;)</th>
  <th>A(&#34;fat&#34;)</th>
  <th>A(&#34;cat&#34;)</th>
  <th>A(&#34;sat&#34;)</th>
  <th>A(&#34;on&#34;)</th>
  <th>A(&#34;the&#34;)</th>
  <th>A(&#34;mat&#34;)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>The</td>
  <td>2.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>fat</td>
  <td>0.9266</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>cat</td>
  <td>0.0000</td>
  <td>0.6648</td>
  <td>0.6908</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>sat</td>
  <td>0.4710</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.5396</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>on</td>
  <td>0.0000</td>
  <td>0.3820</td>
  <td>0.0000</td>
  <td>0.4062</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>the</td>
  <td>0.0000</td>
  <td>0.3226</td>
  <td>0.0000</td>
  <td>0.3226</td>
  <td>0.0000</td>
  <td>0.3836</td>
  <td>0.0000</td>
</tr>
<tr>
  <td>mat</td>
  <td>0.2688</td>
  <td>0.2688</td>
  <td>0.0000</td>
  <td>0.2978</td>
  <td>0.0000</td>
  <td>0.0000</td>
  <td>0.3102</td>
</tr>
</tbody>
</table>

<p>The first row is 2 and none of the others sum to 1 either!  That scaling is exactly what
the <code>Dropout</code> class is meant to do, but it definitely feels like we must be using it wrong
in the light of what we&#39;ve been doing so far.</p>

<p>That surprised me enough that I reread the section and checked
the code in the next section to make sure that the dropout was not meant to be applied
to the attention <em>scores</em>, pre-softmax, rather than the attention weights, but it&#39;s
definitely not.  I don&#39;t have a strong intuition about why that might be, or why it
might not matter (apart from the fact that if you were working with the attention
scores you&#39;d need to replace the dropped-out values with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>−</mo><mo>∞</mo></mrow></math> rather
than zero, and the <code>Dropout</code> class
<a href="https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html">doesn&#39;t seem to support that</a>).</p>

<blockquote>
  <p>While finishing off this post, I ran it past a few LLMs to check for accuracy.
  ChatGPT tells me that in real-world scenarios, people often <em>do</em> run dropout on
  the attention scores (using something other than PyTorch&#39;s <code>Dropout</code> so that they
  can put in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>−</mo><mo>∞</mo></mrow></math> rather than zero) and then run softmax.  That&#39;s interesting!
  Either it&#39;s wrong on that (though it did seem very certain, and other LLMs agreed
  when queried) or this is more of a pedagogical example for the sake of the book.
  Another one for the &#34;further investigation needed&#34; list.</p>
</blockquote>

<p>But I guess that in practice, with a 10% dropout rate, it probably doesn&#39;t matter
too much.  The attention weights for the first &#34;The&#34; summing to 2 in the example
is obviously crazy, but with 10% we&#39;d be dividing by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>1</mn><mo>−</mo><mn>0.1</mn><mo>=</mo><mn>0.9</mn></mrow></math>, and a sum
of 1.111 would be much less obviously weird.</p>

<p>So that&#39;s it for dropout.  I was originally
going to combine this one with the next section, which brings everything together to
show a full causal attention class with dropout in PyTorch -- but the book glosses
over something for that, something that I want to dig into in a little more depth
than the book does -- how do we work with the third-order tensors that are required
to handle batches in an LLM?</p>

<p>All of the maths I&#39;ve blogged about so far has topped
out at second-order tensors -- matrices -- and so this is a big jump.  I don&#39;t
think there is any super-heavy intellectual lifting to do to get past it, but at
the same time it feels like something worth -- for me -- spending a little more
time on than I could in a post that covered dropout too.</p>

<p>So: more soon :-)</p>

    

    
        
    

    



            
        </div></div>
  </body>
</html>
