<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20230904-00/?p=108704">Original</a>
    <h1>What happens when you shift a register by more than the register size?</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            September 4th, 2023</p><!-- .entry-meta -->
        <p>Just for fun, let’s compare what happens on different processor architectures when you shift a register by more than the register size.</p>
<table>
<tbody>
<tr>
<th>Processor</th>
<th>Register size</th>
<th>Behavior</th>
</tr>
<tr>
<td>8086</td>
<td>Any</td>
<td>mod 256 (Note 1)</td>
</tr>
<tr>
<td>Alpha AXP</td>
<td>64</td>
<td>mod  64</td>
</tr>
<tr>
<td>80386</td>
<td>Any</td>
<td>mod  32</td>
</tr>
<tr>
<td rowspan="2">x86-64</td>
<td>≤ 32</td>
<td>mod  32</td>
</tr>
<tr>
<td>64</td>
<td>mod  64</td>
</tr>
<tr>
<td>Intel ia64</td>
<td>64</td>
<td>full value</td>
</tr>
<tr>
<td rowspan="2">MIPS</td>
<td>32</td>
<td>mod  32</td>
</tr>
<tr>
<td>64</td>
<td>mod  64</td>
</tr>
<tr>
<td rowspan="2">PowerPC</td>
<td>32</td>
<td>mod  64</td>
</tr>
<tr>
<td>64</td>
<td>mod 128</td>
</tr>
<tr>
<td>SH-4</td>
<td>32</td>
<td>mod  32 + sign (Note 2)</td>
</tr>
<tr>
<td>ARM (Thumb-2)</td>
<td>Any</td>
<td>mod 256</td>
</tr>
<tr>
<td rowspan="2">ARM (AArch 64)</td>
<td>32</td>
<td>mod  32</td>
</tr>
<tr>
<td>64</td>
<td>mod  64</td>
</tr>
<tr>
<td>68000</td>
<td>32</td>
<td>mod  64</td>
</tr>
<tr>
<td>SPARC</td>
<td>32</td>
<td>mod  32</td>
</tr>
<tr>
<td rowspan="2">RISC-V</td>
<td>32</td>
<td>mod  32</td>
</tr>
<tr>
<td>64</td>
<td>mod  64</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol>
<li>On the 8086, the shift amount is given by the 8-bit <code>cl</code> register. The running time of the instruction is proportional to the number of bits shifted, and the processor does not optimize shifts that are larger than the register size, so if you ask to shift by 255 places, it will run a loop 255 times.</li>
<li>On the SH-4, the sign of the shift amount controls the direction of the shift, and the lower 5 bits control how far to shift.</li>
</ol>
<p>I’ve added some architectures that are of historic or current interest. Do not assume that the presence of an architecture on this list implies that I will someday cover it, and don’t assume that omission of your favorite architecture means that I never will.</p>
<p>From the above table, you can sort of come up with a taxonomy of shifts.</p>
<table>
<tbody>
<tr>
<th> </th>
<th>Unsigned</th>
<th>Signed</th>
</tr>
<tr>
<th>mod register size</th>
<td>Alpha AXP, x86-32, x86-64,</td>
<td>SH-4</td>
</tr>
<tr>
<th>mod 2 × register size</th>
<td>PowerPC, 68000</td>
<td> </td>
</tr>
<tr>
<th>mod 256</th>
<td>8086, Thumb-2</td>
<td> </td>
</tr>
<tr>
<th>full value</th>
<td>ia64</td>
<td> </td>
</tr>
</tbody>
</table>
<p>For x86-32, I’m kind of cheating and ignoring the registers smaller than 32 bits.</p>
<p><b>Bonus chatter</b>: The wide variety of behavior when shifting by more than the register size is one of the reasons why the C and C++ languages leave undefined what happens when you shift by more than the bit width of the shifted type.</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
