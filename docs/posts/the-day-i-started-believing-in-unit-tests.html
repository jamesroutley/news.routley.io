<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mental-reverb.com/blog.php?id=42">Original</a>
    <h1>The day I started believing in unit tests</h1>
    
    <div id="readability-page-1" class="page"><div><p>
Right after getting my degree, I was lucky to be hired into a small but decent R&amp;D department as an embedded software engineer. My first task was to create a Unit Test project and have it run in our build pipeline after compilation. I was not particularly excited about this task, it seemed like busywork to me. I believed that Unit Tests are largely worthless throwaway code. They probably didn&#39;t want me to immediately dive into production code. Fair enough, I thought. I&#39;m the newcomer and this is something that is requested by engineers who are way more experienced than I am. So for now, I should just go along with it, even if I believe it&#39;s a waste of time.
</p>

<p>
So, ahead I went. I implemented the test suite and some basic tests, including some that I ported from our old, deprecated test framework to googletest. The test was started by our build pipeline after compilation, it actually transferred the test binary to a physical device which was (and still is) situated in our office and ran the QNX operating system to perform on-target tests. This was necessary because the code used many QNX primitives and needed to be tested on that operating system. So, the test was something between a Unit Test and an Integration Test. The mechanism worked well and it ran multiple times per day. Since the test coverage was quite small and nobody ever touched that code anyway, it always succeeded - another reason why I thought it&#39;s a waste of time. Also, it was rare for new tests to be added. It&#39;s very hard to write Unit Tests for embedded firmware and hardware abstractions because the very thing you want to test is the interaction with the hardware, which is precisely what you can&#39;t do in pure code. Because the test ran automatically and always succeeded, we all soon forgot about it and moved on to other things.
</p>

<p>
Fast forward about a year. The test ran hundreds if not thousands of times successfully. What a waste of time... But then, one day, we started observing test failures. Not many, maybe three over the course of a few weeks. The test actually crashed with a Segmentation Fault, so it was clear that it was a severe error. Interestingly, none of the code under test had actually changed. Well, that&#39;s definitely something we had to investigate! I spare you the details of the search for the error, but eventually, I was able to reproduce the problem while a debugger was attached, so the entire context of the problem was handed to me on a silver platter.
</p>

<p>
The problem had to do with how our threading abstraction, which worked with inheritance, was used in the test framework. There is a base class that starts the thread with a virtual function and the user of the abstraction is supposed to <code>override</code> that function, kind of like this:
</p>

<p><code>/* Library code: */
class Thread {
	public:
		Thread() { /* ... */ }
		virtual ~Thread() { stop(); }
		void stop() { /* join the thread if running */ }
	protected:
		virtual void singlepassThreadWork() = 0;
};

/* User code: */
class MyThread : public Thread {
	protected:
		void singlepassThreadWork() override {
			/* do stuff with foobar */
		}
	private:
		std::vector&lt;int&gt; foobar;
};
</code></p><p>

Now, what happens when <code>MyThread::singlepassThreadWork()</code> uses a member variable of <code>MyThread</code> like <code>foobar</code> and we <code>delete</code> the <code>MyThread</code> object while the thread is still running? The destruction sequence is such that <code>MyThread</code> is deleted first and <i>after that</i>, the destructor of its parent object <code>Thread</code> runs and the thread is joined. Thus, there is a race condition: We risk accessing the vector <code>foobar</code> in <code>singlepassThreadWork()</code> after it was already deleted. We can fix the user code by explicitly stopping the thread in its destructor:

</p><p><code>/* User code: */
class MyThread : public Thread {
	public:
		~MyThread() { stop() }
	protected:
		void singlepassThreadWork() override {
			/* do stuff with foobar */
		}
	private:
		std::vector&lt;int&gt; foobar;
};
</code></p>

<p>
My disappointment was immeasurable. The bug was in the test framework itself, not in the code under test. Unit Tests really are worthless and this is a waste of time... Right? But then I had to think of a <a href="https://multicians.org/thvv/comix.html">comic</a> that I had found on the internet and I had actually printed out this comic and put it on the wall in our office:
</p>

<p>
<img src="https://mental-reverb.com/img/believeinunittest_comix-1.gif"/>
</p>

<p>
Even though this comic is older than I am, from a long bygone hacker era, it resonated with me a lot because the wisdom within it still holds true. Whenever you encounter a bug, ask yourself the following three questions:
</p>

<ol>
	<li>Have I made this error anywhere else?</li>
	<li>What happens when I fix the bug?</li>
	<li>How can I change my ways to make this bug impossible?</li>
</ol>

<p>
It seems so simple, but it&#39;s a really powerful methodology to prevent further errors and raise code quality. With this comic in mind, I asked myself whether this error existed anywhere else in the code - and boy did I find a boatload of instances of this race condition. It was <i>everywhere</i>. A co-worker and I combed through the entire code base and fixed this type of error in a few large commits, adding a <code>stop()</code> call in the destructor of the class that was the lowest in the inheritance hierarchy for each thread. Furthermore, we made all the developers aware of this pitfall and kept an eye on new code that could be affected. We never observed this bug again in the years since. In addition, we were now aware that this inheritance-based abstraction is defective by design, since most of its uses suffer from a race condition that has to be mitigated manually by the programmer. Designs of new abstractions would not be subject to such pitfalls as we encouraged developers to use composition and dependency injection over inheritance, which raised the overall code quality significantly.
</p>

<p>
We never found out why the race condition suddenly started causing crashes after a year&#39;s worth of successful runs. As mentioned, none of the involved code was changed. As far as I know, the operating system on the test system was not modified during that time period. The crashes must have been caused by subtle differences in how the threads were scheduled. Perhaps the addition of unrelated tests made the Unit Test binary larger and caused side-effects regarding CPU caches and timings? We&#39;ll never know.
</p>

<p>
The day I found this race condition thanks to Unit Tests was the day I truly started to believe in their value. I kept expanding the test project and even achieved 100% test coverage of a crucial library we depended on, which later prevented disaster when a code modification introduced a subtle but critical bug that was caught by the test suite. The effort spent on Unit Tests is worth it.
</p>

<p>
This event also taught me not to reject concepts and development methodologies based on half-knowledge and prejudice. When in doubt, just try it. What&#39;s the worst that could happen? You wasted a bit of time. On the other hand, the potential upside is that you added a useful tool to your toolbox for the rest of your life.
</p>
</div></div>
  </body>
</html>
