<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hacks.mozilla.org/2022/02/retrospective-and-technical-details-on-the-recent-firefox-outage/">Original</a>
    <h1>Retrospective and technical details on the recent Firefox outage</h1>
    
    <div id="readability-page-1" class="page"><article role="article">
    <p>On January 13th 2022, Firefox became unusable for close to two hours for users worldwide. This incident interrupted many people’s workflow. This post highlights the complex series of events and circumstances that, together, triggered a bug deep in the networking code of Firefox.<span id="more-47574"></span></p>
<h2>What Happened?</h2>
<p>Firefox has a number of servers and related infrastructure that handle several internal services. These include updates, telemetry, certificate management, crash reporting and other similar functionality. This infrastructure is hosted by different cloud service providers that use load balancers to distribute the load evenly across servers. For those services hosted on Google Cloud Platform (GCP) these load balancers have settings related to the HTTP protocol they should advertise and one of these settings is HTTP/3 support with three states: “Enabled”, “Disabled” or “Automatic (default)”. Our load balancers were set to the “Automatic (default)” setting and on January 13, 2022 at 07:28 UTC, GCP deployed an unannounced change to make HTTP/3 the default. As Firefox uses HTTP/3 when supported, from that point forward, some connections that Firefox makes to the services infrastructure would use HTTP/3 instead of the previously used HTTP/2 protocol.<a id="footnote1">¹</a></p>
<p>Shortly after, we noticed a spike in crashes being reported through our crash reporter and also received several reports from inside and outside of Mozilla describing a hang of the browser.</p>
<div id="attachment_47575"><p><img aria-describedby="caption-attachment-47575" loading="lazy" src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2022/01/crashes-foxstuck2.png" alt="A graph showing the curve of unprocessed crash reports quickly growing." width="3490" height="1612" srcset="https://hacks.mozilla.org/files/2022/01/crashes-foxstuck2.png 3490w, https://hacks.mozilla.org/files/2022/01/crashes-foxstuck2-250x115.png 250w, https://hacks.mozilla.org/files/2022/01/crashes-foxstuck2-500x231.png 500w, https://hacks.mozilla.org/files/2022/01/crashes-foxstuck2-768x355.png 768w, https://hacks.mozilla.org/files/2022/01/crashes-foxstuck2-1536x709.png 1536w, https://hacks.mozilla.org/files/2022/01/crashes-foxstuck2-2048x946.png 2048w" sizes="(max-width: 3490px) 100vw, 3490px"/></p><p id="caption-attachment-47575"><small> Backlog of pending crash reports building up and reaching close to 300K unprocessed reports.</small></p></div>
<p>As part of the incident response process, we quickly discovered that the client was hanging inside a network request to one of the Firefox internal services. However, at this point we neither had an explanation for why this would trigger just now, nor what the scope of the problem was. We continued to look for the “trigger” — some change that must have occurred to start the problem. We found that we had not shipped updates or configuration changes that could have caused this problem. At the same time, we were keeping in mind that HTTP/3 had been enabled since Firefox 88 and was actively used by some popular websites.</p>
<p>Although we couldn’t see it, we suspected that there had been some kind of “invisible” change rolled out by one of our cloud providers that somehow modified load balancer behavior. On closer inspection, none of our settings were changed. We then discovered through logs that for some reason, the load balancers for our Telemetry service were serving HTTP/3 connections while they hadn’t done that before. We disabled HTTP/3 explicitly on GCP at 09:12 UTC. This unblocked our users, but we were not yet certain about the root cause and without knowing that, it was impossible for us to tell if this would affect additional HTTP/3 connections.</p>
<p><small><a href="#footnote1">¹</a> <i>Some highly critical services such as updates use a special <code>beConservative</code> flag that prevents the use of any experimental technology for their connections (e.g. HTTP/3).</i></small></p>
<h2>A Special Mix of Ingredients</h2>
<p>It quickly became clear to us that there must be some combination of special circumstances for the hang to occur. We performed a number of tests with various tools and remote services and were not able to reproduce the problem, not even with a regular connection to the Telemetry staging server (a server only used for testing deployments, which we had left in its original configuration for testing purposes). With Firefox itself, however, we were able to reproduce the issue with the staging server.</p>
<p>After further debugging, we found the “special ingredient” required for this bug to happen. All HTTP/3 connections go through Necko, our networking stack. However, Rust components that need direct network access are not using Necko directly, but are calling into it through an intermediate library called <a href="https://github.com/mozilla/application-services/tree/main/components/viaduct"><i><code>viaduct</code></i></a>.</p>
<p>In order to understand why this mattered, we first need to understand some things about the internals of Necko, in particular about HTTP/3 upload requests. For such requests, the higher-level Necko APIs<a id="footnote2">²</a> check if the <code>Content-Length</code> header is present and if it isn’t, it will automatically be added. The lower-level HTTP/3 code later relies on this header to determine the request size. This works fine for web content and other requests in our code.</p>
<p>When requests pass through <code>viaduct</code> first, however, <code>viaduct</code> will lower-case each header and pass it on to Necko. And here is the problem: the API checks in Necko are case-<b>insensitive</b> while the lower-level HTTP/3 code is case-<b>sensitive</b>. So if any code was to add a <code>Content-Length</code> header and pass the request through <code>viaduct</code>, it would pass the Necko API checks but the HTTP/3 code would not find the header.</p>
<p>It just so happens that Telemetry is currently the only Rust-based component in Firefox Desktop that uses the network stack and adds a <code>Content-Length</code> header. This is why users who disabled Telemetry would see this problem resolved even though the problem is not related to Telemetry functionality itself and could have been triggered otherwise.</p>
<div id="attachment_47579"><p><img aria-describedby="caption-attachment-47579" loading="lazy" src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2022/01/foxstuck-diagram4.png" alt="A diagram showing the different network components in Firefox." width="1826" height="973" srcset="https://hacks.mozilla.org/files/2022/01/foxstuck-diagram4.png 1826w, https://hacks.mozilla.org/files/2022/01/foxstuck-diagram4-250x133.png 250w, https://hacks.mozilla.org/files/2022/01/foxstuck-diagram4-500x266.png 500w, https://hacks.mozilla.org/files/2022/01/foxstuck-diagram4-768x409.png 768w, https://hacks.mozilla.org/files/2022/01/foxstuck-diagram4-1536x818.png 1536w" sizes="(max-width: 1826px) 100vw, 1826px"/></p><p id="caption-attachment-47579"><small> A specific code path was required to trigger the problem in the HTTP/3 protocol implementation.</small></p></div>
<p><small><a href="#footnote2">²</a> <i>These are internal APIs, not accessible to web content.</i></small></p>
<h2>The Infinite Loop</h2>
<p>With the load balancer change in place, and a special code path in a new Rust service now active, the necessary final ingredient to trigger the problem for users was deep in Necko HTTP/3 code.</p>
<p>When handling a request, the code <a href="https://searchfox.org/mozilla-central/rev/435a77f1a1aaf1a78d30a2aaa81c6158a2f83dba/netwerk/protocol/http/Http3Stream.cpp#71,79-83">looked up the field in a case-sensitive way</a> and failed to find the header as it had been lower-cased by <code>viaduct</code>. Without the header, the request was determined by the Necko code to be complete, leaving the real request body unsent. However, this code would only terminate when there was no additional content to send. This <a href="https://searchfox.org/mozilla-central/rev/435a77f1a1aaf1a78d30a2aaa81c6158a2f83dba/netwerk/protocol/http/Http3Stream.cpp#223,228,272-274">unexpected state caused the code to loop indefinitely rather than returning an error</a>. Because all network requests go through one <i>socket thread</i>, this loop blocked any further network communication and made Firefox unresponsive, unable to load web content.</p>
<h2>Lessons Learned</h2>
<p>As so often is the case, the issue was a lot more complex than it appeared at first glance and there were many contributing factors working together. Some of the key factors we have identified include:</p>
<ul>
<li aria-level="1">
<p>GCP’s deployment of HTTP/3 as default was unannounced. We are actively working with them to improve the situation. We realize that an announcement (as is usually sent) might not have entirely mitigated the risk of an incident, but it would likely have triggered more controlled experiments (e.g. in a staging environment) and deployment.</p>
</li>
<li aria-level="1">
<p>Our setting of “Automatic (default)” on the load balancers instead of a more explicit choice allowed the deployment to take place automatically. We are reviewing all service configurations to avoid similar mistakes in the future.</p>
</li>
<li aria-level="1">
<p>The particular combination of HTTP/3 and <code>viaduct</code> on Firefox Desktop was not covered in our continuous integration system. While we cannot test every possible combination of configurations and components, the choice of HTTP version is a fairly major change that should have been tested, as well as the use of an additional networking layer like <code>viaduct</code>. Current HTTP/3 tests cover the low-level protocol behavior and the Necko layer as it is used by web content. We should run more system tests with different HTTP versions and doing so could have revealed this problem.</p>
</li>
</ul>
<p>We are also investigating action points both to make the browser more resilient towards such problems and to make incident response even faster. Learning as much as possible from this incident will help us improve the quality of our products. We’re grateful to all the users who have sent crash reports, worked with us in Bugzilla or helped others to work around the problem.</p>
    <section>
                                
                      <p>Christian is a Firefox Tech Lead and Senior Staff Security Engineer at Mozilla.</p>
                                <p><a href="https://hacks.mozilla.org/author/chollermozilla-com/">More articles by Christian Holler…</a></p>
                  </section>
  </article></div>
  </body>
</html>
