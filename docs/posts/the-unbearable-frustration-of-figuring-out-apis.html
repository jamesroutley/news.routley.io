<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.ar-ms.me/thoughts/translation-cli/">Original</a>
    <h1>The Unbearable Frustration of Figuring Out APIs</h1>
    
    <div id="readability-page-1" class="page"><div><p>In the ongoing effort for activities that fill the void made by unemployment, I have recently started to learn Chinese. Got into a Chinese language institute and everything. And because not every app supports right-clicking some text and selecting the &#34;Translate&#34; menu option, I found myself launching TextEdit just to do that. So, I figured, maybe I can do a small command line tool where I&#39;d write something like:</p>
<pre><code data-lang="shellscript"><span><span>translate</span><span> 你好</span></span></code></pre>
<p>And the terminal would happily tell me it means &#34;Hello&#34;. Should be easy. A <a rel="external" href="https://bsky.app/profile/hikikomorphism.bsky.social/post/3lwamjk3pjk2x">hungry ghost trapped in a jar</a> can probably figure it out in one shot.</p>
<p>First I figured I&#39;d look for some translation API. Almost everything I looked at seemed to want an API token and there is a rate limit (not that I&#39;d hit it), and maybe a credit card number. Then I remembered that macOS has that Translate right click action, surely I can just hook into that.</p>
<p>Note that this article, unlike what I do usually, is written after the fact.</p>
<hr/>
<h2 id="first-steps">First Steps</h2>
<h3 id="zig">Zig</h3>
<p>I have been using Zig for different projects this year. So I got the Ghost to write the thing for me, and it even gave me the correct flags to pass to the compiler! But then when I tried it, I realized it used the <em>Dictionary</em> service instead of the Translation service. When I asked it for that instead, it was like yeah you cannot call Swift <code>async</code> functions from Zig, you need a Swift shim.</p>
<p>So let&#39;s do the thing in Swift instead. I have been meaning to learn Swift anyway.</p>
<h3 id="mycli">MyCLI</h3>
<p>Thankfully, Swift was already set up on my machine with an LSP and a formatter and the works. I had even <a rel="external" href="https://www.swift.org/getting-started/cli-swiftpm/">followed the basic tutorial</a> and the file is on my machine already, A small edit and I can be on my way.</p>
<p>For reference, this is the code at the end of the tutorial:</p>
<pre><code data-lang="swift"><span><span>import</span><span> </span><span>ArgumentParser</span></span>
<span><span>import</span><span> </span><span>Figlet</span></span>
<span></span>
<span><span>@main</span></span>
<span><span>struct</span><span> </span><span>FigletTool</span><span>:</span><span> </span><span>ParsableCommand </span><span>{</span></span>
<span><span>	@Option</span><span>(help</span><span>:</span><span> &#34;Specify the input&#34;</span><span>)</span></span>
<span><span>	public var</span><span> input: String</span></span>
<span></span>
<span><span>	public func</span><span> run()</span><span> throws</span><span> {</span></span>
<span><span>		Figlet.say(self.input)</span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre>
<p>After so long in Rust and Zig lands, the most jarring thing about Swift so far is that <code>import</code> creates glob imports. This is not quite apparent here, but it is there. Also, this is the accompanying <code>Package.swift</code>, comments and all.</p>
<pre><code data-lang="swift"><span></span>
<span></span>
<span></span>
<span><span>import</span><span> </span><span>PackageDescription</span></span>
<span></span>
<span><span>let package</span><span> =</span><span> Package(</span></span>
<span><span>    name:</span><span> &#34;MyCLI&#34;</span><span>,</span></span>
<span><span>    dependencies: [</span></span>
<span><span>      .package(url:</span><span> &#34;https://github.com/apple/example-package-figlet&#34;</span><span>, branch:</span><span> &#34;main&#34;</span><span>),</span></span>
<span><span>      .package(url:</span><span> &#34;https://github.com/apple/swift-argument-parser&#34;</span><span>, from:</span><span> &#34;1.0.0&#34;</span><span>),</span></span>
<span><span>    ],</span></span>
<span><span>    targets: [</span></span>
<span></span>
<span></span>
<span><span>        .executableTarget(</span></span>
<span><span>            name:</span><span> &#34;MyCLI&#34;</span><span>,</span></span>
<span><span>            dependencies: [</span></span>
<span><span>                .product(name:</span><span> &#34;Figlet&#34;</span><span>, package:</span><span> &#34;example-package-figlet&#34;</span><span>),</span></span>
<span><span>                .product(name:</span><span> &#34;ArgumentParser&#34;</span><span>, package:</span><span> &#34;swift-argument-parser&#34;</span><span>),</span></span>
<span><span>            ],</span></span>
<span><span>            path:</span><span> &#34;Sources&#34;</span><span>),</span></span>
<span><span>    ]</span></span>
<span><span>)</span></span></code></pre>
<p>This is run with <code>swift run</code>, but to pass arguments, one needs to do the following:</p>
<pre><code data-lang="shellscript"><span><span>swift</span><span> run MyCLI</span><span> --input</span><span> Hello</span></span></code></pre>
<p>I spent like 15 minutes trying different variations of this</p>
<pre><code data-lang="shellscript"><span></span>
<span><span>swift</span><span> run</span><span> -- --input</span><span> Hello</span></span></code></pre>
<p>Anyway, I deleted the <code>Figlet</code> related lines and went from there.</p>
<hr/>
<h2 id="false-starts">False Starts</h2>
<p>I asked the Ghost in the Jar for how the API to use it looks like, but every version it gave me was hallucinated in some fashion. So I wrote <code>import Translation</code> at the top of the file, and figured maybe I can figure it out as I go along. <a rel="external" href="https://developer.apple.com/documentation/Translation">Here is the Apple API documentation</a>. A quick look tells you all the functions in here return a <code>some View</code>, and the only function seemingly unrelated to SwiftUI is the <code>init</code> function in <code>TranslationSession</code>, which, annoyingly, <em>needs</em> a known source language.</p>
<p>So I do this</p>
<pre><code data-lang="swift"><span><span>import</span><span> </span><span>ArgumentParser</span></span>
<span><span>import</span><span> </span><span>Translation</span></span>
<span></span>
<span><span>@main</span></span>
<span><span>struct</span><span> </span><span>Translate</span><span>:</span><span> </span><span>ParsableCommand </span><span>{</span></span>
<span><span>	@Argument</span><span>(help</span><span>:</span><span> &#34;Specify the input&#34;</span><span>)</span></span>
<span><span>	public var</span><span> input: String</span></span>
<span></span>
<span><span>	public func</span><span> run()</span><span> async throws</span><span> {</span></span>
<span><span>		print(</span><span>&#34;&gt;</span><span>\t</span><span>\(input)&#34;</span><span>)</span></span>
<span></span>
<span><span>		let</span><span> source </span><span>=</span><span> Locale.Language(identifier:</span><span> &#34;zh_CN&#34;</span><span>)</span></span>
<span><span>		let</span><span> target </span><span>=</span><span> Locale.Language(identifier:</span><span> &#34;en_US&#34;</span><span>)</span></span>
<span></span>
<span><span>		let</span><span> session </span><span>=</span><span> TranslationSession(installedSource: source, target: target)</span></span>
<span></span>
<span><span>		let</span><span> response </span><span>=</span><span> try await</span><span> session.translate(input)</span></span>
<span><span>		let</span><span> result </span><span>=</span><span> response.targetText</span></span>
<span></span>
<span><span>		print(</span><span>&#34;&gt;</span><span>\t</span><span>\(result)&#34;</span><span>)</span></span>
<span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre>
<p>You can see the number of small changes to the original file here. I changed the struct&#39;s name (because it shows up in the <code>--help</code> message.) I changed <code>Option</code> to <code>Argument</code> so it does not need a flag. I even turned <code>run</code> into an <code>async</code> function so I can <code>await</code> the <code>session.translate</code> function call.</p>
<p>However, I start to hit a couple of snags. First is that <code>TranslationSession.init</code> is restricted to macOS 26. Not wanting to do a bunch of conditional compilation, (after all this tool is for my own use), I will just add the <code>platforms</code> field in <code>Package.swift</code>。 Oh it needs to be <em>before</em> <code>dependencies</code>? Fine, whatever.</p>
<pre><code data-lang="swift"><span></span>
<span></span>
<span></span>
<span><span>import</span><span> </span><span>PackageDescription</span></span>
<span></span>
<span><span>let package</span><span> =</span><span> Package(</span></span>
<span><span>	name:</span><span> &#34;MyCLI&#34;</span><span>,</span></span>
<span><span>	platforms: [</span></span>
<span><span>		.macOS(</span><span>)</span></span>
<span><span>	],</span></span>
<span><span>	dependencies: [</span></span>
<span><span>		.package(url:</span><span> &#34;https://github.com/apple/swift-argument-parser&#34;</span><span>, from:</span><span> &#34;1.0.0&#34;</span><span>)</span></span>
<span><span>	],</span></span>
<span><span>	targets: [</span></span>
<span></span>
<span></span>
<span><span>		.executableTarget(</span></span>
<span><span>			name:</span><span> &#34;MyCLI&#34;</span><span>,</span></span>
<span><span>			dependencies: [</span></span>
<span><span>				.product(name:</span><span> &#34;ArgumentParser&#34;</span><span>, package:</span><span> &#34;swift-argument-parser&#34;</span><span>)</span></span>
<span><span>			],</span></span>
<span><span>			path:</span><span> &#34;Sources&#34;</span><span>,</span></span>
<span><span>		)</span></span>
<span><span>	]</span></span>
<span><span>)</span></span></code></pre>
<p>I cannot find <code>.v26</code> in the LSP&#39;s drop down. There is no <code>.Tahoe</code> either. Even if I type it manually, I get an error. I am on Tahoe. I have the latest version of Swift (I checked). why can&#39;t I select it from here?</p>
<p>You probably already know this, but apparently the first line in the file, that <em>comment</em>, is actually significant. I edited that to say <code>swift-tools-version: 6.2</code>, and now I can write <code>.v26</code> in peace. I <em>hate</em> syntactic comments.</p>
<p>Ok, the LSP is happy. The compiler seems happy. Let&#39;s get going.</p>
<hr/>
<h2 id="async-woes">Async Woes</h2>
<p>Running this with <code>swift run -q MyCLI 你好</code> gives the following message:</p>
<pre><code data-lang="plain"><span><span>USAGE: translate &lt;input&gt;</span></span>
<span></span>
<span><span>ARGUMENTS:</span></span>
<span><span>  &lt;input&gt;                 Specify the input</span></span>
<span></span>
<span><span>OPTIONS:</span></span>
<span><span>  -h, --help              Show help information.</span></span></code></pre>
<p>Eh, I clearly passed in something. What gives? I tried changing <code>Argument</code> back to <code>Option</code>, same result. Hm. I realized that the problem maybe is that <code>run</code> is not supposed to be <code>async</code>. Fine, let&#39;s remove <code>async</code>, but then how do I call <code>session.translate</code> ?</p>
<p>Looking things up, and communing with ghosts, apparently I can wrap thing in <code>Task</code>. Sure.</p>
<pre><code data-lang="swift"><span><span>Task {</span></span>
<span><span>	let</span><span> response </span><span>=</span><span> try await</span><span> session.translate(input)</span></span>
<span><span>	let</span><span> result </span><span>=</span><span> response.targetText</span></span>
<span></span>
<span><span>	print(</span><span>&#34;&gt;</span><span>\t</span><span>\(result)&#34;</span><span>)</span></span>
<span><span>}</span></span></code></pre>
<p>And this runs! I rerun the command I do <code>swift run -q MyCLI 你好</code> and I get ... nothing. Just the print message that prints <code>input</code> at the start. I think hah .. I have fallen into the classic trap, I am spawning a Task but I am not waiting for it. <em>How</em> do I wait for it?</p>
<p>The ghosts suggested a <code>DispatchSemaphore</code>. This is the full code:</p>
<pre><code data-lang="swift"><span><span>import</span><span> </span><span>ArgumentParser</span></span>
<span><span>import</span><span> </span><span>Translation</span></span>
<span></span>
<span><span>@main</span></span>
<span><span>struct</span><span> </span><span>Translate</span><span>:</span><span> </span><span>ParsableCommand </span><span>{</span></span>
<span><span>	@Argument</span><span>(help</span><span>:</span><span> &#34;Specify the input&#34;</span><span>)</span></span>
<span><span>	public var</span><span> input: String</span></span>
<span></span>
<span><span>	public func</span><span> run()</span><span> throws</span><span> {</span></span>
<span><span>		print(</span><span>&#34;&gt;</span><span>\t</span><span>\(input)&#34;</span><span>)</span></span>
<span></span>
<span><span>		let</span><span> source </span><span>=</span><span> Locale.Language(identifier:</span><span> &#34;zh_CN&#34;</span><span>)</span></span>
<span><span>		let</span><span> target </span><span>=</span><span> Locale.Language(identifier:</span><span> &#34;en_US&#34;</span><span>)</span></span>
<span></span>
<span><span>		let</span><span> session </span><span>=</span><span> TranslationSession(installedSource: source, target: target)</span></span>
<span><span>		let</span><span> semaphore </span><span>=</span><span> DispatchSemaphore(value:</span><span> 0</span><span>)</span></span>
<span></span>
<span><span>		Task {</span></span>
<span><span>			let</span><span> response </span><span>=</span><span> try await</span><span> session.translate(input)</span></span>
<span><span>			let</span><span> result </span><span>=</span><span> response.targetText</span></span>
<span></span>
<span><span>			print(</span><span>&#34;&gt;</span><span>\t</span><span>\(result)&#34;</span><span>)</span></span>
<span><span>			semaphore.signal()</span></span>
<span><span>		}</span></span>
<span><span>		semaphore.wait()</span></span>
<span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre>
<p>Ok .. for some reason, when I tried this right now, it actually works. But when I tried it before, probably with a different arrangement of stuff, it did not. It just froze and gave no feedback. The power of hindsight, I guess.</p>
<p>Nonetheless, since it did not work, I figured I was doing something wrong. So I searched for &#34;how to call an async function from a sync function in Swift&#34;, and came across <a rel="external" href="https://www.hackingwithswift.com/quick-start/concurrency/what-calls-the-first-async-function">What calls the first async function?</a> from Hacking With Swift, and the tl;dr of that article was &#34;not you, just make your main <code>async</code>&#34;. Very helpful, Paul. Apparently I needed to make <code>run</code> async. I looked into the docs of <code>swift-argument-parser</code>, I figured surely they have <em>some</em> guidance on how to deal with <code>async</code> functions. Apparently the guidance was just to replace the <code>ParsableCommand</code> protocol with <code>AsyncParsableCommand</code>. Ok, now I felt like an idiot. This is the full code:</p>
<pre><code data-lang="swift"><span><span>import</span><span> </span><span>ArgumentParser</span></span>
<span><span>import</span><span> </span><span>Translation</span></span>
<span></span>
<span><span>@main</span></span>
<span><span>struct</span><span> </span><span>Translate</span><span>:</span><span> </span><span>AsyncParsableCommand </span><span>{</span></span>
<span><span>	@Argument</span><span>(help</span><span>:</span><span> &#34;Specify the input&#34;</span><span>)</span></span>
<span><span>	public var</span><span> input: String</span></span>
<span></span>
<span><span>	public func</span><span> run()</span><span> async throws</span><span> {</span></span>
<span><span>		print(</span><span>&#34;&gt;</span><span>\t</span><span>\(input)&#34;</span><span>)</span></span>
<span></span>
<span><span>		let</span><span> source </span><span>=</span><span> Locale.Language(identifier:</span><span> &#34;zh_CN&#34;</span><span>)</span></span>
<span><span>		let</span><span> target </span><span>=</span><span> Locale.Language(identifier:</span><span> &#34;en_US&#34;</span><span>)</span></span>
<span></span>
<span><span>		let</span><span> session </span><span>=</span><span> TranslationSession(installedSource: source, target: target)</span></span>
<span></span>
<span><span>		let</span><span> response </span><span>=</span><span> try await</span><span> session.translate(input)</span></span>
<span><span>		let</span><span> result </span><span>=</span><span> response.targetText</span></span>
<span></span>
<span><span>		print(</span><span>&#34;&gt;</span><span>\t</span><span>\(result)&#34;</span><span>)</span></span>
<span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre>
<p>Works like magic <em>now</em>. Except, at the time, it did not. It gave me the following message:</p>
<pre><code data-lang="plain"><span><span>&gt;	你好</span></span>
<span><span>Error: Unable to Translate</span></span></code></pre>
<p>Also it leaves the small detail of autodetecting the language, which is here hardcoded as <code>zh_CN</code>.</p>
<hr/>
<h2 id="language-recognition">Language Recognition</h2>
<p>The error had <em>zero</em> feedback. Absolutely unhelpful. No idea what&#39;s going on. I added a <code>try await session.prepareTranslation()</code> line I saw in some online examples, but .. nothing. I looked a bit more around for tutorials, I could not find anything. All tutorials just regurgitate the same SwiftUI code examples, but I am not using SwiftUI. Ekh.</p>
<p>Eventually, I came across the original <a rel="external" href="https://www.youtube.com/watch?v=MuIFhbHNmqA">WWDC video introducing the Translation API</a>, and decided to watch it. And it was actually very helpful, despite it being SwiftUI focused.</p>
<p>It does not touch on how to use <code>TranslationSession.init</code>, instead it mentions that a <code>session</code> is given to you to run in a SwiftUI closure. It gives the rationale behind the API, but it also introduces the bit I needed for autodetection, and that is <code>NLLanguageRecognizer</code>.</p>
<p><code>NaturalLanguage</code> is an Apple framework for dealing with natural language (How did you guess?). I pretty much copied the code from the video into its own function (after <code>import NaturalLanguage</code>).</p>
<pre><code data-lang="swift"><span><span>func</span><span> identify_lang(_ sample: String)</span><span> -&gt;</span><span> Locale.Language</span><span>?</span><span> {</span></span>
<span><span>	let</span><span> recognizer </span><span>=</span><span> NLLanguageRecognizer()</span></span>
<span><span>	recognizer.processString(sample)</span></span>
<span><span>	guard let</span><span> language </span><span>=</span><span> recognizer.dominantLanguage </span><span>else</span><span> {</span><span> return</span><span> nil</span><span> }</span></span>
<span></span>
<span><span>	return</span><span> Locale.Language(identifier: language.rawValue)</span></span>
<span><span>}</span></span></code></pre>
<p>And this is my new <code>func run()</code></p>
<pre><code data-lang="swift"><span><span>public func</span><span> run()</span><span> async throws</span><span> {</span></span>
<span><span>	print(</span><span>&#34;&gt;</span><span>\t</span><span>\(input)&#34;</span><span>)</span></span>
<span></span>
<span></span>
<span><span>	let</span><span> source </span><span>=</span><span> identify_lang(input)</span><span>!</span></span>
<span><span>	let</span><span> target </span><span>=</span><span> Locale.Language(identifier:</span><span> &#34;en_US&#34;</span><span>)</span></span>
<span></span>
<span><span>	let</span><span> session </span><span>=</span><span> TranslationSession(installedSource: source, target: target)</span></span>
<span><span>	try await</span><span> session.prepareTranslation()</span></span>
<span></span>
<span><span>	let</span><span> response </span><span>=</span><span> try await</span><span> session.translate(input)</span></span>
<span><span>	let</span><span> result </span><span>=</span><span> response.targetText</span></span>
<span></span>
<span><span>	print(</span><span>&#34;&gt;</span><span>\t</span><span>\(result)&#34;</span><span>)</span></span>
<span></span>
<span><span>}</span></span></code></pre>
<p>The other thing the video pointed out, is that the API user should check language availability. I saw that earlier, but did not particularly care. I <em>know</em> Chinese and English are available. I have been using them! Nonetheless, I copied that code as well just to be thorough, to figure out what the API does.</p>
<pre><code data-lang="swift"><span><span>let</span><span> availability </span><span>=</span><span> LanguageAvailability()</span></span>
<span><span>let</span><span> is_it </span><span>=</span><span> await</span><span> availability.status(from: source, to: target)</span></span>
<span><span>switch</span><span> is_it {</span></span>
<span><span>case</span><span> .unsupported</span><span>:</span></span>
<span><span>	print(</span><span>&#34;&gt; language pairing from \(source.languageCode) to \(target.languageCode) unsupprted&#34;</span><span>)</span></span>
<span><span>	return</span></span>
<span><span>case</span><span> .supported</span><span>:</span></span>
<span><span>	print(</span><span>&#34;&gt; language pairing from \(source.languageCode</span><span>!</span><span>) to \(target.languageCode</span><span>!</span><span>) not installed&#34;</span><span>)</span></span>
<span><span>	return</span></span>
<span><span>case</span><span> .installed</span><span>:</span></span>
<span><span>	break</span></span>
<span><span>}</span></span></code></pre>
<p>This gave me a compile error, as it happens, as apparently the enum is marked the Swift equivelant of <code>#[non_exhaustive]</code>. Going over StackOverflow and the Swift book, told me the answer is to add a <code>@unknown default:</code> case. I could not quickly figure out how to merge it with another case so I did not bother.</p>
<p>To my surprise, the pairing returned <code>.supported</code>, and <em>not</em> <code>.installed</code>. In a SwiftUI app, the <code>try await session.prepareTranslation()</code> call creates a pop up to ask the user to download the model.</p>
<p>But it is already installed! I am already using it via the right click menu! Nonetheless, that must be the reason for the <code>Unable to Translate</code> error.</p>
<hr/>
<h2 id="installing-models">Installing Models</h2>
<p>Communing again with Ghosts, they told me to install the models through System Settings, General, Language, etc. I went where they told me, to this dialogue, where I can install the models locally.</p>
<p><img src="https://blog.ar-ms.me/thoughts/translation-cli/dialogue.png" alt="the dialogue"/></p>
<p>You can see that Mandarin is installed now, but the only language installed at the time was English(US). No matter, I installed Mandarin SImplified and Arabic, and added a note to the <code>switch</code> above showing where to install the items. And then I tried again: <code>swift run -q MyCLI 你好</code>.</p>
<p>And .. same error. I guessed that it identified the language as Mandarin Traditional for some reason, so I installed that as well, and now it works, finally!!</p>
<pre><code data-lang="plain"><span><span>% swift/MyCLI ❭ swift run -q MyCLI 你好</span></span>
<span><span>&gt;	你好</span></span>
<span><span>&gt;	Hello</span></span></code></pre>
<p>Why was that so hard? Why are the models here separate from the ones in the right click menu? Too many questions.</p>
<hr/>
<h2 id="final-code">Final Code</h2>
<p>This is the full final code, with some proper error names thrown in for good measure.</p>
<pre><code data-lang="swift"><span><span>import</span><span> </span><span>ArgumentParser</span></span>
<span><span>import</span><span> </span><span>NaturalLanguage</span></span>
<span><span>import</span><span> </span><span>Translation</span></span>
<span></span>
<span><span>@main</span></span>
<span><span>struct</span><span> </span><span>Translate</span><span>:</span><span> </span><span>AsyncParsableCommand </span><span>{</span></span>
<span><span>	@Argument</span><span>(help</span><span>:</span><span> &#34;Specify the input&#34;</span><span>)</span></span>
<span><span>	public var</span><span> input: String</span></span>
<span></span>
<span><span>	public func</span><span> run()</span><span> async throws</span><span> {</span></span>
<span><span>		print(</span><span>&#34;&gt;</span><span>\t</span><span>\(input)&#34;</span><span>)</span></span>
<span></span>
<span><span>		let</span><span> target </span><span>=</span><span> Locale.Language(identifier:</span><span> &#34;en_US&#34;</span><span>)</span></span>
<span><span>		guard let</span><span> source </span><span>=</span><span> identify_lang(input)</span><span> else</span><span> {</span></span>
<span><span>			print(</span><span>&#34;&gt; could not identify language&#34;</span><span>)</span></span>
<span><span>			throw</span><span> CliError.Recognitionfailed</span></span>
<span><span>		}</span></span>
<span></span>
<span><span>		let</span><span> availability </span><span>=</span><span> LanguageAvailability()</span></span>
<span><span>		let</span><span> is_it </span><span>=</span><span> await</span><span> availability.status(from: source, to: target)</span></span>
<span><span>		switch</span><span> is_it {</span></span>
<span><span>		case</span><span> .unsupported</span><span>:</span></span>
<span><span>			print(</span><span>&#34;&gt; language pairing from \(source.languageCode) to \(target.languageCode) unsupprted&#34;</span><span>)</span></span>
<span><span>			throw</span><span> CliError.PairingUnsupported</span></span>
<span><span>		case</span><span> .supported</span><span>:</span></span>
<span><span>			print(</span><span>&#34;&gt; language pairing from \(source.languageCode</span><span>!</span><span>) to \(target.languageCode</span><span>!</span><span>) not installed&#34;</span><span>)</span></span>
<span><span>			print(</span><span>&#34;&gt; Go to System Settings &gt; General &gt; Language &amp; Region &gt; Translation Languages and download the models.&#34;</span><span>)</span></span>
<span><span>			throw</span><span> CliError.PairingNotInstalled</span></span>
<span><span>		case</span><span> .installed</span><span>:</span></span>
<span><span>			break</span></span>
<span><span>		@unknown default</span><span>:</span></span>
<span><span>			print(</span><span>&#34;Unknown status.&#34;</span><span>)</span></span>
<span><span>		}</span></span>
<span></span>
<span><span>		let</span><span> session </span><span>=</span><span> TranslationSession(installedSource: source, target: target)</span></span>
<span><span>		try await</span><span> session.prepareTranslation()</span></span>
<span></span>
<span><span>		let</span><span> response </span><span>=</span><span> try await</span><span> session.translate(input)</span></span>
<span><span>		let</span><span> result </span><span>=</span><span> response.targetText</span></span>
<span></span>
<span><span>		print(</span><span>&#34;&gt;</span><span>\t</span><span>\(result)&#34;</span><span>)</span></span>
<span></span>
<span><span>	}</span></span>
<span><span>}</span></span>
<span></span>
<span><span>func</span><span> identify_lang(_ sample: String)</span><span> -&gt;</span><span> Locale.Language</span><span>?</span><span> {</span></span>
<span><span>	let</span><span> recognizer </span><span>=</span><span> NLLanguageRecognizer()</span></span>
<span><span>	recognizer.processString(sample)</span></span>
<span><span>	guard let</span><span> language </span><span>=</span><span> recognizer.dominantLanguage </span><span>else</span><span> {</span><span> return</span><span> nil</span><span> }</span></span>
<span></span>
<span><span>	return</span><span> Locale.Language(identifier: language.rawValue)</span></span>
<span><span>}</span></span>
<span></span>
<span><span>enum</span><span> </span><span>CliError</span><span>:</span><span> </span><span>Error </span><span>{</span></span>
<span><span>	case</span><span> Recognitionfailed</span></span>
<span><span>	case</span><span> PairingUnsupported</span></span>
<span><span>	case</span><span> PairingNotInstalled</span></span>
<span><span>}</span></span></code></pre>
<p>So I compiled it for release, put it in <code>/usr/local/bin</code>, and called it a day. You can see an example of a failing call if you do <code>swift run -q MyCLI Bonjour</code>, where it prompts to install the dictionary.</p>
<h2 id="in-conclusion">In Conclusion</h2>
<p>To rub some salt on the wound, during the time I was trying to puzzle this out, I realized that Spotlight (with the Cmd+Space key) can already do this exactly how I envisioned it, with around the same number of keystrokes, and it does not need this dance with installing models and whatever.</p>
<p><img src="https://blog.ar-ms.me/thoughts/translation-cli/spotlight.png" alt="spotlight"/></p>
<p>Also, Swift is frustrating. API of Swift libraries is frustrating.</p>
<p>Until later.</p>
<hr/>

</div></div>
  </body>
</html>
