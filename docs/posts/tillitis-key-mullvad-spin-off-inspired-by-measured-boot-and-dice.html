<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tillitis.se/">Original</a>
    <h1>Tillitis Key – Mullvad spin-off inspired by measured boot and DICE</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<div>
    <p>The Tillitis Key is a new kind of USB security key inspired by measured boot and DICE.</p>
<p>Tillitis Key’s design encourages developers to experiment with new security key applications and models in a way that makes adoption easier and less risky for end-users.</p>
<p>It offers both security and flexibility by being end-user programmable while also preventing applications loaded onto the device from knowing each other’s secrets. During use firmware on Tillitis Key derives a unique key for each application it runs by measuring it before execution. This is done by combining an application’s hash value with a unique per device secret. Applications are loaded onto the device from the host computer during use, and are not stored persistently on the device.</p>
<p>A user- or host-supplied secret can also be mixed into the key derivation function, providing further protection. A sophisticated physical attacker should be assumed to have knowledge of the target application’s hash, and will likely eventually succeed in extracting the UDS from the hardware. By adding a host-supplied secret, knowledge of the application used as well as the security key’s UDS is not sufficient to produce the application secret. This makes the security impact of a lost or stolen Tillitis Key less than for conventional security keys.</p>
<p>Device applications can be chain-loaded where the first application stage hands off its secret to the second stage. This improves user experience as it makes it possible for the application secret (and its public key) to remain the same even if a device application is updated. It also enables developers to define their own software update trust policies. A simple first-stage application might do code signing verification of the second stage, whereas a more advanced one will require m-of-n code signatures, or a <a href="https://www.sigsum.org/">Sigsum</a> inclusion proof. Sigsum was designed with embedded use cases in mind.</p>
<p><img src="https://www.tillitis.se/media/tkopenw.jpg" alt="Tillitis Key hardware"/></p>
<h2 id="open-source-hardware-and-software">Open source hardware and software</h2>
<p>Tillitis Key is and always will be open source hardware and software. Schematics, PCB design and FPGA design source as well as all software source code can be found on <a href="https://www.github.com/tillitis/">GitHub</a>.</p>

</div>

        </div></div>
  </body>
</html>
