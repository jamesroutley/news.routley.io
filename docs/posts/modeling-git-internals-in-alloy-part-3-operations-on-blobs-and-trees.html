<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/posts/modeling-git-internals-in-alloy-part-3-operations-on-blobs-and-trees/">Original</a>
    <h1>Modeling Git Internals in Alloy, Part 3: Operations on Blobs and Trees</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, April 24, 2023</em></p><p>In the last two posts, we&#39;ve modeled Git&#39;s internal data structures in <a href="https://bytes.zone/posts/alloy/">Alloy</a>. First, we handled <a href="https://bytes.zone/posts/modeling-git-internals-in-alloy-part-1-blobs-and-trees/">blobs and trees</a>, then <a href="https://bytes.zone/posts/modeling-git-internals-in-alloy-part-2-commits-and-tags/">commits and tags</a>. During all that, we introduced some <code>fact</code>s—things that Alloy will accept as true, regardless of whether those assumptions hold in real life. Today, we&#39;ll model some Git operations to see if those facts actually hold! In particular, we&#39;ll look at:</p><ul><li><code>hash-object</code> to get a <code>Blob</code></li><li><code>update-index</code> and <code>write-tree</code> to get a <code>Tree</code></li></ul><p>To do that, we&#39;re going to have to introduce changes over time to our model. In Alloy, this means two things:</p><ol><li>Marking the parts of our model that can change.</li><li>Defining transitions between one state and the next.</li></ol><p>Once we do that, we can make assertions about time, for example that something is always or never true, or becomes true eventually given some other condition.</p><p>Let&#39;s begin by redefining <code>Blob</code> to be able to change over time. To do that, we just prepend <code>var</code> to its definition:</p><pre data-lang="alloy"><code data-lang="alloy"><span>var </span><span>sig</span><span> Blob {}
</span></code></pre><p>If we run this, we get new goodies in the instance viewer:</p><p><img src="https://bytes.zone/images/blob-over-time-in-the-instance-viewer.png" alt="The Alloy instance viewer, a macOS window with a row of buttons at the top like &#34;New Init&#34; or &#34;New Fork&#34;. Below the controls is a timeline that shows distinct states. In this instance, there is only one state repeated twice."/></p><p>On the left, we have time step 0—the initial state of the instance. On the right, we have the next step. Alloy will always show at least two time steps, and in this case Alloy also shows us that the last step repeats forever (by showing a looping arrow over the second step.)</p><p>Where we had “New” before to get a new instance, we now click “New Init”—that&#39;ll get us another starting state for the model. We can also scrub back and forth on the timeline by clicking the left and right arrow buttons. If you click “New Fork”, Alloy will make something new happen starting from the second visible step (the one on the right.) I&#39;d encourage you to load up Alloy and play around with this some—it&#39;ll look totally random right now, but that&#39;s just because we&#39;re not controlling how <code>Blob</code> changes at all right now, so Alloy allows it to change in arbitrary ways.</p><h2 id="adding-processes">Adding Processes</h2><p>This model isn&#39;t super useful yet, since we don&#39;t actually say <em>how</em> blobs can change over time. Let&#39;s add some structure so we can define that!</p><p>To start with, we need to define an initial state. Seems fine to start with the same thing Git does: an empty repo with no objects.</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> init {
</span><span>  </span><span>no</span><span> Blob
</span><span>}
</span></code></pre><p>We&#39;d normally use a predicate to check if a condition holds, and that&#39;s the same here except with the addition of time. Said another way, at any time that <code>init</code> is true, there will be no <code>Blob</code>s. We&#39;ll place this <code>init</code> at a precise moment in time (namely, the first time step) very soon here.</p><p>From there, one reasonable thing to do is to do nothing. We&#39;ll need a step like this for most models, since Alloy needs to be able to say “… and then nothing ever happens again for the rest of time.” This is traditionally called a stutter step:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> stutter {
</span><span>  Blob&#39; </span><span>=</span><span> Blob
</span><span>}
</span></code></pre><p>We get a new bit of syntax here: saying <code>&#39;</code> after something means you&#39;re referring to that thing in the next time step. So <code>Blob&#39; = Blob</code> (which I pronounce “blob prime equals blob”) means that <code>Blob</code> will stay exactly the same whenever the <code>stutter</code> predicate is true.</p><p>Now let&#39;s combine these! Right now, we can keep the system the same across time by saying “init is true at the beginning, and then stutter is true forever.” We&#39;d do that with another predicate that traces those events through time:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> traces {
</span><span>  init
</span><span>  always stutter
</span><span>}
</span></code></pre><p>This introduces another new piece of syntax: <code>always</code> means “from this point going forward, this condition is always true.” In other words, we&#39;re saying “at the current time step, <code>init</code> is true. Going forward, <code>stutter</code> is always true.” Effectively, that means that we start with no blobs and never add any.</p><p>Finally, we tell Alloy that it should assume that the <code>traces</code> predicate is always true:</p><pre><code><span>fact { traces }
</span></code></pre><p>Now if we evaluate the model, we see that it has exactly zero blobs forever:</p><p><img src="https://bytes.zone/images/no-blobs-in-the-instance-viewer.png" alt="The Alloy instance viewer showing a totally uninhabited instance that does not change over time."/></p><p>If we click “New Init” now, we get the usual “there are no more instances” message:</p><p><img src="https://bytes.zone/images/no-more-satisfying-instances.png" alt="a dialog box saying &#34;There are no more satisfying instances. Note: due to symmetry breaking and other optimizations, some equivalent solutions may have been omitted.&#34;"/></p><h2 id="hashing-objects">Hashing Objects</h2><p>Now we have a blank canvas and can start adding operations. Let&#39;s start as we did in <a href="https://bytes.zone/posts/modeling-git-internals-in-alloy-part-1-blobs-and-trees/">part 1</a> with <code>git hash-object</code>. As a refresher, this command takes some content, hashes it, and stores it according to the hash. You can invoke it like this:</p><pre><code><span>$ echo &#39;Hello, Alloy!&#39; | git hash-object -w --stdin
</span><span>39528abd81b13b2731d47f86206351a61f1e6484
</span></code></pre><p>In Alloy, that looks like adding a new predicate:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> hashObject {
</span><span>  </span><span>one</span><span> Blob&#39; </span><span>-</span><span> Blob
</span><span>}
</span></code></pre><p>Since we only care about the presence of the blobs and not their content, it&#39;s sufficient to say, “there is one (and only one) blob in the next state that doesn&#39;t appear in the previous state.”</p><p>Next, we&#39;ll tell <code>traces</code> that <code>hashObject</code> is one of the things that can be true at any time step:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> traces {
</span><span>  init
</span><span>  always {
</span><span>    stutter
</span><span>    </span><span>or</span><span> hashObject
</span><span>  }
</span><span>}
</span></code></pre><p>Just to reiterate what this means, we&#39;re now saying “<code>init</code> is true at the start. Forever after, either <code>stutter</code> or <code>hashObject</code> is true.”</p><p>If it helps, you can kind of think of this as saying “<code>init</code> is true at the start; afterward, either <code>stutter</code> or <code>hashObject</code> <em>can happen</em>.” However, this is not strictly accurate: Alloy has no concept of events happening, only conditions which happen to be true at any given time.</p><p>If you execute this spec, you can now see blobs coming into existence between time steps (you may need to click “New Fork” to get this to happen.)</p><p><img src="https://bytes.zone/images/one-blob-in-the-instance-viewer.png" alt="The Alloy instance viewer showing the creation of a single new blob."/></p><h2 id="adding-to-the-index">Adding to the Index</h2><p>To finish up, we&#39;re going to create trees. As a reminder, this is two operations:</p><ol><li>Adding a blob to the index at a certain path</li><li>Creating the tree from the index</li></ol><p>On the command line, this looks like this:</p><pre><code><span>$ git update-index --add --cacheinfo 100644 \
</span><span>  39528abd81b13b2731d47f86206351a61f1e6484 hello-alloy.txt
</span><span>
</span><span>$ git write-tree
</span><span>3ee29075f260c5eebd8b9480b6464a7612668dde
</span></code></pre><p>To model this in Alloy, we&#39;ll need to model the index as well as trees. First, the index:</p><pre data-lang="alloy"><code data-lang="alloy"><span>one </span><span>sig</span><span> Repo {
</span><span>  var index</span><span>: set</span><span> Blob </span><span>+</span><span> Tree,
</span><span>}
</span></code></pre><p>(This is <code>one sig</code> because there can only be one repo in our model. We&#39;ve assumed there was one implicitly—we wouldn&#39;t have been able to add blobs otherwise—it&#39;s just explicit now.)</p><p>We&#39;ll also need to add trees:</p><pre data-lang="alloy"><code data-lang="alloy"><span>var </span><span>sig</span><span> Tree {
</span><span>  var children</span><span>: set</span><span> Blob </span><span>+</span><span> Tree,
</span><span>}
</span></code></pre><p>Like <code>Blob</code>, <code>Tree</code> is <code>var</code>: we can create new trees from an index. But unlike <code>Blob</code>, <code>Tree</code> has children. These are also marked <code>var</code>, despite an individual tree&#39;s contents never changing, because we need to be able to change the mapping of trees to blobs over time.</p><p>Before we can add any events on these, we&#39;ll need to define what they look like initially, and say that they never change in the stutter step:</p><pre data-lang="diff"><code data-lang="diff"><span> pred init {
</span><span>   no Blob
</span><span>+  no Tree
</span><span>+  no children
</span><span> }
</span><span> 
</span><span> pred stutter {
</span><span>   Blob&#39; = Blob
</span><span>+  Tree&#39; = Tree
</span><span>+  children&#39; = children
</span><span>+  index&#39; = index
</span><span> }
</span></code></pre><p>We could have omitted <code>no children</code> in <code>init</code> because there really can&#39;t be any trees or blobs present in <code>children</code> if there are no trees or blobs in the whole system, but I find it&#39;s better to be explicit.</p><p>We&#39;ll also need to add similar lines as a frame condition in <code>hashObject</code>:</p><pre data-lang="diff"><code data-lang="diff"><span> pred hashObject {
</span><span>   one Blob&#39; - Blob
</span><span>+
</span><span>+  // frame
</span><span>+  Tree&#39; = Tree
</span><span>+  children&#39; = children
</span><span>+  index&#39; = index
</span><span> }
</span></code></pre><p>We need to do this because of the behavior we observed at first: if we don&#39;t control the next state of every varying thing in our model, Alloy allows it to change in arbitrary ways. This can be annoying, but so far I&#39;ve found it&#39;s something I can get over in order to get the useful stuff Alloy can do.</p><p>But now that we have that done, we can add blobs and trees to the index:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred </span><span>updateIndex[</span><span>bt: Blob + Tree</span><span>]</span><span> {
</span><span>  index&#39; </span><span>=</span><span> index </span><span>+</span><span> Repo</span><span>-&gt;</span><span>bt
</span><span>
</span><span>  </span><span>// frame
</span><span>  Blob&#39; </span><span>=</span><span> Blob
</span><span>  Tree&#39; </span><span>=</span><span> Tree
</span><span>  children&#39; </span><span>=</span><span> children
</span><span>}
</span></code></pre><p>Our action here is saying “the next version of <code>stage</code> is the old version plus the addition of <code>bt</code>.” We haven&#39;t seen <code>-&gt;</code> before in this post; it means “all of <code>Repo</code> maps to all of <code>bt</code>.” It so happens that we have only one thing in each of those sets, so this is effectively saying “add the mapping of repo-to-bt to the index.”</p><p>Now that we have an index, let&#39;s take care of <code>write-tree</code>:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> writeTree {
</span><span>  </span><span>one</span><span> t</span><span>:</span><span> Tree&#39; </span><span>-</span><span> Tree {
</span><span>    Tree&#39; </span><span>=</span><span> Tree </span><span>+</span><span> t
</span><span>    children&#39; </span><span>=</span><span> children </span><span>+</span><span> t</span><span>-&gt;</span><span>Repo</span><span>.</span><span>index
</span><span>  }
</span><span>
</span><span>  </span><span>// frame
</span><span>  Blob&#39; </span><span>=</span><span> Blob
</span><span>  index&#39; </span><span>=</span><span> index
</span><span>}
</span></code></pre><p>A couple of details here:</p><ul><li>We&#39;re dancing around a little by saying “I want one tree in <code>Tree&#39;</code> that doesn&#39;t exist in <code>Tree</code>, and then that <code>Tree&#39;</code> is only changed by that new tree.” I feel this is a little awkward but it&#39;s the best way I can find to get exactly one new thing. If you&#39;re an Alloy expert reading this and know a better way to do this, I&#39;d really appreciate it if you could let me know!</li><li>Since <code>-&gt;</code> maps <em>all</em> of the left- and right-hand sides, this time we&#39;re saying “our new tree has all the things currently in the index.”</li></ul><p>With that taken care of, we need to unstage the items afterward. One final action:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> resetIndex {
</span><span>  </span><span>no</span><span> index&#39;
</span><span>
</span><span>  </span><span>// frame
</span><span>  Blob&#39; </span><span>=</span><span> Blob
</span><span>  Tree&#39; </span><span>=</span><span> Tree
</span><span>  children&#39; </span><span>=</span><span> children
</span><span>}
</span></code></pre><p>Now, finally, we can add these predicates to the list of conditions that Alloy will consider at every time step:</p><pre data-lang="diff"><code data-lang="diff"><span> pred traces {
</span><span>   init
</span><span>   always {
</span><span>     stutter
</span><span>     or hashObject
</span><span>+    or (one bt: Blob + Tree | updateIndex[bt])
</span><span>+    or writeTree
</span><span>+    or resetIndex
</span><span>   }
</span><span> }
</span></code></pre><p>At this point, I&#39;d usually show some instances from the visualizer and ask if we thought they were reasonable, but that gets harder to do as you add more ways for the system to change. Instead, we&#39;re going to jump right into…</p><h2 id="making-assertions">Making Assertions</h2><p>Remember how we had this <code>fact</code> back in the static version of the model?</p><pre data-lang="alloy"><code data-lang="alloy"><span>fact</span><span> &#34;trees cannot refer to themselves&#34; {
</span><span>  </span><span>no</span><span> t</span><span>:</span><span> Tree </span><span>|</span><span> t </span><span>in</span><span> t</span><span>.^</span><span>children
</span><span>}
</span></code></pre><p>We added this because it didn&#39;t look like it was in the design of Git for trees to refer to themselves (that is, appear in their own children, grandchildren, etc.) Well, now that we&#39;re modeling operations instead of the data structures alone, we can ask Alloy to think about all the state transitions in the system and tell us whether that&#39;s allowed:</p><pre><code><span>check TreesCannotReferToThemselves {
</span><span>  always (no t: Tree | t in t.^children)
</span><span>}
</span></code></pre><p>Remembering that <code>always</code> means “true at this time and forever after”, we&#39;re asking it to check if there&#39;s any series of time steps where a tree can appear in its own <code>children</code>.</p><p>Alloy can&#39;t find a counterexample for this—yay! Here&#39;s what that looks like:</p><pre><code><span>Executing &#34;Check TreesCannotReferToThemselves&#34;
</span><span>   Solver=minisatprover(jni) Steps=1..10 Bitwidth=4 MaxSeq=4 SkolemDepth=1 Symmetry=20 Mode=batch
</span><span>   1..10 steps. 27665 vars. 1790 primary vars. 67627 clauses. 275ms.
</span><span>   No counterexample found. Assertion may be valid. 45ms.
</span><span>   . contains 9 top-level formulas. 10ms.
</span></code></pre><p>Let&#39;s also check that the content of trees cannot change with any of our operations. This is as much a unit test of our modeling as it is a property of Git:</p><pre data-lang="alloy"><code data-lang="alloy"><span>check</span><span> TreesAreImmutable {
</span><span>  always (</span><span>all</span><span> t</span><span>:</span><span> Tree </span><span>|</span><span> always t</span><span>.</span><span>children </span><span>=</span><span> t</span><span>.</span><span>children&#39;)
</span><span>}
</span></code></pre><p>And again, no counterexample found.</p><p>Finally, let&#39;s do something a little trickier. We said it should be OK for files to have the same children—we assume that they&#39;ll have different filenames. We can ask Alloy to generate this as a counterexample, just to make sure it&#39;s possible. To do this, we make the opposite assertion (that two distinct trees can&#39;t have the same children):</p><pre data-lang="alloy"><code data-lang="alloy"><span>check</span><span> NoDuplicateTrees {
</span><span>  always (</span><span>no disjoint</span><span> t1, t2</span><span>:</span><span> Tree </span><span>|</span><span> t1</span><span>.</span><span>children </span><span>=</span><span> t2</span><span>.</span><span>children)
</span><span>}
</span></code></pre><p>We get a counterexample, but not the one we wanted: it turns out that in our model you can call <code>write-tree</code> over and over and get a new tree each time. If you do that in a real repo you&#39;ll just the same tree over and over.</p><p>We could deal with this in a few ways:</p><ul><li>We could add a guard condition to <code>writeTree</code> so that it cannot be true if more than one empty tree would be produced. <strong>BUT</strong> in real life, Git allows you to call <code>write-tree</code> at any time.</li><li>We could add a precondition to <code>traces</code> to do the same, <strong>BUT</strong> that models someone just never does the wrong thing, so I&#39;d rather assume that anything can be called at any time.</li><li>We could add a <code>fact</code> about empty trees, <strong>but</strong> every fact we have introduces assumptions to our model.</li></ul><p>In this case, I think adding a <code>fact</code> is worth it, since we don&#39;t represent the behavior of empty trees accurately now and introducing a fact helps with accuracy. Here&#39;s how we do it:</p><pre data-lang="alloy"><code data-lang="alloy"><span>fact</span><span> &#34;there can only be </span><span>one</span><span> empty tree&#34; {
</span><span>  always </span><span>lone</span><span> t</span><span>:</span><span> Tree </span><span>| no</span><span> t</span><span>.</span><span>children
</span><span>}
</span></code></pre><p>This hinges on <code>lone</code> enforcing that there will be zero or one <code>Tree</code>s matching this description. We could also say <code>no disjoint t1, t2: Tree | no t1.children and no t2.children</code>, but that&#39;s a bit of a mouthful.</p><p>With the addition of the fact, though, I only see the kinds of traces in the instance viewer that I was expecting. For example:</p><ol><li><p>Start off with nothing:</p><p><img src="https://bytes.zone/images/git-trace-0.png" alt="An instance with only the repo."/></p></li><li><p>hash an object:</p><p><img src="https://bytes.zone/images/git-trace-1.png" alt="An instance with the repo and a single blob."/></p></li><li><p>stage the object:</p><p><img src="https://bytes.zone/images/git-trace-2.png" alt="The previous instance, but with the blob staged."/></p></li><li><p>write a tree:</p><p><img src="https://bytes.zone/images/git-trace-3.png" alt="The previous instance, but with a tree pointing to the blob. The tree is labeled &#34;no duplicate trees t2&#34;"/></p></li><li><p>without resetting, write another tree:</p><p><img src="https://bytes.zone/images/git-trace-4.png" alt="The previous instance, with an additional tree pointing to the blob. The tree is labeled &#34;no duplicate trees t1&#34;"/></p></li></ol><p>I think we&#39;re good at this point! Just to recap, today we&#39;ve modeled:</p><ol><li>blobs and <code>hash-object</code></li><li>the plumbing we need to make trees—a repo, the index, staging, and resetting</li><li>trees and <code>write-tree</code></li></ol><p>Next time we&#39;ll go a bit further by adding commits. Stay tuned!</p><p>Before I leave you, though, here&#39;s the complete model from this post. It&#39;s quite a bit longer than other ones we&#39;ve worked with, but it&#39;s also doing way more:</p><pre data-lang="alloy"><code data-lang="alloy"><span>var </span><span>sig</span><span> Blob {}
</span><span>
</span><span>pred</span><span> hashObject {
</span><span>  </span><span>one</span><span> Blob&#39; </span><span>-</span><span> Blob
</span><span>
</span><span>  </span><span>// frame
</span><span>  Tree&#39; </span><span>=</span><span> Tree
</span><span>  children&#39; </span><span>=</span><span> children
</span><span>  index&#39; </span><span>=</span><span> index
</span><span>}
</span><span>
</span><span>var </span><span>sig</span><span> Tree {
</span><span>  var children</span><span>: set</span><span> Blob </span><span>+</span><span> Tree,
</span><span>}
</span><span>
</span><span>fact</span><span> &#34;there can only be </span><span>one</span><span> empty tree&#34; {
</span><span>  always </span><span>lone</span><span> t</span><span>:</span><span> Tree </span><span>| no</span><span> t</span><span>.</span><span>children
</span><span>}
</span><span>
</span><span>one </span><span>sig</span><span> Repo {
</span><span>  var index</span><span>: set</span><span> Blob </span><span>+</span><span> Tree,
</span><span>}
</span><span>
</span><span>pred </span><span>updateIndex[</span><span>bt: Blob + Tree</span><span>]</span><span> {
</span><span>  index&#39; </span><span>=</span><span> index </span><span>+</span><span> Repo</span><span>-&gt;</span><span>bt
</span><span>
</span><span>  </span><span>// frame
</span><span>  Blob&#39; </span><span>=</span><span> Blob
</span><span>  Tree&#39; </span><span>=</span><span> Tree
</span><span>  children&#39; </span><span>=</span><span> children
</span><span>}
</span><span>
</span><span>pred</span><span> writeTree {
</span><span>  </span><span>one</span><span> t</span><span>:</span><span> Tree&#39; </span><span>-</span><span> Tree {
</span><span>    Tree&#39; </span><span>=</span><span> Tree </span><span>+</span><span> t
</span><span>    children&#39; </span><span>=</span><span> children </span><span>+</span><span> t</span><span>-&gt;</span><span>Repo</span><span>.</span><span>index
</span><span>  }
</span><span>
</span><span>  </span><span>// frame
</span><span>  Blob&#39; </span><span>=</span><span> Blob
</span><span>  index&#39; </span><span>=</span><span> index
</span><span>}
</span><span>
</span><span>pred</span><span> resetIndex {
</span><span>  </span><span>no</span><span> index&#39;
</span><span>
</span><span>  </span><span>// frame
</span><span>  Blob&#39; </span><span>=</span><span> Blob
</span><span>  Tree&#39; </span><span>=</span><span> Tree
</span><span>  children&#39; </span><span>=</span><span> children
</span><span>}
</span><span>
</span><span>pred</span><span> init {
</span><span>  </span><span>no</span><span> Blob
</span><span>  </span><span>no</span><span> Tree
</span><span>  </span><span>no</span><span> children
</span><span>}
</span><span> 
</span><span>pred</span><span> stutter {
</span><span>  Blob&#39; </span><span>=</span><span> Blob
</span><span>  Tree&#39; </span><span>=</span><span> Tree
</span><span>  children&#39; </span><span>=</span><span> children
</span><span>  index&#39; </span><span>=</span><span> index
</span><span>}
</span><span>
</span><span>pred</span><span> traces {
</span><span>  init
</span><span>  always {
</span><span>    stutter
</span><span>    </span><span>or</span><span> hashObject
</span><span>    </span><span>or</span><span> (</span><span>one</span><span> bt</span><span>:</span><span> Blob </span><span>+</span><span> Tree </span><span>| </span><span>updateIndex[</span><span>bt</span><span>]</span><span>)
</span><span>    </span><span>or</span><span> writeTree
</span><span>    </span><span>or</span><span> resetIndex
</span><span>  }
</span><span>}
</span><span>
</span><span>fact</span><span> { traces }
</span><span>
</span><span>check</span><span> TreesCannotReferToThemselves {
</span><span>  always (</span><span>no</span><span> t</span><span>:</span><span> Tree </span><span>|</span><span> t </span><span>in</span><span> t</span><span>.^</span><span>children)
</span><span>}
</span><span>
</span><span>check</span><span> TreesAreImmutable {
</span><span>  always (</span><span>all</span><span> t</span><span>:</span><span> Tree </span><span>|</span><span> always t</span><span>.</span><span>children </span><span>=</span><span> t</span><span>.</span><span>children&#39;)
</span><span>}
</span><span>
</span><span>check</span><span> NoDuplicateTrees {
</span><span>  always (</span><span>no disjoint</span><span> t1, t2</span><span>:</span><span> Tree </span><span>|</span><span> t1</span><span>.</span><span>children </span><span>=</span><span> t2</span><span>.</span><span>children)
</span><span>}
</span></code></pre></article></div>
  </body>
</html>
