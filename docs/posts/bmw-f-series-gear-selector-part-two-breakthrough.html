<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.projectgus.com/2022/06/bmw-f-series-gear-selector-part-two-breakthrough/">Original</a>
    <h1>BMW F Series Gear Selector, Part Two: Breakthrough</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="description articleBody">
<h2>Previously</h2>
<p>At the end of <a href="https://www.projectgus.com/2022/06/bmw-f-series-gear-selector-part-one-failures/">Part One</a>, I found myself staring at this BMW F20 GWS (<em>Gangwahlschalter</em> - gear selector switch - thanks to everyone who helped dig up the German name) that I wanted to adapt into an Electric Vehicle conversion.</p>
<p><a href="https://www.projectgus.com/images/2022-06/bmw-gws-idle.webp"><img alt="BMW GWS powered on bench with no LEDs lit" src="https://www.projectgus.com/images/2022-06/derivatives/medium/1x/bmw-gws-idle.webp" srcset="https://www.projectgus.com/images/2022-06/derivatives/medium/1x/bmw-gws-idle.webp 1x, https://www.projectgus.com/images/2022-06/derivatives/medium/2x/bmw-gws-idle.webp 2x, https://www.projectgus.com/images/2022-06/derivatives/medium/4x/bmw-gws-idle.webp 4x"/></a></p>
<p>I had the GWS wired up and was able to see some CAN messages coming out, but despite trying I couldn&#39;t make it show any indication of the current gear. Nothing I tried sending had any measurable effect inside the GWS.</p>
<p>I&#39;d put the gear selector aside on my desk and it was getting dangerously close to being retired into the Cupboard Of Forgotten Projects.</p>
<h2>Responses To Part One</h2>
<p>The first part got a huge response. I genuinely only expected this to resonate with a few CAN Bus loving oddballs, so I was amazed so many people responded.</p>
<p>Some very interesting comments, including a few new investigative techniques. I think the best idea that I hadn&#39;t thought of was making friends with a wrecker or a BMW mechanic and grabbing a CAN log from one of their cars. Maybe easier said than done, but still a good idea! It&#39;s easy to underestimate human solutions to technical problems.</p>
<h2>Getting COVID</h2>
<p>Anyway, back to the story. Having COVID sucks, do not recommend. Even with all the vaccines and being pretty healthy with a pretty mild infection, it really knocked me around.</p>
<p>At some point, sitting in a fog on the couch after watching one too many television series, I picked up my phone and resumed my obsessive hobby of &#34;Searching for Information about BMW GWS&#34;. Miserable as I was, I noticed something...</p>
<h2>DTC Clues</h2>
<p>Previously, I had skimmed over the contents of BMW Device Trouble Codes (DTCs). DTCs are the short &#34;error messages&#34; that are read out by diagnostic scanners to get a summary of problems in the system and how frequently they happen. I&#39;d previously stumbled across a bunch of random BMW DTCs posted to forums by people looking for help. Hidden in two different posts was:</p>
<ul>
<li><a href="https://f10.5post.com/forums/showthread.php?t=1832587">E09400: Message (data display gear train, 0x3FD) missing, receiver GWS (PT-CAN), transmitter EGS (PT-CAN)</a></li>
<li><a href="https://f15.bimmerpost.com/forums/showthread.php?t=1841645">E09402 Message (data, display, drive train, 0x3FD) not current, receiver GWS (PT-CAN)</a></li>
</ul>
<p>Right there in the DTC description is <strong>0x3FD</strong> - a value that looks exactly like a CAN message ID, sent by the transmission (EGS) to the gear selector (GWS) over the PT-CAN! How did I miss this?</p>
<p>There is no official list of BMW fault codes available online. Presumably BMW&#39;s own proprietary diagnostic software has this, but thankfully someone has taken this information from somewhere and put it on a website: <a href="https://bmwfault.codes/">bmwfault.codes</a>.</p>
<p>By searching for more codes close to the value E09400 (and filling in a <em>lot</em> of captchas), I built up a list of &#34;receiver GWS&#34; CAN errors:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>E09400</td>
<td>No message (data, display, drivetrain, 0x3FD),</td>
</tr>
<tr>
<td>E09402</td>
<td>Message (data, display, drivetrain, 0x3FD) not current,</td>
</tr>
<tr>
<td>E09404</td>
<td>Message (data, display, drive train, 0x3FD) checksum error,</td>
</tr>
<tr>
<td>E09408</td>
<td>No message (terminals, 0x12F),</td>
</tr>
<tr>
<td>E0940A</td>
<td>No message (dimming, 0x202),</td>
</tr>
<tr>
<td>E0940C</td>
<td>No message (LCD brightness control, 0x393),</td>
</tr>
<tr>
<td>E09410</td>
<td>No message (data, display, transmission train, 0x3FD),</td>
</tr>
<tr>
<td>E09412</td>
<td>Message (data, display, transmission train, 0x3FD) not current,</td>
</tr>
<tr>
<td>E09420</td>
<td>No message (relative time, 0x328),</td>
</tr>
<tr>
<td>E09422</td>
<td>No message (vehicle condition, 0x3A0),</td>
</tr>
</tbody>
</table>
<p>The most promising are the first three, all related to <em>Message (data, display, drivetrain, 0x3FD) ... transmitter EGS</em>. There is E09400 for <em>no message</em>, E09402 for <em>not current</em> message (presumably the counter value is repeating), and E09404 for <em>checksum error</em>.</p>
<p>If it was possible to read the current DTCs from the GWS, then maybe this could be used as a feedback function to &#34;fuzz&#34; correct checksums and counter fields for the &#34;data, display, drivetrain&#34; message 0x3FD... It would certainly beat staring wide-eyed at the GWS unit, hoping it&#39;s going to blink!</p>
<p>The concept is little similar to a &#34;decryption oracle&#34; in information security, where an attacker may not have the key to decrypt a particular message but they do have a way to ask an &#34;oracle&#34; (say, a server) whether the encrypted message they have is valid or not, and then use that information to derive something else.</p>
<h2>Diagnostic Access</h2>
<p>So, how to read the diagnostic codes?</p>
<p>The official BMW software knows how to do this, but I don&#39;t have that software or a compatible hardware adaptor. Even if I had the software and an adaptor then I don&#39;t have a BMW to plug it into. This is particularly important in modern cars, where the excessive number of CAN buses means that the diagnostic connector may not connect to any &#34;real&#34; CAN bus at all. It connects to a &#34;Diagnostic Bus&#34; that runs back to a &#34;CAN Gateway&#34;:</p>
<p><a href="https://www.projectgus.com/images/2022-06/bmw-f01-gateway.png"><img alt="CAN Gateway diagram for BMW F01" src="https://www.projectgus.com/images/2022-06/derivatives/article/1x/bmw-f01-gateway.png" srcset="https://www.projectgus.com/images/2022-06/derivatives/article/1x/bmw-f01-gateway.png 1x, https://www.projectgus.com/images/2022-06/derivatives/article/2x/bmw-f01-gateway.png 2x, https://www.projectgus.com/images/2022-06/derivatives/article/4x/bmw-f01-gateway.png 4x"/></a></p>
<p>In the blurry diagram above, the purple D-CAN lines marked &#34;OBD&#34; are the diagnostic connector CAN bus, the &#34;ZGM&#34; box is BMW&#39;s central gateway module, and the other CAN buses are all linked to it.</p>
<p>On some really fancy modern cars, the diagnostic part of this interface isn&#39;t even CAN - it&#39;s Ethernet or something else.</p>
<p>The CAN gateway reads the diagnostic messages and relays them to the correct CAN bus, possibly changing the message format as it does so. So it may not even work to connect the BMW diagnostic software to only a GWS, outside of a car and not behind a CAN gateway. It&#39;s also possible the software will flat-out refuse to talk to something that is obviously a gear selector in a trench coat, and not a real car.</p>
<p>Thankfully, someone named bill57p9 posted about <a href="https://www.bimmerfest.com/threads/enet-can-diagnostic-messages-for-bench-coding.1398888/">reverse engineering the diagnostic interface on their BMW F46</a>. Bill describes the Ethernet diagnostic messages sent to the gateway (&#34;ZGM&#34;), <em>and the CAN message format sent out the other side</em>. Woo!</p>
<p>The diagnostic CAN messages seem to be a modified version of the common Universal Diagnostic Services protocol (UDS, aka ISO-14229) running over the CAN ISO-TP protocol (ISO-15765-2). That&#39;s a lot of acronym soup, but the idea is that ISO-TP is a transport protocol layer on top of CAN that lets you create messages of any length with <em>source</em> and <em>target</em> module addresses, and both source and target modules will coordinate to deliver the message by sending CAN messages back and forth.</p>
<p>UDS is an application layer that can be implemented on top of multiple different transport protocols, including ISO-TP. It provides a way to make Remote Procedure Call style &#34;service requests&#34;. A diagnostic tester module can make a request like &#34;read diagnostic codes&#34; or &#34;enter programming mode&#34; and receive back a &#34;service response&#34; with a status and data. <a href="https://shayanmukhtar.com/2020/08/20/unified-diagnostic-services-introduction-uds/">These posts have a good explanation of the UDS protocol</a>.</p>
<p><img alt="Diagram of UDS, ISO-TP and CAN as three layers" src="https://www.projectgus.com/images/2022-06/uds_layers.svg"/></p>
<p>Searching further, I found a GitHub user named brandonros has published a <a href="https://gist.github.com/brandonros/4aa6ae51d0f925671d034446947df555">list of &#34;UDS functions&#34; (service IDs) for BMW</a>. Some of these look like standard UDS service IDs, and some look BMW-specific.</p>
<p>Usually, UDS uses CAN IDs as sender and receiver addresses: if a module in the car listens for diagnostic messages with CAN ID <em>X</em>, it will send back responses with CAN ID <em>X+8</em>. BMW uses a less common ISO-TP option called &#34;Extended 11-bit Addressing&#34;. In his forum post, Bill explained that diagnostic CAN message IDs have value 0x600 plus an 8-bit number identifying the <em>sender module</em> of the message. Then the first byte of the CAN message data identifies the <em>receiver module</em>.</p>
<p>Wait a second, hadn&#39;t I seen some of these messages already? Recall in part one there were these intermittent unknown messages:</p>
<div><pre><span></span><code>ID: 065e   f0 10 0a 62 17 04 e0 94
</code></pre></div>
<p>Yeah... these messages look like module <code>5e</code> trying to send an ISO-TP message to module <code>f0</code>. Reading more of the data bytes we can see it&#39;s an ISO-TP message of length <code>0a</code> bytes, starting with <code>62 17 04 e0 94</code>. I don&#39;t know what this exact message means, I don&#39;t think it&#39;s a standard UDS request. We also only receive the first 5 bytes of the message because module <code>f0</code> never replies to negotiate receiving the rest, as required by the ISO-TP protocol. My best guess, this is the GWS sporadically saying &#34;hey, I&#39;ve noticed something is wrong and I want to tell you about it!&#34;</p>
<p>Module ID <code>5e</code> also appears in another message sent by the GWS, the &#34;Heartbeat&#34; message. Note the ID and the last byte of the data:</p>
<div><pre><span></span><code>ID: 055e   00 00 00 00 02 00 00 5e
</code></pre></div>
<p>Searching around confirms <a href="https://bimmerguide.de/hardware-hex-adressen-e9x/">5e is the GWS module ID on other BMW models</a>. So I think this 0x500 series message on ID 0x55e is advertising &#34;I&#39;m here on diagnostic ID 5e!&#34; as part of the module heartbeat.</p>
<p><small>(Afterword: In the discussion of Part One on Hacker News, <a href="https://news.ycombinator.com/item?id=31886765">halifaxbeard</a> pointed out that the versatile &#34;packet manipulation&#34; tool Scapy has an <a href="https://github.com/secdev/scapy/blob/master/scapy/contrib/automotive/bmw/definitions.py">impressive amount of BMW diagnostic definitions</a>. I haven&#39;t looked into these, but they do look handy!)</small></p>
<h2>Confirming UDS works</h2>
<p>Taking the UDS standard &#34;hard reset&#34; request (11 01) from the list of &#34;UDS functions&#34; linked above, I made a quick python-can function to reset the GWS:</p>
<div><pre><span></span><code><span>def</span> <span>hard_reset_simple</span><span>(</span><span>bus</span><span>):</span>
    <span># Message ID encodes sender &#39;0xf1&#39; (tester). Destination is in</span>
    <span># first data byte - 5e for GWS, can also use 0xdf for broadcast</span>
    <span># then send 2 byte UDS payload 0x11 0x01. response comes via ID 0x65e</span>
    <span>broadcast_msg</span> <span>=</span> <span>can</span><span>.</span><span>Message</span><span>(</span>
        <span>arbitration_id</span><span>=</span><span>0x6F1</span><span>,</span> <span>data</span><span>=</span><span>b</span><span>&#34;</span><span>\x5e\x02\x11\x01</span><span>&#34;</span><span>,</span>
        <span>is_extended_id</span><span>=</span><span>False</span>
    <span>)</span>
    <span>bus</span><span>.</span><span>send</span><span>(</span><span>broadcast_msg</span><span>)</span>
    <span>t0</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span>
    <span>while</span> <span>time</span><span>.</span><span>time</span><span>()</span> <span>&lt;</span> <span>t0</span> <span>+</span> <span>1.0</span><span>:</span>
        <span>r</span> <span>=</span> <span>bus</span><span>.</span><span>recv</span><span>(</span><span>0.1</span><span>)</span>
        <span>if</span> <span>r</span> <span>and</span> <span>0x600</span> <span>&lt;=</span> <span>r</span><span>.</span><span>arbitration_id</span> <span>&lt;</span> <span>0x700</span><span>:</span>
            <span>print</span><span>(</span><span>r</span><span>)</span>
</code></pre></div>
<p>It worked! If I send the 0x202 Dimmer message that I&#39;d discovered in Part One, the backlighting turns on. Then I send a hard reset, the GWS sends a positive response back, and finally the backlighting turns off again due to the reset:</p>
<p><img alt="GWS Blinking off due to hard reset" src="https://www.projectgus.com/images/2022-06/hard_reset.webp"/></p>
<p>Progress, sweet blinky progress!</p>
<p>The very simple hand-rolled UDS request above only works because the request and the response each fit into one CAN message. By using the Python <a href="https://pypi.org/project/can-isotp/">can-isotp package</a>, it&#39;s possible to make UDS requests of any length and get back responses of any length:</p>
<div><pre><span></span><code><span>def</span> <span>hard_reset</span><span>(</span><span>bus</span><span>):</span>
    <span>return</span> <span>req_isotp</span><span>(</span><span>bus</span><span>,</span> <span>b</span><span>&#34;</span><span>\x11\x01</span><span>&#34;</span><span>)</span>


<span>def</span> <span>req_isotp</span><span>(</span><span>bus</span><span>,</span> <span>req</span><span>):</span>
    <span>with</span> <span>ThreadedBmwIsoTp</span><span>(</span><span>bus</span><span>,</span> <span>0x5E</span><span>,</span> <span>0xF1</span><span>)</span> <span>as</span> <span>iso</span><span>:</span>
        <span>r</span> <span>=</span> <span>iso</span><span>.</span><span>request</span><span>(</span><span>req</span><span>,</span> <span>timeout</span><span>=</span><span>0.5</span><span>)</span>
        <span>return</span> <span>r</span>
</code></pre></div>
<p>(<a href="https://github.com/projectgus/car_hacking/blob/main/bmw_gear_selector/bmw_gws.py#L228=">ThreadedBmwIsoTp</a> is a class that enables the unusual &#34;Extended 11-bits&#34; ISO-TP addressing mode used by BMW, already supported by the isotp package.)</p>
<h2>Reading DTCs</h2>
<p>Going back to the list of BMW UDS service IDs, we see <code>19 02 0C;ReadDTC(0C)</code>. This is also a standard UDS request, to read DTCs that have certain bits set in their associated &#34;status mask&#34; (in this case 0x0C).</p>
<p>Each DTC stored in a module is associated with a <code>DTCStatusMask</code> field that records <em>how</em> and <em>when</em> this code was logged (for example, did it happen this &#34;session&#34; or in the past, is it happening intermittently or consistently, etc). The official list is locked away in the ISO-14229 UDS specification, but <a href="https://static.nhtsa.gov/odi/tsbs/2018/MC-10150854-9999.pdf">this PDF from Volkswagen has a good summary</a>.</p>
<p><code>0x0C</code> is a bit mask covering <code>0x04</code> &#34;pending DTCs&#34; (this is probably happening but not yet consistently) and <code>0x08</code> &#34;confirmed DTCs&#34; (this is definitely happening).</p>
<div><pre><span></span><code><span>def</span> <span>get_dtcs</span><span>(</span><span>bus</span><span>,</span> <span>status_mask</span><span>=</span><span>0x0C</span><span>):</span>
    <span>return</span> <span>req_isotp</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x19</span><span>,</span> <span>0x02</span><span>,</span> <span>status_mask</span><span>])</span>
</code></pre></div>
<p>The GWS sent back a response containing data like this:</p>
<div><pre><span></span><code>59 02 ff e0 94 20 2f e0 94 22 2f e0 94 00 2f e0 94 02 2c e0 94 04 2c e0 94 08 2f e0 94 0a 2f e0 94 0c 2f e0 94 10 2f
</code></pre></div>
<p>After writing a simple decoding function this can be translated to a dict containing the DTCs and their status values:</p>
<div><pre><span></span><code><span>{</span><span>&#39;e09420&#39;</span><span>:</span> <span>0x2f</span><span>,</span>
 <span>&#39;e09422&#39;</span><span>:</span> <span>0x2f</span><span>,</span>
 <span>&#39;e09400&#39;</span><span>:</span> <span>0x2f</span><span>,</span>
 <span>&#39;e09402&#39;</span><span>:</span> <span>0x2c</span><span>,</span>
 <span>&#39;e09404&#39;</span><span>:</span> <span>0x2c</span><span>,</span>
 <span>&#39;e09408&#39;</span><span>:</span> <span>0x2f</span><span>,</span>
 <span>&#39;e0940a&#39;</span><span>:</span> <span>0x2f</span><span>,</span>
 <span>&#39;e0940c&#39;</span><span>:</span> <span>0x2f</span><span>,</span>
 <span>&#39;e09410&#39;</span><span>:</span> <span>0x2f</span><span>}</span>
</code></pre></div>
<p>The DTCs include the ones we were expecting for the 0x3FD message! It&#39;s working...</p>
<p>At this point I started using the <a href="https://ipython.org/">IPython</a> terminal a lot for experimentation. It&#39;s a great command line REPL interface for exploratory programming, especially combined with the <a href="https://waylonwalker.com/autoreload-ipython/">autoreload feature</a> and <a href="https://stackoverflow.com/questions/14977066/how-can-i-configure-ipython-to-display-integers-in-hex-format/44426295#44426295">configured to display all integers as hex</a>.</p>
<p><a href="https://www.projectgus.com/images/2022-06/ipython.png"><img alt="Screenshot of IPython terminal showing functions used in this post" src="https://www.projectgus.com/images/2022-06/derivatives/article/1x/ipython.png" srcset="https://www.projectgus.com/images/2022-06/derivatives/article/1x/ipython.png 1x, https://www.projectgus.com/images/2022-06/derivatives/article/2x/ipython.png 2x, https://www.projectgus.com/images/2022-06/derivatives/article/4x/ipython.png 4x"/></a></p>
<h2>&#34;Guess&#34; the message structure</h2>
<p>So, we finally have a way for the GWS to give us feedback about the valid or invalid CAN messages that it has seen. Going back to the &#34;change one byte at a time&#34; search method, a function sends each generated message sixteen times and then reads the diagnostic codes. If the E09404 &#34;checksum error&#34; DTC status has changed, the function prints the new status value and the message which caused it to change:</p>
<div><pre><span></span><code>In [245]: bmw_gws_uds.search_valid_checksum(bus)
Base bytes 0x0
Changing offset 0
ID: 03fd   70 00 00 00 00 00 00 00
   E09404 -&gt; 0x2e
ID: 03fd   71 00 00 00 00 00 00 00
   E09404 -&gt; 0x2e
Changing offset 1
ID: 03fd   00 d7 00 00 00 00 00 00
   E09404 -&gt; 0x2e
Changing offset 2
ID: 03fd   00 00 ab 00 00 00 00 00
   E09404 -&gt; 0x2e
Changing offset 3
ID: 03fd   00 00 00 6e 00 00 00 00
   E09404 -&gt; 0x2e
Changing offset 4
ID: 03fd   00 00 00 00 32 00 00 00
   E09404 -&gt; 0x2e
Changing offset 5
Changing offset 6
Changing offset 7
Base bytes 0x1
Changing offset 0
ID: 03fd   33 01 01 01 01 01 01 01
   E09404 -&gt; 0x2e
Changing offset 1
ID: 03fd   01 be 01 01 01 01 01 01
   E09404 -&gt; 0x2e
Changing offset 2
ID: 03fd   01 01 d6 01 01 01 01 01
   E09404 -&gt; 0x2e
[...]
</code></pre></div>
<p>Iterating through values 0x00 to 0xFF for each of the first five bytes in the message (offsets 0-4), there is always one message where the status of the E09404 &#34;checksum error&#34; changes from 0x2F to 0x2E. This means that the &#34;Test Failed&#34; status bit (0x01) has cleared showing that the error is not currently happening. (At the time I didn&#39;t bother to look the meaning of the bit up - any status change seemed good!)</p>
<p>So, all of the individual messages logged above should include a valid checksum. This process also reveals that the whole message is only five bytes long, because changing any later bytes in the message (offsets 5,6,7) never leads to a change in the checksum DTC status.</p>
<h2>&#34;Guess&#34; the checksum</h2>
<p>Building on the above, it&#39;s possible to write a function that sends any message data and returns True if the message has a valid checksum according to the GWS:</p>
<div><pre><span></span><code><span>def</span> <span>verify_checksum</span><span>(</span><span>bus</span><span>,</span> <span>payload</span><span>):</span>
    <span>&#34;&#34;&#34;Return &#39;True&#39; if &#39;payload&#39; appears to have a valid checksum</span>
<span>       according to the GWS DTC status!&#34;&#34;&#34;</span>
    <span>message</span> <span>=</span> <span>can</span><span>.</span><span>Message</span><span>(</span><span>arbitration_id</span><span>=</span><span>0x3FD</span><span>,</span> <span>data</span><span>=</span><span>payload</span><span>,</span>
                          <span>is_extended_id</span><span>=</span><span>False</span><span>)</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>16</span><span>):</span>
        <span>bus</span><span>.</span><span>send</span><span>(</span><span>message</span><span>)</span>
        <span>time</span><span>.</span><span>sleep</span><span>(</span><span>0.01</span><span>)</span>

    <span>time</span><span>.</span><span>sleep</span><span>(</span><span>0.1</span><span>)</span>

    <span>dtcs</span> <span>=</span> <span>get_dtcs</span><span>(</span><span>bus</span><span>)</span>
    <span>csum_dtc</span> <span>=</span> <span>dtcs</span><span>.</span><span>get</span><span>(</span><span>&#34;e09404&#34;</span><span>,</span> <span>&#34;missing&#34;</span><span>)</span>
    <span>return</span> <span>csum_dtc</span> <span>==</span> <span>0x2e</span>
</code></pre></div>
<div><pre><span></span><code><span>In</span> <span>[</span><span>247</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>verify_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x70</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>])</span>
<span>Out</span><span>[</span><span>247</span><span>]:</span> <span>True</span>

<span>In</span> <span>[</span><span>249</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>verify_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x70</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x01</span><span>])</span>
<span>Out</span><span>[</span><span>249</span><span>]:</span> <span>False</span>
</code></pre></div>
<p>Another incremental improvement, here&#39;s a function where you send any four byte message and it iterates through the 255 possible checksum bytes and tells you which one is valid:</p>
<div><pre><span></span><code><span>def</span> <span>find_checksum</span><span>(</span><span>bus</span><span>,</span> <span>message</span><span>):</span>
    <span>if</span> <span>len</span><span>(</span><span>message</span><span>)</span> <span>!=</span> <span>4</span><span>:</span>
        <span>print</span><span>(</span><span>&#34;WARNING: Expected 4 byte message&#34;</span><span>)</span>
    <span>for</span> <span>chksum</span> <span>in</span> <span>range</span><span>(</span><span>0x100</span><span>):</span>
        <span>if</span> <span>verify_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>chksum</span><span>]</span> <span>+</span> <span>list</span><span>(</span><span>message</span><span>)):</span>
            <span>return</span> <span>chksum</span>
    <span>raise</span> <span>RuntimeError</span><span>(</span><span>&#34;No valid checksum found...&#34;</span><span>)</span>
</code></pre></div>
<div><pre><span></span><code><span>In</span> <span>[</span><span>256</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>find_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x70</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x03</span><span>])</span>
<span>Out</span><span>[</span><span>256</span><span>]:</span> <span>0x27</span>

<span>In</span> <span>[</span><span>257</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>find_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x70</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x13</span><span>])</span>
<span>Out</span><span>[</span><span>257</span><span>]:</span> <span>0xea</span>

<span>In</span> <span>[</span><span>258</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>find_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>])</span>
<span>Out</span><span>[</span><span>258</span><span>]:</span> <span>0x32</span>

<span>In</span> <span>[</span><span>259</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>find_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x01</span><span>])</span>
<span>Out</span><span>[</span><span>259</span><span>]:</span> <span>0x2f</span>
</code></pre></div>
<h2>CRC8?</h2>
<p>Now I had a list of valid messages including checksums, I was able to use <a href="https://github.com/colinoflynn/crcbeagle">CrcBeagle</a> by Colin O&#39;Flynn (of ChipWhisperer fame) to guess the actual checksum algorithm in use.</p>
<p>Initially this didn&#39;t work, as I&#39;d accidentally put the last byte of each message as the checksum but the checksum was in the first byte position (same as the status message 0x197 from Part One). Once the order was correct, CrcBeagle worked immediately:</p>
<div><pre><span></span><code><span>In</span> <span>[</span><span>44</span><span>]:</span> <span>crcbeagle</span><span>.</span><span>CRCBeagle</span><span>()</span><span>.</span><span>search</span><span>(</span><span>messages</span><span>,</span> <span>crcs</span><span>)</span>
<span>Input</span> <span>parameters</span><span>:</span>
    <span>8</span><span>-</span><span>bit</span> <span>CRC</span> <span>size</span>
    <span>12</span> <span>total</span> <span>messages</span><span>,</span> <span>with</span><span>:</span>
      <span>12</span> <span>messages</span> <span>with</span> <span>4</span> <span>byte</span> <span>payload</span>
<span>NOTE</span><span>:</span> <span>Output</span> <span>parameters</span> <span>may</span> <span>be</span> <span>specific</span> <span>to</span> <span>this</span> <span>message</span> <span>size</span> <span>only</span><span>.</span> <span>Pass</span> <span>different</span> <span>length</span> <span>messages</span> <span>if</span> <span>possible</span><span>.</span>

<span>Working</span> <span>on</span> <span>messages</span> <span>of</span> <span>4</span> <span>length</span><span>:</span> 
  <span>Found</span> <span>single</span> <span>likely</span> <span>solution</span> <span>for</span> <span>differences</span> <span>of</span> <span>len</span><span>=</span><span>4</span><span>,</span> <span>yah</span><span>!</span>
  <span>Found</span> <span>single</span> <span>XOR</span><span>-</span><span>out</span> <span>value</span> <span>for</span> <span>len</span> <span>=</span> <span>4</span><span>:</span> <span>0x70</span>
<span>**********</span> <span>example</span> <span>usage</span> <span>*************</span>
<span>import</span> <span>struct</span>
<span>from</span> <span>crccheck.crc</span> <span>import</span> <span>Crc8Base</span>
<span>crc</span> <span>=</span> <span>Crc8Base</span>
<span>def</span> <span>my_crc</span><span>(</span><span>message</span><span>):</span>
  <span>crc</span><span>.</span><span>_poly</span> <span>=</span> <span>0x1D</span>
  <span>crc</span><span>.</span><span>_reflect_input</span> <span>=</span> <span>False</span>
  <span>crc</span><span>.</span><span>_reflect_output</span> <span>=</span> <span>False</span>
  <span>crc</span><span>.</span><span>_initvalue</span> <span>=</span> <span>0x0</span>
  <span>crc</span><span>.</span><span>_xor_output</span> <span>=</span> <span>0x70</span>
  <span>output_int</span> <span>=</span> <span>crc</span><span>.</span><span>calc</span><span>(</span><span>message</span><span>)</span>
  <span>output_bytes</span> <span>=</span> <span>struct</span><span>.</span><span>pack</span><span>(</span><span>&#34;B&#34;</span><span>,</span> <span>output_int</span><span>)</span>
  <span>output_list</span> <span>=</span> <span>list</span><span>(</span><span>output_bytes</span><span>)</span>
  <span>return</span> <span>(</span><span>output_int</span><span>,</span> <span>output_bytes</span><span>,</span> <span>output_list</span><span>)</span>

<span>m</span> <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>]</span>
<span>output</span> <span>=</span> <span>my_crc</span><span>(</span><span>m</span><span>)</span>
<span>print</span><span>(</span><span>hex</span><span>(</span><span>output</span><span>[</span><span>0</span><span>]))</span>
<span>**************************************</span>
<span>If</span> <span>you</span> <span>have</span> <span>multiple</span> <span>message</span> <span>lengths</span> <span>this</span> <span>solution</span> <span>may</span> <span>be</span> <span>valid</span> <span>for</span> <span>this</span> <span>only</span><span>.</span>
</code></pre></div>
<p>The CRC polynomial value is the same as the standard &#34;CRC-8/SAE-J1850&#34; algorithm, but this variant has custom &#34;init&#34; &amp; &#34;xor&#34; parameters.</p>
<p>Time to write yet another experimental function: this one takes a 4 byte message and will calculate the checksum, send it to the GWS, and confirm that the GWS thinks the checksum is correct:</p>
<div><pre><span></span><code><span>class</span> <span>BMW3FDCRC</span><span>(</span><span>crccheck</span><span>.</span><span>crc</span><span>.</span><span>Crc8Base</span><span>):</span>
    <span>_poly</span> <span>=</span> <span>0x1D</span>
    <span>_initvalue</span> <span>=</span> <span>0x0</span>
    <span>_xor_output</span> <span>=</span> <span>0x70</span>

<span>def</span> <span>bmw_3fd_crc</span><span>(</span><span>message</span><span>):</span>
    <span>return</span> <span>BMW3FDCRC</span><span>.</span><span>calc</span><span>(</span><span>message</span><span>)</span> <span>&amp;</span> <span>0xFF</span>

<span>def</span> <span>confirm_working_checksum</span><span>(</span><span>bus</span><span>,</span> <span>message</span><span>):</span>
    <span>&#34;&#34;&#34;Simple function to use the DTCs to check if bmw_3fd_crc() returns correct values&#34;&#34;&#34;</span>
    <span>return</span> <span>verify_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>bmw_3fd_crc</span><span>(</span><span>message</span><span>)]</span> <span>+</span> <span>message</span><span>)</span>
</code></pre></div>
<div><pre><span></span><code><span>In</span> <span>[</span><span>49</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>confirm_working_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x23</span><span>,</span> <span>0x33</span><span>,</span> <span>0x44</span><span>,</span> <span>0x55</span><span>])</span>
<span>Out</span><span>[</span><span>49</span><span>]:</span> <span>True</span>

<span>In</span> <span>[</span><span>50</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>confirm_working_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x23</span><span>,</span> <span>0x33</span><span>,</span> <span>0x44</span><span>,</span> <span>0x77</span><span>])</span>
<span>Out</span><span>[</span><span>50</span><span>]:</span> <span>True</span>

<span>In</span> <span>[</span><span>51</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>confirm_working_checksum</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x23</span><span>,</span> <span>0x33</span><span>,</span> <span>0x44</span><span>,</span> <span>0x99</span><span>])</span>
<span>Out</span><span>[</span><span>51</span><span>]:</span> <span>True</span>
</code></pre></div>
<p>Looking good...</p>
<h2>&#34;Guess&#34; the counter field</h2>
<p>The next DTC to tackle was E04902 &#34;not current&#34;, probably relating to the counter field.</p>
<p>I probably could have guessed at this point that message byte 1 was the counter, after the checksum. Just in case, I made another function that ran through all four possible bytes or half bytes (masks 0xFF, 0xF0, 0x0F) and sent a sequence of messages &#34;counting&#34; with that byte, then looked for the E04902 <em>not current</em> DTC to see if it was still actively failing.</p>
<p>This confirmed that byte 1, or at least some of its bits, was the counter value.</p>
<h2>Arbitrary data payloads</h2>
<p>So, the message structure for ID 0x3FD looks like:</p>
<table>
<thead>
<tr>
<th>Byte</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>CRC8 (init=0x0, poly=0x1d, xor=0x53) of bytes 1-4</td>
</tr>
<tr>
<td>1</td>
<td>Counter value (must increment each message)</td>
</tr>
<tr>
<td>2</td>
<td>Payload byte 0</td>
</tr>
<tr>
<td>3</td>
<td>Payload byte 1</td>
</tr>
<tr>
<td>4</td>
<td>Payload byte 2</td>
</tr>
</tbody>
</table>
<p>With yet another experimental function, it&#39;s possible to input arbitrary three byte payloads and have the function send a valid CAN message repeatedly every 100ms for 3 seconds, with the counter value incrementing correctly:</p>
<div><pre><span></span><code><span>def</span> <span>send_gws_status</span><span>(</span><span>bus</span><span>,</span> <span>status_bytes</span><span>,</span> <span>tx_seconds</span><span>=</span><span>3</span><span>):</span>
    <span>counter</span> <span>=</span> <span>0</span>
    <span>t0</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span>

    <span>while</span> <span>time</span><span>.</span><span>time</span><span>()</span> <span>&lt;</span> <span>t0</span> <span>+</span> <span>tx_seconds</span><span>:</span>
        <span>payload</span> <span>=</span> <span>[</span><span>counter</span> <span>&amp;</span> <span>0xFF</span><span>]</span> <span>+</span> <span>status_bytes</span>
        <span>payload</span> <span>=</span> <span>[</span><span>bmw_3fd_crc</span><span>(</span><span>payload</span><span>)]</span> <span>+</span> <span>payload</span>
        <span>message</span> <span>=</span> <span>can</span><span>.</span><span>Message</span><span>(</span><span>arbitration_id</span><span>=</span><span>0x3FD</span><span>,</span>
                              <span>data</span><span>=</span><span>payload</span><span>,</span> <span>is_extended_id</span><span>=</span><span>False</span><span>)</span>
        <span>message</span><span>.</span><span>channel</span> <span>=</span> <span>0</span>
        <span>bus</span><span>.</span><span>send</span><span>(</span><span>message</span><span>)</span>

        <span>time</span><span>.</span><span>sleep</span><span>(</span><span>0.1</span><span>)</span>
        <span>counter</span> <span>+=</span> <span>1</span>
</code></pre></div>
<div><pre><span></span><code><span>In</span> <span>[</span><span>88</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>send_gws_status</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x80</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>])</span>

<span>In</span> <span>[</span><span>89</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>send_gws_status</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x40</span><span>,</span> <span>0x40</span><span>,</span> <span>0x40</span><span>])</span>

<span>In</span> <span>[</span><span>90</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>send_gws_status</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0x20</span><span>,</span> <span>0xff</span><span>,</span> <span>0xff</span><span>])</span>

<span>In</span> <span>[</span><span>91</span><span>]:</span> <span>bmw_gws_uds</span><span>.</span><span>send_gws_status</span><span>(</span><span>bus</span><span>,</span> <span>[</span><span>0xa0</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>])</span>
</code></pre></div>
<p>Now it&#39;s possible to experiment with different values in the payload bytes, and see what happens. Sure enough, the gear selector started to respond:</p>
<p><a href="https://www.projectgus.com/images/2022-06/gws_in_drive.webp"><img alt="BMW GWS with Drive LED lit" src="https://www.projectgus.com/images/2022-06/derivatives/article/1x/gws_in_drive.webp" srcset="https://www.projectgus.com/images/2022-06/derivatives/article/1x/gws_in_drive.webp 1x, https://www.projectgus.com/images/2022-06/derivatives/article/2x/gws_in_drive.webp 2x, https://www.projectgus.com/images/2022-06/derivatives/article/4x/gws_in_drive.webp 4x"/></a></p>
<p>Decent effort to light an LED! Champagne, anyone?</p>
<p>Stay tuned for more about these CAN messages, and some &#34;gearbox simulator&#34; code to use it all together - coming soon in Part Three.</p>
<p>The code used in this post for experimentation, sometimes with some extra checks or features, can all be found in <a href="https://github.com/projectgus/car_hacking/tree/main/bmw_gear_selector">this car_hacking repository</a>.</p>
</div></div>
  </body>
</html>
