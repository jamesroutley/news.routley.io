<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://esoteric.codes/blog/yayimhere-interview">Original</a>
    <h1>Interview with yayimhere</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p><img src="https://blog.booleanbiotech.com/uploads/441d0ae6-a564-423a-9e62-675d780876f7/yayimhere_wide.png" alt="" width="" height=""/></p>
<p><em>yayimhere&#39;s dream-inspired work uncovers subtle anomalies and contradictions in the strict logic of minimalist systems.</em></p>
<p><strong>» How did you discover esolangs and drew you to this form in the beginning? </strong></p>
<p>I only partly remember how I got into esolanging itself. I think the reason was <a href="https://esolangs.org/w/index.php?search=Malbolge&amp;title=Special%3ASearch" target="_blank" rel="noopener">Malbolge</a>. It was so interesting to me, that you could make something so hard to use! Because of that, my first esolangs (now deleted, since I don&#39;t even remember how they work anymore) were goto-based, and self-modifying in one way or the other. </p>
<p><em>[See also: <a href="https://esoteric.codes/blog/interview-with-ben-olmstead" target="_blank" rel="noopener">interview with Ben Olmstead</a>, creator of Malbolge]</em></p>
<p><strong>» Tell me about your approach to esolanging / esoprogramming. You seem to have many languages that relate in some way to Minsky machines. Could you explain what a Minsky machine is and why you are drawn to that architecture? </strong></p>
<p>Most of my esolangs are made along the lines of:</p>
<ul>
<li aria-level="1">Read another esolang, and highly overthink one very very specific feature<span>, </span><span>quote</span><span>, or programming</span> method from it.</li>
<li aria-level="1">Come up with a half concept for something using that.</li>
<li aria-level="1">In my sleep make the precise command set</li>
<li aria-level="1">And wake up in the morning, with a whole programming language!</li>
</ul>
<p>Which I think you can see in languages like <a href="https://esolangs.org/wiki/Hexad" target="_blank" rel="noopener">hexad</a>, which is a strange self modifying language where reading and writing basically is impossible. This originated from a single quote on the <a href="https://esolangs.org/w/index.php?search=WUUI&amp;title=Special%3ASearch" target="_blank" rel="noopener">WUUI</a> page: &#34;It is currently unclear whether such a memory structure can be reliably set up under WUUI&#39;s rules&#34;. <span>This then made me wonder, is it possible to make every structure unreliable. And after a while, I had a language.</span></p>
<p>Now onto Minsky machines.</p>
<p>Minsky machines are a type of counter machine.</p>
<p>Counter machines are generally just an <a href="https://esolangs.org/w/index.php?search=FSA&amp;title=Special%3ASearch" target="_blank" rel="noopener">FSA</a>&#39;s hooked up to one or two <em>counters</em>. One of these is the <a href="https://esolangs.org/w/index.php?search=Minsky%20Machine&amp;title=Special%3ASearch" target="_blank" rel="noopener">Minsky Machine</a>, which comes up a lot in my esolangin&#39;. A Minsky Machine can &#34;increment&#34; and &#34;decrement and check if zero, if yes jump one place, if no jump another&#34;.</p>
<p>I&#39;m probably drawn to these out of circumstance. Many of the languages i like are proven Turing Complete, via proof by a Minsky machine. <span>And also many languages are derived from them. They truly aren&#39;t the most interesting machines.</span></p>
<p><strong>» You seem to be an avid esoprogrammer as well as esolanger. What esolangs by others have you spent the most time with? What&#39;s your usual approach when you&#39;re experimenting with a new esolang; do they mostly run in your head, or do you do significant programming in existing languages to understand them?</strong></p>
<p>Thanks! Most esolangs I work with sort of run in my head until I eventually try and type it out, to look what might be wrong. Then I do that again, until I&#39;ve created something. I usually trust my mind quite a bit when doing this. </p>
<p>I&#39;ve spent a lot of time with brainfuck, as well as <a href="https://esolangs.org/wiki/Topple" target="_blank" rel="noopener">Topple</a> (which I was first to prove Turing Complete). Others are SUBLEQ, Underload, Sike, Unlambda, and the non-esoteric lambda calculus. <span>I&#39;ve also spent quite a bit on </span><a href="https://esolangs.org/w/index.php?search=ErrorBucket&amp;title=Special%3ASearch"><span>ErrorBucket</span></a><span>, but not in writing programs.</span></p>
<p>I think from this point, it&#39;s a good jumping off point to talk about my favorite esolangs, how I got to them, and how I make esolangs. </p>
<p>The story of how I got here, to my &#34;style&#34; of today will lead me to mention one of my esolangs, called <a href="https://esolangs.org/w/index.php?search=Bring%20to%20another&amp;title=Special%3ASearch" target="_blank" rel="noopener">Bring to another</a>. </p>
<p>The unique thing about Bring to another is that no-one knows <em>how</em> it works because I forgot. However, me and another person tried to solve it, and found it to use sub stacks, which as such lead me to make another language, called <a href="https://esolangs.org/w/index.php?search=A%20Question%20of%20Protocol&amp;title=Special%3ASearch" target="_blank" rel="noopener">A Question of Protocol</a>. This is a language where the only data forms are stacks/arrays nested within other stacks. This led to my main four styles: self modification, string rewriting, functional programming, and counter machines. </p>
<p>And for the ones who don&#39;t know what the heck those are, I should probably describe these shortly. String rewriting systems are just systems where strings of characters are rewritten, like the <a href="https://esolangs.org/w/index.php?search=Bitwise%20Cyclic%20Tag&amp;title=Special%3ASearch" target="_blank" rel="noopener">Bitwise Cyclic Tag</a>, which I&#39;ve used a lot for proofs of turing completeness, and I&#39;ve also made quite a lot myself. Functional programming is programming based only, or at least mainly, around functions. The purest of these is probably lambda calculus, which languages like Unlambda are built upon. </p>
<p>But how can a sub-stack language lead to all this? Well, during AQOP&#39;s (A Question Of Protocol) development, I was speaking to a whole lot of other esolangers. And this showed me different cool concepts to add to the language, like for example, macros! This led me down the path of self modification and functional programming, which then led me to the <a href="https://esolangs.org/w/index.php?search=SKI%20combinator%20calculus&amp;title=Special%3ASearch" target="_blank" rel="noopener">SKI combinator calculus</a>, and Underload, the latter a language of Ais523 <em>[Ed NOTE: interviewed <a href="https://esoteric.codes/blog/interview-with-ais523" target="_blank" rel="noopener">here</a> and <a href="https://esoteric.codes/blog/ais523-interview-2017" target="_blank" rel="noopener">here</a>]</em>, who is a big inspiration of mine. This then led me down the path of string rewriting, where I got a love for strange ways to change a string<span> (what a strange thing to love). But where do the counter machines come in you may ask! Well, the Minsky Machine came in for the proof of Turing Completeness, because I proved</span> AQoP&#39;s Turing Completeness via compilation/translation from a Minsky Machine. </p>
<p>These influences lead to me discovering some of my favorite languages, all of which influenced me. <a href="https://esolangs.org/w/index.php?search=Underload&amp;title=Special%3ASearch" target="_blank" rel="noopener">Underload</a>, a self-interpreting stack based language (which I mentioned before), <a href="https://esolangs.org/w/index.php?search=Emmental&amp;title=Special%3ASearch" target="_blank" rel="noopener">Emmental</a>, a language that modifies its own interpreter(!), <a href="https://esolangs.org/w/index.php?search=Unlambda&amp;title=Special%3ASearch" target="_blank" rel="noopener">Unlambda</a>, a pretty strange functionally pure (ignoring IO), and, probably most importantly, <a href="https://esolangs.org/w/index.php?search=An%20Odd%20Rewriting%20System&amp;title=Special%3ASearch" target="_blank" rel="noopener">An Odd Rewriting System</a>, which is <em>the</em> string rewriting system to me, because <em>still</em> have no idea how it works. And I guess there&#39;s also <a href="https://esolangs.org/w/index.php?search=P%22&amp;title=Special%3ASearch" target="_blank" rel="noopener">P&#34;</a>, which isn&#39;t really a language but… oh well<span>, it’s brainfuck but formal. </span></p>
<p>This then led to the <a href="https://esolangs.org/w/index.php?search=Do%20Minsk%20Family&amp;title=Special%3ASearch" target="_blank" rel="noopener">Do Minsk Family</a>. This is a family of varying esolangs, with one very simple connection: They are proven turing complete by Minsky Machine compilation (and have inspired each other). However the languages themselves are very different. I&#39;m going to name four languages from this family. These are <a href="https://esolangs.org/w/index.php?search=Karvity&amp;title=Special%3ASearch" target="_blank" rel="noopener">Karvity</a>, The Last Question (yes, named after <a href="https://en.wikipedia.org/wiki/The_Last_Question" target="_blank" rel="noopener">the Isaac Asimov story)</a> or <a href="https://esolangs.org/w/index.php?search=TLQ&amp;title=Special%3ASearch" target="_blank" rel="noopener">TLQ</a>, <a href="https://esolangs.org/w/index.php?search=Goto%20tag&amp;title=Special%3ASearch" target="_blank" rel="noopener">Goto tag</a>, and <a href="https://esolangs.org/w/index.php?search=Combine%20and%20continue&amp;title=Special%3ASearch" target="_blank" rel="noopener">Combine and continue</a>. Karvity is a modified version of a Minsky machine, which was created as a &#34;church numeral&#34; version. Church numerals is a form of numbers made in lambda calculus. If you pass any function to a church numeral (remember, in lambda calculus everything is a function), it gets repeated by the numerals value. In Karvity, each line is a loop over the rest of the program. Karvity is important because it showed me that new things can be done with a counter machine, like what Karvity is (in my opinion).</p>
<p>This inspired two other languages, TLQ and Combine and continue. TLQ is basically a language where every goto affects one of the two counters. It was actually made because of my disappointment with another language, called infinite goto. Infinite goto is similar, but every &#34;goto number&#34; has an associated command <span>(or perhaps the jump  lengths)</span>. I was a little sad that these goto&#39;s weren&#39;t generalized to every value however, so I changed that! I think this shows something about my esolangs. Almost all of them is just a process running on some given memory again and again, or something similar. This is what TLQ does, it jumps around the program, while decrementing and incrementing two counters, which is very uniform. I like generalizing, basically. Now, TLQ eventually wasn&#39;t good enough for my want of this &#34;perfect&#34; goto only language, which led me to the Goto tag! Every time a goto happens, it is added to a list. This list will then, when longer than the program, be run. And we just do that forever, similar to the Bitwise Cyclic Tag.</p>
<p>Now, onto Combine and Continue (I&#39;ve lost track of the capitalizing for this language). Its idea was, what if I took these church numerals from Karvity, and let it repeat instructions on the stack, <a href="https://esoteric.codes/blog/interview-with-ais523" target="_blank" rel="noopener">Underload</a>-style. It was pretty fun to make, and shows pretty well how the Do Minsky Family developed. I extracted something from one of the languages that came up inside of it, and put it directly into a new system that also fascinated me. This made it a very fun process.</p>
<p>Now, <span>since we are talking about minsky machines n’ all that, i want to bring up my</span> <a href="https://esolangs.org/w/index.php?search=Short%20Minsky%20Machine%20Notation&amp;title=Special%3ASearch" target="_blank" rel="noopener">Short Minsky Machine Notation</a>, which further leads me to something interesting. SMMN was made purely out of necessity. Along those lines, all intermediate languages are middle men between two languages, for compilation. I am always so fascinated by these languages, because I have no idea how someone could come up with them, and hearing their back stories is so cool. For example, <a href="https://esolangs.org/w/index.php?search=ErrorBucket&amp;title=Special%3ASearch" target="_blank" rel="noopener">ErrorBucket</a> is an intermediate language between a sort of <a href="https://esolangs.org/w/index.php?search=Cyclic%20tag%20system&amp;title=Special%3ASearch" target="_blank" rel="noopener">Cyclic tag system</a>, and the <a href="https://esolangs.org/w/index.php?search=I%2FD%20machine&amp;title=Special%3ASearch" target="_blank" rel="noopener">I/D machine</a>. It was so interesting to hear about how it was come up with! It happens that in the cases where I would need one are <em>very</em> rare. And in the case where I would need one (like <a href="https://esolangs.org/w/index.php?search=Uncompetition&amp;title=Special%3ASearch" target="_blank" rel="noopener">Uncompetition</a>, which is one of the most cursed language <em>ever</em>), it usually ends up being too hard for me.</p>
<p><strong>» </strong><strong>Are sub stacks simply &#34;stacks/arrays nested within other stacks&#34; (as you describe AQoP)?</strong></p>
<p>I&#39;d say they are just nested arrays (but they could probably be expanded, like nested stacks and queues). But you can do a lot more with them than with normal stack without this nesting, data wise (which I&#39;ll talk about in a bit), or at least more easily. But I think I&#39;m drawn to them in a less programming way and more &#34;symbolic&#34; or art-sy way. It&#39;s similar to fractals. Infinitely nesting within themselves again and again and again, and so on. It&#39;s artful, in some way or the other, and I think that subconsciously, my goal is to create something artful or beautiful with my esolangs (which is why I also like language like Malbolge, because they look like art, just random characters, but they actually mean something!). I&#39;ve slowly begun realizing this goal more consciously, credit to esoteric.codes for that. But also, computationally, they are interesting, because it lets you keep lots of different data in different places. It&#39;s probably, to me, one of the more complex data structures, because you can build a lot of things. I will also probably make a whole new language based on this data structure in the future, maybe even one more useful and less esoteric (if I&#39;m able to do that).</p>
<p><strong>» </strong><strong>Your main styles: string rewriting, combinators, self-modification etc, are all minimalist in a way (most lead to languages with small lexicons, for instance). Also, &#34;running on some given memory again and again,&#34; has its own strange efficiency (also, btw, is that part of what you find fascinating in Malbolge?). Is the minimalism of language definition itself important to you or is there something else these concepts all have in common for you? (Also, have you experimented with OISCs at all?)</strong></p>
<p><span>I do like the simplicity, and find some level of importance in having it. One part of it is a frustration with most actual programming languages, because they all have these closed systems that can&#39;t interact with each other, or at least have a hard time doing so. You don&#39;t have like, a universal stack, or similar. You don&#39;t have this big thing linking everything. </span>It&#39;s all over the place, and I think this draws me away from most languages, which probably, again in my subconscious, led me to esolangs. So as said, there is some importance to me of having a simple system (though, to be honest, some of my esolangs are only simple if you look at it from the perspective of the creator). But there&#39;s another thing that draws me to these systems, and it is, what strange programming method that may come up with this hyper simple language, because you are restricted to such simple systems(which especially happens with that concept of data repeatedly being manipulated by the same process). But I&#39;m also slightly drawn to those systems because they can have very interesting interactions, if you just throw away all logic of using them. This especially happens with lambda calculus, because you can for example, take the square root of the pair creating function. Here, I bring up the first language of this long response, a language of mine called Utral, which does computation, using only a null value, and negation. But it&#39;s based in lambda calculus, and all of a sudden it actually works/makes sense, and I&#39;ve been able to program lots of different functions with it. Now that you mention it, Utral is probably the closest I&#39;ve gotten to an OISC. To answer your question on OISC&#39;s, I&#39;ve never really experimented with them, but sometimes, I end up accidentally reducing my language to an OISC, or very very near OISC. But, back on topic, I like most of these systems because they are simplistic, yet lead to a strange, almost magical feeling, to a person without knowledge on how it works, on how this language can do what it does. This is of course similar to that want of an artful language I mentioned before.</p>
<p><strong>» Utral speaks of an un-neutral, the negation of the null, where null is ordinarily understood as neither positive or negative. Also, it offers parentheses to wipe out mention of a parameter. Is it primarily a language of emptiness and deletion? What inspired the language, and does it have specific influences?</strong></p>
<p>I think it&#39;s quite funny that you noticed the parenthesis thing. I think it&#39;s one of those things I just do, because I think parameters look ugly. On the topic of &#34;how something looks&#34;, </p>
<pre><code>-(-()-())</code></pre>
<p>Which already resembles how utral looks. The only thing I had to do from that point was figure out how to negate a null. The obvious way to me was just to implement it in lambda calculus. And then, I found a negation function, and implemented a null.</p>
<p>I hadn&#39;t actually thought of it as being empty, but it is one of deletion, and in fact, it&#39;s the only way to achieve… Well, anything at all. But it probably is pretty &#34;empty&#34; (in fact, I&#39;ve found every possible function is affine, every input has one or less instance in the output). </p>
<p>Inspiration-wise, it&#39;s actually quite the isolated esolang, with the only influence being Unlambda&#39;s <code>`</code>, which is replaced with the prefix version &#34;<code>.</code>&#34;.</p>
<p>One strange feature of <code>-null</code>, is that double negation doesn&#39;t return to its original value. The reason for this is obvious: a lambda function cannot naturally return nothing. But it does show an observation that I think we need to recognize, and some probably already do: The weirder a value gets, the less and less we can trust what we think is always true. And even less can we trust what we think is impossible.</p>
<p><strong>» How do you make decisions about which esolangs to implement? Are there languages of yours that you feel can be &#34;solved&#34; by discovering its capabilities (or computational class), apart from the actual act of writing programs for it directly?</strong></p>
<p>The reason why I usually don&#39;t implement my languages are for two reasons: 1. I&#39;m terrible at interpreting syntax, and more interestingly 2. That my languages are <em>strange</em>. And when I say strange I don&#39;t just mean that it uses a tape and no variables, for example. I mean, that they function in a way that just is really hard to describe in context of another language. Take <a href="https://esolangs.org/wiki/Turtle_just_want_to_dig" target="_blank" rel="noopener">Turtle just want to dig</a> for example. It&#39;s a pretty simple 2d language, but behaves pretty strangely, even stranger than Befunge, because of the movement mechanics. As such, it would be pretty hard to implement. This leads me onto a point that, to this day, still fascinates me. Most formal systems–and esolangs–do &#34;simple behaviour&#34;. But a lot of that behaviour isn&#39;t easily describable to a computer. One could perhaps even define esolangs as languages hard to define to a computer, but easy to define to a human (though I don&#39;t think we should adopt this, since a lot of languages would be excluded). And I think maybe this is why esolanging <em>is</em> an art. It defies how a computer <em>should</em> operate, for something that instead is for humans. And, just perhaps, implementing them, defies that, even though slight? I&#39;m not here to argue for or against that, and I am one to try and get better at implementing, but, food for thought!</p>
<p><strong>» </strong><strong>Could you expand on how Karvity does something new with counter machines?</strong></p>
<p>Oh karvity, the second child nobody wanted (Lul). karvity is one of those languages that are hard to describe to a computer. It&#39;s also one of the few languages I&#39;ve made that is kind of hard to explain. This however comes from it packing a lot of different functions into a single control flow operator. That control flow operator basically calls the whole program following the operator, with one extra command added onto it, and then we repeat this called code as many times as the current counter. You could, in principle, write this as pseudo-code:</p>
<pre><code>While I&lt;=cur_count:
    Apply call extra_com
    I++</code></pre>
<p>(Note: giving a program as an argument to and instruction in an imperative language, is basically just appending that command to the end of the program, since reverse polish notation.)</p>
<p>As you can see, this is quite the strange construct for an imperative language, since a call/cc command is more common to functional programming languages. You could even, if you &#34;convert&#34; the counter value to a church numeral, write this as:</p>
<pre><code>Apply church(cur_count) (call extra_com)</code></pre>
<p>Which is, once again, quite the strange construct of a conditional for an imperative language! This actually brings me to a thing I&#39;ve been thinking about doing recently. I see in more and more of my esolangs, a mix of imperative constructs and functional constructs coming up as commands. As such, I had the idea to make a mix of the two, using some more basic imperative and functional operators, instead of the highly strange ones that come up when they build within me only subconsciously blending imperative and functional.   </p>
<p>There is something I want to bring up with this. I think that this constant subconscious influence happening is very similar to art. You&#39;ll make it at the time and find you just took some choices without any real thought behind them. But then you come back later, and find some meaning in those choices. As you can see, this is the exact same thing happening to me! </p>
<p><strong>» What do you remember of creating Bring to another? You have apparently </strong><a href="https://hackmd.io/vhBWPdmIRTK6mCFlrev1QA" target="_blank" rel="noopener"><strong>many example programs to work from</strong></a><strong> but somehow the language itself is lost! What is the story of its creation and attempted recovery?</strong></p>
<p>Bring to another is a language that to this day mystifies me, both in the way of &#34;how does it work?&#34; (or you could say, Waduzitdo?), and &#34;How did I forget this?&#34;. However I am quite surprised how complex it is, and it originates from many concepts I use now (as I mentioned at the start of the interview). But it&#39;s really just a question, and I don&#39;t have much to say! Sadly, we just still don&#39;t know that much yet. Hopefully, this is a call to someone here to try and solve it. I&#39;ve personally abandoned it though, and I more so look at it for new ideas sourced from our theories on the language. Hopefully it inspires others as well. </p>
<p><strong>» UnCompetition reminds me a bit of Chris Pressey&#39;s <a href="https://esolangs.org/wiki/You_are_Reading_the_Name_of_this_Esolang" target="_blank" rel="noopener">You are Reading the Name of this Esolang</a>, in how they bring another aspect of computation into the act of writing code. Could you expand on what is a &#34;solution&#34; to an UnCompetition (sub-)program, and what is the experience of writing code in the language?</strong></p>
<p>I hadn&#39;t heard of You are Reading the Name of this Esolang before! I do see the similarity. Now, what is the solution to an UnCompetition program? I think this is best explained by an analogy. Say you give a student a writing task, with a few rules. These rules are the conditions defined in an UnCompetition program, and what the student writes, is one of the generated programs. Now we just give this to a bunch of students, until they&#39;ve made all the unique ones. Every one of the things written is a solution. Then we simply take each written piece, and put it as the conditions, and do this until the conditions become too strict, and it&#39;s impossible to write any more. This of course leads to a process of writing programs, that barely is programming and is… It&#39;s actually more similar to twisting the knobs on an AI system. You change the conditions again and again, until you just find what you want. A brute force method is probably the most effective. From what few programs I&#39;ve made, it&#39;s very hard. The biggest thing to achieve is constants, and variables, etc. I did make a single program that was the constant 1, which is:</p>
<pre><code>~!</code></pre>
<p>Here, <code>!</code> means &#34;Solution must be different&#34;, and <code>~</code> is a logical negation of the condition. As such the program says &#34;The solution must not be different&#34;.</p>
<p>But overall, it&#39;s very difficult to program in, and I&#39;m actually still working on figuring it out.</p>
<p><strong>» Could you explain language <a href="https://esolangs.org/wiki/2I1IF" target="_blank" rel="noopener">2I1IF</a> in simple terms? Does it require infinitely large programs?</strong></p>
<p>2I1IF is a family of languages, with the property that they can either be thought of as a universal function operating on some data, or, a potentially infinite set of functions that has one universal input. One of these languages is Uncompetition. The universal function could be the &#34;solver&#34; which finds all the solutions. But you could also consider each program as a function, with the input simply triggering it to find the solutions and then send the next triggers. There are three stricter subsets, called Sinistry, 2M1, and Metastry, the last of which is a combination of the first two.</p>
<p>In Sinistry, an infinite amount of outputs must be possible. Uncompetition falls in this category.</p>
<p>In 2M1, standing for Meta 2I1IF, the program can modify the universal function/input during runtime, requiring a way to switch between the two.</p>
<p>Then Metastry just combines the two requirements of Sinistry and 2M1.</p>
<p>2I1IF originated from my search of a Turing Completeness proof of Uncompetition, in which I found out both these interpretations existed. Then I realized that it&#39;s something probably pretty common. And as such, I described it! But to answer your question, it doesn&#39;t require infinite programs. Which is great!</p>
<p><strong>» The <a href="https://esolangs.org/wiki/Apraxia" target="_blank" rel="noopener">Apraxia</a> lang, named for brain damage, takes on the &#34;pattern based esolang,&#34; a descriptor often misused (in a sense, all code is pattern based, but usually the lexicon is not really a pattern). What was your approach to this language? Is it true that any string is valid code in the language?</strong></p>
<p>My approach was really just, come up with a concept, then generalize it for all strings and symbols. The biggest challenge was, &#34;how do I modify and define data when there&#39;s no way to differentiate those two actions&#34;. I needed to be able to do that, because I had the secondary of being Turing complete(another open question to one of the readers).</p>
<p>In fact, I did tell the truth, Apraxia can interpret any string… IF it&#39;s &gt;1 character in length. That&#39;s the only issue with that statement (but I do say it in the article). </p>
<p>But I do actually have a call to everyone. Stop calling everything pattern based. Most languages aren&#39;t. I can only name two that truly are, which is Apraxia, and Incident (which was the inspiration). So, Stop!!! Lol.</p>
<p><strong>» Are there programs yet for languages of yours that surprised you or made you understand the language in a new way?</strong></p>
<p>There are two specific cases (languages, not programs). First there is the infinite loop in Apraxia:</p>
<pre><code>XCYCC</code></pre>
<p><span>Which was so very surprising that it worked! It’s so short, and works very simply. Also, if you want it to look cooler, here’s one using greek characters (which also uses a very slightly cooler definition):</span></p>
<pre><code>εωσεω</code></pre>
<p>Very cool maths I know (lol). </p>
<p>I have discovered that Apraxia very often gets into that type of loop.</p>
<p>I was also quite surprised by the copying function(defined as <code>:(x)=c((x)(x))</code>), which can be produced simply by an empty variable:</p>
<pre><code>:c</code></pre>
<p>(Note that the <code>c</code> must end the program)</p>
<p>Next is is the program:</p>
<pre><code>:/</code></pre>
<p>They aren&#39;t made by me btw (credit to Kaveh Yousefi on the esolangs wiki, who made an implementation and made the examples). </p>
<p>This program uses my language <a href="https://esolangs.org/wiki/;;;" target="_blank" rel="noopener">;;;</a>. It writes a 1 to one cell of memory, then moves onto the next one. It really surprised me how the commands behave, but they behave very well together. : is an increment, and moves to the right, and / decrements 0, which goes to the start of the program.</p>
<p>But yea, I&#39;m very happy to find that my languages actually produce interesting programs.</p>
<p><strong>» What advice do you have for people starting out with esolangs?</strong></p>
<p>To any new esolanger designer, don&#39;t make what seems useless or funny<span>, or whatever,</span> <em>to everyone else.</em> Make the esolang you would have wished to be in the light. And don&#39;t focus too much on being the next new giant thing, nor making an implementation. Just go out there and do it.</p>
            </div></div>
  </body>
</html>
