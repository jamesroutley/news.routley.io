<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gkbrk.com/2016/05/hotel-music/">Original</a>
    <h1>Reverse engineering a mysterious UDP stream in my hotel (2016)</h1>
    
    <div id="readability-page-1" class="page"><div> <p>Hey everyone, I have been staying at a hotel for a while. It’s one of those modern ones with smart TVs and other connected goodies. I got curious and opened Wireshark, as any tinkerer would do.</p> <p>I was very surprised to see a huge amount of UDP traffic on port 2046. I looked it up but the results were far from useful. This wasn’t a standard port, so I would have to figure it out manually.</p> <p>At first, I suspected that the data might be a television stream for the TVs, but the packet length seemed too small, even for a single video frame.</p> <blockquote> <p>This article is also available in <a href="http://linuxfr.org/news/son-et-lumiere-a-l-hotel" rel="nofollow noopener" target="_blank">French</a>.</p> </blockquote> <h3 id="grabbing-the-data">Grabbing the data</h3> <p>The UDP packets weren’t sent to my IP and I wasn’t doing ARP spoofing, so these packets were sent to everyone. Upon closer inspection, I found out that these were <strong>Multicast</strong> packets. This basically means that the packets are sent once and received by multiple devices simultaneously. Another thing I noticed was the fact that all of those packets were the same length (634 bytes).</p> <p>I decided to write a Python script to save and analyze this data. First of all, here’s the code I used to receive Multicast packets. In the following code, <em>234.0.0.2</em> is the IP I got from Wireshark.</p> <div><div><pre><code><span>import</span> <span>socket</span>
<span>import</span> <span>struct</span>

<span>s</span> <span>=</span> <span>socket</span><span>.</span><span>socket</span><span>(</span><span>socket</span><span>.</span><span>AF_INET</span><span>,</span> <span>socket</span><span>.</span><span>SOCK_DGRAM</span><span>,</span> <span>socket</span><span>.</span><span>IPPROTO_UDP</span><span>)</span>
<span>s</span><span>.</span><span>setsockopt</span><span>(</span><span>socket</span><span>.</span><span>SOL_SOCKET</span><span>,</span> <span>socket</span><span>.</span><span>SO_REUSEADDR</span><span>,</span> <span>1</span><span>)</span>
<span>s</span><span>.</span><span>bind</span><span>((</span><span>&#39;&#39;</span><span>,</span> <span>2046</span><span>))</span>

<span>mreq</span> <span>=</span> <span>struct</span><span>.</span><span>pack</span><span>(</span><span>&#34;4sl&#34;</span><span>,</span> <span>socket</span><span>.</span><span>inet_aton</span><span>(</span><span>&#34;234.0.0.2&#34;</span><span>),</span> <span>socket</span><span>.</span><span>INADDR_ANY</span><span>)</span>
<span>s</span><span>.</span><span>setsockopt</span><span>(</span><span>socket</span><span>.</span><span>IPPROTO_IP</span><span>,</span> <span>socket</span><span>.</span><span>IP_ADD_MEMBERSHIP</span><span>,</span> <span>mreq</span><span>)</span>

<span>while</span> <span>True</span><span>:</span>
    <span>data</span> <span>=</span> <span>s</span><span>.</span><span>recv</span><span>(</span><span>2048</span><span>)</span>
    <span>print</span><span>(</span><span>data</span><span>)</span>
</code></pre></div></div> <p>On top of this, I also used <a href="https://docs.python.org/3.5/library/binascii.html" rel="nofollow noopener" target="_blank">binascii</a> to convert this to hex in order make reading the bytes easier. After watching thousands of these packets scroll through the console, I noticed that the first ~15 bytes were the same. These bytes probably indicate the protocol and the packet/command ID but I only received the same one so I couldn’t investigate those.</p> <h3 id="audio-is-so-lame">Audio is so LAME</h3> <p>It also took me an embarrassingly long time to see the string <code>LAME3.91UUUUUUU</code> at the end of the packets. I suspected this was MPEG compressed audio data, but saving one packet as test.mp3 failed to played with mplayer and the <em>file</em> utility only identified this as <code>test.mp3: data</code>. There was obviously data in this packet and <em>file</em> should know when it sees MPEG Audio data, so I decided to write another Python script to save the packet data with offsets. This way it would save the file <code>test1</code> skipping 1 byte from the packet, <code>test2</code> skipping 2 bytes and so on. Here’s the code I used and the result.</p> <div><div><pre><code><span>data</span> <span>=</span> <span>s</span><span>.</span><span>recv</span><span>(</span><span>2048</span><span>)</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>25</span><span>):</span>
    <span>open</span><span>(</span><span>&#34;test{}&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span><span>),</span> <span>&#34;wb+&#34;</span><span>).</span><span>write</span><span>(</span><span>data</span><span>[</span><span>i</span><span>:])</span>
</code></pre></div></div> <p>After this, I ran <code>file test*</code> and voilà! Now we know we have to skip 8 bytes to get to the MPEG Audio data.</p> <div><div><pre><code><span>$</span><span> </span>file <span>test</span><span>*</span>
<span>test0:    data
test1:    UNIF v-16624417 format NES ROM image
test10:   UNIF v-763093498 format NES ROM image
test11:   UNIF v-1093499874 format NES ROM image
test12:   data
test13:   TTComp archive, binary, 4K dictionary
test14:   data
test15:   data
test16:   UNIF v-1939734368 format NES ROM image
test17:   UNIF v-1198759424 format NES ROM image
test18:   UNIF v-256340894 format NES ROM image
test19:   UNIF v-839862132 format NES ROM image
test2:    UNIF v-67173804 format NES ROM image
test20:   data
test21:   data
test22:   data
test23:   DOS executable (COM, 0x8C-variant)
test24:   COM executable for DOS
test3:    UNIF v-1325662462 format NES ROM image
test4:    data
test5:    data
test6:    data
test7:    data
test8:    MPEG ADTS, layer III, v1, 192 kbps, 44.1 kHz, JntStereo
test9:    UNIF v-2078407168 format NES ROM image
</span></code></pre></div></div> <div><div><pre><code><span>while</span> <span>True</span><span>:</span>
    <span>data</span> <span>=</span> <span>s</span><span>.</span><span>recv</span><span>(</span><span>2048</span><span>)</span>
    <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>buffer</span><span>.</span><span>write</span><span>(</span><span>data</span><span>[</span><span>8</span><span>:])</span>
</code></pre></div></div> <p>Now all we need to do is continuously read packets, skip the first 8 bytes, write them to a file and it should play perfectly.</p> <p>But what was this audio? Was this a sneakily placed bug that listened to me? Was it something related to the smart TVs in my room? Something related to the hotel systems? Only one way to find out.</p> <div><div><pre><code><span>$</span><span> </span>python3 listen_2046.py <span>&gt;</span> test.mp3
<span>* wait a little to get a recording *
^C

</span><span>$</span><span> </span>mplayer test.mp3
<span>MPlayer (C) 2000-2016 MPlayer Team
224 audio &amp; 451 video codecs

Playing test.mp3.
libavformat version 57.25.100 (external)
Audio only file format detected.
=====
Starting playback...
A:   3.9 (03.8) of 13.0 (13.0)  0.7%
</span></code></pre></div></div> <h3 id="the-revelationdisappointment">The Revelation/Disappointment</h3> <p>What the hell? I can’t believe I spent time for this. It’s just elevator music. It is played in the hotel corridors around the elevators. Oh well, at least I can listen to it from my room now.</p> </div></div>
  </body>
</html>
