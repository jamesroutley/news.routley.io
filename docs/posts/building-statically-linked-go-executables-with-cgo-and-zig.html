<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://calabro.io/zig-cgo">Original</a>
    <h1>Building Statically Linked Go Executables with CGO and Zig</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <div>
                    <h4>Building Statically Linked Go Executables with CGO and Zig</h4>
                    </div>
                
                
<p>
    This is a short post about how to create a statically linked Go executable that calls in to CGO dependencies using Zig. The full code for this post is available in <a href="https://github.com/jcalabro/zig-cgo-example" target="_blank">this repo</a>.
</p>
<p>
    By default, if you&#39;re using CGO, the executable you generate dynamically links, but I frequently want to statically link to avoid runtime errors.
</p>
<p>
    First, let&#39;s create a zig library, with <strong>zig init</strong>, then trim back the excess stuff it generates so we&#39;re left just with a simple static library. You can <strong>rm src/main.zig</strong> since we&#39;re not creating a zig executable.
</p>
<p>
    Next, we can trim <strong>build.zig</strong> to just:
</p>
<pre><code>// build.zig
const std = @import(&#34;std&#34;);

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const lib_mod = b.createModule(.{
        .root_source_file = b.path(&#34;src/root.zig&#34;),
        .target = target,
        .optimize = optimize,
    });

    const lib = b.addLibrary(.{
        .linkage = .static,
        .name = &#34;cgo_static_linking&#34;,
        .root_module = lib_mod,
    });
    b.installArtifact(lib);
}
</code></pre>
<p>
    We can leave the <i>build.zig.zon</i> file alone.
</p>
<p>
    Now, let&#39;s actually write a simple library function that uses the C ABI in <strong>src/root.zig</strong>:
</p>
<pre><code>// src/root.zig
const std = @import(&#34;std&#34;);

pub export fn my_zig_function() void {
    std.debug.print(&#34;Hello from zig!\n&#34;, .{});
}
</code></pre>
<p>
    And its corresponding C header file named <strong>zig_lib.h</strong>:
</p>
<pre><code>// zig_lib.h
#pragma once

void my_zig_function();
</code></pre>
<p>
    That&#39;s it on the zig side! You can build the library now by simply running <strong>zig build</strong>.
</p>
<p>
    Let&#39;s write the Go program that calls it.
</p>
<pre><code>// main.go
package main

/*
#cgo LDFLAGS: -L./zig-out/lib -lcgo_static_linking -static
#include &#34;zig_lib.h&#34;
*/
import &#34;C&#34;
import &#34;fmt&#34;

func main() {
	fmt.Println(&#34;starting program&#34;)
	defer fmt.Println(&#34;done&#34;)

	C.my_zig_function()
}
</code></pre>
<p>
    We&#39;ll now build the Go executable and statically link it with this bash command:
</p>
<pre><code>CC=&#34;zig cc -target x86_64-linux-musl&#34; \
CGO_ENABLED=1 \
CGO_LDFLAGS=&#34;-static&#34; \
GOOS=linux GOARCH=amd64 \
go build -a -ldflags &#39;-extldflags &#34;-static&#34;&#39; main.go
</code></pre>
<p>
    Let&#39;s check our work:
</p>
<pre><code>$ ./main
starting program
Hello from zig!
done

$ ldd ./main
        not a dynamic executable
</code></pre>
<p>
    Looks good to me!
</p>
<p>
    I&#39;m incredibly grateful that I&#39;m building at a time where our tools are getting extremely good. Go and Zig are both amazing!
</p>
<p>
    If you find this useful as I do, perhaps consider making a donation to the <a href="https://ziglang.org/zsf/" target="_blank">Zig Software Foundation</a>!
</p>

            </div></div>
  </body>
</html>
