<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ente.io/blog/monorepo-retrospective/">Original</a>
    <h1>Monorepo â€“ Our Experience</h1>
    
    <div id="readability-page-1" class="page"><div><div><section itemprop="articleBody"><div><p>Nine months ago, we switched to a monorepo. Here I describe our experience with
the switch so far.</p><p>This is not meant as a prescriptive recommendation, but is rather meant as an
anecdotal exposition, in the hope that it might helps other teams make informed
decisions.</p><p>Unlike most forks in the road, we&#39;ve travelled both ones. So first I will
describe the history that lead up to the change, outlining how we&#39;ve already
experienced the alternative non-monorepo setup too in a similar context, and
thus are now well positioned to compare apples to apples.</p><h3 id="platforms-and-monorepos">Platforms and monorepos</h3><p>Ente began its life half a decade ago. It was a meant as a end-to-end encrypted
platform for storing all of Vishnu&#39;s personal data, but two things happened:
Vishnu realized it was not just him that needed such a thing to exist, and he
realized it was going to be a lot of work to build his vision.</p><p>So he became a we, and instead of tackling all personal data, the focus was
shifted to a singular aspect of it, Ente Photos, to get the spaceship off the
ground. To an external observer what looks like a photos app (and that indeed is
our concrete current goal) is driven by an underlying vision of the human right
to the privacy of all forms of personal data.</p><p>Why do I describe all this? Because when viewed in light of this vision, Ente
isn&#39;t a single app, it is a <strong>platform</strong>, and storing its code as a monorepo is
the ideologically appropriate choice.</p><p>This is similar to, say, the Linux kernel. Most people don&#39;t realize that the
biggest open source project in the world, by most metrics imaginable, the Linux
kernel itself, is a monorepo. Even though it is called a <em>kernel</em>, ideologically
it really is the full platform, device drivers and all, and the code
organization as a monorepo reflects that.</p><p>Staying close to the vision of Ente as a platform is not only about the a
ideology, but it has practical offshoots too.</p><p>For example, a few years ago, we realized that there was no good open source
end-to-end encrypted OTP app with cloud backups. So we built one, for our own
use, because it was rather easy to build it on top of the primitives we had
already created for the photos app.</p><p>Today, this side project is the #1 OTP app in the world with the aforementioned
characteristics. This might seem like a happy accident, but it isn&#39;t, this was
always the plan: build a solid platform, then one by one tackle the various
bespoke apps we&#39;ll need to best handle different forms of data.</p><h3 id="microrepos">Microrepos</h3><p>So ideologically Ente is best kept as a monorepo. But it wasn&#39;t one to start
with, due to various historical factors in how the product evolved. What was a
hardware device transitioned into software. The server component was closed
source until we had the bandwidth to get it audited. Weekend projects like Auth
outgrew their reach. Etc.</p><p>Let us rewind the tape back to, say, 2 years ago (just to pick a roughly
symmetrical split). While we have grown since then in all product aspects
including number of developers, we are extremely cautious in adding engineering
headcount, so the number of developers hasn&#39;t grown that much. Thus it is a
similar number of developers working on the same number of products (Ente
Photos, Ente Auth) multiplied by the same number of platforms (mobile, web,
desktop, server, CLI).</p><p>2 years ago, these codebases were spread across a dozen or so repositories.</p><p>In February we decided to take time out to finish the task for open sourcing the
server side. This was a natural point to also rein in the proliferation of
codebases, and we took this as a chance to move to a monorepo.</p><p>So, as a similar sized team doing similar work, we&#39;ve experienced an ~year with
a split microrepo setup, and an ~year with the alternative combined monorepo
setup.</p><h3 id="summary">Summary</h3><p>If I had to summarize the difference: <strong>Moving to a monorepo didn&#39;t change much,
and what minor changes it made have been positive</strong>.</p><p>This is not coming as a surprise to us. Most of us didn&#39;t care strongly about
our repository organization, and overall we weren&#39;t expecting much from changing
it either. The general vibe was a monorepo might be better, and so why not, and
since none of us opposed the choice, we went ahead, but we weren&#39;t trying to
&#34;solve&#34; anything by the change. We were already happy with our development
velocity.</p><p>And indeed, overall it hasn&#39;t changed much. We&#39;re still happy with our
development velocity, so it did not get in our way. There have been many small
wins however, so for the rest of this post I&#39;ll delve deeper into them.</p><h3 id="less-grunt-work">Less grunt work</h3><p>This is the biggest practical win. There is much less grunt work we have to do.</p><p>As an example, take the following pull request. It changed the ML model that is
used for computing on-device face embeddings.</p><p><span>
      <span></span>
  <picture>
        <source srcset="/static/54a05b4a4ca40099ea55a59cbea84c28/a8ad8/pr.webp 160w,/static/54a05b4a4ca40099ea55a59cbea84c28/cb523/pr.webp 320w,/static/54a05b4a4ca40099ea55a59cbea84c28/797b9/pr.webp 640w,/static/54a05b4a4ca40099ea55a59cbea84c28/6c7d1/pr.webp 960w,/static/54a05b4a4ca40099ea55a59cbea84c28/3adf3/pr.webp 1136w" sizes="(max-width: 640px) 100vw, 640px" type="image/webp"/>
        <source srcset="/static/54a05b4a4ca40099ea55a59cbea84c28/86fa0/pr.png 142w,/static/54a05b4a4ca40099ea55a59cbea84c28/fad16/pr.png 284w,/static/54a05b4a4ca40099ea55a59cbea84c28/319f8/pr.png 568w,/static/54a05b4a4ca40099ea55a59cbea84c28/7f797/pr.png 852w,/static/54a05b4a4ca40099ea55a59cbea84c28/7f285/pr.png 1136w" sizes="(max-width: 568px) 100vw, 568px" type="image/png"/>
        <img src="https://ente.io/static/54a05b4a4ca40099ea55a59cbea84c28/319f8/pr.png" alt="Screenshot of the GitHub view of a pull request that changed multiple subsystems in Ente&#39;s repository" title="Screenshot of the GitHub view of a pull request that changed multiple subsystems in Ente&#39;s repository" loading="lazy"/>
      </picture>
    </span></p><p>This change affected (1) the photos mobile app, (2) the photos desktop app, (3)
the photos web app, and (4) the ML scaffolding code itself.</p><p>In the previous, separate repository world, this would&#39;ve been four separate
pull requests in four separate repositories, and with comments linking them
together for posterity.</p><p>Now, it is a single one. Easy to review, easy to merge, easy to revert.</p><h3 id="less-submodules">Less submodules</h3><p>Submodules are an irritating solution to a real problem. The problem is real, so
a solution is welcome, and submodules are indeed an apppropriate solution, but
they&#39;re irritating nonetheless.</p><p>All this is to say, we appreciate the existence of git submodules as a way to
solve practical code organization problems, but we wish we didn&#39;t need to use
them.</p><p>Monorepos reduce the number of places where a submodule would otherwise be
required, and is thus a win.</p><p>As an example, previously the web and desktop codebases for the Ente Photos app
had a submodule relationship. This required a PR dance each time a release had
to be made or some other important change pushed to main. All that&#39;s gone now.
These two interdependent pieces of code now directly refer to each other, and
changes can be made to them atomically in the same commit.</p><h3 id="more-stars">More stars</h3><p>This is the biggest marketing win. Previously our stars were spread out across
the dozen or so repositories. If each had a thousand stars, we&#39;d still have 12k
stars in total, but because of the way both human psychology and GitHub&#39;s
recommendation algorithms work, it&#39;d come off as less impactful than a single
repository with 12k stars.</p><h3 id="easy">Easy</h3><p>One of the concerns we had going into this was that this might impact our
development velocity. We thought we&#39;ll have to invent various schemes and
conventions to avoid stepping on each other&#39;s toes.</p><p>Those concerns turned out to be unfounded. We didn&#39;t invent anything, waiting to
see if the need arose, and it never did. So for an individual engineer in their
day to day work, the move has been easy since we didn&#39;t ask anyone in the team
to change their workflows in any way.</p><p>There still are no &#34;repository wide&#34; guidelines, except two:</p><ol><li>There should not be any repository wide guidelines</li><li>Don&#39;t touch the root folder</li></ol><p>That&#39;s it. Within each folder, or subteam of ourselves, we are otherwise free to
come up with whatever organization or coding conventions or what not.</p><blockquote><p>I do realize that maybe the ease for us was a function of both the relatively
small size of our team, and the amount of trust we have in each others&#39;
competence, and both these factors might not be replicable in other teams.</p></blockquote><h3 id="long-term-refactoring">Long term refactoring</h3><p>Refactoring across repository boundaries requires much more activation energy as
compared to spotting and performing gradual refactorings across folder
boundaries. Technically it is the same, but the psychological barriers are
different.</p><p>As an example, we&#39;ve already merged together many of our disparate web apps into
a similar setup, without needing to make elaborate upfront plans. It happened
easily and naturally, since we could see all of them &#34;next to each other&#34; and
the opportunities for code reuse become obviously apparent.</p><h3 id="connectedness">Connectedness</h3><p>This way of &#34;working in a shared space without working in the same folder&#34; has
lead to us feeling more connected to each other&#39;s work as compared to when,
individually or as subteams, we were all committing to separate repositories.</p><p>Previously, it was easy to get lost in one&#39;s work (in a good way), but sometimes
it lead to the feeling of working on a small part without being able to see the
whole (in a not so good way).</p><p>Now, one can still remain lost in one&#39;s own work in the universe of one&#39;s own
&#34;folder&#34;, so that part of the goodness remains. But there are now also
additional subtle cues that let us see how what we are doing is part of a
interconnected whole. So it&#39;s a win win.</p><p>What I described might be too abstract, so let me give an example. Everytime I
do a <code>git pull</code>, I get to see all the changes that my team mates have been
working on. The names of the recently changed files. The number of changes in
them. The names of the recent branches. The tags that were recently pushed. All
of these individually are very low bit, and imprecise, information vectors, and
I don&#39;t even consciously look at them.</p><p>But what I&#39;ve found over time that, subconsciously and automatically, these
&#34;environmental cues&#34; give me a great sense of &#34;all that is happening around&#34;.
What features are being worked on, what stage of completion they are at, what
bugfixes were pushed, what releases were recently made.</p><p>Similar serendipitious information exchange happens when I, say, open the pull
requests page and without even intending to, I glance at the stuff others are up
to.</p><p>The best part is, all of this is subverbal and effortless. Everybody just does
their thing, and just by virtue of doing them all in the same shared digital
space, arises a sense of awareness and connectedness.</p><h3 id="wrapping-up">Wrapping up</h3><p>This is already too long, much longer than I intended to write, so let me stop
now.</p><p>I could offer tips, but I don&#39;t think there is any secret technical sauce that
is needed. One thing that had bothered me before the move was how will we manage
our GitHub workflows, but that turned out to be trivial since we can scope
GitHub workflows to only run on changes to a specific folder.</p><p>An engineering-mindset retrospective document would be incomplete without both a
Pros and Cons section, but we haven&#39;t really found any cons that have effected
us so far, so excuse that exclusion.</p><p>On a personal level, what I&#39;ve liked most about the move to our monorepo is the
feeling of being part of a juggernaut that is relentlessly rising towards
perfection, and has attained an unstoppable momentum. The code I&#39;m writing is
not an isolated web component or a goroutine or a little documentation fix, it
is now part of this singular platform that will outlive me.</p></div></section></div></div></div>
  </body>
</html>
