<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yuri.is/not-julia/">Original</a>
    <h1>The Julia language has a number of correctness flaws</h1>
    
    <div id="readability-page-1" class="page">








<p>For many years I used the <a href="https://julialang.org/">Julia</a> programming language for transforming, cleaning, analyzing, and visualizing data, doing statistics, and performing simulations.</p>

<p>I published a handful of open-source packages for things like <a href="https://github.com/JuliaGraphics/SignedDistanceFields.jl">signed distance fields</a>, <a href="https://github.com/yurivish/LowDimNearestNeighbors.jl">nearest-neighbor search</a>, and <a href="https://github.com/yurivish/TuringPatterns.jl">Turing patterns</a> (<a href="https://github.com/JuliaWeb/Hyperscript.jl">among</a> <a href="https://github.com/yurivish/Treaps.jl">others</a>), made visual explanations of Julia concepts like <a href="https://julia-guide.netlify.app/broadcasting">broadcasting</a> and <a href="https://observablehq.com/@yurivish/julia-array-notation">arrays</a>, and used Julia to make the generative art on my <a href="https://yuri.is/cardcrafting">business cards</a>.</p>

<p>I stopped using Julia a while ago, but it still sometimes comes up. When people ask, I tell them that I can no longer recommend it. I thought I‚Äôd write up my reasons why.</p>

<p>My conclusion after using Julia for many years is that there are too many correctness and composability bugs throughout the ecosystem to justify using it in just about any context where correctness matters. </p>

<p>In my experience, Julia and its packages have the highest rate of serious correctness bugs of any programming system I‚Äôve used, and I started programming with Visual Basic 6 in the mid-2000s. </p>

<p>It might be useful to give some concrete examples.</p>

<p>Here are some correctness issues I filed:</p>

<ul>
<li><a href="https://github.com/JuliaStats/Distributions.jl/issues/1241">Sampling a probability density produces an incorrect result</a></li>
<li><a href="https://github.com/JuliaStats/StatsBase.jl/issues/642">Sampling an array can produce biased results</a></li>
<li><a href="https://github.com/JuliaLang/julia/issues/39183">The product function can produce incorrect results for 8-bit, 16-bit, and 32-bit integers</a></li>
<li><a href="https://github.com/JuliaStats/StatsBase.jl/issues/616">Fitting a histogram to a Float64 array can produce incorrect results</a></li>
<li><a href="https://github.com/JuliaLang/julia/issues/39385">Base functions sum!, prod!, any!, and all! may silently return incorrect results</a></li>
</ul>

<p>Here are comparable issues filed by others:</p>

<ul>
<li><a href="https://github.com/JuliaStats/StatsBase.jl/pull/632">Summarystats returns NaN quantiles for arrays with mean 0</a></li>
<li><a href="https://github.com/JuliaCollections/OrderedCollections.jl/issues/71">OrderedDict can corrupt keys</a></li>
<li><a href="https://github.com/JuliaLang/julia/pull/36543">Off-by-one error in dayofquarter() in leap years</a></li>
<li><a href="https://github.com/JuliaPhysics/Measurements.jl/issues/64">Incorrect simulation results when using a number type with error bars</a></li>
<li><a href="https://github.com/JuliaLang/julia/issues/36069">Pipeline with stdout=IOStream writes out of order</a></li>
<li><a href="https://github.com/JuliaLang/julia/issues/39460">Wrong results since some <code>copyto!</code> methods don‚Äôt check for aliasing</a></li>
<li><a href="https://github.com/JuliaLang/julia/issues/41096">Wrong if-else control flow</a></li>
</ul>

<p>I would hit bugs of this severity often enough to make me question the correctness of any moderately complex computation in Julia. </p>

<p>This was particularly true when trying a novel combination of packages or functions ‚Äî composing together functionality from multiple sources was a significant source of bugs.</p>

<p>Sometimes the problems would be with packages that don‚Äôt compose together, and other times an unexpected combination of Julia‚Äôs features within a single package would unexpectedly fail.</p>

<p>For example, I found that the Euclidean distance from the Distances package <a href="https://github.com/JuliaStats/Distances.jl/issues/201">does not work with Unitful vectors</a>. Others discovered that Julia‚Äôs function to run external commands <a href="https://github.com/JuliaLang/julia/issues/36406">doesn‚Äôt work with substrings</a>. Still others found that Julia‚Äôs support for missing values <a href="https://github.com/JuliaLang/julia/issues/39362">breaks matrix multiplication in some cases</a>. And that the standard library‚Äôs <code>@distributed</code> macro <a href="https://github.com/JuliaLang/julia/issues/34870">didn‚Äôt work with OffsetArrays</a>.</p>

<p><a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays</a> in particular proved to be a strong source of correctness bugs. The package provides an array type that leverages Julia‚Äôs flexible <a href="https://julialang.org/blog/2017/04/offset-arrays/">custom indices feature</a> to create arrays whose indices don‚Äôt have to start at zero or one. </p>

<p>Using them would often result in out-of-bounds memory accesses, just like those one might encounter in C or C++. This would lead to segfaults if you were lucky, or, if you weren‚Äôt, to results that were quietly wrong. I once found <a href="https://github.com/JuliaLang/julia/issues/39379">a bug in core Julia</a> that could lead to out-of-bounds memory accesses even when both the user and library authors wrote correct code.</p>

<p>I filed a number of indexing-related issues with the JuliaStats organization, which stewards statistics packages like <a href="https://juliahub.com/ui/Packages/Distributions/xILW0/0.25.58">Distributions</a>, which 945 packages depend on, and <a href="https://juliahub.com/ui/Packages/StatsBase/EZjIG/0.33.16">StatsBase</a>, which 1,660 packages depend on. Here are some of them:</p>

<ul>
<li><p><a href="https://github.com/JuliaStats/StatsBase.jl/issues/646">The majority of sampling methods are unsafe and incorrect in the presence of offset axes</a></p></li>
<li><p><a href="https://github.com/JuliaStats/Distributions.jl/issues/1253">Fitting a DiscreteUniform distribution can silently return an incorrect answer</a></p></li>
<li><p><a href="https://github.com/JuliaStats/StatsBase.jl/issues/638">counteq, countne, sqL2dist, L2dist, L1dist, L1infdist, gkldiv, meanad, maxad, msd, rmsd, and psnr may return incorrect results with offset indices</a></p></li>
<li><p><a href="https://github.com/JuliaStats/Distributions.jl/issues/1265">Incorrect uses of @inbounds cause miscalculation of statistics</a></p></li>
<li><p><a href="https://github.com/JuliaStats/Distances.jl/issues/206">Colwise and pairwise can return incorrect distances</a></p></li>
<li><p><a href="https://github.com/JuliaStats/StatsBase.jl/issues/643">Showing a Weights vector wrapping an offset array accesses out-of-bounds memory</a></p></li>
</ul>

<p>The root cause behind these issues was not the indexing alone but its use together with another Julia feature, <code>@inbounds</code>, which permits Julia to remove bounds checks from array accesses.</p>

<p>For example:</p>

<pre><code>function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i in 1:length(A)
        @inbounds r += A[i] # ‚Üê üå∂
    end
    return r
end
</code></pre>

<p>The code above iterates <code>i</code> from 1 to the length of the array. If you pass it an array with an unusual index range, it will access out-of-bounds memory: the array access was annotated with <code>@inbounds</code>, which removed the bounds check.</p>

<p>The example above shows how to use <code>@inbounds</code> <strong>incorrectly</strong>. However, for years it was also the official example of how to use <code>@inbounds</code> <strong>correctly</strong>. The example was situated directly above a warning explaining why it was incorrect:</p>

<figure>
<img src="https://yuri.is/not-julia/issue.png" alt=""/>
</figure>

<p><a href="https://github.com/JuliaLang/julia/issues/39367">That issue</a> is now fixed, but it is worrying that <code>@inbounds</code> can be so easily misused, causing silent data corruption and incorrect mathematical results.</p>

<p>In my experience, issues like these were not confined to the mathematical parts of the Julia ecosystem.</p>

<p>I encountered library bugs while trying to accomplish mundane tasks like <a href="https://github.com/quinnj/JSON3.jl/issues/63">encoding</a> <a href="https://github.com/JuliaLang/julia/issues/34249">JSON</a>, issuing <a href="https://github.com/JuliaWeb/HTTP.jl/issues/626">HTTP requests</a>, using <a href="https://github.com/apache/arrow-julia/issues/101">Arrow files</a> <a href="https://github.com/apache/arrow-julia/issues/102">together</a> with DataFrames, and <a href="https://github.com/fonsp/Pluto.jl/issues/826">editing</a> <a href="https://github.com/fonsp/Pluto.jl/issues/751">Julia</a> <a href="https://github.com/fonsp/Pluto.jl/issues/836">code</a> with <a href="https://github.com/fonsp/Pluto.jl">Pluto</a>, Julia‚Äôs reactive notebook environment.</p>

<p>When I became curious if my experience was representative, a number of Julia users privately shared similar stories. Recently, public accounts of comparable experiences have begun to surface.</p>

<p>For example, in <a href="https://kidger.site/thoughts/jax-vs-julia/">this post</a> Patrick Kidger describes his attempt to use Julia for machine learning research:</p>

<blockquote>
<p>It‚Äôs pretty common to see posts on the Julia Discourse saying ‚ÄúXYZ library doesn‚Äôt work‚Äù, followed by a reply from one of the library maintainers stating something like ‚ÄúThis is an upstream bug in the new version a.b.c of the ABC library, which XYZ depends upon. We‚Äôll get a fix pushed ASAP.‚Äù</p>
</blockquote>

<p>Here‚Äôs Patrick‚Äôs experience tracking down a correctness bug (emphasis mine):</p>

<blockquote>
<p>I remember all too un-fondly a time in which one of my Julia models was failing to train. I spent multiple months on-and-off trying to get it working, trying every trick I could think of.</p>

<p>Eventually ‚Äì eventually! ‚Äì I found the error: <strong>Julia/Flux/Zygote was returning incorrect gradients.</strong> After having spent so much energy wrestling with points 1 and 2 above, this was the point where I simply gave up. Two hours of development work later, I had the model successfully training‚Ä¶ in PyTorch.</p>
</blockquote>

<p>In a <a href="https://discourse.julialang.org/t/state-of-machine-learning-in-julia/74385/4">discussion</a> about the post others responded that they, too, had similar experiences.</p>

<p><a href="https://discourse.julialang.org/t/state-of-machine-learning-in-julia/74385/13">@Samuel_Ainsworth</a>:</p>

<blockquote>
<p>Like @patrick-kidger, I have been bit by incorrect gradient bugs in Zygote/ReverseDiff.jl. This cost me weeks of my life and has thoroughly shaken my confidence in the entire Julia AD landscape. [...] In all my years of working with PyTorch/TF/JAX I have not once encountered an incorrect gradient bug.</p>
</blockquote>

<p><a href="https://discourse.julialang.org/t/state-of-machine-learning-in-julia/74385/21">@JordiBolibar</a>:</p>

<blockquote>
<p>Since I started working with Julia, I‚Äôve had two bugs with Zygote which have slowed my work by several months. On a positive note, this has forced me to plunge into the code and learn a lot about the libraries I‚Äôm using. But I‚Äôm finding myself in a situation where this is becoming too much, and I need to spend a lot of time debugging code instead of doing climate research. </p>
</blockquote>

<p>Given Julia‚Äôs extreme generality it is not obvious to me that the correctness problems <em>can</em> be solved. Julia has no formal notion of interfaces, generic functions tend to leave their semantics unspecified in edge cases, and the nature of many common implicit interfaces has not been made precise (for example, there is no agreement in the Julia community on what a number is).</p>

<p>The Julia community is full of capable and talented people who are generous with their time, work, and expertise. But systemic problems like this can rarely be solved from the bottom up, and my sense is that the project leadership does not agree that there is a serious correctness problem. They accept the existence of individual isolated issues, but not the pattern that those issues imply. </p>

<p>At a time when Julia‚Äôs machine learning ecosystem was even less mature, for example, a co-founder of the language spoke enthusiastically about using Julia in production for self-driving cars:</p>

<figure>
<img src="https://yuri.is/not-julia/picture.png" alt=""/>
</figure>

<p>And while it‚Äôs possible that attitudes have shifted since I was an active member, the following quote from another co-founder, also made around the same time, serves as a good illustration of the perception gap (emphasis mine):</p>

<blockquote>
<p>I think the top-level take away here is not that Julia is a great language (although it is) and that they should use it for all the things (although that‚Äôs not the worst idea), but that its design has hit on something that has made a major step forwards in terms of our ability to achieve code reuse. <strong>It is actually the case in Julia that you can take generic algorithms that were written by one person and custom types that were written by other people and just use them together efficiently and effectively.</strong> This majorly raises the table stakes for code reuse in programming languages. Language designers should not copy all the features of Julia, but they should at the very least understand why this works so well, and be able to accomplish this level of code reuse in future designs.</p>
</blockquote>

<p>Whenever a post critiquing Julia makes the rounds, people from the community are often quick to respond that, while there have historically been some legitimate issues, things have improved substantially and most of the issues are now fixed.</p>

<p>For example:</p>

<ul>
<li>In 2016: <a href="https://news.ycombinator.com/item?id=11073642">‚ÄúThe legitimate issues raised in that blog post are fixed.‚Äù</a></li>
<li>In 2018: <a href="https://news.ycombinator.com/item?id=17726336">‚ÄúI complained also about the ‚Äòcowboy‚Äô culture I saw among the Julia developers when I first started with it [...] but those days are gone.‚Äù</a></li>
<li>In 2020: <a href="https://news.ycombinator.com/item?id=22138071">‚ÄúIn 2016 yes. But this has been very much addressed.‚Äù</a></li>
<li>In 2021: <a href="https://news.ycombinator.com/item?id=27921467">‚ÄúIn Julia there is no technical enforcement of consistency, but semantic meaning of generic functions is broadly respected and generic code works.‚Äù</a></li>
<li>In 2022: <a href="https://news.ycombinator.com/item?id=30939963">‚ÄúOf course there are bugs, but none of them are serious.‚Äù</a></li>
</ul>

<p>These responses often look reasonable in their narrow contexts, but the net effect is that people‚Äôs legitimate experiences feel diminished or downplayed, and the deeper issues go unacknowledged and unaddressed.</p>

<p>My experience with the language and community over the past ten years strongly suggests that, at least in terms of basic correctness, Julia is not currently reliable or on the path to becoming reliable. For the majority of use cases the Julia team wants to service, the risks are simply not worth the rewards.</p>

<p>Ten years ago, Julia was introduced to the world with <a href="https://julialang.org/blog/2012/02/why-we-created-julia/">inspiring and ambitious set of goals</a>. I still believe that they can, one day, be achieved‚Äîbut not without revisiting and revising the patterns that brought the project to the state it is in today.</p>



<p><small>Thanks to Mitha Nandagopalan, Ben Cartwright-Cox, Imran Qureshi, Elad Bogomolny, Zora Killpack, Ben Kuhn, and Yuriy Rusko for discussions and comments on earlier drafts of this post.</small></p>


</div>
  </body>
</html>
