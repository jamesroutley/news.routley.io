<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://j3s.sh/thought/write-posix-shell.html">Original</a>
    <h1>Write Posix Shell</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
  <p><a href="https://j3s.sh/"><img height="92" src="https://j3s.sh/static/unnamed-puffy.png" alt="another pufferfish drawn by rekka"/></a>
  <a href="https://j3s.sh/"><img height="92" src="https://j3s.sh/static/unnamed-puffy-2.png" alt="yet another pufferfish drawn by rekka"/></a>
  <a href="https://j3s.sh/"><img height="92" src="https://j3s.sh/static/unnamed-puffy-3.png" alt="yet another pufferfish drawn by rekka"/></a></p><hr/>
  <pre>           write posix shell
              2023-03-10

                  /\
                 {.-}
                ;_.-&#39;\
               {    _.}_
                \.-&#39; /  `,
                 \  |    /
                  \ |  ,/
               [0] \|_/


            what is shell?

  most people in tech are familiar with shell scripts.
  but shell is a language!

  ...

  shit. actually. wait, let me rephrase-

  most people _use_ shell.
  most people _avoid_ shell.

  but mostly

  most people  _hate_ shell.

  but should they?


           why do people hate shell?

  arcane syntax
      shell&#39;s syntax can feel cumbersome and cryptic
      because it was invented around the time
      people thought lawn darts were a good idea.

  confusing error handling
      in python there&#39;s try/except. in golang, errors are values.
      in shell, errors sorta just happen in insane ways.

  hard to maintain
      when shell grows beyond a few hundred lines
      or so, it becomes impossible to maintain.

  unique and weird
      since shell has no canonical format, shell scripts
      can look wildly different depending on the author,
      which furthers confusion.

  perception
      in the tech industry, people often look down on
      shell scripts as tech debt / lame, devs are
      often incentiviced to use hotter, more exciting things.


           so why use shell at all?

  simply: because shell is an insanely productive language.

  in fact, i believe that shell is the *most* productive language.

  in terms of time + brainpower spent to produce a result,
  shell can do in 10 seconds what would take much longer
  in any other language, because shell is optimized for speed,
  instant feedback, and is enhanced by many years of easily
  searchable knowledge. shell is also ubiquitous and accessible
  almost anywhere you need it.

  people often think that i work extremely quickly.
  they think that i must have Exceptional Skills

  my friends, i have no secret - i am dumb as hell.
      but i do know a little bit of shell.


                 [1] .----.   @   @
                    / .-&#34;-.`.  \v/
                    | | &#39;\ \ \_/ )
                  ,-\ `-.&#39; /.&#39;  /
.................&#39;---`----&#39;----&#39;______________*,___&#39;_


             bash me in the head

  like human languages, shell has many dialects. there&#39;s
  the common bash and zsh. let&#39;s see. there&#39;s also ksh.
  oh, and dash.
  and fish.
    and csh.
    mrsh.
    tcsh. pdksh.
  the list of shell dialects goes on and on forever,
  like a big long slimy snail trail.

  each shell dialect has varying levels of compatibility
  with the others.

  for example, imagine writing a bash shell
  program only to later realize that it won&#39;t
  run inside of your alpine container,
  because alpine uses dash.

  imagine writing a shell script on macos only
  to realize that it doesn&#39;t work on linux.

  when people write shell, they will often say things
  like &#34;i&#39;m writing bash&#34; or &#34;i&#39;m bash scripting&#34;

  people say &#34;bash&#34; because bash is the most
  common shell dialect.

  to be clear:
      if you write shell and use some bash features,
      you&#39;re writing shell in the bash dialect.
      if you happen to not use any bash features,
      then you&#39;re writing plain old shell.

  the reason i&#39;m being pedantic about dialects is because
  i believe that most people should only learn and write
  a single dialect of shell: posix shell

  this opinion is not very widespread, but i think that
  it should be.

  let me explain


          *eternal sunshine of the posix shell*

  describing posix shell is simple. it is shell written
  in accordance with the posix specification.

  the bad news is that the posix specification is documented
  on the worst website i&#39;ve ever seen[2], which i believe is
  a twisted conspiracy to make posix shell less popular.

  the good news is that if you write posix shell, there are
  huge benefits.

  posix shell is compatible:
      it&#39;ll run on debian, ubuntu,
                  on openbsd,
                      in an alpine container,
                          on illumos! arch!
                              even horrible old AIX!

  posix shell is defined:
      the posix spec fully describes how shell should work.
      it defines every command, every flag, and every builtin
      function. it defines how loops work, how case statements
      ought to look, and how exit codes work. everything.

  posix shell is pretty small:
      if you enjoy reading technical specifications for
      fun (aka: if you are a masochist), you might read
      through the posix spec - it&#39;d only take a day or two.

      or, you might just read the parts of it that
      apply to the problems you&#39;re solving, and piece
      it together as you go.

      this feels bad:
          running arcane shell commands copy&amp;pasted
          from stackoverflow, having them work, and
          being like &#34;uhhhh wut&#34; and moving on because
          &#34;shell is such a weird little guy&#34;

      this feels good:
          running posix shell commands that you
          reference directly from the specification,
          knowing that they&#39;ll simply work everywhere
          on everything for eternity.

  posix shell is eternal:
      imagine posix shell as the &#34;standard library of shell&#34;
      the concrete foundation on which you stand. posix shell
      was first defined in 1992, and has remained largely the
      same since. it is an important language that has lasted
      30 years, and is very likely to last 30 more.


         /------------------------------\
         |                              |
         |          omg!                |
         |  posix shell is amazing!     |
         | i wanna use it everywhere!   |
         | i wanna go use it RIGHT NOW! |
         \------------------------------/*
                                          *
                                           *
                                            ðŸ¤” &lt;-- you

  slow down there you son of a gun!!
  yes, posix shell is amazing, but it&#39;s also very constraining.

  consider this sentence:
    &#34;arrays do not exist in posix shell&#34;

  ...

  &#34;NOOO!&#34; you shout, because you like data structures a LOT
  &#34;now THAT&#39;S a good reason to use bash! bash supports arrays!&#34;

  absolutely not!

  i believe that you should use shell if your problem is:
    - small and scoped (~200 lines of shell or less)
    - unlikely to increase in size and scope as time goes on
    - not very complex

  if you find yourself desiring arrays, good error handling,
  static typing, structs, etc, then your problem should
  be solved using a different language, not shell.

  in this way, posix shell offers you a &#34;sniff test&#34;

  if something sucks to implement in posix shell, you
  probably shouldn&#39;t implement it in shell at all.


               when should i use shell?

  in short;
  when the problem you&#39;re solving is small, well defined,
  and unlikely to change, consider shell.

  when the problem you&#39;re solving involves linux,
  text processing, or managing files, consider shell.

  here are a bunch of ideas that shell would be a great
  fit for:

    - rename a bunch of files
    - make a take-my-estrogen alarm clock
      (perhaps your laptop would beep)
    - run a command when a certain file changes
    - delete all files that end in .kfx
    - execute a series of commands on many remote systems
    - count the number of occurrences of the word &#34;fuck&#34;
      across your projects, then sort the results
    - back up your raspberry pi up to an external hard drive
    - submit JSON data to an endpoint on a schedule
    - create a virtual machine with a certain name
    - update a personal website whenever its git repo changes
      &gt; this is how i deploy j3s.sh!
        one 2-line cronjob,
        one 10-line shell script,
        2 years with 99.999% uptime
    - find rss feed endpoints and print any that exist
     &gt; my friend begriffs[3] and i wrote shell that does this!

  most of the above examples would take between 10 seconds and
  2 minutes to implement in the hands of an experienced
  shell person. that person could be you!!


            âœ¨ posix shell inspo âœ¨

  dylan araps is the person who first inspired me to
  dig into posix shell, and his projects[4] are
  absolutely worth a browse.

  drew devault often promotes posix shell, and has used
  posix shell to write a git client called shit[5]

  check out pa[6], a posix shell password manager that i
  made.

  check out my dotfiles[7], which contain a ton of
  little posix shell scripts that i use for all sorts
  of things

  here&#39;s a cool arch wiki entry[8] on shells, check out
  the posix section.

  shellcheck[9] is an amazing tool that can check your shell
  for posix compatibility issues &amp; many other things.
  i use it every time i write more than a few dozen
  lines of shell.

  shfmt[10] is like gofmt, but for shell. it supports posix
  shell as well!


                      :D :3

  posix shell is fun, sloppy, powerful, portable, and eternal.

    wield it with caution, dear friend. but enjoy yourself.

  NOW GET OUT THERE AND WRITE SOME POSIX SHELL, GOD DAMNIT!

      ALL HAIL POSIX SHELL! ALL SNAIL POSIX SHELL!

                     __,._
                    /  _  \
                   |  o \  \  oo
                    \___/ .|__||
             __,..=&#34;^  . , &#34;  , \
............&lt;._________________=/*___.__*___&#39;___all snail!?____

          NOW GET OUT OF HERE CUTIE!

                    -jes


         =&gt; refs

[0]: https://archive.ph/KLpzo
[1]: ascii snail by Hayley Jane Wakenshaw
[2]: https://archive.ph/higTn
    sidenote: if anyone out there wants to make a posix shell
              website that doesn&#39;t suck absolute ass, let me know.
[3]: https://begriffs.com
[4]: https://github.com/dylanaraps
[5]: https://git.sr.ht/~sircmpwn/shit
[6]: https://github.com/biox/pa
[7]: https://git.j3s.sh/dotfiles/tree/main/bin
[8]: https://wiki.archlinux.org/title/command-line_shell
[9]: https://www.shellcheck.net
[10]: https://github.com/mvdan/sh
</pre>
</div></div>
  </body>
</html>
