<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smallcultfollowing.com/babysteps/blog/2024/06/02/the-borrow-checker-within/">Original</a>
    <h1>The borrow checker within</h1>
    
    <div id="readability-page-1" class="page"><div><p>This post lays out a 4-part roadmap for the borrow checker that I call ‚Äúthe borrow checker within‚Äù. These changes are meant to help Rust become a better version of itself, enabling patterns of code which feel like they fit within Rust‚Äôs <em>spirit</em>, but run afoul of the letter of its <em>law</em>. I feel fairly comfortable with the design for each of these items, though work remains to scope out the details. My belief is that a-mir-formality will make a perfect place to do that work.</p><h2 id="rusts-spirit-is-mutation-xor-sharing">Rust‚Äôs <em>spirit</em> is <em>mutation xor sharing</em></h2><p>When I refer to the <em>spirit</em> of the borrow checker, I mean the rules of <em>mutation xor sharing</em> that I see as Rust‚Äôs core design ethos. This basic rule‚Äîthat when you are mutating a value using the variable <code>x</code>, you should not also be reading that data through a variable <code>y</code>‚Äîis what enables Rust‚Äôs memory safety guarantees and also, I think, contributes to its overall sense of ‚Äúif it compiles, it works‚Äù.</p><p><em>Mutation xor sharing</em> is, in some sense, neither necessary nor sufficient. It‚Äôs not <em>necessary</em> because there are many programs (like every program written in Java) that share data like crazy and yet still work fine<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. It‚Äôs also not <em>sufficient</em> in that there are many problems that demand some amount of sharing ‚Äì which is why Rust has ‚Äúbackdoors‚Äù like <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, <code>AtomicU32</code>, and‚Äîthe ultimate backdoor of them all‚Äî<code>unsafe</code>.</p><p>But to me the biggest surprise from working on Rust is how often this <em>mutation xor sharing</em> pattern is ‚Äújust right‚Äù, once you learn how to work with it<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. The other surprise has been seeing the benefits over time: programs written in this style are fundamentally ‚Äúless surprising‚Äù which, in turn, means they are more maintainable over time.</p><p>In Rust today though there are a number of patterns that are rejected by the borrow checker despite fitting the <em>mutation xor sharing</em> pattern. Chipping away at this gap, helping to make the borrow checker‚Äôs rules a more perfect reflection of <em>mutation xor sharing</em>, is what I mean by <em>the borrow checker within</em>.</p><blockquote><p>I saw the angel in the marble and carved until I set him free. ‚Äî Michelangelo</p></blockquote><h2 id="ok-enough-inspirational-rhetoric-lets-get-to-the-code">OK, enough inspirational rhetoric, let‚Äôs get to the code.</h2><p>Ahem, right. Let‚Äôs do that.</p><h2 id="step-1-conditionally-return-references-easily-with-polonius">Step 1: Conditionally return references easily with ‚ÄúPolonius‚Äù</h2><p>Rust 2018 introduced <a href="https://rust-lang.github.io/rfcs/2094-nll.html">‚Äúnon-lexical lifetimes‚Äù</a> ‚Äî this rather cryptic name refers to an extension of the borrow checker so that it understood the control flow within functions much more deeply. This change made using Rust a much more ‚Äúfluid‚Äù experience, since the borrow checker was able to accept a lot more code.</p><p>But NLL does not handle one important case<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>: conditionally returning references. Here is the canonical example, taken from Remy‚Äôs <a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Polonius update blog post</a>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_default</span><span>&lt;</span><span>&#39;r</span><span>,</span><span> </span><span>K</span>: <span>Hash</span><span> </span><span>+</span><span> </span><span>Eq</span><span> </span><span>+</span><span> </span><span>Copy</span><span>,</span><span> </span><span>V</span>: <span>Default</span><span>&gt;</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>map</span>: <span>&amp;</span><span>&#39;r</span> <span>mut</span><span> </span><span>HashMap</span><span>&lt;</span><span>K</span><span>,</span><span> </span><span>V</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>key</span>: <span>K</span><span>,</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>&#39;r</span> <span>mut</span><span> </span><span>V</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>map</span><span>.</span><span>get_mut</span><span>(</span><span>&amp;</span><span>key</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Some</span><span>(</span><span>value</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>value</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>map</span><span>.</span><span>insert</span><span>(</span><span>key</span><span>,</span><span> </span><span>V</span>::<span>default</span><span>());</span><span>
</span></span></span><span><span><span>            </span><span>//  ------ üí• Gets an error today,
</span></span></span><span><span><span></span><span>            </span><span>//            but not with polonius
</span></span></span><span><span><span></span><span>            </span><span>map</span><span>.</span><span>get_mut</span><span>(</span><span>&amp;</span><span>key</span><span>).</span><span>unwrap</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>  
</span></span></span></code></pre></div><p><a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Remy‚Äôs post</a> gives more details about why this occurs and how we plan to fix it. It‚Äôs mostly accurate except that the timeline has stretched on more than I‚Äôd like (of course). But we are making steady progress these days.</p><h2 id="step-2-a-syntax-for-lifetimes-based-on-places">Step 2: A syntax for lifetimes based on places</h2><p>The next step is to add an explicit syntax for lifetimes based on ‚Äúplace expressions‚Äù (e.g., <code>x</code> or <code>x.y</code>). I wrote about this in my post <a href="https://smallcultfollowing.com/babysteps/blog/2024/03/04/borrow-checking-without-lifetimes/">Borrow checking without lifetimes</a>. This is basically taking the formulation that underlies Polonius and adding a syntax.</p><p>The idea would be that, in addition to the abstract lifetime parameters we have today, you could reference program variables and even fields as the ‚Äúlifetime‚Äù of a reference. So you could write <code>‚Äôx</code> to indicate a value that is ‚Äúborrowed from the variable <code>x</code>‚Äù. You could also write <code>‚Äôx.y</code> to indicate that it was borrowed from the field <code>y</code> of <code>x</code>, and even <code>&#39;(x.y, z)</code> to mean borrowed from <em>either</em> <code>x.y</code> or <code>z</code>. For example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>manufacturer</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>model</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>new_widget</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>name</span>: <span>String</span><span>)</span><span> </span>-&gt; <span>Widget</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>name_suffix</span>: <span>&amp;</span><span>‚Äô</span><span>name</span><span> </span><span>str</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>name</span><span>[</span><span>3</span><span>..</span><span>];</span><span>
</span></span></span><span><span><span>                       </span><span>// ‚Äî‚Äî- borrowed from ‚Äúname‚Äù
</span></span></span><span><span><span></span><span>        </span><span>let</span><span> </span><span>model_prefix</span>: <span>&amp;</span><span>‚Äô</span><span>self</span><span>.</span><span>model</span><span> </span><span>str</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>model</span><span>[</span><span>..</span><span>2</span><span>];</span><span>
</span></span></span><span><span><span>                         </span><span>// ‚Äî‚Äî‚Äî‚Äî‚Äî- borrowed from ‚Äúself.model‚Äù
</span></span></span><span><span><span></span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This would make many of lifetime parameters we write today unnecessary. For example, the classic Polonius example where the function takes a parameter <code>map: &amp;mut Hashmap&lt;K, V&gt;</code> and returns a reference into the map can be written as follows:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_default</span><span>&lt;</span><span>K</span>: <span>Hash</span><span> </span><span>+</span><span> </span><span>Eq</span><span> </span><span>+</span><span> </span><span>Copy</span><span>,</span><span> </span><span>V</span>: <span>Default</span><span>&gt;</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>map</span>: <span>&amp;</span><span>mut</span><span> </span><span>HashMap</span><span>&lt;</span><span>K</span><span>,</span><span> </span><span>V</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>key</span>: <span>K</span><span>,</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>&#39;map</span> <span>mut</span><span> </span><span>V</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>//---- &#34;borrowed from the parameter map&#34;
</span></span></span><span><span><span></span><span>    </span><span>..</span><span>.</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This syntax is more convenient ‚Äî but I think its bigger impact will be to make Rust more teachable and learnable. Right now, lifetimes are in a tricky place, because</p><ul><li>they represent a concept (spans of code) that isn‚Äôt normal for users to think explicitly about and</li><li>they don‚Äôt have any kind of syntax.</li></ul><p>Syntax is useful when learning because it allows you to make everything explicit, which is a critical intermediate step to really internalizing a concept ‚Äî what boats memorably called the <a href="https://github.com/rust-lang/rfcs/pull/2071#issuecomment-329026602">dialectical ratchet</a>. Anecdotally I‚Äôve been using a ‚Äúplace-based‚Äù syntax when teaching people Rust and I‚Äôve found it is much quicker for them to grasp it.</p><h2 id="step-3-view-types-and-interprocedural-borrows">Step 3: View types and interprocedural borrows</h2><p>The next piece of the plan is <a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">view types</a>, which are a way to have functions declare which fields they access. Consider a struct like <code>WidgetFactory</code>‚Ä¶</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>counter</span>: <span>usize</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>widgets</span>: <span>Vec</span><span>&lt;</span><span>Widget</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>‚Ä¶which has a helper function <code>increment_counter</code>‚Ä¶</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>increment_counter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Today, if we want to iterate over the widgets and occasionally increment the counter with <code>increment_counter</code>, <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=afeb1a8021ab1abf73639ffea0bbcae3">we will encounter an error</a>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>increment_counter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>..</span><span>.}</span><span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>count_widgets</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>for</span><span> </span><span>widget</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>widgets</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>if</span><span> </span><span>widget</span><span>.</span><span>should_be_counted</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>self</span><span>.</span><span>increment_counter</span><span>();</span><span>
</span></span></span><span><span><span>                </span><span>// ^ üí• Can&#39;t borrow self as mutable
</span></span></span><span><span><span></span><span>                </span><span>//      while iterating over `self.widgets`
</span></span></span><span><span><span></span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>    
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The problem is that the borrow checker operates one function at a time. It doesn‚Äôt know precisely which fields <code>increment_counter</code> is going to mutate. So it conservatively assumes that <code>self.widgets</code> may be changed, and that‚Äôs not allowed. There are a number of workarounds today, such as writing a ‚Äúfree function‚Äù that doesn‚Äôt take <code>&amp;mut self</code> but rather takes references to the individual fields (e.g., <code>counter: &amp;mut usize</code>) or even collecting those references into a ‚Äúview struct‚Äù (e.g., <code>struct WidgetFactoryView&lt;&#39;a&gt; { widgets: &amp;&#39;a [Widget], counter: &amp;&#39;a mut usize }</code>) but these are non-obvious, annoying, and non-local (they require changing significant parts of your code)</p><p><a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">View types</a> extend struct types so that instead of just having a type like <code>WidgetFactory</code>, you can have a ‚Äúview‚Äù on that type that included only a subset of the fields, like <code>{counter} WidgetFactory</code>. We can use this to modify <code>increment_counter</code> so that it declares that it will only access the field <code>counter</code>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>increment_counter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>{</span><span>counter</span><span>}</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>//               -------------------
</span></span></span><span><span><span></span><span>        </span><span>// Equivalent to `self: &amp;mut {counter} WidgetFactory`
</span></span></span><span><span><span></span><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This allows the compiler to compile <code>count_widgets</code> just fine, since it can see that iterating over <code>self.widgets</code> while modifying <code>self.counter</code> is not a problem.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p><h3 id="view-types-also-address-phased-initialization">View types also address phased initialization</h3><p>There is another place where the borrow checker‚Äôs rules fall short: <em>phased initialization</em>. Rust today follows the functional programming language style of requiring values for all the fields of a struct when it is created. Mostly this is fine, but sometimes you have structs where you want to initialize some of the fields and then invoke helper functions, much like <code>increment_counter</code>, to create the remainder. In this scenario you are stuck, because those helper functions cannot take a reference to the struct since you haven‚Äôt created the struct yet. The workarounds (free functions, intermediate struct types) are very similar.</p><h3 id="start-with-private-functions-consider-scaling-to-public-functions">Start with private functions, consider scaling to public functions</h3><p>View types as described here have limitations. Because the types involve the names of fields, they are not really suitable for public interfaces. They could also be annoying to use in practice because one will have sets of fields that go together that have to be manually copied and pasted. All of this is true but I think something that can be addressed later (e.g., with named groups of fields).</p><p>What I‚Äôve found is that the majority of times that I want to use view types, it is in <em>private</em> functions. Private methods often do little bits of logic and make use of the struct‚Äôs internal structure. Public methods in contrast tend to do larger operations and to hide that internal structure from users. This isn‚Äôt a universal law ‚Äì sometimes I have public functions that should be callable concurrently ‚Äì but it happens less.</p><p>There is also an advantage to the current behavior for public functions in particular: it preserves forward compatibilty. Taking <code>&amp;mut self</code> (versus some subset of fields) means that the function can change the set of fields that it uses without affecting its clients. This is not a concern for private functions.</p><h2 id="step-4-internal-references">Step 4: Internal references</h2><p>Rust today cannot support structs whose fields refer to data owned by another. This gap is partially closed through crates like <a href="https://crates.io/crates/rental">rental</a> (no longer maintained), though more often by <a href="https://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">modeling internal references with indices</a>. We also have <code>Pin</code>, which covers the related (but even harder) problem of immobile data.</p><p>I‚Äôve been chipping away at a solution to this problem for some time. I won‚Äôt be able to lay it out in full in this post, but I can sketch what I have in mind, and lay out more details in future posts (I have done some formalization of this, enough to convince myself it works).</p><p>As an example, imagine that we have some kind of <code>Message</code> struct consisting of a big string along with several references into that string. You could model that like so:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Message</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>text</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>headers</span>: <span>Vec</span><span>&lt;</span><span>(</span><span>&amp;</span><span>&#39;self</span><span>.</span><span>text</span><span> </span><span>str</span><span>,</span><span> </span><span>&amp;</span><span>&#39;self</span><span>.</span><span>text</span><span> </span><span>str</span><span>)</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>body</span>: <span>&amp;</span><span>&#39;self</span><span>.</span><span>text</span><span> </span><span>str</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This message would be constructed in the usual way:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>text</span>: <span>String</span> <span>=</span><span> </span><span>parse_text</span><span>();</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>(</span><span>headers</span><span>,</span><span> </span><span>body</span><span>)</span><span> </span><span>=</span><span> </span><span>parse_message</span><span>(</span><span>&amp;</span><span>text</span><span>);</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>message</span><span> </span><span>=</span><span> </span><span>Message</span><span> </span><span>{</span><span> </span><span>text</span><span>,</span><span> </span><span>headers</span><span>,</span><span> </span><span>body</span><span> </span><span>};</span><span>
</span></span></span></code></pre></div><p>where <code>parse_message</code> is some function like</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>parse_message</span><span>(</span><span>text</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>(</span><span>
</span></span></span><span><span><span>    </span><span>Vec</span><span>&lt;</span><span>(</span><span>&amp;</span><span>&#39;text</span><span> </span><span>str</span><span>,</span><span> </span><span>&amp;</span><span>&#39;text</span><span> </span><span>str</span><span>)</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>&amp;</span><span>&#39;text</span><span> </span><span>str</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>headers</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[];</span><span>
</span></span></span><span><span><span>    </span><span>// ...
</span></span></span><span><span><span></span><span>    </span><span>(</span><span>headers</span><span>,</span><span> </span><span>body</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Note that <code>Message</code> doesn‚Äôt have any lifetime parameters ‚Äì it doesn‚Äôt need any, because it doesn‚Äôt borrow from anything outside of itself. In fact, <code>Message: &#39;static</code> is true, which means that I could send this <code>Message</code> to another thread:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// A channel of `Message` values:
</span></span></span><span><span><span></span><span>let</span><span> </span><span>(</span><span>tx</span><span>,</span><span> </span><span>rx</span><span>)</span><span> </span><span>=</span><span> </span><span>std</span>::<span>sync</span>::<span>mpsc</span>::<span>channel</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// A thread to consume those values:
</span></span></span><span><span><span></span><span>std</span>:<span>üßµ</span>:<span>spawn</span><span>(</span><span>move</span><span> </span><span>||</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>message</span><span> </span><span>in</span><span> </span><span>rx</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// `message` here has type `Message`
</span></span></span><span><span><span></span><span>        </span><span>process</span><span>(</span><span>message</span><span>.</span><span>body</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>});</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Produce them:
</span></span></span><span><span><span></span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>message</span>: <span>Message</span><span> </span><span>=</span><span> </span><span>next_message</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>tx</span><span>.</span><span>send</span><span>(</span><span>message</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="how-far-along-are-each-of-these-ideas">How far along are each of these ideas?</h2><p>Roughly speaking‚Ä¶</p><ul><li>Polonius ‚Äì ‚Äòjust‚Äô engineering</li><li>Syntax ‚Äì ‚Äòjust‚Äô bikeshedding</li><li>View types ‚Äì needs modeling, one or two open questions in my mind<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></li><li>Internal references ‚Äì modeled in some detail for a simplified variant of Rust, have to port to Rust and explain the assumptions I made along the way<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></li></ul><p>‚Ä¶in other words, I‚Äôve done enough work to to convince myself that these designs are practical, but plenty of work remains. :)</p><h2 id="how-do-we-prioritize-this-work">How do we prioritize this work?</h2><p>Whenever I think about investing in borrow checker ergonomics and usability, I feel a bit guilty. Surely something so fun to think about must be a bad use of my time.</p><p>Conversations at RustNL shifted my perspective. When I asked people about pain points, I kept hearing the same few themes arise, especially from people trying building applications or GUIs.</p><p>I now think I had fallen victim to the dreaded ‚Äúcurse of knowledge‚Äù, forgetting how frustrating it can be to run into a limitation of the borrow checker and not know how to resolve it.</p><h2 id="conclusion">Conclusion</h2><p>This post proposes four changes attacking some very long-standing problems:</p><ul><li><strong>Conditionally returned references</strong>, solved by <a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Polonius</a></li><li><strong>No or awkward syntax for lifetimes</strong>, solved by an <a href="https://smallcultfollowing.com/babysteps/blog/2024/03/04/borrow-checking-without-lifetimes/">explicit lifetime syntax</a></li><li><strong>Helper methods whose body must be inlined</strong>, solved by <a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">view types</a></li><li><strong>Can‚Äôt ‚Äúpackage up‚Äù a value and references into that value</strong>, solved by interior references</li></ul><p>You may have noticed that these changes build on one another. Polonius remodels borrowing in terms of ‚Äúplace expressions‚Äù (variables, fields). This enables an explicit lifetime syntax, which in turn is a key building block for interior references. View types in turn let us expose helper methods that can operate on ‚Äòpartially borrowed‚Äô (or even partially initialized!) values.</p><h3 id="why-these-changes-wont-make-rust-more-complex-or-if-they-do-its-worth-it">Why these changes won‚Äôt make Rust ‚Äúmore complex‚Äù (or, if they do, it‚Äôs worth it)</h3><p>You might wonder about the impact of these changes on Rust‚Äôs complexity. Certainly they grow the set of things the type system can express. But in my mind they, like <a href="https://rust-lang.github.io/rfcs/2094-nll.html">NLL</a> before them, fall into that category of changes that will actually make using Rust feel <em>simpler</em> overall.</p><p>To see why, put yourself in the shoes of a user today who has written any one of the ‚Äúobviously correct‚Äù programs we‚Äôve seen in this post ‚Äì for example, <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c9f5902084a631a8af5b769c094b69b6">the <code>WidgetFactory</code> code we saw in view types</a>. Compiling this code today gives an error:</p><pre tabindex="0"><code>error[E0502]: cannot borrow `*self` as mutable
              because it is also borrowed as immutable
  --&gt; src/lib.rs:14:17
   |
12 | for widget in &amp;self.widgets {
   |               -------------
   |               |
   |               immutable borrow occurs here
   |               immutable borrow later used here
13 |     if widget.should_be_counted() {
14 |         self.increment_counter();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         mutable borrow occurs here
</code></pre><p>Despite all our efforts to render it well, this error is <strong>inherently confusing</strong>. It is not possible to explain why <code>WidgetFactory</code> doesn‚Äôt work from an ‚Äúintuitive‚Äù point-of-view because <strong>conceptually it <em>ought</em> to work</strong>, it just runs up against a limit of our type system.</p><p>The only way to understand why <code>WidgetFactory</code> doesn‚Äôt compile is to dive deeper into the engineering details of how the Rust type system functions, and that is precisely the kind of thing people <em>don‚Äôt</em> want to learn. Moreover, once you‚Äôve done that deep dive, what is your reward? At best you can devise an awkward workaround. Yay ü•≥.<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup></p><p>Now imagine what happens with view types. You still get an error, but now that error can come with a suggestion:</p><pre tabindex="0"><code>help: consider declaring the fields
      accessed by `increment_counter` so that
      other functions can rely on that
 7 | fn increment_counter(&amp;mut self) {
   |                      ---------
   |                      |
   |      help: annotate with accessed fields: `&amp;mut {counter} self`
</code></pre><p>You now have two choices. First, you can apply the suggestion and move on ‚Äì your code works! Next, at your leisure, you can dig in a bit deeper and understand what‚Äôs going on. You can learn about the semver hazards that motivate an explicit declaration here.</p><p>Yes, you‚Äôve learned a new detail of the type system, but you did so <strong>on your schedule</strong> and, where extra annotations were required, they were well-motivated. Yay ü•≥!<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup></p><h3 id="reifying-the-borrow-checker-into-types">Reifying the borrow checker into types</h3><p>There is another theme running through here: moving the borrow checker analysis out from the compiler‚Äôs mind and into types that can be expressed. Right now, all types always represent fully initialized, unborrowed values. There is no way to express a type that captures the state of being in the midst of iterating over something or having moved one or two fields but not all of them. These changes address that gap.<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup></p><h3 id="this-conclusion-is-too-long">This conclusion is too long</h3><p>I know, I‚Äôm like Peter Jackson trying to end ‚ÄúThe Return of the King‚Äù, I just can‚Äôt do it! I keep coming up with more things to say. Well, I‚Äôll stop now. Have a nice weekend y‚Äôall.</p></div></div>
  </body>
</html>
