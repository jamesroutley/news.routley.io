<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smallcultfollowing.com/babysteps/blog/2024/06/02/the-borrow-checker-within/">Original</a>
    <h1>The borrow checker within</h1>
    
    <div id="readability-page-1" class="page"><div><p>This post lays out a 4-part roadmap for the borrow checker that I call “the borrow checker within”. These changes are meant to help Rust become a better version of itself, enabling patterns of code which feel like they fit within Rust’s <em>spirit</em>, but run afoul of the letter of its <em>law</em>. I feel fairly comfortable with the design for each of these items, though work remains to scope out the details. My belief is that a-mir-formality will make a perfect place to do that work.</p><h2 id="rusts-spirit-is-mutation-xor-sharing">Rust’s <em>spirit</em> is <em>mutation xor sharing</em></h2><p>When I refer to the <em>spirit</em> of the borrow checker, I mean the rules of <em>mutation xor sharing</em> that I see as Rust’s core design ethos. This basic rule—that when you are mutating a value using the variable <code>x</code>, you should not also be reading that data through a variable <code>y</code>—is what enables Rust’s memory safety guarantees and also, I think, contributes to its overall sense of “if it compiles, it works”.</p><p><em>Mutation xor sharing</em> is, in some sense, neither necessary nor sufficient. It’s not <em>necessary</em> because there are many programs (like every program written in Java) that share data like crazy and yet still work fine<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. It’s also not <em>sufficient</em> in that there are many problems that demand some amount of sharing – which is why Rust has “backdoors” like <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, <code>AtomicU32</code>, and—the ultimate backdoor of them all—<code>unsafe</code>.</p><p>But to me the biggest surprise from working on Rust is how often this <em>mutation xor sharing</em> pattern is “just right”, once you learn how to work with it<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. The other surprise has been seeing the benefits over time: programs written in this style are fundamentally “less surprising” which, in turn, means they are more maintainable over time.</p><p>In Rust today though there are a number of patterns that are rejected by the borrow checker despite fitting the <em>mutation xor sharing</em> pattern. Chipping away at this gap, helping to make the borrow checker’s rules a more perfect reflection of <em>mutation xor sharing</em>, is what I mean by <em>the borrow checker within</em>.</p><blockquote><p>I saw the angel in the marble and carved until I set him free. — Michelangelo</p></blockquote><h2 id="ok-enough-inspirational-rhetoric-lets-get-to-the-code">OK, enough inspirational rhetoric, let’s get to the code.</h2><p>Ahem, right. Let’s do that.</p><h2 id="step-1-conditionally-return-references-easily-with-polonius">Step 1: Conditionally return references easily with “Polonius”</h2><p>Rust 2018 introduced <a href="https://rust-lang.github.io/rfcs/2094-nll.html">“non-lexical lifetimes”</a> — this rather cryptic name refers to an extension of the borrow checker so that it understood the control flow within functions much more deeply. This change made using Rust a much more “fluid” experience, since the borrow checker was able to accept a lot more code.</p><p>But NLL does not handle one important case<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>: conditionally returning references. Here is the canonical example, taken from Remy’s <a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Polonius update blog post</a>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_default</span><span>&lt;</span><span>&#39;r</span><span>,</span><span> </span><span>K</span>: <span>Hash</span><span> </span><span>+</span><span> </span><span>Eq</span><span> </span><span>+</span><span> </span><span>Copy</span><span>,</span><span> </span><span>V</span>: <span>Default</span><span>&gt;</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>map</span>: <span>&amp;</span><span>&#39;r</span> <span>mut</span><span> </span><span>HashMap</span><span>&lt;</span><span>K</span><span>,</span><span> </span><span>V</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>key</span>: <span>K</span><span>,</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>&#39;r</span> <span>mut</span><span> </span><span>V</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>map</span><span>.</span><span>get_mut</span><span>(</span><span>&amp;</span><span>key</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Some</span><span>(</span><span>value</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>value</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>map</span><span>.</span><span>insert</span><span>(</span><span>key</span><span>,</span><span> </span><span>V</span>::<span>default</span><span>());</span><span>
</span></span></span><span><span><span>            </span><span>//  ------ 💥 Gets an error today,
</span></span></span><span><span><span></span><span>            </span><span>//            but not with polonius
</span></span></span><span><span><span></span><span>            </span><span>map</span><span>.</span><span>get_mut</span><span>(</span><span>&amp;</span><span>key</span><span>).</span><span>unwrap</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>  
</span></span></span></code></pre></div><p><a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Remy’s post</a> gives more details about why this occurs and how we plan to fix it. It’s mostly accurate except that the timeline has stretched on more than I’d like (of course). But we are making steady progress these days.</p><h2 id="step-2-a-syntax-for-lifetimes-based-on-places">Step 2: A syntax for lifetimes based on places</h2><p>The next step is to add an explicit syntax for lifetimes based on “place expressions” (e.g., <code>x</code> or <code>x.y</code>). I wrote about this in my post <a href="https://smallcultfollowing.com/babysteps/blog/2024/03/04/borrow-checking-without-lifetimes/">Borrow checking without lifetimes</a>. This is basically taking the formulation that underlies Polonius and adding a syntax.</p><p>The idea would be that, in addition to the abstract lifetime parameters we have today, you could reference program variables and even fields as the “lifetime” of a reference. So you could write <code>’x</code> to indicate a value that is “borrowed from the variable <code>x</code>”. You could also write <code>’x.y</code> to indicate that it was borrowed from the field <code>y</code> of <code>x</code>, and even <code>&#39;(x.y, z)</code> to mean borrowed from <em>either</em> <code>x.y</code> or <code>z</code>. For example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>manufacturer</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>model</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>new_widget</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>name</span>: <span>String</span><span>)</span><span> </span>-&gt; <span>Widget</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>name_suffix</span>: <span>&amp;</span><span>’</span><span>name</span><span> </span><span>str</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>name</span><span>[</span><span>3</span><span>..</span><span>];</span><span>
</span></span></span><span><span><span>                       </span><span>// ——- borrowed from “name”
</span></span></span><span><span><span></span><span>        </span><span>let</span><span> </span><span>model_prefix</span>: <span>&amp;</span><span>’</span><span>self</span><span>.</span><span>model</span><span> </span><span>str</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>model</span><span>[</span><span>..</span><span>2</span><span>];</span><span>
</span></span></span><span><span><span>                         </span><span>// —————- borrowed from “self.model”
</span></span></span><span><span><span></span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This would make many of lifetime parameters we write today unnecessary. For example, the classic Polonius example where the function takes a parameter <code>map: &amp;mut Hashmap&lt;K, V&gt;</code> and returns a reference into the map can be written as follows:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_default</span><span>&lt;</span><span>K</span>: <span>Hash</span><span> </span><span>+</span><span> </span><span>Eq</span><span> </span><span>+</span><span> </span><span>Copy</span><span>,</span><span> </span><span>V</span>: <span>Default</span><span>&gt;</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>map</span>: <span>&amp;</span><span>mut</span><span> </span><span>HashMap</span><span>&lt;</span><span>K</span><span>,</span><span> </span><span>V</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>key</span>: <span>K</span><span>,</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>&#39;map</span> <span>mut</span><span> </span><span>V</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>//---- &#34;borrowed from the parameter map&#34;
</span></span></span><span><span><span></span><span>    </span><span>..</span><span>.</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This syntax is more convenient — but I think its bigger impact will be to make Rust more teachable and learnable. Right now, lifetimes are in a tricky place, because</p><ul><li>they represent a concept (spans of code) that isn’t normal for users to think explicitly about and</li><li>they don’t have any kind of syntax.</li></ul><p>Syntax is useful when learning because it allows you to make everything explicit, which is a critical intermediate step to really internalizing a concept — what boats memorably called the <a href="https://github.com/rust-lang/rfcs/pull/2071#issuecomment-329026602">dialectical ratchet</a>. Anecdotally I’ve been using a “place-based” syntax when teaching people Rust and I’ve found it is much quicker for them to grasp it.</p><h2 id="step-3-view-types-and-interprocedural-borrows">Step 3: View types and interprocedural borrows</h2><p>The next piece of the plan is <a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">view types</a>, which are a way to have functions declare which fields they access. Consider a struct like <code>WidgetFactory</code>…</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>counter</span>: <span>usize</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>widgets</span>: <span>Vec</span><span>&lt;</span><span>Widget</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>…which has a helper function <code>increment_counter</code>…</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>increment_counter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Today, if we want to iterate over the widgets and occasionally increment the counter with <code>increment_counter</code>, <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=afeb1a8021ab1abf73639ffea0bbcae3">we will encounter an error</a>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>increment_counter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>..</span><span>.}</span><span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>count_widgets</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>for</span><span> </span><span>widget</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>widgets</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>if</span><span> </span><span>widget</span><span>.</span><span>should_be_counted</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>self</span><span>.</span><span>increment_counter</span><span>();</span><span>
</span></span></span><span><span><span>                </span><span>// ^ 💥 Can&#39;t borrow self as mutable
</span></span></span><span><span><span></span><span>                </span><span>//      while iterating over `self.widgets`
</span></span></span><span><span><span></span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>    
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The problem is that the borrow checker operates one function at a time. It doesn’t know precisely which fields <code>increment_counter</code> is going to mutate. So it conservatively assumes that <code>self.widgets</code> may be changed, and that’s not allowed. There are a number of workarounds today, such as writing a “free function” that doesn’t take <code>&amp;mut self</code> but rather takes references to the individual fields (e.g., <code>counter: &amp;mut usize</code>) or even collecting those references into a “view struct” (e.g., <code>struct WidgetFactoryView&lt;&#39;a&gt; { widgets: &amp;&#39;a [Widget], counter: &amp;&#39;a mut usize }</code>) but these are non-obvious, annoying, and non-local (they require changing significant parts of your code)</p><p><a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">View types</a> extend struct types so that instead of just having a type like <code>WidgetFactory</code>, you can have a “view” on that type that included only a subset of the fields, like <code>{counter} WidgetFactory</code>. We can use this to modify <code>increment_counter</code> so that it declares that it will only access the field <code>counter</code>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>increment_counter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>{</span><span>counter</span><span>}</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>//               -------------------
</span></span></span><span><span><span></span><span>        </span><span>// Equivalent to `self: &amp;mut {counter} WidgetFactory`
</span></span></span><span><span><span></span><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This allows the compiler to compile <code>count_widgets</code> just fine, since it can see that iterating over <code>self.widgets</code> while modifying <code>self.counter</code> is not a problem.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p><h3 id="view-types-also-address-phased-initialization">View types also address phased initialization</h3><p>There is another place where the borrow checker’s rules fall short: <em>phased initialization</em>. Rust today follows the functional programming language style of requiring values for all the fields of a struct when it is created. Mostly this is fine, but sometimes you have structs where you want to initialize some of the fields and then invoke helper functions, much like <code>increment_counter</code>, to create the remainder. In this scenario you are stuck, because those helper functions cannot take a reference to the struct since you haven’t created the struct yet. The workarounds (free functions, intermediate struct types) are very similar.</p><h3 id="start-with-private-functions-consider-scaling-to-public-functions">Start with private functions, consider scaling to public functions</h3><p>View types as described here have limitations. Because the types involve the names of fields, they are not really suitable for public interfaces. They could also be annoying to use in practice because one will have sets of fields that go together that have to be manually copied and pasted. All of this is true but I think something that can be addressed later (e.g., with named groups of fields).</p><p>What I’ve found is that the majority of times that I want to use view types, it is in <em>private</em> functions. Private methods often do little bits of logic and make use of the struct’s internal structure. Public methods in contrast tend to do larger operations and to hide that internal structure from users. This isn’t a universal law – sometimes I have public functions that should be callable concurrently – but it happens less.</p><p>There is also an advantage to the current behavior for public functions in particular: it preserves forward compatibilty. Taking <code>&amp;mut self</code> (versus some subset of fields) means that the function can change the set of fields that it uses without affecting its clients. This is not a concern for private functions.</p><h2 id="step-4-internal-references">Step 4: Internal references</h2><p>Rust today cannot support structs whose fields refer to data owned by another. This gap is partially closed through crates like <a href="https://crates.io/crates/rental">rental</a> (no longer maintained), though more often by <a href="https://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">modeling internal references with indices</a>. We also have <code>Pin</code>, which covers the related (but even harder) problem of immobile data.</p><p>I’ve been chipping away at a solution to this problem for some time. I won’t be able to lay it out in full in this post, but I can sketch what I have in mind, and lay out more details in future posts (I have done some formalization of this, enough to convince myself it works).</p><p>As an example, imagine that we have some kind of <code>Message</code> struct consisting of a big string along with several references into that string. You could model that like so:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Message</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>text</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>headers</span>: <span>Vec</span><span>&lt;</span><span>(</span><span>&amp;</span><span>&#39;self</span><span>.</span><span>text</span><span> </span><span>str</span><span>,</span><span> </span><span>&amp;</span><span>&#39;self</span><span>.</span><span>text</span><span> </span><span>str</span><span>)</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>body</span>: <span>&amp;</span><span>&#39;self</span><span>.</span><span>text</span><span> </span><span>str</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This message would be constructed in the usual way:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>text</span>: <span>String</span> <span>=</span><span> </span><span>parse_text</span><span>();</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>(</span><span>headers</span><span>,</span><span> </span><span>body</span><span>)</span><span> </span><span>=</span><span> </span><span>parse_message</span><span>(</span><span>&amp;</span><span>text</span><span>);</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>message</span><span> </span><span>=</span><span> </span><span>Message</span><span> </span><span>{</span><span> </span><span>text</span><span>,</span><span> </span><span>headers</span><span>,</span><span> </span><span>body</span><span> </span><span>};</span><span>
</span></span></span></code></pre></div><p>where <code>parse_message</code> is some function like</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>parse_message</span><span>(</span><span>text</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>(</span><span>
</span></span></span><span><span><span>    </span><span>Vec</span><span>&lt;</span><span>(</span><span>&amp;</span><span>&#39;text</span><span> </span><span>str</span><span>,</span><span> </span><span>&amp;</span><span>&#39;text</span><span> </span><span>str</span><span>)</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>&amp;</span><span>&#39;text</span><span> </span><span>str</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>headers</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[];</span><span>
</span></span></span><span><span><span>    </span><span>// ...
</span></span></span><span><span><span></span><span>    </span><span>(</span><span>headers</span><span>,</span><span> </span><span>body</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Note that <code>Message</code> doesn’t have any lifetime parameters – it doesn’t need any, because it doesn’t borrow from anything outside of itself. In fact, <code>Message: &#39;static</code> is true, which means that I could send this <code>Message</code> to another thread:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// A channel of `Message` values:
</span></span></span><span><span><span></span><span>let</span><span> </span><span>(</span><span>tx</span><span>,</span><span> </span><span>rx</span><span>)</span><span> </span><span>=</span><span> </span><span>std</span>::<span>sync</span>::<span>mpsc</span>::<span>channel</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// A thread to consume those values:
</span></span></span><span><span><span></span><span>std</span>:<span>🧵</span>:<span>spawn</span><span>(</span><span>move</span><span> </span><span>||</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>message</span><span> </span><span>in</span><span> </span><span>rx</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// `message` here has type `Message`
</span></span></span><span><span><span></span><span>        </span><span>process</span><span>(</span><span>message</span><span>.</span><span>body</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>});</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Produce them:
</span></span></span><span><span><span></span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>message</span>: <span>Message</span><span> </span><span>=</span><span> </span><span>next_message</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>tx</span><span>.</span><span>send</span><span>(</span><span>message</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="how-far-along-are-each-of-these-ideas">How far along are each of these ideas?</h2><p>Roughly speaking…</p><ul><li>Polonius – ‘just’ engineering</li><li>Syntax – ‘just’ bikeshedding</li><li>View types – needs modeling, one or two open questions in my mind<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></li><li>Internal references – modeled in some detail for a simplified variant of Rust, have to port to Rust and explain the assumptions I made along the way<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></li></ul><p>…in other words, I’ve done enough work to to convince myself that these designs are practical, but plenty of work remains. :)</p><h2 id="how-do-we-prioritize-this-work">How do we prioritize this work?</h2><p>Whenever I think about investing in borrow checker ergonomics and usability, I feel a bit guilty. Surely something so fun to think about must be a bad use of my time.</p><p>Conversations at RustNL shifted my perspective. When I asked people about pain points, I kept hearing the same few themes arise, especially from people trying building applications or GUIs.</p><p>I now think I had fallen victim to the dreaded “curse of knowledge”, forgetting how frustrating it can be to run into a limitation of the borrow checker and not know how to resolve it.</p><h2 id="conclusion">Conclusion</h2><p>This post proposes four changes attacking some very long-standing problems:</p><ul><li><strong>Conditionally returned references</strong>, solved by <a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Polonius</a></li><li><strong>No or awkward syntax for lifetimes</strong>, solved by an <a href="https://smallcultfollowing.com/babysteps/blog/2024/03/04/borrow-checking-without-lifetimes/">explicit lifetime syntax</a></li><li><strong>Helper methods whose body must be inlined</strong>, solved by <a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">view types</a></li><li><strong>Can’t “package up” a value and references into that value</strong>, solved by interior references</li></ul><p>You may have noticed that these changes build on one another. Polonius remodels borrowing in terms of “place expressions” (variables, fields). This enables an explicit lifetime syntax, which in turn is a key building block for interior references. View types in turn let us expose helper methods that can operate on ‘partially borrowed’ (or even partially initialized!) values.</p><h3 id="why-these-changes-wont-make-rust-more-complex-or-if-they-do-its-worth-it">Why these changes won’t make Rust “more complex” (or, if they do, it’s worth it)</h3><p>You might wonder about the impact of these changes on Rust’s complexity. Certainly they grow the set of things the type system can express. But in my mind they, like <a href="https://rust-lang.github.io/rfcs/2094-nll.html">NLL</a> before them, fall into that category of changes that will actually make using Rust feel <em>simpler</em> overall.</p><p>To see why, put yourself in the shoes of a user today who has written any one of the “obviously correct” programs we’ve seen in this post – for example, <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c9f5902084a631a8af5b769c094b69b6">the <code>WidgetFactory</code> code we saw in view types</a>. Compiling this code today gives an error:</p><pre tabindex="0"><code>error[E0502]: cannot borrow `*self` as mutable
              because it is also borrowed as immutable
  --&gt; src/lib.rs:14:17
   |
12 | for widget in &amp;self.widgets {
   |               -------------
   |               |
   |               immutable borrow occurs here
   |               immutable borrow later used here
13 |     if widget.should_be_counted() {
14 |         self.increment_counter();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         mutable borrow occurs here
</code></pre><p>Despite all our efforts to render it well, this error is <strong>inherently confusing</strong>. It is not possible to explain why <code>WidgetFactory</code> doesn’t work from an “intuitive” point-of-view because <strong>conceptually it <em>ought</em> to work</strong>, it just runs up against a limit of our type system.</p><p>The only way to understand why <code>WidgetFactory</code> doesn’t compile is to dive deeper into the engineering details of how the Rust type system functions, and that is precisely the kind of thing people <em>don’t</em> want to learn. Moreover, once you’ve done that deep dive, what is your reward? At best you can devise an awkward workaround. Yay 🥳.<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup></p><p>Now imagine what happens with view types. You still get an error, but now that error can come with a suggestion:</p><pre tabindex="0"><code>help: consider declaring the fields
      accessed by `increment_counter` so that
      other functions can rely on that
 7 | fn increment_counter(&amp;mut self) {
   |                      ---------
   |                      |
   |      help: annotate with accessed fields: `&amp;mut {counter} self`
</code></pre><p>You now have two choices. First, you can apply the suggestion and move on – your code works! Next, at your leisure, you can dig in a bit deeper and understand what’s going on. You can learn about the semver hazards that motivate an explicit declaration here.</p><p>Yes, you’ve learned a new detail of the type system, but you did so <strong>on your schedule</strong> and, where extra annotations were required, they were well-motivated. Yay 🥳!<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup></p><h3 id="reifying-the-borrow-checker-into-types">Reifying the borrow checker into types</h3><p>There is another theme running through here: moving the borrow checker analysis out from the compiler’s mind and into types that can be expressed. Right now, all types always represent fully initialized, unborrowed values. There is no way to express a type that captures the state of being in the midst of iterating over something or having moved one or two fields but not all of them. These changes address that gap.<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup></p><h3 id="this-conclusion-is-too-long">This conclusion is too long</h3><p>I know, I’m like Peter Jackson trying to end “The Return of the King”, I just can’t do it! I keep coming up with more things to say. Well, I’ll stop now. Have a nice weekend y’all.</p></div></div>
  </body>
</html>
