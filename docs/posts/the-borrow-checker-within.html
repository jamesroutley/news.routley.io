<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smallcultfollowing.com/babysteps/blog/2024/06/02/the-borrow-checker-within/">Original</a>
    <h1>The borrow checker within</h1>
    
    <div id="readability-page-1" class="page"><div><p>This post lays out a 4-part roadmap for the borrow checker that I call â€œthe borrow checker withinâ€. These changes are meant to help Rust become a better version of itself, enabling patterns of code which feel like they fit within Rustâ€™s <em>spirit</em>, but run afoul of the letter of its <em>law</em>. I feel fairly comfortable with the design for each of these items, though work remains to scope out the details. My belief is that a-mir-formality will make a perfect place to do that work.</p><h2 id="rusts-spirit-is-mutation-xor-sharing">Rustâ€™s <em>spirit</em> is <em>mutation xor sharing</em></h2><p>When I refer to the <em>spirit</em> of the borrow checker, I mean the rules of <em>mutation xor sharing</em> that I see as Rustâ€™s core design ethos. This basic ruleâ€”that when you are mutating a value using the variable <code>x</code>, you should not also be reading that data through a variable <code>y</code>â€”is what enables Rustâ€™s memory safety guarantees and also, I think, contributes to its overall sense of â€œif it compiles, it worksâ€.</p><p><em>Mutation xor sharing</em> is, in some sense, neither necessary nor sufficient. Itâ€™s not <em>necessary</em> because there are many programs (like every program written in Java) that share data like crazy and yet still work fine<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. Itâ€™s also not <em>sufficient</em> in that there are many problems that demand some amount of sharing â€“ which is why Rust has â€œbackdoorsâ€ like <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, <code>AtomicU32</code>, andâ€”the ultimate backdoor of them allâ€”<code>unsafe</code>.</p><p>But to me the biggest surprise from working on Rust is how often this <em>mutation xor sharing</em> pattern is â€œjust rightâ€, once you learn how to work with it<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. The other surprise has been seeing the benefits over time: programs written in this style are fundamentally â€œless surprisingâ€ which, in turn, means they are more maintainable over time.</p><p>In Rust today though there are a number of patterns that are rejected by the borrow checker despite fitting the <em>mutation xor sharing</em> pattern. Chipping away at this gap, helping to make the borrow checkerâ€™s rules a more perfect reflection of <em>mutation xor sharing</em>, is what I mean by <em>the borrow checker within</em>.</p><blockquote><p>I saw the angel in the marble and carved until I set him free. â€” Michelangelo</p></blockquote><h2 id="ok-enough-inspirational-rhetoric-lets-get-to-the-code">OK, enough inspirational rhetoric, letâ€™s get to the code.</h2><p>Ahem, right. Letâ€™s do that.</p><h2 id="step-1-conditionally-return-references-easily-with-polonius">Step 1: Conditionally return references easily with â€œPoloniusâ€</h2><p>Rust 2018 introduced <a href="https://rust-lang.github.io/rfcs/2094-nll.html">â€œnon-lexical lifetimesâ€</a> â€” this rather cryptic name refers to an extension of the borrow checker so that it understood the control flow within functions much more deeply. This change made using Rust a much more â€œfluidâ€ experience, since the borrow checker was able to accept a lot more code.</p><p>But NLL does not handle one important case<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>: conditionally returning references. Here is the canonical example, taken from Remyâ€™s <a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Polonius update blog post</a>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_default</span><span>&lt;</span><span>&#39;r</span><span>,</span><span> </span><span>K</span>: <span>Hash</span><span> </span><span>+</span><span> </span><span>Eq</span><span> </span><span>+</span><span> </span><span>Copy</span><span>,</span><span> </span><span>V</span>: <span>Default</span><span>&gt;</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>map</span>: <span>&amp;</span><span>&#39;r</span> <span>mut</span><span> </span><span>HashMap</span><span>&lt;</span><span>K</span><span>,</span><span> </span><span>V</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>key</span>: <span>K</span><span>,</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>&#39;r</span> <span>mut</span><span> </span><span>V</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>map</span><span>.</span><span>get_mut</span><span>(</span><span>&amp;</span><span>key</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Some</span><span>(</span><span>value</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>value</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>map</span><span>.</span><span>insert</span><span>(</span><span>key</span><span>,</span><span> </span><span>V</span>::<span>default</span><span>());</span><span>
</span></span></span><span><span><span>            </span><span>//  ------ ğŸ’¥ Gets an error today,
</span></span></span><span><span><span></span><span>            </span><span>//            but not with polonius
</span></span></span><span><span><span></span><span>            </span><span>map</span><span>.</span><span>get_mut</span><span>(</span><span>&amp;</span><span>key</span><span>).</span><span>unwrap</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>  
</span></span></span></code></pre></div><p><a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Remyâ€™s post</a> gives more details about why this occurs and how we plan to fix it. Itâ€™s mostly accurate except that the timeline has stretched on more than Iâ€™d like (of course). But we are making steady progress these days.</p><h2 id="step-2-a-syntax-for-lifetimes-based-on-places">Step 2: A syntax for lifetimes based on places</h2><p>The next step is to add an explicit syntax for lifetimes based on â€œplace expressionsâ€ (e.g., <code>x</code> or <code>x.y</code>). I wrote about this in my post <a href="https://smallcultfollowing.com/babysteps/blog/2024/03/04/borrow-checking-without-lifetimes/">Borrow checking without lifetimes</a>. This is basically taking the formulation that underlies Polonius and adding a syntax.</p><p>The idea would be that, in addition to the abstract lifetime parameters we have today, you could reference program variables and even fields as the â€œlifetimeâ€ of a reference. So you could write <code>â€™x</code> to indicate a value that is â€œborrowed from the variable <code>x</code>â€. You could also write <code>â€™x.y</code> to indicate that it was borrowed from the field <code>y</code> of <code>x</code>, and even <code>&#39;(x.y, z)</code> to mean borrowed from <em>either</em> <code>x.y</code> or <code>z</code>. For example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>manufacturer</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>model</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>new_widget</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>name</span>: <span>String</span><span>)</span><span> </span>-&gt; <span>Widget</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>name_suffix</span>: <span>&amp;</span><span>â€™</span><span>name</span><span> </span><span>str</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>name</span><span>[</span><span>3</span><span>..</span><span>];</span><span>
</span></span></span><span><span><span>                       </span><span>// â€”â€”- borrowed from â€œnameâ€
</span></span></span><span><span><span></span><span>        </span><span>let</span><span> </span><span>model_prefix</span>: <span>&amp;</span><span>â€™</span><span>self</span><span>.</span><span>model</span><span> </span><span>str</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>model</span><span>[</span><span>..</span><span>2</span><span>];</span><span>
</span></span></span><span><span><span>                         </span><span>// â€”â€”â€”â€”â€”- borrowed from â€œself.modelâ€
</span></span></span><span><span><span></span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This would make many of lifetime parameters we write today unnecessary. For example, the classic Polonius example where the function takes a parameter <code>map: &amp;mut Hashmap&lt;K, V&gt;</code> and returns a reference into the map can be written as follows:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_default</span><span>&lt;</span><span>K</span>: <span>Hash</span><span> </span><span>+</span><span> </span><span>Eq</span><span> </span><span>+</span><span> </span><span>Copy</span><span>,</span><span> </span><span>V</span>: <span>Default</span><span>&gt;</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>map</span>: <span>&amp;</span><span>mut</span><span> </span><span>HashMap</span><span>&lt;</span><span>K</span><span>,</span><span> </span><span>V</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>key</span>: <span>K</span><span>,</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>&#39;map</span> <span>mut</span><span> </span><span>V</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>//---- &#34;borrowed from the parameter map&#34;
</span></span></span><span><span><span></span><span>    </span><span>..</span><span>.</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This syntax is more convenient â€” but I think its bigger impact will be to make Rust more teachable and learnable. Right now, lifetimes are in a tricky place, because</p><ul><li>they represent a concept (spans of code) that isnâ€™t normal for users to think explicitly about and</li><li>they donâ€™t have any kind of syntax.</li></ul><p>Syntax is useful when learning because it allows you to make everything explicit, which is a critical intermediate step to really internalizing a concept â€” what boats memorably called the <a href="https://github.com/rust-lang/rfcs/pull/2071#issuecomment-329026602">dialectical ratchet</a>. Anecdotally Iâ€™ve been using a â€œplace-basedâ€ syntax when teaching people Rust and Iâ€™ve found it is much quicker for them to grasp it.</p><h2 id="step-3-view-types-and-interprocedural-borrows">Step 3: View types and interprocedural borrows</h2><p>The next piece of the plan is <a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">view types</a>, which are a way to have functions declare which fields they access. Consider a struct like <code>WidgetFactory</code>â€¦</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>counter</span>: <span>usize</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>widgets</span>: <span>Vec</span><span>&lt;</span><span>Widget</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>â€¦which has a helper function <code>increment_counter</code>â€¦</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>increment_counter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Today, if we want to iterate over the widgets and occasionally increment the counter with <code>increment_counter</code>, <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=afeb1a8021ab1abf73639ffea0bbcae3">we will encounter an error</a>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>increment_counter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>..</span><span>.}</span><span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>count_widgets</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>for</span><span> </span><span>widget</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>widgets</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>if</span><span> </span><span>widget</span><span>.</span><span>should_be_counted</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>self</span><span>.</span><span>increment_counter</span><span>();</span><span>
</span></span></span><span><span><span>                </span><span>// ^ ğŸ’¥ Can&#39;t borrow self as mutable
</span></span></span><span><span><span></span><span>                </span><span>//      while iterating over `self.widgets`
</span></span></span><span><span><span></span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>    
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The problem is that the borrow checker operates one function at a time. It doesnâ€™t know precisely which fields <code>increment_counter</code> is going to mutate. So it conservatively assumes that <code>self.widgets</code> may be changed, and thatâ€™s not allowed. There are a number of workarounds today, such as writing a â€œfree functionâ€ that doesnâ€™t take <code>&amp;mut self</code> but rather takes references to the individual fields (e.g., <code>counter: &amp;mut usize</code>) or even collecting those references into a â€œview structâ€ (e.g., <code>struct WidgetFactoryView&lt;&#39;a&gt; { widgets: &amp;&#39;a [Widget], counter: &amp;&#39;a mut usize }</code>) but these are non-obvious, annoying, and non-local (they require changing significant parts of your code)</p><p><a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">View types</a> extend struct types so that instead of just having a type like <code>WidgetFactory</code>, you can have a â€œviewâ€ on that type that included only a subset of the fields, like <code>{counter} WidgetFactory</code>. We can use this to modify <code>increment_counter</code> so that it declares that it will only access the field <code>counter</code>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>WidgetFactory</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>increment_counter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>{</span><span>counter</span><span>}</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>//               -------------------
</span></span></span><span><span><span></span><span>        </span><span>// Equivalent to `self: &amp;mut {counter} WidgetFactory`
</span></span></span><span><span><span></span><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This allows the compiler to compile <code>count_widgets</code> just fine, since it can see that iterating over <code>self.widgets</code> while modifying <code>self.counter</code> is not a problem.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p><h3 id="view-types-also-address-phased-initialization">View types also address phased initialization</h3><p>There is another place where the borrow checkerâ€™s rules fall short: <em>phased initialization</em>. Rust today follows the functional programming language style of requiring values for all the fields of a struct when it is created. Mostly this is fine, but sometimes you have structs where you want to initialize some of the fields and then invoke helper functions, much like <code>increment_counter</code>, to create the remainder. In this scenario you are stuck, because those helper functions cannot take a reference to the struct since you havenâ€™t created the struct yet. The workarounds (free functions, intermediate struct types) are very similar.</p><h3 id="start-with-private-functions-consider-scaling-to-public-functions">Start with private functions, consider scaling to public functions</h3><p>View types as described here have limitations. Because the types involve the names of fields, they are not really suitable for public interfaces. They could also be annoying to use in practice because one will have sets of fields that go together that have to be manually copied and pasted. All of this is true but I think something that can be addressed later (e.g., with named groups of fields).</p><p>What Iâ€™ve found is that the majority of times that I want to use view types, it is in <em>private</em> functions. Private methods often do little bits of logic and make use of the structâ€™s internal structure. Public methods in contrast tend to do larger operations and to hide that internal structure from users. This isnâ€™t a universal law â€“ sometimes I have public functions that should be callable concurrently â€“ but it happens less.</p><p>There is also an advantage to the current behavior for public functions in particular: it preserves forward compatibilty. Taking <code>&amp;mut self</code> (versus some subset of fields) means that the function can change the set of fields that it uses without affecting its clients. This is not a concern for private functions.</p><h2 id="step-4-internal-references">Step 4: Internal references</h2><p>Rust today cannot support structs whose fields refer to data owned by another. This gap is partially closed through crates like <a href="https://crates.io/crates/rental">rental</a> (no longer maintained), though more often by <a href="https://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">modeling internal references with indices</a>. We also have <code>Pin</code>, which covers the related (but even harder) problem of immobile data.</p><p>Iâ€™ve been chipping away at a solution to this problem for some time. I wonâ€™t be able to lay it out in full in this post, but I can sketch what I have in mind, and lay out more details in future posts (I have done some formalization of this, enough to convince myself it works).</p><p>As an example, imagine that we have some kind of <code>Message</code> struct consisting of a big string along with several references into that string. You could model that like so:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Message</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>text</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>headers</span>: <span>Vec</span><span>&lt;</span><span>(</span><span>&amp;</span><span>&#39;self</span><span>.</span><span>text</span><span> </span><span>str</span><span>,</span><span> </span><span>&amp;</span><span>&#39;self</span><span>.</span><span>text</span><span> </span><span>str</span><span>)</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>body</span>: <span>&amp;</span><span>&#39;self</span><span>.</span><span>text</span><span> </span><span>str</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This message would be constructed in the usual way:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>text</span>: <span>String</span> <span>=</span><span> </span><span>parse_text</span><span>();</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>(</span><span>headers</span><span>,</span><span> </span><span>body</span><span>)</span><span> </span><span>=</span><span> </span><span>parse_message</span><span>(</span><span>&amp;</span><span>text</span><span>);</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>message</span><span> </span><span>=</span><span> </span><span>Message</span><span> </span><span>{</span><span> </span><span>text</span><span>,</span><span> </span><span>headers</span><span>,</span><span> </span><span>body</span><span> </span><span>};</span><span>
</span></span></span></code></pre></div><p>where <code>parse_message</code> is some function like</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>parse_message</span><span>(</span><span>text</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>(</span><span>
</span></span></span><span><span><span>    </span><span>Vec</span><span>&lt;</span><span>(</span><span>&amp;</span><span>&#39;text</span><span> </span><span>str</span><span>,</span><span> </span><span>&amp;</span><span>&#39;text</span><span> </span><span>str</span><span>)</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>&amp;</span><span>&#39;text</span><span> </span><span>str</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>headers</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[];</span><span>
</span></span></span><span><span><span>    </span><span>// ...
</span></span></span><span><span><span></span><span>    </span><span>(</span><span>headers</span><span>,</span><span> </span><span>body</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Note that <code>Message</code> doesnâ€™t have any lifetime parameters â€“ it doesnâ€™t need any, because it doesnâ€™t borrow from anything outside of itself. In fact, <code>Message: &#39;static</code> is true, which means that I could send this <code>Message</code> to another thread:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// A channel of `Message` values:
</span></span></span><span><span><span></span><span>let</span><span> </span><span>(</span><span>tx</span><span>,</span><span> </span><span>rx</span><span>)</span><span> </span><span>=</span><span> </span><span>std</span>::<span>sync</span>::<span>mpsc</span>::<span>channel</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// A thread to consume those values:
</span></span></span><span><span><span></span><span>std</span>:<span>ğŸ§µ</span>:<span>spawn</span><span>(</span><span>move</span><span> </span><span>||</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>message</span><span> </span><span>in</span><span> </span><span>rx</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// `message` here has type `Message`
</span></span></span><span><span><span></span><span>        </span><span>process</span><span>(</span><span>message</span><span>.</span><span>body</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>});</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Produce them:
</span></span></span><span><span><span></span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>message</span>: <span>Message</span><span> </span><span>=</span><span> </span><span>next_message</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>tx</span><span>.</span><span>send</span><span>(</span><span>message</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="how-far-along-are-each-of-these-ideas">How far along are each of these ideas?</h2><p>Roughly speakingâ€¦</p><ul><li>Polonius â€“ â€˜justâ€™ engineering</li><li>Syntax â€“ â€˜justâ€™ bikeshedding</li><li>View types â€“ needs modeling, one or two open questions in my mind<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></li><li>Internal references â€“ modeled in some detail for a simplified variant of Rust, have to port to Rust and explain the assumptions I made along the way<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></li></ul><p>â€¦in other words, Iâ€™ve done enough work to to convince myself that these designs are practical, but plenty of work remains. :)</p><h2 id="how-do-we-prioritize-this-work">How do we prioritize this work?</h2><p>Whenever I think about investing in borrow checker ergonomics and usability, I feel a bit guilty. Surely something so fun to think about must be a bad use of my time.</p><p>Conversations at RustNL shifted my perspective. When I asked people about pain points, I kept hearing the same few themes arise, especially from people trying building applications or GUIs.</p><p>I now think I had fallen victim to the dreaded â€œcurse of knowledgeâ€, forgetting how frustrating it can be to run into a limitation of the borrow checker and not know how to resolve it.</p><h2 id="conclusion">Conclusion</h2><p>This post proposes four changes attacking some very long-standing problems:</p><ul><li><strong>Conditionally returned references</strong>, solved by <a href="https://blog.rust-lang.org/inside-rust/2023/10/06/polonius-update.html">Polonius</a></li><li><strong>No or awkward syntax for lifetimes</strong>, solved by an <a href="https://smallcultfollowing.com/babysteps/blog/2024/03/04/borrow-checking-without-lifetimes/">explicit lifetime syntax</a></li><li><strong>Helper methods whose body must be inlined</strong>, solved by <a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">view types</a></li><li><strong>Canâ€™t â€œpackage upâ€ a value and references into that value</strong>, solved by interior references</li></ul><p>You may have noticed that these changes build on one another. Polonius remodels borrowing in terms of â€œplace expressionsâ€ (variables, fields). This enables an explicit lifetime syntax, which in turn is a key building block for interior references. View types in turn let us expose helper methods that can operate on â€˜partially borrowedâ€™ (or even partially initialized!) values.</p><h3 id="why-these-changes-wont-make-rust-more-complex-or-if-they-do-its-worth-it">Why these changes wonâ€™t make Rust â€œmore complexâ€ (or, if they do, itâ€™s worth it)</h3><p>You might wonder about the impact of these changes on Rustâ€™s complexity. Certainly they grow the set of things the type system can express. But in my mind they, like <a href="https://rust-lang.github.io/rfcs/2094-nll.html">NLL</a> before them, fall into that category of changes that will actually make using Rust feel <em>simpler</em> overall.</p><p>To see why, put yourself in the shoes of a user today who has written any one of the â€œobviously correctâ€ programs weâ€™ve seen in this post â€“ for example, <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c9f5902084a631a8af5b769c094b69b6">the <code>WidgetFactory</code> code we saw in view types</a>. Compiling this code today gives an error:</p><pre tabindex="0"><code>error[E0502]: cannot borrow `*self` as mutable
              because it is also borrowed as immutable
  --&gt; src/lib.rs:14:17
   |
12 | for widget in &amp;self.widgets {
   |               -------------
   |               |
   |               immutable borrow occurs here
   |               immutable borrow later used here
13 |     if widget.should_be_counted() {
14 |         self.increment_counter();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         mutable borrow occurs here
</code></pre><p>Despite all our efforts to render it well, this error is <strong>inherently confusing</strong>. It is not possible to explain why <code>WidgetFactory</code> doesnâ€™t work from an â€œintuitiveâ€ point-of-view because <strong>conceptually it <em>ought</em> to work</strong>, it just runs up against a limit of our type system.</p><p>The only way to understand why <code>WidgetFactory</code> doesnâ€™t compile is to dive deeper into the engineering details of how the Rust type system functions, and that is precisely the kind of thing people <em>donâ€™t</em> want to learn. Moreover, once youâ€™ve done that deep dive, what is your reward? At best you can devise an awkward workaround. Yay ğŸ¥³.<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup></p><p>Now imagine what happens with view types. You still get an error, but now that error can come with a suggestion:</p><pre tabindex="0"><code>help: consider declaring the fields
      accessed by `increment_counter` so that
      other functions can rely on that
 7 | fn increment_counter(&amp;mut self) {
   |                      ---------
   |                      |
   |      help: annotate with accessed fields: `&amp;mut {counter} self`
</code></pre><p>You now have two choices. First, you can apply the suggestion and move on â€“ your code works! Next, at your leisure, you can dig in a bit deeper and understand whatâ€™s going on. You can learn about the semver hazards that motivate an explicit declaration here.</p><p>Yes, youâ€™ve learned a new detail of the type system, but you did so <strong>on your schedule</strong> and, where extra annotations were required, they were well-motivated. Yay ğŸ¥³!<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup></p><h3 id="reifying-the-borrow-checker-into-types">Reifying the borrow checker into types</h3><p>There is another theme running through here: moving the borrow checker analysis out from the compilerâ€™s mind and into types that can be expressed. Right now, all types always represent fully initialized, unborrowed values. There is no way to express a type that captures the state of being in the midst of iterating over something or having moved one or two fields but not all of them. These changes address that gap.<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup></p><h3 id="this-conclusion-is-too-long">This conclusion is too long</h3><p>I know, Iâ€™m like Peter Jackson trying to end â€œThe Return of the Kingâ€, I just canâ€™t do it! I keep coming up with more things to say. Well, Iâ€™ll stop now. Have a nice weekend yâ€™all.</p><div role="doc-endnotes"><hr/><ol><li id="fn:1"><p>Well, every program written in Java <em>does</em> share data like crazy, but they do not all work fine. But you get what I mean.Â <a href="#fnref:1" role="doc-backlink">â†©ï¸</a></p></li><li id="fn:2"><p>And I think learning how to work with <em>mutation xor sharing</em> is a big part of what it means to learn Rust.Â <a href="#fnref:2" role="doc-backlink">â†©ï¸</a></p></li><li id="fn:3"><p>NLL as implemented, anyway. The original design was meant to cover conditionally returning references, but the proposed type system was not feasible to implement. Moreover, and I say this as the one who designed it, the formulation in the NLL RFC was not good. It was mind-bending and hard to comprehend. Polonius is much better.Â <a href="#fnref:3" role="doc-backlink">â†©ï¸</a></p></li><li id="fn:4"><p>In fact, view types will also allow us to implement the â€œdisjoint closure captureâ€ rules from <a href="https://rust-lang.github.io/rfcs/2229-capture-disjoint-fields.html">RFC 2229</a> in a more efficient way. Currently a closure using <code>self.widgets</code> and <code>self.counter</code> will store 2 references, kind of an implicit â€œview structâ€. Although <a href="https://rust-lang.zulipchat.com/#narrow/stream/189812-t-compiler.2Fwg-rfc-2229/topic/measure.20closure.20sizes">we found this doesnâ€™t really affect much code in practice</a>, it still bothers me. With view types they could store 1.Â <a href="#fnref:4" role="doc-backlink">â†©ï¸</a></p></li><li id="fn:5"><p>To me, the biggest open question for view types is how to accommodate â€œstrong updatesâ€ to types. Iâ€™d like to be able to do <code>let mut wf: {} WidgetFactory = WidgetFactory {}</code> to create a <code>WidgetFactory</code> value that is completely uninitialized and then permit writing (for example) <code>wf.counter = 0</code>. This should update the type of <code>wf</code> to <code>{counter} WidgetFactory</code>. Basically I want to link the information found in types with the borrow checkerâ€™s notion of what is initialized, but I havenâ€™t worked that out in detail.Â <a href="#fnref:5" role="doc-backlink">â†©ï¸</a></p></li><li id="fn:6"><p>As an example, to make this work Iâ€™m assuming some kind of â€œtrue derefâ€ trait that indicates that <code>Deref</code> yields a reference that remains valid even as the value being derefâ€™d moves from place to place. We need a trait much like this for other reasons too.Â <a href="#fnref:6" role="doc-backlink">â†©ï¸</a></p></li><li id="fn:7"><p>Thatâ€™s a sarcastic â€œYay ğŸ¥³â€, in case you couldnâ€™t tell.Â <a href="#fnref:7" role="doc-backlink">â†©ï¸</a></p></li><li id="fn:8"><p>This â€œYay ğŸ¥³â€ is genuine.Â <a href="#fnref:8" role="doc-backlink">â†©ï¸</a></p></li><li id="fn:9"><p>I remember years ago presenting Rust at some academic conference and a friendly professor telling me, â€œIn my experience, you always want to get that state into the type systemâ€. I think that professor was right, though I donâ€™t regret not prioritizing it (always a million things to do, better to ask what is the right next step <em>now</em> than to worry about what step mightâ€™ve been better in the past). Anyway, I wish I could remember <em>who</em> that was!Â <a href="#fnref:9" role="doc-backlink">â†©ï¸</a></p></li></ol></div></div></div>
  </body>
</html>
