<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fuzzypixelz.com/blog/deref-confusion/">Original</a>
    <h1>Mistakes with Rust smart pointers: when Deref goes wrong</h1>
    
    <div id="readability-page-1" class="page"><article id="blog-page-article">
<h2 id="prologue">Prologue</h2>
<p>The following is an attempt at highlighting the sources of <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">high
astonishment</a>
arising from the implementation of the
<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>std::ops::Deref</code></a> trait on
custom types.</p>
<p>I write this, in part, because I had recently used <code>Deref</code> inappropriately while
at <code>$day_job</code>, due to my lack of a full understanding of how <code>Deref</code> interacts
with the rest of the language. It should go without saying that this was a
confusing experience.</p>
<p>Naturally, the aforementioned mishap will serve as a motivating example
throughout this dive into Rust semantics.</p>
<h2 id="newtypes">Newtypes</h2>
<p>I cannot share the full context surrounding my misuse of <code>Deref</code> (for both
pedagogic and legal reasons) so please understand that my motivating example
won&#39;t be well motivated itself.</p>
<p>With that disclaimer out of the way, suppose we&#39;re building a library that
provides an <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> string type called
<code>AsciiString</code>. A fitting representation of these so-called <em>byte strings</em> would
simply be a plain ol&#39; <code>Vec&lt;u8&gt;</code>.</p>
<p>However, ASCII characters are limited to the range <code>0..128</code>, and thus not any
value of type <code>Vec&lt;u8&gt;</code> would be a valid ASCII string. In other words, it&#39;s not
a good idea to
<a href="https://doc.rust-lang.org/reference/items/type-aliases.html">alias</a>
<code>AsciiString</code> to <code>Vec&lt;u8&gt;</code>; <a href="https://lexi-lambda.github.io/blog/2020/11/01/names-are-not-type-safety/">they are not
interchangeable</a>.</p>
<p>In Rust, it is considered good practice to enforce invariants at the type
level. Thus, the idiomatic course of action would be to use a
<a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html">newtype</a> to
wrap a <code>Vec&lt;u8&gt;</code> and then statically guarantee that all wrapped byte vectors
represent valid ASCII strings.</p>
<pre data-lang="rust"><code data-lang="rust">/// An ASCII-encoded, growable string.
struct AsciiString(Vec<u8>);

impl AsciiString {
    /// Range of valid ASCII bytes.
    const ASCII_RANGE: Range<u8> = 0..128;

    /// Converts a byte vector to an `AsciiString`.
    ///
    /// # Errors
    /// Returns `Err` if any byte in `vec` 
    /// falls outside the range [`Self::ASCII_RANGE`].
    fn from_ascii(vec: Vec<u8>) -&gt; Result<self, asciierror=""> {
        if vec
            .iter()
            .all(|b| Self::ASCII_RANGE.contains(b))
        {
            Ok(Self(vec))
        } else {
            Err(AsciiError)
        }
    }
}
</self,></u8></u8></u8></code></pre>
<h2 id="explicit-conversion">Explicit conversion</h2>
<p>UTF-8 is backward compatible with ASCII. This means that we can freely
reinterpret any well-constructed <code>AsciiString</code> value to a <code>str</code> value. What we
stand to gain from this is compatibility with code written with UTF-8 strings in
mind.</p>
<pre data-lang="rust"><code data-lang="rust">impl AsciiString {
    fn as_str(&amp;self) -&gt; &amp;str {
        debug_assert!(str::from_utf8(&amp;self.0).is_ok());

        // SAFETY: self.0 is ASCII-encoded, 
        // and ASCII is a subset of UTF-8
        unsafe { str::from_utf8_unchecked(&amp;self.0) }
    }
}
</code></pre>
<p>Two statements in, and the unspeakable keyword has already been uttered; I&#39;m
feeling pretty <a href="https://twitter.com/ManishEarth/status/901269205718155264">tall</a>
today and the temptation is frankly irresistible. Obviously, any bug surrounding
the construction of <code>AsciiString</code> values implies memory unsafely outside <code>debug</code>
mode.</p>
<p>Hold on a second. Both
<a href="https://doc.rust-lang.org/std/str/fn.from_utf8.html">std::str::from_utf8</a> and
<a href="https://doc.rust-lang.org/stable/std/str/fn.from_utf8_unchecked.html">std::str::from_utf8_unchecked</a>
take in a <code>&amp;[u8]</code> as an argument, while <code>&amp;self.0</code> is of type <code>&amp;Vec&lt;u8&gt;</code>; there
is definitely some kind of implicit coercion going on here. Is Rust not so
strongly typed after all?</p>
<h2 id="enter-deref">Enter <code>Deref</code></h2>
<pre data-lang="rust"><code data-lang="rust">pub trait Deref {
    type Target: ?Sized;

    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
</code></pre>
<p>We seem to have inadvertently run into <code>Deref</code> before I even got the chance to
introduce it properly. The <a href="https://www.youtube.com/watch?v=2bjk26RwjyU">simple</a>
explanation of why <code>&amp;Vec&lt;u8&gt;</code> was &#34;coerced&#34; to <code>&amp;[u8]</code> is that <code>Vec&lt;T&gt;</code>
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Deref-for-Vec%3CT,+A%3E">implements</a>
<code>Deref&lt;Target = [T]&gt;</code>. In short, the compiler conceptually transformed the
expression <code>str::from_utf8(&amp;self.0)</code> into something akin to:</p>
<pre data-lang="rust"><code data-lang="rust">str::from_utf8(<vec<u8> as Deref&gt;::deref(&amp;self.0))
</vec<u8></code></pre>
<p>This mechanism at play here is called <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">Deref
Coercion</a>,
and is defined by the interaction between two distinct mechanisms defined by The
Rust Reference: <a href="https://doc.rust-lang.org/nightly/reference/expressions/method-call-expr.html">Method
Resolution</a>
and <a href="https://doc.rust-lang.org/reference/type-coercions.html">Type
Coercion</a>. Having
already dropped so much jargon, I refrain from uncovering any gory details for
now.</p>
<h2 id="clean-codetm">Clean Code™</h2>
<p>For all practical purposes, <code>AsciiString:as_str</code> works perfectly as a sure and
simple way to convert any <code>&amp;AsciiString</code> reference to a <code>&amp;str</code>. However, it will
mean one would have to manually add <code>.as_str()</code> every time a conversion is
needed.</p>
<p>For dubious reasons involving &#34;clean code&#34; we shall implement <code>Deref&lt;Target = str&gt;</code> for <code>AsciiString</code>: the compiler will from now on call <code>.as_str()</code> on our
behalf.</p>
<pre data-lang="rust"><code data-lang="rust">impl Deref for AsciiString {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        self.as_str()
    }
}
</code></pre>
<h2 id="idiomatic-codetm">Idiomatic Code™</h2>
<p>For those who care not for aesthetics when it comes to computer programs — a
vulgar but arguably rational position — I shall appeal to Rust
idioms. Chapter 5 of the Rust API Guidelines contains a recommendation
titled
<a href="https://rust-lang.github.io/api-guidelines/predictability.html#only-smart-pointers-implement-deref-and-derefmut-c-deref">C-DEREF</a>
which states:</p>
<blockquote>
<p>The Deref traits are used implicitly by the compiler in many circumstances,
and interact with method resolution. The relevant rules are designed
specifically to accommodate smart pointers, and so the traits should be used
only for that purpose.</p>
</blockquote>
<p>Is <code>AsciiString</code> a smart pointer? What is a smart pointer anyway? That is a
<a href="https://users.rust-lang.org/t/what-are-smart-pointers/67361">debate</a> I&#39;m
uninterested in exploring here. However, the authors of the Rust API Guidelines
go on to give examples of smart pointers in the Standard Library:</p>
<ul>
<li><code>Box&lt;T&gt;</code></li>
<li><code>String</code> as a smart pointer to <code>str</code></li>
<li><code>Rc&lt;T&gt;</code></li>
<li><code>Arc&lt;T&gt;</code></li>
<li><code>Cow&lt;&#39;a, T&gt;</code></li>
</ul>
<p>On these grounds, I claim that <code>AsciiString</code> ought to be considered a smart
pointer to <code>str</code>. Note that the idea that <code>String</code> is a smart pointer is itself
often contested, since <code>String</code> is not generic over the data it points to the
way <code>Box&lt;T&gt;</code> and friends are.</p>
<h2 id="to-my-astonishment">To my astonishment</h2>
<p>Note that <code>AsciiString</code> inherits the implementation of <code>Index&lt;Range&lt;usize&gt;&gt;</code>
from <code>str</code>. We get this as a side effect of implementing <code>Deref</code> and it allows
us to borrow string slices from an <code>AsciiString</code>.</p>
<pre data-lang="rust"><code data-lang="rust">let data = vec![b&#39;A&#39;, b&#39;B&#39;, b&#39;C&#39;];
let ascii = AsciiString::from_ascii(data).unwrap();
assert_eq!(&amp;ascii[1..3], &#34;BC&#34;);
</code></pre>
<p>Up until now, we have been relatively well-behaved rustaceans. But where is the
fun in that? One cannot be writing production-ready code all the time, for that
is a sure path to madness.</p>
<p>Let&#39;s allow for <code>AsciiString</code> to be indexed using floating-point numbers;
precisely because we can.</p>
<pre data-lang="rust"><code data-lang="rust">impl Index<range<f64>&gt; for AsciiString {
    type Output = str;

    /// Returns an ASCII string slice by rounding 
    /// the given floating-point indices in `index`.
    fn index(&amp;self, index: Range<f64>) -&gt; &amp;Self::Output {
        /// Returns the integer nearest 
        /// to the absolute value of `float`.
        fn nearest_index(float: f64) -&gt; usize {
            float.abs().round() as usize
        }

        let start = nearest_index(index.start);
        let end = nearest_index(index.end);
        let string = self.as_str();

        &amp;string[start..end]
    }
}
</f64></range<f64></code></pre>
<p>You may be wondering what happens when your index is exactly halfway between two
integers. The answer is that <code>f64::round</code> will round <em>away from</em> <code>0.0</code>, thus
<code>0.5</code> will be rounded to <code>1</code>. At this point, we might as well have had <code>Index</code>
toss a coin to resolve this ambiguity.</p>
<pre data-lang="rust"><code data-lang="rust">let data = vec![b&#39;A&#39;, b&#39;B&#39;, b&#39;C&#39;];
let ascii = AsciiString::from_ascii(data).unwrap();
assert_eq!(&amp;ascii[1.5_f64..3_f64], &#34;BC&#34;);
</code></pre>
<p>We finally arrived at the part which surprised me and served as the motivation
for all that I wrote before and after this point: we <strong>no longer inherit</strong>
<code>Index&lt;Range&lt;usize&gt;&gt;</code> <strong>from</strong> <code>str</code>. The previous version of the above code
block doesn&#39;t compile anymore:</p>
<pre data-lang="console"><code data-lang="console">error[E0308]: mismatched types
  --&gt; src/main.rs:69:23
   |
69 |     assert_eq!(&amp;ascii[1..3], &#34;BC&#34;);
   |                       ^^^^ expected `Range<f64>`, 
   |                            found `Range&lt;{integer}&gt;`
   |
   = note: expected struct `std::ops::Range<f64>`
              found struct `std::ops::Range&lt;{integer}&gt;`
</f64></f64></code></pre>
<p>To me, this was incredibly confusing because <code>Index</code> is generic over its <code>Idx</code>
type, which means it&#39;s perfectly valid to have multiple implementations of
<code>Index&lt;Idx&gt;</code> for different <code>Idx</code> types.</p>
<p>Somehow, the compiler can no longer find the implementation of <code>Index&lt;usize&gt;</code> on
<code>&amp;str</code>. If you&#39;re like me, it&#39;s not at all obvious how that came to be. To
better understand all of this, we dig deeper into exactly how the compiler
resolves methods in the presence of a <code>Deref</code> implementation.</p>
<h2 id="nitty-gritty-details">Nitty-gritty details</h2>
<p><em>Everything I describe below is limited to commit
<a href="https://github.com/rust-lang/rust/tree/6bacf5a54468f8db33b6077405652f0ab0059174">6bacf5a</a>
of the Rust project, i.e. Rust 1.69.0</em>.</p>
<p>Method lookup in <code>rustc</code> is divided into two phases:
<a href="https://github.com/rust-lang/rust/blob/6bacf5a/compiler/rustc_hir_typeck/src/method/probe.rs" title="probe">probe</a> and
<a href="https://github.com/rust-lang/rust/blob/6bacf5a54468f8db33b6077405652f0ab0059174/compiler/rustc_hir_typeck/src/method/confirm.rs">confirm</a>. As
the <a href="https://rustc-dev-guide.rust-lang.org/method-lookup.html">Rust Compiler Development
Guide</a> explains,
<code>probe</code> is concerned with finding the callee method while <code>confirm</code> solves for
unknown type variables.</p>
<p>During the <code>probe</code> phase, the compiler would first perform a &#34;Deref-loop&#34;:
essentially repeated dereferencing of the receiver type, i.e. <code>AsciiString</code>. In
our particular case, this would yield two <em>steps</em>: <code>AsciiString</code> and <code>[u8]</code>.</p>
<p>Then, the compiler would <em>assemble</em> a list of <em>candidates</em> from each step. These
candidate methods are subsequently searched for one that fits the reliever
type. Up until this point, it seems that <code>rustc</code> should&#39;ve been able to find the
<code>index</code> method from the <code>Index&lt;Range&lt;usize&gt;&gt;</code> implementation on <code>[u8]</code> because
the search always includes Deref targets.</p>
<p>The issue, it turns out, is that method search does not check method parameter
types against argument types. Rather, it only checks for method names and
where-clauses such as <code>T: Trait</code>. Types are only resolved in the <code>confirm</code> phase,
at which point <code>rustc</code> would have already <em>picked</em> its method.</p>
<p>But why is method lookup in <code>rustc</code> split into two phases? The answer lies in
the cacheability of the <em>picks</em> provided by the <code>probe</code> phase. In other words,
<code>rustc</code> developers wished to reuse <code>probe</code> search results of identical methods,
hence why <code>probe</code> cannot depend on inferred types local to one particular call
site. I would wager that this was most likely done to address performance
issues.</p>
<p>If you can spot any inaccuracies in the above description, please don&#39;t shy away
from correcting me via email. I would appreciate it, as I am by no means a
<code>rustc</code> developer.</p>
<h2 id="epilogue">Epilogue</h2>
<p>Moral of the story: don&#39;t implement <code>Deref</code> kids!</p>
<p>On a more serious note, if one does implement <code>Deref&lt;Target = U&gt;</code> on a type <code>T</code>,
<em>and</em> it proved necessary to implement a generic trait <code>Trait&lt;S&gt;</code> on <code>T</code>. Then
one should ensure that the implementations of <code>Trait&lt;S&gt;</code> for different
parameters <code>S</code> <strong>are not scattered across <code>T</code> and <code>U</code></strong>.</p>
<p>Put simply, either <code>T</code> or <code>U</code> should host all existing <code>Trait&lt;S&gt;</code>
implementations. Note that the preceding &#34;or&#34; is <em>inclusive</em>, meaning that both
<code>T</code> and <code>U</code> can host some <code>Trait&lt;S&gt;</code> implementations, as long as they both host
<em>all of them</em>.</p>
<hr/>






</article></div>
  </body>
</html>
