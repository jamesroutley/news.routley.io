<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pkh.me/p/41-fixing-the-iterative-damping-interpolation-in-video-games.html">Original</a>
    <h1>Fixing the iterative damping interpolation in video games</h1>
    
    <div id="readability-page-1" class="page"><article><p>As I&#39;m exploring the fantastic world of indie game development lately, I end up
watching a large number of video tutorials on the subject. Even though the
quality of the content is pretty variable, I&#39;m very grateful to the creators
for it. That being said, I couldn&#39;t help noticing this particular bit times and
times again:</p>
<pre><code>a = lerp(a, B, delta * RATE)
</code></pre>
<p>Behind this apparent banal call hides a terrible curse, forever perpetrated by
innocent souls on the Internet.</p>
<p>In this article we will study what it&#39;s trying to achieve, how it works, why
it&#39;s wrong, and then we&#39;ll come up with a good solution to the initial problem.</p>
<p>The usual warning: I don&#39;t have a mathematics or academic background, so the
article is addressed at other neanderthals like myself, who managed to
understand that pressing keys on a keyboard make pixels turn on and off.</p>
<h2>What is it?</h2>
<p>Let&#39;s start from the beginning. We&#39;re in a game engine main loop callback
called at a regular interval (roughly), passing down the time difference from
the last call.</p>
<p>In Godot engine, it looks like this:</p>
<pre><code>func _physics_process(delta: float):
    ...
</code></pre>
<p>If the game is configured to refresh at 60 FPS, we can expect this function to
be called around 60 times per second with <code>delta = 1/60 = 0.01666...</code>.</p>
<p>As a game developer, we want some smooth animations for all kind of
transformations. For example, we may want the speed of the player to go down to
zero as they release the moving key. We could do that linearly, but to make the
stop less brutal and robotic we want to slow down the speed progressively.</p>
<figure>
  <img src="https://blog.pkh.me/img/fixing-damp/lin-vs-exp.gif" alt="linear vs exponential GIF"/>
  <figcaption>Linear (top) versus smooth/exponential (bottom) animation</figcaption>
</figure>
<p>Virtually every tutorial will suggest updating some random variable with
something like that:</p>
<pre><code>velocity = lerp(velocity, 0, delta * RATE)
</code></pre>
<p>At 60 FPS, a decay <code>RATE</code> defined to <code>3.5</code>, and an initial <code>velocity</code> of <code>100</code>,
the <code>velocity</code> will go down to <code>0</code> following this curve:</p>
<figure>
  <img src="https://blog.pkh.me/img/fixing-damp/velocity-curve.png" alt="velocity curve"/>
  <figcaption>Example curve of a decaying variable</figcaption>
</figure>
<p><strong>Note</strong>: <code>velocity</code> is just a variable name example, it can be found in many
other contexts</p>
<p>If you&#39;re familiar with <code>lerp()</code> (&#34;linear interpolation&#34;) you may be wondering
why this is making a curve. Indeed, this <code>lerp()</code> function, also known as
<code>mix()</code>, is a simple linear function defined as <code>lerp(a,b,x) = x*(b-a) + a</code> or
its alternative stable form <code>lerp(a,b,x) = (1-a)x + bx</code>. For more information,
see a <a href="https://blog.pkh.me/p/29-the-most-useful-math-formulas.html">previous article</a> about this particular function. But here
we are re-using the previous value, so this essentially means nesting <code>lerp()</code>
function calls, which expands into a power formula, forming a curve composed of
a chain of small straight segments.</p>
<h2>Why is it wrong?</h2>
<p>The main issue is that the formula is heavily depending on the refresh rate. If
the game is supposed to work at 30, 60, or 144 FPS, then it means the physics
engine is going to behave differently.</p>
<p>Here is an illustration of the kind of instability we can expect:</p>
<figure>
  <img src="https://blog.pkh.me/img/fixing-damp/problematic-formula.png" alt="problematic formula"/>
  <figcaption>Comparison of the curves at different frame rates with the problematic formula</figcaption>
</figure>
<p>Note that the inaccuracy when compared to an ideal curve is not the issue here.
The problem is that the game mechanics are different depending on the hardware,
the system, and the wind direction observed in a small island of Japan. Imagine
being able to jump further if we replace our 60Hz monitor with a 144Hz one,
that would be some nasty pay to win incentive.</p>
<p>We may be able to get away with this by forcing a constant refresh rate for the
game and consider this a non-issue (I&#39;m not convinced this is achievable on all
engines and platforms), but then we meet another problem: the device may not be
able to hold this requirement at all times because of potential lags (for
reasons that may be outside our control). That&#39;s right, so far we assumed
<code>delta=1/FPS</code> but that&#39;s merely a target, it could fluctuate, causing mild to
dramatic situations gameplay wise.</p>
<p>One last issue with that formula is the situation of a huge delay spike,
causing an overshooting of the target. For example if we have <code>RATE=3</code> and we
end up with a frame that takes 500ms for whatever random reason, we&#39;re going to
interpolate with a value of 1.5, which is way above 1. This is easily fixed by
maxing out the 3rd argument of <code>lerp</code> to 1, but we have to keep that issue in
mind.</p>
<p>To summarize, the formula is:</p>
<ol>
<li>not frame rate agnostic ❌</li>
<li>non deterministic ❌</li>
<li>vulnerable to overshooting ❌</li>
</ol>
<p>If you&#39;re not interested in the gory details on the <em>how</em>, you can now jump
straight to the conclusion for a better alternative.</p>
<h2>Study</h2>
<p>We&#39;re going to switch to a more mathematical notation from now on. It&#39;s only
going to be linear algebra, nothing particularly fancy, but we&#39;re going to make
a mess of 1 letter symbols, bear with me.</p>
<p>Let&#39;s name the exhaustive list of inputs of our problem:</p>
<ul>
<li>initial value: <span>a_0=\Alpha</span> (from where we start, only used once)</li>
<li>target value: <span>\Beta</span> (where we are going, constant value)</li>
<li>time delta: <span>\Delta_n</span> (time difference from last call)</li>
<li>the rate of change: <span>R</span> (arbitrary scaling user constant)</li>
<li>original sequence: <span>a_{n+1} = \texttt{lerp}(a_n, \Beta, R\Delta_n)</span> (the code in the main
loop callback)</li>
<li>frame rate: <span>F</span> (the target frame rate, for example <span>60</span> FPS)</li>
<li>time: <span>t</span> (animation time elapsed)</li>
</ul>
<p>What we are looking for is a new sequence formula <span>u_n</span> (<span>u</span> standing for
<em>purfect</em>) that doesn&#39;t have the 3 previously mentioned pitfalls.</p>
<p>The first thing we can do is to transform this recursive sequence into the
expected ideal contiguous time based function. The original sequence was
designed for a given rate <span>R</span> and FPS <span>F</span>: this means that while <span>\Delta_n</span>
changes in practice every frame, the ideal function we are looking for is
constant: <span>\Delta=1/F</span>.</p>
<p>So instead of starting from <span>a_{n+1} = \texttt{lerp}(a_n, \Beta, R\Delta_n)</span>,
we will look for <span>u_n</span> starting from <span>u_{n+1} = \texttt{lerp}(u_n, \Beta,
R\Delta)</span> with <span>u_0=a_0=\Alpha</span>.</p>
<p>Since I&#39;m lazy and incompetent, we are just going to ask WolframAlpha for help
finding the solution to the recursive sequence. But to feed its input we need
to simplify the terms a bit:</p>
<p>
\begin{split}
u_{n+1} &amp;= \texttt{lerp}(u_n, \Beta, R\Delta) \\
      &amp;= u_n(1-R\Delta) + \Beta R\Delta \\
      &amp;= u_nP + Q
\end{split}
</p>
<p>...with <span>P=(1-R\Delta)</span> and <span>Q=\Beta R\Delta</span>. We do that so we have a familiar <span>ax+b</span> linear form.</p>
<p><a href="https://www.wolframalpha.com/input?i=u%280%29%3DA+and+u%28n%2B1%29%3Du%28n%29*P%2BQ">According to WolframAlpha</a> this is equivalent to:</p>
<p>
u_n = \Alpha P^n + \frac{Q(P^n-1)}{P-1}
</p>
<p>This is great because we now have the formula according to <span>n</span>, our frame
number. We can also express that discrete sequence into a contiguous function
according to the time <span>t</span>:</p>
<p>
f(t) = \Alpha P^{tF} + \frac{Q(P^{tF}-1)}{P-1}
</p>
<p>Expanding our temporary <span>P</span> and <span>Q</span> placeholders with their values and
unrolling, we get:</p>
<p>
\begin{split}
f(t) &amp;= AP^{tF} + \frac{Q(P^{tF}-1)}{P-1} \\
     &amp;= A(1-R\Delta)^{tF} + \frac{\Beta R\Delta((1-R\Delta)^{tF}-1)}{(1-R\Delta)-1} \\
     &amp;= A(1-R\Delta)^{tF} - \Beta((1-R\Delta)^{tF}-1) \\
     &amp;= A(1-R\Delta)^{tF} + \Beta(1-(1-R\Delta)^{tF}) \\
     &amp;= \texttt{lerp}(\Beta, \Alpha, (1-R\Delta)^{tF}) \\
     &amp;= \texttt{lerp}(\Beta, \Alpha, (1-R/F)^{tF}) \\
f(t) &amp;= \boxed{\texttt{lerp}(\Alpha, \Beta, 1-(1-R/F)^{tF})}
\end{split}
</p>
<p>This function perfectly matches the initial <code>lerp()</code> sequence in the
hypothetical situation where the frame rate is honored. Basically, it&#39;s <strong>what
the sequence <span>a_{n+1}</span> was meant to emulate at a given frame rate <span>F</span></strong>.</p>
<p><strong>Note</strong>: we swapped the first 2 terms of <code>lerp()</code> at the last step because it
makes more sense semantically to go from <span>\Alpha</span> to <span>\Beta</span>.</p>
<p>Let&#39;s again summarize what we have and what we want: we&#39;re into the game main
loop and we want our running value to stick to that <span>f(t)</span> function. We
have:</p>
<ul>
<li><span>v=f(t)</span>: the value previously computed (<span>t</span> is the running duration so far,
but we don&#39;t have it); in the original sequence this is known as <span>a_n</span></li>
<li><span>\Delta_n</span>: the delta time for the current frame</li>
</ul>
<p>We are looking for a function <span>\Eta(v,\Delta_n)</span> which defines the position of
a new point on the curve, only knowing <span>v</span> and <span>\Delta_n</span>. It&#39;s a &#34;time
agnostic&#34; version of <span>f(t)</span>.</p>
<p>Basically, it is defined as <span>\Eta(v,\Delta_n)=f(t+\Delta_n)</span>, but since we don&#39;t have
<span>t</span> it&#39;s not very helpful. That being said, while we don&#39;t have <span>t</span>, we do have
<span>f(t)</span> (the previous value <span>v</span>).</p>
<p>Looking at the curve, we know the y-value of the previous point, and we know
the difference between the new point and the previous point on the x-axis:</p>
<figure>
  <img src="https://blog.pkh.me/img/fixing-damp/prev-to-current-curve.png" alt="previous to current point"/>
  <figcaption>Previous and current point in time</figcaption>
</figure>
<p>If we want <span>t</span> (the total time elapsed at the previous point), we need the
inverse function <span>f^{-1}</span>. Indeed, <span>t = f^{-1}(f(t))</span>: taking the inverse of a
function gives back the input. We know <span>f</span> so we can inverse it, relying on
WolframAlpha again (what a blessing this website is):</p>
<p>
f^{-1}(x) = \frac{\ln{\frac{\Beta-x}{\Beta-\Alpha}}}{F \ln(1-R/F)}
</p>
<p><strong>Note</strong>: <span>\ln</span> stands for natural logarithm, sometimes also called <span>\log</span>.
Careful though, on Desmos for example <span>\log</span> is in base 10, not base <span>e</span> (while
its <span>\exp</span> is in base <span>e</span> for some reason).</p>
<p>This complex formula may feel a bit intimidating but we can now find <span>\Eta</span>
only using its two parameters:</p>
<p>
\begin{split}
\Eta(v,\Delta_n) &amp;= f(t + \Delta_n) \\
                &amp;= f(f^{-1}(f(t)) + \Delta_n) \\
                &amp;= f(f^{-1}(v) + \Delta_n) \\
                &amp;= f(\frac{\ln{\frac{\Beta-v}{\Beta-\Alpha}}}{F \ln(1-R/F)} + \Delta_n) \\
                &amp;= \texttt{lerp}(\Alpha, \Beta, 1-(1-R/F)^{(\frac{\ln{\frac{\Beta-v}{\Beta-\Alpha}}}{F \ln(1-R/F)} + \Delta_n) \times F}) \\
                &amp;= \texttt{lerp}(\Alpha, \Beta, 1-(1-R/F)^{\frac{\ln{\frac{\Beta-v}{\Beta-\Alpha}}}{\ln(1-R/F)}} (1-R/F)^{F\Delta_n}) \\
                &amp;= \texttt{lerp}(\Alpha, \Beta, 1-\frac{\Beta-v}{\Beta-\Alpha} (1-R/F)^{F\Delta_n}) \\
                &amp;= (1-\frac{\Beta-v}{\Beta-\Alpha} (1-R/F)^{F\Delta_n})(\Beta-\Alpha) + A \\
                &amp;= (\Beta-\Alpha) - (\Beta-v) (1-R/F)^{F\Delta_n} + A \\
                &amp;= (v-\Beta)(1-R/F)^{F\Delta_n} + \Beta \\
                &amp;= \texttt{lerp}(\Beta, v, (1-R/F)^{F\Delta_n}) \\
\Eta(v,\Delta_n) &amp;= \texttt{lerp}(v, \Beta, 1-(1-R/F)^{F\Delta_n})
\end{split}
</p>
<p>Again we swapped the first 2 arguments of <code>lerp</code> at the last step at the cost
of an additional subtraction: this is more readable because <span>\Beta</span> is our
destination point.</p>
<p>An interesting property that is going to be helpful here is <span>m^n = e^{n
\ln{m}}</span>. For my fellow programmers getting tensed here: <code>pow(m, n) == exp(n * log(m))</code>. Replacing the power with the exponential may not seem like an
improvement at first, but it allows packing all the constant terms together:</p>
<p>
\begin{split}
\Eta(v,\Delta_n) &amp;= \texttt{lerp}(v, \Beta, 1-(1-R/F)^{F\Delta_n}) \\
                &amp;= \texttt{lerp}(v, \Beta, 1-e^{F\ln(1-R/F)\Delta_n})
\end{split}
</p>
<p><span>F\ln(1-R/F)</span> can be pre-computed because it is constant: it&#39;s our <strong>rate
conversion formula</strong>, which we can extract:</p>
<p>
\begin{split}
             R&#39; &amp;= F\ln(1-R/F) \\
\Eta(v,\Delta_n) &amp;= \texttt{lerp}(v, \Beta, 1-e^{R&#39;\Delta_n})
\end{split}
</p>
<p>Rewriting this in a sequence notation, we get:</p>
<p>
\begin{split}
  R&#39; &amp;= F\ln(1-R/F) \\
u_{n+1} &amp;= \texttt{lerp}(u_n, \Beta, 1-e^{R&#39;\Delta_n})
\end{split}
</p>
<p>We&#39;re going to make one last adjustment: <span>R&#39;</span> is negative, which is not
exactly intuitive to work with as a user (in case it is defined arbitrarily and
not through the conversion formula), so we make a sign swap for convenience:</p>
<p>
\boxed{\begin{split}
  R&#39; &amp;= -F\ln(1-R/F) \\
u_{n+1} &amp;= \texttt{lerp}(u_n, \Beta, 1-e^{-R&#39;\Delta_n})
\end{split}}
</p>
<p>The conversion formula is optional, it&#39;s only needed to port a previously
broken code to the new formula. One interesting thing here is that <span>R&#39;</span> is
fairly close to <span>R</span> when <span>R</span> is small.</p>
<p>For example, a rate factor <span>R=5</span> at 60 FPS gives us <span>R&#39; \approx 5.22</span>. This
means that if the rate factors weren&#39;t closely tuned, it is probably acceptable
to go with <span>R&#39;=R</span> and not bother with any conversion. Still, having that
formula can be useful to update all the decay constants and check that
everything still works as expected.</p>
<p>Also, notice how if the delta gets very large, <span>-R&#39;\Delta_n</span> is going toward
<span>-\infty</span>, <span>e^{-R&#39;\Delta_n}</span> toward <span>0</span>, <span>1-e^{-R&#39;\Delta_n}</span> toward <span>1</span>, and so
the interpolation is going to reach our final target <span>\Beta</span> without
overshooting. This means the formula doesn&#39;t need any extra care with regard to
the 3rd issue we pointed out earlier.</p>
<p>Looking at the previous curves but now with the new formula and an adjusted
rate:</p>
<figure>
  <img src="https://blog.pkh.me/img/fixing-damp/new-formula.png" alt="new formula"/>
  <figcaption>Comparison of the curves at different frame rates with the new formula</figcaption>
</figure>
<h2>Conclusion</h2>
<p>So there we have it, the perfect formula, frame rate agnostic ✅,
deterministic ✅ and resilient to overshooting ✅. If you&#39;ve quickly skimmed
through the maths, here is what you need to know:</p>
<pre><code>a = lerp(a, B, delta * RATE)
</code></pre>
<p>Should be changed to:</p>
<pre><code>a = lerp(a, B, 1.0 - exp(-delta * RATE2))
</code></pre>
<p>With the precomputed <code>RATE2 = -FPS * log(1 - RATE/FPS)</code> (where <code>log</code> is the
natural logarithm), or simply using <code>RATE2 = RATE</code> as a rough equivalent.</p>
<p>Also, any existing overshooting clamping can safely be dropped.</p>
<p>Now please adjust your game to make the world a better and safer place for
everyone ♥</p>
</article><p>
 For updates and more frequent content you can follow me on <a href="https://fosstodon.org/@bug">Mastodon</a>. Feel also free to
 subscribe to the <a href="https://blog.pkh.me/rss.xml">RSS</a> in order to be notified
 of new write-ups. It is also usually possible to reach me through
 other means (check the footer below). Finally, discussions on some of
 the articles can sometimes be found on HackerNews, Lobste.rs and
 Reddit.
</p></div>
  </body>
</html>
