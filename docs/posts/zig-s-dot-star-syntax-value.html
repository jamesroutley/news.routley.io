<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.openmymind.net/Zig-Dot-Star-Syntax/">Original</a>
    <h1>Zig&#39;s dot star syntax (value.*)</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  
  
<p>Maybe I&#39;m the only one, but it always takes my little brain a split second to understand what&#39;s happening whenever I see, or have to write, something like <code>value.* = .{...}</code>.</p>

<p>If we take a step back, a variable is just a convenient name for an address on the stack. When this function executes:</p>

<pre><code><span>fn</span> <span>isOver9000</span><span>(</span>power<span>:</span> <span><span>i64</span></span><span>)</span> <span><span>bool</span></span> <span>{</span>
    <span>return</span> power <span>&gt;</span> <span>9000</span><span>;</span>
<span>}</span></code></pre>

<p>Say, with a <code>power</code> of 593, we could visualize its stack as:</p>

<pre><code>power -&gt;  -------------
          |    593    |
          -------------</code></pre>

<p>If we changed our function to take a pointer to an integer:</p>

<pre><code>
<span>fn</span> <span>isOver9000</span><span>(</span>power<span>:</span> <span><span>*</span><span>i64</span></span><span>)</span> <span><span>bool</span></span> <span>{</span>
    <span>return</span> power <span>&gt;</span> <span>9000</span><span>;</span>
<span>}</span></code></pre>

<p>Our <code>power</code> argument would still be a label for a stack address, but instead of directly containing an number, the stack value would itself be an address. That&#39;s the <em>indirection</em> of pointers:</p>

<pre><code>power -&gt;  -------------
          | 1182145c0 |------------------------
          -------------                        |
                                               |
          .............  empty space           |
          .............  or other data         |
                                               |
          -------------                        |
          |    593    | &lt;----------------------
          -------------</code></pre>

<p>But this code doen&#39;t work: it&#39;s trying to compare a <code>comptime_int</code> (<code>9000</code>) with an <code>*i64</code>. We need to make another change to the function:</p>

<pre><code>
<span>fn</span> <span>isOver9000</span><span>(</span>power<span>:</span> <span><span>*</span><span>i64</span></span><span>)</span> <span><span>bool</span></span> <span>{</span>
    
    <span>return</span> power<span>.*</span> <span>&gt;</span> <span>9000</span><span>;</span>
<span>}</span></code></pre>

<p><code>power.*</code> is how we dereference a pointer. Dereferencing means to get the value pointed to by a pointer. From our above visualization, you could say that the <code>.*</code> follows the arrow to get the value, <code>593</code>.</p>

<p>This same syntax works for writing as well. The following is valid:</p>

<pre><code><span>fn</span> <span>isOver9000</span><span>(</span>power<span>:</span> <span><span>*</span><span>i64</span></span><span>)</span> <span><span>bool</span></span> <span>{</span>
    power<span>.*</span> <span>=</span> <span>9001</span><span>;</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span></code></pre>

<p>Like before, the dereferencing operator (<code>.*</code>), &#34;follows&#34; the pointer, but now that it&#39;s on the receiving end of an assignment, we write the value into the pointed add memory.</p>

<p>This is all true for more complex types. Let&#39;s say we have a <code>User</code> struct with an <code>id</code> and a <code>name</code>:</p>

<pre><code><span>const</span> <span>User</span> <span>=</span> <span>struct</span> <span>{</span>
    id<span>:</span> <span><span>i32</span></span><span>,</span>
    name<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>,</span>
<span>}</span><span>;</span>

<span>var</span> user <span>=</span> <span>User</span><span>{</span>
    <span>.</span>id <span>=</span> <span>900</span><span>,</span>
    <span>.</span>name <span>=</span> <span>&#34;Teg&#34;</span>
<span>}</span><span>;</span></code></pre>

<p>The <code>user</code> variable is a label for the location of the [start of] the user:</p>

<pre><code>user  -&gt;  -------------
          |    900    |
          -------------
          |     3     |
          -------------
          | 3c9414e99 | -----------------------
          -------------                        |
                                               |
          .............  empty space           |
          .............  or other data         |
                                               |
          -------------                        |
          |     T     | &lt;----------------------
          -------------
          |     e     |
          -------------
          |     g     |
          -------------</code></pre>

<p>A slice in Zig, like our <code>[]const u8</code>, is a length (<code>3</code>) and a pointer to the values. Now, if we were to take the address of <code>user</code>, via <code>&amp;user</code>, we introduce a level of indirection. For example, imagine this code:</p>

<pre><code><span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>

<span>const</span> <span>User</span> <span>=</span> <span>struct</span> <span>{</span>
    id<span>:</span> <span><span>i32</span></span><span>,</span>
    name<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>,</span>
<span>}</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    <span>var</span> user <span>=</span> <span>User</span><span>{</span>
        <span>.</span>id <span>=</span> <span>900</span><span>,</span>
        <span>.</span>name <span>=</span> <span>&#34;Teg&#34;</span>
    <span>}</span><span>;</span>
    <span>updateUser</span><span>(</span><span>&amp;</span>user<span>)</span><span>;</span>
    std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;{d}\n&#34;</span><span>,</span> <span>.</span><span>{</span>user<span>.</span>id<span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>fn</span> <span>updateUser</span><span>(</span>user<span>:</span> <span><span>*</span>User</span><span>)</span> <span><span>void</span></span> <span>{</span>
    user<span>.</span>id <span>+=</span> <span>100000</span><span>;</span>
<span>}</span></code></pre>

<p>The <code>user</code> parameter of our <code>updateUser</code> function is pointing to the  <code>user</code> on <code>main</code>&#39;s stack:</p>

<pre><code>updateUser
user  -&gt;   -------------
           |  83abcc30 |------------------------
           -------------                        |
                                                |
           .............  empty space           |
           .............  or other data         |
                                                |
main                                            |
user  -&gt;   -------------                        |
           |    900    | &lt;----------------------
           -------------
           |     3     |
           -------------
           | 3c9414e99 | -----------------------
           -------------                        |
                                                |
           .............  empty space           |
           .............  or other data         |
                                                |
           -------------                        |
           |     T     | &lt;----------------------
           -------------
           |     e     |
           -------------
           |     g     |
           -------------</code></pre>

<p>Because we&#39;re referencing <code>main</code>&#39;s <code>user</code> (rather than a copy), any changes we make will be reflected in <code>main</code>. But, we aren&#39;t limited to operating on fields of <code>user</code>, we can operate on its entire memory.</p>

<p>Of course, we can create a copy of the id field (assignment are always copies, just an matter of knowing <em>what</em> we&#39;re copying):</p>

<pre><code><span>fn</span> <span>updateUser</span><span>(</span>user<span>:</span> <span><span>*</span>User</span><span>)</span> <span><span>void</span></span> <span>{</span>
    <span>const</span> id <span>=</span> user<span>.</span>id
    
<span>}</span></code></pre>

<p>And now the stack for our function looks like:</p>

<pre><code>user  -&gt;  -------------
          |  83abcc30 |
id    -&gt;  -------------
          |    900    |
          -------------</code></pre>

<p>But we can also copy the entire user:</p>

<pre><code><span>fn</span> <span>updateUser</span><span>(</span>user<span>:</span> <span><span>*</span>User</span><span>)</span> <span><span>void</span></span> <span>{</span>
    <span>const</span> copy <span>=</span> user<span>.*</span><span>;</span>
    
<span>}</span></code></pre>

<p>Whch gives us something like:</p>

<pre><code>updateUser
user  -&gt;  -------------
          |  83abcc30 |---------------------
copy  -&gt;  -------------                     |
          |    900    |                     |
          -------------                     |
          |     3     |                     |
          -------------                     |
          | 3c9414e99 | --------------------|--
          -------------                     |  |
                                            |  |
          .............  empty space        |  |
          .............  or other data      |  |
                                            |  |
main                                        |  |
user   -&gt; -------------                     |  |
          |    900    | &lt;-------------------   |
          -------------                        |
          |     3     |                        |
          -------------                        |
          | 3c9414e99 | -----------------------|
          -------------                        |
                                               |
          .............  empty space           |
          .............  or other data         |
                                               |
          -------------                        |
          |     T     | &lt;----------------------
          -------------
          |     e     |
          -------------
          |     g     |
          -------------</code></pre>

<p>Notice that it didn&#39;t create a copy of the value &#39;Teg&#39;. You could call this copying &#34;shallow&#34;: it copied the <code>900</code>, the <code>3</code> (name length) and the <code>3c9414e99</code> (address of the name pointer).</p>

<p>Just like our simpler example above, we can also assign using the dereferencing operator:</p>

<pre><code><span>fn</span> <span>updateUser</span><span>(</span>user<span>:</span> <span><span>*</span>User</span><span>)</span> <span><span>void</span></span> <span>{</span>
    
    
    

    user<span>.*</span> <span>=</span> <span>.</span><span>{</span>
        <span>.</span>id <span>=</span> <span>5</span><span>,</span>
        <span>.</span>name <span>=</span> <span>&#34;Paul&#34;</span><span>,</span>
    <span>}</span><span>;</span>
<span>}</span></code></pre>


<p>This doesn&#39;t copy anything; it writes into the address that we were given, the address of the main&#39;s <code>user</code>:</p>

<pre><code>updateUser
user  -&gt;  -------------
          |  83abcc30 |------------------------
          -------------                        |
                                               |
          .............  empty space           |
          .............  or other data         |
                                               |
main                                        |  |
user  -&gt;  -------------                        |
          |     5     | &lt;----------------------
          -------------
          |     4     |
          -------------
          | 9bf4a990  | -----------------------
          -------------                        |
                                               |
          .............  empty space           |
          .............  or other data         |
                                               |
          -------------                        |
          |     P     | &lt;----------------------
          -------------
          |     a     |
          -------------
          |     u     |
          -------------
          |     l     |
          -------------</code></pre>


<p>If you&#39;re still not fully comfortable with this, and if you haven&#39;t done so already, you might be interested in the <a href="https://www.openmymind.net/learning_zig/pointers/">pointers</a> and <a href="https://www.openmymind.net/learning_zig/stack_memory/">stack memory</a> parts of my learning zig series.</p>

</article></div>
  </body>
</html>
