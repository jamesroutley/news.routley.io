<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickgregory.me/linux/security/2022/03/12/cve-2022-25636/">Original</a>
    <h1>The Discovery and Exploitation of CVE-2022-25636</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
  
  <p><span>12 Mar 2022</span>
  <span>Tagged: <a href="https://nickgregory.me/category/linux">linux</a> <a href="https://nickgregory.me/category/security">security</a></span></p><p>A few weeks ago, I found and reported CVE-2022-25636 - a heap out of bounds write in the Linux kernel.
The bug is exploitable to achieve kernel code execution (via ROP), giving full local privilege escalation, container escape, whatever you want.</p>

<p>In this post, I cover the entire process of finding and exploiting the bug (to as much of an extent as I did at least) - from initial “huh that looks weird” to a working LPE.</p>

<p>It’s a long post, but hopefully this will be useful to others (especially those newer to kernel exploitation) to get a feel for what my process was like.</p>

<p>Finally, if you’re just here for the exploit details and don’t want the backstory of me discovering it, feel free to <a href="#exploitation">skip head</a>.</p>



<p>One night a few weeks back, I was bored. There were a few other projects I could have worked on,
but none of them seemed particularly interesting, so I decided to do some random (kernel) code review.
There have been a few notable bugs in the netfilter kernel subsystem that I’ve seen over the past few years
(perhaps most notably <a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">CVE-2021-22555</a>), so I decided to start looking there.
It’s a relatively complex subsystem that’s widely available - the perfect target.</p>

<h2 id="aside-what-is-netfilter">Aside: What is netfilter?</h2>

<p>Netfilter, as the <a href="https://www.netfilter.org/">project’s website</a> says, “enables packet filtering, network address [and port] translation (NA[P]T), packet logging, userspace packet queueing and other packet mangling.”
You’ve probably interacted with netfilter before without knowing about it!
Ever used <code>iptables</code> to block inbound traffic on a server, or configured a Linux box as a router with NAT?
All of that packet processing is done in the kernel by netfilter.</p>

<p>I’ve done a bunch of stuff with <code>iptables</code> in the past, but other than that I wasn’t familiar with anything else netfilter provided (and definitely didn’t know anything about how it worked),
so I clicked around on some files in the subsystem’s <a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter">main source directory</a> to try and get a lay of the land.</p>

<p>I started at the top by looking at a few of the (what seemed to be) protocol parsers. Parsing non-trivial data is always potentially error-prone, so it felt like a good place to start.
I ended up focusing on the parts of the code taking configuration input from userland (over a netlink socket), as while a bug in packet processing would be interesting,
the decoder would still have to be “activated” by some configuration from userland in the first place.</p>

<p><em>Editor’s note</em>: perhaps it’s worth taking another look at these since <a href="https://syzkaller.appspot.com/upstream">syzkaller</a> doesn’t show much of any coverage on these files so maybe there’s something lurking…</p>

<p>Anyways, after going through <a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_conntrack_ftp.c"><code>nf_conntrack_ftp.c</code></a> and a few others without seeing much interesting,
I was scrolling through looking for other “types” of code and saw <a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_dup_netdev.c"><code>nf_dup_netdev.c</code></a>.
I was actually just about to click on some other file when I saw that and thought “well maybe there could be some refcounting bug if something is duplicated” so I decided to look in there.</p>

<p>It’s quite a short file, but <a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_dup_netdev.c#L67">line 67</a></p>

<div><div><pre><code>entry = &amp;flow-&gt;rule-&gt;action.entries[ctx-&gt;num_actions++];
</code></pre></div></div>

<p>stood out to me for two particular reasons:</p>

<ol>
  <li>It was incrementing <code>ctx-&gt;num_actions</code> and using it as the index into an array without any bounds checking</li>
  <li>The index (<code>ctx-&gt;num_actions</code>) and the array itself (<code>flow-&gt;rule-&gt;action.entries</code>) are struct members of two completely different variables, not obviously related. That is, the line is equivalent to <code>a-&gt;b[x-&gt;y]</code> which seems potentially more “suspicious” than <code>a-&gt;b[a-&gt;c]</code>.</li>
</ol>

<p>None of these reasons made this a definite bug (yet) of course, however it definitely “smelled” which prompted a bit more digging.</p>



<p>I had a few immediate questions:</p>

<ul>
  <li>What determines the size of the <code>action.entries</code> array?</li>
  <li>How is <code>nft_fwd_dup_netdev_offload</code> called? And what controls how many times it’s called?</li>
  <li>When/how is <code>ctx</code> initialized?</li>
</ul>

<p>At this point I also realized that this was in <code>nft_fwd_dup_netdev_</code><strong><code>offload</code></strong>. Even if this bug was real, it may only be reachable on systems with Network Interface Cards (NICs) with support for packet processing offload, which are very rare (and very expensive).
It would still be a bug, but maybe not the most interesting bug in the world.</p>

<p>Pulling up the x-refs of <code>nft_fwd_dup_netdev_offload</code> showed it was called in a <code>.offload</code> handler of the <a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nft_dup_netdev.c#L67"><code>dup</code></a> and <a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nft_fwd_netdev.c#L77"><code>fwd</code></a> <code>nft_expr_type</code>s.
Looking at the references for the <code>offload</code> struct member (which is really not a pleasant experience in Elixir…), I found <a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_tables_offload.c#L125">this use</a> which answered all but one of the questions above:</p>

<div><div><pre><code>ctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);

...

while (nft_expr_more(rule, expr)) {
  if (!expr-&gt;ops-&gt;offload) {
    err = -EOPNOTSUPP;
    goto err_out;
  }
  err = expr-&gt;ops-&gt;offload(ctx, flow, expr);
  if (err &lt; 0)
    goto err_out;

  expr = nft_expr_next(expr);
}
</code></pre></div></div>

<ul>
  <li><strong>How is <code>nft_fwd_dup_netdev_offload</code> called?</strong>: It’s indirectly called as part of <code>nft_flow_rule_create</code>.</li>
  <li><strong>What controls how many times <code>nft_fwd_dup_netdev_offload</code> is called?</strong>: Offload handlers (and therefore <code>nft_fwd_dup_netdev_offload</code> for fwd/dup expressions) are called for every expression in the rule which has one. No other checks.</li>
  <li><strong>When/how is <code>ctx</code> initialized?</strong>: For each rule created, the context is zero-initialized and the same instance is passed to each offload handler.</li>
</ul>

<p>More importantly than all of those however, the answer to the most interesting question was just above:</p>

<div><div><pre><code>expr = nft_expr_first(rule);
while (nft_expr_more(rule, expr)) {
  if (expr-&gt;ops-&gt;offload_flags &amp; NFT_OFFLOAD_F_ACTION)
    num_actions++;

  expr = nft_expr_next(expr);
}

...

flow = nft_flow_rule_alloc(num_actions);
</code></pre></div></div>

<p>We see that for each expression in the rule, a <code>num_actions</code> counter is incremented <em>only when the expression has a certain bit (<code>NFT_OFFLOAD_F_ACTION</code>) set</em> in <code>ops-&gt;offload_flags</code>.
Quickly checking back at the definition for the <code>dup</code> and <code>fwd</code> expressions, neither of them have <code>NFT_OFFLOAD_F_ACTION</code> set.
In fact, there’s only one use of <code>NFT_OFFLOAD_F_ACTION</code> at all: in the <code>immediate</code> expression type (<a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nft_immediate.c#L227">here</a>).</p>

<p>At this point I was pretty confident there was a bug.
As far as I could tell, the only thing that could prevent it would be if there was some enforcement of having one immediate per dup/fwd rule.</p>

<h2 id="checking-for-exploitability">Checking for Exploitability</h2>

<p>Unfamiliar with how to “talk” to nftables, I searched around for some examples of what a nftables table/chain definition looks like and how to install it.
<a href="https://www.spinics.net/lists/netfilter/msg59251.html">One mailing list post</a> was particularly useful as it had everything needed, including how to set the <code>offload</code> flag which is required to reach the bug (because of <a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_tables_api.c#L3423">this</a> check).</p>

<div><div><pre><code>table netdev filter_test {
  chain ingress {
    type filter hook ingress device eth0 priority 0; flags offload;
    ip daddr 192.168.0.10 tcp dport 22 drop
  }
}
</code></pre></div></div>

<p>With that sample in hand, I started playing around with nftables to see if/how the bug could be hit.</p>

<p>First, I setup a kprobe on <code>flow_rule_alloc</code> (responsible for creating our <code>action.entries</code> array) with a fetcharg to show the <code>num_actions</code> argument: <code>sudo kprobe-perf -F &#39;p:flow_rule_alloc num_actions=%di:u32&#39;</code>.
This immediately failed because (at least on Ubuntu) nftables is a lazily loaded kernel module so the code wasn’t actually loaded yet. Oops.
After quickly running <code>nft -a mailing_list.nft</code> (which forced the kernel module to load even though the command itself failed), I could actually set the kprobe.</p>

<p>Running <code>nft -a mailing_list.nft</code> for real this time resulted in a kprobe hit (despite the rule installation failing):</p>

<div><div><pre><code>$ sudo nft -f mailing_list.nft
a.nf:1:1-2: Error: Could not process rule: Operation not supported
table netdev x {
^^
</code></pre></div></div>

<div><div><pre><code>$ sudo kprobe-perf &#39;p:flow_rule_alloc num_actions=%di:u32&#39;
Tracing kprobe flow_rule_alloc. Ctrl-C to end.
             nft-20137   [001] .... 1573655.306178: flow_rule_alloc: (flow_rule_alloc+0x0/0x60) num_actions=1
</code></pre></div></div>

<p>So <code>flow_rule_alloc</code> was indeed being hit even though the VM I was testing in definitely didn’t have a network device capable of hardware offload!
The system didn’t crash or anything so it seemed like the buggy behavior wasn’t getting hit yet, but this was good progress.</p>

<p>And it was at this point that I realized I had never changed the example from the mailing list to actually include a <code>dup</code> expression. Oops again.
After changing the rule to <code>ip daddr 192.168.0.10 dup to eth0</code> though, my system annoyingly remained in a non-<code>panic</code>d state.</p>

<p>Before continuing, I also wanted to try running the <code>nft</code> commands after <code>unshare</code>ing into a new user and network namespace (<code>unshare -Urn</code>) to see if it’s possible to reach this as an unprivileged user. Sure enough it was, making this bug potentially even more potent.</p>

<p>Back to the bug itself though: poking around through the <code>nft</code> man pages, I found you could pass <code>-d netlink</code> which ended up being incredibly useful as it showed the “disassembly” of the rule that was being sent to the kernel:</p>

<div><div><pre><code>[ meta load protocol =&gt; reg 1 ]
[ cmp eq reg 1 0x00000008 ]
[ payload load 4b @ network header + 16 =&gt; reg 1 ]
[ cmp eq reg 1 0x0a00a8c0 ]
[ immediate reg 1 0x00000001 ]
[ dup sreg_dev 1 ]
</code></pre></div></div>

<p>From this, it’s apparent why the bug isn’t being triggered: the CLI generates an immediate expression before the <code>dup</code> (representing the device the packet should be duplicated to), so the accounting was “working”.
Is it possible to have a <code>dup</code> without a preceeding <code>immediate</code>?
I couldn’t find a way to have the CLI install a rule from this disassembled format (so couldn’t force it to generate <code>dup</code>s with no <code>immediate</code>s),
so it was time to go deeper and manually create the packets to send to the subsystem.</p>

<h3 id="golang-implementation">Golang Implementation</h3>

<p>I have a love/hate relationship with Go, but that’s a blog for another time.
At the end of the day, it’s basically the only language that has a large community (and therefore a large selection of libraries) that’s low enough level to do what I need for this,
but also high enough level to not make me want to throw my computer out the window while I’m trying to get something to work.
So I started building a proof of concept in Go.</p>

<p>Conveniently, Google has a go <code>nftables</code> <a href="https://github.com/google/nftables">library</a> which looked like a good starting point since I’d be able to manually construct the rule.
Unfortunately, it didn’t expose quite everything I needed (mainly around setting the offload flag) and by the time I discovered this, I was a few hours into building around it and really didn’t want to rewrite it in C.
I cobbled together some truely awful code which used reflection to overwrite the private array of messages to send, manually constructed the necessary chain creation message with the proper bit flipped, etc. etc. and another hour or so later I was back to where I started with the <code>nft</code> CLI.</p>

<p>I added another <code>dup</code> without an <code>immediate</code> before it, ran it and…</p>

<p>…</p>

<p>not much happened. It errored out with the normal “operation not permitted”, but nothing else. So at least it didn’t get rejected because of missing immediates which was good I guess?</p>

<p>Then, a few seconds later, kaboom. The kernel panicked and my shell was dead. We have a bug!</p>

<p>Now comes the fun part.</p>



<p>Analyzing what our bug actually provides us (with the help of <code>pahole</code> to get struct offsets), we see that there are 2 out of bounds writes:</p>

<div><div><pre><code>entry = &amp;flow-&gt;rule-&gt;action.entries[ctx-&gt;num_actions++];
entry-&gt;id = id;
entry-&gt;dev = dev;
</code></pre></div></div>

<ol>
  <li>The write of <a href="https://elixir.bootlin.com/linux/v5.16.11/source/include/net/flow_offload.h#L199"><code>enum flow_action_id id</code></a> immediately after the end of the array, writing the value 4 or 5 (depending on whether this is a <code>fwd</code> or <code>dup</code>) expression</li>
  <li>The write of <a href="https://elixir.bootlin.com/linux/v5.16.11/source/include/net/flow_offload.h#L205"><code>struct net_device *dev</code></a> 24 bytes past the end of the array</li>
</ol>

<p>As for the sizes of everything (on my Ubuntu test VM with a 5.13 kernel), the base <code>flow_rule</code> structure is 32 bytes and each additional <code>entry</code> in the array is 80 bytes. This means:</p>

<ul>
  <li>If there are no immediates in our rule, the size of the rule allocation will be 32 and will be allocated in the kmalloc-32 slab</li>
  <li>One rule gives an allocation of size 112, landing in the kmalloc-128 slab</li>
  <li>Two rules gives an allocation of size 192, landing in the kmalloc-192 slab</li>
  <li>and so on</li>
</ul>

<p>Focusing on the <code>dev</code> pointer write, the above allocation sizes means that the write will be either at offset 24 of the next 32- or 192-slab allocation, or at offset 8 of the next 128-slab allocation.
I manually hunted around through <code>pahole</code>’s output looking for any interesting structure which had a pointer at the necessary offset, but came up empty handed.
Everything that I found was either in a subsystem that required elevated privileges to access, in a subsystem that is “exotic” (probably not easily reachable), or in a subsystem which I felt was too flaky to try and land in (e.g. the scheduler).</p>

<p>Long story short, I put this aside and came back to it a couple days later with fresh eyes.</p>

<p>While reading through Alexander Popov’s writeup of <a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">another recent kernel bug</a> looking for inspiration the thought occurred to me:
we have the ability to cause <strong>multiple</strong> of these out of bounds writes, not just one (since multiple <code>dup</code>s can be put in a rule).
So in addition to hitting offset 8 of the next 128-slab allocation, we could also hit offset 88 of that allocation,
or offset 40 of the 2nd next allocation, or offset 120 of the 2nd next, or…</p>

<p>Having just read that writeup in which Alexander uses the security pointer (<strong>at offset 40</strong>) to land a <code>kfree</code>, the exploit path became obvious.</p>

<p>What we do is:</p>
<ul>
  <li>Spray a bunch of System V message queue messages, causing the kernel to allocate a lot of <code>msg_msg</code> structures of a controlled size. For now, we care about landing in the kmalloc-128 slab</li>
  <li>Free some of them</li>
  <li>Add the netlink rule, causing the <code>flow_rule</code> allocation to hopefully land in one of the the just free’d heap slots</li>
  <li>Do our OOB write a total of 3 times (i.e. have 3 <code>dup</code>s in our rule with no <code>immediate</code>), clobbering
    <ul>
      <li>The <code>list_head.prev</code> pointer (offset 8) of the next message on the heap</li>
      <li>Some random data (offset 88) in the contents of the next message on the heap</li>
      <li>The <code>security</code> pointer (offset 40) of the 2nd next message on the heap</li>
    </ul>
  </li>
  <li>Find and <code>msgrcv</code> the 2nd next message, causing the kernel to <code>kfree()</code> the <code>net_device</code> (since it was a <code>net_device</code> pointer that was written)</li>
  <li>Allocate some more messages, but this time in the kmalloc-4k slab with the goal of landing in the <code>net_device</code> that was just free’d</li>
  <li>Cause the kernel to do something on the device which would cause a function pointer in the (now controlled) <code>net_device.netdev_ops</code> operations struct to be called, giving us code execution. Reading from <code>/proc/net/dev</code> is a simple answer to this (causing <code>netdev_ops-&gt;ndo_get_stats64</code> to <a href="https://elixir.bootlin.com/linux/v5.16.11/source/net/core/dev.c#L10697">be called</a>) which is what I ended up using.</li>
</ul>

<p>This chain is <em>incredibly</em> nice. Just to highlight a few benefits:</p>

<ul>
  <li>We know exactly which <code>msg_msg</code> had its <code>list_head.prev</code> pointer clobbered (and is therefore unsafe to free) since we can <code>MSG_COPY</code> it out of the queue (which wont touch the next/prev pointers since it’s not actually removed) and look to see if the contents of the message have changed.</li>
  <li>In addition to telling us which message is “dangerous”, this also leaks the kernel heap pointer that we’re going to be landing in, making it trivial to start ROPing (more on this <a href="#sidenote-rop">below</a>).</li>
  <li>We also know exactly which message had its <code>security</code> pointer overwritten. We could either add a 4th <code>dup</code> (and again look at message data after copying it), or we can look at the messages <code>mtype</code> after it’s copied out. Remember how 2 things are written out of bounds (4 or 5, and the pointer)? It just so happens that the 4 or 5 gets written over the message’s <code>mtype</code> (offset 16), so by checking if the <code>mtype</code> changed from whatever value was put in, we can tell if we have the right message.</li>
</ul>

<p>By the end of the night (perhaps staying up a <em>bit</em> too late…), I had the first working proof of concept for this (in an ARM VM not x86, hence the different registers and whatnot).</p>

<p><img src="https://nickgregory.me/images/cve-2022-25636/Screen%20Shot%202022-02-15%20at%2002.28.17.png" alt="A panic!"/></p>

<p>Success!</p>

<p>A few more hours of hacking on this though, and I hadn’t gotten much closer to code execution.</p>

<p>For some reason, the exploit was incredibly flaky (i.e. it had a very low success rate). I figured this was either because:</p>

<ol>
  <li>The kernel <a href="https://mxatone.medium.com/randomizing-the-linux-kernel-heap-freelists-b899bb99c767">freelist randomization</a> was more potent than I thought against this</li>
  <li>All of the stuff the go runtime does in the background was messing with the kernel heap.</li>
  <li>Other things running on the system were causing sporadic <code>kmalloc-128</code> allocations, throwing off/using up the freelist</li>
</ol>

<p>I tried changing everything to work out of the <code>kmalloc-2048</code> slab (since all of the offset math still works out), but this didn’t seem to help at all.
At this point I probably should have spent some time with a kernel debugger, tracing exactly what was happening with the freelist, but I decided to go ahead and rewrite the exploit in C to see if that would help.
If nothing else, it’d probably make later stages of the exploit much easier to work with since I wouldn’t have to try and link in some other thing that the kernel could jump to as a final stage of the exploit.</p>

<h2 id="rewriting">Rewriting</h2>

<p>Boy was this a nightmare. There <em>is</em> a C library for “nicely” working with nftables, however at the end of the day it’s C so nothing is really “nice.”
After many hours of staring at <code>strace</code> output of the netlink packets trying to figure out what I was missing in the C code, I eventually got back to where I was in goland.
If you’re interested, the code necessary to interface with nftables is available in the <a href="https://www.openwall.com/lists/oss-security/2022/02/21/2">reproducer</a> I posted to the oss-security mailing list.</p>

<p>But it wasn’t any more stable. Damn.</p>

<p>Another couple days of messing around (mainly trying to figure out if there was a specific order in which to free the initial messages to best get around freelist randomization), I got to a point where the exploit was ~30% successful which was good enough to proceed with.
It’s entirely possible I was missing something obviously broken in my exploit code, but if you have any ideas about something I could be missing kernel-side, please do drop me an email or DM - I would really like to know what’s going on.</p>

<p>Having spent enough time on this already, I decided to forgo making this into a full exploit. I just wanted to get my root shell and call it a day.
I disabled SMEP, SMAP, KPTI, and KASLR on my test VM, and put together a quick “callback” (getting me root and out of any container/namespace) which I could jump directly to from the kernel:</p>

<div><div><pre><code>void *get_task(void) {
    void *task;
    asm volatile (&#34;movq %%gs: 0x1fbc0, %0&#34;:&#34;=r&#34;(task));
    return task;
}

void *elevate(void *dev, void *storage) {
    void *c = ((void * (*)(int))(prepare_kernel_cred))(0);
    ((void (*)(void *))(commit_creds))(c);
    void *current = get_task();
    ((void (*)(void *, void *))(switch_task_namespaces))(current, (void *)init_nsproxy);
    return NULL;
}
</code></pre></div></div>

<p>And that’s basically it. Minus the whole “it only works 30% of the time,” the exploit was done, and I got my shell after a few attempts.</p>

<p><img src="https://nickgregory.me/images/cve-2022-25636/Screenshot%20from%202022-03-08%2023-28-57.png" alt="root"/></p>

<p>And before you go burning cycles trying to crack that password hash, it’s just <code>vagrant</code> :P</p>

<h2 id="sidenote-rop">Sidenote: ROP</h2>

<p>While I didn’t end up implementing it in my exploit, we’re in an amazing position to ROP (making SMEP/SMAP/KPTI a non-issue).
Since the kernel heap address of the <code>net_device</code> is leaked, we know where our message data is going to be in memory.
That pointer can then be used to compute an address for our fake <code>netdev_ops</code> (putting it somewhere else in our message),
and then when the kernel goes to call a function taken from that ops structure (with the <code>net_device</code> (/our message) as the first argument),
we can give it the address of a simple <code>mov rsp, rdi; ret</code> gadget to stack pivot on to our message.
From there, anything is possible.</p>

<p>The only thing missing is a KASLR leak, but that’s not much of a barrier :)</p>



<p>In the couple of weeks it took me to write up this blog post, <a href="https://twitter.com/Bonfee1/status/1500837241991618565">@Bonfee</a> already independently developed an exploit for the bug and published it!</p>

<p>I haven’t looked through the entirety of their implementation, but it seems to use a similar path to what I describe above. However, it also includes a full ROP chain and KASLR leak making it far more complete than mine. I’d recommend you check it out! <a href="https://github.com/Bonfee/CVE-2022-25636">https://github.com/Bonfee/CVE-2022-25636</a></p>



<p>This was a really fun bug to discover and work on. From start to end, it took just under a week to find, triage the bug, figure out how to hit it, and build the exploit.
While not novel, the OOB write primitive we get with it is also pretty interesting, and makes for quite a clean exploit as we’ve seen.</p>

<p>I hope you’ve enjoyed reading, and of course reach out with any questions you may have.</p>

</div>



    </div></div>
  </body>
</html>
