<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://t3.gg/blog/posts/types-and-nextjs">Original</a>
    <h1>An Inconsistent Truth: Next.js and Typesafety</h1>
    
    <div id="readability-page-1" class="page"><article><main><div><h2>An Inconsistent Truth: Next.js and Type Safety</h2><p><time datetime="Thu Dec 02 2021 00:00:00 GMT+0000 (Coordinated Universal Time)">December 2, 2021</time></p></div><p>Imagine a world where Next.js was architected around type safety.</p><blockquote><p>“But doesn’t Next.js already work with TypeScript?”</p></blockquote><p>Yes. I even <a href="https://init.tips/">recommend the Next.js TypeScript template on init.tips</a>.</p><p>Type safety goes deeper than TypeScript support.</p><h2 id="what-is-type-safety">What is Type Safety?</h2><blockquote><p>“…type safety is the extent to which a programming language discourages or prevents type errors”</p><p><a href="https://en.wikipedia.org/wiki/Type_safety">Wikipedia</a></p></blockquote><p>It’s important to recognize first and foremost that type safety isn’t a boolean ‘on/off’ state. Type safety is a set of pipes from your furthest off dependency and your user.</p><p>Throughout my career, I’ve seen a number of systems that handle types in various ways. For the sake of simplicity, I’m going to over-generalize the structure of a system into a few parts</p><ul><li>Data store (SQL, Mongo, Worker KV)</li><li>Backend (interface to data store)</li><li>API + Schema layer (REST/Swagger, GraphQL, gRPC)</li><li>Client (Frontend web app, mobile app, video game)</li></ul><p>I’ve been lucky to work primarily in systems where each of these pieces is type safe. At Twitch, we used PostgreSQL for data, Golang for backend, GraphQL for APIs, and React + TypeScript for the front end. Each piece was type safe, and tools like GraphQL allowed us to write a “type contract” between different type systems (in this case a GraphQL schema).</p><p>Given the separation of concerns and focus, combined with the varied technologies on frontend and backend, this architecture made a lot of sense.</p><p>Given a full-stack TypeScript app using Next.js, I think we can do much better.</p><h2 id="building-better-type-systems">Building Better Type Systems</h2><p>Going to start this with a question:</p><p><em>When working in a type safe system, should you be writing more types, or less?</em></p><p>This question may seem dumb. “Of course you would have more type definitions in the better typed system!”</p><p>The best type systems should require no types to be written at all.</p><p><em>But how??!</em></p><h3 id="type-inference">Type Inference</h3><img src="https://t3.gg/images/next-typesafety/drake.jpeg"/><p>Credits to <a href="https://twitter.com/alexdotjs/status/1465975816370728963">Alex for this fantastic meme</a></p><p><em>Writing type definitions for every piece of your code does not make a type safe system.</em></p><p><em>Good type systems are built on top of strongly typed dependencies and models. Type safety comes when the rest is inferred from there</em>.</p><p>Say I have a model in SQL:</p><pre><code>model User <span>{</span>
  id   String  <span><span>@</span><span>id</span></span> @<span>default</span><span>(</span><span>cuid</span><span>(</span><span>)</span><span>)</span>
  name String<span>?</span>
<span>}</span>
</code></pre><p>We know, given a <code>User</code>, that we have an <code>id</code> string that is unique and we <em>might</em> have a <code>name</code> that is a string. If we were interfacing with this in TypeScript, the TS definition would look something like</p><pre><code><span>type</span> <span>User</span> <span>{</span>
	id<span>:</span> <span>string</span><span>;</span>
	name<span>:</span> <span>string</span> <span>|</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><p>Here’s where the Theo spice comes in: <em>you should never have to write types that look this much like your data models</em></p><p>Tools like <a href="https://www.prisma.io/">Prisma</a> serve as a beautiful “translation layer” between your SQL data and your TypeScript backend.</p><pre><code><span>export</span> <span>const</span> <span>getUserById</span> <span>=</span> <span>(</span><span>userId<span>:</span> string</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>await</span> prisma<span>.</span>user<span>.</span><span>findFirst</span><span>(</span><span>{</span> where<span>:</span> <span>{</span> id<span>:</span> userId <span>}</span> <span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><p>That’s it.</p><p>The type safety doesn’t come from defining our own types. It comes from <em>the source of truth being honored and all further contracts being inferred from that source</em>.</p><p>Next.js often breaks that contract.</p><h2 id="next-can-be-a-type-safety-risk">Next can be a (type) safety risk</h2><p>This statement is bold, but this problem is large enough to justify it IMO. Know that it comes from a place of love.</p><p>It is hard to believe that the biggest breach in contract for my type system exists within any given file in the Next.js <code>pages</code> directory, but it’s the concern I’m here to shout about.</p><pre><code>
<span>export</span> <span>default</span> <span>function</span> <span>UserInfo</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Hello </span><span>{</span>props<span>.</span>user<span>?.</span>name<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span>

<span>export</span> <span>async</span> <span>function</span> <span>getServerSideProps</span><span>(</span><span>context</span><span>)</span> <span>{</span>
  <span>const</span> id <span>=</span> context<span>.</span>params<span>.</span>id<span>;</span>
  <span>const</span> user <span>=</span> <span>await</span> prisma<span>.</span>user<span>.</span><span>findFirst</span><span>(</span><span>{</span> where<span>:</span> <span>{</span> id<span>:</span> id <span>}</span> <span>}</span><span>)</span><span>;</span>

  <span>return</span> <span>{</span> props<span>:</span> <span>{</span> user <span>}</span> <span>}</span><span>;</span>
<span>}</span>
</code></pre><p>This seems innocent enough, right? Drop this code into your Next.js <code>pages</code> dir and everything passes.</p><p>Sadly, there are numerous type errors that this will silently allow you to introduce, such as:</p><ul><li>Modifying the schema (rename <code>name</code> to <code>username</code>)</li><li>Selecting different values from the <code>prisma.user</code> call</li><li>Changing the key you return <code>user</code> under in <code>getServerSideProps</code></li><li>Erroneously deleting the <code>getServerSideProps</code> function (…yes I’ve done this before)</li></ul><p>Even putting aside the <em>egregious</em> allowance of <code>implicit-any</code> that allows most of these failures to be possible, the recommended mitigation strategies don’t do enough. Let’s take a look at a few.</p><h3 id="manually-typing-props">Manually Typing Props</h3><pre><code>
<span>import</span> <span>type</span> <span>{</span> User <span>}</span> <span>from</span> <span>&#34;@prisma/client&#34;</span><span>;</span>

<span>const</span> UserInfo<span>:</span> React<span>.</span><span>FC</span><span>&lt;</span><span>{</span>user<span>:</span> User<span>}</span><span>&gt;</span> <span>=</span> <span>(</span>props<span>)</span> <span>{</span>
  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Hello </span><span>{</span>props<span>.</span>user<span>?.</span>name<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span>
</code></pre><p>Yay we did it! If we were to change <code>name</code> to <code>username</code> in the schema, we’d get a type error here!</p><p>But what if we modify the <code>getServerSideProps</code> function?</p><pre><code><span>export</span> <span>async</span> <span>function</span> <span>getServerSideProps</span><span>(</span><span>context</span><span>)</span> <span>{</span>
  <span>const</span> id <span>=</span> context<span>.</span>params<span>.</span>id<span>;</span>
  <span>const</span> user <span>=</span> <span>await</span> prisma<span>.</span>user<span>.</span><span>findFirst</span><span>(</span><span>{</span>
    where<span>:</span> <span>{</span> id<span>:</span> id <span>}</span><span>,</span>
    select<span>:</span> <span>{</span> id <span>}</span><span>,</span> 
  <span>}</span><span>)</span><span>;</span>

  <span>return</span> <span>{</span> props<span>:</span> <span>{</span> user <span>}</span> <span>}</span><span>;</span>
<span>}</span>
</code></pre><p>Note: we only made one change here, we <em>started selecting the values we needed more carefully</em>.</p><p>Sadly, since the page component <em>presumed the entire User was coming down the wire</em>, this will silently pass type checks. Since the <code>user?.name</code> call is optionally chained, this case will not throw an error, but that will only make debugging more painful.</p><h3 id="nexts-provided-inference-helper-infergetserversidepropstype">Next’s provided inference helper: <code>InferGetServerSidePropsType</code></h3><pre><code>
<span>import</span> <span>type</span> <span>{</span>
  GetServerSidePropsContext<span>,</span>
  InferGetServerSidePropsType<span>,</span>
<span>}</span> <span>from</span> <span>&#34;next&#34;</span><span>;</span>

<span>export</span> <span>const</span> <span>getServerSideProps</span> <span>=</span> <span>async</span> <span>(</span>
  <span>context<span>:</span> GetServerSidePropsContext</span>
<span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> id <span>=</span> context<span>.</span>params<span>?.</span>id<span>;</span>
  <span>const</span> user <span>=</span> <span>await</span> prisma<span>.</span>user<span>.</span><span>findFirst</span><span>(</span><span>{</span> where<span>:</span> <span>{</span> id<span>:</span> id <span>}</span> <span>}</span><span>)</span><span>;</span>

  <span>return</span> <span>{</span> props<span>:</span> <span>{</span> user <span>}</span> <span>}</span><span>;</span>
<span>}</span><span>;</span>


<span>type</span> <span>ServerSideProps</span> <span>=</span> InferGetServerSidePropsType<span>&lt;</span><span>typeof</span> getServerSideProps<span>&gt;</span><span>;</span>


<span>export</span> <span>default</span> <span>function</span> <span>UserInfo</span><span>(</span><span>props<span>:</span> ServerSideProps</span><span>)</span> <span>{</span>
  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Hello </span><span>{</span>props<span>.</span>user<span>?.</span>name<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span>
</code></pre><p>Shout out to <a href="https://twitter.com/flybayer">Brandon (Blitz.js)</a> and <a href="https://twitter.com/luis_fades">Luis (Vercel)</a> for pointing out that I <a href="https://nextjs.org/docs/basic-features/data-fetching#typescript-use-getserversideprops">entirely missed the provided inference type in the Next.js docs</a>.</p><p>The goal here is to use the types of your <code>getServerSideProps</code> function as a source of truth via inference. Funny enough, I’ve written a number of helpers to do this myself before.</p><p>As happy I am to know this exists, I’ve already ran into some painful edges with Next’s provided <code>InferGetServerSidePropsType</code></p><ul><li>It <a href="https://t3.gg/images/next-typesafety/infer-props-fail-1.png">overrides inferable types</a> as <code>{[key: string]: any}</code> generic objects if you cast function as <code>GetServerSideProps</code> w/o also manually assigning a type</li><li>It infers to <code>props: never</code> if you <a href="https://github.com/vercel/next.js/issues/15913">don’t specify input types as it expects</a></li></ul><p>To use this correctly, I had to have decent familiarity with Next’s internal typings and read through <a href="https://github.com/vercel/next.js/issues/15913">this GitHub issue thoroughly</a>. Even with that prerequisite, I found it shockingly easy to accidentally return a non-implicit <code>any</code> type, which <em>does not throw any errors under the provided Next.js <code>tsconfig</code></em> .</p><p>This method also requires you to manually type both the server-side function and the component props. There’s nothing implicit about the relationship, those prop types could easily be re-assigned or mis-assigned :(</p><h3 id="manually-typing-api-endpoints">Manually typing API endpoints</h3><p>This path is <a href="https://nextjs.org/docs/basic-features/typescript#api-routes">vaguely hinted at in the Next.js docs</a>, but will require we break up our solution a bit. I will also be including <a href="https://react-query.tanstack.com/">React Query</a> to make this example significantly less burdensome (I would have used Vercel’s <a href="https://swr.vercel.app/">swr</a> package, but I was unable to find a TypeScript example in their docs).</p><pre><code>
<span>import</span> <span>type</span> <span>{</span> NextApiRequest<span>,</span> NextApiResponse <span>}</span> <span>from</span> <span>&#34;next&#34;</span><span>;</span>
<span>import</span> <span>type</span> <span>{</span> User <span>}</span> <span>from</span> <span>&#34;@prisma/client&#34;</span><span>;</span>

<span>export</span> <span>type</span> <span>UserRequestData</span> <span>=</span> <span>{</span>
  user<span>:</span> User<span>;</span>
<span>}</span><span>;</span>

<span>export</span> <span>default</span> <span>async</span> <span>(</span>
  <span>req<span>:</span> NextApiRequest<span>,</span>
  res<span>:</span> NextApiResponse<span>&lt;</span>UserRequestData<span>&gt;</span></span>
<span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>{</span> userId <span>}</span> <span>=</span> req<span>.</span>query<span>;</span>

  <span>const</span> user <span>=</span> <span>await</span> prisma<span>.</span>user<span>.</span><span>findFirst</span><span>(</span><span>{</span> where<span>:</span> <span>{</span> id<span>:</span> userId <span>}</span> <span>}</span><span>)</span><span>;</span>
  res<span>.</span><span>status</span><span>(</span><span>200</span><span>)</span><span>.</span><span>json</span><span>(</span><span>{</span> user <span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span>


<span>import</span> <span>{</span> UserRequestData <span>}</span> <span>from</span> <span>&#34;../api/get-user-by-id&#34;</span><span>;</span>
<span>import</span> <span>{</span> useQuery <span>}</span> <span>from</span> <span>&#34;react-query&#34;</span><span>;</span>

<span>const</span> <span>getUserById</span> <span>=</span> <span>async</span> <span>(</span><span>userId<span>:</span> string</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>&#34;/api/get-user-by-id?userId=&#34;</span> <span>+</span> query<span>.</span>userId<span>)</span><span>;</span>

  <span>// Assign type imported from server code</span>
  <span>return</span> <span>(</span><span>await</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>)</span> <span>as</span> UserRequestData<span>;</span>
<span>}</span><span>;</span>

<span>export</span> <span>function</span> <span>UserInfo</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>const</span> <span>{</span> query <span>}</span> <span>=</span> <span>useRouter</span><span>(</span><span>)</span><span>;</span> <span>// Get userId from query params</span>

  <span>// Fetch from server with loading and error state</span>
  <span>const</span> <span>{</span> data<span>,</span> isLoading <span>}</span> <span>=</span> <span><span>useQuery</span><span><span>&lt;</span>UserRequestData<span>&gt;</span></span></span><span>(</span>
    <span>[</span><span>&#34;user&#34;</span><span>,</span> query<span>.</span>id<span>]</span><span>,</span>
    <span>(</span><span>)</span> <span>=&gt;</span> <span>getUserById</span><span>(</span>query<span>.</span>id<span>)</span>
  <span>)</span><span>;</span>

  <span>if</span> <span>(</span>isLoading<span>)</span> <span>return</span> <span>null</span><span>;</span>

  <span>if</span> <span>(</span><span>!</span>data<span>)</span> <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Error: user not found</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Hello </span><span>{</span>data<span>.</span>user<span>?.</span>name<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span>
</code></pre><p>This one may look like a lot, but for a full-stack backend and frontend with typesafety across both, it’s not bad. It’s important to note that, by moving from <code>getServerSideProps</code> to React Query (or swr), <em>we have moved the data fetching from the server to the client in pursuit of type safety.</em></p><p>There are definite benefits to this approach. By putting the type definition so close to the API, we are making the “contract of what is returned” more reliable to consume.</p><p>There are definite negatives as well. The verbosity compared to the earlier options is apparent and absurd. We’ve given up a lot of our SSR benefits. But have we gained a lot in terms of type safety?</p><p>I’d argue no.</p><p>By defining the types manually, we’re still leaving a lot of surface area for error. What if I import the wrong type? What if I fetch from the wrong URL? What if I forget to call <code>.json()</code> (which I totally did when writing this example)?</p><p>I think we can do better.</p><h2 id="an-inconsistent-truth">An Inconsistent Truth</h2><p>All of the type failures encountered in the above examples stem from roughly the same core issue: the “types” and the “sources of data” are not tied together implicitly. By separating the source of data and the source of truth, we introduce space for errors.</p><p>Let’s repeat that for those in the back.</p><p><strong>By separating the source of data and the source of truth, we introduce space for errors.</strong></p><p>This is a big part of why I love Prisma so much. Your “source of truth” is the <code>schema.prisma</code> file. Everything else is inferred from there. You will not be writing your own type defs with Prisma.</p><p>To be clear, Next is solving a very different problem and can’t generate a bunch of types out of a model file. Still though, I’d love if <code>getServerSideProps</code> worked similarly.</p><p>The closest we can get right now is <code>InferGetServerSidePropsType</code>. It is the <em>safest way to honor the contracts inherent to TypeScript across the client and server barrier while using server side function helpers in Next.</em></p><p>Sadly, digging deeper into the provided types has only made me more cynical. There are some scary typedefs within Next’s provided types, <code>GetServerSideProps</code> in particular</p><pre><code><span>export</span> <span>type</span> <span>GetServerSideProps<span>&lt;</span>
  <span>P</span> <span>extends</span> <span>{</span> <span>[</span>key<span>:</span> <span>string</span><span>]</span><span>:</span> <span>any</span> <span>}</span> <span>=</span> <span>{</span> <span>[</span>key<span>:</span> <span>string</span><span>]</span><span>:</span> <span>any</span> <span>}</span><span>,</span>
  <span>Q</span> <span>extends</span> ParsedUrlQuery <span>=</span> ParsedUrlQuery<span>,</span>
  <span>D</span> <span>extends</span> PreviewData <span>=</span> PreviewData
<span>&gt;</span></span> <span>=</span> <span>(</span>
  <span>context<span>:</span> GetServerSidePropsContext<span>&lt;</span><span>Q</span><span>,</span> <span>D</span><span>&gt;</span></span>
<span>)</span> <span>=&gt;</span> <span>Promise</span><span>&lt;</span>GetServerSidePropsResult<span>&lt;</span><span>P</span><span>&gt;&gt;</span><span>;</span>
</code></pre><p>The <code>P extends</code> bit that auto-assigns a generic object as the return type is…very scary. Way too easy to trigger. IMO, this first arg should be mandatory if this prop is going to be used.</p><p>After chatting with some folks at Vercel, it’s clear they’re working to make this better. A lot of the generic export type issues I’ve laid out here can be <a href="https://github.com/microsoft/TypeScript/issues/38511">sourced back to a more generic export typing issue in TypeScript itself</a> (ty <a href="https://twitter.com/balazsorban44">Balázs</a> for pointing me to this).</p><p><em>All that said</em>, I think we can work around these problems :)</p><h2 id="exploring-outside-of-next">Exploring Outside Of Next</h2><h3 id="typesafe-apis">Typesafe APIs</h3><p>Before I go too deep here, I should make my bias clear. I’m a <a href="https://twitter.com/t3dotgg/status/1438434802839945220">tRPC fanboy</a>.</p><p><a href="https://trpc.io/">tRPC</a> takes full stack type inference to the next level by relying on the types defined in your router as a “schema” on your client. <a href="https://blitzjs.com/">Blitz.js</a> does <a href="https://blitzjs.com/docs/query-resolvers">something similar with queries</a>. Both wrap React Query with typesafe definitions at the API level, which enables some “magic” with type consistency.</p><p>While this example uses Next, tRPC does not require you use it. It doesn’t even require React. Any typescript server and client can serve and consume a tRPC router</p><pre><code><span>// pages/api/trpc/[trpc].ts</span>
<span>const</span> appRouter <span>=</span> trpc<span>.</span><span>router</span><span>(</span><span>)</span><span>.</span><span>query</span><span>(</span><span>&#34;get-user-by-id&#34;</span><span>,</span> <span>{</span>
  input<span>:</span> z<span>.</span><span>object</span><span>(</span><span>{</span>
    userId<span>:</span> z<span>.</span><span>string</span><span>(</span><span>)</span><span>,</span>
  <span>}</span><span>)</span><span>,</span>
  <span>async</span> <span>resolve</span><span>(</span><span><span>{</span> input <span>}</span></span><span>)</span> <span>{</span>
    <span>const</span> user <span>=</span> <span>await</span> prisma<span>.</span>user<span>.</span><span>findFirst</span><span>(</span><span>{</span> where<span>:</span> <span>{</span> id<span>:</span> input<span>.</span>userId <span>}</span> <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>{</span> user <span>}</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>

<span>export</span> <span>type</span> <span>AppRouter</span> <span>=</span> <span>typeof</span> appRouter<span>;</span>

<span>// pages/user/[id].ts</span>
<span>import</span> trpc <span>from</span> <span>&#34;../utils/trpc&#34;</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>UserInfo</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>{</span> query <span>}</span> <span>=</span> <span>useRouter</span><span>(</span><span>)</span><span>;</span>

  <span>// trpc.useQuery will call &#34;get-user-by-id&#34; api with {userId: query.id}</span>
  <span>const</span> <span>{</span> data <span>}</span> <span>=</span> trpc<span>.</span><span>useQuery</span><span>(</span><span>[</span><span>&#34;get-user-by-id&#34;</span><span>,</span> <span>{</span> userId<span>:</span> query<span>.</span>id <span>}</span><span>]</span><span>)</span><span>;</span>

  <span>if</span> <span>(</span><span>!</span>data<span>)</span> <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Error: user not found</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Hello </span><span>{</span>data<span>.</span>user<span>?.</span>name<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span>
</code></pre><p>It’s important to note that the <code>trpc.useQuery</code> call is as close to 100% typesafe as you can get (hell, even in this case it will type error because <code>query.id</code> isn’t guaranteed to exist).</p><p>The <code>&#34;get-user-by-id&#34;</code> string will auto-complete, and type error if it is not a real query in your tRPC router. The input will error if it doesn’t match the <a href="https://github.com/colinhacks/zod">zod schema</a> in your query/mutation. The data is typed identically to the return types of your <code>resolve</code> function (even if you use <code>Map</code> and <code>Date</code>, <a href="https://github.com/blitz-js/superjson">superjson</a> can convert those too). Also - unlike the earlier example, this one <a href="https://trpc.io/docs/ssr#configure-_apptsx-for-ssr">can also work with SSR</a>.</p><h3 id="server-components">Server Components</h3><p>This is the React 18 solution. “Just call the backend code in the component”.</p><pre><code><span>// components/user.server.tsx</span>
<span>export</span> <span>const</span> UserInfo<span>:</span> React<span>.</span><span>FC</span><span>&lt;</span><span>{</span> userId<span>:</span> <span>string</span> <span>}</span><span>&gt;</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> user <span>=</span> prisma<span>.</span>user<span>.</span><span>findFirst</span><span>(</span><span>{</span> where<span>:</span> <span>{</span> id<span>:</span> props<span>.</span>userId <span>}</span> <span>}</span><span>)</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Hello </span><span>{</span>user<span>?.</span>name<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span><span>;</span>

<span>// pages/user/[id].tsx</span>
<span>import</span> <span>{</span> Suspense <span>}</span> <span>from</span> <span>&#34;react&#34;</span><span>;</span>
<span>import</span> <span>{</span> UserInfo <span>}</span> <span>from</span> <span>&#34;../../components/user.server&#34;</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>UserInfoPage</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>const</span> <span>{</span> query <span>}</span> <span>=</span> <span>useRouter</span><span>(</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span><span>Suspense</span></span> <span>fallback</span><span><span>=</span><span>{</span><span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Loading...</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>}</span></span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span><span>UserInfo</span></span> <span>userId</span><span><span>=</span><span>{</span>query<span>.</span>id<span>}</span></span> <span>/&gt;</span></span><span>
    </span><span><span><span>&lt;/</span><span>Suspense</span></span><span>&gt;</span></span>
  <span>)</span><span>;</span>
<span>}</span>
</code></pre><p>Server components are really damn cool. I think they will help significantly reduce the number of places where this problem exists. I also suspect the transition towards server components will take a long while, and important cases like header metadata will be missed unless explicitly SSR’d ahead of time.</p><p>Server components are the future. What about now?</p><h2 id="a-proposal-_propsts">A Proposal: <code>_props.ts</code></h2><p>I want to preface this with a few things</p><ul><li>I’m writing this out of immense love for Vercel and Next.js. This stack is the most productive I’ve ever felt and I don’t suspect that will change any time soon. I’m betting my company on it.</li><li>I’m far from a TypeScript expert - especially on the maintainer side. TypeScript is a whole different beast when you are working on libraries that provide generics. Thank you <a href="https://twitter.com/tannerlinsley">Tanner</a> and <a href="https://twitter.com/alexdotjs">KATT</a> for giving me a glimpse into that world.</li><li>I have no intention of implementing any of the things I discuss here. I’m very happy with my tRPC + Next setup and don’t want to move. This is purely theoretical.</li></ul><p>All that said, hear me out.</p><h3 id="lightly-inspired">Lightly Inspired</h3><p>Think of this ergonomically as an in-between of the new <a href="https://nextjs.org/docs/middleware">Next.js Middleware syntax</a> of <code>_middleware.ts</code> and the philosophy behind <a href="https://blitzjs.com/docs/query-resolvers">Blitz.js query resolvers</a>.</p><pre><code><span>// pages/user-info/_props.ts</span>
<span>export</span> <span>async</span> <span>function</span> <span>getServerSideProps</span><span>(</span><span>context</span><span>)</span> <span>{</span>
  <span>const</span> id <span>=</span> context<span>.</span>params<span>.</span>id<span>;</span>
  <span>const</span> user <span>=</span> <span>await</span> prisma<span>.</span>user<span>.</span><span>findFirst</span><span>(</span><span>{</span> where<span>:</span> <span>{</span> id<span>:</span> id <span>}</span> <span>}</span><span>)</span><span>;</span>

  <span>return</span> <span>{</span> props<span>:</span> <span>{</span> user <span>}</span> <span>}</span><span>;</span>
<span>}</span>

<span>// pages/user-info/[id].ts</span>
<span>import</span> Props <span>from</span> <span>&#34;./_props&#34;</span><span>;</span> <span>// This will have to be some wizardry or a compile step</span>

<span>// This should lint error if the type was assigned</span>
<span>// to something other than _props in the same dir</span>
<span>export</span> <span>default</span> <span>function</span> <span>UserInfo</span><span>(</span><span>props<span>:</span> Props</span><span>)</span> <span>{</span>
  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>Hello </span><span>{</span>props<span>.</span>user<span>?.</span>name<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span>
</code></pre><p>This is a very rough sketch of what I have in mind. My “general thought” is a file-level barrier between “the thing run on the server” and “the thing run on server AND client”, with an implicit type contract (potentially generated) through the creation of these files. Could even spit out a <code>useServerSideProps</code> hook 🤔</p><p>Under the hood I would expect this to use something similar to the <code>AsyncInferType</code> example earlier. I can see potential ways to extend this further, such as additional keys you can return or other named files i.e. <code>_dynamicProps.ts</code> or <code>_staticProps.ts</code>.</p><p>Generally, I like the idea of “files with an underscore run on the server”, and that thought brought me here. I think it can go really far, especially when combined with a compiler. Not many other companies are in a position to change all the pieces to build something like this.</p><p><strong>It’s been proven that full stack type inference is possible with modern TypeScript tooling. Let’s work towards a future where that’s the default 🙂</strong></p><h2 id="thank-you">Thank You</h2><p>This was a long one. I know it may seem harsh towards Next and Vercel, but that was not my intent at all. I’m critical out of love. I would never have written this much about something <em>I didn’t intend to use for years</em>. I bet my company on this stack. I feel like we’re working in a stack from the future.</p><p>Want to shout out a bunch of people who gave feedback on this article, I would have looked way stupider without y’all</p><p>Shoutout to <a href="https://twitter.com/alexdotjs">Alex (tRPC)</a>, <a href="https://twitter.com/balazsorban44">Balázs (NextAuth.js)</a>, <a href="https://twitter.com/luis_fades">Luis (Vercel)</a>, <a href="https://twitter.com/leeerob">Lee (Vercel)</a>, <a href="https://twitter.com/flybayer">Brandon (Blitz.jz)</a>, <a href="https://twitter.com/JacobMGEvans">Jacob (CloudFlare)</a>, <a href="https://twitter.com/tannerlinsley">Tanner (TanStack/ React-Query)</a>, <a href="https://twitter.com/jnsdls">Jonas (ThirdWeb)</a> and everyone else who I’m forgetting.</p><h3 id="extra-stuff">Extra stuff</h3><p>If you got this far, you <strong><a href="https://twitter.com/t3dotgg">might like my rants on Twitter as well</a>.</strong></p><p>If you want to see this tech in action, check out this 2+ hour deep dive <a href="https://www.youtube.com/watch?v=PKy2lYEnhgs">building a full stack app with Prisma, PlanetScale, Next.js, TypeScript, Vercel, tRPC, and Tailwind</a>.</p></main></article></div>
  </body>
</html>
