<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dbreunig.com/2026/02/21/why-is-claude-an-electron-app.html">Original</a>
    <h1>When Code is Free, Why is Claude is an Electron app?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <h3 id="if-code-is-free-why-arent-all-apps-native">If code is free, why aren’t all apps native?</h3>

<p>The state of coding agents can be summed up by <a href="https://x.com/dbreunig/status/2024970389156495365?s=46">this fact</a></p>

<blockquote>
  <p>Claude spent $20k on an agent swarm implementing (kinda) a C-compiler in Rust, but desktop Claude is an Electron app.</p>
</blockquote>

<p>If you’re unfamiliar, Electron is a coding framework for building desktop applications using web tech, specifically HTML, CSS, and JS. What’s great about Electron is it allows you to  build one desktop app that supports Windows, Mac, and Linux. Plus it lets developers use existing web app code to get started. It’s great for teams big and small. <a href="https://en.wikipedia.org/wiki/List_of_software_using_Electron?wprov=sfti1">Many apps you probably use every day are built with Electron</a>: Slack, Discord, VS Code, Teams, Notion, and more.</p>

<p>There are downsides though. Electron apps are bloated; each runs its own Chromium engine. The minimum app size is usually a couple hundred megabytes. They are often laggy or unresponsive. They don’t integrate well with OS features.</p>

<p>(These last two issues <em>can</em> be addressed by smart development and OS-specific code, but they rarely are. The benefits of Electron (one codebase, many platforms, it’s just web!) don’t incentivize optimizations outside of HTML/JS/CSS land.)</p>

<p>But these downsides are dramatically outweighed by the ability to build and maintain one app, shipping it everywhere.</p>

<p>But now we have coding agents! <a href="https://www.dbreunig.com/2026/02/06/the-rise-of-spec-driven-development.html">And one thing coding agents are proving to be pretty good at is cross-platform, cross-language implementations given a well-defined spec and test suite</a>.</p>

<p>On the surface, this ability should render Electron’s benefits obsolete! Rather than write one web app and ship it to each platform, we should write <em>one spec and test suite</em> and use coding agents to ship <em>native</em> code to each platform. If this ability is real and adopted, users get snappy, performant, native apps from small, focused teams serving a broad market.</p>

<p>But we’re still leaning on Electron. Even Anthropic, one of the leaders in AI coding tools, who keeps publishing flashy agentic coding achievements, still uses Electron in the Claude desktop app. And it’s slow, buggy, and bloated app.</p>

<p><em>So why are we still using Electron and not embracing the agent-powered, spec driven development future?</em></p>

<p>For one thing, coding agents are <em>really</em> good at the first 90% of dev. But that last bit – nailing down all the edge cases and continuing support once it meets the real world – remains hard, tedious, and requires plenty of agent hand-holding.</p>

<p>Anthropic’s <a href="https://www.anthropic.com/engineering/building-c-compiler">Rust-base C compiler</a> slammed into this wall, after screaming through the bulk of the tests:</p>

<blockquote>
  <p>The resulting compiler has nearly reached the limits of Opus’s abilities. I tried (hard!) to fix several of the above limitations but wasn’t fully successful. New features and bugfixes frequently broke existing functionality.</p>
</blockquote>

<p>The resulting compiler <em>is</em> impressive, given the time it took to deliver it and the number of people who worked on it, but it is largely unusable. That last mile is <em>hard</em>.</p>

<p>And this gets even worse once a program meets the real world. Messy, unexpected scenarios stack up and development never really ends. Agents make it easier, sure, but hard product decisions become challenged and require human decisions.</p>

<p>Further, with 3 different apps produced (Mac, Windows, and Linux) the surface area for bugs and support increases 3-fold. Sure, there are local quirks with Electron apps, but most of it is mitigated by the common wrapper. Not so with native!</p>

<p>A good test suite and spec <em>could</em> enable the Claude team to ship a Claude desktop app native to each platform. But the resulting overhead of that last 10% of dev and the increased support and maintenance burden will remain.</p>

<p>For now, Electron still makes sense. Coding agents are amazing. But the last mile of dev and the support surface area remains a real concern.</p>

<hr/>



  </div></div>
  </body>
</html>
