<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.candyjapan.com/behind-the-scenes/algorithmic-fitting-of-japanese-candy">Original</a>
    <h1>Algorithmic fitting of Japanese candy</h1>
    
    <div id="readability-page-1" class="page"><div id="droparea"><p>Back when I still ran the subscription box Candy Japan, I spent many hours looking for candy and then checking which combinations would fit into a box in the best way.</p>

<p>Hey I know, I&#39;m a programmer, I&#39;ll just write an algorithm to do it for me. How hard could it be?</p>

<p><i>Given a list of candy dimensions, test if they&#39;ll fit within the 23 x 17 x 4 cm parcel pictured below.</i></p>

<canvas id="box" width="1000" height="600"></canvas>

<p>One necessary but not sufficient condition is that the total volume of the candies has to be less than the volume of the parcel.</p>

<p>Another one is that no individual candy can be too big:</p>

<canvas id="tooBig" width="1000" height="600"></canvas>

<p>Even with both conditions met, the candy still might not fit.</p>

<p>Below you can see an example of this. The green candy would fit in the box, but adding the red candy is impossible, even though each would fit individually and their total volume is less than that of the box.</p>

<canvas id="noCombo" width="1000" height="600"></canvas>

<p>To find the true solution, we can try putting candies next to each other in various ways to see if any permutations would fit. Different locations and rotations need to be tested.</p>

<p>Rotating the boxes is simple, just find all the ways to permute dimensions.</p>

<canvas id="showRotations" width="1000" height="600"></canvas>

<p>If you tested different locations millimeter by millimeter in three dimensions, with just three candies you would be looking at roughly 10<sup>20</sup> ways to place them. The program would take millions of years to complete.</p>

<h2>Reducing permutations</h2>
<p>Testing any combination which leaves space between the candies is useless. You can always just move them closer together and still have a valid permutation. In other words, don&#39;t test &#34;islands&#34; of candy.</p>

<canvas id="candyIsland" width="1000" height="600"></canvas>

<p>Now you only need to test combinations where the candies are touching, but you can still slide the candies along each other, leaving as many permutations as you want accuracy.</p>

<p>Sliding the smaller one past the edge of the larger one just takes more space. Placing the smaller one between the edges doesn&#39;t take more space, but it isn&#39;t helping either.</p>

<canvas id="candySlide" width="1000" height="600"></canvas>

<p>From this it seems enough to only test combinations where two edges align. The parent box stays put while the child box goes through possible positions. The parent has 6 surfaces, each surface with 4 ways to align the unrotated child.</p>

<canvas id="twoBoxes" width="1000" height="600"></canvas>

<p>Below you can see the 144 different alignments after child rotation is also taken into account.</p>

<canvas id="twoBoxesRotated" width="1000" height="600"></canvas>

<p>This method can be chained to test for arbitrary numbers of candy, although the permutations explode quite rapidly. </p>

<h3>6*144<sup>(n-1)</sup>*(n-1)! <sup onclick="$(&#39;#explanation&#39;).slideToggle()">?</sup></h3>



<table>
            <tbody><tr><td>n</td><td>permutations</td></tr>
            <tr><td>1</td><td>6</td></tr>
            <tr><td>2</td><td>864</td></tr>
            <tr><td>3</td><td>248832</td></tr>
            <tr><td>4</td><td>107495424</td></tr>
</tbody></table>

<p>At a million tests per second, 4 boxes would already take over a minute in the worst case, although you can abort as soon as you find a fit.  With more boxes it would also be necessary to test for intersections with previously added ones, which would also eliminate many recursions. </p>

<h2>Conclusion &amp; improvements</h2>
<p>So how hard can it be? <a href="https://en.wikipedia.org/wiki/Bin_packing_problem">NP-hard</a>, it turns out.</p>

<p>It would make sense to try some common arrangements first, and to not venture down recursive branches where the previous box combination is already known not to fit.</p>

<p>I am likely to use an existing solution if I adopt this way to find optimal candy sequences, since at this point my JavaScript code is just too slow. For example the Python package pyShipping comes with <a href="https://github.com/hudora/pyShipping/blob/master/pyshipping/binpack_simple.py">an implementation</a> which speeds up these tests by using heuristics.</p>

<p>Still, writing this was a fun learning experience. While I didn&#39;t learn to solve this problem, at least now I know it&#39;s way harder than it seems.Â </p>

<p><b>Thank you for reading</b></p><div><p>Candy Japan no longer exists, as the increase of postal rates from Japan made my already low margins even worse, so I gave up on the project. To see what I&#39;m up to now, <a href="https://www.bemmu.com/">check here</a> or follow me on X/Twitter <a href="https://twitter.com/bemmu">@bemmu</a>.<br/></p></div>






</div></div>
  </body>
</html>
