<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/nviennot/stm32-emulator">Original</a>
    <h1>An STM32 emulator written in Rust for 3D printers</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">The goal is to simulate 3D printers, but any sort of stm32 microcontroller firmware should work.</p>
<p dir="auto">The emulator is configured via a configuration file, see example
<a href="https://github.com/nviennot/stm32-emulator/blob/main/saturn/config.yaml">here</a>.</p>
<p dir="auto">In the following example, I show how to emulate the 3D printer of the Elegoo
Saturn and Anycubic MonoX unmodified firmwares downloaded from the vendor website.</p>
<p dir="auto">This emulator is done in the context of my work on <a href="https://github.com/nviennot/reversing-mono4k">reverse engineering 3D
printers</a> so I can write a Rust
firmware for 3D printers, <a href="https://github.com/nviennot/turbo-resin">Turbo Resin</a>.</p>
<h2 dir="auto"><a id="user-content-table-of-content" aria-hidden="true" href="#table-of-content"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Table of content</h2>
<ul dir="auto">
<li><a href="#emulating-the-elegoo-saturn">Emulating the Elegoo Saturn</a></li>
<li><a href="#emulating-the-anycubic-mono-x">Emulating the Anycubic Mono X</a></li>
<li><a href="#emulator-features">Features</a></li>
<li><a href="#existing-work">Existing Work</a></li>
</ul>
<h2 dir="auto"><a id="user-content-emulating-the-elegoo-saturn" aria-hidden="true" href="#emulating-the-elegoo-saturn"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Emulating the Elegoo Saturn</h2>
<p dir="auto">In the <a href="https://github.com/nviennot/stm32-emulator/blob/main/saturn/config.yaml">configuration file</a>,
we provide an SVD file that provides all the peripheral register addresses for
the STM32F407. We then configure various memory regions, framebuffers, and
devices. We also patch two functions in the firmware just to speed things up as
we don&#39;t need to wait for our devices to initialize.</p>
<p dir="auto">We also specify the firmware binary <code>saturn-v4.4.3-pj-v5.bin</code>, and that&#39;s the
official binary downloaded from the Elegoo website.  The <code>ext-flash.bin</code> is the
content of the external SPI flash dumped from the Saturn board itself (I cheated
a bit here, I wish we could have just used the downloaded version, it wasn&#39;t
working, and I was in a hurry).</p>
<h3 dir="auto"><a id="user-content-youtube-demo-click-on-the-image" aria-hidden="true" href="#youtube-demo-click-on-the-image"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Youtube demo (click on the image)</h3>
<p dir="auto"><a href="https://www.youtube.com/watch?v=Uc8eq4JsJyM" rel="nofollow"><img src="https://blog.jfo.click/nviennot/stm32-emulator/raw/main/readme-assets/youtube-saturn.png" alt="Saturn"/></a></p>
<h3 dir="auto"><a id="user-content-try-it-out" aria-hidden="true" href="#try-it-out"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Try it out</h3>
<div data-snippet-clipboard-copy-content="$ git clone https://github.com/nviennot/stm32-emulator.git
$ cd stm32-emulator/saturn
$ cargo run --release -- config.yaml -v"><pre><code>$ git clone https://github.com/nviennot/stm32-emulator.git
$ cd stm32-emulator/saturn
$ cargo run --release -- config.yaml -v
</code></pre></div>
<h3 dir="auto"><a id="user-content-the-output" aria-hidden="true" href="#the-output"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The output</h3>
<p dir="auto">On the following we see some of the output.
We can see how the firmware initialize the display for example. These are
display commands we need to reproduce when implementing our own firmware.
We can also see that it&#39;s emitting something on the UART.
We also see its interaction with the SPI Flash.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://blog.jfo.click/nviennot/stm32-emulator/blob/main/readme-assets/saturn-trace.png"><img src="https://blog.jfo.click/nviennot/stm32-emulator/raw/main/readme-assets/saturn-trace.png" alt="Saturn trace"/></a></p>
<p dir="auto">We can also see that the firmware has issues. The init routines are messy from
what I&#39;ve seen in the decompilation. In the emulation, we can see NULL pointer
exceptions, GPIO being re-configured multiple times.
On the STM32, address 0 is actually mapped to the flash, and so the memory
accesses in the first 4K don&#39;t actually fail, so failures of this nature go
silent.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://blog.jfo.click/nviennot/stm32-emulator/blob/main/readme-assets/saturn-null.png"><img src="https://blog.jfo.click/nviennot/stm32-emulator/raw/main/readme-assets/saturn-null.png" alt="Saturn NULL"/></a></p>
<p dir="auto">We can see how the GPIOs are getting configured:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://blog.jfo.click/nviennot/stm32-emulator/blob/main/readme-assets/saturn-gpio.png"><img src="https://blog.jfo.click/nviennot/stm32-emulator/raw/main/readme-assets/saturn-gpio.png" alt="Saturn GPIO"/></a></p>
<p dir="auto">We can see how a specific peripheral gets initialized, like SPI2. That
information is coming right off the SVD file.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://blog.jfo.click/nviennot/stm32-emulator/blob/main/readme-assets/saturn-spi2.png"><img src="https://blog.jfo.click/nviennot/stm32-emulator/raw/main/readme-assets/saturn-spi2.png" alt="Saturn SPI2"/></a></p>
<p dir="auto">We can also do instruction tracing with <code>-vvvv</code>:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://blog.jfo.click/nviennot/stm32-emulator/blob/main/readme-assets/saturn-inst.png"><img src="https://blog.jfo.click/nviennot/stm32-emulator/raw/main/readme-assets/saturn-inst.png" alt="Saturn instructions"/></a></p>
<p dir="auto">Overall, the emulator is useful to understand what the firmware is doing without
having the real printer on hand, which will be helpful in supporting additional
printers for TurboResin.</p>
<p dir="auto">It would be fun to implement a GDB server provided by the emulator, this way we
could use GDB to inspect the runtime, and even connect a decompiler like Ghirda
or IDA Pro.</p>
<h2 dir="auto"><a id="user-content-emulating-the-anycubic-mono-x" aria-hidden="true" href="#emulating-the-anycubic-mono-x"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Emulating the Anycubic Mono X</h2>
<h3 dir="auto"><a id="user-content-youtube-demo-click-on-the-image-1" aria-hidden="true" href="#youtube-demo-click-on-the-image-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Youtube demo (click on the image)</h3>
<p dir="auto"><a href="https://www.youtube.com/watch?v=VyB3ru0u4Go" rel="nofollow"><img src="https://blog.jfo.click/nviennot/stm32-emulator/raw/main/readme-assets/youtube-monox.png" alt="MonoX"/></a></p>
<h3 dir="auto"><a id="user-content-try-it-out-1" aria-hidden="true" href="#try-it-out-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Try it out</h3>
<div data-snippet-clipboard-copy-content="$ git clone https://github.com/nviennot/stm32-emulator.git
$ cd stm32-emulator/monox
$ cargo run --release -- config.yaml -v"><pre><code>$ git clone https://github.com/nviennot/stm32-emulator.git
$ cd stm32-emulator/monox
$ cargo run --release -- config.yaml -v
</code></pre></div>
<hr/>
<h2 dir="auto"><a id="user-content-emulator-features" aria-hidden="true" href="#emulator-features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Emulator Features</h2>
<ul dir="auto">
<li>The ARM instructions are emulated via Unicorn (a Qemu fork). We can register
hooks on memory read/write given memory range. This gives us a way to provide
implementations for all the internal peripherals as they are all accessible
via memory mapped registers. For example, writing <code>1</code> to the address <code>0x40020014</code>
means that the pin <code>PA0</code> should be driven to +3.3V.</li>
<li>There are a lot of registers, precisely 1537 of them for the STM32F407.
The emulator is configured via a <a href="https://github.com/stm32-rs/stm32-rs-mmaps">vendor provided SVD
file</a>. This way, we can easily
emulate many different STM32s without having to worry about peripheral
register addresses. The emulator also uses that to display traces of all
register accesses, useful for debugging the firmware.</li>
<li>The following internal peripherals are implemented, some just partially:
<ul dir="auto">
<li>Systick: Used by the firmware to schedule tasks, and perform long delays.
(short delays are typically done with empty <code>for</code> loops doing lots of
iterations).</li>
<li>RCC: Clocks configuration. The firmware waits for the PLLs to be ready, so
we must give the illusion that some PLLs are ready.</li>
<li>USART: Sometimes, the firmware emits debug messages (printf), we can collect
these messages on these devices and print it on stdout.</li>
<li>SPI: SPI peripherals are connected to various external devices. For example,
both the Saturn and the Anycubic Mono X use the SPI interface for access
their on-board 16MB SPI flash.</li>
<li>I2C: There&#39;s an EEPROM on board to store settings, like if the sound should
be on or off, or the chosen language.</li>
<li>FSMC: Normally used for connecting external SDRAM chips, this is used for
connecting the display as this peripheral makes it easy to output data on
16 wires in parallel in a single instruction.</li>
<li>GPIO: We want to see all the pin input/output configurations and monitor
all activity. That&#39;s a really important part of figuring out what the system
does.</li>
<li>Software SPI: This is not a real internal peripheral. Sometimes, the
firmware implements its own bit-banging SPI algorithm by manipulating the
GPIO port directly  to communicate to various devices. For example, the
Saturn uses software SPI with the FPGA, and the Mono X uses software SPI to
communicate with its resistive touchscreen.</li>
<li>DMA: The Saturn firmware uses DMA to send data to USART
peripherals at times. This means that instead of writing to the USART
data register one byte at a time, it instructs the DMA
engine to copy a memory region to the USART data register, byte after byte,
allowing the CPU to go do something else.</li>
<li>NVIC a.k.a. the interrupt controller: The Unicorn engine does not handle
interrupts. We need it, as the Saturn OS uses PENDSV interrupts to perform
context switches between different execution threads. Here&#39;s what was
involved with implementing the interrupt controller. Here&#39;s how it works:
<ul dir="auto">
<li>After every single executed instruction, we check if there&#39;s a pending
interrupt that should be triggered.</li>
<li>We push all the needed registers onto the stack. There&#39;s actually two
different stacks on the ARM CPU. The master stack and the process stack.
The one in use is indicated through the Control register. We must
also push floating point registers if they are enabled.</li>
<li>Then we setup the LR register to a special value that will turn a regular
function return instruction into a return from interrupt instruction.
That special value encodes whether we are using the master or process
stack.</li>
<li>Next, we setup the PC register to point to the correct interrupt vector
address configured via the vector table located at <code>0x08000000</code>.</li>
<li>When the function returns, we read the LR register (modifiable by the
firmware to switch from the master stack to the process stack) to unwind
the interrupt stack correctly.</li>
</ul>
</li>
</ul>
</li>
<li>Next, we have external devices that can be plugged into internal devices like
USART, FSMC, I2C, software SPI, or directly on a specific GPIO pin. I have
implemented a few:
<ul dir="auto">
<li>SPI flash: Both the Saturn and Mono X use a SPI flash to store things like
fonts and graphics for the display. Reads happen at the same time as writes
(full-duplex), making the implementation a big streaming state machine.
There were challenging details such as supporting the SPI peripheral in both
8-bit and 16-bit mode, and having everything configurable via a config file.</li>
<li>TFT display: This emulates an ILI9341 TFT display controller.
firmware can instruct commands like &#34;The following data is the pixel data
to fill this (x1,y1,x2,y2) rectangle&#34;.  The pixel data can be configured to
go in two different framebuffers:
<ul dir="auto">
<li>A PNG file on disk, written after the emulation is stopped</li>
<li>A live window showing in real time the content of the display. This is
implemented using the SDL2 library. I thought it would be a good idea
to use this one because it&#39;s used for video games and other performance
sensitive applications.</li>
</ul>
</li>
<li>Touch screen: This emulates an ADS7846 resistive touch screen. There&#39;s
various commands to handle, like MeasureX, MeasureY, MeasureZ (pressure),
which can be configured to be read in either 8 or 12 bits precision.
The Mono X relies on a separate GPIO pin to indicate when the display
detects a touch. Implementing this was important otherwise, it would ignore
the touch screen.</li>
<li>LCD panel: We emulate the FPGA driving the LCD panel. It decodes and sends
the pixel data to a framebuffer similarly to the TFT display.</li>
</ul>
</li>
<li>The emulated system is configurable through a yaml file. See example below.</li>
<li>Despite all the things we are doing, the emulator is reasonably fast. On my
laptop, the emulator is able to run on at around 50Mhz. That&#39;s 1/3 of the real
speed. That&#39;s much faster than the other emulators which are at least 10x
slower, if not more.</li>
</ul>
<h2 dir="auto"><a id="user-content-existing-work" aria-hidden="true" href="#existing-work"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Existing work</h2>
<p dir="auto">There&#39;s some existing work in the STM32 emulation space:</p>
<ul dir="auto">
<li><a href="https://qiling.io/2022/04/14/intro/" rel="nofollow">Qiling</a> emulates all kinds of devices,
including STM32s. It would be a good candidate, but wasn&#39;t fitting the bill
because 1) it&#39;s written in Python, and is very slow. 2) It doesn&#39;t support
what I really want which is tracing in registers that I care about.</li>
<li><a href="https://renode.io/" rel="nofollow">Renode</a>: Emulate all sorts of devices, written in C#.
The configuration files are finicky, and it&#39;s overall pretty slow. I didn&#39;t
like it.</li>
<li><a href="https://github.com/tinylabs/flexsoc_cm3">Tinylabs&#39; flexsoc-cm3</a>: This is
Elliot&#39;s project to have the real stm32 peripherals to be accessible directly
to a host that is emulating a CPU. I haven&#39;t tried it, but it looks promising.</li>
<li>Use GDB and single step everything. That might be too slow.</li>
</ul>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">The code is released under the GPLv3</p>
</article>
          </div></div>
  </body>
</html>
