<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/sqlite-virtual-machine/">Original</a>
    <h1>How the SQLite Virtual Machine Works</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://avatars.githubusercontent.com/u/118015" alt="Ben Johnson" srcset=""/> <dl> <dt>Name</dt> <dd> Ben Johnson </dd> <dt>Twitter</dt> <dd> <a href="https://twitter.com/benbjohnson" target="_blank"> @benbjohnson </a> </dd> </dl> </dd> </dl> <section> <img src="https://blog.rowan.earth/blog/2022-09-07/cover.jpg" alt="A robot furiously making sandwiches."/> <p><a href="http://fly.io/">Fly.io</a> runs apps close to users around the world, by taking containers and upgrading them to full-fledged virtual machines running on our own hardware around the world. Sometimes those containers run SQLite and we make that easy too. <a href="https://fly.io/docs/speedrun/">Give us a whirl</a> and get up and running quickly.</p><p>SQL is a weird concept. You write your application in one language, say JavaScript, and then send commands in a completely different language, called SQL, to the database. The database then compiles and optimizes that SQL command, runs it, and returns your data. It seems terribly inefficient and, yet, your application might do this hundreds of times per second. It&#39;s madness!</p> <p>But it gets weirder.</p> <p>SQL was <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6359709">originally designed for non-technical users</a> to interact with the database, however, it&#39;s used almost exclusively by software developers peppering it throughout their applications.</p> <p>Why would this language made for &#34;business folks&#34; become the industry standard for how applications are built?</p> <p>One of the key benefits of SQL is that it is declarative. That means you tell the database what you want but not how to do it. Your database knows <em>WAY</em> more about your data than you do so it should be able to make better decisions about how to fetch it and update it. This lets you improve your data layer by adding indexes or even restructuring tables with minimal effects on your application code.</p> <p>SQLite is unique among embedded databases in that it not only has a transactional, b-tree storage layer but it also includes a robust SQL execution engine. Today, we&#39;re diving into how SQLite parses, optimizes, &amp; executes your SQL queries.</p> <h2 id="a-sandwich-making-machine"><a href="#a-sandwich-making-machine" aria-label="Anchor"></a>A Sandwich-making Machine</h2><p>If you&#39;ve read our previous sandwich-themed SQLite blog posts on the <a href="https://blog.rowan.earth/blog/sqlite-internals-btree/">SQLite file format</a>, the <a href="https://blog.rowan.earth/blog/sqlite-internals-rollback-journal/">rollback journal</a>, &amp; the <a href="https://blog.rowan.earth/blog/sqlite-internals-wal/">WAL</a>, then you&#39;re probably feeling pretty hungry by now. You&#39;re also probably tired of the tedium of making sandwiches by hand, so we&#39;ll use a sandwich-making machine as our analogy in this blog post.</p> <p>This machine will do a few tasks:</p> <ol> <li>Take an order for sandwiches. </li><li>Determine the most efficient way to build the sandwiches. </li><li>Build the sandwiches and hand them to you. </li></ol> <p>The process for building and executing SQL queries is similar to this sandwich-building process, albeit less delicious. Let&#39;s dive in.</p> <h2 id="teaching-our-machine-to-read"><a href="#teaching-our-machine-to-read" aria-label="Anchor"></a>Teaching Our Machine to Read</h2><p>The first step is to give our machine an order. We hand it an order slip that says:</p> <div><pre><code>Make 3 BLT sandwiches hold the mayo, 1 grilled cheese
</code></pre></div><p>To our computer, this order is just a string of individual characters: <code>M</code>, <code>a</code>, <code>k</code>, <code>e</code>, etc… If we want to make sense of it, we first need to group these letters together into words, or more specifically, &#34;tokens&#34;. This process is called &#34;tokenizing&#34; or &#34;lexing&#34;.</p> <p>After tokenizing, we see this list of tokens:</p> <div><pre><code>&#34;MAKE&#34;, &#34;3&#34;, &#34;BLT&#34;, &#34;SANDWICHES&#34;, &#34;HOLD&#34;, &#34;THE&#34;, &#34;MAYO&#34;, &#34;,&#34;, &#34;1&#34;, &#34;GRILLED&#34;, &#34;CHEESE&#34;
</code></pre></div><p>From there, we start the parsing stage. The parser takes in a stream of tokens and tries to structure it some way that makes sense to a computer. This structure is called an <em>Abstract Syntax Tree,</em> or <em>AST.</em></p> <p>This AST for our sandwich command might look like this:</p> <div><pre><code>{
  &#34;command&#34;: &#34;MAKE&#34;,
  &#34;sandwiches&#34;: [
    {
      &#34;type&#34;:&#34;BLT&#34;,
      &#34;count&#34;: 3,
      &#34;remove&#34;: [&#34;MAYO&#34;]
    },
    {
      &#34;type&#34;: &#34;GRILLED CHEESE&#34;,
      &#34;count&#34;: 1
    }
  ]
}
</code></pre></div><p>From here, we can start to see how we might take this definition and begin building sandwiches from it. We&#39;ve added structure to an otherwise structure-less blob of text.</p> <h3 id="lexing-parsing-sql"><a href="#lexing-parsing-sql" aria-label="Anchor"></a>Lexing &amp; Parsing SQL</h3><p>SQLite does this same process when it reads in SQL queries. First, it groups characters together into tokens such as <code>SELECT</code> or <code>FROM</code>. Then the parser builds a structure to represent it.</p> <p>The SQLite documentation provides helpful &#34;railroad diagrams&#34; to represent the paths the parser can take when consuming the stream of tokens. The <a href="https://www.sqlite.org/lang_select.html">SELECT definition</a> shows how it can start with the <code>WITH</code> keyword (for <a href="https://www.sqlite.org/lang_with.html">CTEs</a>) and then move into the <code>SELECT</code>, <code>FROM</code>, and <code>WHERE</code> clauses.</p> <p><img src="https://slabstatic.com/prod/uploads/p1b436gf/posts/images/t7Xvs_UNlDc_GnlwSjc6PuWe.png" alt=""/></p> <p>When the parser is done, it outputs the aptly named <code>Select struct</code>. If you had a SQL query like this:</p> <div><pre><code>SELECT name, age FROM persons WHERE favorite_color = &#39;lime green&#39;
</code></pre></div><p>Then you&#39;ll end up with an AST that looks something like this:</p> <div><pre><code>{
  &#34;ExprList&#34;: [&#34;name&#34;, &#34;age&#34;],
  &#34;Src&#34;: &#34;persons&#34;,
  &#34;Where&#34;: {
    &#34;Left&#34;: &#34;favorite_color&#34;,
    &#34;Right: &#34;lime_green&#34;,
    &#34;Op&#34;: &#34;eq&#34;
  }
}
</code></pre></div><h2 id="determining-the-best-course-of-action"><a href="#determining-the-best-course-of-action" aria-label="Anchor"></a>Determining the Best Course of Action</h2><p>So now that we have our sandwich order AST, we have a plan to make our sandwich, right? Not quite.</p> <p>The AST represents what you want—which is a couple of sandwiches. It doesn&#39;t tell us how to make the sandwiches. Before we get to the plan, though, we need to determine the optimal way to make the sandwiches.</p> <p>Our sandwich-making machine can assemble a plethora of different sandwiches, so we stock all kinds of ingredients. If we were making a monster sandwich loaded with most of our available toppings it might make sense for the machine to visit each ingredient’s location, using it, or not, according to the AST.</p> <p>But for our BLT, we need only bacon, lettuce &amp; tomato. It’ll be way faster if we can have the machine look up the locations of just these three toppings in an index and jump directly between them.</p> <p>SQLite has a similar decision to make when planning how to execute a query. For this, it uses statistics about its tables&#39; contents.</p> <h3 id="using-statistics-for-faster-queries"><a href="#using-statistics-for-faster-queries" aria-label="Anchor"></a>Using Statistics for Faster Queries</h3><p>When SQLite looks at an AST, there could be hundreds of ways to access the data to fulfill a query. The naive approach would be to simply read through the whole table and check every row to see if it matches. This what we in the biz call a <em>full table scan</em> and it is painfully slow if you only need a few rows from a large table.</p> <p>Another option would be to use an index to help you quickly jump to the rows you need. An index is a list of row identifiers that are sorted by one or more columns, so if we have an index like this:</p> <div><pre><code>CREATE INDEX favorite_color_idx ON persons (favorite_color);
</code></pre></div><p>Then all the row identifiers for people who love &#34;mauve&#34; are all grouped together in our index. Using the index for our query means we have to first read from the index and then jump to a row in the table. This has a higher cost per row as it requires two lookups, however almost no one likes mauve so we don&#39;t have too many matching rows.</p> <p>But what happens if you search for a popular color like &#34;blue&#34;? Searching the index first and then jumping to our table for so many rows would actually be slower than if we simply searched the entire table.</p> <p>So SQLite does some statistical analysis on our data and uses this information to choose the (probably) optimal recipe for each query.</p> <p>SQLite&#39;s statistics are stored in several &#34;sqlite_stat&#34; tables. These tables have evolved over the years so there&#39;re 4 different versions of stats but only two are still in use with recent versions of SQLite: <code>sqlite_stat1</code> &amp; <code>sqlite_stat4</code>.</p> <p>The <code>sqlite_stat1</code> table has a simple format. It stores the approximate number of rows for each index and it stores the number of duplicate values for the columns of the index. These coarse-grained stats are the equivalent of tracking basic averages for a data set—they&#39;re not super accurate but they&#39;re quick to calculate and update.</p> <p>The <code>sqlite_stat4</code> table is a bit more advanced. It will store a few dozen samples of values that are spread across an index. These finer-grained samples mean that SQLite can understand how unique different values are across the key space.</p> <h2 id="executing-on-our-plan"><a href="#executing-on-our-plan" aria-label="Anchor"></a>Executing on Our Plan</h2><p>Once we have an optimized plan for building a sandwich, we should have our machine write it down. That way if we get the same order again in the future, we can simply reuse the plan rather than having to parse &amp; optimize the order each time.</p> <p>So what does this sandwich plan look like?</p> <p>The plan will be recorded as a list of commands that the machine can execute to build the BLT again in the future. We don&#39;t want a command for each type of sandwich, as we may have a lot of different types. Better to have a set of common instructions that can be reused to compose any sandwich plan.</p> <p>For example, we might have the following commands:</p> <ul> <li><code>FIND_INGREDIENT_BIN(ingredient_name)</code> - looks up the bin position of an ingredient. </li><li><code>FETCH_INGREDIENT(bin)</code> - this grabs an ingredient with the machine&#39;s robot arm from the given ingredient bin number. </li><li><code>APPLY_INGREDIENT</code> - this puts the ingredient from the robot arm onto the sandwich. </li><li><code>GRILL</code> - this grills the current sandwich. </li></ul> <p>We also have one more requirement that&#39;s not immediately obvious. We only have so much space to hold our finished sandwiches so we need to make one sandwich at a time and have the customer take it before making the next sandwich. That way we can handle any number of sandwiches in an order.</p> <p>This process of handing off is called <em>yielding</em> so we&#39;ll have a <code>YIELD</code> command when where we wait for the customer to take the sandwich.</p> <p>We&#39;ll also need some control flow so we can make multiple of the same kind of sandwich so we&#39;ll add a <code>FOREACH</code> command.</p> <p>So putting our commands together, our plan might look like:</p> <div><pre><code>// Make our BLT sandwiches
FOREACH 1...3
  bin = FETCH_INGREDIENT_BIN(&#34;bacon&#34;)
  FETCH_INGREDIENT(bin)
  APPLY_INGREDIENT

  bin = FETCH_INGREDIENT_BIN(&#34;lettuce&#34;)
  FETCH_INGREDIENT(bin)
  APPLY_INGREDIENT

  bin = FETCH_INGREDIENT_BIN(&#34;tomato&#34;)
  FETCH_INGREDIENT(bin)
  APPLY_INGREDIENT

  YIELD
END

// Make our grilled cheese
bin = FETCH_INGREDIENT_BIN(&#34;cheese&#34;)
FETCH_INGREDIENT(bin)
APPLY_INGREDIENT
GRILL
YIELD
</code></pre></div><p>This set of domain-specific commands and the execution engine to run it is called a <em>virtual machine.</em> It gives us a level of abstraction that&#39;s appropriate for the task we&#39;re trying to complete (e.g. sandwich making) and it lets us reconfigure commands in different ways for different sandwiches.</p> <h3 id="inspecting-the-sqlite-virtual-machine"><a href="#inspecting-the-sqlite-virtual-machine" aria-label="Anchor"></a>Inspecting the SQLite Virtual Machine</h3><p>SQLite&#39;s virtual machine is structured similarly. It has a set of database-related commands that can execute the steps needed to fetch the results of a query.</p> <p>For example, let&#39;s start with a table of people with a few rows added:</p> <div><pre><code>CREATE TABLE persons (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT,
  favorite_color TEXT
);

INSERT INTO persons
  (name, favorite_color)
VALUES
  (&#39;Vicki&#39;, &#39;black&#39;),
  (&#39;Luther&#39;, &#39;mauve&#39;),
  (&#39;Loren&#39;, &#39;blue&#39;);
</code></pre></div><p>We can inspect this with two different SQLite commands. The first command is called <code>EXPLAIN QUERY PLAN</code> and it gives a very high level plan of the query. If we run it for a simple <code>SELECT</code> with a conditional then we&#39;ll see that it performs a table scan of the <code>persons</code> table:</p> <div><pre><code>sqlite&gt; EXPLAIN QUERY PLAN SELECT * FROM persons WHERE favorite_color = &#39;blue&#39;;

QUERY PLAN
`--SCAN persons
</code></pre></div><p>This command can give more information as you do more complex queries. Now let&#39;s look at the other command to further inspect the plan.</p> <p>Confusingly, it&#39;s called the <code>EXPLAIN</code> command. Simply drop the &#34;<code>QUERY PLAN</code>&#34; part of the first command and it will show a much more detailed plan:</p> <div> <div><pre><code>sqlite&gt; EXPLAIN SELECT * FROM persons WHERE favorite_color = &#39;blue&#39;;

addr  opcode         p1    p2    p3    p4             p5  comment      
----  -------------  ----  ----  ----  -------------  --  -------------
0     Init           0     11    0                    0   Start at 11
1     OpenRead       0     2     0     3              0   root=2 iDb=0; persons
2     Rewind         0     10    0                    0   
3       Column       0     2     1                    0   r[1]=persons.favorite_color
4       Ne           2     9     1     BINARY-8       82  if r[1]!=r[2] goto 9
5       Rowid        0     3     0                    0   r[3]=rowid
6       Column       0     1     4                    0   r[4]=persons.name
7       Column       0     2     5                    0   r[5]=persons.favorite_color
8       ResultRow    3     3     0                    0   output=r[3..5]
9     Next           0     3     0                    1   
10    Halt           0     0     0                    0   
11    Transaction    0     0     1     0              1   usesStmtJournal=0
12    String8        0     2     0     blue           0   r[2]=&#39;blue&#39;
13    Goto           0     1     0                    0   
</code></pre></div></div><p>This is the &#34;plain English&#34; representation of the byte code that your query is compiled down to. This may look confusing but we can walk through it step-by-step to break it down.</p> <h3 id="the-sqlite-virtual-machine-instruction-set"><a href="#the-sqlite-virtual-machine-instruction-set" aria-label="Anchor"></a>The SQLite Virtual Machine Instruction Set</h3><p>Just like how a computer has low-level CPU operations such <code>MOV</code> and <code>JMP</code>, SQLite has a similar instruction set but it&#39;s just at a higher level. As of this writing, there are 186 commands, or <em>opcodes</em>, that the SQLite VM can understand. You can find the <a href="https://sqlite.org/opcode.html#the_opcodes">full specification</a> on the SQLite web site but we&#39;ll walk through a couple of them here.</p> <p>The first opcode is an <a href="https://sqlite.org/opcode.html#Init">Init</a> which initializes our execution and then jumps to another instruction in our program. The parameters for the opcodes are listed as <code>p1</code> through <code>p5</code> and their definition is specific to each command. For the <code>Init</code> opcode, it jumps to the instruction listed in <code>p2</code> which is <code>11</code>.</p> <p>At address <code>11</code> we arrive at the <a href="https://sqlite.org/opcode.html#Transaction">Transaction</a> opcode which starts our transaction. For most opcodes, the VM will move to the next address after executing the instruction so we move to address <code>12</code>. This <a href="https://sqlite.org/opcode.html#String8">String8</a> opcode stores string value <code>&#34;blue&#34;</code> into register <code>r[2]</code>. The registers act like a set of memory addresses and are used to store values during execution. We&#39;ll use this value later for our equality comparison.</p> <p>Next, we move to address <code>13</code> which is a <a href="https://sqlite.org/opcode.html#Goto">Goto</a> instruction which has us jump to the instruction listed in its <code>p2</code> parameter, which is address <code>1</code>.</p> <p>Now we get into the row processing. The <a href="https://sqlite.org/opcode.html#OpenRead">OpenRead</a> instruction opens a <em>cursor</em> on the <code>persons</code> table. A cursor is an object for iterating over or moving around in a table. The next instruction, <a href="https://sqlite.org/opcode.html#Rewind">Rewind</a>, moves the cursor to the first entry of the database to begin our table scan.</p> <p>The <a href="https://sqlite.org/opcode.html#Column">Column</a> instruction reads the <code>favorite_color</code> column into register <code>r[1]</code> and the <a href="https://sqlite.org/opcode.html#Ne">Ne</a> instruction compares it with the <code>&#34;blue&#34;</code> value in register <code>r[2]</code>. If the values don&#39;t match then we&#39;ll move to the <a href="https://sqlite.org/opcode.html#Next">Next</a> instruction at address <code>9</code>. If they do match, we&#39;ll fill in registers <code>r[3]</code> , <code>r[4]</code>, &amp; <code>r[5]</code> with the column <code>id</code>, <code>name</code>, &amp; <code>favorite_color</code> for the row.</p> <p>Finally, we get to where we can yield the result back to the caller using the <a href="https://sqlite.org/opcode.html#ResultRow">ResultRow</a> instruction. This will let the calling application copy out the values in registers <code>r[3…5]</code>. When the calling application calls <code>sqlite3_step()</code>, the program will resume from where it left off by calling <a href="https://sqlite.org/opcode.html#Next">Next</a> and jumping back to re-execute the row processing at instruction <code>3</code>.</p> <p>When Next no longer produces any more rows, it&#39;ll jump to the <a href="https://sqlite.org/opcode.html#Halt">Halt</a> instruction and the program is done.</p> <h2 id="wrapping-up-our-sandwich-processing-engine"><a href="#wrapping-up-our-sandwich-processing-engine" aria-label="Anchor"></a>Wrapping Up Our Sandwich Processing Engine</h2><p>The query execution side of SQLite follows this simple parse-optimize-execute plan on every query that comes into the database. We can use this knowledge to improve our application performance. By using bind parameters in SQL statements (aka those <code>?</code> placeholders), we can prepare a statement once and skip the parse &amp; optimize phases every time we reuse it.</p> <p>SQLite uses a virtual machine approach to its query execution but that&#39;s not the only approach available. Postgres, for example, uses a node-based execution plan which is structured quite differently.</p> <p>Now that you understand the basics of how an execution plan works, try running <code>EXPLAIN</code> on one of your more complex queries and see if you can understand the step-by-step execution of how your query materializes into a result set for your application.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://blog.rowan.earth/blog/sqlite-internals-wal/"> How SQLite Scales Read Concurrency </a> </dd> </dl> </article></div>
  </body>
</html>
