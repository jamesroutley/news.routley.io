<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danlark.org/2023/06/06/csinc-the-arm-instruction-you-didnt-know-you-wanted/">Original</a>
    <h1>“csinc”, the AArch64 instruction you didn’t know you wanted</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

	<section id="primary">
		<main id="main">

			
<article id="post-1071">

	

	
	<div>
		
<p>After a long time of not publishing anything and being passive about doing any writing in this blog, I am coming back for … however many articles I can. Today I want to talk about an underrated feature of AArch64 ISA which is often overlooked but used by compilers a lot. It’s just a good and short story on what made Arm even better and more “CISCy” when it comes down to conditional moves. The story of <code>csinc</code> deserves an article like this.</p>



<h2>You probably heard of cmov</h2>



<p>Traditionally, when you encounter conditional moves in literature, it is about x86 instruction <code>cmov</code>. It’s a nice feature and allows to accomplish better performance in low level optimization. Say, if you merge 2 arrays, you can compare numbers and choose the one depending on the value of compare instructions (more precisely, flags):</p>


<div><pre title="">while ((pos1 &lt; size1) &amp; (pos2 &lt; size2)) {
    v1 = input1[pos1];
    v2 = input2[pos2];
    output_buffer[pos++] = (v1 &lt;= v2) ? v1 : v2;
    pos1 = (v1 &lt;= v2) ? pos1 + 1 : pos1;
    pos2 = (v1 &gt;= v2) ? pos2 + 1 : pos2;
}
</pre></div>


<figure><img data-attachment-id="1076" data-permalink="https://danlark.org/2023/06/06/csinc-the-arm-instruction-you-didnt-know-you-wanted/image-26/" data-orig-file="https://danlarkorg.files.wordpress.com/2023/06/image.png" data-orig-size="1162,566" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2023/06/image.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2023/06/image.png?w=750" src="https://danlarkorg.files.wordpress.com/2023/06/image.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2023/06/image.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2023/06/image.png?w=150 150w, https://danlarkorg.files.wordpress.com/2023/06/image.png?w=300 300w, https://danlarkorg.files.wordpress.com/2023/06/image.png?w=768 768w, https://danlarkorg.files.wordpress.com/2023/06/image.png 1162w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>


<div><pre title="">cmpl %r14d, %ebp   # compare which one is smaller, set CF
setbe %bl          # set CF to %bl if it&#39;s smaller
cmovbl %ebp, %r14d # move ebp into r14d if flag CF was set
</pre></div>


<p>If branches are unpredictable, for instance, you merge 2 arrays of random integers, conditional move instructions bring significant speed-ups against branchy version because of removing the branch misprediction penalty. A lot was written about this in <a href="https://lemire.me/blog/2021/07/14/faster-sorted-array-unions-by-reducing-branches/">the Lemire’s blog</a>. Much engineering has been done on this including <a href="https://www.agner.org/optimize/instruction_tables.pdf">Agner Fog</a>, <a href="https://discourse.llvm.org/t/rfc-cmov-vs-branch-optimization/6040">cmov vs branch profile guided optimizations</a>. Conditional move instructions are a huge domain of modern software, pretty much anything you run likely have them.</p>



<h2>What about Arm?</h2>



<p>AArch64 is no exception in this area and has some conditional move instructions as well. The immediate equivalent, if you Google it, is <code>csel</code> which is translated like <code>conditional select</code>. There is almost no difference to <code>cmov</code> except you <a href="https://developer.arm.com/documentation/dui0802/b/CSEL">specify directly</a> which condition you want to check and destination register (in cmov the destination is unchanged if condition is not met). To my eye it is a bit more intuitive to read:</p>





<p>When I was studying the structure of this instruction in the optimization guide, I noticed the family included different variations:</p>



<figure><img data-attachment-id="1078" data-permalink="https://danlark.org/2023/06/06/csinc-the-arm-instruction-you-didnt-know-you-wanted/2023-06-06-211325_1054x155_scrot/" data-orig-file="https://danlarkorg.files.wordpress.com/2023/06/2023-06-06-211325_1054x155_scrot.png" data-orig-size="1054,155" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="2023-06-06-211325_1054x155_scrot" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2023/06/2023-06-06-211325_1054x155_scrot.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2023/06/2023-06-06-211325_1054x155_scrot.png?w=750" src="https://danlarkorg.files.wordpress.com/2023/06/2023-06-06-211325_1054x155_scrot.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2023/06/2023-06-06-211325_1054x155_scrot.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2023/06/2023-06-06-211325_1054x155_scrot.png?w=150 150w, https://danlarkorg.files.wordpress.com/2023/06/2023-06-06-211325_1054x155_scrot.png?w=300 300w, https://danlarkorg.files.wordpress.com/2023/06/2023-06-06-211325_1054x155_scrot.png?w=768 768w, https://danlarkorg.files.wordpress.com/2023/06/2023-06-06-211325_1054x155_scrot.png 1054w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>I was intrigued by the existence of some other forms as this involves more opportunities for the compilers and engineers to write software. For example, <code>csinc Xd, Xa, Xb, cond</code> (conditional select <em>increase</em>) means that if the condition holds, <code>Xd = Xb + 1</code>, otherwise <code>Xd = Xa</code>. For example, in merging 2 arrays, the line:</p>



<pre><code>pos1 = (v1 &lt;= v2) ? pos1 + 1 : pos1;</code></pre>



<p>can be compiled into:</p>



<pre><code>csinc X0, X0, X0, #condition_of_v1_less_equal_v2</code></pre>



<p>where <code>X0</code> is a register for <code>pos1</code>.</p>



<p><code>csneg</code>, <code>csinv</code> are similar and represent conditional negations and inversions.</p>



<p>For example, clang recognizes this sequence, whereas GCC does not.</p>



<figure><img data-attachment-id="1081" data-permalink="https://danlark.org/2023/06/06/csinc-the-arm-instruction-you-didnt-know-you-wanted/image-1-2/" data-orig-file="https://danlarkorg.files.wordpress.com/2023/06/image-1.png" data-orig-size="1134,849" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-1" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2023/06/image-1.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2023/06/image-1.png?w=750" src="https://danlarkorg.files.wordpress.com/2023/06/image-1.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2023/06/image-1.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2023/06/image-1.png?w=150 150w, https://danlarkorg.files.wordpress.com/2023/06/image-1.png?w=300 300w, https://danlarkorg.files.wordpress.com/2023/06/image-1.png?w=768 768w, https://danlarkorg.files.wordpress.com/2023/06/image-1.png 1134w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a href="https://godbolt.org/z/5cKG3vvKT" rel="nofollow">https://godbolt.org/z/5cKG3vvKT</a></figcaption></figure>



<h2>Where can this be useful otherwise?</h2>



<p>Interestingly enough, in compression! You might heard of <a href="https://github.com/google/snappy">Snappy</a>, the old Google compression library which was surpassed by <a href="https://github.com/lz4/lz4">LZ4</a> many times. For x86, the difference in speed – even for the latest version of clang – is quite big. For example, on my server Intel Xeon 2.00GHz I have <strong>2721MB/s</strong> of decompression for LZ4 and <strong>2172MB/s</strong> for Snappy which is a <strong>25% gap.</strong></p>



<p>For Snappy to reach that level of decompression, engineers needed to write very subtle code to <a href="https://github.com/google/snappy/blob/c9f9edf6d75bb065fa47468bf035e051a57bec7c/snappy.cc#L1140">achieve <code>cmov</code> code generation</a>:</p>



<figure><div>
<div id="gist122839866">
    <div translate="no">
      <div>
        <div>
  <div id="file-x86_snappy_cmov-cc">
    
    <div itemprop="text">

        
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path>
</svg>
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path>
</svg>
</span></template>

  
</div>


    </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>For Arm, <code>csinc</code> instruction was used because of the nature of the format:</p>



<figure><img data-attachment-id="1086" data-permalink="https://danlark.org/2023/06/06/csinc-the-arm-instruction-you-didnt-know-you-wanted/image-2-2/" data-orig-file="https://danlarkorg.files.wordpress.com/2023/06/image-2.png" data-orig-size="1215,163" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-2" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2023/06/image-2.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2023/06/image-2.png?w=750" src="https://danlarkorg.files.wordpress.com/2023/06/image-2.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2023/06/image-2.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2023/06/image-2.png?w=150 150w, https://danlarkorg.files.wordpress.com/2023/06/image-2.png?w=300 300w, https://danlarkorg.files.wordpress.com/2023/06/image-2.png?w=768 768w, https://danlarkorg.files.wordpress.com/2023/06/image-2.png 1215w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Shortly, last 2 bits of the byte that opens the block have the instruction on what to do and which memory to copy: <code>00</code> copies <code>len-1</code> data. With careful optimization of conditional moves, we can save on adding this +1 back through <code>csinc</code>:</p>



<figure><img loading="lazy" data-attachment-id="1087" data-permalink="https://danlark.org/2023/06/06/csinc-the-arm-instruction-you-didnt-know-you-wanted/image-3-2/" data-orig-file="https://danlarkorg.files.wordpress.com/2023/06/image-3.png" data-orig-size="1138,486" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-3" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2023/06/image-3.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2023/06/image-3.png?w=750" src="https://danlarkorg.files.wordpress.com/2023/06/image-3.png?w=1024" alt="" width="780" height="332" srcset="https://danlarkorg.files.wordpress.com/2023/06/image-3.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2023/06/image-3.png?w=777 777w, https://danlarkorg.files.wordpress.com/2023/06/image-3.png?w=150 150w, https://danlarkorg.files.wordpress.com/2023/06/image-3.png?w=300 300w, https://danlarkorg.files.wordpress.com/2023/06/image-3.png?w=768 768w, https://danlarkorg.files.wordpress.com/2023/06/image-3.png 1138w" sizes="(max-width: 780px) 100vw, 780px"/><figcaption><a href="https://gcc.godbolt.org/z/oPErYhz9b" rel="nofollow">https://gcc.godbolt.org/z/oPErYhz9b</a></figcaption></figure>



<p>On Google T2A instances I got <strong>3048MB/s</strong> decompression for LZ4 and <strong>2839MB/s</strong> which is <strong>only a 7% gap.</strong> If I enable <a href="https://github.com/lz4/lz4/blob/e82198428c8061372d5adef1f9bfff4203f6081e/lib/lz4.c#L471">LZ4_FAST_DEC_LOOP</a>, I have <strong>3233MB/s</strong> which still makes a <strong>13% gap</strong> but not 25% as per x86 execution.</p>



<p>In conclusion, conditional select instructions for Arm deserve attention and awareness:</p>



<ol>
<li><code>csel</code>, <code>csinc</code> and others have same latency and throughput, meaning, they are as cheap as usual <code>csel</code> for almost all modern Arm processors including <a href="https://dougallj.github.io/applecpu/firestorm.html">Apple M1, M2</a>.</li>



<li>Compilers do recognize them (in my experience, clang did better than GCC, see above), no need to do anything special, just be aware that some formats might work better for Arm than for x86.</li>
</ol>



<p>To sum up, contrary to the belief of CISC vs RISC debate about x86 and Arm ISA, the latter has surprising features of conditional instructions which are more flexible than the traditionally discussed ones.</p>



<p>You can read more about this topic in <a href="https://eclecticlight.co/2021/07/20/code-in-arm-assembly-conditions-without-branches/">other blogs</a>, in <a href="https://developer.arm.com/documentation/dui0802/b/A64-General-Instructions/CSINC">Arm reference guide</a>, <a href="https://devblogs.microsoft.com/oldnewthing/20220817-00/?p=106998">Microsoft blog of AArch64 conditional execution</a>.</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->

				
</article><!-- #post-${ID} -->

	<nav aria-label="Posts">
		<h2>Post navigation</h2>
		
	</nav>
<!-- #comments -->

		</main><!-- #main -->
	</section><!-- #primary -->


	</div></div>
  </body>
</html>
