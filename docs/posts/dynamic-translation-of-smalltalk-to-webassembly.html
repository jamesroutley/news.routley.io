<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thiscontext.com/2023/07/26/dynamic-translation-of-smalltalk-to-webassembly/">Original</a>
    <h1>Dynamic Translation of Smalltalk to WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div>
				<div>
<figure><a href="https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg"><img data-attachment-id="2438" data-permalink="https://thiscontext.com/2023/07/26/dynamic-translation-of-smalltalk-to-webassembly/r647yxe-scientific-dna-wallpapers-2015/" data-orig-file="https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg" data-orig-size="1920,1080" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="r647yxe-scientific-dna-wallpapers-2015" data-image-description="" data-image-caption="" data-medium-file="https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg?w=300" data-large-file="https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg?w=450" tabindex="0" role="button" src="https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg?w=1024" alt="" width="669" height="376" srcset="https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg?w=1024 1024w, https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg?w=669 669w, https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg?w=1338 1338w, https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg?w=150 150w, https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg?w=300 300w, https://thiscontext.com/wp-content/uploads/2023/07/r647yxe-scientific-dna-wallpapers-2015.jpg?w=768 768w" sizes="(max-width: 669px) 100vw, 669px"/></a><figcaption><em>continuing with the DNA theme…</em></figcaption></figure></div>


<p>In <a href="https://thiscontext.com/2023/05/08/catalyst-a-webassembly-enabled-version-of-squeakjs/">Catalyst</a>, a <a href="https://www.wikiwand.com/en/Webassembly">WebAssembly</a> implementation of the <a href="https://github.com/OpenSmalltalk/opensmalltalk-vm">OpenSmalltalk</a> virtual machine, there are three linguistic levels in play: <a href="https://www.wikiwand.com/en/Smalltalk">Smalltalk</a>, <a href="https://www.wikiwand.com/en/JavaScript">JavaScript</a> (JS), and WebAssembly (WASM). Smalltalk is our primary language, JS is the coordinating language of the hosting environment (a web browser), and WASM is a high-performance runtime instruction set to which we can compile any other language. In a previous article, I wrote about <a href="https://thiscontext.com/2023/07/06/automated-translation-of-javascript-to-webassembly-for-squeakjs/">automatic translation of JS to WASM</a>, as a temporary way of translating the <a href="https://squeak.js.org/">SqueakJS</a> virtual machine to WASM. That benefits from a proven JS starting point for the relatively large codebase of the virtual machine. When translating individual Smalltalk compiled methods for “just-in-time” optimization, however, it makes more sense to translate from Smalltalk to WASM directly.</p>



<h2>compiled method transcription</h2>



<p>We already have infrastructure for transcribing Smalltalk compiled methods, via class InstructionStream. We use it to print human-readable descriptions of method instructions, and to simulate their execution in the Smalltalk debugger. We can also use it to translate a method to human-readable <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format">WebAssembly Text</a> (WAT) source code, suitable for translation to binary WASM code which the web browser can execute. Since the Smalltalk and WASM instruction sets are both stack-oriented, the task is straightforward.</p>



<p>I’ve created a subclass of InstructionStream, called WATCompiledMethodTranslator, which uses the classic scanner pattern to drive translation from Smalltalk instructions to WASM instructions. With accompanying WASM type information for Smalltalk virtual machine structures, we can make WASM modules that execute the instructions for individual Smalltalk methods.</p>



<h2>the “hello world” of Smalltalk: 3 + 4</h2>



<p>As an example, let’s take a look at translating the traditional first Smalltalk expression, 3 + 4. We’ll create a Smalltalk method in class HelloWASM from this source:</p>


<div><pre title="">HelloWASM&gt;&gt;add
	&#34;Add two numbers.&#34;

	^3 + 4
</pre></div>


<p>This gives us a compiled method with the following Smalltalk instructions. On each line below, we list the program counter value, the instruction, and a description of the instruction.</p>


<div><pre title="">0: 0x20: push the literal constant at index 0 (3) onto the method&#39;s stack
1: 0x21: push the literal constant at index 1 (4) onto the method&#39;s stack
2: 0xB0: send the arithmetic message at index 0 (+)
3: 0x7C: return the top of the method&#39;s stack
</pre></div>


<p>A WATCompiledMethodTranslator uses an instance of InstructionStream as a scanner of the method, interpreting each Smalltalk instruction in turn. When interpreting an instruction, the scanner sends a corresponding message to the translator, which in turn writes a transcription of that instruction as WASM instructions, onto a stream of WAT source.</p>



<p>The first instruction in the method is “push the literal constant at index 0”. The scanner finds the indicated literal in the literal frame of the method (i.e., 3), and sends <strong>pushConstant: 3</strong> to the translator. Here are the methods that the translator runs in response:</p>


<div><pre title="">WATCompiledMethodTranslator&gt;&gt;pushConstant: value
	&#34;Push value, a constant, onto the method&#39;s stack.&#34;

	self
		comment: &#39;push constant &#39;, value printString;
		pushFrom: [value printWATFor: self]
</pre></div>

<div><pre title="">WATCompiledMethodTranslator&gt;&gt;pushFrom: closure
     &#34;Evaluate closure, which emits WASM instructions that push a value onto the WASM stack. Emit further WASM instructions that push that value onto the Smalltalk stack.&#34;

	self
		setElementAtIndexFrom: [
			self
				incrementField: #sp
				ofStructType: #vm
				named: #vm;
				getField: #sp
				ofStructType: #vm
				named: #vm]
		ofArrayType: #pointers
		named: #stack
		from: closure
</pre></div>

<div><pre title="">WATCompiledMethodTranslator&gt;&gt;setElementAtIndexFrom: elementIndexClosure ofArrayType: arrayTypeName named: arrayName from: elementValueClosure
	&#34;Evaluate elementIndexClosure to emit WASM instructions that leave an array index on the WASM stack. Evaluate elementValueClosure to emit WASM instructions that leave an array element value on the WASM stack. Emit further WASM instructions, setting the element with that index in an array of the given type and variable name to the value.&#34;

	self get: arrayName.
	{elementIndexClosure. elementValueClosure} do: [:each | each value].

	self
		indent;
		nextPutAll: &#39;array.set $&#39;;
		nextPutAll: arrayTypeName
</pre></div>


<p>In the final method above, we finally see a WASM instruction, <strong>array.set</strong>. The translator implements stream protocol for actually writing WAT text to a stream. The <strong>comment:</strong>, <strong>get:</strong>, and <strong>getField:ofStructType:named:</strong> methods are similar, using “;;” and the <strong>array.get</strong> and <strong>struct.get</strong> WASM instructions. The array and struct instructions are part of the <a href="https://github.com/WebAssembly/gc/blob/master/proposals/gc/MVP.md">WASM garbage collection extension</a>, which introduces types.</p>



<h2>WASM types for virtual machine structures</h2>



<p>To actually use WASM instructions that make use of types, we need to define the types in our method’s WASM module. In <strong>pushFrom:</strong> above, we use a struct variable of type <strong>vm</strong> named <strong>vm</strong>, and an array variable of type <strong>pointers</strong> named <strong>stack</strong>. The <strong>vm</strong> variable holds global virtual machine state (for example, the currently executing method’s stack pointer), similar to the <strong>SqueakJS.vm</strong> variable in SqueakJS. The <strong>stack</strong> variable holds an array of Smalltalk object pointers, constituting the current method’s stack. In general, the WASM code for a Smalltalk method will also need fast variable access to the active Smalltalk context, the active context’s stack, the current method’s literals, and the current method’s temporary variables.</p>



<p>Our WASM module for <strong>HelloWASM&gt;&gt;add</strong> might begin like this:</p>


<div><pre title="">(module
	(type $bytes (array (mut i8)))
 	(type $words (array (mut i32)))
 	(type $pointers (array (ref $object)))

 	(type $object (struct
		(field $metabits (mut i32))
		(field $class (ref $object))
		(field $format (mut i32))
		(field $hash (mut i32))
		(field $pointers (ref $pointers))
		(field $words (ref $words))
		(field $bytes (ref $bytes))
		(field $float (mut f32))
		(field $integer (mut i32))
		(field $address (mut i32))
		(field $nextObject (ref $object))))

	(global $vm (struct
		(field $sp (mut i32))
		(field $pc (mut i32)))

	(global $stack (array (ref $pointers)))

	(function $HelloWASM_add
		;; pc 0
		;; push constant 3
		global.get $stack
		global.get $vm
		global.get $vm
		struct.get $vm $sp
		i32.const 1
		i32.add
		struct.set $vm $sp ;; increment the stack pointer
		global.get $vm
		struct.get $vm $sp
		i32.const 3
		array.set $pointers
		
		;; pc 1
		...
</pre></div>


<p>As is typical with assembly-level code, there’s a lot of setup involved which seems quite verbose, but it enables fast paths for the execution machinery. We’re also effectively taking on the task of writing the firmware for our idealized Smalltalk processor, by setting up interfaces to contexts and methods, and by implementing the logic for each Smalltalk instruction. In a future article, I’ll discuss the mechanisms by which we actually run the WASM code for a Smalltalk method. I’ll also compare the performance of dynamic WASM translations of Smalltalk methods versus the dynamic JS translations that SqueakJS makes. I don’t expect the WASM translations to be much (or any) faster at the moment, but I do expect them to get faster over time, as the WASM engines in web browsers improve (just as JS engines have).</p>

				
				<p>
					<small>
						This entry was posted on 26 July 2023 at 9:52 am and is filed under <a href="https://thiscontext.com/tag/caffeine/" rel="category tag">Caffeine</a>, <a href="https://thiscontext.com/tag/consulting/" rel="category tag">consulting</a>, <a href="https://thiscontext.com/category/context/" rel="category tag">Context</a>, <a href="https://thiscontext.com/tag/livecoding/" rel="category tag">livecoding</a>, <a href="https://thiscontext.com/category/smalltalk-2/" rel="category tag">Smalltalk</a>, <a href="https://thiscontext.com/category/spoon/" rel="category tag">Spoon</a>, <a href="https://thiscontext.com/tag/squeakjs/" rel="category tag">SqueakJS</a> with tags <a href="https://thiscontext.com/tag/caffeine/" rel="tag">Caffeine</a>, <a href="https://thiscontext.com/tag/context-2/" rel="tag">context</a>, <a href="https://thiscontext.com/tag/javascript/" rel="tag">JavaScript</a>, <a href="https://thiscontext.com/tag/livecoding/" rel="tag">livecoding</a>, <a href="https://thiscontext.com/tag/smalltalk/" rel="tag">smalltalk</a>, <a href="https://thiscontext.com/tag/squeak/" rel="tag">squeak</a>, <a href="https://thiscontext.com/tag/squeakjs/" rel="tag">SqueakJS</a>, <a href="https://thiscontext.com/tag/webassembly/" rel="tag">WebAssembly</a>.						You can follow any responses to this entry through the <a href="https://thiscontext.com/2023/07/26/dynamic-translation-of-smalltalk-to-webassembly/feed/">RSS 2.0</a> feed.
													You can <a href="#respond">leave a response</a>, or <a href="https://thiscontext.com/2023/07/26/dynamic-translation-of-smalltalk-to-webassembly/trackback/">trackback</a> from your own site.
						
					</small>
				</p>

			</div></div>
  </body>
</html>
