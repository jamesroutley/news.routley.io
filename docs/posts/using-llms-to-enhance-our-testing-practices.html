<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.assembled.com/blog/how-we-saved-hundreds-of-engineering-hours-by-writing-tests-with-llms">Original</a>
    <h1>Using LLMs to enhance our testing practices</h1>
    
    <div id="readability-page-1" class="page"><div><div fs-richtext-element="rich-text" fs-toc-element="contents" fs-toc-offsettop="9vh"><div fs-richtext-element="rich-text" fs-toc-element="contents" fs-toc-offsettop="9vh"><p>At Assembled, engineering velocity is our competitive edge. We pride ourselves on delivering <a href="https://www.assembled.com/whats-new">new features at a fast pace</a>. But how do we maintain quality without slowing down? The answer lies in robust testing. <a href="https://martinfowler.com/bliki/SelfTestingCode.html" target="_blank">As Martin Fowler aptly puts it</a>:</p><blockquote>[Testing] can drastically reduce the number of bugs that get into production… But the biggest benefit isn&#39;t about merely avoiding production bugs, it&#39;s about the confidence that you get to make changes to the system.</blockquote><p>Despite this, writing comprehensive tests is often overlooked due to time constraints or the complexity involved. Large Language Models (LLMs) have shifted this dynamic by making it significantly easier and faster to generate robust tests. Tasks that previously required hours can now be completed in just 5–10 minutes.</p><p>We&#39;ve observed tangible benefits within our team:</p><ul role="list"><li>An engineer who previously wrote few tests began consistently writing them after utilizing LLMs for test generation.</li><li>Another engineer, known for writing thorough tests, saved weeks of time by using LLMs to streamline the process.</li><li>Collectively, our engineers have saved hundreds of hours, reallocating that time to developing new features and refining existing ones.</li></ul><p>In this blog post, we&#39;ll explore how we’ve used LLMs to enhance our testing practices.</p><h2>Leveraging LLMs for testing</h2><p>To get started, you&#39;ll need access to a high-quality LLM for code generation like OpenAI&#39;s o1-preview or Anthropic&#39;s Claude 3.5 Sonnet.</p><p>Then, you should craft a precise prompt that guides the model to produce the desired output. Here&#39;s a sample prompt we&#39;ve found effective for generating Go unit tests:</p><pre contenteditable="false"><code><span>Help me write a comprehensive set </span><span>of</span><span> unit tests </span><span>in</span><span> Golang </span><span>for</span><span> the following </span><span>function</span><span>:
</span><span>
</span><span>&lt;</span><span>function_to_test</span><span>&gt;
</span><span>// </span><span>Insert</span><span> </span><span>your</span><span> </span><span>function</span><span> </span><span>code</span><span> </span><span>here</span><span>
</span><span>&lt;/</span><span>function_to_test</span><span>&gt;
</span><span>
</span><span></span><span>Here</span><span> </span><span>are</span><span> </span><span>the</span><span> </span><span>definitions</span><span> </span><span>of</span><span> </span><span>the</span><span> </span><span>associated</span><span> </span><span>structs</span><span> </span><span>used</span><span> </span><span>in</span><span> </span><span>the</span><span> </span><span>function</span><span>:
</span><span>
</span><span>&lt;</span><span>struct_definitions</span><span>&gt;
</span><span>// </span><span>Optionally</span><span> </span><span>insert</span><span> </span><span>any</span><span> </span><span>relevant</span><span> </span><span>struct</span><span> </span><span>definitions</span><span> </span><span>here</span><span>
</span><span>&lt;/</span><span>struct_definitions</span><span>&gt;
</span><span>
</span><span></span><span>Please</span><span> </span><span>ensure</span><span> </span><span>that</span><span>:
</span><span>- </span><span>The</span><span> </span><span>tests</span><span> </span><span>use</span><span> </span><span>the</span><span> </span><span>fixture</span><span> </span><span>pattern</span><span> </span><span>by</span><span> </span><span>defining</span><span> </span><span>different</span><span> </span><span>test</span><span> </span><span>cases</span><span> </span><span>in</span><span> </span><span>a</span><span> </span><span>slice</span><span>.
</span><span>- </span><span>The</span><span> </span><span>tests</span><span> </span><span>follow</span><span> </span><span>Go</span><span>&#39;</span><span>s</span><span> </span><span>testing</span><span> </span><span>best</span><span> </span><span>practices</span><span>, </span><span>including</span><span> </span><span>proper</span><span> </span><span>naming</span><span> </span><span>conventions</span><span> </span><span>and</span><span> </span><span>code</span><span> </span><span>organization</span><span>.
</span><span>- </span><span>Use</span><span> </span><span>the</span><span> `</span><span>testing</span><span>` </span><span>and</span><span> `</span><span>require</span><span>` </span><span>packages</span><span> </span><span>as</span><span> </span><span>shown</span><span> </span><span>in</span><span> </span><span>the</span><span> </span><span>example</span><span> </span><span>below</span><span>.
</span><span>- </span><span>Cover</span><span> </span><span>various</span><span> </span><span>scenarios</span><span>, </span><span>including</span><span> </span><span>normal</span><span> </span><span>cases</span><span>, </span><span>edge</span><span> </span><span>cases</span><span>, </span><span>and</span><span> </span><span>error</span><span> </span><span>handling</span><span>.
</span><span>
</span><span>&lt;</span><span>test_example</span><span>&gt;
</span><span>// </span><span>Include</span><span> </span><span>an</span><span> </span><span>example</span><span> </span><span>of</span><span> </span><span>a</span><span> </span><span>good</span><span> </span><span>unit</span><span> </span><span>test</span><span> </span><span>from</span><span> </span><span>your</span><span> </span><span>codebase</span><span>
</span><span>&lt;/</span><span>test_example</span><span>&gt;</span></code></pre><p>‍</p><p>In this prompt, you need to provide:</p><ul role="list"><li><strong>Function to test</strong>: Copy and paste the exact code you’re looking to write tests for.</li><li><strong>Struct definitions</strong>: Include any relevant definitions that the function uses (especially for any objects that appear in the input or output of the function).</li><li><strong>Example of a test suite</strong>: An example of existing tests that reflect your codebase&#39;s style and conventions.</li></ul><p>Once you’ve dropped this into an LLM and generated a result, you might need to review and refine the generated tests. You should check for compilation issues, add any potential edge cases the LLM missed, and adjust the style to match your codebase conventions. We’ve found that a few iterations of back and forth are sometimes necessary to arrive at an acceptable test suite. Once you’re close enough, just copy and paste the resulting tests back into your codebase.</p><p>If you have an AI-assisted code editor like Copilot or Cursor, the principles remain the same; though, because tools can provide context-aware suggestions based on your existing code, you often can get away with less detailed prompts.</p><h2>Example in action</h2><p>Suppose you&#39;re building an e-commerce platform and have a function that calculates an order summary. Here&#39;s how you might apply the above approach.</p><pre contenteditable="false"><code><span>// Struct definitions</span><span>
</span>type OrderItem struct {
    ProductID   string
    Quantity    int
    UnitPrice   float64
<span>    Weight      float64 </span><span>// Weight per unit in kg</span><span>
</span>    Category    string
}

type OrderSummary struct {
    TotalPrice      float64
    TotalWeight     float64
<span>    ItemsByCategory map[string]int </span><span>// Category name to total quantity</span><span>
</span>}

<span></span><span>// Function to test</span><span>
</span>func CalculateOrderSummary(items []OrderItem) OrderSummary {
<span>    </span><span>itemsByCategory</span><span> := make(map[string]int)
</span><span>    </span><span>totalPrice</span><span> := </span><span>0.0</span><span>
</span><span>    </span><span>totalWeight</span><span> := </span><span>0.0</span><span>
</span>
<span>    </span><span>for</span><span> _, </span><span>item</span><span> := range items {
</span><span>        </span><span>totalItemPrice</span><span> := float64(item.Quantity) * item.UnitPrice
</span><span>        </span><span>totalItemWeight</span><span> := float64(item.Quantity) * item.Weight
</span>
        totalPrice += totalItemPrice
        totalWeight += totalItemWeight

        itemsByCategory[item.Category] += item.Quantity
    }

<span>    </span><span>summary</span><span> := OrderSummary{
</span><span>		    </span><span>TotalPrice</span><span>: totalPrice,
</span><span>		    </span><span>TotalWeight</span><span>: totalWeight,
</span><span>		    </span><span>ItemsByCategory</span><span>: itemsByCategory    
</span>		}
<span>    </span><span>return</span><span> summary
</span>}</code></pre><p>‍</p><p>Using the suggested prompt, we fed this code into ChatGPT o1-preview and, in <strong>just 48 seconds</strong>, it generated a comprehensive test suite that was ready to use straight out of the box. <a href="https://chatgpt.com/share/671576aa-c914-8000-9458-798e847e3c2c" target="_blank">Here’s the full prompt and results from ChatGPT</a><strong>.</strong></p><p>You’ll notice that the resulting tests are both comprehensive and well written:</p><ul role="list"><li>The tests cover basically all of the cases that you might think of: empty slices, nil slices, single item, multiple items, items with zero quantity, etc. These test cases are mutually exclusive and collectively exhaustive and cover most of the edge cases a good engineer would think of.</li><li>Moreover, the resultant code is in the table-driven fixture style that is idiomatic in Go — the exact format that we specified in the initial prompt. The resultant tests even use the <code>testify/require</code> library, which is prescribed in the original example.</li></ul><p>‍</p><pre contenteditable="false"><code><span>import</span><span> (
</span><span>	</span><span>&#34;testing&#34;</span><span>
</span>
<span>	</span><span>&#34;github.com/stretchr/testify/require&#34;</span><span>
</span>)

<span>func </span><span>TestCalculateOrderSummary</span><span>(</span><span>t *testing.T</span><span>)</span><span> {
</span><span>	</span><span>fixtures</span><span> := []struct {
</span>		Name     string
		Items    []OrderItem
		Expected OrderSummary
	}{
	  ...
		{
<span>			</span><span>Name</span><span>: </span><span>&#34;Multiple items in different categories&#34;</span><span>,
</span><span>			</span><span>Items</span><span>: []OrderItem{
</span>				{
<span>					</span><span>ProductID</span><span>: </span><span>&#34;P1&#34;</span><span>,
</span><span>					</span><span>Quantity</span><span>:  </span><span>2</span><span>,
</span><span>					</span><span>UnitPrice</span><span>: </span><span>5.0</span><span>,
</span><span>					</span><span>Weight</span><span>:    </span><span>0.2</span><span>,
</span><span>					</span><span>Category</span><span>:  </span><span>&#34;Books&#34;</span><span>,
</span>				},
				{
<span>					</span><span>ProductID</span><span>: </span><span>&#34;P2&#34;</span><span>,
</span><span>					</span><span>Quantity</span><span>:  </span><span>1</span><span>,
</span><span>					</span><span>UnitPrice</span><span>: </span><span>100.0</span><span>,
</span><span>					</span><span>Weight</span><span>:    </span><span>1.0</span><span>,
</span><span>					</span><span>Category</span><span>:  </span><span>&#34;Electronics&#34;</span><span>,
</span>				},
			},
<span>			</span><span>Expected</span><span>: OrderSummary{
</span><span>				</span><span>TotalPrice</span><span>:  (</span><span>2</span><span> * </span><span>5.0</span><span>) + (</span><span>1</span><span> * </span><span>100.0</span><span>),
</span><span>				</span><span>TotalWeight</span><span>: (</span><span>2</span><span> * </span><span>0.2</span><span>) + (</span><span>1</span><span> * </span><span>1.0</span><span>),
</span><span>				</span><span>ItemsByCategory</span><span>: map[string]int{
</span><span>					</span><span>&#34;Books&#34;</span><span>:       </span><span>2</span><span>,
</span><span>					</span><span>&#34;Electronics&#34;</span><span>: </span><span>1</span><span>,
</span>				},
			},
		},
		...
	}

<span>	</span><span>for</span><span> _, </span><span>fixture</span><span> := range fixtures {
</span><span>		t.Run(fixture.Name, </span><span>func</span><span>(</span><span>t *testing.T</span><span>)</span><span> {
</span><span>			</span><span>result</span><span> := CalculateOrderSummary(fixture.Items)
</span><span>			</span><span>require</span><span>.Equal(t, fixture.Expected.TotalPrice, result.TotalPrice, </span><span>&#34;TotalPrice mismatch&#34;</span><span>)
</span><span>			</span><span>require</span><span>.Equal(t, fixture.Expected.TotalWeight, result.TotalWeight, </span><span>&#34;TotalWeight mismatch&#34;</span><span>)
</span><span>			</span><span>require</span><span>.Equal(t, fixture.Expected.ItemsByCategory, result.ItemsByCategory, </span><span>&#34;ItemsByCategory mismatch&#34;</span><span>)
</span>		})
	}
}</code></pre><p>‍</p><h2>Extending to more complex scenarios</h2><p>The same approach can be applied to more complex testing scenarios. By adjusting the prompt and providing a different set of baseline test cases, you can generate tests for:</p><ul role="list"><li><strong>Different programming languages</strong>. It’s relatively straightforward to adjust the prompt for other languages and tailor the results to specific testing frameworks.<ul role="list"><li><a href="https://gist.github.com/wangjohn/418991f0dac46efdd7daab73a87c722b" target="_blank">Example: Unit tests for a typescript function that converts roman numerals to integers, using Claude 3.5 Sonnet</a></li></ul></li><li><strong>Frontend component testing.</strong> You can also extend this to test React components with user interactions and state changes — just make sure your examples capture the libraries you’d use.<ul role="list"><li><a href="https://chatgpt.com/share/67191e6b-9b54-8000-b9b0-17fcd391b677" target="_blank">Example: Testing a React dropdown component with Jest and React Testing Library, including user interactions and DOM assertions, using o1-preview.</a></li></ul></li><li><strong>Integration testing with mocked services.</strong> By changing the test case examples, you can test functions that interact with external APIs by mocking HTTP clients.<ul role="list"><li><a href="https://chatgpt.com/share/671942a2-15f8-8000-8815-4dc68f6dd4e8" target="_blank">Example: Testing a function that fetches average weather data by mocking a weather API call, using o1-preview.</a></li></ul></li></ul><h2>Considerations</h2><p>At Assembled, we’ve been using LLMs to write tests for a few months now and have seen big boosts in engineering productivity. That said, there are a few considerations to keep in mind as you start using LLMs for test writing:</p><ul role="list"><li><strong>Iterative refinement</strong>: You may need several iterations to cover missed edge cases or adjust to your codebase standards. Sometimes, the LLMs might generate code that doesn’t compile, so asking the LLM to make adjustments is critical.</li><li><strong>Double check your test logic:</strong> While LLMs are pretty good out of the box, they can sometimes get tests wrong. For example, one of our engineers had an experience where the model gave incorrect output because of improper formatting. We insist that all Assembled engineers read and run any LLM-generated tests before merging into production.</li><li><strong>Customize your prompt to your specific context</strong>: Our engineers have found that tailoring their prompts can significantly enhance the quality of the generated tests. For example, you might consider specifying your test frameworks (e.g. “Use Jest and React Testing Library for testing this React component.”) or highlighting important edge cases (e.g. “Ensure you include tests for handling null inputs and maximum integer values.”).</li><li><strong>Examples matter:</strong> LLMs do their best work when they have a good example of tests to learn from. The engineering team at Assembled has built a large repository of comprehensive and idiomatic tests over time, which makes it easier to use these techniques. Remember that your examples are often your most important way to drive the LLM to do what you want.</li><li><strong>Use the smartest models</strong>: Models like o1-preview or Claude 3.5 Sonnet generally provide better results. Since latency isn&#39;t a major concern, we tend to use the best available models.</li><li><strong>Code structure reflects testability</strong>: If you’re having trouble getting the LLM to construct suitable tests, consider refactoring your code. It’s likely that whatever combination of inputs and outputs you have may be poorly structured or overly complex. You can even ask the LLM to break things up and refactor your code with the same prompting principles discussed above.</li><li><strong>Don’t overdo testing</strong>: You generally want to test the functions that have clear input / output and which contain the most important pieces of logic. You don’t need to test that a checkbox is working correctly (unless you’re the maintainer of a component library). Likewise, glue code is tough to test, and writing tests for some pretty straightforward glue code may not be worth it — though you should check on a case-by-case basis (e.g., if that glue code is a very hot codepath).</li></ul><h2>Conclusion</h2><p>Using LLMs to generate comprehensive test suites in minutes has been a game changer at Assembled. It reduces the activation energy to write tests and makes it less likely that engineers skip tests due to time constraints. This has resulted in a cleaner, safer codebase that has increased development velocity.</p><h2>We’re hiring</h2><p>We’ve got a lot of features to build and tests to write. If you’re interested in helping us transform customer support, <a href="https://www.assembled.com/careers-at-assembled#openings" target="_blank">check out our open roles</a>.</p></div></div></div></div>
  </body>
</html>
