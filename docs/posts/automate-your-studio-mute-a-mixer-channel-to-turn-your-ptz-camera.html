<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/KopiasCsaba/open_sound_control_bridge">Original</a>
    <h1>Show HN: Automate your studio â€“ mute a mixer channel to turn your PTZ camera</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">

<ul dir="auto">
<li><a href="#open-sound-control-bridge">Open Sound Control Bridge</a>
<ul dir="auto">
<li><a href="#example-uses">Example uses</a></li>
</ul>
</li>
<li><a href="#install">Install</a>
<ul dir="auto">
<li><a href="#docker">Docker</a></li>
</ul>
</li>
<li><a href="#overview">Overview</a></li>
<li><a href="#configuration">Configuration</a>
<ul dir="auto">
<li><a href="#example-configuration">Example configuration</a></li>
<li><a href="#actions">Actions</a>
<ul dir="auto">
<li><a href="#debouncing">Debouncing</a></li>
</ul>
</li>
<li><a href="#trigger-chain">Trigger chain</a>
<ul dir="auto">
<li><a href="#conditions">Conditions</a>
<ul dir="auto">
<li><a href="#oscmatch-check-if-a-single-message-exists">OSC_MATCH: Check if a single message exists</a>
<ul dir="auto">
<li><a href="#trigger-on-change">Trigger on change</a></li>
</ul>
</li>
<li><a href="#and-require-all-children-condition-to-resolve-to-true">AND: Require all children condition to resolve to true</a></li>
<li><a href="#or-require-at-least-one-children-to-resolve-to-true">OR: Require at least one children to resolve to true</a></li>
<li><a href="#not-negate-the-single-childs-result">NOT: Negate the single child&#39;s result.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sources">Sources</a>
<ul dir="auto">
<li><a href="#digital-mixing-consoles">Digital Mixing Consoles</a></li>
<li><a href="#dummy-console">Dummy console</a></li>
<li><a href="#obs-bridges">OBS bridges</a></li>
<li><a href="#http-bridges">HTTP bridges</a></li>
<li><a href="#tickers">Tickers</a></li>
</ul>
</li>
<li><a href="#tasks">Tasks</a>
<ul dir="auto">
<li><a href="#http-request">HTTP request</a></li>
<li><a href="#obs-scene-change">OBS Scene change</a></li>
<li><a href="#obs-vendor-message">OBS Vendor message</a></li>
<li><a href="#delay">Delay</a></li>
<li><a href="#run-command">Run command</a></li>
<li><a href="#send-osc-message">Send OSC message</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#development">Development</a></li>
</ul>


<p dir="auto">OSCBridge is a tool to help automate operations with audio/streaming gear.</p>
<p dir="auto">Input could come from various sources, such as:</p>
<ul dir="auto">
<li>Digital Audio Mixer Console state (such as Behringer X32 or other that supports OSC)</li>
<li>OBS Studio state</li>
<li>A HTTP Request</li>
<li>Time</li>
</ul>
<p dir="auto">OSCBridge currently supports the following &#34;tasks&#34;:</p>
<ul dir="auto">
<li>HTTP Request</li>
<li>Delay (just wait)</li>
<li>OBS Change preview scene</li>
<li>OBS Change program scene</li>
<li>OBS Send &#34;vendor&#34; message to any plugin that cares, e.g. to the amazingly
excellent <a href="https://github.com/WarmUpTill/SceneSwitcher">Advanced Scene Switcher</a>.</li>
<li>Excecute a command</li>
<li>Send an OSC message</li>
</ul>

<p dir="auto">Here is just a few idea:</p>
<ul dir="auto">
<li>When a microphone is unmuted, turn the PTZ camera to the speaker.</li>
<li>When the stage is unmuted, turn the PTZ camera to the stage.</li>
<li>When a special HTTP request arrives, mute/unmute something.</li>
<li>When a special HTTP request arrives, set the volume of a channel to the specified value.</li>
<li>At a specified time, unmute a microphone.</li>
<li>At a specified time, switch to an OBS Scene.</li>
<li>At a specified time, send an HTTP Request.</li>
<li>When something is unmuted, switch to a scene in OBS.</li>
<li>When a scene is activated in OBS unmute certain channels.</li>
<li>When a microphone is unmuted, then turn the camera but only if a ceratin OBS scene is active.</li>
<li>When ... send a command to Advanced Scene Switcher, to do
a <a href="https://github.com/WarmUpTill/SceneSwitcher/wiki">zillion other things</a></li>
<li>When ... then make Advanced Scene Switcher do an http request to execute some other actions through the oscbridge. (
Btw A.S.S. can send OSC messages too.)</li>
</ul>
<p dir="auto">I think now you got the point!</p>

<ul dir="auto">
<li>Download the binary from the latest <a href="https://github.com/KopiasCsaba/open_sound_control_bridge/releases">release</a></li>
<li>Create a <a href="https://github.com/KopiasCsaba/open_sound_control_bridge#example-configuration">config.yml</a> next to the binary.</li>
<li>Execute!</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="$:oscbridge$ ls
config.yml  oscbridge-6acaf3b4-linux-amd64.bin

$:oscbridge$ chmod +x oscbridge-6acaf3b4-linux-amd64.bin 

$:oscbridge$ ./oscbridge-6acaf3b4-linux-amd64.bin 
2023-11-13 07:30:51 [ INFO] OPEN SOUND CONTROL BRIDGE is starting.
2023-11-13 07:30:51 [ INFO] Version: v1.0.0 Revision: 6acaf3b4 
2023-11-13 07:30:51 [ INFO] Initializing OBS connections...
2023-11-13 07:30:51 [ INFO]     Connecting to streaming_pc_obs...
2023-11-13 07:30:51 [ INFO] Initializing OBS bridges...
2023-11-13 07:30:51 [ INFO] Initializing Open Sound Control (mixer consoles, etc) connections...

..."><pre>$:oscbridge$ ls
config.yml  oscbridge-6acaf3b4-linux-amd64.bin

$:oscbridge$ chmod +x oscbridge-6acaf3b4-linux-amd64.bin 

$:oscbridge$ ./oscbridge-6acaf3b4-linux-amd64.bin 
2023-11-13 07:30:51 [ INFO] OPEN SOUND CONTROL BRIDGE is starting.
2023-11-13 07:30:51 [ INFO] Version: v1.0.0 Revision: 6acaf3b4 
2023-11-13 07:30:51 [ INFO] Initializing OBS connections...
2023-11-13 07:30:51 [ INFO]     Connecting to streaming_pc_obs...
2023-11-13 07:30:51 [ INFO] Initializing OBS bridges...
2023-11-13 07:30:51 [ INFO] Initializing Open Sound Control (mixer consoles, etc) connections...

...</pre></div>
<p dir="auto">You may override the config.yml location with the environment variable <code>APP_CONFIG_FILE</code>, e.g.: <code>APP_CONFIG_FILE=/a/b/c/d/osc.yml</code>.</p>

<p dir="auto">A docker-hub version will be coming soon when my time permits.</p>

<p dir="auto">From a birds eye view, oscbridge provides a central &#34;message store&#34;, to which &#34;osc sources&#34; can publish messages.
Every time a new message arrives, each action is checked, if their trigger_chain conditions are resolving to true based
on the current store.
If every the trigger chain resolves to true, then the action&#39;s tasks are executed.</p>
<p dir="auto">So this is the control flow:
[OSC SOURCES] -&gt; [OSC MESSAGE STORE] -&gt; [ACTION TRIGGER CHAIN] -&gt; [ACTION TASK]</p>


<p dir="auto">Below is the simplest example to showcase how the system works.</p>
<details>
<summary>Click to see YAML</summary>
<div dir="auto" data-snippet-clipboard-copy-content="obs_connections:
  - name: &#34;streaming_pc_obs&#34;
    host: 192.168.1.75
    port: 4455
    password: &#34;foobar&#34;

osc_sources:
  console_bridges:
    - name: &#34;behringer_x32&#34;
      enabled: false
      prefix: &#34;&#34;
      host: 192.168.2.99
      port: 10023
      osc_implementation: l
      init_command:
        address: /xinfo
      check_address: /ch/01/mix/on
      check_pattern: &#34;^0|1$&#34;
      subscriptions:
        - osc_command:
            address: /subscribe
            arguments:
              - type: string
                value: /ch/01/mix/on
              - type: int32
                value: 10
          repeat_millis: 8000

  dummy_connections:
    - name: &#34;behringer_x32_dummy&#34;
      enabled: true
      prefix: &#34;&#34;
      iteration_speed_secs: 1
      message_groups:
        - name: mic_1_on
          osc_commands:
            - address: /ch/01/mix/on
              comment: &#34;headset mute (0: muted, 1: unmuted)&#34;
              arguments:
                - type: int32
                  value: 1
        - name: mic_1_off
          osc_commands:
            - address: /ch/01/mix/on
              comment: &#34;headset mute (0: muted, 1: unmuted)&#34;
              arguments:
                - type: int32
                  value: 0

actions:
  to_pulpit:
    trigger_chain:
      type: osc_match
      parameters:
        address: /ch/01/mix/on
        arguments:
          - index: 0
            type: &#34;int32&#34;
            value: &#34;1&#34;
    tasks:
      - type: http_request
        parameters:
          url: &#34;http://127.0.0.1:8888/cgi-bin/ptzctrl.cgi?ptzcmd&amp;poscall&amp;0&amp;__TURN_TO_PULPIT&#34;
          method: &#34;get&#34;
          timeout_secs: 1
      - type: obs_scene_change
        parameters:
          scene: &#34;PULPIT&#34;
          scene_match_type: regexp
          target: &#34;program&#34;
          connection: &#34;streaming_pc_obs&#34;
      - type: obs_scene_change
        parameters:
          scene: &#34;STAGE&#34;
          scene_match_type: regexp
          target: &#34;preview&#34;
          connection: &#34;streaming_pc_obs&#34;

  to_stage:
    trigger_chain:
      type: osc_match
      parameters:
        address: /ch/01/mix/on
        arguments:
          - index: 0
            type: &#34;int32&#34;
            value: &#34;0&#34;
    tasks:
      - type: http_request
        parameters:
          url: &#34;http://127.0.0.1:8888/cgi-bin/ptzctrl.cgi?ptzcmd&amp;poscall&amp;1&amp;__TURN_TO_STAGE&#34;
          method: &#34;get&#34;
          timeout_secs: 1
      - type: obs_scene_change
        parameters:
          scene: &#34;STAGE&#34;
          scene_match_type: regexp
          target: &#34;program&#34;
          connection: &#34;streaming_pc_obs&#34;
      - type: obs_scene_change
        parameters:
          scene: &#34;PULPIT&#34;
          scene_match_type: regexp
          target: &#34;preview&#34;
          connection: &#34;streaming_pc_obs&#34;"><pre><span>obs_connections</span>:
  - <span>name</span>: <span><span>&#34;</span>streaming_pc_obs<span>&#34;</span></span>
    <span>host</span>: <span>192.168.1.75</span>
    <span>port</span>: <span>4455</span>
    <span>password</span>: <span><span>&#34;</span>foobar<span>&#34;</span></span>

<span>osc_sources</span>:
  <span>console_bridges</span>:
    - <span>name</span>: <span><span>&#34;</span>behringer_x32<span>&#34;</span></span>
      <span>enabled</span>: <span>false</span>
      <span>prefix</span>: <span><span>&#34;</span><span>&#34;</span></span>
      <span>host</span>: <span>192.168.2.99</span>
      <span>port</span>: <span>10023</span>
      <span>osc_implementation</span>: <span>l</span>
      <span>init_command</span>:
        <span>address</span>: <span>/xinfo</span>
      <span>check_address</span>: <span>/ch/01/mix/on</span>
      <span>check_pattern</span>: <span><span>&#34;</span>^0|1$<span>&#34;</span></span>
      <span>subscriptions</span>:
        - <span>osc_command</span>:
            <span>address</span>: <span>/subscribe</span>
            <span>arguments</span>:
              - <span>type</span>: <span>string</span>
                <span>value</span>: <span>/ch/01/mix/on</span>
              - <span>type</span>: <span>int32</span>
                <span>value</span>: <span>10</span>
          <span>repeat_millis</span>: <span>8000</span>

  <span>dummy_connections</span>:
    - <span>name</span>: <span><span>&#34;</span>behringer_x32_dummy<span>&#34;</span></span>
      <span>enabled</span>: <span>true</span>
      <span>prefix</span>: <span><span>&#34;</span><span>&#34;</span></span>
      <span>iteration_speed_secs</span>: <span>1</span>
      <span>message_groups</span>:
        - <span>name</span>: <span>mic_1_on</span>
          <span>osc_commands</span>:
            - <span>address</span>: <span>/ch/01/mix/on</span>
              <span>comment</span>: <span><span>&#34;</span>headset mute (0: muted, 1: unmuted)<span>&#34;</span></span>
              <span>arguments</span>:
                - <span>type</span>: <span>int32</span>
                  <span>value</span>: <span>1</span>
        - <span>name</span>: <span>mic_1_off</span>
          <span>osc_commands</span>:
            - <span>address</span>: <span>/ch/01/mix/on</span>
              <span>comment</span>: <span><span>&#34;</span>headset mute (0: muted, 1: unmuted)<span>&#34;</span></span>
              <span>arguments</span>:
                - <span>type</span>: <span>int32</span>
                  <span>value</span>: <span>0</span>

<span>actions</span>:
  <span>to_pulpit</span>:
    <span>trigger_chain</span>:
      <span>type</span>: <span>osc_match</span>
      <span>parameters</span>:
        <span>address</span>: <span>/ch/01/mix/on</span>
        <span>arguments</span>:
          - <span>index</span>: <span>0</span>
            <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
            <span>value</span>: <span><span>&#34;</span>1<span>&#34;</span></span>
    <span>tasks</span>:
      - <span>type</span>: <span>http_request</span>
        <span>parameters</span>:
          <span>url</span>: <span><span>&#34;</span>http://127.0.0.1:8888/cgi-bin/ptzctrl.cgi?ptzcmd&amp;poscall&amp;0&amp;__TURN_TO_PULPIT<span>&#34;</span></span>
          <span>method</span>: <span><span>&#34;</span>get<span>&#34;</span></span>
          <span>timeout_secs</span>: <span>1</span>
      - <span>type</span>: <span>obs_scene_change</span>
        <span>parameters</span>:
          <span>scene</span>: <span><span>&#34;</span>PULPIT<span>&#34;</span></span>
          <span>scene_match_type</span>: <span>regexp</span>
          <span>target</span>: <span><span>&#34;</span>program<span>&#34;</span></span>
          <span>connection</span>: <span><span>&#34;</span>streaming_pc_obs<span>&#34;</span></span>
      - <span>type</span>: <span>obs_scene_change</span>
        <span>parameters</span>:
          <span>scene</span>: <span><span>&#34;</span>STAGE<span>&#34;</span></span>
          <span>scene_match_type</span>: <span>regexp</span>
          <span>target</span>: <span><span>&#34;</span>preview<span>&#34;</span></span>
          <span>connection</span>: <span><span>&#34;</span>streaming_pc_obs<span>&#34;</span></span>

  <span>to_stage</span>:
    <span>trigger_chain</span>:
      <span>type</span>: <span>osc_match</span>
      <span>parameters</span>:
        <span>address</span>: <span>/ch/01/mix/on</span>
        <span>arguments</span>:
          - <span>index</span>: <span>0</span>
            <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
            <span>value</span>: <span><span>&#34;</span>0<span>&#34;</span></span>
    <span>tasks</span>:
      - <span>type</span>: <span>http_request</span>
        <span>parameters</span>:
          <span>url</span>: <span><span>&#34;</span>http://127.0.0.1:8888/cgi-bin/ptzctrl.cgi?ptzcmd&amp;poscall&amp;1&amp;__TURN_TO_STAGE<span>&#34;</span></span>
          <span>method</span>: <span><span>&#34;</span>get<span>&#34;</span></span>
          <span>timeout_secs</span>: <span>1</span>
      - <span>type</span>: <span>obs_scene_change</span>
        <span>parameters</span>:
          <span>scene</span>: <span><span>&#34;</span>STAGE<span>&#34;</span></span>
          <span>scene_match_type</span>: <span>regexp</span>
          <span>target</span>: <span><span>&#34;</span>program<span>&#34;</span></span>
          <span>connection</span>: <span><span>&#34;</span>streaming_pc_obs<span>&#34;</span></span>
      - <span>type</span>: <span>obs_scene_change</span>
        <span>parameters</span>:
          <span>scene</span>: <span><span>&#34;</span>PULPIT<span>&#34;</span></span>
          <span>scene_match_type</span>: <span>regexp</span>
          <span>target</span>: <span><span>&#34;</span>preview<span>&#34;</span></span>
          <span>connection</span>: <span><span>&#34;</span>streaming_pc_obs<span>&#34;</span></span></pre></div>
</details>
<p dir="auto">In this configuration there are two OSC sources:</p>
<ul dir="auto">
<li>Dummy (enabled)</li>
<li>A Behringer X32 digital console (disabled)</li>
</ul>
<p dir="auto">The dummy source acts as if someone would press Ch1&#39;s mute button every second to toggle it.</p>
<p dir="auto">Then there are two actions defined, &#34;to_pulpit&#34; and &#34;to_stage&#34;.
Each has a single trigger, that matches /ch/01/mix/on to be 0 or 1.</p>
<p dir="auto">Then for each action, there are three tasks:</p>
<ul dir="auto">
<li>An HTTP request that would recall a PTZ Optics camera preset (0 and 1 respectively).</li>
<li>An obs_scene_change to change the program scene.</li>
<li>An obs_scene_change to change the preview scene.</li>
</ul>
<p dir="auto">You can see the results on this gif:</p>
<p dir="auto"><a href="https://github.com/KopiasCsaba/open_sound_control_bridge/blob/main/docs/assets/readme/example_config.mkv"><img src="https://github.com/KopiasCsaba/open_sound_control_bridge/raw/main/docs/assets/readme/example_config.gif" width="300" data-animated-image=""/></a></p>
<p dir="auto">OBS is switching scenes based on the mute status, and at the bottom you can see the arriving requests.</p>
<p dir="auto">You can just switch from the dummy to the console one, and your mute button is then tied to OBS scenes and the camera.</p>

<p dir="auto">Actions encapsulate a so called <code>trigger_chain</code> and a list of <code>tasks</code> together.</p>
<p dir="auto">This is how actions look like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  change_to_pulpit:
    trigger_chain:
    # ... tree of conditions
    tasks:
    # ... 1 dimensional list of tasks to be executed in order, serially

  change_to_stage:
    trigger_chain:
    # ... tree of conditions
    tasks:
    # ... 1 dimensional list of tasks to be executed in order, serially

  start_live_stream:
    trigger_chain:
    # ... tree of conditions
    tasks:
    # ... 1 dimensional list of tasks to be executed in order, serially"><pre><span>actions</span>:
  <span>change_to_pulpit</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ... tree of conditions</span>
    <span>tasks</span>:
    <span><span>#</span> ... 1 dimensional list of tasks to be executed in order, serially</span>

  <span>change_to_stage</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ... tree of conditions</span>
    <span>tasks</span>:
    <span><span>#</span> ... 1 dimensional list of tasks to be executed in order, serially</span>

  <span>start_live_stream</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ... tree of conditions</span>
    <span>tasks</span>:
    <span><span>#</span> ... 1 dimensional list of tasks to be executed in order, serially</span></pre></div>
<p dir="auto">Each action has it&#39;s own name, that is shown in the logs upon evaluation/execution.</p>
<p dir="auto">Whenever the internal store receives an update, OSCBridge checks each action&#39;s trigger_chain, the tree of conditions if
they match the store or not.
If the trigger_chain is evaluated to be true, then the tasks will be executed.</p>

<p dir="auto">There is an option, that can be specified for each action, called <code>debounce_millis</code>,
if provided then the logic changes a bit. Upon store change, if the trigger_chain resolves to true,
then after the specified ammount of milliseconds the trigger_chain is re-evaluated.
If it is still true, only then will the tasks be executed.</p>
<p dir="auto">For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  change_to_pulpit:
    trigger_chain:
    # ... tree of conditions
    tasks:
    # ... 1 dimensional list of tasks to be executed in order, serially
    debounce_millis: 500"><pre><span>actions</span>:
  <span>change_to_pulpit</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ... tree of conditions</span>
    <span>tasks</span>:
    <span><span>#</span> ... 1 dimensional list of tasks to be executed in order, serially</span>
    <span>debounce_millis</span>: <span>500</span></pre></div>
<p dir="auto">This could protect against quick transients, e.g. an accidental unmute/mute. For example here,
if the trigger chain is watching for ch1&#39;s unmute, then it will only execute the tasks if it is unmute for more than
0.5seconds.
This can help avoid accidents, where you accidentally unmute something but then you immediately mute it back.</p>

<p dir="auto">The trigger chain is a tree of conditions. Some conditions can be nested, some of them are just leafs on a tree, without
any children.</p>
<p dir="auto">You can build very complex conditions into here, e.g. (in pseudo code):</p>
<div data-snippet-clipboard-copy-content="IF
(mic1-is-muted AND mic2-is-unmuted) OR 
(ch10-is-unmuted AND 
    (
    ch11fader &gt; 0.5 OR 
    ch12fader &gt; 0.5
    )
) THEN
...
"><pre><code>IF
(mic1-is-muted AND mic2-is-unmuted) OR 
(ch10-is-unmuted AND 
    (
    ch11fader &gt; 0.5 OR 
    ch12fader &gt; 0.5
    )
) THEN
...

</code></pre></div>
<p dir="auto">But the way to express these are a bit more complicated due to the YAML configuration we use.</p>

<div dir="auto"><h4 tabindex="-1" dir="auto">OSC_MATCH: Check if a single message exists</h4><a id="user-content-osc_match-check-if-a-single-message-exists" aria-label="Permalink: OSC_MATCH: Check if a single message exists" href="#osc_match-check-if-a-single-message-exists"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>osc_match</code> condition can nothave any children, and it is checking for a single message in the store.
It can check based on address, address regexp and also based on arguments.</p>
<p dir="auto">Here is an example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  change_to_pulpit:
    trigger_chain:
      - type: osc_match
        parameters:
          address: /ch/01/mix/on
          arguments:
            - index: 0
              type: &#34;int32&#34;
              value: &#34;1&#34;
    tasks:
    # ..."><pre><span>actions</span>:
  <span>change_to_pulpit</span>:
    <span>trigger_chain</span>:
      - <span>type</span>: <span>osc_match</span>
        <span>parameters</span>:
          <span>address</span>: <span>/ch/01/mix/on</span>
          <span>arguments</span>:
            - <span>index</span>: <span>0</span>
              <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
              <span>value</span>: <span><span>&#34;</span>1<span>&#34;</span></span>
    <span>tasks</span>:
    <span><span>#</span> ...</span></pre></div>
<p dir="auto">This is a single condition on an action&#39;s trigger_chain.
This checks for a message with an exact address of  &#34;/ch/01/mix/on&#34; and with a single first argument, that is int32 and
the value is 1.</p>
<p dir="auto">If such a message exists in the store, the tasks will be executed.</p>
<p dir="auto">Parameters:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Parameter</th>
<th>Default value</th>
<th>Possible values</th>
<th>Description</th>
<th>Example values</th>
</tr>
</thead>
<tbody>
<tr>
<td>address</td>
<td>none, required</td>
<td></td>
<td>The value for matching a message&#39;s address. Can be a regexp, see next option.</td>
<td>/ch/01/mix/on, /ch/0[0-9]/mix/on</td>
</tr>
<tr>
<td>address_match_type</td>
<td><code>eq</code></td>
<td><code>eq</code>, <code>regexp</code></td>
<td>Determines the way of address matching.</td>
<td><code>regexp</code></td>
</tr>
<tr>
<td>trigger_on_change</td>
<td><code>true</code></td>
<td><code>true</code>, <code>false</code></td>
<td>See the <a href="#trigger-on-change">trigger on change</a> paragraph.</td>
<td><code>true</code></td>
</tr>
<tr>
<td>arguments</td>
<td>none, optional</td>
<td></td>
<td>See the next table.</td>
<td>List of arguments</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Arguments:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Parameter</th>
<th>Default value</th>
<th>Possible values</th>
<th>Description</th>
<th>Example values</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>none, required</td>
<td><code>0</code></td>
<td>The 0 based index for the argument.</td>
<td><code>0</code>, <code>1</code>, <code>2</code></td>
</tr>
<tr>
<td>type</td>
<td>none, required</td>
<td><code>string</code>, <code>int32</code>, <code>float32</code></td>
<td>The type of the argument.</td>
<td><code>string</code></td>
</tr>
<tr>
<td>value</td>
<td>none, required</td>
<td></td>
<td>The value of the argument.</td>
<td><code>1</code></td>
</tr>
<tr>
<td>value_match_type</td>
<td><code>=</code></td>
<td><code>regexp</code>, <code>&lt;=</code>,<code>&lt;</code>,<code>&gt;</code>,<code>&gt;=</code>,<code>!=</code></td>
<td>The comparison method. In case of regexp, the value can be a regexp expression.</td>
<td><code>=</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">The <code>trigger_on_change</code> option is a special one. Whenever a new message arrives that changes the store, every
trigger_chain is checked.</p>
<p dir="auto">Now, during the execution of the trigger_chain, it is being monitored what messages those conditions accessed.
By default (when <code>trigger_on_change: true</code>) if the trigger chain did not access the NEWLY UPDATED message, so the one
that just arrived,
the tasks aren&#39;t going to be executed. This avoids unneccessary re-execution just because an unrelevant message updated
the store.</p>
<p dir="auto">But this is also usable, to avoid re-execution in a case when a relevant message updated the store.</p>
<p dir="auto">Practically this option decouples a condition from being a trigger. The condition is still required to match in order to
execute the tasks, but that single condition&#39;s change will not trigger execution.</p>
<p dir="auto">You want to set this to false, when you don&#39;t want to re-execute the action upon the toggling of one of the parameters
your trigger_chain is watching for. This is an edge case, that comes handy sometimes.</p>
<p dir="auto">For example, let&#39;s say you have the following trigger_chain (in pseudo-ish code):</p>
<div data-snippet-clipboard-copy-content="IF ( OBS-scene-name-contains-foobar AND
     OR (ch1-unmuted OR ch2-unmuted OR stage-is-muted) 
    )
THEN
..."><pre><code>IF ( OBS-scene-name-contains-foobar AND
     OR (ch1-unmuted OR ch2-unmuted OR stage-is-muted) 
    )
THEN
...
</code></pre></div>
<p dir="auto">So you want to only execute the tasks, when certain things on the console match, but don&#39;t wanna re-execute just because
of an OBS scene change.
But you only want to execute the tasks, when certain things on the console match AND obs scene name contains foobar.</p>
<p dir="auto">Then you can mark the OBS-scene-name-contains condition with <code>trigger_on_change: false</code>.
That will cause the tasks to be executed when the console state changes (and obs scene contains foobar), but will not
trigger if only obs changes would otherwise match.
E.g. you might switch from one scene to another that contains foobar in our pseudo example, but that would not
re-execute the tasks.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">AND: Require all children condition to resolve to true</h4><a id="user-content-and-require-all-children-condition-to-resolve-to-true" aria-label="Permalink: AND: Require all children condition to resolve to true" href="#and-require-all-children-condition-to-resolve-to-true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>And</code> as it&#39;s name implies requires all children to resolve to true.</p>
<p dir="auto">The following example action requires both ch1 <strong>AND</strong> ch2 to be on.</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  change_to_pulpit:
    trigger_chain:
      type: and
      children:
        - type: osc_match
          parameters:
            address: /ch/01/mix/on
            arguments:
              - index: 0
                type: &#34;int32&#34;
                value: &#34;1&#34;
        - type: osc_match
          parameters:
            address: /ch/02/mix/on
            arguments:
              - index: 0
                type: &#34;int32&#34;
                value: &#34;1&#34;
  tasks:
  # ..."><pre><span>actions</span>:
  <span>change_to_pulpit</span>:
    <span>trigger_chain</span>:
      <span>type</span>: <span>and</span>
      <span>children</span>:
        - <span>type</span>: <span>osc_match</span>
          <span>parameters</span>:
            <span>address</span>: <span>/ch/01/mix/on</span>
            <span>arguments</span>:
              - <span>index</span>: <span>0</span>
                <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
                <span>value</span>: <span><span>&#34;</span>1<span>&#34;</span></span>
        - <span>type</span>: <span>osc_match</span>
          <span>parameters</span>:
            <span>address</span>: <span>/ch/02/mix/on</span>
            <span>arguments</span>:
              - <span>index</span>: <span>0</span>
                <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
                <span>value</span>: <span><span>&#34;</span>1<span>&#34;</span></span>
  <span>tasks</span>:
  <span><span>#</span> ...</span></pre></div>
<p dir="auto">Now you see how conditions can be nested.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">OR: Require at least one children to resolve to true</h4><a id="user-content-or-require-at-least-one-children-to-resolve-to-true" aria-label="Permalink: OR: Require at least one children to resolve to true" href="#or-require-at-least-one-children-to-resolve-to-true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>Or</code> as it&#39;s name implies requires that at least one of the childrens would resolve to true.</p>
<p dir="auto">The following example action executes the tasks if ch1 <strong>OR</strong> ch2 is be on.</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  change_to_pulpit:
    trigger_chain:
      type: or
      children:
        - type: osc_match
          parameters:
            address: /ch/01/mix/on
            arguments:
              - index: 0
                type: &#34;int32&#34;
                value: &#34;1&#34;
        - type: osc_match
          parameters:
            address: /ch/02/mix/on
            arguments:
              - index: 0
                type: &#34;int32&#34;
                value: &#34;1&#34;
  tasks:
  # ..."><pre><span>actions</span>:
  <span>change_to_pulpit</span>:
    <span>trigger_chain</span>:
      <span>type</span>: <span>or</span>
      <span>children</span>:
        - <span>type</span>: <span>osc_match</span>
          <span>parameters</span>:
            <span>address</span>: <span>/ch/01/mix/on</span>
            <span>arguments</span>:
              - <span>index</span>: <span>0</span>
                <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
                <span>value</span>: <span><span>&#34;</span>1<span>&#34;</span></span>
        - <span>type</span>: <span>osc_match</span>
          <span>parameters</span>:
            <span>address</span>: <span>/ch/02/mix/on</span>
            <span>arguments</span>:
              - <span>index</span>: <span>0</span>
                <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
                <span>value</span>: <span><span>&#34;</span>1<span>&#34;</span></span>
  <span>tasks</span>:
  <span><span>#</span> ...</span></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">NOT: Negate the single child&#39;s result.</h4><a id="user-content-not-negate-the-single-childs-result" aria-label="Permalink: NOT: Negate the single child&#39;s result." href="#not-negate-the-single-childs-result"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>NOT</code> condition simply negates it&#39;s single child&#39;s result.</p>
<p dir="auto">Here is how you would achieve this pseudo code:</p>
<div data-snippet-clipboard-copy-content="AND(ch1-unmuted; NOT(OR(ch10-unmuted,ch20-unmuted)))"><pre><code>AND(ch1-unmuted; NOT(OR(ch10-unmuted,ch20-unmuted)))
</code></pre></div>
<p dir="auto">In yaml:</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  change_to_pulpit:
    trigger_chain:
      type: and
      children:
        - type: osc_match
          parameters:
            address: /ch/01/mix/on
            arguments:
              - index: 0
                type: &#34;int32&#34;
                value: &#34;1&#34;
        - type: not
          children:
            - type: or
              children:
                - type: osc_match
                  parameters:
                    address: /ch/10/mix/on
                    arguments:
                      - index: 0
                        type: &#34;int32&#34;
                        value: &#34;1&#34;
                - type: osc_match
                  parameters:
                    address: /ch/20/mix/on
                    arguments:
                      - index: 0
                        type: &#34;int32&#34;
                        value: &#34;1&#34;

  tasks:
  # ..."><pre><span>actions</span>:
  <span>change_to_pulpit</span>:
    <span>trigger_chain</span>:
      <span>type</span>: <span>and</span>
      <span>children</span>:
        - <span>type</span>: <span>osc_match</span>
          <span>parameters</span>:
            <span>address</span>: <span>/ch/01/mix/on</span>
            <span>arguments</span>:
              - <span>index</span>: <span>0</span>
                <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
                <span>value</span>: <span><span>&#34;</span>1<span>&#34;</span></span>
        - <span>type</span>: <span>not</span>
          <span>children</span>:
            - <span>type</span>: <span>or</span>
              <span>children</span>:
                - <span>type</span>: <span>osc_match</span>
                  <span>parameters</span>:
                    <span>address</span>: <span>/ch/10/mix/on</span>
                    <span>arguments</span>:
                      - <span>index</span>: <span>0</span>
                        <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
                        <span>value</span>: <span><span>&#34;</span>1<span>&#34;</span></span>
                - <span>type</span>: <span>osc_match</span>
                  <span>parameters</span>:
                    <span>address</span>: <span>/ch/20/mix/on</span>
                    <span>arguments</span>:
                      - <span>index</span>: <span>0</span>
                        <span>type</span>: <span><span>&#34;</span>int32<span>&#34;</span></span>
                        <span>value</span>: <span><span>&#34;</span>1<span>&#34;</span></span>

  <span>tasks</span>:
  <span><span>#</span> ...</span></pre></div>

<p dir="auto">Now that you know how to compose conditions, you need input sources, that would add messages to the internal store,
against which you can match your trigger chains.</p>

<p dir="auto">Many digital mixing consoles support a protocol
called &#34;<a href="https://en.wikipedia.org/wiki/Open_Sound_Control" rel="nofollow">Open Sound Control</a>&#34;,
this is a UDP based simple protocol. It is based on &#34;Messages&#34;, where each message has an address, and 0 or more
arguments, and each argument can be a string, a float, an int, etc.</p>
<p dir="auto">I have tested on Behringer X32, so most examples are based on this console.
See pmalliot&#39;s excellent work <a href="https://sites.google.com/site/patrickmaillot/x32" rel="nofollow">here</a> on
X32&#39;s <a href="https://drive.google.com/file/d/1Snbwx3m6us6L1qeP1_pD6s8hbJpIpD0a/view" rel="nofollow">OSC</a> implementation.</p>
<p dir="auto">In the case of X32, we need to regularly(8-10 sec) issue a /subscribe command with proper arguments, to show that we are
interested in updates of a certain value from the console. Then the mixer is flooding us with the requested parameter.</p>
<p dir="auto">So below is a real world example for behringer x32 OSC connection:</p>
<details>
<summary>Click to see YAML</summary>
<div dir="auto" data-snippet-clipboard-copy-content="osc_sources:
  console_bridges:
    # The name of this mixer
    - name: &#34;behringer_x32&#34;

      # If enabled, OSCBRIDGE will try to connect, and restart if fails.
      enabled: true

      # Prefix determines the message address prefix as it will be stored to the store.
      # E.g. if you&#39;d have multiple consoles, you could prefix them &#34;/console1&#34;, &#34;/console2&#34;,
      # and you could match for /console1/ch/01/mix/on for example.
      prefix: &#34;&#34;

      host: 192.168.2.99
      port: 10023

      # The driver to use. We only have &#34;l&#34; for now.
      osc_implementation: l

      # This command is sent right after the connection is opened.
      # It can be used for authentication, or anything that is required.
      # X32 does not require anything, but for this it returns it&#39;s own name.
      init_command:
        address: /xinfo
        # You could specify arguments also.
        # arguments:
        #   - type: string
        #     value: &#34;foobar&#34;

      # There is a regular query running, for checking if the connection is still alive.
      # Specify an address here, and a regexp that matches the returned value.
      # If there is no response, or the response doesn&#39;t match, the connection is counted as broken and the app restarts.
      check_address: /ch/01/mix/on
      check_pattern: &#34;^0|1$&#34;
      # Subscriptions are commands that are sent regularly (repeat_millis) that cause the mixer to update us with the lates values for the subscribed thing.
      # Research your own mixer for the exact syntax, but this is how you do it for X32.
      subscriptions:
        - osc_command:
            # This command subscribes for channel 1&#39;s mute status. 0 is muted, 1 is unmuted.
            address: /subscribe
            arguments:
              - type: string
                value: /ch/01/mix/on
              - type: int32
                value: 10
          repeat_millis: 8000"><pre><span>osc_sources</span>:
  <span>console_bridges</span>:
    <span><span>#</span> The name of this mixer</span>
    - <span>name</span>: <span><span>&#34;</span>behringer_x32<span>&#34;</span></span>

      <span><span>#</span> If enabled, OSCBRIDGE will try to connect, and restart if fails.</span>
      <span>enabled</span>: <span>true</span>

      <span><span>#</span> Prefix determines the message address prefix as it will be stored to the store.</span>
      <span><span>#</span> E.g. if you&#39;d have multiple consoles, you could prefix them &#34;/console1&#34;, &#34;/console2&#34;,</span>
      <span><span>#</span> and you could match for /console1/ch/01/mix/on for example.</span>
      <span>prefix</span>: <span><span>&#34;</span><span>&#34;</span></span>

      <span>host</span>: <span>192.168.2.99</span>
      <span>port</span>: <span>10023</span>

      <span><span>#</span> The driver to use. We only have &#34;l&#34; for now.</span>
      <span>osc_implementation</span>: <span>l</span>

      <span><span>#</span> This command is sent right after the connection is opened.</span>
      <span><span>#</span> It can be used for authentication, or anything that is required.</span>
      <span><span>#</span> X32 does not require anything, but for this it returns it&#39;s own name.</span>
      <span>init_command</span>:
        <span>address</span>: <span>/xinfo</span>
        <span><span>#</span> You could specify arguments also.</span>
        <span><span>#</span> arguments:</span>
        <span><span>#</span>   - type: string</span>
        <span><span>#</span>     value: &#34;foobar&#34;</span>

      <span><span>#</span> There is a regular query running, for checking if the connection is still alive.</span>
      <span><span>#</span> Specify an address here, and a regexp that matches the returned value.</span>
      <span><span>#</span> If there is no response, or the response doesn&#39;t match, the connection is counted as broken and the app restarts.</span>
      <span>check_address</span>: <span>/ch/01/mix/on</span>
      <span>check_pattern</span>: <span><span>&#34;</span>^0|1$<span>&#34;</span></span>
      <span><span>#</span> Subscriptions are commands that are sent regularly (repeat_millis) that cause the mixer to update us with the lates values for the subscribed thing.</span>
      <span><span>#</span> Research your own mixer for the exact syntax, but this is how you do it for X32.</span>
      <span>subscriptions</span>:
        - <span>osc_command</span>:
            <span><span>#</span> This command subscribes for channel 1&#39;s mute status. 0 is muted, 1 is unmuted.</span>
            <span>address</span>: <span>/subscribe</span>
            <span>arguments</span>:
              - <span>type</span>: <span>string</span>
                <span>value</span>: <span>/ch/01/mix/on</span>
              - <span>type</span>: <span>int32</span>
                <span>value</span>: <span>10</span>
          <span>repeat_millis</span>: <span>8000</span></pre></div>
</details>

<p dir="auto">The dummy console implementation is just what it&#39;s name implies.
It has <code>message_groups</code>, and each <code>message_group</code> contains <code>messages</code>.
The dummy console iterates infinitely through the groups, and executes the messages in them.
Between each group it waits the configured ammount of time.</p>
<p dir="auto">The below example configures two groups, called &#34;mic_1_on&#34; and &#34;mic_1_off&#34;.</p>
<p dir="auto">Therefore, it provides a way to test the logic even without a real connection to a mixer.
You can have a dummy emitting the same messages the real console would, and you can freely enable/disable any source,
so you can test, or you can switch to the real operation mode by enabling the console connection.</p>
<details>
<summary>Click to see YAML</summary>
<div dir="auto" data-snippet-clipboard-copy-content="osc_sources:
  dummy_connections:
    - name: &#34;behringer_x32_dummy&#34;
      # Use this source, or not.
      enabled: true

      # Prefix determines the message address prefix as it will be stored to the store.
      prefix: &#34;&#34;

      # How much delay should be between each group?
      iteration_speed_secs: 1

      # Message groups are set of messages being emitted at once.
      message_groups:
        - name: mic_1_on
          osc_commands:
            - address: /ch/01/mix/on
              comment: &#34;headset mute (0: muted, 1: unmuted)&#34;
              arguments:
                - type: int32
                  value: 1

        - name: mic_1_off
          osc_commands:
            - address: /ch/01/mix/on
              comment: &#34;headset mute (0: muted, 1: unmuted)&#34;
              arguments:
                - type: int32
                  value: 0
"><pre><span>osc_sources</span>:
  <span>dummy_connections</span>:
    - <span>name</span>: <span><span>&#34;</span>behringer_x32_dummy<span>&#34;</span></span>
      <span><span>#</span> Use this source, or not.</span>
      <span>enabled</span>: <span>true</span>

      <span><span>#</span> Prefix determines the message address prefix as it will be stored to the store.</span>
      <span>prefix</span>: <span><span>&#34;</span><span>&#34;</span></span>

      <span><span>#</span> How much delay should be between each group?</span>
      <span>iteration_speed_secs</span>: <span>1</span>

      <span><span>#</span> Message groups are set of messages being emitted at once.</span>
      <span>message_groups</span>:
        - <span>name</span>: <span>mic_1_on</span>
          <span>osc_commands</span>:
            - <span>address</span>: <span>/ch/01/mix/on</span>
              <span>comment</span>: <span><span>&#34;</span>headset mute (0: muted, 1: unmuted)<span>&#34;</span></span>
              <span>arguments</span>:
                - <span>type</span>: <span>int32</span>
                  <span>value</span>: <span>1</span>

        - <span>name</span>: <span>mic_1_off</span>
          <span>osc_commands</span>:
            - <span>address</span>: <span>/ch/01/mix/on</span>
              <span>comment</span>: <span><span>&#34;</span>headset mute (0: muted, 1: unmuted)<span>&#34;</span></span>
              <span>arguments</span>:
                - <span>type</span>: <span>int32</span>
                  <span>value</span>: <span>0</span>
</pre></div>
</details>

<p dir="auto">OSCBridge can be configured to connect to an OBS Studio instance via websocket, and it will subscribe to some events in
OBS.</p>
<p dir="auto">These events are the following:</p>
<ul dir="auto">
<li>CurrentPreviewSceneChanged
<ul dir="auto">
<li>Message:
<ul dir="auto">
<li>Address: /obs/preview_scene</li>
<li>Argument[0]: string, value: NAME_OF_SCENE</li>
</ul>
</li>
</ul>
</li>
<li>CurrentProgramSceneChanged
<ul dir="auto">
<li>Message:
<ul dir="auto">
<li>Address: /obs/program_scene</li>
<li>Argument[0]: string, value: NAME_OF_SCENE</li>
</ul>
</li>
</ul>
</li>
<li>RecordStateChanged
<ul dir="auto">
<li>Message:
<ul dir="auto">
<li>Address: /obs/recording</li>
<li>Argument[0]: int32, value: 0 or 1</li>
</ul>
</li>
</ul>
</li>
<li>StreamStateChanged
<ul dir="auto">
<li>Message:
<ul dir="auto">
<li>Address: /obs/streaming</li>
<li>Argument[0]: int32, value: 0 or 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<p dir="auto">In order to configure an OBS Bridge, you&#39;ll also need to configure an OBS Connection.</p>
<details>
<summary>Click to see YAML</summary>
<div dir="auto" data-snippet-clipboard-copy-content="
obs_connections:
  - name: &#34;streampc_obs&#34;
    host: 192.168.1.75
    port: 4455
    password: &#34;foobar12345&#34;

osc_sources:
  obs_bridges:
    - name: &#34;obsbridge1&#34;
      # You may choose to disable it.
      enabled: true

      # Prefix determines the message address prefix as it will be stored to the store.
      prefix: &#34;&#34;

      # The name of the obs connection, see above.
      connection: &#34;streampc_obs&#34;
"><pre><span>obs_connections</span>:
  - <span>name</span>: <span><span>&#34;</span>streampc_obs<span>&#34;</span></span>
    <span>host</span>: <span>192.168.1.75</span>
    <span>port</span>: <span>4455</span>
    <span>password</span>: <span><span>&#34;</span>foobar12345<span>&#34;</span></span>

<span>osc_sources</span>:
  <span>obs_bridges</span>:
    - <span>name</span>: <span><span>&#34;</span>obsbridge1<span>&#34;</span></span>
      <span><span>#</span> You may choose to disable it.</span>
      <span>enabled</span>: <span>true</span>

      <span><span>#</span> Prefix determines the message address prefix as it will be stored to the store.</span>
      <span>prefix</span>: <span><span>&#34;</span><span>&#34;</span></span>

      <span><span>#</span> The name of the obs connection, see above.</span>
      <span>connection</span>: <span><span>&#34;</span>streampc_obs<span>&#34;</span></span>
</pre></div>
</details>

<p dir="auto">HTTP Bridges in OSCBridge enables you to open a port on a network interface and start a HTTP server on them.
The server can receive special HTTP GET requests, and converts them to OSC messages and stores them in the message
store.
Then you can write actions that check for that value, and may even execute tasks based on it.</p>
<p dir="auto">The message can be put away under some namespace by using the prefix option, but you could also use it to override an
existing message.</p>
<p dir="auto">To insert an OSC Message like this:</p>
<div data-snippet-clipboard-copy-content="Message(address: /foo/bar/baz, arguments: [Argument(string:hello), Argument(int32:1)])"><pre><code>Message(address: /foo/bar/baz, arguments: [Argument(string:hello), Argument(int32:1)])
</code></pre></div>
<p dir="auto">Execute a GET request like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="curl &#34;127.0.0.1:7878/?address=/foo/bar/baz&amp;args[]=string,hello&amp;args[]=int32,1&#34;"><pre>curl <span><span>&#34;</span>127.0.0.1:7878/?address=/foo/bar/baz&amp;args[]=string,hello&amp;args[]=int32,1<span>&#34;</span></span></pre></div>
<details>
<summary>Click to see YAML</summary>
<div dir="auto" data-snippet-clipboard-copy-content="osc_sources:
  http_bridges:
    - name: &#34;httpbridge1&#34;
      # You may choose to disable it.
      enabled: true
      # Prefix determines the message address prefix as it will be stored to the store.
      prefix: &#34;&#34;
      port: 7878
      host: 0.0.0.0"><pre><span>osc_sources</span>:
  <span>http_bridges</span>:
    - <span>name</span>: <span><span>&#34;</span>httpbridge1<span>&#34;</span></span>
      <span><span>#</span> You may choose to disable it.</span>
      <span>enabled</span>: <span>true</span>
      <span><span>#</span> Prefix determines the message address prefix as it will be stored to the store.</span>
      <span>prefix</span>: <span><span>&#34;</span><span>&#34;</span></span>
      <span>port</span>: <span>7878</span>
      <span>host</span>: <span>0.0.0.0</span></pre></div>
</details>

<p dir="auto">You can enable &#34;Tickers&#34;, that would regularly update the store with messages representing the current date/time.</p>
<p dir="auto">The ticker publishes several packages under &#34;/time/&#34; (if you don&#39;t specify a prefix), with names that might be weird for
the first time,
if you are not familiar with how golang&#39;s time formatting works.</p>
<p dir="auto">You may see the full reference <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.21.3:src/time/format.go;l=9" rel="nofollow">here</a>.</p>
<p dir="auto">Currently these messages are being emitted in every iteration:</p>
<div data-snippet-clipboard-copy-content="Message(address: /time/rfc3339,         arguments: [Argument(string:2023-11-07T08:53:06Z)])
Message(address: /time/parts/2006,      arguments: [Argument(string:2023)])
Message(address: /time/parts/06,        arguments: [Argument(string:23)])
Message(address: /time/parts/Jan,       arguments: [Argument(string:Nov)])
Message(address: /time/parts/January,   arguments: [Argument(string:November)])
Message(address: /time/parts/01,        arguments: [Argument(string:11)])
Message(address: /time/parts/1,         arguments: [Argument(string:11)])
Message(address: /time/parts/Mon,       arguments: [Argument(string:Tue)])
Message(address: /time/parts/Monday,    arguments: [Argument(string:Tuesday)])
Message(address: /time/parts/2,         arguments: [Argument(string:7)])
Message(address: /time/parts/_2,        arguments: [Argument(string: 7)])
Message(address: /time/parts/02,        arguments: [Argument(string:07)])
Message(address: /time/parts/__2,       arguments: [Argument(string:311)])
Message(address: /time/parts/002,       arguments: [Argument(string:311)])
Message(address: /time/parts/15,        arguments: [Argument(string:08)])
Message(address: /time/parts/3,         arguments: [Argument(string:8)])
Message(address: /time/parts/03,        arguments: [Argument(string:08)])
Message(address: /time/parts/4,         arguments: [Argument(string:53)])
Message(address: /time/parts/04,        arguments: [Argument(string:53)])
Message(address: /time/parts/5,         arguments: [Argument(string:6)])
Message(address: /time/parts/05,        arguments: [Argument(string:06)])
Message(address: /time/parts/PM,        arguments: [Argument(string:AM)])"><pre><code>Message(address: /time/rfc3339,         arguments: [Argument(string:2023-11-07T08:53:06Z)])
Message(address: /time/parts/2006,      arguments: [Argument(string:2023)])
Message(address: /time/parts/06,        arguments: [Argument(string:23)])
Message(address: /time/parts/Jan,       arguments: [Argument(string:Nov)])
Message(address: /time/parts/January,   arguments: [Argument(string:November)])
Message(address: /time/parts/01,        arguments: [Argument(string:11)])
Message(address: /time/parts/1,         arguments: [Argument(string:11)])
Message(address: /time/parts/Mon,       arguments: [Argument(string:Tue)])
Message(address: /time/parts/Monday,    arguments: [Argument(string:Tuesday)])
Message(address: /time/parts/2,         arguments: [Argument(string:7)])
Message(address: /time/parts/_2,        arguments: [Argument(string: 7)])
Message(address: /time/parts/02,        arguments: [Argument(string:07)])
Message(address: /time/parts/__2,       arguments: [Argument(string:311)])
Message(address: /time/parts/002,       arguments: [Argument(string:311)])
Message(address: /time/parts/15,        arguments: [Argument(string:08)])
Message(address: /time/parts/3,         arguments: [Argument(string:8)])
Message(address: /time/parts/03,        arguments: [Argument(string:08)])
Message(address: /time/parts/4,         arguments: [Argument(string:53)])
Message(address: /time/parts/04,        arguments: [Argument(string:53)])
Message(address: /time/parts/5,         arguments: [Argument(string:6)])
Message(address: /time/parts/05,        arguments: [Argument(string:06)])
Message(address: /time/parts/PM,        arguments: [Argument(string:AM)])
</code></pre></div>
<p dir="auto">So if you want to match for hour:minute, then you want to match the values of /time/15 and /time/04 respectively in the
trigger chain (to be explained later).</p>
<details>
<summary>Click to see YAML</summary>
<div dir="auto" data-snippet-clipboard-copy-content="osc_sources:
  tickers:
    - name: &#34;ticker1&#34;
      # You may choose to disable it.
      enabled: true

      # Prefix determines the message address prefix as it will be stored to the store.
      prefix: &#34;&#34;

      # How often updates should occur
      refresh_rate_millis: 1000"><pre><span>osc_sources</span>:
  <span>tickers</span>:
    - <span>name</span>: <span><span>&#34;</span>ticker1<span>&#34;</span></span>
      <span><span>#</span> You may choose to disable it.</span>
      <span>enabled</span>: <span>true</span>

      <span><span>#</span> Prefix determines the message address prefix as it will be stored to the store.</span>
      <span>prefix</span>: <span><span>&#34;</span><span>&#34;</span></span>

      <span><span>#</span> How often updates should occur</span>
      <span>refresh_rate_millis</span>: <span>1000</span></pre></div>
</details>

<p dir="auto">Now you have actions, trigger_chains and sources, the final piece is to have tasks that will be executed if the
trigger_chain evaluates to true.</p>

<p dir="auto">The <code>http_request</code> task executes a specific http request upon evaluation.</p>
<p dir="auto">Parameters:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Parameter</th>
<th>Default value</th>
<th>Possible values</th>
<th>Description</th>
<th>Example values</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td>none, required</td>
<td></td>
<td>The URL for the request.</td>
<td><a href="http://127.0.0.1/?foo=bar" rel="nofollow">http://127.0.0.1/?foo=bar</a></td>
</tr>
<tr>
<td>body</td>
<td>empty string</td>
<td></td>
<td>The request body.</td>
<td>{&#34;json&#34;:&#34;or something else&#34;}</td>
</tr>
<tr>
<td>timeout_secs</td>
<td>30</td>
<td></td>
<td>The timeout for the request.</td>
<td>1</td>
</tr>
<tr>
<td>method</td>
<td><code>GET</code></td>
<td><code>GET</code>, <code>POST</code></td>
<td>The method for the request.</td>
<td><code>POST</code></td>
</tr>
<tr>
<td>headers</td>
<td>empty</td>
<td></td>
<td>A list of &#34;Key: value&#34; pairs.</td>
<td><pre>- &#34;Content-Type: text/json&#34;</pre></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  to_pulpit:
    trigger_chain:
    # ...
    tasks:
      - type: http_request
        parameters:
          url: &#34;http://127.0.0.1:8888/cgi-bin/ptzctrl.cgi?ptzcmd&amp;poscall&amp;0&amp;__TURN_TO_PULPIT&#34;
          method: &#34;get&#34;
          timeout_secs: 1
          headers:
            - &#34;X-Foo: bar&#34;
            - &#34;X-Foo2: baz&#34;
          body: &#34;O HAI&#34;"><pre><span>actions</span>:
  <span>to_pulpit</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ...</span>
    <span>tasks</span>:
      - <span>type</span>: <span>http_request</span>
        <span>parameters</span>:
          <span>url</span>: <span><span>&#34;</span>http://127.0.0.1:8888/cgi-bin/ptzctrl.cgi?ptzcmd&amp;poscall&amp;0&amp;__TURN_TO_PULPIT<span>&#34;</span></span>
          <span>method</span>: <span><span>&#34;</span>get<span>&#34;</span></span>
          <span>timeout_secs</span>: <span>1</span>
          <span>headers</span>:
            - <span><span>&#34;</span>X-Foo: bar<span>&#34;</span></span>
            - <span><span>&#34;</span>X-Foo2: baz<span>&#34;</span></span>
          <span>body</span>: <span><span>&#34;</span>O HAI<span>&#34;</span></span></pre></div>
<p dir="auto">The request that will be made:</p>
<div data-snippet-clipboard-copy-content="GET /cgi-bin/ptzctrl.cgi?ptzcmd&amp;poscall&amp;0&amp;__TURN_TO_PULPIT HTTP/1.1
Host: 127.0.0.1:8888
User-Agent: Go-http-client/1.1
Content-Length: 5
X-Foo: bar
X-Foo2: baz
Accept-Encoding: gzip

O HAI"><pre><code>GET /cgi-bin/ptzctrl.cgi?ptzcmd&amp;poscall&amp;0&amp;__TURN_TO_PULPIT HTTP/1.1
Host: 127.0.0.1:8888
User-Agent: Go-http-client/1.1
Content-Length: 5
X-Foo: bar
X-Foo2: baz
Accept-Encoding: gzip

O HAI
</code></pre></div>

<p dir="auto">The <code>obs_scene_change</code> task changes the live or program scene on a remote OBS instance.</p>
<p dir="auto">Parameters:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Parameter</th>
<th>Default value</th>
<th>Possible values</th>
<th>Description</th>
<th>Example values</th>
</tr>
</thead>
<tbody>
<tr>
<td>scene</td>
<td>none, required</td>
<td></td>
<td>The name of the scene to which we need to switch.</td>
<td><code>PULPIT</code>, <code>STAGE</code></td>
</tr>
<tr>
<td>connection</td>
<td>none, required</td>
<td></td>
<td>The name of the obs connection that this task should use.</td>
<td><code>streampc_obs</code></td>
</tr>
<tr>
<td>scene_match_type</td>
<td><code>exact</code></td>
<td><code>exact</code>, <code>regexp</code></td>
<td>How to match the scene name.</td>
<td><code>regexp</code></td>
</tr>
<tr>
<td>target</td>
<td>none, required</td>
<td><code>program</code>, <code>preview</code></td>
<td>Which side of OBS should be switched.</td>
<td><code>program</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="obs_connections:
  - name: &#34;streampc_obs&#34;
    host: 192.168.1.75
    port: 4455
    password: &#34;foobar12345&#34;


actions:
  to_pulpit:
    trigger_chain:
    # ...
    tasks:
      - type: obs_scene_change
        parameters:
          scene: &#34;PULPIT.*&#34;
          scene_match_type: regexp
          target: &#34;program&#34;
          connection: &#34;streaming_pc_obs&#34;

      - type: obs_scene_change
        parameters:
          scene: &#34;STAGE&#34;
          scene_match_type: exact
          target: &#34;preview&#34;
          connection: &#34;streaming_pc_obs&#34;"><pre><span>obs_connections</span>:
  - <span>name</span>: <span><span>&#34;</span>streampc_obs<span>&#34;</span></span>
    <span>host</span>: <span>192.168.1.75</span>
    <span>port</span>: <span>4455</span>
    <span>password</span>: <span><span>&#34;</span>foobar12345<span>&#34;</span></span>


<span>actions</span>:
  <span>to_pulpit</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ...</span>
    <span>tasks</span>:
      - <span>type</span>: <span>obs_scene_change</span>
        <span>parameters</span>:
          <span>scene</span>: <span><span>&#34;</span>PULPIT.*<span>&#34;</span></span>
          <span>scene_match_type</span>: <span>regexp</span>
          <span>target</span>: <span><span>&#34;</span>program<span>&#34;</span></span>
          <span>connection</span>: <span><span>&#34;</span>streaming_pc_obs<span>&#34;</span></span>

      - <span>type</span>: <span>obs_scene_change</span>
        <span>parameters</span>:
          <span>scene</span>: <span><span>&#34;</span>STAGE<span>&#34;</span></span>
          <span>scene_match_type</span>: <span>exact</span>
          <span>target</span>: <span><span>&#34;</span>preview<span>&#34;</span></span>
          <span>connection</span>: <span><span>&#34;</span>streaming_pc_obs<span>&#34;</span></span></pre></div>

<p dir="auto">It is possible to send
a <a href="https://github.com/obsproject/obs-websocket/blob/master/docs/generated/protocol.md#vendorevent">VendorEvent</a> to OBS
via a websocket connection.
Different plugins can listen for these events, one example is the
marvelous <a href="https://github.com/WarmUpTill/SceneSwitcher/">Advanced Scene Switcher</a>,
which <a href="https://github.com/WarmUpTill/SceneSwitcher/wiki/Websockets#websocket-condition">supports</a> this.</p>
<p dir="auto">So given that you are listening in that plugin for &#34;IF Websocket Message waas received: foobar_notice&#34;,
you can execute macros remotely with OSCBridge:</p>
<div dir="auto" data-snippet-clipboard-copy-content="obs_connections:
  - name: &#34;streampc_obs&#34;
    host: 192.168.1.75
    port: 4455
    password: &#34;foobar12345&#34;

actions:
  to_pulpit:
    trigger_chain:
    # ...
    tasks:
      - type: obs_vendor_request
        parameters:
          connection: &#34;streampc_obs&#34;
          vendorName: &#34;AdvancedSceneSwitcher&#34;
          requestType: &#34;AdvancedSceneSwitcherMessage&#34;
          requestData:
            message: &#34;foobar_notice&#34;"><pre><span>obs_connections</span>:
  - <span>name</span>: <span><span>&#34;</span>streampc_obs<span>&#34;</span></span>
    <span>host</span>: <span>192.168.1.75</span>
    <span>port</span>: <span>4455</span>
    <span>password</span>: <span><span>&#34;</span>foobar12345<span>&#34;</span></span>

<span>actions</span>:
  <span>to_pulpit</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ...</span>
    <span>tasks</span>:
      - <span>type</span>: <span>obs_vendor_request</span>
        <span>parameters</span>:
          <span>connection</span>: <span><span>&#34;</span>streampc_obs<span>&#34;</span></span>
          <span>vendorName</span>: <span><span>&#34;</span>AdvancedSceneSwitcher<span>&#34;</span></span>
          <span>requestType</span>: <span><span>&#34;</span>AdvancedSceneSwitcherMessage<span>&#34;</span></span>
          <span>requestData</span>:
            <span>message</span>: <span><span>&#34;</span>foobar_notice<span>&#34;</span></span></pre></div>
<p dir="auto">Parameters:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Parameter</th>
<th>Default value</th>
<th>Description</th>
<th>Example values</th>
</tr>
</thead>
<tbody>
<tr>
<td>connection</td>
<td>none, required</td>
<td>The name of the obs connection that this task should use.</td>
<td><code>streampc_obs</code></td>
</tr>
<tr>
<td>vendorName</td>
<td>none, required</td>
<td></td>
<td><code>AdvancedSceneSwitcher</code></td>
</tr>
<tr>
<td>requestType</td>
<td>none, required</td>
<td></td>
<td><code>AdvancedSceneSwitcherMessage</code></td>
</tr>
<tr>
<td>requestData</td>
<td>none, required</td>
<td></td>
<td><code>message: whatever</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">The <code>delay</code> simply delays the serial execution of the tasks, taking up as much time as you configure.</p>
<p dir="auto">Parameters:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Parameter</th>
<th>Default value</th>
<th>Description</th>
<th>Example values</th>
</tr>
</thead>
<tbody>
<tr>
<td>delay_millis</td>
<td>none, required</td>
<td>How much milliseconds to wait.</td>
<td><code>1500</code> (for 1.5 second)</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  to_pulpit:
    trigger_chain:
    # ...
    tasks:
      - type: delay
        parameters:
          delay_millis: 1500"><pre><span>actions</span>:
  <span>to_pulpit</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ...</span>
    <span>tasks</span>:
      - <span>type</span>: <span>delay</span>
        <span>parameters</span>:
          <span>delay_millis</span>: <span>1500</span></pre></div>

<p dir="auto">The <code>run_command</code> task simply executes the given command.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Parameter</th>
<th>Default value</th>
<th>Description</th>
<th>Example values</th>
</tr>
</thead>
<tbody>
<tr>
<td>command</td>
<td>none, required</td>
<td>The path to the binary to execute.</td>
<td>/usr/bin/bash</td>
</tr>
<tr>
<td>arguments</td>
<td>optional</td>
<td>The list of arguments.</td>
<td><pre>- &#34;-l&#34;</pre></td>
</tr>
<tr>
<td>run_in_background</td>
<td>false</td>
<td>Whether or not the serial execution of tasks should wait for the command to finish.</td>
<td></td>
</tr>
<tr>
<td>directory</td>
<td>optional</td>
<td>The execution folder for the command.</td>
<td></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">You need to <a href="https://pkg.go.dev/os/exec#example-Command" rel="nofollow">follow</a> the classical way of specifying a binary and it&#39;s
arguments.
So you can not use <code>date &gt; /tmp/date.txt</code> as the command, you need to specify <code>/usr/bin/bash</code> as the command, and then
the parameters.</p>
<p dir="auto">Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  to_pulpit:
    trigger_chain:
    # ...
    tasks:
      - type: run_command
        parameters:
          command: &#34;/usr/bin/bash&#34;
          arguments: [ &#34;-l&#34;,&#34;-c&#34;,&#34;date &gt; /tmp/date.txt&#34; ]"><pre><span>actions</span>:
  <span>to_pulpit</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ...</span>
    <span>tasks</span>:
      - <span>type</span>: <span>run_command</span>
        <span>parameters</span>:
          <span>command</span>: <span><span>&#34;</span>/usr/bin/bash<span>&#34;</span></span>
          <span>arguments</span>: <span>[ &#34;-l&#34;,&#34;-c&#34;,&#34;date &gt; /tmp/date.txt&#34; ]</span></pre></div>

<p dir="auto">The <code>send_osc_message</code> sends an open sound control message through the specified connection.
Currently only the <code>console_bridges</code> support sending a message. E.g. you can send a message back to your console.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Parameter</th>
<th>Default value</th>
<th>Description</th>
<th>Example values</th>
</tr>
</thead>
<tbody>
<tr>
<td>connection</td>
<td>none, required</td>
<td>The OSC connection to use (the <code>name</code> from one of your <code>console_bridges</code>)</td>
<td><code>behringer_x32</code></td>
</tr>
<tr>
<td>address</td>
<td>none, required</td>
<td>The address of the message.</td>
<td><code>/ch/10/mix/on</code></td>
</tr>
<tr>
<td>arguments</td>
<td>optional</td>
<td>The arguments of the message.</td>
<td><pre>- type: int32</pre></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Example:</p>
<p dir="auto">(Unmute channel 10)</p>
<div dir="auto" data-snippet-clipboard-copy-content="actions:
  to_pulpit:
    trigger_chain:
    # ...
    tasks:
      - type: send_osc_message
        parameters:
          connection: &#34;behringer_x32&#34;
          address: &#34;/ch/10/mix/on&#34;
          arguments:
            - type: int32
              value: 1"><pre><span>actions</span>:
  <span>to_pulpit</span>:
    <span>trigger_chain</span>:
    <span><span>#</span> ...</span>
    <span>tasks</span>:
      - <span>type</span>: <span>send_osc_message</span>
        <span>parameters</span>:
          <span>connection</span>: <span><span>&#34;</span>behringer_x32<span>&#34;</span></span>
          <span>address</span>: <span><span>&#34;</span>/ch/10/mix/on<span>&#34;</span></span>
          <span>arguments</span>:
            - <span>type</span>: <span>int32</span>
              <span>value</span>: <span>1</span></pre></div>

<p dir="auto">You&#39;ll need &#34;make&#34; and &#34;docker&#34; installed.
After cloning the repository, run &#34;make&#34; to see the available commands.</p>
<p dir="auto">Run <code>make dev_start</code> to start the development environment.</p>
<p dir="auto">It&#39;ll look for a config.yml in the source root.</p>
</article></div></div>
  </body>
</html>
