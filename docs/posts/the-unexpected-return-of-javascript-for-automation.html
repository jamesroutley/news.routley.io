<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scriptingosx.com/2021/11/the-unexpected-return-of-javascript-for-automation/">Original</a>
    
    <div id="readability-page-1" class="page"><article id="post-1703">
	
	<!-- .entry-header -->

	<div>
		
<p>Monterey has deprecated the pre-installed python on macOS. To be precise, built-in python has been deprecated since macOS Catalina, but Monterey will now throw up dialogs warning the user that an app or process using built-in python needs to be updated.</p>



<p>I and others have written about this before:</p>



<ul><li><a href="https://scriptingosx.com/2021/11/monterey-python-and-free-disk-space/">Monterey, python, and free disk space – Scripting OS X</a></li><li><a href="https://macmule.com/2021/10/25/macos-monterey-prompt-needs-to-be-updated/">macOS Monterey prompt: “…..” needs to be updated – Ben Toms</a></li><li><a href="https://grahamrpugh.com/2021/10/25/monterey-disable-python-2-deprecation-warnings.html">MDM custom preference to disable python 2 deprecation popups – Graham R Pugh</a></li><li><a href="https://scriptingosx.com/2020/02/wrangling-pythons/">Wrangling Pythons – Scripting OS X</a></li><li><a href="https://scriptingosx.com/2019/09/get-current-user-in-shell-scripts-on-macos/">Get Current User in Shell Scripts on macOS – Scripting OS X</a></li></ul>



<p>So far, I have recommended to build native Swift command line tools to replace python calls. However, from discussions in MacAdmins Slack, a new option has emerged. Most of the credit for popularizing and explaining this goes to @Pico (<a href="https://twitter.com/randomapps">@RandomApps</a> on Twitter) in the #bash and #scripting channels.</p>



<h2>(Re-)Introducing JavaScript for Automation</h2>



<p>AppleScript has been part of macOS since System 7.1. In the late nineties, there was concern that it wouldn’t make the transition to Mac OS X, but AppleScript made the jump and has happily co-existed with the Terminal and shell scripting as an automation tool on macOS. AppleScript has a very distinct set of strengths (interapplication communication) and weaknesses (awkward syntax and inconsitent application functionality and dictionaries) but it has been serving its purpose well for many users.</p>



<div><figure><a href="https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?ssl=1"><img data-attachment-id="1704" data-permalink="https://scriptingosx.com/2021/11/the-unexpected-return-of-javascript-for-automation/automator/" data-orig-file="https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?fit=1024%2C1024&amp;ssl=1" data-orig-size="1024,1024" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="automator" data-image-description="" data-image-caption="" data-medium-file="https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?fit=300%2C300&amp;ssl=1" data-large-file="https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?fit=660%2C660&amp;ssl=1" loading="lazy" src="https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?resize=256%2C256&amp;ssl=1" alt="" width="256" height="256" data-recalc-dims="1" data-lazy-srcset="https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?w=1024&amp;ssl=1 1024w, https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?resize=300%2C300&amp;ssl=1 300w, https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?resize=150%2C150&amp;ssl=1 150w, https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?resize=768%2C768&amp;ssl=1 768w" data-lazy-sizes="(max-width: 256px) 100vw, 256px" data-lazy-src="https://i2.wp.com/scriptingosx.com/wp-content/uploads/2021/11/automator.png?resize=256%2C256&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>



<p>With Mac OS X 10.4 Tiger, Apple introduced Automator, which provided a neat UI to put together workflows. Much of Automator was based on AppleScript and users expected a more and improved AppleScript support because of that going forward. Instead, we saw AppleScript’s support from Apple and third parties slowly wane over the years.</p>



<p>AppleScript is stil very much present and functional in recent versions of macOS. It just seems like it hasn’t gotten much love over the last decade or so. Now that <a href="https://support.apple.com/guide/shortcuts-mac/welcome/mac">Shortcuts</a> has made the jump from iOS, there may be <a href="https://mjtsai.com/blog/2021/11/01/applescript-much-faster-in-monterey/">hope for another revival?</a></p>



<p>The last major changes to AppleScript came with Mavericks and Yosemite. Mavericks (10.9) included a JavaScript syntax for the Open Scripting Architecture (OSA), which is the underlying framework for all AppleScript functionality. Apple called this “<a href="https://developer.apple.com/library/archive/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/Introduction.html#//apple_r">JavaScript for Automation</a>.” Because this is a mouthful, it often abbreviated as JXA.</p>



<p>The JavaScript syntax and structure is more like a “real” programming language, than the “english language like” AppleScript. Once again this raised hopes that this could attract more scripters to AppleScript and thus encourage Apple and third party developers to support more AppleScript. But unfortunately, this positive re-inforcement did not take off.</p>



<p>Then Yosemite (10.10) made the AppleScript-Objective-C bridge available <em>everywhere</em> in AppleScript. Previously, the Objective-C bridge was only available when you built AppleScript GUI applications using AppleScript Studio in Xcode. The Objective-C bridge allows scripters to access most of the functionality of the system frameworks using AppleScript or JXA.</p>



<p>The coincidence of these two new features might be the reason that the ObjC bridge works much better using JXA than it does with the native AppleScript syntax.</p>



<h2>JXA and Python</h2>



<p>What does JXA and the AppleScriptObjC bridge have to do with the Python deprecation in modern macOS?</p>



<p>One reason python became so popular with MacAdmins, was that the pre-installed python on Mac OS X, also came with PyObjC, the Objective-C bridge for python. This allowed python to build applications with a native Cocoa UI, such as AutoDMG and Munki’s Managed Software Center. It also allowed for short python scripts or even one-liners to access system functionality that was otherwise unavailable to shell scripts.</p>



<p>For example, to determine if a preference setting in macOS is enforced with a configuration profile, you can use <a href="https://developer.apple.com/documentation/corefoundation/preferences_utilities?language=objc"><code>CFPreferences</code></a> or <a href="https://developer.apple.com/documentation/foundation/nsuserdefaults"><code>NSUserDefaults</code></a>.</p>



<p>Objective-C/C:</p>



<pre><code>BOOL isManaged =CFPreferencesAppValueIsForced(&#34;idleTime&#34;, &#34;com.apple.screensaver&#34;)</code></pre>



<p>Swift:</p>



<pre><code>let isManaged = CFPreferencesAppValueIsForced(&#34;idleTime&#34;, &#34;com.apple.screensaver&#34;)</code></pre>



<p>The Objective-C bridge allows to use this call from python, as well:</p>



<pre><code>from Foundation import CFPreferencesAppValueIsForced
isManaged=CFPreferencesAppValueIsForced(&#34;idleTime&#34;, &#34;com.apple.screensaver&#34;)</code></pre>



<p>With JXA and the AppleScriptObjC bridge, this will look like this:</p>



<pre><code>ObjC.import(&#39;Foundation&#39;);
$.CFPreferencesAppValueIsForced(ObjC.wrap(&#39;idleTime&#39;), ObjC.wrap(&#39;com.apple.screensaver&#39;))</code></pre>



<p>Now, this looks really simple, but working with <em>any</em> Objective-C bridge is always fraught with strange behaviors, inconsistencies and errors and the JXA ObjC implementation is no different.</p>



<p>For example, I wanted to change the code above to return the <em>value</em> of the setting instead of whether it is managed. The CFPreferences function for that is called <code>CFPreferencesCopyAppValue</code> and it works fine in Swift and Python, but using JXA it only ever returned <code>[object Ref]</code>. The easiest solution was to switch from the CFPreferences functions to using the <code>NSUserDefaults</code> object:</p>



<pre><code>ObjC.import(&#39;Foundation&#39;);
ObjC.unwrap($.NSUserDefaults.alloc.initWithSuiteName(&#39;$1&#39;).objectForKey(&#39;$2&#39;))</code></pre>



<p>(Once again many thanks to @Pico on the MacAdmins Slack for helping me and everyone else with this and also pointing out, that there is a different, somewhat complicated, <a href="https://macadmins.slack.com/archives/C4ENKD38A/p1636485897034900?thread_ts=1636360393.011100&amp;cid=C4ENKD38A">solution to the <code>object Ref</code> problem</a>. I will keep that one bookmarked for situations where there is no alternative Cocoa object.)</p>



<p>We used this to <a href="https://github.com/mvdbent/CIS-Script/pull/4">remove the python dependency</a> from <a href="https://github.com/mvdbent/CIS-Script">Mischa van der Bent’s CIS-Scripts</a>.</p>



<h2>JXA in shell scripts</h2>



<p>To call JXA from a shell script, you use the same <code>osascript</code> command as for normal AppleScript, but add the <code>-l</code> option option to switch the language to <code>JavaScript</code>:</p>



<pre><code>osascript -l JavaScript &lt;&lt; EndOfScript
     ObjC.import(&#39;Foundation&#39;);
    ObjC.unwrap($.NSUserDefaults.alloc.initWithSuiteName(&#39;idleTime&#39;).objectForKey(&#39;com.apple.screensaver&#39;))
EndOfScript</code></pre>



<p>For convenience, you can wrap calls like this in a shell function:</p>



<pre><code>function getPrefValue() { # $1: domain, $2: key
      osascript -l JavaScript &lt;&lt; EndOfScript
         ObjC.import(&#39;Foundation&#39;);
         ObjC.unwrap($.NSUserDefaults.alloc.initWithSuiteName(&#39;$1&#39;).objectForKey(&#39;$2&#39;))
 EndOfScript
 }

 function getPrefIsManaged() { # $1: domain, $2: key
     osascript -l JavaScript &lt;&lt; EndOfScript
     ObjC.import(&#39;Foundation&#39;)
     $.CFPreferencesAppValueIsForced(ObjC.wrap(&#39;$1&#39;), ObjC.wrap(&#39;$2&#39;))
EndOfScript
}

echo $(getPrefValue &#34;com.apple.screensaver&#34; &#34;idleTime&#34;)
# -&gt; actual value
echo $(getPrefIsManaged &#34;com.apple.screensaver&#34; &#34;idleTime&#34;)
# -&gt; true/false</code></pre>



<p>Note that the <code>$</code> character does <em>a lot</em> of work here. It does the shell variable substitution for the function arguments in the case of <code>$1</code> and <code>$2</code>. These are substituted <em>before</em> the here doc is piped into the <code>osascript</code> command. The <code>$.</code> at the beginning of the command is a shortcut where <code>$</code> stands in for the current application and serves as a root for all ObjC objects.</p>



<p>There is also a <code>$(…)</code> function in JXA which is short for <code>ObjC.unwrap(…)</code> but I would recommend against using that in combination with shell scripts as shell’s command substitution has the same syntax and would happen <em>before</em> the JavaScript is piped into <code>osascript</code>.</p>



<p>There is a <a href="https://github.com/JXA-Cookbook/JXA-Cookbook/wiki">GitHub wiki with more detailed documentation on using JXA</a>, and the <a href="https://github.com/JXA-Cookbook/JXA-Cookbook/wiki/Using-Objective-C-%28ObjC%29-with-JXA">JXA Objective-C bridge</a> in particular.</p>



<h2>JXA for management tasks</h2>



<p>I’ll be honest here and admit that working with JXA seems strange, inconsistent, and — in weird way — like a step backwards. Putting together <a href="https://scriptingosx.com/2021/11/monterey-python-and-free-disk-space/">a Command Line Tool written in Swift</a> feels like a much more <em>solid</em> (for lack of a better word) way of solving a problem.</p>



<p>However, the Swift binary command line tool has one huge downside: you have to install the binary on the client before you can use it in scripts and your management system. Now, as MacAdmins, we usually have all the tools and workflows available to install and manage software on the client. That’s <em>what we do.</em></p>



<p>On the other hand, I have encountered three situations (<a href="https://scriptingosx.com/swiftagain">set default browser</a>, <a href="https://scriptingosx.com/2021/11/monterey-python-and-free-disk-space/">get free disk space</a>, determine if a preference is managed) where I needed to replace some python code in the last few months and I would have no trouble finding a few more if I thought about it. Building, maintaining, and deploying a Swift CLI tool for each of these small tasks would add up to a lot of extra effort, both for me as the developer and any MacAdmin who wants to use the tools.</p>



<p>Alternatively, you can deploy and use a Python 3 runtime with PyObjC, like the <a href="https://github.com/macadmins/python">MacAdmins Python</a> and continue to use python scripts. That is a valid solution, especially when you use other tools built in python, like <a href="https://github.com/chilcote/outset">Outset</a> or <a href="https://github.com/homebysix/docklib#managed-python">docklib</a>. But it still adds a dependency that you have to install and maintain.</p>



<p>In addition to being extra work, it adds some burden to sharing your solutions with other MacAdmins. You can’t just simply say “here’s a script I use,” but you have to add “it depends on this runtime or tool, which you also have to install.</p>



<p>Dependencies add friction.</p>



<p>This is where JXA has an advantage. Since AppleScript and its Objective-C bridge are present on every Mac (and have been since 2014 when 10.10 was released) there is no extra tool to install and manage. You can “just share” scripts you build this way, and they will work on any Mac.</p>



<p>For example, I recently built <a href="https://scriptingosx.com/2021/11/monterey-python-and-free-disk-space/">a Swift command line tool to determine the free disk space</a>. You can download the pkg, upload it to your management system, deploy it on your clients and then use a script or extension attribute or fact or something like to report this value to your management system. Since there is a possibility that the command line tool is not yet installed when the script runs, you need to add some code to check for that. All-in-all, nothing here is terribly difficult or even a lot of work, but it adds up.</p>



<p>Instead you can use this script (sample code for a Jamf extension attribute):</p>



<pre><code>#!/bin/sh

freespace=$(/usr/bin/osascript -l JavaScript &lt;&lt; EndOfScript
    ObjC.import(&#39;Foundation&#39;)
    var freeSpaceBytesRef=Ref()
    $.NSURL.fileURLWithPath(&#39;/&#39;).getResourceValueForKeyError(freeSpaceBytesRef, &#39;NSURLVolumeAvailableCapacityForImportantUsageKey&#39;, null)
    ObjC.unwrap(freeSpaceBytesRef[0])
EndOfScript
)

echo &#34;&lt;result&gt;${freespace}&lt;/result&gt;&#34;</code></pre>



<p>Just take this and copy/paste it in the field for a Jamf Extension Attribute script and you will get the same same free disk space value as the Finder does. If you are running a different management solution, it shouldn’t be too difficult to adapt this script to work there.</p>



<p>The Swift tool is nice. Once it is deployed, there are some use cases where it could be useful to have a CLI tool available. But most of the time, the JXA code snippet will “do the job” with much less effort.</p>



<h3>Note on Swift scripts</h3>



<p>Some people will interject with “but you can <a href="https://github.com/scriptingosx/diskspace/pull/2">write scripts with a <code>swift</code> shebang</a>!” And they are correct. However, scripts with a <code>swift</code> shebang will <em>not</em> run on any Mac. They will only run with Xcode, or at least the Developer Command Line Tools, installed. And yes, I understand this is hard for developers to wrap their brains around, but most people don’t have or need Xcode installed.</p>



<p>When neither of these are installed yet, and your management system attempts to run a script with a <code>swift</code> shebang, it will prompt the user to install the Developer command line tools. This is obviously not a good user experience for a managed deployment.</p>



<p>As dependencies go, Xcode is a fairly gigantic installation. The Developer Command Line Tools much less so, but we are back in the realm of “install and manage a dependency.”</p>



<h2>Parsing JSON</h2>



<p>Another area where JXA is (not surprisingly) extremely useful is JSON parsing. There are no built-in tools in macOS for this so MacAdmins either have to install <a href="https://stedolan.github.io/jq/"><code>jq</code></a> or <a href="https://github.com/ABridoux/scout"><code>scout</code></a> or fall back to parsing the text with <code>sed</code> or <code>awk</code>. Since JSON <em>is</em> native JavaScript,<a href="https://www.macblog.org/posts/how-to-parse-json-macos-command-line/"> JXA “just works” with it.</a></p>



<p>For example <a href="https://danpetrov.xyz/macos/2021/11/14/analysing-network-quality-macos.html">the new <code>networkQuality</code> command line tool in Monterey</a> has a <code>-c</code> option which returns JSON data instead of printing a table to the screen. In a shell script, we can capture the JSON in a variable and substitute it into a JXA script:</p>



<pre><code>#!/bin/sh

json=$(networkQuality -c)

osascript -l JavaScript &lt;&lt; EndOfScript
    var result=$json
    console.log(&#34;Download:  &#34; + result.dl_throughput)
    console.log(&#34;Upload:    &#34; + result.ul_throughput)
EndOfScript</code></pre>



<p><strong>Update: (2021-11-24)</strong> <a href="https://paulgalow.com/how-to-work-with-json-api-data-in-macos-shell-scripts">Paul Galow points out</a> that this syntax might allow someone to inject code into my JavaScript. This would be especially problematic with MacAdmin scripts as those often run with root privileges. The way to avoid this injection is too parse the JSON data with <code>JSON.parse</code> : </p>



<pre>#!/bin/sh 

json=$(networkQuality -c) 

osascript -l JavaScript &lt;&lt; EndOfScript     
  var result=JSON.parse<code>(\`$json\`</code>)     
  console.log(&#34;Download:  &#34; + result.dl_throughput)     
  console.log(&#34;Upload:    &#34; + result.ul_throughput) 
EndOfScript</pre>



<p>(I am leaving the original code up there for comparison.)</p>



<h2>Conclusion</h2>



<p>After being overlooked for years, JXA now became noticeable again as a useful tool to replace python in MacAdmin scripts, without adding new dependencies. The syntax and implementation is inconsistent, buggy, and frustrating, but the same can be said about the PyObjC bridge, we are just used it. The community knowledge around the PyObjC bridge and solutions goes deeper.</p>



<p>However, as flawed as it is, JXA can be a simple replacement for the classic python “one-liners” to get data out of a macOS system framework. Other interesting use cases are being discovered, <a href="https://www.macblog.org/posts/how-to-parse-json-macos-command-line/">such as JSON parsing</a>. As such, JavaScript for Automation or JXA should be part of a MacAdmins tool chest.</p>

	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
