<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://proclamations.nebcorp-hias.com/sundries/hitman/">Original</a>
    <h1>Hitman: another fine essential sundry service from Nebcorp Heavy Industries and Sundries</h1>
    
    <div id="readability-page-1" class="page"><section>
            
<p>Recently, someone in a community I&#39;m part of asked the following:</p>
<blockquote>
<p>I was thinking about how we used to have website hit counters in the 2000s and I was wondering --
has anyone put a hit counter on your personal website?</p>
</blockquote>
<p>Some people had, it turns out, but many had not. Among the had-nots was me, and I decided to do
something about it. The bottom line up front is that you can see it in action right now at the
bottom of this very page, and if you want, check out the code
<a href="https://git.kittencollective.com/nebkor/hitman">here</a>; it&#39;s called Hitman!</p>
<h2 id="what-s-the-problem">What&#39;s the problem?</h2>
<p>Back in the day, there was basically only one way to have a website: you have a Linux box,
running the Apache webserver, with PHP enabled, and a MySQL database to hold state; this is your
classic LAPM stack, obviously.  If this is your website, adding a visible counter is trivial: you
just use PHP to do server side rendering of the count after a quick SQL query. And because this was
basically the only way to have a website, lots of &#34;website operators&#34; put hitcounters on their site,
because why not?</p>
<p>But this is the year 2024, and we do things differently these days. This blog, for example, is built
with a &#34;static site generator&#34; called <a href="https://www.getzola.org/">Zola</a>, which means that there&#39;s no
server side rendering, or any other kind of dynamic behavior from the backend. It&#39;s served by a
small Linux VPS that&#39;s running the <a href="https://caddyserver.com/">Caddy</a> webserver, and costs about five
bucks a month to run. If I wanted to have a hitcounter, I&#39;d have to do something non-traditional.</p>
<h2 id="what-s-the-solution">What&#39;s the solution?</h2>
<p>For me, it turned out to be a sidecar microservice for counting and reporting the hits. As usual
these days, my first instinct is to reach for <a href="https://docs.rs/axum/latest/axum/">Axum</a>, a framework
for building servers in Rust, and to use <a href="https://sqlite.org/">SQLite</a> for a database. Caddy proxies
all requests to the hit-counting URL to Hitman, which is listening only on localhost.</p>
<h3 id="that-sounds-simple">That sounds simple</h3>
<p>Ha ha, it does, doesn&#39;t it? And in the end, it actually kinda is. But there are a few nuances to
consider.</p>
<h3 id="privacy">Privacy</h3>
<p>The less I know the better, as far as I&#39;m concerned, and I didn&#39;t see any reason to know more than I
already did with this, but I&#39;d need to track the IP of the client that was doing the request in order to
de-duplicate views. Someone linked to <a href="https://herman.bearblog.dev/how-bear-does-analytics-with-css/">this
post</a> about how the author uses a
notional CSS load to register a hit, and also how they hash the IP with the date to keep the counts
down to one per IP per day. They&#39;re doing quite a bit more actual &#34;analytics&#34; than I&#39;m interested
in, but I liked the other idea. They mention scrubbing the hashes from their DB every night in order to
pre-emptively satisfy an overzealous GDPR regulator, but I had a better idea, which was to hash the
IP+date with a random number that is not disclosed, and is regenerated every time the server
restarts.</p>
<p>I wound up <a href="https://git.kittencollective.com/nebkor/hitman/src/commit/1617eae17448273114ca1b1d9277b3465986e9f1/src/main.rs#L79-L94">hashing with the date +
hour</a>,
along with the page, IP, and the secret. This buckets views to one per IP per page per hour, vs the
once per day from the bearblog.</p>
<h3 id="security">Security?</h3>
<p>I spent some time on this, but ultimately realized that there&#39;s</p>
<ul>
<li>not much I can do, but</li>
<li>not much they can do, either.</li>
</ul>
<p>The server <a href="https://git.kittencollective.com/nebkor/hitman/src/commit/1617eae17448273114ca1b1d9277b3465986e9f1/src/main.rs#L45-L48">rejects remote
origins</a>,
but the <code>Origin</code> headers can be trivially forged. On the other hand, the worst someone could do is
add a bunch of junk to my DB, and I don&#39;t care about the data that much; this is all just for
funsies, anyway!</p>
<p>Still, after writing this out, I realized that someone could send a bunch of junk slugs and hence
fill my disk from a single IP, so I <a href="https://git.kittencollective.com/nebkor/hitman/commit/89a985e96098731e5e8691fd84776c1592b6184b">added a check against a set of allowed
slugs</a>
to guard against that. Beyond that, I&#39;d need to start thinking about being robust against a targeted
and relatively sophisticated distributed attack, and it&#39;s definitely not worth it.</p>
<h2 id="the-front-end">The front end</h2>
<p>I mentioned that this blog is made using Zola, a static site generator. Zola has a built-in
templating system, so the <a href="https://git.kittencollective.com/nebkor/blog/commit/87afa418b239419f551459e9cc5e838f9fac7ed6">following
bit</a>
of HTML with inlined JavaScript is enough to register a hit and return the latest count:</p>
<pre data-lang="html"><code data-lang="html"><span>&lt;</span><span>div </span><span>class</span><span>=</span><span>hias-footer</span><span>&gt;
</span><span>    &lt;</span><span>p</span><span>&gt;There have been &lt;</span><span>span </span><span>id</span><span>=&#34;</span><span>hitman-count</span><span>&#34;&gt;no&lt;/</span><span>span</span><span>&gt; views of this page.&lt;/</span><span>p</span><span>&gt;
</span><span>&lt;/</span><span>div</span><span>&gt;
</span><span>
</span><span>&lt;</span><span>script </span><span>defer</span><span>&gt;
</span><span>    </span><span>const </span><span>hits </span><span>= document.</span><span>getElementById</span><span>(&#39;</span><span>hitman-count</span><span>&#39;);
</span><span>    </span><span>fetch</span><span>(&#34;</span><span>/hit/{{ page.slug }}</span><span>&#34;).</span><span>then</span><span>((resp) </span><span>=&gt; </span><span>{
</span><span>        </span><span>if </span><span>(</span><span>resp</span><span>.ok) {
</span><span>            </span><span>return </span><span>resp</span><span>.</span><span>text</span><span>();
</span><span>        } </span><span>else </span><span>{
</span><span>            </span><span>return </span><span>&#34;</span><span>I don&#39;t even know how many</span><span>&#34;;
</span><span>        }
</span><span>    }).</span><span>then</span><span>((data) </span><span>=&gt; </span><span>{
</span><span>        </span><span>hits</span><span>.innerHTML = </span><span>data</span><span>;
</span><span>    });
</span><span>&lt;/</span><span>script</span><span>&gt;
</span></code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>OK, all the pieces are laid out, but here&#39;s the actual setup on the backend:</p>
<h3 id="caddy">Caddy</h3>
<p>The Caddy configuration has the following:</p>
<pre><code><span>proclamations.nebcorp-hias.com {
</span><span>    handle /hit/* {
</span><span>        reverse_proxy localhost:5000
</span><span>    }
</span><span>    handle {
</span><span>        &lt;all the other routes on the site&gt;
</span><span>    }
</span><span>}
</span><span>
</span></code></pre>
<p>This means that requests to, eg, <code>https://proclamations.nebcorp-hias.com/hit/hitman</code> will register a
hit for this post, and return the number of views so far.</p>
<h3 id="systemd">systemd</h3>
<p>I created a system user for the service, <code>hitman</code>, with a homedir in <code>/var/lib/hitman</code>, and added
the following systemd unit file into <code>/etc/systemd/system/hitman.service</code>:</p>
<pre><code><span>Description=Hitman
</span><span>After=network.target network-online.target
</span><span>Requires=network-online.target
</span><span>
</span><span>[Service]
</span><span>Type=exec
</span><span>User=hitman
</span><span>Group=hitman
</span><span>ExecStart=/var/lib/hitman/hitman -e /var/lib/hitman/.env
</span><span>TimeoutStopSec=5s
</span><span>LimitNOFILE=1048576
</span><span>LimitNPROC=512
</span><span>PrivateTmp=true
</span><span>ProtectSystem=full
</span><span>
</span><span>[Install]
</span><span>WantedBy=multi-user.target
</span></code></pre>
<p>This will ensure the hitman service is running after boot, and will be restarted if it crashes:</p>
<pre><code><span>$ systemctl status hitman.service
</span><span>● hitman.service - Hitman
</span><span>     Loaded: loaded (/etc/systemd/system/hitman.service; enabled; preset: enabled)
</span><span>     Active: active (running) since Sun 2024-03-31 12:12:14 PDT; 4h 0min ago
</span><span>   Main PID: 46338 (hitman)
</span><span>      Tasks: 2 (limit: 1018)
</span><span>     Memory: 948.0K
</span><span>        CPU: 53ms
</span><span>     CGroup: /system.slice/hitman.service
</span><span>             └─46338 /var/lib/hitman/hitman -e /var/lib/hitman/.env
</span></code></pre>
<h3 id="hitman">Hitman</h3>
<p>Inside the <code>/var/lib/hitman</code> directory there&#39;s a <code>.env</code> file with the following content:</p>
<pre><code><span>DATABASE_URL=sqlite:///${HOME}/.hitman.db
</span><span>DATABASE_FILE=${HOME}/.hitman.db
</span><span>LISTENING_ADDR=127.0.0.1
</span><span>LISTENING_PORT=5000
</span><span>HITMAN_ORIGIN=https://proclamations.nebcorp-hias.com
</span></code></pre>

<p>When I got this working, a friend said, &#34;Drat, that means I need to follow through on my goal to
write a little web-ring server.&#34; Something like two hours later, she had <a href="https://erikarow.land/notes/gleam-webring">a working
webring</a>, and indeed, if you look at the bottom of this
very page, you&#39;ll see the webring links; as she says, this Web 1.0 stuff is fun!</p>
<hr/>



        </section></div>
  </body>
</html>
