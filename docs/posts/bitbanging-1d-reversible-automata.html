<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://richiejp.com/1d-reversible-automata">Original</a>
    <h1>Bitbanging 1D Reversible Automata</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section id="one-dimensional-reversible-automata">
    <h2>One Dimensional Reversible Automata</h2>
    <p>I created a <a href="https://github.com/gfxprim/automata">demo</a> for the <a href="http://gfxprim.ucw.cz/index.html">GFXPrim</a> library. It
    implements and displays a nearest-neighbor, one-dimensional, binary
    cell automata. Additionally it implements a reversible automata,
    which is almost identical except for a small change to make it
    reversible. The automata is displayed over time in two dimensions,
    time travels from top to bottom. Although in the reversible case
    time could be played backwards.</p>
    <figure>
    <img src="https://richiejp.com/73r.png" alt="A reversible rendition of rule 73"/>
    <figcaption aria-hidden="true">A reversible rendition of rule
    73</figcaption>
    </figure>
    <p>The automata works as follows:</p>
    <ul>
    <li>Each cell has a state, which is on or off, black or white,
    boolean etc.</li>
    <li>At each time step, the state of a cell in the next step is
    chosen by a rule.</li>
    <li>The rule looks at a cell’s current value and the values of its
    left and right neighbors.</li>
    <li>There are <span>2<sup>3</sup> = 8</span>
    possible state combinations (patterns) for 3 binary cells.</li>
    <li>A rule states which patterns result in a black cell in the next
    time step.</li>
    <li>There are <span>2<sup>8</sup> = 256</span>
    possible rules. That is, 256 unique combinations of patterns.</li>
    </ul>
    <figure>
    <img src="https://richiejp.com/105.png" alt="Rule 105"/>
    <figcaption aria-hidden="true">Rule 105</figcaption>
    </figure>
    <p>So a pattern is a 3 digit binary number, where each digit
    corresponds to a cell. The middle digit is the center cell, the high
    order bit the left cell, the low order bit the right cell. A rule
    can be display by showing a row of patterns and a row of next
    states.</p>
    <table>
    <thead>
    <tr>
    <th>111</th>
    <th>110</th>
    <th>101</th>
    <th>100</th>
    <th>011</th>
    <th>010</th>
    <th>001</th>
    <th>000</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    </tr>
    </tbody>
    </table>
    <p>Above is rule <code>110</code>, <code>0x6e</code> or
    <code>01101110</code>. It essentially says to match patterns
    <code>110</code>, <code>101</code>, <code>011</code>,
    <code>010</code>, <code>001</code>. Where a pattern match results in
    the cell being set to 1 at the next time step. If no pattern is
    matched or equivalently, an inactive pattern is matched, then the
    cell will be set to 0.</p>
    <p>Again note that each pattern resembles a 3bit binary number. Also
    the values of the active patterns resemble an 8bit binary number. We
    can use this to perform efficient matching of the patterns using
    binary operations.</p>
    <p>Let’s assume our CPU natively operates on 64bit integers (called
    <em>words</em>). We can pack a 64 cell automata into a single 64bit
    integer. Each bit corresponds to a cell. If a bit is <code>1</code>
    then it is a black cell and <code>0</code> for white. In this case
    we are using integers as bit fields. We don’t care about the integer
    number the bits can represent.</p>
    <figure>
    <img src="https://richiejp.com/94r.png" alt="Rule 94 Reversible"/>
    <figcaption aria-hidden="true">Rule 94 Reversible</figcaption>
    </figure>
    <p>The CPU can perform bitwise operations on all 64bits in parallel
    and without branching. This means we can perform a single operation
    64 times in parallel.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
    <p>If we <em>rotate</em> (wrapped <code>&gt;&gt;</code><a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>) all bits to the right by one,
    then we get a new integer where the left neighbor of a bit is now in
    its position. Likewise if we shift all bits to the left, then we get
    an integer representing the right neighbors. This gives us 3
    integers where the left, center and right bits are in the same
    position. For example, using only 8bits:</p>
    <table>
    <tbody>
    <tr>
    <td>left:</td>
    <td>0100 1011</td>
    <td><code>&gt;&gt;</code></td>
    </tr>
    <tr>
    <td>center:</td>
    <td>1001 0110</td>
    <td></td>
    </tr>
    <tr>
    <td>right:</td>
    <td>0010 1101</td>
    <td><code>&lt;&lt;</code></td>
    </tr>
    </tbody>
    </table>
    <p>Each pattern can be represented as a 3bit number, plus a 4th bit
    to say whether it is active in a given rule. As we want to operate
    on all 64bits at once in the left, right and center bit fields. We
    can generate 64bit long <em>masks</em> from the value of each bit in
    a given pattern.</p>
    <p>So if we have a pattern where the left cell should be one, then
    we can create a 64bit mask of <em>all</em> ones. If it should be
    zero, then all zeroes. Likewise for the center and right cells. The
    masks can be <em>xor’ed</em><a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> (<code>^</code>)
    with the corresponding cell fields to show if no match occurred.
    That is, if the pattern is one and the cell is zero or the cell is
    one and the pattern is zero. We can invert this (<code>~</code>) to
    give one when a match occurs.</p>
    <p>To see whether all components (left, right, center) of a pattern
    matches we can bitwise <em>and</em> (<code>&amp;</code>) them
    together. We can then bitwise <em>or</em><a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>
    (<code>|</code>) the result of the pattern matches together to
    produce the final values.</p>
    <figure>
    <img src="https://richiejp.com/193.jpg" alt="Rule 193, inverted rule 110"/>
    <figcaption aria-hidden="true">Rule 193, inverted rule
    110</figcaption>
    </figure>
    <p>If we wish to operate on an automata larger than 64 cells, then
    we can combine multiple integers into an array. After performing the
    left and right shifts, we get the high or low bit from the next or
    previous integers in the array. Then set the low and high bits of
    the right and left bit fields. In other words we chain them together
    using the end bits of the left and right bit fields.</p>
    <p>For illustration purposes, below is the <em>kernel</em> of the
    the automata algorithm.</p>
    <div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>/* If bit n is 1 then make all bits 1 otherwise 0 */</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>#define BIT_TO_MAX</span><span>(</span><span>b</span><span>,</span><span> n</span><span>)</span><span> </span><span>(((</span><span>b </span><span>&gt;&gt;</span><span> n</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>1</span><span>)</span><span> </span><span>*</span><span> </span><span>~</span><span>0</span><span>UL</span><span>)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>/* Numeric representation of the current update rule */</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>uint8_t</span> rule <span>=</span> <span>110</span><span>;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span>/* Apply the current rule to a 64bit segment of a row */</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>inline</span> <span>uint64_t</span> ca1d_rule_apply<span>(</span><span>uint64_t</span> c_prev<span>,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                                       <span>uint64_t</span> c<span>,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                                       <span>uint64_t</span> c_next<span>,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                                       <span>uint64_t</span> c_prev_step<span>)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span>int</span> i<span>;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span>/* These are wrapping shifts when c_prev == c or c_next == c */</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span>uint64_t</span> l <span>=</span> <span>(</span>c <span>&gt;&gt;</span> <span>1</span><span>)</span> <span>^</span> <span>(</span>c_prev <span>&lt;&lt;</span> <span>63</span><span>);</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span>uint64_t</span> r <span>=</span> <span>(</span>c <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>^</span> <span>(</span>c_next <span>&gt;&gt;</span> <span>63</span><span>);</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span>uint64_t</span> c_next_step <span>=</span> <span>0</span><span>;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> i<span>++)</span> <span>{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span>uint64_t</span> active <span>=</span> BIT_TO_MAX<span>(</span>rule<span>,</span> i<span>);</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span>uint64_t</span> left   <span>=</span> BIT_TO_MAX<span>(</span>i<span>,</span> <span>2</span><span>);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span>uint64_t</span> center <span>=</span> BIT_TO_MAX<span>(</span>i<span>,</span> <span>1</span><span>);</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span>uint64_t</span> right  <span>=</span> BIT_TO_MAX<span>(</span>i<span>,</span> <span>0</span><span>);</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        c_next_step <span>|=</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            active <span>&amp;</span> <span>~(</span>left <span>^</span> l<span>)</span> <span>&amp;</span> <span>~(</span>center <span>^</span> c<span>)</span> <span>&amp;</span> <span>~(</span>right <span>^</span> r<span>);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span>/* The automata becomes reversible when we use c_prev_state */</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span>return</span> c_next_step <span>^</span> c_prev_step<span>;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
    <p>To make the automata “reversible” an extra step can be added. We
    look at a cell’s previous (in addition to the current, left and
    right) and if it was one then <em>invert</em> the next value. This
    is equivalent to xor’ring the previous value with the next.</p>
    <figure>
    <img src="https://richiejp.com/193r.jpg" alt="Rule 193 again, but reversible"/>
    <figcaption aria-hidden="true">Rule 193 again, but
    reversible</figcaption>
    </figure>
    <p>It is not entirely clear to me what the mathematical implications
    are of being reversible. However it is important to physics and
    makes some really cool patterns which mimic nature. Also entropy and
    the second rule of themodynamics, yada, yada…</p>
    <p>The automata definition is taken from Stephen Wolfram’s “A new
    kind of science”. He proposes at least one <em>obvious</em><a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a> C implementation using arrays of
    cells. He also provides a table of binary expressions for each rule.
    E.g. rule 90 reduces to just the <code>l^r</code> binary expression.
    It may be possible for the compiler to automatically reduce my
    implementation to these minimal expressions.</p>
    <p>To see why, let’s consider rule 90 for each pattern.</p>
    <figure>
    <img src="https://richiejp.com/90r.png" alt="Rule 90 reversible"/>
    <figcaption aria-hidden="true">Rule 90 reversible</figcaption>
    </figure>
    <table>
    <thead>
    <tr>
    <th>111</th>
    <th>110</th>
    <th>101</th>
    <th>100</th>
    <th>011</th>
    <th>010</th>
    <th>001</th>
    <th>000</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    </tr>
    </tbody>
    </table>
    <p><span>01011010 = 90</span></p>
    <p>First for pattern <code>000</code>.</p>
    <div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  active <span>&amp;</span> <span>~(</span>left <span>^</span> l<span>)</span> <span>&amp;</span> <span>~(</span>center <span>^</span> c<span>)</span> <span>&amp;</span> <span>~(</span>right <span>^</span> r<span>);</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>=</span> <span>0</span> <span>&amp;</span> <span>~(</span><span>0</span> <span>^</span> l<span>)</span> <span>&amp;</span> <span>~(</span><span>0</span> <span>^</span> c<span>)</span> <span>&amp;</span> <span>~(</span><span>0</span> <span>^</span> r<span>);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>=</span> <span>0.</span>`</span></code></pre></div>
    <p>Active is zero so the whole line reduces to zero. Now for
    <code>001</code>. Note that <code>1</code> here actually means
    <code>~0UL</code>, that is 64bit integer max.</p>
    <div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>   <span>1</span> <span>&amp;</span> <span>~(</span><span>0</span> <span>^</span> l<span>)</span> <span>&amp;</span> <span>~(</span><span>0</span> <span>^</span> c<span>)</span> <span>&amp;</span> <span>~(</span><span>1</span> <span>^</span> r<span>);</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>=</span> <span>~</span>l <span>&amp;</span> <span>~</span>c <span>&amp;</span> r<span>.</span></span></code></pre></div>
    <p>As expected pattern <code>001</code> matches
    <code>l=0, c=0, r=1</code>. Let’s just list the remaining patterns
    or’ed together in their reduced state. Then reduce that further.
    Note that the <code>for</code> loop in <code>ca1d_rule_apply</code>
    will be <em>unrolled</em> by the compiler when optimising for
    performance. It’s also quite clear that <code>c_next_step</code> is
    dependant on an expression from the previous iteration or zero. So
    all the pattern match results will get or’ed together.</p>
    <div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  l <span>&amp;</span> c <span>&amp;</span> <span>~</span>r <span>|</span> l <span>&amp;</span> <span>~</span>c <span>&amp;</span> <span>~</span>r <span>|</span> <span>~</span>l <span>&amp;</span> c <span>&amp;</span> r <span>|</span> <span>~</span>l <span>&amp;</span> <span>~</span>c <span>&amp;</span> r<span>;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>=</span> l <span>&amp;</span> <span>~</span>r <span>|</span> <span>~</span>l <span>&amp;</span> r<span>;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span>=</span> l <span>^</span> r<span>.</span></span></code></pre></div>
    <p>See on the top row that
    <code>(l &amp; c &amp; ~r | l &amp; ~c &amp; ~r)</code> or’s
    together <code>c</code> and not <code>c</code>. So we can remove it.
    Then we get an expression equivalent to xor’ring <code>l</code> and
    <code>r</code>.</p>
    <p>In theory at least, the compiler can see that <code>rule</code>
    only has 256 values and create a reduced version of
    <code>ca1d_rule_apply</code> for each value. Whether it actually
    does is not of much practical concern when the rendering code is the
    bottle neck. However it’s interesting to see if the compiler can
    deduce the best solution or whether anything trips it up.</p>
    <p>Judging from the disassembly from
    <code>gcc -O3 -mcpu=native -mtune=native</code>, it may actually do
    this. Additionally it <em>vectorizes</em> the code packing four
    64bit ints at a time into 256bit registers and operating on those. I
    don’t know which part of the code it is vectorising or how. It’s
    possible that what I think is the rule being reduced is something
    related to vectorisation.</p>
    <figure>
    <img src="https://richiejp.com/210.png" alt="Rule 210"/>
    <figcaption aria-hidden="true">Rule 210</figcaption>
    </figure>
    <p>To render the automata we take the approach of iterating over
    each pixel in the image. We calculate which cell the pixel falls
    inside and set the color of the pixel to that of the cell. That’s
    it.</p>
    <div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>/* Draws a pixel */</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>inline</span> <span>void</span> shade_pixel<span>(</span>gp_pixmap <span>*</span>p<span>,</span> gp_coord x<span>,</span> gp_coord y<span>,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                               gp_pixel bg<span>,</span> gp_pixel fg<span>)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    gp_pixel px<span>;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span>size_t</span> i <span>=</span> <span>(</span>x <span>*</span> <span>(</span><span>64</span> <span>*</span> width<span>))</span> <span>/</span> p<span>-&gt;</span>w<span>;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span>size_t</span> j <span>=</span> <span>(</span>y <span>*</span> height<span>)</span> <span>/</span> p<span>-&gt;</span>h<span>;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span>size_t</span> k <span>=</span> <span>63</span> <span>-</span> <span>(</span>i <span>&amp;</span> <span>63</span><span>);</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span>uint64_t</span> c <span>=</span> steps<span>[</span>gp_matrix_idx<span>(</span>width<span>,</span> j<span>,</span> i <span>&gt;&gt;</span> <span>6</span><span>)];</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    c <span>=</span> BIT_TO_MAX<span>(</span>c<span>,</span> k<span>);</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    px <span>=</span> <span>(</span>fg <span>&amp;</span> c<span>)</span> <span>|</span> <span>(</span>bg <span>&amp;</span> <span>~</span>c<span>);</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    gp_putpixel_raw<span>(</span>p<span>,</span> x<span>,</span> y<span>,</span> px<span>);</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
    <p>GFXPrim makes drawing very simple. The above code is fast enough
    for my purpsoses, but a significant improvement can be had. Integer
    division is much slower than floating point multiplication on most
    newer CPUs. It’s actually much faster (2x at least) on my CPU to
    calculate a pair of ratios in floating point, then convert them back
    to integers.</p>
    <p>However, you may ask why we are even drawing on the CPU in the
    first place? This is because GFXPrim targets embedded systems with
    no graphics processor. Additionally the CPU may not even support
    floating point natively. So integer division may actually be faster
    in this case. Still better would be to limit the size of the pixmap
    to be <span>2<sup><em>x</em></sup></span> larger
    than the dimensions of the automata, where <span><em>x</em> ∈ ℕ</span> then we can use shifts
    instead of division.</p>
    <figure>
    <img src="https://richiejp.com/210r.png" alt="Rule 210 Reversible"/>
    <figcaption aria-hidden="true">Rule 210 Reversible</figcaption>
    </figure>
    <figure>
    <img src="https://richiejp.com/105r.png" alt="Rule 105 Reversible"/>
    <figcaption aria-hidden="true">Rule 105 Reversible</figcaption>
    </figure>
    </section>
    
  </div></div>
  </body>
</html>
