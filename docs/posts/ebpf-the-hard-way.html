<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://feyor.sh/blog/ebpf-the-hard-way/">Original</a>
    <h1>eBPF the Hard Way</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>A while back I was messing around with eBPF and I couldn’t find any good materials on using BPF <em>without</em> libbpf/LLVM/GCC (i.e. rawdogging bytecode), so here’s the resource I wished I had.</p>
<p>I’ll be using Linux version 6.18 in this post; eBPF moves pretty fast and the verifier gets smarter with every release, so the information in this post might be out of date when you read this.</p>
<p>In conjunction with this post, I would recommend reading the documentation (especially to supplement parts that might be confusing):</p>
<ul>
<li><a href="https://docs.kernel.org/bpf/standardization/instruction-set.html">BPF ISA reference</a></li>
<li><a href="https://docs.kernel.org/userspace-api/ebpf/syscall.html">BPF syscall reference</a></li>
<li><a href="https://docs.kernel.org/bpf/btf.html">BTF reference</a></li>
<li><a href="https://docs.ebpf.io/linux/">ebpf.io docs</a> (for maps, program types, helpers/KFuncs)</li>
</ul>
<h2 id="ebpf-hello-world">eBPF Hello World</h2>
<p>Linux exposes eBPF functionality to user space through the <kbd>bpf</kbd> syscall, whose functionality is split into several subcommands.</p>
<p>The basic flow of eBPF is to create an array of eBPF bytecode instructions, pass it to the <code>BPF_PROG_LOAD</code> subcommand along with a program type (e.g. socket filter), and then attach it to the corresponding resource (like a socket or a kprobe).</p>






  
  
    
    
    
  
  
    

  
  
    




  






<details open="">
  
  <summary>Zig</summary>
  
  
  <div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> std <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);
</span></span><span><span>
</span></span><span><span><span>const</span> linux <span>=</span> std.os.linux;
</span></span><span><span><span>const</span> posix <span>=</span> std.posix;
</span></span><span><span><span>const</span> BPF <span>=</span> linux.BPF;
</span></span><span><span><span>const</span> AF <span>=</span> linux.AF;
</span></span><span><span><span>const</span> SOCK <span>=</span> linux.SOCK;
</span></span><span><span><span>const</span> SOL <span>=</span> linux.SOL;
</span></span><span><span><span>const</span> SO <span>=</span> linux.SO;
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> main() <span>!</span><span>void</span> {
</span></span><span><span>    <span>const</span> insns <span>=</span> [_]BPF.Insn{
</span></span><span><span>        .mov(.r0, <span>4</span>),
</span></span><span><span>        .exit(),
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>var</span> verifier_log<span>:</span> [<span>0x10000</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>var</span> log <span>=</span> BPF.Log{ .buf <span>=</span> <span>&amp;</span>verifier_log, .level <span>=</span> <span>2</span> };
</span></span><span><span>    <span>const</span> progfd <span>=</span> <span>try</span> BPF.prog_load(.socket_filter, <span>&amp;</span>insns, <span>&amp;</span>log, <span>&#34;GPL v2&#34;</span><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, <span>0</span>, <span>0</span>);
</span></span><span><span>
</span></span><span><span>    std.debug.print(<span>&#34;BPF Verifier output:</span><span>\n</span><span>{s}&#34;</span>, .{std.mem.sliceTo(<span>&amp;</span>verifier_log, <span>0</span>)});
</span></span><span><span>
</span></span><span><span>    <span>var</span> socks<span>:</span> [<span>2</span>]linux.fd_t <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>switch</span> (posix.errno(linux.socketpair(AF.UNIX, SOCK.DGRAM, <span>0</span>, <span>&amp;</span>socks))) {
</span></span><span><span>        .SUCCESS <span>=&gt;</span> {},
</span></span><span><span>        <span>else</span> <span>=&gt;</span> <span>|</span>e<span>|</span> <span>return</span> posix.unexpectedErrno(e),
</span></span><span><span>    }
</span></span><span><span>    <span>switch</span> (posix.errno(linux.setsockopt(socks[<span>0</span>], SOL.SOCKET, SO.ATTACH_BPF, std.mem.asBytes(<span>&amp;</span>progfd), <span>4</span>))) {
</span></span><span><span>        .SUCCESS <span>=&gt;</span> {},
</span></span><span><span>        <span>else</span> <span>=&gt;</span> <span>|</span>e<span>|</span> <span>return</span> posix.unexpectedErrno(e),
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>const</span> input <span>=</span> <span>&#34;Hello&#34;</span>;
</span></span><span><span>    _ <span>=</span> <span>try</span> posix.write(socks[<span>1</span>], input);
</span></span><span><span>
</span></span><span><span>    <span>var</span> buf<span>:</span> [input.len]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>const</span> n_read <span>=</span> <span>try</span> posix.read(socks[<span>0</span>], <span>&amp;</span>buf);
</span></span><span><span>
</span></span><span><span>    std.log.info(<span>&#34;Sent &#39;{s}&#39;, received &#39;{s}&#39;&#34;</span>, .{ input, buf[<span>0</span>..n_read] });
</span></span><span><span>}</span></span></code></pre></div>
</details>






  
  
    

  
  
    









<div><pre tabindex="0"><code data-lang="text"><span><span>BPF Verifier output:
</span></span><span><span>func#0 @0
</span></span><span><span>Live regs before insn:
</span></span><span><span>      0: .......... (b7) r0 = 4
</span></span><span><span>      1: 0......... (95) exit
</span></span><span><span>0: R1=ctx() R10=fp0
</span></span><span><span>0: (b7) r0 = 4                        ; R0=4
</span></span><span><span>1: (95) exit
</span></span><span><span>processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0
</span></span><span><span>info: Sent &#39;Hello&#39;, received &#39;Hell&#39;</span></span></code></pre></div>


<p>A socket filter is the OG type of eBPF program (and the namesake for BPF), but in addition to high performance packet filtering, eBPF can be used for syscall tracing, perf counter monitoring, security policy enforcement, and everything in between (<code>BPF_PROG_TYPE_XDP</code> programs can even be offloaded to run directly on the NIC, bypassing the kernel entirely<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>).</p>
<p>Now is a good time to mention that there are many restrictions on how unprivileged users (those without <code>CAP_SYS_ADMIN</code> or <code>CAP_BPF</code>) can interact with eBPF—as there should be, because a verified eBPF program runs with more or less the same privileges as a kernel module.
The restrictions that I know of (not exhaustive) are as follows:</p>
<ul>
<li>Programs are limited to 4096 instructions</li>
<li>There are <a href="https://elixir.bootlin.com/linux/v6.18.6/source/include/linux/bpf_types.h">79</a> types of eBPF programs<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>, but regular users are only allowed to use socket filters and cgroup socket buffers
<ul>
<li>Even for programs with <code>CAP_BPF</code>, many program types are gated behind <a href="https://elixir.bootlin.com/linux/v6.18.6/source/kernel/bpf/syscall.c#L2775"><code>CAP_NET_ADMIN</code></a> and/or <a href="https://elixir.bootlin.com/linux/v6.18.6/source/kernel/bpf/syscall.c#L2806"><code>CAP_PERFMON</code></a></li>
</ul>
</li>
<li>No subprograms (i.e. <kbd>static</kbd> functions)</li>
<li>No back edges (and consequently no loops)</li>
<li>No <a href="https://docs.ebpf.io/linux/concepts/kfuncs/">KFuncs</a></li>
<li><a href="https://elixir.bootlin.com/linux/v6.18.6/source/kernel/bpf/helpers.c#L1988">Most</a> eBPF helpers are off-limits</li>
<li>Sanitation
<ul>
<li>Arithmetic with constant values in registers is changed to use those constants directly (ALU sanitation)<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></li>
<li>Dead code is turned into <kbd>ja -1</kbd> to force either an infinite loop or exit instead of potentially executing beyond the bounds of the program</li>
</ul>
</li>
</ul>
<p>Clearly a lot of the more interesting stuff is beyond the reach of unprivileged users, so I will henceforth be assuming that our process has <code>CAP_BPF</code>, <code>CAP_NET_ADMIN</code> and <code>CAP_PERFMON</code> (although not root).</p>
<h2 id="passing-data-between-kernel-and-user-space">Passing data between kernel and user space</h2>
<p>eBPF maps are data structures used for sharing data between eBPF programs and user space (or other eBPF programs).
Contrary to the name, there are more types of eBPF maps than just hashmaps, and eBPF maps are also used for other purposes like storing string constants.</p>
<p>To demonstrate usage of eBPF maps, let’s write a simple eBPF program that drops a packet if it contains the substring “foobar”.</p>
<p>The <kbd>strncmp</kbd> helper function looks like it could be useful, but it’s a little unclear what the eBPF equivalent of a <span data-lang="c"><code>char *</code></span> is.
Let’s check the source:</p>





  
  
    

  
  
    









<details open="">
  
  <summary>
  
  </summary>
  <div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>584
</span><span>585
</span><span>586
</span><span>587
</span><span>588
</span><span>589
</span><span>590
</span><span>591
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>const</span> <span>struct</span> bpf_func_proto bpf_strncmp_proto <span>=</span> {
</span></span><span><span>	.func       <span>=</span> bpf_strncmp,
</span></span><span><span>	.gpl_only   <span>=</span> <span>false</span>,
</span></span><span><span>	.ret_type   <span>=</span> RET_INTEGER,
</span></span><span><span>	.arg1_type  <span>=</span> ARG_PTR_TO_MEM <span>|</span> MEM_RDONLY,
</span></span><span><span>	.arg2_type  <span>=</span> ARG_CONST_SIZE,
</span></span><span><span>	.arg3_type  <span>=</span> ARG_PTR_TO_CONST_STR,
</span></span><span><span>};</span></span></code></pre></td></tr></tbody></table>
</div>
</div>
</details>

<p>Arguments 1 and 2 are self-explanatory, but what about argument 3?
Further inspection reveals that <code>ARG_PTR_TO_CONST_STR</code> is checked by the function <kbd>check_reg_const_str</kbd>, which ensures that a register points to an element (a null-terminated string) of a read-only eBPF map.</p>
<p>Here’s how we’ll create such a map:</p>






  
  
    

  
  
    









<details open="">
  
  <summary>Zig</summary>
  
  
  <div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span> bpf_string_map(str<span>:</span> [<span>:</span><span>0</span>]<span>const</span> <span>u8</span>) <span>!</span>posix.fd_t {
</span></span><span><span>    <span>var</span> attr <span>=</span> BPF.Attr{
</span></span><span><span>        .map_create <span>=</span> std.mem.zeroes(BPF.MapCreateAttr),
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    attr.map_create.map_type <span>=</span> <span>@intFromEnum</span>(BPF.MapType.array);
</span></span><span><span>    attr.map_create.key_size <span>=</span> <span>@sizeOf</span>(<span>i32</span>);
</span></span><span><span>    attr.map_create.value_size <span>=</span> <span>@sizeOf</span>(<span>u64</span>);
</span></span><span><span>    attr.map_create.max_entries <span>=</span> <span>1</span>;
</span></span><span><span>    <span>// make this map read-only from the ebpf program
</span></span></span><span><span><span></span>    attr.map_create.map_flags <span>=</span> BPF.BPF_F_RDONLY_PROG;
</span></span><span><span>
</span></span><span><span>    <span>const</span> rc <span>=</span> linux.bpf(.map_create, <span>&amp;</span>attr, <span>@sizeOf</span>(BPF.MapCreateAttr));
</span></span><span><span>    <span>const</span> fd<span>:</span> posix.fd_t <span>=</span> <span>switch</span> (posix.errno(rc)) {
</span></span><span><span>        .SUCCESS <span>=&gt;</span> <span>@intCast</span>(rc),
</span></span><span><span>        .INVAL <span>=&gt;</span> <span>return</span> <span>error</span>.MapTypeOrAttrInvalid,
</span></span><span><span>        .NOMEM <span>=&gt;</span> <span>return</span> <span>error</span>.SystemResources,
</span></span><span><span>        .PERM <span>=&gt;</span> <span>return</span> <span>error</span>.AccessDenied,
</span></span><span><span>        <span>else</span> <span>=&gt;</span> <span>|</span>err<span>|</span> <span>return</span> posix.unexpectedErrno(err),
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>try</span> BPF.map_update_elem(fd, <span>&amp;</span>std.mem.toBytes(<span>@as</span>(<span>i32</span>, <span>0</span>)), str, BPF.ANY);
</span></span><span><span>
</span></span><span><span>    attr <span>=</span> BPF.Attr{
</span></span><span><span>        .map_elem <span>=</span> std.mem.zeroes(BPF.MapElemAttr),
</span></span><span><span>    };
</span></span><span><span>    attr.map_elem.map_fd <span>=</span> fd;
</span></span><span><span>    <span>// make this map read-only from userspace
</span></span></span><span><span><span></span>    <span>try</span> <span>switch</span> (posix.errno(linux.bpf(.map_freeze, <span>&amp;</span>attr, <span>@sizeOf</span>(BPF.MapElemAttr)))) {
</span></span><span><span>        .SUCCESS <span>=&gt;</span> {},
</span></span><span><span>        <span>else</span> <span>=&gt;</span> <span>|</span>err<span>|</span> posix.unexpectedErrno(err),
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>return</span> fd;
</span></span><span><span>}</span></span></code></pre></div>
</details>

<p>Now we can iterate over the packet data one byte at a time, returning <code>DROP</code> if <kbd>strncmp</kbd> returns 0.</p>






  
  
    

  
  
    









<details open="">
  
  <summary>Zig</summary>
  
  
  <div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> SK <span>=</span> <span>enum</span>(<span>i32</span>) {
</span></span><span><span>    DROP <span>=</span> <span>0</span>,
</span></span><span><span>    PASS,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>const</span> mapfd <span>=</span> <span>try</span> bpf_string_map(<span>&#34;foobar&#34;</span>);
</span></span><span><span>
</span></span><span><span><span>const</span> insns <span>=</span> [_]BPF.Insn{
</span></span><span><span>    .mov(.r6, .r1),
</span></span><span><span>    .stx(.double_word, .r10, <span>-</span><span>0x8</span>, .r1),
</span></span><span><span>    .st(.double_word, .r10, <span>-</span><span>0x10</span>, <span>0</span>),
</span></span><span><span>
</span></span><span><span>    <span>// return if packet_len &lt; 6 bytes
</span></span></span><span><span><span></span>    .ldx(.double_word, .r1, .r10, <span>-</span><span>0x8</span>),
</span></span><span><span>    .ldx(.word, .r7, .r1, <span>0</span>),
</span></span><span><span>    .jmp(.jge, .r7, <span>6</span>, <span>2</span>),
</span></span><span><span>    .mov(.r0, <span>@intFromEnum</span>(SK.PASS)),
</span></span><span><span>    .exit(),
</span></span><span><span>
</span></span><span><span>    <span>// load &#34;foobar&#34; into r9
</span></span></span><span><span><span></span>    .ld_map_fd1(.r1, mapfd),
</span></span><span><span>    .ld_map_fd2(mapfd),
</span></span><span><span>    .mov(.r2, .r10),
</span></span><span><span>    .add(.r2, <span>-</span><span>0x10</span>),
</span></span><span><span>    .call(.map_lookup_elem),
</span></span><span><span>    .jmp(.jne, .r0, <span>0</span>, <span>2</span>),
</span></span><span><span>    .mov(.r0, <span>@intFromEnum</span>(SK.DROP)),
</span></span><span><span>    .exit(),
</span></span><span><span>    .mov(.r9, .r0),
</span></span><span><span>
</span></span><span><span>    <span>// begin checking for &#34;foobar&#34;
</span></span></span><span><span><span></span>    .mov(.r8, <span>0</span>),
</span></span><span><span>    .mov(.r1, .r6),
</span></span><span><span>    .mov(.r2, .r8),
</span></span><span><span>    .mov(.r3, .r10),
</span></span><span><span>    .add(.r3, <span>-</span><span>0x18</span>),
</span></span><span><span>    .mov(.r4, <span>6</span>),
</span></span><span><span>    .call(.skb_load_bytes),
</span></span><span><span>    .jmp(.jlt, .r0, <span>0</span>, <span>10</span>),
</span></span><span><span>
</span></span><span><span>    <span>// drop packet if it contains &#34;foobar&#34;
</span></span></span><span><span><span></span>    .mov(.r1, .r10),
</span></span><span><span>    .add(.r1, <span>-</span><span>0x18</span>),
</span></span><span><span>    .mov(.r2, <span>6</span>),
</span></span><span><span>    .mov(.r3, .r9),
</span></span><span><span>    <span>// bug in Zig std, call helper manually
</span></span></span><span><span><span></span>    <span>// .call(.strncmp),
</span></span></span><span><span><span></span>    .{
</span></span><span><span>        .code <span>=</span> BPF.CALL <span>|</span> BPF.JMP,
</span></span><span><span>        .dst <span>=</span> <span>0</span>,
</span></span><span><span>        .src <span>=</span> <span>0</span>,
</span></span><span><span>        .off <span>=</span> <span>0</span>,
</span></span><span><span>        .imm <span>=</span> <span>182</span>,
</span></span><span><span>    },
</span></span><span><span>    .jmp(.jne, .r0, <span>0</span>, <span>2</span>),
</span></span><span><span>    .mov(.r0, <span>@intFromEnum</span>(SK.DROP)),
</span></span><span><span>    .exit(),
</span></span><span><span>    .add(.r8, <span>1</span>),
</span></span><span><span>    .jmp(.jlt, .r8, <span>0x200</span>, <span>-</span><span>17</span>),
</span></span><span><span>
</span></span><span><span>    .mov(.r0, <span>@intFromEnum</span>(SK.PASS)),
</span></span><span><span>    .exit(),
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>var</span> verifier_log<span>:</span> [<span>0x10000</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span><span>var</span> log <span>=</span> BPF.Log{ .buf <span>=</span> <span>&amp;</span>verifier_log, .level <span>=</span> <span>4</span> };
</span></span><span><span><span>errdefer</span> std.debug.print(<span>&#34;BPF Verifier output:</span><span>\n</span><span>{s}&#34;</span>, .{std.mem.sliceTo(<span>&amp;</span>verifier_log, <span>0</span>)});
</span></span><span><span>
</span></span><span><span><span>const</span> progfd <span>=</span> <span>try</span> BPF.prog_load(.sk_skb, <span>&amp;</span>insns, <span>&amp;</span>log, <span>&#34;GPL v2&#34;</span>, <span>0</span>, <span>0</span>);
</span></span><span><span>
</span></span><span><span><span>const</span> sockmapfd <span>=</span> <span>try</span> BPF.map_create(.sockmap, <span>@sizeOf</span>(<span>i32</span>), <span>@sizeOf</span>(<span>i32</span>), <span>1</span>);
</span></span><span><span>
</span></span><span><span>{
</span></span><span><span>    <span>var</span> attr <span>=</span> BPF.Attr{
</span></span><span><span>        .prog_attach <span>=</span> .{
</span></span><span><span>            .target_fd <span>=</span> sockmapfd,
</span></span><span><span>            .attach_bpf_fd <span>=</span> progfd,
</span></span><span><span>            .attach_type <span>=</span> <span>@intFromEnum</span>(BPF.AttachType.sk_skb_stream_verdict),
</span></span><span><span>            .attach_flags <span>=</span> <span>0</span>,
</span></span><span><span>            .replace_bpf_fd <span>=</span> <span>0</span>,
</span></span><span><span>        },
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>try</span> <span>switch</span> (posix.errno(linux.bpf(.prog_attach, <span>&amp;</span>attr, <span>@sizeOf</span>(BPF.ProgAttachAttr)))) {
</span></span><span><span>        .SUCCESS <span>=&gt;</span> {},
</span></span><span><span>        .ACCES <span>=&gt;</span> <span>error</span>.UnsafeProgram,
</span></span><span><span>        .FAULT <span>=&gt;</span> <span>unreachable</span>,
</span></span><span><span>        .INVAL <span>=&gt;</span> <span>error</span>.InvalidProgram,
</span></span><span><span>        .PERM <span>=&gt;</span> <span>error</span>.PermissionDenied,
</span></span><span><span>        <span>else</span> <span>=&gt;</span> <span>|</span>err<span>|</span> posix.unexpectedErrno(err),
</span></span><span><span>    };
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>var</span> socks<span>:</span> [<span>2</span>]linux.fd_t <span>=</span> <span>undefined</span>;
</span></span><span><span><span>switch</span> (posix.errno(linux.socketpair(AF.UNIX, SOCK.DGRAM <span>|</span> SOCK.NONBLOCK, <span>0</span>, <span>&amp;</span>socks))) {
</span></span><span><span>    .SUCCESS <span>=&gt;</span> {},
</span></span><span><span>    <span>else</span> <span>=&gt;</span> <span>|</span>e<span>|</span> <span>return</span> posix.unexpectedErrno(e),
</span></span><span><span>}
</span></span><span><span><span>try</span> BPF.map_update_elem(sockmapfd, <span>&amp;</span>std.mem.toBytes(<span>@as</span>(<span>i32</span>, <span>0</span>)), std.mem.asBytes(<span>&amp;</span>socks[<span>0</span>]), BPF.ANY);
</span></span><span><span>
</span></span><span><span><span>const</span> packets <span>=</span> [_][]<span>const</span> <span>u8</span>{
</span></span><span><span>    <span>&#34;foo&#34;</span>,
</span></span><span><span>    <span>&#34;bar&#34;</span>,
</span></span><span><span>    <span>&#34;foobar&#34;</span>,
</span></span><span><span>    <span>&#34;fooba&#34;</span>,
</span></span><span><span>    <span>&#34;snafu&#34;</span>,
</span></span><span><span>    <span>&#34;ffoobarbaz&#34;</span>,
</span></span><span><span>    <span>&#34;bazbarfoo&#34;</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>var</span> buf<span>:</span> [<span>0x10</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span><span>for</span> (packets) <span>|</span>p<span>|</span> {
</span></span><span><span>    _ <span>=</span> <span>try</span> posix.write(socks[<span>1</span>], p);
</span></span><span><span>    <span>const</span> n_read <span>=</span> posix.read(socks[<span>0</span>], <span>&amp;</span>buf) <span>catch</span> <span>0</span>;
</span></span><span><span>    std.log.info(<span>&#34;Sent &#39;{s}&#39;, received &#39;{s}&#39;&#34;</span>, .{ p, buf[<span>0</span>..n_read] });
</span></span><span><span>}</span></span></code></pre></div>
</details>






  
  
    

  
  
    









<div><pre tabindex="0"><code data-lang="text"><span><span>info: Sent &#39;foo&#39;, received &#39;foo&#39;
</span></span><span><span>info: Sent &#39;bar&#39;, received &#39;bar&#39;
</span></span><span><span>info: Sent &#39;foobar&#39;, received &#39;&#39;
</span></span><span><span>info: Sent &#39;fooba&#39;, received &#39;fooba&#39;
</span></span><span><span>info: Sent &#39;snafu&#39;, received &#39;snafu&#39;
</span></span><span><span>info: Sent &#39;ffoobarbaz&#39;, received &#39;&#39;
</span></span><span><span>info: Sent &#39;bazbarfoo&#39;, received &#39;bazbarfoo&#39;</span></span></code></pre></div>

<h2 id="type-information--btf">Type information (BTF)</h2>
<p>Even though the eBPF verifier uses type information extensively to prove correctness of a program, almost all eBPF instructions don’t encode type information (besides integer width), so how do we represent types in eBPF?</p>
<p>That’s where BTF (BPF type format) comes in.
It’s described as a format that “encodes the debug info related to BPF program/map,” but in my opinion this is misleading as it encodes information useful for debugging <strong>and</strong> information that is used by the eBPF verifier to check that your program is valid.</p>
<p>That is to say, eBPF programs that use certain features <strong>require</strong> BTF information in order to pass verification.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></p>
<p>To see this in action, let’s rewrite the previous program using the <kbd>bpf_loop</kbd> helper and the <kbd>bpf_strcmp</kbd> KFunc.</p>
<p>According to the docs the second argument of <kbd>bpf_loop</kbd>, <span data-lang="c"><code>void *callback</code></span>, is a pointer to a static function.
But wait, how do you define a (static) function within an eBPF program?
The preferred verbiage for functions within a program seems to be “subprograms”, which are subsequences of instructions within the list of instructions that you pass to the <kbd>bpf</kbd> syscall.</p>
<p>To let the verifier know that your subprogram exists, you need to use a special variant of the <code>CALL</code> or <code>LD</code> opcodes, which jump to a program-local function or load a program-local function pointer into a register, respectively.</p>






  
  
    

  
  
    









<details open="">
  
  <summary>Zig</summary>
  
  
  <div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> main_insns <span>=</span> [_]BPF.Insn{
</span></span><span><span>    .stx(.double_word, .r10, <span>-</span><span>0x8</span>, .r1),
</span></span><span><span>    .st(.double_word, .r10, <span>-</span><span>0x10</span>, <span>0</span>),
</span></span><span><span>    .mov(.r1, .r10),
</span></span><span><span>    .add(.r1, <span>-</span><span>0x8</span>),
</span></span><span><span>    .stx(.double_word, .r10, <span>-</span><span>0x18</span>, .r1),
</span></span><span><span>
</span></span><span><span>    <span>// return if packet_len &lt; 6 bytes
</span></span></span><span><span><span></span>    .ldx(.double_word, .r1, .r10, <span>-</span><span>0x8</span>),
</span></span><span><span>    .ldx(.word, .r7, .r1, <span>0</span>),
</span></span><span><span>    .jmp(.jge, .r7, <span>6</span>, <span>2</span>),
</span></span><span><span>    .mov(.r0, <span>@intFromEnum</span>(SK.PASS)),
</span></span><span><span>    .exit(),
</span></span><span><span>
</span></span><span><span>    .mov(.r1, .r7),
</span></span><span><span>    .add(.r1, <span>-</span><span>5</span>),
</span></span><span><span>    _ld_funcall1(.r2, <span>11</span>),
</span></span><span><span>    _ld_funcall2(<span>11</span>),
</span></span><span><span>    .mov(.r3, .r10),
</span></span><span><span>    .add(.r3, <span>-</span><span>0x18</span>),
</span></span><span><span>    .mov(.r4, <span>0</span>),
</span></span><span><span>    <span>// .call(.loop),
</span></span></span><span><span><span></span>    .{
</span></span><span><span>        .code <span>=</span> BPF.CALL <span>|</span> BPF.JMP,
</span></span><span><span>        .dst <span>=</span> <span>0</span>,
</span></span><span><span>        .src <span>=</span> <span>0</span>,
</span></span><span><span>        .off <span>=</span> <span>0</span>,
</span></span><span><span>        .imm <span>=</span> <span>181</span>,
</span></span><span><span>    },
</span></span><span><span>    .ldx(.double_word, .r1, .r10, <span>-</span><span>0x10</span>),
</span></span><span><span>    .jmp(.jeq, .r1, <span>1</span>, <span>2</span>),
</span></span><span><span>    .mov(.r0, <span>@intFromEnum</span>(SK.PASS)),
</span></span><span><span>    .exit(),
</span></span><span><span>
</span></span><span><span>    .mov(.r0, <span>@intFromEnum</span>(SK.DROP)),
</span></span><span><span>    .exit(),
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>const</span> helper_insns <span>=</span> [_]BPF.Insn{
</span></span><span><span>    <span>// r1 = loop index, r2 = ctx
</span></span></span><span><span><span></span>    .stx(.double_word, .r10, <span>-</span><span>0x8</span>, .r2),
</span></span><span><span>    .st(.double_word, .r10, <span>-</span><span>0x10</span>, <span>0</span>),
</span></span><span><span>    .mov(.r3, .r1),
</span></span><span><span>
</span></span><span><span>    <span>// load skb-&gt;data[index..][0..6] onto the stack
</span></span></span><span><span><span></span>    .ldx(.double_word, .r1, .r2, <span>0</span>),
</span></span><span><span>    .ldx(.double_word, .r1, .r1, <span>0</span>),
</span></span><span><span>    .mov(.r2, .r3),
</span></span><span><span>    .mov(.r3, .r10),
</span></span><span><span>    .add(.r3, <span>-</span><span>0x18</span>),
</span></span><span><span>    .mov(.r4, <span>6</span>),
</span></span><span><span>    .call(.skb_load_bytes),
</span></span><span><span>    .jmp(.jeq, .r0, <span>0</span>, <span>2</span>),
</span></span><span><span>    .mov(.r0, <span>1</span>),
</span></span><span><span>    .exit(),
</span></span><span><span>
</span></span><span><span>    <span>// load &#34;foobar&#34; into r9
</span></span></span><span><span><span></span>    .ld_map_fd1(.r1, mapfd),
</span></span><span><span>    .ld_map_fd2(mapfd),
</span></span><span><span>    .mov(.r2, .r10),
</span></span><span><span>    .add(.r2, <span>-</span><span>0x10</span>),
</span></span><span><span>    .call(.map_lookup_elem),
</span></span><span><span>    .jmp(.jne, .r0, <span>0</span>, <span>2</span>),
</span></span><span><span>    .mov(.r0, <span>1</span>),
</span></span><span><span>    .exit(),
</span></span><span><span>    .mov(.r9, .r0),
</span></span><span><span>
</span></span><span><span>    .mov(.r1, .r10),
</span></span><span><span>    .add(.r1, <span>-</span><span>0x18</span>),
</span></span><span><span>    .mov(.r2, .r9),
</span></span><span><span>    .{
</span></span><span><span>        .code <span>=</span> BPF.CALL <span>|</span> BPF.JMP,
</span></span><span><span>        .dst <span>=</span> <span>0</span>,
</span></span><span><span>        .src <span>=</span> <span>2</span>,
</span></span><span><span>        .off <span>=</span> <span>0</span>,
</span></span><span><span>        .imm <span>=</span> strcmp_btf_id,
</span></span><span><span>    },
</span></span><span><span>    .jmp(.jne, .r0, <span>0</span>, <span>5</span>),
</span></span><span><span>    .ldx(.double_word, .r1, .r10, <span>-</span><span>0x8</span>),
</span></span><span><span>    .ldx(.double_word, .r1, .r1, <span>0</span>),
</span></span><span><span>    .st(.double_word, .r1, <span>-</span><span>0x8</span>, <span>1</span>), <span>// store &#34;1&#34; on the callee&#39;s stack past the sk_buff ctx pointer
</span></span></span><span><span><span></span>    .mov(.r0, <span>1</span>),
</span></span><span><span>    .exit(),
</span></span><span><span>
</span></span><span><span>    .mov(.r0, <span>0</span>),
</span></span><span><span>    .exit(),
</span></span><span><span>};</span></span></code></pre></div>
</details>






  
  
    

  
  
    









<div><pre tabindex="0"><code data-lang="text"><span><span>BPF Verifier output:
</span></span><span><span>missing btf func_info
</span></span><span><span>verification time 13905 usec
</span></span><span><span>stack depth 24+0
</span></span><span><span>processed 13 insns (limit 1000000) max_states_per_insn 0 total_states 1 peak_states 1 mark_read 0
</span></span><span><span>error: InvalidProgram
</span></span><span><span>/nix/store/pp3rdgdy6pnji9zm91qqcd6c86wljw58-zig-0.15.2/lib/zig/std/os/linux/bpf.zig:1710:5: 0x10c0602 in prog_load (tmp.vvZfe6NDKR)
</span></span><span><span>/tmp/nix-shell.6Qivnq/tmp.vvZfe6NDKR.zig:167:20: 0x10c15cf in main (tmp.vvZfe6NDKR)</span></span></code></pre></div>

<p>Ok, now the verifier is upset because we’re missing <kbd>btf func_info</kbd>.
Basically, if we want to use callbacks, we need to tell the verifier the type signatures of all of our subprograms.</p>
<p>When loading our program, one of the attributes we can pass in is <kbd>func_info</kbd>, which is a pointer to an array of <kbd>bpf_func_info</kbd> structs, each of which contains an offset of a subprogram and a “type id” for a <code>BTF_KIND_FUNC_PROTO</code> representing that subprogram’s type information.
A type id is basically an index into the list of types contained within a BTF object; because a BPF map or program can only reference types within a single BTF object (not counting btf_vmlinux), for all intents and purposes you should shove any type information your program will need into one BTF object.</p>
<p>Fortunately, constructing a BTF object is fairly straightforward (if not a little tedious), so I will let the code do the talking:</p>






  
  
    

  
  
    









<details open="">
  
  <summary>Zig</summary>
  
  
  <div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> BTF_FUNC <span>=</span> <span>enum</span>(<span>u32</span>) {
</span></span><span><span>    STATIC <span>=</span> <span>0</span>,
</span></span><span><span>    GLOBAL,
</span></span><span><span>    EXTERN,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>const</span> bpf_func_info <span>=</span> <span>extern</span> <span>struct</span> {
</span></span><span><span>    insn_off<span>:</span> <span>u32</span>,
</span></span><span><span>    type_id<span>:</span> <span>u32</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>const</span> BPFContext <span>=</span> opaque {};
</span></span><span><span>
</span></span><span><span><span>const</span> BTFContext <span>=</span> <span>struct</span> {
</span></span><span><span>    type_map<span>:</span> []<span>const</span> <span>struct</span> { []<span>const</span> <span>u8</span>, <span>u32</span> } <span>=</span> <span>&amp;</span>.{.{ <span>&#34;void&#34;</span>, <span>0</span> }},
</span></span><span><span>    strings<span>:</span> []<span>const</span> <span>u8</span> <span>=</span> <span>&#34;</span><span>\x00</span><span>&#34;</span>,
</span></span><span><span>    btf_bytes<span>:</span> []<span>const</span> <span>u8</span> <span>=</span> <span>&amp;</span>.{},
</span></span><span><span>    type_id<span>:</span> <span>u32</span> <span>=</span> <span>1</span>,
</span></span><span><span>
</span></span><span><span>    <span>pub</span> <span>fn</span> indexOf(self<span>:</span> <span>*</span><span>const</span> <span>@This</span>(), T<span>:</span> <span>type</span>) <span>?</span><span>usize</span> {
</span></span><span><span>        <span>inline</span> <span>for</span> (self.type_map) <span>|</span>typ<span>|</span> {
</span></span><span><span>            <span>if</span> (std.mem.eql(<span>u8</span>, <span>@typeName</span>(T), typ.@<span>&#34;0&#34;</span>)) <span>return</span> typ.@<span>&#34;1&#34;</span>;
</span></span><span><span>        }
</span></span><span><span>        <span>return</span> <span>null</span>;
</span></span><span><span>    }
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>fn</span> type_to_btf_context(T<span>:</span> <span>type</span>, <span>comptime</span> ctx<span>:</span> BTFContext) BTFContext {
</span></span><span><span>    <span>comptime</span> <span>var</span> ret <span>=</span> ctx;
</span></span><span><span>
</span></span><span><span>    <span>@setEvalBranchQuota</span>(<span>2000000</span>);
</span></span><span><span>
</span></span><span><span>    <span>if</span> (BTFContext.indexOf(<span>&amp;</span>ctx, T)) <span>|</span>_<span>|</span> {
</span></span><span><span>        <span>return</span> ctx;
</span></span><span><span>    } <span>else</span> {
</span></span><span><span>        ret.type_map <span>=</span> ret.type_map <span>++</span> .{.{ <span>@typeName</span>(T), ret.type_id }};
</span></span><span><span>        ret.type_id <span>+=</span> <span>1</span>;
</span></span><span><span>
</span></span><span><span>        <span>switch</span> (<span>@typeInfo</span>(T)) {
</span></span><span><span>            .int <span>=&gt;</span> <span>|</span>info<span>|</span> {
</span></span><span><span>                <span>const</span> encoding<span>:</span> <span>u32</span> <span>=</span> <span>if</span> (info.signedness <span>==</span> .signed) <span>1</span> <span>else</span> <span>if</span> (T <span>==</span> <span>u8</span>) <span>2</span> <span>else</span> <span>0</span>;
</span></span><span><span>                ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Type{
</span></span><span><span>                    .name_off <span>=</span> <span>0</span>,
</span></span><span><span>                    .info <span>=</span> .{
</span></span><span><span>                        .vlen <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                        .unused_1 <span>=</span> <span>0</span>,
</span></span><span><span>                        .kind <span>=</span> .int,
</span></span><span><span>                        .unused_2 <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                        .kind_flag <span>=</span> <span>false</span>,
</span></span><span><span>                    },
</span></span><span><span>                    .size_type <span>=</span> .{ .size <span>=</span> (info.bits <span>+</span> <span>7</span>) <span>/</span> <span>8</span> <span>*</span> <span>8</span> },
</span></span><span><span>                }) <span>++</span> std.mem.toBytes(<span>@as</span>(<span>u32</span>, (encoding <span>&lt;&lt;</span> <span>24</span>) <span>+</span> <span>@as</span>(<span>u32</span>, <span>0</span> <span>&lt;&lt;</span> <span>16</span>) <span>+</span> info.bits));
</span></span><span><span>            },
</span></span><span><span>            .<span>bool</span> <span>=&gt;</span> {
</span></span><span><span>                <span>const</span> encoding<span>:</span> <span>u32</span> <span>=</span> <span>4</span>;
</span></span><span><span>                ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Type{
</span></span><span><span>                    .name_off <span>=</span> <span>0</span>,
</span></span><span><span>                    .info <span>=</span> .{
</span></span><span><span>                        .vlen <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                        .unused_1 <span>=</span> <span>0</span>,
</span></span><span><span>                        .kind <span>=</span> .int,
</span></span><span><span>                        .unused_2 <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                        .kind_flag <span>=</span> <span>false</span>,
</span></span><span><span>                    },
</span></span><span><span>                    .size_type <span>=</span> .{ .size <span>=</span> <span>@sizeOf</span>(<span>bool</span>) },
</span></span><span><span>                }) <span>++</span> std.mem.toBytes(<span>@as</span>(<span>u32</span>, (encoding <span>&lt;&lt;</span> <span>24</span>) <span>+</span> <span>@as</span>(<span>u32</span>, <span>0</span> <span>&lt;&lt;</span> <span>16</span>) <span>+</span> <span>@bitSizeOf</span>(<span>bool</span>)));
</span></span><span><span>            },
</span></span><span><span>            .float <span>=&gt;</span> <span>|</span>info<span>|</span> {
</span></span><span><span>                ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Type{
</span></span><span><span>                    .name_off <span>=</span> <span>0</span>,
</span></span><span><span>                    .info <span>=</span> .{
</span></span><span><span>                        .vlen <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                        .unused_1 <span>=</span> <span>0</span>,
</span></span><span><span>                        .kind <span>=</span> .float,
</span></span><span><span>                        .unused_2 <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                        .kind_flag <span>=</span> <span>false</span>,
</span></span><span><span>                    },
</span></span><span><span>                    .size_type <span>=</span> .{ .size <span>=</span> (info.bits <span>+</span> <span>7</span>) <span>/</span> <span>8</span> <span>*</span> <span>8</span> },
</span></span><span><span>                });
</span></span><span><span>            },
</span></span><span><span>            .@<span>&#34;enum&#34;</span> <span>=&gt;</span> <span>|</span>info<span>|</span> {
</span></span><span><span>                <span>const</span> enum_size <span>=</span> <span>switch</span> (<span>@sizeOf</span>(info.tag_type)) {
</span></span><span><span>                    <span>1</span>, <span>2</span>, <span>4</span>, <span>8</span> <span>=&gt;</span> <span>|</span>s<span>|</span> s,
</span></span><span><span>                    <span>else</span> <span>=&gt;</span> <span>@compileError</span>(<span>&#34;enum size must be 1/2/4/8 bytes&#34;</span>),
</span></span><span><span>                };
</span></span><span><span>
</span></span><span><span>                ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Type{
</span></span><span><span>                    .name_off <span>=</span> <span>0</span>,
</span></span><span><span>                    .info <span>=</span> .{
</span></span><span><span>                        .vlen <span>=</span> info.fields.len,
</span></span><span><span>
</span></span><span><span>                        .unused_1 <span>=</span> <span>0</span>,
</span></span><span><span>                        .kind <span>=</span> <span>if</span> (enum_size <span>==</span> <span>8</span>) .enum64 <span>else</span> .@<span>&#34;enum&#34;</span>,
</span></span><span><span>                        .unused_2 <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                        .kind_flag <span>=</span> info.signedness,
</span></span><span><span>                    },
</span></span><span><span>                    .size_type <span>=</span> .{ .size <span>=</span> enum_size },
</span></span><span><span>                });
</span></span><span><span>
</span></span><span><span>                <span>inline</span> <span>for</span> (info.fields) <span>|</span>f<span>|</span> {
</span></span><span><span>                    <span>if</span> (enum_size <span>==</span> <span>8</span>) {
</span></span><span><span>                        ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Enum64{
</span></span><span><span>                            .name_off <span>=</span> ret.strings.len,
</span></span><span><span>                            .val_lo32 <span>=</span> <span>@as</span>(<span>i32</span>, <span>@bitCast</span>(<span>@as</span>(<span>u32</span>, <span>@truncate</span>(f.value)))),
</span></span><span><span>                            .val_hi32 <span>=</span> <span>@as</span>(<span>i32</span>, <span>@bitCast</span>(<span>@as</span>(<span>u32</span>, <span>@truncate</span>(f.value <span>&gt;&gt;</span> <span>32</span>)))),
</span></span><span><span>                        });
</span></span><span><span>                    } <span>else</span> {
</span></span><span><span>                        ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Enum{
</span></span><span><span>                            .name_off <span>=</span> ret.strings.len,
</span></span><span><span>                            .val <span>=</span> <span>@bitCast</span>(f.value),
</span></span><span><span>                        });
</span></span><span><span>                    }
</span></span><span><span>                    ret.strings <span>=</span> ret.strings <span>++</span> f.name;
</span></span><span><span>                }
</span></span><span><span>            },
</span></span><span><span>            .pointer <span>=&gt;</span> <span>|</span>info<span>|</span> {
</span></span><span><span>                <span>if</span> (info.child <span>==</span> BPFContext <span>and</span> BTFContext.indexOf(<span>&amp;</span>ret, BPFContext) <span>==</span> <span>null</span>) {
</span></span><span><span>                    ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span>
</span></span><span><span>                        std.mem.asBytes(<span>&amp;</span>BPF.btf.Type{
</span></span><span><span>                            .name_off <span>=</span> ret.strings.len,
</span></span><span><span>                            .info <span>=</span> .{
</span></span><span><span>                                .vlen <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                                .unused_1 <span>=</span> <span>0</span>,
</span></span><span><span>                                .kind <span>=</span> .decl_tag,
</span></span><span><span>                                .unused_2 <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                                .kind_flag <span>=</span> <span>false</span>,
</span></span><span><span>                            },
</span></span><span><span>                            .size_type <span>=</span> .{ .typ <span>=</span> <span>1</span> },
</span></span><span><span>                        }) <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.DeclTag{
</span></span><span><span>                        .component_idx <span>=</span> <span>0</span>,
</span></span><span><span>                    }) <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Type{
</span></span><span><span>                        .name_off <span>=</span> <span>0</span>,
</span></span><span><span>                        .info <span>=</span> .{
</span></span><span><span>                            .vlen <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                            .unused_1 <span>=</span> <span>0</span>,
</span></span><span><span>                            .kind <span>=</span> .ptr,
</span></span><span><span>                            .unused_2 <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                            .kind_flag <span>=</span> <span>false</span>,
</span></span><span><span>                        },
</span></span><span><span>                        .size_type <span>=</span> .{ .typ <span>=</span> <span>0</span> },
</span></span><span><span>                    });
</span></span><span><span>                    ret.strings <span>=</span> ret.strings <span>++</span> <span>&#34;arg:ctx</span><span>\x00</span><span>&#34;</span>;
</span></span><span><span>                    ret.type_map <span>=</span> ret.type_map <span>++</span> .{.{ <span>@typeName</span>(<span>*</span><span>void</span>), ret.type_id <span>-</span> <span>1</span> }};
</span></span><span><span>                } <span>else</span> {
</span></span><span><span>                    <span>comptime</span> <span>var</span> _ctx <span>=</span> ret;
</span></span><span><span>                    _ctx.btf_bytes <span>=</span> <span>&amp;</span>.{};
</span></span><span><span>                    <span>const</span> new <span>=</span> type_to_btf_context(info.child, _ctx);
</span></span><span><span>                    _ctx.btf_bytes <span>=</span> _ctx.btf_bytes <span>++</span>
</span></span><span><span>                        std.mem.asBytes(<span>&amp;</span>BPF.btf.Type{
</span></span><span><span>                            .name_off <span>=</span> <span>0</span>,
</span></span><span><span>                            .info <span>=</span> .{
</span></span><span><span>                                .vlen <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                                .unused_1 <span>=</span> <span>0</span>,
</span></span><span><span>                                .kind <span>=</span> .ptr,
</span></span><span><span>                                .unused_2 <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                                .kind_flag <span>=</span> <span>false</span>,
</span></span><span><span>                            },
</span></span><span><span>                            .size_type <span>=</span> .{ .typ <span>=</span> BTFContext.indexOf(<span>&amp;</span>new, info.child).<span>?</span> },
</span></span><span><span>                        }) <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.DeclTag{
</span></span><span><span>                        .component_idx <span>=</span> <span>0</span>,
</span></span><span><span>                    }) <span>++</span> new.btf_bytes;
</span></span><span><span>                    _ctx.type_id <span>=</span> new.type_id;
</span></span><span><span>                    _ctx.strings <span>=</span> new.strings;
</span></span><span><span>
</span></span><span><span>                    ret <span>=</span> _ctx;
</span></span><span><span>                }
</span></span><span><span>            },
</span></span><span><span>            .@<span>&#34;fn&#34;</span> <span>=&gt;</span> <span>|</span>info<span>|</span> {
</span></span><span><span>                <span>const</span> cc<span>:</span> <span>u16</span> <span>=</span> <span>switch</span> (info.calling_convention) {
</span></span><span><span>                    .auto <span>=&gt;</span> <span>@intFromEnum</span>(BTF_FUNC.STATIC),
</span></span><span><span>                    .naked <span>=&gt;</span> <span>@intFromEnum</span>(BTF_FUNC.GLOBAL),
</span></span><span><span>                    <span>else</span> <span>=&gt;</span> <span>@compileError</span>(<span>&#34;only auto and naked calling conventions are allowed&#34;</span>),
</span></span><span><span>                };
</span></span><span><span>
</span></span><span><span>                <span>comptime</span> <span>var</span> _ctx <span>=</span> ret;
</span></span><span><span>                _ctx.btf_bytes <span>=</span> <span>&amp;</span>.{};
</span></span><span><span>                _ctx.type_id <span>+=</span> <span>1</span>;
</span></span><span><span>                _ctx <span>=</span> type_to_btf_context(info.return_type.<span>?</span>, _ctx);
</span></span><span><span>
</span></span><span><span>                ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Type{
</span></span><span><span>                    .name_off <span>=</span> _ctx.strings.len,
</span></span><span><span>                    .info <span>=</span> .{
</span></span><span><span>                        .vlen <span>=</span> cc,
</span></span><span><span>
</span></span><span><span>                        .unused_1 <span>=</span> <span>0</span>,
</span></span><span><span>                        .kind <span>=</span> .func,
</span></span><span><span>                        .unused_2 <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                        .kind_flag <span>=</span> <span>false</span>,
</span></span><span><span>                    },
</span></span><span><span>                    .size_type <span>=</span> .{ .typ <span>=</span> ret.type_id },
</span></span><span><span>                }) <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Type{
</span></span><span><span>                    .name_off <span>=</span> <span>0</span>,
</span></span><span><span>                    .info <span>=</span> .{
</span></span><span><span>                        .vlen <span>=</span> info.params.len,
</span></span><span><span>
</span></span><span><span>                        .unused_1 <span>=</span> <span>0</span>,
</span></span><span><span>                        .kind <span>=</span> .func_proto,
</span></span><span><span>                        .unused_2 <span>=</span> <span>0</span>,
</span></span><span><span>
</span></span><span><span>                        .kind_flag <span>=</span> <span>false</span>,
</span></span><span><span>                    },
</span></span><span><span>                    .size_type <span>=</span> .{ .typ <span>=</span> BTFContext.indexOf(<span>&amp;</span>_ctx, info.return_type.<span>?</span>).<span>?</span> },
</span></span><span><span>                });
</span></span><span><span>                _ctx.strings <span>=</span> _ctx.strings <span>++</span> <span>&#34;foo</span><span>\x00</span><span>&#34;</span>;
</span></span><span><span>
</span></span><span><span>                <span>inline</span> <span>for</span> (info.params) <span>|</span>p<span>|</span> {
</span></span><span><span>                    <span>if</span> (p.<span>type</span>) <span>|</span>t<span>|</span> {
</span></span><span><span>                        _ctx.type_id <span>+=</span> <span>1</span>;
</span></span><span><span>                        _ctx <span>=</span> type_to_btf_context(t, _ctx);
</span></span><span><span>                        _ctx.type_id <span>-=</span> <span>1</span>;
</span></span><span><span>                        ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Param{
</span></span><span><span>                            .name_off <span>=</span> _ctx.strings.len,
</span></span><span><span>                            .typ <span>=</span> BTFContext.indexOf(<span>&amp;</span>_ctx, t).<span>?</span>,
</span></span><span><span>                        });
</span></span><span><span>                        _ctx.strings <span>=</span> _ctx.strings <span>++</span> <span>&#34;foo</span><span>\x00</span><span>&#34;</span>;
</span></span><span><span>                    } <span>else</span> <span>@compileError</span>(<span>&#34;param type cannot be null&#34;</span>);
</span></span><span><span>                }
</span></span><span><span>                ret.btf_bytes <span>=</span> ret.btf_bytes <span>++</span> _ctx.btf_bytes;
</span></span><span><span>                ret.type_id <span>=</span> _ctx.type_id;
</span></span><span><span>                ret.strings <span>=</span> _ctx.strings;
</span></span><span><span>                ret.type_map <span>=</span> _ctx.type_map;
</span></span><span><span>            },
</span></span><span><span>            .array, .@<span>&#34;struct&#34;</span>, .@<span>&#34;union&#34;</span> <span>=&gt;</span> <span>@compileError</span>(<span>&#34;unimplemented&#34;</span>),
</span></span><span><span>            <span>else</span> <span>=&gt;</span> <span>@compileError</span>(<span>@typeName</span>(T) <span>++</span> <span>&#34; is unimplemented or unsupported&#34;</span>),
</span></span><span><span>        }
</span></span><span><span>        <span>return</span> ret;
</span></span><span><span>    }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> prog_load_with_btf(prog_type<span>:</span> BPF.ProgType, progs<span>:</span> []<span>const</span> []<span>const</span> BPF.Insn, <span>comptime</span> funcs<span>:</span> []<span>const</span> <span>type</span>) <span>!</span>posix.fd_t {
</span></span><span><span>    <span>if</span> (funcs.len <span>&gt;</span> <span>32</span>) {
</span></span><span><span>        <span>@compileError</span>(<span>&#34;32 arguments max are supported&#34;</span>);
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>comptime</span> <span>var</span> ctx <span>=</span> BTFContext{};
</span></span><span><span>    <span>comptime</span> <span>var</span> func_type_ids<span>:</span> [funcs.len]<span>u32</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>inline</span> <span>for</span> (funcs, <span>&amp;</span>func_type_ids) <span>|</span>f, <span>*</span>ft<span>|</span> {
</span></span><span><span>        ctx <span>=</span> <span>comptime</span> type_to_btf_context(f, ctx);
</span></span><span><span>        ctx.type_id <span>+=</span> <span>1</span>;
</span></span><span><span>        ft.<span>*</span> <span>=</span> <span>comptime</span> BTFContext.indexOf(<span>&amp;</span>ctx, f).<span>?</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>const</span> btf <span>=</span> std.mem.asBytes(<span>&amp;</span>BPF.btf.Header{
</span></span><span><span>        .magic <span>=</span> BPF.btf.magic,
</span></span><span><span>        .version <span>=</span> <span>1</span>,
</span></span><span><span>        .flags <span>=</span> <span>0</span>,
</span></span><span><span>        .hdr_len <span>=</span> <span>@sizeOf</span>(BPF.btf.Header),
</span></span><span><span>        .type_off <span>=</span> <span>0</span>,
</span></span><span><span>        .type_len <span>=</span> ctx.btf_bytes.len,
</span></span><span><span>        .str_off <span>=</span> ctx.btf_bytes.len,
</span></span><span><span>        .str_len <span>=</span> ctx.strings.len,
</span></span><span><span>    }) <span>++</span> ctx.btf_bytes <span>++</span> ctx.strings;
</span></span><span><span>
</span></span><span><span>    <span>var</span> btf_log<span>:</span> [<span>0x10000</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>defer</span> std.debug.print(<span>&#34;BTF Verifier output:</span><span>\n</span><span>{s}&#34;</span>, .{std.mem.sliceTo(<span>&amp;</span>btf_log, <span>0</span>)});
</span></span><span><span>
</span></span><span><span>    <span>var</span> attr <span>=</span> BPF.Attr{
</span></span><span><span>        .btf_load <span>=</span> std.mem.zeroes(BPF.BtfLoadAttr),
</span></span><span><span>    };
</span></span><span><span>    attr.btf_load.btf <span>=</span> <span>@intFromPtr</span>(btf);
</span></span><span><span>    attr.btf_load.btf_size <span>=</span> btf.len;
</span></span><span><span>    attr.btf_load.btf_log_buf <span>=</span> <span>@intFromPtr</span>(<span>&amp;</span>btf_log);
</span></span><span><span>    attr.btf_load.btf_log_size <span>=</span> btf_log.len;
</span></span><span><span>    attr.btf_load.btf_log_level <span>=</span> <span>2</span>;
</span></span><span><span>
</span></span><span><span>    <span>var</span> rc <span>=</span> linux.bpf(.btf_load, <span>&amp;</span>attr, <span>@sizeOf</span>(BPF.BtfLoadAttr));
</span></span><span><span>    <span>const</span> btf_fd <span>=</span> <span>try</span> <span>switch</span> (posix.errno(rc)) {
</span></span><span><span>        .SUCCESS <span>=&gt;</span> <span>@as</span>(posix.fd_t, <span>@intCast</span>(rc)),
</span></span><span><span>        .ACCES <span>=&gt;</span> <span>error</span>.UnsafeProgram,
</span></span><span><span>        .FAULT <span>=&gt;</span> <span>unreachable</span>,
</span></span><span><span>        .INVAL <span>=&gt;</span> <span>error</span>.InvalidProgram,
</span></span><span><span>        .PERM <span>=&gt;</span> <span>error</span>.AccessDenied,
</span></span><span><span>        <span>else</span> <span>=&gt;</span> <span>|</span>err<span>|</span> posix.unexpectedErrno(err),
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>var</span> func_info<span>:</span> [funcs.len]bpf_func_info <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>var</span> offset<span>:</span> <span>u32</span> <span>=</span> <span>0</span>;
</span></span><span><span>    <span>var</span> insns<span>:</span> [<span>4096</span>]BPF.Insn <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>for</span> (<span>&amp;</span>func_info, func_type_ids, progs) <span>|*</span>fi, ft, p<span>|</span> {
</span></span><span><span>        fi.<span>*</span> <span>=</span> .{ .insn_off <span>=</span> offset, .type_id <span>=</span> ft };
</span></span><span><span>        <span>@memcpy</span>(insns[offset..][<span>0</span>..p.len], p);
</span></span><span><span>        offset <span>+=</span> <span>@intCast</span>(p.len);
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>const</span> license <span>=</span> <span>&#34;GPL v2&#34;</span>;
</span></span><span><span>    <span>const</span> kernel_version <span>=</span> <span>0</span>;
</span></span><span><span>    <span>const</span> flags <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>    <span>var</span> bpf_log<span>:</span> [<span>0x10000</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>errdefer</span> std.debug.print(<span>&#34;BPF Verifier output:</span><span>\n</span><span>{s}&#34;</span>, .{std.mem.sliceTo(<span>&amp;</span>bpf_log, <span>0</span>)});
</span></span><span><span>
</span></span><span><span>    attr <span>=</span> BPF.Attr{
</span></span><span><span>        .prog_load <span>=</span> std.mem.zeroes(BPF.ProgLoadAttr),
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    attr.prog_load.prog_type <span>=</span> <span>@intFromEnum</span>(prog_type);
</span></span><span><span>    attr.prog_load.insns <span>=</span> <span>@intFromPtr</span>(<span>&amp;</span>insns);
</span></span><span><span>    attr.prog_load.insn_cnt <span>=</span> offset;
</span></span><span><span>    attr.prog_load.license <span>=</span> <span>@intFromPtr</span>(license.ptr);
</span></span><span><span>    attr.prog_load.kern_version <span>=</span> kernel_version;
</span></span><span><span>    attr.prog_load.prog_flags <span>=</span> flags;
</span></span><span><span>    attr.prog_load.log_buf <span>=</span> <span>@intFromPtr</span>(<span>&amp;</span>bpf_log);
</span></span><span><span>    attr.prog_load.log_size <span>=</span> <span>@intCast</span>(bpf_log.len);
</span></span><span><span>    attr.prog_load.log_level <span>=</span> <span>2</span>;
</span></span><span><span>    attr.prog_load.prog_btf_fd <span>=</span> btf_fd;
</span></span><span><span>    attr.prog_load.func_info_rec_size <span>=</span> <span>@sizeOf</span>(bpf_func_info);
</span></span><span><span>    attr.prog_load.func_info <span>=</span> <span>@intFromPtr</span>(<span>&amp;</span>func_info);
</span></span><span><span>    attr.prog_load.func_info_cnt <span>=</span> <span>@intCast</span>(func_info.len);
</span></span><span><span>
</span></span><span><span>    rc <span>=</span> linux.bpf(.prog_load, <span>&amp;</span>attr, <span>@sizeOf</span>(BPF.ProgLoadAttr));
</span></span><span><span>    <span>return</span> <span>switch</span> (posix.errno(rc)) {
</span></span><span><span>        .SUCCESS <span>=&gt;</span> <span>@as</span>(posix.fd_t, <span>@intCast</span>(rc)),
</span></span><span><span>        .ACCES <span>=&gt;</span> <span>error</span>.UnsafeProgram,
</span></span><span><span>        .FAULT <span>=&gt;</span> <span>unreachable</span>,
</span></span><span><span>        .INVAL <span>=&gt;</span> <span>error</span>.InvalidProgram,
</span></span><span><span>        .PERM <span>=&gt;</span> <span>error</span>.AccessDenied,
</span></span><span><span>        <span>else</span> <span>=&gt;</span> <span>|</span>err<span>|</span> posix.unexpectedErrno(err),
</span></span><span><span>    };
</span></span><span><span>}</span></span></code></pre></div>
</details>

<p>I make no claims that the code above is fundamentally correct (several BTF types are left unimplemented, not to mention I doubt it’s idiomatic Zig), but it gets the job done for our purposes.</p>
<p>Once we have our BTF, we load it using the <code>BPF_BTF_LOAD</code> subcommand, and we can then reference it by its fd when creating maps or programs.</p>






  
  
    

  
  
    









<details open="">
  
  <summary>Zig</summary>
  
  
  <div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> progfd <span>=</span> <span>try</span> prog_load_with_btf(.sk_skb, <span>&amp;</span>.{<span>&amp;</span>main_insns, <span>&amp;</span>helper_insns}, <span>&amp;</span>.{<span>fn</span> (<span>*</span>BPFContext) callconv(.naked) <span>u32</span>, <span>fn</span> (<span>u64</span>, <span>*</span><span>void</span>) <span>u64</span>});</span></span></code></pre></div>
</details>

<p>The next thing to deal with is how to call a KFunc.
There’s a variant of the <code>CALL</code> opcode that calls a function by BTF ID for exactly this purpose, so the next logical question is: how do we find the BTF ID for our KFunc?</p>
<p>The normal way to do this is generate <code>vmlinux.h</code> with pahole/bpftools (<span data-lang="bash"><code>bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</code></span>), but in the spirit of roughing it, we’ll forego that in favor of parsing btf_vmlinux directly.</p>
<p>I say “parse”, but we actually only care about a specific <code>BTF_KIND_FUNC</code> with the name we’re searching for, so my implementation ignores everything besides that.</p>






  
  
    

  
  
    









<details open="">
  
  <summary>Zig</summary>
  
  
  <div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> builtin <span>=</span> <span>@import</span>(<span>&#34;builtin&#34;</span>);
</span></span><span><span>
</span></span><span><span><span>fn</span> get_vmlinux_btf_id_from_name(name<span>:</span> []<span>const</span> <span>u8</span>) <span>!</span><span>u32</span> {
</span></span><span><span>    <span>const</span> fd <span>=</span> <span>try</span> std.posix.open(<span>&#34;/sys/kernel/btf/vmlinux&#34;</span>, .{ .ACCMODE <span>=</span> .RDONLY }, <span>0o550</span>);
</span></span><span><span>    <span>defer</span> std.posix.close(fd);
</span></span><span><span>
</span></span><span><span>    <span>var</span> buf<span>:</span> [<span>0x80</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>var</span> f_reader <span>=</span> std.fs.File.reader(.{ .handle <span>=</span> fd }, <span>&amp;</span>buf);
</span></span><span><span>    <span>var</span> reader <span>=</span> <span>&amp;</span>f_reader.interface;
</span></span><span><span>
</span></span><span><span>    <span>var</span> btf_id<span>:</span> <span>u32</span> <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>    <span>const</span> header <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.Header, builtin.cpu.arch.endian());
</span></span><span><span>    <span>const</span> string_off <span>=</span> header.hdr_len <span>+</span> header.str_off;
</span></span><span><span>    <span>while</span> (f_reader.logicalPos() <span>&lt;</span> string_off) {
</span></span><span><span>        btf_id <span>+=</span> <span>1</span>;
</span></span><span><span>        <span>const</span> btf_type <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.Type, builtin.cpu.arch.endian());
</span></span><span><span>        <span>switch</span> (btf_type.info.kind) {
</span></span><span><span>            .func <span>=&gt;</span> {
</span></span><span><span>                <span>const</span> pos <span>=</span> f_reader.logicalPos();
</span></span><span><span>                <span>try</span> f_reader.seekTo(string_off <span>+</span> btf_type.name_off);
</span></span><span><span>                <span>if</span> (std.mem.eql(<span>u8</span>, <span>try</span> reader.takeDelimiterExclusive(<span>&#39;\x00&#39;</span>), name)) <span>return</span> btf_id;
</span></span><span><span>                <span>try</span> f_reader.seekTo(pos);
</span></span><span><span>            },
</span></span><span><span>            .int <span>=&gt;</span> _ <span>=</span> <span>try</span> reader.takeStruct(<span>extern</span> <span>struct</span> { _<span>:</span> <span>u32</span> }, builtin.cpu.arch.endian()),
</span></span><span><span>            .array <span>=&gt;</span> _ <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.Array, builtin.cpu.arch.endian()),
</span></span><span><span>            .@<span>&#34;struct&#34;</span>, .@<span>&#34;union&#34;</span> <span>=&gt;</span> <span>for</span> (<span>0</span>..btf_type.info.vlen) <span>|</span>_<span>|</span> {
</span></span><span><span>                _ <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.Member, builtin.cpu.arch.endian());
</span></span><span><span>            },
</span></span><span><span>            .@<span>&#34;enum&#34;</span> <span>=&gt;</span> <span>for</span> (<span>0</span>..btf_type.info.vlen) <span>|</span>_<span>|</span> {
</span></span><span><span>                _ <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.Enum, builtin.cpu.arch.endian());
</span></span><span><span>            },
</span></span><span><span>            .enum64 <span>=&gt;</span> <span>for</span> (<span>0</span>..btf_type.info.vlen) <span>|</span>_<span>|</span> {
</span></span><span><span>                _ <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.Enum64, builtin.cpu.arch.endian());
</span></span><span><span>            },
</span></span><span><span>            .func_proto <span>=&gt;</span> <span>for</span> (<span>0</span>..btf_type.info.vlen) <span>|</span>_<span>|</span> {
</span></span><span><span>                _ <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.Param, builtin.cpu.arch.endian());
</span></span><span><span>            },
</span></span><span><span>            .@<span>&#34;var&#34;</span> <span>=&gt;</span> _ <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.Var, builtin.cpu.arch.endian()),
</span></span><span><span>            .datasec <span>=&gt;</span> <span>for</span> (<span>0</span>..btf_type.info.vlen) <span>|</span>_<span>|</span> {
</span></span><span><span>                _ <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.VarSecInfo, builtin.cpu.arch.endian());
</span></span><span><span>            },
</span></span><span><span>            .decl_tag <span>=&gt;</span> _ <span>=</span> <span>try</span> reader.takeStruct(BPF.btf.DeclTag, builtin.cpu.arch.endian()),
</span></span><span><span>            <span>else</span> <span>=&gt;</span> {},
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> <span>error</span>.NotFound;
</span></span><span><span>}</span></span></code></pre></div>
</details>






  
  
    

  
  
    









<div><pre tabindex="0"><code data-lang="text"><span><span>BTF Verifier output:
</span></span><span><span>magic: 0xeb9f
</span></span><span><span>version: 1
</span></span><span><span>flags: 0x0
</span></span><span><span>hdr_len: 24
</span></span><span><span>type_off: 0
</span></span><span><span>type_len: 132
</span></span><span><span>str_off: 132
</span></span><span><span>str_len: 29
</span></span><span><span>btf_total_size: 185
</span></span><span><span>[1] FUNC foo type_id=2
</span></span><span><span>[2] FUNC_PROTO (anon) return=3 args=(5 foo)
</span></span><span><span>[3] INT (anon) size=32 bits_offset=0 nr_bits=32 encoding=(none)
</span></span><span><span>[4] DECL_TAG arg:ctx type=1 component_idx=0
</span></span><span><span>[5] PTR (anon) type_id=0
</span></span><span><span>[6] FUNC foo type_id=7
</span></span><span><span>[7] FUNC_PROTO (anon) return=8 args=(8 foo, 5 foo)
</span></span><span><span>[8] INT (anon) size=64 bits_offset=0 nr_bits=64 encoding=(none)
</span></span><span><span>info: Sent &#39;foo&#39;, received &#39;foo&#39;
</span></span><span><span>info: Sent &#39;bar&#39;, received &#39;bar&#39;
</span></span><span><span>info: Sent &#39;foobar&#39;, received &#39;&#39;
</span></span><span><span>info: Sent &#39;fooba&#39;, received &#39;fooba&#39;
</span></span><span><span>info: Sent &#39;snafu&#39;, received &#39;snafu&#39;
</span></span><span><span>info: Sent &#39;ffoobarbaz&#39;, received &#39;&#39;
</span></span><span><span>info: Sent &#39;bazbarfoo&#39;, received &#39;bazbarfoo&#39;</span></span></code></pre></div>

<p>Hopefully this has been educational and helpful if you have the <del>misfortune</del> pleasure of working with eBPF at the bytecode level, whether you’re a security researcher hunting for bugs in the kernel or you just want to better understand how libbpf works.</p>
<p>Happy hacking!</p>





  
  
    

  
  
    









<details>
  
  <summary><p><span>Nix</span>
      <span>flake.nix</span>
    </p>
  
  </summary>
  <div><pre tabindex="0"><code data-lang="nix"><span><span>{
</span></span><span><span>  description <span>=</span> <span>&#34;Rush E(bpf)&#34;</span>;
</span></span><span><span>
</span></span><span><span>  inputs <span>=</span> {
</span></span><span><span>    nixpkgs<span>.</span>url <span>=</span> <span>&#34;github:NixOS/nixpkgs/nixpkgs-unstable&#34;</span>;
</span></span><span><span>    flake-utils<span>.</span>url <span>=</span> <span>&#34;github:numtide/flake-utils&#34;</span>;
</span></span><span><span>  };
</span></span><span><span>
</span></span><span><span>  outputs <span>=</span> { self<span>,</span> nixpkgs<span>,</span> flake-utils }:
</span></span><span><span>    (flake-utils<span>.</span>lib<span>.</span>eachDefaultSystem (system:
</span></span><span><span>      <span>let</span>
</span></span><span><span>        <span>inherit</span> (nixpkgs) lib;
</span></span><span><span>        fetchpatch&#39; <span>=</span> (<span>import</span> nixpkgs { <span>inherit</span> system; })<span>.</span>fetchpatch;
</span></span><span><span>        pkgs&#39; <span>=</span> (<span>import</span> nixpkgs { <span>inherit</span> system; })<span>.</span>applyPatches {
</span></span><span><span>          name <span>=</span> <span>&#34;fix-libcap-cross-compile&#34;</span>;
</span></span><span><span>          src <span>=</span> nixpkgs;
</span></span><span><span>          patches <span>=</span> [ (fetchpatch&#39; {
</span></span><span><span>            url <span>=</span> <span>&#34;https://patch-diff.githubusercontent.com/raw/NixOS/nixpkgs/pull/461685.patch&#34;</span>;
</span></span><span><span>            hash <span>=</span> <span>&#34;sha256-FXDc234uF05woQLYRvfVyA3FboWSmXnPhYOm8PeVs6Y=&#34;</span>;
</span></span><span><span>          }) ];
</span></span><span><span>        };
</span></span><span><span>        pkgs <span>=</span> <span>import</span> pkgs&#39; { <span>inherit</span> system; };
</span></span><span><span>      <span>in</span>
</span></span><span><span>        {
</span></span><span><span>          packages <span>=</span> {
</span></span><span><span>            kernel <span>=</span> pkgs<span>.</span>pkgsCross<span>.</span>gnu64<span>.</span>linuxKernel<span>.</span>kernels<span>.</span>linux_6_18;
</span></span><span><span>            initramfs <span>=</span> pkgs<span>.</span>runCommand <span>&#34;build-initramfs&#34;</span> {}
</span></span><span><span>              <span>&#39;&#39;
</span></span></span><span><span><span>                mkdir initramfs; cd initramfs
</span></span></span><span><span><span>                mkdir -pv {etc,proc,sys,usr/{bin,sbin}}
</span></span></span><span><span><span>                cp -a </span><span>${</span>pkgs<span>.</span>pkgsCross<span>.</span>gnu64<span>.</span>pkgsStatic<span>.</span>busybox<span>}</span><span>/{bin,sbin} .
</span></span></span><span><span><span>                chmod 755 ./{bin,sbin}
</span></span></span><span><span><span>                cp -a </span><span>${</span>pkgs<span>.</span>pkgsCross<span>.</span>gnu64<span>.</span>pkgsStatic<span>.</span>libcap<span>}</span><span>/bin .
</span></span></span><span><span><span>
</span></span></span><span><span><span>                cat &lt;&lt;EOF &gt; init
</span></span></span><span><span><span>                #!/bin/sh
</span></span></span><span><span><span>                mount -t proc none /proc
</span></span></span><span><span><span>                mount -t sysfs none /sys
</span></span></span><span><span><span>                mount -t devtmpfs devtmpfs /dev
</span></span></span><span><span><span>
</span></span></span><span><span><span>                setcap &#39;cap_bpf=eip cap_net_admin=eip cap_perfmon=eip&#39; /prog
</span></span></span><span><span><span>
</span></span></span><span><span><span>                echo -e &#34;\nBoot took \$(cut -d&#39; &#39; -f1 /proc/uptime) seconds\n&#34;
</span></span></span><span><span><span>
</span></span></span><span><span><span>                setsid cttyhack setuidgid 1337 sh
</span></span></span><span><span><span>
</span></span></span><span><span><span>                umount /proc
</span></span></span><span><span><span>                poweroff -d 0 -f
</span></span></span><span><span><span>                EOF
</span></span></span><span><span><span>                chmod +x init
</span></span></span><span><span><span>
</span></span></span><span><span><span>                find . -print0 | </span><span>${</span>lib<span>.</span>getExe pkgs<span>.</span>cpio<span>}</span><span> --null -ov --format=newc &gt; $out
</span></span></span><span><span><span>              &#39;&#39;</span>;
</span></span><span><span>            run <span>=</span> pkgs<span>.</span>writeShellScript <span>&#34;run.sh&#34;</span> <span>&#39;&#39;
</span></span></span><span><span><span>              </span><span>${</span>pkgs<span>.</span>qemu<span>}</span><span>/bin/qemu-system-x86_64 \
</span></span></span><span><span><span>                  </span><span>&#39;&#39;$</span><span>{DEBUG:+ -s} \
</span></span></span><span><span><span>                  -m 512 \
</span></span></span><span><span><span>                  -kernel </span><span>${</span>self<span>.</span>packages<span>.</span><span>${</span>system<span>}</span><span>.</span>kernel<span>}</span><span>/bzImage \
</span></span></span><span><span><span>                  -initrd rootfs.cpio \
</span></span></span><span><span><span>                  -append &#34;console=ttyS0 loglevel=3 oops=panic panic=-1&#34; \
</span></span></span><span><span><span>                  -no-reboot \
</span></span></span><span><span><span>                  -nographic \
</span></span></span><span><span><span>                  -monitor /dev/null \
</span></span></span><span><span><span>                  -serial unix:vm.sock,server,nowait
</span></span></span><span><span><span>            &#39;&#39;</span>;
</span></span><span><span>          };
</span></span><span><span>
</span></span><span><span>          devShells<span>.</span>default <span>=</span> <span>with</span> pkgs; mkShellNoCC {
</span></span><span><span>            packages <span>=</span> [
</span></span><span><span>              zig_0_15
</span></span><span><span>              linux-scripts
</span></span><span><span>            ];
</span></span><span><span>            <span># https://github.com/NixOS/nixpkgs/pull/479423</span>
</span></span><span><span>            shellHook <span>=</span> <span>&#34;unset ZIG_GLOBAL_CACHE_DIR&#34;</span>;
</span></span><span><span>          };
</span></span><span><span>        }
</span></span><span><span>    ));
</span></span><span><span>}</span></span></code></pre></div>
</details>


</div></div>
  </body>
</html>
