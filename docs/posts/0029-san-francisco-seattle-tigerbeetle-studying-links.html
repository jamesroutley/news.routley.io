<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scattered-thoughts.net/log/0029/">Original</a>
    <h1>0029: san francisco, seattle, tigerbeetle, studying, links</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>I&#39;ll be in San Francisco Nov 6-11, and in Seattle for <a href="https://handmade-seattle.com/">Handmade</a> Nov 15-19.</p>
<h2 id="tigerbeetle">tigerbeetle</h2>
<p>In October I joined the database team at <a href="https://tigerbeetle.com/">TigerBeetle</a>.</p>
<p>Like most of my major life decisions, this was made somewhat impulsively. There wasn&#39;t one big reason, rather many nudges that all happened to peak at the same time:</p>
<ul>
<li>I&#39;m getting tired of working alone and I&#39;ve had no success finding collaborators. All of the people I&#39;d like to work with are either already busy working full-time or are totally burnt out.</li>
<li>For the last year I&#39;ve been feeling I&#39;m stagnating - not being pushed outside my comfort zone. HYTRADBOI was the last thing I did that felt uncomfortable.</li>
<li>I&#39;ve been thinking for a long time about collapsing the boundaries between databases and applications. TigerBeetle is doing this for real in a challenging domain.</li>
<li>The chance to bring up a production-quality storage engine from scratch would fill a huge gap in my skills.</li>
<li>Designing a query language for TigerBeetle is a massive nerd-snipe because of the unusual constraints - bounded latency, no dynamic allocation, deterministic results etc.</li>
</ul>
<p>I&#39;ll be working for TigerBeetle 3 out of every 4 weeks, with the other week reserved for research, tinkering and writing here. I think the direction of my own work next year will be different - I&#39;ll let go of the work on programming languages/environments which consumed most of this year to focus on more near-future work on databases and query engines. </p>
<p>I&#39;m going to return my <a href="https://www.mercatus.org/emergent-ventures">Emergent Ventures</a> grant. That money will have more leverage elsewhere.</p>
<p>I&#39;ll leave my github sponsors open but I&#39;ll take down the banners here, and I think it&#39;s perfectly reasonable for y&#39;all to cancel your sponsorships.</p>
<p>This log will keep going too, because I like to read other peoples monthly notes. It&#39;s a version of social media that respects attention and focus.</p>
<p>The last two years were worthwhile. I will definitely try more independent efforts in the future. But I&#39;ll be better prepared next time, and I won&#39;t go it alone.</p>
<h2 id="notes-to-self">notes to self</h2>
<p>I&#39;ve been doing a lot of code review lately. It&#39;s difficult to really pay attention when reading code vs writing it. A trick I&#39;ve been trying lately is to imagine that someone told me they already found a subtle bug in the PR I&#39;m reviewing, and they bet I won&#39;t find it.</p>
<p>Similarly, for my own PRs I&#39;ve started reviewing the diff myself before submitting it, with the goal of predicting all the questions that the reviewer will ask and answering them in advance.</p>
<p>TigerBeetle has a lot of asserts (<a href="https://github.com/tigerbeetledb/tigerbeetle/blob/878f83cc2caa52c945743fd2f4bc44f6026c25f2//src/lsm/segmented_array.zig#L447-L529">eg</a>). I&#39;m finding they fill a lot of different purposes:</p>
<ul>
<li>Short term memory. It&#39;s tiring and error-prone to keep track of eg the possible values of an index throughout a function. Was it inclusive or exclusive at the end? Asserting the range of values pulls that reasoning out of short-term memory and into the code, where the fuzzer can tell you you&#39;re wrong.</li>
<li>Guarding against changes in global invariants. Often I&#39;ll see a function assert an invariant and at first it seems silly because that function is only ever called from one place and the caller already asserted the invariant. But code changes over time and it&#39;s easy to lose track of conditions like that that aren&#39;t right next to each other in the code. The assertion prevents mistakes in the future when the function a new caller, or the calling site gets moved.</li>
<li>Documenting invariants, and when they are broken and restored. Several data-structures have <code>verify</code> functions (<a href="https://github.com/tigerbeetledb/tigerbeetle/blob/878f83cc2caa52c945743fd2f4bc44f6026c25f2//src/lsm/segmented_array.zig#L160-L193">eg</a>) which assert all the invariants. In test builds, these <code>verify</code> functions are called before relying on invariants and after restoring them (<a href="https://github.com/tigerbeetledb/tigerbeetle/blob/878f83cc2caa52c945743fd2f4bc44f6026c25f2//src/lsm/segmented_array.zig#L428-L444">eg</a>). This is better than only documenting invariants in comments, because a) it&#39;s unambiguous and b) fuzzing can&#39;t catch incorrect comments.</li>
<li>Checking test coverage. Eg <a href="https://github.com/tigerbeetledb/tigerbeetle/blob/878f83cc2caa52c945743fd2f4bc44f6026c25f2//src/lsm/segmented_array.zig#L1320-L1321">these assertions</a> check that the random tests have covered two important edge cases.</li>
</ul>
<p>I&#39;m learning to think about disks in a similar way to distributed systems. Many reads and writes can be in flight at one time. They can be reordered before being applied to the disk. In the event of crash, they might not be applied at all. Driver bugs and hardware faults can result in reads and writes being <a href="https://dev.snia.org/sites/default/orig/sdc_archives/2008_presentations/thursday/GarthGoodson_DataCorruption.pdf">corrupted, applied to the wrong location or dropped entirely</a>. Resilient storage requires treating data with the same level of suspicion as reads/writes received over the network.</p>
<p>You can read cpu perf counters before/after a benchmark (<a href="https://github.com/tigerbeetledb/tigerbeetle/blob/878f83cc2caa52c945743fd2f4bc44f6026c25f2//src/lsm/eytzinger_benchmark.zig#L234-L287">eg</a>) rather than trying to run enough iterations to amortize the noise of process setup/teardown. (This is sort of obvious, because the perf command is itself just a program, but it had never occurred to me to find out how to do this).</p>
<p>Zig&#39;s build tool has an undocumented function <code>addOption</code>, which provides an easy way to pass options at the command line or in the build file as comptime constants to the program being built.</p>
<p>Rather than writing <code>slice[a * b .. (a + 1) * b]</code>, write <code>slice[a * b ..][0..b]</code>. It&#39;s clearer, and corresponds more directly to the underlying operation (<code>slice.ptr += a * b</code> and <code>slice.len = b</code>).</p>
<p>When porting c build systems to zig, pick out the underlying commands with <code>strace -fq -s 100 -e trace=execve make 2&gt;&amp;1 | grep $(which gcc)</code>.</p>
<h2 id="studying">studying</h2>
<p>I&#39;m slowly working through <a href="https://www.goodreads.com/en/book/show/57850403-understanding-software-dynamics">Understanding Software Dynamics</a>. </p>
<p><a href="https://github.com/jamii/understanding-software-dynamics/blob/c9de95600813d6c5816738d03b1c33ef90cdc197/mystery1-fixed.zig">Here</a> is some cute zig code for the first chapter, featuring variables whose type depends on the op (<code>total</code>, <code>incr</code>) and compile-time manipulation of the asm strings (<code>** unroll_count</code>).</p>
<pre data-lang="zig"><code data-lang="zig"><span>pub fn </span><span>run</span><span>(</span><span>comptime </span><span>op</span><span>: </span><span>anytype</span><span>) </span><span>void </span><span>{
</span><span>    </span><span>var</span><span> total </span><span>= </span><span>switch </span><span>(op) {
</span><span>        .add </span><span>=&gt; </span><span>@as</span><span>(u32</span><span>, </span><span>3</span><span>)</span><span>,
</span><span>        .fmul </span><span>=&gt; </span><span>@as</span><span>(f32</span><span>, </span><span>3</span><span>)</span><span>,
</span><span>        </span><span>...
</span><span>        </span><span>else </span><span>=&gt; </span><span>unreachable</span><span>,
</span><span>    }</span><span>;
</span><span>
</span><span>    </span><span>const</span><span> incr </span><span>= </span><span>switch </span><span>(op) {
</span><span>        .add </span><span>=&gt; </span><span>@as</span><span>(u32</span><span>, </span><span>3</span><span>)</span><span>,
</span><span>        .fmul </span><span>=&gt; </span><span>@as</span><span>(f32</span><span>, </span><span>1.01</span><span>)</span><span>,
</span><span>        </span><span>...
</span><span>        </span><span>else </span><span>=&gt; </span><span>unreachable</span><span>,
</span><span>    }</span><span>;
</span><span>
</span><span>    </span><span>const</span><span> start </span><span>=</span><span> util.</span><span>rdtscp</span><span>()</span><span>;
</span><span>
</span><span>    </span><span>var </span><span>loop_index</span><span>: </span><span>usize </span><span>= </span><span>0</span><span>;
</span><span>    </span><span>while </span><span>(loop_index </span><span>&lt;</span><span> loop_count_max) : (loop_index </span><span>+= </span><span>1</span><span>) {
</span><span>        </span><span>switch </span><span>(op) {
</span><span>            .add </span><span>=&gt; </span><span>asm volatile </span><span>(
</span><span>                </span><span>\\add %%ebx, %%eax;
</span><span>                </span><span>**</span><span> unroll_count
</span><span>                : [total] </span><span>&#34;={eax}&#34; </span><span>(total)</span><span>,
</span><span>                : [total] </span><span>&#34;{eax}&#34; </span><span>(total)</span><span>,
</span><span>                  [incr] </span><span>&#34;{ebx}&#34; </span><span>(incr)</span><span>,
</span><span>            )</span><span>,
</span><span>            .fmul </span><span>=&gt; </span><span>asm volatile </span><span>(
</span><span>                </span><span>\\fmul %%st(1), %%st(0);
</span><span>                </span><span>**</span><span> unroll_count
</span><span>                : [total] </span><span>&#34;={st(0)}&#34; </span><span>(total)</span><span>,
</span><span>                : [total] </span><span>&#34;{st(0)}&#34; </span><span>(total)</span><span>,
</span><span>                  [incr] </span><span>&#34;{st(1)}&#34; </span><span>(incr)</span><span>,
</span><span>            )</span><span>,
</span><span>            </span><span>...
</span><span>            </span><span>else </span><span>=&gt; </span><span>unreachable</span><span>,
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span>const</span><span> elapsed </span><span>=</span><span> util.</span><span>rdtscp</span><span>() </span><span>-</span><span> start</span><span>;
</span><span>
</span><span>    std.debug.</span><span>print</span><span>(</span><span>&#34;{:&gt;4} </span><span>\t</span><span> {d:&gt;6.0} cycles </span><span>\t</span><span> {d:&gt;6.2} cycles/iteration </span><span>\t</span><span> total={}</span><span>\n</span><span>&#34;</span><span>,</span><span> .{
</span><span>        op</span><span>,
</span><span>        elapsed</span><span>,
</span><span>        </span><span>@intToFloat</span><span>(f64</span><span>,</span><span> elapsed) </span><span>/</span><span> loop_count_max </span><span>/</span><span> unroll_count</span><span>,
</span><span>        total</span><span>,
</span><span>    })</span><span>;
</span><span>}
</span></code></pre>
<p>Along the way I learned how to print perf counters that aren&#39;t built in to the perf binary. Intel has a full list of counters <a href="https://perfmon-events.intel.com/">here</a>. For alder lake, in the additional info for eg ASSISTS.FP we can see <code>EventSel=C1H UMask=02H</code>. That becomes <code>perf stat -e &#39;cpu_core/event=0xc1,umask=0x02,name=assists.fp/&#39;</code>.</p>
<p>Judging from my progress so far I&#39;ll be working on this book for a while, but next on the list is likely <a href="https://en.algorithmica.org/hpc/">Algorithms for Modern Hardware</a> followed by <a href="https://pages.cs.wisc.edu/%7Eremzi/OSTEP/">Operating Systems: Three Easy Pieces</a>. </p>
<p>I skimmed this years <a href="https://www.p99conf.io/">P99</a>, <a href="http://hpts.ws/agenda.html">HPTS</a> and <a href="https://www.thestrangeloop.com/">Strange Loop</a> talks too. Not much stands out in my memory. The <a href="https://www.p99conf.io/session/a-new-io-scheduler-algorithm-for-mixed-workloads/">ScyllaDB IO scheduler</a> seems interesting but is beyond me at the moment. Marc Brookers talk on <a href="https://brooker.co.za/blog/2022/06/02/formal.html">the need for tools to understand system dynamics</a> resonated but doesn&#39;t itself contain any answers.</p>
<h2 id="links">links</h2>
<p><a href="https://from-a-to-remzi.blogspot.com/2014/01/the-case-for-free-online-books-fobs.html">The case for free online books</a>. Among other arguments, notes the ability to cite a book with a link that other people can trivially check. This is huge - fact-checking citations used to require manual work (and often a university library subscription) but if all books are online then following citations is trivial.</p>
<p><a href="http://transactional.blog/simulation/buggify.html">BUGGIFY</a> - notes on how FoundationDB helps the fuzzer into weird edge cases.</p>
<p>Everything about <a href="https://www.youtube.com/watch?v=xvlsJ3FqNYU">this automata toy</a> is wonderful.</p>
<p><a href="https://ziglang.org/download/0.10.0/release-notes.html">Zig 0.10.0 shipped</a>. The bigs news is the self-hosted compiler, but also of note:</p>
<ul>
<li>packed structs apparently work now</li>
<li><code>inline switch</code> shipped</li>
<li>much better c abi compliance</li>
<li>std.debug.Trace seems like a useful tool</li>
</ul>
<p><code>inline switch</code> is nice by itself, but I&#39;m excited to see if <a href="https://github.com/ziglang/zig/issues/7772">inline parameters</a> will make it into the language too. Together they&#39;ll make it easy in vectorized interpreters to write a single function and produce both specialized versions for common arguments and a generic fallback for other arguments.</p>

</article></div>
  </body>
</html>
