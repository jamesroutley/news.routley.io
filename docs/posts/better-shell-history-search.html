<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tratt.net/laurie/blog/2025/better_shell_history_search.html">Original</a>
    <h1>Better Shell History Search</h1>
    
    <div id="readability-page-1" class="page"><div id="article-body">





<p>I spend an awful lot of my day in Unix terminals running shell commands. For
some reason, the variance in efficiency between different people when using the shell
is huge: I know people who can run rings around me, and I’ve come across
more than one paid professional who doesn’t use the “up” key to retrieve the
previous command.</p>
<p>I chose that last example very deliberately: most of the commands most of us
run in the shell are highly repetitive. I typically run around 50-100 unique
(i.e. syntactically distinct) shell commands per working day <span>[1]</span> — but
I’ll often run a tiny subset of those commands (e.g. <code>cargo test</code>) hundreds of
time in a single day.</p>
<p>Since many command-line tools have hard-to-remember options, we can save huge
chunks of time – not to mention make fewer errors – if we can search our
shell history to find a previous incantation of a command we want to run. In
this post I’m going to show how, with little effort, searching shell
history can look like this:</p>
<p><video controls=""><source src="/laurie/blog/extra/2025/better_shell_history_search/skim.mp4" type="video/mp4"/><a href="https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/skim.mp4">[Video]</a></video></p>
<h2><a name="searching_shell_history">Searching shell history</a></h2>
<p>Larger Unix shells such as Bash have long allowed users to search through their
shell history by pressing <code>Ctrl-r</code> and entering a substring. If I (in order)
executed the commands <code>cat /etc/motd</code> then <code>cat /etc/rc.conf</code>, then <code>Ctrl-r</code>
followed by “cat” will first match <code>cat /etc/rc.conf</code>; pressing <code>Ctrl-r</code> again
will cycle backwards for the next match which is <code>cat /etc/motd</code>. I almost
never used this feature, because substring matching is too crude.
For example, I may know the command I want is <code>cat</code>, the leaf
name I’m looking for is <code>motd</code> but I don’t remember the directory: substring
matching can’t help me find what I’m looking for. Instead, I regularly used
<code>grep</code> (with wildcards) to search through my shell’s history file instead.</p>
<p>For me, the game changer was pairing <code>Ctrl-r</code> with
<a href="https://github.com/junegunn/fzf">fzf</a>, which brought two changes. First,
matching is “fuzzy”, so I can type “c mo” and <code>cat /etc/motd</code> will be
matched. Second, multiple matches are shown at once. Typing “cat” will show
me several <code>cat</code> commands, allowing me to quickly select the right
incantation (which may not have been the most recent).</p>
<p>It’s difficult for me to overstate how powerful a feature this is. Few things
in life make me as happy as pressing <code>ctrl-R</code> then typing “<code>l1</code>” and having a 100
character command-line execution that runs a complicated debugging tool, with
multiple environment variables set, whose output gets put in <code>/tmp/l1</code> appear
in my terminal.</p>
<p>Using <code>Ctrl-r</code> and fzf roughly doubled my efficiency in the shell
overnight. Interestingly, it had an even greater long term effect: I became a
more ambitious user of shell commands because I knew I could outsource my
memory to fzf. For example, since it’s now very easy to recall past commands, I
no longer set global environment variables, which had previously caused me
grief when I forgot about them <span>[2]</span>. Now I set environment variables on a
per-command basis, knowing that I can recall them with <code>Ctrl-r</code> and fzf.</p>
<p>For many years my favoured shell was zsh. When I later moved from zsh to fish,
<code>Ctrl-r</code> and fzf was the first thing I configured; and when I moved back to zsh
<span>[3]</span>, and redid my configuration from scratch, <code>Ctrl-r</code> and fzf was again the first
thing I got working (shortly followed by
<a href="https://github.com/zsh-users/zsh-autosuggestions">autosuggestions</a>). If you
take nothing else from this
post than “<code>Ctrl-r</code> and fzf are a significant productivity boon for Unix
users”, then I will have done something useful.</p>
<p>No tool, of course, is perfect. A
couple of months back I somehow stumbled across
<a href="https://github.com/skim-rs/skim">skim</a>, an fzf-alike that out-of-the-box
happens to suit me just a little bit better than fzf. The differences
are mostly minor, and you won’t go far wrong with either tool. That said,
I find that skim’s matching more often finds the commands I want quickly,
I prefer skim’s UI, and I find it easier to install skim on
random boxes — small advantages, perhaps, but enough for switching to be
worth it for me.</p>
<h2><a name="doing_even_better">Doing even better</a></h2>
<p>Finding Skim encouraged me to quickly look around to see what else in this sphere might
improve my productivity. I quickly came across <a href="https://atuin.sh/">Atuin</a>, which is a much
more sophisticated shell history recording mechanism: the video on its front
page showed a much nicer matching UI than I had previously considered possible.</p>
<p>However, I quickly realised Atuin wasn’t for me or, at least, wasn’t easily for
me. These days I regularly <code>ssh</code> into many different servers: over time I’ve
streamlined my shell configuration to a single <code>.zshrc</code> file that I can <code>scp</code>
over to a new machine and which instantly makes me productive. Atuin – and
this isn’t a criticism, because it’s a more powerful tool – is more difficult
to install <span>[4]</span> and setup <span>[5]</span> (I’m also not sure the ‘fuzzy’
aspects of Atuin quite match the heights of fzf/skim). That said, some readers may find
it a useful tool to investigate.</p>
<p>However, what I immediately realised from the Atuin video is that I would like
my fuzzy matcher to show me more useful information about the commands it’s
matching.</p>
<p>In particular, fzf and skim both default to showing me a (to me!) meaningless
integer before my matched command: this had always slightly bothered me, but
I’d never thought to work out what it meant. For example, if I use
zsh + fzf + <code>Ctrl-r</code> I see:</p>
<p><img src="https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/fzf.png" alt=""/></p>
<p>What does 5408 mean and why is it taking up valuable screen space? Skim
tries to be a bit nicer: it will show <code>5408 today&#39;21:26</code> <span>[6]</span>, but that
takes up even more screen space!</p>
<h2><a name="adapting_zsh_and_fzfskim">Adapting zsh and fzf/skim</a></h2>
<p>Fortunately, it turns out that improving the <code>Ctrl-r</code> and the fzf/skim UI is
easy. Instead of wasting space on a meaningless-to-me integer, what I
now see is the following (where <code>11d</code> means “11 days in the past” and so on):</p>
<p><img src="https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/skim.png" alt=""/></p>
<p>I’m going to show how I adapted zsh and skim to do this. My guess is that it
will take very little ingenuity to adapt this to other shells (and adapting
this to fzf mostly involves swapping the <code>sk</code> command for <code>fzf</code>).</p>
<p>The first thing I needed to do is make zsh record <em>when</em> commands
were executed. I added this to my <code>~/.zshrc</code>:</p>
<pre><span>setopt</span><span> EXTENDED_HISTORY
</span><span>setopt</span><span> inc_append_history_time
</span></pre>
<p>The <code>EXTENDED_HISTORY</code> changes the format of <code>.zsh_history</code> to record when (in
seconds from the Unix epoch) a command was executed and (with
<code>inc_append_history_time</code>) how long it ran for. The good news is that these
options migrate “traditionally formatted” history files naturally: any
non-extended-history commands will be given the current date so that
all of <code>.zsh_history</code> is in the same format.</p>
<p>I then needed to understand how zsh’s history ended up being interrogated and
displayed when I pressed <code>Ctrl-r</code>. fzf and skim share almost exactly the same
code here: I’ll use skim’s <a href="https://github.com/skim-rs/skim/blob/master/shell/key-bindings.zsh">zsh key
bindings</a>
as my example. In essence, both tools define a function <code>history-widget</code>
which they then bind to <code>Ctrl-r</code>:</p>
<pre><span>history-widget</span><span>() { </span><span>... </span><span>}
</span><span>zle</span><span>     -N</span><span>   history-widget
</span><span>bindkey </span><span>&#39;</span><span>^R</span><span>&#39; history-widget
</span></pre>
<p>One can override the version fzf and skim provide by putting the code above
into your <code>~/.zshrc</code> after the point you import their normal key bindings.</p>
<p>Let’s look at skim’s <code>history-widget</code>:</p>
<pre><span>skim-history-widget</span><span>() {
</span><span>  </span><span>local </span><span>selected num
</span><span>  </span><span>setopt</span><span> localoptions noglobsubst noposixbuiltins pipefail no_aliases </span><span>2</span><span>&gt; /dev/null
</span><span>  </span><span>local </span><span>awk_filter</span><span>=&#39;</span><span>{ cmd=$0; sub(/^\s*[0-9]+\**\s+/, &#34;&#34;, cmd); if (!seen[cmd]++) print $0 }</span><span>&#39;  </span><span># filter out duplicates
</span><span>  </span><span>local </span><span>n</span><span>=</span><span>2 </span><span>fc_opts</span><span>=&#39;&#39;
</span><span>  </span><span>if </span><span>[[ </span><span>-o</span><span> extended_history </span><span>]]</span><span>; </span><span>then
</span><span>    </span><span>local </span><span>today</span><span>=$</span><span>(</span><span>date</span><span> +</span><span>%</span><span>Y</span><span>-</span><span>%</span><span>m</span><span>-</span><span>%</span><span>d</span><span>)
</span><span>    </span><span># For today&#39;s commands, replace date ($2) with &#34;today&#34;, otherwise remove time ($3).
</span><span>    </span><span># And filter out duplicates.
</span><span>    </span><span>awk_filter</span><span>=&#39;</span><span>{
</span><span>      if ($2 == &#34;</span><span>&#39;$</span><span>today</span><span>&#39;</span><span>&#34;) sub($2 &#34; &#34;, &#34;today</span><span>&#39;</span><span>\&#39;</span><span>&#39;</span><span>&#34;)
</span><span>      else sub($3, &#34;&#34;)
</span><span>      line=$0; $1=&#34;&#34;; $2=&#34;&#34;; $3=&#34;&#34;
</span><span>      if (!seen[$0]++) print line
</span><span>    }</span><span>&#39;
</span><span>    </span><span>fc_opts</span><span>=&#39;</span><span>-i</span><span>&#39;
</span><span>    </span><span>n</span><span>=</span><span>3
</span><span>  </span><span>fi
</span><span>  </span><span>selected</span><span>=( $(</span><span>fc</span><span> -rl </span><span>$</span><span>fc_opts</span><span> 1 | </span><span>awk </span><span>&#34;$</span><span>awk_filter</span><span>&#34; |
</span><span>    </span><span>SKIM_DEFAULT_OPTIONS</span><span>=&#34;</span><span>--height </span><span>$</span><span>{</span><span>SKIM_TMUX_HEIGHT</span><span>:-</span><span>40%} </span><span>$</span><span>SKIM_DEFAULT_OPTIONS</span><span> -n</span><span>$</span><span>n</span><span>..,.. --bind=ctrl-r:toggle-sort </span><span>$</span><span>SKIM_CTRL_R_OPTS</span><span> --query=</span><span>$</span><span>{</span><span>(qqq)LBUFFER</span><span>} --no-multi</span><span>&#34; $(</span><span>__skimcmd</span><span>)) )
</span><span>  </span><span>...
</span></pre>
<p>The first thing to note is that – thanks to <code>EXTENDED_HISTORY</code> – in
my context the <code>-o extended_history</code> check always returns <code>true</code>, so the body of the <code>if</code> is
always executed.</p>
<p>We can then skip ahead: <code>fc -rli 1</code> gets zsh to output its history in a more
easily digestible form than going through <code>.zsh_history</code> directly:</p>
<pre><span>$ fc -rli 1
</span><span>    4  2025-02-07 15:05  pizauth status
</span><span>    3  2025-02-07 15:03  cargo run --release server
</span><span>    2  2025-02-07 15:03  email quick
</span><span>    1  2025-02-07 14:59  rsync_cmd bencher16 ./build.sh cargo test nested_tracing
</span></pre>
<p>We can also now see what the magical integers from earlier are: they’re the row
numbers from <code>fc</code>, where <code>1</code> is the oldest command in my <code>~/.zsh_history</code>! These
are, in some situations, used as identifiers because one can ask zsh to “return
me command 5408”.</p>
<p>The awk code streams over this output, replacing today’s date with the literal
string <code>today</code>, removes the hours/minutes output from previous days, and
removes duplicates.</p>
<p>Although it’s easily missed, in the final line of the code snippet is
<code>-n$n..,..</code> which tells skim which whitespace-separated columns to fuzzy
match and print out.</p>
<p>At this point we now need to decide how to adapt things to our purposes.
The first thing we need to do with <code>fc</code>’s output is convert the time to seconds
since the Unix epoch. We can get <code>fc</code> to do that for us with <code>-t &#39;%s&#39;</code>. Instead
of outputting <code>2025-03-21 22:10</code> we now get <code>1742595052</code>. Notice that two
fields have now become one! Because <code>fc</code> adds leading space to the row
numbers, we’ll strip that off by piping <code>fc</code>’s output through <code>sed -E &#34;s/^ *//&#34;</code> <span>[7]</span>.</p>
<p>I then needed to decide how to format “how far in the past was the command
run”. After a few tries, I decided that a good approach is to give absolute
<code>hour:minute</code> times for commands in the last 20 hours, and <code>1d</code>, <code>2d</code> (etc.)
for commands 1 or more days in the past. Why 20 hours? Well, it turns out that
if I start work at 08:00, press <code>Ctrl-r</code> and see an entry at <code>08:01</code> I won’t
realise that was <em>yesterday’s</em> 08:01 (today’s 08:01 is only 60 seconds in the
future!). 20 hours solves this ambiguity: it means that, at 08:00,
yesterday afternoon’s commands show as <code>16:33</code> but yesterday
morning’s commands as <code>1d</code>.</p>
<p>We now need to switch to awk. I will admit that I initially balked at the use
of awk, a language I have never used before. I quickly explored alternatives
before realising why the code uses awk: every Unix machine has awk installed.
For those unfamiliar with awk, the program that we’re writing iterates over
each line in the input, splits that line up by whitespace, and puts the split
fields into the variables <code>$1</code>, <code>$2</code> (etc.). We’ll keep the duplicate detection
from the awk code above, but change most of the rest.</p>
<p>The first thing we need to do in awk is to convert the Unix epoch time for a
command (in field/variable <code>$2</code>) to an integer, and calculate how many seconds
it is in the past using <code>systime</code> (which returns the current time relative to
the Unix epoch):</p>
<pre><span>ts = int($2)
</span><span>delta = systime() - ts
</span></pre>
<p>We can then convert <code>delta</code> seconds to days by dividing by 86,400 (24h * 60m *
60s == 86,400s). It’s then a simple series of <code>if</code>/<code>else</code> to format this nicely
bearing in mind that:</p>
<ol>
<li>20h == 72,000s</li>
<li>string concatenation and int-to-string conversion in awk is implicit</li>
</ol>
<p>The conversion code looks as follows:</p>
<pre><span>delta_days = int(delta / 86400)
</span><span>if (delta_days &lt; 1 &amp;&amp; delta &lt; 72000) { $2=strftime(&#34;%H:%M&#34;, ts) }
</span><span>else if (delta_days == 0) { $2=&#34;1d&#34; }
</span><span>else { $2=delta_days &#34;d&#34; }
</span></pre>
<p>One could choose to divvy things up further, perhaps showing commands older
than a week with “1w” and so on: I haven’t found that worth worrying about yet.</p>
<p>There is, however, one minor fly in the ointment: clock skew. This could cause
commands to appear to be executing in the future. I’ve not seen seen this
happen in practice yet, but bitter experience with computers and clocks tells
me it will at some point. I’ve defensively catered for the inevitable confusion
that will cause me by using a <code>+</code> prefix for such cases:</p>
<pre><span>delta_days = int(delta / 86400)
</span><span>if (delta &lt; 0) { $2=&#34;+&#34; (-delta_days) &#34;d&#34; }
</span><span>else ...
</span></pre>
<p>Notice that I had to put <code>(-delta_days)</code> in brackets as otherwise – for reasons I’m
too lazy to investigate – awk doesn’t concatenate the integer and
string in the way I want.</p>
<p>Since we have one fewer field than before we can slightly simplify our output:</p>
<pre><span>line=$0; $1=&#34;&#34;; $2=&#34;&#34;
</span><span>if (!seen[$0]++) print line
</span></pre>
<p>That’s the awk code done. We then need to make one change to the <code>selected=...</code>
line changing <code>-n$n..,..</code> to <code>--with-nth $n..</code>. This tells fzf and skim to
suppress the output of the row number and not to make it part
of the fuzzy matching either.</p>
<p>Putting all that together, the updated chunk of the <code>history-widget</code> now
looks as follows (you can find the <a href="https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/zsh_history_widget.sh">whole code chunk
here</a>):</p>
<pre><span>    </span><span>local </span><span>n</span><span>=</span><span>1 </span><span>fc_opts</span><span>=&#39;&#39;
</span><span>    </span><span>if </span><span>[[ </span><span>-o</span><span> extended_history </span><span>]]</span><span>; </span><span>then
</span><span>      </span><span>awk_filter</span><span>=&#39;
</span><span>{
</span><span>  ts = int($2)
</span><span>  delta = systime() - ts
</span><span>  delta_days = int(delta / 86400)
</span><span>  if (delta &lt; 0) { $2=&#34;+&#34; (-delta_days) &#34;d&#34; }
</span><span>  else if (delta_days &lt; 1 &amp;&amp; delta &lt; 72000) { $2=strftime(&#34;%H:%M&#34;, ts) }
</span><span>  else if (delta_days == 0) { $2=&#34;1d&#34; }
</span><span>  else { $2=delta_days &#34;d&#34; }
</span><span>  line=$0; $1=&#34;&#34;; $2=&#34;&#34;
</span><span>  if (!seen[$0]++) print line
</span><span>}</span><span>&#39;
</span><span>      </span><span>fc_opts</span><span>=&#39;</span><span>-i</span><span>&#39;
</span><span>      </span><span>n</span><span>=</span><span>2
</span><span>    </span><span>fi
</span><span>    </span><span>selected</span><span>=( $(</span><span>fc</span><span> -rl </span><span>$</span><span>fc_opts -t </span><span>&#39;</span><span>%s</span><span>&#39; 1 | </span><span>sed</span><span> -E </span><span>&#34;</span><span>s/^ *//</span><span>&#34; | </span><span>awk </span><span>&#34;$</span><span>awk_filter</span><span>&#34; |
</span><span>      </span><span>SKIM_DEFAULT_OPTIONS</span><span>=&#34;</span><span>--height </span><span>$</span><span>{</span><span>SKIM_TMUX_HEIGHT</span><span>:-</span><span>40%} </span><span>$</span><span>SKIM_DEFAULT_OPTIONS</span><span> --with-nth </span><span>$</span><span>n</span><span>.. --bind=ctrl-r:toggle-sort </span><span>$</span><span>SKIM_CTRL_R_OPTS</span><span> --query=</span><span>$</span><span>{</span><span>(qqq)LBUFFER</span><span>} --no-multi</span><span>&#34; $(</span><span>__skimcmd</span><span>)) )
</span></pre>
<p>That simple change is enough to give me this output when I press <code>Ctrl-r</code> and
start typing:</p>
<p><video controls=""><source src="/laurie/blog/extra/2025/better_shell_history_search/skim.mp4" type="video/mp4"/><a href="https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/skim.mp4">[Video]</a></video></p>
<h2><a name="summary">Summary</a></h2>
<p>I’ve been using the changes above for about 6 weeks, and I’ve found it a
meaningful productivity enhancement. It turns out that I often remember enough
about a command I want to recall that seeing if a match is “1d” or “7d” in the
past is enough to immediately rule it in or out without scanning rightwards.
Occasionally I even search on the time delta itself: if I start a match with
“2d” fzf or skim will naturally search commands from 2 days ago.</p>
<p>But, perhaps, there is a larger point to take from this post. If, like me, you
spend a lot of your life in a Unix terminal, it can be easy to fall into
patterns of usage that would be recognisable to shell users from the 1970s.
Not only can we do better, it’s easy to do so, and the productivity
gains can be substantial!</p>
<p><strong>Acknowledgements</strong>: thanks to <a href="http://www.eddbarrett.co.uk/">Edd Barrett</a> for comments.</p>


<p>

2025-03-25 11:50

<a href="https://tratt.net/laurie/blog/2024/can_we_retain_the_benefits_of_transitive_dependencies_without_undermining_security.html">Older</a>

</p>




<h3>Footnotes</h3>
<div><p><a name="5c6af7402599"><span>[1]</span></a></p><div><p>One can use the <code>fc</code> command to find this out, but there are some
cross-platform annoyances in dealing with date formats. I used variants of
this Python code to quickly analyse my shell history:</p>
<pre><span>from </span><span>datetime </span><span>import </span><span>datetime
</span><span>days = {}
</span><span>for </span><span>l </span><span>in </span><span>open</span><span>(&#34;</span><span>.zsh_history</span><span>&#34;):
</span><span>  </span><span>if </span><span>len</span><span>(l.</span><span>split</span><span>(&#34;</span><span>:</span><span>&#34;)) &lt; </span><span>3</span><span>: </span><span>continue
</span><span>  </span><span>_</span><span>, t, cmd = [x.</span><span>strip</span><span>() </span><span>for </span><span>x </span><span>in </span><span>l.</span><span>split</span><span>(&#34;</span><span>:</span><span>&#34;, </span><span>2</span><span>)]
</span><span>  d = datetime.</span><span>fromtimestamp</span><span>(int(t)).</span><span>strftime</span><span>(&#34;</span><span>%Y</span><span>-</span><span>%m</span><span>-</span><span>%d</span><span>&#34;)
</span><span>  cmd = cmd.</span><span>split</span><span>(&#34;</span><span>;</span><span>&#34;)[</span><span>1</span><span>]
</span><span>  cmds = days[d] = days.</span><span>get</span><span>(d, set())
</span><span>  cmds.</span><span>add</span><span>(cmd)
</span><span>print</span><span>(</span><span>len</span><span>(days[&#34;</span><span>2025-03-19</span><span>&#34;]))
</span></pre>
</div></div>
<div id="pu_5c6af7402599" onclick="this.style.display=&#39;none&#39;"><p><span>☒</span></p><p>One can use the <code>fc</code> command to find this out, but there are some
cross-platform annoyances in dealing with date formats. I used variants of
this Python code to quickly analyse my shell history:</p>
<pre><span>from </span><span>datetime </span><span>import </span><span>datetime
</span><span>days = {}
</span><span>for </span><span>l </span><span>in </span><span>open</span><span>(&#34;</span><span>.zsh_history</span><span>&#34;):
</span><span>  </span><span>if </span><span>len</span><span>(l.</span><span>split</span><span>(&#34;</span><span>:</span><span>&#34;)) &lt; </span><span>3</span><span>: </span><span>continue
</span><span>  </span><span>_</span><span>, t, cmd = [x.</span><span>strip</span><span>() </span><span>for </span><span>x </span><span>in </span><span>l.</span><span>split</span><span>(&#34;</span><span>:</span><span>&#34;, </span><span>2</span><span>)]
</span><span>  d = datetime.</span><span>fromtimestamp</span><span>(int(t)).</span><span>strftime</span><span>(&#34;</span><span>%Y</span><span>-</span><span>%m</span><span>-</span><span>%d</span><span>&#34;)
</span><span>  cmd = cmd.</span><span>split</span><span>(&#34;</span><span>;</span><span>&#34;)[</span><span>1</span><span>]
</span><span>  cmds = days[d] = days.</span><span>get</span><span>(d, set())
</span><span>  cmds.</span><span>add</span><span>(cmd)
</span><span>print</span><span>(</span><span>len</span><span>(days[&#34;</span><span>2025-03-19</span><span>&#34;]))
</span></pre>
</div>
<div><p><a name="506ea5576343"><span>[2]</span></a></p><p>Indeed, when other people have “weird” behaviour in the shell,
the first thing I ask them to do is check which global environment variables
have been set.</p></div>
<div id="pu_506ea5576343" onclick="this.style.display=&#39;none&#39;"><p><span>☒</span></p><p>Indeed, when other people have “weird” behaviour in the shell,
the first thing I ask them to do is check which global environment variables
have been set.</p>
</div>
<div><p><a name="7ceec4048226"><span>[3]</span></a></p><p>I like fish’s out-of-the-box behaviour, but left it for two reasons.
First, the differences with a POSIX shell aren’t marked improvements, but
writing “normal” shell scripts then required my brain to switch modes. Second,
fish defaults to making some settings like path adjustments <a href="https://github.com/fish-shell/fish-shell/issues/9648">global and
permanent</a>. I encouraged
a number of people to fish: every single person (no exaggeration) ended up
making the same security-worrying mistakes I did. I thus found myself no longer able
to recommend it to others, at which point I wondered why I was using it myself.
Such is life.</p></div>
<div id="pu_7ceec4048226" onclick="this.style.display=&#39;none&#39;"><p><span>☒</span></p><p>I like fish’s out-of-the-box behaviour, but left it for two reasons.
First, the differences with a POSIX shell aren’t marked improvements, but
writing “normal” shell scripts then required my brain to switch modes. Second,
fish defaults to making some settings like path adjustments <a href="https://github.com/fish-shell/fish-shell/issues/9648">global and
permanent</a>. I encouraged
a number of people to fish: every single person (no exaggeration) ended up
making the same security-worrying mistakes I did. I thus found myself no longer able
to recommend it to others, at which point I wondered why I was using it myself.
Such is life.</p>
</div>
<div><p><a name="bb8b39279383"><span>[4]</span></a></p><p>I must admit that the sheer length of the Atuin <a href="https://github.com/atuinsh/atuin/releases/latest/download/atuin-installer.sh">installation
script</a>
was the first surprise. Atuin also doesn’t currently have an OpenBSD port (i.e.
“package”). That isn’t Atuin’s fault and it isn’t necessarily a show-stopper –
I later made an OpenBSD port for Skim – but when I’m quickly experimenting
with new software, it is a barrier.</p></div>
<div id="pu_bb8b39279383" onclick="this.style.display=&#39;none&#39;"><p><span>☒</span></p><p>I must admit that the sheer length of the Atuin <a href="https://github.com/atuinsh/atuin/releases/latest/download/atuin-installer.sh">installation
script</a>
was the first surprise. Atuin also doesn’t currently have an OpenBSD port (i.e.
“package”). That isn’t Atuin’s fault and it isn’t necessarily a show-stopper –
I later made an OpenBSD port for Skim – but when I’m quickly experimenting
with new software, it is a barrier.</p>
</div>
<div><p><a name="f19d27f3e13d"><span>[5]</span></a></p><p>The network aspects of Atuin also gave me the heebie-jeebies.
Reasonable people can differ on such matters.</p></div>
<div id="pu_f19d27f3e13d" onclick="this.style.display=&#39;none&#39;"><p><span>☒</span></p><p>The network aspects of Atuin also gave me the heebie-jeebies.
Reasonable people can differ on such matters.</p>
</div>
<div><p><a name="a0e268281570"><span>[6]</span></a></p><p>No, I’m not sure why there’s only <code>&#39;</code> mark in there. This may
ultimately be a quirk of the awk implementation I’m using.</p></div>
<div id="pu_a0e268281570" onclick="this.style.display=&#39;none&#39;"><p><span>☒</span></p><p>No, I’m not sure why there’s only <code>&#39;</code> mark in there. This may
ultimately be a quirk of the awk implementation I’m using.</p>
</div>
<div><p><a name="597110c4ea66"><span>[7]</span></a></p><p>I’m sure there’s a way to do this in awk, but the things I tried
didn’t seem portable across the different awk versions I tried, so I fell
back on <code>sed</code>.</p></div>
<div id="pu_597110c4ea66" onclick="this.style.display=&#39;none&#39;"><p><span>☒</span></p><p>I’m sure there’s a way to do this in awk, but the things I tried
didn’t seem portable across the different awk versions I tried, so I fell
back on <code>sed</code>.</p>
</div>


<h3>Comments</h3>

<div id="comments">

<form id="comment-form" action="dummy" method="post" onsubmit="comment(event)">
  <div>
  
  <div>
  <p>
  <label for="notify">Notify me of further comments</label></p></div>
  </div>

  
</form>

</div>





</div></div>
  </body>
</html>
