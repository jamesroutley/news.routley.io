<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://begriffs.com/posts/2022-07-17-debugging-gdb-ddd.html">Original</a>
    <h1>Pleasant debugging with GDB and DDD</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      <div>
        <div>
  

  <div>
    <p>GDB is an old and ubiquitous debugger for Linux and BSD systems that has extensive language, processor, and binary format support. Its interface is a little cryptic, but learning GDB pays off.</p>
<p>This article is a set of miscellaneous configuration and scripting tricks that illustrate reusable principles. It assumes you’re familiar with the basics of debugging, like breakpoints, stepping, inspecting variables, etc.</p>
<p><strong>Table of contents</strong></p>
<ul>
<li><a href="#gdb-front-ends">GDB front ends</a>
<ul>
<li><a href="#fixing-ddd-freeze-on-startup">Fixing DDD freeze on startup</a></li>
<li><a href="#honoring-gdbinit-changes">Honoring gdbinit changes</a></li>
<li><a href="#dark-mode">Dark mode</a></li>
<li><a href="#utf-8-rendering">UTF-8 rendering</a></li>
<li><a href="#remote-gdb-configuration">Remote GDB configuration</a></li>
</ul></li>
<li><a href="#gdb-tricks">GDB tricks</a>
<ul>
<li><a href="#useful-execution-commands">Useful execution commands</a></li>
<li><a href="#batch-mode">Batch mode</a></li>
<li><a href="#user-defined-commands">User-defined commands</a></li>
<li><a href="#hooks">Hooks</a></li>
</ul></li>
<li><a href="#python-api">Python API</a>
<ul>
<li><a href="#simple-helper-functions">Simple helper functions</a></li>
<li><a href="#pretty-printing">Pretty printing</a></li>
</ul></li>
<li><a href="#ddd-features">DDD features</a>
<ul>
<li><a href="#historical-values">Historical values</a></li>
<li><a href="#interesting-shortcuts">Interesting shortcuts</a></li>
</ul></li>
<li><a href="#further-reading">Further reading</a></li>
</ul>
<h3 id="gdb-front-ends">GDB front ends</h3>
<p>By default, GDB provides a terse line-based terminal. You need to explicitly ask to print the source code being debugged, the values of variables, or the current list of breakpoints. There are four ways to customize this interface. Ordered from basic to complicated, they are:</p>
<ol type="1">
<li>Get used to the <strong>default</strong> behavior. Then you’ll be comfortable on any system with GDB installed. However, this approach does forego some real conveniences.</li>
<li>Enable the built-in GDB <strong>TUI mode</strong> with the <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/TUI.html">-tui command line flag</a> (available since GDB version 7.5). The TUI creates Curses windows for source, registers, commands, etc. It’s easier to trace execution through the code and spot breakpoints than in the default interface.</li>
<li>Customize the UI using <strong>scripting</strong>, sourced from your <code>.gdbinit</code>. Some good examples are projects like <a href="https://github.com/cyrus-and/gdb-dashboard">gdb-dashboard</a> and <a href="https://github.com/hugsy/gef">gef</a>.</li>
<li>Use a <strong>graphical front-end</strong> that communicates with an “inferior” GDB instance. Front ends either use the GDB machine interface (MI) to communicate, or they screen scrape sessions directly.</li>
</ol>
<p>In my experiments, the TUI mode (option two) seemed promising, but it has some limitations:</p>
<ul>
<li>no persistent window to display variables or the call stack</li>
<li>no ability to set or clear breakpoints by mouse</li>
<li>no value inspection with mouse hover</li>
<li>mouse scroll wheel didn’t work for me on OpenBSD+xterm</li>
<li>no interactive structure/pointer exploration</li>
<li>no historical value tracking for variables (aside from GDB’s Linux-only <a href="https://sourceware.org/gdb/onlinedocs/gdb/Process-Record-and-Replay.html">process record and replay</a>)</li>
</ul>
<p>Ultimately I chose option four, with the <a href="https://www.gnu.org/software/ddd/">Data Display Debugger</a> (DDD). It’s fairly ancient, and requires configuration changes to work at all with recent versions of GDB. However, it has a lot of features delivered in a 3MB binary, with no library dependencies other than a Motif-compatible UI toolkit. DDD can also control GDB sessions remotely over SSH.</p>
<figure>
<img src="https://charles.inclouds.space/blog/images/ddd.png" alt="DDD screenshot"/><figcaption aria-hidden="true">DDD screenshot</figcaption>
</figure>
<h4 id="fixing-ddd-freeze-on-startup">Fixing DDD freeze on startup</h4>
<p>As a front-end, DDD translates user actions to text commands that it sends to GDB. Newer front-ends use GDB’s unambiguous machine interface (MI), but DDD never got updated for that. It parses the standard text interface, essentially screen scraping GDB’s regular output. This causes some problems, but there are workarounds.</p>
<p>Upon starting DDD, the first serious error you’ll run into is the program locking up with this message:</p>
<pre><code>Waiting until GDB gets ready...</code></pre>
<p>The freeze happens because DDD is looking for the prompt <code>(gdb)</code>. However, DDD never sees that prompt because it incorrectly changed the prompt at startup.</p>
<p>To fix this error, you must explicitly set the prompt and <em>unset</em> the extended-prompt. In <code>~/.ddd/init</code> include this code:</p>
<pre><code>Ddd*gdbSettings: \
unset extended-prompt\n\
set prompt (gdb) \n</code></pre>
<p>The root of the problem is that during DDD’s first run, it probes all GDB settings, and saves them in to its .ddd/init file for consistency in future runs. It probes by running <code>show settingname</code> for all settings. However, it interprets the results wrong for these settings:</p>
<ul>
<li>exec-direction</li>
<li>extended-prompt</li>
<li>filename-display</li>
<li>interactive-mode</li>
<li>max-value-size</li>
<li>mem inaccessible-by-default</li>
<li>mpx bound</li>
<li>record btrace bts</li>
<li>record btrace pt</li>
<li>remote interrupt-sequence</li>
<li>remote system-call-allowed</li>
<li>tdesc</li>
</ul>
<p>The incorrect detection is especially bad for <code>extended-prompt</code>. GDB reports the value as <code>not set</code>, which DDD interprets – not as the lack of a value – but as text to set for the extended prompt. That text overrides the regular prompt, causing GDB to output <code>not set</code> as its actual prompt.</p>
<h4 id="honoring-gdbinit-changes">Honoring gdbinit changes</h4>
<p>As mentioned, DDD probes and saves all GDB settings during first launch. While specifying all settings in <code>~/.ddd/init</code> might make for deterministic behavior on local and remote debugging sessions, it’s inflexible. I want <code>~/.gdbinit</code> to be the source of truth.</p>
<p>Thus you should:</p>
<ul>
<li>Delete all <code>Ddd*gdbSettings</code> other than the prompt ones above, and</li>
<li>Set <code>Ddd*saveOptionsOnExit: off</code> to prevent DDD from putting the values back.</li>
</ul>
<h4 id="dark-mode">Dark mode</h4>
<p>DDD’s default color scheme is a bit glaring. For dark mode in the code window, console, and data display panel, set these resources:</p>
<pre><code>Ddd*XmText.background:             black
Ddd*XmText.foreground:             white
Ddd*XmTextField.background:        black
Ddd*XmTextField.foreground:        white
Ddd*XmList.background:             black
Ddd*XmList.foreground:             white
Ddd*graph_edit.background:         #333333
Ddd*graph_edit.edgeColor:          red
Ddd*graph_edit.nodeColor:          white
Ddd*graph_edit.gridColor:          white</code></pre>
<h4 id="utf-8-rendering">UTF-8 rendering</h4>
<p>By default, DDD uses X core fonts. All its resources, like <code>Ddd*defaultFont</code>, can pick from only those legacy fonts, which don’t properly render UTF-8. For proper rendering, we have to change the Motif <a href="http://www.ist.co.uk/motif/books/vol6A/ch-24.fm.html">rendering table</a> to use the newer FreeType (XFT) fonts. Pick an XFT font you have on your system; I chose Inconsolata:</p>
<pre><code>Ddd*renderTable: rt
Ddd*rt*fontType: FONT_IS_XFT
Ddd*rt*fontName: Inconsolata
Ddd*rt*fontSize: 8</code></pre>
<p>The change applies to all UI areas of the program <em>except</em> the data display window. That window comes from an earlier codebase bolted on to DDD, and I don’t know how to change its rendering. AFAICT, you can choose only legacy fonts there, with <code>Ddd*dataFont</code> and <code>Ddd*dataFontSize</code>.</p>
<p>Although international graphemes are garbled in the data display window, you can inspect UTF-8 variables by printing them in the GDB console, or by hovering the mouse over variable names for a tooltip display.</p>
<h4 id="remote-gdb-configuration">Remote GDB configuration</h4>
<p>DDD interacts with GDB through the terminal like a user would, so it can drive debugging sessions over SSH just as easily as local sessions. It also knows how to fetch remote source files, and find remote program PIDs to which GDB can attach. DDD’s default program for running commands on a remote inferior is <code>remsh</code> or <code>rsh</code>, but it can be customized to use SSH:</p>
<pre><code>Ddd*rshCommand: ssh -t</code></pre>
<p>In my experience, the <code>-t</code> is needed, or else GDB warnings and errors can appear out of order with the <code>(gdb)</code> prompt, making DDD hang.</p>
<p>To debug a remote GDB over SSH, pass the <code>--host</code> option to DDD. I usually include these command-line options:</p>
<pre><code>ddd --debugger gdb --host admin@example.com --no-exec-window</code></pre>
<p>(I specify the remote debugger command as <code>gdb</code> when it differs from my local inferior debugger command of <code>egdb</code> from the OpenBSD <a href="https://openports.pl/path/devel/gdb">devel/gdb</a> port.)</p>
<h3 id="gdb-tricks">GDB tricks</h3>
<h4 id="useful-execution-commands">Useful execution commands</h4>
<p>Beyond the basics of <code>run</code>, <code>continue</code> and <code>next</code>, don’t forget some other handy commands.</p>
<ul>
<li><code>finish</code> - execute until the current function returns, and break in caller. Useful if you accidentally go too deep, or if the rest of a function is of no interest.</li>
<li><code>until</code> - execute until reaching a later line. You can use this on the last line of a loop to run through the rest of the iterations, break out, and stop.</li>
<li><code>start</code> - create a temporary breakpoint on the first line of <code>main()</code> and then <code>run</code>. Starts the program and breaks right away.</li>
<li><code>step</code> vs <code>next</code> - how to remember the difference? Think a flight of “steps” goes downward, “stepping down” into subroutines. Whereas “next” is the next contiguous source line.</li>
</ul>
<h4 id="batch-mode">Batch mode</h4>
<p>GDB can be used non-interactively, with predefined scripts, to create little utility programs. For example, the <a href="https://poormansprofiler.org">poor man’s profiler</a> is a technique of calling GDB repeatedly to sample the call stack of a running program. It sends the results to awk to tally where most wall clock time (as opposed to just CPU time) is being spent.</p>
<p>A related idea is using GDB to print information about a core dump without leaving the UNIX command line. We can issue a single GDB command to list the backtraces for all threads, plus all stack frame variables and function arguments. Notice the <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Print-Settings.html">print settings</a> customized for clean, verbose output.</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span># show why program.core died</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>gdb</span> <span>--batch</span> <span>\</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span>-ex</span> <span>&#34;set print frame-arguments all&#34;</span> <span>\</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span>-ex</span> <span>&#34;set print pretty on&#34;</span> <span>\</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span>-ex</span> <span>&#34;set print addr off&#34;</span> <span>\</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span>-ex</span> <span>&#34;thread apply all bt full&#34;</span> <span>\</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  /path/to/program program.core</span></code></pre></div>
<p>You can put this incantation (minus the final program and core file paths) into a shell alias (like <code>bt</code>) so you can run it more easily. To test, you can generate a core by running a program and sending it SIGQUIT with <code>Ctrl-\</code>. Adjusting <code>ulimit -c</code> may also be necessary to save cores, depending on your OS.</p>
<h4 id="user-defined-commands">User-defined commands</h4>
<p>GDB allows you to define custom commands that can do arbitrarily complex things. Commands can set breakpoints, display values, and even call to the shell.</p>
<p>Here’s an example that does a few of these things. It traces the system calls made by a single function of interest. The real work happens by shelling out to OpenBSD’s <a href="https://man.openbsd.org/ktrace">ktrace(1)</a>. (An equivalent tracing utility should exist for your operating system.)</p>
<pre><code>define ktrace
    # if a user presses enter on a blank line, GDB will by default
    # repeat the command, but we don&#39;t want that for ktrace

    dont-repeat

    # set a breakpoint for the specified function, and run commands
    # when the breakpoint is hit

    break $arg0
    commands
        # don&#39;t echo the commands to the user
        silent

        # set a convenience variable with the result of a C function
        set $tracepid = (int)getpid()

        # eval (GDB 7.2+) interpolates values into a command, and runs it
        eval &#34;set $ktraceout=\&#34;/tmp/ktrace.%d.out\&#34;&#34;, $tracepid
        printf &#34;ktrace started: %s\n&#34;, $ktraceout
        eval &#34;shell ktrace -a -f %s -p %d&#34;, $ktraceout, $tracepid

        printf &#34;\nrun \&#34;ktrace_stop\&#34; to stop tracing\n\n&#34;

        # &#34;finish&#34; continues execution for the duration of the current
        # function, and then breaks
        finish

        # After commands that continue execution, like finish does,
        # we lose control in the GDB breakpoint. We cannot issue
        # more commands here
    end

    # GDB automatically sets $bpnum to the identifier of the created breakpoint
    set $tracebp = $bpnum
end

define ktrace_stop
    dont-repeat

    # consult $ktraceout and $tracebp set by ktrace earlier

    eval &#34;shell ktrace -c -f %s&#34;, $ktraceout
    del $tracebp
    printf &#34;ktrace stopped for %s\n&#34;, $ktraceout
end</code></pre>
<p>Here’s demonstration with a simple program. It has two functions that involve different kinds of system calls:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>#define _POSIX_C_SOURCE 200112L</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;stdio.h&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;unistd.h&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span>void</span> delay<span>(</span><span>void</span><span>)</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>	sleep<span>(</span><span>1</span><span>);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span>void</span> alert<span>(</span><span>void</span><span>)</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>	puts<span>(</span><span>&#34;Hello&#34;</span><span>);</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>(</span><span>void</span><span>)</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>	alert<span>();</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>	delay<span>();</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>After loading the program into GDB, here’s how to see which syscalls the <code>delay()</code> function makes. Tracing is focused to just that function, and doesn’t include the system calls made by any other functions, like <code>alert()</code>.</p>
<pre><code>(gdb) ktrace delay
Breakpoint 1 at 0x1a10: file sleep.c, line 7.
(gdb) run
Starting program: sleep
ktrace started: /tmp/ktrace.5432.out

run &#34;ktrace_stop&#34; to stop tracing

main () at sleep.c:20
(gdb) ktrace_stop
ktrace stopped for /tmp/ktrace.5432.out</code></pre>
<p>The trace output is a binary file, and we can use kdump(1) to view it, like this:</p>
<pre><code>$ kdump -f /tmp/ktrace.5432.out
  5432 sleep    CALL  kbind(0x7f7ffffda6a8,24,0xa0ef4d749fb64797)
  5432 sleep    RET   kbind 0
  5432 sleep    CALL  nanosleep(0x7f7ffffda748,0x7f7ffffda738)
  5432 sleep    STRU  struct timespec { 1 }
  5432 sleep    STRU  struct timespec { 0 }
  5432 sleep    RET   nanosleep 0</code></pre>
<p>This shows that, on OpenBSD, sleep(3) calls nanosleep(2).</p>
<p>On a related note, another way to get insight into syscalls is by setting <a href="https://sourceware.org/gdb/onlinedocs/gdb/Set-Catchpoints.html">catchpoints</a> to break on a call of interest. This is a Linux-only feature.</p>
<h4 id="hooks">Hooks</h4>
<p>GDB treats user defined commands specially whose names begin with <code>hook-</code> or <code>hookpost-</code>. It runs <code>hook-foo</code> (<code>hookpost-foo</code>) automatically before (after) a user runs the command <code>foo</code>. In addition, a pseudo-command “stop” exists for when execution stops at a breakpoint.</p>
<p>As an example, consider <a href="https://sourceware.org/gdb/onlinedocs/gdb/Auto-Display.html">automatic variable displays</a>. GDB can automatically print the value of expressions every time the program stops with, e.g. <code>display varname</code>. However, what if we want to display all local variables this way?</p>
<p>There’s no direct expression to do it with <code>display</code>, but we can create a hook:</p>
<pre><code>define hook-stop
    # do it conditionally
    if $display_locals_flag
        # dump the values of all local vars
        info locals
    end
end

# commands to (de)activate the display

define display_locals
    set $display_locals_flag = 1
end

define undisplay_locals
    set $display_locals_flag = 0
end</code></pre>
<p>To be fair, the <a href="https://sourceware.org/gdb/onlinedocs/gdb/TUI-Single-Key-Mode.html#TUI-Single-Key-Mode">TUI single key mode</a> binds <code>info locals</code> to the <code>v</code> key, so our hook is less useful in TUI mode than it first appears.</p>
<h3 id="python-api">Python API</h3>
<h4 id="simple-helper-functions">Simple helper functions</h4>
<p>GDB exposes a <a href="https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html">Python API</a> for finer control over the debugger. GDB scripts can include Python directly in designated blocks. For instance, right in <code>.gdbinit</code> we can access the Python API to get call stack frame information.</p>
<p>In this example, we’ll trace function calls matching a regex. If no regex is specified, we’ll match all functions visible to GDB, except low level functions (which start with underscore).</p>
<pre><code># drop into python to access frame information

python
    # this module contains the GDB API

    import gdb

    # define a helper function we can use later in a user command
    #
    # it prints the name of the function in the specified frame,
    # with indentation depth matching the stack depth

    def frame_indented_name(frame):
        # frame.level() is not always available,
        # so we traverse the list and count depth

        f = frame
        depth = 0
        while (f):
            depth = depth + 1
            f = f.older()
        return &#34;%s%s&#34; % (&#34;  &#34; * depth, frame.name())
end

# trace calls of functions matching a regex

define ftrace
    dont-repeat

    # we&#39;ll set possibly many breakpoints, so record the
    # starting number of the group

    set $first_new = 1 + ($bpnum ? $bpnum : 0)

    if $argc &lt; 1
        # by default, trace all functions except those that start with
        # underscore, which are low-level system things
        #
        # rbreak sets multiple breakpoints via a regex

        rbreak ^[a-zA-Z]
    else
        # or match based on ftrace argument, if passed

        rbreak $arg0
    end
    commands
        silent
        
        # drop into python again to use our helper function to
        # print the name of the newest frame

        python print(frame_indented_name(gdb.newest_frame()))

        # then immediately keep going
        cont
    end

    printf &#34;\nTracing enabled. To disable, run:\n\tdel %d-%d\n&#34;, $first_new, $bpnum
end</code></pre>
<p>To use ftrace, put breakpoints at either end of an area of interest. When you arrive at the first breakpoint, run ftrace with an optional regex argument. Then, continue the debugger and watch the output.</p>
<p>Here’s sample trace output from inserting a key-value into a treemap (<code>tm_insert()</code>) in my <a href="https://github.com/begriffs/libderp">libderp</a> library. You can see the “split” and “skew” operations happening in the underlying balanced <a href="https://user.it.uu.se/~arnea/ps/simp.pdf">AA-tree</a>.</p>
<pre><code>tm_insert
  malloc
    omalloc
  malloc
    omalloc
          map
          insert
  internal_tm_insert
    derp_strcmp
    internal_tm_insert
      derp_strcmp
      internal_tm_insert
        derp_strcmp
        internal_tm_insert
        internal_tm_skew
        internal_tm_split
      internal_tm_skew
      internal_tm_split
    internal_tm_skew
    internal_tm_split</code></pre>
<h4 id="pretty-printing">Pretty printing</h4>
<p>GDB allows you to customize the way it displays values. For instance, you may want to inspect Unicode strings when working with the ICU library. ICU’s internal encoding for <a href="https://unicode-org.github.io/icu/userguide/strings/#icu-16-bit-unicode-strings">UChar</a> is UTF-16. GDB has no way to know that an array ostensibly containing numbers is actually a string of UTF-16 code units. However, using the Python API, we can convert the string to a form GDB understands.</p>
<p>While a bit esoteric, this example provides the template you would use to create pretty printers for any type.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>import</span> gdb.printing, re</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span># a pretty printer </span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span>class</span> UCharPrinter:</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span>&#39;Print ICU UChar string&#39;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, val):</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.val <span>=</span> val</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span># tell gdb to print the value in quotes, like a string</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span>def</span> display_hint(<span>self</span>):</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>&#39;string&#39;</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span># the actual work...</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span>def</span> to_string(<span>self</span>):</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        p_c16 <span>=</span> gdb.lookup_type(<span>&#39;char16_t&#39;</span>).pointer()</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>self</span>.val.cast(p_c16).string(<span>&#39;UTF-16&#39;</span>)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span># bookkeeping that associates the UCharPrinter with the types</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span># it can handle, and adds an entry to &#34;info pretty-printer&#34;</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span>class</span> UCharPrinterInfo(gdb.printing.PrettyPrinter):</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    <span># friendly name for printer</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>):</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        <span>super</span>().<span>__init__</span>(<span>&#39;UChar string printer&#39;</span>)</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        <span>self</span>._re <span>=</span> re.<span>compile</span>(<span>&#39;^UChar [\[*]&#39;</span>)</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>    <span># is UCharPrinter appropriate for val?</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__call__</span>(<span>self</span>, val):</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        <span>if</span> <span>self</span>._re.match(<span>str</span>(val.<span>type</span>)):</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>            <span>return</span> UCharPrinter(val)</span></code></pre></div>
<p>While it’s nice to create code such as the pretty printer above, the code won’t do anything until we tell GDB how and when to load it. You can certainly dump Python code blocks into your <code>~/.gdbinit</code>, but that’s not very modular, and can load things unnecessarily.</p>
<p>I prefer to organize the code in dedicated directories like this:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>mkdir</span> <span>-p</span> ~/.gdb/<span>{py-modules</span><span>,</span><span>auto-load}</span></span></code></pre></div>
<p>The <code>~/.gdb/py-modules</code> is for user modules (like the ICU pretty printer), and <code>~/.gdb/auto-load</code> is for scripts that GDB automatically loads at certain times.</p>
<p>Having created those directories, tell GDB to consult them. Add this to your <code>~/.gdbinit</code>:</p>
<pre><code>add-auto-load-safe-path /home/foo/.gdb
add-auto-load-scripts-directory /home/foo/.gdb/auto-load</code></pre>
<p>Now, when GDB loads a library like <code>/usr/lib/baz.so.x.y</code> on behalf of your program, it will also search for <code>~/.gdb/auto-load/usr/lib/baz.so.x.y-gdb.py</code> and load it if it exists. To see which libraries GDB loads for an application, enable verbose mode, and then start execution.</p>
<pre><code>(gdb) set verbose
(gdb) start

...
Reading symbols from /usr/libexec/ld.so...
Reading symbols from /usr/lib/libpthread.so.26.1...
Reading symbols from ...</code></pre>
<p>On my machine for an application using ICU, GDB loaded <code>/usr/local/lib/libicuio.so.20.1</code>. To enable the ICU pretty printer, I create an auto-load file:</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span># ~/.gdb/auto-load/usr/local/lib/libicuuc.so.20.1-gdb.py</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span>import</span> gdb.printing</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span>import</span> printers.libicuuc</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>gdb.printing.register_pretty_printer(</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    gdb.current_objfile(),</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    printers.libicuuc.UCharPrinterInfo())</span></code></pre></div>
<p>The final question is how the auto-loader resolves the <code>printers.libicuuc</code> module. We need to add <code>~/.gdb/py-modules</code> to the Python system path. I use a little trick: a file in the appropriate directory that detects its own location and adds that to the syspath:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span># ~/.gdb/py-modules/add-syspath.py</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span>import</span> sys, os</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>sys.path.append(os.path.dirname(os.path.realpath(<span>__file__</span>)))</span></code></pre></div>
<p>Then just source the file from <code>~/.gdbinit</code>:</p>
<pre><code>source /home/foo/.gdb/py-modules/add-syspath.py</code></pre>
<p>After doing that, save the ICU pretty printing code as <code>~/.gdb/py-modules/printers/libicuuc.py</code>, and the <code>import printers.libicuuc</code> statement will find it.</p>
<h3 id="ddd-features">DDD features</h3>
<p>In addition to providing a graphical user interface, DDD has a few features of its own.</p>
<h4 id="historical-values">Historical values</h4>
<p>Each time the program stops at a breakpoint, DDD records the values of all displayed variables. You can place breakpoints strategically to sample the historical values of a variable, and then view or plot them on a graph.</p>
<p>For instance, compile this program with debugging information enabled, and load it in DDD:</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>(</span><span>void</span><span>)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>	<span>unsigned</span> x <span>=</span> <span>381</span><span>;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>	<span>while</span> <span>(</span>x <span>!=</span> <span>1</span><span>)</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>		x <span>=</span> <span>(</span>x <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span> <span>?</span> x<span>/</span><span>2</span> <span>:</span> <span>3</span><span>*</span>x <span>+</span> <span>1</span><span>;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>	<span>return</span> <span>0</span><span>;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<ol type="1">
<li><p>Double click to the left of the <code>x = ...</code> line to set a breakpoint. Right click the stop sign icon that appears, and select <strong>Properties…</strong>. In the dialog box, click <strong>Edit &gt;&gt;</strong> and enter <code>continue</code> into the text box. Apply your change and close the dialog. This breakpoint will stop, record the value of <code>x</code>, then immediately continue running.</p></li>
<li><p>Set a breakpoint on the <code>return 0</code> line.</p></li>
<li><p>Select <strong>GDB console</strong> from the <strong>View</strong> menu (or press Alt-1).</p></li>
<li><p>Run <code>start</code> in the GDB console to run the program and break at the first line.</p></li>
<li><p>Double click the “x” variable to add it to the graphical display. (If you don’t put it in the display window, DDD won’t track its values over time.)</p></li>
<li><p>Select <strong>Continue</strong> from the <strong>Program</strong> menu (or press F9). You’ll see the displayed value of <code>x</code> updating rapidly.</p></li>
<li><p>When execution stops at the last breakpoint, run <code>graph history x</code> in the GDB console. It will output an array of all previous values:</p>
<pre><code>(gdb) graph history x
history x = {0, 381, 1144, 572, 286, 143, 430, 215, 646, 323, 970, 485,
1456, 728, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350,
175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502,
251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719,
2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102,
2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325,
976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10,
5, 16, 8, 4, 2, 1}</code></pre></li>
</ol>
<p><img src="https://charles.inclouds.space/blog/images/ddd-graph.png" alt="graph of values"/></p>
<p>To see the values plotted graphically, run</p>
<pre><code>graph plot `graph display x`</code></pre>
<p>DDD sends the data to gnuplot to render the graph. (Be sure to set <code>Ddd*plotTermType: x11</code> in <code>~/.ddd/init</code>, or else DDD will hang with a dialog saying “Starting Gnuplot…”.)</p>
<h4 id="interesting-shortcuts">Interesting shortcuts</h4>
<p>DDD has some shortcuts that aren’t obvious from the interface, but which I found interesting in the documentation.</p>
<ul>
<li>Control-doubleclick on the left of a line to set a temporary breakpoint, or on an existing breakpoint to delete it. Control double clicking in the data window dereferences in place, rather than creating a new display.</li>
<li>Click and drag a breakpoint to a new line, and it moves while preserving all its properties.</li>
<li>Click and hold buttons to reveal special functions. For instance, on the watch button to set a watchpoint on change or on read.</li>
<li>Pressing Esc (or the interrupt button) acts like an impromptu breakpoint.</li>
<li>By default, typing into the source window redirects keystrokes to the GDB console, so you don’t have to focus the console to issue commands.</li>
<li>Control-Up/Down changes the stack frame quickly.</li>
<li>You can display more than single local variables in the data window. Go to Data -&gt; Status Displays to access checkboxes of other common ones, like the backtrace, or all local vars at once.</li>
<li>Pressing F1 shows help specific to whatever control is under the mouse cursor.</li>
<li>GDB by default tries to confirm kill/detach when you quit. Use ‘set confirm off’ to disable the prompt.</li>
</ul>
<h3 id="further-reading">Further reading</h3>
<ul>
<li><a href="https://sourceware.org/gdb/documentation/">Debugging with GDB: the GNU Source-Level Debugger</a>. This page links to a printed book, a PDF, and online HTML.</li>
<li><a href="https://www.gnu.org/software/ddd/manual/">DDD Manual</a></li>
<li><a href="https://www.goodreads.com/book/show/3938178-debugging">Debugging: The 9 Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems</a>. Timeless debugging techniques, not specific to any particular tooling, or even computers per se.</li>
</ul>
  </div>
</div>

      </div>
    </div></div>
  </body>
</html>
