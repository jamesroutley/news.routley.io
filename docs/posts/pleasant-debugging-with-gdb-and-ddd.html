<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://begriffs.com/posts/2022-07-17-debugging-gdb-ddd.html">Original</a>
    <h1>Pleasant Debugging with GDB and DDD</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      <div>
        <div>
  

  <div>
    <p>GDB is an old and ubiquitous debugger for Linux and BSD systems that has
extensive language, processor, and binary format support. Its interface is a
little cryptic, but learning GDB pays off.</p>
<p>This article is a set of miscellaneous configuration and scripting tricks that
illustrate reusable principles. It assumes you’re familiar with the basics of
debugging, like breakpoints, stepping, inspecting variables, etc.</p>
<p><strong>Table of contents</strong></p>
<ul>
<li><a href="#gdb-front-ends">GDB front ends</a>
<ul>
<li><a href="#fixing-ddd-freeze-on-startup">Fixing DDD freeze on startup</a></li>
<li><a href="#honoring-gdbinit-changes">Honoring gdbinit changes</a></li>
<li><a href="#dark-mode">Dark mode</a></li>
<li><a href="#utf-8-rendering">UTF-8 rendering</a></li>
<li><a href="#remote-gdb-configuration">Remote GDB configuration</a></li>
</ul></li>
<li><a href="#gdb-tricks">GDB tricks</a>
<ul>
<li><a href="#useful-execution-commands">Useful execution commands</a></li>
<li><a href="#batch-mode">Batch mode</a></li>
<li><a href="#user-defined-commands">User-defined commands</a></li>
<li><a href="#hooks">Hooks</a></li>
</ul></li>
<li><a href="#python-api">Python API</a>
<ul>
<li><a href="#simple-helper-functions">Simple helper functions</a></li>
<li><a href="#pretty-printing">Pretty printing</a></li>
</ul></li>
<li><a href="#ddd-features">DDD features</a>
<ul>
<li><a href="#historical-values">Historical values</a></li>
<li><a href="#interesting-shortcuts">Interesting shortcuts</a></li>
</ul></li>
<li><a href="#further-reading">Further reading</a></li>
</ul>
<h3 id="gdb-front-ends">GDB front ends</h3>
<p>By default, GDB provides a terse line-based terminal. You need to explicitly
ask to print the source code being debugged, the values of variables, or the
current list of breakpoints. There are four ways to customize this interface.
Ordered from basic to complicated, they are:</p>
<ol type="1">
<li>Get used to the <strong>default</strong> behavior. Then you’ll be comfortable on any
system with GDB installed. However, this approach does forego some
real conveniences.</li>
<li>Enable the built-in GDB <strong>TUI mode</strong> with the <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/TUI.html">-tui command line
flag</a> (available
since GDB version 7.5). The TUI creates Curses windows for source, registers,
commands, etc. It’s easier to trace execution through the code and spot
breakpoints than in the default interface.</li>
<li>Customize the UI using <strong>scripting</strong>, sourced from your <code>.gdbinit</code>. Some
good examples are projects like
<a href="https://github.com/cyrus-and/gdb-dashboard">gdb-dashboard</a> and
<a href="https://github.com/hugsy/gef">gef</a>.</li>
<li>Use a <strong>graphical front-end</strong> that communicates with an “inferior” GDB
instance. Front ends either use the GDB machine interface (MI) to
communicate, or they screen scrape sessions directly.</li>
</ol>
<p>In my experiments, the TUI mode (option two) seemed promising, but it has some
limitations:</p>
<ul>
<li>no persistent window to display variables or the call stack</li>
<li>no ability to set or clear breakpoints by mouse</li>
<li>no value inspection with mouse hover</li>
<li>mouse scroll wheel didn’t work for me on OpenBSD+xterm</li>
<li>no interactive structure/pointer exploration</li>
<li>no historical value tracking for variables (aside from GDB’s Linux-only
<a href="https://sourceware.org/gdb/onlinedocs/gdb/Process-Record-and-Replay.html">process record and
replay</a>)</li>
</ul>
<p>Ultimately I chose option four, with the <a href="https://www.gnu.org/software/ddd/">Data Display
Debugger</a> (DDD). It’s fairly ancient, and
requires configuration changes to work at all with recent versions of GDB.
However, it has a lot of features delivered in a 3MB binary, with no library
dependencies other than a Motif-compatible UI toolkit. DDD can also control
GDB sessions remotely over SSH.</p>
<figure>
<img src="https://begriffs.com/images/ddd.png" alt="DDD screenshot"/>
<figcaption aria-hidden="true">DDD screenshot</figcaption>
</figure>
<h4 id="fixing-ddd-freeze-on-startup">Fixing DDD freeze on startup</h4>
<p>As a front-end, DDD translates user actions to text commands that it sends to
GDB. Newer front-ends use GDB’s unambiguous machine interface (MI), but DDD
never got updated for that. It parses the standard text interface, essentially
screen scraping GDB’s regular output. This causes some problems, but there are
workarounds.</p>
<p>Upon starting DDD, the first serious error you’ll run into is the program
locking up with this message:</p>
<pre><code>Waiting until GDB gets ready...</code></pre>
<p>The freeze happens because DDD is looking for the prompt <code>(gdb)</code>. However, DDD
never sees that prompt because it incorrectly changed the prompt at startup.</p>
<p>To fix this error, you must explicitly set the prompt and <em>unset</em> the
extended-prompt. In <code>~/.ddd/init</code> include this code:</p>
<pre><code>Ddd*gdbSettings: \
unset extended-prompt\n\
set prompt (gdb) \n</code></pre>
<p>The root of the problem is that during DDD’s first run, it probes all GDB
settings, and saves them in to its .ddd/init file for consistency in future
runs. It probes by running <code>show settingname</code> for all settings. However, it
interprets the results wrong for these settings:</p>
<ul>
<li>exec-direction</li>
<li>extended-prompt</li>
<li>filename-display</li>
<li>interactive-mode</li>
<li>max-value-size</li>
<li>mem inaccessible-by-default</li>
<li>mpx bound</li>
<li>record btrace bts</li>
<li>record btrace pt</li>
<li>remote interrupt-sequence</li>
<li>remote system-call-allowed</li>
<li>tdesc</li>
</ul>
<p>The incorrect detection is especially bad for <code>extended-prompt</code>. GDB reports
the value as <code>not set</code>, which DDD interprets – not as the lack of a value –
but as text to set for the extended prompt. That text overrides the regular
prompt, causing GDB to output <code>not set</code> as its actual prompt.</p>
<h4 id="honoring-gdbinit-changes">Honoring gdbinit changes</h4>
<p>As mentioned, DDD probes and saves all GDB settings during first launch. While
specifying all settings in <code>~/.ddd/init</code> might make for deterministic behavior
on local and remote debugging sessions, it’s inflexible. I want <code>~/.gdbinit</code> to
be the source of truth.</p>
<p>Thus you should:</p>
<ul>
<li>Delete all <code>Ddd*gdbSettings</code> other than the prompt ones above, and</li>
<li>Set <code>Ddd*saveOptionsOnExit: off</code> to prevent DDD from putting the values back.</li>
</ul>
<h4 id="dark-mode">Dark mode</h4>
<p>DDD’s default color scheme is a bit glaring. For dark mode in the code window,
console, and data display panel, set these resources:</p>
<pre><code>Ddd*XmText.background:             black
Ddd*XmText.foreground:             white
Ddd*XmTextField.background:        black
Ddd*XmTextField.foreground:        white
Ddd*XmList.background:             black
Ddd*XmList.foreground:             white
Ddd*graph_edit.background:         #333333
Ddd*graph_edit.edgeColor:          red
Ddd*graph_edit.nodeColor:          white
Ddd*graph_edit.gridColor:          white</code></pre>
<h4 id="utf-8-rendering">UTF-8 rendering</h4>
<p>By default, DDD uses X core fonts. All its resources, like <code>Ddd*defaultFont</code>,
can pick from only those legacy fonts, which don’t properly render UTF-8. For
proper rendering, we have to change the Motif <a href="http://www.ist.co.uk/motif/books/vol6A/ch-24.fm.html">rendering
table</a> to use the newer
FreeType (XFT) fonts. Pick an XFT font you have on your system; I chose
Inconsolata:</p>
<pre><code>Ddd*renderTable: rt
Ddd*rt*fontType: FONT_IS_XFT
Ddd*rt*fontName: Inconsolata
Ddd*rt*fontSize: 8</code></pre>
<p>The change applies to all UI areas of the program <em>except</em> the data display
window. That window comes from an earlier codebase bolted on to DDD, and I
don’t know how to change its rendering. AFAICT, you can choose only legacy
fonts there, with <code>Ddd*dataFont</code> and <code>Ddd*dataFontSize</code>.</p>
<p>Although international graphemes are garbled in the data display window, you
can inspect UTF-8 variables by printing them in the GDB console, or by hovering
the mouse over variable names for a tooltip display.</p>
<h4 id="remote-gdb-configuration">Remote GDB configuration</h4>
<p>DDD interacts with GDB through the terminal like a user would, so it can drive
debugging sessions over SSH just as easily as local sessions. It also knows how
to fetch remote source files, and find remote program PIDs to which GDB can
attach. DDD’s default program for running commands on a remote inferior is
<code>remsh</code> or <code>rsh</code>, but it can be customized to use SSH:</p>
<pre><code>Ddd*rshCommand: ssh -t</code></pre>
<p>In my experience, the <code>-t</code> is needed, or else GDB warnings and errors can
appear out of order with the <code>(gdb)</code> prompt, making DDD hang.</p>
<p>To debug a remote GDB over SSH, pass the <code>--host</code> option to DDD. I usually
include these command-line options:</p>
<pre><code>ddd --debugger gdb --host admin@example.com --no-exec-window</code></pre>
<p>(I specify the remote debugger command as <code>gdb</code> when it differs from my local
inferior debugger command of <code>egdb</code> from the OpenBSD
<a href="https://openports.pl/path/devel/gdb">devel/gdb</a> port.)</p>
<h3 id="gdb-tricks">GDB tricks</h3>
<h4 id="useful-execution-commands">Useful execution commands</h4>
<p>Beyond the basics of <code>run</code>, <code>continue</code> and <code>next</code>, don’t forget some other
handy commands.</p>
<ul>
<li><code>finish</code> - execute until the current function returns, and break in caller.
Useful if you accidentally go too deep, or if the rest of a function is of
no interest.</li>
<li><code>until</code> - execute until reaching a later line. You can use this on the
last line of a loop to run through the rest of the iterations, break
out, and stop.</li>
<li><code>start</code> - create a temporary breakpoint on the first line of <code>main()</code> and
then <code>run</code>. Starts the program and breaks right away.</li>
<li><code>step</code> vs <code>next</code> - how to remember the difference? Think a flight of “steps”
goes downward, “stepping down” into subroutines. Whereas “next” is the next
contiguous source line.</li>
</ul>
<h4 id="batch-mode">Batch mode</h4>
<p>GDB can be used non-interactively, with predefined scripts, to create little
utility programs. For example, the <a href="https://poormansprofiler.org">poor man’s
profiler</a> is a technique of calling GDB
repeatedly to sample the call stack of a running program. It sends the results
to awk to tally where most wall clock time (as opposed to just CPU time) is
being spent.</p>
<p>A related idea is using GDB to print information about a core dump without
leaving the UNIX command line. We can issue a single GDB command to list the
backtraces for all threads, plus all stack frame variables and function
arguments. Notice the <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Print-Settings.html">print
settings</a>
customized for clean, verbose output.</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span># show why program.core died</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>gdb</span> <span>--batch</span> <span>\</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span>-ex</span> <span>&#34;set print frame-arguments all&#34;</span> <span>\</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span>-ex</span> <span>&#34;set print pretty on&#34;</span> <span>\</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span>-ex</span> <span>&#34;set print addr off&#34;</span> <span>\</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span>-ex</span> <span>&#34;thread apply all bt full&#34;</span> <span>\</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  /path/to/program program.core</span></code></pre></div>
<p>You can put this incantation (minus the final program and core file paths) into
a shell alias (like <code>bt</code>) so you can run it more easily. To test, you can
generate a core by running a program and sending it SIGQUIT with <code>Ctrl-\</code>.
Adjusting <code>ulimit -c</code> may also be necessary to save cores, depending on your
OS.</p>
<h4 id="user-defined-commands">User-defined commands</h4>
<p>GDB allows you to define custom commands that can do arbitrarily complex
things. Commands can set breakpoints, display values, and even call to the
shell.</p>
<p>Here’s an example that does a few of these things. It traces the system calls
made by a single function of interest. The real work happens by shelling out to
OpenBSD’s <a href="https://man.openbsd.org/ktrace">ktrace(1)</a>. (An equivalent tracing
utility should exist for your operating system.)</p>
<pre><code>define ktrace
    # if a user presses enter on a blank line, GDB will by default
    # repeat the command, but we don&#39;t want that for ktrace

    dont-repeat

    # set a breakpoint for the specified function, and run commands
    # when the breakpoint is hit

    break $arg0
    commands
        # don&#39;t echo the commands to the user
        silent

        # set a convenience variable with the result of a C function
        set $tracepid = (int)getpid()

        # eval (GDB 7.2+) interpolates values into a command, and runs it
        eval &#34;set $ktraceout=\&#34;/tmp/ktrace.%d.out\&#34;&#34;, $tracepid
        printf &#34;ktrace started: %s\n&#34;, $ktraceout
        eval &#34;shell ktrace -a -f %s -p %d&#34;, $ktraceout, $tracepid

        printf &#34;\nrun \&#34;ktrace_stop\&#34; to stop tracing\n\n&#34;

        # &#34;finish&#34; continues execution for the duration of the current
        # function, and then breaks
        finish

        # After commands that continue execution, like finish does,
        # we lose control in the GDB breakpoint. We cannot issue
        # more commands here
    end

    # GDB automatically sets $bpnum to the identifier of the created breakpoint
    set $tracebp = $bpnum
end

define ktrace_stop
    dont-repeat

    # consult $ktraceout and $tracebp set by ktrace earlier

    eval &#34;shell ktrace -c -f %s&#34;, $ktraceout
    del $tracebp
    printf &#34;ktrace stopped for %s\n&#34;, $ktraceout
end</code></pre>
<p>Here’s demonstration with a simple program. It has two functions that involve
different kinds of system calls:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>#define _POSIX_C_SOURCE </span><span>200112</span><span>L</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;stdio.h&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;unistd.h&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span>void</span> delay<span>(</span><span>void</span><span>)</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>	sleep<span>(</span><span>1</span><span>);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span>void</span> alert<span>(</span><span>void</span><span>)</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>	puts<span>(</span><span>&#34;Hello&#34;</span><span>);</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>(</span><span>void</span><span>)</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>	alert<span>();</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>	delay<span>();</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>After loading the program into GDB, here’s how to see which syscalls the
<code>delay()</code> function makes. Tracing is focused to just that function, and doesn’t
include the system calls made by any other functions, like <code>alert()</code>.</p>
<pre><code>(gdb) ktrace delay
Breakpoint 1 at 0x1a10: file sleep.c, line 7.
(gdb) run
Starting program: sleep
ktrace started: /tmp/ktrace.5432.out

run &#34;ktrace_stop&#34; to stop tracing

main () at sleep.c:20
(gdb) ktrace_stop
ktrace stopped for /tmp/ktrace.5432.out</code></pre>
<p>The trace output is a binary file, and we can use kdump(1) to view it, like
this:</p>
<pre><code>$ kdump -f /tmp/ktrace.5432.out
  5432 sleep    CALL  kbind(0x7f7ffffda6a8,24,0xa0ef4d749fb64797)
  5432 sleep    RET   kbind 0
  5432 sleep    CALL  nanosleep(0x7f7ffffda748,0x7f7ffffda738)
  5432 sleep    STRU  struct timespec { 1 }
  5432 sleep    STRU  struct timespec { 0 }
  5432 sleep    RET   nanosleep 0</code></pre>
<p>This shows that, on OpenBSD, sleep(3) calls nanosleep(2).</p>
<p>On a related note, another way to get insight into syscalls is by setting
<a href="https://sourceware.org/gdb/onlinedocs/gdb/Set-Catchpoints.html">catchpoints</a>
to break on a call of interest. This is a Linux-only feature.</p>
<h4 id="hooks">Hooks</h4>
<p>GDB treats user defined commands specially whose names begin with <code>hook-</code> or
<code>hookpost-</code>. It runs <code>hook-foo</code> (<code>hookpost-foo</code>) automatically before (after) a
user runs the command <code>foo</code>. In addition, a pseudo-command “stop” exists for
when execution stops at a breakpoint.</p>
<p>As an example, consider <a href="https://sourceware.org/gdb/onlinedocs/gdb/Auto-Display.html">automatic variable
displays</a>. GDB
can automatically print the value of expressions every time the program stops
with, e.g. <code>display varname</code>. However, what if we want to display all local
variables this way?</p>
<p>There’s no direct expression to do it with <code>display</code>, but we can create a hook:</p>
<pre><code>define hook-stop
    # do it conditionally
    if $display_locals_flag
        # dump the values of all local vars
        info locals
    end
end

# commands to (de)activate the display

define display_locals
    set $display_locals_flag = 1
end

define undisplay_locals
    set $display_locals_flag = 0
end</code></pre>
<p>To be fair, the <a href="https://sourceware.org/gdb/onlinedocs/gdb/TUI-Single-Key-Mode.html#TUI-Single-Key-Mode">TUI single key
mode</a>
binds <code>info locals</code> to the <code>v</code> key, so our hook is less useful in TUI mode than
it first appears.</p>
<h3 id="python-api">Python API</h3>
<h4 id="simple-helper-functions">Simple helper functions</h4>
<p>GDB exposes a <a href="https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html">Python
API</a> for finer
control over the debugger. GDB scripts can include Python directly in
designated blocks. For instance, right in <code>.gdbinit</code> we can access the Python
API to get call stack frame information.</p>
<p>In this example, we’ll trace function calls matching a regex. If no regex is
specified, we’ll match all functions visible to GDB, except low level functions
(which start with underscore).</p>
<pre><code># drop into python to access frame information

python
    # this module contains the GDB API

    import gdb

    # define a helper function we can use later in a user command
    #
    # it prints the name of the function in the specified frame,
    # with indentation depth matching the stack depth

    def frame_indented_name(frame):
        # frame.level() is not always available,
        # so we traverse the list and count depth

        f = frame
        depth = 0
        while (f):
            depth = depth + 1
            f = f.older()
        return &#34;%s%s&#34; % (&#34;  &#34; * depth, frame.name())
end

# trace calls of functions matching a regex

define ftrace
    dont-repeat

    # we&#39;ll set possibly many breakpoints, so record the
    # starting number of the group

    set $first_new = 1 + ($bpnum ? $bpnum : 0)

    if $argc &lt; 1
        # by default, trace all functions except those that start with
        # underscore, which are low-level system things
        #
        # rbreak sets multiple breakpoints via a regex

        rbreak ^[a-zA-Z]
    else
        # or match based on ftrace argument, if passed

        rbreak $arg0
    end
    commands
        silent
        
        # drop into python again to use our helper function to
        # print the name of the newest frame

        python print(frame_indented_name(gdb.newest_frame()))

        # then immediately keep going
        cont
    end

    printf &#34;\nTracing enabled. To disable, run:\n\tdel %d-%d\n&#34;, $first_new, $bpnum
end</code></pre>
<p>To use ftrace, put breakpoints at either end of an area of interest. When you
arrive at the first breakpoint, run ftrace with an optional regex argument.
Then, continue the debugger and watch the output.</p>
<p>Here’s sample trace output from inserting a key-value into a treemap
(<code>tm_insert()</code>) in my <a href="https://github.com/begriffs/libderp">libderp</a> library.
You can see the “split” and “skew” operations happening in the underlying
balanced <a href="https://user.it.uu.se/~arnea/ps/simp.pdf">AA-tree</a>.</p>
<pre><code>tm_insert
  malloc
    omalloc
  malloc
    omalloc
          map
          insert
  internal_tm_insert
    derp_strcmp
    internal_tm_insert
      derp_strcmp
      internal_tm_insert
        derp_strcmp
        internal_tm_insert
        internal_tm_skew
        internal_tm_split
      internal_tm_skew
      internal_tm_split
    internal_tm_skew
    internal_tm_split</code></pre>
<h4 id="pretty-printing">Pretty printing</h4>
<p>GDB allows you to customize the way it displays values. For instance, you may
want to inspect Unicode strings when working with the ICU library. ICU’s
internal encoding for
<a href="https://unicode-org.github.io/icu/userguide/strings/#icu-16-bit-unicode-strings">UChar</a>
is UTF-16. GDB has no way to know that an array ostensibly containing numbers
is actually a string of UTF-16 code units. However, using the Python API, we
can convert the string to a form GDB understands.</p>
<p>While a bit esoteric, this example provides the template you would use to
create pretty printers for any type.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>import</span> gdb.printing, re</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span># a pretty printer </span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span>class</span> UCharPrinter:</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span>&#39;Print ICU UChar string&#39;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, val):</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.val <span>=</span> val</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span># tell gdb to print the value in quotes, like a string</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span>def</span> display_hint(<span>self</span>):</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>&#39;string&#39;</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span># the actual work...</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span>def</span> to_string(<span>self</span>):</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        p_c16 <span>=</span> gdb.lookup_type(<span>&#39;char16_t&#39;</span>).pointer()</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>self</span>.val.cast(p_c16).string(<span>&#39;UTF-16&#39;</span>)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span># bookkeeping that associates the UCharPrinter with the types</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span># it can handle, and adds an entry to &#34;info pretty-printer&#34;</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span>class</span> UCharPrinterInfo(gdb.printing.PrettyPrinter):</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    <span># friendly name for printer</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>):</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        <span>super</span>().<span>__init__</span>(<span>&#39;UChar string printer&#39;</span>)</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        <span>self</span>._re <span>=</span> re.<span>compile</span>(<span>&#39;^UChar [\[*]&#39;</span>)</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>    <span># is UCharPrinter appropriate for val?</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__call__</span>(<span>self</span>, val):</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        <span>if</span> <span>self</span>._re.match(<span>str</span>(val.<span>type</span>)):</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>            <span>return</span> UCharPrinter(val)</span></code></pre></div>
<p>While it’s nice to create code such as the pretty printer above, the code won’t
do anything until we tell GDB how and when to load it. You can certainly dump
Python code blocks into your <code>~/.gdbinit</code>, but that’s not very modular, and can
load things unnecessarily.</p>
<p>I prefer to organize the code in dedicated directories like this:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>mkdir</span> <span>-p</span> ~/.gdb/<span>{py-modules</span><span>,</span><span>auto-load}</span></span></code></pre></div>
<p>The <code>~/.gdb/py-modules</code> is for user modules (like the ICU pretty printer), and
<code>~/.gdb/auto-load</code> is for scripts that GDB automatically loads at certain times.</p>
<p>Having created those directories, tell GDB to consult them. Add this to your
<code>~/.gdbinit</code>:</p>
<pre><code>add-auto-load-safe-path /home/foo/.gdb
add-auto-load-scripts-directory /home/foo/.gdb/auto-load</code></pre>
<p>Now, when GDB loads a library like <code>/usr/lib/baz.so.x.y</code> on behalf of your
program, it will also search for <code>~/.gdb/auto-load/usr/lib/baz.so.x.y-gdb.py</code>
and load it if it exists. To see which libraries GDB loads for an application,
enable verbose mode, and then start execution.</p>
<pre><code>(gdb) set verbose
(gdb) start

...
Reading symbols from /usr/libexec/ld.so...
Reading symbols from /usr/lib/libpthread.so.26.1...
Reading symbols from ...</code></pre>
<p>On my machine for an application using ICU, GDB loaded
<code>/usr/local/lib/libicuio.so.20.1</code>. To enable the ICU pretty printer, I create
an auto-load file:</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span># ~/.gdb/auto-load/usr/local/lib/libicuuc.so.20.1-gdb.py</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span>import</span> gdb.printing</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span>import</span> printers.libicuuc</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>gdb.printing.register_pretty_printer(</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    gdb.current_objfile(),</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    printers.libicuuc.UCharPrinterInfo())</span></code></pre></div>
<p>The final question is how the auto-loader resolves the <code>printers.libicuuc</code>
module. We need to add <code>~/.gdb/py-modules</code> to the Python system path. I use a
little trick: a file in the appropriate directory that detects its own location
and adds that to the syspath:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span># ~/.gdb/py-modules/add-syspath.py</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span>import</span> sys, os</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>sys.path.append(os.path.dirname(os.path.realpath(<span>__file__</span>)))</span></code></pre></div>
<p>Then just source the file from <code>~/.gdbinit</code>:</p>
<pre><code>source /home/foo/.gdb/py-modules/add-syspath.py</code></pre>
<p>After doing that, save the ICU pretty printing code as
<code>~/.gdb/py-modules/printers/libicuuc.py</code>, and the <code>import printers.libicuuc</code>
statement will find it.</p>
<h3 id="ddd-features">DDD features</h3>
<p>In addition to providing a graphical user interface, DDD has a few features of
its own.</p>
<h4 id="historical-values">Historical values</h4>
<p>Each time the program stops at a breakpoint, DDD records the values of all
displayed variables. You can place breakpoints strategically to sample the
historical values of a variable, and then view or plot them on a graph.</p>
<p>For instance, compile this program with debugging information enabled, and
load it in DDD:</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>(</span><span>void</span><span>)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>	<span>unsigned</span> x <span>=</span> <span>381</span><span>;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>	<span>while</span> <span>(</span>x <span>!=</span> <span>1</span><span>)</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>		x <span>=</span> <span>(</span>x <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span> <span>?</span> x<span>/</span><span>2</span> <span>:</span> <span>3</span><span>*</span>x <span>+</span> <span>1</span><span>;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>	<span>return</span> <span>0</span><span>;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<ol type="1">
<li><p>Double click to the left of the <code>x = ...</code> line to set a breakpoint. Right
click the stop sign icon that appears, and select <strong>Properties…</strong>. In the
dialog box, click <strong>Edit &gt;&gt;</strong> and enter <code>continue</code> into the text box. Apply
your change and close the dialog. This breakpoint will stop, record the value
of <code>x</code>, then immediately continue running.</p></li>
<li><p>Set a breakpoint on the <code>return 0</code> line.</p></li>
<li><p>Select <strong>GDB console</strong> from the <strong>View</strong> menu (or press Alt-1).</p></li>
<li><p>Run <code>start</code> in the GDB console to run the program and break at the
first line.</p></li>
<li><p>Double click the “x” variable to add it to the graphical display.
(If you don’t put it in the display window, DDD won’t track its values
over time.)</p></li>
<li><p>Select <strong>Continue</strong> from the <strong>Program</strong> menu (or press F9). You’ll see the
displayed value of <code>x</code> updating rapidly.</p></li>
<li><p>When execution stops at the last breakpoint, run <code>graph history x</code> in the
GDB console. It will output an array of all previous values:</p>
<pre><code>(gdb) graph history x
history x = {0, 381, 1144, 572, 286, 143, 430, 215, 646, 323, 970, 485,
1456, 728, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350,
175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502,
251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719,
2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102,
2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325,
976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10,
5, 16, 8, 4, 2, 1}</code></pre></li>
</ol>
<p><img src="https://begriffs.com/images/ddd-graph.png" alt="graph of values"/></p>
<p>To see the values plotted graphically, run</p>
<pre><code>graph plot `graph display x`</code></pre>
<p>DDD sends the data to gnuplot to render the graph. (Be sure to set
<code>Ddd*plotTermType: x11</code> in <code>~/.ddd/init</code>, or else DDD will hang with a dialog
saying “Starting Gnuplot…”.)</p>
<h4 id="interesting-shortcuts">Interesting shortcuts</h4>
<p>DDD has some shortcuts that aren’t obvious from the interface, but which I
found interesting in the documentation.</p>
<ul>
<li>Control-doubleclick on the left of a line to set a temporary breakpoint, or
on an existing breakpoint to delete it. Control double clicking in the data
window dereferences in place, rather than creating a new display.</li>
<li>Click and drag a breakpoint to a new line, and it moves while preserving all
its properties.</li>
<li>Click and hold buttons to reveal special functions. For instance, on the
watch button to set a watchpoint on change or on read.</li>
<li>Pressing Esc (or the interrupt button) acts like an impromptu breakpoint.</li>
<li>By default, typing into the source window redirects keystrokes to the GDB
console, so you don’t have to focus the console to issue commands.</li>
<li>Control-Up/Down changes the stack frame quickly.</li>
<li>You can display more than single local variables in the data window. Go to
Data -&gt; Status Displays to access checkboxes of other common ones, like the
backtrace, or all local vars at once.</li>
<li>Pressing F1 shows help specific to whatever control is under the mouse cursor.</li>
<li>GDB by default tries to confirm kill/detach when you quit. Use ‘set confirm
off’ to disable the prompt.</li>
</ul>
<h3 id="further-reading">Further reading</h3>
<ul>
<li><a href="https://sourceware.org/gdb/documentation/">Debugging with GDB: the GNU Source-Level Debugger</a>.
This page links to a printed book, a PDF, and online HTML.</li>
<li><a href="https://www.gnu.org/software/ddd/manual/">DDD Manual</a></li>
<li><a href="https://www.goodreads.com/book/show/3938178-debugging">Debugging: The 9 Indispensable Rules for Finding Even the Most Elusive
Software and Hardware
Problems</a>. Timeless
debugging techniques, not specific to any particular tooling, or even computers
per se.</li>
</ul>
  </div>
</div>

      </div>
    </div></div>
  </body>
</html>
