<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danluu.com/cgroup-throttling/">Original</a>
    <h1>The container throttling problem</h1>
    
    <div id="readability-page-1" class="page"><i><b><a href="https://patreon.com/danluu">I&#39;m trying some experimental tiers on Patreon</a></b> to see if I can get to <a href="https://twitter.com/danluu/status/1456346963691991041">substack-like levels of financial support for this blog without moving to substack</a>!</i> <hr/> <strong>The container throttling problem</strong> <p><i>This is an excerpt from an internal document </i>David Mackey<i> and I co-authored in April 2019. The document is excerpted since much of the original doc was about comparing possible approaches to increasing efficency at Twitter, which is mostly information that&#39;s meaningless outside of Twitter without a large amount of additional explanation/context.</i></p> <p>At Twitter, most CPU bound services start falling over at around 50% reserved container CPU utilization and almost all services start falling over at not much more CPU utilization even though CPU bound services should, theoretically, be able to get higher CPU utilizations. Because load isn&#39;t, in general, evenly balanced across shards and the shard-level degradation in performance is so severe when we exceed 50% CPU utilization, this makes the practical limit much lower than 50% even during peak load events.</p> <p>This document will describe potential solutions to this problem. We&#39;ll start with describing why we should expect this problem given how services are configured and how the Linux scheduler we&#39;re using works. We&#39;ll then look into case studies on how we can fix this with config tuning for specific services, which can result in a 1.5x to 2x increase in capacity, which can translate into $[redacted]M/yr to $[redacted]M/yr in savings for large services. While this is worth doing and we might get back $[redacted]M/yr to $[redacted]M/yr in <a href="https://en.wikipedia.org/wiki/Total_cost_of_ownership">TCO</a> by doing this for large services. Manually fixing services one at a time isn&#39;t really scalable, so we&#39;ll also look at how we can make changes that can recapture some of the value for most services.</p> <h3 id="the-problem-in-theory">The problem, in theory</h3> <p>Almost all services at Twitter run on Linux with <a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">the CFS scheduler</a>, using quotas for isolation, with default parameters. For jobs running on mesos, this means that the number of cores requested doesn&#39;t limit how many cores the job can use at any given moment. Instead, if a job &#34;wants to&#34; use more than that many cores over a quota timeslice, it will use more cores than its quota for a short period of time and then get throttled, i.e., basically get put to sleep, in order to keep its amortized core usage below the quota, which is disastrous for <a href="https://danluu.com/latency-pitfalls/">tail latency</a>.</p> <p>Since the vast majority of services at Twitter use thread pools that are much larger than their mesos core reservation, when jobs have heavy load, they end up requesting and then using more cores than their reservation and then throttling. This causes services that are provisioned based on load test numbers or observed latency under load to over provision CPU to avoid violating their <a href="https://en.wikipedia.org/wiki/Service-level_objective">SLO</a>s. They either have to ask for more CPUs per shard than they actually need or they have to increase the number of shards they use.</p> <p>An old example of this problem was the JVM Garbage Collector. Prior to work on the JVM to make the JVM container aware, each JVM would default the GC parallel thread pool size to the number of cores on the machine. During a GC, all these GC threads would run simultaneously, exhausting the cpu quota rapidly causing throttling. The resulting effect would be that a subsecond stop-the-world GC pause could take many seconds of wallclock time to complete. While the GC issue has been fixed, the issue still exists at the application level for virtually all services that run on mesos.</p> <h3 id="the-problem-in-practice-case-study">The problem, in practice [case study]</h3> <p>As a case study, let&#39;s look at <code>service-1</code>, the largest and most expensive service at Twitter.</p> <p>Below is the CPU utilization histogram for this service just as it starts failing its load test, i.e., when it&#39;s just above the peak load the service can handle before it violates its SLO. The x-axis is the number of CPUs used at a given point in time and the y-axis is (relative) time spent at that utilization. The service is provisioned for 20 cores and we can see that the utilization is mostly significantly under that, even when running at nearly peak possible load:</p> <p><img src="https://danluu.com/images/cgroup-throttling/cpu-histogram-1.png" alt="Histogram for service with 20 CPU quota showing that average utilization is much lower but peak utilization is significantly higher when the service is overloaded and violates its SLO" width="1266" height="658"/></p> <p>The problem is the little bars above 20. These spikes caused the job to use up its CPU quota and then get throttled, which caused latency to drastically increase, which is why the SLO was violated even though average utilization is about 8 cores, or 40% of quota. One thing to note is that the sampling period for this graph was 10ms and the quota period is 100ms, so it&#39;s technically possible to see an excursion above 20 in this graph without throttling, but on average, if we see a lot of excursions, especially way above 20, we&#39;ll likely get throttling.</p> <p>After reducing the thread pool sizes to avoid using too many cores and then throttling, we got the following CPU utilization histogram under a load test:</p> <p><img src="https://danluu.com/images/cgroup-throttling/cpu-histogram-2.png" alt="Histogram for service with 20 CPU quota showing that average utilization is much lower but peak utilization is significantly higher when the service is overloaded and violates its SLO" width="1216" height="548"/></p> <p>This is at 1.6x the load (request rate) of the previous histogram. In that case, the load test harness was unable to increase load enough to determine peak load for <code>service-1</code> because the service was able to handle so much load before failure that the service that&#39;s feeding it during the load test couldn&#39;t keep it and send more load (although that&#39;s fixable, I didn&#39;t have the proper permissions to quickly fix it). [later testing showed that the service was able to handle about 2x the capacity after tweaking the thread pool sizes]</p> <p>This case study isn&#39;t an isolated example — Andy Wilcox has looked at the same thing for <code>service-2</code> and found similar gains in performance under load for similar reasons.</p> <p>For services that are concerned about latency, we can get significant latency gains if we prefer to get latency gains instead of cost reduction. For <code>service-1</code>, if we leave the provisioned capacity the same instead of cutting by 2x, we see a 20% reduction in latency.</p> <p>The gains for doing this for individual large services are significant (in the case of <code>service-1</code>, it&#39;s [mid 7 figures per year] for the service and [low 8 figures per year] including services that are clones of it, but tuning every service by hand isn&#39;t scalable. That raises the question: how many services are impacted?</p> <h3 id="thread-usage-across-the-fleet">Thread usage across the fleet</h3> <p>If we look at the number of active threads vs. number of reserved cores for moderate sized services (&gt;= 100 shards), we see that almost all services have many more threads that want to execute than reserved cores. It&#39;s not uncommon to see tens of <a href="https://access.redhat.com/sites/default/files/attachments/processstates_20120831.pdf">runnable threads</a> per reserved core. This makes the <code>service-1</code> example, above, look relatively tame, at 1.5 to 2 runnable threads per reserved core under load.</p> <p>If we look at where these threads are coming from, it&#39;s common to see that a program has multiple thread pools where each thread pool is sized to either twice the number of reserved cores or twice the number of logical cores on the host machine. Both inside and outside of Twitter, It&#39;s common to see advice that thread pool size should be 2x the number of logical cores on the machine. This advice probably comes from a workload like picking how many threads to use for something like a gcc compile, where we don&#39;t want to have idle resources when we could have something to do. Since threads will sometimes get blocked and have nothing to do, going to 2x can increase throughput over 1x by decreasing the odds that any core is every idle, and 2x is a nice, round, number.</p> <p>However, there are a few problems with applying this to Twitter applications:</p> <ol> <li>Most applications have multiple, competing, thread pools</li> <li>Exceeding the reserved core limit is extremely bad</li> <li>Having extra threads working on computations can increase latency</li> </ol> <p>The &#34;we should provision 2x the number of logical cores&#34; model assumes that we have only one main thread pool doing all of the work and that there&#39;s little to no downside to having threads that could do work sit and do nothing and that we have a throughput oriented workload where we don&#39;t care about the deadline of any particular unit of work.</p> <p>With the CFS scheduler, threads that have active work that are above the core reservation won&#39;t do nothing, they&#39;ll get scheduled and run, but this will cause throttling, which negatively impacts tail latency.</p> <h3 id="potential-solutions">Potential Solutions</h3> <p>Given that we see something similar looking to our case study on many services and that it&#39;s difficult to push performance fixes to a lot of services (because service owners aren&#39;t really incentivized to take performance improvements), what can we do to address this problem across the fleet and just on a few handpicked large services? We&#39;re going to look at a list of potential solutions and then discuss each one in more detail, below.</p> <ul> <li>Better defaults for cross-fleet threadpools (eventbus, netty, etc.)</li> <li>Negotiating ThreadPool sizes via a shared library</li> <li>CFS period tuning</li> <li>CFS bandwidth slice tuning</li> <li>Other scheduler tunings</li> <li>CPU pinning and isolation</li> <li>Overprovision at the mesos scheduler level</li> </ul> <h4 id="better-defaults-for-cross-fleet-threadpools">Better defaults for cross-fleet threadpools</h4> <p><b>Potential impact</b>: some small gains in efficiency</p> <p>Many defaults are too large. Netty default threadpool size is 2x the reserved cores. In some parts of [an org], they use a library that spins up <a href="https://news.ycombinator.com/item?id=26643392">eventbus</a> and allocates a threadpool that&#39;s 2x the number of logical cores on the host (resulting in [over 100] eventbus threads) when 1-2 threads is sufficient for most of their eventbus use cases.</p> <p>Adjusting these default sizes won&#39;t fix the problem, but it will reduce the impact of the problem and this should be much less work than the solutions below, so this can be done while we work on a more comprehensive solution.</p>  <p>[this section was written by <i>Vladimir Kostyukov</i>]</p> <p><b>Potential impact</b>: can mostly mitigate the problem for most services.</p> <p>CSL’s util library has a package that bridges in some integration points between an application and a JVM (util-jvm), which could be a good place to host a new API for negotiating the sizes of the thread pools required by the application.</p> <p>The look and feel of such API is effectively dictated by how granular the negotiation is needed to be. Simply contending on a total number of allowed threads allocated per process, while being easy to implement, doesn’t allow distinguishing between application and IO threads. Introducing a notion of QoS for threads in the thread pool (i.e., “IO thread; can not block”, “App thread; can block”), on the other hand, could make the negotiation fine grained.</p> <h4 id="cfs-period-tuning">CFS Period Tuning</h4> <p><b>Potential impact</b>: small reduction tail latencies by shrinking the length of the time period before the process group’s CFS runtime quota is refreshed.</p> <p>To limit CPU usage, CFS operates over a time window known as the CFS period. Processes in a scheduling group take time from the CFS quota assigned to the cgroup and this quota is consumed over the cfs_period_us in CFS bandwidth slices. By shrinking the CFS period, the worst case time between quota exhaustion causing throttling and the process group being able to run again is reduced proportionately. Taking the default values of a CFS bandwidth slice of 5ms and CFS period of 100ms, in the worst case, a highly parallel application could exhaust all of its quota in the first bandwidth slice leaving 95ms of throttled time before any thread could be scheduled again.</p> <p>It&#39;s possible that total throttling would increase because the scheduled time over 100ms might not exceed the threshold even though there are (for example) 5ms bursts that exceed the threshold.</p> <h4 id="cfs-bandwidth-slice-tuning">CFS Bandwidth Slice Tuning</h4> <p><b>Potential impact</b>: small reduction in tail latencies by allowing applications to make better use of the allocated quota.</p> <p>When CFS goes to schedule a process it will transfer run-time between a global pool and CPU local pool to reduces global accounting pressure on large systems.The amount transferred each time is called the &#34;slice&#34;. A larger bandwidth slice is more efficient from the scheduler’s perspective but a smaller bandwidth slice allows for more fine grained execution. In debugging issues in [link to internal JIRA ticket] it was determined that if a scheduled process fails to consume its entire bandwidth slice, the default slice size being 5ms, because it has completed execution or blocked on another process, this time is lost to the process group reducing its ability to consume all available resources it has requested.</p> <p>The overhead of tuning this value is expected to be minimal, but should be measured. Additionally, it is likely not a one size fits all tunable, but exposing this to the user as a tunable has been rejected in the past in Mesos. Determining a heuristic for tuning this value and providing a per application way to set it may prove infeasible.</p> <h4 id="other-scheduler-tunings">Other Scheduler Tunings</h4> <p><b>Potential Impact</b>: small reduction in tail latencies and reduced throttling.</p> <p>The kernel has numerous auto-scaling and auto-grouping features whose impact to scheduling performance and throttling is currently unknown. <code>kernel.sched_tunable_scaling</code> can adjust <code>kernel.sched_latency_ns</code> underneath our understanding of its value. <code>kernel.sched_min_granularity_ns</code> and <code>kernel.sched_wakeup_granularity_ns</code> can be tuned to allow for preempting sooner, allowing better resource sharing and minimizing delays. <code>kernel.sched_autogroup_enabled</code> may currently not respect <code>kernel.sched_latency_ns</code>leading to more throttling challenges and scheduling inefficiencies. These tunables have not been investigated significantly and the impact of tuning them is unknown.</p> <h4 id="cfs-scheduler-improvements">CFS Scheduler Improvements</h4> <p><b>Potential impact</b>: better overall cpu resource utilization and minimized throttling due to CFS inefficiencies.</p> <p>How the CFS scheduler deals with unused slack time from the CFS bandwidth slice has shown to be ineffective. The kernel team has a patch to ensure that this unused time is returned back to the global pool for other processes to use, <a href="https://lore.kernel.org/patchwork/patch/907450/">https://lore.kernel.org/patchwork/patch/907450/</a> to ensure better overall system resource utilization. There are some additional avenues to explore that could provide further enhancements. Another of many recent discussions in this area that fell out of a k8s throttling issue(<a href="https://github.com/kubernetes/kubernetes/issues/67577">https://github.com/kubernetes/kubernetes/issues/67577</a>) is <a href="https://lkml.org/lkml/2019/3/18/706">https://lkml.org/lkml/2019/3/18/706</a>.</p> <p>Additionally, CFS may lose efficiency due to bugs such as [link to internal JIRA ticket] and <a href="http://www.ece.ubc.ca/~sasha/papers/eurosys16-final29.pdf">http://www.ece.ubc.ca/~sasha/papers/eurosys16-final29.pdf</a>. However, we haven&#39;t spent much time looking at the CFS performance for Twitter’s particular use cases. A closer look at CFS may find ways to improve efficiency.</p> <p>Another change which has more upside and downside potential would be to use a scheduler other than CFS.</p> <h4 id="cpu-pinning-and-isolation">CPU Pinning and Isolation</h4> <p><b>Potential impact</b>: removes the concept of throttling from the system by making the application developer’s mental model of a CPU map to a physical one. </p> <p>The fundamental issue that allows throttling to occur is that a heavily threaded application can have more threads executing in parallel than the “number of CPUs” it requested resulting in an early exhaustion of available runtime. By restricting the number of threads executing simultaneously to the number of CPUs an application requested there is now a 1:1 mapping and an application’s process group is free to consume the logical CPU thread unimpeded by the scheduler. Additionally, by dedicating a CPU thread rather than a bandwidth slice to the application, the application is now able to take full advantage of CPU caching benefits without having to contend with other applications being scheduled on the same CPU thread while it is throttled or context switched away.</p> <p>In Mesos, implementing CPU pinning has proven to be quite difficult. However, in k8s there is existing hope in the form of a project from Intel known as the k8s CPU Manager. The CPU Manager was added as an alpha feature to k8s in 1.8 and has been enabled as a beta feature since 1.10. It has somewhat stalled in beta as few people seem to be using it but the core functionality is present. The performance improvements promoted by the CPU Manager project are significant as shown in examples such as <a href="https://kubernetes.io/blog/2018/07/24/feature-highlight-cpu-manager/">https://kubernetes.io/blog/2018/07/24/feature-highlight-cpu-manager/</a> and <a href="https://builders.intel.com/docs/networkbuilders/cpu-pin-and-isolation-in-kubernetes-app-note.pdf">https://builders.intel.com/docs/networkbuilders/cpu-pin-and-isolation-in-kubernetes-app-note.pdf</a> While these benchmarks should be looked at with some skepticism, it does provide promising hope for exploring this avenue. A cursory inspection of the project highlights a few <a href="https://github.com/kubernetes/kubernetes/issues/70585">areas</a> where work may still be needed but it is already in a usable state for validating the approach. Underneath, the k8s CPU Manager leverages the cpuset cgroup functionality that is present in the kernel.</p> <p>Potentially, this approach does reduce the ability to oversubscribe the machines. However, the efficiency gains from minimized cross-pod interference, CPU throttling, a more deterministic execution profile and more may offset the need to oversubscribe. Currently, the k8s CPU Manager does allow for minor oversubscription in the form of allowing system level containers and the daemonset to be oversubscribed, but on a pod scheduling basis the cpus are reserved for that pod’s use.</p> <p>Longer term, oversubscription could be possible through a multitiered approach of wherein a primary class of pods is scheduled using CPU pinning but a secondary class of pods that is not as latency sensitive is allowed to float across all cores consuming slack resources from the primary pods. The work on the CPU Manager side would be extensive. However, recently <a href="https://lwn.net/ml/linux-kernel/20190408214539.2705660-1-songliubraving@fb.com/">Facebook has been doing some work</a> on the kernel scheduler side to further enable this concept in a way that minimally impacts the primary pod class that we can expand upon or evolve.</p> <h4 id="oversubscription-at-the-cluster-scheduler-level">Oversubscription at the cluster scheduler level</h4> <p><b>Potential impact</b>: can bring machine utilization up to an arbitrarily high level and overprovisioning &#34;enough&#34;.</p> <h4 id="disable-cfs-quotas">Disable CFS quotas</h4> <p><b>Potential impact</b>: prevents throttling and allows services to use all available cores on a box.</p> <p>This isn&#39;t a serious suggestion and is just presented for completeness. This &#34;solution&#34; is what was used before we enabled quotas and most service owners found it too difficult to estimate performance under load for this to be practical. At least one company has tried this &#34;suggestion&#34; to fix their throttling problem and has had severe incidents under load because of it.</p> <h3 id="results">Results</h3> <p><i>This section was not in the original document from April 2019; it was written in December 2021 and describes work that happened as a result of the original document.</i></p> <p>The suggestion of changing default thread pool sizes was taken and resulted in minor improvements. More importantly, two major efforts came out of the document. Vladimir Kostyukov (from the <a href="https://finagle.github.io/blog/2021/03/31/quarterly/">CSL team</a>) and Flavio Brasil (from the JVM team) created <a href="https://github.com/twitter/finagle/blob/develop/finagle-core/src/main/scala/com/twitter/finagle/filter/OffloadFilter.scala">Finagle Offload Filter</a> and Xi Yang (my intern at the time and now a full-time employee for my team) created a kernel patch which eliminates container throttling (the patch is still internal, but will hopefully eventually upstreamed).</p> <p>Almost all applications that run on mesos at Twitter run on top of <a href="https://kostyukov.net/posts/finagle-101/">Finagle</a>. The Finagle Offload Filter, created by, makes it trivial for service owners to put application work onto a different thread pool than IO (which was often not previously happening). In combination with sizing thread pools properly, this resulted in, ceteris paribus, applications having <a href="https://mobile.twitter.com/fbrasisil/status/1163974576511995904">drastically reduced latency</a>, enabling them to reduce their provisioned capacity and therefore their cost while meeting their SLO. Depending on the service, this resulted in a 15% to 60% cost reduction for the service.</p> <p>The kernel patch implements the obvious idea of preventing containers from using more cores than a container&#39;s quota at every moment instead of allowing a container to use as many cores as are available on the machine and then putting the container to sleep if it uses too many cores to bring its amortized core usage down.</p> <p>In experiments on hosts running major services at Twitter, this has the expected impact of eliminating issues related to throttling, giving a roughly 50% cost reduction for a typical service with untuned thread pool sizes. And it turns out the net impact is larger than we realized when we wrote this document due to the reduction in interference caused by preventing services from using &#34;too many&#34; cores and then throttling.</p> <p>In an independent effort, Matt Tejo found that, for a fixed average core utilization, services that throttle cause a much larger negative impact on other services on the same host than services that use a constant number of cores. That&#39;s because a service that&#39;s highly loaded and throttling toggles between attempting to use all of the cores on the box and then using none of the cores on the box, causing an extremely large amount of interference during the periods where it&#39;s attempting to use all of the cores on the box.</p> <p>Xi Yang has experimented with variations on the naive kernel scheduler change mentioned above, but even the naive change seems to be quite effective.</p>  <p><a href="https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/">https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/</a> <a href="https://lkml.org/lkml/2019/11/26/196">https://lkml.org/lkml/2019/11/26/196</a> <a href="https://lwn.net/Articles/840595/">https://lwn.net/Articles/840595/</a></p> <p><i>Thanks to Xi Yang, Ian Downes, Rebecca Isaacs, Brian Martin, Vladimir Kotsyukov, Moses Nakamura, Flavio Brasil, Laurence Tratt, Julian Squires, and ??? for comments/corrections/discussion</i></p>   </div>
  </body>
</html>
