<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://underjord.io/userspace-drivers-in-elixir.html">Original</a>
    <h1>Physical Knobs and Elixir</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        <small>2023-03-01</small>
        <p>I like production gear. Audio, video and .. miscellaneous. I like things that seem like they’ll make me oh-so-very productive. I’m a sucker prosumer as a hobby. Let’s talk about Elgato, Elixir and why I never actually get anything done. This is unfortunately not sponsored by a prosumer brand, or anyone, that’d have been something.</p>
<p><em>Ad-style pitch for a business-thing: I help companies find competent, capable or promising Elixir developers. If you build in Elixir and want to spend less time finding great candidates, reach out.</em></p>
<img src="https://underjord.io/assets/images/blog/streamdeckplus.jpg" alt="Picture of my Stream Deck Plus showing some text and some custom button icons. It looks proud."/>
<p>I was first introduced to Elgato for their lighting panels, the arms that hold them up and the Camlink 4K. I was stepping up my streaming/meeting camera situation by putting my then only good camera, a Sony ZV-1, on a stand and improving the lighting.</p>
<p>At the time the camera didn’t do USB streaming, recent firmware allows it to do 720p.. I got the Elgato Camlink 4K instead. It takes the HDMI out from the camera and lets me treat it as a webcam via USB. It has been essentially problem-free for me under Linux continuously. It can hang but I’d blame my USB controllers more than the hardware, other hardware has also complained.</p>
<p>The Elgato Keylights have been nice enough as well. Hook them up to wifi via the app, a Mac or Windows. Then they are accessible to be controlled and they provide nice diffused light that does the job. As I moved <a href="https://underjord.io/the-mac-is-losing-me.html">from Mac to Linux</a> I started controlling them with a Python script using <a href="https://pypi.org/project/leglight/">leglight</a> and also some <a href="https://github.com/lawik/lightswitch">experiments with Nerves</a> and my own <a href="https://github.com/lawik/keylight">keylight library</a>.</p>
<p>I’ve been eyeing the Stream Deck because all the Mac productivity podcasts I have a bad habit of following has been hyping it up. Of course. No Linux support. So I held off. Then I saw the <a href="https://www.elgato.com/en/stream-deck-plus">Stream Deck Plus</a> which has <strong>physical knobs</strong>. And then the <a href="https://www.elgato.com/en/stream-deck-pedal">Stream Deck Pedal</a> which is <strong>a pedal</strong>. I am not hard to impress. Unfortunately.</p>
<p>No Linux support from Elgato but I’ve been feeling up for a challenge. I checked and saw existing implementations in Python, Node, etcetera and therefore I considered it doable. I’ve <a href="https://underjord.io/case-study-inky-an-elixir-library.html">ported from Pyton</a> before with good results. And if I got hard stuck it seemed like <a href="https://timothycrosley.github.io/streamdeck-ui/">streamdeck-ui</a> is a thing. (note: no Stream Deck Plus support at time of writing.).</p>
<p>The Stream Decks are  <code>hidraw</code> (not hi draw, hid raw) devices in Linux terminology which essentially means they can be driven with <a href="https://www.kernel.org/doc/html/next/hid/hidraw.html">a very simplistic interface</a> and all the knowledge about the specific device is enshrined in the userspace code that talks to it. Pretty much the same thing in other OS:es. If you are using the Stream Deck software to set things up, there is literally nothing saved on the device. The software is polling the device for activity, generating and pushing new images whenever the screens need to change and such. Even the Stream Deck Plus with a neat variety of controls and interfaces does very little beside retain an image and provide input signals.</p>
<p>I’d like my code to work on both Linux and the occasional Mac (I still run an Apple laptop) and I don’t mind accidental Windows support. Rather than work with Elixir libraries for straight <a href="https://github.com/nerves-web-kiosk/hidraw">hidraw</a> I looked for something using the library <a href="https://github.com/libusb/hidapi">hidapi</a> which provides cross-platform abstractions with a simple API. I found <a href="https://hex.pm/packages/hid">hid</a> on Hex.pm, unfortunately the source repo is gone.</p>
<p>This is already much more elaborate than the Elgato Keylight. That’s a very straight-forward JSON API. This was more challenging but also a lot more interesting.</p>
<p>The hidapi library provides:</p>
<ul>
<li>hid_enumerate - list devices</li>
<li>hid_open - open a device</li>
<li>hid_write - write an “output report” to a device</li>
<li>hid_read - read an “input report” from a device</li>
<li>hid_send_feature_report - this is another type of write</li>
<li>hid_get_feature_report - this is another type of read</li>
<li>hid_close</li>
</ul>
<p>There are some other I don’t care about as well providing more info about the device and such.</p>
<p>The NIF library I had didn’t have all of those hooked up, I believe I needed to add sending feature reports. I imagine the original author just happened to not need that. I also fixed the makefile to work on recent MacOS and actually fixed a bug or two in the C code. As someone who doesn’t write C, essentially ever, that felt like an achievement. You can <a href="https://github.com/lawik/hid/commits/master">see my changes here</a>.</p>
<p>This stuff happened during the process of porting. I worked off of <a href="https://github.com/abcminiuser/python-elgato-streamdeck">python-elgato-streamdeck</a> as a reference implementation. Particular props to <a href="https://github.com/abcminiuser/python-elgato-streamdeck/pull/108">this PR for Plus support</a>. I also checked my work against <a href="https://github.com/julusian/node-elgato-stream-deck">node-elgato-stream-deck</a> a few times as I wasn’t sure the Python one had it right. Some weird build issue with dynamic shared libraries and ctypes meant I never actually got the Python one running.</p>
<p>The device offers the following functionality:</p>
<ul>
<li>8 buttons aka. “keys” with full color LCD screens under them. Down, Up. That’s all they do.</li>
<li>An LCD touchscreen strip. 800x100, full color. Can register short tap, long press and a weird kind of drag.</li>
<li>4 knobs, turns in steps, left, right, can also send multiple steps if turned quickly. Can also be pressed as a button, up/down.</li>
<li>Controllable LCD brightness (it is really just one panel).</li>
</ul>
<p>All of this is done over that USB HID interface.</p>
<p>I had very little trouble with the Elixir port overall. My most long-standing wtfs where around sending images to the StreamDeck and making sure they worked. I have <a href="https://youtube.com/live/v_7-2L2TFM4">a stream of me struggling to update the LCD</a> where in the end I had just flipped two fields in the messages I was sending. Buttons and knobs took very little time. Compared to when I was making Inky over 3 years ago I have written Elixir pretty much daily since. It is nice to feel that the language fades away when solving problems.</p>
<p>Building and matching binaries could have been more challenging if it wasn’t for all the work I did <a href="https://changelog.com/posts/a-new-chapter-for-changelog-podcasts">with The Changelog for chapter support</a> where I implemented <a href="https://hex.pm/packages/id3vx">an ID3v2 library for Elixir</a>. That made me very familiar with <a href="https://changelog.com/posts/id3vx-a-library-for-parsing-and-encoding-id3-tags">all of the binary pattern matching and constructing binaries</a>.</p>
<p>Let’s actually have some code in here:</p>

  <div data-file="lib/streamdex/devices/streamdeck_plus.ex">
    <p><span>elixir</span>
      <span>lib/streamdex/devices/streamdeck_plus.ex</span>
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>def</span> set_brightness(d, percent) <span>when</span> is_integer(percent) <span>do</span>
	percent <span>=</span> min(max(percent, <span>0</span>), <span>100</span>)
	payload <span>=</span> rightpad_bytes(&lt;&lt;<span>0x03</span>, <span>0x08</span>, percent&gt;&gt;, <span>32</span>)

	write_feature(d, payload)
<span>end</span></code></pre></div>
  </div>

<p>Not too complicated. How about reading keys?</p>

  <div data-file="lib/streamdex/devices/streamdeck_plus.ex">
    <p><span>elixir</span>
      <span>lib/streamdex/devices/streamdeck_plus.ex</span>
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>def</span> read_key_states(d) <span>do</span>
	{<span>:ok</span>, binary} <span>=</span> read(d, <span>14</span>)
	binary
<span>end</span></code></pre></div>
  </div>

<p>Also simple. Writing a new chunk of image to the LCD is a bit more involved..</p>

  <div data-file="lib/streamdex/devices/streamdeck_plus.ex">
    <p><span>elixir</span>
      <span>lib/streamdex/devices/streamdeck_plus.ex</span>
    </p>
    <div><pre tabindex="0"><code data-lang="elixir"><span>def</span> set_lcd_image(d, x, y, width, height, binary) <span>do</span>
    send_lcd_image_chunk(d, binary, x, y, width, height, <span>0</span>)
<span>end</span>

<span>defp</span> send_lcd_image_chunk(_, &lt;&lt;&gt;&gt;, _, _, _, _, _), <span>do</span>: <span>:ok</span>

<span>defp</span> send_lcd_image_chunk(d, binary, x, y, width, height, page_number) <span>do</span>
    <span>if</span> width <span>+</span> x <span>&gt;</span> <span>800</span> <span>do</span>
      <span>raise</span> <span>&#34;too wide&#34;</span>
    <span>end</span>

    <span>if</span> height <span>+</span> y <span>&gt;</span> <span>100</span> <span>do</span>
      <span>raise</span> <span>&#34;too high&#34;</span>
    <span>end</span>

    bytes_remaining <span>=</span> byte_size(binary)
    payload_length <span>=</span> <span>@config</span><span>.</span>image<span>.</span>report<span>.</span>touchlcd_payload_length
    length <span>=</span> min(bytes_remaining, payload_length)

    {bytes, remainder, is_last} <span>=</span>
      <span>case</span> binary <span>do</span>
        &lt;&lt;bytes<span>::</span>binary<span>-</span>size(payload_length), remainder<span>::</span>binary&gt;&gt; <span>-&gt;</span>
          {bytes, remainder, <span>0</span>}

        bytes <span>-&gt;</span>
          {bytes, &lt;&lt;&gt;&gt;, <span>1</span>}
      <span>end</span>

    header <span>=</span>
      [
        <span>0x02</span>,
        <span>0x0C</span>,
        &lt;&lt;x<span>::</span>size(<span>16</span>)<span>-</span>unsigned<span>-</span>integer<span>-</span>little&gt;&gt;,
        &lt;&lt;y<span>::</span>size(<span>16</span>)<span>-</span>unsigned<span>-</span>integer<span>-</span>little&gt;&gt;,
        &lt;&lt;width<span>::</span>size(<span>16</span>)<span>-</span>unsigned<span>-</span>integer<span>-</span>little&gt;&gt;,
        &lt;&lt;height<span>::</span>size(<span>16</span>)<span>-</span>unsigned<span>-</span>integer<span>-</span>little&gt;&gt;,
        is_last,
        &lt;&lt;page_number<span>::</span>size(<span>16</span>)<span>-</span>unsigned<span>-</span>integer<span>-</span>little&gt;&gt;,
        &lt;&lt;length<span>::</span>size(<span>16</span>)<span>-</span>unsigned<span>-</span>integer<span>-</span>little&gt;&gt;,
        <span>0x00</span>
      ]
      <span>|&gt;</span> <span>IO</span><span>.</span>iodata_to_binary()

    <span>16</span> <span>=</span> byte_size(header)

    payload <span>=</span> header <span>&lt;&gt;</span> bytes

    payload <span>=</span> rightpad_bytes(payload, <span>@config</span><span>.</span>image<span>.</span>report<span>.</span>touchlcd_length)

    <span>1024</span> <span>=</span> byte_size(payload)

    <span>case</span> write(d, payload, <span>&#34;set lcd image chunk&#34;</span>) <span>do</span>
      {<span>:ok</span>, _} <span>-&gt;</span>
        send_lcd_image_chunk(d, remainder, x, y, width, height, page_number <span>+</span> <span>1</span>)

      err <span>-&gt;</span>
        err
    <span>end</span>
  <span>end</span></code></pre></div>
  </div>

<p>Still not unreasonable. Just longer.</p>
<iframe width="422" height="751" src="https://www.youtube.com/embed/1c9cwARW2pk" title="StreamDeck Plus in Elixir" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
<p>I shared some in-progress work both in <a href="https://youtube.com/shorts/1c9cwARW2pk">this Short</a> and <a href="https://youtube.com/live/v_7-2L2TFM4">on the livestream</a>.</p>
<p>The end result is <a href="https://github.com/lawik/streamdex">the streamdex library</a> which supports the Stream Deck Plus right now as well as the Stream Deck Pedal (literally three keys, very simple). It is pretty rough, alpha-level, as I only took it to the point where I could use it. If you have a Stream Deck and interest in Elixir, feel free to contribute your device.</p>
<p>As a self-taught web dev it is wild to me that I’m writing something that can be fairly called device drivers right now. I’m not claiming they are advanced or impressive. Userspace drivers like this one live on top of many layers of more complex implementation. I just know that teenager me is nodding his head right now. He is pretty proud.</p>
<p>I’m also very glad that someone else has done the reverse engineering. I did fire up Wireshark a couple of times, actually how I found the final swapped byte for the LCD, but I don’t want any credit for figuring out how these work.</p>
<p>Ever since I got it fully operational I’ve been hacking at a crude but effective project for running a bunch of my computer .. stuff. That’s <a href="https://github.com/lawik/auto">also public</a>.</p>
<p>So far I’ve tried:</p>
<ul>
<li>Lights
<ul>
<li>keys for on/off</li>
<li>a knob for brightness that can be pressed for on/off</li>
<li>a knob for light temperature and pressing the knob resets that to a good default</li>
</ul>
</li>
<li>Calendar
<ul>
<li>Show current and upcoming calendar events on the LCD which I mostly ripped from <a href="https://github.com/lawik/calendar_gadget">my calendar gadget eInk project</a>. Simplistic display still, much more fun to be had.</li>
</ul>
</li>
<li>Play/Pause
<ul>
<li>A key that toggles and uses <a href="https://git.sr.ht/~geb/dotool">dotool</a> to send the media play/pause key event to the OS. Made a quick and nasty <a href="https://github.com/lawik/dotool_elixir">dotool_elixir</a> library that pulls that together and compiles the Go code.</li>
</ul>
</li>
<li>Mic mute
<ul>
<li>Both a key for toggle and a pedal for press. Sends micmute key event to the OS. <em>does not work currently on my KDE :(</em></li>
</ul>
</li>
<li>Key icons
<ul>
<li>Made a small library called <a href="https://github.com/lawik/bs_icons">bs_icons</a> which pulls the Bootstrap Icons repository and provides those for me in my Elixir project. I then mangle into keys.</li>
</ul>
</li>
</ul>
<p>Building on the backs of the community and ecosystem like this I have gotten amazing mileage out of Kip Cole’s great <a href="https://hexdocs.pm/image/readme.html">Image</a> library. I’ve also used <a href="https://github.com/teamon/resvg">resvg</a> for turning SVG into PNG, which I apparently could have done with Image. On the plus side that also brought in Rust as well which meant achieving basic hipster compliance. Now I just need to change my HID library to use Zig and I’ll have aced it. That might happen actually.</p>
<p>Things yet to try:</p>
<ul>
<li>Touchscreen
<ul>
<li>Want to render much more interesting UI on it. Image can do so much fun stuff and I bet I could make it play nice with Brian Cardarella’s <a href="https://hexdocs.pm/easing/readme.html">easing library</a>. I’ve already tested a bit and Image can update the screen at just shy of 60hz. No idea if that looks reasonable though. We can expect to push 30hz with no issue I expect. Image provides operations like <code>blur</code> and <code>ripple</code> which I’d love to animate. I made <a href="https://youtube.com/shorts/ze2ZGMh8hQY">a Short showing the silliness I’m after</a>.</li>
<li>Using the touch at all. I’m most curious about the drag. I couldn’t actually see that Elgato uses that so it might be too crap. But I want to see what I can make it do. Build a whole little touch UI in there.</li>
</ul>
</li>
<li>Update keys while being pressed, trigger events on key up after down instead of down. Those kinds of niceties.</li>
</ul>
<iframe width="422" height="751" src="https://www.youtube.com/embed/ze2ZGMh8hQY" title="Elixir image processing" frameborder="0" allow="autoplay; clipboard-write; encrypted-media; picture-in-picture; web-share" allowfullscreen=""></iframe>
<p>This is a really fun thing to poke around with when I have some moments for myself. Just making it do more and more. Exploring how I can combine more and more sources of data, inputs and outputs. I have a very simplistic GenServer-driven approach right now that I’d like to think about abstracting a bit. If I want to do better UI I need to keep the state of the UI differently and I’ll need to manage timing for animations.</p>
<p>I have a bunch of ideas around how to wrap libraries that provide new capabilities in a way where they plug into this in a more flexible way. Early thoughts. Might go nowhere.</p>
<p>When they market macro-pads like this for productivity I don’t think they usually mean that you’ll write tons of lines of code to make them do things. For me, this device has made me very productive. In a very specific way.</p>

    </article></div>
  </body>
</html>
