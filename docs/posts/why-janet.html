<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ianthehenry.com/posts/why-janet/">Original</a>
    <h1>Why Janet?</h1>
    
    <div id="readability-page-1" class="page"><article>

<div><p>I never thought it could happen to me. I mean, parentheses? In this day and age? But for the past couple years, my go-to programming language for fun side projects has been a little Lisp dialect called <a href="https://janet-lang.org/">Janet</a>.</p>
<pre tabindex="0"><code>(print &#34;hey janet&#34;)
</code></pre><p>I like Janet so much that <a href="https://janet.guide/">I wrote an entire book about it</a>, and put it on The Internet for free, in the hopes of attracting more Janetors to the language.</p>
<p>I think you should read it, but I know that you don’t believe me, so I’m going to try to convince you. Here’s my attempt at a sales pitch: here is why you – <em>you of all people</em> – should give Janet a chance.</p>

<p>Janet is an imperative language with first-class functions, a single namespace for identifiers, and lexical block scoping. The core of the language is very small, consisting of only eight instructions: <code>do</code>, <code>def</code>, <code>var</code>, <code>set</code>, <code>if</code>, <code>while</code>, <code>break</code>, <code>fn</code>. But thanks to macros, there are lots of high-level wrappers that give you more powerful or convenient control flow.</p>

<p>You can “learn” Janet in an afternoon, because the runtime semantics are extremely familiar: think JavaScript, plus value types, minus all the wats. And the rest of the language is small: the entire standard library <a href="https://janet-lang.org/api/index.html">fits on one page</a>. It was this ease of getting started that got me hooked in the first place.</p>

<p>It’s easy to compile Janet programs into native executables that statically link the Janet runtime. And you can share those programs with other people, without asking them to install Janet first – or your project’s dependencies, or anything else for that matter. You don’t even have to tell them it’s written in Janet!</p>
<p>The way that Janet pulls this off is very elegant: Janet compiles itself to bytecode, and then writes that bytecode into a <code>.c</code> file that also starts up the Janet runtime. Then it compiles that C file with your system’s C compiler. Since Janet is designed to be easy to embed, this makes perfect sense: it is, essentially, embedding itself into a trivial C executable.</p>
<p>A simple Janet “hello world” compiled to a native binary weighs under a megabyte (784K for Janet 1.27.0 on aarch64 macOS, but your mileage may vary). This includes the full Janet runtime, garbage collector, and even the bytecode compiler – so you can write programs that evaluate Janet code at runtime, <a href="https://bauble.studio/">if you want to</a>.</p>
<p>This makes Janet an excellent choice for writing little command-line apps. Which is especially true when you consider that…</p>

<p>Instead of regular expressions, Janet’s text wrangling is based around <em>parsing expression grammars</em>. Parsing expression grammars are simpler, more powerful, and more predictable than regular expressions. They aren’t line-oriented, so they can parse multi-line text without a problem. They can also parse HTML, or JSON, or any other non-regular language. They can also parse <em>binary</em> file formats – they have no problems with arbitrary null bytes.</p>
<p>They really are <em>parsers</em>: structured, composable, first-class parsers. <a href="https://janet.guide/pegular-expressions/">And they’re pretty easy to learn!</a></p>

<p>There is a <a href="https://github.com/andrewchambers/janet-sh">third-party library called <code>sh</code></a> that provides a shell scripting DSL that allows you to express pipes and redirects directly in Janet. Like this:</p>
<pre tabindex="0"><code data-lang="janet">($ find . -name *.janet | say)
</code></pre><p>It’s pretty incredible. It’s such a nice DSL that <a href="https://janet.guide/scripting/">I dedicated a whole chapter of <em>Janet for Mortals</em> to it</a> – and the things that you can do with it. It elevates Janet from a reasonable alternative to Perl to a reasonable alternative to <em>Bash</em> for a surprisingly large range of programs.</p>

<p>Lua has become the de facto “embedded language,” which is a shame, because… well, this isn’t a post about Lua. You might not care about this very much, but there’s a chance that it’s just because you haven’t tried it yet: being able to write <a href="https://bauble.studio/">progams that expose scripting interfaces</a> is a pretty fun superpower.</p>
<p>Embedding Janet is very easy: the Janet runtime is a small C library, and all you have to do is link it in and then call regular C functions to manipulate Janet values. You can even embed it into <em>websites</em>, and write <a href="https://toodle.studio/">static sites with custom programmable DSLs</a>!</p>

<p>Janet’s collection types come in mutable and immutable flavors. Immutable collections have value semantics: the immutable vector <code>[1 2]</code> is indistinguishable from <code>(take 2 [1 2 3])</code>, despite the fact that they have different memory addresses. Mutable collections, on the other hand, have reference semantics: the hash table <code>@{:x 1 :y 2}</code> is only equal to itself. Another hash table with the same keys and values is a distinct object.</p>
<p>Not every language has immutable composite values built right into the standard library!</p>

<p>I think this is the real reason you should learn Janet, but I didn’t want to lead with it because I didn’t want to scare you off.</p>
<p>You can write Janet just fine without ever learning how to write macros. But you should learn how, because writing macros is <em>fun</em>. It feels different than any sort of programming that I’ve done before.</p>
<p>Writing macros requires thinking twice at once: you’re writing code to write code, so you have to keep two threads of execution straight in your mind: the code that is running now, at compile time, manipulating values and abstract syntax trees, and the code that you are manipulating, the application code that you produce, the code that will run in the future.</p>
<p>Janet’s macros are not hygienic, and Janet does not have a separate namespace for functions. But by allowing you to unquote literal functions, Janet makes it possible to write macros that are completely referentially transparent. It’s an incredibly simple and elegant solution to an <a href="https://ianthehenry.com/posts/janet-game/the-problem-with-macros/">otherwise very delicate problem</a>. And the fact that it is possible to do this in Janet highlights my next favorite feature…</p>

<p>This is the most interesting thing about Janet, in my opinion. But it might not sound very interesting at first – really all it means is that any Janet value can be serialized to disk and read back in later.</p>
<p>But this serialization is implicit: when you compile a Janet program, it runs all of the top-level instructions – regular statements, function declarations, whatever – and then, once it’s executed all of the top-level values, Janet writes down a snapshot of your program’s state to disk.</p>
<p>And it’s a <em>full</em> snapshot of your program’s state: shared references are preserved, so mutable values can still be mutated after you “resume” the snapshot. Generators remember exactly what instruction they need to run the next time you resume them. Closures gonna close.</p>
<p>Macros are a special-case of compile-time code execution – manipulating abstract syntax trees to create new functions – but this is a superpower that you can enjoy without any macros at all. Making a game? Reticulate your splines ahead of time! Or embed assets in your final binary by reading files at compile time – you can perform arbitrary side effects!</p>
<p><a href="https://janet.guide/macros-and-metaprogramming/"><em>Janet for Mortals</em> has an example of using this to autogenerate database bindings based on a SQL schema file</a> – a bit of a silly example, but something that would be quite difficult to do in most languages.</p>

<p>This is completely subjective, but I love Janet’s syntax. It strikes a perfect balance of simplicity, uniformity, and variety.</p>
<p>It uses pervasive parentheses, but breaks them up with <code>[]</code> for lists and <code>{}</code> for tables.</p>
<p>Mutable literals are always prefixed with <code>@</code>: <code>@&#34;mutable string&#34;</code>, <code>{:immutable hash-table}</code>, etc.</p>
<p>Anonymous functions are written <code>(fn [x] (+ 1 x))</code>, but there’s a shorthand notation for lifting any expression into a function with <code>|</code>: <code>|(+ 1 $)</code>.</p>
<p>Janet supports “splats” or “spreads” with <code>;</code>: <code>(+ ;args)</code>.</p>
<p>String literals can be written with any number of backticks, and closed with the same number of backticks. Escape sequences like <code>\n</code> don’t apply in backtick-quoted strings, so you can create strings with any contents without ever thinking about how to escape them – all you have to do is wrap them in a sufficient number of backticks.</p>
<p>Rest parameters use <code>&amp;</code> instead of <code>.</code>: <code>(defn foo [first &amp; rest] ...)</code>.</p>
<p>Janet doesn’t support reader macros, so the syntax itself is fixed. If you know how to read Janet, you can read all Janet programs. Which is not to say you can make sense of them…</p>

<p>Janet does not adhere to the ancient customs. <code>CAR</code> is called <code>first</code>. <code>PROGN</code> is called <code>do</code>. <code>LAMBDA</code> is <code>fn</code>, and <code>SETQ</code> is <code>def</code>. <code>nil</code> is not the empty list; it is its own type, and there are first-class Booleans in the language. It eschews <code>EQ</code>, <code>EQL</code>, <code>EQUAL</code>, and <code>EQUALP</code>. There is nary a linked list in sight.</p>
<p>This isn’t really <em>good</em> or <em>bad</em>, but I thought it was worth calling out: if you saw the parentheses and assumed <code>FORMAT</code> was not far behind, maybe give Janet a second look.</p></div>
</article></div>
  </body>
</html>
