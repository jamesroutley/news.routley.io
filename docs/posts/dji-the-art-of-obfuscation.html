<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.quarkslab.com/dji-the-art-of-obfuscation.html">Original</a>
    <h1>DJI – The ART of obfuscation</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p>Study of an Android runtime (ART) hijacking mechanism for bytecode
injection through a step-by-step analysis of the packer used to protect the
DJI Pilot Android application.</p>

  <center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/logo.png" alt="Logo" width="40%"/>
</center>
<h2>Introduction</h2>
<p>In the world of Android applications, it&#39;s not uncommon to come across
applications protected by a packer. The role of a packer is to protect all
or part of the application code from static analysis. There are many reasons
why a developer might want to protect an application:</p>
<ul>
<li>Protect valuable business logic;</li>
<li>Protect application monetization logic (e.g. a license management mechanism);</li>
<li>Evading conventional analysis tools to hide malicious logic;</li>
<li>...</li>
</ul>
<p>Here, we take a look at the <a href="https://www.dji.com/downloads/djiapp/dji-pilot"><em>DJI Pilot</em></a>
application, not to understand why developers want to protect their code - this
has already been the subject of previous work (see in particular this
<em>DJI Pilot</em> <a href="https://www.synacktiv.com/en/publications/dji-pilot-android-application-security-analysis-1.html">analysis</a>)
- but to highlight a runtime mechanism implemented by DJI to protect its
application code. This protection is based on the use of a modified version of
the <em>SecNeo</em> packer.</p>
<p>The article details the various stages in the analysis to understand how the
application code is obfuscated. A Python proof-of-concept named
<a href="https://github.com/quarkslab/dxfx/tree/main"><em>DxFx</em></a> for statically unpacking
the <em>DJI Pilot</em> application is provided as practical support for this article.
<em>DxFx</em> does not claim to be a <em>SecNeo</em> unpacker. Its sole aim is to improve the
reader&#39;s understanding of the various mechanisms implemented by the packer
through Python code. It will not be maintained in the future.</p>
<h2>Targeted application</h2>
<p>The analysis is performed on the latest version of the <em>DJI Pilot</em> application:</p>
<ul>
<li>Version: 2.5.1.17</li>
<li>SHA256: <code>642aa123437c259eea5895fe01dc4210c4a3a430842b79612074d88745f54714</code></li>
<li><a href="https://service-adhoc.dji.com/download/app/android/cf4cc976-50c5-4960-b09e-45a82d31ce83">Download link</a></li>
</ul>
<p><em>DxFx</em> provided in support of the article has also been tested on the following
versions of the <em>DJI Pilot</em> application:</p>
<ul>
<li>Version: 2.5.1.15</li>
<li>SHA256: <code>d6f96f049bc92b01c4782e27ed94a55ab232717c7defc4c14c1059e4fa5254c8</code></li>
</ul>
<p>and</p>
<ul>
<li>Version: 2.5.1.10</li>
<li>SHA256: <code>860d9d75dc2b2e9426f811589b624b96000fea07cc981b15005686d3c55251d9</code></li>
</ul>
<h2>Bytecode, where are you?</h2>
<h3>Primary analysis</h3>
<p>Static analysis of the APK initially reveals that the result of bytecode
decompilation is, to say the least, uncluttered...</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/jadx-apk-packed.png" alt="Decompiled tree"/>
</center>
<p>This is because, like other packers, <em>SecNeo</em> leaves only a bootstrap code in
the bytecode to launch the application&#39;s unpacking phase. Here, the packer
bootstrap code loads the native <code>libDexHelper.so</code> library:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/load-native-library.png" alt="Decompiled tree" width="80%"/>
</center>
<p>The first step in the analysis is therefore to find the bytecode containing the
application&#39;s business logic.</p>
<p>The packer logic is present in the native library <code>libDexHelper.so</code>. However,
the code of this library is itself packed. So, we have to unpack... the packer
to analyze its logic.</p>
<p>As the aim of this article is not to understand how the packer itself is
protected, this part is not dealt with in-depth, and we simply dump the
library at runtime from the <em>DJI Pilot</em> application process memory space. There
are a multitude of ways to do this, using tools such as <em>gdb</em> or <em>Frida</em>.</p>
<p>However, you may be in for a few surprises:</p>
<div><pre><span></span><code>Cannot attach to process 25562: Operation not permitted (1), process 25562 is already traced by process 25598
</code></pre></div>

<p>or:</p>
<div><pre><span></span><code>Failed to attach: process not found
</code></pre></div>

<p>The packer contains some countermeasures, as partially described in this
<a href="https://github.com/strazzere/android-unpacker/issues/39">issue</a>,
to prevent the use of dynamic tools. Fortunately, these can be easily bypassed.</p>
<p>Once <code>libDexHelper.so</code> has been dumped from memory, it can be analyzed with a
disassembly tool.</p>
<h3>First look at the packer binary</h3>
<p>An initial brief analysis of the <code>libDexHelper.so</code> library reveals the presence
of the <code>decrypt_jar_128K</code> symbol. A hook of the associated function with
<em>Frida</em> reveals that a buffer is passed as input and contains the contents of a
DEX file as output :</p>
<div><pre><span></span><code><span>&#39;use strict&#39;</span><span>;</span><span></span>

<span>const</span><span> </span><span>dlopen_ext</span><span> </span><span>=</span><span> </span><span>Module</span><span>.</span><span>getExportByName</span><span>(</span><span>null</span><span>,</span><span> </span><span>&#39;__loader_android_dlopen_ext&#39;</span><span>);</span><span></span>

<span>function</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>const</span><span> </span><span>decrypt_jar_128K_addr</span><span> </span><span>=</span><span> </span><span>Module</span><span>.</span><span>getExportByName</span><span>(</span><span></span>
<span>    </span><span>&#39;libDexHelper.so&#39;</span><span>,</span><span> </span><span>&#39;decrypt_jar_128K&#39;</span><span></span>
<span>  </span><span>);</span><span></span>

<span>  </span><span>/**</span>
<span>  * decrypt_jar_128K function hook</span>
<span>  */</span><span></span>
<span>  </span><span>Interceptor</span><span>.</span><span>attach</span><span>(</span><span>decrypt_jar_128K_addr</span><span>,</span><span> </span><span>{</span><span></span>
<span>    </span><span>onEnter</span><span>:</span><span> </span><span>function</span><span>(</span><span>args</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>this</span><span>.</span><span>dex_buffer_ptr</span><span> </span><span>=</span><span> </span><span>args</span><span>[</span><span>1</span><span>];</span><span></span>
<span>    </span><span>},</span><span></span>
<span>    </span><span>onLeave</span><span>:</span><span> </span><span>function</span><span>()</span><span> </span><span>{</span><span></span>
<span>      </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`\nReading dex buffer @ </span><span>${</span><span>this</span><span>.</span><span>dex_buffer_ptr</span><span>}</span><span>`</span><span>);</span><span></span>
<span>      </span><span>console</span><span>.</span><span>log</span><span>(</span><span>this</span><span>.</span><span>dex_buffer_ptr</span><span>.</span><span>readByteArray</span><span>(</span><span>16</span><span>));</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>});</span><span></span>
<span>}</span><span></span>

<span>/**</span>
<span> * Bootstrap</span>
<span> */</span><span></span>
<span>const</span><span> </span><span>boot_intercept</span><span> </span><span>=</span><span> </span><span>Interceptor</span><span>.</span><span>attach</span><span>(</span><span>dlopen_ext</span><span>,</span><span> </span><span>{</span><span></span>
<span>  </span><span>onEnter</span><span>:</span><span> </span><span>function</span><span>(</span><span>args</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>this</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>args</span><span>[</span><span>0</span><span>].</span><span>readUtf8String</span><span>();</span><span></span>
<span>  </span><span>},</span><span></span>
<span>  </span><span>onLeave</span><span>:</span><span> </span><span>function</span><span>()</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>this</span><span>.</span><span>name</span><span>.</span><span>includes</span><span>(</span><span>&#39;libDexHelper.so&#39;</span><span>))</span><span> </span><span>{</span><span></span>
<span>      </span><span>main</span><span>()</span><span></span>
<span>      </span><span>boot_intercept</span><span>.</span><span>detach</span><span>();</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>}</span><span></span>
<span>});</span><span></span>
</code></pre></div>

<p>The result of the script is:</p>
<div><pre><span></span><code>Reading dex buffer @ 0x74d1e63140
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  64 65 78 0a 30 33 35 00 4a 8b b5 fd 1b 58 54 1f  dex.035.J....XT.

Reading dex buffer @ 0x74d268c140
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  64 65 78 0a 30 33 35 00 6f 02 2a 0b 48 26 a5 e0  dex.035.o.*.H&amp;..

Reading dex buffer @ 0x74d3005140
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  64 65 78 0a 30 33 35 00 8a b4 08 1c 90 61 5a 34  dex.035......aZ4

Reading dex buffer @ 0x74d3643140
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  64 65 78 0a 30 33 35 00 cb b9 8e 72 35 3a d8 bc  dex.035....r5:..

Reading dex buffer @ 0x74d4055140
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  64 65 78 0a 30 33 35 00 c2 8b a3 7b 64 3b c6 54  dex.035....{d;.T

Reading dex buffer @ 0x74d4a5f140
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  64 65 78 0a 30 33 35 00 dd 47 c2 4e a1 39 cc 79  dex.035..G.N.9.y

Reading dex buffer @ 0x74d552f140
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  64 65 78 0a 30 33 35 00 58 17 ae a9 56 21 f1 1f  dex.035.X...V!..

Reading dex buffer @ 0x74d5a77140
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  64 65 78 0a 30 33 35 00 84 62 14 0d ac 5f b7 f8  dex.035..b..._..
</code></pre></div>

<p>So, here we can see that <strong>8</strong> DEX files (with the <code>dex.035</code> magic) are
unpacked. It is possible to modify the previous hook to be able to dump the
various DEX files as they are unpacked. Another solution is to understand where
the packed DEX files are stored in the APK and how we can unpack them
statically.</p>
<h3>Static unpacking of DEX files</h3>
<p>The advantage of the dynamic extraction method lies in its rapid
implementation. However, the latter requires the application to be run and an
environment set up to allow instrumentation of the process. Static extraction,
on the other hand, enables cold unpacking of DEX files directly from the APK.
The drawback of the static approach is that it requires a slightly deeper
understanding of how the packer works.</p>
<h4>DEX files where are you?</h4>
<p>Some versions of the <em>SecNeo</em> packer store the bytecode in the <code>classes0.jar</code>
file located in the APK assets. Unfortunately, this is not the case here as
the file does not exist.</p>
<p>However, if we take a closer look at the <code>classes.dex</code> file located at the root
of the APK and supposed to contain only the packer bootstrap code, we can see
that something is wrong with its size:</p>
<div><pre><span></span><code>du -h classes.dex
63M     classes.dex
</code></pre></div>

<p>63MB is a very large size for the code we observed in the first analysis.
Usually, the <a href="https://developer.android.com/build/multidex">multidex</a> mechanism
will split the bytecode file into several <code>.dex</code> files well before reaching
this size. File entropy analysis also gives us some interesting clues:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/classes-dex-entropy.png" alt="Entropy of classes.dex"/>
</center>
<p>We can see <strong>8</strong> peaks tending towards an entropy of 8, which may
suggest that these chunks are encrypted. The previous <em>Frida</em> hook revealed
that 8 DEX files were unpacked, which is probably no coincidence. The 8 chunks
shown in the graph correspond to 128KB sections, so we can make the connection
with the <code>decrypt_jar_128K</code> symbol of the function. A differential analysis
with the dynamically obtained files finally confirms that the <code>classes.dex</code>
file contains all 8 DEX files after the <em>SecNeo</em> bootstrap code. The first 128K
chunk of each DEX file is encrypted to probably conceal certain information that
could be used to detect the presence of the hidden files like the
<a href="https://source.android.com/docs/core/runtime/dex-format#header-item">magic number</a>
in the header.</p>
<h4>Encryption analysis</h4>
<p>To understand how the first 128KB of each DEX is decrypted, we need to analyze
how the <code>decrypt_jar_128K</code> function works.</p>
<p>One of the function&#39;s basic blocks contains the encryption logic:</p>
<div><pre><span></span><code><span>loc_8DC78</span><span></span>
<span>ADD</span><span>             </span><span>W3</span><span>,</span><span> </span><span>W3</span><span>,</span><span> </span><span>#1</span><span>      </span><span>;</span><span> </span><span>i</span><span>++</span><span></span>
<span>LDRB</span><span>            </span><span>W6</span><span>,</span><span> </span><span>[</span><span>X5</span><span>]</span><span>,</span><span>#1</span><span>     </span><span>;</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>buffer</span><span>[</span><span>cursor++</span><span>]</span><span></span>
<span>AND</span><span>             </span><span>W7</span><span>,</span><span> </span><span>W3</span><span>,</span><span> </span><span>#0xFF</span><span>   </span><span>;</span><span> </span><span>i</span><span> </span><span>%=</span><span> </span><span>256</span><span></span>
<span>SUB</span><span>             </span><span>W0</span><span>,</span><span> </span><span>W5</span><span>,</span><span> </span><span>W1</span><span></span>
<span>MOV</span><span>             </span><span>X3</span><span>,</span><span> </span><span>X7</span><span></span>
<span>CMP</span><span>             </span><span>X2</span><span>,</span><span> </span><span>X0</span><span></span>
<span>LDRB</span><span>            </span><span>W0</span><span>,</span><span> </span><span>[</span><span>X8,X7</span><span>]</span><span>     </span><span>;</span><span> </span><span>+--</span><span></span>
<span>ADD</span><span>             </span><span>W4</span><span>,</span><span> </span><span>W4</span><span>,</span><span> </span><span>W0</span><span>      </span><span>;</span><span> </span><span>|</span><span> </span><span>j</span><span> </span><span>=</span><span> </span><span>(</span><span>j</span><span> </span><span>+</span><span> </span><span>S</span><span>[</span><span>i</span><span>]</span><span>)</span><span> </span><span>%</span><span> </span><span>256</span><span></span>
<span>AND</span><span>             </span><span>W9</span><span>,</span><span> </span><span>W4</span><span>,</span><span> </span><span>#0xFF</span><span>   </span><span>;</span><span> </span><span>+--</span><span></span>
<span>MOV</span><span>             </span><span>X4</span><span>,</span><span> </span><span>X9</span><span></span>
<span>LDRB</span><span>            </span><span>W10</span><span>,</span><span> </span><span>[</span><span>X8,X9</span><span>]</span><span>    </span><span>;</span><span> </span><span>+--</span><span></span>
<span>STRB</span><span>            </span><span>W10</span><span>,</span><span> </span><span>[</span><span>X8,X7</span><span>]</span><span>    </span><span>;</span><span> </span><span>|</span><span></span>
<span>STRB</span><span>            </span><span>W0</span><span>,</span><span> </span><span>[</span><span>X8,X9</span><span>]</span><span>     </span><span>;</span><span> </span><span>|</span><span> </span><span>S</span><span>[</span><span>i</span><span>]</span><span>,</span><span> </span><span>S</span><span>[</span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>S</span><span>[</span><span>j</span><span>]</span><span>,</span><span> </span><span>S</span><span>[</span><span>i</span><span>]</span><span></span>
<span>LDRB</span><span>            </span><span>W7</span><span>,</span><span> </span><span>[</span><span>X8,X7</span><span>]</span><span>     </span><span>;</span><span> </span><span>+--</span><span></span>
<span>ADD</span><span>             </span><span>W0</span><span>,</span><span> </span><span>W7</span><span>,</span><span> </span><span>W0</span><span>      </span><span>;</span><span> </span><span>+--</span><span></span>
<span>UXTB</span><span>            </span><span>W0</span><span>,</span><span> </span><span>W0</span><span>          </span><span>;</span><span> </span><span>|</span><span></span>
<span>LDRB</span><span>            </span><span>W0</span><span>,</span><span> </span><span>[</span><span>X8,X0</span><span>]</span><span>     </span><span>;</span><span> </span><span>|</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>S</span><span>[</span><span>(S[i</span><span>]</span><span> </span><span>+</span><span> </span><span>S</span><span>[</span><span>j</span><span>]</span><span>)</span><span> </span><span>%</span><span> </span><span>256</span><span>]</span><span> </span><span>^</span><span> </span><span>x</span><span></span>
<span>EOR</span><span>             </span><span>W0</span><span>,</span><span> </span><span>W0</span><span>,</span><span> </span><span>W6</span><span>      </span><span>;</span><span> </span><span>+--</span><span></span>
<span>STURB</span><span>           </span><span>W0</span><span>,</span><span> </span><span>[</span><span>X5,#-1</span><span>]</span><span>    </span><span>;</span><span> </span><span>buffer</span><span>[</span><span>cursor-1</span><span>]</span><span> </span><span>=</span><span> </span><span>x</span><span></span>
<span>B</span><span>.</span><span>HI</span><span>            </span><span>loc_8DC78</span><span></span>
</code></pre></div>

<p>This is <a href="https://en.wikipedia.org/wiki/RC4">RC4</a>&#39;s pseudo-random generation
algorithm (<a href="https://en.wikipedia.org/wiki/RC4#Pseudo-random_generation_algorithm_(PRGA)">PRGA</a>):</p>
<div><pre><span></span><code>i := 0
j := 0
while GeneratingOutput:
    i := (i + 1) mod 256
    j := (j + S[i]) mod 256
    swap values of S[i] and S[j]
    t := (S[i] + S[j]) mod 256
    K := S[t]
    output K
endwhile
</code></pre></div>

<p>Analysis of the decrypt_jar_128K CFG gives us information about where different
parts of the RC4 algorithm are located:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/decrypt-jar-128K-overview.png" alt="decrypt_jar_128K CFG" width="70%"/>
</center>
<h4>Encryption key generation</h4>
<p>The key&#39;s cross-references lead to a generation function based on a simple XOR
between a 16-byte hardcoded constant and the 16 first bytes of the string
<code>com.dji.industry.pilot</code>:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/dex-rc4-keygen-cfg.png" alt="Generate RC4 key DEX"/>
</center>
<p>We are now able to statically unpack DEX files.</p>
<blockquote>
<p>The DEX encryption is currently implemented in the <a href="https://github.com/quarkslab/dxfx/blob/c5d65eade92ce818e07af6edacb83a6f3f8d7669/dxfx/dex.py#L247">DexPool</a> class of <em>DxFx</em></p>
</blockquote>
<p>However, disassembly of the unpacked DEX files reveals a problem. The code for
a large number of methods seems to have been stolen, overwritten, and replaced
mainly by <code>nop</code> instructions:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/stolen-bytecode.png" alt="Stolen bytecode" width="60%"/>
</center>
<p>We can therefore assume that the packer has a second bytecode protection
mechanism.</p>
<h2>Bytecode where are you? Again...</h2>
<h3>Method debug info</h3>
<p>The various methods whose code is stolen all seem to contain a
<a href="https://source.android.com/docs/core/runtime/dex-format#code-item">debug info offset</a>
(<code>debug_info_off</code>) which also appears in the body of the method:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/debug-info-off.png" alt="Method degug_info_off" width="80%"/>
</center>
<p>It seems there is something fishy with the <code>debug_info_off</code>, this field could
play a role in the method code unpacking mechanism, perhaps as an identifier.
Moreover, a <code>classes.dgc</code> file located in the APK assets contains a large
number of debug info offsets used in stolen methods... The <code>classes.dgc</code> file
therefore seems a potentially interesting candidate for further analysis.</p>
<h3>The classes.dgc file</h3>
<p>An entropy analysis reveals that the beginning of the file (oddly enough, a
128KB chunk) probably contains encrypted data:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/dgc-entropy.png" alt="Entropy of classes.dgc"/>
</center>
<p>This is a good lead to follow in the <code>libDexHelper.so</code> binary.</p>
<h4>Encryption analysis</h4>
<p>Likely, a mechanism similar to the 128KB chunk encryption of DEX
files is used for the <code>classes.dgc</code> file. Analysis of <code>libDexHelper.so</code> reveals
a function whose scheme also corresponds to an RC4 encryption algorithm:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/dgc-rc4-decrypt.png" alt="DGC RC4 decryption" width="70%"/>
</center>
<p>We can confirm that is the <code>classes.dgc</code> decryption function by using a simple
Frida hook:</p>
<div><pre><span></span><code><span>&#39;use strict&#39;</span><span>;</span><span></span>

<span>const</span><span> </span><span>dlopen_ext</span><span> </span><span>=</span><span> </span><span>Module</span><span>.</span><span>getExportByName</span><span>(</span><span>null</span><span>,</span><span> </span><span>&#34;__loader_android_dlopen_ext&#34;</span><span>);</span><span></span>
<span>const</span><span> </span><span>nullptr</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>

<span>function</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>const</span><span> </span><span>rc4_fct_addr</span><span> </span><span>=</span><span> </span><span>Module</span><span>.</span><span>getExportByName</span><span>(</span><span></span>
<span>    </span><span>&#39;libDexHelper.so&#39;</span><span>,</span><span></span>
<span>    </span><span>&#39;p416302DA23BEF5D5A81473ACFAC4DA25&#39;</span><span></span>
<span>  </span><span>);</span><span></span>

<span>  </span><span>Interceptor</span><span>.</span><span>attach</span><span>(</span><span>rc4_fct_addr</span><span>,</span><span> </span><span>{</span><span></span>
<span>    </span><span>onEnter</span><span>:</span><span> </span><span>function</span><span>(</span><span>args</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>console</span><span>.</span><span>log</span><span>(</span><span>args</span><span>[</span><span>0</span><span>].</span><span>readByteArray</span><span>(</span><span>32</span><span>))</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>});</span><span></span>
<span>}</span><span></span>

<span>Interceptor</span><span>.</span><span>attach</span><span>(</span><span>dlopen_ext</span><span>,</span><span> </span><span>{</span><span></span>
<span>  </span><span>onEnter</span><span>:</span><span> </span><span>function</span><span>(</span><span>args</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>this</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>args</span><span>[</span><span>0</span><span>].</span><span>readUtf8String</span><span>();</span><span></span>
<span>  </span><span>},</span><span></span>
<span>  </span><span>onLeave</span><span>:</span><span> </span><span>function</span><span>(</span><span>retval</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>retval</span><span> </span><span>!=</span><span> </span><span>nullptr</span><span> </span><span>&amp;&amp;</span><span> </span><span>this</span><span>.</span><span>name</span><span>.</span><span>includes</span><span>(</span><span>&#39;libDexHelper.so&#39;</span><span>))</span><span></span>
<span>      </span><span>main</span><span>();</span><span></span>
<span>  </span><span>}</span><span></span>
<span>});</span><span></span>
</code></pre></div>

<p>The result is:</p>
<div><pre><span></span><code>           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  ef bd de 50 8b bb 81 c7 80 63 35 ca 95 6e 1d 1d  ...P.....c5..n..
00000010  36 d5 ef 02 df 2a 50 2b e8 88 03 c3 9b 45 da 5f  6....*P+.....E._
</code></pre></div>

<p>It matches the first bytes of the <code>classes.dgc</code> file:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/first-bytes-of-classes-dgc.png" alt="First bytes of the classes.dgc file" width="60%"/>
</center>
<p>As with the <code>decrypt_jar_128K</code> function, the basic block initializing <code>S</code> to
identity permutation reveals the presence of a cross-reference to the key.</p>
<h4>Encryption key generation</h4>
<p>From the cross-references, it is possible to locate the key generation function.
The CFG of the function looks a bit like the one used to generate the DEX
decryption key. However, a slightly more complex mechanism is used to generate
the key:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/dgc-rc4-keygen-cfg.png" alt="DGC RC4 key generation" width="90%"/>
</center>
<p>First, the <a href="https://en.wikipedia.org/wiki/MD5">MD5</a> hash of a 4096-byte binary
blob in memory is computed. MD5 is identified by looking at a sub-function called
in the previous CFG. This sub-function corresponds to the
<a href="https://en.wikipedia.org/wiki/MD5#Pseudocode">MD5 algorithm</a> for calculating a
block (512 bits). The algorithm is flattened and contains hardcoded <code>K</code>
constants (<code>0xe8c7b756</code>, <code>0xd76aa478</code>, ...).</p>
<p>The binary blob is loaded directly from <code>libDexHelper.so</code> and can be found even
in the packed version of the library. This chunk appears to be preceded by a
kind of header containing the name <code>mthfilekey</code>:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/mthfilekey-header.png" alt="mthfilekey entry in libDexHelper.so" width="60%"/>
</center>
<p>Once the MD5 has been calculated, a deterministic sequence is generated by
calling another sub-function. Analysis of the function reveals that it is a
<em>Fibonacci</em> sequence:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/generate-sequence-cfg.png" alt="Fibonacci generator function CFG" width="80%"/>
</center>
<p>Next, the 16 bytes of the MD5 hash are <em>XORed</em> with 16 bytes retrieved directly
from the 4096-byte chunk (<code>mthfilekey</code>) following a deterministic walk based
on the <em>Fibonacci</em> sequence previously generated.</p>
<p>We are now able to statically generate the RC4 key that decrypts the first
128KB of the <code>classes.dgc</code> file.</p>
<blockquote>
<ul>
<li>The <code>classes.dgc</code> decryption is implemented in the <a href="https://github.com/quarkslab/dxfx/blob/c5d65eade92ce818e07af6edacb83a6f3f8d7669/dxfx/dgc.py#L42">CodePool._decrypt_chunk</a> method of <em>DxFx</em>.</li>
<li>The RC4 key generation is done by the <a href="https://github.com/quarkslab/dxfx/blob/c5d65eade92ce818e07af6edacb83a6f3f8d7669/dxfx/bin.py#L57">BinHelper.code_pool_key</a> method of <em>DxFx</em>.</li>
</ul>
</blockquote>
<h4>classes.dgc file format</h4>
<p>Once decrypted, looking at <code>classes.dgc</code> reveals that the beginning of the
file contains a table indexing all the application methods
(<a href="https://source.android.com/docs/core/runtime/dex-format#code-item">code_item</a>)
whose code has been stolen:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/dgc-index-layout.png" alt="classes.dgc index layout" width="70%"/>
</center>
<p>Each table item points to the code_item of a method:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/dgc-code-item.png" alt="classes.dgc index layout" width="70%"/>
</center>
<p>However, as it stands, the Dalvik opcodes present in the method bodies seem
inconsistent and therefore probably obfuscated... At this stage, we have all
the elements needed to link the stolen bytecode (even if obfuscated for the
moment, we will address this later) to the application&#39;s various damaged
methods. First of all, it&#39;s interesting to understand when the packer repairs
the methods so that the application can run normally. This mechanism is
particularly interesting because it uses an ART&#39;s functionality.</p>
<h2>ART hijacking</h2>
<h3>ART in a nutshell</h3>
<p>The <a href="https://source.android.com/docs/core/runtime">Android Runtime (ART)</a> is
Dalvik&#39;s successor runtime in charge of optimizing and executing code for
Android applications and other Android system components. The <a href="https://proandroiddev.com/android-runtime-how-dalvik-and-art-work-6e57cf1c50e5">Android Runtime — How Dalvik and ART work?</a>
article by <em>Paulina Sadowska</em> is a great introduction to ART.</p>
<h3>Class loading mechanism</h3>
<p>When a method is to be executed, the runtime must first check that the class to
which the method belongs is loaded. If this is not the case, the runtime will
load and link the class. The linking process involves several phases as
described in the <a href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-12.html#jls-12.3">Java Language Specification</a>:</p>
<ol>
<li>Class verification;</li>
<li>Class preparation;</li>
<li>Resolution.</li>
</ol>
<p>The stage we&#39;re interested in here is the class verification because it&#39;s
precisely this stage that is instrumented by the packer. Among other things,
this step checks the bytecode of the class&#39;s various methods for
inconsistencies. It is implemented in the <code>ClassLinker::VerifyClass</code> method of
ART.</p>
<p>One of the interesting features of <code>VerifyClass</code> is that it calls the
<code>UpdateClassAfterVerification</code> method:</p>
<div><pre><span></span><code><span>static</span><span> </span><span>void</span><span> </span><span>UpdateClassAfterVerification</span><span>(</span><span>Handle</span><span>&lt;</span><span>mirror</span><span>::</span><span>Class</span><span>&gt;</span><span> </span><span>klass</span><span>,</span><span></span>
<span>                                         </span><span>PointerSize</span><span> </span><span>pointer_size</span><span>,</span><span></span>
<span>                                         </span><span>verifier</span><span>::</span><span>FailureKind</span><span> </span><span>failure_kind</span><span>)</span><span></span>
<span>    </span><span>REQUIRES_SHARED</span><span>(</span><span>Locks</span><span>::</span><span>mutator_lock_</span><span>)</span><span> </span><span>{</span><span></span>

<span>  </span><span>// [...]</span>

<span>  </span><span>// Now that the class has passed verification, try to set nterp entrypoints</span>
<span>  </span><span>// to methods that currently use the switch interpreter.</span>
<span>  </span><span>if</span><span> </span><span>(</span><span>interpreter</span><span>::</span><span>CanRuntimeUseNterp</span><span>())</span><span> </span><span>{</span><span></span>
<span>    </span><span>for</span><span> </span><span>(</span><span>ArtMethod</span><span>&amp;</span><span> </span><span>m</span><span> </span><span>:</span><span> </span><span>klass</span><span>-&gt;</span><span>GetMethods</span><span>(</span><span>pointer_size</span><span>))</span><span> </span><span>{</span><span></span>
<span>      </span><span>if</span><span> </span><span>(</span><span>class_linker</span><span>-&gt;</span><span>IsQuickToInterpreterBridge</span><span>(</span><span>m</span><span>.</span><span>GetEntryPointFromQuickCompiledCode</span><span>()))</span><span> </span><span>{</span><span></span>
<span>        </span><span>runtime</span><span>-&gt;</span><span>GetInstrumentation</span><span>()</span><span>-&gt;</span><span>InitializeMethodsCode</span><span>(</span><span>&amp;</span><span>m</span><span>,</span><span> </span><span>/*aot_code=*/</span><span>nullptr</span><span>);</span><span></span>
<span>      </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>
</code></pre></div>

<p><code>UpdateClassAfterVerification</code> updates the entry points of the various methods
of the verified class. So, it has to iterate over all
the methods of the class and call the <code>Instrumentation::InitializeMethodsCode</code>
method:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/linker-cg.png" alt="InitializeMethodsCode callgraph" width="70%"/>
</center>
<h3>Anatomy of the hook</h3>
<p>The <code>Instrumentation::InitializeMethodsCode</code> method provides a crossing point
on every method in the application that can be executed. It is precisely this
crossing point that is exploited by the packer to repair methods whose code has
been stolen. To do this, <code>libDexHelper.so</code> places a hook on
<code>InitializeMethodsCode</code>:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/linker-callgraph-hook.png" alt="Hook call graph" width="90%"/>
</center>
<p>The prolog of the <code>Instrumentation::InitalizedMethodsCode</code> method is patched to
redirect the execution flow to a function in <code>libDexHelper.so</code> that we call
<code>PatchMethodCode</code> :</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/patch-method-code-cfg.png" alt="PatchMethodCode CFG"/>
</center>
<p><a href="https://youtu.be/S3wsCRJVUyg?si=CM9ikhkSJ04S-PLb">A few moments later...</a> we
can deduce the hook&#39;s anatomy and the different operations performed by
<code>PatchMethodCode</code> :</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/hook-anatomy-cg.png" alt="Hook anatomy with callgraph"/>
</center>
<p>Once the <code>PatchMethodCode</code> function is called, it first loads the
obfuscated bytecode of the current method using the <code>debug_info_off</code> as an
identifier with the method index table of the <code>classes.dgc</code> file. The code is
passed to the function we call here <code>DecryptMethodCode</code> to be
de-obfuscated. Then <code>code_item</code> (<a href="https://cs.android.com/android/platform/superproject/main/+/main:art/libdexfile/dex/dex_file_structs.h;l=99?q=dex::CodeItem&amp;sq=">dex::CodeItem</a>)
of the method (<a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/art_method.h;l=87?q=art::ArtMethod">art::Method</a>)
is patched to point to the buffer containing the de-obfuscated bytecode.</p>
<p>This mechanism ensures that the damaged code in each method is repaired before
the method is executed. At this point, the last thing we need to understand is
how bytecode is obfuscated in <code>classes.dgc</code>. To do this, we need to analyze the
<code>DecryptMethodCode</code> function.</p>
<h2>Bytecode de-obfuscation</h2>
<p>The function is rather small, and an analysis of a few basic blocks gives a
good idea of how it works:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/decrypt-method-code-cfg.png" alt="DecryptMethodCode CFG" width="80%"/>
</center>
<p>The function iterates over each opcode. The obfuscated opcodes are <em>XORed</em> with
the low byte of the method&#39;s <code>info_debug_off</code> offset. The result of this
operation is then used as the index of a substitution table. The obfuscated
opcode is replaced by the one obtained from the substitution table:</p>
<div><pre><span></span><code>opcode = S[obfuscated_opcode ^ info_debug_off &amp; 0xff]
</code></pre></div>

<p>Since the substitution table is theoretically a maximum of 256 bytes, one might
assume that one of the RC4 KSA previously reversed is reused to generate it,
but... no.</p>
<p>The <code>S</code> substitution table is simply stored in the <code>libDexHelper.so</code> library
and can be directly extracted from the packed binary. We have everything we
need to fix all the damaged methods and the unpacked DEX can be decompiled
properly:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2024-02-06_dji-the-art-of-obfuscation/fixed-method.png" alt="Fixed method"/>
</center>
<p>We are now able to perform static unpacking of the application.</p>
<blockquote>
<ul>
<li>The method fixing step is implemented in the <a href="https://github.com/quarkslab/dxfx/blob/c5d65eade92ce818e07af6edacb83a6f3f8d7669/dxfx/dex.py#L181">Dex</a> class of <em>DxFx</em>.</li>
<li>The bytecode de-obfuscation is located in the <a href="https://github.com/quarkslab/dxfx/blob/c5d65eade92ce818e07af6edacb83a6f3f8d7669/dxfx/dex.py#L27">MethodCipher</a> class of <em>DxFx</em>.</li>
</ul>
</blockquote>
<h2>Conclusion</h2>
<p>Through the unfolding of the analysis methodology used to create a static
unpacker, we can see the different encryption/obfuscation algorithms used by
the packer at different stages. In addition, we were able to highlight an
interesting protection mechanism involving bytecode injection and
exploiting Android runtime hijacking.</p>

<hr/><p>

If you would like to learn more about our security audits and explore how we can help you, <a href="https://content.quarkslab.com/talk-to-our-experts-blog">get in touch with us</a>!

</p></div></div>
  </body>
</html>
