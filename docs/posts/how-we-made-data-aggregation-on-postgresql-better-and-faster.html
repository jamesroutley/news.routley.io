<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.timescale.com/blog/how-we-made-data-aggregation-better-and-faster-on-postgresql-with-timescaledb-2-7/">Original</a>
    <h1>How we made data aggregation on PostgreSQL better and faster</h1>
    
    <div id="readability-page-1" class="page"><div>
        <!--kg-card-begin: html--><p>
        <svg width="17" height="16" viewBox="0 0 17 16" fill="none" xmlns="http://www.w3.org/2000/svg">
	</svg>
It‚Äôs time for another #AlwaysBeLaunching week! ü•≥üöÄ‚ú® In our #AlwaysBeLaunching initiatives, we challenge ourselves to bring you an array of new features and content. Today, we are introducing TimescaleDB 2.7 and the performance boost it brings for aggregate queries. üî• Expect more news this week about further performance improvements, developer productivity, SQL, and more. Make sure you follow us on Twitter (@TimescaleDB), so you don‚Äôt miss any of it! 
    </p>
<!--kg-card-end: html--><p><a href="https://www.timescale.com/blog/what-the-heck-is-time-series-data-and-why-do-i-need-a-time-series-database-dcf3b1b18563/">Time-series data</a> is the lifeblood of the analytics revolution in nearly every industry today. One of the most difficult challenges for application developers and data scientists is aggregating data efficiently without always having to query billions (or trillions) of raw data rows. Over the years, developers and databases have created numerous ways to solve this problem, usually similar to one of the following options:</p><ul><li><strong>DIY processes to pre-aggregate data and store it in regular tables</strong>. Although this provides a lot of flexibility, particularly with indexing and data retention, it&#39;s cumbersome to develop and maintain, particularly deciding how to track and update aggregates with data that arrives late or has been updated in the past.</li><li><strong>Extract Transform and Load (ETL) process for longer-term analytics.</strong> Even today, development teams employ entire groups that specifically manage ETL processes for databases and applications because of the constant overhead of creating and maintaining the perfect process.</li><li><strong>MATERIALIZED VIEWS.</strong> While these VIEWS are flexible and easy to create, they are static snapshots of the aggregated data. Unfortunately, developers need to manage updates using TRIGGERs or CRON-like applications in all current implementations. And in all but a very few databases, all historical data is replaced each time, preventing developers from dropping older raw data to save space and computation resources every time the data is refreshed.</li></ul><p>Most developers head down one of these paths because we learn, often the hard way, that running reports and analytic queries over the same raw data, request after request, doesn&#39;t perform well under heavy load. In truth, most raw time-series data doesn&#39;t change after it&#39;s been saved, so these complex aggregate calculations return the same results each time.</p><p>In fact, as a long-term time-series database developer, I&#39;ve used all of these methods too, so that I could manage historical aggregate data to make reporting, dashboards, and analytics faster and more valuable, even under heavy usage.</p><p>I loved when customers were happy, even if it meant a significant amount of work behind the scenes maintaining that data.</p><p>But, I always wished for a more straightforward solution.</p><h2 id="how-timescaledb-improves-queries-on-aggregated-data-in-postgresql">How TimescaleDB Improves Queries on Aggregated Data in PostgreSQL</h2><p><a href="https://www.timescale.com/blog/continuous-aggregates-faster-queries-with-automatically-maintained-materialized-views/">In 2019, TimescaleDB introduced continuous aggregates to solve this very problem</a>, making the ongoing aggregation of massive time-series data easy and flexible. This is the feature that first caught my attention as a PostgreSQL developer looking to build more scalable time-series applications‚Äîprecisely because I had been doing it the hard way for so long.</p><p>Continuous aggregates look and act like materialized views in PostgreSQL, but with many of the additional features I was looking for. These are just some of the things they do:</p><ul><li>Automatically track changes and additions to the underlying raw data.</li><li>Provide configurable, user-defined policies to keep the materialized data up-to-date automatically.</li><li>Automatically append new data (as <a href="https://www.timescale.com/blog/achieving-the-best-of-both-worlds-ensuring-up-to-date-results-with-real-time-aggregation/">real-time aggregates</a> by default) before the scheduled process has materialized to disk. This setting is configurable.</li><li>Retain historical aggregated data even if the underlying raw data is dropped.</li><li>Can be compressed to reduce storage needs and further improve the performance of analytic queries.</li><li>Keep dashboards and reports running smoothly.</li></ul><figure><img src="https://www.timescale.com/blog/content/images/2022/06/ABL_CAGGS_Comparison-Chart_V2.0.png" alt="Table comparing the functionality of PostgreSQL materialized views with continuous aggregates in TimescaleDB" loading="lazy" width="1800" height="2066" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/ABL_CAGGS_Comparison-Chart_V2.0.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/ABL_CAGGS_Comparison-Chart_V2.0.png 1000w, https://www.timescale.com/blog/content/images/size/w1600/2022/06/ABL_CAGGS_Comparison-Chart_V2.0.png 1600w, https://www.timescale.com/blog/content/images/2022/06/ABL_CAGGS_Comparison-Chart_V2.0.png 1800w" sizes="(min-width: 720px) 720px"/><figcaption><em>Table comparing the functionality of PostgreSQL materialized views with continuous aggregates in TimescaleDB</em></figcaption></figure><p>Once I tried continuous aggregates, I realized that TimescaleDB provided the solution that I (and many other PostgreSQL users) were looking for. With this feature, managing and analyzing massive volumes of time-series data in PostgreSQL finally felt fast and easy.</p><h2 id="what-about-other-databases">What About Other Databases?</h2><p>By now, some readers might be thinking something along these lines:</p><p><em>‚ÄúContinuous aggregates may help with the management and analytics of time-series data in PostgreSQL, but that‚Äôs what NoSQL databases are for‚Äîthey already provide the features you needed from the get-go. Why didn‚Äôt you try a NoSQL database?‚Äù</em></p><p>Well, I did.</p><p>There are numerous time-series and NoSQL databases on the market that attempt to solve this specific problem. I looked at (and used) many of them. But from my experience, nothing can quite match the advantages of a relational database with a feature like continuous aggregates for time-series data. These other options provide a lot of features for a myriad of use cases, but they weren&#39;t the right solution for this particular problem, among other things.</p><h3 id="what-about-mongodb">What about MongoDB?</h3><p><a href="https://www.mongodb.com/">MongoDB</a> has been the go-to for many data-intensive applications. Included since version 4.2 is a feature called <a href="https://www.mongodb.com/docs/manual/core/materialized-views/">On-Demand Materialized Views</a>. On the surface, it works similar to a materialized view by combining the <a href="https://www.mongodb.com/docs/manual/core/aggregation-pipeline/">Aggregation Pipeline</a> feature with a $merge operation to mimic ongoing updates to an aggregate data collection. However, there is no built-in automation for this process, and MongoDB doesn&#39;t keep track of any modifications to underlying data. The developer is still required to keep track of which time frames to materialize and how far back to look.</p><h3 id="what-about-influxdb">What about InfluxDB?</h3><p>For many years <a href="https://www.influxdata.com/">InfluxDB</a> has been the destination for time-series applications. Although <a href="https://www.timescale.com/blog/timescaledb-vs-influxdb-for-time-series-data-timescale-influx-sql-nosql-36489299877/">we&#39;ve discussed in other articles how InfluxDB doesn&#39;t scale effectively, particularly with high cardinality datasets</a>, it does provide a feature called <a href="https://docs.influxdata.com/influxdb/v1.8/query_language/continuous_queries/">Continuous Queries.</a> This feature is also similar to a materialized view and goes one step further than MongoDB by automatically keeping the dataset updated. Unfortunately, it suffers from the same lack of raw data monitoring and doesn&#39;t provide nearly as much flexibility as SQL in how the datasets are created and stored.</p><h3 id="what-about-clickhouse">What about Clickhouse?</h3><p><a href="https://clickhouse.com/">Clickhouse</a>, and several recent forks like <a href="https://www.firebolt.io/">Firebolt</a>, have redefined the way some analytic workloads perform. Even with some of the<a href="https://www.timescale.com/blog/what-is-clickhouse-how-does-it-compare-to-postgresql-and-timescaledb-and-how-does-it-perform-for-time-series-data/"> impressive query performance</a>, it provides a mechanism similar to a materialized view as well, backed by an <a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/aggregatingmergetree/">AggregationMergeTree</a> engine. In a sense, this provides almost real-time aggregated data because all inserts are saved to both the regular table and the materialized view. The biggest downside of this approach is dealing with updates or modifying the timing of the process.</p><h2 id="recent-improvements-in-continuous-aggregates-meet-timescaledb-27">Recent Improvements in Continuous Aggregates: Meet TimescaleDB 2.7</h2><p>Continuous aggregates were first introduced in <a href="https://www.timescale.com/blog/continuous-aggregates-faster-queries-with-automatically-maintained-materialized-views/">TimescaleDB 1.3</a> solving the problems that many PostgreSQL users, including me, faced with time-series data and materialized views: automatic updates, real-time results, easy data management, and the option of using the view for downsampling.</p><p>But continuous aggregates have come a long way. One of the previous improvements was the introduction of <a href="https://www.timescale.com/blog/increase-your-storage-savings-with-timescaledb-2-6-introducing-compression-for-continuous-aggregates/">compression for continuous aggregates in TimescaleDB 2.6</a>. Now, we took it a step further with the arrival of TimescaleDB 2.7, which introduces dramatic performance improvements in continuous aggregates. <strong>They are now blazing fast‚Äîup to 44,000x faster in some queries than in previous versions. </strong></p><p>Let me give you one concrete example: <strong>in initial testing using live, real-time stock trade transaction data, typical candlestick aggregates were nearly 2,800x faster to query </strong>than in previous versions of continuous aggregates (which were already fast!)</p><figure><img src="https://www.timescale.com/blog/content/images/2022/06/sonic-run.gif" alt="" loading="lazy" width="498" height="206"/></figure><p>Later in this post, we will dig into the performance and storage improvements introduced by TimescaleDB 2.7 by presenting a complete benchmark of continuous aggregates using multiple datasets and queries. üî•</p><p>But the improvements don‚Äôt end here.</p><p>First, the new continuous aggregates also require 60¬†% less storage (on average) than before for many common aggregates, which directly translates into storage savings. </p><p>And now, the fun part.</p><h2 id="show-me-the-numbers-benchmarking-aggregate-queries">Show Me the Numbers: Benchmarking Aggregate Queries</h2><p>To test the new version of continuous aggregates, we chose two datasets that represent common time-series datasets: IoT and financial analysis.</p><ul><li><strong>IoT dataset (~1.7 billion rows): </strong>The IoT data we leveraged is the New York City Taxicab dataset that&#39;s been maintained by Todd Schneider for a number of years, and scripts are available in his <a href="https://github.com/toddwschneider/nyc-taxi-data">GitHub repository</a> to load data into PostgreSQL. Unfortunately, a week after his latest update, the transit authority that maintains the actual datasets changed their long-standing export data format from CSV to Parquet‚Äîwhich means the current scripts will not work. Therefore, the dataset we tested with is from data prior to that change and covers ride information from 2014 to 2021.</li><li><strong>Stock transactions dataset (~23.7 million rows): </strong>The financial dataset we used is a real-time stock trade dataset provided by <a href="https://twelvedata.com/">Twelve Data</a> and ingests ongoing transactions for the top 100 stocks by volume from February 2022 until now. Real-time transaction data is typically the source of many stock trading analysis applications requiring aggregate rollups over intervals for visualizations like <a href="https://docs.timescale.com/timescaledb/latest/tutorials/financial-candlestick-tick-data/create-candlestick-aggregates/">candlestick charts </a>and machine learning analysis. While our example dataset is smaller than a full-fledged financial application would maintain, it provides a working example of ongoing data ingestion using continuous aggregates, TimescaleDB <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/compression/about-compression/">native compression</a>, and <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/data-retention/about-data-retention/">automated raw data retention</a> (while keeping aggregate data for long-term analysis).</li></ul><p>You can use a sample of this data, generously provided by Twelve Data, to try all of the improvements in TimescaleDB 2.7 by following<a href="https://docs.timescale.com/timescaledb/latest/tutorials/ingest-real-time-websocket-data/"> this tutorial</a>, which provides stock trade data for the last 30 days. Once you have the database setup, you can take it a step further by registering for an API key and <a href="https://docs.timescale.com/timescaledb/latest/tutorials/ingest-real-time-websocket-data/">following our tutorial to ingest ongoing transactions from the Twelve Data API</a>.</p><h3 id="creating-continuous-aggregates-using-standard-postgresql-aggregate-functions">Creating Continuous Aggregates Using Standard PostgreSQL Aggregate Functions<br/></h3><p>The first thing we benchmarked was to create an aggregate query that used standard PostgreSQL aggregate functions like <code>MIN()</code>, <code>MAX()</code>, and <code>AVG()</code>. In each dataset we tested, we created the same continuous aggregate in TimescaleDB 2.6.1 and 2.7, ensuring that both aggregates had computed and stored the same number of rows. </p><p><strong>IoT dataset</strong></p><p>This continuous aggregate resulted in 1,760,000 rows of aggregated data spanning seven years of data.</p><pre><code>CREATE MATERIALIZED VIEW hourly_trip_stats
WITH (timescaledb.continuous, timescaledb.finalized=false) 
AS
SELECT 
	time_bucket(&#39;1 hour&#39;,pickup_datetime) bucket,
	avg(fare_amount) avg_fare,
	min(fare_amount) min_fare,
	max(fare_amount) max_fare,
	avg(trip_distance) avg_distance,
	min(trip_distance) min_distance,
	max(trip_distance) max_distance,
	avg(congestion_surcharge) avg_surcharge,
	min(congestion_surcharge) min_surcharge,
	max(congestion_surcharge) max_surcharge,
	cab_type_id,
	passenger_count
FROM 
	trips
GROUP BY 
	bucket, cab_type_id, passenger_count</code></pre><p><strong>Stock transactions dataset</strong></p><p>This continuous aggregate resulted in 950,000 rows of data at the time of testing, although these are updated as new data comes in.</p><pre><code>CREATE MATERIALIZED VIEW five_minute_candle_delta
WITH (timescaledb.continuous) AS
    SELECT
        time_bucket(&#39;5 minute&#39;, time) AS bucket,
        symbol,
        FIRST(price, time) AS &#34;open&#34;,
        MAX(price) AS high,
        MIN(price) AS low,
        LAST(price, time) AS &#34;close&#34;,
        MAX(day_volume) AS day_volume,
        (LAST(price, time)-FIRST(price, time))/FIRST(price, time) AS change_pct
    FROM stocks_real_time srt
    GROUP BY bucket, symbol;
</code></pre><p>To test the performance of these two continuous aggregates, we selected the following queries, all common queries among our users for both the IoT and financial use cases:</p><ol><li>SELECT COUNT (*)</li><li>SELECT COUNT (*) with WHERE</li><li>ORDER BY</li><li>time_bucket reaggregation</li><li>FILTER</li><li>HAVING </li></ol><p>Let‚Äôs take a look at the results.</p><h3 id="query-1-%60select-count-from%E2%80%A6%60">Query #1: `SELECT COUNT(*) FROM‚Ä¶`</h3><p>Doing a <code>COUNT(*)</code> from PostgreSQL is a known performance bottleneck. It&#39;s one of the reasons we created the <a href="https://docs.timescale.com/api/latest/hyperfunctions/approximate_row_count/"><code>approximate_row_count()</code></a> function in TimescaleDB which uses table statistics to provide a close approximation of the overall row count. However, it&#39;s instinctual for most users (and ourselves, if we&#39;re honest) to try and get a quick row count by doing a <code>COUNT(*)</code> query:</p><pre><code>-- IoT dataset
SELECT count(*) FROM hourly_trip_stats;

-- Stock transactions dataset
SELECT count(*) FROM five_min_candle_delta;</code></pre><p>And most users recognized that in previous versions of TimescaleDB, the materialized data seemed slower than normal to do a COUNT over. <br/></p><p>Thinking about our two example datasets, both continuous aggregates reduce the overall row count from raw data by 20x or more. So, while counting rows in PostgreSQL is slow, it always felt a little slower than it had to be. The reason was that not only did PostgreSQL have to scan and count all of the rows of data, it had to group the data a second time because of some additional data that TimescaleDB stored as part of the original design of continuous aggregates. With the new design of continuous aggregates in TimescaleDB 2.7, that second grouping is no longer required, and PostgreSQL can just query the data normally, translating into faster queries.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/06/Query--1-2.png" alt="Table comparing the performance of a query with SELECT COUNT (*) in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7" loading="lazy" width="1351" height="441" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/Query--1-2.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/Query--1-2.png 1000w, https://www.timescale.com/blog/content/images/2022/06/Query--1-2.png 1351w" sizes="(min-width: 720px) 720px"/><figcaption><em>Performance of a query with SELECT COUNT (*) in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7</em></figcaption></figure><h3 id="query-2-select-count-based-on-the-value-of-a-column">Query #2: SELECT COUNT(*) Based on The Value of a Column</h3><p>Another common query that many analytic applications perform is to count the number of records where the aggregate value is within a certain range:</p><pre><code>-- IoT  dataset
SELECT count(*) FROM hourly_trip_stats
WHERE avg_fare &gt; 13.1
AND bucket &gt; &#39;2018-01-01&#39; AND bucket &lt; &#39;2019-01-01&#39;;

-- Stock transactions dataset
SELECT count(*) FROM five_min_candle_delta
WHERE change_pct &gt; 0.02;
</code></pre><p>In previous versions of continuous aggregates, TimescaleDB had to finalize the value before it could be filtered against the predicate value, which caused queries to perform more slowly. With the new version of continuous aggregates, PostgreSQL can now search for the value directly, <em>and</em> we can add an index to meaningful columns to speed up the query even more!</p><p>In the case of the financial dataset, we see a very significant improvement: 1,336x faster. The large change in performance can be attributed to the formula query that has to be calculated over all of the rows of data in the continuous aggregate. With the IoT dataset, we&#39;re comparing against a simple average function, but for the stock data, multiple values have to be finalized (FIRST/LAST) before the formula can be calculated and used for the filter.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/06/Query--2-2.png" alt="Table comparing the performance of a query with SELECT COUNT (*) plus WHERE in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7." loading="lazy" width="1351" height="441" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/Query--2-2.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/Query--2-2.png 1000w, https://www.timescale.com/blog/content/images/2022/06/Query--2-2.png 1351w" sizes="(min-width: 720px) 720px"/><figcaption><em>Performance of a query with SELECT COUNT (*) plus WHERE in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7</em></figcaption></figure><h3 id="query-3-select-top-10-rows-by-value">Query #3: Select Top 10 Rows by Value<br/></h3><p>Taking the first example a step further, it&#39;s very common to query data within a range of time and get the top rows:</p><pre><code>-- IoT dataset
SELECT * FROM hourly_trip_stats
ORDER BY avg_fare desc
LIMIT 10;

-- Stock transactions dataset
SELECT * FROM five_min_candle_delta
ORDER BY change_pct DESC 
LIMIT 10;</code></pre><p>In this case, we tested queries with the continuous aggregate set to provide <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/continuous-aggregates/real-time-aggregates/">real-time results</a> (the default for continuous aggregates) and materialized-only results. When set to real-time, TimescaleDB always queries data that&#39;s been materialized first and then appends (with a <code>UNION</code>) any newer data that exists in the raw data but that has not yet been materialized by the ongoing refresh policy. And, because it&#39;s now possible to index columns within the continuous aggregate, we added an index on the <code>ORDER BY</code> column.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/06/Query--3-1.png" alt="Table comparing the performance of a query with ORDER BY in a continuous aggregate TimescaleDB 2.6.1 and TimescaleDB 2.7." loading="lazy" width="1351" height="606" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/Query--3-1.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/Query--3-1.png 1000w, https://www.timescale.com/blog/content/images/2022/06/Query--3-1.png 1351w" sizes="(min-width: 720px) 720px"/><figcaption><em>Performance of a query with ORDER BY in a continuous aggregate TimescaleDB 2.6.1 and TimescaleDB 2.7</em></figcaption></figure><p><strong>Yes, you read that correctly. <strong>Nearly 45,000x better performance on ¬†<code>ORDER BY</code></strong> </strong>when the query only searches through materialized data.</p><p>The dramatic difference between real-time and materialized-only queries is because of the <code>UNION</code> of both materialized and raw aggregate data. The PostgreSQL planner needs to union the total result before it can limit the query to 10 rows (in our example), and so all of the data from both tables need to be read and ordered first. When you only query materialized data, PostgreSQL and TimescaleDB knows that it can query just the index of the materialized data.</p><p>Again, storing the finalized form of your data and indexing column values dramatically impacts the querying performance of historical aggregate data! And all of this is updated continuously over time in a non-destructive way‚Äîsomething that&#39;s impossible to do with any other relational database, including vanilla PostgreSQL.</p><h3 id="query-4-timescale-hyperfunctions-to-re-aggregate-into-higher-time-buckets">Query #4: Timescale Hyperfunctions to Re-aggregate Into Higher Time Buckets</h3><p>Another example we wanted to test was the impact finalizing data values has on our suite of <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/hyperfunctions/">analytical hyperfunctions</a>. Many of the hyperfunctions we provide as part of the <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/hyperfunctions/install-toolkit/">TimescaleDB Toolkit</a> utilize custom aggregate values that allow many different values to be accessed later depending on the needs of an application or report. Furthermore, these aggregate values can be <a href="https://www.timescale.com/blog/how-postgresql-aggregation-works-and-how-it-inspired-our-hyperfunctions-design-2/">re-aggregated into different size time buckets</a>. This means that if the aggregate functions fit your use case, one continuous aggregate can produce results for many different time_bucket sizes! This is a feature many users have asked for over time, and hyperfunctions make this possible.</p><p>For this example, we only examined the New York City Taxicab dataset to benchmark the impact of finalized CAGGs. Currently, there is not an aggregate hyperfunction that aligns with the OHLC values needed for the stock data set, however, <a href="https://github.com/timescale/timescaledb-toolkit/issues/445">there is a feature request</a> for it! (üòâ)</p><p>Although there are not currently any one-to-one hyperfunctions that provide exact replacements for our min/max/avg example, we can still observe the query improvement using a <code>tdigest</code> value for each of the columns in our original query.</p><p><strong><strong>Original min/max/avg continuous aggregate for multiple columns</strong>:</strong></p><pre><code>CREATE MATERIALIZED VIEW hourly_trip_stats
WITH (timescaledb.continuous, timescaledb.finalized=false) 
AS
SELECT 
	time_bucket(&#39;1 hour&#39;,pickup_datetime) bucket,
	avg(fare_amount) avg_fare,
	min(fare_amount) min_fare,
	max(fare_amount) max_fare,
	avg(trip_distance) avg_distance,
	min(trip_distance) min_distance,
	max(trip_distance) max_distance,
	avg(congestion_surcharge) avg_surcharge,
	min(congestion_surcharge) min_surcharge,
	max(congestion_surcharge) max_surcharge,
	cab_type_id,
	passenger_count
FROM 
	trips
GROUP BY 
	bucket, cab_type_id, passenger_count
</code></pre><p><strong>Hyperfunction-based continuous aggregate for multiple columns:</strong></p><pre><code>CREATE MATERIALIZED VIEW hourly_trip_stats_toolkit
WITH (timescaledb.continuous, timescaledb.finalized=false) 
AS
SELECT 
	time_bucket(&#39;1 hour&#39;,pickup_datetime) bucket,
	tdigest(1,fare_amount) fare_digest,
	tdigest(1,trip_distance) distance_digest,
	tdigest(1,congestion_surcharge) surcharge_digest,
	cab_type_id,
	passenger_count
FROM 
	trips
GROUP BY 
	bucket, cab_type_id, passenger_count</code></pre><p>With the continuous aggregate created, we then queried this data in two different ways:</p><p><strong>1. Using the same `time_bucket()` size defined in the continuous aggregate, which in this example was one-hour data.</strong></p><pre><code>SELECT 
	bucket AS b,
	cab_type_id, 
	passenger_count,
	min_val(ROLLUP(fare_digest)),
	max_val(ROLLUP(fare_digest)),
	mean(ROLLUP(fare_digest))
FROM hourly_trip_stats_toolkit
WHERE bucket &gt; &#39;2021-05-01&#39; AND bucket &lt; &#39;2021-06-01&#39;
GROUP BY b, cab_type_id, passenger_count 
ORDER BY b DESC, cab_type_id, passenger_count;</code></pre><figure><img src="https://www.timescale.com/blog/content/images/2022/06/Query--4.png" alt="Table comparing the erformance of a query with time_bucket() in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7 (the query uses the same bucket size as the definition of the continuous aggregate)" loading="lazy" width="1350" height="354" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/Query--4.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/Query--4.png 1000w, https://www.timescale.com/blog/content/images/2022/06/Query--4.png 1350w" sizes="(min-width: 720px) 720px"/><figcaption><em>Performance of a query with time_bucket() in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7 (the query uses the same bucket size as the definition of the continuous aggregate)</em></figcaption></figure><p><strong>2. We re-aggregated the data from one-hour buckets into one-day buckets. </strong>This allows us to efficiently query different bucket lengths based on the original bucket size of the continuous aggregate.</p><pre><code>SELECT 
	time_bucket(&#39;1 day&#39;, bucket) AS b,
	cab_type_id, 
	passenger_count,
	min_val(ROLLUP(fare_digest)),
	max_val(ROLLUP(fare_digest)),
	mean(ROLLUP(fare_digest))
FROM hourly_trip_stats_toolkit
WHERE bucket &gt; &#39;2021-05-01&#39; AND bucket &lt; &#39;2021-06-01&#39;
GROUP BY b, cab_type_id, passenger_count 
ORDER BY b DESC, cab_type_id, passenger_count;</code></pre><figure><img src="https://www.timescale.com/blog/content/images/2022/06/Query--4-2.png" alt="Table comparing the performance of a query with time_bucket() in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7. The query re-aggregates the data from one-hour buckets into one-day buckets." loading="lazy" width="1350" height="354" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/Query--4-2.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/Query--4-2.png 1000w, https://www.timescale.com/blog/content/images/2022/06/Query--4-2.png 1350w" sizes="(min-width: 720px) 720px"/><figcaption><em>Performance of a query with time_bucket() in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7. The query re-aggregates the data from one-hour buckets into one-day buckets</em></figcaption></figure><p>In this case, the speed is almost identical because the same amount of data has to be queried. But if these aggregates satisfy your data requirements, only one continuous aggregate would be necessary in many cases, rather than a different continuous aggregate for each bucket size (one minute, five minutes, one hour, etc.)</p><h3 id="query-5-pivot-queries-with-filter">Query #5: Pivot Queries With FILTER</h3><p><a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/continuous-aggregates/about-continuous-aggregates/#function-support">In previous versions of continuous aggregates, many common SQL features were not permitted</a> because of how the partial data was stored and finalized later. Using a PostgreSQL <code>FILTER</code> clause was one such restriction.</p><p>For example, we took the IoT dataset and created a simple <code>COUNT(*)</code> to calculate each company&#39;s number of taxi rides ( <code>cab_type_id</code>) for each hour. Before TimescaleDB 2.7, you would have to store this data in a narrow column format, storing a row in the continuous aggregate for each cab type.</p><pre><code>CREATE MATERIALIZED VIEW hourly_ride_counts_by_type 
WITH (timescaledb.continuous, timescaledb.finalized=false) 
AS
SELECT 
	time_bucket(&#39;1 hour&#39;,pickup_datetime) bucket,
	cab_type_id,
  	COUNT(*)
FROM trips
  	WHERE cab_type_id IN (1,2)
GROUP BY 
	bucket, cab_type_id;</code></pre><p>To then query this data in a pivoted fashion, we could <code>FILTER</code> the continuous aggregate data after the fact.</p><pre><code>SELECT bucket,
	sum(count) FILTER (WHERE cab_type_id IN (1)) yellow_cab_count,
  	sum(count) FILTER (WHERE cab_type_id IN (2)) green_cab_count
FROM hourly_ride_counts_by_type
WHERE bucket &gt; &#39;2021-05-01&#39; AND bucket &lt; &#39;2021-06-01&#39;
GROUP BY bucket
ORDER BY bucket;</code></pre><p>In TimescaleDB 2.7, you can now store the aggregated data using a <code>FILTER</code> clause to achieve the same result in one step!</p><pre><code>CREATE MATERIALIZED VIEW hourly_ride_counts_by_type_new 
WITH (timescaledb.continuous) 
AS
SELECT 
	time_bucket(&#39;1 hour&#39;,pickup_datetime) bucket,
  	COUNT(*) FILTER (WHERE cab_type_id IN (1)) yellow_cab_count,
  	COUNT(*) FILTER (WHERE cab_type_id IN (2)) green_cab_count
FROM trips
GROUP BY 
	bucket;</code></pre><p>Querying this data is much simpler, too, because the data is already pivoted and finalized.</p><pre><code>SELECT * FROM hourly_ride_counts_by_type_new 
WHERE bucket &gt; &#39;2021-05-01&#39; AND bucket &lt; &#39;2021-06-01&#39;
ORDER BY bucket;
</code></pre><p>This saves storage (50¬†% fewer rows in this case) and CPU to finalize the <code>COUNT(*)</code> and then filter the results each time based on <code>cab_type_id</code>. We can see this in the query performance numbers.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/06/Query--5.png" alt="Table comparing the performance of a query with FILTER in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7." loading="lazy" width="1350" height="354" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/Query--5.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/Query--5.png 1000w, https://www.timescale.com/blog/content/images/2022/06/Query--5.png 1350w" sizes="(min-width: 720px) 720px"/><figcaption><em>Performance of a query with FILTER in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7.</em></figcaption></figure><p>Being able to use <code>FILTER</code> and other SQL features improve both developer experience and flexibility long term!</p><h3 id="query-6-having-stores-significantly-less-materialized-data">Query #6: HAVING Stores Significantly Less Materialized Data</h3><p>As a final example of how the improvements to continuous aggregates will impact your day-to-day development and analytics processes, let&#39;s look at a simple query that uses a <code>HAVING</code> clause to reduce the number of rows that the aggregate stores.</p><p>In previous versions of TimescaleDB, the having clause couldn&#39;t be applied at materialization time. Instead, the <code>HAVING</code> clause was applied after the fact to all of the aggregated data as it was finalized. In many cases, this dramatically affected both the speed of queries to the continuous aggregate and the amount of data stored overall.</p><p>Using our stock data as an example, let&#39;s create a continuous aggregate that only stores a row of data if the <code>change_pct</code> value is greater than 20 %. This would indicate that a stock price changed dramatically over one hour, something we don&#39;t expect to see in most hourly stock trades.</p><pre><code>CREATE MATERIALIZED VIEW one_hour_outliers
WITH (timescaledb.continuous) AS
    SELECT
        time_bucket(&#39;1 hour&#39;, time) AS bucket,
        symbol,
        FIRST(price, time) AS &#34;open&#34;,
        MAX(price) AS high,
        MIN(price) AS low,
        LAST(price, time) AS &#34;close&#34;,
        MAX(day_volume) AS day_volume,
        (LAST(price, time)-FIRST(price, time))/LAST(price, time) AS change_pct
    FROM stocks_real_time srt
    GROUP BY bucket, symbol
   HAVING (LAST(price, time)-FIRST(price, time))/LAST(price, time) &gt; .02;</code></pre><p>Once the dataset is created, we can query each aggregate to see how many rows matched our criteria.</p><pre><code>SELECT count(*) FROM one_hour_outliers;</code></pre><figure><img src="https://www.timescale.com/blog/content/images/2022/06/Query--6.png" alt="Table comparing the performance of a query with HAVING in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7." loading="lazy" width="1351" height="354" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/Query--6.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/Query--6.png 1000w, https://www.timescale.com/blog/content/images/2022/06/Query--6.png 1351w" sizes="(min-width: 720px) 720px"/><figcaption><em>Performance of a query with HAVING in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7</em></figcaption></figure><p>The biggest difference here (and the one that will more negatively impact the performance of your application over time) is the storage size of this aggregated data. Because TimescaleDB 2.7 only stores rows that meet the criteria, the data footprint is significantly smaller!</p><figure><img src="https://www.timescale.com/blog/content/images/2022/06/Query--6-2.png" alt="Table comparing the storage footprint of a continuous aggregate bucketing stock transactions by the hour in TimescaleDB 2.6.1 and TimescaleDB 2.7." loading="lazy" width="1351" height="354" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/Query--6-2.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/Query--6-2.png 1000w, https://www.timescale.com/blog/content/images/2022/06/Query--6-2.png 1351w" sizes="(min-width: 720px) 720px"/><figcaption><em>Storage footprint of a continuous aggregate bucketing stock transactions by the hour in TimescaleDB 2.6.1 and TimescaleDB 2.7</em></figcaption></figure><h2 id="storage-savings-in-timescaledb-27"></h2><p>One of the final pieces of this update that excites us is how much storage will be saved over time. On many occasions, users with large datasets that contained complex equations in their continuous aggregates would join our <a href="https://slack.timescale.com/">Slack community</a> to ask why more storage is required for the rolled-up aggregate than the raw data.</p><p>In every case we&#39;ve tested, the new, finalized form of continuous aggregates is smaller than the same example in previous versions of TimescaleDB, with or without a <code>HAVING</code> clause that might filter additional data out.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/06/Storage-Savings.png" alt="Table comparing the storage footprint of a query with HAVING in a continuous aggregate in TimescaleDB 2.6.1 and TimescaleDB 2.7." loading="lazy" width="1351" height="654" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/06/Storage-Savings.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/06/Storage-Savings.png 1000w, https://www.timescale.com/blog/content/images/2022/06/Storage-Savings.png 1351w" sizes="(min-width: 720px) 720px"/><figcaption><em>Storage savings for different continuous aggregates in TimescaleDB 2.6.1 and TimescaleDB 2.7</em></figcaption></figure><h2 id="the-new-continuous-aggregates-are-a-game-changer">The New Continuous Aggregates Are a Game-Changer</h2><p>For those dealing with massive amounts of time-series data, continuous aggregates are the best way to solve a problem that has long haunted PostgreSQL users. The following list details how continuous aggregates expand materialized views:</p><ul><li>They always stay up-to-date, automatically tracking changes in the source table for targeted, efficient updates of materialized data.</li><li>You can use configurable policies to conveniently manage refresh/update interval.</li><li>You can keep your materialized data even after the raw data is dropped, allowing you to downsample your large datasets.</li><li>And you can compress older data to save space and improve analytic queries.</li></ul><p>And in TimescaleDB 2.7, continuous aggregates got much better. First, they are blazing fast: as we demonstrated with our benchmark, the performance of continuous aggregates got consistently better across queries and datasets, up to thousands of times better for common queries. They also got lighter, requiring an average of 60¬†% less storage.</p><p>But besides the performance improvements and storage savings, there are significantly fewer limitations on the types of aggregate queries you can use with continuous aggregates, such as:</p><ul><li>Aggregates with DISTINCT</li><li>Aggregates with FILTER</li><li>Aggregates with FILTER in HAVING clause</li><li>Aggregates without combine function</li><li>Ordered-set aggregates</li><li>Hypothetical-set aggregates</li></ul><p>This new version of continuous aggregates is available by default in <a href="https://docs.timescale.com/timescaledb/latest/overview/release-notes/">TimescaleDB 2.7</a>: now, when you create a new continuous aggregate, you will automatically benefit from all the latest changes. For your existing continuous aggregates, we recommend that you recreate them in the latest version to take advantage of all these improvements. <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/update-timescaledb/">Read our release notes for more information on TimescaleDB</a> <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/update-timescaledb/">2.7</a>, and for instructions on how to upgrade, <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/update-timescaledb/">check out our docs.</a></p><!--kg-card-begin: html--><p>
        <svg width="17" height="16" viewBox="0 0 17 16" fill="none" xmlns="http://www.w3.org/2000/svg">
	</svg>
‚òÅÔ∏èüêØ Timescale Cloud avoids the manual work involved in updating your TimescaleDB version. Updates take place automatically during a maintenance window picked by you. 
        <a href="https://docs.timescale.com/cloud/latest/service-operations/maintenance/" target="_blank">Learn more</a> 
about automatic version updates in Timescale Cloud, and to test if yourself, 
                <a href="https://www.timescale.com/timescale-signup/" target="_blank">start a free trial!</a>  
    </p>
<!--kg-card-end: html-->
        <div>
          <p>The open-source relational database for time-series and analytics.</p>
          <p>
            Try Timescale for free
          </p>

        </div>
      </div></div>
  </body>
</html>
