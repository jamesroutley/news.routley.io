<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thenewstack.io/why-were-sticking-with-ruby-on-rails-at-gitlab/">Original</a>
    <h1>Why We’re Sticking with Ruby on Rails at Gitlab</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<div>

<p>When David Heinemeier Hansson created Ruby on Rails (<a href="https://corecursive.com/045-david-heinemeier-hansson-software-contrarian/" rel="external " onclick="this.target=&#39;_blank&#39;;">interview</a>), he was guided by his experience with both PHP and Java. On the one hand, he didn’t like the way the verbosity and rigidness of Java made Java web frameworks complex and difficult to use, but he appreciated their structural integrity. On the other hand, he loved the initial approachability of PHP but was less fond of the quagmires that such projects tended to turn into.</p>
<table>
<tbody>
<tr>
<td><strong>Java</strong></td>
<td><strong>Hard to use, well structured</strong></td>
</tr>
<tr>
<td><strong>PHP</strong></td>
<td><strong>Approachable, messy</strong></td>
</tr>
</tbody>
</table>
<p>It seems like these are exclusive choices: You either get approachable and messy, or well-structured and hard to use, pick your poison. We used to make a similar, and similarly hard, distinction between server-class operating systems such as Unix, which were stable but hard to use, and client operating systems such as Windows and MacOS that were approachable but crashed a lot.</p>
<p>Everyone accepted this dichotomy as God-given until NeXT put a beautiful, approachable and buttery-smooth GUI on top of a solid Unix base. Nowadays, “server-class” Unix runs not just beautiful GUI desktops, but also most phones and smartwatches.</p>
<p>So it turned out that approachability and crashes were not actually linked except by historical accident, and the same turns out to be true for approachability and messiness in web frameworks: They are independent axes.</p>
<table>
<tbody>
<tr>
<td></td>
<td><strong>Hard to use</strong></td>
<td><strong>Approachable</strong></td>
</tr>
<tr>
<td><strong>Messy</strong></td>
<td></td>
<td>PHP</td>
</tr>
<tr>
<td><strong>Well structured</strong></td>
<td>Java</td>
<td></td>
</tr>
</tbody>
</table>
<p>And these independent axes opened up a very desirable open spot in the lower right-hand corner: an approachable, well-structured web framework.</p>
<p>With its solid, metaprogrammable Smalltalk heritage and good Unix integration, Ruby proved to be the perfect vehicle for Ruby creator DHH to fill that desirable bottom-right corner of the table with Rails: an extremely approachable, productive and well-structured web framework.</p>
<table>
<tbody>
<tr>
<td></td>
<td><strong>Hard to use</strong></td>
<td><strong>Approachable</strong></td>
</tr>
<tr>
<td><strong>Messy</strong></td>
<td></td>
<td>PHP</td>
</tr>
<tr>
<td><strong>Well structured</strong></td>
<td>Java</td>
<td><strong>Ruby on Rails</strong></td>
</tr>
</tbody>
</table>
<p>When GitLab co-founder Dmitriy Zaporozhets decided he wanted to work on software for running his (and your) version control server, he also came from a PHP background. But instead of sticking with the familiar, he chose Rails.</p>
<p>Dmitry’s choice may have been prescient or fortuitous, but it has served GitLab extremely well, in part because David succeeded in achieving his goals for Rails: approachability with good architecture.</p>



<h2>Why Modular?</h2>
<a href=" https://www.linkedin.com/in/sijbrandij/" target="_blank">
<p><img src="https://cdn.thenewstack.io/media/2022/04/a20c07fd-headshot-sidsijbrandij.jpg"/>
</p>
<div>
<p> Sid Sijbrandij</p>
<p>Sid is the co-founder, CEO and board chair of GitLab, Inc., the DevOps platform. Sid spent four years building recreational submarines for U-Boat Worx and, while at the Dutch Ministry of Justice and Security (Ministerie van Justitie en Veiligheid), he worked on the Legis project, which developed several innovative web applications to aid lawmaking. He first saw Ruby code in 2007 and loved it so much that he taught himself how to program. In 2012, as a Ruby programmer, he encountered GitLab and discovered his passion for open source. Soon after, Sid commercialized GitLab, which as has grown to more than 30 million registered users from startups to global enterprises. </p>
</div>
</a>
<p>In the preceding section, it was assumed that modularity is a desirable property, but as we also saw, it is dangerous to just assume things. So why, and in what contexts, is modularity actually desirable?</p>
<p>In his 1971 paper “<a href="https://prl.ccs.neu.edu/img/p-tr-1971.pdf" rel="external " onclick="this.target=&#39;_blank&#39;;">On the Criteria to Be Used in Decomposing Systems into Modules</a><em>”</em> David L. Parnas gave the following (desired) benefits of a modular system:</p>
<ul>
<li aria-level="1">Development time should “be shortened because separate groups would work on each module with little need for communication.”</li>
<li aria-level="1">It should be possible to make “drastic changes or improvements in one module without changing others.”</li>
<li aria-level="1">It should be possible to study the system one module at a time.</li>
</ul>
<p>The importance of reducing the need for communication was later highlighted by Fred Brooks in “<a href="https://en.wikipedia.org/wiki/The_Mythical_Man-Month" rel="external " onclick="this.target=&#39;_blank&#39;;">The Mythical Man-Month</a>,” with the additional communication overhead one of the primary reasons for the old saying that “adding people to a late software project makes it later.”</p>
<h2>We Don’t Need Microservices</h2>
<p>Modularity has generally been as elusive as it is highly sought after, with the default architecture of most systems being the <a href="http://laputan.org/mud/" rel="external " onclick="this.target=&#39;_blank&#39;;">Big Ball of Mud</a>. It is therefore understandable that designers took inspiration from arguably the largest software system in existence: the World Wide Web, which is modular by necessity; it cannot function any other way.</p>
<p>Organizing your local software systems using separate processes, microservices that are combined using a <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf" rel="external " onclick="this.target=&#39;_blank&#39;;">REST</a> architectural style, does help enforce module boundaries via the operating system but at significant costs. It is a very heavy-handed approach for achieving modularity.</p>
<p>The difficulties and costs of running what is now a gratuitously distributed system are significant, with some of the performance and reliability issues documented in the well-known <a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" rel="external " onclick="this.target=&#39;_blank&#39;;">fallacies of distributed computing</a>. In short, the performance and reliability costs are significant, as function calls that take nanoseconds and never fail are replaced with network ops that are three to six orders of magnitude slower and do fail. Failures become much harder to diagnose if they must be traced across multiple services with little tooling support.</p>
<p>You need a fairly sophisticated DevOps organization to successfully run microservices. This doesn’t really make a difference if you run at a scale that requires that sophistication anyhow, but it is very likely that <a href="https://blog.bradfieldcs.com/you-are-not-google-84912cf44afb?gi=535609cfb4c4" rel="external " onclick="this.target=&#39;_blank&#39;;">you are not Google</a>.</p>
<p>But even if you think you can manage all that, it is important to note that all this accidental complexity is on top of the original essential complexity of your problem; microservices do nothing to reduce complexity. And even the hoped-for modularity improvements are not in the least guaranteed, typically what happens instead is that you get a <a href="http://www.codingthearchitecture.com/2014/07/06/distributed_big_balls_of_mud.html" rel="external " onclick="this.target=&#39;_blank&#39;;">distributed ball of mud</a>.</p>
<h2>Monorails</h2>
<p>By making good architecture approachable and productive, Rails has allowed GitLab to develop a <a href="https://medium.com/@dan_manges/the-modular-monolith-rails-architecture-fb1023826fc4" rel="external " onclick="this.target=&#39;_blank&#39;;">modular monolith</a>. A modular monolith is the exact opposite of a distributed ball of mud: a well-structured, well-architected, highly modular program that runs as a single process and is as <a href="https://about.gitlab.com/handbook/values/#boring-solutions" rel="external " onclick="this.target=&#39;_blank&#39;;">boring</a> as possible.</p>
<p>Although structuring GitLab as a monolith has been extremely beneficial for us, we are not dogmatic about that structure. Architecture follows needs, not the other way around. And while Rails is excellent technology for our purposes, it does have a few drawbacks, one of them being performance. Luckily, only a tiny part of most codebases is actually performance-critical. We use our own <a href="https://docs.gitlab.com/ee/administration/gitaly/" rel="external " onclick="this.target=&#39;_blank&#39;;">gitaly</a> daemon written in Go to handle actual git operations, and <a href="https://thenewstack.io/two-sizes-fit-most-postgresql-and-clickhouse/">PostgreSQL</a> for non-repository persistence.</p>
<h2>Open Core</h2>
<p>Last but not least, our modular monolith turns <a href="https://about.gitlab.com/blog/2016/07/20/gitlab-is-open-core-github-is-closed-source/" rel="external " onclick="this.target=&#39;_blank&#39;;">our </a><a href="https://en.wikipedia.org/wiki/Open-core_model" rel="external " onclick="this.target=&#39;_blank&#39;;">open core</a> business model from being just a nice theory into a practical <a href="https://www.cnbc.com/2021/10/14/gitlab-jumps-in-nasdaq-debut-after-pricing-ipo-above-expected-range.html" rel="external " onclick="this.target=&#39;_blank&#39;;">reality</a>. Although Rails does not accomplish this by itself — that would be our wonderful contributors and engineers — it does lay the proper foundations.</p>
<p>To reap the true <a href="https://en.wikipedia.org/wiki/The_Cathedral_and_the_Bazaar" rel="external " onclick="this.target=&#39;_blank&#39;;">benefits</a> of open source, the source code that is made available must be approachable for contributors. To maintain architectural integrity in the face of contributions from a wide variety of sources and to keep a clear demarcation line between the open and closed components, the code must be very well structured. Sound familiar?</p>
<p>Wouldn’t it be better to have a proper plugin interface? Or better yet, a services interface modeled on microservices? In a word: no. Not only do these approaches impose deployment and integration hurdles that go far beyond “I made a small change to the source code,” they often enforce architectural constraints too rigidly. Anticipating all the future extension points is a fool’s errand, one that we luckily did not embark on and do not have to.</p>
<p>With our boring modular monolith, users and other third-party developers can and do contribute enhancements to the core product, giving us tremendous leverage, coupled with an unbeatable pace and scalability of innovation.</p>
</div>
</div>



</div></div>
  </body>
</html>
