<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/coder/guts">Original</a>
    <h1>Show HN: Guts – convert Golang types to TypeScript</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://pkg.go.dev/github.com/coder/guts" rel="nofollow"><img src="https://camo.githubusercontent.com/2f126cda8176971f76ef1e61b1469b713272bf6b0a01bb568a2dd5844b58d22f/68747470733a2f2f706b672e676f2e6465762f62616467652f6769746875622e636f6d2f636f6465722f677574732e737667" alt="Go Reference" data-canonical-src="https://pkg.go.dev/badge/github.com/coder/guts.svg"/></a></p>
<p dir="auto"><code>guts</code> is a tool to convert golang types to typescript for enabling a consistent type definition across the frontend and backend. It is intended to be called and customized as a library, rather than as a command line executable.</p>
<p dir="auto">See the <a href="https://github.com/coder/guts/blob/main/example/simple">simple example</a> for a basic usage of the library.</p>
<div dir="auto" data-snippet-clipboard-copy-content="type SimpleType[T comparable] struct {
	FieldString     string
	FieldInt        int
	FieldComparable T
	FieldTime       time.Time
}"><pre><span>type</span> <span>SimpleType</span>[<span>T</span> <span>comparable</span>] <span>struct</span> {
	<span>FieldString</span>     <span>string</span>
	<span>FieldInt</span>        <span>int</span>
	<span>FieldComparable</span> <span>T</span>
	<span>FieldTime</span>       time.<span>Time</span>
}</pre></div>
<p dir="auto">Gets converted into</p>
<div dir="auto" data-snippet-clipboard-copy-content="type Comparable = string | number | boolean;

// From main/main.go
interface SimpleType&lt;T extends Comparable&gt; {
    FieldString: string;
    FieldInt: number;
    FieldComparable: T;
    FieldTime: string;
}"><pre><span>type</span> <span>Comparable</span> <span>=</span> <span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>boolean</span><span>;</span>

<span>// From main/main.go</span>
<span>interface</span> <span>SimpleType</span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&gt;</span> <span>{</span>
    <span>FieldString</span>: <span>string</span><span>;</span>
    <span>FieldInt</span>: <span>number</span><span>;</span>
    <span>FieldComparable</span>: <span>T</span><span>;</span>
    <span>FieldTime</span>: <span>string</span><span>;</span>
<span>}</span></pre></div>

<p dir="auto"><code>guts</code> is a library, not a command line utility. This is to allow configuration with code, and also helps with package resolution.</p>
<p dir="auto">See the <a href="https://github.com/coder/guts/blob/main/example/simple">simple example</a> for a basic usage of the library. A larger example can be found in the <a href="https://github.com/coder/coder/blob/main/scripts/apitypings/main.go">Coder repository</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Step 1: Create a new Golang parser
golang, _ := guts.NewGolangParser()

// Optional: Preserve comments from the golang source code
// This feature is still experimental and may not work in all cases
golang.PreserveComments()

// Step 2: Configure the parser
_ = golang.IncludeGenerate(&#34;github.com/coder/guts/example/simple&#34;)
// Step 3: Convert the Golang to the typescript AST
ts, _ := golang.ToTypescript()
// Step 4: Mutate the typescript AST
ts.ApplyMutations(
    config.ExportTypes, // add &#39;export&#39; to all top level declarations
)
// Step 5: Serialize the typescript AST to a string
output, _ := ts.Serialize()
fmt.Println(output)"><pre><span>// Step 1: Create a new Golang parser</span>
<span>golang</span>, <span>_</span> <span>:=</span> <span>guts</span>.<span>NewGolangParser</span>()

<span>// Optional: Preserve comments from the golang source code</span>
<span>// This feature is still experimental and may not work in all cases</span>
<span>golang</span>.<span>PreserveComments</span>()

<span>// Step 2: Configure the parser</span>
<span>_</span> <span>=</span> <span>golang</span>.<span>IncludeGenerate</span>(<span>&#34;github.com/coder/guts/example/simple&#34;</span>)
<span>// Step 3: Convert the Golang to the typescript AST</span>
<span>ts</span>, <span>_</span> <span>:=</span> <span>golang</span>.<span>ToTypescript</span>()
<span>// Step 4: Mutate the typescript AST</span>
<span>ts</span>.<span>ApplyMutations</span>(
    <span>config</span>.<span>ExportTypes</span>, <span>// add &#39;export&#39; to all top level declarations</span>
)
<span>// Step 5: Serialize the typescript AST to a string</span>
<span>output</span>, <span>_</span> <span>:=</span> <span>ts</span>.<span>Serialize</span>()
<span>fmt</span>.<span>Println</span>(<span>output</span>)</pre></div>

<p dir="auto"><code>guts</code> first parses a set of golang packages. The Go AST is traversed to find all the types defined in the packages.</p>
<p dir="auto">These types are placed into a simple AST that directly maps to the typescript AST.</p>
<p dir="auto">Using <a href="https://github.com/dop251/goja">goja</a>, these types are then serialized to typescript using the typescript compiler API.</p>

<p dir="auto">The generator aims to do the bare minimum type conversion. An example of a common opinion, is to use types to represent enums. Without the mutation, the following is generated:</p>
<div dir="auto" data-snippet-clipboard-copy-content="export enum EnumString {
    EnumBar = &#34;bar&#34;,
    EnumBaz = &#34;baz&#34;,
    EnumFoo = &#34;foo&#34;,
    EnumQux = &#34;qux&#34;
}"><pre><span>export</span> <span>enum</span> <span>EnumString</span> <span>{</span>
    <span>EnumBar</span> <span>=</span> <span>&#34;bar&#34;</span><span>,</span>
    <span>EnumBaz</span> <span>=</span> <span>&#34;baz&#34;</span><span>,</span>
    <span>EnumFoo</span> <span>=</span> <span>&#34;foo&#34;</span><span>,</span>
    <span>EnumQux</span> <span>=</span> <span>&#34;qux&#34;</span>
<span>}</span></pre></div>
<p dir="auto">Add the mutation:</p>
<div dir="auto" data-snippet-clipboard-copy-content="ts.ApplyMutations(
	config.EnumAsTypes,
)
output, _ := ts.Serialize()"><pre><span>ts</span>.<span>ApplyMutations</span>(
	<span>config</span>.<span>EnumAsTypes</span>,
)
<span>output</span>, <span>_</span> <span>:=</span> <span>ts</span>.<span>Serialize</span>()</pre></div>
<p dir="auto">And the output is:</p>
<div dir="auto" data-snippet-clipboard-copy-content="export type EnumString = &#34;bar&#34; | &#34;baz&#34; | &#34;foo&#34; | &#34;qux&#34;;"><pre><span>export</span> <span>type</span> <span>EnumString</span> <span>=</span> <span>&#34;bar&#34;</span> <span>|</span> <span>&#34;baz&#34;</span> <span>|</span> <span>&#34;foo&#34;</span> <span>|</span> <span>&#34;qux&#34;</span><span>;</span></pre></div>

<p dir="auto">The guts package was created to offer a more flexible, programmatic alternative to existing Go-to-TypeScript code generation tools out there.</p>
<p dir="auto">The other solutions out there function as command-line utilities with yaml configurability. <code>guts</code> is a library, giving it a much more flexible and dynamic configuration that static generators can’t easily support.</p>
<p dir="auto">Unlike many of its counterparts, guts leverages the official TypeScript compiler under the hood, ensuring that the generated TypeScript definitions are semantically correct, syntactically valid, and aligned with the latest language features.</p>

<p dir="auto">An incredible website to visualize the AST of typescript: <a href="https://ts-ast-viewer.com/" rel="nofollow">https://ts-ast-viewer.com/</a></p>
</article></div></div>
  </body>
</html>
