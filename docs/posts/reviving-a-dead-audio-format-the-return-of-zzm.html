<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nicole.express/2025/zoo-of-zero-motivation.html">Original</a>
    <h1>Reviving a Dead Audio Format: The Return of ZZM</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Long-time readers will know that my first video game love was the text-mode video game slash creation studio <a href="https://museumofzzt.com/">ZZT</a>. One feature of this game is the ability to play simple music through the PC speaker, and back in the day, I remember that the format “ZZM” existed, so you could enjoy the square wave tunes outside of the games. But imagine my surprise in 2025 to find that, while the Museum of ZZT does have a <a href="https://museumofzzt.com/file/browse/detail/zzm-audio/">ZZM Audio</a> section, it recommends that nobody use the format anymore; because nobody’s made a player that doesn’t require MS-DOS. Let’s fix that by making a player with <em>way</em> higher system requirements, using everyone’s favorite coding environment: Javascript.</p>

<h3 id="hey-i-dont-care-about-all-this-garbage">“Hey, I don’t care about all this garbage!”</h3>

<p>Here’s the <a href="https://github.com/nicolebranagan/zzmplayjs">code</a>, go wild. For everyone else, here is the blog post.</p>

<h2 id="zzt-and-the-pc-speaker">ZZT and the PC Speaker</h2>

<p>Despite being a game from 1990, Epic MegaGames’ (yes, it <em>is</em> that Epic, but it’s less Mega today) ZZT is really designed around what was the bare-minimum PC specs: 640kiB of RAM, and it even works on an Intel 8088– my <a href="https://nicole.express/2023/book-it.html">Book 8088</a> is used to play basically nothing else.</p>

<p><img src="https://nicole.express/assets/img/biossy/book.JPEG" title="reusing old photos BUT CHANGING THE TITLE TEXT what a shock" alt="An open book 8088 playing ZZT"/></p>

<p>That includes the audio, which uses nothing more than the PC Speaker. That makes it a little hard to record; pretty much all the authentic real hardware (tm) I have that can run ZZT pumps the PC speaker directly into a beeper, including the Book 8088.</p>



<p>So what kind of music capabilities did ZZT have? Since the goal of ZZT was also to allow players to create their own game world, it’s documented in the <a href="https://museumofzzt.com/file/view/zztmanl/?file=ZZTMNALR.DOC">unofficial manual</a> (look up the <code>#play</code> command), but a bit loosely. For example, here’s all it says on notes:</p>

<div><div><pre><code>Notes and rests:

X   Rest
A-G Piano notes (can be followed by:
    # sharp
    ! flat
</code></pre></div></div>

<p>There are <code>+</code> and <code>-</code> to move up and down an octave, but what’s the base octave? What frequency are the notes? Just open ZZT and mess around, it’s enough for a game maker to make a little tune for the title screen.</p>



<h3 id="but-zzm">But ZZM!</h3>

<p>ZZM was not made by Epic MegaGames. I believe it originated by ZZT community member Jacob Hammond around the turn of the millennium. And long-time ZZT enthusiasts will know that by that point, the source code for ZZT had been lost– even if Tim Sweeney himself had wanted to, he couldn’t provide it. Therefore, Hammond had to manually reimplement ZZT audio from scratch. Oof.</p>

<p>So what is a ZZM file?</p>

<p>The core of the ZZM environment is the “ZZM Music Ripper”. Essentially, this is a simple program that goes through a .ZZT file looking for all objects, and then digs through their code looking for <code>#play</code> commands. These are shuffled together into a file.</p>

<p>Don’t believe me? Let’s do it ourselves. I wrote up the loop that forms the first few notes of <a href="https://www.youtube.com/watch?v=jzmSREYM2uc"><em>Right</em></a>, the Area 4 theme from <a href="https://nicole-express.itch.io/aspect-legend"><em>Aspect Legend</em></a>. Of course the actual track used Game Boy style audio and has more channels.</p>

<p><img src="https://nicole.express/assets/img/zoom/list.png" title="yellow borders, the real experience" alt="The ZZT editor, with an object with a very basic music script"/></p>

<p>And here’s what it sounds like. This is DOSBox audio output, mind you. Sped up like this, you can really see how <a href="https://www.youtube.com/watch?v=1lH23S5dNa8&amp;list=PLy26JutVWZScc4Ca6AGZlZNi3pqephPjr&amp;index=21"><em>Spaceless</em></a>, the Area 1 theme of <a href="https://nicole-express.itch.io/space-ava"><em>Space Ava</em></a>, started from a similar place.</p>

<p><audio controls="" src="/assets/img/zoom/zzt_001.mp3">Your browser does not support the <code>audio</code> element.</audio></p><p>To rip the track, I used <a href="https://museumofzzt.com/file/view/zztmplay20/">ZZT Music Player v2.0</a>, since it’s the only version that had support in DOSBox.</p>

<div><div><pre><code>; ZZT Music File v1.0
; $TITLE Aspect Legend v0.00
; $GENDATE 01-16-2025
; $GENTIME 18:33:23
; $SONGS BEGIN
; $SONG 1
-scxaxdxaxexaxdxax
; $SONG ENDS
; $SONGS END
; $EOF
</code></pre></div></div>

<p>We will note a few things right away.</p>

<ul>
  <li>This is a plain text file. Special commands seem to be preceded with <code>;</code>.</li>
  <li>Song data itself is on bare lines, and matches the <code>#play</code> format.</li>
  <li>The loop is gone. That’s because there’s no support for loops in ZZM.</li>
  <li>There are no track titles.</li>
</ul>

<p>Later versions of ZZM <em>did</em> feature track titles. In fact, the included file <code>ZZTMUS1.ZZM</code> has them, this version of ZZT Music Player just doesn’t support them. Here’s how that file looks, somewhat trimmed down.</p>

<div><div><pre><code>ZZTMPLAYer file, version 2.0.

; $TITLE ZZT~Music~Collection~1

; $SONGS BEGIN

; $SONG TITLE 1 Blue~Moon~CD~Player~music
; $SONG 1
Q-EF#GF#EDHEQ444I44
IE+E-E+F#-E+G-E+F#-E+E-E+D-E+E-EB
...
</code></pre></div></div>

<p>Notice that it has a different version line as well, and titles use <code>~</code> in place of spaces. But other files I’ve shown don’t follow this rule; it’s a bit rough and dirty. Titles also seem to be able to be placed wherever in the file. (My guess is that this is because they could be added to a ripped file after the fact)</p>

<p>So I ended up writing a very simple parser. One of the most annoying parts proved to just be stripping out <code>/r</code>; these all use the classic MS-DOS <code>/r/n</code>, and at least on my Mac those show up when loaded up into JS as well.</p>

<h2 id="cool-cool-but-what-about-the-music">Cool, cool, but what about the music?</h2>

<p>The thing is, all I’ve got is the input to a <code>#play</code> command. Now, in theory, since one can use <a href="https://zeta.asie.pl/">Zeta</a> to run ZZT in the browser, you could just take those outputs, quickly generate a ZZT file on the fly that plays that on the title screen, and then run Zeta in the background. But that felt pretty silly. Instead, let’s look at how ZZT sound works.</p>

<h3 id="the-pc-speaker">The PC Speaker</h3>

<p>The PC Speaker is not the same as the beeper on the <a href="https://nicole.express/2021/stop-mocking-me.html">Apple ][</a>. On that system, you had to manually pulse the speaker to move its cone in and out, and the frequency you pulse the special address at is the frequency your sound plays at.</p>

<p>The PC Speaker is the next level up of sophistication. It’s not a dedicated sound chip, but uses a channel on the PC’s programmable interval timer. That channel is configured to output a square wave at some frequency; the PC can control the timer to control the frequency. It’s just one channel, and it’s always a square wave. It was possible to be clever and do more complex waveforms, but ZZT doesn’t do that.</p>

<p>Here’s a Pascal documentation on the function <a href="https://www.freepascal.org/docs-html/rtl/crt/sound.html">Sound</a>, used in ZZT to play the music. It takes a single parameter that is the frequency; you call the related function <a href="https://www.freepascal.org/docs-html/rtl/crt/nosound.html">NoSound</a> to stop it.</p>



<p>Now, how do I know what function ZZT uses, when the source code was gone by the 21st century? Because enthusiasts brought it back. Specifically, Asie’s <a href="https://github.com/asiekierka/reconstruction-of-zzt/">Reconstruction of ZZT</a> project has painstakingly recreated the original source code, or at least a source code that compiles byte-for-byte to an identical executable. Check out the <a href="https://blog.asie.pl/2020/08/reconstructing-zzt/">blog post</a>, this is a real accomplishment of reverse-engineering.</p>

<h2 id="recreating-the-zzt-sound-engine">Recreating the ZZT sound engine</h2>

<p>Unfortunately, the W3C has not yet seen to add a WebPcSpeaker API to JavaScript. This is a major oversight, and I recommend all <em>Nicole Express</em> readers who are in charge of standardization committees get that rectified as soon as possible. So we have to use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">Web Audio API</a>. Like pretty much anything designed for audio in the modern era, the Web Audio API is not based around square waves, it’s based around samples.</p>

<p>Of course, the square wave is probably the easiest wave to convert to samples. Here’s how I did it.</p>

<div><div><pre><code>function generateSquareWave(freq, sampleRate, duration) {
    const output = new Float32Array(Math.floor(duration * sampleRate));
    const period = (1 / freq) * sampleRate;
    for (let i = 0; i &lt; output.length; i++) {
        const point = i % period;
        if (point &gt; (period / 2)) {
            output[i] = -1;
        } else {
            output[i] = 1;
        }
    }
    return output;
}
</code></pre></div></div>

<p>There are probably even more clever and efficient ways to do it, but a square wave really is just like that. Now, you could argue that a real square wave output by the PC Speaker has slightly different characteristics, since square waves don’t exist in the real world. To which I’d say that the imperfections will still happen in your headphones or sound system, so don’t worry about it. But I don’t have “golden ears”.</p>

<h3 id="it-hertz">It Hertz</h3>

<p>Of course, generating a square wave is the easy part. That first parameter, <code>freq</code>, now that’s the hard part. Like many sound engines, ZZT’s relies on a hardcoded internal table. This is generated at startup.</p>

<div><div><pre><code>procedure SoundInitFreqTable;
    var
        octave, note: integer;
        freqC1, noteStep, noteBase, ln2: real;
    begin
        freqC1 := 32.0;
        ln2 := Ln(2.0);
        noteStep := Exp(ln2 / 12.0);
        for octave := 1 to 15 do begin
            noteBase := Exp(octave * ln2) * freqC1;
            for note := 0 to 11 do begin
                SoundFreqTable[octave * 16 + note] := Trunc(noteBase);
                noteBase := noteBase * noteStep;
            end;
        end;
    end;
</code></pre></div></div>

<p>Notice that it starts by declaring 32Hz to be the frequency of the note C1, but the actual first octave value is e^(ln(2)) * f<sub>C1</sub>. That is to say, the lowest C in ZZT is 64Hz. (You can also note that the array <code>SoundFreqTable</code> has a lot of empty spots that aren’t filled. It’s actually sized to 256 entries, if I read my Pascal correctly)</p>

<p>Modern tuning is based around the note A. Specifically, most western instruments are tuned to 440Hz as the A above middle C, known as “A440”. Follow the ZZT frequency table, and we get that A at 430Hz. Is that a big deal? Baroque instruments used around 415Hz, and the base frequency rose throughout the 20th century, so variation isn’t un<em>heard</em> of– but it will definitely make ZZT sound just a little out of tune relative to most music. Here’s my translation of that to JavaScript.</p>

<div><div><pre><code>function initSoundFreqTable() {
    let soundFreqTable = [];
    const freqC1 = 32;
    const ln2 = Math.LN2;
    const noteStep = Math.exp(ln2 / 12);
    for (let octave = 1; octave &lt;= 15; octave++) {
        let noteBase = Math.exp(octave*ln2) * freqC1;
        for (let note = 0; note &lt;= 11; note++) {
            soundFreqTable[octave * 16 + note] = Math.floor(noteBase);
            noteBase *= noteStep;
        }
    }
    return soundFreqTable;
}
</code></pre></div></div>

<p>Notice I kept the gaps in the frequency table. Not how I’d implement it from scratch, but felt it was safer to just follow the ZZT code. That included using 1 to index my arrays occasionally and having some weird gaps in the array. I probably didn’t need to declare a variable just for <code>Math.LN2</code>, though; it was already constant.</p>

<h3 id="blazing-pascal">Blazing Pascal</h3>

<p>The big function here, though, is the one that decodes the string you pass to the <code>#play</code> command. That function is <a href="https://github.com/asiekierka/reconstruction-of-zzt/blob/master/SRC/SOUNDS.PAS#L223">SoundParse</a>; I’ve left a link because this is a big one to reproduce in full. This actually creates an intermediate format that is later used to actually play the sound. Why?</p>

<ol>
  <li>Notes can vary from one to two characters (i.e. <code>C</code> and <code>B#</code>). So the intermediate version has them always have one button.</li>
  <li>When writing a track, there is a lot of state that is kept along. Specifically, if you write a <code>B</code>, the program needs to know the current octave and the current note duration in order to actually figure out what note to play. In the intermediate representation, the full note and duration are decoded for each point.</li>
</ol>

<p>In my version of this function, I decided that rather than create an intermediate format, I would have the output be a full <code>Float32Array</code> of audio samples that could be passed directly into the Web Audio API.</p>

<p>The <code>SoundParse</code> function surprised me for another reason. I’m not very familiar with the Pascal language; but the language is quite sophisticated in some ways. The whole function is based around a <code>case</code> statement. This isn’t the same as a C <code>switch</code>. It also features pattern matching; Tim Sweeney also used an <code>AdvanceInput</code> function that acts as a closure.</p>

<div><div><pre><code>case UpCase(input[1]) of
    &#39;T&#39;: begin
        noteDuration := 1;
        AdvanceInput;
    end;

    { some additional code removed }
    
    &#39;A&#39;..&#39;G&#39;: begin
        case UpCase(input[1]) of
            &#39;C&#39;: begin
                noteTone := 0;
                AdvanceInput;
            end;
            &#39;D&#39;: begin
                noteTone := 2;
                AdvanceInput;
            end;
            { etc for all other notes }
        end;

        case UpCase(input[1]) of
            &#39;!&#39;: begin
                noteTone := noteTone - 1;
                AdvanceInput;
            end;
            &#39;#&#39;: begin
                noteTone := noteTone + 1;
                AdvanceInput;
            end;
        end;

        output := output + Chr(noteOctave * $10 + noteTone) + Chr(noteDuration);
    end;
</code></pre></div></div>

<p>Notice that the <code>case</code> can have a clause like <code>&#39;A&#39;..&#39;G&#39;</code>, where all letters between <code>A</code> and <code>G</code> are matched. JavaScript doesn’t have this capability, as far as I know (various proposals have made it to the ECMAScript committee), so for this function I had to diverge quite a bit more from the original. Here’s <a href="https://github.com/nicolebranagan/zzmplayjs/blob/bcda3d2e396e258c52365b34880428b2a5ad9e4e/static/js/audio.js#L110">my take on this code</a>.</p>

<h3 id="note-duration">Note duration</h3>

<p>One last thing. You might wonder how I determined the note duration; after all, in <code>SoundParse</code> the <code>noteDuration</code> is just in multiples of a sixteenth note. But this turns out to be pretty simple. At the very end of <code>SOUNDS.PAS</code>, we see this:</p>

<div><div><pre><code>SetIntVec($1C, SoundNewVector);
</code></pre></div></div>

<p>The <code>0x1C</code> interrupt is an <a href="http://www.delorie.com/djgpp/doc/rbinter/id/53/24.html">MS-DOS timer interrupt</a>. This comes from the very same programmable timer that is used to feed the PC speaker, and in most cases, including this one, fires at a rate of once every 55ms. And using that as my sixteenth note duration worked fine. Let’s take a listen. Here’s that short track from earlier.</p>

<p><audio controls="" src="/assets/img/zoom/dump.mp3">Your browser does not support the <code>audio</code> element.</audio></p><h2 id="drums-cause-a-code-red">Drums cause a Code Red</h2>

<p>Here’s a longer audio sample, the title screen music from Alexis Janson’s <em>Code Red</em>. Note that this was recorded from DOSBox, which is known to not be perfect at running ZZT, but it sounds good to my ears.</p>

<p><audio controls="" src="/assets/img/zoom/codered_zzt.mp3">Your browser does not support the <code>audio</code> element.</audio></p><p>And here’s my take on it. It’s a little louder!</p>

<p><audio controls="" src="/assets/img/zoom/codered_m1.mp3">Your browser does not support the <code>audio</code> element.</audio></p><p>You might hear something a little weird. A little <em>squelchy</em>… or as ZZT calls it, the drums. The manual doesn’t give us much details.</p>

<div><div><pre><code>Rythmic Sound FX:

0   Tick
1   Tweet
2   Cowbell
4   High Snare
5   High woodblock
6   Low snare
7   Low tom
8   Low woodblock
9   Bass drum
</code></pre></div></div>

<p>Notice that “3” is skipped; that’s because 3 is used for triplet notes. But beyond that, we don’t get any description about how these work. It might’ve been fun to just use some samples of real-world drums, but that wouldn’t give the Real ZZT Sound<sup>TM</sup>.</p>

<p>So I just established that all the Pascal API used by ZZT can do is play particular frequencies. So how did ZZT implement drums?</p>

<div><div><pre><code>procedure SoundPlayDrum(var drum: TDrumData);
    var
        i: integer;
    begin
        for i := 1 to drum.Len do begin
            Sound(drum.Data[i]);
            Delay(1);
        end;
        NoSound;
    end;
</code></pre></div></div>

<p>The drums are just a series of single frequencies played in quick succession, each for 1ms. The <code>TDrumData</code> are generated by another table <a href="https://github.com/asiekierka/reconstruction-of-zzt/blob/master/SRC/SOUNDS.PAS#L105">right here</a>, which just needed a little massaging to convert to JavaScript. I started by using ChatGPT but alas, it really got confused by the 1-indexed arrays.</p>

<p>One thing you’ll note is that it uses the <code>Random</code> function to generate certain drums; specifically, the high snare (just like the <a href="https://nicole.express/2024/panasonic-the-hedgehog.html">Panasonic rhythm machine</a>!) and the two woodblocks. I just used <code>Math.random</code>, but in theory, it seems like the particular characteristics of Turbo Pascal’s random number generator will be reflected in the drum sounds. Maybe that’s why my drums sound just a little squelchier.</p>



<p>Here’s an example of what a trace of a drum looks like from my ZZT recording. Notice that the quick changes of frequency mean that you really only see one or two peaks of a square wave before the next one starts. (You can also see that the PC Speaker puts rests at the low amplitude, rather than returning to 0)</p>

<p><img src="https://nicole.express/assets/img/zoom/drum.png" title="not real" alt="Drum trace"/></p>

<p>To see what a difference having the source code makes, here’s how Jacob Hammond’s ZZT Music Player v2.0 plays back the same track. Again this is from DOSBox, which is <em>known</em> to have problems with ZZT Music Player in particular, and in any case I don’t want to be harsh on Hammond here; again, he had to reverse-engineer all of this himself without access to modern tools. This is just for comparison’s sake.</p>

<p><audio controls="" src="/assets/img/zoom/codered_h.mp3">Your browser does not support the <code>audio</code> element.</audio></p><p><img src="https://nicole.express/assets/img/zoom/end.png" title="offer may have expired" alt="Shareware ZZT quit notice"/></p>

  </div>

  
</article>

      </div>
    </div></div>
  </body>
</html>
