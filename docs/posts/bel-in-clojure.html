<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stopa.io/post/290">Original</a>
    <h1>Show HN: Bel in Clojure</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><span><p>9 months ago, I took a gander at PG‚Äôs <a href="http://www.paulgraham.com/bel.html" target="_blank">guide to Bel</a>. If you haven‚Äôt read it, here‚Äôs the premise: </p><p>In 1958 when McCarthy invented Lisp, he started with a mathematical, rather than a practical definition. His paper was more similar to the spec for a Turing Machine than a spec for Fortran. For example, McCarthy didn‚Äôt even think that Lisp would run on real computers until his graduate student suggested it.</p><p>This was the secret to Lisp‚Äôs power. Because McCarthy was unconcerned with how Lisp would work on the computers of 1958, he made a language so powerful that it‚Äôs still magic for the computers of 2021. </p><p>The original spec for Lisp stopped short of a complete language. There were no numbers or errors for example. So PG thought: what would happen if I continued McCarthy‚Äôs tradition, and formally defined a <em>complete</em> language? Numbers, errors, and all.</p><p>This idea spoke to my Lisper heart, and I was intrigued. I opened up the guide and got reading. An hour in, and I knew I couldn‚Äôt understand this without getting my hands dirty. So I told myself, hey, why don‚Äôt I just take a weekend and implement the spec?</p><p>Well...9 months later, I present you Bel in Clojure! </p><p><span><span></span><img src="https://stopa.io/api/image/firstFrame/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE0ODI2MTc1MC1hMzVkZmIxNC0zMDg1LTQ0OGQtOGQxNi00NTFjMGU0OGU4ZjcuZ2lm"/></span></p>
<p>It‚Äôs still rough, and about 85% there, but it‚Äôs ~tolerably fast for small functions, and even supports multi-threading! Want to try it yourself? <a href="https://github.com/stopachka/bel-clojure" target="_blank">Here‚Äôs the code</a>. </p><p>Working on Bel felt like going on a country walk, and running into an old friend who invites you to skydive with them. You think to yourself, sure a bit out of the ordinary but why not, skydiving is fun. As soon as you step on the plane, you discover the pilot is an intrepid adventurer and offers you a glide over London. Well, you wouldn‚Äôt have predicted this, but you did always want to visit London. After your plane lands, you run into a person who speaks to your soul. You blink, and find yourself on a scooter over a dirt road in Thailand, driving off into the sunset with the love of your life.</p><p>Okay this may be a bit too much for a paragraph in a technical essay. What do I mean? </p><h2 id="ebnf">EBNF</h2><p>My first plan was a 2-day project: I would use Clojure‚Äôs reader, keep Clojure data structures, and write a standard recursive interpreter ‚Äî no more than a few hundred lines probably.  </p><p>And there came my first surprise. I couldn‚Äôt use Clojure‚Äôs reader. PG supports quasiquotes (<code>`(foo &#39;,a ,@b)</code>) custom characters (<code>\bel</code>), dotted lists (<code>(a . b)</code>), and a powerful shorthand syntax (<code>x|~f:g!a</code> typechecks, composes 3 functions, quotes and invokes). I realized I‚Äôd need to write my own parser <sup>1</sup>. </p><p>Thankfully, I discovered <a href="https://github.com/Engelberg/instaparse" target="_blank">instaparse</a>, and EBNF notation. EBNF, if you haven‚Äôt heard of it, is a declarative way to describe programming language syntax. Years have made me suspicious of purported ‚Äúdeclarative DSLs‚Äù ‚Äî often a hodpodge of incidental complexity. But, my friends EBNF joins SQL in my eyes as a real solution. </p><h2 id="continuations">Continuations</h2><p>So, with the parser out of the way, I marched forward with confidence. One more weekend, and I‚Äôd surely be done. Oops, I hit another surprise: my simple recursive interpreter wouldn‚Äôt work. </p><p>PG supports continuations. Continuations let you ‚Äúmove back‚Äù to different points in your program‚Äôs execution. (If you haven‚Äôt heard of them, no worries, I‚Äôll describe them in more detail later in the essay). What this meant for me, was that I couldn‚Äôt just have a simple interpreter that recursed over itself, as I‚Äôd need to be able to ‚Äúgo back‚Äù to states in the recursion. </p><p>Now I saw one more weekend wouldn‚Äôt do the trick, and took a break. </p><h2 id="sicp-to-the-rescue">SICP to the rescue?</h2><p>A few months later, I got back to the project, but this time opened up my trusty guide: Structure and Interpretation of Computer Programs. I perused their chapter on the <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-28.html" target="_blank">amb intepreter</a>, and saw how they used the ‚Äúcontinuation-passing-style‚Äù. Yes, this could do the trick. </p><p>Okay, off I went, and re-implemented my interpreter in the continuation-passing-style. If you haven‚Äôt heard of it, here‚Äôs the idea: every step, instead of returning, calls a ‚Äúdone‚Äù callback. This lets you save callbacks and move between different states in the execution.</p><p>Once I made this refactor, continuations were easy peasy.</p><h2 id="-j-xss900m">-J-Xss900M</h2><p>Well, very soon I came to the next setback. After just 100 or 200 lines of reading the Bel source, running simple programs would cause my interpreter to stack overflow. PG heavily takes advantage of recursion in his code, which exacerbated my poor callback-based interpreter. </p><p>At first, I started raising the JVM stack size, hoping I could get through. But, I was beginning to hit stack overflows even when I set the stack size to 900 megabytes. <sup>2</sup> To make matters worse, writing an interpreter with continuation-passing-style is a nightmare to debug and reason about. Here‚Äôs an example of <a href="https://github.com/stopachka/bel-clojure/blob/22f72f6fcae25dff5b725e33104537ab4c588c55/src/bel_clojure/instance.clj#L519-L550" target="_blank">one function</a> ‚Äî this kind of recursion makes my head spin.</p><p>So, off on another break I went.</p><h2 id="stacks">Stacks</h2><p>Then, I opened the project up a week ago. This time, I thought to myself: why don‚Äôt I implement my own call stack? </p><p>Keeping my own call stack (which is just how PG does it in the Bel source), turned out to be the watershed moment. It was easier to debug, and a bunch of the implementation became simpler. For example, supporting multi-threading was only <a href="https://github.com/stopachka/bel-clojure/pull/19/files" target="_blank">~50 lines</a>!</p><p>At this point, I was emboldened. Much of Bel was working, but it was slow. In the formal spirit, PG implements the environment as a list for example. This meant every lookup was O(n). Numbers were also implemented as lists, and just <code>+</code> would take too long to run.  I was worried that if my interpreter ran PG‚Äôs source, it would be intolerably slow. </p><h2 id="clojure-inspiration">Clojure Inspiration</h2><p>So I thought to myself, why don‚Äôt I try to make it faster? I loved Clojure‚Äôs design decisions, when it came to interop with java. Clojure strings are java strings, clojure numbers are java numbers. </p><p>So, I went with that spirit. I leaked <code>java.util.HashMap</code> into Bel, and used that as the environment. That was a huge speedup. After that, I leaked java numbers, strings, and chars <sup>3</sup>. Bel began to take a pragmatic shape.  </p><h2 id="the-current-state">The Current State</h2><p>At this point, the interpreter supports much of Bel, but has diverted from the formal specification in a few ways. Numbers are Clojure numbers, and Strings are a separate type. The most crucial missing feature are streams: I think we‚Äôd want to seep Java streams, but I haven‚Äôt thought deeply about it yet. </p><p>It‚Äôs still slow <sup>4</sup>, and I‚Äôm certain there many bugs to overcome. But, it‚Äôs fun to use as a REPL üôÇ </p><p>Implementing Bel has given me quite an appreciation for the source. Bel is <em>powerful.</em> When defining the whole language in itself, the language designer is forced to expose access to all the constructs they need, and that means the user of the language is as powerful as the designer. </p><h2 id="lit">lit</h2><p>For example, PG introduces a new construct called <code>lit</code>. It‚Äôs like a persistent quote: </p><pre><code><span>(</span><span>quote</span><span> a)</span>
<span>&gt; a </span>
<span>(</span><span>lit</span><span> a) </span>
<span>&gt; (</span><span>lit</span><span> a)</span></code></pre><p>Why would you need this? Well, if you‚Äôre trying to define ‚Äúprimitive types‚Äù in your language, like functions or numbers, you‚Äôd want them to evaluate to themselves. So PG takes advantage of <code>lit</code> to do just this. For example, here‚Äôs how he represents functions: </p><pre><code><span>(</span><span>lit</span><span> clo </span><span>nil</span><span> (</span><span>x</span><span>) (</span><span>+</span><span> x </span><span>1</span><span>))</span></code></pre><p>Functions are lists, just like something the language user could write. If you wanted to create your own primitive type ‚Äî say ‚Äúkeywords‚Äù, it would look conceptually similar: </p><pre><code><span>(</span><span>lit</span><span> kw foo)</span>
<span>&gt; (</span><span>lit</span><span> kw foo)</span></code></pre><h2 id="globe-scope">globe, scope</h2><p>And how about closures? To support that, whenever a function is defined, PG needs a way to ‚Äúinject‚Äù the current lexical scope. So, he introduces <code>globe</code> and <code>scope</code>: variables that expose the actual interpreter environment. Now he can write something like this: </p><pre><code><span>(</span><span>mac</span><span> </span><span>fn</span><span> (</span><span>params</span><span> . body)</span>
<span>  (</span><span>list</span><span> &#39;lit &#39;clo scope &#39;,params &#39;,(</span><span>car</span><span> body)))</span></code></pre><p>So when a <code>fn</code> is defined, it just generates a list, with the current scope plopped inside: </p><pre><code><span>(</span><span>fn</span><span> (</span><span>x</span><span>) (</span><span>+</span><span> x </span><span>1</span><span>))</span>
<span>&gt; (</span><span>lit</span><span> clo scope (</span><span>x</span><span>) (</span><span>+</span><span> x </span><span>1</span><span>))</span></code></pre><p>I don‚Äôt know of a different language that gives you access to the environment in this way. It was pretty cool to see how simple it was to define something like <code>fn</code></p><h2 id="mac">mac</h2><p>I was also surprised with his macros. I traditionally thought macros ran once during compile time. But his macros are ‚Äúever-present‚Äù, and are available at runtime. He defines a macro as a simple <code>lit</code> which keeps a closure. This closure is run over the arguments it receives, before they‚Äôre evaluated. </p><pre><code><span>(</span><span>lit</span><span> mac (</span><span>lit</span><span> clo ...))</span></code></pre><p>This isn‚Äôt unique to Bel, But I thought the way we could define <code>defmacro</code>, was pretty cool: </p><pre><code><span>(</span><span>set</span><span> </span><span>defmacro</span>
<span>  (</span><span>lit</span><span> mac</span>
<span>    (</span><span>lit</span><span> clo </span><span>nil</span><span> (</span><span>n</span><span> p e)</span>
<span>      (</span><span>list</span><span> &#39;set n</span>
<span>            (</span><span>list</span><span> &#39;lit &#39;mac</span>
<span>                  (</span><span>list</span><span> &#39;lit &#39;clo </span><span>nil</span><span> p e))))))</span></code></pre><p>This is a macro-defining macro!</p><h2 id="err">err</h2><p>The ‚Äúdefining the language‚Äù thinking shows up with how PG specs out errors. For example, he says that whenever there‚Äôs an error, the interpreter can‚Äôt just give up. Instead, it must call the <code>err</code> function with a message.</p><pre><code><span>(</span><span>car</span><span> &#39;a) </span><span>;; uh oh, this is an error, interpreter calls (err &#39;bad-arg)</span></code></pre><p>By making this axiom, it now lets PG control <em>how</em> errors happen. For example, say we want to do something special with the <code>err</code> function. We could do this: </p><pre><code><span>(</span><span>dyn</span><span> err (</span><span>fn</span><span> (</span><span>x</span><span>) &#39;hello) (</span><span>car</span><span> &#39;a))</span>
<span>&gt; hello</span></code></pre><p>Here, we redefined <code>err</code>, to a function that returns <code>&#39;hello</code>. All of a sudden, we have half of what we need to implement error catching.</p><h2 id="continuations">Continuations</h2><p>The other half, comes from continuations. Before Bel I had heard of continuations, but I never seriously used a language that supported them. As I said before, continuations let you go to a certain point in a program‚Äôs execution. </p><p>To get a better sense of what I mean, let‚Äôs look at an example PG uses in his guide: </p><pre><code><span>(</span><span>list</span><span> &#39;a (</span><span>ccc</span><span> (</span><span>fn</span><span> (</span><span>c</span><span>) (</span><span>set</span><span> cont c) &#39;b)))</span>
<span>&gt; (</span><span>a</span><span> b)</span></code></pre><p>Here, we start a computation <code>(list &#39;a ...)</code>. This runs <code>(ccc (fn () ...))</code> and returns the result <code>&#39;b</code>, which completes <code>(list &#39;a &#39;b)</code>, and returns <code>(a b)</code>. </p><p>But now watch this: </p><pre><code><span>(</span><span>cont</span><span> &#39;z)</span>
<span>&gt; (</span><span>a</span><span> z)</span>
<span>(</span><span>cont</span><span> &#39;w)</span>
<span>&gt; (</span><span>a</span><span> w)</span></code></pre><p>The callback in <code>ccc</code> gave us <code>c</code>, a continuation. Whenever we call it, it‚Äôs as though we ‚Äúwent back‚Äù to when our interpreter was computing <code>(list a ...)</code>, but this time instead of returning <code>&#39;b</code> , we return <code>&#39;z</code>.  We then do that again but with <code>&#39;w</code>. </p><p>Why do we need it? Well, let‚Äôs say you want to do some kind of error catching. Here‚Äôs how you could do it: </p><pre><code><span>(</span><span>ccc</span><span> (</span><span>fn</span><span> (</span><span>c</span><span>) </span>
<span>        (</span><span>dyn</span><span> err (</span><span>fn</span><span> (</span><span>x</span><span>) (</span><span>c</span><span> &#39;uhohgotanerror))</span>
<span>          (</span><span>car</span><span> &#39;b))))</span>
<span>&gt; uhohgotanerror</span></code></pre><p>All of a sudden, you can implement a whole suite of cool macros, like <code>eif</code>, <code>safe,</code> and <code>onerr</code>, with a <a href="https://github.com/stopachka/bel-clojure/blob/main/resources/core.bel#L250-L267" target="_blank">few lines of code</a>: </p><pre><code><span>(</span><span>onerr</span><span> &#39;oops (</span><span>car</span><span> &#39;a))</span>
<span>&gt; &#39;oops</span></code></pre><p>At first I was skeptical with continuations, but one thing is clear: they are a more <em>fundamental</em> abstraction than exceptions. You can implement exceptions with continuations, but you can‚Äôt implement continuations with exceptions. If power is your priority, than they are more powerful.</p><h2 id="utilities">Utilities</h2><p>I‚Äôm not sure how much this is a consequence of writing a language in itself, but I found a grab-bag of great functions and macros I hadn‚Äôt seen before in other languages. Here are some really fun ones. </p><p>The <code>eif</code> macro, returns one branch if there‚Äôs an error:</p><pre><code><span>(</span><span>eif</span><span> x (</span><span>car</span><span> &#39;a)</span>
<span>        &#39;oops</span>
<span>        x)</span>
<span>&gt; oops</span></code></pre><p>The <code>aif</code> macro, which evaluates the test expression, but lets you access the result as the variable <code>it</code>: </p><pre><code><span>(</span><span>map</span><span> (</span><span>fn</span><span> (</span><span>x</span><span>)</span>
<span>        (</span><span>aif</span><span> (</span><span>cdr</span><span> x) (</span><span>car</span><span> it)))</span>
<span>  &#39;((</span><span>a</span><span>) (</span><span>b</span><span> c) (</span><span>d</span><span> e f) (</span><span>g</span><span>)))</span>
<span>&gt; (</span><span>nil</span><span> c e </span><span>nil</span><span>)</span></code></pre><p>The <code>of</code> function, which applies one function to all arguments, and gives those results another: </p><pre><code><span>((</span><span>of</span><span> + car) x y z)</span>
<span>;; same as -&gt; </span>
<span>(</span><span>+</span><span> (</span><span>car</span><span> x) (</span><span>car</span><span> y) (</span><span>car</span><span> z))</span></code></pre><p>And <code>upon</code>, which lets you save arguments and apply them to different functions:</p><pre><code><span>(</span><span>map</span><span> (</span><span>upon</span><span> &#39;(a b c)) </span>
<span>     (</span><span>list</span><span> car cadr cdr))</span>
<span>&gt; (</span><span>a</span><span> b (</span><span>b</span><span> c))</span></code></pre><h2 id="abbreviations">Abbreviations</h2><p>Perhaps the most fun thing I saw, which I immediately wished was available in clojure was the shorthand syntax: </p><p>For example, composition: </p><pre><code><span>foo:bar:baz</span>
<span>&gt; (</span><span>compose</span><span> foo bar baz)</span></code></pre><p>And whenver you need to get the ‚Äúopposite‚Äù of a function: </p><pre><code><span>~foo</span>
<span>&gt; (</span><span>compose</span><span> no foo)</span></code></pre><p>There‚Äôs two really nice list creation abbreviations too: </p><pre><code><span>foo.a</span>
<span>&gt; (</span><span>foo</span><span> a)</span>
<span>foo!a </span>
<span>&gt; (</span><span>foo</span><span> &#39;a)</span></code></pre><p>This kind of stuff seems small and inconsequential, but it&#39;s significant in practice. I think it may be because though it seems like it&#39;s about saving keystrokes, it&#39;s actually about giving your mind a shorthand to think with.</p><h2 id="my-one-big-gripe">My one big gripe</h2><p>The one thing that made me hesitant, was the underlying pair primitive in Bel. It‚Äôs mutable. On one hand, I can understand the decision, as if you‚Äôre trying to answer ‚Äúhow can I formally define a complete language?‚Äù, I think immutability wouldn‚Äôt be critical. </p><p>But, after immutability in Clojure, I‚Äôm convinced it‚Äôs the way that we should all be programming. It models <a href="https://www.youtube.com/watch?v=ScEPu1cs4l0" target="_blank">reality better</a>, and it makes concurrency a magnitude simpler <sup>5</sup>. </p><p>Still, I‚Äôm not sure an implementation of Bel necessarily has to have mutability as core to the language. It may be just as good to ‚Äúseep‚Äù clojure‚Äôs Peristent Seq, atom, and make threads actual system threads. With that, we‚Äôd come to a pretty darn cool language.</p><h2 id="one-fun-experiment">One Fun Experiment</h2><p>Perhaps the most interesting meta lesson, is to approach projects with naivete and play. If I had known this would have taken 3 different interpreter implementations, I would have been more hesitant to have started, but boy am I glad I did. I learned a lot. It‚Äôs still a toy, and there‚Äôs still a lot of work to do, but the journey itself was worth it. </p><p>I suggest you try it out, and hey, if you want to take it further, the source is out there üôÇ.  </p><p><em>Thanks Alex Reichert, Alexandre Lebrun, Daniel Woelfel, Dennis Heihoff, Joe Averbukh, Julien Odent, Martin Raison, Sean Grove for reviewing drafts of this essay</em></p></span></p></div></div></div></div>
  </body>
</html>
