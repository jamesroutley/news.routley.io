<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ArcaneNibble/i-cant-believe-its-not-webusb">Original</a>
    <h1>I-cant-believe-its-not-webusb: Hacking around lack of WebUSB support in Firefox</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">It turns out that there is a way for a web page to access USB devices <em>without</em> requiring WebUSB and its associated political disagreements! Not only that, a device can intentionally design itself to bypass all of the user consent requirements.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/ArcaneNibble/i-cant-believe-its-not-webusb/blob/main/demo.gif"><img src="https://github.com/ArcaneNibble/i-cant-believe-its-not-webusb/raw/main/demo.gif" alt="demo video" data-animated-image=""/></a></p>

<p dir="auto">Load <a href="https://github.com/ArcaneNibble/i-cant-believe-its-not-webusb/blob/main/u2f-hax.uf2">u2f-hax.uf2</a> onto a Raspberry Pi Pico (RP2040 version), and then load <a href="https://github.com/ArcaneNibble/i-cant-believe-its-not-webusb/blob/main/index.html">index.html</a> from either localhost or another secure context.</p>
<p dir="auto">The &#34;On!&#34; and &#34;Off!&#34; buttons will toggle the LED, and the state of pin <code>GP22</code> will be regularly updated on the page (you can conveniently short it to the adjacent GND pad with a piece of wire or metal).</p>

<p dir="auto">The Pico is programmed to emulate a <a href="https://en.wikipedia.org/wiki/Universal_2nd_Factor" rel="nofollow">U2F</a> dongle (i.e. a physical two-factor security key). However, instead of performing any security functions, arbitrary data is smuggled in the &#34;key handle&#34; and signature of <code>U2F_AUTHENTICATE</code> messages. As long as the key handle starts with 0xfeedface, the Pico instantly &#34;confirms&#34; user presence and returns data.</p>

<p dir="auto">By design, the U2F key handle is an opaque blob of data which is conceptually &#34;owned by&#34; the security dongle. It is supposed to be returned by the dongle as a result of a registration, stored as-is by the relying party, and then given as-is back to the security dongle when authenticating.</p>
<p dir="auto">One reason this key handle functionality exists is to enable an unlimited number of websites to be associated with a particular  low-cost dongle with very limited memory. This hypothetical dongle stores a unique &#34;master&#34; encryption key internally. When a new registration is created, it creates a new public/private key pair, returns the public key, encrypts the private key with the &#34;master&#34; key, and <em>returns the encrypted private key as the key handle</em>. No matter how many registrations are created, the dongle does not have to be responsible for storing the keys associated with them. When the key handle is passed back to the dongle during an authentication, the dongle just unwraps the private key using its master key.</p>
<p dir="auto">In order to <em>allow for</em> all of these low-cost designs without <em>mandating</em> any particular internal algorithms, the key handle is treated as opaque, and so we can abuse it to smuggle arbitrary data.</p>
<p dir="auto">In order to <em>return</em> data, we need to somehow smuggle it as an ECDSA signature. An ECDSA signature is a tuple of two numbers <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="9d860057dfcc06c6c609f835f8fee0ec">$(r, s)$</math-renderer>, where each of the numbers is calculated <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="9d860057dfcc06c6c609f835f8fee0ec">$\mod n$</math-renderer>, where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="9d860057dfcc06c6c609f835f8fee0ec">$n$</math-renderer> is the <em>order</em> of the elliptic curve base point. This basically means any value from 0 up to 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 (the order of the secp256r1 base point). These numbers are then packed into some ASN.1.</p>
<p dir="auto">Although it is <em>sometimes</em> possible to tell whether an ECDSA signature was actually calculated &#34;properly&#34; rather than being some numbers we just made up (see Issue #1), there isn&#39;t a good reason for anybody other than the relying party to perform anything beyond basic validity checks. Chrome appears to check whether the numbers in the signature are actually in the range from 0 to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="9d860057dfcc06c6c609f835f8fee0ec">$n$</math-renderer>, but Firefox doesn&#39;t check even that.</p>
<p dir="auto">As a result, we can just generate some dummy ASN.1 and then put the data we actually want to send inside of it. In order to reliably get around Chrome&#39;s basic validity checks, we just waste the first byte of each number with the value 0x7f. This will result in numbers which are always positive and less than <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="9d860057dfcc06c6c609f835f8fee0ec">$n$</math-renderer>. The entire software stack up to browser JavaScript will pass these &#34;valid-enough&#34; numbers straight through.</p>
<p dir="auto">Finally, because &#34;access to USB devices&#34; is politically contentious but &#34;make users more secure&#34; has very broad political support across the entire browser industry, this capability is widely supported without requiring extraneous setup, configuration, nor prompting.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Is this a security vulnerability?</h2><a id="user-content-is-this-a-security-vulnerability" aria-label="Permalink: Is this a security vulnerability?" href="#is-this-a-security-vulnerability"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">No.</p>
<p dir="auto">This <em>cannot</em> be used to access arbitrary USB devices. It only works with devices which are <em>intentionally</em> breaking the rules. In essence, this is an intentionally vulnerable device.</p>
<p dir="auto"><em>However</em>, it is known that the security model around USB devices is generally... questionable on most platforms. Plugging in a malicious USB device allows it to do anything that you yourself can do with devices such as a keyboard or a mouse.</p>
<p dir="auto">Do not plug arbitrary unknown devices into your computer (or your phone, etc.).</p>
</article></div></div>
  </body>
</html>
