<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nibblestew.blogspot.com/2025/03/writing-your-own-c-standard-library.html">Original</a>
    <h1>Writing your own C&#43;&#43; standard library from scratch</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-7528406150771042207" itemprop="description articleBody">
<p>The C++ standard library (also know as the STL) is, without a doubt, an astounding piece of work. Its scope, performance and incredible backwards compatibility have taken decades of work by many of the world&#39;s best programmers. My hat&#39;s off to all those people who have contributed to it.</p><p>All of that is not to say that it is not without its problems. The biggest one being the absolutely abysmal compile times but unreadability, and certain unoptimalities caused by strict backwards compatibility are also at the top of the list. In fact, it could be argued that most of the things people really dislike about C++ are features of the STL rather than the language itself. Fortunately, using the STL is not mandatory. If you are crazy enough, you can disable it completely and build your own standard library in the best Bender style.</p><p>One of the main advantages of being an unemployed-by-choice open source developer is that you can do all of that if you wish. There are no incompetent middle damagers hovering over your shoulder to ensure you are &#34;producing immediate customer value&#34; rather than &#34;wasting time on useless polishing that does not produce immediate customer value&#34;.</p><p>It&#39;s <i>my</i> time, and I&#39;ll waste it if I want to!</p><p>The biggest design questions of a standard library are scope and the &#34;feel&#34; of the API. Rather than spending time on design, we steal it. Thus, when in doubt, read the Python stdlib documentation and replicate it. Thus the name of the library is <span>pystd</span>.</p><p>To keep the scope meaningful, we start by writing only enough of stdlib to build an app that reads a text file, validates it as UTF-8, splits the contents into words, counts how many time each word appears in the file and prints all words and how many times it appears sorted by decreasing count.</p><p>This requires, at least:</p><ul><li>File handling</li><li>Strings</li><li>UTF8 validation</li><li>A hash map</li><li>A vector</li><li>Sorting</li></ul><p>The code is available in <a href="https://github.com/jpakkane/pystd">this Github repo</a> for those who want to follow along at home.</p><p>Disabling the STL is fairly easy (with Linux+GCC at least) and requires only these two Meson statements:</p><blockquote><p><span><span>add_global_arguments(&#39;-nostdinc++&#39;, language: &#39;cpp&#39;)
</span></span></p></blockquote><p>The <span>supc++</span> library is (according to stackoverflow) a support library GCC needs to implement core language features. Now the stdlib is off and it is time to implement everything with sticks, stones and duct tape.</p><p>Once you have implemented everything discussed above and auxiliary stuff like a hashing framework the main application looks like this.</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiEpKmdPLSQOlvqiROHQIOEFf96ejCzNHnIReu06sLvUVAtlIcenIWOKCBcT0smhJHsxktrgR63nzQsU3ZrW_-JNnwd3b-rOw-nn6pEilsioc-G2LuMKR4LHYnbUOAo_uVfRRBpFgyEMv_z7vEHbAkFwovyH_RWWPd6-A6sk9qlZeLOKl6Dgczt8ORMBeo/s728/pystd_main.png"><img data-original-height="529" data-original-width="728" height="233" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiEpKmdPLSQOlvqiROHQIOEFf96ejCzNHnIReu06sLvUVAtlIcenIWOKCBcT0smhJHsxktrgR63nzQsU3ZrW_-JNnwd3b-rOw-nn6pEilsioc-G2LuMKR4LHYnbUOAo_uVfRRBpFgyEMv_z7vEHbAkFwovyH_RWWPd6-A6sk9qlZeLOKl6Dgczt8ORMBeo/s320/pystd_main.png" width="320"/></a></p><p>The end result is both Valgrind and Asan clean. There is one chunk of unreleased memory, but that comes from <span>supc++</span>. There is probably UB in the implementation. But it should be the good kind of UB that, if it would actually not work, would break the entire Linux userspace because <i>everything</i> depends on it working &#34;as expected&#34;.</p><p>All of this took fewer than 1000 lines of code in the library itself (including a regex implementation that is not actually used). For comparison merely including <span>vector</span> from the STL brings in 27 thousand lines of code.</p><p>Converting this code to use the STL is fairly simple and only requires changing some types and fine tuning the API.  The main difference is that the STL version does not validate that the input is UTF-8 as there is no builtin function for that. Now we can compare the two.</p><p>Runtime for both is 0.001 to 0.002 seconds on the small test file I used. Pystd is not noticeably slower than the STL version, which is enough for our purposes. It almost certainly scales worse because there has been zero performance work on it.</p><p>Compiling the pystd version with <span>-O2</span> takes 0.3 seconds whereas the STL version takes 1.2 seconds. The measurements were done on a Ryzen 7 3700X processor. </p><p>The executable&#39;s unstripped size is 349k for STL and 309k for pystd. The stripped sizes are 23k and 135k. Approximately 100 k of the pystd executable comes from <span>supc++</span>. In the STL version that probably comes dynamically from <span>libstdc++</span> (which, on this machine, takes 2.5 MB).</p><p>Designing a standard library is exceedingly difficult because you can&#39;t ever really change it. Someone, somewhere, is depending on every misfeature in it so they can never be changed.</p><p>Pystd has been designed to both support perfect ABI stability <i>and</i> make it possible to change it in arbitrary ways in the future. If you start from scratch this turned out to be fairly simple.</p><p>The sample code above used the <span>pystd</span> namespace. It does not actually exist. Instead it is defined like this in the cpp file:</p><blockquote><p><span>#include &lt;pystd2025.hpp&gt;</span> </p></blockquote><blockquote><p><span>namespace pystd = pystd2025;</span></p></blockquote><p>In pystd all code is in a namespace with a year and is stored in a header file with the same year. The idea is, then, that every year you create a new release. This involves copying all stdlib header files to a file with the new year and regexping the namespace declarations to match. The old code is now frozen forever (except for bug fixes) whereas the new code can be changed at will because there are <i>zero existing lines of code that depend on it</i>.</p><p>End users now have the choice of when to update their code to use newer pystd versions. Even better, if there is an old library that can not be updated, any of the old versions can be used in parallel. For example:</p><p><span>pystd2030::SomeType foo;</span></p><p>Thus if no code is ever updated, everything keeps working. If all code is updated at once, everything works. If only parts of the code are updated, things can still be made to work with some glue code. This puts the maintenance burden on the people whose projects can not be updated as opposed to every other developer in the world. This is as it should be, and also would motivate people with broken deps to spend some more effort to get them fixed.</p>

</div></div>
  </body>
</html>
