<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alloc.dev/2025/05/29/learning_c3">Original</a>
    <h1>Learning C3</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div id="introduction">
            
            <p>
                In this article, I describe my experience learning the <a href="https://c3-lang.org/" target="_blank">C3</a> programming language.
            </p>
            <p>
                I&#39;ve always been an avid computer programmer. I would say that I am most familiar with low level systems
                languages, though I have dipped into other programming languages from time to time. My journey here is
                motivated by curiosity. I am always curious to try new programming languages, which has resulted in
                learning a dozen or so within the past few years.
            </p>
            <p>
                With each new programming language I learn, I encounter a never-before-seen paradigm. Each language has
                it&#39;s own method of expressing ideas, and it&#39;s own status-quo for solving problems. I hope to learn what
                this means for C3, and what projects I would be likely to use it for.
            </p>
            <p>
                Here&#39;s the disclaimer: I&#39;m writing this article in &#34;real-time&#34;, which is to say I am typing it up as I
                am learning C3. This means that I may have added insights about pain points and neat features that get
                glossed over or forgotten in other articles, yet it may also mean that my explanations and conceptual
                grasp of the language is reduced or faulty compared to other sources.
            </p>
        </div>

        

        <div id="what_is_c3">
            <h2> What is C3? </h2>
            <p>
                According to the C3 website, C3 aims to build on and with C. It offers ergonomics, optimizations, and
                features. Some of these features may be difficult or impossible to express in standard C. These features
                include a module system, operator overloading, generics, compile time execution, semantic macros,
                an integrated build system, error handling, <code>defer</code>, value methods, associated enum data,
                distinct types &amp; subtypes, gradual contracts, built-in slices, <code>foreach</code>, dynamic calls &amp;
                types, <a href="https://c3-lang.org/getting-started/" target="_blank">and more</a>.
            </p>
            <p> Here are two other perspectives on what C3 is: </p>
            <p><img alt="C3 creator: &#39;C3 is an evolution on C&#39;" src="https://alloc.dev/2025/05/29/c3_desc_1.webp" width="100%"/>
            <img alt="FoxKiana: &#39;awesome sauce&#39; and &#39;epic&#39;" src="https://alloc.dev/2025/05/29/c3_desc_0.webp" width="100%"/></p><p> Thank you to FoxKiana and the C3 creator Christoffer Lernö for replying :) </p>
        </div>

        <div id="language_overview">
            <h2> Language Overview: </h2>
            <p>
                It&#39;s hard for me to picture what the language is like without clear examples. For this section I will
                review the language reference online and share my thoughts on the language features C3 offers. I will
                not cover each and every feature of C3, as this isn&#39;t meant to be an introduction to C3.
            </p>

            <h3 id="hello_world"> Hello World: </h3>
            <pre><code>import std::io;

fn void main()
{
    io::printn(&#34;Hello, World!&#34;);
}</code></pre>
            <p>
                Hello world seems pretty straightforward. I can immediately see this reminds me of C, although I
                personally prefer having the opening brackets on the same line as the function declaration. In any case,
                it&#39;s best to follow the status-quo here as it helps you understand other C3 code, and helps other C3
                developers understand your code.
            </p>
            <p>
                Something to note about importing modules - According to the <a href="https://c3-lang.org/language-fundamentals/modules/#importing-modules" target="_blank">modules
                    page</a>, imports will recursively import submodules. C of course would do the same, and you might
                end up needing to deal with name collisions by renaming things deep down the <code>#include</code>
                chain. C3 fixes the name collision issue by requiring you to use a more full case to resolve collisions.
                For example, you would use <code>abc::Context</code> instead of <code>Context</code> if both imported
                modules <code>abc</code> and <code>de</code> have a structure named <code>Context</code>.
            </p>
            <p>
                I find it curious that the language requires the <code>fn</code> keyword to define the function here. I
                would think that the language could get away with avoiding that keyword like C does. On further thought,
                perhaps it is better to be more explicit that this is a function. Some reasons this may be is that the
                function declaration syntax could be used elsewhere, or C3 could allow nested function declarations. The
                first possibility seems more likely than the second, given that C3 is an evolution of C.
            </p>
            <p>
                The <a href="https://c3-lang.org/standard-library/#void-printx-void-printnx-" target="_blank">standard
                    print function</a> will print most types that are passed to it. That seems pretty nice! Definitely a
                step-up from C here. I can imagine that <code>print</code> debugging works great in this language.
            </p>
            <p>
                Taking a look at <a href="https://c3-lang.org/standard-library/#usz-printfstring-format-args-maydiscard" target="_blank">formatted printing</a>, it seems that C3 resembles C quite a bit here. For the
                <code>printf</code> function, <code>%s</code> is still used for strings, <code>%d</code> is still used
                for decimals, <code>%f</code> is still used for floats. Truly C3 is easing the transition for C
                programmers. Something unique to note here - it seems that the string formatter (<code>%s</code>) can be
                used to format certain non-string types as well - so an enum of type <code>Heat</code> with a value of
                <code>REALLY_WARM</code> would format itself as <code>REALLY_WARM</code> when you use the
                <code>%s</code> formatter.
            </p>

            <h3 id="foreach_loops"> <code> foreach </code> loops: </h3>
            <pre><code>// Prints the values in the slice.
fn void example_foreach(float[] values)
{
    foreach (index, value : values)
    {
        io::printfn(&#34;%d: %f&#34;, index, value);
    }
}

// Updates each value in the slice by multiplying it by 2.
fn void example_foreach_by_ref(float[] values)
{
    foreach (&amp;value : values)
    {
        *value *= 2;
    }
}</code></pre>
            <p>
                Hold up, hold up. <a href="https://c3-lang.org/implementation-details/specification/#foreach-and-foreach_r-statements" target="_blank">C3 has foreach</a>? That is interesting. According to the docs, <code>break</code>
                and <code>continue</code> work as you would expect. Iteration by reference is accomplished by prepending
                a <code>&amp;</code> (ampersand) to the variable name, as shown in the second example above. To me, foreach
                feels higher level than normal <code>for</code>. Don&#39;t misunderstand me - I love using foreach in other
                languages; the added syntax better expresses your intent, reducing logic errors. It did jump out at me
                as &#34;this isn&#39;t C&#34; though.
            </p>

            <h3 id="while_loops"> <code> while </code> loops: </h3>
            <pre><code>// while loops are again the same as in C
int a = 10;
while (a &gt; 0)
{
    a--;
}

// while loops can declare variables
while (Point* p = getPoint())
{
    // ..
}</code></pre>
            <p>
                Before C99, you had to declare the <code>for</code> loop variable outside of the <code>for</code> loop.
                As far as I know, you cannot declare variables inside of the <code>while</code> loop condition in C. It
                is nice to see the change here.
            </p>

            <h3 id="enum_and_switch"> <code> enum </code> types and <code> switch </code> statements: </h3>
            <pre><code>enum Height : uint
{
    LOW,
    MEDIUM,
    HIGH,
}

fn void demo_enum(Height h)
{
    switch (h)
    {
        case LOW:
        case MEDIUM:
            io::printn(&#34;Not high&#34;);
            // Implicit break.
        case HIGH:
            io::printn(&#34;High&#34;);
    }

    // This also works
    switch (h)
    {
        case LOW:
        case MEDIUM:
            io::printn(&#34;Not high&#34;);
            // Implicit break.
        case Height.HIGH:
            io::printn(&#34;High&#34;);
    }

    // Completely empty cases are not allowed
    switch (h)
    {
        case LOW:
            break; // Explicit break required, since switches can&#39;t be empty
        case MEDIUM:
            io::printn(&#34;Medium&#34;);
        case HIGH:
            break;
    }

    // special checking of switching on enum types
    switch (h)
    {
        case LOW:
        case MEDIUM:
        case HIGH:
            break;
        default:    // The compiler warns that all values are already handled
            break;
    }

    // Using &#34;nextcase&#34; will fallthrough to the next case statement,
    // and each case statement starts its own scope.
    switch (h)
    {
        case LOW:
            int a = 1;
            io::printn(&#34;A&#34;);
            nextcase;
        case MEDIUM:
            int a = 2;
            io::printn(&#34;B&#34;);
            nextcase;
        case HIGH:
            // a is not defined here
            io::printn(&#34;C&#34;);
    }
}</code></pre>
            <p>
                C3 resembles C a lot here. I appreciate the implicit <code>break</code> that it offers. I&#39;ll have to see
                when I install the compiler, but I feel I would frequently confuse myself here with these implicit /
                explicit <code>break</code> rules. Perhaps C3 would benefit from polarizing itself a bit more. It would
                make more sense to me if all breaks were implicit (requiring <code>nextcase</code> for all multi-case
                scopes), or explicit. That being said, my initial view will surely adapt to fit the language when I
                start writing it for myself.
            </p>
            <p>
                After a short discussion in <a href="https://discord.gg/5WSNhWBxWq" target="_blank">the C3 discord
                    server</a>, (specifically <a href="https://discord.com/channels/650345951868747808/650345952468795425/1376676029258797077" target="_blank">this message</a>,) the power of <code>nextcase</code> was further emphasized:
            </p>
            <pre><code>int n = (count + 7) / 8;
switch (count % 8)
{
  case 0: *to++ = *from++; nextcase;
  case 7: *to++ = *from++; nextcase;
  case 6: *to++ = *from++; nextcase;
  case 5: *to++ = *from++; nextcase;
  case 4: *to++ = *from++; nextcase;
  case 3: *to++ = *from++; nextcase;
  case 2: *to++ = *from++; nextcase;
  case 1: *to++ = *from++; if (--n &gt; 0) nextcase 0;
}</code></pre>
            <p>
                Yes, that is <a href="https://en.wikipedia.org/wiki/Duff&#39;s_device" target="_blank">duff&#39;s device</a> in
                C3! No ugly hacks here, the <code>nextcase</code> keyword supports a (possibly runtime) case, as if
                <code>switch</code> were a jump table. Additionally, the <code>@jump</code> attribute will force the
                optimizing compiler to turn the switch into a jump table, if it did not already do that. I&#39;m pleased to
                note that C3 had this capability *before* Zig. I wish that more languages had this &#34;jump table&#34; view of
                switch statements.
            </p>

            <h3 id="defer_keyword"> <code> defer </code> keyword: </h3>
            <pre><code>fn void test(int x)
{
    defer io::printn();
    defer io::print(&#34;A&#34;);
    if (x == 1) return;
    {
        defer io::print(&#34;B&#34;);
        if (x == 0) return;
    }
    io::print(&#34;!&#34;);
}

fn void main()
{
    test(1); // Prints &#34;A&#34;
    test(0); // Prints &#34;BA&#34;
    test(10); // Prints &#34;B!A&#34;
}</code></pre>
            <p>
                Ahh, the <a href="https://c3-lang.org/language-overview/examples/#defer" target="_blank">defer</a>
                keyword. I&#39;ve enjoyed this feature immensely in <a href="https://ziglang.org/" target="_blank">other
                    languages</a>. If you have never worked with <code>defer</code> before, then you are missing out!
                The feature allows for some amazing control flow capabilities. Essentially, all defer statements are
                invoked in reverse order on scope exit. They are primarily used to clean up resources that you have. I
                find the keyword is much easier to remember, as you always put a <code>defer</code> after claiming a
                resource that is only used in the current scope. Without the keyword, you are stuck remembering to clean
                up your resources at every possible scope exit point. In C, this frequently meant that there was a block
                at the end of the function with a <code>goto</code> label for cleaning up function resources. 10x better
                than C here.
            </p>
            <p>
                On further investigation, it seems like the common constructs <code>errdefer</code> and
                <code>okdefer</code> can be represented with <code>defer catch</code> and <code>defer try</code>
                respectively. This will be pleasant to use.
            </p>

            <h3 id="struct_type"> <code> struct </code> types: </h3>
            <pre><code>alias Callback = fn int(char c);

enum Status : int
{
    IDLE,
    BUSY,
    DONE,
}

struct MyData
{
    char* name;
    Callback open;
    Callback close;
    Status status;

    // named sub-structs (x.other.value)
    struct other
    {
        int value;
        int status;   // ok, no name clash with other status
    }

    // anonymous sub-structs (x.value)
    struct
    {
        int value;
        int status;   // error, name clash with other status in MyData
    }

    // anonymous union (x.person)
    union
    {
        Person* person;
        Company* company;
    }

    // named sub-unions (x.either.this)
    union either
    {
        int this;
        bool  or;
        char* that;
    }
}</code></pre>
            <p>
                After a minute or two, it seems more obvious how this works. It appears that the &#34;sub structs&#34; aren&#39;t
                types, but an expression for how the data is stored / accessed with the structure. The anonymous
                <code>union</code> inside of the structure is of particular note; it seems to me that they offer a
                really clean way of implenting a <a href="https://en.wikipedia.org/wiki/Tagged_union" target="_blank">tagged union</a>. You would only need to have an <code>enum</code> and anonymous
                <code>union</code> in your struct do do so!
            </p>
            <p>
                C allows you to do essentially the same thing here, but I rarely used unions inside of my structures
                like this. Perhaps I need to <a href="https://www.acepace.net/integerQuiz/" target="_blank">brush up on
                    my C</a>.
            </p>

            <h3 id="error_handling"> Error handling: </h3>
            <p>
                The <a href="https://c3-lang.org/language-common/optionals-essential" target="_blank">error handling
                    page</a> of the C3 website is very thorough. Below I have summarized what I have learned in a
                collection of C3 code snippets:
            </p>
            <pre><code>// Optional types are suffxed with a ?
int? a = 1; // Set the Optional to a result</code></pre>
            <pre><code>// When an Optional is empty it has an Excuse explaining what happened.
int? b = io::FILE_NOT_FOUND?; // Set the Optional to an Excuse type of &#34;fault&#34;</code></pre>
            <pre><code>// Faults are defined using the faultdef keyword
faultdef OOPS, LOTS_OF_OOPS, USER_ERROR;</code></pre>
            <pre><code>// This function returns an Optional integer
fn int? get_value();</code></pre>
            <pre><code>// Return an Excuse by adding &#39;?&#39; after the fault.
return io::FILE_NOT_FOUND?;</code></pre>
            <pre><code>// Check if an Optional is empty with &#34;catch&#34;
if (catch excuse = get_value()) // ...</code></pre>
            <pre><code>// If the scope is escaped after checking an Optional, the variable is
// automatically unwrapped for the remainder of the scope.
int? foo = unreliable_function();
if (catch excuse = foo) return excuse?; // Return excuse with the &#39;?&#39; operator
io::printfn(&#34;foo: %s&#34;, foo); // foo is guaranteed to be of type &#34;int&#34; here</code></pre>
            <pre><code>int foo = maybe_function()!;
// The rethrow operator &#34;!&#34; above is equivalent to the following:
int? foo = maybe_function();
if (catch excuse = foo) return excuse?;</code></pre>
            <pre><code>// Optionals in expressions produce optionals
int? first_optional = 7;
// &#34;int?&#34; is required for the type below, unless unwrapped (maybe implicitly)
int? second_optional = first_optional + 1;</code></pre>
            <pre><code>// Optionals affect function return types
fn int test(int input) // ... omitted for brevity ...
int? optional_argument = 7;
int? returned_optional = test(optional_argument);
// The fuction is shortcut if any of it&#39;s non-Optional arguments can&#39;t be so</code></pre>
            <p>
                There&#39;s a lot to unpack here. It took me a while to understand how these optional types work. C3 seems
                to combine the roles of &#34;error unions&#34; and &#34;optional types&#34;. In Zig this would be
                <code>error{SomeError}!i32</code> and <code>?i32</code>, while in Rust this would be
                <code>Result&lt;i32, SomeError&gt;</code> and <code>Option&lt;i32&gt;</code>.
            </p>
            <p>
                This language decision will impact the way I think about error handling. I typically imagine &#34;optional
                types&#34; in these scenarios:
            </p>
            <ol>
                <li> A function can sometimes return a value. (eg. polling for some data)</li>
                <li> A stateful iterator function needs to mark when it is empty / completed. </li>
                <li> A lookup function fails to find a match. (eg. <code>hashmap.get()</code>) </li>
            </ol>
            <p> I likewise imagine &#34;error unions&#34; in these scenarios: </p>
            <ol>
                <li> A function is expected to return, but can fail. (eg. memory allocation) </li>
                <li> A function requires certain specified input, and reports invalid inputs. </li>
                <li> A property that is assumed to be true is false. (eg. runtime assertions) </li>
            </ol>
            <p>
                With the roles combined, It seems harder to differentiate functions that are *expected* to return a
                value, versus functions that *can* return a value. While this is certainly a con, I would say that one
                pro of this approach is that you can avoid worrying about the distinction of the two split types when
                you are handling the return values of functions.
            </p>

            <h3 id="contracts"> Contracts: </h3>
            <pre><code>&lt;*
 @require foo != null
 @ensure return &gt; foo.x
*&gt;
fn uint check_foo(Foo* foo)
{
    uint y = abs(foo.x) + 1;
    // If we had row: foo.x = 0, then this would be a runtime contract error.
    return y * abs(foo.x);
}</code></pre>
            <p>
                <a href="https://c3-lang.org/language-common/contracts/" target="_blank">C3 has support</a> for <a href="https://en.wikipedia.org/wiki/Precondition" target="_blank">preconditions</a> and <a href="https://en.wikipedia.org/wiki/Postcondition" target="_blank">postconditions</a>. These
                contracts are kept inside of <code>&lt;*</code> and <code>*&gt;</code> symbols. According to the C3
                website, this is a type of comment which is parsed. I have mixed feelings here. I personally think that
                a language only needs some well-placed (possibly runtime) asserts to handle inputs &amp; outputs. As noted
                on the website, these contracts allow for more than just runtime assertions. C3 will propagate these
                conditions up the call chain, and analyze them during compile time folding. C3 does not currently
                perform static analysis *beyond* compile-time folding though.
            </p>
            <p>
                It feels a bit strange to me that the language has this third method of comments, given that many
                programming languages have only one or two comment types. This is trivial though, I expect that I will
                easily adapt.
            </p>

            <h3 id="struct_methods"> <code> struct </code> methods: </h3>
            <pre><code>struct Foo
{
    int i;
}

fn void Foo.next(Foo* this)
{
    if (this) this.i++;
}

fn void test()
{
    Foo foo = { 2 };
    foo.next();
    foo.next();
    // Prints 4
    io::printfn(&#34;%d&#34;, foo.i);
}</code></pre>
            <p>
                Namespaced &amp; dot-syntax functions are a thing, apparently. They work on unions, structs, and enums
                <code>[EDIT: They work on *any* type, including primitives!]</code>. This is another strict improvement
                over C, and
                I&#39;ve enjoyed using them in other languages.
            </p>

            <h3 id="macros"> <code>macro</code>s: </h3>
            <p>
                Macros are a bag of worms. Sure, they can be a great source of protein, but will you really see me
                eating them? I might use worms when I&#39;m fishing, but I don&#39;t see much use for them around the home. To
                express my opinion outside of a metaphor: macros have niche use cases, are good at what they do, but
                shouldn&#39;t be abused. One example of this abuse would be making a turing-complete domain-specific
                language inside of some macro-supporting programming language.
            </p>
            <p>
                I won&#39;t dive too far into <a href="https://c3-lang.org/generic-programming/macros/" target="_blank">the
                    complexities</a> of C3&#39;s macros, but here&#39;s a brief overview of what I learned:
            </p>
            <ul>
                <li> C3 macros act similar to C macros; they can be evaluated at compile-time. </li>
                <li> Macros can look like functions, but use <code>macro</code> instead of <code>fn</code>. </li>
                <li> Macros can&#39;t act in their caller&#39;s scope, so no declaring variables. </li>
                <li> Macros avoid the nasty <code>\</code> used for trailing macro lines in C. </li>
                <li> Macro parameters can be prefixed with <code>$</code>, meaning they are compile-time known. </li>
                <li>
                    Macro parameters can be prefixed with <code>#</code>, meaning the expression isn&#39;t yet evaluated.
                    When a variable is passed to a macro this way, it is evaluated once, then used directly where the
                    parameter is referenced. Pretty smart!
                </li>
                <li>
                    User-defined macros which use <code>$</code> or <code>#</code> parameters must be prefixed with
                    <code>@</code>. I like this - it means I can be confident whether a macro will screw up my AST.
                </li>
                <li>
                    C3 macros <a href="https://c3-lang.org/generic-programming/macros/#macro-vaargs" target="_blank">may
                        have</a> a <a href="https://en.wikipedia.org/wiki/Variadic_function" target="_blank">variable
                        number of parameters</a>.
                </li>
                <li>
                    Macros with only compile-time variables are completely evaluated at compile-time. This guarantee is
                    solid. As far as I know, C doesn&#39;t ensure this itself. Yes, it will expand all of your macros, but
                    the evaluation of the parts is up to the specific compiler you are using. As an extension to this,
                    type reflection and compile-time execution in the language is handled exclusively via macros.
                </li>
            </ul>
            <p>
                Ok, that actually wasn&#39;t too bad. I guess I still have some stress from handling cursed macros in other
                language, such as Rust. Too much power and someone is bound to misuse it. C3 macros don&#39;t have quite the
                AST manipulation power of C, but they do have some really nice features in terms of compile-time
                evaluation. In my opinion, the macros in C3 are a good fit.
            </p>

            <h3 id="type_properties"> Type Properties: </h3>
            <p>
                C3 <a href="https://c3-lang.org/language-overview/types/#compile-time-properties" target="_blank">has
                    built-in properties</a> for all types. These properties are avaliable through <code>.method</code>
                syntax. Some types have their own specific properties, yet there are a baker&#39;s dozen that all types
                share. Here they are:
            </p>
            <ol>
                <li> <code>alignof</code> - The standard alignment of the type in bytes. </li>
                <li>
                    <code>kindof</code> - The category of type, e.g. <code>TypeKind.POINTER</code> /
                    <code>TypeKind.STRUCT</code>.
                </li>
                <li> <code>extnameof</code> - Returns a string with the extern name of the type, rarely used. </li>
                <li> <code>nameof</code> - Returns a string with the unqualified name of the type. </li>
                <li> <code>qnameof</code> - Returns a string with the qualified name of the type. </li>
                <li> <code>sizeof</code> - Returns the storage size of the type in bytes. </li>
                <li> <code>typeid</code> - Returns a runtime typeid for the type. </li>
                <li> <code>methodsof</code> - Retuns the methods implemented for a type. </li>
                <li> <code>has_tagof(tagname)</code> - Returns true if the type has a particular tag. </li>
                <li> <code>tagof(tagname)</code> - Retrieves the tag defined on the type. </li>
                <li> <code>is_eq</code> - True if the type implements <code>==</code>. </li>
                <li> <code>is_ordered</code> - True if the type implements comparisons. </li>
                <li> <code>is_substruct</code> - True if the type has an inline member. </li>
            </ol>
            <p>
                These properties appear to be very helpful for metaprogramming. In the Zig language, one would need to
                use <code>@typeInfo</code> on the type to get this information. I imagine that it would be harder for me
                to realize that type reflection is occuring in the code, however alluring the ease of access.
            </p>

            <h3 id="base64_strings"> Base64 &amp; Hex Literals: </h3>
            <p>
                C3 supports <a href="https://c3-lang.org/language-overview/types/#base64-and-hex-data-literals" target="_blank">base64 and hex data literals</a>. Personally I don&#39;t see the appeal, as <a href="https://c3-lang.org/generic-programming/compiletime/#embed" target="_blank">the
                    <code>$embed</code> macro</a> would fulfill my common use-case for this. I imagine that a macro
                could accomplish the same thing as these types of literals. Honestly not too happy about this feature, I
                think it&#39;s trying to add language sugar for something that isn&#39;t often used.
            </p>
            <pre><code>char[*] hello_world_base64 = b64&#34;SGVsbG8gV29ybGQh&#34;;
char[*] hello_world_hex = x&#34;4865 6c6c 6f20 776f 726c 6421&#34;;</code></pre>
            <p>
                While not quite as bad as Rust, I do feel hesitant about the string situation overall in C3. I agree a
                lot with the C &amp; Zig approach that &#34;all strings are just bytes&#34;, rather than different syntaxes and
                types for representing the encoding or capability of a string type.
            </p>

            <h3 id="primitives"> Primitives: </h3>
            <p>
                C3 has several primitive types. These include integers, booleans, and floats. The types are essentially
                equal to C, except <code>char</code> is defined to be unsigned. That&#39;s a big pro, considering C leaves
                char signedness up to the compiler. There are additionally 128 bit integers <code>int128</code> and
                <code>uint128</code>, which are also pleasant to see. It&#39;s not often that you reach for a 128 bit
                integer, but when you do, you appreciate it.
            </p>
            <p>
                C3 has the types <code>iptr</code>, <code>uptr</code>, <code>isz</code>, and <code>usz</code>. They are
                signed respectively according to the letter prefix, whether it be <code>i</code> or <code>u</code>. I
                feel these types are a bit shorter than they should be. The keystrokes that are saved by typing two or
                three fewer letters don&#39;t quite outweigh the cost of reading the code, at least for someone who is
                unfamiliar with the notation.
            </p>
            <p>
                I do appreciate that the bit size of the other primitive types are well defined - it offers another
                improvement over C, where your <code>int</code> could be as small as 16 bits.
            </p>

            <h3 id="much_more"> Much More: </h3>
            <p>
                The C3 language additionally has <a href="https://c3-lang.org/generic-programming/operator-overloading/" target="_blank">operator overloading</a> (pretty great imo), <a href="https://c3-lang.org/language-overview/types/#struct-subtyping" target="_blank">struct
                    subtyping</a> (a bit confusing), <a href="https://c3-lang.org/generic-programming/generics/" target="_blank">generics</a> (seems unclear, as the generic parameters are detatched from the type),
                <a href="https://c3-lang.org/generic-programming/anyinterfaces/" target="_blank">runtime dynamic
                    dispatch</a> (no opinion), <a href="https://c3-lang.org/language-overview/types/#the-any-type" target="_blank">the <code>any</code> type</a> (absolutely amazing idea, I love it!), <a href=" https://c3-lang.org/language-overview/types/#typedef---distinct-type-definitions" target="_blank">distinct types</a> (nitpick: why not use <code>distinct</code> instead of
                <code>typedef</code>?), <a href="https://c3-lang.org/language-overview/types/#bitstructs" target="_blank">bitstructs</a> (awesome imo), and <a href="https://discord.com/channels/650345951868747808/650345952468795425/1376784774676615199" target="_blank">more (link about optionals)</a>.
            </p>
            <p> Feel free to dive more into C3. For now, I&#39;ll continue. </p>
        </div>

        <div id="first_steps">
            <h2> First Steps: </h2>

            <h3 id="installing_c3"> Installing C3: </h3>
            <p>
                The C3 website provides <a href="https://c3-lang.org/getting-started/prebuilt-binaries/" target="_blank">helpful installing instructions</a> for the compiler binary. Unfortunately for C3,
                not many people use it yet. I couldn&#39;t find any package for it on gentoo, so I&#39;ll probably build it from
                source.
            </p>
            <p>
                <a href="https://c3-lang.org/getting-started/compile/" target="_blank">Compiling the C3 compiler</a> is
                surprisingly simple:
            </p>
            <pre><code>git clone https://github.com/c3lang/c3c.git
cd c3c
mkdir build
cd build
cmake ..
make</code></pre>
            <p>
                As long as I have LLVM and LLD installed it should work, right?
            </p>
            <pre><code>CMake Error: The following variables are used in this project, but they are set to NOTFOUND.
Please set them or make sure they are set and tested correctly in the CMake files:
LLD_COFF
    linked by target &#34;c3c&#34; in directory /home/retrodev/repos/C3/c3c
    linked by target &#34;c3c_wrappers&#34; in directory /home/retrodev/repos/C3/c3c
LLD_COMMON
    linked by target &#34;c3c&#34; in directory /home/retrodev/repos/C3/c3c
    linked by target &#34;c3c_wrappers&#34; in directory /home/retrodev/repos/C3/c3c
LLD_ELF
    linked by target &#34;c3c&#34; in directory /home/retrodev/repos/C3/c3c
    linked by target &#34;c3c_wrappers&#34; in directory /home/retrodev/repos/C3/c3c
LLD_MACHO
    linked by target &#34;c3c&#34; in directory /home/retrodev/repos/C3/c3c
    linked by target &#34;c3c_wrappers&#34; in directory /home/retrodev/repos/C3/c3c
LLD_MINGW
    linked by target &#34;c3c&#34; in directory /home/retrodev/repos/C3/c3c
    linked by target &#34;c3c_wrappers&#34; in directory /home/retrodev/repos/C3/c3c
LLD_WASM
    linked by target &#34;c3c&#34; in directory /home/retrodev/repos/C3/c3c
    linked by target &#34;c3c_wrappers&#34; in directory /home/retrodev/repos/C3/c3c

-- Generating done (0.0s)
CMake Generate step failed.</code></pre>
            <p> Haha nope. Let&#39;s check to make sure I actually have LLD installed: </p>
            <pre><code>*  llvm-core/lld
      Latest version available: 20.1.5
      Latest version installed: 20.1.5
      Size of files: 143789 KiB
      Homepage:      https://llvm.org/
      Description:   The LLVM linker (link editor)
      License:       Apache-2.0-with-LLVM-exceptions UoI-NCSA</code></pre>
            <p>
                Well that&#39;s not great! The build script detected LLVM just fine, but couldn&#39;t find LLD for some reason.
                <a href="https://discord.com/channels/650345951868747808/927010276128202762/1377003877492068464" target="_blank">I can probably use</a> <code>-DLLVM_DIR=...</code> and <code>-DLLD_DIR=...</code>
                with cmake to ensure it knows where they are installed.
            </p>
            <p>
                For a while I couldn&#39;t understand why cmake wasn&#39;t working here. And yes, the solutions just mentioned
                did nothing. <a href="https://youtu.be/gakX1m9oJhQ" target="_blank">Some time later</a> I realized that
                my LLD installation did not include the LLD libraries which C3 relies on, so the problem is on my end.
                Instead of building LLD from source to get the required LLD libraries, I decided to just go the cheap
                route and download the C3 compiler build for my laptop:
            </p>
            <pre><code>retrodev@lime ~ $ c3c --version
c3c: /usr/lib64/libtinfo.so.6: no version information available (required by c3c)
C3 Compiler Version:       0.7.1
Installed directory:       /home/retrodev/repos/C3/c3/
Git Hash:                  c5494a23ce18ad16a382774a2f360c94b1515e3f
Backends:                  LLVM
LLVM version:              17.0.6
LLVM default target:       x86_64-pc-linux-gnu</code></pre>
            <p>
                Ahh, much better. Seems like the C3 compiler depends on libtinfo here; I&#39;ll probably install it at some
                point just to silence the error.
            </p>

            <h3 id="new_project"> Creating a new project: </h3>
            <p>
                C3&#39;s compiler reminds me a lot of Zig&#39;s compiler. Both allow initializing projects
                (<code>c3c init</code> / <code>zig init</code>), building their respective projects
                (<code>c3c build</code> / <code>zig build</code>), and of course, compiling source files that don&#39;t
                belong to a project (<code>c3c compile</code> / <code>zig build-exe</code>). I&#39;ll use a project here.
            </p>
            <pre><code>retrodev@lime ~/repos/C3 $ c3c init hello_world
Project &#39;hello_world&#39; created.</code></pre>
            <p>
                From the <code>c3c init</code> command, we can see that a directory for the project is created,
                including a lot of files that would otherwise be boilerplate. Both <code>LICENSE</code> and
                <code>README.md</code> are empty. <code>project.json</code> contains the project configuration,
                including source files, targets to build, optimization and target settings, and more.
            </p>
            <pre><code>retrodev@lime ~/repos/C3 $ tree hello_world -a
hello_world
├── LICENSE
├── README.md
├── build
│   └── .gitkeep
├── docs
│   └── .gitkeep
├── lib
│   └── .gitkeep
├── project.json
├── resources
│   └── .gitkeep
├── scripts
│   └── .gitkeep
├── src
│   ├── .gitkeep
│   └── main.c3
└── test
    └── .gitkeep</code></pre>
            <p>
                Yep. That&#39;s kinda what I was expecting. Overall I agree that the folder structure is helpful here - it
                establishes a status-quo for new users of C3. I do find it strange that C3 would create an empty
                <code>LICENSE</code> file though. I initially expected to find a general permissive licence, and was
                surprised when <code>ls</code> displayed the file as 0 bytes. That might have bitten me if I didn&#39;t
                notice.
            </p>
            <p>
                Let&#39;s look at the generated main.c3 file:
            </p>
            <pre><code>module hello_world;
import std::io;

fn int main(String[] args)
{
    io::printn(&#34;Hello, World!&#34;);
    return 0;
}</code></pre>
            <p>
                Oh! this is pleasant. The conciceness reminds me of the default <code>main.rs</code> file from
                <code>cargo new</code>. I&#39;d consider this an improvement on Zig, which by default will create a template
                stuffed to the brim with comments and example code. Zig&#39;s template is useful for beginners, but
                painfully verbose. I also hadn&#39;t realized that C3&#39;s <code>String</code> is title case. I&#39;m not sure how
                I feel about that - it makes <code>String</code> feel more abstract than an <code>int</code>, which I
                suppose it is.
            </p>
            <p>
                Let&#39;s compile and run this:
            </p>
            <pre><code>retrodev@lime ~/repos/C3/hello_world $ c3c run
Program linked to executable &#39;build/hello_world&#39;.
Launching ./build/hello_world
Hello, World!
Program completed with exit code 0.</code></pre>
            <p>
                Fantastic. I think I&#39;m ready to dive all-in.
            </p>
        </div>

        <div id="making_calculator">
            <h2> Making a calculator with C3: </h2>
            <p>
                To better document this learning experience, I&#39;ll attempt to make a basic calculator in C3. I expect it
                to handle addition <code>+</code>, subtraction <code>-</code>, multiplication <code>*</code>, division
                <code>/</code>, negation (also <code>-</code>), exponentiation <code>^</code>, and parenthesis
                <code>( )</code>.
            </p>

            <h3 id="what_for_calc"> What will this require? </h3>
            <p>
                Writing this form of calculator will test my knowlege of C3. I will need to know how to make and call
                functions (especially for the <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank">recursive descent parser</a>), how to get user input, how to do basic math with
                floats, and how to print to the terminal. I have a rough idea of how I want the code to look like, but
                the point here is to find and document what I find amazing - and not so amazing - about my experience
                learning C3. The internet is too full of armchair experts. Only my hands-on experience will provide me
                with an opinion worth sharing.
            </p>

            <h3 id="getting_input"> Getting user input: </h3>
            <p>
                As with any language, you trip when you transition from *reading* the language to actually *using* the
                language. In this case, I had neglected to read much of the &#34;memory management&#34; documentation for C3, so
                I needed to learn how allocators are currently used in C3:
            </p>
            <pre><code>module calculator;
import std::io;

fn int main()
{
    @pool()
    {
        io::printf(&#34;Enter an equation: &#34;);
        String? equation = io::treadline();
        if (catch equation) return 1;
        io::printfn(&#34;Your equation: %s&#34;, equation);
    };
    return 0;
}
</code></pre>
            <p>
                There are currently <a href="https://discord.com/channels/650345951868747808/927010276128202762/1377463685416616036" target="_blank">two default</a> allocators used in code. (This isn&#39;t a link to the language
                reference, because it is updated by hand and this section is currently out of date.) These allocators
                are <code>tmem</code> and <code>mem</code>. <code>tmem</code> is a &#34;temporary&#34; allocator, acting as an
                <a href="https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator" target="_blank">arena
                    allocator</a>. The context for the temporary allocations is marked by the macro <code>@pool</code>.
                This macro will free items allocated with <code>tmem</code> at the end of the defined scope. Several
                functions in the C3 standard library are prefixed with &#34;t&#34;, representing that they use the temporary
                allocator under the hood. These functions are alternatives to non-prefixed functions, which take an
                allocator parameter.
            </p>
            <p>
                C3 feels like a balance of Zig and C in this instance. It is common practice in Zig to pass allocators
                to every function, so you can know what function may allocate memory, and pick the most effective
                allocator for the job. It is common in C to use only one allocator - namely the standard library
                allocator - through <code>malloc</code>, <code>calloc</code>, and <code>free</code>.
            </p>
            <p>
                One more thing to note here are the return values of functions. Many C compilers will allow you to
                create the standard <code>int main()</code> function, then allow you to omit returning a value from it.
                The compilers I am talking about will implicitly return <code>EXIT_SUCCESS</code> (0 on all systems I
                know of) for you. C3 mandates returning a value from this function. It will give me an error if I fail
                to return a value:
            </p>
            <pre><code> 1: module calculator;
 2: import std::io;
 3: 
 4: fn int main()
           ^^^^
(/home/retrodev/repos/C3/calculator/src/main.c3:4:8) Error: Missing return statement at the end of the function.</code></pre>
            <p>
                C3 will also allow me to mark the main function as <code>void</code>, so this isn&#39;t bothersome. While
                it&#39;s not standard according to ISO C, some C compilers also allow you to define the main function as
                <code>void</code>.
            </p>
            <p>
                Referencing the C3 code again, the <code>io::printf</code> and <code>io::printfn</code> functions return
                a value that the compiler does not require me to handle. C3 allows it&#39;s users to skip checking the
                return value here. This may introduce points of (admittedly very unlikely) failure into a program that
                are hard to identify, for the benefit of ease-of-programming. This is normal C behavior here. Also like
                in C, C3 will allow you to explicitly discard function return values by prefixing the function call with
                <code>(void)</code>. <code>EDIT: The functions here can be implicitly discarded because they have been annotated with @maydiscard. On the flip side, there is also @nodiscard.</code>
            </p>

            <h3 id="tokenizer"> The tokenizer: </h3>
            <p>
                So we are making a calculator? That&#39;s quite a bit to do. Let&#39;s take a bigger leap this time. Here&#39;s my
                code for tokenizing the input:
            </p>
            <pre><code>module calculator;
import std::io;
import std::collections::list;

enum TokenTag: char
{
    // Final Token
    DELIMITER,
    // Operators
    ADD,
    SUBTRACT,
    MULTIPLY,
    DIVIDE,
    POWER,
    // Operator precedence
    LEFT_PAREN,
    RIGHT_PAREN,
    // Number literal
    NUMBER,
}

struct Token
{
    TokenTag tag;
    float number;
}

faultdef INVALID_TOKEN; 

// Convert an input string into a list of tokens that define our equation
fn Token[]? tokenize(Allocator allocator, String equation)
{
    List {Token} token_list;
    token_list.tinit();
    defer token_list.free();
    
    // Scan through the string; most bytes should be one token.
    for (usz idx = 0; idx &lt; equation.len; idx += 1)
    {
        switch (equation[idx])
        {
            case &#39; &#39;: continue; // Skip whitespace
            case &#39;+&#39;: token_list.push({.tag = ADD});
            case &#39;-&#39;: token_list.push({.tag = SUBTRACT});
            case &#39;*&#39;: token_list.push({.tag = MULTIPLY});
            case &#39;/&#39;: token_list.push({.tag = DIVIDE});
            case &#39;^&#39;: token_list.push({.tag = POWER});
            case &#39;(&#39;: token_list.push({.tag = LEFT_PAREN});
            case &#39;)&#39;: token_list.push({.tag = RIGHT_PAREN});
                
            default:
                // We probably have a number - parse it:
                usz start = idx;
                usz end = idx;

                // Scan digits and radix points from this position
                for (; end &lt; equation.len; end += 1)
                {
                    char x = equation[end];
                    if (x != &#39;.&#39; &amp;&amp; (x &lt; &#39;0&#39; || x &gt; &#39;9&#39;)) break;
                }

                // This is true if we didn&#39;t parse a number
                if (start == end) return INVALID_TOKEN?;

                // Slicing indexes are inclusive on both ends
                float? number = equation[start..end - 1].to_float();
                if (catch number) return INVALID_TOKEN?;
                token_list.push({NUMBER, number});

                // Update the index so we don&#39;t re-parse the number
                idx = end - 1;
        }
    }

    token_list.push({DELIMITER, {}});
    return token_list.to_array(allocator);
}

fn int main()
{
    @pool()
    {
        io::printf(&#34;Enter an equation: &#34;);
        String? equation = io::treadline();
        if (catch equation) return 1;

        Token[]? tokens = tokenize(tmem, equation);
        if (catch tokens) return 1;

        io::printn(&#34;[&#34;);
        foreach (Token t : tokens)
        {
            io::printf(&#34;    %s&#34;, t.tag);
            if (t.tag == NUMBER) io::printf(&#34;: %f&#34;, t.number);
            io::printn(&#34;,&#34;);
        }
        io::printn(&#34;]&#34;);
    };
    return 0;
}</code></pre>
            <p>
                Ok bear with me - This was a lot of code all at once. This code essentially gets the equation from the
                user, splits that into a list of &#34;tokens&#34; (parts of the equation), then prints out those tokens. Here is
                an example program output:
            </p>
            <pre><code>Enter an equation: 2+3 * (-7/-4) ^ 3.14
[
    NUMBER: 2.000000,
    ADD,
    NUMBER: 3.000000,
    MULTIPLY,
    LEFT_PAREN,
    SUBTRACT,
    NUMBER: 7.000000,
    DIVIDE,
    SUBTRACT,
    NUMBER: 4.000000,
    RIGHT_PAREN,
    POWER,
    NUMBER: 3.140000,
    DELIMITER,
]</code></pre>
            <p> This representation of the math equation will be perfect for the parser. </p>
            <p>
                I&#39;m sorry to say that I struggled quite a bit while writing this code. A lot of my struggles were not
                due to the language itself, but the lack of features that the language server offers. Code completion
                and jumping to definitions (in the standard library) just doesn&#39;t work. This should improve as the
                language matures.
            </p>
            <p>
                One more confusing aspect of C3 is it&#39;s slicing. The syntax is of the form
                <code>some_string[start..end]</code>, where both the start and end indexes are inclusive. This isn&#39;t
                consistent with most of the other programming languages I know, and it requires that I take the end
                index (exclusive) and subtract one for the slice. It also means I have to make sure I don&#39;t accidentally
                form a slice of negative length (the check above it). One other side effect of this language design
                choice is that I can&#39;t create a slice of length 0 this way. This confuses me.
                <code>EDIT: C3 has built-in slice-by-length syntax of the form some_string[start:length], which is status-quo here.</code>
            </p>
            <p>
                To list the positives though, it is nice how convenient the <code>List</code> type is, which is supplied
                by C3&#39;s standard library. In C I normally use a prebuilt library of mine for this purpose, or I need to
                manually track my allocations, which isn&#39;t fun.
            </p>
            <p>
                The familiar C <code>for</code> loops formed the meat of the tokenizer
                algorithm, and the <code>foreach</code> loop worked great for printing out the token types! In more
                complex tokenizers I may have been able to use the advanced <code>nextcase</code> statement (my
                tokenizers / parsers seem to turn into a FSM after a while). The control flow in this language is really
                nice to use.
            </p>
            <p>
                There was one more thing I really didn&#39;t expect to find - the temporary allocator (<code>tmem</code>)
                could be used at the same time as the passed allocator for the <code>tokenize</code> function. This is
                interesting because you can use it for code that you need allocator assurances for. If I were to make
                this in Zig, I would either have to request a single allocator that worked both for the tokenization and
                return value, or request two allocators, and hope that the user would supply an efficient allocator for
                the intermediate process.
            </p>
            <p>
                Side note: I really wouldn&#39;t use Rust for it&#39;s allocator flexibility - it wasn&#39;t designed to have any
                flexibility in this area, making it hard to use with custom allocators. C3 does very well here.
            </p>
            <p> Let&#39;s finish this. </p>

            <h3 id="parser"> The parser: </h3>
            <p>
                Compared with the tokenizer, the parser was much easier to write. This is likely because I overcame the
                initial hurdle of writing code in the language. I&#39;m pretty pleased with how simple it is! Here&#39;s the
                complete program (minus the tokenizer):
            </p>
            <pre><code>module calculator;
import std::io;
import std::math;
import std::collections::list;

// TokenTag, Token, and tokenize() trimmed for conciseness

faultdef UNEXPECTED_TOKEN;

struct Parser
{
    Token[] source;
    usz index;
}

fn float? Parser.parse(Parser* p)
{
    float result = p.expression()!;
    TokenTag next_tag = p.source[p.index].tag;
    if (next_tag != DELIMITER) return UNEXPECTED_TOKEN?;
    return result;
}

// &lt;​expression&gt; ::= &lt;​term&gt; ((&#34;+&#34; | &#34;-&#34;) &lt;​term&gt;)*
fn float? Parser.expression(Parser* p)
{
    float result = p.term()!;

    switch (p.source[p.index].tag)
    {
        case ADD:
            p.index += 1;
            result += p.term()!;
            nextcase p.source[p.index].tag;
        case SUBTRACT:
            p.index += 1;
            result -= p.term()!;
            nextcase p.source[p.index].tag;
        default:
            return result;
    }
}

// &lt;​term&gt; ::= &lt;​factor&gt; ((&#34;*&#34; | &#34;/&#34;) &lt;​factor&gt;)* | &lt;​factor&gt; &lt;​term&gt;
fn float? Parser.term(Parser* p)
{
    float result = p.factor()!;

    switch (p.source[p.index].tag)
    {
        case MULTIPLY:
            p.index += 1;
            result *= p.factor()!;
            nextcase p.source[p.index].tag;
        case DIVIDE:
            p.index += 1;
            result /= p.factor()!;
            nextcase p.source[p.index].tag;
        default:
            return result;
    }
}

// &lt;​factor&gt; ::= &lt;​negation&gt; (&#39;^&#39; &lt;​factor&gt;)*
fn float? Parser.factor(Parser* p)
{
    float result = p.negation()!;
    if (p.source[p.index].tag == POWER)
    {
        p.index += 1;
        float power = p.factor()!;
        result = math::pow(result, power);
    }
    return result;
}

// &lt;​negation&gt; ::= &#34;-&#34; &lt;​negation&gt; | &lt;​number&gt;
fn float? Parser.negation(Parser* p)
{
    if (p.source[p.index].tag == SUBTRACT)
    {
        p.index += 1;
        return -p.negation()!;
    }
    return p.number();
}

// &lt;​number&gt; ::= &#39;(&#39; &lt;​expression&gt; &#39;)&#39; | &lt;​floating point number&gt;
fn float? Parser.number(Parser* p)
{
    switch (p.source[p.index].tag)
    {
        case LEFT_PAREN:
            p.index += 1;
            float result = p.expression()!;
            TokenTag next_tag = p.source[p.index].tag;
            if (next_tag != RIGHT_PAREN) return UNEXPECTED_TOKEN?;
            p.index += 1;
            return result;
        default:
            float number = p.source[p.index].number;
            p.index += 1;
            return number;
    }
}

fn int main()
{
    while (true) 
    {
        @pool()
        {
            io::printf(&#34;Enter an equation: &#34;);
            String? equation = io::treadline();
            if (catch equation) return 1;

            Token[]? tokens = tokenize(tmem, equation);
            if (catch tokens) return 2;

            Parser p = {tokens, 0};
            float? result = p.parse();
            if (catch result) return 3;

            io::printfn(&#34;Result: %f&#34;, result);
        };
    }
}</code></pre>
            <p> Let&#39;s take it for a spin. </p>
            <pre><code>Enter an equation: 2+3 * (-7/-4) ^ 3.14
Result: 19.388445</code></pre>
            <p> It works! </p>
            <p>
                Earlier in this article, I expressed some concern about the error system. With this small example, I
                found that it worked out well. I was able to write the code nearly the same as if an error would never
                occur, trusting that it would get &#34;bubbled-out&#34; in the case that someone goofed up. 100% an improvement
                on C, yet again.
            </p>
            <p>
                I also found that the <code>nextcase</code> keyword worked very well in both the <code>expression</code>
                and <code>term</code> functions. The same can be accomplished with a normal while loop with the switch,
                but this way it seems cleaner to me :)
            </p>
        </div>

        <div id="conclusion">
            <h2> Conclusion: </h2>
            <p>
                C3 reminds me of C. The flavor lingers in my mouth, yet I don&#39;t sense the same aftertaste. It isn&#39;t
                perfect though, I cut myself a few times. It is fun to work with. This language is simpler than C++ and
                Rust. This language is faster to develop in than Rust, C++, and Zig. This language is safer and more
                expressive than C.
            </p>
            <p>
                Would I use this language daily? I don&#39;t think so. It is a good alternative to C, where projects that
                would otherwise be written in C could be written here. I think personally I prefer working with Zig, and
                that&#39;s alright. Zig holds a special place in my heart, and it won&#39;t give up easily.
            </p>
            <p>
                C3 has loads of potential. Already I&#39;ve seen this in my very short time using it. Yes, I will continue
                to use it. I haven&#39;t even tried to (ab)use the macro system yet, nor have messed with some of the more
                complex features that C3 has, such as it&#39;s dynamic interfaces.
            </p>
            <p>
                The C3 source code is very readable. While in the making of this article, I was able to read the source
                code of many parts of the standard library with ease. Lots of languages with macros seem like
                navigating a non-euclidean labrynth, where the entrance and exit keep running away from you. The C3
                macro system is well built, kindof feeling like a hybrid of Zig&#39;s comptime system and C&#39;s macros. I
                prefer it to other macro systems, hands down.
            </p>
            <p>
                There are some things which I would rather not have in this language. These include inclusive slicing
                syntax, and the error system still doesn&#39;t quite sit right with me. Perhaps these will be fixed in the
                next update!
            </p>
            <p>
                Thank you to <code>is_human_ (1075947477913567294 on discord)</code> for all the wonderful answers you
                supplied to me while I was trying this language out. Thank you to Christoffer for making this language,
                you are certainly more talented than I am: the compiler source code shows it.
            </p>
            <p>
                If you are looking to try C3 out, go for it. <a href="https://xkcd.com/989/" target="_blank">Don&#39;t wait
                    for it to become better</a>. I&#39;ve gained a lot out of this venture, and will continue to gain
                insight as I continue to learn it. Thanks for reading.
            </p>
        </div>
    </div></div>
  </body>
</html>
