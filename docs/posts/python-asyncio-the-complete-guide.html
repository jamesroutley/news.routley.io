<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://superfastpython.com/python-asyncio/">Original</a>
    <h1>Python Asyncio: The Complete Guide</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
<p><strong>Asyncio</strong> allows us to use asynchronous programming with coroutine-based concurrency in Python.</p>



<p>Although asyncio has been available in Python for many years now, it remains one of the most interesting and yet one of the most frustrating areas of Python.</p>



<p>It is just plain hard to get started with asyncio for new developers.</p>



<p>This guide provides a detailed and comprehensive review of asyncio in Python, including how to define, create and run coroutines, what is asynchronous programming, what is non-blocking-io, concurrency primitives used with coroutines, common questions, and best practices.</p>



<p>This is a massive 29,000+ word guide. You may want to bookmark it so you can refer to it as you develop your concurrent programs.</p>



<p>Let’s dive in.</p>




<h2><span id="What_is_Asynchronous_Programming"></span>What is Asynchronous Programming<span></span></h2>



<p>Asynchronous programming is a programming paradigm that does not block.</p>



<p>Instead, requests and function calls are issued and executed somehow in the background at some future time. This frees the caller to perform other activities and handle the results of issued calls at a later time when results are available or when the caller is interested.</p>



<p>Let’s get a handle on asynchronous programming before we dive into asyncio.</p>



<h3><span id="Asynchronous_Tasks"></span>Asynchronous Tasks<span></span></h3>



<p>Asynchronous means not at the same time, as opposed to synchronous or at the same time.</p>



<blockquote>
<p>asynchronous: not simultaneous or concurrent in time</p>
<cite>— <a href="https://www.merriam-webster.com/dictionary/asynchronous">Merriam-Webster Dictionary</a></cite></blockquote>



<p>When programming, asynchronous means that the action is requested, although not performed at the time of the request. It is performed later.</p>



<blockquote>
<p><strong>Asynchronous</strong>: Separate execution streams that can run concurrently in any order relative to each other are asynchronous.</p>
<cite>— Page 265, <a href="https://amzn.to/3TkCuwX">The Art of Concurrency</a>, 2009.</cite></blockquote>



<p>For example, we can make an <a href="https://en.wikipedia.org/wiki/Asynchronous_procedure_call">asynchronous function call</a>.</p>



<p>This will issue the request to make the function call and will not wait around for the call to complete. We can choose to check on the status or result of the function call later.</p>



<ul>
<li><strong>Asynchronous Function Call</strong>: Request that a function is called at some time and in some manner, allowing the caller to resume and perform other activities.</li>
</ul>



<p>The function call will happen somehow and at some time, in the background, and the program can perform other tasks or respond to other events.</p>



<p>This is key. We don’t have control over how or when the request is handled, only that we would like it handled while the program does other things.</p>



<p>Issuing an asynchronous function call often results in some handle on the request that the caller can use to check on the status of the call or get results. This is often called a future.</p>



<ul>
<li><strong>Future</strong>: A handle on an asynchronous function call allowing the status of the call to be checked and results to be retrieved.</li>
</ul>



<p>The combination of the asynchronous function call and future together is often referred to as an asynchronous task. This is because it is more elaborate than a function call, such as allowing the request to be canceled and more.</p>



<ul>
<li><strong>Asynchronous Task</strong>: Used to refer to the aggregate of an asynchronous function call and resulting future.</li>
</ul>



<h3><span id="Asynchronous_Programming"></span>Asynchronous Programming<span></span></h3>



<p>Issuing asynchronous tasks and making asynchronous function calls is referred to as asynchronous programming.</p>



<blockquote>
<p>So what is asynchronous programming? It means that a particular long-running task can be run in the background separate from the main application. Instead of blocking all other application code waiting for that long-running task to be completed, the system is free to do other work that is not dependent on that task. Then, once the long-running task is completed, we’ll be notified that it is done so we can process the result.</p>
<cite>— Page 3, <a href="https://amzn.to/3Cz7Zh6">Python Concurrency with asyncio</a>, 2022.</cite></blockquote>



<ul>
<li><strong>Asynchronous Programming</strong>: The use of asynchronous techniques, such as issuing asynchronous tasks or function calls.</li>
</ul>



<p>Asynchronous programming is primarily used with non-blocking I/O, such as reading and writing from socket connections with other processes or other systems.</p>



<blockquote>
<p>In non-blocking mode, when we write bytes to a socket, we can just fire and forget the write or read, and our application can go on to perform other tasks.</p>
<cite>— Page 18, <a href="https://amzn.to/3Cz7Zh6">Python Concurrency with asyncio</a>, 2022.</cite></blockquote>



<p>Non-blocking I/O is a way of performing I/O where reads and writes are requested, although performed asynchronously. The caller does not need to wait for the operation to complete before returning.</p>



<p>The read and write operations are performed somehow (e.g. by the underlying operating system or systems built upon it), and the status of the action and/or data is retrieved by the caller later, once available, or when the caller is ready.</p>



<ul>
<li><strong>Non-blocking I/O</strong>: Performing I/O operations via asynchronous requests and responses, rather than waiting for operations to complete.</li>
</ul>



<p>As such, we can see how non-blocking I/O is related to asynchronous programming. In fact, we use non-blocking I/O via asynchronous programming, or non-blocking I/O is implemented via asynchronous programming.</p>



<p>The combination of non-blocking I/O with asynchronous programming is so common that it is commonly referred to by the shorthand of asynchronous I/O.</p>



<ul>
<li><strong>Asynchronous I/O</strong>: A shorthand that refers to combining asynchronous programming with non-blocking I/O.</li>
</ul>



<p>Next, let’s consider asynchronous programming support in Python.</p>



<h3><span id="Asynchronous_Programming_in_Python"></span>Asynchronous Programming in Python<span></span></h3>



<p>Broadly, asynchronous programming in Python refers to making requests and not blocking to wait for them to complete.</p>



<p>We can implement asynchronous programming in Python in various ways, although a few are most relevant for Python concurrency.</p>



<p>The first and obvious example is the <a href="https://docs.python.org/3/library/asyncio.html"><strong>asyncio</strong> module</a>. This module directly offers an asynchronous programming environment using the async/await syntax and non-blocking I/O with sockets and subprocesses.</p>



<blockquote>
<p>asyncio is short for asynchronous I/O. It is a Python library that allows us to run code using an asynchronous programming model. This lets us handle multiple I/O operations at once, while still allowing our application to remain responsive.</p>
<cite>— Page 3, <a href="https://amzn.to/3Cz7Zh6">Python Concurrency with asyncio</a>, 2022.</cite></blockquote>



<p>It is implemented using coroutines that run in an event loop that itself runs in a single thread.</p>



<ul>
<li><strong>Asyncio</strong>: An asynchronous programming environment provided in Python via the asyncio module.</li>
</ul>



<p>More broadly, Python offers threads and processes that can execute tasks asynchronously.</p>



<p>For example, one thread can start a second thread to execute a function call and resume other activities. The operating system will schedule and execute the second thread at some time and the first thread may or may not check on the status of the task, manually.</p>



<blockquote>
<p>Threads are asynchronous, meaning that they may run at different speeds, and any thread can halt for an unpredictable duration at any time.</p>
<cite>— Page 76, <a href="https://amzn.to/3CC82J2">The Art of Multiprocessor Programming</a>, 2020.</cite></blockquote>



<p>More concretely, Python provides executor-based thread pools and process pools in the <strong><a href="https://superfastpython.com/threadpoolexecutor-in-python/">ThreadPoolExecutor</a></strong> and <strong><a href="https://superfastpython.com/processpoolexecutor-in-python/">ProcessPoolExeuctor</a></strong> classes.</p>



<p>These classes use the same interface and support asynchronous tasks via the <strong>submit()</strong> method that returns a <strong>Future</strong> object.</p>



<blockquote>
<p>The concurrent.futures module provides a high-level interface for asynchronously executing callables. The asynchronous execution can be performed with threads, using ThreadPoolExecutor, or separate processes, using ProcessPoolExecutor.</p>
<cite>— <a href="https://docs.python.org/3/library/concurrent.futures.html">concurrent.futures — Launching parallel tasks</a></cite></blockquote>



<p>The <a href="https://docs.python.org/3/library/multiprocessing.html"><strong>multiprocessing</strong> module</a> also provides pools of workers using processes and threads in the <strong><a href="https://superfastpython.com/multiprocessing-pool-python/">Pool</a></strong> and <strong><a href="https://superfastpython.com/threadpool-python/">ThreadPool</a></strong> classes, forerunners to the <strong>ThreadPoolExecutor</strong> and <strong>ProcessPoolExeuctor</strong> classes.</p>



<p>The capabilities of these classes are described in terms of worker execution tasks asynchronously. They explicitly provide synchronous (blocking) and asynchronous (non-blocking) versions of each method for executing tasks.</p>



<p>For example, one may issue a one-off function call synchronously via the <strong>apply()</strong> method or asynchronously via the <strong>apply_async()</strong> method.</p>



<blockquote>
<p>A process pool object which controls a pool of worker processes to which jobs can be submitted. It supports asynchronous results with timeouts and callbacks and has a parallel map implementation.</p>
<cite>— <a href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing — Process-based parallelism</a></cite></blockquote>



<p>There are other aspects of asynchronous programming in Python that are less strictly related to Python concurrency.</p>



<p>For example, Python processes receive or handle signals asynchronously. Signals are fundamentally asynchronous events sent from other processes.</p>



<p>This is primarily supported by the <a href="https://docs.python.org/3/library/signal.html"><strong>signal</strong> module</a>.</p>



<p>Now that we know about asynchronous programming, let’s take a closer look at asyncio.</p>




<h2><span id="What_is_Asyncio"></span>What is Asyncio<span></span></h2>



<p>Broadly, asyncio refers to the ability to implement asynchronous programming in Python using coroutines.</p>



<p>Specifically, it refers to two elements:</p>



<ol>
<li>The addition of the “<strong>asyncio</strong>” module to the Python standard library in Python 3.4.</li>



<li>The addition of <strong>async/await</strong> expressions to the Python language in Python 3.5.</li>
</ol>



<p>Together, the module and changes to the language facilitate the development of Python programs that support coroutine-based concurrency, non-blocking I/O, and asynchronous programming.</p>



<blockquote>
<p>Python 3.4 introduced the asyncio library, and Python 3.5 produced the async and await keywords to use it palatably. These new additions allow so-called asynchronous programming.</p>
<cite>— Page vii, <a href="https://amzn.to/3MQC92E">Using Asyncio in Python</a>, 2020.</cite></blockquote>



<p>Let’s take a closer look at these two aspects of asyncio, starting with the changes to the language.</p>



<h3><span id="Changes_to_Python_to_add_Support_for_Coroutines"></span>Changes to Python to add Support for Coroutines<span></span></h3>



<p>The Python language was changed to accommodate asyncio with the addition of expressions and types.</p>



<p>More specifically, it was changed to support coroutines as first-class concepts. In turn, coroutines are the unit of concurrency used in asyncio programs.</p>



<p>A coroutine is a function that can be suspended and resumed.</p>



<blockquote>
<p><strong>coroutine</strong>: Coroutines are a more generalized form of subroutines. Subroutines are entered at one point and exited at another point. Coroutines can be entered, exited, and resumed at many different points.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html#term-coroutine">Python Glossary</a></cite></blockquote>



<p>A coroutine can be defined via the “<strong>async def</strong>” expression. It can take arguments and return a value, just like a function.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62859374938673" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define a coroutine</span></p><p><span>async </span><span>def </span><span>custom_coro</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
</div>



<p>Calling a coroutine function will create a coroutine object, this is a new class. It does not execute the coroutine function.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62864564613985" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a coroutine object</span></p><p><span>coro</span><span> </span><span>=</span><span> </span><span>custom_coro</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>A coroutine can execute another coroutine via the await expression.</p>



<p>This suspends the caller and schedules the target for execution.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62866676392150" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># suspend and schedule the target</span></p><p><span>await </span><span>custom_coro</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>An asynchronous iterator is an iterator that yields awaitables.</p>



<blockquote>
<p>asynchronous iterator: An object that implements the __aiter__() and __anext__() methods. __anext__ must return an awaitable object. async for resolves the awaitables returned by an asynchronous iterator’s __anext__() method until it raises a StopAsyncIteration exception.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>An asynchronous iterator can be traversed using the “<strong>async for</strong>” expression.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62867294404994" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># traverse an asynchronous iterator</span></p><p><span>async </span><span>for</span><span> </span><span>item </span><span>in</span><span> </span><span>async_iterator</span><span>:</span></p><p><span>	</span><span>print</span><span>(</span><span>item</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This does not execute the for-loop in parallel.</p>



<p>Instead, the calling coroutine that executes the for loop will suspend and internally await each awaitable yielded from the iterator.</p>



<p>An asynchronous context manager is a context manager that can await the enter and exit methods.</p>



<blockquote>
<p>An asynchronous context manager is a context manager that is able to suspend execution in its enter and exit methods.</p>
<cite>— <a href="https://peps.python.org/pep-0492/#asynchronous-context-managers-and-async-with">Asynchronous Context Managers and “async with”</a></cite></blockquote>



<p>The “<strong>async with</strong>” expression is for creating and using asynchronous context managers.</p>



<p>The calling coroutine will suspend and await the context manager before entering the block for the context manager, and similarly when leaving the context manager block.</p>



<p>These are the sum of the major changes to Python language to support coroutines.</p>



<p>Next, let’s look at the asyncio module.</p>



<h3><span id="The_asyncio_Module"></span>The asyncio Module<span></span></h3>



<p>The “<strong>asyncio</strong>” module provides functions and objects for developing coroutine-based programs using the asynchronous programming paradigm.</p>



<p>Specifically, it supports non-blocking I/O with subprocesses (for executing commands) and with streams (for TCP socket programming).</p>



<blockquote>
<p>asyncio is a library to write concurrent code using the async/await syntax.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio.html">asyncio — Asynchronous I/O</a></cite></blockquote>



<p>Central to the asyncio module is the event loop.</p>



<p>This is the mechanism that runs a coroutine-based program and implements cooperative multitasking between coroutines.</p>



<blockquote>
<p>The event loop is the core of every asyncio application. Event loops run asynchronous tasks and callbacks, perform network IO operations, and run subprocesses.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-eventloop.html">Asyncio Event Loop</a></cite></blockquote>



<p>The module provides both a high-level and low-level API.</p>



<p>The high-level API is for us Python application developers. The low-level API is for framework developers, not us, in most cases.</p>



<p>Most use cases are satisfied using the high-level API that provides utilities for working with coroutines, streams, synchronization primitives, subprocesses, and queues for sharing data between coroutines.</p>



<p>The lower-level API provides the foundation for the high-level API and includes the internals of the event loop, transport protocols, policies, and more.</p>



<blockquote>
<p>… there are low-level APIs for library and framework developers</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio.html">asyncio — Asynchronous I/O</a></cite></blockquote>



<p>Now that we know what asyncio is, broadly, and that it is for Asynchronous programming.</p>



<p>Next, let’s explore when we should consider using asyncio in our Python programs.</p>



<p>
<strong>Confused by the asyncio module API?</strong></p>
<h2><span id="When_to_Use_Asyncio"></span>When to Use Asyncio<span></span></h2>



<p>Asyncio, broadly, is new, popular, much discussed, and exciting.</p>



<p>Nevertheless, there is a lot of confusion over when it should be adopted in a project.</p>



<p>When should we use asyncio in Python?</p>



<h3><span id="Reasons_to_Use_Asyncio_in_Python"></span>Reasons to Use Asyncio in Python<span></span></h3>



<p>There are perhaps 3 top-level reasons to use asyncio in a Python project.</p>



<p>They are:</p>



<ol>
<li>Use asyncio in order to adopt coroutines in your program.</li>



<li>Use asyncio in order to use the asynchronous programming paradigm.</li>



<li>Use asyncio in order to use non-blocking I/O.</li>
</ol>



<h4>Reason 1: To Use Coroutines</h4>



<p>We may choose to use asyncio because we want to use coroutines.</p>



<p>We may want to use coroutines because we can have many more concurrent coroutines in our program than concurrent threads.</p>



<p>Coroutines are another unit of concurrency, like threads and processes.</p>



<p>Thread-based concurrency is provided by the threading module and is supported by the underlying operating system. It is suited to blocking I/O tasks such reading and writing from files, sockets, and devices.</p>



<p>Process-based concurrency is provided by the multiprocessing module and is also supported by the underlying operating system, like threads. It is suited to CPU-bound tasks that do not require much inter-process communication, such as compute tasks.</p>



<p>Coroutines are an alternative that is provided by the Python language and runtime (standard interpreter) and further supported by the asyncio module. They are suited to non-blocking I/O with subprocesses and sockets, however, blocking I/O and CPU-bound tasks can be used in a simulated non-blocking manner using threads and processes under the covers.</p>



<p>This last point is subtle and key. Although we can choose to use coroutines for the capability for which they were introduced into Python, non-blocking, we may in fact use them with any tasks. Any program written with threads or processes can be rewritten or instead written using coroutines if we so desire.</p>



<p>Threads and processes achieve multitasking via the operating system that chooses which threads and processes should run, when, and for how long. The operating switches between threads and processes rapidly, suspending those that are not running and resuming those granted time to run. This is called preemptive multitasking.</p>



<p>Coroutines in Python provide an alternative type of multitasking called cooperating multitasking.</p>



<p>A coroutine is a subroutine (function) that can be suspended and resumed. It is suspended by the await expression and resumed once the await expression is resolved.</p>



<p>This allows coroutines to cooperate by design, choosing how and when to suspend their execution.</p>



<p>It is an alternate, interesting, and powerful approach to concurrency, different from thread-based and process-based concurrency.</p>



<p>This alone may make it a reason to adopt it for a project.</p>



<p>Another key aspect of coroutines is that they are lightweight.</p>



<p>They are more lightweight than threads. This means they are faster to start and use less memory. Essentially a coroutine is a special type of function, whereas a thread is represented by a Python object and is associated with a thread in the operating system with which the object must interact.</p>



<p>As such, we may have thousands of threads in a Python program, but we could easily have tens or hundreds of thousands of coroutines all in one thread.</p>



<p>We may choose coroutines for their scalability.</p>



<h4>Reason 2: To Use Asynchronous Programming</h4>



<p>We may choose to use asyncio because we want to use asynchronous programming in our program.</p>



<p>That is, we want to develop a Python program that uses the asynchronous programming paradigm.</p>



<p>Asynchronous means not at the same time, as opposed to synchronous or at the same time.</p>



<p>When programming, asynchronous means that the action is requested, although not performed at the time of the request. It is performed later.</p>



<p>Asynchronous programming often means going all in and designing the program around the concept of asynchronous function calls and tasks.</p>



<p>Although there are other ways to achieve elements of asynchronous programming, full asynchronous programming in Python requires the use of coroutines and the asyncio module.</p>



<blockquote>
<p>It is a Python library that allows us to run code using an asynchronous programming model.</p>
<cite>— Page 3, <a href="https://amzn.to/3Cz7Zh6">Python Concurrency with asyncio</a>, 2022.</cite></blockquote>



<p>We may choose to use asyncio because we want to use the asynchronous programming module in our program, and that is a defensible reason.</p>



<p>To be crystal clear, this reason is independent of using non-blocking I/O. Asynchronous programming can be used independently of non-blocking I/O.</p>



<p>As we saw previously, coroutines can execute non-blocking I/O asynchronously, but the asyncio module also provides the facility for executing blocking I/O and CPU-bound tasks in an asynchronous manner, simulating non-blocking under the covers via threads and processes.</p>



<h4>Reason 3: To Use Non-Blocking I/O</h4>



<p>We may choose to use asyncio because we want or require non-blocking I/O in our program.</p>



<p>Input/Output or I/O for short means reading or writing from a resource.</p>



<p>Common examples include:</p>



<ul>
<li><strong>Hard disk drives</strong>: Reading, writing, appending, renaming, deleting, etc. files.</li>



<li><strong>Peripherals</strong>: mouse, keyboard, screen, printer, serial, camera, etc.</li>



<li><strong>Internet</strong>: Downloading and uploading files, getting a webpage, querying RSS, etc.</li>



<li><strong>Database</strong>: Select, update, delete, etc. SQL queries.</li>



<li><strong>Email</strong>: Send mail, receive mail, query inbox, etc.</li>
</ul>



<p>These operations are slow, compared to calculating things with the CPU.</p>



<p>The common way these operations are implemented in programs is to make the read or write request and then wait for the data to be sent or received.</p>



<p>As such, these operations are commonly referred to as blocking I/O tasks.</p>



<p>The operating system can see that the calling thread is blocked and will context switch to another thread that will make use of the CPU.</p>



<p>This means that the blocking call does not slow down the entire system. But it does halt or block the thread or program making the blocking call.</p>



<p>You can learn more about blocking calls in the tutorial:</p>



<ul>
<li><a href="https://superfastpython.com/thread-blocking-call-in-python/">Thread Blocking Call in Python</a></li>
</ul>



<p>Non-blocking I/O is an alternative to blocking I/O.</p>



<p>It requires support in the underlying operating system, just like blocking I/O, and all modern operating systems provide support for some form of non-blocking I/O.</p>



<p>Non-blocking I/O allows read and write calls to be made as asynchronous requests.</p>



<p>The operating system will handle the request and notify the calling program when the results are available.</p>



<ul>
<li><strong>Non-blocking I/O</strong>: Performing I/O operations via asynchronous requests and responses, rather than waiting for operations to complete.</li>
</ul>



<p>As such, we can see how non-blocking I/O is related to asynchronous programming. In fact, we use non-blocking I/O via asynchronous programming, or non-blocking I/O is implemented via asynchronous programming.</p>



<p>The combination of non-blocking I/O with asynchronous programming is so common that it is commonly referred to by the shorthand of asynchronous I/O.</p>



<ul>
<li><strong>Asynchronous I/O</strong>: A shorthand that refers to combining asynchronous programming with non-blocking I/O.</li>
</ul>



<p>The asyncio module in Python was added specifically to add support for non-blocking I/O with subprocesses (e.g. executing commands on the operating system) and with streams (e.g. TCP socket programming) to the Python standard library.</p>



<p>We could simulate non-blocking I/O using threads and the asynchronous programming capability provided by Python thread pools or thread pool executors.</p>



<p>The asyncio module provides first-class asynchronous programming for non-blocking I/O via coroutines, event loops, and objects to represent non-blocking subprocesses and streams.</p>



<p>We may choose to use asyncio because we want to use asynchronous I/O in our program, and that is a defensible reason.</p>



<h3><span id="Other_Reasons_to_Use_Asyncio"></span>Other Reasons to Use Asyncio<span></span></h3>



<p>Ideally, we would choose a reason that is defended in the context of the requirements of the project.</p>



<p>Sometimes we have control over the function and non-functional requirements and other times not. In the cases we do, we may choose to use asyncio for one of the reasons listed above. In the cases we don’t, we may be led to choose asyncio in order to deliver a program that solves a specific problem.</p>



<p>Some other reasons we may use asyncio include:</p>



<ol>
<li>Use asyncio because someone else made the decision for you.</li>



<li>Use asyncio because the project you have joined is already using it.</li>



<li>Use asyncio because you want to learn more about it.</li>
</ol>



<p>We don’t always have full control over the projects we work on.</p>



<p>It is common to start a new job, new role, or new project and be told by the line manager or lead architect of specific design and technology decisions.</p>



<p>Using asyncio may be one of these decisions.</p>



<p>We may use asyncio on a project because the project is already using it. You must use asyncio, rather than you choose to use asyncio.</p>



<p>A related example might be the case of a solution to a problem that uses asyncio that you wish to adopt.</p>



<p>For example:</p>



<ul>
<li>Perhaps you need to use a third-party API and the code examples use asyncio.</li>



<li>Perhaps you need to integrate an existing open-source solution that uses asyncio.</li>



<li>Perhaps you stumble across some code snippets that do what you need, yet they use asyncio.</li>
</ul>



<p>For lack of alternate solutions, asyncio may be thrust upon you by your choice of solution.</p>



<p>Finally, we may choose asyncio for our Python project to learn more about.</p>



<p>You may scoff, “<em>what about the requirements</em>?”</p>



<p>You may choose to adopt asyncio just because you want to try it out and it can be a defensible reason.</p>



<p>Using asyncio in a project will make its workings concrete for you.</p>



<h3><span id="When_to_Not_Use_Asyncio"></span>When to Not Use Asyncio<span></span></h3>



<p>We have spent a lot of time on reasons why we should use asyncio.</p>



<p>It is probably a good idea to spend at least a moment on why we should not use it.</p>



<p>One reason to not use asyncio is that you cannot defend its use using one of the reasons above.</p>



<p>This is not foolproof. There may be other reasons to use it, not listed above.</p>



<p>But, if you pick a reason to use asyncio and the reason feels thin or full of holes for your specific case. Perhaps asyncio is not the right solution.</p>



<p>I think the major reason to not use asyncio is that it does not deliver the benefit that you think it does.</p>



<p>There are many misconceptions about Python concurrency, especially around asyncio.</p>



<p>For example:</p>



<ul>
<li>Asyncio will work around the global interpreter lock.</li>



<li>Asyncio is faster than threads.</li>



<li>Asyncio avoids the need for mutex locks and other synchronization primitives.</li>



<li>Asyncio is easier to use than threads.</li>
</ul>



<p>These are all false.</p>



<p>Only a single coroutine can run at a time by design, they cooperate to execute. This is just like threads under the GIL. In fact, the GIL is an orthogonal concern and probably irrelevant in most cases when using asyncio.</p>



<p>Any program you can write with asyncio, you can write with threads and it will probably be as fast or faster. It will also probably be simpler and easier to read and interpret by fellow developers.</p>



<p>Any concurrency failure mode you might expect with threads, you can encounter with coroutines. You must make coroutines safe from deadlocks and race conditions, just like threads.</p>



<p>Another reason to not use asyncio is that you don’t like asynchronous programming.</p>



<p>Asynchronous programming has been popular for some time now in a number of different programming communities, most notably the JavaScript community.</p>



<p>It is different from procedural, object-oriented, and functional programming, and some developers just don’t like it.</p>



<p>No problem. If you don’t like it, don’t use it. It’s a fair reason.</p>



<p>You can achieve the same effect in many ways, notably by sprinkling a few asynchronous calls in via thread or process executors as needed.</p>



<p>Now that we are familiar with when to use asyncio, let’s look at coroutines in more detail.</p>



<div>
<hr/>
<div>
<p><strong>Free Python Asyncio Course</strong></p>

<p>Download my asyncio API cheat sheet and as a bonus you will get FREE access to my 7-day email course on asyncio.</p>

<p>Discover how to use the Python asyncio module including how to define, create, and run new coroutines and how to use non-blocking I/O.</p>

<p><a href="https://marvelous-writer-6152.ck.page/d29b7d8dfb">Learn more</a></p>
</div>
<hr/></div>
<h2><span id="Coroutines_in_Python"></span>Coroutines in Python<span></span></h2>



<p>Python provides first-class coroutines with a “<strong>coroutine</strong>” type and new expressions like “<strong>async def</strong>” and “<strong>await</strong>“.</p>



<p>It provides the “<strong>asyncio</strong>” module for running coroutines and developing asynchronous programs.</p>



<p>In this section, we will take a much closer look at coroutines.</p>



<h3><span id="What_is_a_Coroutine"></span>What is a Coroutine<span></span></h3>



<p>A <a href="https://en.wikipedia.org/wiki/Coroutine">coroutine is a function</a> that can be suspended and resumed.</p>



<p>It is often defined as a generalized subroutine.</p>



<p>A subroutine can be executed, starting at one point and finishing at another point. Whereas, a coroutine can be executed then suspended, and resumed many times before finally terminating.</p>



<p>Specifically, coroutines have control over when exactly they suspend their execution.</p>



<p>This may involve the use of a specific expression, such as an “await” expression in Python, like a yield expression in a Python generator.</p>



<blockquote>
<p>A coroutine is a method that can be paused when we have a potentially long-running task and then resumed when that task is finished. In Python version 3.5, the language implemented first-class support for coroutines and asynchronous programming when the keywords async and await were explicitly added to the language.</p>
<cite>— Page 3, <a href="https://amzn.to/3ENILNs">Python Concurrency with asyncio</a>, 2022.</cite></blockquote>



<p>A coroutine may suspend for many reasons, such as executing another coroutine, e.g. awaiting another task, or waiting for some external resources, such as a socket connection or process to return data.</p>



<p>Coroutines are used for concurrency.</p>



<blockquote>
<p>Coroutines let you have a very large number of seemingly simultaneous functions in your Python programs.</p>
<cite>— Page 267, <a href="https://amzn.to/3eClkfe">Effective Python</a>, 2019.</cite></blockquote>



<p>Many coroutines can be created and executed at the same time. They have control over when they will suspend and resume, allowing them to cooperate as to when concurrent tasks are executed.</p>



<p>This is called <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperative multitasking</a> and is different from the multitasking typically used with threads called preemptive multitasking tasking.</p>



<blockquote>
<p>… in order to run multiple applications concurrently, processes voluntarily yield control periodically or when idle or logically blocked. This type of multitasking is called cooperative because all programs must cooperate for the scheduling scheme to work.</p>
<cite>— <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">Cooperative multitasking, Wikipedia</a></cite></blockquote>



<p>Preemptive multitasking involves the operating system choosing what threads to suspend and resume and when to do so, as opposed to the tasks themselves deciding in the case of cooperative multitasking.</p>



<p>Now that we have some idea of what a coroutine is, let’s deepen this understanding by comparing them to other familiar programming constructs.</p>



<h3><span id="Coroutine_vs_Routine_and_Subroutine"></span>Coroutine vs Routine and Subroutine<span></span></h3>



<p>A “<em>routine</em>” and “<em>subroutine</em>” often refer to the same thing in modern programming.</p>



<p>Perhaps more correctly, a routine is a program, whereas a <a href="https://en.wikipedia.org/wiki/Function_(computer_programming)">subroutine is a function</a> in the program.</p>



<p>A routine has subroutines.</p>



<p>It is a discrete module of expressions that is assigned a name, may take arguments and may return a value.</p>



<ul>
<li><strong>Subroutine</strong>: A module of instructions that can be executed on demand, typically named, and may take arguments and return a value. also called a function</li>
</ul>



<p>A subroutine is executed, runs through the expressions, and returns somehow. Typically, a subroutine is called by another subroutine.</p>



<p>A coroutine is an extension of a subroutine. This means that a subroutine is a special type of a coroutine.</p>



<p>A coroutine is like a subroutine in many ways, such as:</p>



<ul>
<li>They both are discrete named modules of expressions.</li>



<li>They both can take arguments, or not.</li>



<li>They both can return a value, or not.</li>
</ul>



<p>The main difference is that it chooses to suspend and resume its execution many times before returning and exiting.</p>



<p>Both coroutines and subroutines can call other examples of themselves. A subroutine can call other subroutines. A coroutine executes other coroutines. However, a coroutine can also execute other subroutines.</p>



<p>When a coroutine executes another coroutine, it must suspend its execution and allow the other coroutine to resume once the other coroutine has completed.</p>



<p>This is like a subroutine calling another subroutine. The difference is the suspension of the coroutine may allow any number of other coroutines to run as well.</p>



<p>This makes a coroutine calling another coroutine more powerful than a subroutine calling another subroutine. It is central to the cooperating multitasking facilitated by coroutines.</p>



<h3><span id="Coroutine_vs_Generator"></span>Coroutine vs Generator<span></span></h3>



<p>A generator is a special function that can suspend its execution.</p>



<blockquote>
<p>generator: A function which returns a generator iterator. It looks like a normal function except that it contains yield expressions for producing a series of values usable in a for-loop or that can be retrieved one at a time with the next() function.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>A generator function can be defined like a normal function although it uses a yield expression at the point it will suspend its execution and return a value.</p>



<p>A generator function will return a generator iterator object that can be traversed, such as via a for-loop. Each time the generator is executed, it runs from the last point it was suspended to the next yield statement.</p>



<blockquote>
<p>generator iterator: An object created by a generator function. Each yield temporarily suspends processing, remembering the location execution state (including local variables and pending try-statements). When the generator iterator resumes, it picks up where it left off (in contrast to functions which start fresh on every invocation).</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>A coroutine can suspend or yield to another coroutine using an “<strong>await</strong>” expression. It will then resume from this point once the awaited coroutine has been completed.</p>



<blockquote>
<p>Using this paradigm, an await statement is similar in function to a yield statement; the execution of the current function gets paused while other code is run. Once the await or yield resolves with data, the function is resumed.</p>
<cite>— Page 218, <a href="https://amzn.to/3rY7cQE">High Performance Python</a>, 2020.</cite></blockquote>



<p>We might think of a generator as a special type of coroutine and cooperative multitasking used in loops.</p>



<blockquote>
<p>Generators, also known as semicoroutines, are a subset of coroutines.</p>
<cite>— <a href="https://en.wikipedia.org/wiki/Coroutine">Coroutine, Wikipedia</a>.</cite></blockquote>



<p>Before coroutines were developed, generators were extended so that they might be used like coroutines in Python programs.</p>



<p>This required a lot of technical knowledge of generators and the development of custom task schedulers.</p>



<blockquote>
<p>To implement your own concurrency using generators, you first need a fundamental insight concerning generator functions and the yield statement. Specifically, the fundamental behavior of yield is that it causes a generator to suspend its execution. By suspending execution, it is possible to write a scheduler that treats generators as a kind of “task” and alternates their execution using a kind of cooperative task switching.</p>
<cite>— Page 524, <a href="https://amzn.to/3D002li">Python Cookbook</a>, 2013.</cite></blockquote>



<p>This was made possible via changes to the generators and the introduction of the “<strong>yield from</strong>” expression.</p>



<p>These were later deprecated in favor of the modern async/await expressions.</p>



<h3><span id="Coroutine_vs_Task"></span>Coroutine vs Task<span></span></h3>



<p>A subroutine and a coroutine may represent a “<em>task</em>” in a program.</p>



<p>However, in Python, there is a specific object called an <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task"><strong>asyncio.Task</strong> object</a>.</p>



<blockquote>
<p>A Future-like object that runs a Python coroutine. […] Tasks are used to run coroutines in event loops.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task">Asyncio Task Object</a></cite></blockquote>



<p>A coroutine can be wrapped in an <strong>asyncio.Task</strong> object and executed independently, as opposed to being executed directly within a coroutine. The <strong>Task</strong> object provides a handle on the asynchronously execute coroutine.</p>



<ul>
<li><strong>Task</strong>: A wrapped coroutine that can be executed independently.</li>
</ul>



<p>This allows the wrapped coroutine to execute in the background. The calling coroutine can continue executing instructions rather than awaiting another coroutine.</p>



<p>A <strong>Task</strong> cannot exist on its own, it must wrap a coroutine.</p>



<p>Therefore a <strong>Task</strong> is a coroutine, but a coroutine is not a task.</p>



<p>You can learn more about <strong>asyncio.Task</strong> objects in the tutorial:</p>



<h3><span id="Coroutine_vs_Thread"></span>Coroutine vs Thread<span></span></h3>



<p>A coroutine is more lightweight than a thread.</p>



<ul>
<li><strong>Thread</strong>: heavyweight compared to a coroutine</li>



<li><strong>Coroutine</strong>: lightweight compared to a thread.</li>
</ul>



<p>A coroutine is defined as a function.</p>



<p>A thread is an object created and managed by the underlying operating system and represented in Python as a <strong>threading.Thread</strong> object.</p>



<ul>
<li><strong>Thread</strong>: Managed by the operating system, represented by a Python object.</li>
</ul>



<p>This means that coroutines are typically faster to create and start executing and take up less memory. Conversely, threads are slower than coroutines to create and start and take up more memory.</p>



<blockquote>
<p>The cost of starting a coroutine is a function call. Once a coroutine is active, it uses less than 1 KB of memory until it’s exhausted.</p>
<cite>— Page 267, <a href="https://amzn.to/3eClkfe">Effective Python</a>, 2019.</cite></blockquote>



<p>Coroutines execute within one thread, therefore a single thread may execute many coroutines.</p>



<blockquote>
<p>Many separate async functions advanced in lockstep all seem to run simultaneously, mimicking the concurrent behavior of Python threads. However, coroutines do this without the memory overhead, startup and context switching costs, or complex locking and synchronization code that’s required for threads.</p>
<cite>— Page 267, <a href="https://amzn.to/3eClkfe">Effective Python</a>, 2019.</cite></blockquote>



<p>You can learn more about threads in the guide:</p>



<ul>
<li><a href="https://superfastpython.com/threading-in-python/">Python Threading: The Complete Guide</a></li>
</ul>



<h3><span id="Coroutine_vs_Process"></span>Coroutine vs Process<span></span></h3>



<p>A coroutine is more lightweight than a process.</p>



<p>In fact, a thread is more lightweight than a process.</p>



<p>A process is a computer program. It may have one or many threads.</p>



<p>A Python process is in fact a separate instance of the Python interpreter.</p>



<p>Processes, like threads, are created and managed by the underlying operating system and are represented by a <strong>multiprocessing.Process</strong> object.</p>



<ul>
<li><strong>Process</strong>: Managed by the operating system, represented by a Python object.</li>
</ul>



<p>This means that coroutines are significantly faster than a process to create and start and take up much less memory.</p>



<p>A coroutine is just a special function, whereas a Process is an instance of the interpreter that has at least one thread.</p>



<p>You can learn more about Python processes in the guide:</p>



<ul>
<li><a href="https://superfastpython.com/multiprocessing-in-python/">Python Multiprocessing: The Complete Guide</a></li>
</ul>



<h3><span id="When_Were_Coroutines_Added_to_Python"></span>When Were Coroutines Added to Python<span></span></h3>



<p>Coroutines extend generators in Python.</p>



<p>Generators have slowly been migrating towards becoming first-class coroutines for a long time.</p>



<p>We can explore some of the major changes to Python to add coroutines, which we might consider a subset of the probability addition of asyncio.</p>



<p>New methods like <strong>send()</strong> and <strong>close()</strong> were added to generator objects to allow them to act more like coroutines.</p>



<p>These were added in Python 2.5 and described in <a href="https://peps.python.org/pep-0342/">PEP 342</a>.</p>



<blockquote>
<p>This PEP proposes some enhancements to the API and syntax of generators, to make them usable as simple coroutines.</p>
<cite>— <a href="https://peps.python.org/pep-0342/">PEP 342 – Coroutines via Enhanced Generators</a></cite></blockquote>



<p>Later, allowing generators to emit a suspension exception as well as a stop exception described in <a href="https://peps.python.org/pep-0334/">PEP 334</a>.</p>



<blockquote>
<p>This PEP proposes a limited approach to coroutines based on an extension to the iterator protocol. Currently, an iterator may raise a StopIteration exception to indicate that it is done producing values. This proposal adds another exception to this protocol, SuspendIteration, which indicates that the given iterator may have more values to produce, but is unable to do so at this time.</p>
<cite>— <a href="https://peps.python.org/pep-0334/">PEP 334 – Simple Coroutines via SuspendIteration</a></cite></blockquote>



<p>The vast majority of the capabilities for working with modern coroutines in Python via the asyncio module were described in <a href="https://peps.python.org/pep-3156/">PEP 3156</a>, added in Python 3.3.</p>



<blockquote>
<p>This is a proposal for asynchronous I/O in Python 3, starting at Python 3.3. Consider this the concrete proposal that is missing from PEP 3153. The proposal includes a pluggable event loop, transport and protocol abstractions similar to those in Twisted, and a higher-level scheduler based on yield from (PEP 380). The proposed package name is asyncio.</p>
<cite>— <a href="https://peps.python.org/pep-3156/">PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module</a></cite></blockquote>



<p>A second approach to coroutines, based on generators, was added to <a href="https://docs.python.org/3.4/library/asyncio-task.html">Python 3.4</a> as an extension to Python generators.</p>



<p>A coroutine was defined as a function that used the <strong>@asyncio.coroutine</strong> decorator.</p>



<p>Coroutines were executed using an asyncio event loop, via the asyncio module.</p>



<p>A coroutine could suspend and execute another coroutine via the “<strong>yield from</strong>” expression</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6286b853864425" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define a custom coroutine in Python 3.4</span></p><p><span>@</span><span>asyncio</span><span>.</span><span>coroutine</span></p><p><span>def </span><span>custom_coro</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># suspend and execute another coroutine</span></p><p><span>    </span><span>yield </span><span>from </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The “<strong>yield from</strong>” expression was defined in <a href="https://peps.python.org/pep-0380/">PEP 380</a>.</p>



<blockquote>
<p>A syntax is proposed for a generator to delegate part of its operations to another generator. This allows a section of code containing ‘yield’ to be factored out and placed in another generator.</p>
<cite>— <a href="https://peps.python.org/pep-0380/">PEP 380 – Syntax for Delegating to a Subgenerator</a></cite></blockquote>



<p>The <a href="https://docs.python.org/3/reference/expressions.html#yield-expressions">“<strong>yield from</strong>” expression</a> is still available for use in generators, although is a deprecated approach to suspending execution in coroutines, in favor of the <a href="https://docs.python.org/3/reference/expressions.html#await-expression">“<strong>await</strong>” expression</a>.</p>



<blockquote>
<p>Note: Support for generator-based coroutines is deprecated and is removed in Python 3.11. Generator-based coroutines predate async/await syntax. They are Python generators that use yield from expressions to await on Futures and other coroutines.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html">Asyncio Coroutines and Tasks</a></cite></blockquote>



<p>We might say that coroutines were added as first-class objects to Python in version 3.5.</p>



<p>This included changes to the Python language, such as the “<strong>async def</strong>“, “<strong>await</strong>“, “<strong>async with</strong>“, and “<strong>async for</strong>” expressions, as well as a coroutine type.</p>



<p>These changes were described in <a href="https://peps.python.org/pep-0492/">PEP 492</a>.</p>



<blockquote>
<p>It is proposed to make coroutines a proper standalone concept in Python, and introduce new supporting syntax. The ultimate goal is to help establish a common, easily approachable, mental model of asynchronous programming in Python and make it as close to synchronous programming as possible.</p>
<cite>— <a href="https://peps.python.org/pep-0492/">PEP 492 – Coroutines with async and await syntax</a></cite></blockquote>



<p>Now that we know what a coroutine is, let’s take a closer look at how to use them in Python.</p>



<p>
<strong>Overwheled by the python concurrency APIs?</strong></p>
<h2><span id="Define_Create_and_Run_Coroutines"></span>Define, Create and Run Coroutines<span></span></h2>



<p>We can define coroutines in our Python programs, just like defining new subroutines (functions).</p>



<p>Once defined, a coroutine function can be used to create a coroutine object.</p>



<p>The “<strong>asyncio</strong>” module provides tools to run our coroutine objects in an event loop, which is a runtime for coroutines.</p>



<h3><span id="How_to_Define_a_Coroutine"></span>How to Define a Coroutine<span></span></h3>



<p>A coroutine can be defined via the “<strong>async def</strong>” expression.</p>



<p>This is an extension of the “<strong>def</strong>” expression for defining subroutines.</p>



<p>It defines a coroutine that can be created and returns a coroutine object.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62888592729408" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define a coroutine</span></p><p><span>async </span><span>def </span><span>custom_coro</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>A coroutine defined with the “<strong>async def</strong>” expression is referred to as a “<em>coroutine function</em>“.</p>



<blockquote>
<p>coroutine function: A function which returns a coroutine object. A coroutine function may be defined with the async def statement, and may contain await, async for, and async with keywords.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>A coroutine can then use coroutine-specific expressions within it, such as <strong>await</strong>, <strong>async for</strong>, and <strong>async with</strong>.</p>



<blockquote>
<p>Execution of Python coroutines can be suspended and resumed at many points (see coroutine). await expressions, async for and async with can only be used in the body of a coroutine function.</p>
<cite>— <a href="https://docs.python.org/3/reference/compound_stmts.html#async-def">Coroutine function definition</a></cite></blockquote>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62889421941521" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define a coroutine</span></p><p><span>async </span><span>def </span><span>custom_coro</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># await another coroutine</span></p><p><span>	</span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="How_to_Create_a_Coroutine"></span>How to Create a Coroutine<span></span></h3>



<p>Once a coroutine is defined, it can be created.</p>



<p>This looks like calling a subroutine.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6288b062259321" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a coroutine</span></p><p><span>coro</span><span> </span><span>=</span><span> </span><span>custom_coro</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This does not execute the coroutine.</p>



<p>It returns a <a href="https://docs.python.org/3/reference/datamodel.html#coroutines">“<strong>coroutine</strong>” object</a>.</p>



<blockquote>
<p>You can think of a coroutine function as a factory for coroutine objects; more directly, remember that calling a coroutine function does not cause any user-written code to execute, but rather just builds and returns a coroutine object.</p>
<cite>— Page 516, <a href="https://amzn.to/3TazSBW">Python in a Nutshell</a>, 2017.</cite></blockquote>



<p>A “<strong>coroutine</strong>” Python object has methods, such as <strong>send()</strong> and <strong>close()</strong>. It is a type.</p>



<p>We can demonstrate this by creating an instance of a coroutine and calling the <strong>type()</strong> built-in function in order to report its type.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6288f703094910" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># check the type of a coroutine</span></p><p><span># define a coroutine</span></p><p><span>async </span><span>def </span><span>custom_coro</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># await another coroutine</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span># create the coroutine</span></p><p><span>coro</span><span> </span><span>=</span><span> </span><span>custom_coro</span><span>(</span><span>)</span></p><p><span># check the type of the coroutine</span></p><p><span>print</span><span>(</span><span>type</span><span>(</span><span>coro</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Running the example reports that the created coroutine is a “coroutine” class.</p>



<p>We also get a RuntimeError because the coroutine was created but never executed, we will explore that in the next section.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62890645681835" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>&lt;class &#39;coroutine&#39;&gt;</p><p>sys:1: RuntimeWarning: coroutine &#39;custom_coro&#39; was never awaited</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>A coroutine object is an awaitable.</p>



<p>This means it is a Python type that implements the <strong>__await__()</strong> method.</p>



<blockquote>
<p>An awaitable object generally implements an __await__() method. Coroutine objects returned from async def functions are awaitable.</p>
<cite>— <a href="https://docs.python.org/3/reference/datamodel.html#coroutines">Awaitable Objects</a></cite></blockquote>



<p>You can learn more about awaitables in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-awaitable">What is an Asyncio Awaitable in Python</a></li>
</ul>



<h3><span id="How_to_Run_a_Coroutine_From_Python"></span>How to Run a Coroutine From Python<span></span></h3>



<p>Coroutines can be defined and created, but they can only be executed within an event loop.</p>



<blockquote>
<p>The event loop is the core of every asyncio application. Event loops run asynchronous tasks and callbacks, perform network IO operations, and run subprocesses.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-eventloop.html">Asyncio Event Loop</a></cite></blockquote>



<p>The event loop that executes coroutines, manages the cooperative multitasking between coroutines.</p>



<blockquote>
<p>Coroutine objects can only run when the event loop is running.</p>
<cite>— Page 517, <a href="https://amzn.to/3TazSBW">Python in a Nutshell</a>, 2017.</cite></blockquote>



<p>The typical way to start a coroutine event loop is via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run"><strong>asyncio.run()</strong> function</a>.</p>



<p>This function takes one coroutine and returns the value of the coroutine. The provided coroutine can be used as the entry point into the coroutine-based program.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62892476402245" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of running a coroutine</span></p><p><span>import </span><span>asyncio</span></p><p><span># define a coroutine</span></p><p><span>async </span><span>def </span><span>custom_coro</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># await another coroutine</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># execute my custom coroutine</span></p><p><span>    </span><span>await </span><span>custom_coro</span><span>(</span><span>)</span></p><p><span># start the coroutine program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Running the example</p>



<p>Now that we know how to define, create, and run a coroutine, let’s take a moment to understand the event loop.</p>



<h2><span id="What_is_the_Event_Loop"></span>What is the Event Loop<span></span></h2>



<p>The heart of asyncio programs is the event loop.</p>



<p>In this section, we will take a moment to look at the asyncio event loop.</p>



<h3><span id="What_is_the_Asyncio_Event_Loop"></span>What is the Asyncio Event Loop<span></span></h3>



<p>The event loop is an environment for executing coroutines in a single thread.</p>



<blockquote>
<p>asyncio is a library to execute these coroutines in an asynchronous fashion using a concurrency model known as a single-threaded event loop.</p>
<cite>— Page 3, <a href="https://amzn.to/3VVaq59">Python Concurrency with asyncio</a>, 2022.</cite></blockquote>



<p>The event loop is the core of an asyncio program.</p>



<p>It does many things, such as:</p>



<ol>
<li>Execute coroutines.</li>



<li>Execute callbacks.</li>



<li>Perform network input/output.</li>



<li>Run subprocesses.</li>
</ol>



<blockquote>
<p>The event loop is the core of every asyncio application. Event loops run asynchronous tasks and callbacks, perform network IO operations, and run subprocesses.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-eventloop.html">Asyncio Event Loop</a></cite></blockquote>



<p>Event loops are a common design pattern and became very popular in recent times given their use in JavaScript.</p>



<blockquote>
<p>JavaScript has a runtime model based on an event loop, which is responsible for executing the code, collecting and processing events, and executing queued sub-tasks. This model is quite different from models in other languages like C and Java.</p>
<cite>— <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">The event loop, Mozilla</a>.</cite></blockquote>



<p>The event loop, as its name suggests, is a loop. It manages a list of tasks (coroutines) and attempts to progress each in sequence in each iteration of the loop, as well as perform other tasks like executing callbacks and handling I/O.</p>



<p>The “<strong>asyncio</strong>” module provides functions for accessing and interacting with the event loop.</p>



<p>This is not required for typical application development.</p>



<p>Instead, access to the event loop is provided for framework developers, those that want to build on top of the asyncio module or enable asyncio for their library.</p>



<blockquote>
<p>Application developers should typically use the high-level asyncio functions, such as asyncio.run(), and should rarely need to reference the loop object or call its methods.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-eventloop.html">Asyncio Event Loop</a></cite></blockquote>



<p>The asyncio module provides a low-level API for getting access to the current event loop object, as well as a suite of methods that can be used to interact with the event loop.</p>



<p>The low-level API is intended for framework developers that will extend, complement and integrate asyncio into third-party libraries.</p>



<p>We rarely need to interact with the event loop in asyncio programs, in favor of using the high-level API instead.</p>



<p>Nevertheless, we can briefly explore how to get the event loop.</p>



<h3><span id="How_To_Start_and_Get_An_Event_Loop"></span>How To Start and Get An Event Loop<span></span></h3>



<p>The typical way we create an event loop in asyncio applications is via the <strong>asyncio.run()</strong> function.</p>



<blockquote>
<p>This function always creates a new event loop and closes it at the end. It should be used as a main entry point for asyncio programs, and should ideally only be called once.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html">Asyncio Coroutines and Tasks</a></cite></blockquote>



<p>The function takes a coroutine and will execute it to completion.</p>



<p>We typically pass it to our main coroutine and run our program from there.</p>



<p>There are low-level functions for creating and accessing the event loop.</p>



<p>The <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.new_event_loop"><strong>asyncio.new_event_loop()</strong> function</a> will create a new event loop and return access to it.</p>



<blockquote>
<p>Create and return a new event loop object.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-eventloop.html">Asyncio Event Loop</a></cite></blockquote>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62894291029898" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create and access a new asyncio event loop</span></p><p><span>loop</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>new_event_loop</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can demonstrate this with a worked example.</p>



<p>In the example below we will create a new event loop and then report its details.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62896967003975" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of creating an event loop</span></p><p><span>import </span><span>asyncio</span></p><p><span># create and access a new asyncio event loop</span></p><p><span>loop</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>new_event_loop</span><span>(</span><span>)</span></p><p><span># report defaults of the loop</span></p><p><span>print</span><span>(</span><span>loop</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Running the example creates the event loop, then reports the details of the object.</p>



<p>We can see that in this case the event loop has the type <strong>_UnixSelectorEventLoop</strong> and is not running, but is also not closed.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62897097730507" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>&lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>If an asyncio event loop is already running, we can get access to it via the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><strong>asyncio.get_running_loop()</strong> function</a>.</p>



<blockquote>
<p>Return the running event loop in the current OS thread. If there is no running event loop a RuntimeError is raised. This function can only be called from a coroutine or a callback.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-eventloop.html">Asyncio Event Loop</a></cite></blockquote>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62899000523904" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># access he running event loop</span></p><p><span>loop</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>get_running_loop</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>There is also a function for getting or starting the event loop called <strong><a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_event_loop">asyncio.get_event_loop()</a></strong>, but it was deprecated in Python 3.10 and should not be used.</p>



<h3><span id="What_is_an_Event_Loop_Object"></span>What is an Event Loop Object<span></span></h3>



<p>An event loop is implemented as a Python object.</p>



<p>The event loop object defines how the event loop is implemented and provides a common API for interacting with the loop, defined on the <a href="https://github.com/python/cpython/blob/3.10/Lib/asyncio/events.py#L204"><strong>AbstractEventLoop</strong> class</a>.</p>



<p>There are <a href="https://docs.python.org/3/library/asyncio-eventloop.html#event-loop-implementations">different implementations</a> of the event loop for different platforms.</p>



<p>For example, Windows and Unix-based operations systems will implement the event loop in different ways, given the different underlying ways that non-blocking I/O is implemented on these platforms.</p>



<p>The <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.SelectorEventLoop"><strong>SelectorEventLoop</strong> type event loop</a> is the default on Unix-based operating systems like Linux and macOS.</p>



<p>The <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.ProactorEventLoop"><strong>ProactorEventLoop</strong> type event loop</a> is the default on Windows.</p>



<p>Third-party libraries may implement their own event loops to optimize for specific features.</p>



<h3><span id="Why_Get_Access_to_The_Event_Loop"></span>Why Get Access to The Event Loop<span></span></h3>



<p>Why would we want access to an event loop outside of an asyncio program?</p>



<p>There are many reasons why we may want access to the event loop from outside of a running asyncio program.</p>



<p>For example:</p>



<ol>
<li>To monitor the progress of tasks.</li>



<li>To issue and get results from tasks.</li>



<li>To fire and forget one-off tasks.</li>
</ol>



<p>An asyncio event loop can be used in a program as an alternative to a thread pool for coroutine-based tasks.</p>



<p>An event loop may also be embedded within a normal asyncio program and accessed as needed.</p>



<p>Now that we know a little about the event loop, let’s look at asyncio tasks.</p>



<h2><span id="Create_and_Run_Asyncio_Tasks"></span>Create and Run Asyncio Tasks<span></span></h2>



<p>You can create Task objects from coroutines in asyncio programs.</p>



<p>Tasks provide a handle on independently scheduled and running coroutines and allow the task to be queried, canceled, and results and exceptions to be retrieved later.</p>



<p>The asyncio event loop manages tasks. As such, all coroutines become and are managed as tasks within the event loop.</p>



<p>Let’s take a closer look at asyncio tasks.</p>



<h3><span id="What_is_an_Asyncio_Task"></span>What is an Asyncio Task<span></span></h3>



<p>A Task is an object that schedules and independently runs an asyncio coroutine.</p>



<p>It provides a handle on a scheduled coroutine that an asyncio program can query and use to interact with the coroutine.</p>



<blockquote>
<p>A Task is an object that manages an independently running coroutine.</p>
<cite>— <a href="https://peps.python.org/pep-3156/">PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module</a></cite></blockquote>



<p>A task is created from a coroutine. It requires a coroutine object, wraps the coroutine, schedules it for execution, and provides ways to interact with it.</p>



<p>A task is executed independently. This means it is scheduled in the asyncio event loop and will execute regardless of what else happens in the coroutine that created it. This is different from executing a coroutine directly, where the caller must wait for it to complete.</p>



<blockquote>
<p>Tasks are used to schedule coroutines concurrently. When a coroutine is wrapped into a Task with functions like asyncio.create_task() the coroutine is automatically scheduled to run soon</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></cite></blockquote>



<p>The <a href="https://docs.python.org/3/library/asyncio-task.html#task-object"><strong>asyncio.Task</strong> class</a> extends the <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future"><strong>asyncio.Future</strong> class</a> and an instance are awaitable.</p>



<p>A <strong>Future</strong> is a lower-level class that represents a result that will eventually arrive.</p>



<blockquote>
<p>A Future is a special low-level awaitable object that represents an eventual result of an asynchronous operation.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></cite></blockquote>



<p>Classes that extend the Future class are often referred to as <strong>Future</strong>-like.</p>



<blockquote>
<p>A Future-like object that runs a Python coroutine.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></cite></blockquote>



<p>Because a <strong>Task</strong> is awaitable it means that a coroutine can wait for a task to be done using the await expression.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6289b104918019" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for a task to be done</span></p><p><span>await </span><span>task</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Now that we know what an asyncio task is, let’s look at how we might create one.</p>



<h3><span id="How_to_Create_a_Task"></span>How to Create a Task<span></span></h3>



<p>A task is created using a provided coroutine instance.</p>



<p>Recall that a coroutine is defined using the async def expression and looks like a function.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6289d475146238" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define a coroutine</span></p><p><span>async </span><span>def </span><span>task_coroutine</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>A task can only be created and scheduled within a coroutine.</p>



<p>There are two main ways to create and schedule a task, they are:</p>



<ol>
<li>Create Task With High-Level API (preferred)</li>



<li>Create Task With Low-Level API</li>
</ol>



<p>Let’s take a closer look at each in turn.</p>



<h4>Create Task With High-Level API</h4>



<p>A task can be created using the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task"><strong>asyncio.create_task()</strong> function</a>.</p>



<p>The <strong>asyncio.create_task()</strong> function takes a coroutine instance and an optional name for the task and returns an <strong>asyncio.Task</strong> instance.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6289e805664879" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a coroutine</span></p><p><span>coro</span><span> </span><span>=</span><span> </span><span>task_coroutine</span><span>(</span><span>)</span></p><p><span># create a task from a coroutine</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>coro</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This can be achieved with a compound statement on a single line.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628a0885713644" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a task from a coroutine</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>task_coroutine</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This will do a few things:</p>



<ol>
<li>Wrap the coroutine in a Task instance.</li>



<li>Schedule the task for execution in the current event loop.</li>



<li>Return a Task instance</li>
</ol>



<p>The task instance can be discarded, interacted with via methods, and awaited by a coroutine.</p>



<p>This is the preferred way to create a Task from a coroutine in an asyncio program.</p>



<h4>Create Task With Low-Level API</h4>



<p>A task can also be created from a coroutine using the lower-level asyncio API.</p>



<p>The first way is to use the <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.ensure_future"><strong>asyncio.ensure_future()</strong> function</a>.</p>



<p>This function takes a <strong>Task</strong>, <strong>Future</strong>, or <strong>Future</strong>-like object, such as a coroutine, and optionally the loop in which to schedule it.</p>



<p>If a loop is not provided, it will be scheduled in the current event loop.</p>



<p>If a coroutine is provided to this function, it is wrapped in a Task instance for us, which is returned.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628a1718693473" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create and schedule the task</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>ensure_future</span><span>(</span><span>task_coroutine</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Another low-level function that we can use to create and schedule a <strong>Task</strong> is the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_task"><strong>loop.create_task()</strong> method</a>.</p>



<p>This function requires access to a specific event loop in which to execute the coroutine as a task.</p>



<p>We can acquire an instance to the current event loop within an asyncio program via the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_event_loop"><strong>asyncio.get_event_loop()</strong> function</a>.</p>



<p>This can then be used to call the <strong>create_task()</strong> method to create a <strong>Task</strong> instance and schedule it for execution.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628a3285199777" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the current event loop</span></p><p><span>loop</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>get_event_loop</span><span>(</span><span>)</span></p><p><span># create and schedule the task</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>loop</span><span>.</span><span>create_task</span><span>(</span><span>task_coroutine</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<h3><span id="When_Does_a_Task_Run"></span>When Does a Task Run?<span></span></h3>



<p>A common question after creating a task is when does it run?</p>



<p>This is a good question.</p>



<p>Although we can schedule a coroutine to run independently as a task with the <strong>create_task()</strong> function, it may not run immediately.</p>



<p>In fact, the task will not execute until the event loop has an opportunity to run.</p>



<p>This will not happen until all other coroutines are not running and it is the task’s turn to run.</p>



<p>For example, if we had an asyncio program with one coroutine that created and scheduled a task, the scheduled task will not run until the calling coroutine that created the task is suspended.</p>



<p>This may happen if the calling coroutine chooses to sleep, chooses to await another coroutine or task, or chooses to await the new task that was scheduled.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628a4288727179" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a task from a coroutine</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>task_coroutine</span><span>(</span><span>)</span><span>)</span></p><p><span># await the task, allowing it to run</span></p><p><span>await </span><span>task</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Now that we know what a task is and how to schedule them, next, let’s look at how we may use them in our programs</p>



<h2><span id="Work_With_and_Query_Tasks"></span>Work With and Query Tasks<span></span></h2>



<p>Tasks are the currency of asyncio programs.</p>



<p>In this section, we will take a closer look at how to interact with them in our programs.</p>



<h3><span id="Task_Life-Cycle"></span>Task Life-Cycle<span></span></h3>



<p>An asyncio Task has a life cycle.</p>



<p>Firstly, a task is created from a coroutine.</p>



<p>It is then scheduled for independent execution within the event loop.</p>



<p>At some point, it will run.</p>



<p>While running it may be suspended, such as awaiting another coroutine or task. It may finish normally and return a result or fail with an exception.</p>



<p>Another coroutine may intervene and cancel the task.</p>



<p>Eventually, it will be done and cannot be executed again.</p>



<p>We can summarize this life-cycle as follows:</p>



<ul>
<li>1. Created</li>



<li>2. Scheduled
<ul>
<li>2a Canceled</li>
</ul>
</li>



<li>3. Running
<ul>
<li>3a. Suspended</li>



<li>3b. Result</li>



<li>3c. Exception</li>



<li>3d. Canceled</li>
</ul>
</li>



<li>4. Done</li>
</ul>



<p>Note that Suspended, Result, Exception, and Canceled are not states per se, they are important points of transition for a running task.</p>



<p>The diagram below summarizes this life cycle showing the transitions between each phase.</p>


<div>
<figure><img decoding="async" width="679" height="595" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%20679%20595&#39;%3E%3C/svg%3E" alt="" data-lazy-srcset="https://superfastpython.com/wp-content/uploads/2022/09/Asyncio-Task-Life-Cycle.png 679w, https://superfastpython.com/wp-content/uploads/2022/09/Asyncio-Task-Life-Cycle-300x263.png 300w" data-lazy-sizes="(max-width: 679px) 100vw, 679px" data-lazy-src="https://superfastpython.com/wp-content/uploads/2022/09/Asyncio-Task-Life-Cycle.png"/><figcaption>Asyncio Task Life-Cycle</figcaption></figure></div>


<p>Now that we are familiar with the life cycle of a task from a high level, let’s take a closer look at each phase.</p>



<h3><span id="How_to_Check_Task_Status"></span>How to Check Task Status<span></span></h3>



<p>After a Task is created, we can check the status of the task.</p>



<p>There are two statuses we might want to check, they are:</p>



<ul>
<li>Whether the task is done.</li>



<li>Whether the task was canceled.</li>
</ul>



<p>Let’s take a closer look at each in turn.</p>



<h4>Check if a Task is Done</h4>



<p>We can check if a task is done via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.done"><strong>done()</strong> method</a>.</p>



<p>The method returns <strong>True</strong> if the task is done, or <strong>False</strong> otherwise.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628a6687507699" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># check if a task is done</span></p><p><span>if</span><span> </span><span>task</span><span>.</span><span>done</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>A task is done if it has had the opportunity to run and is now no longer running.</p>



<p>A task that has been scheduled is not done.</p>



<p>Similarly, a task that is running is not done.</p>



<p>A task is done if:</p>



<ul>
<li>The coroutine finishes normally.</li>



<li>The coroutine returns explicitly.</li>



<li>An unexpected error or exception is raised in the coroutine</li>



<li>The task is canceled.</li>
</ul>



<h4>Check if a Task is Canceled</h4>



<p>We can check if a task is canceled via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancelled"><strong>cancelled()</strong> method</a>.</p>



<p>The method returns <strong>True</strong> if the task was canceled, or <strong>False</strong> otherwise.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628a8018951913" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># check if a task was canceled</span></p><p><span>if</span><span> </span><span>task</span><span>.</span><span>cancelled</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>A task is canceled if the <strong>cancel()</strong> method was called on the task and completed successfully, e..g <strong>cancel()</strong> returned <strong>True</strong>.</p>



<p>A task is not canceled if the <strong>cancel()</strong> method was not called, or if the <strong>cancel()</strong> method was called but failed to cancel the task.</p>



<h3><span id="How_to_Get_Task_Result"></span>How to Get Task Result<span></span></h3>



<p>We can get the result of a task via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.result"><strong>result()</strong> method</a>.</p>



<p>This returns the return value of the coroutine wrapped by the <strong>Task</strong> or <strong>None</strong> if the wrapped coroutine does not explicitly return a value.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628a9529132012" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the return value from the wrapped coroutine</span></p><p><span>value</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>result</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If the coroutine raises an unhandled error or exception, it is re-raised when calling the <strong>result()</strong> method and may need to be handled.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628ab165601424" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span># get the return value from the wrapped coroutine</span></p><p><span>	</span><span>value</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>result</span><span>(</span><span>)</span></p><p><span>except </span><span>Exception</span><span>:</span></p><p><span>	</span><span># task failed and there is no result</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>If the task was canceled, then a <strong>CancelledError</strong> exception is raised when calling the <strong>result()</strong> method and may need to be handled.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628ac362934765" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span># get the return value from the wrapped coroutine</span></p><p><span>	</span><span>value</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>result</span><span>(</span><span>)</span></p><p><span>except </span><span>asyncio</span><span>.</span><span>CancelledError</span><span>:</span></p><p><span>	</span><span># task was canceled</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>As such, it is a good idea to check if the task was canceled first.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628ad609308366" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># check if the task was not canceled</span></p><p><span>if</span><span> </span><span>not</span><span> </span><span>task</span><span>.</span><span>cancelled</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># get the return value from the wrapped coroutine</span></p><p><span>	</span><span>value</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>result</span><span>(</span><span>)</span></p><p><span>else</span><span>:</span></p><p><span>	</span><span># task was canceled</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>If the task is not yet done, then an <strong>InvalidStateError</strong> exception is raised when calling the <strong>result()</strong> method and may need to be handled.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628ae848657675" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span># get the return value from the wrapped coroutine</span></p><p><span>	</span><span>value</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>result</span><span>(</span><span>)</span></p><p><span>except </span><span>asyncio</span><span>.</span><span>InvalidStateError</span><span>:</span></p><p><span>	</span><span># task is not yet done</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>As such, it is a good idea to check if the task is done first.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628af096091565" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># check if the task is not done</span></p><p><span>if</span><span> </span><span>not</span><span> </span><span>task</span><span>.</span><span>done</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span>await </span><span>task</span></p><p><span># get the return value from the wrapped coroutine</span></p><p><span>value</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>result</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<h3><span id="How_to_Get_Task_Exception"></span>How to Get Task Exception<span></span></h3>



<p>A coroutine wrapped by a task may raise an exception that is not handled.</p>



<p>This will cancel the task, in effect.</p>



<p>We can retrieve an unhandled exception in the coroutine wrapped by a task via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.exception"><strong>exception()</strong> method</a>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628b1015086546" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the exception raised by a task</span></p><p><span>exception</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>exception</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If an unhandled exception was not raised in the wrapped coroutine, then a value of None is returned.</p>



<p>If the task was canceled, then a <strong>CancelledError</strong> exception is raised when calling the <strong>exception()</strong> method and may need to be handled.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628b2450031753" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span># get the exception raised by a task</span></p><p><span>	</span><span>exception</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>exception</span><span>(</span><span>)</span></p><p><span>except </span><span>asyncio</span><span>.</span><span>CancelledError</span><span>:</span></p><p><span>	</span><span># task was canceled</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>As such, it is a good idea to check if the task was canceled first.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628b3997056786" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># check if the task was not canceled</span></p><p><span>if</span><span> </span><span>not</span><span> </span><span>task</span><span>.</span><span>cancelled</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># get the exception raised by a task</span></p><p><span>	</span><span>exception</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>exception</span><span>(</span><span>)</span></p><p><span>else</span><span>:</span></p><p><span>	</span><span># task was canceled</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>If the task is not yet done, then an <strong>InvalidStateError</strong> exception is raised when calling the <strong>exception()</strong> method and may need to be handled.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628b4731581066" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span># get the exception raised by a task</span></p><p><span>	</span><span>exception</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>exception</span><span>(</span><span>)</span></p><p><span>except </span><span>asyncio</span><span>.</span><span>InvalidStateError</span><span>:</span></p><p><span>	</span><span># task is not yet done</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>As such, it is a good idea to check if the task is done first.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628b6737112227" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># check if the task is not done</span></p><p><span>if</span><span> </span><span>not</span><span> </span><span>task</span><span>.</span><span>done</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span>await </span><span>task</span></p><p><span># get the exception raised by a task</span></p><p><span>exception</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>exception</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<h3><span id="How_to_Cancel_a_Task"></span>How to Cancel a Task<span></span></h3>



<p>We can cancel a scheduled task via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel"><strong>cancel()</strong> method</a>.</p>



<p>The cancel method returns <strong>True</strong> if the task was canceled, or <strong>False</strong> otherwise.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628b7705218327" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># cancel the task</span></p><p><span>was_cancelled</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>cancel</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If the task is already done, it cannot be canceled and the <strong>cancel()</strong> method will return <strong>False</strong> and the task will not have the status of canceled.</p>



<p>The next time the task is given an opportunity to run, it will raise a <strong>CancelledError</strong> exception.</p>



<p>If the <strong>CancelledError</strong> exception is not handled within the wrapped coroutine, the task will be canceled.</p>



<p>Otherwise, if the <strong>CancelledError</strong> exception is handled within the wrapped coroutine, the task will not be canceled.</p>



<p>The <strong>cancel()</strong> method can also take a message argument which will be used in the content of the <strong>CancelledError</strong>.</p>



<h3><span id="How_to_Use_Callback_With_a_Task"></span>How to Use Callback With a Task<span></span></h3>



<p>We can add a done callback function to a task via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.add_done_callback"><strong>add_done_callback()</strong> method</a>.</p>



<p>This method takes the name of a function to call when the task is done.</p>



<p>The callback function must take the <strong>Task</strong> instance as an argument.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628b8336808033" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># done callback function</span></p><p><span>def </span><span>handle</span><span>(</span><span>task</span><span>)</span><span>:</span></p><p><span>	</span><span>print</span><span>(</span><span>task</span><span>)</span></p><p><span>.</span><span>.</span><span>.</span></p><p><span># register a done callback function</span></p><p><span>task</span><span>.</span><span>add_done_callback</span><span>(</span><span>handle</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Recall that a task may be done when the wrapped coroutine finishes normally when it returns, when an unhandled exception is raised or when the task is canceled.</p>



<p>The <strong>add_done_callback()</strong> method can be used to add or register as many done callback functions as we like.</p>



<p>We can also remove or de-register a callback function via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.remove_done_callback"><strong>remove_done_callback()</strong> function</a>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628b9472489675" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># remove a done callback function</span></p><p><span>task</span><span>.</span><span>remove_done_callback</span><span>(</span><span>handle</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="How_to_Set_the_Task_Name"></span>How to Set the Task Name<span></span></h3>



<p>A task may have a name.</p>



<p>This name can be helpful if multiple tasks are created from the same coroutine and we need some way to tell them apart programmatically.</p>



<p>The name can be set when the task is created from a coroutine via the “<strong>name</strong>” argument.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628bb958665920" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a task from a coroutine</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>task_coroutine</span><span>(</span><span>)</span><span>,</span><span> </span><span>name</span><span>=</span><span>&#39;MyTask&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The name for the task can also be set via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.set_name"><strong>set_name()</strong> method</a>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628bc138076315" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># set the name of the task</span></p><p><span>task</span><span>.</span><span>set_name</span><span>(</span><span>&#39;MyTask&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can retrieve the name of a task via the <strong>get_name()</strong> method.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628bd426324834" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the name of a task</span></p><p><span>name</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>get_name</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h2><span id="Current_and_Running_Tasks"></span>Current and Running Tasks<span></span></h2>



<p>We can introspect tasks running in the asyncio event loop.</p>



<p>This can be achieved by getting an <strong>asyncio.Task</strong> object for the currently running task and for all tasks that are running.</p>



<h3><span id="How_to_Get_the_Current_Task"></span>How to Get the Current Task<span></span></h3>



<p>We can get the current task via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.current_task"><strong>asyncio.current_task()</strong> function</a>.</p>



<p>This function will return a <strong>Task</strong> object for the task that is currently running.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628be998732274" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the current task</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>current_task</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This will return a <strong>Task</strong> object for the currently running task.</p>



<p>This may be:</p>



<ul>
<li>The main coroutine passed to <strong>asyncio.run()</strong>.</li>



<li>A task created and scheduled within the asyncio program via <strong>asyncio.create_task()</strong>.</li>
</ul>



<p>A task may create and run another coroutine (e.g. not wrapped in a task). Getting the current task from within a coroutine will return a <strong>Task</strong> object for the running task, but not the coroutine that is currently running.</p>



<p>Getting the current task can be helpful if a coroutine or task requires details about itself, such as the task name for logging.</p>



<p>We can explore how to get a <strong>Task</strong> instance for the main coroutine used to start an asyncio program.</p>



<p>The example below defines a coroutine used as the entry point into the program. It reports a message, then gets the current task and reports its details.</p>



<p>This is an important first example, as it highlights that all coroutines can be accessed as tasks within the asyncio event loop.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628c0602826010" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of getting the current task from the main coroutine</span></p><p><span>import </span><span>asyncio</span></p><p><span># define a main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;main coroutine started&#39;</span><span>)</span></p><p><span>    </span><span># get the current task</span></p><p><span>    </span><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>current_task</span><span>(</span><span>)</span></p><p><span>    </span><span># report its details</span></p><p><span>    </span><span>print</span><span>(</span><span>task</span><span>)</span></p><p><span># start the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Running the example first creates the main coroutine and uses it to start the asyncio program.</p>



<p>The <strong>main()</strong> coroutine runs and first reports a message.</p>



<p>It then retrieves the current task, which is a <strong>Task</strong> object that represents itself, the currently running coroutine.</p>



<p>It then reports the details of the currently running task.</p>



<p>We can see that the task has the default name for the first task, ‘<em>Task-1</em>‘ and is executing the <strong>main()</strong> coroutine, the currently running coroutine.</p>



<p>This highlights that we can use the <strong>asyncio.current_task()</strong> function to access a <strong>Task</strong> object for the currently running coroutine, that is automatically wrapped in a <strong>Task</strong> object.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628c1622787934" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>main coroutine started</p><p>&lt;Task pending name=&#39;Task-1&#39; coro=&lt;main() running at ...&gt; cb=[_run_until_complete_cb() at ...]&gt;</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<h3><span id="How_to_Get_All_Tasks"></span>How to Get All Tasks<span></span></h3>



<p>We may need to get access to all tasks in an asyncio program.</p>



<p>This may be for many reasons, such as:</p>



<ul>
<li>To introspect the current status or complexity of the program.</li>



<li>To log the details of all running tasks.</li>



<li>To find a task that can be queried or canceled.</li>
</ul>



<p>We can get a set of all scheduled and running (not yet done) tasks in an asyncio program via the <strong>asyncio.all_tasks()</strong> function.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628c3711769282" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get all tasks</span></p><p><span>tasks</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>all_tasks</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This will return a set of all tasks in the asyncio program.</p>



<p>It is a set so that each task is only represented once.</p>



<p>A task will be included if:</p>



<ul>
<li>The task has been scheduled but is not yet running.</li>



<li>The task is currently running (e.g. but is currently suspended)</li>
</ul>



<p>The set will also include a task for the currently running task, e.g. the task that is executing the coroutine that calls the <strong>asyncio.all_tasks()</strong> function.</p>



<p>Also, recall that the <strong>asyncio.run()</strong> method that is used to start an asyncio program will wrap the provided coroutine in a task. This means that the set of all tasks will include the task for the entry point of the program.</p>



<p>We can explore the case where we have many tasks within an asyncio program and then get a set of all tasks.</p>



<p>In this example, we first create 10 tasks, each wrapping and running the same coroutine.</p>



<p>The main coroutine then gets a set of all tasks scheduled or running in the program and reports their details.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628c4612731914" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of starting many tasks and getting access to all tasks</span></p><p><span>import </span><span>asyncio</span></p><p><span># coroutine for a task</span></p><p><span>async </span><span>def </span><span>task_coroutine</span><span>(</span><span>value</span><span>)</span><span>:</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;task {value} is running&#39;</span><span>)</span></p><p><span>    </span><span># block for a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span># define a main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;main coroutine started&#39;</span><span>)</span></p><p><span>    </span><span># start many tasks</span></p><p><span>    </span><span>started_tasks</span><span> </span><span>=</span><span> </span><span>[</span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>task_coroutine</span><span>(</span><span>i</span><span>)</span><span>)</span><span> </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>)</span><span>]</span></p><p><span>    </span><span># allow some of the tasks time to start</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0.1</span><span>)</span></p><p><span>    </span><span># get all tasks</span></p><p><span>    </span><span>tasks</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>all_tasks</span><span>(</span><span>)</span></p><p><span>    </span><span># report all tasks</span></p><p><span>    </span><span>for</span><span> </span><span>task </span><span>in</span><span> </span><span>tasks</span><span>:</span></p><p><span>        </span><span>print</span><span>(</span><span>f</span><span>&#39;&gt; {task.get_name()}, {task.get_coro()}&#39;</span><span>)</span></p><p><span>    </span><span># wait for all tasks to complete</span></p><p><span>    </span><span>for</span><span> </span><span>task </span><span>in</span><span> </span><span>started_tasks</span><span>:</span></p><p><span>        </span><span>await </span><span>task</span></p><p><span># start the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
</div>



<p>Running the example first creates the main coroutine and uses it to start the asyncio program.</p>



<p>The <strong>main()</strong> coroutine runs and first reports a message.</p>



<p>It then creates and schedules 10 tasks that wrap the custom coroutine,</p>



<p>The <strong>main()</strong> coroutine then blocks for a moment to allow the tasks to begin running.</p>



<p>The tasks start running and each reports a message and then sleeps.</p>



<p>The <strong>main()</strong> coroutine resumes and gets a list of all tasks in the program.</p>



<p>It then reports the name and coroutine of each.</p>



<p>Finally, it enumerates the list of tasks that were created and awaits each, allowing them to be completed.</p>



<p>This highlights that we can get a set of all tasks in an asyncio program that includes both the tasks that were created as well as the task that represents the entry point into the program.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628d0554322804" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p></div>
				</td>
						<td><div><p>main coroutine started</p><p>task 0 is running</p><p>task 1 is running</p><p>task 2 is running</p><p>task 3 is running</p><p>task 4 is running</p><p>task 5 is running</p><p>task 6 is running</p><p>task 7 is running</p><p>task 8 is running</p><p>task 9 is running</p><p>&gt; Task-9, &lt;coroutine object task_coroutine at 0x10e186e30&gt;</p><p>&gt; Task-2, &lt;coroutine object task_coroutine at 0x10e184e40&gt;</p><p>&gt; Task-11, &lt;coroutine object task_coroutine at 0x10e186f10&gt;</p><p>&gt; Task-7, &lt;coroutine object task_coroutine at 0x10e186d50&gt;</p><p>&gt; Task-4, &lt;coroutine object task_coroutine at 0x10e185700&gt;</p><p>&gt; Task-10, &lt;coroutine object task_coroutine at 0x10e186ea0&gt;</p><p>&gt; Task-8, &lt;coroutine object task_coroutine at 0x10e186dc0&gt;</p><p>&gt; Task-5, &lt;coroutine object task_coroutine at 0x10e186ab0&gt;</p><p>&gt; Task-1, &lt;coroutine object main at 0x10e1847b0&gt;</p><p>&gt; Task-3, &lt;coroutine object task_coroutine at 0x10e184f90&gt;</p><p>&gt; Task-6, &lt;coroutine object task_coroutine at 0x10e186ce0&gt;</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Next, we will explore how to run many coroutines concurrently.</p>



<h2><span id="Run_Many_Coroutines_Concurrently"></span>Run Many Coroutines Concurrently<span></span></h2>



<p>A benefit of asyncio is that we can run many coroutines concurrently.</p>



<p>These coroutines can be created in a group and stored, then executed all together at the same time.</p>



<p>This can be achieved using the <strong>asyncio.gather()</strong> function.</p>



<p>Let’s take a closer look.</p>



<h3><span id="What_is_Asyncio_gather"></span>What is Asyncio gather()<span></span></h3>



<p>The <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather"><strong>asyncio.gather()</strong> module</a> function allows the caller to group multiple awaitables together.</p>



<p>Once grouped, the awaitables can be executed concurrently, awaited, and canceled.</p>



<blockquote>
<p>Run awaitable objects in the aws sequence concurrently.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></cite></blockquote>



<p>It is a helpful utility function for both grouping and executing multiple coroutines or multiple tasks.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628d1692569889" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># run a collection of awaitables</span></p><p><span>results</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>coro1</span><span>(</span><span>)</span><span>,</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>coro2</span><span>(</span><span>)</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>We may use the <strong>asyncio.gather()</strong> function in situations where we may create many tasks or coroutines up-front and then wish to execute them all at once and wait for them all to complete before continuing on.</p>



<p>This is a likely situation where the result is required from many like-tasks, e.g. same task or coroutine with different data.</p>



<p>The awaitables can be executed concurrently, results returned, and the main program can resume by making use of the results on which it is dependent.</p>



<p>The <strong>gather()</strong> function is more powerful than simply waiting for tasks to complete.</p>



<p>It allows a group of awaitables to be treated as a single awaitable.</p>



<p>This allows:</p>



<ul>
<li>Executing and waiting for all awaitables in the group to be done via an await expression.</li>



<li>Getting results from all grouped awaitables to be retrieved later via the result() method.</li>



<li>The group of awaitables to be canceled via the cancel() method.</li>



<li>Checking if all awaitables in the group are done via the done() method.</li>



<li>Executing callback functions only when all tasks in the group are done.</li>
</ul>



<p>And more.</p>



<h3><span id="How_to_use_Asyncio_gather"></span>How to use Asyncio gather()<span></span></h3>



<p>In this section, we will take a closer look at how we might use the <strong>asyncio.gather()</strong> function.</p>



<p>The <strong>asyncio.gather()</strong> function takes one or more awaitables as arguments.</p>



<p>Recall an awaitable may be a coroutine, a <strong>Future</strong> or a <strong>Task</strong>.</p>



<p>Therefore, we can call the <strong>gather()</strong> function with:</p>



<ul>
<li>Multiple tasks</li>



<li>Multiple coroutines</li>



<li>Mixture of tasks and coroutines</li>
</ul>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628d3970620964" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute multiple coroutines</span></p><p><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>coro1</span><span>(</span><span>)</span><span>,</span><span> </span><span>coro2</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If <strong>Task</strong> objects are provided to <strong>gather()</strong>, they will already be running because <strong>Tasks</strong> are scheduled as part of being created.</p>



<p>The <strong>asyncio.gather()</strong> function takes awaitables as position arguments.</p>



<p>We cannot create a list or collection of awaitables and provide it to gather, as this will result in an error.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628d4556279318" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># cannot provide a list of awaitables directly</span></p><p><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>[</span><span>coro1</span><span>(</span><span>)</span><span>,</span><span> </span><span>coro2</span><span>(</span><span>)</span><span>]</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>A list of awaitables can be provided if it is first unpacked into separate expressions using the star operator (*).</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628d5596303524" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># gather with an unpacked list of awaitables</span></p><p><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>*</span><span>[</span><span>coro1</span><span>(</span><span>)</span><span>,</span><span> </span><span>coro2</span><span>(</span><span>)</span><span>]</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If coroutines are provided to <strong>gather()</strong>, they are wrapped in <strong>Task</strong> objects automatically.</p>



<p>The <strong>gather()</strong> function does not block.</p>



<p>Instead, it returns an <strong><a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future">asyncio.Future</a></strong> object that represents the group of awaitables.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628d6166363960" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get a future that represents multiple awaitables</span></p><p><span>group</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>coro1</span><span>(</span><span>)</span><span>,</span><span> </span><span>coro2</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Once the <strong>Future</strong> object is created it is scheduled automatically within the event loop.</p>



<p>The awaitable represents the group, and all awaitables in the group will execute as soon as they are able.</p>



<p>This means that if the caller did nothing else, the scheduled group of awaitables will run (assuming the caller suspends).</p>



<p>It also means that you do not have to await the <strong>Future</strong> that is returned from <strong>gather()</strong>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628d8961075301" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get a future that represents multiple awaitables</span></p><p><span>group</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>coro1</span><span>(</span><span>)</span><span>,</span><span> </span><span>coro2</span><span>(</span><span>)</span><span>)</span></p><p><span># suspend and wait a while, the group may be executing..</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>10</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>The returned Future object can be awaited which will wait for all awaitables in the group to be done.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628d9569881706" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># run the group of awaitables</span></p><p><span>await </span><span>group</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Awaiting the Future returned from <strong>gather()</strong> will return a list of return values from the awaitables.</p>



<p>If the awaitables do not return a value, then this list will contain the default “<strong>None</strong>” return value.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628da949353180" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># run the group of awaitables and get return values</span></p><p><span>results</span><span> </span><span>=</span><span> </span><span>await </span><span>group</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This is more commonly performed in one line.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628db973805079" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># run tasks and get results on one line</span></p><p><span>results</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>coro1</span><span>(</span><span>)</span><span>,</span><span> </span><span>coro2</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="Example_of_gather_For_Many_Coroutines_in_a_List"></span>Example of gather() For Many Coroutines in a List<span></span></h3>



<p>It is common to create multiple coroutines beforehand and then gather them later.</p>



<p>This allows a program to prepare the tasks that are to be executed concurrently and then trigger their concurrent execution all at once and wait for them to complete.</p>



<p>We can collect many coroutines together into a list either manually or using a list comprehension.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628dd234032708" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create many coroutines</span></p><p><span>coros</span><span> </span><span>=</span><span> </span><span>[</span><span>task_coro</span><span>(</span><span>i</span><span>)</span><span> </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>)</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can then call <strong>gather()</strong> with all coroutines in the list.</p>



<p>The list of coroutines cannot be provided directly to the <strong>gather()</strong> function as this will result in an error.</p>



<p>Instead, the <strong>gather()</strong> function requires each awaitable to be provided as a separate positional argument.</p>



<p>This can be achieved by unwrapping the list into separate expressions and passing them to the <strong>gather()</strong> function. The star operator (<strong>*</strong>) will perform this operation for us.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628de799974688" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># run the tasks</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>*</span><span>coros</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Tying this together, the complete example of running a list of pre-prepared coroutines with <strong>gather()</strong> is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628df885833292" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of gather for many coroutines in a list</span></p><p><span>import </span><span>asyncio</span></p><p><span># coroutine used for a task</span></p><p><span>async </span><span>def </span><span>task_coro</span><span>(</span><span>value</span><span>)</span><span>:</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;&gt;task {value} executing&#39;</span><span>)</span></p><p><span>    </span><span># sleep for a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span># coroutine used for the entry point</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;main starting&#39;</span><span>)</span></p><p><span>    </span><span># create many coroutines</span></p><p><span>    </span><span>coros</span><span> </span><span>=</span><span> </span><span>[</span><span>task_coro</span><span>(</span><span>i</span><span>)</span><span> </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>)</span><span>]</span></p><p><span>    </span><span># run the tasks</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>*</span><span>coros</span><span>)</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;main done&#39;</span><span>)</span></p><p><span># start the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
</div>



<p>Running the example executes the <strong>main()</strong> coroutine as the entry point to the program.</p>



<p>The <strong>main()</strong> coroutine then creates a list of 10 coroutine objects using a list comprehension.</p>



<p>This list is then provided to the <strong>gather()</strong> function and unpacked into 10 separate expressions using the star operator.</p>



<p>The <strong>main()</strong> coroutine then awaits the Future object returned from the call to gather(), suspending and waiting for all scheduled coroutines to complete their execution.</p>



<p>The coroutines run as soon as they are able, reporting their unique messages and sleeping before terminating.</p>



<p>Only after all coroutines in the group are complete does the <strong>main()</strong> coroutine resume and report its final message.</p>



<p>This highlights how we might prepare a collection of coroutines and provide them as separate expressions to the <strong>gather()</strong> function.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628e0490201598" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>main starting</p><p>&gt;task 0 executing</p><p>&gt;task 1 executing</p><p>&gt;task 2 executing</p><p>&gt;task 3 executing</p><p>&gt;task 4 executing</p><p>&gt;task 5 executing</p><p>&gt;task 6 executing</p><p>&gt;task 7 executing</p><p>&gt;task 8 executing</p><p>&gt;task 9 executing</p><p>main done</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Next, we will explore how to wait on a group of asyncio tasks.</p>



<h2><span id="Wait_for_A_Collection_of_Tasks"></span>Wait for A Collection of Tasks<span></span></h2>



<p>We can wait for asyncio tasks to complete via the <strong>asyncio.wait()</strong> function.</p>



<p>Different conditions can be waited for, such as all tasks to complete, the first task to complete, and the first task to fail with an exception.</p>



<p>Let’s take a closer look.</p>



<h3><span id="What_is_asynciowait"></span>What is asyncio.wait()<span></span></h3>



<p>The <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait"><strong>asyncio.wait()</strong> function</a> can be used to wait for a collection of asyncio tasks to complete.</p>



<p>Recall that an asyncio task is an instance of the <strong>asyncio.Task</strong> class that wraps a coroutine. It allows a coroutine to be scheduled and executed independently, and the <strong>Task</strong> instance provides a handle on the task for querying status and getting results.</p>



<p>You can learn more about asyncio tasks in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-task">What is an Asyncio Task</a></li>
</ul>



<p>The wait() function allows us to wait for a collection of tasks to be done.</p>



<p>The call to wait can be configured to wait for different conditions, such as all tasks being completed, the first task completed and the first task failing with an error.</p>



<p>Next, let’s look at how we might use the wait() function.</p>



<h3><span id="How_to_Use_asynciowait"></span>How to Use asyncio.wait()<span></span></h3>



<p>The <strong>asyncio.wait()</strong> function takes a collection of awaitables, typically <strong>Task</strong> objects.</p>



<p>This could be a <strong>list</strong>, <strong>dict,</strong> or <strong>set</strong> of task objects that we have created, such as via calls to the <strong>asyncio.create_task()</strong> function in a list comprehension.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628e2249124346" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create many tasks</span></p><p><span>tasks</span><span> </span><span>=</span><span> </span><span>[</span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>task_coro</span><span>(</span><span>i</span><span>)</span><span>)</span><span> </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>)</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>The <strong>asyncio.wait()</strong> will not return until some condition on the collection of tasks is met.</p>



<p>By default, the condition is that all tasks are completed.</p>



<p>The <strong>wait()</strong> function returns a tuple of two sets. The first set contains all task objects that meet the condition, and the second contains all other task objects that do not yet meet the condition.</p>



<p>These sets are referred to as the “<strong>done</strong>” set and the “<strong>pending</strong>” set.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628e3536402701" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for all tasks to complete</span></p><p><span>done</span><span>,</span><span> </span><span>pending</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>tasks</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Technically, the <strong>asyncio.wait()</strong> is a coroutine function that returns a coroutine.</p>



<p>We can then await this coroutine which will return the tuple of sets.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628e5504008645" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create the wait coroutine</span></p><p><span>wait_coro</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>tasks</span><span>)</span></p><p><span># await the wait coroutine</span></p><p><span>tuple</span><span> </span><span>=</span><span> </span><span>await </span><span>wait_coro</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The condition waited for can be specified by the “<strong>return_when</strong>” argument which is set to <strong>asyncio.ALL_COMPLETED</strong> by default.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628e6511627368" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for all tasks to complete</span></p><p><span>done</span><span>,</span><span> </span><span>pending</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>tasks</span><span>,</span><span> </span><span>return_when</span><span>=</span><span>asyncio</span><span>.</span><span>ALL_COMPLETED</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can wait for the first task to be completed by setting <strong>return_when</strong> to <strong>FIRST_COMPLETED</strong>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628e7020519514" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for the first task to be completed</span></p><p><span>done</span><span>,</span><span> </span><span>pending</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>tasks</span><span>,</span><span> </span><span>return_when</span><span>=</span><span>asyncio</span><span>.</span><span>FIRST_COMPLETED</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>When the first task is complete and returned in the done set, the remaining tasks are not canceled and continue to execute concurrently.</p>



<p>We can wait for the first task to fail with an exception by setting <strong>return_when</strong> to <strong>FIRST_EXCEPTION</strong>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628e8169223627" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for the first task to fail</span></p><p><span>done</span><span>,</span><span> </span><span>pending</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>tasks</span><span>,</span><span> </span><span>return_when</span><span>=</span><span>asyncio</span><span>.</span><span>FIRST_EXCEPTION</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>In this case, the done set will contain the first task that failed with an exception. If no task fails with an exception, the done set will contain all tasks and <strong>wait()</strong> will return only after all tasks are completed.</p>



<p>We can specify how long we are willing to wait for the given condition via a “timeout” argument in seconds.</p>



<p>If the timeout expires before the condition is met, the tuple of tasks is returned with whatever subset of tasks do meet the condition at that time, e.g. the subset of tasks that are completed if waiting for all tasks to complete.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628e9574673046" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for all tasks to complete with a timeout</span></p><p><span>done</span><span>,</span><span> </span><span>pending</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>tasks</span><span>,</span><span> </span><span>timeout</span><span>=</span><span>3</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If the timeout is reached before the condition is met, an exception is not raised and the remaining tasks are not canceled.</p>



<p>Now that we know how to use the <strong>asyncio.wait()</strong> function, let’s look at some worked examples.</p>



<h3><span id="Example_of_Waiting_for_All_Tasks"></span>Example of Waiting for All Tasks<span></span></h3>



<p>We can explore how to wait for all tasks using <strong>asyncio.wait()</strong>.</p>



<p>In this example, we will define a simple task coroutine that generates a random value, sleeps for a fraction of a second, then reports a message with the generated value.</p>



<p>The main coroutine will then create many tasks in a list comprehension with the coroutine and then wait for all tasks to be completed.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628ea033568394" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of waiting for all tasks to complete</span></p><p><span>from </span><span>random </span><span>import </span><span>random</span></p><p><span>import </span><span>asyncio</span></p><p><span># coroutine to execute in a new task</span></p><p><span>async </span><span>def </span><span>task_coro</span><span>(</span><span>arg</span><span>)</span><span>:</span></p><p><span>    </span><span># generate a random value between 0 and 1</span></p><p><span>    </span><span>value</span><span> </span><span>=</span><span> </span><span>random</span><span>(</span><span>)</span></p><p><span>    </span><span># block for a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>value</span><span>)</span></p><p><span>    </span><span># report the value</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;&gt;task {arg} done with {value}&#39;</span><span>)</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># create many tasks</span></p><p><span>    </span><span>tasks</span><span> </span><span>=</span><span> </span><span>[</span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>task_coro</span><span>(</span><span>i</span><span>)</span><span>)</span><span> </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>)</span><span>]</span></p><p><span>    </span><span># wait for all tasks to complete</span></p><p><span>    </span><span>done</span><span>,</span><span>pending</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>tasks</span><span>)</span></p><p><span>    </span><span># report results</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;All done&#39;</span><span>)</span></p><p><span># start the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and uses it as the entry point into the asyncio program.</p>



<p>The <strong>main()</strong> coroutine then creates a list of ten tasks in a list comprehension, each providing a unique integer argument from 0 to 9.</p>



<p>The <strong>main()</strong> coroutine is then suspended and waits for all tasks to complete.</p>



<p>The tasks execute. Each generates a random value, sleeps for a moment, then reports its generated value.</p>



<p>After all tasks have been completed, the <strong>main()</strong> coroutine resumes and reports a final message.</p>



<p>This example highlights how we can use the <strong>wait()</strong> function to wait for a collection of tasks to be completed.</p>



<p>This is perhaps the most common usage of the function.</p>



<p>Note, that the results will differ each time the program is run given the use of random numbers.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628ec291219296" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>&gt;task 5 done with 0.0591009105682192</p><p>&gt;task 8 done with 0.10453715687017351</p><p>&gt;task 0 done with 0.15462838864295925</p><p>&gt;task 6 done with 0.4103492027393125</p><p>&gt;task 9 done with 0.45567100006991623</p><p>&gt;task 2 done with 0.6984682905809402</p><p>&gt;task 7 done with 0.7785363531316224</p><p>&gt;task 3 done with 0.827386088873161</p><p>&gt;task 4 done with 0.9481344994700972</p><p>&gt;task 1 done with 0.9577302665040541</p><p>All done</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Next, we will explore how to wait for a single coroutine with a time limit.</p>



<h2><span id="Wait_for_a_Coroutine_with_a_Time_Limit"></span>Wait for a Coroutine with a Time Limit<span></span></h2>



<p>We can wait for an asyncio task or coroutine to complete with a timeout using the <strong>asyncio.wait_for()</strong> function.</p>



<p>If the timeout elapses before the task completes, the task is canceled.</p>



<p>Let’s take a closer look.</p>



<h3><span id="What_is_Asyncio_wait_for"></span>What is Asyncio wait_for()<span></span></h3>



<p>The <strong>asyncio.wait_for()</strong> function allows the caller to wait for an asyncio task or coroutine to complete with a timeout.</p>



<p>If no timeout is specified, the <strong>wait_for()</strong> function will wait until the task is completed.</p>



<p>If a timeout is specified and elapses before the task is complete, then the task is canceled.</p>



<blockquote>
<p>Wait for the aw awaitable to complete with a timeout.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></cite></blockquote>



<p>This allows the caller to both set an expectation about how long they are willing to wait for a task to complete, and to enforce the timeout by canceling the task if the timeout elapses.</p>



<p>Now that we know what the <strong>asyncio.wait_for()</strong> function is, let’s look at how to use it.</p>



<h3><span id="How_to_Use_Asyncio_wait_for"></span>How to Use Asyncio wait_for()<span></span></h3>



<p>The <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for"><strong>asyncio.wait_for()</strong> function</a> takes an awaitable and a timeout.</p>



<p>The awaitable may be a coroutine or a task.</p>



<p>A timeout must be specified and may be <strong>None</strong> for no timeout, an integer or floating point number of seconds.</p>



<p>The <strong>wait_for()</strong> function returns a coroutine that is not executed until it is explicitly awaited or scheduled as a task.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628ed759221107" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for a task to complete</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>wait_for</span><span>(</span><span>coro</span><span>,</span><span> </span><span>timeout</span><span>=</span><span>10</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If a coroutine is provided, it will be converted to the task when the <strong>wait_for()</strong> coroutine is executed.</p>



<p>If the timeout elapses before the task is completed, the task is canceled, and an <strong>asyncio.TimeoutError</strong> is raised, which may need to be handled.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628ef297955141" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute a task with a timeout</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span># wait for a task to complete</span></p><p><span>	</span><span>await </span><span>asyncio</span><span>.</span><span>wait_for</span><span>(</span><span>coro</span><span>,</span><span> </span><span>timeout</span><span>=</span><span>1</span><span>)</span></p><p><span>except </span><span>asyncio</span><span>.</span><span>TimeoutError</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If the waited-for task fails with an unhandled exception, the exception will be propagated back to the caller that is awaiting on the <strong>wait_for()</strong> coroutine, in which case it may need to be handled.</p>



<p>For example</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628f0508220223" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute a task that may fail</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span># wait for a task to complete</span></p><p><span>	</span><span>await </span><span>asyncio</span><span>.</span><span>wait_for</span><span>(</span><span>coro</span><span>,</span><span> </span><span>timeout</span><span>=</span><span>1</span><span>)</span></p><p><span>except </span><span>asyncio</span><span>.</span><span>TimeoutError</span><span>:</span></p><p><span>	</span><span># ...</span></p><p><span>except </span><span>Exception</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Next, let’s look at how we can call <strong>wait_for()</strong> with a timeout.</p>



<h3><span id="Example_of_Asyncio_wait_for_With_a_Timeout"></span>Example of Asyncio wait_for() With a Timeout<span></span></h3>



<p>We can explore how to wait for a coroutine with a timeout that elapses before the task is completed.</p>



<p>In this example, we execute a coroutine as above, except the caller waits a fixed timeout of 0.2 seconds or 200 milliseconds.</p>



<p>Recall that one second is equal to 1,000 milliseconds.</p>



<p>The task coroutine is modified so that it sleeps for more than one second, ensuring that the timeout always expires before the task is complete.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628f1228472219" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of waiting for a coroutine with a timeout</span></p><p><span>from </span><span>random </span><span>import </span><span>random</span></p><p><span>import </span><span>asyncio</span></p><p><span># coroutine to execute in a new task</span></p><p><span>async </span><span>def </span><span>task_coro</span><span>(</span><span>arg</span><span>)</span><span>:</span></p><p><span>    </span><span># generate a random value between 0 and 1</span></p><p><span>    </span><span>value</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>+</span><span> </span><span>random</span><span>(</span><span>)</span></p><p><span>    </span><span># report message</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;&gt;task got {value}&#39;</span><span>)</span></p><p><span>    </span><span># block for a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>value</span><span>)</span></p><p><span>    </span><span># report all done</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;&gt;task done&#39;</span><span>)</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># create a task</span></p><p><span>    </span><span>task</span><span> </span><span>=</span><span> </span><span>task_coro</span><span>(</span><span>1</span><span>)</span></p><p><span>    </span><span># execute and wait for the task without a timeout</span></p><p><span>    </span><span>try</span><span>:</span></p><p><span>        </span><span>await </span><span>asyncio</span><span>.</span><span>wait_for</span><span>(</span><span>task</span><span>,</span><span> </span><span>timeout</span><span>=</span><span>0.2</span><span>)</span></p><p><span>    </span><span>except </span><span>asyncio</span><span>.</span><span>TimeoutError</span><span>:</span></p><p><span>        </span><span>print</span><span>(</span><span>&#39;Gave up waiting, task canceled&#39;</span><span>)</span></p><p><span># start the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and uses it as the entry point into the asyncio program.</p>



<p>The <strong>main()</strong> coroutine creates the task coroutine. It then calls <strong>wait_for()</strong> and passes the task coroutine and sets the timeout to 0.2 seconds.</p>



<p>The <strong>main()</strong> coroutine is suspended and the <strong>task_coro()</strong> is executed. It reports a message and sleeps for a moment.</p>



<p>The <strong>main()</strong> coroutine resumes after the timeout has elapsed. The <strong>wait_for()</strong> coroutine cancels the <strong>task_coro()</strong> coroutine and the main() coroutine is suspended.</p>



<p>The <strong>task_coro()</strong> runs again and responds to the request to be terminated. It raises a TimeoutError exception and terminates.</p>



<p>The <strong>main()</strong> coroutine resumes and handles the <strong>TimeoutError</strong> raised by the <strong>task_coro()</strong>.</p>



<p>This highlights how we can call the <strong>wait_for()</strong> function with a timeout and to cancel a task if it is not completed within a timeout.</p>



<p>The output from the program will differ each time it is run given the use of random numbers.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628f2498092403" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>&gt;task got 0.685375224799321</p><p>Gave up waiting, task canceled</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Next, we will explore how we might protect an asyncio task from being canceled.</p>



<h2><span id="Shield_Tasks_from_Cancellation"></span>Shield Tasks from Cancellation<span></span></h2>



<p>Asyncio tasks can be canceled by calling their <strong>cancel()</strong> method.</p>



<p>We can protect a task from being canceled by wrapping it in a call to <strong>asyncio.shield()</strong>.</p>



<p>Let’s take a closer look.</p>



<h3><span id="What_is_Asyncio_shield"></span>What is Asyncio shield()<span></span></h3>



<p>The asyncio.shield() function wraps an awaitable in Future that will absorb requests to be canceled.</p>



<blockquote>
<p>Protect an awaitable object from being cancelled.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></cite></blockquote>



<p>This means the shielded future can be passed around to tasks that may try to cancel it and the cancellation request will look like it was successful, except that the Task or coroutine that is being shielded will continue to run.</p>



<p>It may be useful in asyncio programs where some tasks can be canceled, but others, perhaps with a higher priority cannot.</p>



<p>It may also be useful in programs where some tasks can safely be canceled, such as those that were designed with asyncio in mind, whereas others cannot be safely terminated and therefore must be shielded from cancellation.</p>



<p>Now that we know what <strong>asyncio.shield()</strong> is, let’s look at how to use it.</p>



<h3><span id="How_to_Use_Asyncio_shield"></span>How to Use Asyncio shield()<span></span></h3>



<p>The <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.shield"><strong>asyncio.shield()</strong> function</a> will protect another <strong>Task</strong> or coroutine from being canceled.</p>



<p>It takes an awaitable as an argument and returns an <strong>asyncio.Future</strong> object.</p>



<p>The Future object can then be awaited directly or passed to another task or coroutine.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628f4675905133" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># shield a task from cancellation</span></p><p><span>shielded</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>shield</span><span>(</span><span>task</span><span>)</span></p><p><span># await the shielded task</span></p><p><span>await </span><span>shielded</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The returned <strong>Future</strong> can be canceled by calling the <strong>cancel()</strong> method.</p>



<p>If the inner task is running, the request will be reported as successful.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628f5067422876" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># cancel a shielded task</span></p><p><span>was_canceld</span><span> </span><span>=</span><span> </span><span>shielded</span><span>.</span><span>cancel</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Any coroutines awaiting the <strong>Future</strong> object will raise an <strong>asyncio.CancelledError</strong>, which may need to be handled.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628f6020431982" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span># await the shielded task</span></p><p><span>	</span><span>await </span><span>asyncio</span><span>.</span><span>shield</span><span>(</span><span>task</span><span>)</span></p><p><span>except </span><span>asyncio</span><span>.</span><span>CancelledError</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Importantly, the request for cancellation made on the <strong>Future</strong> object is not propagated to the inner task.</p>



<p>This means that the request for cancellation is absorbed by the shield.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628f7624088913" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a task</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>coro</span><span>(</span><span>)</span><span>)</span></p><p><span># create a shield</span></p><p><span>shield</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>shield</span><span>(</span><span>task</span><span>)</span></p><p><span># cancel the shield (does not cancel the task)</span></p><p><span>shield</span><span>.</span><span>cancel</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If a coroutine is provided to the <strong>asyncio.shield()</strong> function it is wrapped in an <strong>asyncio.Task()</strong> and scheduled immediately.</p>



<p>This means that the shield does not need to be awaited for the inner coroutine to run.</p>



<blockquote>
<p>If aw is a coroutine it is automatically scheduled as a Task.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></cite></blockquote>



<p>If the task that is being shielded is canceled, the cancellation request will be propagated up to the shield, which will also be canceled.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628f8475738909" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a task</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>coro</span><span>(</span><span>)</span><span>)</span></p><p><span># create a shield</span></p><p><span>shield</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>shield</span><span>(</span><span>task</span><span>)</span></p><p><span># cancel the task (also cancels the shield)</span></p><p><span>task</span><span>.</span><span>cancel</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Now that we know how to use the asyncio.shield() function, let’s look at some worked examples.</p>



<h3><span id="Example_of_Asyncio_shield_for_a_Task"></span>Example of Asyncio shield() for a Task<span></span></h3>



<p>We can explore how to protect a task from cancellation using <strong>asyncio.shield()</strong>.</p>



<p>In this example, we define a simple coroutine task that takes an integer argument, sleeps for a second, then returns the argument. The coroutine can then be created and scheduled as a <strong>Task</strong>.</p>



<p>We can define a second coroutine that takes a task, sleeps for a fraction of a second, then cancels the provided task.</p>



<p>In the main coroutine, we can then shield the first task and pass it to the second task, then await the shielded task.</p>



<p>The expectation is that the shield will be canceled and leave the inner task intact. The cancellation will disrupt the main coroutine. We can check the status of the inner task at the end of the program and we expect it to have been completed normally, regardless of the request to cancel made on the shield.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628fa439983723" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of using asyncio shield to protect a task from cancellation</span></p><p><span>import </span><span>asyncio</span></p><p><span># define a simple asynchronous</span></p><p><span>async </span><span>def </span><span>simple_task</span><span>(</span><span>number</span><span>)</span><span>:</span></p><p><span>    </span><span># block for a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span>    </span><span># return the argument</span></p><p><span>    </span><span>return</span><span> </span><span>number</span></p><p><span># cancel the given task after a moment</span></p><p><span>async </span><span>def </span><span>cancel_task</span><span>(</span><span>task</span><span>)</span><span>:</span></p><p><span>    </span><span># block for a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0.2</span><span>)</span></p><p><span>    </span><span># cancel the task</span></p><p><span>    </span><span>was_cancelled</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>cancel</span><span>(</span><span>)</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;cancelled: {was_cancelled}&#39;</span><span>)</span></p><p><span># define a simple coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># create the coroutine</span></p><p><span>    </span><span>coro</span><span> </span><span>=</span><span> </span><span>simple_task</span><span>(</span><span>1</span><span>)</span></p><p><span>    </span><span># create a task</span></p><p><span>    </span><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>coro</span><span>)</span></p><p><span>    </span><span># created the shielded task</span></p><p><span>    </span><span>shielded</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>shield</span><span>(</span><span>task</span><span>)</span></p><p><span>    </span><span># create the task to cancel the previous task</span></p><p><span>    </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>cancel_task</span><span>(</span><span>shielded</span><span>)</span><span>)</span></p><p><span>    </span><span># handle cancellation</span></p><p><span>    </span><span>try</span><span>:</span></p><p><span>        </span><span># await the shielded task</span></p><p><span>        </span><span>result</span><span> </span><span>=</span><span> </span><span>await </span><span>shielded</span></p><p><span>        </span><span># report the result</span></p><p><span>        </span><span>print</span><span>(</span><span>f</span><span>&#39;&gt;got: {result}&#39;</span><span>)</span></p><p><span>    </span><span>except </span><span>asyncio</span><span>.</span><span>CancelledError</span><span>:</span></p><p><span>        </span><span>print</span><span>(</span><span>&#39;shielded was cancelled&#39;</span><span>)</span></p><p><span>    </span><span># wait a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span>    </span><span># report the details of the tasks</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;shielded: {shielded}&#39;</span><span>)</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;task: {task}&#39;</span><span>)</span></p><p><span># start</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and uses it as the entry point into the application.</p>



<p>The task coroutine is created, then it is wrapped and scheduled in a <strong>Task</strong>.</p>



<p>The task is then shielded from cancellation.</p>



<p>The shielded task is then passed to the <strong>cancel_task()</strong> coroutine which is wrapped in a task and scheduled.</p>



<p>The main coroutine then awaits the shielded task, which expects a <strong>CancelledError</strong> exception.</p>



<p>The task runs for a moment then sleeps. The cancellation task runs for a moment, sleeps, resumes then cancels the shielded task. The request to cancel reports that it was successful.</p>



<p>This raises a <strong>CancelledError</strong> exception in the shielded <strong>Future</strong>, although not in the inner task.</p>



<p>The <strong>main()</strong> coroutine resumes and responds to the <strong>CancelledError</strong> exception, reporting a message. It then sleeps for a while longer.</p>



<p>The task resumes, finishes, and returns a value.</p>



<p>Finally, the <strong>main()</strong> coroutine resumes, and reports the status of the shielded future and the inner task. We can see that the shielded future is marked as canceled and yet the inner task is marked as finished normally and provides a return value.</p>



<p>This example highlights how a shield can be used to successfully protect an inner task from cancellation.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628fb036812901" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>cancelled: True</p><p>shielded was cancelled</p><p>shielded: &lt;Future cancelled&gt;</p><p>task: &lt;Task finished name=&#39;Task-2&#39; coro=&lt;simple_task() done, defined at ...&gt; result=1&gt;</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Next, we will explore how to run a blocking task from an asyncio program.</p>



<h2><span id="Run_a_Blocking_Task_in_Asyncio"></span>Run a Blocking Task in Asyncio<span></span></h2>



<p>A blocking task is a task that stops the current thread from progressing.</p>



<p>If a blocking task is executed in an asyncio program it stops the entire event loop, preventing any other coroutines from progressing.</p>



<p>We can run blocking calls asynchronously in an asyncio program via the <strong>asyncio.to_thread()</strong> and <strong>loop.run_in_executor()</strong> functions.</p>



<h3><span id="Need_to_Run_Blocking_Tasks_in_Asyncio"></span>Need to Run Blocking Tasks in Asyncio<span></span></h3>



<p>The focus of asyncio is asynchronous programming and non-blocking IO.</p>



<p>Nevertheless, we often need to execute a blocking function call within an asyncio application.</p>



<p>This could be for many reasons, such as:</p>



<ul>
<li>To execute a CPU-bound task like calculating something.</li>



<li>To execute a blocking IO-bound task like reading or writing from a file.</li>



<li>To call into a third-party library that does not support asyncio yet.</li>
</ul>



<p>Making a blocking call directly in an asyncio program will cause the event loop to stop while the blocking call is executing. It will not allow other coroutines to run in the background.</p>



<p>How can we execute a blocking call in an asyncio program asynchronously?</p>



<h3><span id="How_to_Run_Blocking_Tasks"></span>How to Run Blocking Tasks<span></span></h3>



<p>The asyncio module provides two approaches for executing blocking calls in asyncio programs.</p>



<p>The first is to use the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.to_thread"><strong>asyncio.to_thread()</strong> function</a>.</p>



<p>This is in the high-level API and is intended for application developers.</p>



<p>The <strong>asyncio.to_thread()</strong> function takes a function name to execute and any arguments.</p>



<p>The function is executed in a separate thread. It returns a coroutine that can be awaited or scheduled as an independent task.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628fd697643749" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute a function in a separate thread</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>to_thread</span><span>(</span><span>task</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The task will not begin executing until the returned coroutine is given an opportunity to run in the event loop.</p>



<p>The <strong>asyncio.to_thread()</strong> function creates a <strong>ThreadPoolExecutor</strong> behind the scenes to execute blocking calls.</p>



<p>As such, the <strong>asyncio.to_thread()</strong> function is only appropriate for IO-bound tasks.</p>



<p>An alternative approach is to use the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor"><strong>loop.run_in_executor()</strong> function</a>.</p>



<p>This is in the low-level asyncio API and first requires access to the event loop, such as via the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><strong>asyncio.get_running_loop()</strong> function</a>.</p>



<p>The <strong>loop.run_in_executor()</strong> function takes an executor and a function to execute.</p>



<p>If <strong>None</strong> is provided for the executor, then the default executor is used, which is a <strong>ThreadPoolExecutor</strong>.</p>



<p>The <strong>loop.run_in_executor()</strong> function returns an awaitable that can be awaited if needed. The task will begin executing immediately, so the returned awaitable does not need to be awaited or scheduled for the blocking call to start executing.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628fe305903215" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the event loop</span></p><p><span>loop</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>get_running_loop</span><span>(</span><span>)</span></p><p><span># execute a function in a separate thread</span></p><p><span>await </span><span>loop</span><span>.</span><span>run_in_executor</span><span>(</span><span>None</span><span>,</span><span> </span><span>task</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Alternatively, an executor can be created and passed to the <strong>loop.run_in_executor()</strong> function, which will execute the asynchronous call in the executor.</p>



<p>The caller must manage the executor in this case, shutting it down once the caller is finished with it.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a628ff292636897" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a process pool</span></p><p><span>with </span><span>ProcessPoolExecutor </span><span>as</span><span> </span><span>exe</span><span>:</span></p><p><span>	</span><span># get the event loop</span></p><p><span>	</span><span>loop</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>get_running_loop</span><span>(</span><span>)</span></p><p><span>	</span><span># execute a function in a separate thread</span></p><p><span>	</span><span>await </span><span>loop</span><span>.</span><span>run_in_executor</span><span>(</span><span>exe</span><span>,</span><span> </span><span>task</span><span>)</span></p><p><span>	</span><span># process pool is shutdown automatically...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>These two approaches allow a blocking call to be executed as an asynchronous task in an asyncio program.</p>



<p>Now that we know how to execute blocking calls in an asyncio program, let’s look at some worked examples.</p>



<h3><span id="Example_of_Running_IO-Bound_Task_in_Asyncio_with_to_thread"></span>Example of Running I/O-Bound Task in Asyncio with to_thread()<span></span></h3>



<p>We can explore how to execute a blocking IO-bound call in an asyncio program using <strong>asyncio.to_thread()</strong>.</p>



<p>In this example, we will define a function that blocks the caller for a few seconds. We will then execute this function asynchronously in a thread pool from asyncio using the <strong>asyncio.to_thread()</strong> function.</p>



<p>This will free the caller to continue with other activities.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62901746291019" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of running a blocking io-bound task in asyncio</span></p><p><span>import </span><span>asyncio</span></p><p><span>import </span><span>time</span></p><p><span># a blocking io-bound task</span></p><p><span>def </span><span>blocking_task</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;Task starting&#39;</span><span>)</span></p><p><span>    </span><span># block for a while</span></p><p><span>    </span><span>time</span><span>.</span><span>sleep</span><span>(</span><span>2</span><span>)</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;Task done&#39;</span><span>)</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;Main running the blocking task&#39;</span><span>)</span></p><p><span>    </span><span># create a coroutine for  the blocking task</span></p><p><span>    </span><span>coro</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>to_thread</span><span>(</span><span>blocking_task</span><span>)</span></p><p><span>    </span><span># schedule the task</span></p><p><span>    </span><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>coro</span><span>)</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;Main doing other things&#39;</span><span>)</span></p><p><span>    </span><span># allow the scheduled task to start</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0</span><span>)</span></p><p><span>    </span><span># await the task</span></p><p><span>    </span><span>await </span><span>task</span></p><p><span># run the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and runs it as the entry point into the asyncio program.</p>



<p>The <strong>main()</strong> coroutine runs and reports a message. It then issues a call to the blocking function call to the thread pool. This returns a coroutine,</p>



<p>The coroutine is then wrapped in a <strong>Task</strong> and executed independently.</p>



<p>The <strong>main()</strong> coroutine is free to continue with other activities. In this case, it sleeps for a moment to allow the scheduled task to start executing. This allows the target function to be issued to the <strong>ThreadPoolExecutor</strong> behind the scenes and start running.</p>



<p>The <strong>main()</strong> coroutine then suspends and waits for the task to complete.</p>



<p>The blocking function reports a message, sleeps for 2 seconds, then reports a final message.</p>



<p>This highlights how we can execute a blocking IO-bound task in a separate thread asynchronously from an asyncio program.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62902989509761" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>Main running the blocking task</p><p>Main doing other things</p><p>Task starting</p><p>Task done</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Next, we will explore how to develop and use asynchronous iterators.</p>



<h2><span id="Asynchronous_Iterators"></span>Asynchronous Iterators<span></span></h2>



<p>Iteration is a basic operation in Python.</p>



<p>We can iterate lists, strings, and all manner of other structures.</p>



<p>Asyncio allows us to develop asynchronous iterators.</p>



<p>We can create and use asynchronous iterators in asyncio programs by defining an object that implements the <strong>__aiter__()</strong> and <strong>__anext__()</strong> methods.</p>



<p>Let’s take a closer look.</p>



<h3><span id="What_Are_Asynchronous_Iterators"></span>What Are Asynchronous Iterators<span></span></h3>



<p>An asynchronous iterator is an object that implements the <strong>__aiter__()</strong> and <strong>__anext__()</strong> methods.</p>



<p>Before we take a close look at asynchronous iterators, let’s review classical iterators.</p>



<h4>Iterators</h4>



<p>An iterator is a Python object that implements a specific interface.</p>



<p>Specifically, the <strong>__iter__()</strong> method that returns an instance of the iterator and the <strong>__next__()</strong> method that steps the iterator one cycle and returns a value.</p>



<blockquote>
<p>iterator: An object representing a stream of data. Repeated calls to the iterator’s __next__() method (or passing it to the built-in function next()) return successive items in the stream. When no more data are available a StopIteration exception is raised instead.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>An iterator can be stepped using the <strong>next()</strong> built-in function or traversed using a for loop.</p>



<p>Many Python objects are iterable, most notable are containers such as lists.</p>



<h4>Asynchronous Iterators</h4>



<p>An asynchronous iterator is a Python object that implements a specific interface.</p>



<blockquote>
<p>asynchronous iterator: An object that implements the __aiter__() and __anext__() methods.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>An asynchronous iterator must implement the <strong>__aiter__()</strong> and <strong>__anext__()</strong> methods.</p>



<ul>
<li>The <strong>__aiter__()</strong> method must return an instance of the iterator.</li>



<li>The <strong>__anext__()</strong> method must return an awaitable that steps the iterator.</li>
</ul>



<p>An asynchronous iterator may only be stepped or traversed in an asyncio program, such as within a coroutine.</p>



<p>Asynchronous iterators were introduced in <a href="https://peps.python.org/pep-0492/">PEP 492 – Coroutines with async and await syntax</a>.</p>



<p>An asynchronous iterator can be stepped using the <a href="https://docs.python.org/3/library/functions.html#anext"><strong>anext()</strong> built-in function</a> that returns an awaitable that executes one step of the iterator, e.g. one call to the <strong>__anext__() </strong>method.</p>



<p>An asynchronous iterator can be traversed using the “<strong>async for</strong>” expression that will automatically call <strong>anext()</strong> each iteration and await the returned awaitable in order to retrieve the return value.</p>



<blockquote>
<p>An asynchronous iterable is able to call asynchronous code in its iter implementation, and asynchronous iterator can call asynchronous code in its next method.</p>
<cite>— <a href="https://peps.python.org/pep-0492/">PEP 492 – Coroutines with async and await syntax</a></cite></blockquote>



<h3><span id="What_is_the_async_for_loop"></span>What is the “async for” loop?<span></span></h3>



<p>The async for expression is used to traverse an asynchronous iterator.</p>



<p>It is an asynchronous for-loop statement.</p>



<p>An asynchronous iterator is an iterator that yields awaitables.</p>



<p>You may recall that an awaitable is an object that can be waited for, such as a coroutine or a task.</p>



<blockquote>
<p>awaitable: An object that can be used in an await expression.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>An asynchronous generator will automatically implement the asynchronous iterator methods, allowing it to be iterated like an asynchronous iterator.</p>



<p>The await for expression allows the caller to traverse an asynchronous iterator of awaitables and retrieve the result from each.</p>



<p>This is not the same as traversing a collection or list of awaitables (e.g. coroutine objects), instead, the awaitables returned must be provided using the expected asynchronous iterator methods.</p>



<p>Internally, the async for loop will automatically resolve or await each awaitable, scheduling coroutines as needed.</p>



<p>Because it is a for-loop, it assumes, although does not require, that each awaitable being traversed yields a return value.</p>



<p>The async for loop must be used within a coroutine because internally it will use the await expression, which can only be used within coroutines.</p>



<p>The async for expression can be used to traverse an asynchronous iterator within a coroutine.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62904970605222" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># traverse an asynchronous iterator</span></p><p><span>async </span><span>for</span><span> </span><span>item </span><span>in</span><span> </span><span>async_iterator</span><span>:</span></p><p><span>	</span><span>print</span><span>(</span><span>item</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This does not execute the for-loop in parallel. The asyncio is unable to execute more than one coroutine at a time within a Python thread.</p>



<p>Instead, this is an asynchronous for-loop.</p>



<p>The difference is that the coroutine that executes the for loop will suspend and internally await for each awaitable.</p>



<p>Behind the scenes, this may require coroutines to be scheduled and awaited, or tasks to be awaited.</p>



<p>We may also use the async for expression in a list comprehension.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62905728061009" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># build a list of results</span></p><p><span>results</span><span> </span><span>=</span><span> </span><span>[</span><span>item </span><span>async </span><span>for</span><span> </span><span>item </span><span>async_iterator</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This would construct a list of return values from the asynchronous iterator.</p>



<p>Next, let’s look at how to define, create and use asynchronous iterators.</p>



<h3><span id="How_to_Use_Asynchronous_Iterators"></span>How to Use Asynchronous Iterators<span></span></h3>



<p>In this section, we will take a close look at how to define, create, step, and traverse an asynchronous iterator in asyncio programs.</p>



<p>Let’s start with how to define an asynchronous iterator.</p>



<h4>Define an Asynchronous Iterator</h4>



<p>We can define an asynchronous iterator by defining a class that implements the <strong>__aiter__()</strong> and <strong>__anext__()</strong> methods.</p>



<p>These methods are defined on a Python object as per normal.</p>



<p>Importantly, because the <strong>__anext__()</strong> function must return an awaitable, it must be defined using the “<strong>async def</strong>” expression.</p>



<blockquote>
<p>object.__anext__(self): Must return an awaitable resulting in a next value of the iterator. Should raise a StopAsyncIteration error when the iteration is over.</p>
<cite>— <a href="https://docs.python.org/3/reference/datamodel.html#asynchronous-iterators">Asynchronous Iterators</a></cite></blockquote>



<p>When the iteration is complete, the <strong>__anext__()</strong> method must raise a <strong>StopAsyncIteration</strong> exception.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62906026616351" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p></div>
				</td>
						<td><div><p><span># define an asynchronous iterator</span></p><p><span>class</span><span> </span><span>AsyncIterator</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># constructor, define some state</span></p><p><span>    </span><span>def </span><span>__init__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>=</span><span> </span><span>0</span></p><p><span>    </span><span># create an instance of the iterator</span></p><p><span>    </span><span>def </span><span>__aiter__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>        </span><span>return</span><span> </span><span>self</span></p><p><span>    </span><span># return the next awaitable</span></p><p><span>    </span><span>async </span><span>def </span><span>__anext__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>        </span><span># check for no further items</span></p><p><span>        </span><span>if</span><span> </span><span>self</span><span>.</span><span>counter</span><span> </span><span>&gt;=</span><span> </span><span>10</span><span>:</span></p><p><span>            </span><span>raise </span><span>StopAsyncIteration</span></p><p><span>        </span><span># increment the counter</span></p><p><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>+=</span><span> </span><span>1</span></p><p><span>        </span><span># return the counter value</span></p><p><span>        </span><span>return</span><span> </span><span>self</span><span>.</span><span>counter</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>Because the asynchronous iterator is a coroutine and each iterator returns an awaitable that is scheduled and executed in the asyncio event loop, we can execute and await awaitables within the body of the iterator.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62908639986247" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># return the next awaitable</span></p><p><span>async </span><span>def </span><span>__anext__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>    </span><span># check for no further items</span></p><p><span>    </span><span>if</span><span> </span><span>self</span><span>.</span><span>counter</span><span> </span><span>&gt;=</span><span> </span><span>10</span><span>:</span></p><p><span>        </span><span>raise </span><span>StopAsyncIteration</span></p><p><span>    </span><span># increment the counter</span></p><p><span>    </span><span>self</span><span>.</span><span>counter</span><span> </span><span>+=</span><span> </span><span>1</span></p><p><span>    </span><span># simulate work</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span>    </span><span># return the counter value</span></p><p><span>    </span><span>return</span><span> </span><span>self</span><span>.</span><span>counter</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>Next, let’s look at how we might use an asynchronous iterator.</p>



<h4>Create Asynchronous Iterator</h4>



<p>To use an asynchronous iterator we must create the iterator.</p>



<p>This involves creating the Python object as per normal.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62909058062303" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create the iterator</span></p><p><span>it</span><span> </span><span>=</span><span> </span><span>AsyncIterator</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This returns an “<em>asynchronous iterable</em>“, which is an instance of an “<em>asynchronous iterator</em>“.</p>



<h4>Step an Asynchronous Iterator</h4>



<p>One step of the iterator can be traversed using the <a href="https://docs.python.org/3/library/functions.html#anext"><strong>anext()</strong> built-in function</a>, just like a classical iterator using the <strong>next()</strong> function.</p>



<p>The result is an awaitable that is awaited.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6290a372969977" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get an awaitable for one step of the iterator</span></p><p><span>awaitable</span><span> </span><span>=</span><span> </span><span>anext</span><span>(</span><span>it</span><span>)</span></p><p><span># execute the one step of the iterator and get the result</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>await </span><span>awaitable</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This can be achieved in one step.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6290b189207815" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># step the async iterator</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>await </span><span>anext</span><span>(</span><span>it</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h4>Traverse an Asynchronous Iterator</h4>



<p>The asynchronous iterator can also be traversed in a loop using the “<strong>async for</strong>” expression that will await each iteration of the loop automatically.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6290c672060717" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># traverse an asynchronous iterator</span></p><p><span>async </span><span>for</span><span> </span><span>result </span><span>in</span><span> </span><span>AsyncIterator</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span>print</span><span>(</span><span>result</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>You can learn more about the “<strong>async for</strong>” expression in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-async-for/">Asyncio async for loop</a></li>
</ul>



<p>We may also use an asynchronous list comprehension with the “<strong>async for</strong>” expression to collect the results of the iterator.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62919054956697" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># async list comprehension with async iterator</span></p><p><span>results</span><span> </span><span>=</span><span> </span><span>[</span><span>item </span><span>async </span><span>for</span><span> </span><span>item </span><span>in</span><span> </span><span>AsyncIterator</span><span>(</span><span>)</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="Example_of_an_Asynchronous_Iterator"></span>Example of an Asynchronous Iterator<span></span></h3>



<p>We can explore how to traverse an asynchronous iterator using the “<strong>async for</strong>” expression.</p>



<p>In this example, we will update the previous example to traverse the iterator to completion using an “<strong>async for</strong>” loop.</p>



<p>This loop will automatically await each awaitable returned from the iterator, retrieve the returned value, and make it available within the loop body so that in this case it can be reported.</p>



<p>This is perhaps the most common usage pattern for asynchronous iterators.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6291b108039957" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of an asynchronous iterator with async for loop</span></p><p><span>import </span><span>asyncio</span></p><p><span># define an asynchronous iterator</span></p><p><span>class</span><span> </span><span>AsyncIterator</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># constructor, define some state</span></p><p><span>    </span><span>def </span><span>__init__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>=</span><span> </span><span>0</span></p><p><span>    </span><span># create an instance of the iterator</span></p><p><span>    </span><span>def </span><span>__aiter__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>        </span><span>return</span><span> </span><span>self</span></p><p><span>    </span><span># return the next awaitable</span></p><p><span>    </span><span>async </span><span>def </span><span>__anext__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>        </span><span># check for no further items</span></p><p><span>        </span><span>if</span><span> </span><span>self</span><span>.</span><span>counter</span><span> </span><span>&gt;=</span><span> </span><span>10</span><span>:</span></p><p><span>            </span><span>raise </span><span>StopAsyncIteration</span></p><p><span>        </span><span># increment the counter</span></p><p><span>        </span><span>self</span><span>.</span><span>counter</span><span> </span><span>+=</span><span> </span><span>1</span></p><p><span>        </span><span># simulate work</span></p><p><span>        </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span>        </span><span># return the counter value</span></p><p><span>        </span><span>return</span><span> </span><span>self</span><span>.</span><span>counter</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># loop over async iterator with async for loop</span></p><p><span>    </span><span>async </span><span>for</span><span> </span><span>item </span><span>in</span><span> </span><span>AsyncIterator</span><span>(</span><span>)</span><span>:</span></p><p><span>        </span><span>print</span><span>(</span><span>item</span><span>)</span></p><p><span># execute the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and uses it as the entry point into the asyncio program.</p>



<p>The <strong>main()</strong> coroutine runs and starts the for loop.</p>



<p>An instance of the asynchronous iterator is created and the loop automatically steps it using the <strong>anext()</strong> function to return an awaitable. The loop then awaits the awaitable and retrieves a value which is made available to the body of the loop where it is reported.</p>



<p>This process is then repeated, suspending the <strong>main()</strong> coroutine, executing a step of the iterator and suspending, and resuming the <strong>main()</strong> coroutine until the iterator is exhausted.</p>



<p>Once the internal counter of the iterator reaches 10, a <strong>StopAsyncIteration</strong> is raised. This does not terminate the program. Instead, it is expected and handled by the “<strong>async for</strong>” expression and breaks the loop.</p>



<p>This highlights how an asynchronous iterator can be traversed using an async for expression.</p>







<p>Next, we will explore asynchronous generators.</p>



<h2><span id="Asynchronous_Generators"></span>Asynchronous Generators<span></span></h2>



<p>Generators are a fundamental part of Python.</p>



<p>A generator is a function that has at least one “<strong>yield</strong>” expression. They are functions that can be suspended and resumed, just like coroutines.</p>



<p>In fact, Python coroutines are an extension of Python generators.</p>



<p>Asyncio allows us to develop asynchronous generators.</p>



<p>We can create an asynchronous generator by defining a coroutine that makes use of the “<strong>yield</strong>” expression.</p>



<p>Let’s take a closer look.</p>



<h3><span id="What_Are_Asynchronous_Generators"></span>What Are Asynchronous Generators<span></span></h3>



<p>An asynchronous generator is a coroutine that uses the yield expression.</p>



<p>Before we dive into the details of asynchronous generators, let’s first review classical Python generators.</p>



<h4>Generators</h4>



<p>A generator is a Python function that returns a value via a yield expression.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6291d520932321" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define a generator</span></p><p><span>def </span><span>generator</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>)</span><span>:</span></p><p><span>		</span><span>yield</span><span> </span><span>i</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The generator is executed to the yield expression, after which a value is returned. This suspends the generator at that point. The next time the generator is executed it is resumed from the point it was resumed and runs until the next yield expression.</p>



<blockquote>
<p>generator: A function which returns a generator iterator. It looks like a normal function except that it contains yield expressions for producing a series of values usable in a for-loop or that can be retrieved one at a time with the next() function.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>Technically, a generator function creates and returns a generator iterator. The generator iterator executes the content of the generator function, yielding and resuming as needed.</p>



<blockquote>
<p>generator iterator: An object created by a generator function. Each yield temporarily suspends processing, remembering the location execution state […] When the generator iterator resumes, it picks up where it left off …</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>A generator can be executed in steps by using the <a href="https://docs.python.org/3/library/functions.html#next"><strong>next()</strong> built-in function</a>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6291f847043600" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create the generator</span></p><p><span>gen</span><span> </span><span>=</span><span> </span><span>generator</span><span>(</span><span>)</span></p><p><span># step the generator</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>next</span><span>(</span><span>gen</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Although, it is more common to iterate the generator to completion, such as using a for-loop or a list comprehension.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62920516609664" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># traverse the generator and collect results</span></p><p><span>results</span><span> </span><span>=</span><span> </span><span>[</span><span>item </span><span>for</span><span> </span><span>item </span><span>in</span><span> </span><span>generator</span><span>(</span><span>)</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Next, let’s take a closer look at asynchronous generators.</p>



<h4>Asynchronous Generators</h4>



<p>An asynchronous generator is a coroutine that uses the yield expression.</p>



<p>Unlike a function generator, the coroutine can schedule and await other coroutines and tasks.</p>



<blockquote>
<p>asynchronous generator: A function which returns an asynchronous generator iterator. It looks like a coroutine function defined with async def except that it contains yield expressions for producing a series of values usable in an async for loop.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>Like a classical generator, an asynchronous generator function can be used to create an asynchronous generator iterator that can be traversed using the built-in <strong>anext()</strong> function, instead of the <strong>next()</strong> function.</p>



<blockquote>
<p>asynchronous generator iterator: An object created by a asynchronous generator function. This is an asynchronous iterator which when called using the __anext__() method returns an awaitable object which will execute the body of the asynchronous generator function until the next yield expression.</p>
<cite>— <a href="https://docs.python.org/3/glossary.html">Python Glossary</a></cite></blockquote>



<p>This means that the asynchronous generator iterator implements the <strong>__anext__()</strong> method and can be used with the async for expression.</p>



<p>This means that each iteration of the generator is scheduled and executed as awaitable. The “<strong>async for</strong>” expression will schedule and execute each iteration of the generator, suspending the calling coroutine and awaiting the result.</p>



<p>You can learn more about the “<strong>async for</strong>” expression in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-async-for/">Asyncio async for loop</a></li>
</ul>



<h3><span id="How_to_Use_an_Asynchronous_Generator"></span>How to Use an Asynchronous Generator<span></span></h3>



<p>In this section, we will take a close look at how to define, create, step, and traverse an asynchronous generator in asyncio programs.</p>



<p>Let’s start with how to define an asynchronous generator.</p>



<h4>Define an Asynchronous Generator</h4>



<p>We can define an asynchronous generator by defining a coroutine that has at least one yield expression.</p>



<p>This means that the function is defined using the “<strong>async def</strong>” expression.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62921265607974" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define an asynchronous generator</span></p><p><span>async </span><span>def </span><span>async_generator</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>)</span></p><p><span>		</span><span>yield</span><span> </span><span>i</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Because the asynchronous generator is a coroutine and each iterator returns an awaitable that is scheduled and executed in the asyncio event loop, we can execute and await awaitables within the body of the generator.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62922468627074" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define an asynchronous generator that awaits</span></p><p><span>async </span><span>def </span><span>async_generator</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>)</span></p><p><span>		</span><span># suspend and sleep a moment</span></p><p><span>		</span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span>		</span><span># yield a value to the caller</span></p><p><span>		</span><span>yield</span><span> </span><span>i</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Next, let’s look at how we might use an asynchronous generator.</p>



<h4>Create Asynchronous Generator</h4>



<p>To use an asynchronous generator we must create the generator.</p>



<p>This looks like calling it, but instead creates and returns an iterator object.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62923547396501" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create the iterator</span></p><p><span>it</span><span> </span><span>=</span><span> </span><span>async_generator</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This returns a type of asynchronous iterator called an asynchronous generator iterator.</p>



<h4>Step an Asynchronous Generator</h4>



<p>One step of the generator can be traversed using the <a href="https://docs.python.org/3/library/functions.html#anext"><strong>anext()</strong> built-in function</a>, just like a classical generator using the <strong>next()</strong> function.</p>



<p>The result is an awaitable that is awaited.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62925598257622" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get an awaitable for one step of the generator</span></p><p><span>awaitable</span><span> </span><span>=</span><span> </span><span>anext</span><span>(</span><span>gen</span><span>)</span></p><p><span># execute the one step of the generator and get the result</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>await </span><span>awaitable</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This can be achieved in one step.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62926473492252" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># step the async generator</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>await </span><span>anext</span><span>(</span><span>gen</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h4>Traverse an Asynchronous Generator</h4>



<p>The asynchronous generator can also be traversed in a loop using the “<strong>async for</strong>” expression that will await each iteration of the loop automatically.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62927896525691" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># traverse an asynchronous generator</span></p><p><span>async </span><span>for</span><span> </span><span>result </span><span>in</span><span> </span><span>async_generator</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span>print</span><span>(</span><span>result</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>You can learn more about the “<strong>async for</strong>” expression in the tutorial:</p>



<p>We may also use an asynchronous list comprehension with the “<strong>async for</strong>” expression to collect the results of the generator.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62928458038343" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># async list comprehension with async generator</span></p><p><span>results</span><span> </span><span>=</span><span> </span><span>[</span><span>item </span><span>async </span><span>for</span><span> </span><span>item </span><span>in</span><span> </span><span>async_generator</span><span>(</span><span>)</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="Example_of_an_Asynchronous_Generator"></span>Example of an Asynchronous Generator<span></span></h3>



<p>We can explore how to traverse an asynchronous generator using the “<strong>async for</strong>” expression.</p>



<p>In this example, we will update the previous example to traverse the generator to completion using an “<strong>async for</strong>” loop.</p>



<p>This loop will automatically await each awaitable returned from the generator, retrieve the yielded value, and make it available within the loop body so that in this case it can be reported.</p>



<p>This is perhaps the most common usage pattern for asynchronous generators.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62929500864135" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of asynchronous generator with async for loop</span></p><p><span>import </span><span>asyncio</span></p><p><span># define an asynchronous generator</span></p><p><span>async </span><span>def </span><span>async_generator</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># normal loop</span></p><p><span>    </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>10</span><span>)</span><span>:</span></p><p><span>        </span><span># block to simulate doing work</span></p><p><span>        </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span>        </span><span># yield the result</span></p><p><span>        </span><span>yield</span><span> </span><span>i</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># loop over async generator with async for loop</span></p><p><span>    </span><span>async </span><span>for</span><span> </span><span>item </span><span>in</span><span> </span><span>async_generator</span><span>(</span><span>)</span><span>:</span></p><p><span>        </span><span>print</span><span>(</span><span>item</span><span>)</span></p><p><span># execute the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and uses it as the entry point into the asyncio program.</p>



<p>The <strong>main()</strong> coroutine runs and starts the for loop.</p>



<p>An instance of the asynchronous generator is created and the loop automatically steps it using the <strong>anext()</strong> function to return an awaitable. The loop then awaits the awaitable and retrieves a value which is made available to the body of the loop where it is reported.</p>



<p>This process is then repeated, suspending the <strong>main()</strong> coroutine, executing an iteration of the generator, and suspending, and resuming the <strong>main()</strong> coroutine until the generator is exhausted.</p>



<p>This highlights how an asynchronous generator can be traversed using an async for expression.</p>







<p>Next, we will explore asynchronous context managers.</p>



<h2><span id="Asynchronous_Context_Managers"></span>Asynchronous Context Managers<span></span></h2>



<p>A context manager is a Python construct that provides a try-finally like environment with a consistent interface and handy syntax, e.g. via the “with” expression.</p>



<p>It is commonly used with resources, ensuring the resource is always closed or released after we are finished with it, regardless of whether the usage of the resources was successful or failed with an exception.</p>



<p>Asyncio allows us to develop asynchronous context managers.</p>



<p>We can create and use asynchronous context managers in asyncio programs by defining an object that implements the <strong>__aenter__()</strong> and <strong>__aexit__()</strong> methods as coroutines.</p>



<p>Let’s take a closer look.</p>



<h3><span id="What_is_an_Asynchronous_Context_Manager"></span>What is an Asynchronous Context Manager<span></span></h3>



<p>An asynchronous context manager is a Python object that implements the <strong>__aenter__()</strong> and <strong>__aexit__()</strong> methods.</p>



<p>Before we dive into the details of asynchronous context managers, let’s review classical context managers.</p>



<h4>Context Manager</h4>



<p>A context manager is a Python object that implements the <strong>__enter__()</strong> and <strong>__exit__()</strong> methods.</p>



<blockquote>
<p>A context manager is an object that defines the runtime context to be established when executing a with statement. The context manager handles the entry into, and the exit from, the desired runtime context for the execution of the block of code.</p>
<cite>— <a href="https://docs.python.org/3/reference/datamodel.html#context-managers">With Statement Context Managers</a></cite></blockquote>



<ul>
<li>The <strong>__enter__()</strong> method defines what happens at the beginning of a block, such as opening or preparing resources, like a file, socket or thread pool.</li>



<li>The <strong>__exit__()</strong> method defines what happens when the block is exited, such as closing a prepared resource.</li>
</ul>



<blockquote>
<p>Typical uses of context managers include saving and restoring various kinds of global state, locking and unlocking resources, closing opened files, etc.</p>
<cite>— <a href="https://docs.python.org/3/reference/datamodel.html#context-managers">With Statement Context Managers</a></cite></blockquote>



<p>A context manager is used via the “with” expression.</p>



<p>Typically the context manager object is created in the beginning of the “<strong>with</strong>” expression and the <strong>__enter__()</strong> method is called automatically. The body of the content makes use of the resource via the named context manager object, then the <strong>__aexit__()</strong> method is called automatically when the block is exited, normally or via an exception.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6292c663083290" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># open a context manager</span></p><p><span>with </span><span>ContextManager</span><span>(</span><span>)</span><span> </span><span>as</span><span> </span><span>manager</span><span>:</span></p><p><span>	</span><span># ...</span></p><p><span># closed automatically</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This mirrors a try-finally expression.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6292d239180591" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create the object</span></p><p><span>manager</span><span> </span><span>=</span><span> </span><span>ContextManager</span><span>(</span><span>)</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span>manager</span><span>.</span><span>__enter__</span><span>(</span><span>)</span></p><p><span>	</span><span># ...</span></p><p><span>finally</span><span>:</span></p><p><span>	</span><span>manager</span><span>.</span><span>__exit__</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Next, let’s take a look at asynchronous context managers.</p>



<h4>Asynchronous Context Manager</h4>



<p>Asynchronous context managers were introduced in “<a href="https://peps.python.org/pep-0492/">PEP 492 – Coroutines with async and await syntax</a>“.</p>



<p>They provide a context manager that can be suspended when entering and exiting.</p>



<blockquote>
<p>An asynchronous context manager is a context manager that is able to suspend execution in its __aenter__ and __aexit__ methods.</p>
<cite>— <a href="https://docs.python.org/3/reference/datamodel.html#asynchronous-context-managers">Asynchronous Context Managers</a></cite></blockquote>



<p>The <strong>__aenter__</strong> and <strong>__aexit__</strong> methods are defined as coroutines and are awaited by the caller.</p>



<p>This is achieved using the “<strong>async with</strong>” expression.</p>



<p>You can learn more about the “async with” expression in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-async-with/">What is Asyncio async with</a></li>
</ul>



<p>As such, asynchronous context managers can only be used within asyncio programs, such as within calling coroutines.</p>



<p>What is “async with”</p>



<p>The “<strong>async with</strong>” expression is for creating and using asynchronous context managers.</p>



<p>It is an extension of the “<strong>with</strong>” expression for use in coroutines within asyncio programs.</p>



<p>The “<strong>async with</strong>” expression is just like the “<strong>with</strong>” expression used for context managers, except it allows asynchronous context managers to be used within coroutines.</p>



<p>In order to better understand “<strong>async with</strong>“, let’s take a closer look at asynchronous context managers.</p>



<p>The async with expression allows a coroutine to create and use an asynchronous version of a context manager.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6292f063717194" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create and use an asynchronous context manager</span></p><p><span>async </span><span>with </span><span>AsyncContextManager</span><span>(</span><span>)</span><span> </span><span>as</span><span> </span><span>manager</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This is equivalent to something like:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62930922634477" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create or enter the async context manager</span></p><p><span>manager</span><span> </span><span>=</span><span> </span><span>await </span><span>AsyncContextManager</span><span>(</span><span>)</span></p><p><span>try</span><span>:</span></p><p><span>	</span><span># ...</span></p><p><span>finally</span><span>:</span></p><p><span>	</span><span># close or exit the context manager</span></p><p><span>	</span><span>await </span><span>manager</span><span>.</span><span>close</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Notice that we are implementing much the same pattern as a traditional context manager, except that creating and closing the context manager involve awaiting coroutines.</p>



<p>This suspends the execution of the current coroutine, schedules a new coroutine and waits for it to complete.</p>



<p>As such an asynchronous context manager must implement the <strong>__aenter__()</strong> and <strong>__aexit__()</strong> methods that must be defined via the async def expression. This makes them coroutines themselves which may also await.</p>



<h3><span id="How_to_Use_Asynchronous_Context_Managers"></span>How to Use Asynchronous Context Managers<span></span></h3>



<p>In this section, we will explore how we can define, create, and use asynchronous context managers in our asyncio programs.</p>



<h4>Define an Asynchronous Context Manager</h4>



<p>We can define an asynchronous context manager as a Python object that implements the <strong>__aenter__()</strong> and <strong>__aexit__()</strong> methods.</p>



<p>Importantly, both methods must be defined as coroutines using the “<strong>async def</strong>” and therefore must return awaitables.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62931821018963" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define an asynchronous context manager</span></p><p><span>class</span><span> </span><span>AsyncContextManager</span><span>:</span></p><p><span>    </span><span># enter the async context manager</span></p><p><span>    </span><span>async </span><span>def </span><span>__aenter__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>        </span><span># report a message</span></p><p><span>        </span><span>print</span><span>(</span><span>&#39;&gt;entering the context manager&#39;</span><span>)</span></p><p><span>    </span><span># exit the async context manager</span></p><p><span>    </span><span>async </span><span>def </span><span>__aexit__</span><span>(</span><span>self</span><span>,</span><span> </span><span>exc_type</span><span>,</span><span> </span><span>exc</span><span>,</span><span> </span><span>tb</span><span>)</span><span>:</span></p><p><span>        </span><span># report a message</span></p><p><span>        </span><span>print</span><span>(</span><span>&#39;&gt;exiting the context manager&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Because each of the methods are coroutines, they may themselves await coroutines or tasks.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62932956909575" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># define an asynchronous context manager</span></p><p><span>class</span><span> </span><span>AsyncContextManager</span><span>:</span></p><p><span>    </span><span># enter the async context manager</span></p><p><span>    </span><span>async </span><span>def </span><span>__aenter__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>        </span><span># report a message</span></p><p><span>        </span><span>print</span><span>(</span><span>&#39;&gt;entering the context manager&#39;</span><span>)</span></p><p><span>        </span><span># block for a moment</span></p><p><span>        </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0.5</span><span>)</span></p><p><span>    </span><span># exit the async context manager</span></p><p><span>    </span><span>async </span><span>def </span><span>__aexit__</span><span>(</span><span>self</span><span>,</span><span> </span><span>exc_type</span><span>,</span><span> </span><span>exc</span><span>,</span><span> </span><span>tb</span><span>)</span><span>:</span></p><p><span>        </span><span># report a message</span></p><p><span>        </span><span>print</span><span>(</span><span>&#39;&gt;exiting the context manager&#39;</span><span>)</span></p><p><span>        </span><span># block for a moment</span></p><p><span>        </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0.5</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<h4>Use an Asynchronous Context Manager</h4>



<p>An asynchronous context manager is used via the “<strong>async with</strong>” expression.</p>



<p>This will automatically await the enter and exit coroutines, suspending the calling coroutine as needed.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62933269837540" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># use an asynchronous context manager</span></p><p><span>async </span><span>with </span><span>AsyncContextManager</span><span>(</span><span>)</span><span> </span><span>as</span><span> </span><span>manager</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>As such, the “<strong>async with</strong>” expression and asynchronous context managers more generally can only be used within asyncio programs, such as within coroutines.</p>



<p>Now that we know how to use asynchronous context managers, let’s look at a worked example.</p>



<h3><span id="Example_of_an_Asynchronous_Context_Manager_and_async_with"></span>Example of an Asynchronous Context Manager and “async with”<span></span></h3>



<p>We can explore how to use an asynchronous context manager via the “<strong>async with</strong>” expression.</p>



<p>In this example, we will update the above example to use the context manager in a normal manner.</p>



<p>We will use an “<strong>async with</strong>” expression and on one line, create and enter the context manager. This will automatically await the enter method.</p>



<p>We can then make use of the manager within the inner block. In this case, we will just report a message.</p>



<p>Exiting the inner block will automatically await the exit method of the context manager.</p>



<p>Contrasting this example with the previous example shows how much heavy lifting the “<strong>async with</strong>” expression does for us in an asyncio program.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62934172449580" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of an asynchronous context manager via async with</span></p><p><span>import </span><span>asyncio</span></p><p><span># define an asynchronous context manager</span></p><p><span>class</span><span> </span><span>AsyncContextManager</span><span>:</span></p><p><span>    </span><span># enter the async context manager</span></p><p><span>    </span><span>async </span><span>def </span><span>__aenter__</span><span>(</span><span>self</span><span>)</span><span>:</span></p><p><span>        </span><span># report a message</span></p><p><span>        </span><span>print</span><span>(</span><span>&#39;&gt;entering the context manager&#39;</span><span>)</span></p><p><span>        </span><span># block for a moment</span></p><p><span>        </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0.5</span><span>)</span></p><p><span>    </span><span># exit the async context manager</span></p><p><span>    </span><span>async </span><span>def </span><span>__aexit__</span><span>(</span><span>self</span><span>,</span><span> </span><span>exc_type</span><span>,</span><span> </span><span>exc</span><span>,</span><span> </span><span>tb</span><span>)</span><span>:</span></p><p><span>        </span><span># report a message</span></p><p><span>        </span><span>print</span><span>(</span><span>&#39;&gt;exiting the context manager&#39;</span><span>)</span></p><p><span>        </span><span># block for a moment</span></p><p><span>        </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0.5</span><span>)</span></p><p><span># define a simple coroutine</span></p><p><span>async </span><span>def </span><span>custom_coroutine</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># create and use the asynchronous context manager</span></p><p><span>    </span><span>async </span><span>with </span><span>AsyncContextManager</span><span>(</span><span>)</span><span> </span><span>as</span><span> </span><span>manager</span><span>:</span></p><p><span>        </span><span># report the result</span></p><p><span>        </span><span>print</span><span>(</span><span>f</span><span>&#39;within the manager&#39;</span><span>)</span></p><p><span># start the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>custom_coroutine</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and uses it as the entry point into the asyncio program.</p>



<p>The <strong>main()</strong> coroutine runs and creates an instance of our <strong>AsyncContextManager</strong> class in an “<strong>async with</strong>” expression.</p>



<p>This expression automatically calls the enter method and awaits the coroutine. A message is reported and the coroutine blocks for a moment.</p>



<p>The <strong>main()</strong> coroutine resumes and executes the body of the context manager, printing a message.</p>



<p>The block is exited and the exit method of the context manager is awaited automatically, reporting a message and sleeping a moment.</p>



<p>This highlights the normal usage pattern for an asynchronous context manager in an asyncio program.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62936579070437" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>&gt;entering the context manager</p><p>within the manager</p><p>&gt;exiting the context manager</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Next, we will explore asynchronous comprehensions.</p>



<h2><span id="Asynchronous_Comprehensions"></span>Asynchronous Comprehensions<span></span></h2>



<p>Comprehensions, like list and dict comprehensions are one feature of Python when we think of “<em>pythonic</em>“.</p>



<p>It is a way we do loops that is different to many other languages.</p>



<p>Asyncio allows us to use asynchronous comprehensions.</p>



<p>We can traverse an asynchronous generators and asynchronous iterators using an asynchronous comprehension via the “<strong>async for</strong>” expression.</p>



<p>Let’s take a closer look.</p>



<h3><span id="What_are_Asynchronous_Comprehensions"></span>What are Asynchronous Comprehensions<span></span></h3>



<p>An async comprehension is an asynchronous version of a classical comprehension.</p>



<p>Asyncio supports two types of asynchronous comprehensions, they are the “<strong>async for</strong>” comprehension and the “<strong>await</strong>” comprehension.</p>



<blockquote>
<p>PEP 530 adds support for using async for in list, set, dict comprehensions and generator expressions</p>
<cite>— <a href="https://docs.python.org/3/whatsnew/3.6.html#pep-530-asynchronous-comprehensions">PEP 530: Asynchronous Comprehensions, What’s New In Python 3.6</a>.</cite></blockquote>



<p>Before we look at each, let’s first recall classical comprehensions.</p>



<h3><span id="Comprehensions"></span>Comprehensions<span></span></h3>



<p>Comprehensions allow data collections like lists, dicts, and sets to be created in a concise way.</p>



<blockquote>
<p>List comprehensions provide a concise way to create lists.</p>
<cite>— <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">List Comprehensions</a></cite></blockquote>



<p>A list comprehension allows a list to be created from a for expression within the new list expression.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62937786223920" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a list using a list comprehension</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>[</span><span>a*</span><span>2</span><span> </span><span>for</span><span> </span><span>a</span><span> </span><span>in</span><span> </span><span>range</span><span>(</span><span>100</span><span>)</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Comprehensions are also supported for creating dicts and sets.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62938059513748" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a dict using a comprehension</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>{</span><span>a</span><span>:</span><span>i</span><span> </span><span>for</span><span> </span><span>a</span><span>,</span><span>i</span><span> </span><span>in</span><span> </span><span>zip</span><span>(</span><span>[</span><span>&#39;a&#39;</span><span>,</span><span>&#39;b&#39;</span><span>,</span><span>&#39;c&#39;</span><span>]</span><span>,</span><span>range</span><span>(</span><span>3</span><span>)</span><span>)</span><span>}</span></p><p><span># create a set using a comprehension</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>{</span><span>a</span><span> </span><span>for</span><span> </span><span>a</span><span> </span><span>in</span><span> </span><span>[</span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>4</span><span>]</span><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<h3><span id="Asynchronous_Comprehensions-2"></span>Asynchronous Comprehensions<span></span></h3>



<p>An asynchronous comprehension allows a list, set, or dict to be created using the “<strong>async for</strong>” expression with an asynchronous iterable.</p>



<blockquote>
<p>We propose to allow using async for inside list, set and dict comprehensions.</p>
<cite>— <a href="https://peps.python.org/pep-0530/">PEP 530 – Asynchronous Comprehensions</a></cite></blockquote>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6293a858012341" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># async list comprehension with an async iterator</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>[</span><span>a</span><span> </span><span>async </span><span>for</span><span> </span><span>a</span><span> </span><span>in</span><span> </span><span>aiterable</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This will create and schedule coroutines or tasks as needed and yield their results into a list.</p>



<p>Recall that the <a href="http://alok.github.io/asyncio-async-for/">“<strong>async for</strong>” expression</a> may only be used within coroutines and tasks.</p>



<p>Also, recall that an asynchronous iterator is an iterator that yields awaitables.</p>



<p>The “<strong>async for</strong>” expression allows the caller to traverse an asynchronous iterator of awaitables and retrieve the result from each.</p>



<p>Internally, the async for loop will automatically resolve or await each awaitable, scheduling coroutines as needed.</p>



<p>An async generator automatically implements the methods for the async iterator and may also be used in an asynchronous comprehension.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6293b896944811" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># async list comprehension with an async generator</span></p><p><span>result</span><span> </span><span>=</span><span> </span><span>[</span><span>a</span><span> </span><span>async </span><span>for</span><span> </span><span>a</span><span> </span><span>in</span><span> </span><span>agenerator</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="Await_Comprehensions"></span>Await Comprehensions<span></span></h3>



<p>The “<strong>await</strong>” expression may also be used within a list, set, or dict comprehension, referred to as an await comprehension.</p>



<blockquote>
<p>We propose to allow the use of await expressions in both asynchronous and synchronous comprehensions</p>
<cite>— <a href="https://peps.python.org/pep-0530/">PEP 530 – Asynchronous Comprehensions</a></cite></blockquote>



<p>Like an async comprehension, it may only be used within an asyncio coroutine or task.</p>



<p>This allows a data structure, like a list, to be created by suspending and awaiting a series of awaitables.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6293c688970956" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># await list compression with a collection of awaitables</span></p><p><span>results</span><span> </span><span>=</span><span> </span><span>[</span><span>await</span><span> </span><span>a</span><span> </span><span>for</span><span> </span><span>a</span><span> </span><span>in</span><span> </span><span>awaitables</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This will create a list of results by awaiting each awaitable in turn.</p>



<p>The current coroutine will be suspended to execute awaitables sequentially, which is different and perhaps slower than executing them concurrently using <strong>asyncio.gather()</strong>.</p>



<p>Next, we will explore how to run commands using subprocesses from asyncio.</p>



<h2><span id="Run_Commands_in_Non-Blocking_Subprocesses"></span>Run Commands in Non-Blocking Subprocesses<span></span></h2>



<p>We can execute commands from asyncio.</p>



<p>The command will run in a subprocess that we can write to and read from using non-blocking I/O.</p>



<p>Let’s take a closer look.</p>



<h3><span id="What_is_asynciosubprocessProcess"></span>What is asyncio.subprocess.Process<span></span></h3>



<p>The <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process"><strong>asyncio.subprocess.Process</strong> class</a> provides a representation of a subprocess run by asyncio.</p>



<p>It provides a handle on a subprocess in asyncio programs, allowing actions to be performed on it, such as waiting and terminating it.</p>



<blockquote>
<p>Process is a high-level wrapper that allows communicating with subprocesses and watching for their completion.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html#interacting-with-subprocesses">Interacting with Subprocesses</a></cite></blockquote>



<p>The API is very similar to the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process"><strong>multiprocessing.Process</strong> class</a> and perhaps more so with the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen"><strong>subprocess.Popen</strong> class</a>.</p>



<p>Specifically, it shares methods such as <strong>wait()</strong>, <strong>communicate()</strong>, and <strong>send_signal()</strong> and attributes such as stdin, stdout, and stderr with the subprocess.Popen.</p>



<p>Now that we know what the <strong>asyncio.subprocess.Process</strong> class is, let’s look at how we might use it in our asyncio programs.</p>



<p>We do not create a <strong>asyncio.subprocess.Process</strong> directly.</p>



<p>Instead, an instance of the class is created for us when executing a subprocess in an asyncio program.</p>



<blockquote>
<p>An object that wraps OS processes created by the create_subprocess_exec() and create_subprocess_shell() functions.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html#interacting-with-subprocesses">Interacting with Subprocesses</a></cite></blockquote>



<p>There are two ways to execute an external program as a subprocess and acquire a Process instance, they are:</p>



<ul>
<li><strong>asyncio.create_subprocess_exec()</strong> for running commands directly.</li>



<li><strong>asyncio.create_subprocess_shell()</strong> for running commands via the shell.</li>
</ul>



<p>Let’s look at examples of each in turn.</p>



<h3><span id="How_to_Run_a_Command_Directly"></span>How to Run a Command Directly<span></span></h3>



<p>A <a href="https://en.wikipedia.org/wiki/Command-line_interface">command</a> is a program executed on the command line (terminal or command prompt). It is another program that is run directly.</p>



<p>Common examples on Linux and macOS might be:</p>



<ul>
<li>‘<strong>ls</strong>‘ to list the contents of a directory</li>



<li>‘<strong>cat</strong>‘ to report the content of a file</li>



<li>‘<strong>date</strong>‘ to report the date</li>



<li>‘<strong>echo</strong>‘ to report back a string</li>



<li>‘<strong>sleep</strong>‘ to sleep for a number of seconds</li>
</ul>



<p>And so on.</p>



<p>We can execute a command from an asyncio program via the <strong>create_subprocess_exec()</strong> function.</p>



<p>The <strong>asyncio.create_subprocess_exec()</strong> function takes a command and executes it directly.</p>



<p>This is helpful as it allows the command to be executed in a subprocess and for asyncio coroutines to read, write, and wait for it.</p>



<blockquote>
<p>Because all asyncio subprocess functions are asynchronous and asyncio provides many tools to work with such functions, it is easy to execute and monitor multiple subprocesses in parallel.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">Asyncio Subprocesses</a></cite></blockquote>



<p>Unlike the <strong>asyncio.create_subprocess_shell()</strong> function, the <strong>asyncio.create_subprocess_exec()</strong> will not execute the command using the shell.</p>



<p>This means that the capabilities provided by the shell, such as shell variables, scripting, and wildcards are not available when executing the command.</p>



<p>It also means that executing the command may be more secure as there is no opportunity for a <a href="https://en.wikipedia.org/wiki/Code_injection#Shell_injection">shell injection</a>.</p>



<p>Now that we know what <strong>asyncio.create_subprocess_exec()</strong> does, let’s look at how to use it.</p>



<h4>How to Use Asyncio create_subprocess_exec()</h4>



<p>The <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_exec"><strong>asyncio.create_subprocess_exec()</strong> function</a> will execute a given string command in a subprocess.</p>



<p>It returns a <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process"><strong>asyncio.subprocess.Process</strong> object</a> that represents the subprocess.</p>



<blockquote>
<p>Process is a high-level wrapper that allows communicating with subprocesses and watching for their completion.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process">Interacting with Subprocesses</a></cite></blockquote>



<p>The <strong>create_subprocess_exec()</strong> function is a coroutine, which means we must await it. It will return once the subprocess has been started, not when the subprocess is finished.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6293e718001798" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute a command in a subprocess</span></p><p><span>process</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_subprocess_exec</span><span>(</span><span>&#39;ls&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Arguments to the command being executed must be provided as subsequent arguments to the <strong>create_subprocess_exec()</strong> function.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6296e206997631" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute a command with arguments in a subprocess</span></p><p><span>process</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_subprocess_exec</span><span>(</span><span>&#39;ls&#39;</span><span>,</span><span> </span><span>&#39;-l&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can wait for the subprocess to finish by awaiting the <strong>wait()</strong> method.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62970607269384" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for the subprocess to terminate</span></p><p><span>await </span><span>process</span><span>.</span><span>wait</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can stop the subprocess directly by calling the <strong>terminate()</strong> or <strong>kill()</strong> methods, which will raise a signal in the subprocess.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62971858935144" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># terminate the subprocess</span></p><p><span>process</span><span>.</span><span>terminate</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The input and output of the command will be handled by <strong>stdin</strong>, <strong>stderr</strong>, and <strong>stdout</strong>.</p>



<p>We can have the asyncio program handle the input or output for the subprocess.</p>



<p>This can be achieved by specifying the input or output stream and specifying a constant to redirect, such as asyncio.<strong>subprocess.PIPE</strong>.</p>



<p>For example, we can redirect the output of a command to the asyncio program:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62972712052583" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># start a subprocess and redirect output</span></p><p><span>process</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_subprocess_exec</span><span>(</span><span>&#39;ls&#39;</span><span>,</span><span> </span><span>stdout</span><span>=</span><span>asyncio</span><span>.</span><span>subprocess</span><span>.</span><span>PIPE</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can then read the output of the program via the <strong>asyncio.subprocess.Process</strong> instance via the <strong>communicate()</strong> method.</p>



<p>This method is a coroutine and must be awaited. It is used to both send and receive data with the subprocess.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62973957005310" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># read data from the subprocess</span></p><p><span>line</span><span> </span><span>=</span><span> </span><span>process</span><span>.</span><span>communicate</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can also send data to the subprocess via the <strong>communicate()</strong> method by setting the “<strong>input</strong>” argument in bytes.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62974130975525" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># start a subprocess and redirect input</span></p><p><span>process</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_subprocess_exec</span><span>(</span><span>&#39;ls&#39;</span><span>,</span><span> </span><span>stdin</span><span>=</span><span>asyncio</span><span>.</span><span>subprocess</span><span>.</span><span>PIPE</span><span>)</span></p><p><span># send data to the subprocess</span></p><p><span>process</span><span>.</span><span>communicate</span><span>(</span><span>input</span><span>=</span><span>b</span><span>&#39;Hello\n&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Behind the scenes the <strong>asyncio.subprocess.PIPE</strong> configures the subprocess to point to a <strong>StreamReader</strong> or <strong>StreamWriter</strong> for sending data to or from the subprocess, and the <strong>communicate()</strong> method will read or write bytes from the configured reader.</p>



<blockquote>
<p>If PIPE is passed to stdin argument, the Process.stdin attribute will point to a StreamWriter instance. If PIPE is passed to stdout or stderr arguments, the Process.stdout and Process.stderr attributes will point to StreamReader instances.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">Asyncio Subprocesses</a></cite></blockquote>



<p>We can interact with the StreamReader or StreamWriter directly via the subprocess via the stdin, stdout, and stderr attributes.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62975637646306" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># read a line from the subprocess output stream</span></p><p><span>line</span><span> </span><span>=</span><span> </span><span>await </span><span>process</span><span>.</span><span>stdout</span><span>.</span><span>readline</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Now that we know how to use the <strong>create_subprocess_exec()</strong> function, let’s look at some worked examples.</p>



<h4>Example of Asyncio create_subprocess_exec()</h4>



<p>We can explore how to run a command in a subprocess from asyncio.</p>



<p>In this example, we will execute the <a href="https://en.wikipedia.org/wiki/Echo_(command)">“<strong>echo</strong>” command</a> to report back a string.</p>



<p>The echo command will report the provided string on standard output directly.</p>



<p>The complete example is listed below.</p>



<p><strong>Note</strong>, this example assumes you have access to the “<strong>echo</strong>” command, I’m not sure it will work on Windows.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62977032515001" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of executing a command as a subprocess with asyncio</span></p><p><span>import </span><span>asyncio</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># start executing a command in a subprocess</span></p><p><span>    </span><span>process</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_subprocess_exec</span><span>(</span><span>&#39;echo&#39;</span><span>,</span><span> </span><span>&#39;Hello World&#39;</span><span>)</span></p><p><span>    </span><span># report the details of the subprocess</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;subprocess: {process}&#39;</span><span>)</span></p><p><span># entry point</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and executes it as the entry point into the asyncio program.</p>



<p>The <strong>main()</strong> coroutine runs and calls the <strong>create_subprocess_exec()</strong> function to execute a command.</p>



<p>The <strong>main()</strong> coroutine suspends while the subprocess is created. A Process instance is returned.</p>



<p>The <strong>main()</strong> coroutine resumes and reports the details of the subprocess. The <strong>main()</strong> process terminates and the asyncio program terminates.</p>



<p>The output of the echo command is reported on the command line.</p>



<p>This highlights how we can execute a command from an asyncio program.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62978977877659" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>Hello World</p><p>subprocess: &lt;Process 50249&gt;</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<h3><span id="How_to_Run_a_Command_Via_the_Shell"></span>How to Run a Command Via the Shell<span></span></h3>



<p>We can execute commands using the <a href="https://en.wikipedia.org/wiki/Shell_(computing)">shell</a>.</p>



<p>The shell is a user interface for the command line, called a command line interpreter (CLI).</p>



<p>It will interpret and execute commands on behalf of the user.</p>



<p>It also offers features such as a primitive programming language for scripting, wildcards, piping, shell variables (e.g. PATH), and more.</p>



<p>For example, we can redirect the output of one command as input to another command, such as the contents of the “<strong>/etc/services</strong>” file into the word count “<strong>wc</strong>” command and count the number of lines:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62979763524570" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>cat /etc/services | wc -l</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Examples of shells in the Unix based operating systems include:</p>



<ul>
<li>‘sh’</li>



<li>‘bash’</li>



<li>‘zsh’</li>



<li>And so on.</li>
</ul>



<p>On Windows, the shell is probably <a href="https://en.wikipedia.org/wiki/Cmd.exe">cmd.exe</a>.</p>



<p>See this great list of command line shells:</p>



<ul>
<li><a href="https://en.wikipedia.org/wiki/List_of_command-line_interpreters">List of command-line interpreters, Wikipedia</a></li>
</ul>



<p>The shell is already running, it was used to start the Python program.</p>



<p>You don’t need to do anything special to get or have access to the shell.</p>



<p>We can execute a command from an asyncio program via the <strong>create_subprocess_shell()</strong> function.</p>



<p>The <strong>asyncio.create_subprocess_shell()</strong> function takes a command and executes it using the current user shell.</p>



<p>This is helpful as it not only allows the command to be executed, but allows the capabilities of the shell to be used, such as redirection, wildcards and more.</p>



<blockquote>
<p>… the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user’s home directory.</p>
<cite>— <a href="https://docs.python.org/3/library/subprocess.html">subprocess — Subprocess management</a></cite></blockquote>



<p>The command will be executed in a subprocess of the process executing the asyncio program.</p>



<p>Importantly, the asyncio program is able to interact with the subprocess asynchronously, e.g. via coroutines.</p>



<blockquote>
<p>Because all asyncio subprocess functions are asynchronous and asyncio provides many tools to work with such functions, it is easy to execute and monitor multiple subprocesses in parallel.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">Asyncio Subprocesses</a></cite></blockquote>



<p>There can be security considerations when executing a command via the shell instead of directly.</p>



<p>This is because there is at least one level of indirection and interpretation between the request to execute the command and the command being executed, allowing possible malicious injection.</p>



<blockquote>
<p>Important It is the application’s responsibility to ensure that all whitespace and special characters are quoted appropriately to avoid shell injection vulnerabilities.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">Asyncio Subprocesses</a></cite></blockquote>



<p>Now that we know what <strong>asyncio.create_subprocess_shell()</strong> does, let’s look at how to use it.</p>



<h4>How to Use Asyncio create_subprocess_shell()</h4>



<p>The <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_shell"><strong>asyncio.create_subprocess_shell()</strong> function</a> will execute a given string command via the current shell.</p>



<p>It returns a <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process"><strong>asyncio.subprocess.Process</strong> object</a> that represents the process.</p>



<p>It is very similar to the <strong>create_subprocess_shell()</strong> function we saw in a previous section. Nevertheless, we will review how to use the function and interact with the process via the Process instance (in case you skipped straight to this section).</p>



<p>The <strong>create_subprocess_shell()</strong> function is a coroutine, which means we must await it. It will return once the subprocess has been started, not when the subprocess is finished.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6297b798091879" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># start a subprocess</span></p><p><span>process</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_subprocess_shell</span><span>(</span><span>&#39;ls&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can wait for the subprocess to finish by awaiting the <strong>wait()</strong> method.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6297d251278503" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for the subprocess to terminate</span></p><p><span>await </span><span>process</span><span>.</span><span>wait</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can stop the subprocess directly by calling the <strong>terminate()</strong> or <strong>kill()</strong> methods, which will raise a signal in the subprocess.</p>



<p>The input and output of the command will be handled by the shell, e.g. <strong>stdin</strong>, <strong>stderr</strong>, and <strong>stdout</strong>.</p>



<p>We can have the asyncio program handle the input or output for the subprocess.</p>



<p>This can be achieved by specifying the input or output stream and specifying a constant to redirect, such as <strong>asyncio.subprocess.PIPE</strong>.</p>



<p>For example, we can redirect the output of a command to the asyncio program:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6297e248490351" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># start a subprocess and redirect output</span></p><p><span>process</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_subprocess_shell</span><span>(</span><span>&#39;ls&#39;</span><span>,</span><span> </span><span>stdout</span><span>=</span><span>asyncio</span><span>.</span><span>subprocess</span><span>.</span><span>PIPE</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can then read the output of the program via the <strong>asyncio.subprocess.Process</strong> instance via the <strong>communicate()</strong> method.</p>



<p>This method is a coroutine and must be awaited. It is used to both send and receive data with the subprocess.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62980832787615" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># read data from the subprocess</span></p><p><span>line</span><span> </span><span>=</span><span> </span><span>process</span><span>.</span><span>communicate</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can also send data to the subprocess via the <strong>communicate()</strong> method by setting the “input” argument in bytes.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62981131946414" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># start a subprocess and redirect input</span></p><p><span>process</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_subprocess_shell</span><span>(</span><span>&#39;ls&#39;</span><span>,</span><span> </span><span>stdin</span><span>=</span><span>asyncio</span><span>.</span><span>subprocess</span><span>.</span><span>PIPE</span><span>)</span></p><p><span># send data to the subprocess</span></p><p><span>process</span><span>.</span><span>communicate</span><span>(</span><span>input</span><span>=</span><span>b</span><span>&#39;Hello\n&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Behind the scenes the <strong>asyncio.subprocess.PIPE</strong> configures the subprocess to point to a <strong>StreamReader</strong> or <strong>StreamWriter</strong> for sending data to or from the subprocess, and the <strong>communicate()</strong> method will read or write bytes from the configured reader.</p>



<blockquote>
<p>If PIPE is passed to stdin argument, the Process.stdin attribute will point to a StreamWriter instance. If PIPE is passed to stdout or stderr arguments, the Process.stdout and Process.stderr attributes will point to StreamReader instances.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">Asyncio Subprocesses</a></cite></blockquote>



<p>We can interact with the <strong>StreamReader</strong> or <strong>StreamWriter</strong> directly via the subprocess via the stdin, stdout, and stderr attributes.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62982435429891" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># read a line from the subprocess output stream</span></p><p><span>line</span><span> </span><span>=</span><span> </span><span>await </span><span>process</span><span>.</span><span>stdout</span><span>.</span><span>readline</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Now that we know how to use the <strong>create_subprocess_shell()</strong> function, let’s look at some worked examples.</p>



<h4>Example of Asyncio create_subprocess_shell()</h4>



<p>We can explore how to run a command in a subprocess from asyncio using the shell.</p>



<p>In this example, we will execute the <a href="https://en.wikipedia.org/wiki/Echo_(command)">“<strong>echo</strong>” command</a> to report back a string.</p>



<p>The echo command will report the provided string on standard output directly.</p>



<p>The complete example is listed below.</p>



<p>Note, this example assumes you have access to the “<strong>echo</strong>” command, I’m not sure it will work on Windows.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62983781153757" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of executing a shell command as a subprocess with asyncio</span></p><p><span>import </span><span>asyncio</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># start executing a shell command in a subprocess</span></p><p><span>    </span><span>process</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_subprocess_shell</span><span>(</span><span>&#39;echo Hello World&#39;</span><span>)</span></p><p><span>    </span><span># report the details of the subprocess</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;subprocess: {process}&#39;</span><span>)</span></p><p><span># entry point</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and executes it as the entry point into the asyncio program.</p>



<p>The <strong>main()</strong> coroutine runs and calls the <strong>create_subprocess_shell()</strong> function to execute a command.</p>



<p>The <strong>main()</strong> coroutine suspends while the subprocess is created. A <strong>Process</strong> instance is returned.</p>



<p>The <strong>main()</strong> coroutine resumes and reports the details of the subprocess. The <strong>main()</strong> process terminates and the asyncio program terminates.</p>



<p>The output of the echo command is reported on the command line.</p>



<p>This highlights how we can execute a command using the shell from an asyncio program.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62985427183274" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>subprocess: &lt;Process 43916&gt;</p><p>Hello World</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<h2><span id="Non-Blocking_Streams"></span>Non-Blocking Streams<span></span></h2>



<p>A major benefit of asyncio is the ability to use non-blocking streams.</p>



<p>Let’s take a closer look.</p>



<h3><span id="Asyncio_Streams"></span>Asyncio Streams<span></span></h3>



<p>Asyncio provides non-blocking I/O socket programming.</p>



<p>This is provided via streams.</p>



<blockquote>
<p>Streams are high-level async/await-ready primitives to work with network connections. Streams allow sending and receiving data without using callbacks or low-level protocols and transports.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>Sockets can be opened that provide access to a stream writer and a stream writer.</p>



<p>Data can then be written and read from the stream using coroutines, suspending when appropriate.</p>



<p>Once finished, the socket can be closed.</p>



<p>The asyncio streams capability is low-level meaning that any protocols required must be implemented manually.</p>



<p>This might include common web protocols, such as:</p>



<ul>
<li>HTTP or HTTPS for interacting with web servers</li>



<li>SMTP for interacting with email servers</li>



<li>FTP for interacting with file servers.</li>
</ul>



<p>The streams can also be used to create a server to handle requests using a standard protocol, or to develop your own application-specific protocol.</p>



<p>Now that we know what asyncio streams are, let’s look at how to use them.</p>



<h3><span id="How_to_Open_a_Connection"></span>How to Open a Connection<span></span></h3>



<p>An asyncio TCP client socket connection can be opened using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection"><strong>asyncio.open_connection()</strong> function</a>.</p>



<blockquote>
<p>Establish a network connection and return a pair of (reader, writer) objects. The returned reader and writer objects are instances of StreamReader and StreamWriter classes.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>This is a coroutine that must be awaited and will return once the socket connection is open.</p>



<p>The function returns a <strong>StreamReader</strong> and <strong>StreamWriter</strong> object for interacting with the socket.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62986136069041" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># open a connection</span></p><p><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The <strong>asyncio.open_connection()</strong> function takes many arguments in order to configure the socket connection.</p>



<p>The two required arguments are the host and the port.</p>



<p>The host is a string that specifies the server to connect to, such as a domain name or an IP address.</p>



<p>The port is the socket port number, such as 80 for HTTP servers, 443 for HTTPS servers, 23 for SMTP and so on.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62988800377984" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># open a connection to an http server</span></p><p><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>&#39;www.google.com&#39;</span><span>,</span><span> </span><span>80</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Encrypted socket connections are supported over the SSL protocol.</p>



<p>The most common example might be HTTPS which is replacing HTTP.</p>



<p>This can be achieved by setting the “<strong>ssl</strong>” argument to <strong>True</strong>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62989604623411" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># open a connection to an https server</span></p><p><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>&#39;www.google.com&#39;</span><span>,</span><span> </span><span>443</span><span>,</span><span> </span><span>ssl</span><span>=</span><span>True</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<h3><span id="How_to_Start_a_Server"></span>How to Start a Server<span></span></h3>



<p>An asyncio TCP server socket can be opened using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.start_server"><strong>asyncio.start_server()</strong> function</a>.</p>



<blockquote>
<p>Create a TCP server (socket type SOCK_STREAM) listening on port of the host address.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-eventloop.html">Asyncio Event Loop</a></cite></blockquote>



<p>This is a coroutine that must be awaited.</p>



<p>The function returns an <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server"><strong>asyncio.Server</strong> object</a> that represents the running server.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6298a656542688" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># start a tcp server</span></p><p><span>server</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>start_server</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The three required arguments are the callback function, the host, and the port.</p>



<p>The callback function is a custom function specified by name that will be called each time a client connects to the server.</p>



<blockquote>
<p>The client_connected_cb callback is called whenever a new client connection is established. It receives a (reader, writer) pair as two arguments, instances of the StreamReader and StreamWriter classes.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>The host is the domain name or IP address that clients will specify to connect. The port is the socket port number on which to receive connections, such as 21 for FTP or 80 for HTTP.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6298c007807368" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># handle connections</span></p><p><span>async </span><span>def </span><span>handler</span><span>(</span><span>reader</span><span>,</span><span> </span><span>writer</span><span>)</span><span>:</span></p><p><span>	</span><span># ...</span></p><p><span>.</span><span>.</span><span>.</span></p><p><span># start a server to receive http connections</span></p><p><span>server</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>start_server</span><span>(</span><span>handler</span><span>,</span><span> </span><span>&#39;127.0.0.1&#39;</span><span>,</span><span> </span><span>80</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<h3><span id="How_to_Write_Data_with_the_StreamWriter"></span>How to Write Data with the StreamWriter<span></span></h3>



<p>We can write data to the socket using an <strong><a href="https://docs.python.org/3/library/asyncio-stream.html#streamwriter">asyncio.StreamWriter</a></strong>.</p>



<blockquote>
<p>Represents a writer object that provides APIs to write data to the IO stream.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>Data is written as bytes.</p>



<p>Byte data can be written to the socket using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write"><strong>write()</strong> method</a>.</p>



<blockquote>
<p>The method attempts to write the data to the underlying socket immediately. If that fails, the data is queued in an internal write buffer until it can be sent.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6298d037315960" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># write byte data</span></p><p><span>writer</span><span>.</span><span>write</span><span>(</span><span>byte_data</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Alternatively, multiple “<strong>lines</strong>” of byte data organized into a list or iterable can be written using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.writelines"><strong>writelines()</strong> method</a>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6298f997253570" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># write lines of byte data</span></p><p><span>writer</span><span>.</span><span>writelines</span><span>(</span><span>byte_lines</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Neither method for writing data blocks or suspends the calling coroutine.</p>



<p>After writing byte data it is a good idea to drain the socket via the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.drain"><strong>drain()</strong> method</a>.</p>



<blockquote>
<p>Wait until it is appropriate to resume writing to the stream.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>This is a coroutine and will suspend the caller until the bytes have been transmitted and the socket is ready.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62990246890017" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># write byte data</span></p><p><span>writer</span><span>.</span><span>write</span><span>(</span><span>byte_data</span><span>)</span></p><p><span># wait for data to be transmitted</span></p><p><span>await </span><span>writer</span><span>.</span><span>drain</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="How_to_Read_Data_with_the_StreamReader"></span>How to Read Data with the StreamReader<span></span></h3>



<p>We can read data from the socket using an <strong><a href="https://docs.python.org/3/library/asyncio-stream.html#streamreader">asyncio.StreamReader</a></strong>.</p>



<blockquote>
<p>Represents a reader object that provides APIs to read data from the IO stream.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>Data is read in byte format, therefore strings may need to be encoded before being used.</p>



<p>All read methods are coroutines that must be awaited.</p>



<p>An arbitrary number of bytes can be read via the <strong>read()</strong> method, which will read until the end of file (EOF).</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62991119549727" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># read byte data</span></p><p><span>byte_data</span><span> </span><span>=</span><span> </span><span>await </span><span>reader</span><span>.</span><span>read</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Additionally, the number of bytes to read can be specified via the “<strong>n</strong>” argument.</p>



<blockquote>
<p>Read up to n bytes. If n is not provided, or set to -1, read until EOF and return all read bytes.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>This may be helpful if you know the number of bytes expected from the next response.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62993692442552" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># read byte data</span></p><p><span>byte_data</span><span> </span><span>=</span><span> </span><span>await </span><span>reader</span><span>.</span><span>read</span><span>(</span><span>n</span><span>=</span><span>100</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>A single line of data can be read using the <strong>readline()</strong> method.</p>



<p>This will return bytes until a new line character ‘\n’ is encountered, or EOF.</p>



<blockquote>
<p>Read one line, where “line” is a sequence of bytes ending with \n. If EOF is received and \n was not found, the method returns partially read data. If EOF is received and the internal buffer is empty, return an empty bytes object.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>This is helpful when reading standard protocols that operate with lines of text.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62994293798169" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># read a line data</span></p><p><span>byte_line</span><span> </span><span>=</span><span> </span><span>await </span><span>reader</span><span>.</span><span>readline</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Additionally, there is a readexactly() method to read an exact number of bytes otherwise raise an exception, and a readuntil() that will read bytes until a specified character in byte form is read.</p>



<h3><span id="How_to_Close_Connection"></span>How to Close Connection<span></span></h3>



<p>The socket can be closed via the <strong>asyncio.StreamWriter</strong>.</p>



<p>The <strong>close()</strong> method can be called which will close the socket.</p>



<blockquote>
<p>The method closes the stream and the underlying socket.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>This method does not block.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62995611937017" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># close the socket</span></p><p><span>writer</span><span>.</span><span>close</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Although the <strong>close()</strong> method does not block, we can wait for the socket to close completely before continuing on.</p>



<p>This can be achieved via the <strong>wait_closed()</strong> method.</p>



<blockquote>
<p>Wait until the stream is closed. Should be called after close() to wait until the underlying connection is closed.</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></cite></blockquote>



<p>This is a coroutine that can be awaited.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62997730528558" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># close the socket</span></p><p><span>writer</span><span>.</span><span>close</span><span>(</span><span>)</span></p><p><span># wait for the socket to close</span></p><p><span>await </span><span>writer</span><span>.</span><span>wait_closed</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can check if the socket has been closed or is in the process of being closed via the <strong>is_closing()</strong> method.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62998522227394" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># check if the socket is closed or closing</span></p><p><span>if</span><span> </span><span>writer</span><span>.</span><span>is_closing</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Now that we know how to use asyncio streams, let’s look at a worked example.</p>



<h2><span id="Example_of_Checking_Website_Status"></span>Example of Checking Website Status<span></span></h2>



<p>We can query the HTTP status of websites using asyncio by opening a stream and writing and reading HTTP requests and responses.</p>



<p>We can then use asyncio to query the status of many websites concurrently, and even report the results dynamically.</p>



<p>Let’s get started.</p>



<h3><span id="How_to_Check_HTTP_Status_with_Asyncio"></span>How to Check HTTP Status with Asyncio<span></span></h3>



<p>The asyncio module provides support for opening socket connections and reading and writing data via streams.</p>



<p>We can use this capability to check the status of web pages.</p>



<p>This involves perhaps four steps, they are:</p>



<ol>
<li>Open a connection</li>



<li>Write a request</li>



<li>Read a response</li>



<li>Close the connection</li>
</ol>



<p>Let’s take a closer look at each part in turn.</p>



<h3><span id="Open_HTTP_Connection"></span>Open HTTP Connection<span></span></h3>



<p>A connection can be opened in asyncio using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection"><strong>asyncio.open_connection()</strong> function</a>.</p>



<p>Among many arguments, the function takes the string hostname and integer port number</p>



<p>This is a coroutine that must be awaited and returns a StreamReader and a StreamWriter for reading and writing with the socket.</p>



<p>This can be used to open an HTTP connection on port 80.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62999082780446" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># open a socket connection</span></p><p><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>&#39;www.google.com&#39;</span><span>,</span><span> </span><span>80</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can also open an SSL connection using the <strong>ssl=True</strong> argument. This can be used to open an HTTPS connection on port 443.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6299b335686845" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># open a socket connection</span></p><p><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>&#39;www.google.com&#39;</span><span>,</span><span> </span><span>443</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="Write_HTTP_Request"></span>Write HTTP Request<span></span></h3>



<p>Once open, we can write a query to the <strong>StreamWriter</strong> to make an HTTP request.</p>



<p>For example, an <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP version 1.1 request</a> is in plain text. We can request the file path ‘/’, which may look as follows:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6299d688709242" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>GET / HTTP/1.1</p><p>Host: www.google.com</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Importantly, there must be a carriage return and a line feed (\r\n) at the end of each line, and an empty line at the end.</p>



<p>As Python strings this may look as follows:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6299e858812366" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>&#39;GET / HTTP/1.1\r\n&#39;</p><p>&#39;Host: www.google.com\r\n&#39;</p><p>&#39;\r\n&#39;</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>You can learn more about HTTP v1.1 request messages here:</p>



<ul>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP/1.1_request_messages">HTTP/1.1 request messages</a></li>
</ul>



<p>This string must be encoded as bytes before being written to the <strong><a href="https://docs.python.org/3/library/asyncio-stream.html#streamwriter">StreamWriter</a></strong>.</p>



<p>This can be achieved using the <a href="https://docs.python.org/3/library/stdtypes.html#str.encode"><strong>encode()</strong> method</a> on the string itself.</p>



<p>The default ‘<strong>utf-8</strong>‘ encoding may be sufficient.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a6299f863865418" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># encode string as bytes</span></p><p><span>byte_data</span><span> </span><span>=</span><span> </span><span>string</span><span>.</span><span>encode</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>You can see a listing of encodings here:</p>



<ul>
<li><a href="https://docs.python.org/3/library/codecs.html#standard-encodings">Python Standard Encodings</a></li>
</ul>



<p>The bytes can then be written to the socket via the <strong>StreamWriter</strong> via the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write"><strong>write()</strong> method</a>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629a0141575509" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># write query to socket</span></p><p><span>writer</span><span>.</span><span>write</span><span>(</span><span>byte_data</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>After writing the request, it is a good idea to wait for the byte data to be sent and for the socket to be ready.</p>



<p>This can be achieved by the <strong>drain()</strong> method.</p>



<p>This is a coroutine that must be awaited.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629a1752127887" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for the socket to be ready.</span></p><p><span>await </span><span>writer</span><span>.</span><span>drain</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="Read_HTTP_Response"></span>Read HTTP Response<span></span></h3>



<p>Once the HTTP request has been made, we can read the response.</p>



<p>This can be achieved via the <strong><a href="https://docs.python.org/3/library/asyncio-stream.html#streamreader">StreamReader</a></strong> for the socket.</p>



<p>The response can be read using the <strong>read()</strong> method which will read a chunk of bytes, or the <strong>readline()</strong> method which will read one line of bytes.</p>



<p>We might prefer the <strong>readline()</strong> method because we are using the text-based HTTP protocol which sends HTML data one line at a time.</p>



<p>The <strong>readline()</strong> method is a coroutine and must be awaited.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629a3511515392" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># read one line of response</span></p><p><span>line_bytes</span><span> </span><span>=</span><span> </span><span>await </span><span>reader</span><span>.</span><span>readline</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP/1.1_response_messages">HTTP 1.1 responses</a> are composed of two parts, a header separated by an empty line, then the body terminating with an empty line.</p>



<p>The header has information about whether the request was successful and what type of file will be sent, and the body contains the content of the file, such as an HTML webpage.</p>



<p>The first line of the HTTP header contains the HTTP status for the requested page on the server.</p>



<p>You can learn more about HTTP v1.1 responses here:</p>



<ul>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP/1.1_response_messages">HTTP/1.1 response messages</a></li>
</ul>



<p>Each line must be decoded from bytes into a string.</p>



<p>This can be achieved using the <a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode"><strong>decode()</strong> method</a> on the byte data. Again, the default encoding is ‘<strong>utf_8</strong>‘.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629a4376743018" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># decode bytes into a string</span></p><p><span>line_data</span><span> </span><span>=</span><span> </span><span>line_bytes</span><span>.</span><span>decode</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="Close_HTTP_Connection"></span>Close HTTP Connection<span></span></h3>



<p>We can close the socket connection by closing the <strong>StreamWriter</strong>.</p>



<p>This can be achieved by calling the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.close"><strong>close()</strong> method</a>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629a5465297943" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># close the connection</span></p><p><span>writer</span><span>.</span><span>close</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This does not block and may not close the socket immediately.</p>



<p>Now that we know how to make HTTP requests and read responses using asyncio, let’s look at some worked examples of checking web page statuses.</p>



<h3><span id="Example_of_Checking_HTTP_Status_Sequentially"></span>Example of Checking HTTP Status Sequentially<span></span></h3>



<p>We can develop an example to check the HTTP status for multiple websites using asyncio.</p>



<p>In this example, we will first develop a coroutine that will check the status of a given URL. We will then call this coroutine once for each of the <a href="https://en.wikipedia.org/wiki/List_of_most_visited_websites">top 10 websites</a>.</p>



<p>Firstly, we can define a coroutine that will take a URL string and return the HTTP status.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629a7879505337" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># get the HTTP/S status of a webpage</span></p><p><span>async </span><span>def </span><span>get_status</span><span>(</span><span>url</span><span>)</span><span>:</span></p><p><span>	</span><span># ...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The URL must be parsed into its constituent components.</p>



<p>We require the hostname and file path when making the HTTP request. We also need to know the URL scheme (HTTP or HTTPS) in order to determine whether SSL is required nor not.</p>



<p>This can be achieved using the <a href="https://docs.python.org/3/library/urllib.parse.html"><strong>urllib.parse.urlsplit()</strong> function</a> that takes a URL string and returns a named tuple of all the URL elements.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629a8879069960" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># split the url into components</span></p><p><span>url_parsed</span><span> </span><span>=</span><span> </span><span>urlsplit</span><span>(</span><span>url</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can then open the HTTP connection based on the URL scheme and use the URL hostname.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629a9149684883" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># open the connection</span></p><p><span>if</span><span> </span><span>url_parsed</span><span>.</span><span>scheme</span><span> </span><span>==</span><span> </span><span>&#39;https&#39;</span><span>:</span></p><p><span>    </span><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>url_parsed</span><span>.</span><span>hostname</span><span>,</span><span> </span><span>443</span><span>,</span><span> </span><span>ssl</span><span>=</span><span>True</span><span>)</span></p><p><span>else</span><span>:</span></p><p><span>    </span><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>url_parsed</span><span>.</span><span>hostname</span><span>,</span><span> </span><span>80</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>Next, we can create the HTTP GET request using the hostname and file path and write the encoded bytes to the socket using the <strong>StreamWriter</strong>.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629aa637006813" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># send GET request</span></p><p><span>query</span><span> </span><span>=</span><span> </span><span>f</span><span>&#39;GET {url_parsed.path} HTTP/1.1\r\nHost: {url_parsed.hostname}\r\n\r\n&#39;</span></p><p><span># write query to socket</span></p><p><span>writer</span><span>.</span><span>write</span><span>(</span><span>query</span><span>.</span><span>encode</span><span>(</span><span>)</span><span>)</span></p><p><span># wait for the bytes to be written to the socket</span></p><p><span>await </span><span>writer</span><span>.</span><span>drain</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Next, we can read the HTTP response.</p>



<p>We only require the first line of the response that contains the HTTP status.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629ab217927503" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># read the single line response</span></p><p><span>response</span><span> </span><span>=</span><span> </span><span>await </span><span>reader</span><span>.</span><span>readline</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The connection can then be closed.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629ad899905254" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># close the connection</span></p><p><span>writer</span><span>.</span><span>close</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Finally, we can decode the bytes read from the server, remote trailing white space, and return the HTTP status.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629ae044642647" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># decode and strip white space</span></p><p><span>status</span><span> </span><span>=</span><span> </span><span>response</span><span>.</span><span>decode</span><span>(</span><span>)</span><span>.</span><span>strip</span><span>(</span><span>)</span></p><p><span># return the response</span></p><p><span>return</span><span> </span><span>status</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Tying this together, the complete <strong>get_status()</strong> coroutine is listed below.</p>



<p>It does not have any error handling, such as the case where the host cannot be reached or is slow to respond.</p>



<p>These additions would make a nice extension for the reader.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629af236947690" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p></div>
				</td>
						<td><div><p><span># get the HTTP/S status of a webpage</span></p><p><span>async </span><span>def </span><span>get_status</span><span>(</span><span>url</span><span>)</span><span>:</span></p><p><span>    </span><span># split the url into components</span></p><p><span>    </span><span>url_parsed</span><span> </span><span>=</span><span> </span><span>urlsplit</span><span>(</span><span>url</span><span>)</span></p><p><span>    </span><span># open the connection</span></p><p><span>    </span><span>if</span><span> </span><span>url_parsed</span><span>.</span><span>scheme</span><span> </span><span>==</span><span> </span><span>&#39;https&#39;</span><span>:</span></p><p><span>        </span><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>url_parsed</span><span>.</span><span>hostname</span><span>,</span><span> </span><span>443</span><span>,</span><span> </span><span>ssl</span><span>=</span><span>True</span><span>)</span></p><p><span>    </span><span>else</span><span>:</span></p><p><span>        </span><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>url_parsed</span><span>.</span><span>hostname</span><span>,</span><span> </span><span>80</span><span>)</span></p><p><span>    </span><span># send GET request</span></p><p><span>    </span><span>query</span><span> </span><span>=</span><span> </span><span>f</span><span>&#39;GET {url_parsed.path} HTTP/1.1\r\nHost: {url_parsed.hostname}\r\n\r\n&#39;</span></p><p><span>    </span><span># write query to socket</span></p><p><span>    </span><span>writer</span><span>.</span><span>write</span><span>(</span><span>query</span><span>.</span><span>encode</span><span>(</span><span>)</span><span>)</span></p><p><span>    </span><span># wait for the bytes to be written to the socket</span></p><p><span>    </span><span>await </span><span>writer</span><span>.</span><span>drain</span><span>(</span><span>)</span></p><p><span>    </span><span># read the single line response</span></p><p><span>    </span><span>response</span><span> </span><span>=</span><span> </span><span>await </span><span>reader</span><span>.</span><span>readline</span><span>(</span><span>)</span></p><p><span>    </span><span># close the connection</span></p><p><span>    </span><span>writer</span><span>.</span><span>close</span><span>(</span><span>)</span></p><p><span>    </span><span># decode and strip white space</span></p><p><span>    </span><span>status</span><span> </span><span>=</span><span> </span><span>response</span><span>.</span><span>decode</span><span>(</span><span>)</span><span>.</span><span>strip</span><span>(</span><span>)</span></p><p><span>    </span><span># return the response</span></p><p><span>    </span><span>return</span><span> </span><span>status</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
</div>



<p>Next, we can call the <strong>get_status()</strong> coroutine for multiple web pages or websites we want to check.</p>



<p>In this case, we will define a list of the top 10 web pages in the world.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629b0273317007" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># list of top 10 websites to check</span></p><p><span>sites</span><span> </span><span>=</span><span> </span><span>[</span><span>&#39;https://www.google.com/&#39;</span><span>,</span></p><p><span>    </span><span>&#39;https://www.youtube.com/&#39;</span><span>,</span></p><p><span>    </span><span>&#39;https://www.facebook.com/&#39;</span><span>,</span></p><p><span>    </span><span>&#39;https://twitter.com/&#39;</span><span>,</span></p><p><span>    </span><span>&#39;https://www.instagram.com/&#39;</span><span>,</span></p><p><span>    </span><span>&#39;https://www.baidu.com/&#39;</span><span>,</span></p><p><span>    </span><span>&#39;https://www.wikipedia.org/&#39;</span><span>,</span></p><p><span>    </span><span>&#39;https://yandex.ru/&#39;</span><span>,</span></p><p><span>    </span><span>&#39;https://yahoo.com/&#39;</span><span>,</span></p><p><span>    </span><span>&#39;https://www.whatsapp.com/&#39;</span></p><p><span>    </span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>We can then query each, in turn, using our <strong>get_status()</strong> coroutine.</p>



<p>In this case, we will do so sequentially in a loop, and report the status of each in turn.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629b2654281915" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># check the status of all websites</span></p><p><span>for</span><span> </span><span>url </span><span>in</span><span> </span><span>sites</span><span>:</span></p><p><span>    </span><span># get the status for the url</span></p><p><span>    </span><span>status</span><span> </span><span>=</span><span> </span><span>await </span><span>get_status</span><span>(</span><span>url</span><span>)</span></p><p><span>    </span><span># report the url and its status</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;{url:30}:\t{status}&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can do better than sequential when using asyncio, but this provides a good starting point that we can improve upon later.</p>



<p>Tying this together, the <strong>main()</strong> coroutine queries the status of the top 10 websites.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629b3575123673" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p></div>
				</td>
						<td><div><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># list of top 10 websites to check</span></p><p><span>    </span><span>sites</span><span> </span><span>=</span><span> </span><span>[</span><span>&#39;https://www.google.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.youtube.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.facebook.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://twitter.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.instagram.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.baidu.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.wikipedia.org/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://yandex.ru/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://yahoo.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.whatsapp.com/&#39;</span></p><p><span>        </span><span>]</span></p><p><span>    </span><span># check the status of all websites</span></p><p><span>    </span><span>for</span><span> </span><span>url </span><span>in</span><span> </span><span>sites</span><span>:</span></p><p><span>        </span><span># get the status for the url</span></p><p><span>        </span><span>status</span><span> </span><span>=</span><span> </span><span>await </span><span>get_status</span><span>(</span><span>url</span><span>)</span></p><p><span>        </span><span># report the url and its status</span></p><p><span>        </span><span>print</span><span>(</span><span>f</span><span>&#39;{url:30}:\t{status}&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
</div>



<p>Finally, we can create the <strong>main()</strong> coroutine and use it as the entry point to the asyncio program.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629b4711266639" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># run the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Tying this together, the complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629b5955043122" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># check the status of many webpages</span></p><p><span>import </span><span>asyncio</span></p><p><span>from </span><span>urllib</span><span>.</span><span>parse </span><span>import </span><span>urlsplit</span></p><p><span># get the HTTP/S status of a webpage</span></p><p><span>async </span><span>def </span><span>get_status</span><span>(</span><span>url</span><span>)</span><span>:</span></p><p><span>    </span><span># split the url into components</span></p><p><span>    </span><span>url_parsed</span><span> </span><span>=</span><span> </span><span>urlsplit</span><span>(</span><span>url</span><span>)</span></p><p><span>    </span><span># open the connection</span></p><p><span>    </span><span>if</span><span> </span><span>url_parsed</span><span>.</span><span>scheme</span><span> </span><span>==</span><span> </span><span>&#39;https&#39;</span><span>:</span></p><p><span>        </span><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>url_parsed</span><span>.</span><span>hostname</span><span>,</span><span> </span><span>443</span><span>,</span><span> </span><span>ssl</span><span>=</span><span>True</span><span>)</span></p><p><span>    </span><span>else</span><span>:</span></p><p><span>        </span><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>url_parsed</span><span>.</span><span>hostname</span><span>,</span><span> </span><span>80</span><span>)</span></p><p><span>    </span><span># send GET request</span></p><p><span>    </span><span>query</span><span> </span><span>=</span><span> </span><span>f</span><span>&#39;GET {url_parsed.path} HTTP/1.1\r\nHost: {url_parsed.hostname}\r\n\r\n&#39;</span></p><p><span>    </span><span># write query to socket</span></p><p><span>    </span><span>writer</span><span>.</span><span>write</span><span>(</span><span>query</span><span>.</span><span>encode</span><span>(</span><span>)</span><span>)</span></p><p><span>    </span><span># wait for the bytes to be written to the socket</span></p><p><span>    </span><span>await </span><span>writer</span><span>.</span><span>drain</span><span>(</span><span>)</span></p><p><span>    </span><span># read the single line response</span></p><p><span>    </span><span>response</span><span> </span><span>=</span><span> </span><span>await </span><span>reader</span><span>.</span><span>readline</span><span>(</span><span>)</span></p><p><span>    </span><span># close the connection</span></p><p><span>    </span><span>writer</span><span>.</span><span>close</span><span>(</span><span>)</span></p><p><span>    </span><span># decode and strip white space</span></p><p><span>    </span><span>status</span><span> </span><span>=</span><span> </span><span>response</span><span>.</span><span>decode</span><span>(</span><span>)</span><span>.</span><span>strip</span><span>(</span><span>)</span></p><p><span>    </span><span># return the response</span></p><p><span>    </span><span>return</span><span> </span><span>status</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># list of top 10 websites to check</span></p><p><span>    </span><span>sites</span><span> </span><span>=</span><span> </span><span>[</span><span>&#39;https://www.google.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.youtube.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.facebook.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://twitter.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.instagram.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.baidu.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.wikipedia.org/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://yandex.ru/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://yahoo.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.whatsapp.com/&#39;</span></p><p><span>        </span><span>]</span></p><p><span>    </span><span># check the status of all websites</span></p><p><span>    </span><span>for</span><span> </span><span>url </span><span>in</span><span> </span><span>sites</span><span>:</span></p><p><span>        </span><span># get the status for the url</span></p><p><span>        </span><span>status</span><span> </span><span>=</span><span> </span><span>await </span><span>get_status</span><span>(</span><span>url</span><span>)</span></p><p><span>        </span><span># report the url and its status</span></p><p><span>        </span><span>print</span><span>(</span><span>f</span><span>&#39;{url:30}:\t{status}&#39;</span><span>)</span></p><p><span># run the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0015 seconds] -->
</div>



<p>Running the example first creates the <strong>main()</strong> coroutine and uses it as the entry point into the program.</p>



<p>The <strong>main()</strong> coroutine runs, defining a list of the top 10 websites.</p>



<p>The list of websites is then traversed sequentially. The <strong>main()</strong> coroutine suspends and calls the <strong>get_status()</strong> coroutine to query the status of one website.</p>



<p>The <strong>get_status()</strong> coroutine runs, parses the URL, and opens a connection. It constructs an HTTP GET query and writes it to the host. A response is read, decoded, and returned.</p>



<p>The <strong>main()</strong> coroutine resumes and reports the HTTP status of the URL.</p>



<p>This is repeated for each URL in the list.</p>



<p>The program takes about 5.6 seconds to complete, or about half a second per URL on average.</p>



<p>This highlights how we can use asyncio to query the HTTP status of webpages.</p>



<p>Nevertheless, it does not take full advantage of the asyncio to execute tasks concurrently.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629b6845832659" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>https://www.google.com/       :	HTTP/1.1 200 OK</p><p>https://www.youtube.com/      :	HTTP/1.1 200 OK</p><p>https://www.facebook.com/     :	HTTP/1.1 302 Found</p><p>https://twitter.com/          :	HTTP/1.1 200 OK</p><p>https://www.instagram.com/    :	HTTP/1.1 200 OK</p><p>https://www.baidu.com/        :	HTTP/1.1 200 OK</p><p>https://www.wikipedia.org/    :	HTTP/1.1 200 OK</p><p>https://yandex.ru/            :	HTTP/1.1 302 Moved temporarily</p><p>https://yahoo.com/            :	HTTP/1.1 301 Moved Permanently</p><p>https://www.whatsapp.com/     :	HTTP/1.1 302 Found</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Next, let’s look at how we might update the example to execute the coroutines concurrently.</p>



<h3><span id="Example_of_Checking_Website_Status_Concurrently"></span>Example of Checking Website Status Concurrently<span></span></h3>



<p>A benefit of asyncio is that we can execute many coroutines concurrently.</p>



<p>We can query the status of websites concurrently in asyncio using the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather"><strong>asyncio.gather()</strong> function</a>.</p>



<p>This function takes one or more coroutines, suspends executing the provided coroutines, and returns the results from each as an iterable. We can then traverse the list of URLs and iterable of return values from the coroutines and report results.</p>



<p>This may be a simpler approach than the above.</p>



<p>First, we can create a list of coroutines.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629b8667463844" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create all coroutine requests</span></p><p><span>coros</span><span> </span><span>=</span><span> </span><span>[</span><span>get_status</span><span>(</span><span>url</span><span>)</span><span> </span><span>for</span><span> </span><span>url </span><span>in</span><span> </span><span>sites</span><span>]</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Next, we can execute the coroutines and get the iterable of results using <strong>asyncio.gather()</strong>.</p>



<p>Note that we cannot provide the list of coroutines directly, but instead must unpack the list into separate expressions that are provided as positional arguments to the function.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629b9537915043" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute all coroutines and wait</span></p><p><span>results</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>*</span><span>coros</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This will execute all of the coroutines concurrently and retrieve their results.</p>



<p>We can then traverse the list of URLs and returned status and report each in turn.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629bb605171747" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># process all results</span></p><p><span>for</span><span> </span><span>url</span><span>,</span><span> </span><span>status </span><span>in</span><span> </span><span>zip</span><span>(</span><span>sites</span><span>,</span><span> </span><span>results</span><span>)</span><span>:</span></p><p><span>    </span><span># report status</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;{url:30}:\t{status}&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Tying this together, the complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629bc616497048" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># check the status of many webpages</span></p><p><span>import </span><span>asyncio</span></p><p><span>from </span><span>urllib</span><span>.</span><span>parse </span><span>import </span><span>urlsplit</span></p><p><span># get the HTTP/S status of a webpage</span></p><p><span>async </span><span>def </span><span>get_status</span><span>(</span><span>url</span><span>)</span><span>:</span></p><p><span>    </span><span># split the url into components</span></p><p><span>    </span><span>url_parsed</span><span> </span><span>=</span><span> </span><span>urlsplit</span><span>(</span><span>url</span><span>)</span></p><p><span>    </span><span># open the connection</span></p><p><span>    </span><span>if</span><span> </span><span>url_parsed</span><span>.</span><span>scheme</span><span> </span><span>==</span><span> </span><span>&#39;https&#39;</span><span>:</span></p><p><span>        </span><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>url_parsed</span><span>.</span><span>hostname</span><span>,</span><span> </span><span>443</span><span>,</span><span> </span><span>ssl</span><span>=</span><span>True</span><span>)</span></p><p><span>    </span><span>else</span><span>:</span></p><p><span>        </span><span>reader</span><span>,</span><span> </span><span>writer</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>open_connection</span><span>(</span><span>url_parsed</span><span>.</span><span>hostname</span><span>,</span><span> </span><span>80</span><span>)</span></p><p><span>    </span><span># send GET request</span></p><p><span>    </span><span>query</span><span> </span><span>=</span><span> </span><span>f</span><span>&#39;GET {url_parsed.path} HTTP/1.1\r\nHost: {url_parsed.hostname}\r\n\r\n&#39;</span></p><p><span>    </span><span># write query to socket</span></p><p><span>    </span><span>writer</span><span>.</span><span>write</span><span>(</span><span>query</span><span>.</span><span>encode</span><span>(</span><span>)</span><span>)</span></p><p><span>    </span><span># wait for the bytes to be written to the socket</span></p><p><span>    </span><span>await </span><span>writer</span><span>.</span><span>drain</span><span>(</span><span>)</span></p><p><span>    </span><span># read the single line response</span></p><p><span>    </span><span>response</span><span> </span><span>=</span><span> </span><span>await </span><span>reader</span><span>.</span><span>readline</span><span>(</span><span>)</span></p><p><span>    </span><span># close the connection</span></p><p><span>    </span><span>writer</span><span>.</span><span>close</span><span>(</span><span>)</span></p><p><span>    </span><span># decode and strip white space</span></p><p><span>    </span><span>status</span><span> </span><span>=</span><span> </span><span>response</span><span>.</span><span>decode</span><span>(</span><span>)</span><span>.</span><span>strip</span><span>(</span><span>)</span></p><p><span>    </span><span># return the response</span></p><p><span>    </span><span>return</span><span> </span><span>status</span></p><p><span># main coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># list of top 10 websites to check</span></p><p><span>    </span><span>sites</span><span> </span><span>=</span><span> </span><span>[</span><span>&#39;https://www.google.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.youtube.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.facebook.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://twitter.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.instagram.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.baidu.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.wikipedia.org/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://yandex.ru/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://yahoo.com/&#39;</span><span>,</span></p><p><span>        </span><span>&#39;https://www.whatsapp.com/&#39;</span></p><p><span>        </span><span>]</span></p><p><span>    </span><span># create all coroutine requests</span></p><p><span>    </span><span>coros</span><span> </span><span>=</span><span> </span><span>[</span><span>get_status</span><span>(</span><span>url</span><span>)</span><span> </span><span>for</span><span> </span><span>url </span><span>in</span><span> </span><span>sites</span><span>]</span></p><p><span>    </span><span># execute all coroutines and wait</span></p><p><span>    </span><span>results</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>gather</span><span>(</span><span>*</span><span>coros</span><span>)</span></p><p><span>    </span><span># process all results</span></p><p><span>    </span><span>for</span><span> </span><span>url</span><span>,</span><span> </span><span>status </span><span>in</span><span> </span><span>zip</span><span>(</span><span>sites</span><span>,</span><span> </span><span>results</span><span>)</span><span>:</span></p><p><span>        </span><span># report status</span></p><p><span>        </span><span>print</span><span>(</span><span>f</span><span>&#39;{url:30}:\t{status}&#39;</span><span>)</span></p><p><span># run the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
</div>



<p>Running the example executes the <strong>main()</strong> coroutine as before.</p>



<p>In this case, a list of coroutines is created in a list comprehension.</p>



<p>The <strong>asyncio.gather()</strong> function is then called, passing the coroutines and suspending the <strong>main()</strong> coroutine until they are all complete.</p>



<p>The coroutines execute, querying each website concurrently and returning their status.</p>



<p>The <strong>main()</strong> coroutine resumes and receives an iterable of status values. This iterable along with the list of URLs is then traversed using the <strong>zip()</strong> built-in function and the statuses are reported.</p>



<p>This highlights a simpler approach to executing the coroutines concurrently and reporting the results after all tasks are completed.</p>



<p>It is also faster than the sequential version above, completing in about 1.4 seconds on my system.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629bd161893947" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>https://www.google.com/       :	HTTP/1.1 200 OK</p><p>https://www.youtube.com/      :	HTTP/1.1 200 OK</p><p>https://www.facebook.com/     :	HTTP/1.1 302 Found</p><p>https://twitter.com/          :	HTTP/1.1 200 OK</p><p>https://www.instagram.com/    :	HTTP/1.1 200 OK</p><p>https://www.baidu.com/        :	HTTP/1.1 200 OK</p><p>https://www.wikipedia.org/    :	HTTP/1.1 200 OK</p><p>https://yandex.ru/            :	HTTP/1.1 302 Moved temporarily</p><p>https://yahoo.com/            :	HTTP/1.1 301 Moved Permanently</p><p>https://www.whatsapp.com/     :	HTTP/1.1 302 Found</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>Next, let’s explore common errors when getting started with asyncio.</p>



<h2><span id="Python_Asyncio_Common_Errors"></span>Python Asyncio Common Errors<span></span></h2>



<p>This section gives examples of general errors encountered by developers when using asyncio in Python.</p>



<p>The 5 most common asyncio errors are:</p>



<ol>
<li>Trying to run coroutines by calling them.</li>



<li>Not letting coroutines run in the event loop.</li>



<li>Using the asyncio low-level API.</li>



<li>Exiting the main coroutine too early.</li>



<li>Assuming race conditions and deadlocks are not possible.</li>
</ol>



<p>Let’s take a closer look at each in turn.</p>



<h3><span id="Error_1_Trying_to_Run_Coroutines_by_Calling_Them"></span>Error 1: Trying to Run Coroutines by Calling Them<span></span></h3>



<p>The most common error encountered by beginners to asyncio is calling a coroutine like a function.</p>



<p>For example, we can define a coroutine using the “async def” expression:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629bf030444064" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># custom coroutine</span></p><p><span>async </span><span>def </span><span>custom_coro</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span>print</span><span>(</span><span>&#39;hi there&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The beginner will then attempt to call this coroutine like a function and expect the print message to be reported.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629c1077026845" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># error attempt at calling a coroutine like a function</span></p><p><span>custom_coro</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Calling a coroutine like a function will not execute the body of the coroutine.</p>



<p>Instead, it will create a coroutine object.</p>



<p>This object can then be awaited within the asyncio runtime, e.g. the event loop.</p>



<p>We can start the event loop to run the coroutine using the asyncio.run() function.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629c2416260188" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># run a coroutine</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>custom_coro</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Alternatively, we can suspend the current coroutine and schedule the other coroutine using the “await” expression.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629c3027857348" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># schedule a coroutine</span></p><p><span>await </span><span>custom_coro</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>You can learn more about running coroutines in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-run-coroutine">How to Run an Asyncio Coroutine in Python</a></li>
</ul>



<h3><span id="Error_2_Not_Letting_Coroutines_Run_in_the_Event_Loop"></span>Error 2: Not Letting Coroutines Run in the Event Loop<span></span></h3>



<p>If a coroutine is not run, you will get a runtime warning as follows:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629c4312229607" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>sys:1: RuntimeWarning: coroutine &#39;custom_coro&#39; was never awaited</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<p>This will happen if you create a coroutine object but do not schedule it for execution within the asyncio event loop.</p>



<p>For example, you may attempt to call a coroutine from a regular Python program:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629c5977003573" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># attempt to call the coroutine</span></p><p><span>custom_coro</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This will not call the coroutine.</p>



<p>Instead, it will create a coroutine object.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629c6802873122" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a coroutine object</span></p><p><span>coro</span><span> </span><span>=</span><span> </span><span>custom_coro</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If you do not allow this coroutine to run, you will get a runtime error.</p>



<p>You can let the coroutine run, as we saw in the previous section, by starting the asyncio event loop and passing it the coroutine object.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629c8547714647" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a coroutine object</span></p><p><span>coro</span><span> </span><span>=</span><span> </span><span>custom_coro</span><span>(</span><span>)</span></p><p><span># run a coroutine</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>coro</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Or, on one line in a compound statement:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629c9381914004" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># run a coroutine</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>custom_coro</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>You can learn more about running coroutines in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-run-coroutine">How to Run an Asyncio Coroutine in Python</a></li>
</ul>



<p>If you get this error within an asyncio program, it is because you have created a coroutine and have not scheduled it for execution.</p>



<p>This can be achieved using the await expression.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629ca628953813" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a coroutine object</span></p><p><span>coro</span><span> </span><span>=</span><span> </span><span>custom_coro</span><span>(</span><span>)</span></p><p><span># suspend and allow the other coroutine to run</span></p><p><span>await </span><span>coro</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Or, you can schedule it to run independently as a task.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629cb798291033" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a coroutine object</span></p><p><span>coro</span><span> </span><span>=</span><span> </span><span>custom_coro</span><span>(</span><span>)</span></p><p><span># schedule the coro to run as a task interdependently</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>coro</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>You can learn more about creating tasks in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-create-task">How to Create an Asyncio Task in Python</a></li>
</ul>



<h3><span id="Error_3_Using_the_Low-Level_Asyncio_API"></span>Error 3: Using the Low-Level Asyncio API<span></span></h3>



<p>A big problem with beginners is that they use the wrong asyncio API.</p>



<p>This is common for a number of reasons.</p>



<ul>
<li>The API has changed a lot with recent versions of Python.</li>



<li>The API docs page makes things confusing, showing both APIs.</li>



<li>Examples elsewhere on the web mix up using the different APIs.</li>
</ul>



<p>Using the wrong API makes things more verbose (e.g. more code), more difficult, and way less understandable.</p>



<p>Asyncio offers <a href="https://docs.python.org/3/library/asyncio.html">two APIs</a>.</p>



<ol>
<li>High-level API for application developers (us)</li>



<li>Low-level API for framework and library developers (not us)</li>
</ol>



<p>The lower-level API provides the foundation for the high-level API and includes the internals of the event loop, transport protocols, policies, and more.</p>



<blockquote>
<p>… there are low-level APIs for library and framework developers</p>
<cite>— <a href="https://docs.python.org/3/library/asyncio.html">asyncio — Asynchronous I/O</a></cite></blockquote>



<p>We should almost always stick to the high-level API.</p>



<p>We absolutely must stick to the high-level API when getting started.</p>



<p>We may dip into the low-level API to achieve specific outcomes on occasion.</p>



<p>If you start getting a handle on the event loop or use a “loop” variable to do things, you are doing it wrong.</p>



<p>I am not saying don’t learn the low-level API.</p>



<p>Go for it. It’s great.</p>



<p>Just don’t start there.</p>



<p>Drive asyncio via the high-level API for a while. Develop some programs. Get comfortable with asynchronous programming and running coroutines at will.</p>



<p>Then later, dip in and have a look around.</p>



<h3><span id="Error_4_Exiting_the_Main_Coroutine_Too_Early"></span>Error 4: Exiting the Main Coroutine Too Early<span></span></h3>



<p>A major point of confusion in asyncio programs is not giving tasks enough time to complete.</p>



<p>We can schedule many coroutines to run independently within an asyncio program via the <strong>asyncio.create_task()</strong> method.</p>



<p>The main coroutine, the entry point for the asyncio program, can then carry on with other activities.</p>



<p>If the main coroutine exits, then the asyncio program will terminate.</p>



<p>The program will terminate even if there are one or many coroutines running independently as tasks.</p>



<p>This can catch you off guard.</p>



<p>You may issue many tasks and then allow the main coroutine to resume, expecting all issued tasks to complete in their own time.</p>



<p>Instead, if the main coroutine has nothing else to do, it should wait on the remaining tasks.</p>



<p>This can be achieved by first getting a set of all running tasks via the <strong>asyncio.all_tasks()</strong> function, removing itself from this set, then waiting on the remaining tasks via the <strong>asyncio.wait()</strong> function.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629cc428994667" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get a set of all running tasks</span></p><p><span>all_tasks</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>all_tasks</span><span>(</span><span>)</span></p><p><span># get the current tasks</span></p><p><span>current_task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>current_task</span><span>(</span><span>)</span></p><p><span># remove the current task from the list of all tasks</span></p><p><span>all_tasks</span><span>.</span><span>remove</span><span>(</span><span>current_task</span><span>)</span></p><p><span># suspend until all tasks are completed</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>all_tasks</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<h3><span id="Error_5_Assuming_Race_Conditions_and_Deadlocks_are_Impossible"></span>Error 5: Assuming Race Conditions and Deadlocks are Impossible<span></span></h3>



<p>Concurrent programming has the hazard of concurrency-specific failure modes.</p>



<p>This includes problems such as race conditions and deadlocks.</p>



<p>A race condition involves two or more units of concurrency executing the same critical section at the same time and leaving a resource or data in an inconsistent or unexpected state. This can lead to data corruption and data loss.</p>



<p>A deadlock is when a unit of concurrency waits for a condition that can never occur, such as for a resource to become available.</p>



<p>Many Python developers believe these problems are not possible with coroutines in asyncio.</p>



<p>The reason being that only one coroutine can run within the event loop at any one time.</p>



<p>It is true that only one coroutine can run at a time.</p>



<p>The problem is, coroutines can suspend and resume and may do so while using a shared resource or shared variable.</p>



<p>Without protecting critical sections, race conditions can occur in asyncio programs.</p>



<p>Without careful management of synchronization primitives, deadlocks can occur </p>



<p>As such, it is important that asyncio programs are created ensuring coroutine-safety, a concept similar to thread-safety and process-safety, applied to coroutines.</p>



<h2><span id="Python_Asyncio_Common_Questions"></span>Python Asyncio Common Questions<span></span></h2>



<p>This section answers common questions asked by developers when using asyncio in Python.</p>



<p><strong>Do you have a question about asyncio?</strong></p>



<h3><span id="How_to_Stop_a_Task"></span>How to Stop a Task?<span></span></h3>



<p>We can cancel a task via the <strong>cancel()</strong> method on an <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel"><strong>asyncio.Task</strong> object</a>.</p>



<p>The <strong>cancel()</strong> method returns <strong>True</strong> if the task was canceled, or <strong>False</strong> otherwise.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629cf204750942" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># cancel the task</span></p><p><span>was_cancelled</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>cancel</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>If the task is already done, it cannot be canceled and the <strong>cancel()</strong> method will return <strong>False</strong> and the task will not have the status of canceled.</p>



<p>The next time the task is given an opportunity to run, it will raise a <strong>CancelledError</strong> exception.</p>



<p>If the <strong>CancelledError</strong> exception is not handled within the wrapped coroutine, the task will be canceled.</p>



<p>Otherwise, if the <strong>CancelledError</strong> exception is handled within the wrapped coroutine, the task will not be canceled.</p>



<p>The <strong>cancel()</strong> method can also take a message argument which will be used in the content of the CancelledError.</p>



<p>We can explore how to cancel a running task.</p>



<p>In this example, we define a task coroutine that reports a message and then blocks for a moment.</p>



<p>We then define the main coroutine that is used as the entry point into the asyncio program. It reports a message, creates and schedules the task, then waits a moment.</p>



<p>The main coroutine then resumes and cancels the task while it is running. It waits a moment more to allow the task to respond to the request to cancel. The main coroutine then reports whether the request to cancel the task was successful.</p>



<p>The task is canceled and is then done.</p>



<p>The main coroutine then reports whether the status of the task is canceled before closing the program.</p>



<p>The complete example is listed below.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629d1521209664" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p></div>
				</td>
						<td><div><p><span># SuperFastPython.com</span></p><p><span># example of canceling a running task</span></p><p><span>import </span><span>asyncio</span></p><p><span># define a coroutine for a task</span></p><p><span>async </span><span>def </span><span>task_coroutine</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;executing the task&#39;</span><span>)</span></p><p><span>    </span><span># block for a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span></p><p><span># custom coroutine</span></p><p><span>async </span><span>def </span><span>main</span><span>(</span><span>)</span><span>:</span></p><p><span>    </span><span># report a message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;main coroutine started&#39;</span><span>)</span></p><p><span>    </span><span># create and schedule the task</span></p><p><span>    </span><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>task_coroutine</span><span>(</span><span>)</span><span>)</span></p><p><span>    </span><span># wait a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0.1</span><span>)</span></p><p><span>    </span><span># cancel the task</span></p><p><span>    </span><span>was_cancelled</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>cancel</span><span>(</span><span>)</span></p><p><span>    </span><span># report whether the cancel request was successful</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;was canceled: {was_cancelled}&#39;</span><span>)</span></p><p><span>    </span><span># wait a moment</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0.1</span><span>)</span></p><p><span>    </span><span># check the status of the task</span></p><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#39;canceled: {task.cancelled()}&#39;</span><span>)</span></p><p><span>    </span><span># report a final message</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;main coroutine done&#39;</span><span>)</span></p><p><span># start the asyncio program</span></p><p><span>asyncio</span><span>.</span><span>run</span><span>(</span><span>main</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
</div>



<p>Running the example starts the asyncio event loop and executes the <strong>main()</strong> coroutine.</p>



<p>The <strong>main()</strong> coroutine reports a message, then creates and schedules the task coroutine.</p>



<p>It then suspends and awaits a moment to allow the task coroutine to begin running.</p>



<p>The task runs, reports a message and sleeps for a while.</p>



<p>The <strong>main()</strong> coroutine resumes and cancels the task. It reports that the request to cancel the task was successful.</p>



<p>It then sleeps for a moment to allow the task to respond to the request to be canceled.</p>



<p>The <strong>task_coroutine()</strong> resumes and a <strong>CancelledError</strong> exception is raised that causes the task to fail and be done.</p>



<p>The <strong>main()</strong> coroutine resumes and reports whether the task has the status of canceled. In this case, it does.</p>



<p>This example highlights the normal case of canceling a running task.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629d2848500432" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p>main coroutine started</p><p>executing the task</p><p>was canceled: True</p><p>canceled: True</p><p>main coroutine done</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0000 seconds] -->
</div>



<h3><span id="How_to_Wait_for_a_Task_To_Finish"></span>How to Wait for a Task To Finish?<span></span></h3>



<p>We can wait for a task to finish by awaiting the <strong>asyncio.Task</strong> object directly.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629d4388076889" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for the task to finish</span></p><p><span>await </span><span>task</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We may create and wait for the task in a single line.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629d5267015196" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create and wait for the task to finish</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>custom_coro</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="How_to_Get_a_Return_Value_from_a_Task"></span>How to Get a Return Value from a Task?<span></span></h3>



<p>We may need to return values from coroutines to the caller.</p>



<p>We can retrieve a return value from a coroutine by awaiting it.</p>



<p>It assumes that the other coroutine being awaited returns a value.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629d6830202563" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># coroutine that returns a value</span></p><p><span>async </span><span>def </span><span>other_coro</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span>return</span><span> </span><span>100</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Awaiting the other coroutine will suspend the calling coroutine and schedule the other coroutine for execution. Once the other coroutine has been completed, the calling coroutine will resume. The return value will be passed from the other coroutine to the caller.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629d7137697545" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute coroutine and retrieve return value</span></p><p><span>value</span><span> </span><span>=</span><span> </span><span>await </span><span>other_coro</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>A coroutine can be wrapped in an <strong>asyncio.Task</strong> object.</p>



<p>This is helpful for independently executing the coroutine without having the current coroutine await it.</p>



<p>This can be achieved using the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task"><strong>asyncio.create_task()</strong> function</a>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629eb358324526" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wrap coroutine in a task and schedule it for execution</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>other_coro</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>You can learn more about how to create tasks in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-create-task">How to Create an Asyncio Task in Python</a></li>
</ul>



<p>There are two ways to retrieve the return value from an <strong>asyncio.Task</strong>, they are:</p>



<ol>
<li>Await the task.</li>



<li>Call the result() method.</li>
</ol>



<p>We can await the task to retrieve the return value.</p>



<p>If the task is scheduled or running, then the caller will suspend until the task is complete and the return value will be provided.</p>



<p>If the task is completed, the return value will be provided immediately.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629ec600277676" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the return value from a task</span></p><p><span>value</span><span> </span><span>=</span><span> </span><span>await </span><span>task</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Unlike a coroutine, we can await a task more than once without raising an error.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629ee948041050" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the return value from a task</span></p><p><span>value</span><span> </span><span>=</span><span> </span><span>await </span><span>task</span></p><p><span># get the return value from a task</span></p><p><span>value</span><span> </span><span>=</span><span> </span><span>await </span><span>task</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>We can also get the return value from the task by calling the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.result"><strong>result()</strong> method</a> on the <strong>asyncio.Task</strong> object.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629ef699585842" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the return value from a task</span></p><p><span>value</span><span> </span><span>=</span><span> </span><span>task</span><span>.</span><span>result</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This requires that the task is done. If not, an <strong>InvalidStateError</strong> exception will be raised.</p>



<p>If the task was canceled a <strong>CancelledError</strong> exception will be raised.</p>



<p>You can learn more about getting the result from tasks in the tutorial:</p>



<ul>
<li><a href="http://alok.github.io/asyncio-task-result">How to Get Asyncio Task Results</a></li>
</ul>



<h3><span id="How_to_Run_a_Task_in_the_Background"></span>How to Run a Task in the Background?<span></span></h3>



<p>We can run a coroutine in the background by wrapping it in an <strong>asyncio.Task</strong> object.</p>



<p>This can be achieved by calling the <strong>asyncio.create_task()</strong> function and passing it the coroutine.</p>



<p>The coroutine will be wrapped in a Task object and will be scheduled for execution. The task object will be returned and the caller will not suspend.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629f0739922000" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># schedule the task for execution</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>other_coroutine</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The task will not begin executing until at least the current coroutine is suspended, for any reason.</p>



<p>We can help things along by suspending for a moment to allow the task to start running.</p>



<p>This can be achieved by sleeping for zero seconds.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629f1725165962" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># suspend for a moment to allow the task to start running</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>0</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This will suspend the caller only for a brief moment and allow the ask an opportunity to run.</p>



<p>This is not required as the caller may suspend at some future time or terminate as part of normal execution.</p>



<p>We may also await the task directly once the caller has run out of things to do.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629f3116183895" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for the task to complete</span></p><p><span>await </span><span>task</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="How_to_Wait_for_All_Background_Tasks"></span>How to Wait for All Background Tasks?<span></span></h3>



<p>We can wait for all independent tasks in an asyncio program.</p>



<p>This can be achieved by first getting a set of all currently running tasks via the <strong>asyncio.all_tasks()</strong> function.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629f4398223123" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get a set of all running tasks</span></p><p><span>all_tasks</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>all_tasks</span><span>(</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>This will return a set that contains one <strong>asyncio.Task</strong> object for each task that is currently running, including the <strong>main()</strong> coroutine.</p>



<p>We cannot wait on this set directly, as it will block forever as it includes the task that is the current task.</p>



<p>Therefore we can get the <strong>asyncio.Task</strong> object for the currently running task and remove it from the set.</p>



<p>This can be achieved by first calling the <strong>asyncio.current_task()</strong> method to get the task for the current coroutine and then remove it from the set via the <strong>remove()</strong> method.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629f5930543543" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the current tasks</span></p><p><span>current_task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>current_task</span><span>(</span><span>)</span></p><p><span># remove the current task from the list of all tasks</span></p><p><span>all_tasks</span><span>.</span><span>remove</span><span>(</span><span>current_task</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>Finally, we can wait on the set of remaining tasks.</p>



<p>This will suspend the caller until all tasks in the set are complete.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629f6110196899" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># suspend until all tasks are completed</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>all_tasks</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Tying this together, the snippet below added to the end of the <strong>main()</strong> coroutine will wait for all background tasks to complete.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629f8394862319" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get a set of all running tasks</span></p><p><span>all_tasks</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>all_tasks</span><span>(</span><span>)</span></p><p><span># get the current tasks</span></p><p><span>current_task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>current_task</span><span>(</span><span>)</span></p><p><span># remove the current task from the list of all tasks</span></p><p><span>all_tasks</span><span>.</span><span>remove</span><span>(</span><span>current_task</span><span>)</span></p><p><span># suspend until all tasks are completed</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>wait</span><span>(</span><span>all_tasks</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<h3><span id="Does_a_Running_Task_Stop_the_Event_Loop_from_Exiting"></span>Does a Running Task Stop the Event Loop from Exiting?<span></span></h3>



<p>No.</p>



<p>A task that is scheduled and run independently will not stop the event loop from exiting.</p>



<p>If your main coroutine has no other activities to complete and there are independent tasks running in the background, you should retrieve the running tasks and wait on them</p>



<p>The previous question/answer shows exactly how to do this.</p>



<h3><span id="How_to_Show_Progress_of_Running_Tasks"></span>How to Show Progress of Running Tasks?<span></span></h3>



<p>We can show progress using a done callback function on each task.</p>



<p>A done callback is a function that we can register on an <strong>asyncio.Task</strong>.</p>



<p>It is called once the task is done, either normally or if it fails.</p>



<p>The done callback function is a regular function, not a coroutine, and takes the <strong>asyncio.Task</strong> that it is associated with as an argument.</p>



<p>We can use the same callback function for all tasks and report progress in a general way, such as by reporting a message.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629f9484953499" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># callback function to show progress of tasks</span></p><p><span>def </span><span>progress</span><span>(</span><span>task</span><span>)</span><span>:</span></p><p><span>    </span><span># report progress of the task</span></p><p><span>    </span><span>print</span><span>(</span><span>&#39;.&#39;</span><span>,</span><span> </span><span>end</span><span>=</span><span>&#39;&#39;</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>We can register a callback function on each <strong>asyncio.Task</strong> that we issue.</p>



<p>This can be achieved using the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.add_done_callback"><strong>add_done_callback()</strong> method</a> on each task and passing it the name of the callback function.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629fa862248519" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># add a done callback to a task</span></p><p><span>task</span><span>.</span><span>add_done_callback</span><span>(</span><span>progress</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<h3><span id="How_to_Run_a_Task_After_a_Delay"></span>How to Run a Task After a Delay?<span></span></h3>



<p>We can develop a custom wrapper coroutine to execute a target coroutine after a delay.</p>



<p>The wrapper coroutine may take two arguments, a coroutine and a time in seconds.</p>



<p>It will sleep for the given delay interval in seconds, then await the provided coroutine.</p>



<p>The <strong>delay()</strong> coroutine below implements this.</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629fc436036019" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># coroutine that will start another coroutine after a delay in seconds</span></p><p><span>async </span><span>def </span><span>delay</span><span>(</span><span>coro</span><span>,</span><span> </span><span>seconds</span><span>)</span><span>:</span></p><p><span>    </span><span># suspend for a time limit in seconds</span></p><p><span>    </span><span>await </span><span>asyncio</span><span>.</span><span>sleep</span><span>(</span><span>seconds</span><span>)</span></p><p><span>    </span><span># execute the other coroutine</span></p><p><span>    </span><span>await </span><span>coro</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>To use the wrapper coroutine, a coroutine object can be created and either awaited directly or executed independently as a task.</p>



<p>For example, the caller may suspend and schedule the delayed coroutine and wait for it to be done:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629fd318534365" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute a coroutine after a delay</span></p><p><span>await </span><span>delay</span><span>(</span><span>coro</span><span>,</span><span> </span><span>10</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Alternatively, the caller may schedule the delayed coroutine to run independently:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a629fe401156356" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute a coroutine after a delay independently</span></p><p><span>_</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>delay</span><span>(</span><span>coro</span><span>,</span><span> </span><span>10</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<h3><span id="How_to_Run_a_Follow-Up_Task"></span>How to Run a Follow-Up Task?<span></span></h3>



<p>There are three main ways to issue follow-up tasks in asyncio.</p>



<p>They are:</p>



<ol>
<li>Schedule the follow-up task from the completed task itself.</li>



<li>Schedule the follow-up task from the caller.</li>



<li>Schedule the follow-up task automatically using a done callback.</li>
</ol>



<p>Let’s take a closer look at each approach.</p>



<p>The task that is completed can issue its own follow-up task.</p>



<p>This may require checking some state in order to determine whether the follow-up task should be issued or not.</p>



<p>The task can then be scheduled via a call to <strong>asyncio.create_task()</strong>.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62a00956687116" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># schedule a follow-up task</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>followup_task</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The task itself may choose to await the follow-up task or let it complete in the background independently.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62a01552371342" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># wait for the follow-up task to complete</span></p><p><span>await </span><span>task</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The caller that issued the task can choose to issue a follow-up task.</p>



<p>For example, when the caller issues the first task, it may keep the <strong>asyncio.Task</strong> object.</p>



<p>It can then check the result of the task or whether the task was completed successfully or not.</p>



<p>The caller can then decide to issue a follow-up task.</p>



<p>It may or may not await the follow-up task directly.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62a02010460672" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># issue and await the first task</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>task</span><span>(</span><span>)</span><span>)</span></p><p><span># check the result of the task</span></p><p><span>if</span><span> </span><span>task</span><span>.</span><span>result</span><span>(</span><span>)</span><span>:</span></p><p><span>	</span><span># issue the follow-up task</span></p><p><span>	</span><span>followup</span><span> </span><span>=</span><span> </span><span>await </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>followup_task</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>We can execute a follow-up task automatically using a done callback function.</p>



<p>For example, the caller that issues the task can register a done callback function on the task itself.</p>



<p>The done callback function must take the <strong>asyncio.Task</strong> object as an argument and will be called only after the task is done. It can then choose to issue a follow-up task.</p>



<p>The done callback function is a regular Python function, not a coroutine, so it cannot await the follow-up task</p>



<p>For example, the callback function may look as follows:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62a04238153893" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># callback function</span></p><p><span>def </span><span>callback</span><span>(</span><span>task</span><span>)</span><span>:</span></p><p><span>    </span><span># schedule and await the follow-up task</span></p><p><span>    </span><span>_</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>followup</span><span>(</span><span>)</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<p>The caller can issue the first task and register the done callback function.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62a05261151164" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># schedule and the task</span></p><p><span>task</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>create_task</span><span>(</span><span>work</span><span>(</span><span>)</span><span>)</span></p><p><span># add the done callback function</span></p><p><span>task</span><span>.</span><span>add_done_callback</span><span>(</span><span>callback</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
</div>



<h3><span id="How_to_Execute_a_Blocking_IO_or_CPU-bound_Function_in_Asyncio"></span>How to Execute a Blocking I/O or CPU-bound Function in Asyncio?<span></span></h3>



<p>The asyncio module provides two approaches for executing blocking calls in asyncio programs.</p>



<p>The first is to use the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.to_thread"><strong>asyncio.to_thread()</strong> function</a>.</p>



<p>This is in the high-level API and is intended for application developers.</p>



<p>The <strong>asyncio.to_thread()</strong> function takes a function name to execute and any arguments.</p>



<p>The function is executed in a separate thread. It returns a coroutine that can be awaited or scheduled as an independent task.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62a06247556418" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># execute a function in a separate thread</span></p><p><span>await </span><span>asyncio</span><span>.</span><span>to_thread</span><span>(</span><span>task</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>The task will not begin executing until the returned coroutine is given an opportunity to run in the event loop.</p>



<p>The <strong>asyncio.to_thread()</strong> function creates a <strong>ThreadPoolExecutor</strong> behind the scenes to execute blocking calls.</p>



<p>As such, the <strong>asyncio.to_thread()</strong> function is only appropriate for IO-bound tasks.</p>



<p>An alternative approach is to use the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor"><strong>loop.run_in_executor()</strong> function</a>.</p>



<p>This is in the low-level asyncio API and first requires access to the event loop, such as via the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><strong>asyncio.get_running_loop()</strong> function</a>.</p>



<p>The <strong>loop.run_in_executor()</strong> function takes an executor and a function to execute.</p>



<p>If <strong>None</strong> is provided for the executor, then the default executor is used, which is a <strong>ThreadPoolExecutor</strong>.</p>



<p>The <strong>loop.run_in_executor()</strong> function returns an awaitable that can be awaited if needed. The task will begin executing immediately, so the returned awaitable does not need to be awaited or scheduled for the blocking call to start executing.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62a07727233743" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># get the event loop</span></p><p><span>loop</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>get_running_loop</span><span>(</span><span>)</span></p><p><span># execute a function in a separate thread</span></p><p><span>await </span><span>loop</span><span>.</span><span>run_in_executor</span><span>(</span><span>None</span><span>,</span><span> </span><span>task</span><span>)</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->
</div>



<p>Alternatively, an executor can be created and passed to the <strong>loop.run_in_executor()</strong> function, which will execute the asynchronous call in the executor.</p>



<p>The caller must manage the executor in this case, shutting it down once the caller is finished with it.</p>



<p>For example:</p>



<div><!-- Urvanov Syntax Highlighter v2.8.28 -->

		<div id="urvanov-syntax-highlighter-636d365a62a09680090496" data-settings=" no-popup minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>.</span><span>.</span><span>.</span></p><p><span># create a process pool</span></p><p><span>with </span><span>ProcessPoolExecutor </span><span>as</span><span> </span><span>exe</span><span>:</span></p><p><span>	</span><span># get the event loop</span></p><p><span>	</span><span>loop</span><span> </span><span>=</span><span> </span><span>asyncio</span><span>.</span><span>get_running_loop</span><span>(</span><span>)</span></p><p><span>	</span><span># execute a function in a separate thread</span></p><p><span>	</span><span>await </span><span>loop</span><span>.</span><span>run_in_executor</span><span>(</span><span>exe</span><span>,</span><span> </span><span>task</span><span>)</span></p><p><span>	</span><span># process pool is shutdown automatically...</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
</div>



<p>These two approaches allow a blocking call to be executed as an asynchronous task in an asyncio program.</p>



<h2><span id="Common_Objections_to_Using_Asyncio"></span>Common Objections to Using Asyncio<span></span></h2>



<p>Asyncio and coroutines may not be the best solution for all concurrency problems in your program.</p>



<p>That being said, there may also be some misunderstandings that are preventing you from making full and best use of the capabilities of the asyncio in Python.</p>



<p>In this section, we review some of the common objections seen by developers when considering using the asyncio.</p>



<h3><span id="What_About_the_Global_Interpreter_Lock_GIL"></span>What About the Global Interpreter Lock (GIL)?<span></span></h3>



<p>The GIL protects the internals of the Python interpreter from concurrent access and modification from multiple threads.</p>



<p>The asyncio event loop runs in one thread.</p>



<p>This means that all coroutines run in a single thread.</p>



<p>As such the GIL is not an issue when using asyncio and coroutine.</p>



<h3><span id="Are_Python_Coroutines_Real"></span>Are Python Coroutines “<em>Real</em>“?<span></span></h3>



<p>Coroutines are managed in software.</p>



<p>Coroutines run and are managed (switched) within the asyncio event loop in the Python runtime.</p>



<p>They are not a software representation of a capability provided by the underlying operating system, like threads and processes.</p>



<p>In this sense, Python does not have support for “native coroutines”, but I’m not sure such things exist in modern operating systems.</p>



<h3><span id="Isnt_Python_Concurrency_Buggy"></span>Isn’t Python Concurrency Buggy?<span></span></h3>



<p>No.</p>



<p>Python provides first-class concurrency with coroutines, threads, and processes.</p>



<p>It has for a long time now and it is widely used in open source and commercial projects.</p>



<h3><span id="Isnt_Python_a_Bad_Choice_for_Concurrency"></span>Isn’t Python a Bad Choice for Concurrency?<span></span></h3>



<p>Developers love python for many reasons, most commonly because it is easy to use and fast for development.</p>



<p>Python is commonly used for glue code, one-off scripts, but more and more for large-scale software systems.</p>



<p>If you are using Python and then you need concurrency, then you work with what you have. The question is moot.</p>



<p>If you need concurrency and you have not chosen a language, perhaps another language would be more appropriate, or perhaps not. Consider the full scope of functional and non-functional requirements (or user needs, wants, and desires) for your project and the capabilities of different development platforms.</p>



<h3><span id="Why_Not_Use_Threads_Instead"></span>Why Not Use Threads Instead?<span></span></h3>



<p>You can use threads instead of asyncio.</p>



<p>Any program developed using threads can be rewritten to use asyncio and coroutines.</p>



<p>Any program developed using coroutines and asyncio can be rewritten to use threads.</p>



<p>Adopting asyncio in a project is a choice, the rationale is yours.</p>



<p>For the most part, they are functionally equivalent.</p>



<p>Many use cases will execute faster using threads and may be more familiar to a wider array of Python developers.</p>



<p>Some use cases in the areas of network programming and executing system commands may be simpler (less code) when using asyncio, and significantly more scalable than using threads.</p>



<h2><span id="Further_Reading"></span>Further Reading<span></span></h2>



<p>This section lists helpful additional resources on the topic.</p>



<h3><span id="Python_Asyncio_Books"></span>Python Asyncio Books<span></span></h3>



<p>This section lists my books on Python asyncio, designed to help you get started and get good, super fast.</p>



<ul>
<li><a href="https://superfastpython.gumroad.com/l/pacs">Asyncio Module API Cheat Sheet</a></li>



<li><a href="https://superfastpython.com/paj-further-reading">Python Asyncio Jump-Start</a>, Jason Brownlee, 2022. (<strong>my book!</strong>)</li>
</ul>



<h3><span id="Other_Books"></span>Other Books<span></span></h3>



<p>Other books on asyncio include:</p>



<ul>
<li><a href="https://amzn.to/3LZvxNn">Python Concurrency with asyncio</a>, Matthew Fowler, 2022.</li>



<li><a href="https://amzn.to/3lNp2ml">Using Asyncio in Python</a>, Caleb Hattingh, 2020.</li>
</ul>



<h3><span id="APIs"></span>APIs<span></span></h3>



<ul>
<li><a href="https://docs.python.org/3/library/asyncio.html">asyncio — Asynchronous I/O</a></li>



<li><a href="https://docs.python.org/3/library/asyncio-task.html">Asyncio Coroutines and Tasks</a></li>



<li><a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></li>



<li><a href="https://docs.python.org/3/library/asyncio-subprocess.html">Asyncio Subprocesses</a></li>



<li><a href="https://docs.python.org/3/library/asyncio-queue.html">Asyncio Queues</a></li>



<li><a href="https://docs.python.org/3/library/asyncio-sync.html">Asyncio Synchronization Primitives</a></li>
</ul>



<h3><span id="References"></span>References<span></span></h3>



<ul>
<li><a href="https://en.wikipedia.org/wiki/Asynchronous_I/O">Asynchronous I/O, Wikipedia</a>.</li>



<li><a href="https://en.wikipedia.org/wiki/Coroutine">Coroutine, Wikipedia</a>.</li>
</ul>



<h2><span id="Conclusions"></span>Conclusions<span></span></h2>



<p>This is a large guide, and you have discovered in great detail how asyncio and coroutines work in Python and how to best use them in your project.</p>



<p><strong>Did you find this guide useful?</strong></p>



<p><strong>Have you used asyncio on a project?</strong></p>



<p><strong>Do you have any questions?</strong></p>

<!-- AI CONTENT END 2 -->
</div></div>
  </body>
</html>
