<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scattered-thoughts.net/writing/coding/">Original</a>
    <h1>Coding</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>This post is part of a series, starting at <a href="https://www.nytimes.com/writing/reflections-on-a-decade-of-coding">Reflections on a decade of coding</a>.</em></p><p>This is going to be much more vague than the other parts of the series because this is the actual work. Good judgement is learned from experience, not from blog posts. So I think the most useful thing I can convey is what kinds of things I think about when coding, rather than what answers I come up with.</p><p>I&#39;m also trying to focus on things that were non-obvious to me or that run counter to what I was taught.</p><hr/><p>The foremost idea I keep in mind is that the goal of writing a program is to turn inputs into outputs, while making good use of limited human and machine resources.</p><hr/><p>The goal is not to make code that is pretty or elegant or that reads like english.</p><p>Certainly I want to write code that is readable, but when I&#39;m reading code it&#39;s because I want to learn what the code actually does, rather than what it says it does.</p><p>That includes understanding what data it reads or writes, and in what order and at what time. So I&#39;ve ended up with a somewhat brutalist aesthetic, where the data is on full display and the access to it is not hidden behind layers of methods calls and private fields.</p><p>I&#39;ve found this data-centric approach works very well for the kinds of problems I work on, but I&#39;ve also seen advocates for this kind of approach in many other domains eg:</p><ul><li><a href="https://www.youtube.com/watch?v=rX0ItVEVjHc">Low-level, performance-bound systems</a></li><li><a href="https://youtu.be/2V1FtfBDsLU?t=642">High-level, long-lived systems</a></li><li><a href="https://www.youtube.com/watch?v=R2Aa4PivG0g">Distributed systems</a></li><li><a href="https://media.handmade-seattle.com/practical-data-oriented-design/">Incremental compilers</a> and <a href="https://www.youtube.com/watch?v=_muY4HjSqVw">IDE tooling</a></li></ul><p>This approach is in stark opposition to the way programming is typically taught, which is to employ maximum defensive encapsulation at every tiny boundary and hide data behind opaque interfaces wherever possible. When code is written in this style it becomes very difficult to answer questions like &#34;is it safe to call myobj.foo() from inside myobj.bar()&#34; or &#34;at which points in time is the value of quux in sync with the upstream value of baz&#34;. It also tends to produce object-at-a-time and copy-heavy apis which get in the way of using the hardware efficiently.</p><hr/><p>The foundational design question is always &#34;what do I want the machine to do&#34;. Everything else is just a tool for concisely expressing that behavior. So when I&#39;m deciding how to design a schema or how to organize code into modules etc, all that matters is what would be most useful for making the computer do the thing.</p><p>If I ever find myself thinking about whether a contractor is &#39;really&#39; a kind of employee, or whether two functions &#39;belong&#39; together, that&#39;s a trap. There is no point trying to get the code to correctly mirror the structure of reality, because that structure doesn&#39;t exist. The categories <a href="https://www.lesswrong.com/posts/yA4gF5KrboK2m2Xu7/how-an-algorithm-feels-from-inside">are in our heads</a>, not out in the world, and they&#39;re only ever &#39;correct&#39; to the extent that they are useful.</p><p>The questions that matter are questions about the behavior of the machine - like should we withhold taxes from contractor payments like we do for employees, or schedule contractors in for mandatory employee training? Once you have the answer to all those questions then in all the cases where contractors and employees are treated the same you can just write that code once, and in all the other cases you have to write different code. At that point the remaining question of whether a contractor is &#39;really&#39; a kind of employee is empty and meaningless - there is no empirical test that would answer it, and even if there was the answer wouldn&#39;t have any bearing on the design of the program.</p><hr/><p>A special case of this trap is trying to organize everything into some hierarchy. The point of any kind of code organization tool is to capture repeated patterns in the desired behavior so that we don&#39;t have to write out a bajillion slightly different versions of the same thing. But there isn&#39;t any law that says that those patterns must always be tree-shaped. Sometimes useful categories will overlap. Trying to force the structure of the problem to fit into some class hierarchy is just borrowing trouble.</p><p>The same goes for organizing code into files and folders. There are always different cross-cutting concerns which suggest different ways to organize the code into a tree. It really isn&#39;t worth wasting a lot of time trying to find the &#39;right&#39; one.</p><h2 id="logical-design">Logical design</h2><p>I usually start by thinking in data in terms of atomic facts.</p><p>Facts are things that will always remain true. So &#39;Bob is a contractor&#39; is not a fact but &#39;Bob signed a contracting agreement with us on 2021-11-10&#39; is.</p><p>If you think too hard about this you end up butting up against the impossibility of direct access to objective reality. So don&#39;t think too hard - it&#39;s enough for something to be &#39;always true&#39; only as far as this program is concerned ie our code will never have to delete or modify it.</p><p>Similarly, &#39;atomic&#39; means that, as far as this program is concerned, the entire fact is input/computed either all at once or not at all. So &#39;Bob had a contracting agreement from 2021-11-10 until 2022-11-10&#39; might be atomic if you always use contracts with fixed end dates, but otherwise might need to be split into &#39;Bob signed contract 1047 on 2021-11-10&#39; and &#39;Bob ended contract 1047 on 2022-11-10&#39;.</p><hr/><p>The sudden appearance of &#39;contract 1047&#39; above is typical. If you know everything there is to know about some thing, then you can refer to it later by using that entire set of facts (realistically, a hash of that set). But if information trickles in over time then you need to find or create some id to tie the facts together with.</p><p>The easiest way to do this is to create a sequential or random id when the thing in question is first mentioned. So someone clicks &#39;new contract&#39; and we report that the new contract has id 1047. Any future input has to refer to that contract id. Effectively we&#39;re pawning off the problem of tieing together the facts about this contract to the outside world, which now has to remember the contract id when interacting with out system in future. We could equally replace the random id with &#39;the contract created by user X at time T&#39;.</p><p>This only works if the creation of the new contract is a unique event. If there are fallible operations between clicking &#39;new contract&#39; and assigning the contract id then we might accidentally assign multiple ids when retrying an operation. So we want to assign the id as close as possible to the event that caused it eg if clicking the &#39;new contract&#39; button in a browser we should assign the id in the browser once and then try (and maybe retry) to submit it to the server. (Another reason to generate ids at the edge of the system is that it&#39;s hard to write tests for a system that generates different ids when run with the same input - much easier to have the ids already in the inputs and then the test outputs can be deterministic).</p><p>When dealing with incremental maintenance or caching we also have to consider how stable is the association between ids and cached data with respect to typical changes in the inputs. Eg inside an IDE we wouldn&#39;t want to use &#39;the variable at character N&#39; as an id to cache type information, because any insert or delete in that file would require changing most of the cached data. Instead we might want to use something like &#39;the first variable named foo in the first function named bar&#39;, which will only change if the function name or variable name are edited.</p><p>Many data modelling methods ask you to identify the &#39;objects&#39; or &#39;entities&#39; in the world, but identity becomes philosophically troublesome when you dig into it. I find it much easier to start with desired behavior and then derive ids from facts that I want to connect or computations that I want to cache.</p><hr/><p>Next I think about how to turn inputs into outputs, and what intermediate state would be useful for writing that code. I end up with some graph of data where the inputs are at the top, the outputs are at the bottom and there is various derived data in the middle.</p><p>Ideally I also want to have some quantitative understanding of the data too - how many inputs there are, how they&#39;re distributed, whether there are any strong correlations in the data etc. But when working on database engines the answer is typically &#34;any many as possible&#34; so I have to settle for looking at existing benchmarks and case studies and trying to come up with both lower bounds and aspirational targets.</p><hr/><p>When I explain all of this explicitly it sounds like an incredibly formal and elaborate process, but it&#39;s mostly automatic. Unless I&#39;m doing upfront design for some difficult or large problem it rarely amounts to more than a few scribbles and sketches in a notebook, and often I don&#39;t have to consciously think about it at all.</p><h2 id="physical-design">Physical design</h2><p>So now I have to map this design to an actual machine. The graph of data tells me what I want to compute, but I still need to think about:</p><ul><li>whether to store inputs or just downstream intermediate state</li><li>whether to store intermediate state or recompute it from scratch</li><li>how to arrange data in memory and on disk</li><li>in what order to compute intermediate state / outputs</li></ul><p>I don&#39;t really have advice on how to do make these decisions. I don&#39;t know any books or courses or anything that teach this well. I know many that teach it poorly.</p><p><a href="https://www.dataorienteddesign.com/dodbook/">Data-Oriented Design</a> is not terrible, but mostly provides tools rather than explaining how/when to use them.</p><hr/><p>For learning how to write fast software the best resource I&#39;ve found is to look at projects that perform dramatically better than existing expectations (eg <a href="https://vectorized.io/blog/fast-and-safe/">redpanda</a>, <a href="https://sorbet.org/docs/talks/jvm-ls-2019">sorbet</a>, <a href="https://media.handmade-seattle.com/practical-data-oriented-design/">zig</a>) and try to understand what they do differently.</p><hr/><p>For key-value or ordered data-structures, the <a href="https://dl.acm.org/doi/pdf/10.1145/2882903.2912569">RUM hypothesis</a> is a really useful organizing principle. Basically, you care about read performance, write performance and space usage. It seems that those are inherently in tension - data-structures that gain on one axis tend to do it by losing on another.</p><p>One way to &#39;cheat&#39; it is to pick different tradeoffs for different subsets of the data. Eg store hot data in a write-optimized structure and cold data in a read-optimized structure. Or batch operations so that you can do all your writes first and then produce a read-optimized structure for later steps.</p><hr/><p>A lot of bugs result from storing different representations of the same state and then having them get out of sync with each other.</p><p>The easiest way to avoid this is to have a single source of truth and recalculate downstream state from scratch each time instead of storing it.</p><p>If that&#39;s not feasible for performance reasons then I try to make it impossible to accidentally access stale state, usually either by:</p><ul><li>forcing all writes to the upstream state go through some api that also deletes or updates the downstream state</li><li>keying the downstream state by timestamp / version number / input hash and then checking on read whether the value is stale</li></ul><p>I think there is a lot of potential upside to more systematic approaches like <a href="https://github.com/salsa-rs/salsa">salsa</a>, but I haven&#39;t tried such techniques myself in any production software yet.</p><h2 id="code">Code</h2><p>Once the structure and flow of data is figured out, writing code isn&#39;t that complicated. Write down all the things that have to happen, in the correct order. If some set of values tend to get passed around togther, group them into a struct/object. If there is a lot of repeated structure in the code try to move it into a function. If trying to reduce some particular repeated structure ends up making things more complicated, just live with the repetition.</p><p><a href="https://caseymuratori.com/blog_0015">Semantic compression</a> describes this process pretty well.</p><hr/><p>Everything I&#39;ve written so far involves thinking a lot about the details of the problem I&#39;m trying to solve. So an immediate corollary is not to try to write code for problems I&#39;m not trying to solve, because I don&#39;t know any of those details.</p><p>This is pretty much the opposite of everything I was taught early on, which was all about making solutions as general as possible. In essence I was taught that the correct approach to solving a problem was to start by replacing that problem with a harder problem for which I have less information. In hindsight, this seems unwise.</p><hr/><p>The main thing I think about in terms of code structure is how someone will be able to understand it later. This includes being able to follow the control flow when reading it, but also runtime observability and debugging.</p><p>Things that make reading difficult include indirection, callbacks, macros, exceptions and any language feature that breaks jump-to-definition.</p><hr/><p>I lean towards <a href="http://number-none.com/blow/john_carmack_on_inlined_code.html">writing longer functions</a>. I find it easier to read one long function than jump around a tree of short functions.</p><p>I&#39;m more likely to break it up if there is a lot of backwards or deeply nested control flow, since that&#39;s just as hard to read as jumping between multiple functions. Ideally I&#39;ll fit all the complicated control flow into one &#39;page&#39; of code and the rest of logic into forwards-only functions.</p><p>To make the high-level structure more skimmable I hide temporary variables inside a block where possible.</p><pre data-lang="zig"><code data-lang="zig"><span>// Need to check any pending timestamp that is before the new input frontier
</span><span>var</span><span> timestamps_to_check </span><span>=</span><span> u.</span><span>ArrayList</span><span>(Timestamp).</span><span>init</span><span>(self.allocator)</span><span>; </span><span>// &lt;-- this is used later in the function
</span><span>{
</span><span>    </span><span>var</span><span> timestamp_iter </span><span>=</span><span> timestamps.</span><span>iterator</span><span>()</span><span>; </span><span>// &lt;-- this is only used inside this block
</span><span>    </span><span>while </span><span>(timestamp_iter.</span><span>next</span><span>()) </span><span>|</span><span>timestamp_entry</span><span>| </span><span>{
</span><span>        </span><span>const</span><span> timestamp </span><span>=</span><span> timestamp_entry.key_ptr</span><span>.*</span><span>;
</span><span>        </span><span>if </span><span>(input_frontier.frontier.</span><span>causalOrder</span><span>(timestamp) </span><span>==</span><span> .gt</span><span>) {
</span><span>            </span><span>try</span><span> timestamps_to_check.</span><span>append</span><span>(</span><span>try</span><span> u.</span><span>deepClone</span><span>(timestamp</span><span>,</span><span> self.allocator))</span><span>;
</span><span>            </span><span>try</span><span> frontier_support_changes.</span><span>append</span><span>(.{ .timestamp </span><span>=</span><span> timestamp</span><span>,</span><span> .diff </span><span>= </span><span>-1 </span><span>})</span><span>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Most of the blocks get a short comment explaining what they are for, so the reader can quickly skim to understand the overall structure.</p><p>When I&#39;m working on something tricky, I write the block comments first and then fill in the code afterwards. It helps me keep track of what I&#39;m doing next.</p><hr/><p>Within a single file, you can introduce things in a logical order. If the same code is split across a lot of small files then that context is lost. So I lean towards bigger files.</p><hr/><p>I like to organize all the state in a program so that it&#39;s reachable from some root pointer.</p><p>This makes it easy for the reader to understand all the resources allocated by the program by just following the tree of types.</p><p>It also makes it easy to find any piece of state from within a debugger, or to write little debugging helpers that eg check global invariants or print queue lengths.</p><pre data-lang="zig"><code data-lang="zig"><span>pub fn </span><span>main</span><span>() </span><span>void </span><span>{
</span><span>    </span><span>var</span><span> state </span><span>=</span><span> State.</span><span>init</span><span>()</span><span>;
</span><span>    </span><span>while </span><span>(</span><span>getEvents</span><span>()) </span><span>|</span><span>events</span><span>| </span><span>{
</span><span>      </span><span>handleEvents</span><span>(</span><span>&amp;</span><span>state</span><span>,</span><span> events)</span><span>;
</span><span>      </span><span>// put debugging stuff in here
</span><span>    }
</span><span>}
</span></code></pre><p>This doesn&#39;t mean that every piece of code gets access to all the state - each component calls its subcomponents only with the parts of the state that they need, so we can still test components individually. But temporarily-inserted debugging code can reach everything.</p><hr/><p>I try to make the state tree-shaped, as much as possible.</p><p>As soon as you allow pointers to point between different components, it becomes hard to:</p><ul><li>reason about what state a function depends on or can change, because it can always find a pointer to the rest of the jungle</li><li>test or reuse components, because they require the destinations of all those pointers to exist, so you have to generate a fake version of the entire state just to run one component</li><li>print, inspect or copy the state, because there might be cycles in the pointer graph</li></ul><p>In unmanaged languages, there is the additional complication that anything that is pointed to can&#39;t be moved. This limits your options for keeping memory layouts compact and also tends to cause subtle, time-consuming bugs.</p><p>See <a href="https://floooh.github.io/2018/06/17/handles-vs-pointers.html">Handles are the better pointers</a> or <a href="https://www.dataorienteddesign.com/dodbook/">Data-Oriented Design</a> for ideas on how to avoid pointers between components.</p><hr/><p>I also try to make access to state flow down the tree.</p><p>What I mean by this is that a function that is looking at some part of the state is allowed to call other functions that look at children of that part, but is not allowed to call functions that look at siblings or the parent of that part.</p><p>The reason for this is that it&#39;s common to need to temporarily break some invariant or be in some weird intermediate state whilst inside a function. When control flow is cyclic what ends up happening is <code>foo(A)</code> calls <code>bar(B)</code> which calls <code>quux(A)</code>, but <code>quux</code> assumes some invariants on <code>A</code> that <code>foo</code> has temporarily broken.</p><p>It&#39;s not always reasonable to enforce this. For example in <a href="https://github.com/jamii/focus">focus</a> every buffer can have multiple editors which can each have multiple cursors. When a character is inserted at one cursor, the positions of all the other cursors in all the other editors need to be updated, and this has to be done before anything else accesses those cursors. There are ways to avoid doing this immediately but they all seemed more error-prone than just allowing the buffer to <a href="https://github.com/jamii/focus/blob/4f937d0d82b73f5ecbbdc17ad967a7d46e814a5a/lib/focus/buffer.zig#L360-L362">reach back across</a> to the attached editors.</p><hr/><p>Usually state comes with some invariants that the code can rely on and is expected to maintain. Explaining these invariants in comments is a start, but I prefer to also add functions that will check the invariants and report any violations, and then sprinkle debug-build-only calls to these functions at key points throughout the code.</p><p>This often shortens debugging time by pinpointing where things first went wrong, rather than where the symptoms first appeared.</p><hr/><p>I&#39;ve come to really hate callbacks.</p><p>Not immediate calls, like <code>list_of_things.map(thing =&gt; ...)</code>. Those are fine because I can tell when reading the code exactly what will happen and when.</p><p>But callbacks that will be stored somewhere and maybe run later like <code>thing.on_event(event =&gt; ...)</code> are evil. Because later when I&#39;m reading the code and I see <code>thing.on_event</code> get triggered, what could happen next? Literally anything, depending on whether any callback has been registered at any point in time anywhere in the codebase.</p><p>The callback itself has to deal with a similar problem. The callback could be run at any point in time, so it has to be safe to run regardless of what state the rest of the program is in.</p><p>(I think it&#39;s notable that a lot of frontend patterns converge towards callbacks like <code>thing.onClick(event =&gt; queue.push({clicked: thing_id}))</code>. Enqueuing an event and dealing with it later is the only action that is always safe.)</p><p>When I&#39;m debugging, I want to understand the state of the system. If the system is full of callbacks then the state of the system is always &#34;a list of opaque closures&#34;. Most runtimes won&#39;t even show you that list, so you can&#39;t even ask whether the program is waiting on some IO or has just run out of things to do.</p><p>The same arguments apply to most implementations of async/await, which turn your entire program into a list of opaque closures. Maybe we&#39;ll eventually get debuggers and profilers that understand async/await, but until then it&#39;s a significant burden.</p><p>A special case of this is frameworks whose entry point looks like <code>thing.run(event =&gt; logic(event))</code>. Not only does this have many of the problems above, it also hides all of its own state and it assumes that it is the only event loop in your program. I always prefer an api that looks like:</p><pre data-lang="zig"><code data-lang="zig"><span>var</span><span> thing </span><span>=</span><span> Thing.</span><span>init</span><span>()</span><span>;
</span><span>while </span><span>(thing.</span><span>nextEvent</span><span>()) </span><span>|</span><span>event</span><span>| </span><span>{
</span><span>  </span><span>logic</span><span>(thing</span><span>,</span><span> event)</span><span>;
</span><span>}
</span></code></pre><p><a href="https://bitsquid.blogspot.com/2011/02/managing-decoupling-part-2-polling.html">This post</a> from the bitsquid blog has various ideas for avoiding callbacks.</p><hr/><p>There is a common argument that developer productivity matters more than performance. Taken to an extreme, this argument is often used to justify implementing a system poorly and then compensating by distributing it over multiple machines and/or adding a caching layer in front. Given that distributed consistency and cache invalidation are two of the hardest problems in software engineering, this doesn&#39;t seem like a surefire way to improve developer productivity in the long run.</p><p>It&#39;s typically taken for granted that better performance must require higher complexity. But I&#39;ve often had the experience that making some component of a system faster allows the system as a whole to be simpler. For example by removing the need for horizontal scaling or downstream caching.</p><hr/><p>The typical approach for improving performance starts by just writing the software anyhow and then profiling it and trying to improve hotspots.</p><p>The problem with this approach is that whenever I encounter software that is really fast, the authors didn&#39;t get there by adding clever code to some hotspot but by carefully designing the overall architecture to make good use of the hardware. Once the architecture is set it&#39;s too late to correct the large-scale mistakes.</p><p>The way to get the architecture right is to start by using knowledge about the problem, the input data and the capabilities of the hardware to estimate a rough upper bound on performance, and then measure performance as a fraction of the theoretical maximum.</p><p>This doesn&#39;t mean that I have to try to reach this theoretical maximum, but I&#39;m at least aware whenever I make a decision that deviates from it.</p><p>For example, <a href="https://github.com/simdjson/simdjson">simdjson</a> can parse json at several GB/s. Is that fast? Who knows.</p><p>But <a href="https://arxiv.org/pdf/1902.08318.pdf">their paper</a> measures each stage of parsing in terms of cpu cycles per byte. Since we know what instructions are available on the cpu and how many cycles each takes, this gives us a rough upper bound and tells us that it&#39;s unlikely that we could eke out another order of magnitude improvement on the same hardware without multi-threading or <a href="https://simdjson.org/api/0.6.0/md_doc_ondemand.html">changing the problem</a>.</p><hr/><p>It&#39;s easier to understand how something works if the information is centralized in one place.</p><p>For example, in materialize the code that starts all the components and glues them together is all in <a href="https://github.com/MaterializeInc/materialize/blob/e1528979bc4e9d14aca7da3db804aaa2e5bff370/src/materialized/src/lib.rs#L175-L330">one function</a>. You can read these few 100 lines of code and understand which components can communicate with each other and how.</p><p>An example of getting this wrong is in my text editor, the editor component has <a href="https://github.com/jamii/focus/blob/62abfa893260001514645d40e0da560d040ddd76/lib/focus/editor.zig#L1189-L1207">several functions</a> for scrolling the viewport that are called from many different places eg if the cursor moves, or the window is resized, or the contents of the buffer are changed from elsewhere.</p><p>What happens if several different components try to scroll the viewport in a single frame? It depends on the order in which those calls happen, which in turn might depend on the order in which different windows were opened, or might be accidentally changed by reorganizing some unrelated code. This has been a constant source of bugs.</p><p>What would have worked much better is to append each request to move the scroll position to some list, and have a single place in the code that looks through the list once per frame and decides which request to prioritize.</p><hr/><p>It&#39;s really hard to make non-deterministic software correct.</p><p>Some sources of non-determinism are intrinsic to the problem (eg network communication) and the best you can do is isolate them to the edge of the system, so that at least you can deterministically replay captured histories. Timeouts in particular are best kept at the edges eg by sending regular tick events to the system, rather than by allowing some internal code to check the current time.</p><p>Other sources can often be avoided eg use seeds for random numbers (and use splittable generators so that random code reorg doesn&#39;t change the results), use deterministic building blocks for multi-threaded computations (<a href="https://arxiv.org/pdf/1901.01930.pdf">eg</a>).</p><p>It&#39;s also useful to keep IO at the edges so that it can be tested or replayed. There are a lot of different ways of doing this and I haven&#39;t tried most of them.</p></article></div>
  </body>
</html>
