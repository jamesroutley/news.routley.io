<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danluu.com/bitc-retrospective/">Original</a>
    <h1>Retrospective Thoughts on BitC</h1>
    
    <div id="readability-page-1" class="page"><div> <p><em>This is an archive of the BitC retrospective by Jonathan Shapiro that seems to have disappeared from the internet</em></p> <pre><code>Jonathan S. Shapiro shap at eros-os.org
Fri Mar 23 15:06:41 PDT 2012
</code></pre> <p>By now it will be obvious to everyone that I have stopped work on BitC. An explanation of <em>why</em> seems long overdue.</p> <p>One answer is that work on Coyotos stopped when I joined Microsoft, and the work that I am focused on <em>now</em> doesn&#39;t really require (or seem to benefit from) BitC. As we all know, there is only so much time to go around in our lives. But that alone wouldn&#39;t have stopped me entirely.</p> <p>A second answer is that BitC isn&#39;t going to work in its current form. I had hit a short list of issues that required a complete re-design of the language and type system followed by a ground-up new implementation. Experience with the first implementation suggested that this would take quite a while, and it was simply more than I could afford to take on without external support and funding. Programming language work is not easy to fund.</p> <p>But the third answer may of greatest interest, which is that I no longer believe that type classes &#34;work&#34; in their current form from the standpoint of language design. That&#39;s the only important science lesson here.</p> <p>In the large, there were four sticking points for the current design:</p> <ol> <li>The compilation model.</li> <li>The insufficiency of the current type system w.r.t. by-reference and reference types.</li> <li>The absence of some form of inheritance.</li> <li>The instance coherence problem.</li> </ol> <p>The first two issues are in my opinion solvable, thought the second requires a nearly complete re-implementation of the compiler. The last (instance coherence) does not appear to admit any general solution, and it raises conceptual concerns about the use of type classes for method overload in my mind. It&#39;s sufficiently important that I&#39;m going to deal with the first three topics here and take up the last as a separate note.</p> <p>Inheritance is something that people on the BitC list might (and sometimes have) argue about strongly. So a few brief words on the subject may be relevant.</p> <h3 id="prefacing-comments-on-objects-inheritance-and-purity">Prefacing Comments on Objects, Inheritance, and Purity</h3> <p>BitC was initially designed as an [imperative] functional language because of our focus on software verification. Specification of the typing and semantics of functional languages is an area that has a <em>lot</em> of people working on it. We (as a field) <em>kind</em> of know how to do it, and it was an area where our group at Hopkins didn&#39;t know very much when we started. Software verification is a known-hard problem, doing it over an imperative language was already a challenge, and this didn&#39;t seem like a good place for a group of novice language researchers to buck the current trends in the field. Better, it seemed, to choose our battles. We knew that there were interactions between inheritance and inference<em>,</em> and it <em>appeared</em> that type classes with clever compilation could achieve much of the same operational results. I therefore decided early <em>not</em> to include inheritance in the language.</p> <p>To me, as a programmer, the removal of inheritance and objects was a very reluctant decision, because it sacrificed any possibility of transcoding the large body of existing C++ code into a safer language. And as it turns out, you can&#39;t really remove the underlying semantic challenges from a successful systems language. A systems language <em>requires</em> some mechanism for existential encapsulation. The <em>mechanism</em> which embodies that encapsulation isn&#39;t really the issue; once you introduce that sort of encapsulation, you bring into play most of the verification issues that objects with subtyping bring into play, and once you do that, you might as well gain the benefit of objects. The remaining issue, in essence, is the modeling of the Self type, and for a range of reasons it&#39;s fairly essential to have a Self type in a systems language once you introduce encapsulation. So you end up pushed in to an object type system at some point in <em>any</em> case. With the benefit of eight years of hindsight, I can now say that this is perfectly obvious!</p> <p>I&#39;m strongly of the opinion that multiple inheritance is a mess. The argument pro or con about single inheritance still seems to me to be largely a matter of religion. Inheritance and virtual methods certainly aren&#39;t the <em>only</em> way to do encapsulation, and they may or may not be the best primitive mechanism. I have always been more interested in getting a large body of software into a safe, high-performance language than I am in innovating in this area of language design. If transcoding current code is any sort of goal, we need something very similar to inheritance.</p> <p>The last reason we left objects out of BitC initially was purity. I wanted to preserve a powerful, pure subset language - again to ease verification. The object languages that I knew about at the time were heavily stateful, and I couldn&#39;t envision how to do a non-imperative object-oriented language. Actually, I&#39;m <em>still</em> not sure I can see how to do that practically for the kinds of applications that are of interest for BitC. But as our faith in the value of verification declined, my personal willingness to remain restricted by purity for the sake of verification decayed quickly.</p> <p>The <em>other</em> argument for a pure subset language has to do with advancing concurrency, but as I really started to dig in to concurrency support in BitC, I came increasingly to the view that this approach to concurrency isn&#39;t a good match for the type of concurrent problems that people are actually trying to solve, and that the needs and uses for non-mutable state in practice are a lot more nuanced than the pure programming approach can address. Pure subprograms clearly play an important role, but they aren&#39;t enough.</p> <p>And I <em>still</em> don&#39;t believe in monads. :-)</p> <h3 id="compilation-model">Compilation Model</h3> <p>One of the objectives for BitC was to obtain acceptable performance under a conventional, static separate compilation scheme. It may be short-sighted on my part, but complex optimizations at run-time make me very nervous from the standpoint of robustness and assurance. I understand that bytecode virtual machines today do very aggressive optimizations with considerable success, but there are a number of concerns with this:</p> <ul> <li>For a robust language, we want to <em>minimize</em> the size and complexity of the code that is exempted from type checking and [eventual] verification. Run-time code is excepted in this fashion. The garbage collector taken alone is already large enough to justify assurance concerns. Adding a large and complex optimizer to the pile drags the credibility of the assurance story down immeasurably.</li> <li>Run-time optimization has very negative consequences for startup times</li> <li>especially in the context of transaction processing. Lots of hard data on this from IBM (in DB/2) and others. It is one of the reasons that &#34;Java in the database&#34; never took hold. As the frequency of process and component instantiation in a system rises, startup delays become more and more of a concern. Robust systems don&#39;t recycle subsystems.</li> <li>Run-time optimization adds a <em>huge</em> amount of space overhead to the run-time environment of the application. While the <em>code</em> of the run-time compiler can be shared, the <em>state</em> of the run-time compiler cannot, and there is quite a lot of that state.</li> <li>Run-time optimization - especially when it is done &#34;on demand&#34; - introduces both variance and unpredictability into performance numbers. For some of the applications that are of interest to me, I need &#34;steady state&#34; performance. If the code is getting optimized on the fly such that it improves by even a modest constant factor, real-time scheduling starts to be a very puzzling challenge.</li> <li>Code that is <em>produced</em> by a run-time optimizer is difficult to share across address spaces, though this probably isn&#39;t solved very well by * other* compilation approaches models either.</li> <li>If run-time optimization is present, applications will come to rely on it for performance. That is: for social reasons, &#34;optional&#34; run-time optimization tends to quickly become required.</li> </ul> <p>To be clear, I&#39;m <em>not</em> opposed to continuous compilation. I actually think it&#39;s a good idea, and I think that there are some fairly compelling use-cases. I <em>do</em> think that the run-time optimizer should be implemented in a strongly typed, safe language. I <em>also</em> think that it took an awfully long time for the hotspot technology to stabilize, and that needs to be taken as a cautionary tale. It&#39;s also likely that many of the problems/concerns that I have enumerated can be solved - but probably not * soon*. For the applications that are most important to me, the concerns about assurance are primary. So from a language design standpoint, I&#39;m delighted to exploit continuous compilation, but I don&#39;t want to design a language that <em>requires</em> continuous compilation in order to achieve reasonable baseline performance.</p> <p>The optimizer complexity issue, of course, can be raised just as seriously for conventional compilers. You are going to optimize <em>somewhere</em>. But my experience with dynamic translation tells me that it&#39;s a lot easier to do (and to reason about) one thing at a time. Once we have a high-confidence optimizer in a safe language, <em>then</em> it may make sense to talk about integrating it into the run-time in a high-confidence system. Until then, separation of concerns should be the watch-word of the day.</p> <p>Now strictly speaking, it should be said that run-time compilation actually isn&#39;t necessary for BitC, or for any other bytecode language. Run-time compilation doesn&#39;t become necessary until you combine run-time loading with compiler-abstracted representations (see below) and allow types having abstracted representation to appear in the signatures of run-time loaded libraries. Until then it is possible to maintain a proper phase separation between code generation and execution. Read on - I&#39;ll explain some of that below.</p> <p>In any case, I knew going in that strongly abstracted types would raise concerns on this issue, and I initially adopted the following view:</p> <ul> <li>Things like kernels can be whole-program compiled. This effectively eliminates the run-time optimizer requirement.</li> <li>Things like critical system components want to be statically linked anyway, so they can <em>also</em> be dealt with as whole-program compilation problems.</li> <li>For everything else, I hoped to adopt a kind of &#34;template expansion&#34; approach to run-time compilation. This wouldn&#39;t undertake the full complexity of an optimizer; it would merely extend run-time linking and loading to incorporate span and offset resolution. It&#39;s still a lot of code, but it&#39;s not horribly <em>complex</em> code, and it&#39;s the kind of thing that lends itself to rigorous - or even formal - specification.</li> </ul> <p>It took several years for me to realize that the template expansion idea wasn&#39;t going to produce acceptable baseline performance. The problem lies in the interaction between abstract types, operator overloading, and inlining.</p> <h3 id="compiler-abstracted-representations-vs-optimization">Compiler-Abstracted Representations vs. Optimization</h3> <p>Types have representations. This sometimes seems to make certain members of the PL community a bit uncomfortable. A thing to be held at arms length. Very much like a zip-lock bag full of dog poo (insert cartoon here). From the perspective of a systems person, I regret to report that where the bits are placed, how big they are, and their assemblage actually <em>does</em> matter. If you happen to be a dog owner, you&#39;ll note that the &#34;bits as dog poo&#34; analogy is holding up well here. It seems to be the lot of us systems people to wade daily through the plumbing of computational systems, so perhaps that shouldn&#39;t be a surprise. Ahem.</p> <p>In any case, the PL community set representation issues aside in order to study type issues first. I don&#39;t think that pragmatics was forgotten, but I think it&#39;s fair to say that representation issues are not a focus in current, mainstream PL research. There is even a school of thought that views representation as a fairly yucky matter that should be handled in the compiler &#34;by magic&#34;, and that imperative operations should be handled that way too. For systems code that approach doesn&#39;t work, because a lot of the representations and layouts we need to deal with are dictated to us by the hardware.</p> <p>In any case, types <em>do</em> have representations, and knowledge of those representations is utterly essential for even the simplest compiler optimizations. So we need to be a bit careful not to abstract types* too * successfully<em>,</em> lest we manage to break the compilation model.</p> <p>In C, the &#34;+&#34; operator is primitive, and the compiler can always select the appropriate opcode directly. Similarly for other &#34;core&#34; arithmetic operations. Now try a thought experiment: suppose we take every use of such core operations in a program and replace each one with a functionally equivalent procedure call to a runtime-implemented intrinsic. You only have to do this for <em>user</em> operations - addition introduced by the compiler to perform things like address arithmetic is always done on concrete types, so those can still be generated efficiently. But even though it is only done for user operations, this would clearly harm the performance of the program quite a lot. You <em>can</em> recover that performance with a run-time optimizer, but it&#39;s complicated.</p> <p>In C++, the &#34;+&#34; operator can be overloaded. But (1) the bindings for primitive types cannot be replaced, (2) we know, statically, what the bindings and representations <em>are</em> for the other types, and (3) we can control, by means of inlining, which of those operations entail a procedure call at run time. I&#39;m not trying to suggest that we want to be forced to control that manually. The key point is that the compiler has enough visibility into the implementation of the operation that it is possible to inline the primitive operators (and many others) at static compile time.</p> <p>Why is this possible in C++, but not in BitC?</p> <p>In C++, the instantiation of an abstract type (a template) occurs in an environment where complete knowledge of the representations involved is visible to the compiler. That information may not all be in scope to the programmer, but the compiler can chase across the scopes, find all of the pieces, assemble them together, and understand their shapes. This is what induces the &#34;explicit instantiation&#34; model of C++. It also causes a lot of &#34;internal&#34; type declarations and implementation code to migrate into header files, which tends to constrain the use of templates and increase the number of header file lines processed for each compilation unit - we measured this at one point on a very early (pre templates) C++ product and found that we processed more than 150 header lines for each &#34;source&#34; line. The ratio has grown since then by at least a factor of ten, and (because of templates) quite likely 20.</p> <p>It&#39;s all rather a pain in the ass, but it&#39;s what makes static-compile-time template expansion possible. From the <em>compiler</em> perspective, the types involved (and more importantly, the representations) aren&#39;t abstracted at all. In BitC, <em>both</em> of these things <em>are</em> abstracted at static compile time. It isn&#39;t until link time that all of the representations are in hand.</p> <p>Now as I said above, we can imagine extending the linkage model to deal with this. All of that header file information is supplied to deal with * representation* issues, not type checking. Representation, in the end, comes down to sizes, alignments, and offsets. Even if we don&#39;t know the concrete values, we <em>do</em> know that all of those are compile-time constants, and that the results we need to compute at compile time are entirely formed by sums and multiples of these constants. We could imagine dealing with these as <em>opaque</em> constants at static compile time, and filling in the blanks at link time. Which is more or less what I had in mind by link-time template expansion. Conceptually: leave all the offsets and sizes &#34;blank&#34;, and rely on the linker to fill them in, much in the way that it handles relocation.</p> <p>The problem with this approach is that it removes key information that is needed for optimization and registerization, and it doesn&#39;t support inlining. In BitC, we can <em>and do</em> extend this kind of instantiation all the way down to the primitive operators! And perhaps more importantly, to primitive accessors and mutators. The reason is that we want to be able to write expressions like &#34;a + b&#34; and say &#34;that expression is well-typed provided there is an appropriate resolution for +:(&#39;a,&#39;a)-&gt;&#39;a&#34;. Which is a fine way to <em>type</em> the operation, but it leaves the representation of &#39;a fully abstracted. Which means that we cannot see when they are primitive types. Which means that we are <em>exactly</em> (or all too often, in any case) left in the position of generating <em>all</em> user-originated &#34;+&#34; operations as procedure calls. Now surprisingly, that&#39;s actually not the end of the world. We can imagine inventing some form of &#34;high-level assembler&#34; that our static code generator knows how to translate into machine code. If the static code generator does this, the run-time loader can be handed responsibility for emitting procedure calls, and can substitute intrinsic calls at appropriate points. Which would cause us to lose code sharing, but that might be tolerable on non-embedded targets.</p> <p>Unfortunately, this kind of high-level assembler has some fairly nasty implications for optimization: First, we no longer have any idea what the * cost* of the &#34;+&#34; operator is for optimization purposes. We don&#39;t know how many cycles that particular use of + will take, but more importantly, we don&#39;t know how many bytes of code it will emit. And without that information there is a very long list of optimization decisions that we can no longer make at static compile time. Second, we no longer have enough information at static code generation time to perform a long list of <em>basic</em> register and storage optimizations, because we don&#39;t know which procedure calls are actually going to use registers.</p> <p>That creaking and groaning noise that you are hearing is the run-time code generator gaining weight and losing reliability as it grows. While the impact of this mechanism actually wouldn&#39;t be as bad as I am sketching - because a lot of user types <em>aren&#39;t</em> abstract - the <em>complexity</em> of the mechanism really is as bad as I am proposing. In effect we end up deferring code generation and optimization to link time. That&#39;s an idea that goes back (at least) to David Wall&#39;s work on link time register optimization in the mid-1980s. It&#39;s been explored in many variants since then. It&#39;s a compelling idea, but it has pros and cons.</p> <p>What is going on here is that types in BitC are <em>too</em> successfully abstracted for static compilation. The result is a rather <em>large</em> bag of poo, so perhaps the PL people are on to something.:-)</p> <h3 id="two-solutions">Two Solutions</h3> <ul> <li>The most obvious solution - adopted by C++ - is to redesign the language so that representation issues are not hidden from the compiler. That&#39;s actually a solution that is worth considering. The problem in C++ isn&#39;t so much the number of header file lines per source line as it is the fact that the C preprocessor requires us to process those lines <em>de novo</em> for each compilation unit. BitC lacks (intentionally) anything comparable to the C preprocessor.</li> <li>The other possibility is to shift to what might be labeled &#34;install time compilation&#34;. Ship some form of byte code, and do a static compilation at install time. This gets you back all of the code sharing and optimization that you might reasonably have expected from the classical compilation approach, it opens up some interesting design point options from a systems perspective, and (with care) it can be retrofitted to existing systems. There are platforms today (notably cell phones) where we basically do this already.</li> </ul> <p>The design point that you don&#39;t want to cross here is dynamic <em>loading</em> where the loaded interface carries a type with an abstracted representation. At that point you are effectively committing yourself to run-time code generation<em>,</em> though I do have some ideas on how to mitigate that.</p> <h3 id="conclusion-concerning-compilation-model">Conclusion Concerning Compilation Model</h3> <p><strong>If static, separate compilation is a requirement, it becomes necessary for the compiler to see into the source code across module boundaries whenever an abstract type is used. That is: any procedure having abstract type must have an exposed source-level implementation.</strong></p> <p><strong>The practical alternative is a high-level intermediate form coupled with install-time or run-time code generation. That is certainly feasible, but it&#39;s more that I felt I could undertake.</strong></p> <p>That&#39;s all manageable and doable. Unfortunately, it isn&#39;t the path we had taken on, so it basically meant starting over.</p> <h3 id="insufficiency-of-the-type-system">Insufficiency of the Type System</h3> <p>At a certain point we had enough of BitC working to start building library code. It may not surprise you that the first thing we set out to do in the library was IO. We found that we couldn&#39;t handle typed input within the type system. Why not?</p> <p>Even if you are prepared to do dynamic allocation within the IO library, there is a level of abstraction at which you need to implement an operation that amounts to &#34;inputStream.read(someObject: ByRef mutable &#39;a)&#34; There are a couple of variations on this, but the point is that you want the ability at some point to move the incoming bytes into previously allocated storage. So far so good.</p> <p>Unfortunately, in an effort to limit creeping featurism in the type system, I had declared (unwisely, as it turned out) that the only place we needed to deal with ByRef types was at parameters. Swaroop took this statement a bit more literally than I intended. He noticed that if this is <em>really</em> the only place where ByRef needs to be handled, then you can internally treat &#34;ByRef &#39;a&#34; as &#39;a, merely keeping a marker on the parameter&#39;s identifier record to indicate that an extra dereference is required at code generation time. Which is actually quite clever, except that it doesn&#39;t extend well to signature matching between type classes and their instances. Since the argument type for <em>read</em> is <em>ByRef &#39;a</em>, InputStream is such a type class.</p> <p>So now we were faced with a couple of issues. The first was that we needed to make ByRef &#39;a a first-class type within the compiler so that we could unify it, and the second was that we needed to deal with the implicit coercion issues that this would entail. That is: conversion back and forth between ByRef &#39;a and &#39;a at copy boundaries. The coercion part wasn&#39;t so bad; ByRef is never inferred, and the type coercions associated with ByRef happen in exactly the same places that const/mutable coercions happen. We already had a cleanly isolated place in the type checker to deal with that.</p> <p>But even if ByRef isn&#39;t inferred, it can propagate through the code by unification. And <em>that</em> causes safety violations! The fact that ByRef was syntactically restricted to appear only at parameters had the (intentional) consequence of ensuring that safety restrictions associated with the lifespan of references into the stack were honored - that was why I had originally imposed the restriction that ByRef could appear only at parameters. Once the ByRef type can unify, the syntactic restriction no longer guarantees the enforcement of the lifespan restriction. To see why, consider what happens in:</p> <pre><code>  define byrefID(x:ByRef &#39;a) { return x; }
</code></pre> <p>Something that is <em>supposed</em> to be a downward-only reference ends up getting returned up the stack. Swaroop&#39;s solution was clever, in part, because it silently prevented this propagation problem. In some sense, his implementation doesn&#39;t really treat ByRef as a type, so it can&#39;t propagate. But *because *he didn&#39;t treat it as a type, we also couldn&#39;t do the necessary matching check between instances and type classes.</p> <p>It turns out that being able to do this is <em>useful</em>. The essential requirement of an abstract mutable &#34;property&#34; (in the C# sense) is that we have the ability within the language to construct a function that returns the <em>location</em> of the thing to be mutated. That location will often be on the stack, so returning the location is <em>exactly</em> like the example above. The &#34;ByRef only at parameters&#34; restriction is actually very conservative, and we knew that it was preventing certain kinds of things that we eventually wanted to do. We had a vague notion that we would come back and fix that at a later time by introducing region types.</p> <p>As it turned out, &#34;later&#34; had to be &#34;now&#34;, because region types are the right way to re-instate lifetime safety when ByRef types become first class. But <em>adding</em> region types presented two problems (which is why we had hoped to defer them):</p> <ul> <li>Adding region types meant rewriting the type checker and re-verifying the soundness and completeness of the inference algorithm, <em>and</em></li> <li>It wasn&#39;t just a re-write. Regions introduce subtyping. Subtyping and polymorphism don&#39;t get along, so we would need to go back and do a lot of study.</li> </ul> <p>Region polymorphism with region subtyping had certainly been done before, but we were looking at subtyping in another case too (below). That was pushing us toward a kinding system and a different type system.</p> <p>So to fix the ByRef problem, we very nearly needed to re-design both the type system and the compiler from scratch. Given the accumulation of cruft in the compiler, that might have been a good thing in any case, but Swaroop was now full-time at Microsoft, and I didn&#39;t have the time or the resources to tackle this by myself.</p> <h3 id="conclusion-concerning-the-type-system">Conclusion Concerning the Type System</h3> <p><strong>In retrospect, it&#39;s hard to imagine a strongly typed imperative language that doesn&#39;t type locations in a first-class way. If the language simultaneously supports explicit unboxing, it is effectively forced to deal with location lifespan and escape issues, which makes memory region typing of some form almost unavoidable.</strong></p> <p><strong>For this reason alone, even if for no other, the type system of an imperative language with unboxing must incorporate some form of subtyping. To ensure termination, this places some constraints on the use of type inference. On the bright side, once you introduce subtyping you are able to do quite a number of useful things in the language that are hard to do without it.</strong></p> <h3 id="inheritance-and-encapsulation">Inheritance and Encapsulation</h3> <p>Our first run-in with inheritance actually showed up in the compiler itself. In spite of our best efforts, the C++ implementation of the BitC compiler had not entirely avoided inheritance, so it didn&#39;t have a direct translation into BitC. And even if we changed the code of the compiler, there are a large number of third-party libraries that we would like to be able to transcode. A good many of those rely on [single] inheritance. Without having at least some form of interface (type) inheritance, We can&#39;t really even do a good job interfacing to those libraries as foreign objects.</p> <p>The compiler aside, we also needed a mechanism for encapsulation. I had been playing with &#34;capsules&#34;, but it soon became clear that capsules were really a degenerate form of subclassing, and that trying to duck that issue wasn&#39;t going to get me anywhere.</p> <p>I could nearly imagine getting what I needed by adding &#34;ThisType&#34; and inherited <em>interfaces</em>. But the combination of those two features introduces subtyping. In fact, the combination is equivalent (from a type system perspective) to single-inheritance subclassing.</p> <p>And the more I stared at interfaces, the more I started to ask myself why an interface wasn&#39;t just a type class. <em>That</em> brought me up against the instance coherence problem from a new direction, which was already making my head hurt. It also brought me to the realization that Interfaces work, in part, because they are always parameterized over a single type (the ThisType) - once you know that one, the bindings for all of the others are determined by type constructors or by explicit specification.</p> <p>And introducing SelfType was an even bigger issue than introducing subtypes. It means moving out of System F&lt;: entirely, and into the object type system of Cardelli <em>et al</em>. That wasn&#39;t just a matter of re-implementing the type checker to support a variant of the type system we already had. It meant re-formalizing the type system entirely, and learning how to think in a different model.</p> <p>Doable, but time not within the framework or the compiler that we had built. At this point, I decided that I needed to start over. We had learned a lot from the various parts of the BitC effort, but sometimes you have to take a step back before you can take more steps forward.</p> <h3 id="instance-coherence-and-operator-overloading">Instance Coherence and Operator Overloading</h3> <p>BitC largely borrows its type classes from Haskell. Type classes aren&#39;t just a basis for type qualifiers; they provide the mechanism for *ad hoc*polymorphism. A feature which, language purists notwithstanding, real languages actually do need.</p> <p>The problem is that there can be multiple type class instances for a given type class at a given type. So it is possible to end up with a function like:</p> <pre><code>define f(x : &#39;x) {
  ...
  a:int32 + b  // typing fully resolved at static compile time
  return x + x  // typing not resolvable until instantiation
}
</code></pre> <p>Problem: we don&#39;t know which instance of &#34;+&#34; to use when &#39;x instantiates to <em>int32</em>. In order for &#34;+&#34; to be meaningful in a+b, we need a static-compile-time resolution for +:(int32, int32)-&gt;int32. And we get that from Arith(int32). So far so good. But if &#39;x is instantiated to <em>int32</em>, we will get a type class instance supplied by the caller. The problem is that there is no way to guarantee that this is the <em>same</em> instance of Arith(int32) that we saw before.</p> <p>The solution in Haskell is to impose the <em>ad hoc</em> rule that you can only instantiate a type class once for each unique type tuple in a given application. This is similar to what is done in C++: you can only have one overload of a given global operator at a particular type. If there is more than one overload at that type, you get a link-time failure. This restriction is tolerable in C++ largely because operator overloading is so limited:</p> <ol> <li>The set of overloadable operators is small and non-extensible.</li> <li>Most of them can be handled satisfactorily as methods, which makes their resolution unambiguous.</li> <li>Most of the ones that <em>can&#39;t</em> be handled as methods are arithmetic operations, and there are practical limits to how much people want to extend those.</li> <li>The remaining highly overloaded global operators are associated with I/O. These <em>could</em> be methods in a suitably polymorphic language.</li> </ol> <p>In languages (like BitC) that enable richer use of operator overloading, it seems unlikely that these properties would suffice.</p> <p>But in Haskell and BitC, overloading is extended to <em>type properties</em> as well. For example, there is a type class &#34;Ord &#39;a&#34;, which states whether a type &#39;a admits an ordering. Problem: most types that admit ordering admit more than one! The fact that we know an ordering <em>exists</em> really isn&#39;t enough to tell us which ordering to <em>use</em>. And we can&#39;t introduce <em>two</em> orderings for &#39;a in Haskell or BitC without creating an instance coherence problem. And in the end, the instance coherence problem exists because the language design performs method resolution in what amounts to a non-scoped way.</p> <p>But if nothing else, you can hopefully see that the heavier use of overloading in BitC and Haskell places much higher pressure on the &#34;single instance&#34; rule. Enough so, in my opinion, to make that rule untenable. And coming from the capability world, I have a strong allergy to things that smell like ambient authority.</p> <p>Now we can get past this issue, up to a point, by imposing an arbitrary restriction on where (which compilation unit) an instance can legally be defined. But as with the &#34;excessively abstract types&#34; issue, we seemed to keep tripping on type class issues. There are other problems as well when multi-variable type classes get into the picture.</p> <p>At the end of the day, type classes just don&#39;t seem to work out very well as a mechanism for overload resolution without some other form of support.</p> <p>A second problem with type classes is that you can&#39;t resolve operators at static compile time. And if instances are explicitly named, references to instances have a way of turning into first-class values. At that point the operator reference can no longer be statically resolved at all, and we have effectively re-invented operator methods!</p> <h3 id="conclusion-about-type-classes-and-overloading">Conclusion about Type Classes and Overloading:</h3> <p><strong>The type class notion (more precisely: qualified types) is seductive, but absent a reasonable approach for instance coherence and lexical resolution it provides an unsatisfactory basis for operator overloading. There is a disturbingly close relationship between type class instances and object instances that needs further exploration by the PL community. The important distinction may be pragmatic rather than conceptual: type class instances are compile-time constants while object instances are run-time values. This has no major consequences for typing, but it leads to significant differences w.r.t. naming, binding, and [human] conceptualization.</strong></p> <p><strong>There are unresolved formal issues that remain with multi-parameter type classes. Many of these appear to have natural practical solutions in a polymorphic object type system, but concerns of implementation motivate kinding distinctions between boxed and unboxed types that are fairly unsatisfactory.</strong></p> <h3 id="wrapping-up">Wrapping Up</h3> <p>The current outcome is <em>extremely</em> frustrating. While the blind spots here were real, we were driven by the requirements of the academic research community to spend nearly three years finding a way to do complete inference over mutability. That was an enormous effort, and it delayed our recognition that we were sitting on the wrong kind of underlying type system entirely. While I continue to think that there is some value in mutability inference, I think it&#39;s a shame that a fairly insignificant wart in the original inference mechanism managed to prevent larger-scale success in the overall project for what amount to <em>political</em> reasons. If not for that distraction, I think we would probably have learned enough about the I/O and the instance coherency issues to have moved to a different type system while we still had a group to do it with, and we would have a working and useful language today.</p> <p>The distractions of academia aside, it is fair to ask why we weren&#39;t building small &#34;concept test&#34; programs as a sanity check of our design. There are a number answers, none very satisfactory:</p> <ul> <li>Research languages can adopt simplifications on primitive types (notably integers) that systems languages cannot. That&#39;s what pushed us into type classes in the first place, we new that polymorphism over unboxed types hadn&#39;t seen a lot of attention in the literature, and we knew that mutability inference had never been done. We had limited manpower, so we chose to focus on those issues first.</li> <li>We knew that parametric polymorphism and subtyping didn&#39;t get along, so we wanted to avoid that combination. Unfortunately, we avoided subtypes too well for too long, and they turned out to be something unavoidable.</li> <li>For the first several years, we were very concerned with software verification, which <em>also</em> drove us strongly away from object-based languages and subtyping. That blinded us.</li> <li>Coming to language design as &#34;systems&#34; people, working in a department that lacked deep expertise and interest in type systems, there was an enormous amount of subject matter that we needed to learn. Some of the reasons for our failure are &#34;obvious&#34; to people in the PL community, but others are not. Our desire for a &#34;systems&#34; language drove us to explore the space in a different way and with different priorities than are common in the PL community.</li> </ul> <p>I think we did make some interesting contributions. We now know how to do (that is: to implement) polymorphism over unboxed types with significant code sharing, and we understand how to deal with inferred mutability. Both of those are going to be very useful down the road. We have also learned a great deal about advanced type systems.</p> <p>In any case, BitC in its current form clearly needs to be set aside and re-worked. I have a fairly clear notion about how I would approach <em>continuing</em> this work, but that&#39;s going to have to wait until someone is willing to pay for all this.</p> </div></div>
  </body>
</html>
