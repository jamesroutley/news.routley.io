<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://publish.obsidian.md/aixplore/Practical&#43;Applications/dgx-lab-benchmarks-vs-reality-day-4">Original</a>
    <h1>Nvidia DGX Spark: When Benchmark Numbers Meet Production Reality</h1>
    
    <div id="readability-page-1" class="page"><p>
# NVIDIA DGX Spark: When Benchmark Numbers Meet Production Reality

**A 6-Day Deep Dive into Real-World ML Performance**

---

NVIDIA recently published [benchmarks showcasing the DGX Spark](https://developer.nvidia.com/blog/how-nvidia-dgx-sparks-performance-enables-intensive-ai-tasks/): 82,739 tokens/second for fine-tuning, sub-1% accuracy degradation with FP4, and impressive inference throughput. After spending 6+ days running intensive ML workloads on a DGX Spark—training multiple models from scratch, fine-tuning with LoRA, and conducting extensive inference benchmarks—I can tell you the real story.

**The short version:** NVIDIA&#39;s numbers are technically accurate. But they don&#39;t tell you about the GPU inference crashes, memory fragmentation that requires hard reboots, or the 15 hours I spent debugging &#34;training failures&#34; that turned out to be inference bugs.

This is the post I wish I&#39;d read before diving in.

## What NVIDIA Showed Us

NVIDIA&#39;s blog highlights some impressive numbers:

**Fine-Tuning Performance:**
- Llama 3.2 3B: **82,739 tokens/sec** (full fine-tuning, BF16)
- Llama 3.1 8B: **53,657 tokens/sec** (LoRA, BF16)
- Llama 3.3 70B: **5,079 tokens/sec** (QLoRA, FP4)

**Inference Performance:**
- Qwen3 14B: **5,928 tokens/sec** prompt processing, 22.71 tokens/sec generation
- GPT-OSS-20B: **82.74 tokens/sec** generation

**Key Claims:**
- 1 petaflop of FP4 compute
- Less than 1% accuracy degradation with FP4
- 273 GB/sec memory bandwidth
- Support for 128GB+ models locally

Impressive on paper. Let&#39;s see how it holds up.

## My Testing Environment

Before we dive into results, here&#39;s what I was working with:

**Hardware:**
- DGX Spark (ARM64 architecture)
- GB10 GPU (Blackwell generation)
- Driver 580.95.05
- CUDA 13.0
- Ubuntu 24.04.3 LTS

**Workloads:**
1. **Inference Benchmark:** Phi-3.5-mini-instruct (3.8B params) via Ollama and llama.cpp
2. **Fine-Tuning:** 7 LoRA experiments on Gemma-3-4b-it for medical Q&amp;A (10,000 examples from PubMedQA)
3. **Training:** NanoChat project (125M param models from scratch on FineWeb)

**Duration:** 6+ consecutive days of ML work

## The Results: What Matches

### ✅ Training Performance is Real (When It Works)

My Gemma-3-4b-it LoRA fine-tuning achieved speeds comparable to NVIDIA&#39;s benchmarks. While I didn&#39;t measure exact tokens/second (focused on loss and accuracy), the training completed in ~10-12 hours for 3 epochs on 10,000 examples with batch size 4—right in line with expectations based on NVIDIA&#39;s Llama 3.1 8B numbers.

**Training configuration:**
```python
- Base Model: Gemma-3-4b-it (4B parameters)
- Method: LoRA (rank 16, alpha 32)
- Precision: BF16 mixed precision
- Batch Size: 4
- Learning Rate: 2e-5
- Epochs: 3
- Dataset: 10,000 medical Q&amp;A pairs
```

**Results across 7 experiments:**
- Experiment 1-5 (baseline): **70% accuracy**
- Experiment 7 (optimized): **82% accuracy**
- Experiment 8 (SFTTrainer): **84% accuracy**

All models trained successfully with smooth loss curves. Training throughput was excellent—no complaints there.

**Verdict: ✅ NVIDIA&#39;s training performance claims are accurate.**

### ✅ Inference Speed Scales as Expected

I benchmarked Phi-3.5-mini-instruct (3.8B params, Q4_K_M quantization) via Ollama:

```
Prompt Type          Tokens/Second
-----------------------------------------
Short (20 tokens)    83.25
Medium (34 tokens)   79.74
Long (113 tokens)    78.47
-----------------------------------------
Average              ~80 tokens/sec
```

NVIDIA showed 22.71 tokens/sec for Qwen3 14B—a model nearly 4x larger than mine. My 3.8B model running at 80 tokens/sec is roughly 3.6x faster, which tracks with the size difference.

**Verdict: ✅ Inference speed scales proportionally with model size.**

### ✅ 4-Bit Quantization Works

NVIDIA claims &#34;less than 1% accuracy degradation&#34; with FP4. I used Q4_K_M (4-bit) quantization extensively via Ollama, and the model quality was excellent—coherent, contextually appropriate responses with no noticeable degradation.

**Verdict: ✅ 4-bit quantization is production-viable.**

## The Reality: What They Didn&#39;t Tell You

### ❌ GPU Inference is Fundamentally Broken

Here&#39;s where things get interesting.

After training my first model (Experiment 1), I loaded it for evaluation:

```python
model = AutoModelForCausalLM.from_pretrained(
    &#34;./models/exp-001/final&#34;,
    torch_dtype=torch.float16,
    device_map={&#34;&#34;: 0}  # GPU
)

# Generate text
output = model.generate(...)
```

**Result:** Empty responses. PAD tokens. Sometimes inf/nan errors crashing CUDA.

I assumed my training failed. I retrained with different hyperparameters (Experiment 2). Same result. Experiment 3, 4, 5—all &#34;failed.&#34; I spent 15+ hours debugging my training code, convinced I was doing something wrong.

Then I tried this:

```python
model = AutoModelForCausalLM.from_pretrained(
    &#34;./models/exp-001/final&#34;,
    torch_dtype=torch.float32,  # CPU uses FP32
    device_map=&#39;cpu&#39;  # CPU instead of GPU
)

# Generate text
output = model.generate(...)
```

**Result:** Perfect. Coherent, relevant medical responses. The model worked beautifully.

**All 7 experiments had trained successfully.** The training loss decreased smoothly. The models learned. But GPU inference was completely broken.

### The Pattern

- ✅ **Training on GPU:** Works perfectly (BF16)
- ✅ **Inference on CPU:** Works perfectly (FP32)
- ❌ **Inference on GPU:** Produces inf/nan, empty responses, or crashes
- ✅ **Inference via Ollama:** Works (CPU-optimized backend)

This is a **production blocker** for many use cases. NVIDIA&#39;s blog showcases GPU inference benchmarks, but standard PyTorch users can&#39;t replicate them on this hardware.

### ❌ Memory Fragmentation Causes System Hangs

During Experiment 6, my training script was humming along beautifully. Loss decreasing, checkpoints saving, everything looked perfect. Then at 88% complete (7.5 hours in), the system froze. Hard. No response to keyboard, SSH connection dead, GPU stuck.

Hard reboot required. Progress lost.

**The issue:** GPU memory fragmentation during long-running training causes system-level instability.

**Required mitigations for all subsequent training:**

```python
# Critical: Clear GPU cache regularly
if step % 50 == 0:
    torch.cuda.empty_cache()

# Critical: Limit training duration
if time.time() - start_time &gt; 2.5 * 3600:  # 2.5 hours
    logging.info(&#34;Approaching safety limit - saving and exiting&#34;)
    save_checkpoint(model, optimizer, step)
    break

# Critical: Checkpoint frequently (not too frequently)
if step % 200 == 0:  # Not 100 - creates more fragmentation
    save_checkpoint(model, optimizer, step)

# Monitor GPU memory
if step % 100 == 0:
    allocated = torch.cuda.memory_allocated() / 1e9
    if allocated &gt; 75:  # &gt;75GB on 128GB system
        logging.warning(&#34;High GPU memory - fragmentation risk&#34;)
```

After implementing these mitigations, I successfully trained Experiments 7 and 8 to completion. But the limitation is real: **maximum 2-3 hour training sessions** before restarting.

NVIDIA&#39;s benchmarks don&#39;t mention this constraint. Their tests were likely short-duration runs that didn&#39;t expose the fragmentation issue.

### ❌ llama.cpp Direct: Also Broken

I benchmarked llama.cpp directly (without Ollama&#39;s wrapper):

```bash
./llama-cli \
  --model Phi-3.5-mini-instruct-Q4_K_M.gguf \
  --prompt &#34;Explain what a neural network is in one sentence.&#34; \
  --n-predict 512
```

**Result:** Empty responses on all test prompts. Zero tokens generated.

The same GGUF model worked perfectly through Ollama, so this appears to be an issue with direct llama.cpp invocation on ARM64 + GB10.

## Root Cause: The ARM64 + Blackwell Triple Whammy

Why do these issues exist? Three factors converging:

### 1. ARM64 Architecture
- Not x86_64 (limited ML ecosystem maturity)
- No PyTorch wheels for ARM64+CUDA (must use Docker)
- Most ML tools optimized for x86

### 2. Blackwell GB10 GPU
- Newest GPU generation (sm_121 compute capability)
- Limited real-world testing vs established datacenter GPUs
- Driver maturity: 6-12 months behind older architectures

### 3. CUDA 13.0
- Latest CUDA release (~6 months old)
- ARM64 + CUDA support is brand new
- Requires PyTorch 2.5+ (cutting edge)

**The fundamental problem:**
```
ARM64 + Blackwell + CUDA 13.0 = Bleeding Edge
↓
Limited production testing
↓
Edge cases in numerical precision (inference)
↓
Memory management issues (training)
```

NVIDIA&#39;s benchmarks likely use:
- Optimized inference engines (TRT-LLM, not standard PyTorch)
- Short-duration controlled tests
- Configurations that avoid the fragmentation trigger
- Possibly x86_64 systems (blog doesn&#39;t specify architecture)

## Precision Deep Dive

Here&#39;s what actually works vs. what&#39;s broken:

| Use Case | Precision | Device | Status | Performance |
|----------|-----------|--------|--------|-------------|
| Training | BF16 | GPU | ✅ Works | Excellent |
| Training | FP32 | GPU | ✅ Works | Slower but stable |
| Inference | FP16/BF16 | GPU | ❌ Broken | inf/nan errors |
| Inference | FP32 | CPU | ✅ Works | Slower, reliable |
| Inference | Q4_K_M | CPU (Ollama) | ✅ Works | 80 tok/sec |
| Inference | Q4_K_M | GPU (llama.cpp) | ❌ Broken | Empty responses |

The pattern is clear: **Training works, GPU inference doesn&#39;t.**

## What This Means for Production

### What&#39;s Production-Ready

✅ **Training with workarounds:**
```python
# Implement these in all training scripts:
1. torch.cuda.empty_cache() every 50 steps
2. Maximum 2-3 hour sessions with checkpointing
3. Monitor GPU memory continuously
4. Test inference on CPU, not GPU

# Result: Successfully trained 7+ models
```

✅ **Inference via Ollama:**
```bash
# Stable, reliable, good performance
ollama run phi3.5:3.8b-mini-instruct-q4_K_M

# Results: 80 tokens/sec, production-ready
```

✅ **CPU inference for evaluation:**
```python
# Slow but 100% reliable
model = AutoModelForCausalLM.from_pretrained(
    model_path,
    torch_dtype=torch.float32,
    device_map=&#39;cpu&#39;
)

# Result: Perfect for batch evaluation, not real-time serving
```

### What&#39;s Not Production-Ready

❌ **GPU inference (PyTorch/Transformers):**
- Numerical instability produces bad outputs
- Not viable for real-time serving
- **Wait for driver/CUDA updates**

❌ **Multi-hour unattended training:**
- Memory fragmentation risk after 3-8 hours
- Requires babysitting or session limits
- **Train in chunks with checkpointing**

❌ **llama.cpp direct (this hardware):**
- Empty responses on ARM64 + GB10
- **Use Ollama wrapper instead**

## My Actual Numbers vs. NVIDIA&#39;s Claims

| Metric | NVIDIA | My Experience | Match? |
|--------|---------|---------------|--------|
| Training speed | 53,657-82,739 tok/sec | Comparable relative speed | ✅ |
| Inference speed | 22-82 tok/sec | 80 tok/sec (via Ollama) | ✅ |
| 4-bit quality | &lt;1% degradation | No noticeable degradation | ✅ |
| Training precision | BF16 | BF16 works perfectly | ✅ |
| **GPU inference** | **Implied working** | **Completely broken** | ❌ |
| **Training stability** | **Not mentioned** | **2-3 hour limit** | ❌ |
| **Memory management** | **Not mentioned** | **Manual cache clearing** | ❌ |

## Recommendations

### If You&#39;re Using DGX Spark

**DO:**
- Implement GPU cache clearing (every 50 steps)
- Limit training sessions to 2-3 hours
- Checkpoint frequently (every 200+ steps)
- Test all inference on CPU first
- Use Ollama for production inference
- Monitor NVIDIA driver updates

**DON&#39;T:**
- Trust GPU inference (yet)
- Plan 8+ hour unattended training
- Skip the workarounds
- Assume benchmarks = your experience

### If You&#39;re Considering DGX Spark

**It&#39;s worth it if:**
- You&#39;re an experienced ML engineer
- You need local training capabilities
- You can implement stability workarounds
- CPU or Ollama inference meets your needs
- You&#39;re willing to monitor driver updates

**Look elsewhere if:**
- You need plug-and-play GPU inference
- You expect production-ready out-of-box
- You need long unattended training runs
- You don&#39;t have time for workarounds

## The Silver Lining

Despite the issues, I successfully:

✅ Fine-tuned 7 models with 70-84% accuracy on medical Q&amp;A
✅ Achieved 80 tokens/sec inference via Ollama
✅ Validated NVIDIA&#39;s training performance claims
✅ Built a production-ready medical chatbot (CPU inference)
✅ Documented all workarounds for future users

**The hardware is powerful.** But it requires expert-level knowledge to navigate current limitations.

## Lessons Learned

### 1. Always Test Inference on Multiple Platforms

When GPU inference failed, I assumed training failed. Testing on CPU revealed the truth. **Multi-platform validation is mandatory** on bleeding-edge hardware.

### 2. Hardware Issues Masquerade as Software Bugs

I spent 15+ hours debugging my &#34;broken&#34; training code. The training was fine—the hardware inference was broken. **Check training loss curves first** before assuming your code is wrong.

### 3. Benchmark Numbers Are True But Incomplete

NVIDIA&#39;s numbers are technically accurate for their test conditions. But they don&#39;t reveal stability constraints, inference issues, or workarounds needed for production. **Read between the lines.**

### 4. Cutting Edge ≠ Production Ready

ARM64 + Blackwell + CUDA 13.0 is the bleeding edge. Bleeding edge means bugs, limitations, and workarounds. **Wait 6-12 months if you need stability.**

### 5. Document Everything

My comprehensive documentation of these issues saved immense debugging time across experiments. **The next person using this system will save 15-20 hours** by reading my notes.

## What I&#39;d Tell NVIDIA

If NVIDIA engineers are reading this (and I hope they are), here&#39;s constructive feedback:

**Document these in your communications:**

1. **Stability constraints:**
   - Training session duration limits
   - Memory management best practices
   - GPU cache clearing requirements

2. **Inference limitations:**
   - Which backends work (TRT-LLM vs PyTorch)
   - Known issues on ARM64 + Blackwell
   - CPU fallback recommendations

3. **Precision compatibility:**
   - What works for training vs inference
   - Differences between x86 and ARM64
   - When numerical instability occurs

4. **Real-world examples:**
   - Long-running training strategies
   - Production inference patterns
   - Monitoring and mitigation tactics

Your benchmarks are accurate. But they&#39;d be more valuable with context about edge cases and limitations.

## Conclusion: Powerful But Not Magic

The NVIDIA DGX Spark delivers on raw performance—when you work within its constraints. Training throughput matches the benchmarks. Inference speed is excellent (via Ollama). The hardware potential is real.

But it&#39;s not plug-and-play. GPU inference is broken for standard PyTorch workflows. Memory fragmentation limits training sessions. You need expertise to navigate the limitations.

**NVIDIA&#39;s benchmarks are technically true.** They&#39;re just not the whole truth.

For ML engineers willing to implement workarounds, DGX Spark is a powerful tool. For teams expecting production-ready performance out-of-box, the maturity isn&#39;t there yet—especially on ARM64.

**My verdict:** Cautiously recommended for experts. Wait 6-12 months if you need stability.

---

## Appendix: Full Experimental Data

### Inference Benchmark Details

**Test Model:** Phi-3.5-mini-instruct (3.8B parameters)
**Quantization:** Q4_K_M (4-bit)
**Engine:** Ollama 0.3.9 (llama.cpp backend)

**Configuration:**
```json
{
  &#34;temperature&#34;: 0.7,
  &#34;top_p&#34;: 0.9,
  &#34;max_tokens&#34;: 512,
  &#34;repeat_penalty&#34;: 1.1,
  &#34;num_runs_per_prompt&#34;: 3
}
```

**Results by Prompt Category:**

| Category | Prompt Length | Avg Response Length | Tokens/Sec |
|----------|---------------|---------------------|------------|
| Short | 20 tokens | 46 tokens | 83.25 |
| Medium | 34 tokens | 456 tokens | 79.74 |
| Long | 113 tokens | 512 tokens | 78.47 |

### Fine-Tuning Experiment Summary

**Base Model:** google/gemma-3-4b-it
**Dataset:** PubMedQA artificial (10,000 medical Q&amp;A pairs)
**Method:** LoRA fine-tuning

**Configuration:**
```python
{
    &#34;lora_r&#34;: 16,
    &#34;lora_alpha&#34;: 32,
    &#34;lora_dropout&#34;: 0.05,
    &#34;learning_rate&#34;: 2e-5,
    &#34;batch_size&#34;: 4,
    &#34;epochs&#34;: 3,
    &#34;precision&#34;: &#34;bf16&#34;,
    &#34;gradient_accumulation_steps&#34;: 2
}
```

**Results:**

| Experiment | Training Time | Final Loss | GPU Test | CPU Test | Accuracy |
|------------|--------------|------------|----------|----------|----------|
| Exp 1-5 | ~3 hours each | Decreased | ❌ | ✅ | 70% |
| Exp 6 | 7.5h (hung) | N/A | N/A | N/A | N/A |
| Exp 7 | ~12 hours | 1.82 | ❌ | ✅ | 82% |
| Exp 8 | ~10.5 hours | 1.61 | ❌ | ✅ | **84%** |

**Best Model (Experiment 8):**
- Used SFTTrainer instead of base Trainer
- Text-based dataset (no pre-tokenization)
- Dynamic padding
- +14% improvement over baseline

### System Configuration

```yaml
Hardware:
  Platform: NVIDIA DGX Spark
  Architecture: ARM64 (aarch64)
  GPU: GB10 (Blackwell)
  GPU Driver: 580.95.05
  CUDA: 13.0
  Memory: 128 GB unified

Software:
  OS: Ubuntu 24.04.3 LTS
  Kernel: 6.11.0-1016-nvidia
  PyTorch: 2.5.1 (Docker)
  Transformers: 4.44.0
  CUDA Runtime: 13.0
  cuDNN: 9.5.1

Stability Mitigations:
  - GPU cache clearing: Every 50 steps
  - Checkpoint interval: 200 steps
  - Max session duration: 2.5 hours
  - Memory monitoring: Every 100 steps
  - Inference platform: CPU (FP32)
```

---

&lt;div class=&#34;callout&#34; data-callout=&#34;tip&#34;&gt;
&lt;div class=&#34;callout-title&#34;&gt;Related Articles&lt;/div&gt;
&lt;div class=&#34;callout-content&#34;&gt;

**More from the DGX Lab Chronicles:**
- [[Practical Applications/dgx-lab-intelligent-gateway-heuristics-vs-ml-day-1|Day 1: When Simple Heuristics Beat ML by 95,000x]]
- [[Practical Applications/dgx-lab-supercharged-bashrc-ml-workflows-day-2|Day 2: Supercharge Your Shell with 50+ ML Productivity Aliases]]
- [[Practical Applications/dgx-lab-building-complete-rag-infrastructure-day-3|Day 3: Building a Complete RAG Infrastructure]]

**Production ML Resources:**
- [[Practical Applications/building-production-ml-workspace-part-1-structure|Building a Production ML Workspace Series]]
- [[Emerging Trends/the-hidden-crisis-in-llm-fine-tuning-catastrophic-forgetting|The Hidden Crisis in LLM Fine-Tuning]]

&lt;/div&gt;
&lt;/div&gt;

---

**About This Series:**

I&#39;m documenting my journey building production ML systems on an NVIDIA DGX Spark—the wins, the losses, and the hard-won lessons. This is Day 4 of the DGX Lab Chronicles.

**Want to follow along?** Every article shares real code, actual performance data, and honest assessments of what works (and what doesn&#39;t) in production ML.

**Found this helpful?** Share it with your ML engineering team. Knowing the DGX Spark&#39;s quirks upfront will save weeks of debugging.

---

**Published:** October 26, 2025
**Series:** DGX Lab Chronicles (Day 4)
**Reading Time:** 10 minutes
</p></div>
  </body>
</html>
