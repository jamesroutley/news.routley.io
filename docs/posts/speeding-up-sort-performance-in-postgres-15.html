<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.citusdata.com/blog/2022/05/19/speeding-up-sort-performance-in-postgres-15/">Original</a>
    <h1>Speeding up sort performance in Postgres 15</h1>
    
    <div id="readability-page-1" class="page"><div data-sticky-container="">  <div>  <section> <div> <p><small> <p> <em>This post by David Rowley about Postgres 15 was <a href="https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/speeding-up-sort-performance-in-postgres-15/ba-p/3396953" target="_blank" rel="noopener">originally published on the Microsoft TechCommunity Blog</a>.</em> </p> </small></p><p>In recent years, PostgreSQL has seen several improvements which make sorting faster. In the PostgreSQL 15 development cycle—which ended in April 2022—Ronan Dunklau, Thomas Munro, Heikki Linnakangas, and I contributed some changes to PostgreSQL to make sorts go even faster.</p> <p>Each of the improvements to sort should be available when PostgreSQL 15 is out in late 2022.</p> <p>Why care about sort performance? When you run your application on PostgreSQL, there are several scenarios where PostgreSQL needs to sort records (aka rows) on your behalf. The main one is for ORDER BY queries. Sorting can also be used in:</p> <ul> <li>Aggregate functions with an ORDER BY clause</li> <li>GROUP BY queries</li> <li>Queries with a plan containing a Merge Join</li> <li>UNION queries</li> <li>DISTINCT queries</li> <li>Queries with window functions with a PARTITION BY and/or ORDER BY clause</li> </ul> <p>If PostgreSQL is able to sort records faster, then queries using sort will run more quickly. </p> <p>Let’s explore each of the 4 improvements in PostgreSQL 15 that make sort performance go faster:</p> <ul> <li><a href="#change1">Change 1</a>: Improvements sorting a single column</li> <li><a href="#change2">Change 2</a>: Reduce memory consumption by using generation memory context</li> <li><a href="#change3">Change 3</a>: Add specialized sort routines for common datatypes</li> <li><a href="#change4">Change 4</a>: Replace polyphase merge algorithm with k-way merge</li> </ul> <h2 id="change1">Change 1: Improvements sorting a single column</h2> <p>PostgreSQL 14’s query executor always would store the entire tuple during a Sort operation. The change here makes it so that PostgreSQL 15 only stores a Datum when there is a single column in the result of the sort. Storing just the Datum means that the tuple no longer has to be copied into the sort’s memory.</p> <p>The optimization works for the following query:</p> <div><pre><code><span>SELECT</span> <span>col1</span> <span>FROM</span> <span>tab</span> <span>ORDER</span> <span>BY</span> <span>col1</span><span>;</span>
</code></pre></div> <p>but not:</p> <div><pre><code><span>SELECT</span> <span>col1</span><span>,</span> <span>col2</span> <span>FROM</span> <span>tab</span> <span>ORDER</span> <span>BY</span> <span>col1</span><span>;</span>
</code></pre></div> <p>The first of the above queries is likely rare in the real world. A more common reason to have single column sorts is for Merge Semi and Anti Joins. These are likely to appear in queries containing an EXISTS or NOT EXISTS clause.</p> <p>The graph below shows how much storing only the Datum can help by testing the performance of sorting 10,000 integer values.</p> <figure> <img src="https://blog.plover.com/assets/images/blog/pg14v15_sorting_fig1.png" alt="Graph: Postgres 14 vs Postgres 15 sorting a single column" loading="lazy" width="850" height="307"/> <figcaption><strong>Figure 1:</strong> Sorting a single column in PostgreSQL 15 performs 26% faster than in PostgreSQL 14.</figcaption> </figure> <p>For further information see the <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=91e9e89dc">link to the Postgres 15 commit message</a></p> <h2 id="change2">Change 2: Reduce memory consumption by using generation memory context</h2> <p>When PostgreSQL stores records in preparation for sorting, it must copy the record into an area of memory ready to sort. In PostgreSQL 14 and earlier, when memory is allocated to store records to be sorted, the “aset” memory allocator is used. These memory allocators get used for managing memory in PostgreSQL. They act as a buffer between PostgreSQL and the underlying operating system. The “aset” allocator always rounds memory allocation request sizes up to the next power of 2. For example, a 24-bytes allocation request becomes 32-bytes, and 600 bytes becomes 1024 bytes. Rounding up to the next power of 2 done because when memory is freed, PostgreSQL wants to be able to reuse that memory for future needs. The rounding up is done so that the memory can be tracked in free-lists according to the size of the allocation. Rounding up vastly reduces the number of distinct sizes so helps keep the number of free-lists manageable.</p> <p>Rounding up to the next power of 2 causes an average of 25% of memory to get wasted.</p> <p>Typically, PostgreSQL has no need to free any memory for records when sorting. Normally it only needs to free all memory at once when the sort is complete, and the records are consumed. PostgreSQL also frees all the memory at once when the data to sort does not fit in memory and must be spilled to disk. So, for the general case, PostgreSQL never has to free individual records and the rounding up of the memory allocation sizes just causes memory to be wasted.</p> <p>PostgreSQL has another memory allocator named “generation”. The generation allocator:</p> <ul> <li>never maintains any free-lists</li> <li>never rounds up allocation sizes</li> <li>assumes the allocation patterns are first in first out.</li> <li>relies on freeing complete blocks when all chunks on each block are no longer needed</li> </ul> <p>Because “generation” does not round up allocation sizes, PostgreSQL can store more records with less memory. Switching sort’s tuple storage to use a generation memory context instead of an aset context also improves the situation from a CPU cache point of view.</p> <p>How much this change improves performance depends on the width of the tuples that are stored. Tuple sizes that are slightly above a power of 2 improve the most. For example, PostgreSQL 14 would round a 36-byte tuple to 64-bytes—close to double the memory that is needed. We can expect the least increase in performance from tuples that are already a power of 2 in size.</p> <p>To show how much faster this change makes sort, we will need to test a few different sizes of tuples. What I have done is start with 1 column and test its performance, before adding another column and repeating. I stopped at 32 columns. Each column uses the BIGINT datatype which consumes an extra 8 bytes each time a column is added.</p> <figure> <img src="https://blog.plover.com/assets/images/blog/pg14v15_sorting_fig2.png" alt="Graph: Postgres 14 vs Postgres 15 with varying record sizes" loading="lazy" width="850" height="1111"/> <figcaption><strong>Figure 2:</strong> Graph showing a 3% to 44% performance improvement for in-memory sorts in PostgreSQL 15</figcaption> </figure> <p>The test results show that the performance of PostgreSQL 15 has improved by between 3% and 44%, depending on the width of the tuple.</p> <ul> <li>Looking closely at the PostgreSQL 14 times, you can see bars going up in steps. Each step lines up with when the tuple size grew beyond another power of 2.</li> <li>Whereas for PostgreSQL 15, you don’t see the same “steps” where query time takes significantly longer, the way you do with Postgres 14 (at 7 columns, 15 columns, and 31 columns). Rather, in PostgreSQL 15 the query time increases more gradually as the number of columns increases.</li> </ul> <p>PostgreSQL 15 does not use the generation memory context for bounded sorts. For example, a query with an ORDER BY and LIMIT N clause. The reason the optimization is not used here is that bounded sorts only store the top-N tuples. Once N records are fetched, PostgreSQL will start to throw away tuples that are out of bounds. Throwing away tuples requires freeing memory. PostgreSQL cannot determine in advance the order that tuples will be freed. The generation memory context is likely to waste large amounts of memory if it was used for bounded sorts.</p> <p>For further information see the <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=40af10b57">link to the Postgres 15 commit message</a>.</p> <h2 id="change3">Change 3: Add specialized sort routines for common datatypes</h2> <p>Sorting done in PostgreSQL using an adapted quicksort algorithm. PostgreSQL has a vast number of different datatypes which users are even able to extend themselves. Each datatype has a comparison function which is given to the quicksort algorithm to use when comparing 2 values. The comparison function returns either a negative number, 0 or a positive number to state which value is higher or if they are equal.</p> <p>The problem with having this comparison function is that to perform a sort, PostgreSQL must call the function many times over.</p> <ul> <li>In the average case, when sorting 10,000 records, PostgreSQL would need to call the comparison function O(n log2 n) times. That is about 132 thousand times.</li> <li>When sorting 1 million records, the average number of comparisons is around 20 million.</li> </ul> <p>PostgreSQL is written in the C programming language—and while C function call overhead is low, C function calls are not free. Calling a function so many times has a noticeable overhead, especially when the comparison itself is cheap.</p> <p>The change made here adds a set of new quicksort functions which suit some common datatypes. These quicksort functions have the comparison function compiled inline to remove the function call overhead.</p> <p>You can do the following if you want to check if the datatype you’re sorting in PostgreSQL 15 is using one of these new quicksort functions:</p> <div><pre><code><span>#</span> <span>set</span> <span>client</span><span>\</span><span>_min</span><span>\</span><span>_messages</span> <span>TO</span> <span>&amp;</span><span>rsquo</span><span>;</span><span>debug1</span><span>&amp;</span><span>rsquo</span><span>;;</span>
</code></pre></div> <p>and run your SQL query:</p> <div><pre><code><span>#</span> <span>explain</span> <span>analyze</span> <span>select</span> <span>x</span> <span>from</span> <span>test</span> <span>order</span> <span>by</span> <span>x</span><span>;</span>
</code></pre></div> <p>If your debug message says either:</p> <ul> <li>qsort_tuple_unsigned</li> <li>qsort_tuple_signed</li> <li>qsort_tuple_int32</li> </ul> <p>then you’re in luck. If the debug message says anything else, then the sort is using the original (slower) quicksort function.</p> <p>The 3 quicksort specializations that have been added cover more than just integer types. These new-to-PostgreSQL 15 functions also cover timestamps and all data types that use abbreviated keys, which included TEXT types using the C collation.</p> <p>Let’s a have a look at the performance increase from the sort specialization functions. We can trick PostgreSQL’s executor into not applying the optimization for change 2 by adding a LIMIT clause to the query.</p> <figure> <img src="https://blog.plover.com/assets/images/blog/pg14v15_sorting_fig3.png" alt="Graph: Postgres 14 vs Postgres 15 in-memory sort performance" loading="lazy" width="850" height="597"/> <figcaption><strong>Figure 3:</strong> Graph showing PostgreSQL 15 performing from 4% to 6% better with in-memory sorts</figcaption> </figure> <p>Here we can see that in this small-scale sort that performance does increase as more rows are sorted. This is expected as the sort specialization change reduces the constant factors of comparing tuples during the sort. Sorting more records requires, on average, more comparisons per record. So we see larger savings with more records. These speedups only apply up until CPU caching effects cause the performance to degrade again due to more frequent CPU cache misses.</p> <p>For further information see <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=697492434">the Postgres 15 commit message</a>.</p> <h2 id="change4">Change 4: Replace polyphase merge algorithm with k-way merge</h2> <p>The final change is aimed at larger scale sorts that exceed the size of <code>work_mem</code> significantly. The algorithm which merges individual tapes was changed to use a <a href="https://en.wikipedia.org/wiki/K-way_merge_algorithm">k-way merge</a>. When the number of tapes is large, less I/O is required than the original <a href="https://en.wikipedia.org/wiki/Polyphase_merge_sort">polyphase merge algorithm</a>.</p> <p>Let’s do some benchmarks to see how the merge algorithm change affects the performance of PostgreSQL 15.</p> <figure> <img src="https://blog.plover.com/assets/images/blog/pg14v15_sorting_fig4.png" alt="Graph: Sort performance, sorting a 10GB table" loading="lazy" width="850" height="593"/> <figcaption><strong>Figure 4:</strong> Graph showing PostgreSQL 15 performing up to 43% faster for large sorts</figcaption> </figure> <p>Figure 4 above shows us that PostgreSQL 15 performs much better than PostgreSQL 14 for large sorts with very small values of <code>work_mem</code>. As the <code>work_mem</code> setting is increased, the performance gap decreases. With the largest value of <code>work_mem</code> (16GB) the sort no longer spills to disk. We can also see that the test with a <code>work_mem</code> setting of 64MB caused the query to run more slowly. This will require some further investigation before PostgreSQL 15 is released.</p> <p>For further information see <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=65014000b">the postgresql git commit message.</a></p> <h2 id="future">Future Work for sort in Postgres</h2> <p>We are highly likely to see further improvements in future PostgreSQL releases in the area of sort function specialization. For example, when PostgreSQL compares two values during a sort, it needs to check for NULLs. That is quite cheap to do for a few values but remember, this comparison must be done many times. The cost of the comparisons adds up quickly. If PostgreSQL already knew that no NULLs existed by checking for them when it stores records, then there would be no need to check for NULLs when comparing two records to sort. Many columns have NOT NULL constraints so this case should be common. PostgreSQL could also use NOT NULL constraints as proofs so that it does not have to check for NULLs at runtime.</p> <h2 id="trypg15">Why not try PostgreSQL 15 today to see how these changes affect your workload?</h2> <p><strong>The first test I ran while working on reducing the memory consumption of sort improved performance by 371%.</strong> This was due to the reduction in memory consumption required for storing the records to sort no longer exceeding my <code>work_mem</code> setting. Previously the sort was spilling to disk and after the change the entire sort was done in memory.</p> <p>Many SQL queries running on PostgreSQL require records to be sorted. Making sort go faster in PostgreSQL 15 is likely to make many of your queries go faster than on PG 14.</p> <p>If you want to give sort performance in PostgreSQL 15 a try:</p> <ul> <li>The <a href="https://www.postgresql.org/docs/15/release-15.html">release notes for PostgreSQL 15</a> are now online.</li> <li>PostgreSQL 15 beta 1 released on the 19th of May 2022 (it will be followed by “release candidate” versions in the months that follow)</li> <li>The final release of PostgreSQL 15 is due around October/November 2022</li> <li>You can <a href="https://www.postgresql.org/about/news/postgresql-15-beta-1-released-2453/">download PostgreSQL 15 beta 1</a> here</li> </ul> <p>If you’re reading this before the final release of PostgreSQL 15, why not download a copy of the PostgreSQL 15 beta and try out your own workload to see for yourself?</p> <ul> <li> <a href="https://blog.plover.com/blog/tags/open-source/">open source</a> </li> <li> <a href="https://blog.plover.com/blog/tags/performance/">performance</a> </li> <li> <a href="https://blog.plover.com/blog/tags/postgres/">Postgres</a> </li> <li> <a href="https://blog.plover.com/blog/tags/postgres-committers/">Postgres committers</a> </li> <li> <a href="https://blog.plover.com/blog/tags/sort/">sort</a> </li> </ul> <div> <h3> Enjoy what you’re reading? </h3> <p>If you’re interested in reading more posts from our team, sign up for our monthly newsletter and get the latest content delivered straight to your inbox.</p>  <form data-formid="1268" data-forminstance="blog-inline"></form>  </div>   <div> <div> <picture> <source srcset="../../../../../assets/images/team/blog_authors/david-859f563a.webp" type="image/webp"/> <source srcset="../../../../../assets/images/team/blog_authors/david-ebb62423.jpg" type="image/jpeg"/> <img alt="David Rowley" loading="lazy" src="https://blog.plover.com/assets/images/team/blog_authors/david-ebb62423.jpg"/> </picture> </div> <div> <p><small> <p> <strong> Written by <a href="https://blog.plover.com/blog/authors/david-rowley/">David Rowley</a> </strong> </p> <p>PostgreSQL contributor and committer. Likes working on performance problems and making Postgres go faster.  Enjoys exploring New Zealand&#39;s mountains and rivers in spare time.</p>  </small> </p></div> </div> <ul> <li> <a href="https://blog.plover.com/blog/tags/open-source/">open source</a> </li> <li> <a href="https://blog.plover.com/blog/tags/performance/">performance</a> </li> <li> <a href="https://blog.plover.com/blog/tags/postgres/">Postgres</a> </li> <li> <a href="https://blog.plover.com/blog/tags/postgres-committers/">Postgres committers</a> </li> <li> <a href="https://blog.plover.com/blog/tags/sort/">sort</a> </li> </ul> </div> </section>  </div> </div></div>
  </body>
</html>
