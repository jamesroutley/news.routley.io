<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lepiter.io/feenk/developers-spend-most-of-their-time-figuri-9q25taswlbzjc5rsufndeu0py/">Original</a>
    <h1>Developers spend most of their time figuring the system out</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>
I am often asked what I mean when I say that developers spend most of their time figuring the system out. Let’s unpack the statement.</p>
<p>
The oldest reference on the topic I know of dates back to 1979 in a book by Zelkowitz, Shaw, and Gannon entitled <a href="https://www.amazon.com/Principles-software-engineering-design-Prentice-Hall/dp/013710202X">Principles of software engineering and design</a>
. It said that most of the development time was spent on maintenance (67%).</p>
<div>
<figure>
<img src="https://theleo.zone/posts/tidal-cycles-setup/attachments/bkt2kwalbppajpqkeyvx46pie/1979-graph-picture.png" alt="Software development costs (1979)"/>
<figcaption>Software development costs (1979)</figcaption>
</figure>
</div>
<p>
Granted, the book does not specify how the figure was obtained. Still, it was deemed an important enough problem to attract significant research attention since then.</p>
<p>
So, how far are we now, more than 4 decades later?</p>
<p>
Let’s look at a recent paper by Xia, Bao, Lo, Xing, Hassan, &amp; Li entitled <a href="https://www.researchgate.net/publication/318811113_Measuring_Program_Comprehension_A_Large-Scale_Field_Study_with_Professionals">Measuring Program Comprehension: A Large-Scale Field Study with Professionals</a>
 and published in IEEE Transactions on Software Engineering, 44, 951-976, 2018. This paper is quite interesting in that it describes in great details how the figures are obtained. And it says that Comprehension took on average ~58%.</p>
<p>
Now, take a closer look at the results table.</p>
<div>
<figure>
<img src="https://theleo.zone/posts/tidal-cycles-setup/attachments/bkt2kwbkh75rlswlqd59cfupo/2018-costs.png" alt="Software development costs (2018)"/>
<figcaption>Software development costs (2018)</figcaption>
</figure>
</div>
<p>
In particular, take a look at the third column in the table: it says Navigation accounts for 24% of the effort, and that is considered separately from the Comprehension effort!</p>
<p>
So, after 4 decades, we can observe that not much has changed beside learning how to measure the “figuring out” time.</p>
<p>
So what?</p>
<p>
Well, that is the single largest expense we have. If we want to optimize anything in our discipline we should look at this part first. We talk often about how we build systems, but how often do you talk about how you spend the “figuring out&#34; time? If we do not talk about it, it’s not explicit. If it’s not explicit, it does not get optimized.</p>
<p>
If we do talk about how the “figuring out the system” time is spent, we notice that people spend it reading. In fact, as the above paper also shows, comprehension is essentially measured as reading! The two are considered as mostly synonymous.</p>
<p>
So, how should we talk about how we figure the system out?</p>
<p>
Given that not much happened for 4 decades, we should entertain the idea that maybe we should frame the problem differently.</p>
<p>
Please, bear with me. This is where it gets interesting. So, why do developers read code? Because they want to figure the situation enough to know what to do next. The intent is important. This is decision making.</p>
<div>
<figure>
<img src="https://theleo.zone/posts/tidal-cycles-setup/attachments/bkt2kw6qokaa8lf7hketedekq/decision-making.png" alt="The figuring out time is a decision making time"/>
<figcaption>The figuring out time is a decision making time</figcaption>
</figure>
</div>
<p>
From this perspective, reading is just the means through which information is gathered from data. It also happens to be the most manual possible way to do that, so this lends itself to an important opportunity for optimization.</p>
<p>
Before you can do something significant about anything, you have to name it. Otherwise it&#39;s like with Voldemort. <a href="http://humane-assessment.com/">Many winters ago</a>
, I called the effort of “figuring the system out to know what to do next&#34; assessment. And I claimed we should optimize development around it.</p>
<div>
<figure>
<img src="https://theleo.zone/posts/tidal-cycles-setup/attachments/bkt2kw6qyw5r5dtyydl9duvvq/assessment.png" alt="Assessment is the process of understanding a situation around a system enough to make a decision"/>
<figcaption>Assessment is the process of understanding a situation around a system enough to make a decision</figcaption>
</figure>
</div>
<p>
For a whole decade my colleagues and I explored this idea. And it led us to what we now call moldable development.</p>
<p>
What’s that?</p>
<p>
Reading is the most manual way to extract information out of data. It does not scale and leads to incomplete information &amp; uncertainty.</p>
<p>
Software is hard enough. Not knowing what the current system is like should not be an acceptable variable in the equation. A hand drawn picture about the current system is a belief. Decisions should never be based on beliefs. Not in engineering.</p>
<p>
Once we accept that systems are data, it becomes obvious we should approach it like data, too. Data science tells us that you first start from the problem and then reason through a tool that matches the context.</p>
<div>
<figure>
<img src="https://theleo.zone/posts/tidal-cycles-setup/attachments/bkt2kw5wc8w7uyr1n9pnr9ahw/molding.png" alt="Tools should match the context"/>
<figcaption>Tools should match the context</figcaption>
</figure>
</div>
<p>
As software is highly contextual we cannot predict specific problems. We can only predict classes of problems. To handle this, the key idea of moldable development is that the tool should be moldable after knowing the problem. In this way it can deal with what&#39;s important in context, and because of it, it can take care of the boring part of reading. Of course, for this to be practical, the cost of creating custom tools must be small.</p>
<p>
I see the flow of constructing custom tools during development, and, ideally, for every single development problem, as the next major leap in software development.</p>
<p>
In a decade from now, we should not be measuring the &#34;figuring the system out” in terms of reading. We should occupy our energy with solving actual problems. To get there we should start by talking about how not to read code. We cannot afford not to.</p>
<p>
We created <a href="https://gtoolkit.com">Glamorous Toolkit</a>
 to provide a concrete start for the &#34;how not to read code&#34; conversation. Glamorous Toolkit is a moldable development environment that makes it possible to create custom tools about software systems inexpensively.</p>
<p>
So, go to <a href="https://gtoolkit.com">gtoolkit.com</a>
. Play with it. Feel #MoldableDevelopment.</p>
<div><p>
And do engage with us: <a href="https://discord.gg/FTJr9gP">discord.gg/FTJr9gP</a>
.</p></div>
<p>
Let’s make that conversation happen.</p>

		
  	</div></div>
  </body>
</html>
