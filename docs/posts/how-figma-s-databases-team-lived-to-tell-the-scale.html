<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.figma.com/blog/how-figmas-databases-team-lived-to-tell-the-scale/">Original</a>
    <h1>How Figma&#39;s databases team lived to tell the scale</h1>
    
    <div id="readability-page-1" class="page"><p>Our nine month journey to horizontally shard Figma’s Postgres stack, and the key to unlocking (nearly) infinite scalability.</p><div><div><div colorscheme="[object Object]"><div><div><p>Vertical partitioning was a relatively easy and very impactful scaling lever that bought us significant runway quickly. It was also a stepping stone on the path to horizontal sharding.</p></div></div><p>Figma’s database stack has grown almost 100x since 2020. This is a <em>good</em> problem to have because it means our business is expanding, but it also poses some tricky technical challenges. Over the past four years, we’ve made a significant effort to stay ahead of the curve and avoid potential growing pains. In 2020, we were running a single Postgres database hosted on AWS’s largest physical instance, and by the end of 2022, we had built out a distributed architecture with caching, read replicas, and a dozen vertically partitioned databases. We split groups of related tables—like “Figma files” or “Organizations”—into their own vertical partitions, which allowed us to make incremental scaling gains and maintain enough runway to stay ahead of our growth.</p><div><p><a href="https://www.jakef.science/blog/how-figma-scaled-to-multiple-databases/"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACa0lEQVQokUXS20/SARjG8a66VBTDY+aNlmbmKa2c81DZQUPbcKIMVEAEDwkrOzjRbJamE88BBvwU+HFQs0xXLpu15dZN6x+o+7rpb/gWWPPivf3sefc8R2LCTUhCLST5O8lcGeS8d4obPgc1vgUuio/JC/WRs2rgzKqOonA7F8IGCsJG0oJtSIMqJKFmYsPKgwspORIBj4la8j02GpZ26XTuc2dhk/7nDrSuEQq9PaQF1WQHFBT6b1EoKskT9WR6TWR4jSQGWqNQTKjpHxhqItVv5KYQZsz9nYBtj+2BUXaGDSxO6bjqMHNKuEepx8I5z22yl3vIWjFT4LFS5hkjb2WEVH8PkqCKSLgoeFw00iqusSp85Zt1ki/GNl6a+3hiHaTBNssV+xp19hDVDhclDjuV9hkM9jHMi9Mo5oPkL80gE3XRlFEwRdQjFxeZf+Fny9yJrUGOUm7isnaYyqdOFM4duoRPGIRdmu2bdD+bYM7ayv3eRmr0D8kdGkYmaA8TpgR01G1MMLhhxzLQTllxLgmyDJJKqikbGqF/7R2+rR/4N34y6v7I+KCF+ZZL1BedJiUrB5nqOvHOg3KiYHpYj37Xjm3/LYrpERLLCzkqkyItLeba+DBzHz6z/f4X669+MyrsYR0yM99Yhf5sJjk5J0nW1hLvUh2CiWENVZuP0GwLVCxNkmJRIlFXIuuVU+S4i2bTTc/6GzrE19QuL1Iz24fpgZwuQzkV3fWcmNAR71MT+//lSN3SoJrkQAfJPgMJgoY4t5K45WakoprkoJ400USaPzITHTJRQ4agJMulIF1QkSBqiI3s8W8pfwBARJixybsgNwAAAABJRU5ErkJggg==" alt="One large database silo connected to two smaller ones." data-lqip="true"/><img data-loading="true" loading="lazy" alt="One large database silo connected to two smaller ones." src="https://cdn.sanity.io/images/599r6htc/localized/5c8ad1394a1cf21fc39adf7ca3d9f317c8b98b80-2120x1000.png?w=2120&amp;h=1000&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/5c8ad1394a1cf21fc39adf7ca3d9f317c8b98b80-2120x1000.png?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 1060w, https://cdn.sanity.io/images/599r6htc/localized/5c8ad1394a1cf21fc39adf7ca3d9f317c8b98b80-2120x1000.png?q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 1590w, https://cdn.sanity.io/images/599r6htc/localized/5c8ad1394a1cf21fc39adf7ca3d9f317c8b98b80-2120x1000.png?q=75&amp;fit=max&amp;auto=format&amp;dpr=2 2120w"/></a></p></div><p>Despite our incremental scaling progress, we always knew that vertical partitioning could only get us so far. Our initial scaling efforts had focused on reducing Postgres CPU utilization. As our fleet grew larger and more heterogeneous, we started to monitor a range of bottlenecks. We used a combination of historical data and load-testing to quantify database scaling limits from CPU and IO to table size and rows written. Identifying these limits was crucial to predicting how much runway we had per shard. We could then prioritize scaling problems before they ballooned into major reliability risks.</p><p>The data revealed that some of our tables, containing several terabytes and billions of rows, were becoming too large for a single database. At this size, we began to see reliability impact during Postgres vacuums, which are essential background operations that keep Postgres from running out of transaction IDs and breaking down. Our highest write tables were growing so quickly that we would soon exceed the maximum IO operations per second (IOPS) supported by Amazon’s Relational Database Service (RDS). Vertical partitioning couldn’t save us here because the smallest unit of partitioning is a single table. To keep our databases from toppling, we needed a bigger lever.</p><h2 id="scaffolding-for-scale"><a href="#scaffolding-for-scale">Scaffolding for scale</a></h2><p>We outlined a number of goals and must-haves to tackle short-term challenges while setting us up for smooth long-term growth. We aimed to:</p><ul><li><strong>Minimize developer impact: </strong>We wanted to handle the majority of our complex relational data model supported by our application. Application developers could then focus on building exciting new features in Figma instead of refactoring large parts of our codebase.</li><li><strong>Scale out transparently:</strong> As we scale in the future, we don’t want to have to make additional changes at the application layer. This means that after any initial upfront work to make a table compatible, future scale-outs should be transparent to our product teams.</li><li><strong>Skip expensive backfills:</strong> We avoided solutions that involve backfilling large tables or every table at Figma. Given the size of our tables and Postgres throughput constraints, these backfills would have taken months.</li><li><strong>Make incremental progress: </strong>We identified approaches that could be rolled out incrementally as we de-risked major production changes. This reduced the risk of major outages and allowed the databases team to maintain Figma’s reliability throughout the migration.</li><li><strong>Avoid one-way migrations: </strong>We maintained the ability to roll back even after a physical sharding operation is completed. This reduced the risk of being stuck in a bad state when unknown <em>unknowns</em> occur.</li><li><strong>Maintain strong data consistency: </strong>We wanted to avoid complex solutions like double-writes that are challenging to implement without taking downtime or compromising on consistency. We also wanted a solution that would allow us to scale out with near-zero downtime.</li><li><strong>Play to our strengths: </strong>Since we were operating under tight deadline pressure, whenever possible, we favored approaches that could be rolled out incrementally on our fastest growing tables. We aimed to leverage existing expertise and technology.</li></ul><h2 id="exploring-our-options"><a href="#exploring-our-options">Exploring our options</a></h2><p>There are many popular open source and managed solutions for horizontally sharded databases that are compatible with Postgres or MySQL. During our evaluation, we explored CockroachDB, TiDB, Spanner, and Vitess. However, switching to any of these alternative databases would have required a complex data migration to ensure consistency and reliability across two different database stores. Additionally, over the past few years, we’ve developed a lot of expertise on how to reliably and performantly run RDS Postgres in-house. While migrating, we would have had to rebuild our domain expertise from scratch. Given our very aggressive growth rate, we had only months of runway remaining. De-risking an entirely new storage layer and completing an end-to-end-migration of our most business-critical use cases would have been extremely risky on the necessary timeline. We favored known low-risk solutions over potentially easier options with much higher uncertainty, where we had less control over the outcome.</p><p>NoSQL databases are another common scalable-by-default solution that companies adopt as they grow. However, we have a very complex relational data model built on top of our current Postgres architecture and NoSQL APIs don’t offer this kind of versatility. We wanted to keep our engineers focused on shipping great features and building new products instead of rewriting almost our entire backend application; NoSQL wasn’t a viable solution.</p><p>Given these tradeoffs, we began to explore building a horizontally sharded solution on top of our existing vertically partitioned RDS Postgres infrastructure. It didn’t make sense for our small team to re-implement a generic horizontally sharded relational database in-house; in doing so, we’d be competing with tools built by the likes of large open source communities or dedicated database vendors. However, because we were tailoring horizontal sharding to Figma’s specific architecture, we could get away with providing a much smaller feature set. For example, we chose not to support atomic cross-shard transactions because we could work around cross-shard transaction failures. We picked a colocation strategy that minimized the changes required at the application layer. This allowed us to support a subset of Postgres that was compatible with the majority of our product logic. We also were able to easily maintain backwards compatibility between sharded and unsharded postgres. If we ran into unknown <em>unknowns</em>, we could easily <a href="https://www.jakef.science/blog/how-figma-scaled-to-multiple-databases/#the-logical-choice">roll back to unsharded</a> Postgres.</p><h2 id="the-path-to-horizontal-sharding"><a href="#the-path-to-horizontal-sharding">The path to horizontal sharding</a></h2><p>Even with these narrower requirements, we knew horizontal sharding would be our largest and most complex database project to date. Luckily, our incremental scaling approach over the past few years bought us the runway to make this investment. In late 2022, we set out to unlock nearly infinite database scalability, and horizontal sharding—the process of breaking up a single table or group of tables and splitting the data across multiple physical database instances—was the key. Once a table is horizontally sharded at the application layer, it can support any number of shards at the physical layer. We can always scale out further by simply running a physical shard split. These operations happen transparently in the background, with minimal downtime and no application level changes required. This capability would allow us to stay ahead of our remaining database scaling bottlenecks, removing one of the last major scaling challenges for Figma. If vertical partitioning let us accelerate to highway speeds, horizontal sharding could remove our speed limits and let us fly.</p><div><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACvElEQVQ4jVWTa1PTWhiF+dMgoqg90qYltml6SQ2IowIWAYvI8TKKOuN1BCo2TS/pLU3SNi3ieP7Bc2YnHOB8WB/2ntlrv2utd02ZvzTMkxC1SQhzcunuV4HaSQhxrloKre0bjJPT/CNN80eaxldmaO5FMHoqU8HjrkqjLNP+EqfzKU7ra4K6kcT0siHJOE/Fz2H4OcyaQruYYJBMMZZVJnKGoZLCKi1itNNMmX6exmcJZ2WOcXqGiTKDn7lCb2Mes3InIPrhZTjsp/nhqZhmBmv7Hp27z7GX9nGW32Ev79LY1TFaYsJhDut1nGHqNqfRGL9jEqexKJ6+QO27zLGX4chRA1JBbpoqrScaTvYxXq7EMF/C1dZp7uQuCJv7OZx7G4z0l/grb/CXXtBfe0j1QKXspDlyVQw/T+B3Q6G9dZuRcosTORJgqEawdqMYXSF5mKP+YZnO2j72WgWnWKO/Wqa9+YzKYY5DWwnkCkIRULWfof4xRq94He/+HO79Obqb89S+xal62f8Il+isvcVe/Ym9btB9cID1pETl4BLh+IzQVqm/j9J7dA1Xn8XVr9Jdv07ts3RB2NzP4i6vMyo8Z6TvMSqU6D9aofo9HUp21NA/sUp1hdZGFO/OAn4iih+P4qUWaO7EMDpnkq3XEqPULU4XIvyO/sVpLIKnRzDPQ0lTdlV+jrJhKJs6jraNV/gbT9vD1jZo7OTPQvHz1L/FsVev4RdmmWizDPVZOk9vYprJwLvjQTaY8niQCQm3lrALJVz9Fe7dl/QKWzSeaWeEQoaToV5NYh3JtA5kmmWZWlNBTB8s9kQLPBQIJBdjDGSJcWKRSWKRQVLCKknhYgujz+s3FshfVE/U7hLE2bRVGh9i9Is3GD6cD9DfvEldhOKKUERfA/z/cXh30elziM/cLKalBJYEaKfDmk40/gV+dzqM3x5jjwAAAABJRU5ErkJggg==" alt="A data silo on the left that breaks out into two other data silos on the right." width="804" height="536" data-lqip="true"/><img data-loading="true" width="804" height="536" loading="lazy" alt="A data silo on the left that breaks out into two other data silos on the right." src="https://cdn.sanity.io/images/599r6htc/localized/5b69dc237c2ee309a970a0ab656d02e62f136c26-2160x1440.png?w=804&amp;h=536&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/5b69dc237c2ee309a970a0ab656d02e62f136c26-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 402w, https://cdn.sanity.io/images/599r6htc/localized/5b69dc237c2ee309a970a0ab656d02e62f136c26-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 603w, https://cdn.sanity.io/images/599r6htc/localized/5b69dc237c2ee309a970a0ab656d02e62f136c26-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format 804w, https://cdn.sanity.io/images/599r6htc/localized/5b69dc237c2ee309a970a0ab656d02e62f136c26-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1206w, https://cdn.sanity.io/images/599r6htc/localized/5b69dc237c2ee309a970a0ab656d02e62f136c26-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1608w"/></p></div><figcaption>Vertical partitioning</figcaption></figure><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACw0lEQVQ4jYWTa2/aZhiG+6fbKmmUlkAAG3yKgZK0lB3aqatWbUu3NSRBPXxIOBS/xgY3hNiAISVZVm3aH7gm280U7cs+XLL8Wr7f+34Ot4ZXD4kY/IfozL0o44gCo2/vEap3mCt3OK2tYh/l6AwKdF/msXM6dl5H/FLAXZS4Nfi9wuBTieFkC+/MwPMNBqGJuywj5lv0j2T8WpG5ViFUKvhVBdHM0+pLdF9J2KqG0FTEXhH3PBK8KDMUBcavUky/X2fywzofmxnEiUL7TMF6KzGtP2JR/olZ6UeCnceIhkzbkeg1Nunra9jGGnYzh/spEjwvMdrPcK7d5XP6NlfZ2wS1VUQnT8dXsY8lgrrMQjeYazr+joRo5mg5Mt1fs1hKGktNI/bzicPheYlxo8DS1PhD2eZKrTB5LCGOJXozHedE46SZJXiZihk1MthOgY5XpLMrYSkGlqpjRZEXXwRPmyaL+gsu629Y1hr4T3ewjmV6oR7HGAQGQ0+NGZwlZ/bUwGpksbX72MZ9xGHuhsN9hYtKhT/Np3w260yfKLFDKzRwAwOvLXFymGF0kME7yuOONYSv09vLIrQUtpFCHH6JHNVwvJfhUlnh7/Qqf22uMNu5h93K82Gi0e/KjL/JEBpZQj3LWS2N/T5HO6rhroxQDYRmJF2Ox2ZZxmvlCb5bY/FohfmTFUa7DxBuIenyO4mgViHces7UeI5frSL25XhsPvwWRU4h9BTi4NphNIehGdfHs4sMHYXBqY6zMOlNdcR7Cb+2xUz/iqn2NX7VjDvaciS6rzcR2jpCX09qGI3Nv1sSCV9WkmdEtCnLMq5dZPwizWx7g7C6wfjZBuIoEpRp/yzRK2j0FA3r9Y1NGcYk6xYTvV9fMjcZugqjthTj9Ys4EwMR6PQOJKztBPFGvuHw2tX/cZ0g+mdZxvFUnHfZhI9q/P0fzqkvRfmIEgIAAAAASUVORK5CYII=" alt="A data silo on the left that breaks out into two other data silos on the right, then four other silos." width="804" height="536" data-lqip="true"/><img data-loading="true" width="804" height="536" loading="lazy" alt="A data silo on the left that breaks out into two other data silos on the right, then four other silos." src="https://cdn.sanity.io/images/599r6htc/localized/8903764c609f32287e38bd435f18b304d586efb0-2160x1440.png?w=804&amp;h=536&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/8903764c609f32287e38bd435f18b304d586efb0-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 402w, https://cdn.sanity.io/images/599r6htc/localized/8903764c609f32287e38bd435f18b304d586efb0-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 603w, https://cdn.sanity.io/images/599r6htc/localized/8903764c609f32287e38bd435f18b304d586efb0-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format 804w, https://cdn.sanity.io/images/599r6htc/localized/8903764c609f32287e38bd435f18b304d586efb0-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1206w, https://cdn.sanity.io/images/599r6htc/localized/8903764c609f32287e38bd435f18b304d586efb0-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1608w"/></p></div><figcaption>Horizontal sharding</figcaption></figure></div><p>Horizontal sharding was an order of magnitude more complex than our previous scaling efforts. When a table is split across multiple physical databases, we lose many of the reliability and consistency properties that we take for granted in ACID SQL databases. For example:</p><ul><li>Certain SQL queries become inefficient or impossible to support.</li><li>Application code must be updated to provide enough information to efficiently route queries to the correct shard(s) wherever possible.</li><li>Schema changes must be coordinated across all shards to ensure the databases stay in sync. Foreign keys and globally unique indexes can no longer be enforced by Postgres.</li><li>Transactions now span multiple shards, meaning Postgres can no longer be used to enforce transactionality. It is now possible that writes to some databases will succeed while others fail. Care must be taken to ensure product logic is resilient to these “partial commit failures” (imagine moving a team between two organizations, only to find half their data was missing!).</li></ul><p>We knew achieving full horizontal sharding would be a multi-year effort. We needed to de-risk the project as much as possible while delivering incremental value. Our first goal was to shard a relatively simple but very high traffic table in production as soon as possible. This would prove the viability of horizontal sharding while also extending our runway on our most loaded database. We could then continue building additional features as we worked to shard more complex groups of tables. Even the simplest possible feature set was still a significant undertaking. End to end, it took our team roughly nine months to shard our first table.</p><h2 id="our-unique-approach"><a href="#our-unique-approach">Our unique approach</a></h2><p>Our horizontal sharding work built on what many others do, but with some unusual design choices. Here are a few highlights:</p><ul><li><strong>Colos</strong>: We horizontally sharded groups of related tables into colocations (which we affectionately call “colos”), which shared the same sharding key and physical sharding layout. This provided a friendly abstraction for developers to interact with horizontally sharded tables.</li><li><strong>Logical sharding: </strong>We separated the concept of “logical sharding” at the application layer from “physical sharding” at the Postgres layer. We leveraged views to perform a safer and lower cost logical sharding rollout before we executed a riskier distributed physical failover.</li><li><strong>DBProxy query engine: </strong>We built a DBProxy service that intercepts SQL queries generated by our application layer, and dynamically routes queries to various Postgres databases. DBProxy includes a query engine capable of parsing and executing complex horizontally sharded queries. DBProxy also allowed us to implement features like dynamic load-shedding and request hedging.</li><li><strong>Shadow application readiness: </strong>We added a “shadow application readiness” framework capable of predicting how live production traffic would behave under different potential sharding keys. This gave product teams a clear picture of what application logic needed to be refactored or removed to prepare the application for horizontal sharding.</li><li><strong>Full logical replication</strong>: We avoided having to implement “filtered logical replication” (where only a subset of data is copied to each shard). Instead, we copied over the entire dataset and then only allowed reads/writes to the subset of data belonging to a given shard.</li></ul><h2 id="our-sharding-implementation"><a href="#our-sharding-implementation">Our sharding implementation</a></h2><p>One of the most important decisions in horizontal sharding is which shard key to use. Horizontal sharding adds many data model constraints that revolve around the shard key. For example, most queries need to include the shard key so that the request can be routed to the right shard. Certain database constraints, like foreign keys, only work when the foreign key is the sharding key. The shard key also needs to distribute data evenly across all shards to avoid hotspots that cause reliability issues or impact scalability.</p><div><div><p>Figma lives in the browser, and many users can collaborate in parallel on the same Figma file. This means that our product is powered by a fairly complex relational data model capturing file metadata, organization metadata, comments, file versions, and more.</p></div></div><p>We considered using the same sharding key for every table, but there was no single good candidate in our existing data model. To add a unified sharding key, we would have had to create a composite key, add the column to every table’s schema, run expensive backfills to populate it, and then substantially refactor our product logic. Instead, we tailored our approach to Figma’s unique data model and selected a handful of sharding keys like UserID, FileID, or OrgID. Almost every table at Figma could be sharded using one of these keys.</p><p>We introduced the concept of colos, which provide a friendly abstraction for product developers: Tables within a colo support cross-table joins and full transactions when restricted to a single sharding key. Most application code already interacted with the database this way, which minimized the work required by application developers to make a table ready for horizontal sharding.</p><div><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB90lEQVQ4ja2TzU7bQBhF/dhVF5SQAIE4/olpHBKVJGpQAwGFpKq66YZVV/wYexxnBjui3cFDnGqmJaCIoi66uPLonM/XXnxjifsmTwmfnVf5a665jCUeQhKd++ZTHtkqf809hOguK75rkMxdRGyTRjbixibJHOLCJ1EeQtQNN07UDTNu5pjZVPPYNh26y0rON1HHJYp+maK/yaJfQQ1LiC8lZuMSt4PfXCcflA3TTg03/vAtin4FOSqTnG9hyeM17twNit09pHNAUQv5YVfIW2/Ig3fkdgNZ/4CqH1DYAXmwhmq9ZeHWyOsdpNPl1t5n4e8gR+tY6qhM4XuI+pBLf0rijFg4AUW4jgp2EM6AS/eMK29C6h4apsISymtz44258KfE7ikqaCGPK1jJic289ZHYn5jC2J8i3w9IOw4ibBL7p1y6E668KUnj1DDRcUj3Drn2Jlx4UyL9sXBAPLKxonGNebuD9Ppkbtc852GHqGcTd3yyxgEzp2tc1ugaFnVrZM02mdtjprnXY7bf5npcw4q+75J+3kEeVZGfqshhldlZlejbNvHXbbITzbeN02fNtNMzelZqd1Q1HbrLSn4GJLlHOneXEbeeWYFk4SPUM65cw7TTM8t3pGs6dNfTYq9E85fc3/hysfWWv3SlHm/Av/JHZ/7wf+YXqnU5r23j3J4AAAAASUVORK5CYII=" alt="Three data silos, each containing blocks for &#34;users table&#34; and &#34;user favorites table.&#34;" width="804" height="536" data-lqip="true"/><img data-loading="true" width="804" height="536" loading="lazy" alt="Three data silos, each containing blocks for &#34;users table&#34; and &#34;user favorites table.&#34;" src="https://cdn.sanity.io/images/599r6htc/localized/8610966e627e683caaff88094d9dd8b75efa1a3b-2160x1440.png?w=804&amp;h=536&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/8610966e627e683caaff88094d9dd8b75efa1a3b-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 402w, https://cdn.sanity.io/images/599r6htc/localized/8610966e627e683caaff88094d9dd8b75efa1a3b-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 603w, https://cdn.sanity.io/images/599r6htc/localized/8610966e627e683caaff88094d9dd8b75efa1a3b-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format 804w, https://cdn.sanity.io/images/599r6htc/localized/8610966e627e683caaff88094d9dd8b75efa1a3b-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1206w, https://cdn.sanity.io/images/599r6htc/localized/8610966e627e683caaff88094d9dd8b75efa1a3b-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1608w"/></p></div><figcaption>Tables sharded by UserID and by FileID are each colocated together</figcaption></figure><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACLklEQVQ4ja2TS09TURSF75/TxKgTBzjSaGOF8FLsy1D6oIXbhvZKKX0/oEBbWrgtJhWupQKmCSaGxJEYMQiNxAn9EZ85B4LCRE0YrOx1vr3XHu2jfD5NcKHuH/5f1b38Vva7SaTOgaj7p+dM8uTF8FV+KdM948qHkwjG9xC1gwArX1X0gwAbh1O877zi3bHG629ByYWEF0z01g+n5OzKeUbsELuU6J6LgdYLTG8s9DbsmBoW+pojuNo27NtWnq5bMDfsmBs26QVzt+0MNgW3yYy5YeVZy8rsngulrzXMzdIA5vwknnyMvrzKjaUhbtWfcKfSz+N5L85clNHcDI/mvNyu9HO33kvPkgNLXsObizGcm6KnZGOwNYIy1LRgWnITyRSopdaIpRYwFbzc04d4WHYQzKapJGssJ1YJZFI8KDu4rz/HthCmkKpSS9RJJ4tYFoOMNO0oquFjupimmNapJ9cop3XChQz26jjeUpj57DIriRrVuM5cpoynGOJl1Ue0kKeaqqPHa5SSq0QXswQMH4q26Se4PIM6l2Qyn5B1ojiDWx/HUwmgFuL4szGpyfkYnoqKSx/HX4zIeX8uxkQujlqOoDV9KIufJgjseHC8dWIznDgMJ/4tF7O7HrS2m7HNMazGqJTwgomemLEbTslFJrDjRuxSPv6Mst3RMI5CbByFZN3qaOyeRGj/mKZ5HJZcSHjBRG/rSma7oyF2ycP+ck2Sh/3fX+0v+v31rkm/AF2cC8RZbsFmAAAAAElFTkSuQmCC" alt="Three data silos, each containing blocks for &#34;files table&#34; and &#34;file comments table.&#34;" width="804" height="536" data-lqip="true"/><img data-loading="true" width="804" height="536" loading="lazy" alt="Three data silos, each containing blocks for &#34;files table&#34; and &#34;file comments table.&#34;" src="https://cdn.sanity.io/images/599r6htc/localized/53ad07418b852f047bf1f19719c63dbf2d211cc3-2160x1440.png?w=804&amp;h=536&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/53ad07418b852f047bf1f19719c63dbf2d211cc3-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 402w, https://cdn.sanity.io/images/599r6htc/localized/53ad07418b852f047bf1f19719c63dbf2d211cc3-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 603w, https://cdn.sanity.io/images/599r6htc/localized/53ad07418b852f047bf1f19719c63dbf2d211cc3-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format 804w, https://cdn.sanity.io/images/599r6htc/localized/53ad07418b852f047bf1f19719c63dbf2d211cc3-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1206w, https://cdn.sanity.io/images/599r6htc/localized/53ad07418b852f047bf1f19719c63dbf2d211cc3-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1608w"/></p></div></figure></div><p>Once we picked our sharding keys, we needed to ensure that there would be an even distribution of data across all backend databases. Unfortunately, many of the sharding keys that we had picked used auto-incrementing or Snowflake timestamp-prefixed IDs. This would have resulted in significant hotspots where a single shard contained the majority of our data. We explored migrating to more randomized IDs, but this required an expensive and time-consuming data migration. Instead, we decided to use the hash of the sharding key for routing. As long as we picked a sufficiently random hash function, we would ensure a uniform distribution of data. One downside of this is that range-scans on shard keys are less efficient, since sequential keys will be hashed to different database shards. However, this query pattern is not common in our codebase, so it was a trade-off we were willing to live with.</p><h3 id="the-logical-solution"><a href="#the-logical-solution">The “logical” solution</a></h3><p>To de-risk the horizontal sharding rollout, we wanted to isolate the process of preparing a table at the application layer from the physical process of running a shard split. To do this, we separated “logical sharding” from “physical sharding.” We could then decouple the two parts of our migration to implement and de-risk them independently. Logically sharding gave us confidence in our serving stack with a low-risk, percentage-based rollout. Rolling back logical sharding when we found bugs was a simple configuration change. Rolling back a physical shard operation is possible, but it requires more complex coordination to ensure data consistency.</p><p>Once a table is logically sharded, all reads and writes will act as if the table is already horizontally sharded. From a reliability, latency, and consistency perspective, we appear to be horizontally sharded, even though the data is still physically located on a single database host. When we are confident that logical sharding is working as expected, we then perform the physical sharding operation. This is the process of copying the data from a single database, sharding it across multiple backends, then re-routing read and write traffic through the new databases.</p><div><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACiUlEQVQ4jZWTTU8TURSG+3cIYWdiJMbfIAUJtCq00iIfBQora6gzDEPLtDOdGQq6Q01QpGpLwYBEiLjSjQjMFPoxLU3EBf6I15xTUsPGxMWbe3Pe5zzJ5GZc1sUSrJ9pWBUDtq3BPkzCPkg0zoIGq2rAOk83UjV4doWxNd5lx8USXMfnadhf4yhnonBeRFBZjqC8/AiV5xE4Lx+j9P4JrG9xDt1pRh0zyxHeoV1ykMt1dGaglBfwIzGOjBzAYtwPM+7HUsyP3GwQViqM0oaI4oaI41SYZ9QRQ2xGDuAwMc4OcrmOagbKWQH5xBC6kz1o1TvQot9Gm+6GT/FgVwuhmhXgZAV80kLwKb1ou2SI7U72IJ8YRiUrgFwsdHIittQR+JIeXE914prmRnuqC6OJu/iij6OaEzn7+hjP2i8ZYv1JD7bVUXY0hfWcCEcJY0MKYlHqhy714Znkw87MIGraFGrrYiPqFD7ODHJHDLGbUhCOMsmOpvAsJ6KgTGBldgCyfB+CfA9xuQ/vpABK2iRqOZFD97dSALFLhtiV2QGcKBPsaAorOQHr6jDupHrRuuBGi9mBtoVO+FQv9vSx5ifv6iH0q17uiGk13ehO9SKvjrCjKaRH2VKG8UDx4KbWiRuqG7e0LozNe7GvhvhBKJ/VEELzXu6IIXZA8fDu30epmyhtirC1MHbmHmI1FsCruQDWYkHsyUM4MadQ/CBy6L4rD+FNLMjM6lyAdwpamB3kch3/SsP+rqC8KcJZi8JZnYbzerpxZqIobkuwDhKc4vYMz64wa1HeJQe5XPzrkfTMRKFi4LRs4LSk46RsoOAYsOom95y6yTPqiCGWdmiXe/r17N9PQbH+kf9h/gBtoOkqRHektgAAAABJRU5ErkJggg==" alt="Two data silos with blocks for logical and physical shards." width="804" height="536" data-lqip="true"/><img data-loading="true" width="804" height="536" loading="lazy" alt="Two data silos with blocks for logical and physical shards." src="https://cdn.sanity.io/images/599r6htc/localized/fc28f4926b31d5e5b9cc97a8fc622ac5788ca865-2160x1440.png?w=804&amp;h=536&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/fc28f4926b31d5e5b9cc97a8fc622ac5788ca865-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 402w, https://cdn.sanity.io/images/599r6htc/localized/fc28f4926b31d5e5b9cc97a8fc622ac5788ca865-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 603w, https://cdn.sanity.io/images/599r6htc/localized/fc28f4926b31d5e5b9cc97a8fc622ac5788ca865-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format 804w, https://cdn.sanity.io/images/599r6htc/localized/fc28f4926b31d5e5b9cc97a8fc622ac5788ca865-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1206w, https://cdn.sanity.io/images/599r6htc/localized/fc28f4926b31d5e5b9cc97a8fc622ac5788ca865-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1608w"/></p></div><figcaption>Four logical shards on two physical shards</figcaption></figure></div><h3 id="the-query-engine-that-could"><a href="#the-query-engine-that-could">The query engine that could</a></h3><p>To support horizontal sharding, we had to significantly re-architect our backend stack. Initially, our application services talked directly to our connection pooling layer, PGBouncer. However, horizontal sharding required much more sophisticated query parsing, planning, and execution. To support this, we built out a new golang service, DBProxy. DBProxy sits between the application layer and PGBouncer. It includes logic for load-shedding, improved observability, transaction support, database topology management, and a lightweight query engine.</p><div><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACJ0lEQVQ4jW2Sa1PaQBSG/fO1Eq3KLXibWhG1hVbH6bSOVju1dZRbjOzZBLAVUQRBfsTT2QQBLx/eycnmPc+eSya8fopx6QfztNGdRTwnR333hH9ZJ5CJPScbfjOewPtUEyHEHsAeTTa6m0L+rqJLOeT3Dup4GynkwrPuwPPwNDcEPoyBxmTO5G4BkQz6ZCeAiruF3C4Nk0feVBgboO7bgxdjMmAb6SWpdBNc3NiI8xH/YB9/7wCd/0ylsUTlPoHqJcNC+qM8oycV6l6KSjuJ04xRbkYpN2I43hJOaQ2nuIajlilfxcNv1zHcVgLphhW+bLmziK6nqZQ3Oc9ncOU9btPGvYsHiYFMfJvA9VdwixncwgbiraPvll8B3qzgF7ap7h3ifz/Ey28jzZVRW8bXt1GtBbzzLNX9H/jfjvD+7KIbq8ONj4DtRbSXQfI51FkW0ebmwQIeh9+3kc4CupZGilnUaRapbKBbYxUO196zqVzFcUozlM8sLmpR9H1Y3ePAg7hnoxpxnPIMpVOLi+o80gkX5JmlDIGdBFKwkM03SHoSObaQ2xg6+D1CYOC7T6KcafSnSXT6LepoCrmODsYyDmzF0YcRarF31Oei+F+nkYYxPgO24+hfEWr2DJezMfQXC3U59wqwnUBOLfz1KaofLPRPC7l5pULTSXEaf3OK6qqFHERQwcXPgWY2V/OokoUUIqj6XNDeC2AwwyjiWEg+gqrOhjMc+P4D9RhT0MygMvMAAAAASUVORK5CYII=" alt="The application layer flows to DB Proxy, PG Bouncer, and then to the database." width="804" height="536" data-lqip="true"/><img data-loading="true" width="804" height="536" loading="lazy" alt="The application layer flows to DB Proxy, PG Bouncer, and then to the database." src="https://cdn.sanity.io/images/599r6htc/localized/2af44a9d935f95fa08d003b61041270b30d1bb07-2160x1440.png?w=804&amp;h=536&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/2af44a9d935f95fa08d003b61041270b30d1bb07-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 402w, https://cdn.sanity.io/images/599r6htc/localized/2af44a9d935f95fa08d003b61041270b30d1bb07-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 603w, https://cdn.sanity.io/images/599r6htc/localized/2af44a9d935f95fa08d003b61041270b30d1bb07-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format 804w, https://cdn.sanity.io/images/599r6htc/localized/2af44a9d935f95fa08d003b61041270b30d1bb07-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1206w, https://cdn.sanity.io/images/599r6htc/localized/2af44a9d935f95fa08d003b61041270b30d1bb07-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1608w"/></p></div><figcaption></figcaption></figure></div><p>The query engine is the heart of DBProxy. Its main components are:</p><ul><li>A query parser reads SQL sent by the application and transforms it into an Abstract Syntax Tree (AST).</li><li>A logical planner parses the AST and extracts the query type (insert, update, etc) and logical shard IDs from the query plan.</li><li>A physical planner maps the query from logical shard IDs to physical databases. It rewrites queries to execute on the appropriate physical shard.</li></ul><div><div><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAABYlAAAWJQFJUiTwAAAEV0lEQVRIiaVW+1vaSBTln69aFV9AIqhrqVrr1m0Rl/oCVOQNSWbyAELCQ+Ql9X84+80EahC23e/bH+43yeTcM/eeuXMnHn0kYJ6Rvh+Fxjqylhc5y4uMuYq8vQb5aQvac2Cujz4S4FGHAQ4qtzdRam2g1HaMkSTIIq7L73AjL+BaeockXULG9KI4xpUfNyF1trg/6fkdwkkk6doqUpVlPFRW8FB17FZbQoIu8vFOX+Lf07XX7yzqnOVFvrHGibVnAR4WPun5+CpSZ/OnlVqbKDY2UGhsoNjYRKnpsraDYT5yl0XngzpwZPAYP0RMTB+xUYDaF6DUdkDlQ2jSZ6jSMTf2TMkBFDsIbShwrD5i4yuHxy2oMRKhM8LONvTCKdqXebSiJdS/ZWFH8niKyWjHM1CVI9BegBMazMe9KXMJH4Oops/xeEpR/UMCCWWh7xbQOtTRiRJopT9BuwGONd4SusN1E2rprzC/5GCE81A/ZKCFs6gdFFGPZEBLn6YIDXfKbzXkhF0RihKGdncGI/EdejzGzUjEoKW+QdH3oPadlPXfETIQ2376JEJt7YDYIRS0AAp6ANTegdoO8QX1Z+E/EP6Y7NpEkwDk7ibujEXcV5ag9LZe9eYBCE7a/0boCDyOciiAtLchV3ZQkIMoykHI1RBoR5wiNH6b8lhH2hWgKB9RiV/CvLhF9XsCWuIctLIPndfgWPPRLwjdO006AmjuBPbXAqxDBeaBhFokBZUcQRu6NRdnCad1cUUoHaB6dQPzPIVq9A7adQxE33edEvE19beEbzVhTrQZBDX2QWgYCv0AUtlzTtFPInHa152y+wNrGHTgB+37IXe2eFfJ1r28GbB51ghYab0lM+ZFyDpHobGGbN1pTaxdJcgCknQBGXOFN9ystYpia52T6/MinLywVQvNddwb75FhhLbTrafMZt2b9cNl3mT1518RDgPcIW2uQOn5eOqso7OFmDnPAShdHydljVV7DkwTuneYOfD7o77Kdaq8zJYFm1MHficDy8t93JUy3hSBA5kmLJVU5T1/Nl7cJTU+Zi8iSN/HZWH6qsPphT08lYEAbSBAefIhpS8jZSxDefLz0mHGSVnaY5zc8eFec+4f0vU782OcR7ZFEHUfVDkEkQ8gFcOQSmH+TulHKPUQvxLYyVGMPX4FTHDyBEcOoVR2QToBeMrlfVSurlE/y6AeScOKZmGf59COlWBfpKHmT6C02R0TgpGMwYpmONaOZtE4z6H1dxHtiwKMVBSSKcIj5Q5QP0uj8YnAOpLROCZofVbRPzXRiVDoDxEoTRGKsQvzMonWCeXY5jFF+0RF77SGQaQGMxFHubINT5nsQr+LonYdR+36hpt5E4eduEUteQUiHYI8ClCsILTMXzDjcf6d4dloxW9hJRPQcl8gWeyifxRArBBofW/GSH2H90QmutoTQBpBPq/OYHdBmkGO4XWojZyCnbHR7D/MXJzrX2e2H/5P+wdOtrQfyJNcZwAAAABJRU5ErkJggg==" alt="A query that flows to &#34;where&#34; and then leads to &#34;shard_key&#34; and &#34;other_col.&#34;" width="528" height="792" data-lqip="true"/><img data-loading="true" width="528" height="792" loading="lazy" alt="A query that flows to &#34;where&#34; and then leads to &#34;shard_key&#34; and &#34;other_col.&#34;" src="https://cdn.sanity.io/images/599r6htc/localized/1547e54a020e816921f740b12b71f2b64f415652-1056x1584.png?w=528&amp;h=792&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/1547e54a020e816921f740b12b71f2b64f415652-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 264w, https://cdn.sanity.io/images/599r6htc/localized/1547e54a020e816921f740b12b71f2b64f415652-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 396w, https://cdn.sanity.io/images/599r6htc/localized/1547e54a020e816921f740b12b71f2b64f415652-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format 528w, https://cdn.sanity.io/images/599r6htc/localized/1547e54a020e816921f740b12b71f2b64f415652-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 792w, https://cdn.sanity.io/images/599r6htc/localized/1547e54a020e816921f740b12b71f2b64f415652-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1056w"/></p></div><figcaption>Query parser</figcaption></figure><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAABYlAAAWJQFJUiTwAAAFQklEQVRIiZ2W21MTZxjGuac31RGv+id0bO1FO+302kMHtNOpClXbau2U2k4dL+pYbbHioYKKQJIlEZBDAgioIAYQAwQSQkIOe8rmyFkion/Er7MbiFC5YHrxzJfN+77PPt/7Pe/u5mmvBdYQfaWvFqKvLKjLAmqmbhMIqC+zOdkaS65eR95mhMqSgKQ0EZ18SGyiF22ix1h1qIFOpFS9QfqmRticUHslENUJF6xo3l5me4Ik2gNEHRMk2v3MdYtMO70okgN1WSe0bJFw3kZ8rJ/p9giK1U+kzot6N0C6SWb6YQA10mG0ZOuEC1ZUz0MS3V40hw/N4SXW5iPePonWO4wstm5NYXSthxkBSb2HGuhCmegmPNpBZOw+qq8bOdiOlL6LurKFHkZXg/rJKRkL8pyVUKwOt/8O3lANYsqKvFhnqNvSKWu5LWQJRbURcayL4EAXoaddiL42pGkb0Zw6i5H7FuH6u0VX+ygvCEjeTpLdPpL2IHF7AO2xC0lpXmcZy1tK8zaSWXIHIy8KyJP3SfV4SXdOkbzvR3M+Q1abNngw+h9Sg3A91JdmxEwtwdlq/KLA1HgrU8MOAsN2/BONBGImwgvVSJla1BXzhlqDcP3+dbKpuSo8iUo88QrGtUrccgUjkRsGxpQKPLFszJuoJDh/J3fauR4aqlbMBvQEl3SVUfU6gdnbBOerCC68wZR+PV+Ff+YWI/I1RpRrhBerc/WGQmnRgpi0IcUamBKtuL01+IIWRK0BMV6PNCegLFuQlyyIqWyeGG3AGzDjnqghKNuQ4g2IaStyxkyeXqiO9JIYGCHRP0LcOUJyYJSZoXFSIy7kiB1x0Wx4MOrpIfV0lOTgKIn+LKafjjPjGiPqe0A4LZAnia3Ee92k7RHSDpHZdpm5DoWlrjgLvZIxHZE5ExGt3rjpbIfMjENirl1h4X6UTHeS5Z4kSZfLGII83bzq0BMSj8cMJPvGST3xMNs/SXrIjRxqQ9IVJm1o7j7STg+pPk82r8/DTL+P2UGfoT6c1BXOC4ixBmS1BUVtRVFbDPOKcjNhpZFQSiCyVEt43kRIsxGRmoyYrOj5LdmaaAtSsh75+aoP9aPXzapDemHiWaqS5sjfWIN/YQuVcTechf7bFiyjU77ChG6Z1RoDK5v4MPZaIJSpwTL1JwcfneLTtmN85jhqrFkc5fOO4/w48As98etvPRi0NR+uH5/AYjVXPL/zfksx75qL2G4qYrvlANvNRWwzFVFQd5B93SdoU8pRXpo3jF9u9Iw5XFUYydRSHy7jmLOU/Q9Osr/7BHs6v2Nv5/fse3CCwkc/cNZ1hifJG5sr1NaefytmxGUToaUaXOlKOpRyWqXLNAbLMLnPIXjO0xS5hF26zCPtGt7520Re1CK9NOX6l+uhTjY8c9NQdsd/wUCV/w+q/Beo8Jzj0sAZyofOcmvivPHfWqwmcJF2pZzJxTtZwterhLoynezAg5Psbi7mIx0tJcb6YeNhdtUf4oOGw+y+dyQbay5md1Mxn9i/oXTwV/pXt6+3zSDUpVcFLrDLXkK+pYh3dJgLya/aT/4/e8iv2EP+zb3k39xHfvUX2Zi5kG22LznYc4qHsWvGU3wDYU3wIh93fUtB6yF22g+xs/lrCqxfsqO6kB01hewwF1EgHKSg8St2th4y8t5zHOGws5Se2PWNhPKyic7oVX5znaF44GdKBk9Toq/OUkr6fnqDJ6WU9GfjxYOnOT54mnLvOYanb27csn4x9byaoXQlzsQNnMmtQe+de/aWscO3fKi/SzTjnfJ/sPahYOFfuepLpFHuVXQAAAAASUVORK5CYII=" alt="A query that flows to &#34;where&#34; that then leads to &#34;shard_key&#34; and &#34;other_col.&#34; Those then flow to &#34;logical select.&#34;" width="528" height="792" data-lqip="true"/><img data-loading="true" width="528" height="792" loading="lazy" alt="A query that flows to &#34;where&#34; that then leads to &#34;shard_key&#34; and &#34;other_col.&#34; Those then flow to &#34;logical select.&#34;" src="https://cdn.sanity.io/images/599r6htc/localized/f01e5c7bb39a8b73ef5f44c4d944ebb4d1ab5872-1056x1584.png?w=528&amp;h=792&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/f01e5c7bb39a8b73ef5f44c4d944ebb4d1ab5872-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 264w, https://cdn.sanity.io/images/599r6htc/localized/f01e5c7bb39a8b73ef5f44c4d944ebb4d1ab5872-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 396w, https://cdn.sanity.io/images/599r6htc/localized/f01e5c7bb39a8b73ef5f44c4d944ebb4d1ab5872-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format 528w, https://cdn.sanity.io/images/599r6htc/localized/f01e5c7bb39a8b73ef5f44c4d944ebb4d1ab5872-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 792w, https://cdn.sanity.io/images/599r6htc/localized/f01e5c7bb39a8b73ef5f44c4d944ebb4d1ab5872-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1056w"/></p></div><figcaption>Logical planner</figcaption></figure><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAABYlAAAWJQFJUiTwAAAErklEQVRIiY2US1CbVRTHu0ZxxlEctS4qK1fOuGh14cZpbasjtaXgCLVjuxKppdhaq9WqA6W0Shte+b4EGpRHCZBUCBECLUJCAiTk+b1CE0hKEhIIYaYLF7r7O/cmgdQm4OKfc+459/5yz733O7ukBAtxnUHaCmsshKgCQlQJMaqkdkuKLcUUdK6YsZbYXckBCynBgI8xcHtvQ7BqIFqGIM4MQpoZoiJ+eixaBsFZ++Dxt0NYSwPZx4FiggEXYeCxqeHXzcCvdsCnnsdSvwP+PjvVUr+TarHPAa9uCh5XN/hVAmRyAzmbGovDs3QhgQQGCMRBxw81bgQ1bgT6nVgYNoJzZwGS2rOVnC6VSDD/TkV876yOWs62bcnM5sGSf+QiLBUfUcC9LMeMJMOsVwb3MkNjNL/CQFhlnrwU6pCSyU7jDPgVBYSwEkK4jcodZGHmZLDwjfA8VECIJON8WAk+ytI1T5ScBnJhFh5nN8RpHSSjHpJJD9Goh+f+ELiJIeqnY8L0INyeTvArbC6gHJ5AG8RJPZY0diyqHZuSuueo/Gp7Ur12+LVWCOZB8CElvVDpMSA9Azm4pXb4pyYQH1xEXBtEtN+HpS4OLoUZHuUMgj0CYgN+mlsdegCfZRRCqG17YMA0ib8MUfw9msD63SD8nW4KE1U2hHolPNJF8I9hA48My/BZDOCzAlNn6Akq4TXrERvjsD62gPCwGz7tLBYGLPBp5xAYnEd0hEdi/AEiY06Is3fBhxQUmPVSyAFz0q8QXf3wurSQnAMQM0TGkktDc4KrD54FFYRYrkuhQdIcyPtiM6T4z5ilEGrXsrxD8pP50r1EGyklsiid20jOlzJgGZ9eMiDEGTijLZgLNWJ2B1nDjXDFWnK1r+TAHm1Gt6cGP5ku4tupC7hszC6SqzNfglaso9CsQFLO9PItfDXxJV7/7WPsaT+OwtslKFSV4lVVSUqlKOwoxR5VCd688wmFWiNNdG1WoGn5FqrvncNrqo/wEnsUuxXHsFt5LGnTflsxXlYW442uMtRMX4Q1nANIrG2lCe2OH3HhfjUqx8/izHgVVaXhLCoNX+AMid2rQuV4Fb6ZPI9erhbOXCUTy8flmF9pxnRIRndrCskwFbwJg1QPg/c69U2pnDkkgyPaTC8yK1DMeAL8mhzcaiu4NTkc4SZMCfUwitfhXGmmMZIjcx674fUsOyTWsizDHa4WcvsVtNqvoNn6HX4xfo0G0yW02L6nMcbxAzRiHWyRps3NZC1ZiMuhla7h1Ggl3lKfxL7uE9jXVY69Ke3rLMfenhN4e+BTVE1UY8z/M91ZTiApo4urwf67p/Es+yHyG95Dfv0h5N84hPzrh5B/7SCevvU+CjqOo2SkArqFekjx7YBxOTq5GryjOYVnWouQV38QeTX7kXf1APLq3sVTtQeQ13AYz6mKUfzHZ9B5/wewh6vFYc1pvMgeRUFzEQpkHyRtyxG80FSE51uP4JWOEpTpKzC80w7JExjx3cDlyfM4oa9A2XBKxNdXoDwVOznyOa6aL2Ey0LD9GRLriLbgz0ADBefSqO8GjMGbcMdaU8CtBpPRvlItiLSx9LvaUakWltG+/gU6NlRL0/vzmgAAAABJRU5ErkJggg==" alt="A diagram showing the logical select plan that leads to logical single shard plan; then a physical select plan that leads to physical single shard query." width="528" height="792" data-lqip="true"/><img data-loading="true" width="528" height="792" loading="lazy" alt="A diagram showing the logical select plan that leads to logical single shard plan; then a physical select plan that leads to physical single shard query." src="https://cdn.sanity.io/images/599r6htc/localized/451db126da5358fff366445be34f74bf5bdb6a2c-1056x1584.png?w=528&amp;h=792&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/451db126da5358fff366445be34f74bf5bdb6a2c-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 264w, https://cdn.sanity.io/images/599r6htc/localized/451db126da5358fff366445be34f74bf5bdb6a2c-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 396w, https://cdn.sanity.io/images/599r6htc/localized/451db126da5358fff366445be34f74bf5bdb6a2c-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format 528w, https://cdn.sanity.io/images/599r6htc/localized/451db126da5358fff366445be34f74bf5bdb6a2c-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 792w, https://cdn.sanity.io/images/599r6htc/localized/451db126da5358fff366445be34f74bf5bdb6a2c-1056x1584.png?w=528&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1056w"/></p></div><figcaption>Physical planner</figcaption></figure></div></div><div><div><p>Think of <strong>“scatter-gather”</strong> like a database-wide game of hide-and-seek: You send out your query to every shard (scatter), then piece together answers from each (gather). Fun, but overdo it, and your speedy database starts feeling more like a snail, especially with complex queries.</p></div></div><p>Some queries are relatively easy to implement in a horizontally sharded world. For example, single-shard queries are filtered to a single shard key. Our query engine just needs to extract the shard key and route the query to the appropriate physical database. We can “push down” the complexity of the query execution into Postgres. However, if the query is missing a sharding key, our query engine has to perform a more complex <strong>“scatter-gather.”</strong> In this case, we need to fan out the query to all shards (the scatter phase) and then aggregate back results (the gather phase). In some cases, like complex aggregations, joins, and nested SQL, this scatter-gather can be very complex to implement<em>. </em>Additionally, having too many scatter-gathers would impact horizontal sharding scalability. Because the queries have to touch every single database, each scatter-gather contributes the same amount of load as it would if the database was unsharded.</p><p>If we supported full SQL compatibility, our DBProxy service would have begun to look a lot like the Postgres database query engine. We wanted to simplify our API to minimize DBProxy’s complexity, while also reducing the work required for our application developers, who would have to re-write any unsupported queries. To determine the right subset, we built out a “shadow planning” framework, which allowed users to define potential sharding schemes for their tables and then run shadow the logical planning phase on top of live production traffic. We logged the queries and associated query plans to a Snowflake database, where we could run offline analysis. From this data, we picked a query language that supported the most common 90% of queries, but avoided worst-case complexity in our query engine. For example, all range scan and point queries are allowed, but joins are only allowed when joining two tables in the same colo and the join is on the sharding key.</p><h3 id="a-view-of-the-future"><a href="#a-view-of-the-future">A view of the future</a></h3><p>We then needed to figure out how to encapsulate our logical shards. We explored partitioning the data using separate Postgres databases or Postgres schemas. Unfortunately, this would have required physical data changes when we logically sharded the application, which was just as complex as doing the physical shard split.</p><p>Instead, we chose to represent our shards with Postgres views. We could create multiple views per-table, each corresponding to the subset of data in a given shard. This would look like: <code>CREATE VIEW table_shard1 AS SELECT * FROM table WHERE hash(shard_key) &gt;= min_shard_range AND hash(shard_key) &lt; max_shard_range).</code> All reads and writes to the table would be sent through these views.</p><p>By creating sharded views on top of our existing unsharded physical databases, we could logically shard before we performed any risky physical reshard operations. Each view is accessed via its own sharded connection pooler service. The connection poolers still point to the unsharded physical instance, which gives the appearance of being sharded. We were able to de-risk the rollout of sharded reads and writes gradually via feature flags in the query engine and roll back at any time within seconds by just rerouting traffic back to the main table. By the time we ran our first reshard, we were confident in the safety of the sharded topology.</p><div><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2UlEQVQ4jY2T208TQRyF+RMJ0QdNKsRLKDwUNdo0rmzpdsvSgmJLWx8lJD4IMVEuLWlCGlMlERNotzu9YIDS1vsL+g98ZmaLVq2Fh5OZnN85XzKTmQHx7TGncr6m3fWX0sr7Q9LrzLs7oqOBf2Cy9CGJOExQrT+iWpmn4jxUknvpyZnMdHfEf4GfUjh7s9RXgxw+1The0mgvumouacqrrQZVRmZFP6A6SiuJnQvxbs5LQfewow9zEPQq7egjFCY9vJ0dpZSbwmktuJ1eQNEBitYCdkbnVWSE54EhXt67xJ7upaiPsaZdZiUwxJZ5heLGJKJ5TuD7TYNGbIK6cZvSzDQilqASS2BHLeqhWxzFfOxnDZV1Ot2+wKNNk5MHfr5bBu34E/bjz5Ta8UV+WAYnc36VOTewmg1Rjo6xPXWDQuQOtmXgWAZvInfZDl6nGB1FZIP9gU4XsJTRyZvDrPgHeRG4wK52laJ2jbXARZb9g+TCHnY37ve/Q+f02bSTlPMm5dRNbMtLdXqcpuWjZfmoWePKKyUnsPNhlRVnAj+ncOrz1F7PcJCL0MiYNNbDrjKm8uRMZmT2bKA8+pc0zsek+86OE4iGK7lXnpzJTL+f8vfg93/urV4dCfwJY2M3IXrZUd4AAAAASUVORK5CYII=" alt="An unsharded databases with views of four different shards." width="804" height="536" data-lqip="true"/><img data-loading="true" width="804" height="536" loading="lazy" alt="An unsharded databases with views of four different shards." src="https://cdn.sanity.io/images/599r6htc/localized/654e4ee15b6ee16b9208ad020eb2ae654b34d0a8-2160x1440.png?w=804&amp;h=536&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/654e4ee15b6ee16b9208ad020eb2ae654b34d0a8-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 402w, https://cdn.sanity.io/images/599r6htc/localized/654e4ee15b6ee16b9208ad020eb2ae654b34d0a8-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 603w, https://cdn.sanity.io/images/599r6htc/localized/654e4ee15b6ee16b9208ad020eb2ae654b34d0a8-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format 804w, https://cdn.sanity.io/images/599r6htc/localized/654e4ee15b6ee16b9208ad020eb2ae654b34d0a8-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1206w, https://cdn.sanity.io/images/599r6htc/localized/654e4ee15b6ee16b9208ad020eb2ae654b34d0a8-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1608w"/></p></div><figcaption>By creating multiple views in an unsharded database, we can query the views as if the data was already physically sharded.</figcaption></figure></div><p>Of course, relying on views also introduced added risks. Views add a performance overhead and in some cases could fundamentally change how the Postgres query planner optimizes queries. To validate that approach, we collected a query corpus of sanitized production queries and ran load tests with and without views. We were able to confirm that views would only add a minimal performance overhead in most cases, and less than 10% in the worst cases. We also built out a shadow reads framework which could send all live read traffic through views, comparing the performance and correctness of view versus non-view queries. We were then able to confirm that views were a viable solution with minimal performance impact.</p><h3 id="tackling-our-topology"><a href="#tackling-our-topology">Tackling our topology</a></h3><p>To perform query routing, DBProxy has to understand the topology of our tables and physical databases. Because we had separated the concept of logical versus physical sharding, we needed a way to represent these abstractions within our topology. For example, we need to be able to map a table (users) to its shard key (user_id). Similarly, we needed to be able to map a logical shard ID (123) to the appropriate logical and physical databases. With vertical partitioning, we relied on a simple, hard-coded configuration file that mapped tables to their partition. However, as we moved towards horizontal sharding, we required something more sophisticated. Our topology would change dynamically during shard splits and DBProxy needed to quickly update its state to avoid routing requests to the wrong database. Because every change to topology is backwards compatible, these changes are never in the critical path for our site. We built out a database topology that encapsulated our complex horizontal sharding metadata and could deliver real-time updates in under a second.</p><div><figure><div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACzElEQVQ4jYWT22/TZhiH/T/2itCbMW2MIpCQuJq0TWuK1LV0FErTdEzTxhhS2EmcCjRpO5Ila9eSxKfEPcSJE9tx4qxx3KaFke5BMYUOuODikT7pkx69v1e/V1DcCG8yg3pI/523p/hrc4JUcZxUcYw/5TBr4lmy2UFyueNsZT/HfbyE8zhLQYohKNYsau0aau1blGoUuXwJufRVgFSZIGtMsqJ/zWplkjXjMk+0K6yvzmBkotQyUdz07+wtabSTRTTxF4SiEqOcfUh1bRE9fRPt7jmk2ADSrQHER5+wKo0EMsmZRm5EKJR+wM4k6S5usr9Q4mnCoJdo0UluoIm/IpSXF/D6nwkb/26a+jefURobYGt8AO36Sdb+DgdCuTEdrEEr3aCZzvI8vs1B3Kc37/FfvHMkrGVS7C1YHMQ7PL1v4MeSeDdu4/10G/NeDFGMBlFlZxqlGaGoX8daTrOzVGFvyXyNm85TlGMI1UyK7oJJb75Nd87Bv2fx7GGT5/MuzWQepfBjIOxHVpozKLVraOot9Ox9KrkHAeXsHJvSb8il746E/Qn/nf+HZ49aHMQ9eolt3JT4WtifsB9Zdq4iV8cpGmE2zGE2zTBadRjFGEW2rryKbELch8QRvXgbN/lKOIlUv4rSiCDXJ9Cs89TcD3E7J3D9E9itD9iyz6LYowjllQTbf2iHu6gdYrK7aGBnlpGK37NSOqpNzrhAyR6i5YXY2Qux0w3R9o9htT5Gtb5EKBRvsiXeoZx/8AZ6fo519WdEfTYQZjYuBgV/oofR66fY7rwU+t0Q3s4xnPZHFKwvEOR6FNmapV/wd7CjyPUIOXPqZamrlxHNUfT6GVreILv7x9ndH6TthzDdk6j2MMK7p/cWzbdwLqHZn1JpnKbuDeF4Q9TcU6zb51HqYwhqc4b38v/7bkwjWReRzAso1giqPYJsjiCZY8jOFC8A5ulhgMS77poAAAAASUVORK5CYII=" alt="A topology library that leads to a square (S3) and a cylinder (ETCD)." width="804" height="536" data-lqip="true"/><img data-loading="true" width="804" height="536" loading="lazy" alt="A topology library that leads to a square (S3) and a cylinder (ETCD)." src="https://cdn.sanity.io/images/599r6htc/localized/8db2e5fe21409fc4c47fc77909a0f8f8f33383e6-2160x1440.png?w=804&amp;h=536&amp;q=75&amp;fit=max&amp;auto=format" srcset="https://cdn.sanity.io/images/599r6htc/localized/8db2e5fe21409fc4c47fc77909a0f8f8f33383e6-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.5 402w, https://cdn.sanity.io/images/599r6htc/localized/8db2e5fe21409fc4c47fc77909a0f8f8f33383e6-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=0.75 603w, https://cdn.sanity.io/images/599r6htc/localized/8db2e5fe21409fc4c47fc77909a0f8f8f33383e6-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format 804w, https://cdn.sanity.io/images/599r6htc/localized/8db2e5fe21409fc4c47fc77909a0f8f8f33383e6-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5 1206w, https://cdn.sanity.io/images/599r6htc/localized/8db2e5fe21409fc4c47fc77909a0f8f8f33383e6-2160x1440.png?w=804&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=2 1608w"/></p></div><figcaption></figcaption></figure></div><p>Having a separate logical and physical topology allowed us to also simplify some of our database management. For example, in our non-production environments, we can keep the same logical topology as production, but serve the data from many fewer physical databases. This saves costs and reduces complexity without having too many changes across environments. The topology library also allowed us to enforce invariants across our topology (e.g. every shard ID should be mapped to exactly one physical database) that were critical to maintaining the correctness of our system as we built out horizontal sharding.</p><h3 id="the-physical-sharding-operation"><a href="#the-physical-sharding-operation">The physical sharding operation</a></h3><p>Once a table is ready for sharding, the last step is the physical failover from unsharded to sharded databases. We were able to reuse much of the same logic for horizontal sharding, but there were a few notable differences: Instead of moving data from 1 to 1 database, we were going from 1 to N. We needed to make the failover process resilient to new failure modes where the sharding operation could succeed on only a subset of our databases. Still, many of the riskiest components had already been de-risked during vertical partitioning. We were able to move much faster towards our first physical sharding operation than would have otherwise been possible.</p><h2 id="we-ve-come-a-long-way"><a href="#we-ve-come-a-long-way">We’ve come a long way</a></h2><p>When we started this journey, we knew that horizontal sharding would be a multi-year investment into Figma’s future scalability. We shipped our first horizontally sharded table in September 2023. We successfully failed over with only ten seconds of partial availability on database primaries and no availability impact on replicas. We saw no regressions in latency or availability after sharding. Since then we’ve been tackling relatively simple shards from our highest write rate databases. This year, we’ll shard increasingly complex databases, which have dozens of tables and thousands of code call-sites.</p><p>To remove our last scaling limits and truly take flight, we will need to horizontally shard every table at Figma. A fully horizontally sharded world will bring many other benefits: improved reliability, cost savings, and developer velocity. Along the way, we’ll need to solve all of these problems:</p><ul><li>Support for horizontally sharded schema updates</li><li>Globally unique ID generation for horizontally sharded primary keys</li><li>Atomic cross-shard transactions for business critical use-cases</li><li>Distributed globally unique indexes (currently unique indexes are only supported on indexes including the sharding key)</li><li>An ORM model that increases developer velocity and is seamlessly compatible with horizontal sharding</li><li>Fully automated reshard operations that can run shard splits with the click of a button</li></ul><p>Once we’ve bought ourselves sufficient runway, we will also reassess our original approach of in-house RDS horizontal sharding. We started this journey 18 months ago with extremely tight timeline pressure. NewSQL stores have continued to evolve and mature. We will finally have bandwidth to reevaluate the tradeoffs of continuing down our current path versus switching to an open source or managed solution.</p><p>We’ve made a lot of exciting progress on our horizontal sharding journey, but our challenges are just beginning<em>. </em>Stay tuned for more deep dives into different parts of our horizontal sharding stack. If you’re interested in working on projects like this, please reach out! We’re <a href="https://www.jakef.science/careers/">hiring</a>.</p><svg xmlns="http://www.w3.org/2000/svg" width="93" height="13" fill="none"><circle cx="6.5" cy="6.5" r="6.5" fill="currentColor"></circle><path fill="currentColor" d="M39.834 0h13v13h-13zM86.5 0 93 13H80l6.5-13z"></path></svg><p>We couldn’t have shipped horizontal sharding without these current and former databases team members: Anna Saplitski, David Harju, Dinesh Garg, Dylan Visher, Erica Kong, Gordon Yoon, Gustavo Mezerhane, Isemi Ekundayo, Josh Bancroft, Junhson Jean-Baptiste, Kevin Lin, Langston Dziko, Maciej Szeszko, Mehant Baid, Ping-Min Lin, Rafael Chacon Vivas, Roman Hernandez, Tim Goh, Tim Liang, and Yiming Li.</p><p>We’d also like to thank all of our cross-functional partner teams, especially Amy Winkler, Braden Walker, Esther Wang, Kat Busch, Leslie Tu, Lin Xu, Michael Andrews, Raghav Anand, and Yichao Zhao.</p></div></div></div></div>
  </body>
</html>
