<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mcilloni.ovh/2023/07/23/unicode-is-hard/">Original</a>
    <h1>Unicode is harder than you think</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
  
  <p><span>23 Jul 2023</span></p><p>Reading the excellent article by JeanHeyd Meneide on <a href="https://thephd.dev/the-c-c++-rust-string-text-encoding-api-landscape">how broken string encoding in C/C++ is</a> made me realise that Unicode is a topic that is often overlooked by a large number of developers. In my experience, there‚Äôs a lot of confusion and wrong expectations on what Unicode is, and what best practices to follow when dealing with strings that may contain characters outside of the ASCII range.</p>

<p>This article attempts to briefly summarise and clarify some of the most common misconceptions I‚Äôve seen people struggle with, and some of the pitfalls that tend to recur in codebases that have to deal with non-ASCII text.</p>

<h2 id="the-convenience-of-ascii">The convenience of ASCII</h2>

<p>Text is usually represented and stored as a sequence of numerical values in binary form. Wherever its source is, to be represented in a way the user can understand it needs to be decoded from its binary representation, as specified by a given <strong>character encoding</strong>.</p>

<p>One such example of this is ASCII, the US-centric standard which has been for decades the de-facto way to represent characters and symbols in C and UNIX. ASCII is a 7-bit encoding, which means that it can represent up to 128 different characters. The first 32 characters are control characters, which are not printable, and the remaining 96 are printable characters, which include the 26 letters of the English alphabet, the 10 digits, and a few symbols:</p>

<div><div><pre><code>Dec Hex    Dec Hex    Dec Hex  Dec Hex  Dec Hex  Dec Hex   Dec Hex   Dec Hex  
  0 00 NUL  16 10 DLE  32 20    48 30 0  64 40 @  80 50 P   96 60 `  112 70 p
  1 01 SOH  17 11 DC1  33 21 !  49 31 1  65 41 A  81 51 Q   97 61 a  113 71 q
  2 02 STX  18 12 DC2  34 22 &#34;  50 32 2  66 42 B  82 52 R   98 62 b  114 72 r
  3 03 ETX  19 13 DC3  35 23 #  51 33 3  67 43 C  83 53 S   99 63 c  115 73 s
  4 04 EOT  20 14 DC4  36 24 $  52 34 4  68 44 D  84 54 T  100 64 d  116 74 t
  5 05 ENQ  21 15 NAK  37 25 %  53 35 5  69 45 E  85 55 U  101 65 e  117 75 u
  6 06 ACK  22 16 SYN  38 26 &amp;  54 36 6  70 46 F  86 56 V  102 66 f  118 76 v
  7 07 BEL  23 17 ETB  39 27 &#39;  55 37 7  71 47 G  87 57 W  103 67 g  119 77 w
  8 08 BS   24 18 CAN  40 28 (  56 38 8  72 48 H  88 58 X  104 68 h  120 78 x
  9 09 HT   25 19 EM   41 29 )  57 39 9  73 49 I  89 59 Y  105 69 i  121 79 y
 10 0A LF   26 1A SUB  42 2A *  58 3A :  74 4A J  90 5A Z  106 6A j  122 7A z
 11 0B VT   27 1B ESC  43 2B +  59 3B ;  75 4B K  91 5B [  107 6B k  123 7B {
 12 0C FF   28 1C FS   44 2C ,  60 3C &lt;  76 4C L  92 5C \  108 6C l  124 7C |
 13 0D CR   29 1D GS   45 2D -  61 3D =  77 4D M  93 5D ]  109 6D m  125 7D }
 14 0E SO   30 1E RS   46 2E .  62 3E &gt;  78 4E N  94 5E ^  110 6E n  126 7E ~
 15 0F SI   31 1F US   47 2F /  63 3F ?  79 4F O  95 5F _  111 6F o  127 7F DEL
</code></pre></div></div>

<p>This table defines a two-way transformation, in jargon a <strong>charset</strong>, which maps a certain sequence of bits (representing a number) to a given character, and vice versa. This can be easily seen by dumping some text as binary:</p>

<div><div><pre><code><span>$ </span><span>echo</span> <span>-n</span> Cat! | xxd
00000000: 4361 7421                                Cat!
</code></pre></div></div>

<p>The first column represents the binary representation of the input string ‚ÄúCat!‚Äù in hexadecimal form. Each character is mapped into a single byte (represented here as two hexadecimal digits):</p>

<ul>
  <li><code>43</code> is the hexadecimal representation of the ASCII character <code>C</code>;</li>
  <li><code>61</code> is the hexadecimal representation of the ASCII character <code>a</code>;</li>
  <li><code>74</code> is the hexadecimal representation of the ASCII character <code>t</code>;</li>
  <li><code>21</code> is the hexadecimal representation of the ASCII character <code>!</code>.</li>
</ul>

<p>This simple set of characters was for decades considered more than enough by most of the English-speaking world, which was where the vast majority of computer early computer users and pioneers came from.</p>

<p>An added benefit of ASCII is that it is a <strong>fixed-width encoding</strong>: each character is always represented <em>univocally</em> by the same number of bits, that in turn always represent the same number.</p>

<p>This leads to some very convenient ergonomics when handling strings in C:</p>

<div><div><pre><code><span>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
</span>
<span>int</span> <span>main</span><span>(</span><span>const</span> <span>int</span> <span>argc</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>argv</span><span>[</span><span>const</span><span>])</span> <span>{</span>
    <span>// converts all arguments to uppercase</span>
    <span>for</span> <span>(</span><span>const</span> <span>char</span> <span>*</span><span>const</span> <span>*</span><span>arg</span> <span>=</span> <span>argv</span> <span>+</span> <span>1</span><span>;</span> <span>*</span><span>arg</span><span>;</span> <span>++</span><span>arg</span><span>)</span> <span>{</span>
        <span>// iterate over each character in the string, and print its uppercase</span>
        <span>for</span> <span>(</span><span>const</span> <span>char</span> <span>*</span><span>it</span> <span>=</span> <span>*</span><span>arg</span><span>;</span> <span>*</span><span>it</span><span>;</span> <span>++</span><span>it</span><span>)</span> <span>{</span>
            <span>putchar</span><span>(</span><span>toupper</span><span>(</span><span>*</span><span>it</span><span>));</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>*</span><span>(</span><span>arg</span> <span>+</span> <span>1</span><span>))</span> <span>{</span>
            <span>putchar</span><span>(</span><span>&#39; &#39;</span><span>);</span>
        <span>}</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>argc</span> <span>&gt;</span> <span>1</span><span>)</span> <span>{</span>
        <span>putchar</span><span>(</span><span>&#39;\n&#39;</span><span>);</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The example above assumes, like a large amount of code written in the last few decades, that the C basic type <code>char</code> represents a byte-sized ASCII character. This assumption minimises the mental and runtime overhead of handling text, as strings can be treated as arrays of characters belonging to a very minimal set. Because of this, ASCII strings can be iterated on, addressed individually and transformed or inspected using simple, cheap operations such as <code>isalpha</code> or <code>toupper</code>.</p>

<h2 id="the-world-outside">The world outside</h2>

<p>However, as computers started to spread worldwide it became clear that it was necessary to devise character sets capable to represent all the characters required in a given locale. For instance, Spanish needs the letter <code>√±</code>, Japan needs the <code>¬•</code> symbol and support for Kana and Kanji, and so on.</p>

<p>All of this led to a massive proliferation of different character encodings, usually tied to a given language, area or locale. These varied from 8-bit encodings, which either extended ASCII by using its unused eighth bit (like <strong>ISO-8859-1</strong>) or completely replaced its character set (like <strong>KOI8-R</strong>), to multi-byte encodings for Asian languages with thousands of characters like <strong>Shift-JIS</strong> and <strong>Big5</strong>.</p>

<p>This turned into a huge headache for both developers and users, as it was necessary to know (or deduce via hacky heuristics) which encoding was used for a given piece of text, for instance when receiving a file from the Internet, which was becoming more and more common thanks to email, IRC and the World Wide Web.</p>

<p>Most crucially, multibyte encodings (a necessity for Asian characters) meant that <em>the assumption ‚Äúone char = one byte‚Äù didn‚Äôt hold anymore</em>, with the small side effect of breaking all code in existence at the time.</p>

<p>For a while, the most common solution was to use a single encoding for each language, and then hope for the best. This often led to garbled text (who hasn‚Äôt seen the infamous <code>ÔøΩ</code> character at least once), so much so that a specific term was coined to describe it - <em>‚Äúmojibake‚Äù</em>, from the Japanese <em>‚ÄúÊñáÂ≠óÂåñ„Åë‚Äù _(‚Äúcharacter transformation‚Äù)</em>.</p>

<p><img src="https://mcilloni.ovh/public/mojibake.jpg" alt="KOI8-R text mistakenly written on an envelope as ISO-8859-1 text" title="I guess they thought it was actual Russian text"/></p>

<p>In general, for a long time using a non-English locale meant that you had to contend with broken third (often first) party software, patchy support for certain characters, and switching encodings on the fly depending on the context. The inconvenience was such that it was common for non-Latin Internet users to converse in their native languages with the Latin alphabet, using impromptu transliterations if necessary. A prime example of this was the Arabic chat alphabet widespread among Arabic-speaking netizens in the 90‚Äôs and 00‚Äôs <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<h2 id="unicode">Unicode</h2>

<p>It was clear to most people back then that the situation as it was untenable, so much so that as early as the late ‚Äô80s people started proposing a universal character encoding capable to cover all modern scripts and symbols in use.</p>

<p>This led to the creation of <strong>Unicode</strong>, whose first version was standardised in 1991 after a few years of joint development led by Xerox and Apple (among others). Unicode main design goal was, and still is, to define a universal <strong>character set</strong> capable to represent all the aforementioned characters, alongside a <strong>character encoding</strong> capable of uniformly representing them all.</p>

<p>In Unicode, every character, or more properly <strong>code point</strong>, is represented by a unique number, belonging to a specific <strong>Unicode block</strong>. Crucially, the first block of Unicode (‚ÄúBasic Latin‚Äù) corresponds point per point to ASCII, so that <em>all ASCII characters correspond to equivalent Unicode codepoints</em>.</p>

<p>Code points are usually represented with the syntax <code>U+XXXX</code>, where <code>XXXX</code> is the hexadecimal representation of the code point. For instance, the code point for the <code>A</code> character is <code>U+0041</code>, while the code point for the <code>√±</code> character is <code>U+00F1</code>.</p>

<p>Unicode 1.0 covered 26 scripts and 7,161 characters, covering most of the world‚Äôs languages and lots of commonplace symbols and glyphs.</p>

<h2 id="ucs-2-or-how-unicode-made-everything-worse">UCS-2, or <em>‚Äúhow Unicode made everything worse‚Äù</em></h2>

<p>Alongside the first Unicode specification, which defined the character set, two<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup> new character encodings, called <strong>UCS-2</strong> and <strong>UCS-4</strong> (which came a bit later), were also introduced. UCS-2 was the original Unicode encoding, and it‚Äôs an extension of ASCII to 16 bits, representing what Unicode called the <strong>Basic Multilingual Plane</strong> (<em>‚ÄúBMP‚Äù</em>); UCS-4 is the same but with 32-bit values. Both were fixed-width encodings, using multiple bytes to represent each single character in a string.</p>

<p>In particular, UCS-2‚Äôs maximum range of 65,536 possible values was good enough to cover the entire Unicode 1.0 set of characters. The storage savings compared with UCS-4 were quite enticing, also - while ‚Äô90s machines weren‚Äôt as constrained as the ones that came before, representing basic Latin characters with 4 bytes was still seen as an egregious waste.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup></p>

<p>Thus, 16 bits quickly became the standard size for the <code>wchar_t</code> type recently added by the C89 standard to support wide characters for encodings like Shift-JIS. Sure, switching from <code>char</code> to <code>wchar_t</code> required developers to rewrite all code to use wide characters and wide functions, but a bit of <code>sed</code> was a small price to pay for the ability to resolve internationalization, right?</p>

<p>The C library had also introduced, alongside the new wide char type, a set of functions and types to handle <code>wchar_t</code>, wide strings and (poorly designed) functions locale support, including support for multibyte encodings. Some vendors, like Microsoft, even devised tricks to make it possible to optionally switch from legacy 8-bit codepages to UCS-2 by using ad-hoc types like <code>TCHAR</code> and <code>LPTSTR</code> in place of specific character types.</p>

<p>All of that said, the code snippet above could be rewritten on Win32 as the following:</p>

<div><div><pre><code><span>#include &lt;ctype.h&gt;
#include &lt;tchar.h&gt;
</span>
<span>#if !defined(_UNICODE) &amp;&amp; !defined(UNICODE)
#   include &lt;stdio.h&gt;
#endif
</span>
<span>int</span> <span>_tmain</span><span>(</span><span>const</span> <span>int</span> <span>argc</span><span>,</span> <span>const</span> <span>TCHAR</span> <span>*</span><span>argv</span><span>[</span><span>const</span><span>])</span> <span>{</span>
    <span>// converts all arguments to uppercase</span>
    <span>for</span> <span>(</span><span>const</span> <span>TCHAR</span> <span>*</span><span>const</span> <span>*</span><span>arg</span> <span>=</span> <span>argv</span> <span>+</span> <span>1</span><span>;</span> <span>*</span><span>arg</span><span>;</span> <span>++</span><span>arg</span><span>)</span> <span>{</span>
        <span>// iterate over each character in the string, and print its uppercase</span>
        <span>for</span> <span>(</span><span>const</span> <span>TCHAR</span> <span>*</span><span>it</span> <span>=</span> <span>*</span><span>arg</span><span>;</span> <span>*</span><span>it</span><span>;</span> <span>++</span><span>it</span><span>)</span> <span>{</span>
            <span>_puttchar</span><span>(</span><span>_totupper</span><span>(</span><span>*</span><span>it</span><span>));</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>*</span><span>(</span><span>arg</span> <span>+</span> <span>1</span><span>))</span> <span>{</span>
            <span>_puttchar</span><span>(</span><span>_T</span><span>(</span><span>&#39; &#39;</span><span>));</span>
        <span>}</span>
    <span>}</span>

    <span>_puttchar</span><span>(</span><span>_T</span><span>(</span><span>&#39;\n&#39;</span><span>));</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Neat, right? This was indeed considered so convenient that developers jumped on the UCS-2 bandwagon in droves, finally glad the encoding mess was over.</p>

<p>16-bit Unicode was indeed a huge success, as attested by the number of applications and libraries that adopted it during the ‚Äô90s:</p>

<ul>
  <li>Windows NT, 2000 and XP used UCS-2 as their internal character encoding, and exposed it to developers via the Win32 API;</li>
  <li>Apple‚Äôs Cocoa, too, used UCS-2 as its internal character encoding for <code>NSString</code> and <code>unichar</code>;</li>
  <li>Sun‚Äôs Java used UCS-2 as its internal character encoding for all strings, even going as far as to define its String type as an array of 16-bit characters;</li>
  <li>Javascript, too, didn‚Äôt want to be left behind, and basically defined its String type the same way Java did;</li>
  <li>Qt, the popular C++ GUI framework, used UCS-2 as its internal character encoding, and exposed it to developers via the QString class;</li>
  <li>Unreal Engine just copied the WinAPI approach and used UCS-2 as its internal character encoding <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">4</a></sup></li>
</ul>

<p>and many more. Every once in a while, I still find out that some piece of code I frequently use is still using UCS-2 (or UTF-16, see later) internally. In general, every time you read something along the lines of ‚ÄúUnicode support‚Äù without any reference to UTF, there‚Äôs an almost 100% chance that it actually means ‚ÄúUCS-2‚Äù, or some borked variant of it.</p>

<h2 id="combining-characters">Combining characters</h2>

<p>Unicode supported since its first release the concept of <strong>combining characters</strong> (later better defined as <strong>grapheme clusters</strong>), which are clusters of characters meant to be combined with other characters in order to form a single unit by text processing tools.</p>

<p>In Unicode jargon, these are called <strong>composite sequences</strong> and were designed to allow Unicode to represent scripts like Arabic, which uses a lot of diacritics and other combining characters, without having to define a separate code point for each possible combination.</p>

<p>This could have been in principle a neat idea - grapheme clusters allow Unicode to save a massive amount of code points from being pointlessly wasted for easily combinable characters (just think about South Asian languages or Hangul). The real issue was that the Consortium, anxious to help with the transition to Unicode, did not want to drop support for dedicated codepoints for ‚Äúpreassembled‚Äù characters such as <code>√®</code> and <code>√±</code>, which were historically supported by the various extended ASCII encodings.</p>

<p>This led to Unicode supporting <strong>precomposed characters</strong>, which are codepoints that stand for <em>a glyph that also be represented using a grapheme cluster</em>. An example of this is the Extended Latin characters with accents or diacritics, which can all be represented by combining the base Latin character with the corresponding modifier, or by using a single code point.</p>

<p>For instance, let‚Äôs try testing out a few things with Python‚Äôs <code>unicodedata</code> and two seemingly identical strings, ‚Äúca√±a‚Äù and ‚ÄúcanÃÉa‚Äù (notice how they look the same):</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>import</span> <span>unicodedata</span>
<span>&gt;&gt;&gt;</span> <span>a</span><span>,</span> <span>b</span> <span>=</span> <span>&#34;ca√±a&#34;</span><span>,</span> <span>&#34;canÃÉa&#34;</span>
<span>&gt;&gt;&gt;</span> <span>a</span> <span>==</span> <span>b</span>
<span>False</span>
</code></pre></div></div>

<p>Uh?</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>a</span><span>,</span> <span>b</span>
<span>(</span><span>&#39;ca√±a&#39;</span><span>,</span> <span>&#39;canÃÉa&#39;</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>len</span><span>(</span><span>a</span><span>),</span> <span>len</span><span>(</span><span>b</span><span>)</span>
<span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span>
</code></pre></div></div>

<p>The two strings are visually identical - they are rendered the same by our Unicode-enabled terminal - and yet, they do not evaluate as equal, and the <code>len()</code> function returns different lengths. This is because the <code>√±</code> in the second string is a grapheme cluster composed of the <code>U+006E LATIN SMALL LETTER N</code> and <code>U+0303 COMBINING TILDE</code> character, combined by terminal into a single character.</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>list</span><span>(</span><span>a</span><span>),</span> <span>list</span><span>(</span><span>b</span><span>)</span>
<span>([</span><span>&#39;c&#39;</span><span>,</span> <span>&#39;a&#39;</span><span>,</span> <span>&#39;√±&#39;</span><span>,</span> <span>&#39;a&#39;</span><span>],</span> <span>[</span><span>&#39;c&#39;</span><span>,</span> <span>&#39;a&#39;</span><span>,</span> <span>&#39;n&#39;</span><span>,</span> <span>&#39;ÃÉ&#39;</span><span>,</span> <span>&#39;a&#39;</span><span>])</span>
<span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>a</span><span>]</span>
<span>[</span><span>&#39;LATIN SMALL LETTER C&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER A&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER N WITH TILDE&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER A&#39;</span><span>]</span>
<span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>b</span><span>]</span>
<span>[</span><span>&#39;LATIN SMALL LETTER C&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER A&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER N&#39;</span><span>,</span> <span>&#39;COMBINING TILDE&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER A&#39;</span><span>]</span>
</code></pre></div></div>

<p>This is obviously a big departure from the ‚Äústrings are just arrays of characters‚Äù model the average developer is used to:</p>

<ol>
  <li>Trivial comparisons like <code>a == b</code> or <code>strcmp(a, b)</code> <strong>are no longer trivial</strong>. A Unicode-aware algorithm must to be implemented, in order to actually compare the strings as they are rendered or printed;</li>
  <li>Random access to characters is no longer safe, because a single glyph can span over multiple code points, and thus over multiple array elements;</li>
</ol>

<h2 id="640k-16-bits-ought-to-be-enough-for-everyone"><em>‚Äù<del>640k</del> 16 bits ought to be enough for everyone‚Äù</em></h2>

<p>Anyone with any degree of familiarity with Asian languages will have noticed that 7,161 characters are way too small a number to include the tens of thousands of Chinese characters in existence. This is without counting minor and historical scripts, and the thousands of symbols and glyphs used in mathematics, music, and other fields.</p>

<p>In the years following 1991, the Unicode character set was thus expanded with tens of thousands of new characters, and it become quickly apparent that UCS-2 was soon going to run out of 16-bit code points.^6]</p>

<p>To circumvent this issue, the Unicode Consortium decided to expand the character set from 16 to 21 bits. This was a huge breaking change that basically meant <strong>obsoleting UCS-2</strong> (and thus breaking most software designed in the ‚Äô90s), just a few years after its introduction and widespread adoption.</p>

<p>While UCS-2 was still capable of representing anything inside the BMP, it became clear a new encoding was needed to support the growing set of characters in the UCS.</p>

<h2 id="utf">UTF</h2>

<p>The acronym <em>‚ÄúUTF‚Äù</em> stands for <em>‚ÄúUnicode Transformation Format‚Äù</em>, and represents a family of <strong>variable-width encodings</strong> capable to represent the whole Unicode character set, up to its hypothetical supported potential 2¬≤¬π characters. Compared to UCS, UTF encodings specify how a given stream of bytes can be converted into a sequence of Unicode code points, and vice versa (i.e., <em>‚Äútransformed‚Äù</em>).</p>

<p>Compared to a fixed-width encoding like UCS-2, a variable-width character encoding can employ a variable number of code units to encode each character. This bypasses the ‚Äúone code unit per character‚Äù limitation of fixed-width encodings, and allows representing a much larger number of characters - potentially, infinite, depending on how many <em>‚Äúlead units‚Äù</em> are reserved as markers for multiunit sequences.</p>

<p>Excluding the dead-on-arrival UTF-1, there are 4 UTF encodings in use today:</p>

<ul>
  <li>UTF-8, a variable-width encoding that uses 1-byte characters;</li>
  <li>UTF-16, a variable-width encoding that uses 2-byte characters;</li>
  <li>UTF-32, a variable-width encoding that uses 4-byte characters;</li>
  <li>UTF-EBCDIC, a variable-width encoding that uses 1-byte characters, designed to be used on IBM‚Äôs EBCDIC systems (note: I think it‚Äôs safe to argue that using EBCDIC in 2023 edges very close to being a felony).</li>
</ul>

<h3 id="utf-16">UTF-16</h3>

<p>To salvage the consistent investments made to support UCS-2, the Unicode Consortium created UTF-16 as a backward-compatible extension of UCS-2. When some piece of software advertises ‚Äúsupport for UNICODE‚Äù, it almost always means that some software supported UCS-2 and switched to UTF-16 sometimes later. <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">5</a></sup></p>

<p>Like UCS-2, UTF-16 can represent the entirety of the BMP using a single 16-bit value. Every codepoint above <code>U+FFFF</code> is represented using a pair of 16-bit values, called <strong>surrogate pairs</strong>. The first value (the <em>‚Äúhigh surrogate‚Äù</em>) is always a value in the range <code>U+D800</code> to <code>U+DBFF</code>, while the second value (the <em>‚Äúlow surrogate‚Äù</em>) is always a value in the range <code>U+DC00</code> to <code>U+DFFF</code>.</p>

<p>This, in practice, means that the range reserved for BMP characters never overlaps with surrogates, making it trivial to distinguish between a single 16-bit codepoint and a surrogate pair, which makes UTF-16 <a href="https://en.wikipedia.org/wiki/Self-synchronizing_code"><em>self-synchronizing</em></a> on 16-bit values.</p>

<p>Emojis are an example of characters that lie outside of the BMP; as such, they are always represented using surrogate pairs.
For instance, the character <code>U+1F600</code> (üòÄ) is represented in UTF-16 by the surrogate pair <code>[0xD83D, 0xDE00]</code>:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span># pack the surrogate pair into bytes by hand, and then decode it as UTF-16
</span><span>&gt;&gt;&gt;</span> <span>bys</span> <span>=</span> <span>[</span><span>b</span> <span>for</span> <span>cp</span> <span>in</span> <span>(</span><span>0xD83D</span><span>,</span> <span>0xDE00</span><span>)</span> <span>for</span> <span>b</span> <span>in</span> <span>list</span><span>(</span><span>cp</span><span>.</span><span>to_bytes</span><span>(</span><span>2</span><span>,</span><span>&#39;little&#39;</span><span>))]</span>
<span>&gt;&gt;&gt;</span> <span>bys</span>
<span>[</span><span>61</span><span>,</span> <span>216</span><span>,</span> <span>0</span><span>,</span> <span>222</span><span>]</span>
<span>&gt;&gt;&gt;</span> <span>bytes</span><span>(</span><span>bys</span><span>).</span><span>decode</span><span>(</span><span>&#39;utf-16le&#39;</span><span>)</span>
<span>&#39;üòÄ&#39;</span>
</code></pre></div></div>

<h3 id="the-bom">The BOM</h3>

<p>Notice that in the example above I had to specify an endianness for the bytes (little-endian in this case) by writing <code>&#34;utf-16le&#34;</code> instead of just <code>&#34;utf-16&#34;</code>. This is due to the fact that <em>UTF-16 is actually two different (incompatible) encodings</em>, UTF-16LE and UTF-16BE, which differ in the endianness of the single codepoints. <sup id="fnref:8" role="doc-noteref"><a href="#fn:8" rel="footnote">6</a></sup></p>

<p>The standard calls for UTF-16 streams to start with a <strong>Byte Order Mark</strong> (BOM), represented by the special codepoint <code>U+FEFF</code>. Reading <code>0xFEFF</code> indicates that the endianness of a text block is the same as the endianness of the decoding system; reading those bytes flipped, as <code>0xFFFE</code>, indicates opposite endianness instead.</p>

<p>As an example, let‚Äôs assume a big-endian system has generated the sequence <code>[0xFE, 0xFF, 0x61, 0x00]</code>. </p>

<ul>
  <li>A <em>big-endian</em> system will decode <code>U+FEFF</code>, which is the BOM, and thus will assume the text is in UTF-16 in its same byte endianness (BE);</li>
  <li>A <em>little-endian</em> system will instead read <code>U+FFEE</code>, which is still the BOM but flipped, so it will assume the text is in the opposite endianness (BE in the case of an LE system).</li>
</ul>

<p>In both cases, the BOM allows the following character to be correctly parsed as <code>U+0061</code> (a.k.a. <code>a</code>).</p>

<p>If no BOM is detected, then most decoders will do as they please (despite the standard recommending to assume UTF-16BE), which most of the time means assuming the endianness of the system:</p>

<div><div><pre><code><span>&gt;&gt;</span> <span>import</span> <span>sys</span>
<span>&gt;&gt;&gt;</span> <span>sys</span><span>.</span><span>byteorder</span>
<span>&#39;little&#39;</span>
<span>&gt;&gt;&gt;</span> <span># BOM read as 0xFEFF and system is LE -&gt; will assume UTF-16LE
</span><span>&gt;&gt;&gt;</span> <span>bytes</span><span>([</span><span>0xFF</span><span>,</span> <span>0xFE</span><span>,</span> <span>0x61</span><span>,</span> <span>0x00</span><span>,</span> <span>0x62</span><span>,</span> <span>0x00</span><span>,</span> <span>0x63</span><span>,</span> <span>0x00</span><span>]).</span><span>decode</span><span>(</span><span>&#39;utf-16&#39;</span><span>)</span> 
<span>&#39;abc&#39;</span>
<span>&gt;&gt;&gt;</span> <span># BOM read as 0xFFFE and system is LE -&gt; will assume UTF-16BE
</span><span>&gt;&gt;&gt;</span> <span>bytes</span><span>([</span><span>0xFE</span><span>,</span> <span>0xFF</span><span>,</span> <span>0x00</span><span>,</span> <span>0x61</span><span>,</span> <span>0x00</span><span>,</span> <span>0x62</span><span>,</span> <span>0x00</span><span>,</span> <span>0x63</span><span>]).</span><span>decode</span><span>(</span><span>&#39;utf-16&#39;</span><span>)</span>
<span>&#39;abc&#39;</span>
<span>&gt;&gt;&gt;</span> <span># no BOM, text is BE and system is LE -&gt; will assume UTF-16LE and read garbage
</span><span>&gt;&gt;&gt;</span> <span>bytes</span><span>([</span><span>0x00</span><span>,</span> <span>0x61</span><span>,</span> <span>0x00</span><span>,</span> <span>0x62</span><span>,</span> <span>0x00</span><span>,</span> <span>0x63</span><span>]).</span><span>decode</span><span>(</span><span>&#39;utf-16&#39;</span><span>)</span>
<span>&#39;ÊÑÄÊàÄÊåÄ&#39;</span>
<span>&gt;&gt;&gt;</span> <span># no BOM, text is BE and UTF-16BE is explicitly specified -&gt; will read the text correctly
</span><span>&gt;&gt;&gt;</span> <span>bytes</span><span>([</span><span>0x00</span><span>,</span> <span>0x61</span><span>,</span> <span>0x00</span><span>,</span> <span>0x62</span><span>,</span> <span>0x00</span><span>,</span> <span>0x63</span><span>]).</span><span>decode</span><span>(</span><span>&#39;utf-16be&#39;</span><span>)</span>
<span>&#39;abc&#39;</span>
</code></pre></div></div>

<p>Some decoders may probe the first few codepoints for zeroes to detect the endianness of the stream, which is in general not an amazing idea. As a rule of thumb, UTF-16 text should <strong>never rely on automated endianness detection</strong>, and thus either always start with a BOM or assume a fixed endianness value (which in the vast majority of cases is UTF-16LE, which is what Windows does).</p>

<h3 id="utf-32">UTF-32</h3>
<p>Just as UTF-16 is an extension of UCS-2, <strong>UTF-32</strong> is an evolution of UCS-4. Compared to all other UTF encodings, UTF-32 is by far the simplest, because like its predecessor it is a <strong>fixed-width encoding</strong>.</p>

<p>The major difference between UCS-4 and UTF-32 is that the latter has been limited down 21 bits, from its maximum of 31 bits (UCS-4 was signed). This has been done to maintain compatibility with UTF-16, which is constrained by its design to only represent codepoints up to <code>U+10FFFF</code>.</p>

<p>While UTF-32 seems convenient at first, it is not in practice all that useful, for quite a few reasons:</p>

<ol>
  <li>
    <p>UTF-32 is outrageously wasteful because all characters, including those belonging to the ASCII plane, are represented using 4 bytes. Given that the vast majority of text uses ASCII characters for markup, content or both, UTF-32 encoded text tends to be mostly comprised of just a few significant bytes scattered in between a sea of zeroes:</p>

    <div><div><pre><code> <span>&gt;&gt;&gt;</span> <span># UTF-32BE encoded text with BOM
</span> <span>&gt;&gt;&gt;</span> <span>bytes</span><span>([</span><span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0xFE</span><span>,</span> <span>0xFF</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x61</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x62</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x63</span><span>]).</span><span>decode</span><span>(</span><span>&#39;utf-32&#39;</span><span>)</span>
 <span>&#39;abc&#39;</span>
 <span>&gt;&gt;&gt;</span> <span># The same, but in UTF-16BE
</span> <span>&gt;&gt;&gt;</span> <span>bytes</span><span>([</span><span>0xFE</span><span>,</span> <span>0xFF</span><span>,</span> <span>0x00</span><span>,</span> <span>0x61</span><span>,</span> <span>0x00</span><span>,</span> <span>0x62</span><span>,</span> <span>0x00</span><span>,</span> <span>0x63</span><span>]).</span><span>decode</span><span>(</span><span>&#39;utf-16&#39;</span><span>)</span>
 <span>&#39;abc&#39;</span>
 <span>&gt;&gt;&gt;</span> <span># The same, but in ASCII
</span> <span>&gt;&gt;&gt;</span> <span>bytes</span><span>([</span><span>0x61</span><span>,</span> <span>0x62</span><span>,</span> <span>0x63</span><span>]).</span><span>decode</span><span>(</span><span>&#39;ascii&#39;</span><span>)</span>
 <span>&#39;abc&#39;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>No major OS or software uses UTF-32 as its internal encoding as far as I‚Äôm aware of. While locales in modern UNIX systems usually define <code>wchar_t</code> as representing UTF-32 codepoints, they are seldom used due to most software in existence assuming that <code>wchar_t</code> is 16-bit wide.</p>

    <p>On Linux, for instance:</p>

    <div><div><pre><code> <span>#include &lt;locale.h&gt;
</span> <span>#include &lt;stdio.h&gt;
</span> <span>#include &lt;wchar.h&gt;
</span>
 <span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
     <span>// one of the bajilion ways to set a Unicode locale - we&#39;ll talk UTF-8 later</span>
     <span>setlocale</span><span>(</span><span>LC_ALL</span><span>,</span> <span>&#34;en_US.UTF-8&#34;</span><span>);</span> 
     <span>const</span> <span>wchar_t</span> <span>s</span><span>[]</span> <span>=</span> <span>L&#34;abc&#34;</span><span>;</span>

     <span>printf</span><span>(</span><span>&#34;sizeof(wchar_t) == %zu</span><span>\n</span><span>&#34;</span><span>,</span> <span>sizeof</span> <span>*</span><span>s</span><span>);</span> <span>// 4</span>
     <span>printf</span><span>(</span><span>&#34;wcslen(s) == %zu</span><span>\n</span><span>&#34;</span><span>,</span> <span>wcslen</span><span>(</span><span>s</span><span>));</span> <span>// 3</span>
     <span>printf</span><span>(</span><span>&#34;bytes in s == %zu</span><span>\n</span><span>&#34;</span><span>,</span> <span>sizeof</span> <span>s</span><span>);</span> <span>// 16 (12 + 4, due to the null terminator)</span>

     <span>return</span> <span>0</span><span>;</span>    
 <span>}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>The fact UTF-32 is a fixed-width encoding is only marginally useful, due to <em>grapheme clusters still being a thing</em>. This means that the equivalence between codepoints and rendered glyphs is still not 1:1, just like in UCS-4:</p>

    <div><div><pre><code> <span>// GNU/Linux, x86_64</span>

 <span>#include &lt;locale.h&gt;
</span> <span>#include &lt;stdio.h&gt;
</span> <span>#include &lt;wchar.h&gt;
</span>
 <span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
     <span>setlocale</span><span>(</span><span>LC_ALL</span><span>,</span> <span>&#34;en_US.UTF-8&#34;</span><span>);</span>

     <span>// &#34;canÃÉa&#34;, with &#39;nÃÉ&#39; written as the grapheme cluster &#34;n&#34; + &#34;combining tilde&#34;</span>
     <span>const</span> <span>wchar_t</span> <span>string</span><span>[]</span> <span>=</span> <span>L&#34;can\u0303a&#34;</span><span>;</span>

     <span>wprintf</span><span>(</span><span>L&#34;`%ls`</span><span>\n</span><span>&#34;</span><span>,</span> <span>string</span><span>);</span> <span>// prints &#34;canÃÉa&#34; as 4 glyphs</span>
     <span>wprintf</span><span>(</span><span>L&#34;`%ls` is %zu codepoints long</span><span>\n</span><span>&#34;</span><span>,</span> <span>string</span><span>,</span> <span>wcslen</span><span>(</span><span>string</span><span>));</span> <span>// 5 codepoints</span>
     <span>wprintf</span><span>(</span><span>L&#34;`%ls` is %zu bytes long</span><span>\n</span><span>&#34;</span><span>,</span> <span>string</span><span>,</span> <span>sizeof</span> <span>string</span><span>);</span> <span>// 24 bytes (5 UCS-4 codepoints + null)</span>

     <span>// this other string is the same as the previous one, but with the precomposed &#34;nÃÉ&#34; character</span>
     <span>const</span> <span>wchar_t</span> <span>probe</span><span>[]</span> <span>=</span> <span>L&#34;ca\u00F1a&#34;</span><span>;</span>

     <span>const</span> <span>_Bool</span> <span>different</span> <span>=</span> <span>wcscmp</span><span>(</span><span>string</span><span>,</span> <span>probe</span><span>);</span>

     <span>// this will always print &#34;different&#34;, because the two strings are not the same despite being identical</span>
     <span>wprintf</span><span>(</span><span>L&#34;`%ls` and `%ls` are %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>string</span><span>,</span> <span>probe</span><span>,</span> <span>different</span> <span>?</span> <span>&#34;different&#34;</span> <span>:</span> <span>&#34;equal&#34;</span><span>);</span>

     <span>return</span> <span>0</span><span>;</span>
 <span>}</span>
</code></pre></div>    </div>

    <div><div><pre><code> <span>$ </span>cc <span>-o</span> widestr_test widestr_test.c <span>-std</span><span>=</span>c11
 <span>$ </span>./widestr_test
 <span>`</span>canÃÉa<span>`</span>
 <span>`</span>canÃÉa<span>`</span> is 5 codepoints long
 <span>`</span>canÃÉa<span>`</span> is 24 bytes long
 <span>`</span>canÃÉa<span>`</span> and <span>`</span>ca√±a<span>`</span> are different
</code></pre></div>    </div>

    <p>This is by far the biggest letdown about UTF-32: it is not the ultimate ‚Äúextended ASCII‚Äù encoding most people wished for, because it is still incorrect so iterate over characters, and it still requires normalization <em>(see below)</em> in order to be safely operated on character by character.</p>
  </li>
</ol>

<h3 id="utf-8">UTF-8</h3>

<p>I left <strong>UTF-8</strong> as last because it is by far the best among the crop of Unicode encodings <sup id="fnref:9" role="doc-noteref"><a href="#fn:9" rel="footnote">7</a></sup>. UTF-8 is a variable width encoding, just like UTF-16, but with the crucial advantage that <strong>UTF-8 uses byte-sized (8-bit) code units</strong>, just like ASCII.</p>

<p>This is a major advantage, for a series of reasons:</p>

<ol>
  <li>All ASCII text is valid UTF-8, and ASCII itself is in UTF-8, limited to the codepoints between <code>U+0000</code> and <code>U+007F</code>.
    <ul>
      <li>This also implies that UTF-8 can encode ASCII text with one byte per character, even when mixed up with non-Latin characters;</li>
      <li>Editors, terminals and other software can just support UTF-8 without having to support a separate ASCII mode;</li>
    </ul>
  </li>
  <li>
    <p>UTF-8 doesn‚Äôt require bothering with endianness, because bytes are just that - bytes. This means that UTF-8 does not require a BOM, even though poorly designed software may still add one <em>(see below)</em>;</p>
  </li>
  <li>UTF-8 doesn‚Äôt need a wide char type, like <code>wchar_t</code> or <code>char16_t</code>. Old APIs can use classic byte-sized <code>chars</code>, and just disregard characters above <code>U+007F</code>.</li>
</ol>

<p>The following is an arguably poorly designed C program that parses a basic key-value file format defined as follows:</p>

<div><div><pre><code>key1:value1
key2:value2
key\:3:value3
</code></pre></div></div>

<div><div><pre><code><span>#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</span>
<span>#define BUFFER_SIZE 1024
</span>
<span>int</span> <span>main</span><span>(</span><span>const</span> <span>int</span> <span>argc</span><span>,</span> <span>const</span> <span>char</span><span>*</span> <span>const</span> <span>argv</span><span>[])</span> <span>{</span>
    <span>if</span> <span>(</span><span>argc</span> <span>!=</span> <span>2</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;usage: %s &lt;file&gt;</span><span>\n</span><span>&#34;</span><span>,</span> <span>argv</span><span>[</span><span>0</span><span>]);</span>
        <span>return</span> <span>EXIT_FAILURE</span><span>;</span>
    <span>}</span>

    <span>FILE</span><span>*</span> <span>const</span> <span>file</span> <span>=</span> <span>fopen</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>],</span> <span>&#34;r&#34;</span><span>);</span>

    <span>if</span> <span>(</span><span>!</span><span>file</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;error: could not open file `%s`</span><span>\n</span><span>&#34;</span><span>,</span> <span>argv</span><span>[</span><span>1</span><span>]);</span>
        <span>return</span> <span>EXIT_FAILURE</span><span>;</span>
    <span>}</span>

    <span>int</span> <span>retval</span> <span>=</span> <span>EXIT_SUCCESS</span><span>;</span>

    <span>char</span><span>*</span> <span>line</span> <span>=</span> <span>malloc</span><span>(</span><span>BUFFER_SIZE</span><span>);</span>
    <span>if</span> <span>(</span><span>!</span><span>line</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;error: could not allocate memory</span><span>\n</span><span>&#34;</span><span>);</span>
        
        <span>goto</span> <span>end</span><span>;</span>
    <span>}</span>

    <span>size_t</span> <span>line_size</span> <span>=</span> <span>BUFFER_SIZE</span><span>;</span>
    <span>ptrdiff_t</span> <span>key_offs</span> <span>=</span> <span>-</span><span>1</span><span>,</span> <span>pos</span> <span>=</span> <span>0</span><span>;</span>
    <span>_Bool</span> <span>escape</span> <span>=</span> <span>0</span><span>;</span>

    <span>for</span> <span>(;;)</span> <span>{</span>
        <span>const</span> <span>int</span> <span>c</span> <span>=</span> <span>fgetc</span><span>(</span><span>file</span><span>);</span>

        <span>switch</span> <span>(</span><span>c</span><span>)</span> <span>{</span>
        <span>case</span> <span>EOF</span><span>:</span>
            <span>goto</span> <span>end</span><span>;</span>
        
        <span>case</span> <span>&#39;\\&#39;</span><span>:</span>
            <span>if</span> <span>(</span><span>!</span><span>escape</span><span>)</span> <span>{</span>
                <span>escape</span> <span>=</span> <span>1</span><span>;</span>
                <span>continue</span><span>;</span>
            <span>}</span>

            <span>break</span><span>;</span>

        <span>case</span> <span>&#39;:&#39;</span><span>:</span>
            <span>if</span> <span>(</span><span>!</span><span>escape</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>key_offs</span> <span>&gt;=</span> <span>0</span><span>)</span> <span>{</span>
                    <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;error: extra `:` at position %td</span><span>\n</span><span>&#34;</span><span>,</span> <span>pos</span><span>);</span>
                    
                    <span>goto</span> <span>end</span><span>;</span>
                <span>}</span>

                <span>key_offs</span> <span>=</span> <span>pos</span><span>;</span>

                <span>continue</span><span>;</span>
            <span>}</span>

            <span>break</span><span>;</span>

        <span>case</span> <span>&#39;\n&#39;</span><span>:</span>
            <span>if</span> <span>(</span><span>escape</span><span>)</span> <span>{</span>
                <span>break</span><span>;</span>
            <span>}</span>

            <span>if</span> <span>(</span><span>key_offs</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
                <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;error: missing `:`</span><span>\n</span><span>&#34;</span><span>);</span>

                <span>goto</span> <span>end</span><span>;</span>
            <span>}</span>

            <span>printf</span><span>(</span><span>&#34;key: `%.*s`, value: `%.*s`</span><span>\n</span><span>&#34;</span><span>,</span> <span>(</span><span>int</span><span>)</span><span>key_offs</span><span>,</span> <span>line</span><span>,</span> <span>(</span><span>int</span><span>)(</span><span>pos</span> <span>-</span> <span>key_offs</span><span>),</span> <span>line</span> <span>+</span> <span>key_offs</span><span>);</span>

            <span>key_offs</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
            <span>pos</span> <span>=</span> <span>0</span><span>;</span>

            <span>continue</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>((</span><span>size_t</span><span>)</span> <span>pos</span> <span>&gt;=</span> <span>line_size</span><span>)</span> <span>{</span>
            <span>line_size</span> <span>=</span> <span>line_size</span> <span>*</span> <span>3</span> <span>/</span> <span>2</span><span>;</span>
            <span>line</span> <span>=</span> <span>realloc</span><span>(</span><span>line</span><span>,</span> <span>line_size</span><span>);</span>

            <span>if</span> <span>(</span><span>!</span><span>line</span><span>)</span> <span>{</span>
                <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;error: could not allocate memory</span><span>\n</span><span>&#34;</span><span>);</span>

                <span>goto</span> <span>end</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>line</span><span>[</span><span>pos</span><span>++</span><span>]</span> <span>=</span> <span>c</span><span>;</span>
        <span>escape</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

<span>end:</span>
    <span>free</span><span>(</span><span>line</span><span>);</span>
    <span>fclose</span><span>(</span><span>file</span><span>);</span>

    <span>return</span> <span>EXIT_SUCCESS</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code><span>$ </span>cc <span>-o</span> kv kv.c <span>-std</span><span>=</span>c11
<span>$ </span><span>cat </span>kv_test.txt
key1:value1
key2:value2
key<span>\:</span>3:value3
<span>$ </span>./kv kv_test.txt
key: <span>`</span>key1<span>`</span>, value: <span>`</span>value1<span>`</span>
key: <span>`</span>key2<span>`</span>, value: <span>`</span>value2<span>`</span>
key: <span>`</span>key:3<span>`</span>, value: <span>`</span>value3<span>`</span>
</code></pre></div></div>

<p>This program operates on files <code>char</code> by <code>char</code> (or rather, <code>int</code> by <code>int</code> - that‚Äôs a long story), using whatever the ‚Äúnative‚Äù 8-bit (‚Äúnarrow‚Äù) execution character set is to match for basic ASCII characters such as <code>:</code>, <code>\</code> and <code>\n</code>.</p>

<p>The beauty of UTF-8 is that code that splits, searches or synchronises using ASCII <em>symbols</em><sup id="fnref:10" role="doc-noteref"><a href="#fn:10" rel="footnote">8</a></sup> will work fine as-is, with little to no modification, even with Unicode text.</p>

<p>Standard C character literals will still be valid Unicode codepoints, as long as the encoding of the source file is UTF-8. In the file above, <code>&#39;:&#39;</code> and other ASCII literals will fit in a char (int, really) as long as they are encoded as ASCII (<code>:</code> is <code>U+003A</code>).</p>

<p>Like UTF-16, UTF-8 is self-synchronizing: the code-splitting logic above will never match a UTF-8 codepoint in the middle, given that ASCII is reserved all of the codepoints between <code>U+0000</code> and <code>U+007F</code>. The text can then be returned to the UTF-8 compliant system as it is, and the Unicode text will be correctly rendered.</p>

<div><div><pre><code><span>$ </span><span>cat </span>kv_test_utf8.txt
tcp:127.0.0.1
Affet, affet:Yalvarƒ±yorum
Why? üòí:bl√•b√¶r
Spla<span>\:</span>too:3u33
<span>$ </span>./kv kv_test_utf8.txt
key: <span>`</span>tcp<span>`</span>, value: <span>`</span>127.0.0.1<span>`</span>
key: <span>`</span>Affet, affet<span>`</span>, value: <span>`</span>Yalvarƒ±yorum<span>`</span>
key: <span>`</span>Why? üòí<span>`</span>, value: <span>`</span>bl√•b√¶r<span>`</span>
key: <span>`</span>Spla:too<span>`</span>, value: <span>`</span>3u33<span>`</span>
</code></pre></div></div>

<h2 id="unicode-normalization">Unicode Normalization</h2>

<p>As I previously mentioned, Unicode codepoints can be modified using combining characters, and the standard supports precomposed forms of some characters which have decomposed forms.
The resulting glyphs are visually indistinguishable after being rendered, and there‚Äôs no limitation on using both forms alongside each other in the same text bit of text:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>import</span> <span>unicodedata</span>
<span>&gt;&gt;&gt;</span> <span>s</span> <span>=</span> <span>&#39;St√∂rfaÃàlle&#39;</span>
<span>&gt;&gt;&gt;</span> <span>len</span><span>(</span><span>s</span><span>)</span>
<span>10</span>
<span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>s</span><span>]</span>
<span>[</span><span>&#39;LATIN CAPITAL LETTER S&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER T&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER O WITH DIAERESIS&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER R&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER F&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER A&#39;</span><span>,</span> <span>&#39;COMBINING DIAERESIS&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER L&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER L&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER E&#39;</span><span>]</span>
<span>&gt;&gt;&gt;</span> <span># getting the last 4 characters actually picks the last 3 glyphs, plus a combining character
</span><span>&gt;&gt;&gt;</span> <span># sometimes the combining character may be mistakenly rendered over the `&#39;` Python prints around the string
</span><span>&gt;&gt;&gt;</span> <span>s</span><span>[</span><span>-</span><span>4</span><span>:]</span>
<span>&#39;Ãàlle&#39;</span>
<span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>s</span><span>[</span><span>-</span><span>4</span><span>:]]</span>
<span>[</span><span>&#39;COMBINING DIAERESIS&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER L&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER L&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER E&#39;</span><span>]</span>
</code></pre></div></div>

<p>This is a significant issue, given how character-centric our understanding of text is: users (and by extension, developers) expect to be able to count what they see as ‚Äúletters‚Äù, in a way that is consistent with how they are printed, shown on screen or inputted in a text field.</p>

<p>Another headache is the fact Unicode also may define special forms for the same letter or group of letters, which are visibly different but understood by humans to be derived from the same symbol.</p>

<p>A very common example of this is the <code>Ô¨Å</code> (U+FB01), <code>Ô¨Ç</code> (U+FB02), <code>Ô¨Ä</code> (U+FB00) and <code>Ô¨É</code> (U+FB03) ligatures, which are ubiquitous in Latin text as a ‚Äúmore readable‚Äù form of the <code>fi</code>, <code>fl</code> and <code>ffi</code> digraphs. In general, users expect <code>office</code>, <code>ofÔ¨Åce</code> and <code>oÔ¨Éce</code> to be treated and rendered similarly, because they all represent the same identical word, but not necessarily without any visual difference. <sup id="fnref:11" role="doc-noteref"><a href="#fn:11" rel="footnote">9</a></sup></p>

<h3 id="canonical-and-compatibility-equivalence">Canonical and Compatibility Equivalence</h3>

<p>To solve this issue, Unicode defines two different types of equivalence between codepoints (or sequences thereof):</p>

<ul>
  <li>
    <p><strong>Canonical equivalence</strong>, when two combinations of one or more codepoints represent the same ‚Äúabstract‚Äù character, like in the case of <em>‚Äú√±‚Äù</em> and <em>‚Äún + combining tilde‚Äù</em>;</p>
  </li>
  <li>
    <p><strong>Compatibility equivalence</strong>, when two combinations of one or more codepoints more or less represent the same ‚Äúabstract‚Äù character, while being rendered differently or having different semantics, like in the case of <em>‚ÄúÔ¨Å‚Äù</em>, or mathematical signs such as ‚ÄúMathematical Bold Capital A‚Äù (<code>ùêÄ</code>).</p>
  </li>
</ul>

<p>Canonical equivalence is generally considered a stronger form of equivalence than compatibility equivalence: it is critical for text processing tools to be able to treat canonically equivalent characters as the same, otherwise, users may be unable to search, edit or operate on text properly.<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" rel="footnote">10</a></sup> On the other end, users are aware of compatibility equivalent characters due to their different semantic and visual features, so their equivalence becomes relevant only in specific circumstances (like textual search, for instance, or when the user tries to copy ‚Äúfancy‚Äù characters from Word to a text box that only accepts plain text).</p>

<h3 id="normalization-forms">Normalization Forms</h3>

<p>Unicode defines four distinct <strong>normalization forms</strong>, which are specific forms a Unicode text can be in, and which allow for safe comparisons between strings.
The standard describes how text can be transformed into any form, following a specific <em>normalization algorithm</em> based <a href="https://www.unicode.org/charts/normalization/">on per-glyph mappings</a>.</p>

<p>The four normalization forms are:</p>

<ul>
  <li>
    <p><strong>NFD</strong>, or <strong>Normalization Form D</strong>, which applies a single <strong>canonical decomposition</strong> to all characters of a string. In general, this can be assumed to mean that every character that has a <em>canonically-equivalent</em> decomposed form is in it, with all of its modifiers <a href="https://unicode.org/reports/tr15/#Description_Norm">sorted into a canonical order</a>.</p>

    <p>For instance,</p>
    <div><div><pre><code>  <span>&gt;&gt;&gt;</span> <span>&#34;e</span><span>\u0302\u0323</span><span>&#34;</span>
  <span>&#39;eÃÇÃ£&#39;</span>
  <span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>&#34;e</span><span>\u0302\u0323</span><span>&#34;</span><span>]</span>
  <span>[</span><span>&#39;LATIN SMALL LETTER E&#39;</span><span>,</span> <span>&#39;COMBINING CIRCUMFLEX ACCENT&#39;</span><span>,</span> <span>&#39;COMBINING DOT BELOW&#39;</span><span>]</span>
  <span>&gt;&gt;&gt;</span> <span>normalized</span> <span>=</span> <span>unicodedata</span><span>.</span><span>normalize</span><span>(</span><span>&#39;NFD&#39;</span><span>,</span> <span>&#34;e</span><span>\u0302\u0323</span><span>&#34;</span><span>)</span>
  <span>&gt;&gt;&gt;</span> <span>normalized</span>
  <span>&#39;eÃÇÃ£&#39;</span>
  <span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>normalized</span><span>]</span>
  <span>[</span><span>&#39;LATIN SMALL LETTER E&#39;</span><span>,</span> <span>&#39;COMBINING DOT BELOW&#39;</span><span>,</span> <span>&#39;COMBINING CIRCUMFLEX ACCENT&#39;</span><span>]</span>
</code></pre></div>    </div>
    <p>Notice how the circumflex and the dot below were in a noncanonical order and were swapped by the normalization algorithm.</p>
  </li>
  <li>
    <p><strong>NFC</strong>, or <strong>Normalization Form C</strong>, which first applies a <strong>canonical decomposition</strong>, followed by a <strong>canonical composition</strong>. In NFC, all characters are composed into a <em>precomposed character</em>, if possible:</p>

    <div><div><pre><code>  <span>&gt;&gt;&gt;</span> <span>precomposed</span> <span>=</span> <span>unicodedata</span><span>.</span><span>normalize</span><span>(</span><span>&#39;NFC&#39;</span><span>,</span> <span>&#34;e</span><span>\u0302\u0323</span><span>&#34;</span><span>)</span>
  <span>&gt;&gt;&gt;</span> <span>precomposed</span>
  <span>&#39;√™Ã£&#39;</span>
  <span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>precomposed</span><span>]</span>
  <span>[</span><span>&#39;LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW&#39;</span><span>]</span>
</code></pre></div>    </div>

    <p>Notice that normalizing to NFC <strong>is not enough to ‚Äúcount‚Äù glyphs</strong>, given that some may not be representable with a single codepoint. An example of this is <code>eÃÑÃ£</code>, which has no associated precomposed character:</p>

    <div><div><pre><code>  <span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>unicodedata</span><span>.</span><span>normalize</span><span>(</span><span>&#39;NFC&#39;</span><span>,</span> <span>&#34;eÃÑÃ£&#34;</span><span>)]</span>
  <span>[</span><span>&#39;LATIN SMALL LETTER E WITH DOT BELOW&#39;</span><span>,</span> <span>&#39;COMBINING MACRON&#39;</span><span>]</span>
</code></pre></div>    </div>

    <p>A particularly nice property of NFC is that by definition all ASCII text is by definition already in NFC, which means that compilers and other tools do not necessarily have to bother with normalization when dealing with source code or scripts. <sup id="fnref:13" role="doc-noteref"><a href="#fn:13" rel="footnote">11</a></sup></p>
  </li>
  <li>
    <p><strong>NFKD</strong>, or <strong>Normalization Form KD</strong>, which applies a <strong>compatibility decomposition</strong> to all characters of a string. Alongside canonical equivalence, Unicode also defines compatibility-equivalent decompositions for certain characters, like the previously mentioned <code>Ô¨Å</code> ligature, which is decomposed into <code>f</code> and <code>i</code>.</p>

    <div><div><pre><code>  <span>&gt;&gt;&gt;</span> <span>fi</span> <span>=</span> <span>&#34;Ô¨Å&#34;</span>
  <span>&gt;&gt;&gt;</span> <span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>fi</span><span>)</span>
  <span>&#39;LATIN SMALL LIGATURE FI&#39;</span>
  <span>&gt;&gt;&gt;</span> <span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>unicodedata</span><span>.</span><span>normalize</span><span>(</span><span>&#39;NFD&#39;</span><span>,</span> <span>fi</span><span>))</span> <span># doesn&#39;t do anything, `Ô¨Å` has no canonical decomposition
</span>  <span>&#39;LATIN SMALL LIGATURE FI&#39;</span>
  <span>&gt;&gt;&gt;</span> <span>decomposed</span> <span>=</span> <span>unicodedata</span><span>.</span><span>normalize</span><span>(</span><span>&#39;NFKD&#39;</span><span>,</span> <span>&#34;Ô¨Å&#34;</span><span>)</span>
  <span>&gt;&gt;&gt;</span> <span>decomposed</span>
  <span>&#39;fi&#39;</span>
  <span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>decomposed</span><span>]</span>
  <span>[</span><span>&#39;LATIN SMALL LETTER F&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER I&#39;</span><span>]</span>
</code></pre></div>    </div>

    <p>Characters that don‚Äôt have a compatibility decomposition are canonically decomposed instead:</p>

    <div><div><pre><code>  <span>&gt;&gt;&gt;</span> <span>&#34;</span><span>\u1EC7</span><span>&#34;</span>
  <span>&#39;·ªá&#39;</span>
  <span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>unicodedata</span><span>.</span><span>normalize</span><span>(</span><span>&#39;NFKD&#39;</span><span>,</span> <span>&#34;</span><span>\u1EC7</span><span>&#34;</span><span>)</span>
  <span>[</span><span>&#39;LATIN SMALL LETTER E&#39;</span><span>,</span> <span>&#39;COMBINING DOT BELOW&#39;</span><span>,</span> <span>&#39;COMBINING CIRCUMFLEX ACCENT&#39;</span><span>]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>NFKC</strong>, or <strong>Normalization Form KC</strong>, which first applies a <strong>compatibility decomposition</strong>, followed by a <strong>canonical composition</strong>. In NFKC, all characters are composed into a <em>precomposed character</em>, if possible:</p>

    <div><div><pre><code>  <span>&gt;&gt;&gt;</span> <span>precomposed</span> <span>=</span> <span>unicodedata</span><span>.</span><span>normalize</span><span>(</span><span>&#39;NFKC&#39;</span><span>,</span> <span>&#34;Ô¨Å&#34;</span><span>)</span> <span># this is U+FB01, &#34;LATIN SMALL LIGATURE FI&#34;
</span>  <span>&gt;&gt;&gt;</span> <span>precomposed</span>
  <span>&#39;fi&#39;</span>
  <span>&gt;&gt;&gt;</span> <span>[</span><span>unicodedata</span><span>.</span><span>name</span><span>(</span><span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>precomposed</span><span>]</span>
 <span>[</span><span>&#39;LATIN SMALL LETTER F&#39;</span><span>,</span> <span>&#39;LATIN SMALL LETTER I&#39;</span><span>]</span> 
</code></pre></div>    </div>

    <p>Notice how the composition performed is <em>canonical</em>: there‚Äôs no such thing as ‚Äúcompatibility composition‚Äù as far as my understanding goes. This means that NFKC never recombines characters into compatibility-equivalent forms, which are thus permanently lost:</p>

    <pre><code>  &gt;&gt;&gt; s = &#34;SouÔ¨Äl\u0065\u0301&#34; # notice the `Ô¨Ä` ligature
  &gt;&gt;&gt; s
  &#39;SouÔ¨Äl√©&#39;
  &gt;&gt;&gt; norm = unicodedata.normalize(&#39;NFKC&#39;, s) 
  &gt;&gt;&gt; norm
  &#39;Souffl√©&#39;
  &gt;&gt;&gt; # the ligature is gone, but the accent is still there
</code></pre>
  </li>
</ul>

<p>All in all, normalization is a fairly complex topic, and it‚Äôs especially tricky to implement right due to the sheer amount of special cases, so it‚Äôs always best to rely on libraries in order to get it right.</p>

<h2 id="unicode-in-the-wild-caveats">Unicode in the wild: caveats</h2>

<p>Unicode is the de facto only relevant character set in existence, with UTF-8 detaining the status of best encoding.</p>

<p>Unfortunately, internationalization support introduces a great deal of complexity into text handling, something that developers are often unaware of:</p>

<ol>
  <li>
    <p>First and foremost, there‚Äôs still a massive amount of software that doesn‚Äôt default to (or outright does not support) UTF-8, because it was either designed to work with legacy 8-bit encodings (like ISO-8859-1) or because it was designed in the ‚Äô90s to use UCS-2 and it‚Äôs permanently stuck with it or with faux <em>‚ÄúUTF-16‚Äù</em>.
Software libraries and frameworks like Qt, Java, Unreal Engine and the Win32 API are constantly converting text from UTF-8 (which is nowadays the sole Internet standard) to their internal UTF-16 representation. This is a massive waste of CPU cycles, which while more abundant than in the past, are still a finite resource.</p>

    <div><div><pre><code> <span>// Linux x86_64, Qt 6.5.1. Encoding is `en_US.UTF-8`.</span>
 <span>#include &lt;iostream&gt;
</span>
 <span>#include &lt;QCoreApplication&gt;
</span> <span>#include &lt;QDebug&gt;
</span>
 <span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>*</span><span>argv</span><span>[])</span> <span>{</span>
     <span>QCoreApplication</span> <span>app</span><span>{</span><span>argc</span><span>,</span> <span>argv</span><span>};</span>

     <span>// converts UTF-8 (the source file&#39;s encoding) to the internal QString representation</span>
     <span>const</span> <span>QString</span> <span>s</span><span>{</span><span>&#34;ca√±a&#34;</span><span>};</span> 

     <span>// prints `&#34;ca√±a&#34;``, using Qt&#39;s debugging facilities. This will convert back to UTF-8 in order</span>
     <span>// to print the string to the console</span>
     <span>qDebug</span><span>()</span> <span>&lt;&lt;</span> <span>s</span><span>;</span>

     <span>// prints `ca√±a`, using C++&#39;s IOStreams. This will force Qt to convert the string to</span>
     <span>// a UTF-8 encoded std::string, which will then be printed to the console</span>
     <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>s</span><span>.</span><span>toStdString</span><span>()</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>

     <span>return</span> <span>0</span><span>;</span>
 <span>}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Case insensitivity in Unicode is a massive headache. First and foremost, the concept itself of ‚Äúignoring case‚Äù is deeply European-centric due to it being chiefly limited to <em>bicameral scripts</em> such as Latin, Cyrillic or Greek. What is considered the opposite case of a letter may vary as well, depending on the system‚Äôs locale:</p>

    <div><div><pre><code> <span>public</span> <span>class</span> <span>Up</span> <span>{</span>
     <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>final</span> <span>String</span><span>[]</span> <span>args</span><span>)</span> <span>{</span>
         <span>final</span> <span>var</span> <span>uc</span> <span>=</span> <span>&#34;CIAO&#34;</span><span>;</span>
         <span>final</span> <span>var</span> <span>lc</span> <span>=</span> <span>&#34;ciao&#34;</span><span>;</span>

         <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>uc</span><span>.</span><span>toLowerCase</span><span>());</span>
         <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>lc</span><span>.</span><span>toUpperCase</span><span>());</span>

         <span>System</span><span>.</span><span>out</span><span>.</span><span>printf</span><span>(</span><span>&#34;uc(\&#34;%s\&#34;) == \&#34;%s\&#34;: %b\n&#34;</span><span>,</span> <span>lc</span><span>,</span> <span>uc</span><span>,</span> <span>lc</span><span>.</span><span>toUpperCase</span><span>().</span><span>equals</span><span>(</span><span>uc</span><span>));</span>
     <span>}</span>
 <span>}</span>
</code></pre></div>    </div>

    <div><div><pre><code> <span>$ </span><span>echo</span> <span>$LANG</span>
 en_US.UTF-8
 <span>$ </span>java Up
 ciao
 CIAO
 uc<span>(</span><span>&#34;ciao&#34;</span><span>)</span> <span>==</span> <span>&#34;CIAO&#34;</span>: <span>true</span>
</code></pre></div>    </div>

    <p>This seems working fine until the runtime locale is switched to Turkish:</p>

    <div><div><pre><code> <span>$ </span><span>env </span><span>LANG</span><span>=</span><span>&#39;tr_TR.UTF-8&#39;</span> java Up
 cƒ±ao
 Cƒ∞AO
 uc<span>(</span><span>&#34;ciao&#34;</span><span>)</span> <span>==</span> <span>&#34;CIAO&#34;</span>: <span>false</span>
</code></pre></div>    </div>

    <p>In Turkish, the uppercase of <code>i</code> is <code>ƒ∞</code>, and the lowercase of <code>I</code> is <code>ƒ±</code>, which breaks the ASCII-centric assumption the Java<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" rel="footnote">12</a></sup> snippet above is built on. There is a multitude of such examples of ‚Äúnaive‚Äù implementations of case insensitivity in Unicode that inevitably end up being incorrect under unforeseen circumstances.</p>

    <p>Taking all edge cases related to Unicode case folding into account is a lot of work, especially since it‚Äôs very hard to properly test all possible locales. This is the reason why <strong>Unicode handling is always best left to a library</strong>. For C/C++ and Java, the Unicode Consortium itself provides a reference implementation of the Unicode algorithms, called <a href="https://unicode-org.github.io/icu/">ICU</a>, which is used by a large number of frameworks and shipped by almost every major OS.</p>

    <p>While quite tricky to get right at times and at times more UTF-16 centric than I‚Äôd like, using ICU is still way saner than any self-written alternative:</p>

    <div><div><pre><code> <span>#include &lt;stdint.h&gt;
</span> <span>#include &lt;stdio.h&gt;
</span> <span>#include &lt;stdlib.h&gt;
</span> <span>#include &lt;string.h&gt;
</span>
 <span>#include &lt;unicode/ucasemap.h&gt;
</span> <span>#include &lt;unicode/utypes.h&gt;
</span>
 <span>int</span> <span>main</span><span>(</span><span>const</span> <span>int</span> <span>argc</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>const</span> <span>argv</span><span>[])</span> <span>{</span>
     <span>// Support custom locales</span>
     <span>const</span> <span>char</span><span>*</span> <span>const</span> <span>locale</span> <span>=</span> <span>argc</span> <span>&gt;</span> <span>1</span> <span>?</span> <span>argv</span><span>[</span><span>1</span><span>]</span> <span>:</span> <span>&#34;en_US&#34;</span><span>;</span>

     <span>UErrorCode</span> <span>status</span> <span>=</span> <span>U_ZERO_ERROR</span><span>;</span>

     <span>// Create a UCaseMap object for case folding</span>
     <span>UCaseMap</span><span>*</span> <span>const</span> <span>caseMap</span> <span>=</span> <span>ucasemap_open</span><span>(</span><span>locale</span><span>,</span> <span>0</span><span>,</span> <span>&amp;</span><span>status</span><span>);</span>
     <span>if</span> <span>(</span><span>U_FAILURE</span><span>(</span><span>status</span><span>))</span> <span>{</span>
         <span>printf</span><span>(</span><span>&#34;Error creating UCaseMap: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>u_errorName</span><span>(</span><span>status</span><span>));</span>
         <span>return</span> <span>EXIT_FAILURE</span><span>;</span>
     <span>}</span>

     <span>// Case fold the input string using the default settings</span>
     <span>const</span> <span>char</span> <span>input</span><span>[]</span> <span>=</span> <span>&#34;CIAO&#34;</span><span>;</span>
     <span>char</span> <span>lc</span><span>[</span><span>100</span><span>];</span>
     <span>const</span> <span>int32_t</span> <span>lcLength</span> <span>=</span> <span>ucasemap_utf8ToLower</span><span>(</span><span>caseMap</span><span>,</span> <span>lc</span><span>,</span> <span>sizeof</span> <span>lc</span><span>,</span> <span>input</span><span>,</span> <span>sizeof</span> <span>input</span><span>,</span> <span>&amp;</span><span>status</span><span>);</span>

     <span>if</span> <span>(</span><span>U_FAILURE</span><span>(</span><span>status</span><span>))</span> <span>{</span>
         <span>printf</span><span>(</span><span>&#34;Error performing case folding: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>u_errorName</span><span>(</span><span>status</span><span>));</span>
         <span>return</span> <span>1</span><span>;</span>
     <span>}</span>

     <span>// Print the lower case string</span>
     <span>printf</span><span>(</span><span>&#34;lc(</span><span>\&#34;</span><span>%s</span><span>\&#34;</span><span>) == %.*s</span><span>\n</span><span>&#34;</span><span>,</span> <span>input</span><span>,</span> <span>lcLength</span><span>,</span> <span>lc</span><span>);</span>

     <span>// Clean up resources</span>
     <span>ucasemap_close</span><span>(</span><span>caseMap</span><span>);</span>

     <span>return</span> <span>EXIT_SUCCESS</span><span>;</span>
 <span>}</span>
</code></pre></div>    </div>

    <div><div><pre><code> <span>$ </span>cc <span>-o</span> casefold casefold.c <span>-std</span><span>=</span>c11 <span>$(</span>icu-config <span>--ldflags</span><span>)</span>
 <span>$ </span>./casefold
 lc<span>(</span><span>&#34;CIAO&#34;</span><span>)</span> <span>==</span> ciao
 <span>$ </span>./casefold tr_TR
 lc<span>(</span><span>&#34;CIAO&#34;</span><span>)</span> <span>==</span> cƒ±ao
</code></pre></div>    </div>

    <p>Unicode generalises ‚Äúcase insensitivity‚Äù into the broader concept of <a href="https://unicode.org/L2/L2002/02186-foldings-0d6.html">character folding</a>, which boils down to a set of rules that define how characters can be transformed into other characters, in order to make them comparable.</p>
  </li>
  <li>
    <p>Similarly to folding, sorting text in a well-defined order (for instance alphabetical), an operation better known as <em><strong>collation</strong></em>, is also not trivial with Unicode.</p>

    <p>Different languages (and thus <em>locales</em>) may have different sorting rules, even with the Latin scripts.</p>

    <p>If, perchance, someone wanted to sort the list of words <code>[ &#34;tuck&#34;, &#34;l√∂we&#34;, &#34;luck&#34;, &#34;zebra&#34;]</code>:</p>

    <ul>
      <li>In German, ‚Äò√ñ‚Äô is placed between ‚ÄòO‚Äô and ‚ÄòP‚Äô, and the rest of the alphabet follows the same order as in English. The correct sorting for that list is thus <code>[ &#34;l√∂we&#34;, &#34;luck&#34;, &#34;tuck&#34;, &#34;zebra&#34;]</code>;</li>
      <li>In Estonian, ‚ÄòZ‚Äô is placed between ‚ÄòS‚Äô and ‚ÄòT‚Äô, and ‚Äò√ñ‚Äô is the penultimate letter of the alphabet. The list is then sorted as <code>[ &#34;luck&#34;, &#34;l√∂we&#34;, &#34;zebra&#34;, &#34;tuck&#34;]</code>;</li>
      <li>In Swedish, ‚Äò√ñ‚Äô is the last letter of the alphabet, with the classical Latin letters in their usual order. The list is thus <code>[ &#34;luck&#34;, &#34;l√∂we&#34;, &#34;tuck&#34;, &#34;zebra&#34;]</code>.</li>
    </ul>

    <p>Unicode defines <a href="https://unicode.org/reports/tr10/">a complex set of rules for collation</a> and provides a reference implementation in ICU through the <code>ucol</code> API (and its relative C++ and Java equivalents).</p>

    <div><div><pre><code> <span>#define _GNU_SOURCE // for qsort_r
</span>
 <span>#include &lt;stdint.h&gt;
</span> <span>#include &lt;stdio.h&gt;
</span> <span>#include &lt;stdlib.h&gt;
</span> <span>#include &lt;string.h&gt;
</span>
 <span>#include &lt;unicode/ustring.h&gt;
</span> <span>#include &lt;unicode/ucol.h&gt;
</span> <span>#include &lt;unicode/uloc.h&gt;
</span>
 <span>int</span> <span>strcmp_helper</span><span>(</span><span>const</span> <span>void</span> <span>*</span><span>const</span> <span>a</span><span>,</span> <span>const</span> <span>void</span> <span>*</span><span>const</span> <span>b</span><span>,</span> <span>void</span> <span>*</span><span>const</span> <span>ctx</span><span>)</span> <span>{</span>
     <span>const</span> <span>char</span> <span>*</span><span>const</span> <span>str1</span> <span>=</span> <span>*</span><span>(</span><span>const</span> <span>char</span><span>**</span><span>)</span> <span>a</span><span>,</span> <span>*</span><span>const</span> <span>str2</span> <span>=</span> <span>*</span><span>(</span><span>const</span> <span>char</span><span>**</span><span>)</span> <span>b</span><span>;</span>

     <span>UErrorCode</span> <span>status</span> <span>=</span> <span>U_ZERO_ERROR</span><span>;</span>
        
     <span>const</span> <span>UCollationResult</span> <span>cres</span> <span>=</span> <span>ucol_strcollUTF8</span><span>(</span><span>ctx</span><span>,</span> <span>str1</span><span>,</span> <span>strlen</span><span>(</span><span>str1</span><span>),</span> <span>str2</span><span>,</span> <span>strlen</span><span>(</span><span>str2</span><span>),</span> <span>&amp;</span><span>status</span><span>);</span>

     <span>return</span> <span>(</span><span>cres</span> <span>==</span> <span>UCOL_GREATER</span><span>)</span> <span>-</span> <span>(</span><span>cres</span> <span>==</span> <span>UCOL_LESS</span><span>);</span>
 <span>}</span>

 <span>void</span> <span>sort_strings</span><span>(</span><span>UCollator</span> <span>*</span><span>const</span> <span>collator</span><span>,</span> <span>const</span> <span>char</span> <span>**</span><span>const</span> <span>strings</span><span>,</span> <span>const</span> <span>ptrdiff_t</span> <span>n</span><span>)</span> <span>{</span>
     <span>qsort_r</span><span>(</span><span>strings</span><span>,</span> <span>n</span><span>,</span> <span>sizeof</span> <span>*</span><span>strings</span><span>,</span> <span>strcmp_helper</span><span>,</span> <span>collator</span><span>);</span>
 <span>}</span>

 <span>int</span> <span>main</span><span>(</span><span>const</span> <span>int</span> <span>argc</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>argv</span><span>[])</span> <span>{</span>
     <span>// Support custom locales</span>
     <span>const</span> <span>char</span><span>*</span> <span>locale</span> <span>=</span> <span>getenv</span><span>(</span><span>&#34;ICU_LOCALE&#34;</span><span>);</span>

     <span>if</span> <span>(</span><span>!</span><span>locale</span><span>)</span> <span>{</span>
         <span>locale</span> <span>=</span> <span>&#34;en_US&#34;</span><span>;</span>
     <span>}</span>

     <span>UErrorCode</span> <span>status</span> <span>=</span> <span>U_ZERO_ERROR</span><span>;</span>
        
     <span>// Create a UCaseMap object for case folding</span>
     <span>UCollator</span> <span>*</span><span>const</span> <span>coll</span> <span>=</span> <span>ucol_open</span><span>(</span><span>locale</span><span>,</span> <span>&amp;</span><span>status</span><span>);</span>
     <span>if</span> <span>(</span><span>U_FAILURE</span><span>(</span><span>status</span><span>))</span> <span>{</span>
         <span>printf</span><span>(</span><span>&#34;Error creating UCollator: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>u_errorName</span><span>(</span><span>status</span><span>));</span>
         <span>return</span> <span>EXIT_FAILURE</span><span>;</span>
     <span>}</span>
        
     <span>sort_strings</span><span>(</span><span>coll</span><span>,</span> <span>++</span><span>argv</span><span>,</span> <span>argc</span> <span>-</span> <span>1</span><span>);</span>

     <span>// Clean up resources</span>
     <span>ucol_close</span><span>(</span><span>coll</span><span>);</span>
        
     <span>while</span> <span>(</span><span>*</span><span>argv</span><span>)</span> <span>{</span>
         <span>puts</span><span>(</span><span>*</span><span>argv</span><span>++</span><span>);</span>
     <span>}</span>
    
     <span>return</span> <span>EXIT_SUCCESS</span><span>;</span>
 <span>}</span>
</code></pre></div>    </div>

    <div><div><pre><code> <span>$ </span><span>env </span><span>ICU_LOCALE</span><span>=</span>de_DE ./coll <span>&#34;tuck&#34;</span> <span>&#34;l√∂we&#34;</span> <span>&#34;luck&#34;</span> <span>&#34;zebra&#34;</span> <span># German</span>
 l√∂we
 luck
 tuck
 zebra
 <span>$ </span><span>env </span><span>ICU_LOCALE</span><span>=</span>et_EE ./coll <span>&#34;tuck&#34;</span> <span>&#34;l√∂we&#34;</span> <span>&#34;luck&#34;</span> <span>&#34;zebra&#34;</span> <span># Estonian</span>
 luck
 l√∂we
 zebra
 tuck
 <span>$ </span><span>env </span><span>ICU_LOCALE</span><span>=</span>sv_SE ./coll <span>&#34;tuck&#34;</span> <span>&#34;l√∂we&#34;</span> <span>&#34;luck&#34;</span> <span>&#34;zebra&#34;</span> <span># Swedish</span>
 luck
 l√∂we
 tuck
 zebra
 <span>$ </span><span># more complex case: sorting Japanese Kana using the Japanese locale&#39;s goj≈´on order</span>
 <span>$ </span><span>env </span><span>ICU_LOCALE</span><span>=</span>ja ./coll <span>&#34;„Éë„É≥„ÉÄ&#34;</span> <span>&#34;„ÅÇ„Çä„Åå„Å®„ÅÜ&#34;</span> <span>&#34;„Éë„ÇΩ„Ç≥„É≥&#34;</span> <span>&#34;„Åï„Çà„Å™„Çâ&#34;</span> <span>&#34;„Ç´„Éº„Éâ&#34;</span>
 „ÅÇ„Çä„Åå„Å®„ÅÜ
 „Ç´„Éº„Éâ
 „Åï„Çà„Å™„Çâ
 „Éë„ÇΩ„Ç≥„É≥
 „Éë„É≥„ÉÄ
</code></pre></div>    </div>
  </li>
  <li>
    <p>To facilitate UTF-8 detection when other encodings may be in use, some platforms annoyingly add a UTF-8 BOM (<code>EF BB 0D</code>) at the beginning of text files. Microsoft‚Äôs Visual Studio is historically a major offender in this regard:</p>

    <div><div><pre><code> <span>$ </span> file OldProject.sln
 OldProject.sln: Unicode text, UTF-8 <span>(</span>with BOM<span>)</span> text, with CRLF line terminators
 <span>$ </span>xxd OldProject.sln | <span>head</span> <span>-n</span> 1
 00000000: efbb bf0d 0a4d 6963 726f 736f 6674 2056  .....Microsoft V
</code></pre></div>    </div>

    <p>The sequence is simply <code>U+FEFF</code>, just like in UTF-16 and 32, but encoded in UTF-8. While it‚Äôs not forbidden by the standard per se, it has no real utility besides signaling that the file is in UTF-8 (it makes no sense talking about endianness with single bytes). Programs that need to parse or operate on UTF-8 encoded files should always be aware that a BOM may be present, and probe for it to avoid exposing users to unnecessary complexity they probably don‚Äôt care about.</p>
  </li>
  <li>
    <p>Because of all of the reasons listed above, random, array-like access to Unicode strings is almost always broken - this is true even with UTF-32, due to grapheme clusters. It also follows that operations such as string slicing are not trivial to implement correctly, and the way languages such as Python and JavaScript do it (codepoint by codepoint) is IMHO arguably problematic.</p>

    <p>A good example of a modern language that attempts to mitigate this issue is Rust, which has UTF-8 strings that disallow indexed access and only support slicing at byte indices, with UTF-8 validation at runtime:</p>

    <div><div><pre><code> <span>fn</span> <span>main</span><span>()</span> <span>{</span>
     <span>let</span> <span>s</span> <span>=</span> <span>&#34;ca√±a&#34;</span><span>;</span>

     <span>// error[E0277]: the type `str` cannot be indexed by `{integer}`</span>
     <span>// let c = s[1];</span>

     <span>// char-by-char access requires iterators</span>
     <span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>s</span><span>.chars</span><span>()</span><span>.nth</span><span>(</span><span>2</span><span>)</span><span>.unwrap</span><span>());</span> <span>// OK: √±</span>

     <span>// this will crash the program at runtime:</span>
     <span>// &#34;byte index 3 is not a char boundary; it is inside &#39;√±&#39; (bytes 2..4) of `ca√±a`&#34;</span>
     <span>// let slice = &amp;s[1..3]);</span>

     <span>// the user needs to check UTF-8 character bounds beforehand</span>
     <span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>&amp;</span><span>s</span><span>[</span><span>1</span><span>..</span><span>4</span><span>]);</span> <span>// OK: &#34;a√±&#34;</span>
 <span>}</span>
</code></pre></div>    </div>

    <p>The stabilisation of the <code>.chars()</code> method took quite a long time, reflecting the fact that deducing what is or is not a character in Unicode is complex and quite controversial. The method itself ended up implementing iteration over Rust‚Äôs <code>char</code>s (aka, Unicode scalar codepoints) instead of grapheme clusters, which is rarely what the user wants. The fact it returns an iterator does at least effectively express that character-by-character access in Unicode is not, indeed, the ‚Äúsimple‚Äù operation developers have been so long accustomed to.</p>
  </li>
</ol>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Unicode is a massive standard, and it‚Äôs constantly adding new characters<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" rel="footnote">13</a></sup>, so for everybody‚Äôs safety it‚Äôs always best to rely on libraries to provide Unicode support, and if necessary ship fonts that support all the characters you may need (such as <em>Noto Fonts</em>). As previously introduced, C and C++ do not provide great support for Unicode, so it‚Äôs always best to just use ICU, which is widely supported and shipped by every major OS (<a href="https://learn.microsoft.com/en-us/windows/win32/intl/international-components-for-unicode--icu-">including Windows</a>).</p>

<p>When handling text that may contain non-English characters, it‚Äôs always best to stick to UTF-8 when possible and use Unicode-aware libraries for text processing. While writing custom text processing code may seem doable, it‚Äôs easy to miss a few corner cases and confuse end users in the process.</p>

<p>This is especially important because the main users of localized text and applications tend to often be the least technically savvy - those who may lack the ability to understand why the piece of software they are using is misbehaving, and can‚Äôt search for help in a language they don‚Äôt understand.</p>

<p>I hope this article may have been useful to shed some light on what is, in my opinion, an often overlooked topic in software development, especially among C++ users. If I had to be honest, I was striving for a shorter article, but I guess I had to make up for all those years I didn‚Äôt post a thing :)</p>

<p>As always, feel free to comment underneath or send me a message if anything does not look right, and hopefully, the next post will come before 2025‚Ä¶</p>



</div>




                            



    </div></div>
  </body>
</html>
