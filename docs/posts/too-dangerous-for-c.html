<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.dureuill.net/articles/too-dangerous-cpp/">Original</a>
    <h1>Too dangerous for C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
                                <p>Some patterns are only made practical thanks to Rust&#39;s memory safety, and too dangerous to use in C++. Here&#39;s a concrete example.</p>
<hr/>
<p>Working on an internal library written in Rust, I had an error type for a parser that I wanted to be <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code>able</a>, without duplicating the data inside. In Rust, this calls for a <strong>r</strong>eference-<strong>c</strong>ounted pointer, like <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a>.</p>
<p>So I wrote my error type, used it as the error variant of the fallible functions, and moved on with my life.</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>Error {
</span><span>    </span><span>data</span><span>: Rc&lt;ExpensiveToCloneDirectly&gt;,
</span><span>}
</span><span>
</span><span>pub type </span><span>Response = Result&lt;Output, Error&gt;;
</span><span>
</span><span>fn </span><span>parse</span><span>(</span><span>input</span><span>: Input) -&gt; Response {
</span><span>    todo!()
</span><span>}
</span></code></pre>
<p>Sometimes later, we noticed that parsing would take a long time to execute on some inputs, so I decided I&#39;d send the input to another thread via a <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">channel</a>, and I&#39;d get the response back through another channel, so that long orders wouldn&#39;t block the main thread.</p>
<pre data-lang="rust"><code data-lang="rust"><span>enum </span><span>Command {
</span><span>    Input(Input),
</span><span>    Exit,
</span><span>}
</span><span>
</span><span>pub enum </span><span>RequestStatus {
</span><span>    Completed(Response),
</span><span>    Running,
</span><span>}
</span><span>
</span><span>pub struct </span><span>Parser {
</span><span>    </span><span>command_sender</span><span>: Sender&lt;Command&gt;,
</span><span>    </span><span>response_receiver</span><span>: Receiver&lt;(Input, Response)&gt;,
</span><span>    </span><span>cached_result</span><span>: HashMap&lt;Input, RequestStatus&gt;,
</span><span>}
</span><span>
</span><span>impl </span><span>Parser {
</span><span>    </span><span>pub fn </span><span>new</span><span>() -&gt; </span><span>Self </span><span>{
</span><span>        </span><span>let </span><span>(command_sender, command_receiver) = channel::&lt;Command&gt;();
</span><span>        </span><span>let </span><span>(response_sender, response_receiver) = channel::&lt;(Input, Response)&gt;();
</span><span>
</span><span>        std::thread::spawn(</span><span>move </span><span>|| </span><span>loop </span><span>{
</span><span>            </span><span>match</span><span> command_receiver.</span><span>recv</span><span>() {
</span><span>                Ok(Command::Input(input)) =&gt; {
</span><span>                    </span><span>let</span><span> response = </span><span>parse</span><span>(input);
</span><span>                    </span><span>let </span><span>_ = response_sender.</span><span>send</span><span>((input, response));
</span><span>                }
</span><span>                Ok(Command::Exit) =&gt; </span><span>break</span><span>,
</span><span>                Err(_) =&gt; </span><span>break</span><span>,
</span><span>            }
</span><span>        });
</span><span>
</span><span>        </span><span>Self </span><span>{
</span><span>            command_sender,
</span><span>            response_receiver,
</span><span>            cached_result: HashMap::default(),
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span>pub fn </span><span>request_parsing</span><span>(&amp;</span><span>mut </span><span>self</span><span>, </span><span>input</span><span>: Input) -&gt; RequestStatus {
</span><span>        </span><span>// pump previously received responses
</span><span>        </span><span>while let </span><span>Ok((input, response)) = </span><span>self</span><span>.response.receiver.</span><span>try_recv</span><span>() {
</span><span>            </span><span>self</span><span>.cached_result
</span><span>                .</span><span>insert</span><span>(input, RequestStatus::Completed(response));
</span><span>        }
</span><span>
</span><span>        </span><span>let</span><span> response = </span><span>match </span><span>self</span><span>.cached_result.</span><span>entry</span><span>(input) {
</span><span>            Entry::Vacant(entry) =&gt; {
</span><span>                </span><span>self</span><span>.command_sender
</span><span>                    .</span><span>send</span><span>(Command::Input(entry.</span><span>key</span><span>()))
</span><span>                    .</span><span>unwrap</span><span>();
</span><span>                entry.</span><span>insert</span><span>(RequestStatus::Running)
</span><span>            }
</span><span>            Entry::Occupied(entry) =&gt; entry.</span><span>into_mut</span><span>(),
</span><span>        };
</span><span>        response.</span><span>clone</span><span>()
</span><span>    }
</span><span>}
</span></code></pre>
<p>However, while doing this change, I was greeted with the following error message:</p>
<pre data-lang="rust"><code data-lang="rust"><span>error[</span><span>E0277</span><span>]: `Rc&lt;String&gt;` cannot be sent between threads safely
</span><span>   --&gt; src/main.rs:</span><span>58</span><span>:</span><span>32
</span><span>    |
</span><span>58  </span><span>|               std::thread::spawn(</span><span>move </span><span>|| </span><span>loop </span><span>{
</span><span>    |  _____________------------------_^
</span><span>    | |             |
</span><span>    | |             required by a bound introduced by this call
</span><span>59  </span><span>| |                 </span><span>match</span><span> command_receiver.</span><span>recv</span><span>() {
</span><span>60  </span><span>| |                     Ok(Command::Input(input)) =&gt; {
</span><span>61  </span><span>| |                         </span><span>let</span><span> response = </span><span>maybe_make</span><span>(input);
</span><span>...   |
</span><span>68  </span><span>| |                 }
</span><span>69  </span><span>| |             });
</span><span>    | |</span><span>_____________</span><span>^ `Rc&lt;String&gt;` cannot be sent between threads safely
</span><span>    |
</span><span>    = help: within `(&amp;</span><span>&#39;static str</span><span>, Result&lt;worker::Output, worker::Error&gt;)`, the </span><span>trait</span><span> `Send` is not implemented </span><span>for</span><span> `Rc&lt;String&gt;`
</span><span>note: required because it appears within the </span><span>type</span><span> `Error`
</span><span>   --&gt; src/main.rs:</span><span>17</span><span>:</span><span>16
</span><span>    |
</span><span>17  </span><span>|     </span><span>pub struct </span><span>Error {
</span><span>    |                ^^^^^
</span><span>note</span><span>: required because it appears within the type `Result&lt;Output, Error&gt;`
</span><span>   --&gt; /home/dureuill/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:502:10
</span><span>    |
</span><span>502 | pub enum Result&lt;T, E&gt; {
</span><span>    |          ^^^^^^
</span><span>    = note: required because it appears within the type `(&amp;</span><span>str</span><span>, Result&lt;Output, Error&gt;)`
</span><span>    = note: required for `Sender&lt;(&amp;</span><span>&#39;static str</span><span>, Result&lt;worker::Output, worker::Error&gt;)&gt;` to implement `Send`
</span><span>note: required because it</span><span>&#39;s</span><span> used within this closure
</span><span>   --&gt; src/main.rs:58:32
</span><span>    |
</span><span>58  |             std::thread::spawn(move || loop {
</span><span>    |                                ^^^^^^^
</span><span>note: required by a bound in `spawn`
</span><span>   --&gt; /home/dureuill/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/mod.rs:683:8
</span><span>    |
</span><span>680 | pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
</span><span>    |        ----- required by a bound in this function
</span><span>...
</span><span>683 |     F: Send + </span><span>&#39;static</span><span>,
</span><span>    |        ^^^^ required by this bound in `spawn`
</span></code></pre>
<p>As the compiler nicely explained, it is because the <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-Send-for-Rc%3CT,+A%3E"><code>Rc</code> type does not support being sent between threads</a>, as doing so would cause data races. Indeed, the reference count in <code>Rc</code> is not manipulated in an atomic manner that would be thread safe, it is using regular integer operations.</p>
<p>For thread-safe reference counting, Rust offers <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">another type called <code>Arc</code></a>, that uses <strong>a</strong>tomic <strong>r</strong>eference <strong>c</strong>ounting. Modifying the code to use <code>Arc</code> is a simple matter of:</p>
<pre data-lang="diff"><code data-lang="diff"><span>diff --git a/src/main.rs b/src/main.rs
</span><span>index 04ec0d0..fd4b447 100644
</span><span>--- a/src/main.rs
</span><span>+++ b/src/main.rs
</span><span>@@ -3,9 +3,9 @@ </span><span>use std::{io::Write, time::Duration};
</span><span> mod parse {
</span><span>     use std::{
</span><span>         collections::{hash_map::Entry, HashMap},
</span><span>-        rc::Rc,
</span><span>         sync::{
</span><span>             mpsc::{channel, Receiver, Sender},
</span><span>+            Arc,
</span><span>         },
</span><span>         time::Duration,
</span><span>     };
</span><span>@@ -15,13 +15,13 @@ </span><span>mod parse {
</span><span>
</span><span>     #[derive(Clone, Debug)]
</span><span>     pub struct Error {
</span><span>-        data: Rc&lt;ExpensiveToCloneDirectly&gt;,
</span><span>+        data: Arc&lt;ExpensiveToCloneDirectly&gt;,
</span><span>     }
</span><span>
</span><span>     impl Error {
</span><span>         fn new(data: ExpensiveToCloneDirectly) -&gt; Self {
</span><span>             Self {
</span><span>-                data: Rc::new(data),
</span><span>+                data: Arc::new(data),
</span><span>             }
</span><span>         }
</span><span>     }
</span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b1f40129f7a6c9baf77fde13a4156889">Test this code online</a>)</p>
<p>As long as I didn&#39;t need reference counting to be atomic, I could use <code>Rc</code>. When I needed thread-safety, the compiler forced me to switch to <code>Arc</code> and the overhead of atomic reference counting. This is an illustration of the old principle of &#34;don&#39;t pay for what you don&#39;t use&#34;.</p>
<p>This principle is dear to the heart of C++ developers too, yet in stark contrast to Rust, C++ only has shared pointers with atomic reference counting in its standard library, that is the equivalent to <code>Arc</code>, not <code>Rc</code>. You always pay for the atomic even if you don&#39;t use it. Providing 2 classes was considered, but rejected, notably because <a href="https://stackoverflow.com/a/15140227/1614219">it was deemed too dangerous</a> (&#34;Code written with the unsynchronized <code>shared_ptr</code> may end up being used in threaded code down the road, ending up causing difficult to debug problems with no warning&#34;).</p>
<p>Because Rust will catch these at compile time, it is not dangerous.</p>
<p>On some C++ standard library implementations, there are attempts to recover the lost performance in some limited situations (e.g. the program as a whole is not multi-threaded), <a href="http://snf.github.io/2019/02/13/shared-ptr-optimization/">to hilarious effect on micro-benchmarks</a>.</p>
<h2 id="and-yet-it-fails-to-be-safe"><a href="#and-yet-it-fails-to-be-safe" aria-label="Anchor link for: and-yet-it-fails-to-be-safe">And yet it fails to be safe</a></h2>
<p>Unfortunately the precaution taken by C++ of always having an atomic reference count is still insufficient to make <code>shared_ptr</code> safe in a multi-threaded context, as one should pay attention to a couple of the proverbial footguns.</p>

<p>This is a bit of a subtle issue, and honestly I don&#39;t think I ever ran into that one, but I include it for clarity because sometimes people mix it with the second one.</p>
<p>You can take a <code>shared_ptr</code> and make a copy of it, calling its copy constructor, in a thread-safe way. What you cannot do, however, is share a single instance of a <code>shared_ptr</code> between multiple threads. Imagine having a struct containing a shared pointer that is shared between threads, and a method on that struct that reassigns the shared pointer. If that method is called unsynchronized by multiple threads, then this will result in undefined behavior.</p>
<p>Apparently, this is enough of an issue that C++20 added a <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2">partial template specialization to <code>std::atomic&lt;std::shared_ptr&gt;</code></a>. My advice, though, would be &#34;don&#39;t do that!&#34;. Instead, keep your shared pointer in a single thread, and send copies to other threads as needed.</p>
<p>Since assignment requires at an exclusive reference or an owned object, Rust statically forbids assigning to an <code>Arc</code> that is shared between multiple threads, avoiding the issue at compile time.</p>
<h3 id="the-pointed-to-object-still-requires-synchronization"><a href="#the-pointed-to-object-still-requires-synchronization" aria-label="Anchor link for: the-pointed-to-object-still-requires-synchronization">The pointed-to object still requires synchronization</a></h3>
<p>In a <code>shared_ptr</code>, only the reference counting is atomic, but the pointed-to object needs its own synchronization for writing and reading from different threads. This is a bit of a pitfall because it is tempting to simplify &#34;<code>shared_ptr</code> is a thread-safely-referenced-counted pointer&#34; to &#34;<code>shared_ptr</code> is a thread-safe reference-counted pointer&#34;, while only the former is true.</p>
<p>While this may seem obvious to seasoned developers, I saw a lot more of this issue in the wild, probably always by junior developers ðŸ™ƒ  never by experienced developers refactoring their code to introduce threads ðŸ˜‡</p>
<p>Naturally, Rust <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html#thread-safety">imposes the same requirement</a> on the content of <code>Arc</code>, but <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-Send-for-Arc%3CT,+A%3E">thanks</a> to <a href="https://doc.rust-lang.org/std/marker/trait.Send.html">the <code>Send</code></a> and <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html">the <code>Sync</code></a> traits, and <code>Arc</code> only providing shared reference to its contents, writing and reading the pointed-to object unsynchronized is a compile-time error.</p>
<p>Rust achieves this result entirely thanks to the borrow checker and its type system. It is the only language I used that can statically <a href="https://doc.rust-lang.org/nomicon/races.html">prevent data races</a>.</p>

                            </div></div>
  </body>
</html>
