<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tumfatig.net/2023/using-openbsd-relayd8-as-an-application-layer-gateway/">Original</a>
    <h1>Using OpenBSD Relayd(8) as an Application Layer Gateway</h1>
    
    <div id="readability-page-1" class="page"><div><article><h4><i></i>¬†
<time datetime="2023-10-10">2023-10-10</time>
¬†<i></i>¬†</h4><nav id="TableOfContents"><ol><li><a href="#what-is-relayd8">What is relayd(8)?</a></li><li><a href="#how-to-manage-relayd8">How to manage relayd(8)?</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#simplest-http-relay">Simplest HTTP relay</a></li><li><a href="#better-simple-http-relay">Better simple HTTP relay</a></li><li><a href="#encrypt-http-relay-using-transport-layer-security-tls">Encrypt HTTP relay using Transport Layer Security (TLS)</a></li><li><a href="#load-balancing--failover">Load balancing &amp; Failover</a></li><li><a href="#fallback-servers---automatic-switch">Fallback server(s) - automatic switch</a></li><li><a href="#fallback-servers---manual-switch">Fallback server(s) - manual switch</a><ol><li><a href="#initial-expected-state">Initial expected state</a></li><li><a href="#primary-servers-go-down">Primary servers go down</a></li><li><a href="#switch-to-the-secondary-servers-pool">Switch to the secondary servers pool</a></li></ol></li><li><a href="#relaying-multiple-fqdns">Relaying multiple FQDNs</a></li><li><a href="#relaying-multiple-pathnames">Relaying multiple pathnames</a></li><li><a href="#solving-problems-with-http-headers">Solving problems with HTTP headers</a><ol><li><a href="#unencrypted-connection">Unencrypted connection</a></li><li><a href="#leaking-headers">Leaking headers</a></li><li><a href="#improve-users-security-and-privacy">Improve users security and privacy</a></li></ol></li><li><a href="#log-management">Log management</a><ol><li><a href="#one-for-log-and-log-for-one">One for log and log for one</a></li><li><a href="#logging-options">Logging options</a></li></ol></li><li><a href="#conditional-filtering">Conditional filtering</a><ol><li><a href="#filtering-branched-on-fqdn-12">Filtering branched on FQDN #(1,2)</a></li><li><a href="#filtering-branched-on-fqdn-3">Filtering branched on FQDN #3</a></li><li><a href="#filtering-branched-on-fqdn-4">Filtering branched on FQDN #4</a></li><li><a href="#connecting-the-branches">Connecting the branches</a></li></ol></li><li><a href="#one-more-thing">One more thing</a></li></ol></nav><p>I was lucky enough to attend to EuroBSDCon 2023 and offered the
opportunity to talk about one of my favorite OpenBSD stock daemon:
relayd(8).</p><p>The talk was recorded and made <a href="https://www.youtube.com/watch?v=yW8QSZyEs6E" target="_blank" rel="external nofollow">available on the EuroBSDCon YouTube
channel.</a>
. One may check
the <a href="https://2023.eurobsdcon.org/program.html" target="_blank" rel="external nofollow">EuroBSDCon 2023 program</a>
for more material.</p><p>This post attempts a reboot of the slides content in a more
browser-friendly format.</p><ul><li>Multi-purpose daemon available on OpenBSD since 4.3*:<ul><li>load-balancer.</li><li>application layer gateway.</li><li>transparent proxy.</li></ul></li><li>Capable of monitoring groups of hosts for high-availability.</li><li>Operates as:<ul><li>Layer 3 redirection via communication with pf(4).</li><li>Layer 7 relaying with application level filtering via itself.</li></ul></li></ul><p><a target="_blank" href="https://www.tumfatig.net/images/2023/relayd-rp.png"><img src="https://www.tumfatig.net/images/2023/relayd-rp.png" alt="Using relayd(8) as a reverse-proxy"/></a></p><p>* relayd was known as hoststated in OpenBSD 4.1.</p><p>The man pages are a must read before proceeding further.</p><pre tabindex="0"><code># man relayd
# man relayd.conf
# man relayctl
</code></pre><p>The configuration file is expected in the standard <code>etc</code> directory. An
example is available if you need more inspiration.</p><pre tabindex="0"><code># more /etc/examples/relayd.conf
# vi /etc/relayd.conf
</code></pre><p>One can check for configuration errors using:</p><pre tabindex="0"><code># relayd -dvn
</code></pre><p>The service is enabled and started using the standard <code>rcctl</code> utility:</p><pre tabindex="0"><code># rcctl enable relayd
# rcctl start relayd
# rcctl stop relayd
</code></pre><p>A dedicated command can be used to get more information about relayd(8)
state and apply specific actions:</p><pre tabindex="0"><code># relayctl ùò§ùò∞ùòÆùòÆùò¢ùòØùò• [ùò¢ùò≥ùò®ùò∂ùòÆùò¶ùòØùòµ ...]
</code></pre><p>More on this later on.</p><ul><li><p>Macros: user-defined variables that can be used later on.</p></li><li><p>Tables: host or a group of hosts defining traffic targets.</p></li><li><p>Protocols: settings and filter rules for relays.</p></li><li><p>Relays: layer 7 proxying instances.</p></li></ul><p>This is the simplest HTTP Reverse proxy configuration that you can get:</p><pre tabindex="0"><code data-lang="pf">http protocol www {
    pass
}

relay www {
    listen on 203.0.113.1 port 80
    protocol www
    forward to 192.0.2.10 port 80
}
</code></pre><p>The first section defines an HTTP PROTOCOL object. Name has been set to
‚Äòwww‚Äô but it can be anything.</p><p>The RELAY section defines a listening address and port. It links the
relay to the previously configured protocol. It defines the backend
server that will receive the HTTP requests.</p><p>This example expands the previous HTTP Reverse proxy configuration with
usage of reusable variables (MACROS) and logging of state changes and
remote connections.</p><pre tabindex="0"><code data-lang="pf"># Macros -----------------------------------
ext_addr=&#34;203.0.113.1&#34;
webhost1=&#34;192.0.2.10&#34;

# Global configuration ---------------------
log state changes
log connection

# Tables -----------------------------------
table &lt;webhosts&gt; { $webhost1 }

# Protocols &amp; Relays -----------------------
http protocol www {
    pass
}

relay www {
    listen on $ext_addr port 80
    protocol www

    forward to &lt;webhosts&gt; port 80
}
</code></pre><p>Previous examples are using plain text HTTP. Switching to HTTPS provides
secure communication and data transfer between the client and the
website.</p><p>You‚Äôll need to acquire a TLS certificate. That steps is beyong the scope
of this post. But have a look at acme-client(1) and httpd(8) manpages.
Those will guide you through the process of getting an HTTPS certificate.</p><p>Once acquired, install the certificate under <code>/etc/ssl</code>. If you used
acme-client(1), you should get files such as:</p><pre tabindex="0"><code>/etc/ssl/private/relayd.example.key
/etc/ssl/relayd.example.crt
</code></pre><p>Reference the certificate name in the protocol section. Then replace the
listen directive of the relay section to specify the usage of <code>tls</code>.</p><pre tabindex="0"><code data-lang="pf"># Macros -----------------------------------
ext_addr=&#34;203.0.113.1&#34;
webhost1=&#34;192.0.2.10&#34;

# Global configuration ---------------------
log state changes
log connection

# Tables -----------------------------------
table &lt;webhosts&gt; { $webhost1 }

# Protocols &amp; Relays -----------------------
http protocol wwwtls {
    tls keypair relayd.example
}

relay wwwtls {
    listen on $ext_addr port 443 tls
    protocol wwwtls

    forward to &lt;webhosts&gt; port 80
}
</code></pre><p>Renaming the protocol and relay names is not mandatory. I only did it to
make it clear what I‚Äôm doing.</p><p>relayd(8) allows to distribute incoming requests to several backend
servers. Depending on its configuration, you can balance the load on
those servers and/or keep the service up and running since you only
encounted n-1 failure(s).</p><pre tabindex="0"><code data-lang="pf">ext_addr=&#34;203.0.113.1&#34;
whost1=&#34;192.0.2.11&#34;
whost2=&#34;192.0.2.12&#34;
whost3=&#34;192.0.2.13&#34;
interval 5
table &lt;webhosts&gt; { $whost1, $whost2, $whost3 }

http protocol wwwtls {
   tls keypair relayd.example
}

relay wwwtls {
    listen on $ext_addr port 443 tls
    protocol wwwtls
    # l/b using source-IP, check HTTP return code
    forward to &lt;webhosts&gt; port 80  \
      mode loadbalance             \
      check &#34;/health-check&#34; code 200
}
</code></pre><p>In this example, a TABLE has been created that references all the backend
servers - those that will receive the HTTP requests.</p><p>There are many scheduling algorithms (aka MODE) available. Check the man
page for more details. The default is using roundrobin and no health
checks. Here, we‚Äôre using the loadbalance algorythm and return code check.</p><p>There are cases when you want to implement automatic reaction on
server(s) outage events. You may want to switch the whole service to a
secondary server pool. You may display an incident status page
rather that an HTTP/500 error page. You should probably display a static
‚Äúbe back soon‚Äù page while performing maintenance.</p><p>This is what the fallback feature can be used for.</p><pre tabindex="0"><code data-lang="pf">ext_addr=&#34;203.0.113.1&#34;
whost1=&#34;192.0.2.11&#34;
whost2=&#34;192.0.2.12&#34;
whost3=&#34;192.0.2.13&#34;
interval 5
table &lt;webhosts&gt; { $whost1, $whost2 }
table &lt;fallback&gt; { $whost3 }

http protocol wwwtls {
   tls keypair relayd.example
}

relay wwwtls {
  listen on $ext_addr port 443 tls
  protocol wwwtls

  # l/b using round-robin, check HTTP return code
  forward to &lt;webhosts&gt; port 80 mode roundrobin \
    check http &#34;/&#34; code 200
  # switch service if all previous checks fail
  forward to &lt;fallback&gt; port 80
}
</code></pre><p>Two TABLEs have been defined. One for the primary server(s). One for the
fallback server(s). Then, everything happens in the relay section. The
first forward directive load-balances the HTTP requests to the primary
servers pool. The second forward directive acts as the fallback target.
It will be triggered as soon as no servers from the primary pool are
known to be working.</p><p>In a use-case where you prefer managed operations on server(s) outage,
you may configure a non-automatic switch. This mostly apply to Business
Continuity Plan where the secondary servers pool is remote or mutualized
or resources limited etc.</p><pre tabindex="0"><code data-lang="pf">ext_addr=&#34;203.0.113.1&#34;
whost1=&#34;192.0.2.11&#34;
whost2=&#34;192.0.2.12&#34;
whost3=&#34;192.0.2.13&#34;
whost4=&#34;192.0.2.14&#34;
interval 5
table &lt;webhosts&gt;         { $whost1, $whost2 }
table &lt;fallback&gt; disable { $whost3, $whost4 }

http protocol wwwtls {
   tls keypair relayd.example
}

relay wwwtls {
  listen on $ext_addr port 443 tls
  protocol wwwtls

  # l/b using source-IP, check HTTP return code
  forward to &lt;webhosts&gt; port 80 mode loadbalance \
    check http &#34;/&#34; code 200
  # l/b using round-robin, check HTTP return code
  forward to &lt;fallback&gt; port 80 mode roundrobin \
    check http &#34;/&#34; code 200
}
</code></pre><p>The main difference with the previous configuration is the <code>disable</code>
property of the fallback table. This implies that it won‚Äôt be used by
relayd(8) unless being told to.</p><h2 id="initial-expected-state">Initial expected state</h2><p>Usage of the <code>relayctl</code> command confirms that the primary servers pool
is working as expected.</p><pre tabindex="0"><code># relayctl show summary
Id      Type            Name                            Avlblty Status
1       relay           wwwtls                                  active
1       table           webhosts:80                             active (2 hosts)
1       host            192.0.2.11                      100.00% up
2       host            192.0.2.12                      100.00% up
2       table           fallback:80                             disabled
</code></pre><ul><li>Primary hosts are up and running.</li><li>Secondary hosts are disabled.</li></ul><p>The service is UP.</p><h2 id="primary-servers-go-down">Primary servers go down</h2><p>On a clear service breakdown, <code>relayctl</code> will indicate that the primary
hosts are down.</p><pre tabindex="0"><code># relayctl show summary
Id      Type            Name                            Avlblty Status
1       relay           wwwtls                                  active
1       table           webhosts:80                             empty
1       host            192.0.2.11                      95.56%  down
2       host            192.0.2.12                      95.56%  down
2       table           fallback:80                             disabled
</code></pre><ul><li>Primary hosts are down.</li><li>Secondary hosts are disabled.</li></ul><p>The service is DOWN. Nothing happens as relayd(8) was told to start the
fallback table disabled.</p><h2 id="switch-to-the-secondary-servers-pool">Switch to the secondary servers pool</h2><p><code>relayctl</code> is used to enable the disabled fallback. This happens
without the need of restarting relayd.</p><pre tabindex="0"><code># relayctl table enable 2
command succeeded

# relayctl show summary
Id      Type            Name                            Avlblty Status
1       relay           wwwtls                                  active
1       table           webhosts:80                             empty
1       host            192.0.2.11                      76.79%  down
2       host            192.0.2.12                      76.79%  down
2       table           fallback:80                             active (2 hosts)
3       host            192.0.2.13                      100.00% up
4       host            192.0.2.14                      100.00% up
</code></pre><ul><li>Primary hosts are down.</li><li>Secondary hosts are enabled.</li></ul><p>The service is UP.</p><p>Note that failback shall happen as soon as relayd detects a Primary host
up. If this is not something you want to happen, use <code>relayctl table disable 1</code> to prevent such an automatic failback.</p><p>What if you want to expose multiple hostnames using a single IP?</p><pre tabindex="0"><code data-lang="pf">(...)
table &lt;blog&gt;  { $whost1, $whost2 }
table &lt;cloud&gt; { $whost3 }

http protocol wwwtls {
  tls keypair blog.example
  tls keypair nextcloud.example

  block
  pass request header &#34;Host&#34; value &#34;blog.example&#34;  \
    forward to &lt;blog&gt;
  pass request header &#34;Host&#34; value &#34;cloud.example&#34; \
    forward to &lt;cloud&gt;
}

relay wwwtls {
  listen on $ext_addr port 443 tls
  protocol wwwtls
  forward to &lt;blog&gt;  port 80 mode roundrobin \
    check http &#34;/&#34; code 200
  forward to &lt;cloud&gt; port 80
}
</code></pre><p>This configuration example checks every HTTP requests‚Äô header and route
them to the proper backend server depending on the value of the ‚ÄúHost‚Äù
header. The backend servers are referenced in tables.</p><p>Using multiple ‚Äúkeypair‚Äù directives to reference the HTTPS certificates
enables the TLS Server Name Indication (SNI) feature of relayd(8).</p><p>Apache has location directives. nginx has location blocks. To design
reaction rules (allow, deny, forward‚Ä¶) depending on URL paths,
relayd(8) can use FILTER RULES based on the ‚Äúpath‚Äù keyword.</p><pre tabindex="0"><code data-lang="pf">(...)
table &lt;blog&gt;  { $whost1, $whost2 }
table &lt;cloud&gt; { $whost3 }

http protocol wwwtls {
  tls keypair relayd.example

  block quick path &#34;/cgi-bin*&#34;
  block quick path &#34;/wp-admin*&#34;
  pass  quick path &#34;/nextcloud/*&#34; forward to &lt;cloud&gt;
  pass  request                   forward to &lt;blog&gt;
}

relay wwwtls {
  listen on $ext_addr port 443 tls
  protocol wwwtls

  forward to &lt;blog&gt; port 80 mode roundrobin \
    check http &#34;/&#34; code 200
  forward to &lt;cloud&gt; port 80
}
</code></pre><p>This configuration blocks any attempt to access paths that look like
<code>/cgi-bin</code> and <code>/wp-admin</code>. It also routes any URL matching
<code>https://relayd.example/nextcloud/</code> to the ‚Äúcloud‚Äù servers pool. Any
other URL will be routed to the ‚Äúblog‚Äù table.</p><p>relayd(8) can add, remove or modify HTTP header on the fly. This allows
solving various kinds of issues with exposed Web services.</p><h2 id="unencrypted-connection">Unencrypted connection</h2><p>There are software like Baikal, Mastodon or SearxNG that refuse to serve
unencrypted content. If you still want to run them using plain text HTTP
on the backend server and feel confident about using relayd(8) as an SSL
terminator, you shall add an HTTP header to the requests reaching the backend
HTTP server.</p><pre tabindex="0"><code data-lang="pf">(...)
http protocol wwwtls {
  tls keypair blog.example
  tls keypair nextcloud.example

  block
  pass request header &#34;Host&#34; value &#34;blog.example&#34;  forward to &lt;blog&gt;
  pass request header &#34;Host&#34; value &#34;cloud.example&#34; forward to &lt;cloud&gt;

  match request header set &#34;X-Forwarded-Proto&#34; value &#34;https&#34;
}
(...)
</code></pre><p>In this particular case, the <code>X-Forwarded-Proto</code> is set to ‚Äúhttps‚Äù and
passed to the backend server to confirm that the communication is
secured using TLS.</p><p>From time to time, you discover that Web services fill their HTTP
replies with too many information. Too many meaning not mandatory to
provide a functionnal user experience while still leaking sensible
information to the external world.</p><pre tabindex="0"><code data-lang="pf">(...)
http protocol wwwtls {
  tls keypair relayd.example

  pass  quick path &#34;/nextcloud/*&#34; forward to &lt;cloud&gt;
  pass  request                   forward to &lt;blog&gt;

  match response header remove &#34;X-Powered-By&#34;
  match response header set &#34;Server&#34; value &#34;Microsoft-IIS/8.5&#34;
}
(...)
</code></pre><p>This configuration removes any <code>X-Powered-By</code> information from every HTTP
replies. It also sets the <code>Server</code> HTTP header to some specific value that
can be used to fool script kiddies ; or to deal with faulty Web clients
that expects a specific value.</p><h2 id="improve-users-security-and-privacy">Improve users security and privacy</h2><p>Some software don‚Äôt really bother about security and privacy. Sometimes, it‚Äôs
just that they expect you to use an htaccess-compatible Web server to provide
a couple of HTTP headers that can help protecting the user.</p><pre tabindex="0"><code data-lang="pf">(...)
http protocol wwwtls {
  tls keypair relayd.example

  pass  quick path &#34;/nextcloud/*&#34; forward to &lt;cloud&gt;
  pass  request                   forward to &lt;blog&gt;

  match response header set &#34;X-XSS-Protection&#34;       value &#34;1; mode=block&#34;
  match response header set &#34;X-Content-Type-Options&#34; value &#34;nosniff&#34;
  match response header set &#34;Permissions-Policy&#34;     value &#34;accelerometer=(),
ambient-light-sensor=(),autoplay=(),camera=(),encrypted-media=(),
focus-without-user-activation=(),geolocation=(),gyroscope=(),
magnetometer=(),microphone=(),midi=(),payment=(),picture-in-picture=(),
speaker=(),sync-xhr=(),usb=(),vr=()&#34;
}
(...)
</code></pre><p>This example only shows a subset of HTTP headers that can be set to
improve users privacy and protection. Check your Web application using
tools like <a href="https://observatory.mozilla.org/" target="_blank" rel="external nofollow">Mozilla Observatory</a>
to
get a better overview of what should / could be achieved on your server.</p><p>The default relayd(8) log configuration doesn‚Äôt suit me well. Traces
appear in several log files and are not detailed enough to my linkings
when it comes to debugging issues.</p><h2 id="one-for-log-and-log-for-one">One for log and log for one</h2><p>To have relayd(8) log in its own dedicated log file, I‚Äôd rather tune
syslogd(8):</p><pre tabindex="0"><code># touch /var/log/relayd

# vi /etc/syslog.conf
!!relayd
*.* /var/log/relayd
!*
(...)

# vi /etc/newsyslog.conf
(...)
/var/log/relayd root:_relayd 640 7 * $D0 ZB

# rcctl restart syslogd
</code></pre><h2 id="logging-options">Logging options</h2><p>Some matching FILTER RULES can be defined to have more information
appear in the log files.</p><pre tabindex="0"><code data-lang="pf">http protocol wwwtls {
  tls keypair relayd.example

  match url log
  match header log &#34;Host&#34;
  match header log &#34;User-Agent&#34;
  match response header log &#34;Content-Type&#34;
  match response header log &#34;Content-Length&#34;

  pass  quick path &#34;/nextcloud/*&#34; forward to &lt;cloud&gt;
  pass  request                   forward to &lt;blog&gt;
}
</code></pre><p>This particular example provides HTTP header information in the
relayd(8) logs.</p><pre tabindex="0"><code>Sep 17 14:35:12 ebsdc relayd[34137]: relay wwwtls, session 1 (1 active), 0, 
    203.0.113.1 -&gt; 127.0.0.1:80, done, 
    [blog.example/about] [Host: blog.example] [User-Agent: curl/8.2.0] 
    GET -&gt; 127.0.0.1:80 {Content-Type: text/html} {Content-Length: 41};
</code></pre><p>Any HTTP header can be matched and rendered in the logs. Select yours.</p><p>Using TAGS and INCLUDES, relayd(8) can perform different computation and
actions depending on wether or not conditions evaluate to true or false.
Here‚Äôs an example of some slightly complex conditional filtering that
can be designed in relayd(8).</p><p><a target="_blank" href="https://www.tumfatig.net/images/2023/relayd-cf.png"><img src="https://www.tumfatig.net/images/2023/relayd-cf.png" alt="Using relayd(8) as a reverse-proxy"/></a></p><h2 id="filtering-branched-on-fqdn-12">Filtering branched on FQDN #(1,2)</h2><p>In a dedicated configuration file, a TAG is set if the ‚ÄúHost‚Äù HTTP
header of the requests matches one of the defined value. Then for each
TAGGED connections, relayd(8) will apply additionnal logging and improve
users security and privacy.</p><pre tabindex="0"><code data-lang="pf"># cat /etc/relayd-ssg.conf

# Mark using hostnames
match request header &#34;Host&#34; value &#34;www.example&#34;     tag &#34;ssg&#34;
match request header &#34;Host&#34; value &#34;blog.example&#34;    tag &#34;ssg&#34;

# Apply additionnal logging
match header log &#34;Host&#34;       tagged &#34;ssg&#34;
match header log &#34;User-Agent&#34; tagged &#34;ssg&#34;
match url    log              tagged &#34;ssg&#34;

# Improve Security and Privacy
match response tagged &#34;ssg&#34; header set \
  &#34;Strict-Transport-Security&#34; value &#34;max-age=31536000; includeSubDomains; preload&#34;
match response tagged &#34;ssg&#34; header set \
  &#34;X-XSS-Protection&#34; value &#34;1; mode=block&#34;
match response tagged &#34;ssg&#34; header set \
  &#34;X-Content-Type-Options&#34; value &#34;nosniff&#34;
</code></pre><h2 id="filtering-branched-on-fqdn-3">Filtering branched on FQDN #3</h2><p>In a dedicated configuration file, a TAG is set if the ‚ÄúHost‚Äù HTTP
header of the requests matches the defined value. Then for each TAGGED
connections, a check is done on the ‚ÄúUser-Agent‚Äù HTTP header and a block
happens for the referenced values. Another check is done, based on the
URL and the source IP, to ensure only trusted computer can acces an
adminstrative URL. In the end, any acceptable HTTP session will have the
‚ÄúServer‚Äù HTTP header removed from the HTTP reply.</p><pre tabindex="0"><code data-lang="pf"># cat /etc/relayd-nextcloud.conf

# Mark using hostname
match request header &#34;Host&#34; value &#34;cloud.example&#34;   tag &#34;nextcloud&#34;

# Block User Agents
block request quick tagged &#34;nextcloud&#34; header &#34;User-Agent&#34; value &#34;Googlebot/*&#34;
block request quick tagged &#34;nextcloud&#34; header &#34;User-Agent&#34; value &#34;YandexBot/*&#34;

# Only allow &#34;admin&#34; path from specific subnet
match request                   url &#34;cloud.example/admin/&#34; tag &#34;forbidden&#34;
match request from 192.0.2.0/24 url &#34;cloud.example/admin/&#34; tag &#34;nextcloud&#34;

# Don&#39;t let version leak via HTTP header
match response tagged &#34;nextcloud&#34; header remove &#34;Server&#34;
</code></pre><h2 id="filtering-branched-on-fqdn-4">Filtering branched on FQDN #4</h2><p>In a dedicated configuration file, a TAG is set if some trusted computer
try to access an allowed FQDN. Any TAGGED connections will have its path
checked for some regex and tagged if matched. Those connections will
have an HTTP header set in their reply.</p><pre tabindex="0"><code data-lang="pf"># cat /etc/relayd-grafana.conf

# Mark using client source IP and path
match request from 192.0.2.0/24    url &#34;metrics.example/&#34; tag &#34;grafana&#34;
match request from 198.51.100.8/32 url &#34;metrics.example/&#34; tag &#34;grafana&#34;

# Overwrite caching
match request tagged &#34;grafana&#34; path &#34;*.css&#34; tag &#34;g-cache&#34;
match request tagged &#34;grafana&#34; path &#34;*.js&#34;  tag &#34;g-cache&#34;
match request tagged &#34;grafana&#34; path &#34;*.png&#34; tag &#34;g-cache&#34;

match response tagged &#34;g-cache&#34; header set &#34;Cache-Control&#34; value &#34;max-age=86400&#34;
</code></pre><h2 id="connecting-the-branches">Connecting the branches</h2><p>In the main relayd(8) configuration file, the dedicated config files are
included so that tagging happens, or not. The routing to the proper
backend servers will happen for every TAGGED connections. The <code>block</code>
directive will drop any connection that has not been matched by the
filtering definition.</p><pre tabindex="0"><code data-lang="pf"># cat /etc/relayd.conf

table &lt;blog&gt;    { $whost1, $whost2 }
table &lt;cloud&gt;   { $whost3 }
table &lt;grafana&gt; { $whost4 }

http protocol wwwtls {
  tls keypair www.example
  tls keypair cloud.example
  tls keypair metrics.example

  block

  include &#34;/etc/relayd-ssg.conf&#34;
  include &#34;/etc/relayd-nextcloud.conf&#34;
  include &#34;/etc/relayd-grafana.conf&#34;

  pass request tagged &#34;ssg&#34;       forward to &lt;blog&gt;
  pass request tagged &#34;nextcloud&#34; forward to &lt;cloud&gt;
  pass request tagged &#34;grafana&#34;   forward to &lt;grafana&gt;
  pass request tagged &#34;g-cache&#34;   forward to &lt;grafana&gt;
}
</code></pre><p>Remarks and answers given during the live session:</p><ul><li>Beware that pf(4) and relayd(8) TABLES are not the same things although they
share the same name.</li><li>PROTOCOL and RELAY names can be any string you like. I had some weird
behaviour when using underscores or hyphens. I don‚Äôt remember which
exactly. So I just avoid them. They just have to match with one
another.</li><li>I have no load metrics. I use relayd(8) on personal projects and have
not faced any specific issues. But if you expect lots of connections,
you may need to increase the <code>prefork</code> value and/or tune the <code>tcp</code>
options.</li><li>In real Enterprise World, you may combine relayd(8) and carp(4) to
achieve a better SLA.</li></ul><p>The original <a href="https://www.bryanbraun.com/files/2023/eurobsdcon2023-relayd.pdf" target="_blank" rel="external nofollow">slides are available
here</a>
. Because OpenBSD and
because fun, you can get the <a href="https://www.bryanbraun.com/files/2023/eurobsdcon2023-relayd-sketch.pdf" target="_blank" rel="external nofollow">same slides rendered in Comic font</a>
.</p></article></div></div>
  </body>
</html>
