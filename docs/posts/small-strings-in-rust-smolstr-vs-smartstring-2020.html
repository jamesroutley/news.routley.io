<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/articles/small-strings-in-rust">Original</a>
    <h1>Small Strings in Rust: smolstr vs. smartstring (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
        

    


<div>
    <p><a href="https://blog.plover.com/">Home</a></p><form action="/search" method="GET">
        
    </form>
    
    <p><span></span>

    
        <a href="https://blog.plover.com/login" rel="nofollow">Log in</a>
    
</p></div>


        

        
            
            
                <div>
        <p><span>
	<a href="https://blog.plover.com/about">
		<img alt="Avatar for fasterthanlime" src="https://cdn.fasterthanli.me/static/img/logo-round-2~36eb4df57846d593.png"/>
		fasterthanlime
	</a>
</span>

    </p></div>

    <p><span>
            Jul  5, 2020
        </span>
        

        
            
                <span>
                    <img id="clock-icon" src="https://cdn.fasterthanli.me/static/img/clock~3a596efef3def988.svg" alt="clock icon" width="16" height="16"/>
                    <abbr title="At 220 words per minute, where one word = 5 characters">
                        34 minute read
                    </abbr>
                </span>
            
        

        
        
            <span>
                
                    
                        <span><a href="https://blog.plover.com/tags/rust">#rust</a></span>
                    
                
            </span>
        

        

        
        
            
        
        
    </p>





        <!-- page_html starts -->
        <p>Hey everyone!</p><p>This article is brought to you by a <a href="https://twitter.com/killercup/status/1279432235133870082">shameless nerd
snipe</a>, courtesy of
Pascal.</p><p>In case you&#39;ve blocked Twitter for your own good, this reads:</p><blockquote><p>There should be a post explaining and comparing
<a href="https://crates.io/crates/smol_str">smolstr</a> and <a href="https://crates.io/crates/smartstring">smartstring</a> (and
maybe others, like smallstr)</p></blockquote><p>Well, I took the bait.</p><p>But, since this is me writing, I get to set the rules:</p><ul><li>There will be no &#34;maybe others&#34; - we&#39;ll review just the first two</li><li>We&#39;re going to allow ourselves at least three digressions.</li></ul><p>Let&#39;s get started - there is much to do.</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo new small
     Created binary (application) `small` package
</pre></div><h2><a id="scaffolding" href="#scaffolding"></a>Scaffolding</h2><p>Our little crate is going to go places, so I want to set up a few things
ahead of time - I&#39;m going to use <code>argh</code> to parse arguments.</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo add argh
      Adding argh v0.1.3 to dependencies
</pre></div><p>And I&#39;m going to set up subcommands - for now, we&#39;ll only have one,
named <code>sample</code>. It&#39;s going to go into its own module.</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/main.rs`</i>

<i>pub</i> <i>mod</i> sample<i>;</i>

<i>use</i> argh<i>::</i>FromArgs<i>;</i>

<i>#<i>[</i>derive<i>(</i>FromArgs<i>)</i><i>]</i></i>
<i>/// Small string demo
</i><i>struct</i> <i>Args</i> <i>{</i>
    <i>#<i>[</i>argh<i>(</i>subcommand<i>)</i><i>]</i></i>
    <i>subcommand</i><i>:</i> <i>Subcommand</i><i>,</i>
<i>}</i>

<i>#<i>[</i>derive<i>(</i>FromArgs<i>)</i><i>]</i></i>
<i>#<i>[</i>argh<i>(</i>subcommand<i>)</i><i>]</i></i>
<i>enum</i> <i>Subcommand</i> <i>{</i>
    Sample<i>(</i>sample<i>::</i><i>Sample</i><i>)</i><i>,</i>
<i>}</i>

<i>impl</i> <i>Subcommand</i> <i>{</i>
    <i>fn</i> <i>run</i><i>(</i><i>self</i><i>)</i> <i>{</i>
        <i>match</i> <i>self</i> <i>{</i>
            <i>Subcommand</i><i>::</i>Sample<i>(</i>x<i>)</i> =&gt; x<i>.</i><i>run</i><i>(</i><i>)</i><i>,</i>
        <i>}</i>
    <i>}</i>
<i>}</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> <i>{</i>
    <i>// see https://turbo.fish/</i>
    argh<i>::</i><i>from_env</i><i>::</i><i>&lt;</i><i>Args</i><i>&gt;</i><i>(</i><i>)</i><i>.</i><i>subcommand</i><i>.</i><i>run</i><i>(</i><i>)</i><i>;</i>
<i>}</i>
</pre></div><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/sample.rs`</i>

<i>use</i> argh<i>::</i>FromArgs<i>;</i>

<i>#<i>[</i>derive<i>(</i>FromArgs<i>)</i><i>]</i></i>
<i>/// Run sample code
</i><i>#<i>[</i>argh<i>(</i>subcommand<i>,</i> name = <i>&#34;sample&#34;</i><i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>Sample</i> <i>{</i><i>}</i>

<i>impl</i> <i>Sample</i> <i>{</i>
    <i>pub</i> <i>fn</i> <i>run</i><i>(</i><i>self</i><i>)</i> <i>{</i>
        <i>todo</i><i>!</i><i>(</i><i>)</i>
    <i>}</i>
<i>}</i>
</pre></div><p>Let&#39;s try it out:</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run -- sample
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/small sample`
thread &#39;main&#39; panicked at &#39;not yet implemented&#39;, src/sample.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</pre></div><p>Wonderful. That&#39;s all we need for now.</p><h2><a id="parsing-a-json-data-set" href="#parsing-a-json-data-set"></a>Parsing a JSON data set</h2><p>Our task for today is going to be: parsing a list of the <a href="https://gist.github.com/fasterthanlime/52664aadaf55fec2ffd280969c028cfc">1000 largest US
cities</a>
from a JSON file.</p><p>If you&#39;re following along, download that gist to a file named <code>cities.json</code>
directly into the <code>small/</code> folder.</p><p><a href="https://crates.io/crates/serde">serde</a> and <a href="https://crates.io/crates/serde_json">serde_json</a>
are going to make this task very easy.</p><div translate="no"><p>TOML markup</p><pre data-lang="toml"><i># in Cargo.toml</i>

<i>[</i><i>dependencies</i><i>]</i>
<i>argh</i> <i>=</i> <i>&#34;0.1.3&#34;</i>

<i># these two are new:</i>
<i>serde</i> <i>=</i> <i>{</i> <i>version</i> <i>=</i> <i>&#34;1.0.114&#34;</i><i>,</i> <i>features</i> <i>=</i> <i>[</i><i>&#34;derive&#34;</i><i>]</i> <i>}</i>
<i>serde_json</i> <i>=</i> <i>&#34;1.0.56&#34;</i>
</pre></div><p>The dataset contains a lot of information, including population growth,
geographic coordinates, population, and rank. We&#39;re only interested in the
city name, and the state name.</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/sample.rs`</i>

<i>impl</i> <i>Sample</i> <i>{</i>
    <i>pub</i> <i>fn</i> <i>run</i><i>(</i><i>self</i><i>)</i> <i>{</i>
        <i>self</i><i>.</i><i>read_records</i><i>(</i><i>)</i><i>;</i>
    <i>}</i>

    <i>fn</i> <i>read_records</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> <i>{</i>
        <i>use</i> serde<i>::</i>Deserialize<i>;</i>

        <i>#<i>[</i>derive<i>(</i>Deserialize<i>)</i><i>]</i></i>
        <i>struct</i> <i>Record</i> <i>{</i>
            <i>#<i>[</i>allow<i>(</i>unused<i>)</i><i>]</i></i>
            <i>city</i><i>:</i> <i>String</i><i>,</i>
            <i>#<i>[</i>allow<i>(</i>unused<i>)</i><i>]</i></i>
            <i>state</i><i>:</i> <i>String</i><i>,</i>
        <i>}</i>

        <i>use</i> std<i>::</i>fs<i>::</i>File<i>;</i>
        <i>let</i> f = <i>File</i><i>::</i><i>open</i><i>(</i><i>&#34;cities.json&#34;</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> records<i>:</i> <i>Vec</i><i>&lt;</i><i>Record</i><i>&gt;</i> = serde_json<i>::</i><i>from_reader</i><i>(</i>f<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;Read {} records&#34;</i><i>,</i> records<i>.</i>len<i>(</i><i>)</i><i>)</i><i>;</i>
    <i>}</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run -- sample
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `target/debug/small sample`
Read 1000 records
</pre></div><p>Fantastic. That was easy!</p><h2><a id="profiling-memory-allocations" href="#profiling-memory-allocations"></a>Profiling memory allocations</h2><p>I&#39;m interested in how much memory our program is using, and also how many
allocations and deallocations it does.</p><p>We&#39;ve used the Massif tool (from the Valgrind suite) in <a href="https://blog.plover.com/articles/abstracting-away-correctness">Abstracting away
correctness</a>, to demonstrate a
bug in Go&#39;s <code>runtime/pe</code> package.</p><p>But today I feel like trying something a little different.</p><p>Something a little more ad hoc. A little more fun.</p><p>We&#39;re going to make a tracing allocator.</p><p>Well, to start with, we&#39;re just going to wrap the system allocator.</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/main.rs`</i>

<i>pub</i> <i>mod</i> alloc<i>;</i>
</pre></div><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/alloc.rs`</i>

<i>use</i> std<i>::</i>alloc<i>::</i><i>{</i>GlobalAlloc<i>,</i> System<i>}</i><i>;</i>

<i>pub</i> <i>struct</i> <i>Tracing</i> <i>{</i>
    <i>pub</i> <i>inner</i><i>:</i> <i>System</i><i>,</i>
<i>}</i>

<i>impl</i> <i>Tracing</i> <i>{</i>
    <i>pub</i> <i>const</i> <i>fn</i> <i>new</i><i>(</i><i>)</i> -&gt; <i>Self</i> <i>{</i>
        <i>Self</i> <i>{</i> <i>inner</i><i>:</i> System <i>}</i>
    <i>}</i>
<i>}</i>

<i>unsafe</i> <i>impl</i> <i>GlobalAlloc</i> <i>for</i> <i>Tracing</i> <i>{</i>
    <i>unsafe</i> <i>fn</i> <i>alloc</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>layout</i><i>:</i> std<i>::</i>alloc<i>::</i><i>Layout</i><i>)</i> -&gt; <i>*</i><i>mut</i> <i>u8</i> <i>{</i>
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>alloc</i><i>(</i>layout<i>)</i>
    <i>}</i>
    <i>unsafe</i> <i>fn</i> <i>dealloc</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>ptr</i><i>:</i> <i>*</i><i>mut</i> <i>u8</i><i>,</i> <i>layout</i><i>:</i> std<i>::</i>alloc<i>::</i><i>Layout</i><i>)</i> <i>{</i>
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>dealloc</i><i>(</i>ptr<i>,</i> layout<i>)</i>
    <i>}</i>
<i>}</i>
</pre></div><p>All of this is in Rust stable, by the way.</p><div>

<p>Why does <code>GlobalAlloc</code> require an <code>unsafe impl</code>?</p><p>It&#39;s not only unsafe to call its methods, it&#39;s unsafe to <em>implement</em> the
trait itself. The <a href="https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html">documentation</a>
mentions &#34;several reasons&#34;, among which:</p><blockquote><p>It&#39;s undefined behavior if global allocators unwind. This restriction may
be lifted in the future, but currently a panic from any of these functions
may lead to memory unsafety.</p></blockquote><p>Luckily, in Rust, undefined behavior is confined to well-identified <code>unsafe</code>
sections, and this is no exception.</p></div>
<p>Now that we&#39;ve got a custom allocator, all we need to do is use it:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/main.rs`</i>

<i>#<i>[</i>global_allocator<i>]</i></i>
<i>pub</i> <i>static</i> ALLOCATOR<i>:</i> alloc<i>::</i><i>Tracing</i> = alloc<i>::</i><i>Tracing</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
</pre></div><div>

<p>See how this is a <code>static</code>, and yet we&#39;re calling a function?</p><p>That&#39;s because it&#39;s a <code>const fn</code> - which are stable <a href="https://caniuse.rs/features/min_const_fn">since Rust 1.31</a>.</p><p>As of 1.44, there&#39;s still restrictions on what you can do inside const fns.
For example, <code>Default::default()</code> is not <code>const fn</code>, and neither is
<code>Into::into()</code>.</p></div>
<p>Does everything still work?</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run -- sample
   Compiling small v0.1.0 (/home/amos/ftl/small)
    Finished dev [unoptimized + debuginfo] target(s) in 1.73s
     Running `target/debug/small sample`
Read 1000 records
</pre></div><p>Yes. Good.</p><p>We&#39;d like our tracing allocator to say something, if they see something.</p><p>But this is easier said than done.</p><p>If we try to use <code>println!</code>:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>unsafe</i> <i>impl</i> <i>GlobalAlloc</i> <i>for</i> <i>Tracing</i> <i>{</i>
    <i>unsafe</i> <i>fn</i> <i>alloc</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>layout</i><i>:</i> std<i>::</i>alloc<i>::</i><i>Layout</i><i>)</i> -&gt; <i>*</i><i>mut</i> <i>u8</i> <i>{</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;allocating {} bytes&#34;</i><i>,</i> layout<i>.</i>size<i>(</i><i>)</i><i>)</i><i>;</i>
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>alloc</i><i>(</i>layout<i>)</i>
    <i>}</i>

    <i>// etc.</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run -- sample
   Compiling small v0.1.0 (/home/amos/ftl/small)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/small sample`
^C
</pre></div><p>...it hangs forever. Both in debug and release builds (I checked).</p><p>Where does it hang?</p><p><picture><source type="image/jxl" srcset="https://cdn.fasterthanli.me/content/articles/small-strings-in-rust/assets/println-hang~405312be15498c4c.jxl"/><source type="image/avif" srcset="https://cdn.fasterthanli.me/content/articles/small-strings-in-rust/assets/println-hang~405312be15498c4c.jxl.avif"/><source type="image/webp" srcset="https://cdn.fasterthanli.me/content/articles/small-strings-in-rust/assets/println-hang~405312be15498c4c.jxl.webp"/><img src="https://cdn.fasterthanli.me/content/articles/small-strings-in-rust/assets/println-hang~405312be15498c4c.jxl" loading="lazy"/></picture></p><p>..while trying to acquire a lock on stdout.</p><p>Let&#39;s bypass Rust&#39;s standard output machinery:</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo add libc
      Adding libc v0.2.71 to dependencies
</pre></div><p>Now, one very important thing to keep in mind when writing a custom allocator,
is that... we can&#39;t allocate any memory. Well, we can - but if we&#39;re not careful,
and we put some values on the heap by accident, the allocator will end up
calling itself, and <em>then</em> we&#39;ll have a stack overflow.</p><p>So this, for example, doesn&#39;t work:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/alloc.rs`</i>

<i>unsafe</i> <i>impl</i> <i>GlobalAlloc</i> <i>for</i> <i>Tracing</i> <i>{</i>
    <i>unsafe</i> <i>fn</i> <i>alloc</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>layout</i><i>:</i> std<i>::</i>alloc<i>::</i><i>Layout</i><i>)</i> -&gt; <i>*</i><i>mut</i> <i>u8</i> <i>{</i>
        <i>let</i> s = <i>format</i><i>!</i><i>(</i><i>&#34;allocating {} bytes&#34;</i><i>,</i> layout<i>.</i>size<i>(</i><i>)</i><i>)</i><i>;</i>
        libc<i>::</i><i>write</i><i>(</i>libc<i>::</i>STDOUT_FILENO<i>,</i> s<i>.</i><i>as_ptr</i><i>(</i><i>)</i> <i>as</i> <i>_</i><i>,</i> s<i>.</i><i>len</i><i>(</i><i>)</i> <i>as</i> <i>_</i><i>)</i><i>;</i>
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>alloc</i><i>(</i>layout<i>)</i>
    <i>}</i>

    <i>// etc.</i>
<i>}</i>
</pre></div><div>

<p>We all like type inference, right?</p><p>Turns out, you don&#39;t need to spell out <code>as u64</code>, or <code>as usize</code>, or <code>as f64</code>. If
the compiler can infer it, just use <code>as _</code>!</p></div>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo run -- sample
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/small run`
[1]    94868 segmentation fault (core dumped)  cargo run -- run
</pre></div><p>...because <code>format!</code> ends up allocating memory - if only for the resulting
<code>String</code>.</p><p>This however, is fine:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>unsafe</i> <i>impl</i> <i>GlobalAlloc</i> <i>for</i> <i>Tracing</i> <i>{</i>
    <i>unsafe</i> <i>fn</i> <i>alloc</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>layout</i><i>:</i> std<i>::</i>alloc<i>::</i><i>Layout</i><i>)</i> -&gt; <i>*</i><i>mut</i> <i>u8</i> <i>{</i>
        <i>let</i> s = <i>&#34;allocating!\n&#34;</i><i>;</i>
        libc<i>::</i><i>write</i><i>(</i>libc<i>::</i>STDOUT_FILENO<i>,</i> s<i>.</i><i>as_ptr</i><i>(</i><i>)</i> <i>as</i> <i>_</i><i>,</i> s<i>.</i><i>len</i><i>(</i><i>)</i> <i>as</i> <i>_</i><i>)</i><i>;</i>
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>alloc</i><i>(</i>layout<i>)</i>
    <i>}</i>

    <i>// etc.</i>
<i>}</i>
</pre></div><div translate="no"><pre data-lang="sh">$ cargo run -- sample | head
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `target/debug/small sample`
allocating!
allocating!
allocating!
allocating!
allocating!
allocating!
allocating!
allocating!
allocating!
allocating!
(cut off by &#39;| head&#39;)
</pre></div><p>But it&#39;s not very helpful. Here&#39;s an idea - how about we write out
one JSON object per line on stderr? I don&#39;t think <code>serde_json</code> needs
to heap-allocate when serializing objects, so we should be in the clear.</p><p>Let&#39;s make an enum with two variants:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/alloc.rs`</i>

<i>use</i> serde<i>::</i><i>{</i>Deserialize<i>,</i> Serialize<i>}</i><i>;</i>

<i>#<i>[</i>derive<i>(</i>Clone<i>,</i> Copy<i>,</i> Serialize<i>,</i> Deserialize<i>)</i><i>]</i></i>
<i>pub</i> <i>enum</i> <i>Event</i> <i>{</i>
    Alloc <i>{</i> <i>addr</i><i>:</i> <i>usize</i><i>,</i> <i>size</i><i>:</i> <i>usize</i> <i>}</i><i>,</i>
    Freed <i>{</i> <i>addr</i><i>:</i> <i>usize</i><i>,</i> <i>size</i><i>:</i> <i>usize</i> <i>}</i><i>,</i>
<i>}</i>
</pre></div><p>Then two helpers so we can write those events to stderr easily:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/alloc.rs`</i>

<i>use</i> std<i>::</i>io<i>::</i>Cursor<i>;</i>

<i>impl</i> <i>Tracing</i> <i>{</i>
    <i>fn</i> <i>write_ev</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>ev</i><i>:</i> <i>Event</i><i>)</i> <i>{</i>
        <i>let</i> <i>mut</i> buf = <i>[</i><i>0u8</i><i>;</i> <i>1024</i><i>]</i><i>;</i>
        <i>let</i> <i>mut</i> cursor = <i>Cursor</i><i>::</i><i>new</i><i>(</i><i>&amp;</i><i>mut</i> buf<i>[</i>..<i>]</i><i>)</i><i>;</i>
        serde_json<i>::</i><i>to_writer</i><i>(</i><i>&amp;</i><i>mut</i> cursor<i>,</i> <i>&amp;</i>ev<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> end = cursor<i>.</i><i>position</i><i>(</i><i>)</i> <i>as</i> <i>usize</i><i>;</i>
        <i>self</i><i>.</i><i>write</i><i>(</i><i>&amp;</i>buf<i>[</i>..end<i>]</i><i>)</i><i>;</i>
        <i>self</i><i>.</i><i>write</i><i>(</i><i>b&#34;\n&#34;</i><i>)</i><i>;</i>
    <i>}</i>

    <i>fn</i> <i>write</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>s</i><i>:</i> <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i> <i>{</i>
        <i>unsafe</i> <i>{</i>
            libc<i>::</i><i>write</i><i>(</i>libc<i>::</i>STDERR_FILENO<i>,</i> s<i>.</i><i>as_ptr</i><i>(</i><i>)</i> <i>as</i> <i>_</i><i>,</i> s<i>.</i><i>len</i><i>(</i><i>)</i> <i>as</i> <i>_</i><i>)</i><i>;</i>
        <i>}</i>
    <i>}</i>
<i>}</i>
</pre></div><p>And use them in our <code>alloc</code> and <code>dealloc</code> function to write the
corresponding events:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/alloc.rs`</i>

<i>unsafe</i> <i>impl</i> <i>GlobalAlloc</i> <i>for</i> <i>Tracing</i> <i>{</i>
    <i>unsafe</i> <i>fn</i> <i>alloc</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>layout</i><i>:</i> std<i>::</i>alloc<i>::</i><i>Layout</i><i>)</i> -&gt; <i>*</i><i>mut</i> <i>u8</i> <i>{</i>
        <i>let</i> res = <i>self</i><i>.</i><i>inner</i><i>.</i><i>alloc</i><i>(</i>layout<i>)</i><i>;</i>
        <i>self</i><i>.</i><i>write_ev</i><i>(</i><i>Event</i><i>::</i><i>Alloc</i> <i>{</i>
            <i>addr</i><i>:</i> res <i>as</i> <i>_</i><i>,</i>
            <i>size</i><i>:</i> layout<i>.</i><i>size</i><i>(</i><i>)</i><i>,</i>
        <i>}</i><i>)</i><i>;</i>
        res
    <i>}</i>
    <i>unsafe</i> <i>fn</i> <i>dealloc</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>ptr</i><i>:</i> <i>*</i><i>mut</i> <i>u8</i><i>,</i> <i>layout</i><i>:</i> std<i>::</i>alloc<i>::</i><i>Layout</i><i>)</i> <i>{</i>
        <i>self</i><i>.</i><i>write_ev</i><i>(</i><i>Event</i><i>::</i><i>Freed</i> <i>{</i>
            <i>addr</i><i>:</i> ptr <i>as</i> <i>_</i><i>,</i>
            <i>size</i><i>:</i> layout<i>.</i><i>size</i><i>(</i><i>)</i><i>,</i>
        <i>}</i><i>)</i><i>;</i>
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>dealloc</i><i>(</i>ptr<i>,</i> layout<i>)</i>
    <i>}</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo build &amp;&amp; ./target/debug/small sample 2&gt;! events.ldjson
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
Read 1000 records
$ head -3 events.ldjson
{&#34;Alloc&#34;:{&#34;addr&#34;:93825708063040,&#34;size&#34;:4}}
{&#34;Alloc&#34;:{&#34;addr&#34;:93825708063072,&#34;size&#34;:5}}
{&#34;Freed&#34;:{&#34;addr&#34;:93825708063040,&#34;size&#34;:4}}
</pre></div><div>

<p>We can no longer use <code>cargo run</code>, otherwise cargo&#39;s own output
would end up in <code>events.ldjson</code>.</p><p>Also, Amos is using zsh here, that&#39;s why he has to use <code>2&gt;!</code> instead
of just <code>2&gt;</code>. The <code>!</code> tells zsh to overwrite the file if it exists.
By default it would just refuse to write to it.</p></div>
<p>There&#39;s one last thing our custom allocator needs: an on and off switch.</p><p>Right now it reports <em>every</em> allocation, from the very start of our program,
including argument parsing. This isn&#39;t much compared to the JSON parsing
phase, but it&#39;s still something I&#39;d like to exclude from our measurements.</p><p>So, let&#39;s add a switch:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/alloc.rs`</i>

<i>use</i> std<i>::</i>sync<i>::</i>atomic<i>::</i><i>{</i>AtomicBool<i>,</i> Ordering<i>}</i><i>;</i>

<i>pub</i> <i>struct</i> <i>Tracing</i> <i>{</i>
    <i>pub</i> <i>inner</i><i>:</i> <i>System</i><i>,</i>
    <i>// new</i>
    <i>pub</i> <i>active</i><i>:</i> <i>AtomicBool</i><i>,</i>
<i>}</i>

<i>impl</i> <i>Tracing</i> <i>{</i>
    <i>pub</i> <i>const</i> <i>fn</i> <i>new</i><i>(</i><i>)</i> -&gt; <i>Self</i> <i>{</i>
        <i>Self</i> <i>{</i>
            <i>inner</i><i>:</i> System<i>,</i>
            <i>active</i><i>:</i> <i>AtomicBool</i><i>::</i><i>new</i><i>(</i><i>false</i><i>)</i><i>,</i>
        <i>}</i>
    <i>}</i>

    <i>pub</i> <i>fn</i> <i>set_active</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>active</i><i>:</i> <i>bool</i><i>)</i> <i>{</i>
        <i>self</i><i>.</i><i>active</i><i>.</i><i>store</i><i>(</i>active<i>,</i> <i>Ordering</i><i>::</i>SeqCst<i>)</i><i>;</i>
    <i>}</i>
<i>}</i>

<i>unsafe</i> <i>impl</i> <i>GlobalAlloc</i> <i>for</i> <i>Tracing</i> <i>{</i>
    <i>unsafe</i> <i>fn</i> <i>alloc</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>layout</i><i>:</i> std<i>::</i>alloc<i>::</i><i>Layout</i><i>)</i> -&gt; <i>*</i><i>mut</i> <i>u8</i> <i>{</i>
        <i>let</i> res = <i>self</i><i>.</i><i>inner</i><i>.</i><i>alloc</i><i>(</i>layout<i>)</i><i>;</i>
        <i>if</i> <i>self</i><i>.</i><i>active</i><i>.</i><i>load</i><i>(</i><i>Ordering</i><i>::</i>SeqCst<i>)</i> <i>{</i>
            <i>self</i><i>.</i><i>write_ev</i><i>(</i><i>Event</i><i>::</i><i>Alloc</i> <i>{</i>
                <i>addr</i><i>:</i> res <i>as</i> <i>_</i><i>,</i>
                <i>size</i><i>:</i> layout<i>.</i><i>size</i><i>(</i><i>)</i><i>,</i>
            <i>}</i><i>)</i><i>;</i>
        <i>}</i>
        res
    <i>}</i>
    <i>unsafe</i> <i>fn</i> <i>dealloc</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>ptr</i><i>:</i> <i>*</i><i>mut</i> <i>u8</i><i>,</i> <i>layout</i><i>:</i> std<i>::</i>alloc<i>::</i><i>Layout</i><i>)</i> <i>{</i>
        <i>if</i> <i>self</i><i>.</i><i>active</i><i>.</i><i>load</i><i>(</i><i>Ordering</i><i>::</i>SeqCst<i>)</i> <i>{</i>
            <i>self</i><i>.</i><i>write_ev</i><i>(</i><i>Event</i><i>::</i><i>Freed</i> <i>{</i>
                <i>addr</i><i>:</i> ptr <i>as</i> <i>_</i><i>,</i>
                <i>size</i><i>:</i> layout<i>.</i><i>size</i><i>(</i><i>)</i><i>,</i>
            <i>}</i><i>)</i><i>;</i>
        <i>}</i>
        <i>self</i><i>.</i><i>inner</i><i>.</i><i>dealloc</i><i>(</i>ptr<i>,</i> layout<i>)</i>
    <i>}</i>
<i>}</i>
</pre></div><p>The allocator will start off inactive, and we can activate it just
for our JSON workload:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/sample.rs`</i>

<i>impl</i> <i>Sample</i> <i>{</i>
    <i>fn</i> <i>read_records</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> <i>{</i>
        <i>// omitted: `struct Record`</i>

        <i>use</i> std<i>::</i>fs<i>::</i>File<i>;</i>
        <i>let</i> f = <i>File</i><i>::</i><i>open</i><i>(</i><i>&#34;cities.json&#34;</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>crate</i><i>::</i>ALLOCATOR<i>.</i><i>set_active</i><i>(</i><i>true</i><i>)</i><i>;</i>
        <i>let</i> records<i>:</i> <i>Vec</i><i>&lt;</i><i>Record</i><i>&gt;</i> = serde_json<i>::</i><i>from_reader</i><i>(</i>f<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>crate</i><i>::</i>ALLOCATOR<i>.</i><i>set_active</i><i>(</i><i>false</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;Read {} records&#34;</i><i>,</i> records<i>.</i>len<i>(</i><i>)</i><i>)</i><i>;</i>
    <i>}</i>
<i>}</i>
</pre></div><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo build &amp;&amp; ./target/debug/small sample 2&gt;! events.ldjson
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
Read 1000 records
$ grep &#39;Alloc&#39; events.ldjson | wc -l
2017
$ grep &#39;Freed&#39; events.ldjson | wc -l
16
</pre></div><p>But <code>grep</code> and <code>wc</code> aren&#39;t the best we can do to analyze those events.</p><p>Let&#39;s build something a little comfier.</p><h2><a id="the-report-subcommand" href="#the-report-subcommand"></a>The <code>report</code> subcommand</h2><p>Let&#39;s add another subcommand, also in its own module:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/main.rs`</i>

<i>pub</i> <i>mod</i> report<i>;</i>

<i>#<i>[</i>derive<i>(</i>FromArgs<i>)</i><i>]</i></i>
<i>#<i>[</i>argh<i>(</i>subcommand<i>)</i><i>]</i></i>
<i>enum</i> <i>Subcommand</i> <i>{</i>
    Sample<i>(</i>sample<i>::</i><i>Sample</i><i>)</i><i>,</i>
    Report<i>(</i>report<i>::</i><i>Report</i><i>)</i><i>,</i>
<i>}</i>

<i>impl</i> <i>Subcommand</i> <i>{</i>
    <i>fn</i> <i>run</i><i>(</i><i>self</i><i>)</i> <i>{</i>
        <i>match</i> <i>self</i> <i>{</i>
            <i>Subcommand</i><i>::</i>Sample<i>(</i>x<i>)</i> =&gt; x<i>.</i><i>run</i><i>(</i><i>)</i><i>,</i>
            <i>Subcommand</i><i>::</i>Report<i>(</i>x<i>)</i> =&gt; x<i>.</i><i>run</i><i>(</i><i>)</i><i>,</i>
        <i>}</i>
    <i>}</i>
<i>}</i>
</pre></div><p>Here&#39;s my wishlist. I would like:</p><ul><li>To measure peak memory usage</li><li>Along with total allocations and deallocations</li><li>To format sizes as B, KiB, etc.</li><li>To have a nice little graph of memory usage, just like Massif does</li></ul><div>

<p>Alright then, let&#39;s go shopping.</p></div>
<div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo add bytesize
      Adding bytesize v1.0.1 to dependencies
$ cargo add textplots
      Adding textplots v0.5.1 to dependencies
</pre></div><div>

<p>That&#39;s it? Are we saving our crate budget for something else?</p></div>
<p>Nope, that&#39;s all we need.</p><div>

<p>Hold on a second, I have a question: why are we first saving events to a file,
and <em>later</em> analyzing it with another subcommand?</p><p>Couldn&#39;t we just do everything in one run?</p></div>
<p>We probably could! But that way, the code is simpler. It would probably be
tricky to collect events in-memory without doing any heap allocations.</p><p>We would have to:</p><ul><li>Allocate a fixed-size buffer ahead of time, either in static storage,
or on the heap but using the system allocator directly.</li><li>Make sure we handle synchronization properly - <code>GlobalAlloc</code> only requires
<code>&amp;self</code> for <code>alloc</code> and <code>dealloc</code>, so we&#39;d have to do our own locking</li></ul><p>And locking hasn&#39;t worked great for us so far (see the <code>println!</code> debacle).</p><p>So, that way is simpler! A bit more annoying to use, but simpler.</p><div>

<p>Fair enough, carry on.</p></div>
<p>The reporter is fairly simple. It simply parses each line as a JSON record
of type <code>crate::alloc::Event</code>, using <code>serde_json</code>. Then it goes through each
record, keeps track of the current of amount of memory used, and peak usage,
and builds a series of <code>(f32, f32)</code> for <a href="https://crates.io/crates/textplots">textplots</a>.</p><p>Let&#39;s go:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/report.rs`</i>

<i>use</i> <i>crate</i><i>::</i>alloc<i>;</i>
<i>use</i> alloc<i>::</i>Event<i>;</i>
<i>use</i> argh<i>::</i>FromArgs<i>;</i>
<i>use</i> bytesize<i>::</i>ByteSize<i>;</i>
<i>use</i> std<i>::</i><i>{</i>
    fs<i>::</i>File<i>,</i>
    io<i>::</i><i>{</i>BufRead<i>,</i> BufReader<i>}</i><i>,</i>
    path<i>::</i>PathBuf<i>,</i>
<i>}</i><i>;</i>
<i>use</i> textplots<i>::</i><i>{</i>Chart<i>,</i> Plot<i>,</i> Shape<i>}</i><i>;</i>

<i>#<i>[</i>derive<i>(</i>FromArgs<i>)</i><i>]</i></i>
<i>/// Analyze report
</i><i>#<i>[</i>argh<i>(</i>subcommand<i>,</i> name = <i>&#34;report&#34;</i><i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>Report</i> <i>{</i>
    <i>#<i>[</i>argh<i>(</i>positional<i>)</i><i>]</i></i>
    <i>path</i><i>:</i> <i>PathBuf</i><i>,</i>
<i>}</i>

<i>trait</i> <i>Delta</i> <i>{</i>
    <i>fn</i> <i>delta</i><i>(</i><i>self</i><i>)</i> -&gt; <i>isize</i><i>;</i>
<i>}</i>

<i>impl</i> <i>Delta</i> <i>for</i> alloc<i>::</i><i>Event</i> <i>{</i>
    <i>fn</i> <i>delta</i><i>(</i><i>self</i><i>)</i> -&gt; <i>isize</i> <i>{</i>
        <i>match</i> <i>self</i> <i>{</i>
            <i>Event</i><i>::</i>Alloc <i>{</i> size<i>,</i> .. <i>}</i> =&gt; size <i>as</i> <i>isize</i><i>,</i>
            <i>Event</i><i>::</i>Freed <i>{</i> size<i>,</i> .. <i>}</i> =&gt; -<i>(</i>size <i>as</i> <i>isize</i><i>)</i><i>,</i>
        <i>}</i>
    <i>}</i>
<i>}</i>

<i>impl</i> <i>Report</i> <i>{</i>
    <i>pub</i> <i>fn</i> <i>run</i><i>(</i><i>self</i><i>)</i> <i>{</i>
        <i>let</i> f = <i>BufReader</i><i>::</i><i>new</i><i>(</i><i>File</i><i>::</i><i>open</i><i>(</i><i>&amp;</i><i>self</i><i>.</i><i>path</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i><i>;</i>
        <i>let</i> <i>mut</i> events<i>:</i> <i>Vec</i><i>&lt;</i>alloc<i>::</i><i>Event</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

        <i>for</i> line <i>in</i> f<i>.</i><i>lines</i><i>(</i><i>)</i> <i>{</i>
            <i>let</i> line = line<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
            <i>let</i> ev<i>:</i> <i>Event</i> = serde_json<i>::</i><i>from_str</i><i>(</i><i>&amp;</i>line<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
            events<i>.</i><i>push</i><i>(</i>ev<i>)</i><i>;</i>
        <i>}</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;found {} events&#34;</i><i>,</i> events<i>.</i>len<i>(</i><i>)</i><i>)</i><i>;</i>

        <i>let</i> <i>mut</i> points = <i>vec</i><i>!</i><i>[</i><i>]</i><i>;</i>
        <i>let</i> <i>mut</i> curr_bytes = <i>0</i><i>;</i>
        <i>let</i> <i>mut</i> peak_bytes = <i>0</i><i>;</i>
        <i>let</i> <i>mut</i> alloc_events = <i>0</i><i>;</i>
        <i>let</i> <i>mut</i> alloc_bytes = <i>0</i><i>;</i>
        <i>let</i> <i>mut</i> freed_events = <i>0</i><i>;</i>
        <i>let</i> <i>mut</i> freed_bytes = <i>0</i><i>;</i>
        <i>for</i> <i>(</i>i<i>,</i> ev<i>)</i> <i>in</i> events<i>.</i><i>iter</i><i>(</i><i>)</i><i>.</i><i>copied</i><i>(</i><i>)</i><i>.</i><i>enumerate</i><i>(</i><i>)</i> <i>{</i>
            curr_bytes += ev<i>.</i><i>delta</i><i>(</i><i>)</i><i>;</i>
            points<i>.</i><i>push</i><i>(</i><i>(</i>i <i>as</i> <i>f32</i><i>,</i> curr_bytes <i>as</i> <i>f32</i><i>)</i><i>)</i><i>;</i>

            <i>if</i> peak_bytes &lt; curr_bytes <i>{</i>
                peak_bytes = curr_bytes<i>;</i>
            <i>}</i>
            <i>match</i> ev <i>{</i>
                <i>Event</i><i>::</i>Alloc <i>{</i> size<i>,</i> .. <i>}</i> =&gt; <i>{</i>
                    alloc_events += <i>1</i><i>;</i>
                    alloc_bytes += size<i>;</i>
                <i>}</i>
                <i>Event</i><i>::</i>Freed <i>{</i> size<i>,</i> .. <i>}</i> =&gt; <i>{</i>
                    freed_events += <i>1</i><i>;</i>
                    freed_bytes += size<i>;</i>
                <i>}</i>
            <i>}</i>
        <i>}</i>
        <i>Chart</i><i>::</i><i>new</i><i>(</i><i>120</i><i>,</i> <i>80</i><i>,</i> <i>0.0</i><i>,</i> points<i>.</i><i>len</i><i>(</i><i>)</i> <i>as</i> <i>f32</i><i>)</i>
            <i>.</i><i>lineplot</i><i>(</i><i>Shape</i><i>::</i><i>Steps</i><i>(</i><i>&amp;</i>points<i>[</i>..<i>]</i><i>)</i><i>)</i>
            <i>.</i><i>nice</i><i>(</i><i>)</i><i>;</i>

        <i>println</i><i>!</i><i>(</i><i>&#34;     total events | {}&#34;</i><i>,</i> events<i>.</i>len<i>(</i><i>)</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;      peak bytes  | {}&#34;</i><i>,</i> ByteSize<i>(</i>peak_bytes <i>as</i> _<i>)</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;     ----------------------------&#34;</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;     alloc events | {}&#34;</i><i>,</i> alloc_events<i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;     alloc bytes  | {}&#34;</i><i>,</i> ByteSize<i>(</i>alloc_bytes <i>as</i> _<i>)</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;     ----------------------------&#34;</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;     freed events | {}&#34;</i><i>,</i> freed_events<i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;     freed bytes  | {}&#34;</i><i>,</i> ByteSize<i>(</i>freed_bytes <i>as</i> _<i>)</i><i>)</i><i>;</i>
    <i>}</i>
<i>}</i>
</pre></div><p>Shall we give it a try?</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo build &amp;&amp; ./target/debug/small sample 2&gt;! events.ldjson &amp;&amp; ./target/debug/small report events.ldjson
    Finished dev [unoptimized + debuginfo] target(s) in 0.09s
Read 1000 records
found 2033 events
⡁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⡏ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⡁ 82670.0
⠄                              ⡇                            ⠄
⠂                              ⡇                            ⠂
⡁                              ⡇                            ⡁
⠄                              ⡇              ⣀⣀⣀⣠⠤⠤⠤⠖⠒⠒⠚⠉⠉⠉⠅
⠂                              ⡇⣀⣀⣀⣠⠤⠤⠤⠖⠒⠒⠚⠉⠉⠉⠁             ⠂
⡁                              ⡏⠁                           ⡁
⠄                              ⡇                            ⠄
⠂                              ⡇                            ⠂
⡁                              ⡇                            ⡁
⠄               ⡇              ⡇                            ⠄
⠂               ⡇              ⡇                            ⠂
⡁               ⡇⣀⣀⣀⣀⡤⠤⠤⠴⠒⠒⠒⠋⠉⠉⠁                            ⡁
⠄               ⡏⠁                                          ⠄
⠂               ⡇                                           ⠂
⡁       ⢸       ⡇                                           ⡁
⠄       ⢸⠴⠒⠒⠒⠚⠉⠉⠁                                           ⠄
⠂   ⢠   ⢸                                                   ⠂
⡁ ⢀ ⢸⠒⠋⠉⠉                                                   ⡁
⢄⣰⠼⠉⠉                                                       ⠄
⠉⠉ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁ 1.0
0.0                                                      2033.0
     total events | 2033
      peak bytes  | 82.7 KB
     ----------------------------
     alloc events | 2017
     alloc bytes  | 115.8 KB
     ----------------------------
     freed events | 16
     freed bytes  | 49.2 KB
</pre></div><p>How fascinating! You can see that the line goes way up and falls back down
almost immediately at several points.</p><p>My theory is pretty simple: it&#39;s reading a thousand records into a <code>Vec</code>. But
since everything is streaming, it has no idea what capacity to reserve for
the <code>Vec</code>.</p><p>When it grows, the <code>Vec</code> must first allocate <code>new_capacity</code> bytes, then copy
over from the <em>old</em> storage, and only then can it free the old storage.</p><p>So the peaks we see are almost definitely <code>Vec</code> resizes.</p><p>We can also see that between those peaks, memory usage increases steadily -
each <code>String</code> stores its data on the heap, which explains the number of
allocation events, 2017.</p><h2><a id="as-few-allocations-as-possible" href="#as-few-allocations-as-possible"></a>As few allocations as possible</h2><p>Now that we can read our JSON file into Rust data structures, and we can
profile allocations, let&#39;s think about reducing the number of allocations.</p><p>Why? Because the fastest code is the code you don&#39;t execute. If you do fewer
allocations, then you&#39;re spending less time in the allocator, so you should
see a performance boost.</p><p>Unless you&#39;re achieving &#34;fewer allocations&#34; by doing a lot more work, which
would be a different compromise - but one that is still worth doing in some
cases.</p><p>In our case, our input file is relatively small (in terms of a contemporary
desktop computer), so we can afford to read it all in memory in one go.</p><p>And if we do that, we can deserialize to <code>&amp;str</code> rather than <code>String</code>, if
we tell <code>serde</code> to borrow from the input.</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/sample.rs`</i>

<i>impl</i> <i>Sample</i> <i>{</i>
    <i>pub</i> <i>fn</i> <i>run</i><i>(</i><i>self</i><i>)</i> <i>{</i>
        <i>self</i><i>.</i><i>read_records</i><i>(</i><i>)</i><i>;</i>
    <i>}</i>

    <i>fn</i> <i>read_records</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> <i>{</i>
        <i>use</i> serde<i>::</i>Deserialize<i>;</i>

        <i>#<i>[</i>derive<i>(</i>Deserialize<i>)</i><i>]</i></i>
        <i>struct</i> <i>Record</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> <i>{</i>
            <i>#<i>[</i>allow<i>(</i>unused<i>)</i><i>]</i></i>
            <i>#<i>[</i>serde<i>(</i>borrow<i>)</i><i>]</i></i>
            <i>city</i><i>:</i> <i>&amp;</i><i>&#39;</i><i>a</i> <i>str</i><i>,</i>
            <i>#<i>[</i>allow<i>(</i>unused<i>)</i><i>]</i></i>
            <i>state</i><i>:</i> <i>&amp;</i><i>&#39;</i><i>a</i> <i>str</i><i>,</i>
        <i>}</i>

        <i>crate</i><i>::</i>ALLOCATOR<i>.</i><i>set_active</i><i>(</i><i>true</i><i>)</i><i>;</i>
        <i>let</i> input = std<i>::</i>fs<i>::</i><i>read_to_string</i><i>(</i><i>&#34;cities.json&#34;</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> records<i>:</i> <i>Vec</i><i>&lt;</i><i>Record</i><i>&gt;</i> = serde_json<i>::</i><i>from_str</i><i>(</i><i>&amp;</i>input<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>crate</i><i>::</i>ALLOCATOR<i>.</i><i>set_active</i><i>(</i><i>false</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;Read {} records&#34;</i><i>,</i> records<i>.</i>len<i>(</i><i>)</i><i>)</i><i>;</i>
    <i>}</i>
<i>}</i>
</pre></div><p>Let&#39;s measure that:</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo build &amp;&amp; ./target/debug/small sample 2&gt;! events.ldjson &amp;&amp; ./target/debug/small report events.ldjson
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
Read 1000 records
found 24 events
⡁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⢸⠉⠉⡏ ⠁⠈ ⡁ 293365.0
⠄                                              ⢀⣀⣀⡀ ⢸  ⠉⠉⠉  ⠄
⠂                                         ⢠⠤⠤⣄⣀⣸  ⠓⠒⠚       ⠂
⡁ ⢰⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠚⠉⠉⠉⠉⠉                 ⡁
⠄ ⢸                                                         ⠄
⠂ ⢸                                                         ⠂
⡁ ⢸                                                         ⡁
⠄ ⢸                                                         ⠄
⠂ ⢸                                                         ⠂
⡁ ⢸                                                         ⡁
⠄ ⢸                                                         ⠄
⠂ ⢸                                                         ⠂
⡁ ⢸                                                         ⡁
⠄ ⢸                                                         ⠄
⠂ ⢸                                                         ⠂
⡁ ⢸                                                         ⡁
⠄ ⢸                                                         ⠄
⠂ ⢸                                                         ⠂
⡁ ⢸                                                         ⡁
⠄ ⢸                                                         ⠄
⠉⠉⠉⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁ 0.0
0.0                                                      24.0
     total events | 24
      peak bytes  | 293.4 KB
     ----------------------------
     alloc events | 13
     alloc bytes  | 309.7 KB
     ----------------------------
     freed events | 11
     freed bytes  | 32.7 KB
</pre></div><p>What a result!</p><p>The number of allocation events fell to <strong>13</strong>, but peak memory usage
climbed all the way up to 293 KB.</p><div>

<p>Unfortunately, <a href="https://crates.io/crates/bytesize">bytesize</a> defaults to powers of
1000, not 1024.</p></div>
<p>In our particular scenario, this tradeoff is perfectly acceptable - 293 KB
memory usage is more than reasonable. The speed difference is going to be
imperceptible, unless we do it thousands of times, but that&#39;s fine too.</p><p>However, if our dataset was much larger, we might start running into problems.</p><p>Say we ran this workload on a machine with 64 GiB of RAM - that&#39;s not atypical
for a server. And say the input file was 100 GiB. We couldn&#39;t even read the
whole thing in memory! We&#39;d have to go back to a streaming solution.</p><p>And our initial streaming solution may well work - because we&#39;re only reading
out the <code>city</code> and <code>state</code> fields - not all the others, which I&#39;m sure make
up the bulk of the 100 GiB input file.</p><p>There are other reasons why <code>&amp;str</code> might not be suitable for us. We may want
to hang on to those strings, and hand them out to other parts of our program,
without worrying about lifetimes too much.</p><p>For some use cases, we may want to consider using a <a href="https://crates.io/search?q=string+intern">string
interner</a>, as a middle ground between
&#34;owned values&#34; and &#34;low memory usage&#34;. We&#39;re not going to review that option here.</p><p>Let&#39;s go back to our streaming solution, for the needs of the story.</p><h2><a id="the-smol-str-crate" href="#the-smol-str-crate"></a>The <code>smol_str</code> crate</h2><p>The <a href="https://crates.io/crates/smol_str">smol_str</a> crate provides us with a
<code>SmolStr</code> type that has the same size as <code>String</code>, and stores strings of up
to 22 bytes <em>inline</em>. It also has special-case optimizations for strings that
are made purely of whitespace (0+ newlines followed by 0+ spaces).</p><p>It&#39;s important to note that <code>SmolStr</code> is <strong>immutable</strong>, unlike <code>String</code>. That
works well enough for our purposes.</p><p>Strings longer than 22 bytes are heap-allocated, just like the standard
<code>String</code> type.</p><p>But enough marketing! Let&#39;s give it a go.</p><p>Luckily, it comes with a <code>serde</code> feature, so we can just drop it in:</p><div translate="no"><p>TOML markup</p><pre data-lang="toml"><i># in `Cargo.toml`</i>

<i>[</i><i>dependencies</i><i>]</i>
<i># omitted: others</i>
<i>smol_str</i> <i>=</i> <i>{</i> <i>version</i> <i>=</i> <i>&#34;0.1.15&#34;</i><i>,</i> <i>features</i> <i>=</i> <i>[</i><i>&#34;serde&#34;</i><i>]</i> <i>}</i>
</pre></div><p>In order to compare various string implementations, we&#39;ll add an option to
our <code>sample</code> command - parsed from an enum.</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo add parse-display
      Adding parse-display v0.1.2 to dependencies
</pre></div><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/sample.rs`</i>

<i>use</i> parse_display<i>::</i><i>{</i>Display<i>,</i> FromStr<i>}</i><i>;</i>

<i>#<i>[</i>derive<i>(</i>FromArgs<i>)</i><i>]</i></i>
<i>/// Run sample code
</i><i>#<i>[</i>argh<i>(</i>subcommand<i>,</i> name = <i>&#34;sample&#34;</i><i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>Sample</i> <i>{</i>
    <i>#<i>[</i>argh<i>(</i>option<i>)</i><i>]</i></i>
    <i>/// which library to use
</i>    <i>lib</i><i>:</i> <i>Lib</i><i>,</i>
<i>}</i>

<i>#<i>[</i>derive<i>(</i>Display<i>,</i> FromStr<i>)</i><i>]</i></i>
<i>#<i>[</i>display<i>(</i>style = <i>&#34;snake_case&#34;</i><i>)</i><i>]</i></i>
<i>enum</i> <i>Lib</i> <i>{</i>
    Std<i>,</i>
    Smol<i>,</i>
    Smart<i>,</i>
<i>}</i>
</pre></div><p>We&#39;ll add a generic type parameter to <code>read_records</code> and our <code>Record</code> type,
so we can use whichever implementation we want:</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/sample.rs`</i>

<i>impl</i> <i>Sample</i> <i>{</i>
    <i>pub</i> <i>fn</i> <i>run</i><i>(</i><i>self</i><i>)</i> <i>{</i>
        <i>match</i> <i>self</i><i>.</i><i>lib</i> <i>{</i>
            <i>Lib</i><i>::</i>Std =&gt; <i>self</i><i>.</i><i>read_records</i><i>::</i><i>&lt;</i><i>String</i><i>&gt;</i><i>(</i><i>)</i><i>,</i>
            <i>Lib</i><i>::</i>Smol =&gt; <i>self</i><i>.</i><i>read_records</i><i>::</i><i>&lt;</i>smol_str<i>::</i><i>SmolStr</i><i>&gt;</i><i>(</i><i>)</i><i>,</i>
            <i>Lib</i><i>::</i>Smart =&gt; <i>todo</i><i>!</i><i>(</i><i>)</i><i>,</i>
        <i>}</i>
    <i>}</i>

    <i>fn</i> <i>read_records</i><i>&lt;</i><i>S</i><i>&gt;</i><i>(</i><i>&amp;</i><i>self</i><i>)</i>
    <i>where</i>
        <i>S</i><i>:</i> serde<i>::</i>de<i>::</i><i>DeserializeOwned</i><i>,</i>
    <i>{</i>
        <i>use</i> serde<i>::</i>Deserialize<i>;</i>

        <i>#<i>[</i>derive<i>(</i>Deserialize<i>)</i><i>]</i></i>
        <i>struct</i> <i>Record</i><i>&lt;</i><i>S</i><i>&gt;</i> <i>{</i>
            <i>#<i>[</i>allow<i>(</i>unused<i>)</i><i>]</i></i>
            <i>city</i><i>:</i> <i>S</i><i>,</i>
            <i>#<i>[</i>allow<i>(</i>unused<i>)</i><i>]</i></i>
            <i>state</i><i>:</i> <i>S</i><i>,</i>
        <i>}</i>

        <i>use</i> std<i>::</i>fs<i>::</i>File<i>;</i>
        <i>let</i> f = <i>File</i><i>::</i><i>open</i><i>(</i><i>&#34;cities.json&#34;</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>crate</i><i>::</i>ALLOCATOR<i>.</i><i>set_active</i><i>(</i><i>true</i><i>)</i><i>;</i>
        <i>let</i> records<i>:</i> <i>Vec</i><i>&lt;</i><i>Record</i><i>&lt;</i><i>S</i><i>&gt;</i><i>&gt;</i> = serde_json<i>::</i><i>from_reader</i><i>(</i>f<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>crate</i><i>::</i>ALLOCATOR<i>.</i><i>set_active</i><i>(</i><i>false</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;Read {} records&#34;</i><i>,</i> records<i>.</i>len<i>(</i><i>)</i><i>)</i><i>;</i>
    <i>}</i>
<i>}</i>
</pre></div><p>Let&#39;s give it a go:</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo build &amp;&amp; ./target/debug/small sample --lib smol 2&gt;! events.ldjson &amp;&amp; ./target/debug/small report events.ldjson
   Compiling small v0.1.0 (/home/amos/ftl/small)
    Finished dev [unoptimized + debuginfo] target(s) in 1.82s
Read 1000 records
found 42 events
⡁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⢹⢹ ⠁⠈ ⡁ 73896.0
⠄                                                     ⢸⢸    ⠄
⠂                                                     ⢸⢸    ⠂
⡁                                                     ⢸⢸    ⡁
⠄                                                     ⢸⢸    ⠄
⠂                                                     ⢸⢸    ⠂
⡁                                                     ⢸⢸⣀⣀⣀ ⡁
⠄                                                     ⢸     ⠄
⠂                                                     ⢸     ⠂
⡁                                                     ⢸     ⡁
⠄                                              ⡏⢹     ⢸     ⠄
⠂                                              ⡇⢸     ⢸     ⠂
⡁                                              ⡇⢸     ⢸     ⡁
⠄                                              ⡇⠘⠒⠒⠒⠒⠒⠚     ⠄
⠂                                              ⡇            ⠂
⡁                                           ⢸⢹ ⡇            ⡁
⠄                                           ⢸⢸⣀⡇            ⠄
⠂                                    ⡤⢤     ⢸               ⠂
⡁                                 ⢀⣀ ⡇⠘⠒⠒⠒⠒⠒⠚               ⡁
⠄                    ⢀⣀⡀⢀⣀⣀⡖⠲⠤⠤⠤⠤⠤⠼⠘⠒⠃                      ⠄
⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠈⠉⠉⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁ 1.0
0.0                                                      42.0
     total events | 42
      peak bytes  | 73.9 KB
     ----------------------------
     alloc events | 23
     alloc bytes  | 98.5 KB
     ----------------------------
     freed events | 19
     freed bytes  | 49.2 KB
</pre></div><p>Amazing!</p><p>Memory usage is lower than with <code>String</code>, and the number of allocations fell
from 2017 to just 23!</p><p>As we did before, we see peaks when the <code>Vec</code> resizes, but between them,
everything is flat. It seems that 22 bytes is enough to store most of the
names of the top 1000 US cities.</p><h2><a id="the-smartstring-crate" href="#the-smartstring-crate"></a>The <code>smartstring</code> crate</h2><p>Can we do even better?</p><p>The <a href="https://crates.io/crates/smartstring">smartstring</a> crate makes similar promises
to <code>smol_str</code> with the following differences:</p><ul><li>It can inline strings of up to 23 bytes (that&#39;s one more byte!)</li><li>Its String type is <strong>mutable</strong></li><li>There are two strategies, one of them re-inlines the string if
a mutation makes it short enough again.</li></ul><p>That all sounds great.</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo add smartstring
      Adding smartstring v0.2.2 to dependencies
</pre></div><p>It doesn&#39;t come with a <code>serde</code> feature at the time of this writing, but it is
pretty trivial to write an adapter.</p><div translate="no"><p>Rust code</p><pre data-lang="rust"><i>// in `src/sample.rs`</i>

<i>use</i> smartstring<i>::</i><i>{</i>LazyCompact<i>,</i> SmartString<i>}</i><i>;</i>
<i>struct</i> <i>SmartWrap</i><i>(</i><i>SmartString</i><i>&lt;</i><i>LazyCompact</i><i>&gt;</i><i>)</i><i>;</i>

<i>impl</i> <i>From</i><i>&lt;</i><i>String</i><i>&gt;</i> <i>for</i> <i>SmartWrap</i> <i>{</i>
    <i>fn</i> <i>from</i><i>(</i><i>s</i><i>:</i> <i>String</i><i>)</i> -&gt; <i>Self</i> <i>{</i>
        <i>Self</i><i>(</i>s<i>.</i><i>into</i><i>(</i><i>)</i><i>)</i>
    <i>}</i>
<i>}</i>

<i>impl</i> <i>From</i><i>&lt;</i><i>&amp;</i><i>str</i><i>&gt;</i> <i>for</i> <i>SmartWrap</i> <i>{</i>
    <i>fn</i> <i>from</i><i>(</i><i>s</i><i>:</i> <i>&amp;</i><i>str</i><i>)</i> -&gt; <i>Self</i> <i>{</i>
        <i>Self</i><i>(</i>s<i>.</i><i>into</i><i>(</i><i>)</i><i>)</i>
    <i>}</i>
<i>}</i>

<i>impl</i><i>&lt;</i><i>&#39;</i><i>de</i><i>&gt;</i> serde<i>::</i><i>Deserialize</i><i>&lt;</i><i>&#39;</i><i>de</i><i>&gt;</i> <i>for</i> <i>SmartWrap</i> <i>{</i>
    <i>fn</i> <i>deserialize</i><i>&lt;</i><i>D</i><i>&gt;</i><i>(</i><i>deserializer</i><i>:</i> <i>D</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>Self</i><i>,</i> <i>D</i><i>::</i><i>Error</i><i>&gt;</i>
    <i>where</i>
        <i>D</i><i>:</i> serde<i>::</i><i>Deserializer</i><i>&lt;</i><i>&#39;</i><i>de</i><i>&gt;</i><i>,</i>
    <i>{</i>
        <i>use</i> <i>::</i>serde<i>::</i>de<i>::</i><i>{</i>Error<i>,</i> Visitor<i>}</i><i>;</i>
        <i>use</i> std<i>::</i>fmt<i>;</i>

        <i>struct</i> <i>SmartVisitor</i><i>;</i>

        <i>impl</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> <i>Visitor</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> <i>for</i> <i>SmartVisitor</i> <i>{</i>
            <i>type</i> <i>Value</i> = <i>SmartWrap</i><i>;</i>

            <i>fn</i> <i>expecting</i><i>(</i><i>&amp;</i><i>self</i><i>,</i> <i>formatter</i><i>:</i> <i>&amp;</i><i>mut</i> fmt<i>::</i><i>Formatter</i><i>)</i> -&gt; fmt<i>::</i><i>Result</i> <i>{</i>
                formatter<i>.</i><i>write_str</i><i>(</i><i>&#34;a string&#34;</i><i>)</i>
            <i>}</i>

            <i>fn</i> <i>visit_str</i><i>&lt;</i><i>E</i><i>:</i> <i>Error</i><i>&gt;</i><i>(</i><i>self</i><i>,</i> <i>v</i><i>:</i> <i>&amp;</i><i>str</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>Self</i><i>::</i><i>Value</i><i>,</i> <i>E</i><i>&gt;</i> <i>{</i>
                <i>Ok</i><i>(</i>v<i>.</i><i>into</i><i>(</i><i>)</i><i>)</i>
            <i>}</i>

            <i>fn</i> <i>visit_borrowed_str</i><i>&lt;</i><i>E</i><i>:</i> <i>Error</i><i>&gt;</i><i>(</i><i>self</i><i>,</i> <i>v</i><i>:</i> <i>&amp;</i><i>&#39;</i><i>a</i> <i>str</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>Self</i><i>::</i><i>Value</i><i>,</i> <i>E</i><i>&gt;</i> <i>{</i>
                <i>Ok</i><i>(</i>v<i>.</i><i>into</i><i>(</i><i>)</i><i>)</i>
            <i>}</i>

            <i>fn</i> <i>visit_string</i><i>&lt;</i><i>E</i><i>:</i> <i>Error</i><i>&gt;</i><i>(</i><i>self</i><i>,</i> <i>v</i><i>:</i> <i>String</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>Self</i><i>::</i><i>Value</i><i>,</i> <i>E</i><i>&gt;</i> <i>{</i>
                <i>Ok</i><i>(</i>v<i>.</i><i>into</i><i>(</i><i>)</i><i>)</i>
            <i>}</i>
        <i>}</i>

        deserializer<i>.</i><i>deserialize_str</i><i>(</i>SmartVisitor<i>)</i>
    <i>}</i>
<i>}</i>

<i>impl</i> <i>Sample</i> <i>{</i>
    <i>pub</i> <i>fn</i> <i>run</i><i>(</i><i>self</i><i>)</i> <i>{</i>
        <i>match</i> <i>self</i><i>.</i><i>lib</i> <i>{</i>
            <i>Lib</i><i>::</i>Std =&gt; <i>self</i><i>.</i><i>read_records</i><i>::</i><i>&lt;</i><i>String</i><i>&gt;</i><i>(</i><i>)</i><i>,</i>
            <i>Lib</i><i>::</i>Smol =&gt; <i>self</i><i>.</i><i>read_records</i><i>::</i><i>&lt;</i>smol_str<i>::</i><i>SmolStr</i><i>&gt;</i><i>(</i><i>)</i><i>,</i>
            <i>Lib</i><i>::</i>Smart =&gt; <i>self</i><i>.</i><i>read_records</i><i>::</i><i>&lt;</i><i>SmartWrap</i><i>&gt;</i><i>(</i><i>)</i><i>,</i>
        <i>}</i>
    <i>}</i>
<i>}</i>
</pre></div><p>Let&#39;s try it!</p><div translate="no"><p>Shell session</p><pre data-lang="shell">$ cargo build &amp;&amp; ./target/debug/small sample --lib smart 2&gt;! events.ldjson &amp;&amp; ./target/debug/small report events.ldjson
   Compiling small v0.1.0 (/home/amos/ftl/small)
    Finished dev [unoptimized + debuginfo] target(s) in 0.95s
Read 1000 records
found 35 events
⡁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈⡏⠉⡏ ⠁⠈ ⡁ 73813.0
⠄                                                    ⡇ ⡇    ⠄
⠂                                                    ⡇ ⡇    ⠂
⡁                                                    ⡇ ⡇    ⡁
⠄                                                    ⡇ ⡇    ⠄
⠂                                                    ⡇ ⡇    ⠂
⡁                                                    ⡇ ⣇⣀⣀⣀ ⡁
⠄                                                    ⡇      ⠄
⠂                                                    ⡇      ⠂
⡁                                                    ⡇      ⡁
⠄                                               ⡏⢹   ⡇      ⠄
⠂                                               ⡇⢸   ⡇      ⠂
⡁                                               ⡇⢸   ⡇      ⡁
⠄                                               ⡇⠘⠒⠒⠒⠃      ⠄
⠂                                               ⡇           ⠂
⡁                                           ⢸⠉⢹ ⡇           ⡁
⠄                                           ⢸ ⢸⣀⡇           ⠄
⠂                                        ⡤⠤⡄⢸               ⠂
⡁                                    ⢀⣀⣀ ⡇ ⠓⠚               ⡁
⠄                        ⢀⣀⣀ ⣀⣀⣀⣰⠒⠲⠤⠤⠼ ⠘⠒⠃                  ⠄
⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉ ⠉⠉⠁⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁⠈ ⠁ 1.0
0.0                                                      35.0
     total events | 35
      peak bytes  | 73.8 KB
     ----------------------------
     alloc events | 19
     alloc bytes  | 98.4 KB
     ----------------------------
     freed events | 16
     freed bytes  | 49.2 KB
</pre></div><p>This is the best performance we&#39;ve seen so far. We&#39;re down to 19
allocation events, and peak memory usage of 73.8 KB.</p><h2><a id="let-s-summarize" href="#let-s-summarize"></a>Let&#39;s summarize</h2><p>Here&#39;s a quick comparison of the feature sets:</p><div><table><thead><tr><td>Type</td><td>Serde</td><td>Max inline</td><td>Stream-friendly</td><td>Mutable</td><td><code>unsafe</code></td><td>Clone</td></tr></thead><tbody><tr><td>&amp;&#39;a str</td><td>Built-in</td><td>(borrowed)</td><td>no</td><td>no</td><td>-</td><td><strong>O(1)</strong></td></tr><tr><td>String</td><td>Built-in</td><td>0</td><td><strong>yes</strong></td><td><strong>yes</strong></td><td>-</td><td>O(n)</td></tr><tr><td>SmolStr</td><td>Feature</td><td>22</td><td><strong>yes</strong></td><td>no</td><td><strong>no</strong></td><td><strong>O(1)</strong></td></tr><tr><td>SmartString</td><td>In progress</td><td>23</td><td><strong>yes</strong></td><td><strong>yes</strong></td><td>yes</td><td>O(n)</td></tr></tbody></table></div><div>

<p>A PR for serde support in <code>smartstring</code> <a href="https://github.com/bodil/smartstring/pull/2">has been merged</a>.</p></div>
<p>Let&#39;s now compare the memory characterestics for our sample workload:</p><div><table><thead><tr><td>Type</td><td>Peak memory usage</td><td>Total memory events</td></tr></thead><tbody><tr><td>String</td><td>82.7 KB</td><td>2033</td></tr><tr><td>SmolStr</td><td>73.9 KB</td><td>42</td></tr><tr><td>SmartString</td><td>73.8 KB</td><td>35</td></tr></tbody></table></div><p>Finally, let&#39;s look at <a href="https://github.com/fasterthanlime/small-str-bench">three microbenchmarks</a>,
which relevance I absolutely cannot guarantee. Microbenchmarks lie <em>all the time</em>.</p><blockquote><p>In particular, those graphs completely ignore the things we&#39;ve just learned
about the number of allocation operations, they completely ignore the effects
of cache locality - they&#39;re just that - microbenchmarks.</p><p>Even then, we can still validate some instincts by looking at them.</p></blockquote><p>Note that <strong>all these graphs use a <a href="https://en.wikipedia.org/wiki/Logarithmic_scale">logarithmic scale</a></strong>.
They were run on an <code>Intel(R) Xeon(R) CPU E5-1650 v2 @ 3.50GHz</code>.</p><p>The legend (top right) shows:</p><ul><li><code>string</code> for <code>std::string::String</code></li><li><code>smol</code> for <code>smol_str::SmolStr</code></li><li><code>smart</code> for <code>smartstring::SmartString&lt;LazyCompact&gt;</code></li></ul><div>

<p>No mutations are being benchmarked, so testing <code>Compact</code> probably wouldn&#39;t make sense.</p></div>
<p>The first one builds a &#34;string&#34; from a <code>&amp;str</code>:</p><p><img src="https://cdn.fasterthanli.me/content/articles/small-strings-in-rust/assets/from~d863e3655f21dbf5.svg"/></p><p>This is a <code>O(n)</code> operation, as none of the types have any choice but to copy the entire
contents to their own storage.</p><p>For long (&gt;22 bytes) strings, we can see <code>smol</code> has a slight constant overhead over
<code>SmartString</code> and <code>String</code>. That&#39;s not surprising, as <code>smol</code> uses
<code>Arc&lt;str&gt;</code> for those - which also means it&#39;s <code>Send</code> and <code>Sync</code>.</p><p>The second benchmark simply clones a &#34;string&#34;:</p><p><img src="https://cdn.fasterthanli.me/content/articles/small-strings-in-rust/assets/clone~83d5078533a71e7a.svg"/></p><p>This is where <code>smol_str</code> shines.</p><p>For short strings, <code>SmartString</code> wins. For longer strings, <code>SmolStr::clone</code> is <code>O(1)</code>, since
it&#39;s just incrementing the reference count of an <code>Arc</code>.</p><p>The final benchmark converts a &#34;string&#34; back into the <code>String</code> type:</p><p><img src="https://cdn.fasterthanli.me/content/articles/small-strings-in-rust/assets/into~ada5acabd40f36fa.svg"/></p><p>This one is particularly interesting to me - it looks a bit noisy, as if there were too many
outliers. And there were, probably! But that&#39;s not the whole story.</p><p>For short strings, both <code>smartstring</code> and <code>smol_str</code> need to actually build a
<code>String</code> from scratch: which means allocating the <code>String</code> struct itself, and
its storage on the heap. For longer strings, it looks like <code>smol</code> is doing twice the work!
Is it allocating storage and copying twice? I&#39;m not sure.</p><p>Go look for yourself and report back!</p><p>What <em>don&#39;t</em> those benchmarks show, though?</p><p>We&#39;ve used both crates to deserialize JSON records, but that&#39;s not what
either says to use them for. <code>smol_str</code> is <a href="https://crates.io/crates/smol_str/rev">used in
rowan</a>, itself used by rust-analyzer -
its README says its primary use case is &#34;good enough default storage for
tokens of typical programming languages&#34;. We haven&#39;t experimented with its
whitespace-specific features at all.</p><p>As for <code>smartstring</code>, it&#39;s recommended for &#34;a key type for a B-tree&#34; (such as
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html">BTreeMap</a>),
because inline strings greatly improve <a href="https://en.wikipedia.org/wiki/Locality_of_reference">cache
locality</a>. This is something
none of our benchmarks even touched.</p><p>This concludes our comparison of <code>String</code>, <code>SmolStr</code>, and <code>SmartString</code> -
even though there would be a lot more to say about them both.</p><p>Until next time, take care!</p>

        

        
            <div>
                    
                    
                    <p><a target="_blank" rel="nofollow" href="https://blog.plover.com/api/comments?url=https%3A%2F%2Ffasterthanli.me%2Farticles%2Fsmall-strings-in-rust&amp;title=Small%20strings%20in%20Rust">
                        <img alt="Reddit logo" src="https://cdn.fasterthanli.me/static/img/reddit~219e569d62a043b2.svg"/>
                        <span>
                            Comment <span>on /r/fasterthanlime</span>
                        </span>
                    </a>
                </p></div>
            
        

        
            
<p>If you liked what you saw, please support my work!</p>
<p>
    <a href="https://github.com/sponsors/fasterthanlime">
    <img alt="Github logo" src="https://cdn.fasterthanli.me/static/img/github~55b614e277dce71c.black.png"/>
    <span>Donate on GitHub</span>
    </a>
    <a href="https://www.patreon.com/bePatron?u=47556">
    <img alt="Patreon logo" src="https://cdn.fasterthanli.me/static/img/patreon/mark-white~5bbe96f563a716c8.png"/>
    <span>Donate on Patreon</span>
    </a>
</p>


        

        


        <div>
            <div><p>
                Looking for <a href="https://blog.plover.com/">the homepage</a>?
            </p></div>

            

            
            
            
                <div><p>
                    Another article: <a href="https://blog.plover.com/articles/when-rustc-explodes">When rustc explodes</a>
                </p></div>
            
        </div>
        <!-- page_html ends -->
    </div></div>
  </body>
</html>
