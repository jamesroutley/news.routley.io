<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2025/12/28/parsing-advances.html">Original</a>
    <h1>Parsing Advances</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <header>
          
          <time datetime="2025-12-28">Dec 28, 2025</time>
        </header>
        <p>
          I find myself writing yet another toy parser, as one does during a
          Christmas break. It roughly follows
          <a href="https://matklad.github.io/2023/05/21/resilient-ll-parsing-tutorial.html"><em>Resilient LL Parsing Tutorial</em></a>. Not because I need
          resilience, but mostly because I find producing a syntax tree and a
          collection of diagnostics a more natural fit for the problem than
          bailing out on the first error.
        </p>
        <p>
          One practical pitfall with the approach is infinite loops/recursion.
          Resilience sometimes means
          <em>not</em> consuming a token, and, if you do that in a loop or a
          Pratt recursive call, you’ll get yourself an annoying to debug error:
        </p>

        <figure>
          <pre><code><span>running 1 test from ./src/corpus_test.ts</span>
<span>corpus ...Task test deno test --allow-read=./src/corpus --allow-write=./src/corpus &#34;--&#34; &#34;--update&#34;</span>
<span>Check src/corpus_test.ts</span>
<span></span>
<span>&lt;--- Last few GCs ---&gt;</span>
<span>4,[26641:0x9d1574000]     7390 ms: Mark-Compact (reduce) 3924.9 (3927.3) -&gt; 3924.9 (3926.3) MB, pooled: 0.0 MB, 1224.00 / 0.00 ms (+ 0.3 ms in 1 steps since start of marking, biggest step 0.3 ms, walltime since start of marking 1232 ms) (average mu = 0.200,[26641:0x9d1574000]     8804 ms: Mark-Compact (reduce) 4009.9 (4011.3) -&gt; 4009.9 (4011.3) MB, pooled: 0.0 MB, 1294.67 / 0.00 ms (+ 0.2 ms in 1 steps since start of marking, biggest step 0.2 ms, walltime since start of marking 1302 ms) (average mu = 0.141,</span>
<span></span>
<span></span>
<span>#</span>
<span># Fatal JavaScript out of memory: Ineffective mark-compacts near heap limit</span>
<span>#</span>
<span>==== C stack trace ===============================</span>
<span></span>
<span>    0   deno                                0x0000000102ce8404 v8::base::debug::StackTrace::StackTrace() + 24</span>
<span>    1   deno                                0x0000000102ceeb9c v8::platform::(anonymous namespace)::PrintStackTrace() + 24</span>
<span>    2   deno                                0x0000000102ce4094 v8::base::FatalOOM(v8::base::OOMType, char const*) + 68</span>
<span>    3   deno                                0x0000000102d3a7a8 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, v8::OOMDetails const&amp;) + 296</span>
<span>    4   deno                                0x0000000102f37378 v8::internal::Heap::stack() + 0</span>
<span>    5   deno                                0x0000000102f3581c v8::internal::Heap::CheckMemoryPressure() + 0</span>
<span>    6   deno                                0x0000000102ead4f8 v8::internal::StackGuard::HandleInterrupts(v8::internal::StackGuard::InterruptLevel) + 504</span>
<span>    7   deno                                0x000000010335fe44 v8::internal::Runtime_HandleNoHeapWritesInterrupts(int, unsigned long*, v8::internal::Isolate*) + 304</span>
<span>    8   deno                                0x00000001043887b4 Builtins_CEntry_Return1_ArgvOnStack_NoBuiltinExit + 84</span>
<span>    9   ???                                 0x0000000126997874 0x0 + 4942559348</span>
<span>    10  ???                                 0x000000012698a758 0x0 + 4942505816</span>
<span>...</span></code></pre>
        </figure>
        <p>
          For a concrete example, you might parse function argument list using
          code like this:
        </p>

        <figure>
          <pre><code><span><span>const</span> <span>result</span>: ast.<span>Expression</span>[] = [];</span>
<span>p.<span>expect</span>(<span><span>&#34;(&#34;</span></span>);</span>
<span><span>while</span> (!p.<span>eof</span>() &amp;&amp; !p.<span>at</span>(<span>&#34;)&#34;</span>)) {</span>
<span>  result.<span>push</span>(<span>expression</span>(p));</span>
<span>  <span>if</span> (!p.<span>at</span>(<span>&#34;)&#34;</span>)) p.<span>expect</span>(<span>&#34;,&#34;</span>);</span>
<span>}</span>
<span>p.<span>expect</span>(<span>&#34;)&#34;</span>);</span>
<span><span>return</span> result;</span></code></pre>
        </figure>
        <p>
          The implicit contract here is that <code>expression</code> consumes at
          least one token, even if there are errors in the source code. If
          there’s some token that makes <code>expression</code> bail without
          consuming anything, the code loops forever, and you’ll need a debugger
          to get at the stack trace!
        </p>
        <p>
          The way I solved this issue traditionally is via a combination of two
          techniques:
        </p>
        <p>
          <em>Fuel:</em> parser has a <code>fuel: Cell&lt;u32&gt;</code> field,
          which is decremented even by “readonly” lookahead methods, and topped
          up every time the parser consumes a token. Fuel is useful to make you
          parser crash somewhat cleanly, though the crash is typically still
          removed from problematic function by several stack frames.
        </p>
        <p>
          The second technique is to maintain a mental map of functions which
          always consume at least one token of input, and functions which might
          bail without consuming anything. And, whenever you write a loop or a
          recursive call, consult this map to be sure to call at least one
          token-consuming function. Hard and error prone!
        </p>
        <p>
          Well, I think I’ve figured something better today! You can assert that
          parser did advance when you expect it to. The <em>smaller</em> benefit
          here is that if parser didn’t advance, you get an immediate error. The
          <em>bigger</em> benefit is that these asserts materialize the mental
          map of advancing functions in the source code, so it doesn’t have to
          be mental anymore!
        </p>
        <p>
          This seems like an obvious idea in retrospect, but, well, took me more
          than one parser to figure it out!
        </p>
        <p>Concretely, I came up with the following base parser API:</p>

        <figure>
          <pre><code><span><span>class</span> <span>Parser</span> {</span>
<span>  <span>private</span> <span>tokens</span>: ast.<span>Token</span>[];</span>
<span>  <span>private</span> <span>index</span>: <span>number</span> = <span>0</span>;</span>
<span>  <span>private</span> <span>advances</span>: <span>number</span>[] = [];</span>
<span></span>
<span>  <span>advance_push</span>(<span></span>) {</span>
<span>    <span>this</span>.<span>advances</span>.<span>push</span>(<span>this</span>.<span>index</span>);</span>
<span>  }</span>
<span>  <span>advance_pop</span>(<span></span>) {</span>
<span>    <span>const</span> advance = <span>this</span>.<span>advances</span>.<span>pop</span>();</span>
<span>    <span>assert</span>(advance !== <span>undefined</span>);</span>
<span>    <span>assert</span>(advance &lt; <span>this</span>.<span>index</span>);</span>
<span>  }</span>
<span>  <span>advance_drop</span>(<span></span>) {</span>
<span>    <span>const</span> advance = <span>this</span>.<span>advances</span>.<span>pop</span>();</span>
<span>    <span>assert</span>(advance !== <span>undefined</span>);</span>
<span>  }</span>
<span>}</span></code></pre>
        </figure>
        <p>
          And here is the buggy function that lead to the error at the start of
          the article:
        </p>

        <figure>
          <pre><code><span><span>function</span> <span>expression_pratt</span>(<span></span></span>
<span><span>  p: Parser,</span></span>
<span><span>  left: ast.TokenTag,</span></span>
<span><span></span>): ast.<span>Expression</span> {</span>
<span>  <span>let</span> <span>lhs</span>: ast.<span>Expression</span> = <span>expression_delimited</span>(p);</span>
<span></span>
<span>  <span>while</span> (p.<span>at</span>(<span><span>&#34;(&#34;</span></span>)) {</span>
<span>    lhs = <span>expression_call</span>(p, lhs);</span>
<span>  }</span>
<span></span>
<span>  <span>while</span> (<span>true</span>) {</span>
<span>    <span>const</span> right = p.<span>token</span>();</span>
<span>    <span>if</span> (<span>expression_pratt_right_binds_tighter</span>(left, right.<span>tag</span>)) {</span>
<span>      <span>const</span> rhs = <span>expression_pratt</span>(p, right.<span>tag</span>);</span>
<span>      lhs = {</span>
<span>        <span>tag</span>: <span>&#34;ExpressionBinary&#34;</span>,</span>
<span>        <span>location</span>: right.<span>location</span>,</span>
<span>        <span>operator</span>: right.<span>tag</span> <span>as</span> ast.<span>BinaryOperation</span>,</span>
<span>        lhs,</span>
<span>        rhs,</span>
<span>      };</span>
<span>    } <span>else</span> {</span>
<span>      <span>return</span> lhs;</span>
<span>    }</span>
<span>  }</span>
<span>}</span></code></pre>
        </figure>
        <p>The same function, but with advanced assertions:</p>

        <figure>
          <pre><code><span><span>function</span> <span>expression_pratt</span>(<span></span></span>
<span><span>  p: Parser,</span></span>
<span><span>  left: ast.TokenTag,</span></span>
<span><span></span>): ast.<span>Expression</span> {</span>
<span>  <span>let</span> <span>lhs</span>: ast.<span>Expression</span> = <span>expression_delimited</span>(p);</span>
<span></span>
<span>  <span>while</span> (p.<span>at</span>(<span><span>&#34;(&#34;</span></span>)) {</span>
<span>    lhs = <span>expression_call</span>(p, lhs);</span>
<span>  }</span>
<span></span>
<span>  <span>while</span> (<span>true</span>) {</span>
<span>    p.<span>advance_push</span>();</span>
<span>    <span>const</span> right = p.<span>token</span>();</span>
<span>    <span>if</span> (<span>expression_pratt_right_binds_tighter</span>(left, right.<span>tag</span>)) {</span>
<span>      <span>const</span> rhs = <span>expression_pratt</span>(p, right.<span>tag</span>);</span>
<span>      lhs = {</span>
<span>        <span>tag</span>: <span>&#34;ExpressionBinary&#34;</span>,</span>
<span>        <span>location</span>: right.<span>location</span>,</span>
<span>        <span>operator</span>: rhs.<span>tag</span> <span>as</span> ast.<span>BinaryOperation</span>,</span>
<span>        lhs,</span>
<span>        rhs,</span>
<span>      };</span>
<span>    } <span>else</span> {</span>
<span>      p.<span>advance_drop</span>();</span>
<span>      <span>return</span> lhs;</span>
<span>    }</span>
<span>    p.<span>advance_pop</span>();</span>
<span>  }</span>
<span>}</span></code></pre>
        </figure>
        <p>The new error message:</p>

        <figure>
          <pre><code><span>running 1 test from ./src/corpus_test.ts</span>
<span>corpus ... FAILED (11ms)</span>
<span></span>
<span> ERRORS</span>
<span></span>
<span>corpus =&gt; ./src/corpus_test.ts:47:6</span>
<span>error: Error: assertion failed</span>
<span>  if (!condition) throw new Error(&#34;assertion failed&#34;);</span>
<span>                        ^</span>
<span>    at assert (./src/stdx.ts:2:25)</span>
<span>    at Parser.advance_pop (./src/parse.ts:132:5)</span>
<span>    at expression_pratt (./src/parse_grammar.ts:169:7)</span>
<span>    at expression (./src/parse_grammar.ts:143:10)</span>
<span>    at expression_block (./src/parse_grammar.ts:305:21)</span>
<span>    at declaration_fun (./src/parse_grammar.ts:73:7)</span>
<span>    at declaration (./src/parse_grammar.ts:25:12)</span>
<span>    at Module.file (./src/parse_grammar.ts:10:15)</span>
<span>    at Module.parse (./src/parse.ts:13:18)</span>
<span>    at ast_dump (./src/corpus_test.ts:85:22)</span></code></pre>
        </figure>
        <p>and the fix:</p>

        <figure>
          <pre><code><span>  <span>while</span> (<span>true</span>) {</span>
<span>    p.<span>advance_push</span>();</span>
<span>    <span>const</span> right = p.<span>token</span>();</span>
<span>    <span>if</span> (<span>expression_pratt_right_binds_tighter</span>(left, right.<span>tag</span>)) {</span>
<span>      p.<span>bump</span>();</span>
<span>      <span>const</span> rhs = <span>expression_pratt</span>(p, right.<span>tag</span>);</span>
<span>      lhs = {</span>
<span>        <span>tag</span>: <span>&#34;ExpressionBinary&#34;</span>,</span>
<span>        <span>location</span>: right.<span>location</span>,</span>
<span>        <span>operator</span>: rhs.<span>tag</span> <span>as</span> ast.<span>BinaryOperation</span>,</span>
<span>        lhs,</span>
<span>        rhs,</span>
<span>      };</span>
<span>    } <span>else</span> {</span>
<span>      p.<span>advance_drop</span>();</span>
<span>      <span>return</span> lhs;</span>
<span>    }</span>
<span>    p.<span>advance_pop</span>();</span>
<span>  }</span></code></pre>
        </figure>
      </article>
    </div></div>
  </body>
</html>
