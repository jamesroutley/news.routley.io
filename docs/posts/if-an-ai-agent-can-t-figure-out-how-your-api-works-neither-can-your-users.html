<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stytch.com/blog/if-an-ai-agent-cant-figure-out-how-your-api-works-neither-can-your-users/">Original</a>
    <h1>If an AI agent can&#39;t figure out how your API works, neither can your users</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>LLM-powered agents are beginning to look a lot like <strong>tireless junior developers</strong>. Hand them an API along with the docs and they’ll diligently read the reference, issue a request, parse the error, adjust parameters, and try again and again—<strong>on loop—until something works</strong>. </p><p>Frameworks like <a rel="noreferrer noopener" href="https://github.com/langchain-ai/langchain">LangChain</a> and <a rel="noreferrer noopener" href="https://platform.openai.com/docs/guides/function-calling?api-mode=chat">OpenAI function-calling</a> helpers, as well as agents like <a rel="noreferrer noopener" href="https://www.cursor.com/en">Cursor</a>, <a rel="noreferrer noopener" href="https://github.com/anthropics/claude-code">Claude Code</a>, <a rel="noreferrer noopener" href="https://openai.com/codex/">OpenAI Codex</a>, and <a rel="noreferrer noopener" href="https://block.github.io/goose/">Codename Goose</a>, make that cycle even easier to wire up and follow.</p><p>But raw persistence of an agent isn’t always enough. The moment your API’s developer experience falters—<em>an outdated example, a vague 400 payload, an undiscoverable required field</em>—the agent stalls out. That stall is diagnostic. If an algorithm with perfect patience and zero ego can’t figure things out, then <strong>a human developer on a deadline is almost certainly hitting the same wall</strong>.</p><p>That symmetry can be a powerful lever. Fix the friction points that trip up agents, and you clear the path for every user, silicon‑ or carbon‑based, to have a great experience using your API.</p><h2 id="quickwalkthroughhowaiagentsworkwithapis"><strong>Quick walk-through: how AI agents work with APIs</strong></h2><p>Most agent frameworks follow a <strong>ReAct cycle</strong> that interleaves reasoning and action, all intended to mirror human problem-solving.</p><div><figure><img alt="ReAct Cycle" loading="lazy" width="1324" height="312" decoding="async" data-nimg="1" srcset="https://cdn.sanity.io/images/3jwyzebk/production/47463c8f84f8e20a6c584ba2330410a3eacfda67-1324x312.png?auto=format&amp;fit=max&amp;w=1920&amp;q=75 1x, https://cdn.sanity.io/images/3jwyzebk/production/47463c8f84f8e20a6c584ba2330410a3eacfda67-1324x312.png?auto=format&amp;fit=max&amp;w=3840&amp;q=75 2x" src="https://cdn.sanity.io/images/3jwyzebk/production/47463c8f84f8e20a6c584ba2330410a3eacfda67-1324x312.png?auto=format&amp;fit=max&amp;w=3840&amp;q=75"/><figcaption></figcaption></figure></div><p>Give the agent a task (e.g. “List open PRs”) and a set of tools (e.g. the GitHub <code>/pulls </code>endpoint plus API docs), and it will iterate exactly like a human. It will consult the reference, fire the HTTP call, inspect the JSON or error, tweak its approach, and loop until it lands a 2xx response. </p><p>To walk through a quick example:</p><ol><li><strong>Thought</strong>: “I need to create a new user via this API. Let me see… The docs show an endpoint POST /users.”</li><li><strong>Action</strong>: Call POST /users with the data it thinks is required (say, it provides a JSON with an email and password).</li><li><strong>Observation</strong>: The API returns 400 Bad Request. (Uh-oh, something’s wrong.)</li><li><strong>Thought</strong>: “The error is just ‘Bad Request’ with no details. I’m not sure what’s missing. Maybe I forgot a field? The docs weren’t clear about required fields. Let me guess and add a name field.”</li><li><strong>Action</strong>: Call POST /users with email, password, and name.</li><li><strong>Observation</strong>: This time it returns 201 Created – success!</li></ol><p>In this case, the agent got lucky after one blind retry, but it was working in the dark because the error said nothing and the docs never called out the required name field. A human developer would have hit the same wall—just with more frustration and a slower iteration cycle.</p><p>When breadcrumbs do exist, agents eagerly follow along. They parse code samples, follow embedded links, and can even load documentation directly—provided it&#39;s integrated via a standardized interface such as an <code>llms.txt</code> file. Frameworks and tools like LangChain&#39;s <code>mcpdoc</code> or <a rel="noreferrer noopener" href="https://mintlify.com/">Mintlify</a> facilitate this by auto-generating structured documentation that agents can parse. Agents can also incorporate hints from error payloads directly into reasoning steps. Without these clear signals, the agent quickly runs out of options.</p><p>So the success rate of <strong>an LLM agent can be a direct reflection of the clarity of your docs and error design</strong>. If the agent can’t figure out your API, odds are a human developer is stuck at the same breakpoint.</p><h2 id="whenpoorapiuxderailseveryone"><strong>When poor API UX derails everyone</strong></h2><p>The same usability gaps that frustrate human developers—scattered docs, cryptic errors, quirky naming—throw an LLM into a tail-spin.</p><h3 id="startwithdocs">Start with docs</h3><p>This should come as no surprise. If critical details are split between a marketing page, a stale forum post, and a 3yr old PDF, the agent won&#39;t magically stitch them together. It sees only what you feed it. Required parameters that live in a buried Changelog or a comment thread simply don’t exist from the model’s perspective. Humans feel the same pain, just more slowly.</p><h3 id="surfacecleardetailederrorpayloads">Surface clear, detailed error payloads</h3><p>An LLM consumes exactly what your API returns. Providing nothing beyond a bare HTTP status and generic code forces the agent into guesswork, potentially triggering endless retry loops. </p><p>For example, one team integrating an agent discovered a 422 response with no body text caused perpetual retries. By explicitly surfacing the error message &#34;missing required field &#39;first_name&#39;&#34;, they immediately enabled the agent to self-correct and succeed.</p><p>On the other hand, vague messages like &#34;400 Bad Request&#34; don&#39;t give actionable direction to either agents or humans. Clear, descriptive errors—like &#34;expiry_date must be in YYYY-MM-DD format&#34;—allow the agent to instantly parse the hint, regenerate its call, and move forward without interruption. Without these informative breadcrumbs, progress just stops.</p><h3 id="addressconsistencygaps">Address consistency gaps</h3><p>LLMs are world-class pattern detectors. They learn your casing, pluralization, and resource hierarchy in a few shots. Deviate once—<code>user_id</code> here, <code>userId</code> there—and the model may treat the second field as unrelated data. Humans might curse under their breath and move on; the agent quietly corrupts its prompt chain or mis-routes data... then spirals.</p><h3 id="twovignettes">Two vignettes</h3><p>To illustrate the impact of good vs. bad API UX, we can compare two scenarios of an agent interacting with a hypothetical API.</p><h4 id="1guessinginthedark">1: Guessing in the dark</h4><pre tabindex="0"><code>Thought: Need to create an order. Docs show example curl; let&#39;s try it.
Action: POST /orders {&#34;item&#34;: &#34;Book&#34;}
Obs: 400 Bad Request
Thought: No detail provided. Maybe quantity is required?
Action: POST /orders {&#34;item&#34;: &#34;Book&#34;, &#34;quantity&#34;: 1}
Obs: 400 Bad Request
Thought: Still failing. Is the endpoint wrong? Another required field missing? I&#39;m stuck</code></pre><p>The agent sprawls, trying random tweaks—exactly what a rushed developer would do after copy-pasting a broken example.</p><h4 id="scenario2failingtowardsuccess">Scenario 2: Failing Toward Success</h4><pre tabindex="0"><code>Thought: Goal is `POST /orders`. Docs say item_id and customer_id are required.
Action: POST /orders {&#34;item_id&#34;: &#34;12345&#34;}
Obs: 400 Bad Request – missing required field &#34;customer_id&#34;
Thought: Right, add it.
Action: POST /orders {&#34;item_id&#34;: &#34;12345&#34;, &#34;customer_id&#34;: &#34;999&#34;}
Obs: 201 Created {&#34;order_id&#34;: &#34;ABC123&#34;, ...}</code></pre><p>One clear error message turns a dead end into a single iteration. The difference in time-to-success (seconds vs. minutes) comes directly from clearer docs and more context-rich errors. Fixing the documentation, tightening the schema, and writing explicit errors isn’t AI polish; it’s basic DX hygiene that you can no longer ignore.</p><h3 id="agentshighlightwhathumansstrugglewith"><strong>Agents highlight what humans struggle with</strong></h3><p>When an agent stumbles, it doesn’t hide the evidence. It dumps a log of every consideration, tool call, and error it saw on the way down. Reviewing that log is like replaying a new developer’s first session—you pinpoint exactly where the trail goes cold instead of guessing.</p><p>Because the agent relies solely on what you expose—docs, examples, errors, etc—it offers <strong>noise‑free feedback</strong>. What a person might improvise or Google; an agent can’t. If it stalls, your onboarding material fell short. That’s why teams now talk about <a rel="noreferrer noopener" href="https://stytch.com/blog/the-age-of-agent-experience/">Agent Experience (AX)</a><em> as the next DX frontier: the fundamentals—clear reference, solid examples, consistent patterns—remain the same, but an LLM ruthlessly exposes and logs any gaps.</em></p><p>Think of it like front‑end testing. Just as Selenium scripts click through your UI to catch regressions, an LLM agent “clicks” through your API in sequence. If that automated “Hello World” breaks in CI, treat it as a failing test case—you’ve caught a broken onboarding path before real users did.</p><h2 id="agentsaspracticaldxsmoketests"><strong>Agents as practical DX smoke tests</strong></h2><p>As you iterate on your API, it’s easy for small changes to slip through and break the critical first‑use path. Rather than waiting for a support ticket or forum post, you can enlist an AI agent to act as a nightly smoke tester. By automating your “hello‑world” flow—think <em>create user → log in</em>—you gain immediate visibility into regressions, long before customers bump into them.</p><div><figure><img alt="LLM agent as practical DX smoke test" loading="lazy" width="1212" height="374" decoding="async" data-nimg="1" srcset="https://cdn.sanity.io/images/3jwyzebk/production/c37d41f233f5ddf7a4ad8323c72cca40a6ee0dc9-1212x374.png?auto=format&amp;fit=max&amp;w=1920&amp;q=75 1x, https://cdn.sanity.io/images/3jwyzebk/production/c37d41f233f5ddf7a4ad8323c72cca40a6ee0dc9-1212x374.png?auto=format&amp;fit=max&amp;w=3840&amp;q=75 2x" src="https://cdn.sanity.io/images/3jwyzebk/production/c37d41f233f5ddf7a4ad8323c72cca40a6ee0dc9-1212x374.png?auto=format&amp;fit=max&amp;w=3840&amp;q=75"/><figcaption></figcaption></figure></div><ol><li><strong>Pick a critical flow.</strong> Define your golden path, such as creating an account and authenticating.</li><li><strong>Craft a tight prompt.</strong> Supply just enough documentation so the agent knows which endpoints to call and in what order.</li><li><strong>Run inside CI.</strong> Use deterministic settings (e.g., temperature=0, cap at 3 retries) to execute the agent on each pull request.</li><li><strong>Record &amp; track.</strong> Surface three key metrics—pass/fail, retry count, and time‑to‑first‑success—in your CI logs or an evaluation dashboard.</li></ol><p>A small fintech team ran this play and caught a missing email_verified flag during a pre‑release smoke test, fixing the issue before any customers noticed.</p><p>To implement this in your stack, consider:</p><table><thead><tr><td></td><th><h4>Tooling selection</h4></th><th><h4>Why it works</h4></th></tr></thead><tbody><tr><td colspan="2"><h4>Local sanity check</h4></td></tr><tr><td><h4>Local sanity check</h4></td><td><p>OpenAI Python SDK</p></td><td><p>Quick, ad‑hoc verification</p></td></tr><tr><td colspan="2"><h4>CI‑gated flow</h4></td></tr><tr><td><h4>CI‑gated flow</h4></td><td><p>LangChain agent + PyTest</p></td><td><p>Captures full trace and asserts pass</p></td></tr><tr><td colspan="2"><h4>Trend dashboard</h4></td></tr><tr><td><h4>Trend dashboard</h4></td><td><p>LangSmith or OpenAI Evals</p></td><td><p>Visualizes pass/fail and retry trends</p></td></tr></tbody></table><p>You can run a golden‑path test on every PR and schedule broader agent suites against a staging sandbox nightly (or reset fixtures to avoid state bleed). This type of loop keeps your core onboarding green and gives you confidence that any integration will stay solid.</p><h2 id="buildingapisthatarefriendlytoagentsandusers"><strong>Building APIs that are friendly to agents <em>and</em> users</strong></h2><p>Improving your API’s developer experience for AI agents doesn’t require an entirely separate playbook from improving it for humans. In fact, the needs overlap almost 100%. Here are some best practices – none of them brand new ideas, but newly validated by agent-based testing – that make your API easier to learn and use for all parties involved:</p><h3 id="1provideconsistentpredictabledesign"><strong>1. Provide consistent, predictable design</strong></h3><p><strong>Consistency is king.</strong> Use the same patterns everywhere—endpoints, parameter names, response shapes. If collection routes are plural (<code>/users</code>, <code>/orders</code>) but detail routes are singular (<code>/user/{id}</code>), don’t slip in a rogue <code>/users/{id}</code>. If your payloads are snake_case, never sneak in a camelCase field.</p><p>Both humans and LLMs internalize these conventions almost immediately. After five calls that follow one rule, the sixth is assumed to follow it too; any deviation becomes a silent trap. Bottom line: a solid<em> API foundation built on predictable, consistent patterns</em> is the single biggest lever for an AI-first developer experience. Consistency trims away special cases, reduces onboarding cognitive load, and honors the “principle of least astonishment” that seasoned engineers live by.</p><h3 id="2writeclearcomprehensivedocumentationandkeepitupdated"><strong>2. Write clear, comprehensive documentation (and keep it updated)</strong></h3><p>Good documentation has always mattered, but “good” shifts a notch when the reader is an LLM. For an agent,<strong> docs must be complete, unambiguous, and centralized</strong>—otherwise the model treats missing or conflicting information as fact.</p><p>Start with the basics. <strong>Every endpoint needs a concise description</strong>, clearly flagged required and optional inputs, and explicit response structures including possible errors. Inline JSON examples are critical; agents rely on these to accurately infer payload structure and avoid hallucinations.</p><p><strong>Provide an OpenAPI spec</strong>. GPT-4 plugins and many agent frameworks ingest Swagger files directly, turning specs into live API calls. A single machine-readable spec ensures your guides, references, and examples stay synchronized.</p><p>Finally, <strong>retire outdated PDFs and stale forum answers</strong>—they’ll mislead an agent just like a human. Document authentication explicitly; agents won’t guess that a 401 means “authenticate first.” Clear, consolidated, and example-rich documentation isn’t just user-friendly—it directly determines if your agent succeeds quickly or struggles through trial and error.</p><h3 id="3surfaceerrorswithdetailandclarity"><strong>3. Surface errors with detail and clarity</strong></h3><p>We’ve hammered on error messages, and for good reason. Make your error messages as informative as possible without exposing security-sensitive info. Wherever feasible, include specific reasons for the error and hints to fix it. For example:</p><ul><li><strong>If a required field is missing or empty</strong>, name it in the error: e.g. {&#34;error&#34;: &#34;Missing required field &#39;<code>start_date</code>&#39;&#34;}.</li><li><strong>If a field is improperly formatted or out of range</strong>, explain the expectation: e.g. {&#34;error&#34;: &#34;<code>expiry_date</code> must be in <code>YYYY-MM-DD</code> format&#34;} or {&#34;error&#34;: &#34;<code>quantity</code> must be between <code>1</code> and <code>100</code>&#34;}.</li><li><strong>If an ID wasn’t found</strong>: {&#34;error&#34;: &#34;No customer found with ID <code>XYZ</code>&#34;} instead of just &#34;Invalid ID&#34;.</li><li><strong>For auth issues</strong>: distinguish “<code>token missing</code>” vs “<code>token invalid</code>” vs “<code>insufficient scope</code>” if you can – an agent can react differently to each.</li></ul><p>Many teams now embed a doc link in the error body. Stytch, for instance, returns an error code plus a URL that jumps straight to the remediation page in their docs. A developer can click through; an agent, given the right tool, can fetch the page and incorporate the guidance on its next try. The message itself should remain verbose. JSON structure is fine—machines like it—but a plain-English &#34;message&#34; field often helps an LLM more than a perfectly terse schema. One “AI-friendly” API experiment showed that a chatty text error drove faster agent recovery than a minimal machine-formatted response.</p><p>The last step is to document every error your endpoints can throw. List the code, the conditions that trigger it, and at least one fix. Most references still gloss over error cases, yet they are exactly what an agent—or a frustrated human—needs in order to fail toward success instead of stalling out.</p><h3 id="4guideusersthroughexamplesandtutorials"><strong>4. Guide users through examples and tutorials</strong></h3><p>A solid quick-start guide is a good safety harness for both humans and agents. For products involving multi-step flows—<em>OAuth handshakes, sandbox exchanges, webhook callbacks, etc</em>—a clear, numbered walkthrough with payload examples goes a long way. Agents can ingest these guides verbatim; a snippet from “Create your first invoice” often leads them to succeed immediately, rather than stumbling on hidden dependencies.</p><p>Providing official examples in multiple languages matters, too. Yes, an LLM can convert cURL to Python, but offering a ready-made template in Python, JavaScript, and cURL removes ambiguity around headers and JSON structure.</p><p>As you’d expect, these examples do need constant care. Nothing undermines trust like a copy-pasted snippet failing due to outdated parameters. Wire example payloads into automated tests against staging environments, so breakages surface in CI—not in front of users.</p><p>Finally, embedding live sandboxed API explorers directly in your docs demonstrates working requests in real-time. While agents don’t interact with GUIs, maintaining these interactive examples keeps your golden paths tested, ensuring everyone’s smoother experience..</p><h3 id="5designforsimplicityandnaturaluse"><strong>5. Design for simplicity and natural use</strong></h3><p>Design choices that feel like minor conveniences for humans can be hard blockers for an AI agent. Imagine your API forces clients to list all customers, scrape the numeric ID for “Jane Doe,” then use that ID in a second call to fetch her profile.</p><p>A person can muddle through this. An agent, given only the name, has no path forward. A single search endpoint, <code>GET /customers?query=Jane%20Doe, </code>solves the problem for both audiences and trims two calls to one. The same principle applies to higher-level “shortcut” routes, bulk operations, or summary endpoints. If developers ask for them, then an agent will probably benefit even more because it can stay within a simpler reasoning chain.</p><p>Granularity matters, too. LLMs still have context windows; burying the one BTCUSD price somebody needs inside a 10-thousand-row payload wastes tokens and risks truncation. A filter like <code>GET /prices?symbol=BTCUSD</code> or a paginated response lets the model work with just the relevant slice of data and spares your bandwidth at the same time.</p><p>In short, when you streamline an API to minimize look-ups, hops, and payload bloat, you’re not only polishing DX, you’re also improving AX for agents that can’t improvise around those hurdles.</p><h3 id="6closethefeedbackloop"><strong>6. Close the feedback loop</strong></h3><p>Treat every agent run and every developer support ticket as data in a live feedback loop. When the same questions surface over and over again, assume your docs or API fell short; likely the agent stumbled in that exact spot. Fix the docs, add clear examples, or, if friction is structural, adjust the endpoint itself.</p><p>It’s becoming even more common now to deploy an <strong>LLM assistant within docs and Slack channels</strong>. Each time a bot answers “I&#39;m not sure,” you&#39;ve pinpointed a documentation gap. It’s search analytics on steroids. Developers get instant answers (or occasionally hallucinations), and you clearly see what&#39;s missing.</p><p>Production logs offer another view. If you see repeated calls with obsolete parameters or missing version prefixes, <strong>proactively add targeted errors</strong> (“Did you mean X?”) <strong>or gracefully handle legacy inputs</strong>. More explicit guidance helps both agents and humans self-correct.</p><div><figure><img alt="API feedback flywheel" loading="lazy" width="1840" height="1634" decoding="async" data-nimg="1" srcset="https://cdn.sanity.io/images/3jwyzebk/production/eb784cfeb7ace6fe98864a9c7dfbda0d05660c7b-1840x1634.png?auto=format&amp;fit=max&amp;w=1920&amp;q=75 1x, https://cdn.sanity.io/images/3jwyzebk/production/eb784cfeb7ace6fe98864a9c7dfbda0d05660c7b-1840x1634.png?auto=format&amp;fit=max&amp;w=3840&amp;q=75 2x" src="https://cdn.sanity.io/images/3jwyzebk/production/eb784cfeb7ace6fe98864a9c7dfbda0d05660c7b-1840x1634.png?auto=format&amp;fit=max&amp;w=3840&amp;q=75"/><figcaption></figcaption></figure></div><p>This mindset can turn DX into an ongoing practice, not a one-time deliverable. You&#39;re no longer designing just for people, but for any client—human or machine. Building for an agent&#39;s zero prior knowledge forces explicitness and consistency, creating clarity that directly benefits human developers too.</p><h2 id="dxexcellenceisawinwin"><strong>DX excellence is a win-win</strong></h2><p>LLM-powered agents are sliding into everyday engineering—writing glue code, wiring SaaS products, even answering forum posts. As that line blurs between <em>developer</em> and <em>user agent</em>, one truth holds: great DX still rules.</p><p>If an agent chokes on vague docs or cryptic errors, real developers will get stuck in the same place. <strong>Treat each agent failure as a usability bug</strong>. It flags gaps in docs, errors, or flow design that deserve an immediate fix.</p><p>This mindset merges DX and AX. <strong>The core ingredients—clear references, consistent patterns, actionable errors—haven’t changed</strong>, but the tolerance for rough edges is gone. Use an agent as a tireless intern: run the golden path, note where it breaks, patch, repeat, until the run is boringly green.</p><p>Polish the path for agents and every human newcomer benefits. Support tickets drop, word-of-mouth rises, and the next auto-code tool looking for a showcase API might pick yours. Build for the agent, and you build for everyone.</p></div></div></div></div>
  </body>
</html>
