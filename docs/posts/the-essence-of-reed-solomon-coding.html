<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mazzo.li/posts/reed-solomon.html">Original</a>
    <h1>The essence of Reed-Solomon coding</h1>
    
    <div id="readability-page-1" class="page"><div id="wrapper">



<p>Let’s say we want to store some data on multiple drives, so that we can recover from drive failures.</p>
<div>
<p>One obvious (and valid!) first attempt is to just store everything multiple times – usually called “mirroring”. The most common form of mirroring is to store things twice: if one drive fails, the data is still in the other.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p><a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction">Reed-Solmon coding</a> gives us much more flexibility, allowing us to store our data over <span>n = k + t</span> drives, so that <em>any <span>t</span></em> drives can fail while still not losing data.<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>For instance, with <span>\mathrm{RS}(10, 4)</span> we can store data over 14 drives, and any 4 drives can fail at once, without incurring data loss. The data is split over 10 equal blocks, and then 4 additional blocks (“parity” blocks) are generated in a such a way that any 4 blocks can be recovered from the other 10.<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a><a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>The main idea behind Reed-Solomon is easy to visualize. We’ll focus on the task of durably storing <span>k</span> numbers <span>y_1, ..., y_k</span>. We’ll plot them as <span>(1, y_1), ..., (k, y_k)</span>. For instance, with <span>k = 4</span>, we might have:</p>
</div>

<p><img src="https://mazzo.li/assets/images/rs-plot-1.svg"/></p>
<div>
<p>For any distinct <span>k</span> points, there’s a <a href="https://en.wikipedia.org/wiki/Lagrange_polynomial">unique polynomial</a> of degree <span>d &lt; k</span> passing through them.<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a> This fact should not be too surprising, and is apparent when <span>k = 2</span>: given two distinct points, there’s only one line passing through them.</p>
<p>Here’s the unique third-degree polynomial passing through our four points:</p>
<p><img src="https://mazzo.li/assets/images/rs-plot-2.svg"/></p>
</div>

<p>Armed with this fact, we can pick an additional <span>t</span> points on the same polynomial. Again, with <span>k = 4</span> and <span>t = 2</span>, we would have:</p>
<p><img src="https://mazzo.li/assets/images/rs-plot-3.svg"/></p>
<p>Sampled points are in gold. Since the interpolating polynomial is unique given any <span>k</span> points it passes through, we can drop any <span>t</span> points, and we’ll still be able to recover the polynomial. Once we’ve done that, we can just resample it to recover the numbers we’re storing.</p>
<p>To recap, our procedure to durably store <span>k</span> numbers is as follows:</p>
<ul>
<li>Compute the unique polynomial of degree <span>d &lt; k</span> by placing the numbers at some predefined interval on the XY plane;</li>
<li>Sample the polynomial <span>t</span> times beyond the original points;</li>
<li>Store the <span>k</span> original numbers alongside the <span>t</span> “parity” numbers;</li>
<li>If some numbers are lost we can recompute them by resampling the polynomial.</li>
</ul>
<p>At this point, you already understand a key idea powering Reed-Solomon coding.</p>
<div>
<p>The other key idea allows us to store bits, rather than numbers. I won’t properly explain it here, but the gist of it is to use <em><a href="https://en.wikipedia.org/wiki/Finite_field">finite fields</a></em> of order <span>2^{\mathrm{bits}}</span> as our number type.<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>Such finite fields are numeric types working differently from the usual integers modulo <span>2^{\mathrm{bits}}</span> that we’re used to program with, but still easy to implement in hardware, and importantly numbers for which the considerations in this blog post about polynomials <a href="https://en.wikipedia.org/wiki/Lagrange_polynomial#Finite_fields">hold</a>.<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>Once we have such a numeric type, all we need to do to durably store some blob of data is to split it in a series of <span>2^{\mathrm{bits}}</span> numbers (each <span>\mathrm{bits}</span> wide), group them in sets of <span>k</span>, and then store them durably as described in this post, tuning <span>t</span> based on how redundant we want to be.</p>
<p>The final trick worth mentioning is that this kind of Reed-Solomon encoding can be implemented efficiently given that we have fixed the <span>x</span> coordinates, no matter what numbers we want to store. Or in other words, <a href="https://en.wikipedia.org/wiki/Lagrange_polynomial#Definition">the definition for <span>\ell_j</span> which we use to generate the unique polynomial</a> only depends on the <span>x</span> coordinates, which allows us to do the heavy lifting once for any <span>k</span> numbers we want to store.</p>
</div>







</div></div>
  </body>
</html>
