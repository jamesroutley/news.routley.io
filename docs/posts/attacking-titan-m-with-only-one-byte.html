<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.quarkslab.com/attacking-titan-m-with-only-one-byte.html">Original</a>
    <h1>Attacking Titan M with Only One Byte</h1>
    
    <div id="readability-page-1" class="page"><div>

        <!--/.well -->

        <div>
<section id="content">
<article>
<header>

</header>
<div>
  

  <p>Following our presentation at Black Hat USA, in this blog post we provide some details on CVE-2022-20233, the latest vulnerability we found on Titan M, and how we exploited it to obtain code execution on the chip.</p>

  <div id="introduction">
<h2>Introduction</h2>
<p>During the last year and a half, we (Damiano Melotti, Maxime Rossi Bellom &amp; Philippe Teuwen) studied the Titan M, a security chip introduced by Google in their Pixel smartphones, starting from the Pixel 3.
Among other events, we presented our results at <a href="https://www.youtube.com/watch?v=UNPblJup5ko">Black Hat EU 2021</a>, together with a <a href="https://github.com/quarkslab/titanm/blob/master/BHEU_2021/EU-21-Rossi_Bellom-2021_A_Titan_M_Odyssey-wp.pdf">whitepaper</a> that contains all the background knowledge we acquired in the first part of this research.
In this blog post, we dive into <a href="https://nvd.nist.gov/vuln/detail/CVE-2022-20233">CVE-2022-20233</a>, the latest vulnerability we found on the chip&#39;s firmware.
First, we show how we found this vulnerability, using emulation-based fuzzing with AFL++ in Unicorn mode.
Then, we go over the exploitation and its inherent challenges, that eventually led us to obtain code execution on the chip.</p>
</div>
<div id="background">
<h2>Background</h2>
<p>The Titan M was introduced by Google in their Pixel devices in 2018.
The main goal was to reduce the attack surface available to attackers, mitigating hardware tampering and side-channel attacks.
Indeed, the chip lies on a separate system-on-a-chip (SoC) in the device, runs its own firmware, and communicates with the Application Processor (AP) through the SPI bus.
It implements several APIs that guarantee a higher level of protection for the most security sensitive features of the smartphone, such as secure boot or a hardware-backed Keystore with <em>StrongBox</em>.</p>
<p>In the first steps of this research, we focused on reverse engineering the Titan M firmware, which is based on <a href="https://chromium.googlesource.com/chromiumos/platform/ec/">Embedded Controller (EC)</a>, a lightweight open source OS for micro-controllers.
This OS is fairly simple, and is built around the concept of <em>tasks</em>, with a fixed stack size and no heap (so no complex dynamic allocation).
This is an important point that will turn out to be useful later: the Titan M chip has essentially a static memory layout, therefore we can assume some objects to always be located at the same address.</p>
<p>The simplicity of the OS also helps when it comes to security, especially by completely eliminating some temporal memory safety bugs associated with dynamic allocation.
In addition, thanks to it&#39;s Memory Protection Unit (MPU), the chip&#39;s memory is configured such that no Write and eXecute permissions are granted to a region at the same time.
Secure boot is implemented thanks to some signature checks performed before loading the firmware.
Despite these properties, no common exploit mitigation techniques can be found on the chip, except for a hardcoded stack canary that is placed at the end of the tasks&#39; stacks to detect errors.
This leaves Titan M fairly exposed to memory corruption vulnerabilities, therefore we decided to explore how to fuzz it and look for some of them.</p>
</div>
<div id="fuzzing-titan-m">
<h2>Fuzzing Titan M</h2>
<p>As broadly known, fuzzing is an extremely effective way to find memory corruption bugs in code bases written in unsafe languages, such as C.
However, fuzzing a security chip without access to the sources, and with plenty of hardware-dependent code, can be quite a challenge.
We decided to explore two different techniques, namely black-box and emulation-based fuzzing.</p>
<div id="black-box-fuzzing">
<h3>Black-box fuzzing</h3>
<p>We have already shown how to perform black-box fuzzing in our previous presentations, but briefly going over it again is useful to understand the differences with the other approach we explored.
In general, black-box fuzzing of targets like Titan M can be quite simple: all we need is a channel to interact with what we want to test, and a way to tell if it crashes or reaches unexpected states.
In our case, in the previous steps of this research, we had developed <a href="https://github.com/quarkslab/titanm/tree/master/nugget_toolkit/">nosclient</a>, a custom client that runs natively on Android and communicates directly with the kernel driver responsible for the communication with the chip.
The possibility to send arbitrary messages gave us both the channel to communicate with Titan M, and the signal to infer what happened while processing them, represented by the return code from the library functions we use.</p>
<p>Most of the tasks communicating with Android use <a href="https://github.com/protocolbuffers/protobuf">Protobuf</a> to serialize messages.
Therefore, we could leverage this grammar, accessible thanks to the open source definitions in the <a href="https://android.googlesource.com/platform/external/nos/host/generic/+/refs/tags/android-platform-12.1.0_r1/nugget/proto/nugget/app/">AOSP</a>, to mutate these messages with <a href="https://github.com/google/libprotobuf-mutator">libprotobuf-mutator</a>.
For Nugget, one of the tasks that is not using Protobuf, we used the evergreen <a href="https://gitlab.com/akihe/radamsa/">Radamsa</a> to generate our test cases.</p>
<p>This approach did bring some interesting results, which when it comes to fuzzing, can be measured in bugs.
We could find again several bugs we already knew about, while fuzzing an older version of the firmware, including the buffer overflow we had exploited during last year&#39;s research.
Moreover, we discovered two new crashes in the latest version of the firmware at the time, although both were caused by the same null pointer dereference, that was not considered serious enough to be a vulnerability and end up in an Android Security Bulletin.</p>
<p>Despite its relatively straightforward setup, and the advantage of testing in the real world, black-box fuzzing comes with a number of shortcomings.
First of all, detection is extremely difficult, since we can only spot the bugs that cause crashes or faulty return codes.
But most importantly, a well-known limitation is that black-box fuzzing tends to only exercise the targets&#39; shallow states, given the lack of visibility over their internals.
As a consequence, we might have been only scratching the surface of the Titan M firmware, which could also explain why all the detected crashes happened after just a few minutes of fuzzing.</p>
</div>
<div id="emulation-based-fuzzing">
<h3>Emulation-based fuzzing</h3>
<p>An alternative approach that we focused on is emulation-based fuzzing.
In short, given that the firmware is publicly available, why not try to <em>emulate</em> its execution on our laptop?
Leveraging our background knowledge on how it works, coming from hours of reverse engineering, we can set up an emulation framework to run the firmware instruction by instruction, and analyze its behavior.
This is also a very good feedback for a coverage-guided fuzzer, which can prioritize inputs leading to new instructions being reached and adjust its mutator accordingly.</p>
<p>There exist a number of different ways to implement a solution like this.
We tried a few, but we ended up using the <a href="https://www.unicorn-engine.org/">Unicorn</a> emulator engine, and <a href="https://github.com/AFLplusplus/AFLplusplus/">AFL++</a> as fuzzing framework.
Unicorn is a QEMU-based project that only supports CPU emulation, without full-system emulation.
Rather than a limitation, this was an advantage in our case, since we could set up our scripts very easily, and implement some ad-hoc tweaks to improve the detection of bugs or work around some issues.
In addition, Unicorn integrates very well with AFL++, thanks to its <em>unicorn mode</em>, which essentially allows to fuzz pretty much anything that can be emulated with Unicorn.
The only step required is the definition of the <tt>place_input_callback</tt>, a function that writes inputs in the target&#39;s memory at every interaction.</p>
<p>Thanks to this, we could also test other functions in the Titan M firmware, while not forgetting about reasonable attack scenarios.
Nonetheless, after a couple of fuzzing campaigns around the SPI rescue feature that did not lead to any significant result, we decided to focus on the tasks again, replicating a similar experiment as the one we did in a black-box setting.
AFL++ allows to have custom mutators, hence we plugged libprotobuf-mutator again and emulated three tasks of the firmware separately: <tt>Keymaster</tt>, <tt>Identity</tt>, and <tt>Weaver</tt>.
We decided to ignore AVB due to the limited attack surface it exposes, with most of the interactions happening while the device is in bootloader mode.</p>
<p>First and foremost, we asked ourselves whether we could once again find the bugs we already knew about, to prove the effectiveness of this new solution.
Fortunately, the answer was positive, with the exception of one bug, which takes us to the limitations of emulation-based fuzzing.
As we all know, indeed, there is no free lunch, and also in this case, this approach brings some drawbacks.</p>
<ul>
<li>Multiple hardware-dependent functions: these parts of the code cannot be easily emulated, thus we had to hook them and inevitably reduce the coverage of our testing.</li>
<li>Still limited detection: while improving the bare black-box approach, we still can only detect bugs that cause Unicorn errors, consequently missing the various in-page overflows, off-by-ones, etc.</li>
<li>Lack of full system emulation: this choice in itself also brings the drawback of ignoring certain functions, which inevitably implies missing some bugs. That is the reason why we did not succeed in finding again the vulnerability we just mentioned above.</li>
</ul>
<p>To address the second issue, Unicorn allows to set a number of custom hooks to monitor certain memory accesses or specific fragments of code.
We did implement some heuristics to catch some patterns of bugs, like broken calls to <tt>memcpy</tt> that ended up reading from the Boot ROM (that is mapped at address <tt>0x0</tt>).
On the other hand, this comes at a cost: hooks impact performance, and there is always a trade-off between the time spent reverse engineering to identify these patterns, and the time you actually let the fuzzer run freely.</p>
</div>
</div>
<div id="the-vulnerability">
<h2>The vulnerability</h2>
<p>But now, let&#39;s get into the tasty part.
While fuzzing the Keymaster task, we discovered an interesting crash caused by a <tt>UC_ERR_WRITE_UNMAPPED</tt>, while processing an <tt>ImportKey</tt> request.
This crash was occurring in a <tt>strb</tt> instruction, meaning that the firmware was trying to write 1 byte in an unmapped memory area. Note that the vulnerable firmware was introduced by Google&#39;s Pixel security update of May 2022.</p>
<p>A simple message that triggers the vulnerability is the following:</p>
<div><pre><span></span><span>ImportKeyRequest</span>
<span>params</span> <span>{</span>
  <span>params</span> <span>{</span>
    <span>tag</span><span>:</span> <span>ALGORITHM</span>
    <span>integer</span><span>:</span> <span>4</span>
  <span>}</span>
  <span>params</span> <span>{</span>
    <span>tag</span><span>:</span> <span>DIGEST</span>
    <span>integer</span><span>:</span> <span>40706</span>
  <span>}</span>
<span>}</span>
<span>symmetric_key</span> <span>{</span>
  <span>material</span><span>:</span> <span>&#34;&lt;1h5\003H\232@\233&#34;</span>
<span>}</span>
</pre></div>
<p>As we can see from the Protobuf <a href="https://android.googlesource.com/platform/external/nos/host/generic/+/refs/tags/android-platform-12.1.0_r1/nugget/proto/nugget/app/keymaster/keymaster.proto#184">definitions</a>, <tt>ImportKey</tt> messages contain a <tt>KeyParameters</tt> field, which in turn is made of one or more <tt>KeyParameter</tt> objects.
The bug occurs while processing the <a href="https://android.googlesource.com/platform/external/nos/host/generic/+/refs/tags/android-platform-12.1.0_r1/nugget/proto/nugget/app/keymaster/keymaster_defs.proto#39">tags</a> in a key parameter: the vulnerable function loops through the list of parameters, and for each one it checks if the tag is <tt>0x20005</tt>, corresponding to <tt>DIGEST</tt>.
When such parameters are found, the function takes the associated <tt>integer</tt> field, and after some checks it uses it as an offset of a stack buffer to set a byte to 1.
By passing a large enough integer as parameter, it is possible to write out of bounds that one byte value of <tt>0x01</tt>.</p>
<p>The code snippet below, both in assembly and decompiled view, shows these checks as well as the <tt>strb</tt> instruction causing the out of bounds write and subsequent crash. At that point, <tt>r1</tt> is <tt>0x1</tt>, <tt>r7</tt> is the buffer address and <tt>r3</tt> is the integer field of the current <tt>KeyParameter</tt>.</p>
<!-- it would be *fantastic* to have these two listings side-by-side, but I have no clue of how to do it -->
<!-- also, the "asm" syntax highlighting doesn't work super well, it seems better in C -->
<div><pre><span></span><span>ldr</span><span>.</span><span>w</span>   <span>r1</span><span>,[</span><span>r2</span><span>,</span><span>#</span><span>-</span><span>0x4</span><span>]</span>
<span>ldr</span>     <span>r3</span><span>,[</span><span>PTR_DAT_0005d808</span><span>]</span> <span>;</span> <span>0x20005</span>
<span>cmp</span>     <span>r1</span><span>,</span><span>r3</span>
<span>bne</span>     <span>increment_loop_vars</span>
<span>ldr</span>     <span>r3</span><span>,[</span><span>r2</span><span>,</span><span>#</span><span>0x0</span><span>]</span>
<span>uxtb</span>    <span>r0</span><span>,</span><span>r3</span>
<span>cmp</span>     <span>r0</span><span>,</span><span>#</span><span>0x4</span>
<span>bhi</span>     <span>error_exit</span>
<span>movs</span>    <span>r1</span><span>,</span><span>#</span><span>0x1</span>
<span>lsl</span><span>.</span><span>w</span>   <span>r0</span><span>,</span><span>r1</span><span>,</span><span>r0</span>
<span>tst</span>     <span>r0</span><span>,</span><span>#</span><span>0x15</span>
<span>beq</span>     <span>error_exit</span>
<span>strb</span>    <span>r1</span><span>,[</span><span>r7</span><span>,</span><span>r3</span><span>]</span>
</pre></div>
<div><pre><span></span><span>if</span> <span>(((</span><span>nugget_app_keymaster_KeyParameter</span> <span>*</span><span>)(</span><span>offset</span> <span>+</span> <span>-</span><span>1</span><span>))</span><span>-&gt;</span><span>tag</span> <span>==</span> <span>0x20005</span><span>)</span> <span>{</span>
  <span>masked</span> <span>=</span> <span>*</span><span>offset</span> <span>&amp;</span> <span>0xff</span><span>;</span>
  <span>if</span> <span>((</span><span>4</span> <span>&lt;</span> <span>masked</span><span>)</span> <span>||</span> <span>((</span><span>1</span> <span>&lt;&lt;</span> <span>masked</span> <span>&amp;</span> <span>0x15U</span><span>)</span> <span>==</span> <span>0</span><span>))</span> <span>{</span>
    <span>return</span> <span>0x26</span><span>;</span>
  <span>}</span>
  <span>*</span><span>(</span><span>undefined</span> <span>*</span><span>)(</span><span>buffer</span> <span>+</span> <span>*</span><span>offset</span><span>)</span> <span>=</span> <span>1</span><span>;</span>
  <span>*</span><span>param_3</span> <span>=</span> <span>*</span><span>param_3</span> <span>+</span> <span>1</span><span>;</span>
  <span>*</span><span>param_4</span> <span>=</span> <span>offset</span><span>;</span>
<span>}</span>
</pre></div>
<p>The vulnerability can actually be triggered as many times as the number of parameters with a <tt>DIGEST</tt> tag, with the only limitation of remaining within the maximum size of the <tt>KeyParameters</tt> list.
This results in multiple, 1-byte, out-of-bounds writes.
Such writes are however far from arbitrary, due to the checks on the offset.
Without entering into details of the bit-wise operations, the least significant byte can only be <tt>0x0</tt>, <tt>0x2</tt> or <tt>0x4</tt>.</p>
<p>At this point, it may seem that this is a very minor and hardly exploitable issue.
However, do not forget that Titan M&#39;s memory is completely static, as we mentioned earlier.
In addition, the bug can be reached by different code paths, considering the various messages that contain a <tt>KeyParameters</tt> field.
Provided that we can write at the right place, there are plenty of different things that can be done by setting a single byte to 1, from a simple DoS to altering a <em>size</em> variable somewhere in memory and causing a corruption elsewhere.</p>
</div>
<div id="exploitation">
<h2>Exploitation</h2>
<p>At this point, we wrote a small script to generate and highlight all the possible writable addresses in Ghidra.
Then we started searching for interesting targets, and as it turned out, triggering the vulnerability just <em>once</em> was enough to compromise the chip.</p>
<div id="what-to-overwrite">
<h3>What to overwrite</h3>
<p>During our tests, we understood that we could get to the vulnerable code with <tt>r1</tt> containing <tt>0x14019</tt>.
After applying a <tt>0xa204</tt> offset to this (note that the least significant byte allows to pass the checks), we could reach <tt>0x1e21d</tt>.
This address is part of a structure that we called <tt>KEYMASTER_SPI_DATA</tt>, containing information about the exchange of Keymaster messages with Android.
In particular, we can overwrite one byte of the memory location pointing to where incoming requests for the Keymaster task are stored: by default this is <tt>0x192c8</tt>, but if we write <tt>0x1</tt> to <tt>0x1e21d</tt>, the value becomes <tt>0x101c8</tt>.
As a result, the following Keymaster requests would be stored quite far from where they are supposed to be, with catastrophic consequences for the Titan M.</p>
</div>
<div id="the-uart-console">
<h3>The UART console</h3>
<p>Before diving into the tale of how we exploited this vulnerability, let us take a moment to refresh how we can actually interact with the chip.
The only tool we use is our <em>nosclient</em>, which allows us to forge arbitrary messages and send them directly to the driver.
After sending a request, Titan M replies with a return code, and a response, which is empty in case of errors.
With only this information available, developing any exploit is particularly challenging: not only we do not have access to any debugger capability, but we also cannot see any stack traces nor immediate side-effects of an attack.</p>
<p>This is where the UART console exposed by the chip becomes extremely handy.
There are two ways of accessing it, and both of them present different challenges.
The first way relies on a special debugging cable called <em>SuzyQable</em>.
This is officially mentioned as the cable to debug <a href="https://chromium.googlesource.com/chromiumos/third_party/hdctools/+/HEAD/docs/ccd.md">Chrome OS microcontrollers</a>, and since Titan M is based on the same operating system, it actually turns out to also work with it.
To activate it, we only need to boot the Pixel smartphone in fastboot mode, and use the command <tt>fastboot oem citadel suzyq on</tt>.
Then, when connecting the device using the <em>SuzyQable</em>, we can access the UART console as a <tt>tty</tt> interface on our laptop.
In parallel, the cable also allows to communicate with the device through <tt>adb</tt>.
Unfortunately though, as soon as the chip crashes or even after a <tt>reboot</tt> command is sent over this console, the channel is closed and the interface needs to be activated again going back to fastboot mode.
This is very impractical, which is the reason why we went with the second way.</p>
<p>The second solution can be seen as the <em>MacGyver</em> one.
The Titan M exposes the UART pins on the motherboard, so all we needed to do was solder two wires and obtain the very same shell as the one we could get with the cable.
In this case, the console never closes and stays active no matter what happens to the device or the chip.</p>
<p><img alt="A picture of the UART pins on the Pixel 3 motherboard" src="https://blog.quarkslab.com/resources/2022-08-11_titan-m/uart.png"/></p><p>The Titan M console is extremely basic and allows simple interactions with the chip, to investigate statistics, versions, and similar things.
Most importantly though, it is the place where debugging logs are printed.
Indeed, going back to exploit development, this clearly does not provide any information on what goes wrong when something does not work, but it is still very useful: for example, we could always try to jump to a function that prints something and verify that our exploit is working fine up to that point.</p>
</div>
<div id="hijacking-execution-flow">
<h3>Hijacking execution flow</h3>
<p>As we said, thanks to the out of bounds write, we changed the address where incoming Keymaster requests were stored.
This location is still in the memory space of the chip, thus an incoming message would end up overwriting other data in the Titan M&#39;s memory.
For this reason, we tried sending larger and larger commands, monitoring the UART logs.
After a bit of testing, we realized that if we placed a valid code address after <tt>556</tt> bytes of payload, we could jump to such an address, practically redirecting execution to a function of our choice.
We were able to detect that thanks to some logs being printed in the UART console.</p>
<p><img alt="A gif showing the growing messages until we detect a crash." src="https://blog.quarkslab.com/resources/2022-08-11_titan-m/payload.gif"/></p><p>We suppose that this portion of memory was being used by some task (probably <tt>idle</tt>), which may have pushed a return address to its stack, that was now overwritten.
At this point, we knew we could jump to an arbitrary function.
How can we translate that into an actual exploit?</p>
</div>
<div id="return-oriented-programming">
<h3>Return Oriented Programming</h3>
<p>Given the memory protections in place, we cannot write our own shellcode and jump to it, as writable memory is not executable.
Instead, we can rely on a code-reuse attack, and mount an exploit based on Return Oriented Programming.
The objective was to build a read-anywhere primitive: this way, we could leak the secrets Titan M is protecting with a crafted command from <em>nosclient</em>.</p>
<p>Unfortunately, we could not write our ROP chain exactly where we wrote our first gadget, because it would corrupt some memory that would make the chip crash before our exploit would be complete.
Consequently, the first challenge was to <em>pivot</em> the stack.
Ideally, we wanted to decrease the stack pointer: assuming the stack to be moving towards larger addresses, we wanted to rely on the payload we could place in those 556 bytes, which we knew we could set as we wanted without causing any nasty side-effect.
We found only one gadget to do so, which however also does a few more things:</p>
<div><pre><span></span><span>sub</span> <span>sp</span><span>,</span> <span>#</span><span>0x20</span><span>;</span> <span>mov</span> <span>r4</span><span>,</span> <span>r0</span><span>;</span> <span>ldr</span> <span>r3</span><span>,</span> <span>[</span><span>r0</span><span>];</span> <span>add</span><span>.</span><span>w</span> <span>r5</span><span>,</span> <span>r4</span><span>,</span> <span>#</span><span>0x70</span><span>;</span> <span>ldr</span> <span>r3</span><span>,</span> <span>[</span><span>r3</span><span>,</span> <span>#</span><span>8</span><span>];</span> <span>blx</span> <span>r3</span><span>;</span>
</pre></div>
<p>Despite that, we wrote a ROP chain that would call it several times, while making sure that <tt>r0</tt> was pointing to a memory area we also controlled, and where we wrote some gadgets to make the <tt>ldr</tt> and <tt>blx</tt> instructions work as we wanted.
In the picture below, we graphically show this approach for the first iterations (it is actually done several more times).
The red arrows follow the execution flow, and the blue ones the stack pointer.
Note that the scale is not respected.</p>
<p><img alt="The first stage of the exploit: climbing up on the stack" src="https://blog.quarkslab.com/resources/2022-08-11_titan-m/exploit_1.png"/></p><p>After having <em>climbed up</em> the stack a few times, we could proceed with the actual attack.
The only way we could return our leaked bytes back to Android was to copy them in the response of an SPI command.
For this to happen, we needed to be in the context of the command handler, which is called taking its address from memory after parsing the command code.
We could therefore overwrite its address, but how should we set it?
As replacing the actual code was impossible, all we could do was to make it jump into some memory area that we could also control, and write there more gadgets for our ROP chain.
This is done in the space we created in the first step, making sure to ignore the slots we used in the previous ROP chain (basically assigning them to registers that we do not use).</p>
<p>This step was probably the most challenging one, as it entails finding the right gadget to make the stack pivot to a memory area that remains under our control when the handler is triggered.
Unfortunately again, no such gadget existed, so we had to be creative.
The way we solved this was quite tricky: by emulating the execution of the Keymaster <em>DestroyAttestationIds</em> command handler, we understood that there was one single 32-bit slot in its stack that was not overwritten by some previous functions in the call chain.
Therefore, we wrote one single gadget there, that would act as a trampoline to actually move the stack far enough from the Keymaster stack and reach an area where our payload would be preserved.</p>
<p><img alt="The final stage of the exploit: executing the overwritten handler and jumping to the final ROP chain" src="https://blog.quarkslab.com/resources/2022-08-11_titan-m/exploit_2.png"/></p><p>Wrapping up so far, the exploit goes as follows:</p>
<ol>
<li>move up on the stack from where we get code execution;</li>
<li>once we have enough space, execute a ROP chain that:<ul>
<li>replaces the Keymaster <em>DestroyAttestationIds</em> command handler with one gadget, popping some registers from the stack;</li>
<li>writes <em>one</em> gadget on the Keymaster stack, that ends up being executed when the handler is triggered, and moves the stack pointer enough to reach an area where what we write will not be tampered with by the normal execution of the firmware;</li>
<li>copies the final ROP chain to such an area.</li>
</ul>
</li>
</ol>
<p>Once we got here, finishing the exploit was relatively straightforward, as we controlled execution from the handler context.
We called <tt>memcpy</tt> with the user-provided arguments, to copy what we wanted to read in the Keymaster SPI response buffer.
We then jumped back to the Keymaster stack, like the normal command handler would have done.</p>
</div>
</div>
<div id="impact">
<h2>Impact</h2>
<p>Thanks to the leak functionality that we built with this exploit, we can now read arbitrary memory on the chip.
This means we can now have access to any readable address.
As a consequence, we can dump the secrets stored in the chip (such as the Root of Trust sent by the Pixel bootloader when the Titan M is updated).
Moreover, we can access the Boot ROM, that was not previously available.
This is possible despite the slightly customized version of <tt>memcpy</tt> present in the chip, which checks if the <tt>src</tt> or <tt>dst</tt> buffers equal <tt>0x0</tt>.
In fact, instead of jumping directly to the entry point of the function, we skip those checks and jump directly to the basic block where the copying happens.</p>
<p>One of the most interesting consequences of this attack is the ability to retrieve any StrongBox protected key, defeating the highest level of protection of the Android Keystore.
Similarly to what happens in TrustZone, these keys can only be used inside Titan M, while they are stored in an encrypted <em>key blob</em> on the device.</p>
<p>The procedure is the following:</p>
<ul>
<li>read a key blob from the Android OS (from any application);</li>
<li>send a valid, well-formed <em>BeginOperation</em> request, containing such a key blob:<ul>
<li>the handler for this command decrypts the key and stores it into a specific memory address. This prepares the chip to perform the requested operation;</li>
</ul>
</li>
<li>run the exploit and leak the memory where the plaintext key is now stored.</li>
</ul>
<p>To demonstrate the effectiveness of this attack we also developed a dummy application that simply creates a StrongBox-protected AES key and encrypts a string with it.
With our exploit and the approach explained above, we can leak the corresponding key from the Titan M, and by re-using the same initialization vector we can successfully decrypt the string offline (or rather &#34;off phone&#34;).</p>
<video id="demo" controls="" width="100%" muted="true">
  <source src="resources/2022-08-11_titan-m/demo.mp4" type="video/mp4"/>
  <p>Sorry, your web browser doesn&#39;t support embedded videos.</p>
</video><p>As a reminder, there are two conditions to perform this attack.
First, we need to be able to send commands to the chip, either from a <em>rooted</em> device (required to use <em>nosclient</em>), or physically accessing the SPI bus.</p>
<p>Then, we need a way to access the key blobs on the Android file system, which can be done again by being root, or with some exploit to bypass File Based Encryption or the <em>uid</em> access control.</p>
</div>
<div id="mitigations">
<h2>Mitigations</h2>
<p>We reported this vulnerability to Google, and of course the best mitigation is the patch provided in the June security bulletin.
However, we do want to point out an interesting feature that would have made the <em>StrongBox</em> key blob leak impossible.
Indeed, an application can create a key that is <em>authentication-bound</em>, specifying <tt>setUserAuthenticationRequired(true)</tt> when building it with <tt>KeyGenParameterSpec</tt>.
This way, users need to authenticate before using the key and the key blob is encrypted a second time using a special key derived from the user password that we do not have.</p>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>The Titan M chip is the most secure component of Google&#39;s Pixel phones and the anchor to which all the security of the device is ultimately linked. Despite good architectural decisions and many efforts made to minimize its attack surface, making exploitation of vulnerabilities very hard, and the lack of appropriate tools to debug the chip, in our project we managed to:</p>
<ul>
<li>Reverse engineer the communications between Android and the chip.</li>
<li>Develop <em>nosclient</em>, an open source tool that lets a researcher send arbitrary commands to the chip.</li>
<li>Discover vulnerabilities using black box fuzzing.</li>
<li>Emulate the chip and discover a vulnerability using emulation-based fuzzing.</li>
<li>Leverage some implementation weaknesses and exploit the vulnerability to achieve code execution on the chip and exfiltrate sensitive data (cryptographic keys) that should never leave it.</li>
</ul>
<p>The vulnerability was reported to Google in May 2022 and a fix was released in the Pixel Security update of June 2022.</p>
</div>
<div id="disclosure-timeline">
<h2>Disclosure timeline</h2>
<p>To provide transparency of our vulnerability disclosure process and illustrate the complexity of coordinating the reporting, triaging, and fixing bugs in embedded software, a detailed timeline of all relevant events of the reporting process is provided below.</p>
<ul>
<li><strong>2022-03-02</strong>: Vulnerability reported. Opened <a href="https://issuetracker.google.com/issues/222318108">issue 222318108</a> in Google&#39;s Issue Tracker, providing a technical description of the bug and a Proof of Concept (PoC) exploit using Quarkslab&#39;s <a href="https://github.com/quarkslab/titanm/">nosclient tool</a>.</li>
<li><strong>2022-03-02</strong>: Google&#39;s Android Security Team (AST) acknowledged the report and asked for a PoC program.</li>
<li><strong>2022-03-07</strong>: Quarkslab provided a standalone copy of the <em>nosclient</em> code repository with the PoC.</li>
<li><strong>2022-03-08</strong>: AST asked for some more obvious way to reproduce the bug, such as triggering a crash with a callstack, demonstrable code execution, or some way to observe memory corruption with a debugger. Asked for a PoC for a more recent version of the firmware.</li>
<li><strong>2022-03-10</strong>: Quarkslab replied that it does not have tools for debugging the Titan M chip. However, with the precise description of the bug that was included in the report, it should be possible to identify it in the source code.</li>
<li><strong>2022-03-15</strong>: Quarkslab sent a new version of <em>nosclient</em> that adds a functionality to write the one byte value <tt>0x01</tt> to any memory address (with the constraints shown above) using the bug, which should make it possible for AST to observe memory corruption using a debugger.</li>
<li><strong>2022-03-16</strong>: Google AST was able to run the PoC and reviewed the source code of the mentioned functions and other code paths, but did not see any out of bounds write as reported. They stated they were unable to find or reproduce the security issue. Nonetheless they passed the report to the Titan M engineering team for further investigation.</li>
<li><strong>2022-03-16</strong>: Quarkslab asked which version of the firmware was used for testing and if that version is publicly available.</li>
<li><strong>2022-03-18</strong>: Google AST indicated they used the firmware build of the March OTA for Pixel 5/Redfin devices, which is public. Also said that they would continue the investigation to try to find the issue.</li>
<li><strong>2022-03-20</strong>: Quarkslab informed Google AST that it managed to achieve code execution on the chip on a Pixel 3 phone with the firmware version that Google used for testing. The PoC demonstrates gaining control of execution flow and redirecting it to an internal firmware function (<tt>task_print_list</tt>) that prints the list of tasks to the logs, which can be observed by attaching to the UART console. The exploit&#39;s source code, a description of how it works, and sample log output was provided.</li>
<li><strong>2022-03-30</strong>: Google AST asked clarification about how Quarkslab retrieved the UART logs.</li>
<li><strong>2022-03-31</strong>: Quarkslab indicated that engineers had soldered wires to the chip&#39;s UART points in the PCB. They also mentioned the alternative of the special <em>SuzyQable</em>, which should be available to Google.</li>
<li><strong>2022-03-31</strong>: Google replied saying they would continue investigating the issue.</li>
<li><strong>2022-04-18</strong>: Quarkslab asked for a status update.</li>
<li><strong>2022-04-18</strong>: Google indicated that they were waiting for the necessary hardware to investigate the issue, and would communicate as soon as there is an update.</li>
<li><strong>2022-04-27</strong>: Quarkslab informed Google that a presentation about the Titan M vulnerability research project was accepted at the TROOPERS conference in Germany to be held at the end of June, 2022.</li>
<li><strong>2022-04-29</strong>: Google told Quarkslab that they identified the vulnerability and a potential fix, proposing a conference call to discuss the status.</li>
<li><strong>2022-05-04</strong>: Conference call between Quarkslab engineers, Google Android Security Team members, and a Titan engineering team member. Google indicated that they planned to release a fix in June. Quarkslab recalled that the TROOPERS conference was coming up, and another talk had been submitted to Black Hat USA, acceptance pending. They also offered to continue investigating ways to exploit the vulnerability in a way that would be easier to reproduce and verify. Google appreciated Quarkslab&#39;s feedback on the disclosure process so far and said they would follow up on the necessity for a different exploit.</li>
<li><strong>2022-05-27</strong>: Google notified the imminent release of a fix in the June 2022 Pixel update and asked Quarkslab to confirm the acknowledgments information. Google assigned <strong>CVE-2022-20233</strong> to the vulnerability.</li>
<li><strong>2022-06-05</strong>: Google published the June 2022 Pixel update with fixes for CVE-2022-20233 (Severity: Critical) and 4 other vulnerabilities (3 ranked High severity, 1 Moderate) in the Titan M component.</li>
<li><strong>2022-06-07</strong>: Google informed Quarkslab that they had assigned the vulnerability a reward of 10,000 USD per its Android Security Rewards program.</li>
<li><strong>2022-06-08</strong>: Quarkslab thanked Google for the reward and asked what criteria were used to assign it, given that the public information about Android&#39;s bug bounty states that the top possible reward for a code execution bug in Titan M is 1 million USD, two orders of magnitude higher than the assigned one.</li>
<li><strong>2022-06-10</strong>: Google replied that the bug was fixed and released in the June Pixel Update Bulletin and that with regards to the payment amount each report is reviewed individually for reward by a committee, and that while it is possible to receive an award up to the amounts listed on the publicly stated bounty program website, based on severity and impact to the Android ecosystem, this particular report was only eligible for 10,000 USD.</li>
<li><strong>2022-06-10</strong>: Quarkslab thanked Google for the response but stated that it actually did not include an answer to the question about the criteria used to assign the reward, and asked in case another vulnerability was to be reported in the future, how would a reporter get it considered for the top range advertised in the program.</li>
<li><strong>2022-06-17</strong>: Google replied that they would do an internal review and provide an update soon.</li>
<li><strong>2022-06-20</strong>:  Quarkslab sent Google a new exploit that demonstrates code execution on the chip and exfiltration of encryption keys from it. A detailed description of the exploitation technique, the exploit&#39;s source code, and a video showing its use to exfiltrate a StrongBox-protected AES key were provided.</li>
<li><strong>2022-06-21</strong>: Google acknowledged the new submission and said they would review it.</li>
<li><strong>2022-06-24</strong>: Google asked for the source code of the sample Android application used in the demo video.</li>
<li><strong>2022-06-29</strong>: Quarkslab sent the source code of the sample Android app, a description of how it works, and an explanation of how it is exploited using the reported vulnerability.</li>
<li><strong>2022-06-30</strong>: Quarkslab&#39;s engineers Damiano Melotti and Maxime Rossi Bellom presented their Titan M vulnerability research project at the TROOPERS conference.</li>
<li><strong>2022-07-18</strong>: Google notified Quarkslab that the reward was increased to 75,000 USD.</li>
<li><strong>2022-08-11</strong>: Quarkslab&#39;s engineers Damiano Melotti and Maxime Rossi Bellom presented their Titan M vulnerability research project at the Black Hat USA Briefings in Las Vegas.</li>
</ul>
</div>

</div><!-- /.entry-content -->

                </article>
                </section>
        </div><!--/span-->

      </div></div>
  </body>
</html>
