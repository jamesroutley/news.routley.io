<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://milescole.dev/data-engineering/2024/12/12/Should-You-Ditch-Spark-DuckDB-Polars.html">Original</a>
    <h1>Should you ditch Spark for DuckDB or Polars?</h1>
    
    <div id="readability-page-1" class="page"><article>
    <header id="main">
        
    </header>

    <section>
    
            <p>There’s been a lot of excitement lately about single-machine compute engines like DuckDB and Polars. With the recent release of pure Python Notebooks in Microsoft Fabric, the excitement about these lightweight native engines has risen to a new high. Out with Spark and in with the new and cool animal-themed engines— is it time to finally migrate your small and medium workloads off of Spark?</p>

<p>Before writing this blog post, honestly, I couldn’t have answered with anything besides a gut feeling largely based on having a confirmation bias towards Spark. With recent folks in the community posting their own benchmarks highlighting the power of these lightweight engines, I felt it was finally time to pull up my sleeves and explore whether or not I should abandon everything I know and become a DuckDB and/or Polars convert.</p>



<p>While performance can be the most important driver in selecting an engine, the reality is that performance alone does not make a technology worthy of a spot in your architecture landscape. In this analysis, I’ve chosen to build a benchmark suite that aims to evaluate the following based on real-world-type test cases:</p>

<ul>
  <li><strong>Performance</strong></li>
  <li><strong>Execution Cost</strong></li>
  <li><strong>Development Cost</strong></li>
  <li><strong>Engine Maturity and Compatibility</strong></li>
</ul>

<h2 id="the-test-cases">The Test Cases</h2>

<p>If I can find any complaint with benchmarks that people post, it’s that they don’t always reflect real-world use cases. The recent <a href="https://fabric.guru/delta-lake-tables-for-optimal-direct-lake-performance-in-fabric-python-notebook">blog</a> by my colleague Sandeep Pawar is fantastic, as it highlights how optimizing row group sizes can allow single-machine engines to approach V-Order-like performance. In terms of the Spark comparison, as I shared with Sandeep, the use of the <code>LIMIT</code> operator in his benchmark resulted in Spark running a <em>CollectLimit</em> operation, which forces all data on worker nodes to be collected and then filtered at the driver level. This resulted in unnecessary data movement from workers to the driver as well as a single-threaded write operation, which constrained the possible parallelism and performance. While using <code>LIMIT</code> to interactively return a small result set to the console is a real-world use case, returning 50M rows to the console OR using the <code>LIMIT</code> operation in typical ELT processes (i.e., building a fact table) is not. Therefore, it doesn’t make sense to draw serious conclusions about Spark based on this test.</p>

<p>For my test cases, I aimed to comprehensively cover the basic ELT use cases in a Lakehouse architecture, evaluated at both the 10GB and 100GB levels based on a sampling of TPC-DS tables generated via the <a href="https://github.com/databricks/spark-sql-perf">Databricks DS-DGEN-based library</a> (the largest was the <em>store_sales</em> table):</p>

<ol>
  <li>
    <p><strong>Read Parquet, Write Delta (5x)</strong>: I’ve selected five tables from the TPC-DS schema. This test simply measures the time to read the source Parquet data and write a Delta table for each of the five tables.</p>
  </li>
  <li>
    <p><strong>Create Fact Table</strong>: This test measures the time to create a fact table based on the aggregation of data from the five source TPC-DS tables. A simple <code>CREATE TABLE AS SELECT</code> operation is run.</p>
  </li>
  <li>
    <p><strong>Merge 0.1% into Fact Table (3x)</strong>: This test measures the time to take a 0.1% sampling of records from the core transaction source table, join them with dimension tables, randomize values, and then merge them into the target fact table created in the prior step. This is run three times to simulate having multiple incremental loads.</p>
  </li>
  <li>
    <p><strong>VACUUM (0 Hours)</strong>: This measures the time to clean up old Parquet files that are no longer in the latest Delta commit. I ran with 0 hours of history retained (not recommended for production workloads) so that it would clean up the maximum number of files.</p>
  </li>
  <li>
    <p><strong>OPTIMIZE</strong>: Nothing fancy about this, just the time to perform compaction.</p>
  </li>
  <li>
    <p><strong>Ad-hoc Query (Small Result Aggregation)</strong>: The time to perform a simple aggregated <code>SELECT</code> statement that returns a small result set. This imitates the type of ad-hoc query that would be run interactively and displayed for analysis.</p>
  </li>
</ol>

<p>Based on my experience consulting where I built many Lakehouse architectures, these are the types of operations that would be generally representative of end-to-end data engineering work. No APIs or semi-structured data to make things too complex—just the typical operations that would result if you had Parquet files being delivered as a starting place and the goal was to build a dimensional model to support reporting and ad-hoc queries.</p>

<h2 id="compute-configurations">Compute Configurations</h2>

<p>I elected to use the smallest possible compute size for each respective engine for both the 10GB and 100GB benchmarks. For DuckDB and Polars, using Python Notebooks, this was the default 2-vCore VM size. For Spark, the smallest possible compute size is a Single-Node 4-vCore Spark cluster (one single Small node VM). While the starting node size for Spark is 2x bigger, Fabric Single-Node clusters allocate 50% of cores to the driver, meaning the Spark job effectively only has 2 vCores available for typical Spark tasks.</p>

<ul>
  <li>The 10GB benchmark was run on 2, 4, and 8-vCore machines (all single-node configurations for Spark).</li>
  <li>The 100GB benchmark was run on 2, 4, 8, 16, and 32-vCore compute configurations:
    <ul>
      <li>For Spark, I used single-node configurations for 4 and 8-vCores.</li>
      <li>For 16-vCores, I used a cluster with three 4-vCore worker nodes (4 driver vCores + 12 worker vCores).</li>
      <li>For 32-vCores, I used a cluster with three 8-vCore worker nodes (8 driver vCores + 24 worker vCores).</li>
    </ul>
  </li>
</ul>

<p>For Spark, I used the Native Execution Engine (NEE), as this is a native C++ vectorized engine that makes vanilla Spark faster. There’s no additional CU rate multiplier, so there’s no reason not to use it, particularly when trying to optimize for both cost and performance.</p>

<h3 id="delta-lake-writer-configs">Delta Lake Writer Configs</h3>

<p>I used the best practice Delta Lake writer configs available in each engine.</p>

<ul>
  <li>For the Spark tests, I enabled deletion vectors. See my <a href="https://milescole.dev/data-engineering/2024/11/04/Deletion-Vectors.html">blog</a> on this topic to understand their value.</li>
  <li>For both DuckDB and Polars, since they depend on the Rust-based <a href="https://delta-io.github.io/delta-rs/">DeltaLake Python library</a>, which does not support deletion vectors, this setting could not be enabled. However, at this small scale, deletion vectors only have a marginal impact on performance, so this does not skew the results in any meaningful way.</li>
</ul>

<blockquote>
  <p>The Native Execution Engine (NEE) doesn’t yet natively support deletion vectors. When DVs are included, it results in mixed execution query plans with fallback to Spark row-based execution. Depending on the workload, DVs can still improve performance where merge-on-read results in less data being written. In this benchmark, DVs resulted in NEE completing ~3% faster.</p>
</blockquote>

<h3 id="polars-benchmark-sampling-mod">Polars Benchmark Sampling Mod</h3>

<p>After running the benchmark with Polars and getting OOM errors below 16-vCores, I identified that Polars does not support lazy evaluation for data sampling. This meant that to run the <em>Merge 0.1% into Fact Table (3x)</em> test, Polars needed to read the entire source Delta table into memory and then take an in-memory sampling of data. Spark and DuckDB, on the other hand, are able to sample directly on top of the source data, eliminating the need to load the entire table into memory.</p>

<p>Since sampling a large table as the source for an incremental load is not something you’d typically see in production and was only used for data generation purposes, I decided to run a second version of the benchmark for Polars. This version, labeled as <strong>Polars (Mod)</strong>, uses DuckDB to perform the more efficient sampling operation (<code>sampled_table = duckdb.sql(&#34;SELECT * FROM delta_scan(&#39;abfss://...&#39;) USING SAMPLE 0.1%&#34;).record_batch()</code>) before processing the data further with Polars.</p>



<h2 id="performance">Performance</h2>

<h3 id="10gb-scale">10GB Scale</h3>
<ul>
  <li>At 2-vCores, <em>Polars (Mod)</em> was the fastest engine, followed by DuckDB, and then Polars without the benchmark modification.</li>
  <li>At 4-vCores, DuckDB takes the win followed by Polars and lastly Spark. DuckDB was ~1.6x faster than Spark w/ NEE.</li>
  <li>At 8-vCores, DuckDB finishes only slightly faster than Spark w/ NEE. Both Polars scenarios come last.</li>
</ul>

<p><img src="https://milescole.dev/assets/img/posts/Engine-Benchmark/10g_results2.png" alt="10GB Results"/></p>

<h3 id="100gb-scale">100GB Scale</h3>
<ul>
  <li>No engine completed the benchmark with only 2-vCores (Fabric doesn’t offer a 2-vCore node size for Spark so this wasn’t tested).</li>
  <li>DuckDB was the fastest engine when using 4-vCores, taking a slight edge over Spark w/ NEE.</li>
  <li>Spark w/ NEE was fastest at 8, 16, and 32-vCores.</li>
  <li>Polars ran into out-of-memory (OOM) and wasn’t able to finish tests at 4 or 8 vCores. Polars was much slower than DuckDB and Spark at 16 and 32-vCores.</li>
</ul>

<p><img src="https://milescole.dev/assets/img/posts/Engine-Benchmark/100g_results2.png" alt="100GB Results"/></p>

<p>Note: In all of these tests, Spark has access to fewer total vCores for data processing work yet was able to keep up and even exceed the others.</p>

<h3 id="which-phases-did-different-engines-excel-at">Which Phases Did Different Engines Excel At?</h3>

<ol>
  <li><strong>Read Parquet, Write Delta (5x)</strong>
    <ul>
      <li><em>10GB:</em> While Polars took the win at 2-vCores, DuckDB had an edge at 4-vCores.</li>
      <li><em>100GB:</em> Spark was over 2x faster than both DuckDB and Polars.</li>
    </ul>
  </li>
  <li><strong>Create Fact Table</strong>
    <ul>
      <li><em>10GB:</em> DuckDB was ~2x faster than every other engine, with the other engines performing very similarly.</li>
      <li><em>100GB:</em> DuckDB and Spark w/ NEE tied, with both Polars variants running almost 6x longer.</li>
    </ul>
  </li>
  <li><strong>Merge 0.1% into Fact Table (3x)</strong>
    <ul>
      <li><em>10GB:</em> <em>Polars (Mod)</em> was the fastest at 4-vCores, with the other engines closely clustered.</li>
      <li><em>100GB:</em> Spark w/ NEE was ~2x faster than DuckDB and significantly faster than both Polars variants.</li>
    </ul>
  </li>
  <li><strong>VACUUM (0 Hours)</strong>
    <ul>
      <li>Neither DuckDB nor Polars have a native <code>VACUUM</code> command; however, the DeltaLake Python library based on Delta-rs was significantly faster than the native <code>VACUUM</code> command in Spark.</li>
    </ul>
  </li>
  <li><strong>OPTIMIZE</strong>
    <ul>
      <li>Same as <code>VACUUM</code>, neither DuckDB nor Polars have a native <code>OPTIMIZE</code> command, but the Delta-rs-based library again was significantly faster than the native <code>OPTIMIZE</code> command in Spark.</li>
    </ul>
  </li>
  <li><strong>Ad-hoc Query (Small Result Aggregation)</strong>
    <ul>
      <li>As expected, this is where engines like DuckDB and Polars provide mind-blowing, super-low-latency performance. Depending on the scale, DuckDB and Polars were between 2-6x faster than Spark w/ NEE.</li>
    </ul>
  </li>
</ol>

<h4 id="10gb-results--4-vcores">10GB Results @ 4-vCores</h4>
<p><img src="https://milescole.dev/assets/img/posts/Engine-Benchmark/10g_phase_results2.png" alt="10GB Phase Results"/></p>

<h4 id="100gb-results--16-vcores">100GB Results @ 16-vCores</h4>
<p><img src="https://milescole.dev/assets/img/posts/Engine-Benchmark/100g_phase_results2.png" alt="100GB Phase Results"/></p>

<hr/>
<p>Since the performance difference for <code>VACUUM</code>, <code>OPTIMIZE</code>, and <em>Ad-hoc/Interactive Queries</em> tends to be overshadowed by longer-running ELT processes, here’s an isolated view of the 10GB 4-vCore benchmark highlighting how much faster DuckDB and Polars (with Delta-rs) are for these workloads.</p>

<p><img src="https://milescole.dev/assets/img/posts/Engine-Benchmark/10g_phase_result_isolation2.png" alt="10GB Phase Isolation"/></p>

<hr/>

<h2 id="execution-cost">Execution Cost</h2>

<p>Since I logged the vCores used for each run, translating to CU seconds and then the approximate dollar cost for the job was straightforward. Now that I’ve established that vanilla Spark can compete, going forward I will highlight results comparing Spark w/ NEE and deletion vectors enabled compared to DuckDB and Polars.</p>

<h3 id="10gb-cost">10GB Cost</h3>
<ul>
  <li>Both DuckDB and <em>Polars (Mod)</em> were about 50% cheaper compared to Spark.</li>
  <li>With 8-vCores, Spark w/ NEE and DuckDB have very close job costs ($0.019 vs $0.017).</li>
</ul>

<p><img src="https://milescole.dev/assets/img/posts/Engine-Benchmark/10g_cost_results2.png" alt="10GB Cost Results"/></p>

<h3 id="100gb-cost">100GB Cost</h3>

<ul>
  <li>With 4-vCores, the <strong>DuckDB and Spark jobs cost the same at ~ $0.08</strong>.</li>
  <li>With 8-vCores, the cost of the Spark job is unchanged ($0.08) but we were able to cut ~10 minutes off the processing time. Spark was the cheapest.</li>
  <li>As the allocated cores increase, the relative performance gain for Spark is much higher compared to DuckDB and Polars:
    <ul>
      <li><em>Spark</em>: <strong>Compared to the 4-vCore run, Spark w/ 32-vCores was 4.5x faster while the job only costs 2x more.</strong></li>
      <li><em>DuckDB</em>: Compared to the 4-vCore run, DuckDB w/ 32-vCores was only 2.4x faster while the job costs 3.5x more.</li>
      <li><em>Polars</em>: Compared to the 16-vCore run, Polars w/ 32-vCores was only ~1.1x faster while costing ~1.9x more.</li>
    </ul>
  </li>
</ul>

<p><img src="https://milescole.dev/assets/img/posts/Engine-Benchmark/100g_cost_results2.png" alt="100GB Cost Results"/></p>

<hr/>

<h2 id="development-cost">Development Cost</h2>

<p>Selecting a compute engine isn’t just about raw performance—it’s also about how easily and quickly developers can implement solutions. In this evaluation, I focused on two key aspects of development agility: features that impact implementation time and the real-world experience of implementing this benchmark. While the feature evaluation is relatively objective, the implementation evaluation is based on my experience and prior background, making it subjective.</p>

<h3 id="key-features-impacting-development-cost">Key Features Impacting Development Cost</h3>

<table>
  <thead>
    <tr>
      <th><strong>Engine</strong></th>
      <th>SQL</th>
      <th>DataFrame API</th>
      <th>Native Delta Reader</th>
      <th>Native Delta Writer</th>
      <th>Local Development</th>
      <th>Live Monitoring Capabilities</th>
      <th>OneLake Auth Setup</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Spark</strong></td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Poor</td>
      <td>Good but w/ a steep learning curve</td>
      <td>Excellent</td>
    </tr>
    <tr>
      <td><strong>DuckDB</strong></td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Great</td>
      <td>Poor</td>
      <td>Ok</td>
    </tr>
    <tr>
      <td><strong>Polars</strong></td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Great</td>
      <td>Very Poor</td>
      <td>Partial</td>
    </tr>
  </tbody>
</table>

<h4 id="my-analysis">My Analysis</h4>
<ul>
  <li>
    <p><strong>SQL and DataFrame API</strong>: While you can use a DataFrame abstraction library like Ibis or SQLFrame, Spark is the only engine I benchmarked that natively supports both SQL and a DataFrame API. Having both presents tremendous flexibility in building data engineering pipelines. Most Spark developers I know heavily use both the SparkSQL and the DataFrame API.</p>
  </li>
  <li><strong>Native Delta Writer</strong>:
    <ul>
      <li><em>DuckDB</em> only supports writing to Delta tables by converting DuckDB DataFrames to another memory format and then using the DeltaLake Python library to perform the write operation. This should be natively supported in time, but today this experience of needing to convert DataFrames and use another writer was quite surprising and took some time to figure out the most optimal way to do it. I first started by converting DuckDB DataFrames to Arrow Tables via <code>arrow()</code> and ran into OOM issues below 16-vCore. Mim then jumped in and helped me understand that I should be using <code>record_batch()</code> to make this a streaming Arrow DataFrame so that the data gets processed in batches and doesn’t require the full dataset to fit into memory.</li>
      <li><em>Polars</em> supports a native Delta Lake writer through Delta-rs.</li>
      <li>Since both DuckDB and Polars are dependent on the Delta-rs-based DeltaLake Python library for full-featured writes, both are limited by features that have yet to be implemented in Delta-rs, namely deletion vectors. This feature request was reported almost two years ago and is still <a href="https://github.com/delta-io/delta-rs/issues/1094">open</a>. Since deletion vectors are not supported, this means that while DuckDB can read from DV-enabled tables, since both DuckDB and Polars are dependent on Delta-rs, neither can write to such tables. See my post on <a href="https://milescole.dev/data-engineering/2024/11/04/Deletion-Vectors.html">deletion vectors</a> to understand the importance of merge-on-read.</li>
    </ul>
  </li>
  <li>
    <p><strong>Local Development</strong>: DuckDB and Polars both win in the ‘local development’ category as the engines are super lightweight and can be run on a local computer with a simple PIP command. Spark is more complex, as it’s not possible to run the Fabric Spark Runtime locally. Therefore, you must connect remotely to a Fabric Spark cluster in VS Code (local or web) to get Fabric Spark-specific features. This experience is getting better every day but is not nearly as simple as running the actual engine locally.</p>
  </li>
  <li>
    <p><strong>Live Monitoring Capabilities</strong>: When doing development and you run something, you often might need to check to see what is actually happening. With Spark, you can look in the Spark UI or Fabric UI surfaced telemetry. It’s not perfect by any means, and the learning curve is steep, but once you have the basics figured out, it’s easy enough to check what is running, triage where something might be stuck, or evaluate live running query plans. With DuckDB, there’s a nice <em>tqdm</em>-style progress bar, while with Polars, you’re left to guess what might be going on and when your job might be done.</p>
  </li>
  <li><strong>OneLake Auth Setup</strong>: <em>Note, this is not a critique of the engine itself; this is an evaluation of how natively the engine is integrated to authenticate to OneLake (or ADLS) in Fabric.</em>
    <ul>
      <li><em>Spark</em>: Easy—you don’t do anything; it just works.</li>
      <li><em>DuckDB</em>: In hopes of avoiding more complex auth methods, I tried to get token authentication to work. I was blocked on this for a few hours until my colleague Mim Djouallah (he has some great <a href="https://datamonkeysite.com">blogs</a> on DuckDB) saved the day and noted that I needed to upgrade to DuckDB version 1.1.3 to use this newer auth method. Once I got this one line of code, everything seamlessly works.</li>
      <li><em>Polars</em>: At first, I couldn’t get any Polars authentication to work, then Sandeep Pawar showed me that <code>scan_delta()</code> works with ABFSS paths without needing to specify auth (since it gets a token from env vars). ABFSS does not currently work with <code>scan_parquet()</code>, <code>read_parquet()</code>, and other similar methods. David Browne, however, pointed out that while ABFSS does not work for all methods, relative file paths do work: <code>/lakehouse/default/Files</code> since it interacts with the OneLake directory via a mount point instead of directly making ABFSS endpoint calls. I got everything working eventually, but this was frustrating to say the least.</li>
    </ul>
  </li>
</ul>

<h3 id="implementation-cost-comparison">Implementation Cost Comparison</h3>

<table>
  <thead>
    <tr>
      <th><strong>Engine</strong></th>
      <th>Learning Curve</th>
      <th>Implementation Speed / Workflow Integration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Spark</strong></td>
      <td>Medium</td>
      <td>Excellent</td>
    </tr>
    <tr>
      <td><strong>DuckDB</strong></td>
      <td>Medium</td>
      <td>Ok</td>
    </tr>
    <tr>
      <td><strong>Polars</strong></td>
      <td>High</td>
      <td>Ok</td>
    </tr>
  </tbody>
</table>

<h4 id="my-analysis-1">My Analysis</h4>

<ul>
  <li>
    <p><strong>Learning Curve</strong></p>

    <ul>
      <li>
        <p><strong><em>Spark</em></strong>: For myself, and I think for most people as well, learning distributed computing concepts that are critical to being successful with Spark is not a simple task. But once you get the basics, Spark is so mature that it can be hard to get too stuck. Plus, Spark supports SparkSQL, which is one of the best SQL dialects there is.</p>
      </li>
      <li><strong><em>DuckDB</em></strong>: I was quite surprised how long it took me to get going with DuckDB. I couldn’t figure out how to authenticate to OneLake until Mim told me I had to update DuckDB to the latest version (1.1.3). Once I was authenticated, I was challenged by how far from straightforward it was to take my PySpark code and refactor it as DuckDB. Beyond the below challenges I stumbled through, DuckDB is almost all SQL, and thus very easy to navigate once you get going:
        <ul>
          <li>No support for natively writing to Delta tables. This includes inserts, running optimize or vacuum. You can only write to Delta tables by converting your DuckDB DataFrame to an Arrow DataFrame and then using the <a href="https://delta-io.github.io/delta-rs/usage/appending-overwriting-delta-lake-table/#delta-lake-append-transactions">Delta-rs Python library</a> to do the actual write to Delta.</li>
          <li>No support for natively reading from Hive Meta Store. You can use <code>delta_scan()</code> or register Delta tables as views. Not hard once you understand this.</li>
          <li>I originally used the <code>arrow()</code> method to convert DuckDB DataFrames to Arrow Tables prior to writing to Delta and experienced OOM issues. Mim thankfully showed me that the <code>record_batch()</code> method should be used instead so that the data is streamed into Arrow format in batches. Quite a cool feature as this allows you to run on very constrained compute and prevent OOM. That said, this was not intuitive and I have yet to find the documentation on this specific method. Is there a reason why you’d use <code>arrow()</code> over <code>record_batch()</code>? I have no idea at this point, but it seems like <code>record_batch()</code> makes more sense to prevent OOM.</li>
        </ul>
      </li>
      <li><strong><em>Polars</em></strong>: Polars is a DataFrame API-centric engine, which is good news for those already comfortable with the Spark DataFrame API. That said, Polars adds additional (and possibly unnecessary?) complexity through the nuance of being able to control the evaluation model based on what methods you use. For example, <code>read_parquet()</code> is an eager evaluation method, while <code>scan_parquet()</code> is lazily evaluated. Calling the native <code>write_delta()</code> method to save data to a Delta table will throw an error if you chain it on top of a lazy-evaluated step, so you need to run <code>collect()</code> first before running <code>write_delta()</code> (but why can’t it just automatically do that???). Oh, and if you want to have the data be streamed for batch processing so that you can process data that is larger than your VM memory, you need to specify <code>collect(streaming=True)</code>. I can see this level of control being fantastic if you live and breathe Polars, but this makes the learning curve pretty steep.</li>
    </ul>
  </li>
  <li>
    <p><strong>Workflow Integration / Implementation Speed</strong>: I’d define this category as how well the engine works to fit into a typical data engineering workflow. How well is it integrated into the platform? How do features of the engine impact how fast you can get work done, and do the features work with typical data engineering patterns? How complete is the engine itself, or does it feel more like a bolt-on capability?</p>
    <ul>
      <li><strong><em>Spark</em></strong>: I live and breathe Spark, so the actual implementation was fast for me. For the average user, I’d still suggest it can be pretty fast since things like auth, evaluation, and both reader and writer capabilities are extremely robust. Spark is a standalone, full-featured data processing engine. AL/ML, Graph, structured, semi-structured—Spark can do it all at any data size.</li>
      <li><strong><em>DuckDB</em></strong>: Ok. Could I swap some DuckDB into normal workflows? Certainly. Would I take additional time to refactor things since DuckDB doesn’t natively support Hive Meta Store and in-memory database concepts are fundamentally different? Yes. The necessity to pass DataFrames from DuckDB to the DeltaLake Writer and so forth is not hard when you get used to it, but the user experience of having to do this isn’t great and does impact the time to implement solutions.</li>
      <li><strong><em>Polars</em></strong>: Ok. The positive here is that Polars offers a native Delta Lake writer method built on Delta-rs, which provides full-featured writes (including a merge operator), and authentication for OneLake was out-of-the-box—<em>for Delta tables</em>. The downside is that Polars offers no SQL dialect, so you are stuck with learning a new DataFrame API and learning the nuances of having tasks evaluated with potentially both eager and lazy evaluation in the same DataFrame. This adds additional work to figure out the most optimal way to code things. That said, like DuckDB, Polars is blazing fast for querying Delta tables, and this is a big positive. I was about to give Polars an <em>OK+</em> rating but will leave off the plus since I could never get Polars to complete the tests below 16-vCores, even after successfully swapping in DuckDB for the data sampling and unsuccessfully trying to improve write performance for the large table by messing with write batch sizes.</li>
    </ul>
  </li>
</ul>

<p>I’d easily give Spark the win in this category.</p>

<h2 id="engine-maturity-and-oss-table-format-compatibility">Engine Maturity and OSS Table Format Compatibility</h2>

<p>As mentioned, the Delta-rs library which Polars is dependent on for reading Delta (DuckDB uses the Delta Kernel) and both Polars and DuckDB are dependent on for writing to Delta does not support deletion vectors. Deletion vectors are a general best practice setting for Delta tables. If you want to use Polars or DuckDB to write to Delta tables, you need to weigh the impact of not being able to use deletion vectors and potentially other newer Delta features. If your data is super small, this likely doesn’t matter, but as your data size increases, the potential impact also increases.</p>

<p>In terms of engine maturity, Polars and DuckDB are both relatively new. In contrast, Spark has been around for over a decade, and we are now approaching GA of the 4th major release. Spark performance continues to improve, Spark capabilities are continuing to expand, and Spark is going nowhere. Just consider some of the upcoming Spark 4.0 features:</p>

<ul>
  <li>Stored Procedures</li>
  <li>SQL scripting constructs</li>
  <li>Data Source APIs (create your own spark.read class extension)</li>
  <li>Improved error logging</li>
  <li>Variant data types</li>
  <li>Collation support</li>
  <li>Structured logging</li>
</ul>

<p>…and so much more. All I’m trying to point out is that the Spark community is taking real action on pretty much everything that Spark doesn’t excel at or doesn’t support. In terms of performance, both Fabric and Databricks provide native C++ engines within Spark that allow Spark jobs to run much faster than natively possible with vanilla OSS Spark. Spark is here to stay and continues to improve, so get used to it. :)</p>

<p>New doesn’t mean bad, just that you should be cautious about APIs or syntax changes and that the engine is not going to be as full-featured as an engine like Spark that has been around for over a decade.</p>



<ul>
  <li>
    <p><strong>Future data growth</strong>: Avoid needing to refactor all code because your data went from small to medium and now you need to rewrite your code as PySpark. If you have small data today and a non-Spark engine only runs 2x faster, I would still use Spark simply so that I don’t have to migrate once my data gets large, as well as to take advantage of the more robust engine capabilities.</p>
  </li>
  <li>
    <p><strong>Skillset of team</strong>: Spark is synonymous with data processing. Tons of people know Python, more know basic SQL, but Spark supports both and since it’s been around longer, more people will have this experience. That said, I highly encourage people to learn additional languages, frameworks, and engines, so don’t rule out using DuckDB or Polars because of a potential skillset gap—just be aware there might be some time needed for cross-skilling.</p>
  </li>
  <li>
    <p><strong>Performance</strong>: To summarize my performance analysis, Spark can be just as fast, and even faster, for typical data engineering tasks. DuckDB and Polars can be much faster than Spark for lightweight exploration tasks and maintenance operations.</p>
  </li>
  <li>
    <p><strong>Cost</strong>: In my benchmark, Spark was as cheap as DuckDB and cheaper than all engines as the allocated vCores scaled. The only two tests where Spark was not the cheapest was the 10GB 2 and 4-vCore benchmarks. Remember that the cost of an engine goes beyond the direct invoice you get from your cloud provider—you should consider the cost of time to learn, the cost for your team to upskill and refactor code, and the cost of longer development cycles through the engine not being as tightly integrated as you’d like.</p>
  </li>
</ul>



<p>Ok, I’ve done the benchmark, but where would I actually use each engine now that I’ve done some basic testing and can confidently say that I’m less ignorant when it comes to single-machine engines?</p>

<p>If I were to optimize for performance, cost, and engine maturity/compatibility, I would do the following (<em>with exceptions</em>):</p>

<h2 id="primary-spark-use-cases">Primary Spark Use Cases</h2>

<p>Any and all “data processing.” Think E.L.T., the steps to extract, load, and transform your data in the Lakehouse architecture.</p>

<h2 id="primary-duckdb-use-cases">Primary DuckDB Use Cases</h2>

<ul>
  <li>Interactive and ad-hoc queries</li>
  <li>Data exploration</li>
</ul>

<h2 id="primary-polars-use-cases">Primary Polars Use Cases</h2>

<p>Honestly, with DuckDB generally outperforming Polars, with zero tuning effort, and providing a rich SQL surface area, I probably wouldn’t use Polars unless there was something that DuckDB didn’t support and was significantly faster than Spark.</p>

<h2 id="primary-deltalake-python-library-use-cases">Primary DeltaLake Python Library Use Cases</h2>

<p>I added this category since all of the <code>VACUUM</code> and <code>OPTIMIZE</code> operations in my benchmark for Polars and DuckDB technically were just using the DeltaLake Python library. Using a pure Python Notebook, I would use the DeltaLake library for:</p>

<ul>
  <li>Maintenance operations: Maintenance operations on this library were significantly faster compared to Spark. While you could use this library on a Spark cluster, there’s no need to have your worker nodes sit idle while you run lightweight jobs that only run on the driver node. Rather than running <code>VACUUM</code> and <code>OPTIMIZE</code> (where the table can fit into VM memory), I would split these maintenance jobs into a Python notebook (2-vCore for <code>VACUUM</code>) and have these jobs complete much faster, all while consuming much less compute.</li>
</ul>

<p>Here’s a quick visual to summarize where I think each engine makes sense for most Lakehouse architecture use cases.</p>

<p><img src="https://milescole.dev/assets/img/posts/Engine-Benchmark/engine-map.excalidraw.png" alt="alt text"/></p>



<ol>
  <li><strong>Migrating off of Spark is all hype</strong>: I think the whole narrative that you should consider replacing your Spark workloads with DuckDB or Polars if your data is small is all hype. Yes, the engines have certainly earned their place at the table, however Spark is still reigns king for data processing any way you look at it. Sure, DuckDB and Polars can marginally outperform Spark at data processing at the 10GB scale on a 4-vCore (or smaller machine). I think the real story here is this:
    <ul>
      <li><strong>Each engine does something really well, so why not strategically mix and match them</strong> to take advantage of where each truly shines. Use Spark for ELT work, use the Rust-based DeltaLake Library on Python for maintenance operations, and use DuckDB for interactive queries on your small datasets.</li>
    </ul>
  </li>
  <li>
    <p><strong>I now have tremendous respect for Polars and DuckDB</strong>: While I prefer developing with Spark because I can move between SparkSQL and the DataFrame API as needed (without needing an abstraction library like Ibis), DuckDB’s implementation of an in-memory SQL engine is extremely powerful and could have many use cases, particularly if you don’t readily have access to use a Spark cluster.</p>
  </li>
  <li>
    <p><strong>Performance with Spark more consistently scales as compute scales</strong>: I was extremely surprised to find that the performance of DuckDB and Polars was barely impacted by throwing more cores and memory at the benchmark. I’m sure there’s some magic that could be worked to tune things and get more efficient compute utilization as cores are increased, but this just isn’t something you often need to consider with Spark.</p>
  </li>
  <li>
    <p><strong>Memory spill matters!</strong>: While you want to avoid it, by default, Spark can spill memory to disk if needed, making it resilient to out-of-memory (OOM) issues. With DuckDB and Polars, I ran into OOM issues (100GB @ 2-vCore for DuckDB and 2, 4, and 8-vCore for Polars), and neither engine supports memory spilling to disk to prevent the memory exhaustion causing the VM to crash. While memory spill causes Spark to run slower when it happens, it at least greatly reduces the risk of job failures and allows flexibility in compute sizing.</p>
  </li>
  <li>
    <p><strong>Distributed computing has compute overhead for task orchestration, but this adds fault tolerance</strong>: When DuckDB and Polars VMs crashed due to OOM, that was it—no automatic restart or ability to resume from where it left off. The same would happen with single-node Spark clusters. However, with multi-node Spark clusters (which most production workloads use), fault tolerance is built in. If a worker node crashes for any reason, the driver node maintains the task lineage and processing state so another VM can replace the worker and resume from where the crashed VM left off, without data loss. This may lead to some in-process transformations being reprocessed, but the engine guarantees that data writes are only performed once. See my blog on <a href="https://milescole.dev/data-engineering/2024/10/10/RDDs-vs-DataFrames.html">RDDs vs. DataFrames</a> for more details.</p>
  </li>
  <li><strong>Consider your specific workload</strong>: I designed my benchmark to reflect the typical lakehouse architecture that I see. Given that Spark has the biggest advantage for ELT-type data processing, if your use case involves infrequent small data loads (e.g., monthly), primarily interactive querying, or the necessity for an embedded in-memory database engine, DuckDB could be a great fit—especially for small data volumes.</li>
</ol>

<p><em>Lastly, this is just another benchmark—do your own testing.</em></p>

    
    </section>

    <!-- Social media shares -->
    






    <!-- Tag list -->
    
    


  



</article></div>
  </body>
</html>
