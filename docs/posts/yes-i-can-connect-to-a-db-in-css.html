<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.leemeichin.com/posts/yes-i-can-connect-to-a-db-in-css.html">Original</a>
    <h1>Yes, I can connect to a DB in CSS</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<header>

</header><p>
As they&#39;re wont to do, a certain tweet was floating around the interwebs for a while the other week.
</p>


<figure id="orgf67eea0">
<img src="https://www.leemeichin.com/img/yes-i-can-connect-to-a-db-in-css/tweet.jpg" alt="tweet.jpg"/>

</figure>

<blockquote>
<p>
Recruiters be like:
</p>

<p>
We&#39;re looking for someone who can connect to the database using CSS.
</p>
</blockquote>

<p>
It&#39;s been a hell of a long time since I last embarked on a quality shitpost project<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup>, in fact it&#39;s been so long that back then I probably didn&#39;t even have the word <i>shitpost</i> in my vocabulary.
</p>

<p>
To that end, I was partially inspired by an earlier shitpost project based on a blockchain startup&#39;s projection of their investors&#39; faces onto 3D cubes.<sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup> Reminds me of the old days of the internet when everything was just <i>weird</i>.
</p>

<p>
I&#39;m not looking to write a recipe here so I&#39;ll spare you the life story. Instead, I&#39;m going to talk about how I managed my own new shitpost project: sqlcss.xyz<sup><a id="fnr.3" href="#fn.3" role="doc-backlink">3</a></sup>
</p>


<figure id="org5db6a38">
<img src="https://www.leemeichin.com/img/yes-i-can-connect-to-a-db-in-css/example.png" alt="example.png"/>

</figure>

<p>
As the name might suggest, this is how you connect to a database using CSS. It only works in Chrome, unfortunately, but you can provide any SQLite database you like and query it via CSS.
</p>

<p>
How does it work?
</p>

<p>
-—
</p>

<p>
A new set of APIs affectionately known as Houdini<sup><a id="fnr.4" href="#fn.4" role="doc-backlink">4</a></sup> give your browser the power to control CSS via its own Object Model in Javascript. In English, this means that you can make custom CSS styles, add custom properties, and so on.
</p>

<p>
Possibly the biggest feature to come out of this work is the CSS Paint Worklet<sup><a id="fnr.5" href="#fn.5" role="doc-backlink">5</a></sup>, which allows you to &#39;paint&#39; on an element, not unlike the Canvas you know and love, and have the browser treat it as an image in CSS. There are some examples to play with at houdini.how<sup><a id="fnr.6" href="#fn.6" role="doc-backlink">6</a></sup>.
</p>

<p>
However, this worklet provides only a subset of the Worker API, and the canvas context itself is also heavily stripped down. The practical result of this is that your custom CSS painting code provides a smaller sandbox than you might have expected.
</p>

<p>
What does that mean? You have no network access, so you can kiss <code>fetch</code> and <code>XmlHttpRequest</code> goodbye. You have no <code>drawText</code> functionality on the paint context. Various other JS APIs have also vanished, just in case you were hoping to work around some of those issues.
</p>

<p>
No need to worry, though. All is not lost. Let&#39;s break this down into steps.
</p>

<p>
—
</p>

<div id="outline-container-orgf738517">
<h2 id="orgf738517">1. Setting up the database</h2>
<div id="text-orgf738517">
<p>
This has to be the first step, to understand if a proof of concept is even possible.
</p>

<p>
There&#39;s a library called <code>sql.js</code><sup><a id="fnr.7" href="#fn.7" role="doc-backlink">7</a></sup>. It&#39;s quite literally a version of SQLite compiled into WebAssembly and old-skool ASM.js via emscripten. We can&#39;t use the WASM version unfortunately, because it has to fetch a binary over the network. The ASM version doesn&#39;t have this limitation though as all of the code is available in a single module.
</p>

<p>
While the PaintWorklet restricts network access inside the worker, you are still allow to <code>import</code> code as long as it&#39;s an ES6 Module. That means the file has to have an <code>export</code> statement somewhere inside it. Unfortunately, sql.js doesn&#39;t have an ES6 only build so I modified the script myself to make this work.
</p>

<p>
Now for the moment of truth: can I set up a database inside my worklet?
</p>

<div>
<pre><span>const</span> <span>SQL</span> = <span>await</span> initSqlJs({
  locateFile: file =&gt; <span>`./${file}`</span>,
});

<span>const</span> <span>DB</span> = <span>new</span> <span>SQL.Database</span>();
</pre>
</div>

<p>
Success! No errors. But no data either, so let&#39;s fix that.
</p>
</div>
</div>

<div id="outline-container-org3b05ec1">
<h2 id="org3b05ec1">2. Querying the database</h2>
<div id="text-org3b05ec1">
<p>
Easiest thing to do at the start is set up some fake data. Sql.js has a couple of functions to do precisely that.
</p>

<div>
<pre>DB.run(<span>&#39;CREATE TABLE test (name TEXT NOT NULL)&#39;</span>)
DB.run(
  <span>&#39;INSERT INTO test VALUES (?), (?), (?), (?)&#39;</span>,
  [<span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>, <span>&#39;D&#39;</span>]
)
</pre>
</div>

<p>
I&#39;ve got my test table with some values in it now. I should be able to query this and get those values back, although I&#39;m not sure how the result will be structured.
</p>

<div>
<pre><span>const</span> <span>result</span> = DB.exec(<span>&#39;SELECT * FROM test&#39;</span>)
console.log(result)
</pre>
</div>

<p>
Results are there, as expected. It would be nice to actually render this result though.
</p>
</div>
</div>

<div id="outline-container-org1be19ea">
<h2 id="org1be19ea">3. Rendering the results, the easy way</h2>
<div id="text-org1be19ea">
<p>
I assumed this would be just like writing text to a canvas. How hard can that be, right?
</p>

<div>
<pre><span>class</span> SqlDB {
  <span>async</span> paint(ctx, geom, properties) {
    <span>const</span> <span>result</span> = DB.exec(<span>&#39;SELECT * FROM test&#39;</span>);
    ctx.font = <span>&#39;32px monospace&#39;</span>;
    ctx.drawText(JSON.stringify(result), 0, 0, geom.width);
  }
}
</pre>
</div>

<p>
Nah, that would have been too simple. The context here isn&#39;t the same as the context you can get for a canvas element, it only provides a subset of functionality.
</p>

<p>
It can still draw paths and curves, of course, so the lack of a convenient API is an impediment but not a dealbreaker.
</p>
</div>
</div>

<div id="outline-container-org18a168d">
<h2 id="org18a168d">4. Creating text without a text API</h2>
<div id="text-org18a168d">
<p>
Luckily, a library called opentype.js<sup><a id="fnr.8" href="#fn.8" role="doc-backlink">8</a></sup> offers hope of a solution. It can parse a font file and then, given a string of text, generate the letterforms of each character. The practical result of this operation is a path object that represents the string, which can then rendered into my context.
</p>

<p>
I don&#39;t have to modify the opentype library to import it this time, as it&#39;s already available from JSPM<sup><a id="fnr.9" href="#fn.9" role="doc-backlink">9</a></sup>. If you give JSPM an npm package, it&#39;ll autogenerate an ES6 module that you can import directly into your browser. This is fantastic because I really didn&#39;t want to have to fuck around with a bundling tool for the sake of a joke project.
</p>


<div>
<pre><span>import</span> opentype from <span>&#39;https://ga.jspm.io/npm:opentype.js@1.3.4/dist/opentype.module.js&#39;</span>

opentype.load(<span>&#39;fonts/firasans.otf&#39;</span>)
</pre>
</div>

<p>
One problem here though - it wants to load a font over the network and I can&#39;t do that! Gah, foiled again!
</p>

<p>
…Or am I? It also has a <code>parse</code> method that accepts an array buffer. I&#39;ll just base64 encode the font then and decode it in my module.
</p>

<div>
<pre><span>import</span> opentype from <span>&#39;https://ga.jspm.io/npm:opentype.js@1.3.4/dist/opentype.module.js&#39;</span>
<span>import</span> base64 from <span>&#39;https://ga.jspm.io/npm:base64-js@1.5.1/index.js&#39;</span>

<span>const</span> <span>font</span> = <span>&#39;T1RUTwAKAIAAAwA ... 3 days later ... wAYABkAGgAbABwAIAKM&#39;</span>

<span>export</span> <span>default</span> opentype.parse(base64.toByteArray(font).buffer)
</pre>
</div>

<p>
Did I tell you that the worklet doesn&#39;t have the APIs for handling base64 strings either? Not even <code>atob</code> and <code>btoa</code>? I had to find a plain JS implementation for that, too.
</p>

<p>
I put this code in its own file because it&#39;s not very…ergonomic…to have to work around a 200kb string of encoded font alongside the rest of the code.
</p>

<p>
And that&#39;s how I abused an ES module to load my font.
</p>
</div>
</div>

<div id="outline-container-org4d985df">
<h2 id="org4d985df">5. Rendering the results, the <i>other</i> easy way</h2>
<div id="text-org4d985df">
<p>
The opentype library does all the heavy lifting from now on, so all I need to do is a little mathemology to align things nicely.
</p>

<div>
<pre><span>import</span> font from <span>&#39;./font.js&#39;</span>

<span>const</span> <span>SQL</span> = <span>await</span> initSqlJs({
  locateFile: file =&gt; <span>`./${file}`</span>,
});

<span>const</span> <span>DB</span> = <span>new</span> <span>SQL.Database</span>();

DB.run(<span>&#39;CREATE TABLE test (name TEXT NOT NULL)&#39;</span>)
DB.run(
  <span>&#39;INSERT INTO test VALUES (?), (?), (?), (?)&#39;</span>,
  [<span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>, <span>&#39;D&#39;</span>]
)

<span>class</span> SqlDB {
  <span>async</span> paint(ctx, geom, properties) {
    <span>const</span> <span>query</span> = DB.exec(<span>&#39;SELECT * FROM test&#39;</span>)
    <span>const</span> <span>result</span> = query[0].values.join(<span>&#39;, &#39;</span>)

    <span>const</span> <span>size</span> = 48
    <span>const</span> <span>width</span> = font.getAdvanceWidth(queryResults, size)
    <span>const</span> <span>point</span> = {
      x: (geom.width / 2) - (width / 2),
      y: geom.height / 2
    }

    <span>const</span> <span>path</span> = font.getPath(result, point.x, point.y, size)
    path.draw(ctx)
  }
}

registerPaint(<span>&#39;sql-db&#39;</span>, SqlDb)
</pre>
</div>

<p>
Better had do some HTML and CSS to see what&#39;s happening.
</p>

<div>
<pre>&lt;<span>html</span>&gt;
  &lt;<span>head</span>&gt;
    &lt;<span>script</span>&gt;
      CSS.paintWorklet.addModule(&#39;./cssdb.js&#39;)
    &lt;/<span>script</span>&gt;
    &lt;<span>style</span>&gt;
      main {
        width: 100vw;
        height: 100vh;
        background: paint(sql-db);
      }
    &lt;/<span>style</span>&gt;
  &lt;/<span>head</span>&gt;
  &lt;<span>body</span>&gt;
    &lt;<span>main</span>&gt;&lt;/<span>main</span>&gt;
  &lt;/<span>body</span>&gt;
&lt;/<span>html</span>&gt;
</pre>
</div>

<p>
It works, but there&#39;s not enough CSS here and the query is hardcoded.
</p>
</div>
</div>

<div id="outline-container-org98af374">
<h2 id="org98af374">6. Querying via CSS</h2>
<div id="text-org98af374">
<p>
It would be better if you had to use CSS to query the database. In fact, that&#39;s the only way we can communicate with the paint worker from outside of its context as there is no messaging API like with normal workers.
</p>

<p>
For this, a custom CSS property is required. Defining <code>inputProperties</code> has the benefit of subscribing to changes to that property, so this will re-render if the value of that property ever changes. No need to set up any listeners ourselves.
</p>

<div>
<pre><span>class</span> SqlDb {
  <span>static</span> get inputProperties() {
    <span>return</span> [
      <span>&#39;--sql-query&#39;</span>,
    ]
  }

  <span>async</span> paint(ctx, geom, properties) {
    
    <span>const</span> <span>query</span> = DB.exec(String(properties.get(<span>&#39;--sql-query&#39;</span>)))
  }
}
</pre>
</div>

<p>
Those CSS properties are known as typed properties, but they&#39;re essentially boxed up in a special <code>CSSProperty</code> class that isn&#39;t very useful by itself. So you have to manually convert it to a string or a number or some such to use it, as above.
</p>

<p>
Just a quick tweak to the CSS now.
</p>

<div>
<pre><span>main </span>{
  // ...
  <span>--sql-query</span>: SELECT name FROM test;
}
</pre>
</div>

<p>
Quotes are deliberately omitted here because otherwise I would have to remove them from the string before passing it to the database. That said, this works well!
</p>

<p>
<b>Mission Accomplished!</b>
</p>

<hr/>

<p>
If you&#39;ve played with sqlcss.xyz already you will have noticed that I didn&#39;t settle for that. After a bit of refactoring, a couple more changes were made.
</p>
</div>
</div>

<div id="outline-container-orgc7aaabb">
<h2 id="orgc7aaabb">7. BYODB</h2>
<div id="text-orgc7aaabb">
<p>
Hard-coding a database schema and, well, actual data, kinda sucks. It proves the concept but surely we can do better than that.
</p>

<p>
It would be cool if you could query whatever database you liked, so long as you had the database file handy. I would just have to read that file and base64 encode it, like I did with the font file.
</p>

<div>
<pre><span>const</span> <span>fileInput</span> = document.getElementById(<span>&#39;db-file&#39;</span>)
fileInput.onchange = () =&gt; {
  <span>const</span> <span>reader</span> = <span>new</span> <span>FileReader</span>()
  reader.readAsDataURL(fileInput.files[0])

  reader.onload = () =&gt; {
    document.documentElement.style.setProperty(
        <span>&#39;--sql-database&#39;</span>,
        <span>`url(&#39;${reader.result}&#39;)`</span>
    )
  }
}
</pre>
</div>

<p>
I made an extra CSS property for that, where you can provide your SQLite database as a base64-encoded data URI. The data URI is basically just for show and to make sure it&#39;s valid for the DOM; I&#39;ll parse that stuff out on the worker side.
</p>

<p>
The last step is to make it easier to query, because otherwise you have to go into your debugger to manipulate the CSS on an element.
</p>
</div>
</div>

<div id="outline-container-org9150531">
<h2 id="org9150531">8. Write your own queries</h2>
<div id="text-org9150531">
<p>
This is possibly the least complicated part of the project. The custom property has a bit of an issue with semicolons, and SQLite doesn&#39;t care if the trailing semicolon is omitted, so the easiest thing to do is delete it if it&#39;s found in the input.
</p>

<div>
<pre><span>const</span> <span>queryInput</span> = document.getElementById(<span>&#39;db-query&#39;</span>)
queryInput.onchange = () =&gt; {
  <span>let</span> <span>query</span> = queryInput.value;
  <span>if</span> (query.endsWith(<span>&#39;;&#39;</span>)) {
    query = query.slice(0, -1)
  }

    document.documentElement.style.setProperty(
    <span>&#39;--sql-query&#39;</span>,
    queryInput.value
  )
}
</pre>
</div>

<p>
Now you can use CSS to import and browse your own database!
</p>

<hr/>

<p>
One thing I left out from all of this is how to nicely render the results when there are a lot of them and they need to be split up onto separate lines. That&#39;s not really related to connecting to a database via CSS so I decided it wasn&#39;t worth it, but the code is all available on git if you want to take this ridiculous concept even further.<sup><a id="fnr.10" href="#fn.10" role="doc-backlink">10</a></sup>
</p>
</div>
</div>
</div></div>
  </body>
</html>
