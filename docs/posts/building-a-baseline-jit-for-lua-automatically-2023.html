<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sillycross.github.io/2023/05/12/2023-05-12/">Original</a>
    <h1>Building a baseline JIT for Lua automatically (2023)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      
        <blockquote>
<p><text>This is the Part 2 of a series. Feel free to read the prequel for more context: <a href="https://brian.abelson.live/2022/11/22/2022-11-22/">Building the fastest Lua interpreter automatically</a></text></p>
</blockquote>
<p>Building a good VM for a dynamic language takes a ton of engineering. The best-performing VMs (e.g., <a href="https://github.com/WebKit/WebKit/tree/main/Source/JavaScriptCore" target="_blank" rel="noopener">JavaScriptCore</a>, <a href="https://v8.dev/" target="_blank" rel="noopener">V8</a>, <a href="https://firefox-source-docs.mozilla.org/js/index.html" target="_blank" rel="noopener">SpiderMonkey</a>) employ at least 3 VM tiers (interpreter, baseline JIT and optimizing JIT), and pervasively use hand-coded assembly in every VM tier. Optimizations such as inline caching and type speculation are required to get high performance, but they require high expertise and introduce additional engineering complexity.</p>
<!--The best interpreters are hand-coded in assembly. The baseline JIT compiler[^1] is more assembly, plus an assembler to assemble them to machine code at runtime. The optimizing JIT compiler is even more assembly among other things[^2]. -->
<!--### Deegen: High Performance VMs at Low Engineering Cost-->
<p><em>Deegen</em> is my research meta-compiler to make high-performance VMs easier to write. Deegen takes in a semantic description of the VM bytecodes in C++, and use it as the single source of truth to <em>automatically generate</em> a high-performance VM at build time, as illustrated below.</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/deegen-arch.png" alt="Deegen: automatically generating a high-performance VM!"/></p>
<p>In <a href="https://sillycross.github.io/2022/11/22/2022-11-22/">a prior post</a>, we used Deegen to automatically generate the fastest Lua 5.1 interpreter to date, outperforming LuaJIT’s interpreter by an average of 34% across a variety of Lua benchmarks. The VM was named <a href="https://github.com/luajit-remake/luajit-remake" target="_blank" rel="noopener"><em>LuaJIT Remake</em></a>, even though it had no JIT tiers at that time.</p>
<p>Today, after months of additional work, <a href="https://github.com/luajit-remake/luajit-remake" target="_blank" rel="noopener"><em>LuaJIT Remake</em></a> is finally a JIT-capable VM. It is now equipped with a state-of-the-art baseline JIT compiler, also automatically generated by Deegen. The baseline JIT features:</p>
<ul>
<li>Extremely fast compilation speed.</li>
<li>High-quality machine code (under the design constraints of a baseline JIT).</li>
<li>Automatic call inline caching (IC) with two modes (direct/closure call).</li>
<li>Automatic generic inline caching (IC) <a href="https://brian.abelson.live/2022/11/22/2022-11-22/#deegen_generic_inline_caching_api">driven by Deegen API</a>.</li>
<li>Self-modifying-code-based IC implementation for best performance.</li>
<li>Hot-cold-splitted JIT code for less branches and better code locality.</li>
</ul>
<p>It is important to note that the baseline JIT is generated from the <em>same</em> bytecode semantic description that Deegen uses to generate the interpreter. Therefore, for a language implementer, the baseline JIT comes <em>for free</em>:</p>
<ul>
<li>No need to have any assembly knowledge.</li>
<li>No need to manually engineer the JIT.</li>
<li>No need to manually keep the JIT updated with new language features.</li>
</ul>
<p>Because Deegen does all the work automatically!</p>
<p>Of course, this is no easy feat. In order to generate the baseline JIT automatically, a sophiscated build-time pipeline is employed, as illustrated below.</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/deegen-jit-pipeline.png" alt="The pipeline that automatically generates the baseline JIT from bytecode semantics"/></p>
<p>As a side note, LLVM is only used at build time to generate the JIT. The generated baseline JIT is self-contained, and does not use LLVM at runtime.</p>
<p>At runtime, the generated baseline JIT generates machine code using <em>Copy-and-Patch</em> (we’ll cover it in a minute). Except that, it heavily follows the design of the <a href="https://webkit.org/blog/10308/speculation-in-javascriptcore/" target="_blank" rel="noopener">baseline JIT in JavaScriptCore</a>, and has employed most of their optimizations. As such, we claim that our baseline JIT qualifies as a state-of-the-art.</p>
<p>In the rest of the post, we will explore the internals of how Deegen generates the baseline JIT in more detail. It is organized as follows:</p>
<ul>
<li>A gentle introduction of the relavent backgrounds (VM, JIT, IC, etc.).</li>
<li>An overview of the Copy-and-Patch technique, the core tool employed by the generated JIT to generate machine code at runtime.</li>
<li>How Deegen further extends Copy-and-Patch to fully automate the process and fit it for the domain-specific use cases of dynamic languages.</li>
<li>An end-to-end example of the machine code generated by the baseline JIT.</li>
<li>Performance evaluation and conclusion thoughts.</li>
</ul>
<h3 id="Background-a-name-deegen-baseline-jit-background-section-a">Background<a name="deegen_baseline_jit_background_section"></a></h3>
<div id="folded_modern_dynamic_language_vm_background_section">
<p>Not everyone is familiar with topics like modern dynamic language VM, multi-tier JIT compilers, baseline JIT, speculative compilation, inline caching, OSR exit…  Therefore, I prepared a background section to gently introduce the background contexts for this post.</p>
<p>Due to its length, I folded this section by default. <a onclick="document.getElementById(&#39;modern_dynamic_language_vm_background_section&#39;).style.display=&#39;inline&#39;; document.getElementById(&#39;folded_modern_dynamic_language_vm_background_section&#39;).style.display = &#39;none&#39;;">To unfold, click here</a>.</p>
</div> <!-- background section -->
<h3 id="How-to-Generate-Machine-Code-a-name-after-background-section-a">How to Generate Machine Code?<a name="after_background_section"></a></h3>
<p>For every JIT, this is an unavoidable problem: how do you generate machine code?</p>
<p>A typical solution used by many (<a href="https://github.com/WebKit/WebKit/tree/main/Source/JavaScriptCore" target="_blank" rel="noopener">JSC</a>, <a href="https://v8.dev/" target="_blank" rel="noopener">V8</a>, <a href="https://luajit.org/" target="_blank" rel="noopener">LuaJIT</a>, etc) is a <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h.html">hand-coded assembler</a>. The assembler provides APIs (e.g., <code>EmitMovRegReg64</code>) to the JIT, which the JIT uses to emit assembly instructions as machine code one by one.</p>
<p>However, such an approach is clearly infeasible for a meta-compiler like Deegen, as our input is expressed as C++ bytecode semantics.</p>
<p>So can we use LLVM directly at runtime to generate code? Unfortunately this is also impractical, as LLVM’s compilation speed is <a href="https://webkit.org/blog/5852/introducing-the-b3-jit-compiler/" target="_blank" rel="noopener">too slow even for a heavyweight optimizing JIT</a>, not to mention a baseline JIT where fast compilation is a top concern.</p>
<h3 id="Copy-and-Patch-the-Art-of-Repurposing-Existing-Tools">Copy-and-Patch: the Art of Repurposing Existing Tools</h3>
<p>The solution is a paper I wrote years ago: <a href="https://brian.abelson.live/assets/copy-and-patch.pdf">Copy-and-Patch Compilation</a>.</p>
<p>In one sentence, Copy-and-Patch is a trick that allows one to generate code without knowing anything about how to generate code.</p>
<p>How is that even possible? While the paper is long, the trick is actually extremely simple, which I will explain here.</p>
<p>Consider the following C++ function:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>int</span> <span>evaluate_lhs</span><span>()</span></span>;</span></pre></td></tr></tbody></table></figure>
<p>When the C++ compiler compiles the above code, it knows nothing about the definition of <code>evaluate_lhs</code> and <code>evaluate_rhs</code>. But it can somehow produce an object file, and the linker can link the object file to <em>any</em> definition of <code>evaluate_lhs</code> and <code>evaluate_rhs</code>, and the final executable would just work.</p>
<h4 id="Relocation-Code-Generation">Relocation = Code Generation</h4>
<p>What does it mean? The object file must contain structured information on how to link <code>evaluate_add</code> against <em>any</em> definition of <code>evaluate_lhs</code> and <code>evaluate_rhs</code>. So if we parse the object file to get that info, at runtime, we can act as the linker, and “link” <code>evaluate_add</code> against any runtime-known <code>evaluate_lhs</code> and <code>evaluate_rhs</code> of our choice to perform an <code>add</code>. This is effectively a JIT!</p>
<p>Of course, the “structured information” has its formal name: <em>linker relocation records</em>. But the name is not important. The important thing is as long as we parsed out those information, we can use them at runtime to emit executable code. And this process is extremely cheap: all it takes is a <code>memcpy</code> followed by a few scalar additions, thus the name “Copy-and-Patch”.</p>
<p>For example, the <code>evaluate_add</code> we just saw will produce an object file with the following contents:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>evaluate_add:</span></pre></td></tr></tbody></table></figure>
<p>with the following linker relocation record:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>offset = 2, type = R_X86_64_PLT32, sym = evaluate_lhs, addend = -4</span></pre></td></tr></tbody></table></figure>
<p>Then, the following copy-and-patch logic would allow one to JIT this function at any address with any desired <code>evaluate_lhs</code> and <code>evaluate_rhs</code> targets:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>void</span> <span>codegen</span><span>(<span>uint8_t</span>* dst, <span>uint8_t</span>* lhsFn, <span>uint8_t</span>* rhsFn)</span> </span>{</span></pre></td></tr></tbody></table></figure>
<p>Yes, that’s all of the core trick of Copy-and-Patch: at build time, compile the logic pieces we want to JIT into object file, and parse the object file to obtain the unrelocated code and relocation records (a <em>stencil</em> in the paper’s terminology). At runtime, code generation is simply wiring up the stencils and materializing them into executable code by a <em>copy</em> (<code>memcpy</code>) and a few <em>patches</em> (scalar additions).</p>
<h4 id="Continuation-Passing-Style-Branch">Continuation-Passing Style = Branch</h4>
<p>The generated code above works, but the code quality is miserable. Everything is executed by a <code>call</code> to another function, which is a lot of overhead.</p>
<p>However, what if one rewrites the code to <a href="https://dl.acm.org/doi/10.1145/800179.810196" target="_blank" rel="noopener">continuation-passing style</a>?</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>void</span> <span>continuation</span><span>(<span>int</span> result)</span></span>;</span></pre></td></tr></tbody></table></figure>
<p>Now, the calls are gone. Furthermore, the function will end with a <code>jmp</code> instruction to function <code>continuation</code> (since the call is a <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">tail call</a>). Since we have control over where to put each function at, if we put <code>continuation</code> right after <code>evaluate_add</code>, then we can even eliminate the <code>jmp</code> to a fallthrough altogether.</p>
<p>After employing this trick, it’s fairly easy to prove that the generated code will not contain unnecessary <code>jmp</code> instructions: all the branches must correspond to actual control flow edges in the generated logic.</p>
<p>One of the main reasons that interpreters are slow is the unpredictable indirect dispatch. At this stage, our generated code has no indirect dispatch, in fact, no unnecessary branches at all. This is already a big speedup over an interpreter.</p>
<h4 id="Address-of-External-Symbol-Runtime-Constant">Address of External Symbol = Runtime Constant</h4>
<p>Another important reason that JITs are faster than interpreters is the ability of JIT to burn runtime constants (bytecode operands, etc) into the instruction stream. Can we support it as well?</p>
<p>Of course! The trick is simple:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>extern</span> <span>char</span> x;  </span></pre></td></tr></tbody></table></figure>
<p>All it takes is to define an external symbol, and use its <em>address</em> as the runtime constant we want to use. Since by definition an external symbol is external, the compiler cannot assume anything about where it resides at. This gives us a way to represent an opaque constant value.</p>
<p>Of course, the linker knows how to patch the code to make the external symbol point to the right location. Thus, we can patch it at runtime to make it represent any runtime constant as well :)</p>
<h4 id="Function-Prototype-Register-Allocation-Combinatorial-Explosion-Instruction-Selection">Function Prototype = Register Allocation / Combinatorial Explosion = Instruction Selection</h4>
<p>Finally, there are <a href="https://developers.redhat.com/blog/2020/01/20/mir-a-lightweight-jit-compiler-project#lightweight_jit_compiler_project_goals" target="_blank" rel="noopener">two most important codegen-level optimizations</a>: register allocation and instruction selection. Can we support them as well? The answer is yes. However, these optimizations are primarily only useful for the static language use cases where each bytecode only implements very simple logic. So to keep this post focused, I will not go into details.</p>
<h4 id="Copy-and-Patch-Wrapping-up">Copy-and-Patch: Wrapping up</h4>
<p>I wouldn’t mind at all if you view Copy-and-Patch as a big hack: because it is! But it works! And it works nicely!</p>
<p>As shown <a href="https://brian.abelson.live/assets/copy-and-patch.pdf">in the paper</a>, one can use Copy-and-Patch to construct extremely fast baseline JIT that <em>significantly</em> outperforms the existing state-of-the-arts:</p>
<ul>
<li>For WebAssembly, we <a href="https://github.com/sillycross/WasmNow" target="_blank" rel="noopener">implemented a baseline JIT</a> that compiles 4.9x-6.5x faster than Google Chrome’s <a href="https://v8.dev/blog/liftoff" target="_blank" rel="noopener">Liftoff baseline compiler</a>, while also generating 39%-63% faster code.</li>
<li>For SQL database, we implemented a prototype <a href="https://github.com/sillycross/PochiVM" target="_blank" rel="noopener">SQL query baseline JIT</a> that on TPC-H queries, compiles &gt;1000x faster than LLVM -O3, while only generating 24% slower code.</li>
</ul>
<p>Furthermore, Copy-and-Patch perfectly suits Deegen’s needs for a JIT:</p>
<ol>
<li>It does not know or care about what is being JIT’ed. The logic we want to JIT is directly compiled by a C++ compiler into an object file at build time. C&amp;P merely parses the object file to produce the <em>stencils</em>, which can then be used to JIT code at runtime.</li>
<li>The code generation at runtime is extremely fast, which perfectly matches the requirement of a baseline JIT. Note that we are doing a lot of expensive preprocessing work, but all of them happen at build time.</li>
</ol>
<h3 id="Deegen-the-Art-of-Repurposing-Existing-Tools-Continued">Deegen: the Art of Repurposing Existing Tools, Continued</h3>
<p>While Copy-and-Patch is a nice technique, its vanilla form as described above is still not enough to fulfill Deegen’s use case. Specifically, the vanilla Copy-and-Patch still requires quite a bit of manual work to implement the stencils and the runtime logic, whereas in Deegen, all must be fully automatic.</p>
<p>As it turns out, fully automating Copy-and-Patch requires significant design-level improvements to the original technique, which we will cover in this section.</p>
<!-- The vanilla Copy-and-Patch does not support the important domain-specific optimizations required to make dynamic languages fast, e.g., inline caching and hot-cold code splitting. -->
<p>To make things easier to understand, we will use the following hypothetical <code>Add</code> bytecode as example (see <a href="https://sillycross.github.io/2022/11/22/2022-11-22/">prior post</a> for a detailed explanation of the code):</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>void</span> <span>Add</span><span>(TValue lhs, TValue rhs)</span> </span>{</span></pre></td></tr></tbody></table></figure>
<h4 id="Identifying-the-Runtime-Constants">Identifying the Runtime Constants</h4>
<p>To get good performance, it is almost mandetory for a JIT to be able to burn runtime constants (bytecode operands, etc.) into the instruction flow. In vanilla Copy-and-Patch, the programmer is required to declare the runtime constants by special macros. So our first improvement is to make this step automatic.</p>
<p>Fortunately this is fairly easy. In our case, the runtime constants are the bytecode operands, and for the IC, everything in the IC state. Since Deegen is already responsible for generating the bytecode decoding logic and the encoding / decoding of the IC state, all we need to do is to not emit the decoding logic, but a magic function call, so that the later processing stages knows that the value is a runtime constant.</p>
<p>For example, for <code>Add</code>, we know that the bytecode slot ordinal of <code>lhs</code>, <code>rhs</code> and the output slot are runtime constants. So the bytecode semantic function will be lowered to LLVM IR that conceptually resembles the following C logic:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>size_t</span> lhs_slot = __runtime_constant_lhs_slot();</span></pre></td></tr></tbody></table></figure>
<p>Correspondingly, at runtime, in order for the generated JIT to generate code, it needs to decode the bytecode struct to retrieve all the operand values and use these values to materialize the copy-and-patch stencils: we will showcase the concrete generated implementation of the <code>__codegen_Add</code> function (which emits machine code for <code>Add</code> at runtime) later in the post.</p>
<h4 id="Propagating-the-Runtime-Constants">Propagating the Runtime Constants</h4>
<p>Acute readers may have noticed that the C logic above cannot result in optimal code. Consider line 3: <code>TValue lhs = stack[lhs_slot]</code>. What actually happens in this line is that we are decoding address <code>(uint64_t)stack + lhs_slot * 8</code> (since each <code>TValue</code> is 8 bytes). If we only make <code>lhs_slot</code> a runtime constant (as we are doing right now), there is no way for LLVM to fold <code>lhs_slot * 8</code> into a constant (recall that at LLVM level, a runtime constant is really the address of an external symbol). As a result, it will generate less-optimal code like <code>mov $XXXX, %rax; shl 3, %rax</code>.</p>
<p>Therefore, we need a customized LLVM constant propagation pass to identify all the constant expressions derived from the “root” runtime constants. Then, we should make each constant expression a runtime constant. Of course, this also means that at runtime, in order to populate these derived runtime constants with concrete values, the codegen function needs to replay the computation of the expression using the concrete values of the root runtime constants.</p>
<p>After this transform, the LLVM IR of our <code>Add</code> example would resemble the following C logic:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>size_t</span> tmp1 = __derived_runtime_constant_1();</span></pre></td></tr></tbody></table></figure>
<p>where the derived runtime constants <code>__derived_runtime_constant_1/2/3</code> are defined as follow:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>__derived_runtime_constant_1 := lhs_slot * 8</span></pre></td></tr></tbody></table></figure>
<h4 id="Fixing-the-Symbol-Range-Assumption">Fixing the Symbol Range Assumption</h4>
<p>As we already explained, in Copy-and-Patch, a runtime constant is expressed by the address of an external symbol.</p>
<p>While it is a neat trick that is crucial for high-quality code, it could break down and cause miscompilation in edge cases. For example, consider the code below:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>extern</span> <span>char</span> x;</span></pre></td></tr></tbody></table></figure>
<p>LLVM would deduce that the <code>val == 0</code> check is trivially false, and “optimize away” the whole if-clause. Why? Because <code>val</code> is the address of variable <code>x</code>, and of course the address of a variable is never <code>0</code>, good game.</p>
<p>In vanilla Copy-and-Patch, the programmer is responsible for avoiding such corner cases. But in Deegen, where stencils are automatically generated, we must find a systematic and provably-correct solution.</p>
<p>So what’s the issue? You might think the issue is “symbol must not be null”. That’s what I initially believed as well, but I later realized it is only the symptom of a much larger issue.</p>
<p>As it turns out, according to <a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf" target="_blank" rel="noopener">x86-64 ABI</a>, every symbol will reside in address range <code>[1, 2^31 - 2^24)</code>. This is also exactly the assumption held by LLVM, and used by LLVM to do optimizations (e.g., in the example above, it deduces that the address of a symbol must not equal <code>0</code>). So the “<code>val == 0</code> check” example is not the only buggy case. LLVM can, for example, do a zero extension instead of a sign extension, as it believes that the address of the symbol must have bit <code>31</code> being <code>0</code> thus a <code>ZExt</code> is equivalent to a <code>SExt</code>, causing buggy code if the runtime constant were to represent a negative value.</p>
<p>One might think the <code>[1, 2^31 - 2^24)</code> range assumption is artificial, but it isn’t. This range assumption is actually important to generate correct code. For a simple example, the code <code>movq sym+100(%rax), %rax</code> would not work correctly due to an <code>int32_t</code> overflow in the imm32 addressing mode field of the instruction, if <code>sym</code> were to have value <code>2^31 - 50</code>.</p>
<p>Therefore, for a provably correct solution, we must make sure that whenever we use an external symbol to represent a runtime constant, the runtime constant we want to express must fit in <code>[1, 2^31 - 2^24)</code>.</p>
<p>In Deegen, this is accomplished by a customized Constant Range Analysis pass to track the range of every constant expression based on the runtime constants. Of course, we also need to know the possible range for the “root” runtime constants – the bytecode operands, and the values captured by the IC state. Fortunately, for most of them, the range is implicit (for example, a bytecode slot is known to be a small non-negative integer, and an operand with type <code>uint16_t</code> obviously fits in <code>[0, 65535]</code>) and requires no user intervention. For the rest, a new Deegen API is added so the user can tell us the range assumption of the value.</p>
<p>Once we figured out the proven range of each runtime constant expression, we can retrofit it into our target range <code>[1, 2^31 - 2^24)</code> by simple transformation. To explain how it works, let’s revisit our <code>Add</code> example:</p>
<ul>
<li><code>lhs_slot</code> is a root runtime constant. Since it represents a bytecode slot ordinal, it is known to be a small non-negative integer, say <code>[0, 10000]</code>.</li>
<li>And we have a derived runtime constant <code>lhs_slot * 8</code>, which is known to fit in <code>[0, 80000]</code> by range analysis.</li>
<li>The range <code>[0, 80000]</code> does not fit in <code>[1, 2^31 - 2^24)</code>.</li>
<li>However, if we define a new expression <code>new_expr := lhs_slot * 8 + 1</code>, the new expression would have range <code>[1, 80001]</code> and fit the assumption.</li>
<li>Therefore, we use an external symbol <code>sym</code> to represent <code>lhs_slot * 8 + 1</code>, and rewrite the LLVM IR to substitute <code>lhs * 8</code> with <code>sym - 1</code>.</li>
</ul>
<p>Now, we are guaranteed correct code as the symbol range assumption is met.</p>
<p>Lastly, if the range of an expression is too large to fit in <code>[1, 2^31 - 2^24)</code>, we simply give up. This means the expression will be evaluated at runtime, but this is rare, and is only a minor performance issue, not a correctness issue.</p>
<p>After this transformation, the conceptual logic of the <code>Add</code> example would look like something below:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>size_t</span> tmp1 = __derived_runtime_constant_1() - <span>1</span>;</span></pre></td></tr></tbody></table></figure>
<p>where the derived runtime constants <code>__derived_runtime_constant_1/2/3</code> are defined as follow:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>__derived_runtime_constant_1 := lhs_slot * 8 + 1</span></pre></td></tr></tbody></table></figure>
<p>Note that in normal cases, those <code>+1 / -1</code> adjustments will not end up as machine instructions in the resulting JIT code, as normally all of those computation ends up being an imm32 field of an instruction, as we’ll see in the example below.</p>
<h4 id="Example-Generated-Code-for-the-AddVV-Bytecode">Example: Generated Code for the <code>AddVV</code> Bytecode</h4>
<p>For a concrete example, the figure below demonstrates the disassembly of the actual JIT code generated for the Lua <code>AddVV</code> bytecode, which performs a Lua <code>add</code> on the given two bytecode values. The C++ bytecode semantic that Deegen takes as input is <a href="https://github.com/luajit-remake/luajit-remake/blob/f8fb972ec91c28b849bd263f164832f0ff434d1f/annotated/bytecodes/arithmetic_bytecodes.cpp" target="_blank" rel="noopener">here</a>.</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/add-generated-code.png" alt="Disassembly of the JIT&#39;ed machine code for the Lua AddVV bytecode"/></p>
<p>The blue boxes indicates the runtime constants that gets burnt into the instruction stream, with their value definitions shown on the right.</p>
<p>Note that the code contains two separated parts: <code>fast_path</code> and <code>slow_path</code>. We will explain this in detail in the next section: for now focus on <code>fast_path</code> only.</p>
<p>As one can see, the code quality has no problem rivalling a hand-written baseline JIT. It loads the two operands from the stack frame, and checks if any of them is <code>NaN</code>, which means either double <code>NaN</code> or a non-double value (which will exhibit as <code>NaN</code> in our NaN-boxing scheme). If so, it branches to <code>slow_path</code>. Otherwise, it performs a <code>double</code> addition and stores the result back to the <code>output_slot</code> in the stack frame. Finally, the control implicitly fallthroughs to the next bytecode.</p>
<p>The implementation of the JIT compiler logic that generates the above code at runtime will be showcased in the next section.</p>
<h3 id="Design-of-the-Baseline-JIT">Design of the Baseline JIT</h3>
<p>Having covered the core of the JIT code generation system, we are finally ready to explore the design of the JIT itself and the supporting components.</p>
<p>For a quick overview, the following figure illustrates the high-level architecture of the baseline JIT (except inline caching, which is complex enough that deserves its own section):</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/baseline-jit-arch.png" alt="A summary of the high-level architecture of Deegen&#39;s baseline JIT (except IC)"/></p>
<h4 id="The-AOT-Slow-Path">The AOT Slow Path</h4>
<p>A distinctive “feature” of dynamic languages is the pervasive existence of slow paths. For example, if you call a boolean value like <code>true</code> (why would anyone do that?), it could trigger some complicated metamethod lookup in Lua, ending up with a function to call or an error. In Deegen, a slow path can be created by both automatic type-based quickening and explicit user annotation (the <code>EnterSlowPath</code> API). But for the JIT, there are some extra complexity in implementing them.</p>
<p>Obviously, the slow path logic should be AOT-compiled, not JIT’ed. However, this introduces two problems:</p>
<ol>
<li>How the JIT’ed code could transfer control to the AOT slow path.</li>
<li>How the AOT slow path could transfer control back to the JIT’ed code.</li>
</ol>
<p>Let’s look at the second problem first. The bytecode stream does not contain any information about the JIT’ed code. Also, the slow path could make branches to other bytecodes and calls to other functions, so it’s not as easy as letting the JIT’ed code pass the JIT address of the next bytecode to the slow path.</p>
<p>Deegen’s solution is a dedicated <code>SlowPathData</code> stream. The <code>SlowPathData</code> stream is similar to the bytecode stream, except that it is intended to be used by the AOT slow path of the JIT tier, instead of the interpreter. A <code>SlowPathData</code> contains all the information needed by the slow path, such as bytecode operands, JIT address for this bytecode, JIT address of the conditional branch target of this bytecode, etc. When the JIT’ed code wants to transfer control to the slow path, it would pass the <code>SlowPathData</code> pointer corresponding to the current bytecode to the AOT slow path. The AOT slow path can then have access to all the data it needs to complete the execution and transfer control back to JIT’ed code.</p>
<p>Of course, the <code>SlowPathData</code> stream has to be generated. Fortunately, since Deegen understands the bytecode stream, it is not hard to generate logic that transcribes the bytecode stream to the <code>SlowPathData</code> stream. Specifically, the generated JIT compiler will generate the <code>SlowPathData</code> stream alongside the executable code.</p>
<p>Now let’s look at the first problem. Transferring control from JIT’ed code to the AOT slow path requires some set up logic, for example, to correctly set up the <code>SlowPathData</code> pointer. However, these logic are rarely executed, as slow paths are, of course, rarely used. If no special handling is taken, the resulted code would have cold logic and hot logic mixed together, resulting in unnecessary additional branches and worse code locality. Of course, this is not a correctness problem, but ideally we want to handle it without sacrificing compilation time.</p>
<p>Deegen employs the solution used in JavaScriptCore: <em>hot-cold code splitting</em>, except that Deegen must accomplish it automatically. Specifically, every stencil will be split into a hot part and a cold part. The JIT will generate two streams of executable code, one holding all the hot path logic, and one holding all the slow path logic. The hot-cold splitting is accomplished by an ASM transformation pass, which we will elaborate in the next section.</p>
<h4 id="The-Baseline-JIT-Algorithm">The Baseline JIT Algorithm</h4>
<p>We now have all the pretexts to understand how the baseline JIT itself works.</p>
<p>In addition to the logic that actually generates machine code, Deegen also generates a <em>bytecode trait table</em> that contains various info about the generated code for each bytecode, e.g., the length of the JIT’ed code’s hot part and cold part, the length and alignment of the data section accompanying the JIT’ed code, the length of the <code>SlowPathData</code> for this bytecode, etc. This allows the baseline JIT to precompute all the buffer sizes in advance.</p>
<p>The baseline JIT compiler works in two passes.</p>
<p>In the first pass, we iterates through the bytecode stream, and use the bytecode trait table to compute various buffer sizes of the generated code and data. All the buffers are then allocated in advance, knowing that a buffer overrun will never happen when we actually fill contents (code, data, etc.) into the buffers. This pass is very cheap because no indirect dispatch is needed.</p>
<p>In the second pass, we iterates through the bytecode stream again, and generate everything (executable code, the accompanying data, the <code>SlowPathData</code>, etc.) for each bytecode by populating the pre-allocated buffers. This step conceptually works similar to an interpreter. We have a pre-built dispatch table storing the codegen functions for each bytecode kind. Control is first transferred to the codegen function for the first bytecode. The function would generate everything needed for the first bytecode, advance buffer pointers accordingly, and then transfer control to the codegen function for the next bytecode. This process repeats until the end of the bytecode stream is reached.</p>
<p>Thanks to Copy-and-Patch, each codegen function is completely branchless, except the tail dispatch that transfers control to the next codegen function, as we shall see in the <code>Add</code> example below. This allows a modern CPU to utilize its Instruction-Level Paralleism (ILP) capabilities to the utmost, yielding an extremely fast compilation process.</p>
<p>Finally, due to the nature of one-pass code generation, bytecodes that can branch to other bytecodes would not know their branch destination address at the time their own code is being generated. To solve this issue, those bytecodes would push information about how the branch destination address shall be fixed up into a late-patch buffer. After all code generation is done, we need to iterate through the late-patch buffer and fix up all the branch targets.</p>
<h4 id="Example-Code-Generation-Function-for-the-AddVV-Bytecode">Example: Code Generation Function for the <code>AddVV</code> Bytecode</h4>
<p>Below is the actual code-generation logic generated by Deegen that generates code for the Lua <code>AddVV</code> bytecode. The machine code generated by the logic is demonstrated in the right half of the figure for cross-reference.</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/add-code-gen.png" alt="Generated JIT logic that generates code for AddVV (left) and the generated code (right)"/></p>
<p>As one can see, the code-generation logic is just what we have explained in the previous subsection. It first decodes the bytecode, then performs a copy-and-patch to generate the JIT fast path and the JIT slow path logic. The expression that defines each runtime constant is replayed to compute the patch value in the instruction stream. Besides the machine code, it also generates the <code>SlowPathData</code> stream and other minor support data. Finally, it advances pointers and dispatch to the next codegen function to codegen the next bytecode. The whole process is completely branchless (except the tail dispatch) by design.</p>
<h3 id="Supporting-Inline-Caching-the-Art-of-Repurposing-Existing-Tools-Evermore">Supporting Inline Caching: the Art of Repurposing Existing Tools, Evermore</h3>
<p>Due to inherent design constraints of a baseline JIT (e.g., compilation must be fast, no OSR-exit is allowed), inline caching (IC) is the only high-level optimization tool available to the baseline JIT.</p>
<p>And inline caching is powerful: on benchmarks that extensively work with Lua tables, a baseline JIT with IC can often be more than 100% faster than the same baseline JIT without IC.</p>
<p>In this section, we will elaborate how Deegen supports inline caching.</p>
<h4 id="How-IC-works-in-Deegen-a-Step-by-Step-Example-of-Call-IC">How IC works in Deegen: a Step-by-Step Example of Call IC</h4>
<p>For a beginner’s introduction to what IC is, please read the <a href="#deegen_baseline_jit_background_section">background section</a>. However, to understand how IC actually works in Deegen’s baseline JIT, the easiest way is to walk through an assembly example. Here, we will use a simplified <code>Call</code> bytecode, which performs a call with no arguments and discards all return values, to demonstrate how <em>call IC</em> works.</p>
<p>The C++ bytecode semantic description is very simple:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>void</span> <span>ReturnContinuation</span><span>(TValue* )</span> </span>{ Return(); }</span></pre></td></tr></tbody></table></figure>
<p>It checks if the callee is a function object. If so, it uses Deegen’s <code>MakeInPlaceCall</code> API to make a call, and the return continuation simply discards all return values and transfer control to the next bytecode. Otherwise, it enters the outlined slow path function (omitted) that checks for a metatable call.</p>
<p>Deegen would generate the following JIT code for this bytecode:</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/call-bytecode-main-logic.png" alt="JIT code generated for the example Call bytecode"/></p>
<p>Note that runtime constants are marked in purple in the form of <code>${X}</code>.</p>
<p>Let’s pretend for now that the <code>codegen_call_ic</code> thing doesn’t exist, and look at the naive implementation. If you stare at the assembly code a little bit, you will notice that the logic involves:</p>
<ol>
<li>Two branches to check that <code>func</code> is a function object.</li>
<li>Two dependent memory loads: one loads the function prototype <code>proto</code> from <code>func</code>, and one loads the actual entry point address from <code>proto</code>.</li>
<li>One indirect branch to branch to the entry point.</li>
</ol>
<p>Unfortunately, dependent memory loads and unpredictable indirect branchs are <em>exactly</em> the two things modern CPUs hate the most. Even predictable branches can be slow, if there are too many of them so that the BTB is overwhelmed.</p>
<p>So how does IC speeds up this code?</p>
<p>As one might have expected, <code>codegen_call_ic</code> will be called on the first time this code is executed. What <code>codegen_call_ic</code> does is that it will emit a piece of IC code snippet, and chain it to the main logic by repatching the self-modifying-code (SMC) region, as shown below:</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/call-bytecode-direct-call-ic-1.png" alt="The JIT code after one IC entry is created"/></p>
<p>As one can see, the next time the same function is called, thanks to the SMC region, the IC will hit, and the optimized logic will be executed. The optimized logic does not check that <code>func</code> is a function object (because we already checked it last time), has no memory loads, and the branch is direct.</p>
<p>This process can be repeated to chain any number of IC entries into a chain:</p>
<ul>
<li>SMC region branches to IC <code>#N</code></li>
<li>IC <code>#N</code> branches to IC <code>#(N-1)</code> if the cached value does not hit</li>
<li>… etc …</li>
<li>IC <code>#1</code> branches to the IC miss slow path, which will create a new IC snippet <code>#(N+1)</code> and chain it at the head of the chain.</li>
</ul>
<p>Of course, at a certain point the overhead from the check chain would cancel out the benefit of the optimized code, and we will stop chaining more cases.</p>
<h4 id="Call-IC’s-Direct-Call-Mode-vs-Closure-Call-Mode">Call IC’s Direct Call Mode vs Closure Call Mode</h4>
<p>While the above approach works well if a Lua function is used like a C function (monomorphism) or a C++ virtual method (class-like polymorphism), it would work very poorly for the <em>function factory</em> design pattern. For example, consider the following Lua snippet:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>createCounter = <span><span>function</span><span>()</span></span> </span></pre></td></tr></tbody></table></figure>
<p>In this example, the call in line <code>9</code> is likely to see a lot of different function objects, even though all of them share the same prototype (the counter lambda in line <code>3</code>). Since our current call IC strategy caches on the function object, not the function prototype, it is completely ineffective for this use pattern.</p>
<p>Again, we employ the solution used in JavaScriptCore. Our call IC supports two modes: <em>direct call</em> mode and <em>closure call</em> mode. A call IC site always starts in direct call mode, in which it caches on function objects, as we have shown above.</p>
<p>But when a call IC site first sees a IC miss that has the same function prototype as one of the already-cached function objects, it will transition the IC to closure-call mode. To do this, it rewrites the self-modifying code region and invalidates all existing ICs at this site, and from now on, this IC site will instead cache on the function prototypes. This is demonstrated by the figure below:</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/call-bytecode-closure-call-ic-1.png" alt="The JIT code after the Call IC transitions to Closure Call Mode"/></p>
<p>As one can see, the SMC region is repatched to completely different logic: it checks if <code>func</code> is a heap object (which is required for us to load its hidden class), then load the hidden class of the heap object and branch to the first IC case.</p>
<p>Each closure call IC case caches on a function prototype. So it compares if the hidden class matches the cached prototype. If yes, it knows that <code>func</code> must be a function object with the cached prototype, so it can perform an optimized call similar to before.</p>
<p>Of course, one can also chain up as many IC cases in closure call as desired, until the chained check overhead overwhelms the perf gain from the optimized code.</p>
<p>As one can see, closure call mode is less efficient than direct call mode as it performs one extra check and one extra memory load, but it works effectively for the function factory design pattern. This is why a call IC site always starts in direct call mode, and only transitions to closure call mode when it actually observes a closure call pattern.</p>
<h4 id="So-How-to-Automatically-Generate-All-of-These">So, How to Automatically Generate All of These?</h4>
<p>Having understood how IC works in Deegen (we only demonstrated Call IC, but the case for Deegen’s Generic IC API is similar), the next question is: how could Deegen generate all of these automatically?</p>
<p>However, as you can already see, what we want to do is something totally outside the operating envelope of LLVM. LLVM is simply not designed to generate a function that can dynamically patch itself at runtime to append a dynamic chain of parametrizable code snippets.</p>
<p>As before, our solution is to repurpose existing tools to trick LLVM into helping us without its knowledge. And as it turns out, the core of the trick is to repurpose a completely-irrelevant little-known GCC feature in the dark corner.</p>
<h4 id="Thank-you-GCC-ASM-goto">Thank you, GCC ASM-goto!</h4>
<p>GCC supports a little-known extension feature called <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#:~:text=6.47.2.7%20Goto%20Labels" target="_blank" rel="noopener">ASM-goto</a>, which basically allows one to write inline assembly that branches from assembler code to C labels. And LLVM, aiming for compatibility with GCC, <a href="https://lists.llvm.org/pipermail/llvm-dev/2018-October/127239.html" target="_blank" rel="noopener">has also supported this feature a few years ago</a> by a special <code>CallBr</code> IR instruction.</p>
<p>I just want to say a big thank you to the GCC developers who designed this feature and the LLVM developers who added support for it! Without this feature, it’s very likely Deegen couldn’t support inline caching at all.</p>
<p>So how does ASM-goto have anything to do with inline caching?</p>
<p>As you might have seen from the assembly example above, the hard part of IC is that each IC case is a piece of machine code that directly “clings” to the main logic. It cannot be implemented by a separate function due to the call overhead and the requirements of Lua’s stackful coroutine. It must work directly using the context (e.g., which register holds which value) of the main logic, and could transfer control to different destinations in the main logic.</p>
<p>ASM-goto (and its underlying <code>CallBr</code> LLVM IR) provided <em>exactly</em> the semantics we want. Since it is an <code>InlineAsm</code>, LLVM is <em>required</em> to treat its contents as opaque. All LLVM knows is that after executing the <code>InlineAsm</code>, control will be transferred to one of the destinations specified in the <code>CallBr</code>.</p>
<p>In other words, we repurpose <code>CallBr</code> as a way to model “a control flow transfer in an unspecified manner”. At runtime, we are building up a dynamic chain of IC cases; but if one views the chain-check logic as a black box, then it can be characterized as: after the black box is executed, control is transferred to either an IC hit case specialized to the cached values, or the IC miss slowpath. This is exactly the semantics <code>CallBr</code> provided, so we can safely model it using <code>CallBr</code>.</p>
<p>But this is still far from enough. Now we have a way to model the control flow of the dynamic IC chain in LLVM IR, but it’s still unclear how we can extract the IC logic from the main function, implement the IC check chain, and do all the self-modifying code stuff.</p>
<p>This is where the last piece of the puzzle comes in: ASM transformation.</p>
<h4 id="ASM-Transformation-the-Last-Piece-of-the-Puzzle">ASM Transformation: the Last Piece of the Puzzle</h4>
<p>I know this might scare off people, as directly messing with assembly sounds like an extremely fragile approach.</p>
<p>But it really isn’t. Deegen treats most of the assembly instructions as opaque and will not modify any of them. The ASM transformation is limited to reordering and extracting ASM blocks.</p>
<p>As a result, Deegen’s assembly knowledge is extremely limited. All it knows is that:</p>
<ul>
<li>A <code>jmp</code> does a direct jump.</li>
<li>A <code>jmpq</code> does an indirect jump.</li>
<li>Any other instruction starting with <code>j</code> does a conditional jump.</li>
</ul>
<p>However, as it turns out, with some clever tricks and cooperation from LLVM IR, doing only ASM block rearrangements is already sufficient to achieve a lot: we can support all the inline caching stuffs, among other things.</p>
<p>The full trick is the following. Recall that we are only using <code>CallBr</code> as a device to express an opaque control flow, and the <code>InlineAsm</code> inside <code>CallBr</code> does not matter. So we will use this <code>InlineAsm</code> to carry down information to the textual assembly level, as shown below.</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/callbr-example.png" alt="The CallBr trick at LLVM IR level and the resulting assembly"/></p>
<p>As one can see, the previledged instruction <code>hlt</code> is used as a magic to allows us to identify the <code>CallBr</code> in the textual assembly. Then, the fake branches following the <code>hlt</code> allows us to know the assembly labels that implements each logic case.</p>
<p>Having parsed these information, we no longer need the <code>CallBr</code> payload, so we remove it from assembly, and make it branch to the slow path directly.</p>
<p>Next, we perform a CFG analysis of the assembly. The only hard part about the CFG analysis is to know the possible destinations of the indirect branches. This ideally should be implemented as a LLVM backend pass, but I haven’t figured out how to do it due to limited documentation about LLVM backend. So currently, the indirect branch target analysis is done via some hacks that map the indirect branch back to LLVM IR by debug info.</p>
<p>Now we have the CFG of the assembly, we can then figure out the ASM blocks only reachable from the function entry, and only reachable from each IC logic kind, as shown below.</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/ic-extraction.png" alt="ASM CFG Analysis and IC Extraction"/></p>
<p>Note that the logic entry of each IC kind must not be reachable from the function entry, because they are only reachable by the <code>CallBr</code>, but we have removed those control flow edges as the <code>CallBr</code> has been removed by us.</p>
<p>Finally, we can separate out the IC logic from the main function logic. For the main function, we only retain ASM blocks reachable from the function entry. And for each IC kind, we only retain ASM blocks reachable from its logic entry but not the main function entry. Each piece of extracted assembly is then compiled to object file and extracted to a Copy-and-Patch stencil, so we can JIT it at runtime.</p>
<p>There are still some minor issues that we haven’t covered, such as how we build up the dynamic IC check chain, and how exactly the self-modifying code region is constructed. But the idea is similar to how we supported inline caching: most of the heavy-lifting of actually building up the logic is done at LLVM, and <code>InlineAsm</code> is repurposed as a tool to pass down information to assembly. Then at assembly level, Deegen can piece everything together by very simple transformations that requires little to no assembly knowledge.</p>
<h4 id="The-Inline-Slab-Optimization">The Inline Slab Optimization</h4>
<p>Deegen employed one additional optimization for IC: the <em>Inline Slab</em> optimization (again, the terminology is a JavaScriptCore jargon).</p>
<p>Conceptually, the idea is very simple: currently, each IC case is an outlined piece of JIT code. As a result, control has to branch from main logic to the IC case, and then from the IC case back to the main logic in the end. So why not use the SMC region to hold one IC case? Now, the “blessed” IC case sitting directly inside the SMC region can be executed directly, saving one or two jumps.</p>
<p>Of course, it is harder to do than said. One has to decide a good size for the inline slab (i.e., the SMC region), as only IC whose size is less than the inline slab size can sit in the inline slab. And updating the patchable jump in the SMC region is more complicated, as the location of the jump is different depending on whether the inline slab exists. Finally, the inline slab version of the IC has slightly different logic from the normal version: the tail branch could potentially be eliminated, and one must pad NOPs to exactly the size of the inline slab.</p>
<p>As a result, even in JavaScriptCore, the inline slab optimization requires quite some engineering efforts, e.g., more hand-rolled assembly, <a href="https://sillycross.github.io/r/WebKit/Source/JavaScriptCore/bytecode/InlineAccess.h.html">manual book-keeping of the inline slab sizes</a> that has to be updated whenever the generated assembly changes, etc.</p>
<p>Fortunately, in Deegen, the inline slab optimization is employed fully automatically. So for a language implementer, the additional ~4% performance on average (and occasionally 10+% on IC intensive workloads) from inline slab comes for free!</p>
<h4 id="Runtime-Support-and-IC-Design-Summary">Runtime Support, and IC Design Summary</h4>
<p>Finally, the VM runtime needs to manage the IC. For example, it needs to reclaim the JIT code memory when the IC is invalidated, and upon tiering-up, it needs to update all the call IC cases to point to the new entry point.</p>
<p>Therefore, in additional to the actual JIT’ed code, we also need to allocate a piece of metadata to manage each IC. The metadata are chained into a linked list at the use site of the IC (the <code>ICSite</code>), which resides in the <code>SlowPathData</code> stream.</p>
<p>Putting everything about Deegen’s IC design together into one figure:</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/deegen-ic-design-detail.png" alt="An overview of Deegen&#39;s design of Inline Caching in more detail"/></p>
<h4 id="Full-Example-for-Deegen’s-Generic-IC-TableGetById-Bytecode">Full Example for Deegen’s Generic IC: <code>TableGetById</code> Bytecode</h4>
<p>To conclude our discussions on inline caching, we will present a full example for the <code>TableGetById</code> (aka., <code>TGETS</code> in LuaJIT) bytecode.</p>
<p>The bytecode takes two operands: <code>base</code> and <code>index</code>, where <code>index</code> is a constant string, and returns <code>base[index]</code>. Any Lua string property access, for example, <code>employee.name</code> or <code>animal.weight</code>, would generate this bytecode.</p>
<p>In <em>LuaJIT Remake</em>, a Lua table is not implemented by a plain hash table with an array part, but employs <a href="https://github.com/luajit-remake/luajit-remake/blob/b9b5274d15373a24f9297cf551621506f87b375f/runtime/structure.h" target="_blank" rel="noopener">hidden class</a> for better performance, using a design <a href="https://webkit.org/blog/10308/speculation-in-javascriptcore/" target="_blank" rel="noopener">mostly mirroring JavaScriptCore’s</a>. Deegen supports <a href="https://brian.abelson.live/2022/11/22/2022-11-22/#deegen_generic_inline_caching_api">generic IC API</a> to allow easy deployment of IC via clever use of C++ lambdas. The actual implementation of the C++ bytecode semantic for <code>TableGetById</code> can be <a href="https://github.com/luajit-remake/luajit-remake/blob/b9b5274d15373a24f9297cf551621506f87b375f/annotated/bytecodes/table_get_by_id.cpp#L91" target="_blank" rel="noopener">found here</a>.</p>
<p>The figure below is the disassembly of the actual machine code generated by the baseline JIT, alongside the JIT’ed code for all 6 kinds of IC stubs, as well as their inline-slab versions. As before, the runtime constants burnt into the instruction stream are shown in purple text.</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/getbyid_ic.png" alt="Disassembly of the main logic and all IC logic generated for the TableGetById bytecode"/></p>
<p>As you can see above, in the good case of an inline-slab IC hit for a table without metatable (which is very common), a <code>TableGetById</code> can be accomplished with no taken branches and in less than 10 instructions. This is why IC could drastically speed up table operations.</p>
<p>On the other hand, as you can also see above, implementing IC by hand requires a deep understanding of assembly and a significant amount of engineering. This is exactly where Deegen comes in. With Deegen’s generic IC API that makes all of these happen automatically, a language implementer can enjoy the benefits of IC without the high engineering cost.</p>
<h4 id="The-Hot-Cold-Splitting-Pass-and-Jump-to-Fallthrough-Pass">The Hot-Cold Splitting Pass and Jump-to-Fallthrough Pass</h4>
<p>Finally, since we already have an ASM transformation infrastructure, why not use it for more good?</p>
<p>The Hot-Cold Splitting Pass works by reordering ASM blocks and move cold blocks to a separated text section, which reduces some unnecessary branches and improves code locality. Of course, the stencil extraction logic that generates the copy-and-patch stencil from the object file needs to be made aware of this and extract both sections, but this is not hard to do. To figure out which blocks are cold, ideally, one should write a LLVM backend pass. However, as explained before, I still haven’t figured out how to write a LLVM backend pass, so currently this is accomplished by injecting debug info to map assembly blocks back to LLVM IR blocks, and use LLVM IR’s block frequency infrastructure to determine the cold blocks.</p>
<p>The Jump-to-Fallthrough transformation pass attempts to move the dispatch to the next bytecode to the last instruction, so that the jump could be eliminated to a fallthrough, reducing an unnecessary branch. This is needed because at LLVM IR level, a dispatch is a tail call, and LLVM is not aware of the fact that a dispatch to the next bytecode could potentially be implemented by a fallthrough if it were the last instruction. Deegen implemented a simple pass to address this issue, which attempts to make the fallthrough possible by reordering ASM blocks and doing very limited rewrites like flipping branch conditions.</p>
<h3 id="An-End-to-End-Example">An End-to-End Example</h3>
<p>To demonstrate how the actual end-to-end JIT’ed code generated by the baseline JIT looks like, we will use the following Lua example that computes a factorial:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>While it is a simple example, it demonstrates almost all the important things in a baseline JIT: basic operations such as arithmetic and comparison, control flow, function calls, call inline caching (automatically provided as part of Deegen) and table inline caching (implement using Deegen’s generic IC API).</p>
<p>The above Lua function results in 8 bytecodes:</p>
<ul>
<li>(Bytecode #0) BranchIfNotLessThan {<code>Slot(0)</code>, <code>Double(1)</code>} → #3</li>
<li>(Bytecode #1) ConstInt16  {<code>1</code>} → <code>Slot(1)</code></li>
<li>(Bytecode #2) Return {<code>SlotRange [1, 2)</code>}</li>
<li>(Bytecode #3) GlobalGet {<code>String(&#34;fact&#34;)</code>} → <code>Slot(1)</code></li>
<li>(Bytecode #4) ArithmeticSub {<code>Slot(0)</code>, <code>Double(1)</code>} → <code>Slot(5)</code></li>
<li>(Bytecode #5) Call { Frame: <code>Slot(1)</code>, #arg: <code>1</code>, #ret: <code>1</code> }</li>
<li>(Bytecode #6) ArithmeticMul {<code>Slot(1)</code>,<code>Slot(0)</code>} → <code>Slot(1)</code></li>
<li>(Bytecode #7) Return {<code>SlotRange [1, 2)</code>}</li>
</ul>
<p>For clarity, we demonstrate the code <em>after</em> the function has been executed, so all the self-modifying code regions (including inline slabs) have been repatched, and outlined IC stubs have been created.</p>
<p>I manually grabbed the JIT’ed code using GDB and hand-remapped all the labels, so please pardon me if I made an mistake. The disassembly is as follows:</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/factorial-jit-code.png" alt="Disassembly of the JIT&#39;ed code for the factorial function"/></p>
<p>Note that under normal circumstances (i.e., a number is passed in as parameter to <code>fact</code>), the <code>GlobalGet</code> and <code>Call</code> slow path will be executed once to create the IC. After that, none of the slow path logic will ever be executed, and none of the self-modifying code region in the fast path will get repatched further.</p>
<h3 id="Tiering-up-Logic">Tiering-up Logic</h3>
<p>The last bit of complexity is the tiering-up logic. In a multi-tier VM, the user program starts execution in the interpreter tier, and hot functions are eventually tiered up to the baseline JIT tier (and potentially further to the optimizing JIT tier, but that’s future work).</p>
<p>To support tiering-up, we have two problems to solve. First, how hot functions could be identified. Second, how future calls to the tiered-up function could get redirected to the JIT’ed version.</p>
<p>Let’s look at the second problem first. While seemingly trivial (just change the entry point stored in the function prototype), it is actually not that trivial due to the existence of call IC. When a function gets tiered-up, every call IC that caches on the function must be updated and redirected to the new entry point. To achieve this, all the call IC are chained into a circular doubly-linked list on the function prototype that it caches on. In addition, Deegen generates information on how one can update the JIT’ed code of a call IC to change the function entry point it branches to. Then, whenever a function is tiered up, one can iterate through all the call ICs caching on the function using the doubly-linked list, and update each of them to point to the new entry.</p>
<p>For the first problem, the idea is to increment a per-function counter whenever the interpreter reaches a loop bytecode or a function return bytecode. When the counter reaches a threshold, we trigger JIT compilation and redirect control to the JIT’ed code. Unfortunately, the engineering of this part has not been finished. I have to publish this post now, because this post is used as the reading material for a talk a couple of days later :(</p>
<p>This also means that currently we cannot tier-up from interpreter to baseline JIT, so for the benchmarks, everything is directly compiled by the baseline JIT and executed in baseline JIT tier.</p>
<h3 id="Performance-Evaluation">Performance Evaluation</h3>
<p>In this section, we will analyze the performance of <a href="https://github.com/luajit-remake/luajit-remake" target="_blank" rel="noopener">LuaJIT Remake</a> (LJR)&#39;s baseline JIT on 44 synthetic benchmarks from <a href="https://github.com/smarr/are-we-fast-yet" target="_blank" rel="noopener">Are-we-fast-yet</a>, <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/" target="_blank" rel="noopener">CLBG</a>, <a href="https://github.com/LuaJIT/LuaJIT-test-cleanup/tree/master/bench" target="_blank" rel="noopener">LuaJIT Benchmarks</a> and <a href="https://github.com/gligneul/Lua-Benchmarks" target="_blank" rel="noopener">Lua Benchmarks</a>.</p>
<p>Disclaimer: synthetic benchmarks are well-known to be misleading and unable to reflect real workloads (see [<a href="https://blog.mozilla.org/nnethercote/2014/06/16/a-browser-benchmarking-manifesto/" target="_blank" rel="noopener">1</a>,<a href="https://v8.dev/blog/retiring-octane" target="_blank" rel="noopener">2</a>,<a href="https://www.microsoft.com/en-us/research/publication/jsmeter-characterizing-real-world-behavior-of-javascript-programs/" target="_blank" rel="noopener">3</a>,<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/why-measure-toy-benchmark-programs.html" target="_blank" rel="noopener">4</a>]). The sole purpose of this section is to put our results within the context of the existing works, to give a <em>rough sense</em> on the performance of our baseline JIT.</p>
<h4 id="Compilation-Throughput">Compilation Throughput</h4>
<p>The top priority of a baseline JIT is to generate machine code as fast as possible. Therefore, our first evaluation is the compilation throughput.</p>
<p>We measured the compilation throughput of our baseline JIT by timing the main compilation function, which performs the end-to-end work of compiling a input Lua bytecode stream to machine code. We also recorded the total number of Lua bytecodes processed by the baseline JIT, and the total size of the generated machine code.</p>
<p>The average result over all 44 benchmarks is as follows:</p>
<ul>
<li>In terms of Lua bytecodes processed per second, LJR’s baseline JIT can compile 19.1 million Lua bytecodes per second.</li>
<li>In terms of machine code generated per second, LJR’s baseline JIT can generate 1.62GB of machine code per second.</li>
</ul>
<p>To demonstrate what 19.1 million Lua bytecodes means, the 44 Lua benchmark programs (254KB total) contains 17197 Lua bytecodes in total. So our baseline JIT generated machine code for all 44 benchmarks in less than one millisecond total.</p>
<p>As such, we claim that the compilation throughput of our baseline JIT is extremely fast, to the point that the start delay can be considered negligible.</p>
<h4 id="Generated-Code-Performance">Generated Code Performance</h4>
<p>While the baseline JIT is designed to generate code fast, generating fast code is still a second priority.</p>
<p>In this section, we will evaluate the execution performance of the machine code generated by LJR’s baseline JIT by comparing with LuaJIT and PUC Lua.</p>
<p>LJR and LuaJIT have drastically different high-level architecture, mid-level design and low-level implementation choices. For the most obvious part, a baseline JIT performs few optimizations <em>by design</em>, while the tracing JIT in LuaJIT does a lot of optimizations. Therefore, the sole purpose of the benchmark is to put the end performance of LJR’s baseline JIT within the context of the existing works, as shown in the figure below:</p>
<p><img src="https://brian.abelson.live/images/2023-05-12/perf-numbers.png" alt="Performance comparison of LJR&#39;s baseline JIT, LuaJIT and PUC Lua, higher is better"/></p>
<p>As one can see, LuaJIT’s optimizing tracing JIT generally works better than our baseline JIT, which is no surprise.</p>
<p>However, it’s worth noting that with IC as the only high-level optimization, we are already outperforming LuaJIT on 13 of the 44 benchmarks. On geometric average, we are about 34% slower than LuaJIT, and 4.6x faster than PUC Lua.</p>
<p>In my opinion, it is fair to say that Deegen is now on a very stable ground. With its excellent interpreter and baseline JIT that can already achieve pretty good execution performance at a negligble startup delay, the optimizing JIT (to come in the future) would have much less pressure in doing expensive optimizations.</p>
<h3 id="Conclusion-Thoughts-and-Future-Works">Conclusion Thoughts and Future Works</h3>
<p>This post demonstrated the second phase of the Deegen project – to build a high-performance baseline JIT compiler automatically from the bytecode semantic.</p>
<p>Of course, this is far from the end. Our next step is to automatically generate an optimizing compiler, which will likely follow the design of JavaScriptCore’s DFG lightweight JIT compiler. If you have any comments, suggestions or thoughts, please do not hesitate to <a href="https://sillycross.github.io/about/">shoot me an email</a> :)</p>
<h4 id="Acknowledgements">Acknowledgements</h4>
<p>I thank <a href="https://fredrikbk.com/" target="_blank" rel="noopener">Fredrik Kjolstad</a> and <a href="https://saambarati.org/" target="_blank" rel="noopener">Saam Barati</a> for their comments and discussions on the draft version of this post. Fredrik also did the image editing work for the <code>Add</code> bytecode figure.</p>
<hr/>




      
    </div></div>
  </body>
</html>
