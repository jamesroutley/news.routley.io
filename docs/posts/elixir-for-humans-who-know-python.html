<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hibox.live/elixir-for-humans-who-know-python">Original</a>
    <h1>Elixir for Humans Who Know Python</h1>
    
    <div id="readability-page-1" class="page"><div id="root-main"><nav><div><p><a href="https://blog.plover.com/"><b>:) Hibox</b></a></p></div><ul><li><a href="#howitworks"></a></li><li></li><li></li></ul><div><p><a href="https://blog.plover.com/users/log_in">Login</a><a href="https://blog.plover.com/#pricing">
    Get Started for Free
  </a></p></div><p><img src="https://blog.plover.com/assets/svg/logos/Menu.svg" alt="Menu icon"/></p></nav><div id="mobileNav"><p><img src="https://blog.plover.com/assets/svg/logos/Cross.svg" alt=""/></p><ul><li><a href="https://blog.plover.com/users/log_in">Sign In</a></li></ul></div><section><div><p class="text-slate-700"><i>This article has nothing to do with <b><a href="https://hibox.live">Hibox</a></b>, a service that lets you video chat with visitors to your website so you can make more sales and get better feedback. Yes, Hibox is written in Elixir.</i></p><p>
            Hi there! My name is <a href="https://github.com/Miserlou">Rich</a>. Some of you might already know me from some of my Python projects and talks I&#39;ve given at Python and server-less conferences.
          </p><p>
             Recently, I&#39;ve been growing a bit unhappy with the direction that Python has taken, so I&#39;ve been trying out other languages, looking for something which expands upon the things I love about Python but jettisons the things I don&#39;t like about it.
          </p><p>
            I&#39;ve spent the past year or so working in a language called Elixir, building games, web services and <a href="https://miserlou.github.io/Helix/misc/2022/12/27/introducing-helix.html">AI projects</a>, and I&#39;ve been enjoying it very much.
          </p><p>
            I wrote this article to share some of what I&#39;ve learned so far so that other Python developers who want to give Elixir a try can hit the ground running.  I&#39;ll start with a high-level overview about the benefits and capabilities of Elixir and then dive into some practical examples, common patterns, and how to overcome snags and oddities that you might find along the way. It assumes a little bit of knowledge of Python, but even if you&#39;re not familiar with Python, I think you&#39;ll still find it useful.
          </p><p>
            This article is quite long, so if you want to skip my opinions and get right to Elixir, <a href="#letsgo">click here to skip to that</a>.
          </p><h2>
            Why I&#39;m Excited About Elixir
          </h2><p>
            Just to get it out of the way, Elixir is not &#34;Python++.&#34; Linguistically, Elixir is more of a descendant of Ruby than it is a descendant of Python. It&#39;s not white-space significant, there&#39;s often more than one right way to solve a problem, and control logic requires the use of a <code>do</code> keyword, which I&#39;ve always found a turn-off, but it&#39;s not difficult to get used to. The reasons I like Elixir are not because it&#39;s a Python 2.7 taken in a different direction - <b>I like it because Elixir enables me to build with new capabilities at a speed that I don&#39;t think would be possible with Python in its current state</b>.
          </p><p>
            The main reason to be excited about Elixir isn&#39;t actually the language itself, but rather a web development framework, Phoenix. Phoenix is a batteries-included web framework, similar to Django. It isn&#39;t <i>quite</i> as featureful as Django - there are no Users or Admin - but it gives you 80% of what you&#39;ll need out of the box, and provides some new things that you never knew you needed before, but once you try them, you&#39;ll never want to look back.
          </p><p>
            The most significant of those benefits is LiveView. I think LiveView-like functionality (known generally as &#34;Live Apps&#34;) will be the basis for a &#34;fourth age&#34; of  web-development, and I&#39;m very excited about it.
          </p><h2>
            A Brief Detour Into The Different Eras of Web Development
          </h2><p>
            The first age of web development was static files served through a webserver. It was new, exciting, chaotic and fun, but very primitive. Most of you are probably too young to remember this era by now.
          </p><p>
            The second age of web development was in languages like Perl, PHP, Ruby and Python, where a client sends HTTP requests to URLs, and the server returns dynamic content rendered as a static resource. This was a very fun era to be a developer, but applications were limited in how complex and featureful they could be, and there were a fair inefficiencies from re-sending a whole page just to reflect a single updated value.
          </p><p>
            In next phase of web development, browsers rendered applications using a client-side JavaScript framework like React, Angular or Vue, which then make HTTP requests through a separate API, which are then rendered dynamically inside of the JS framework. This enabled more complex applications to emerge, starting with GMail, but exploded the amount of work required, as now applications required a hefty about of development in JavaScript on the front-end in addition to the the back-end work maintaining an API.
          </p><h2>
            Live Apps
          </h2><p>
            Live Apps combine the best of two worlds, enabling developers to build complex, dynamic applications without the need for any JavaScript or a dedicated API. A client requests an initial page load, which the server renders and maintains a local understanding of, and then makes a follow-up request to establish a WebSocket connection. Client side interactions with the application are then passed through the WebSocket and changes to the state are returned and the DOM is dynamically updated accordingly, without any API interaction or custom JavaScript required, as all of the logic is kept on the server-side.
          </p><p>
            This is where the capabilities of Elixir over Python become really apparent. Concurrency in Python has been notoriously tricky since the early days, and more recent advancements like <code>await</code>/<code>async</code> still seem hacky and cumbersome. In Elixir, however, concurrency is at the heart of the system.
          </p><p>
            Spawning and maintaining a new process is essentially cost-free, meaning that even a small server can house millions of concurrent processes. This is because Elixir runs on top of the Erlang BEAM VM, which has been used for telephony applications for decades, illustrated most wonderfully in <a href="https://www.youtube.com/watch?v=xrIjfIjssLE">Erlang, The Movie</a>, and has famously powered WhatsApp and Facebook Chat.
          </p><p>
            What this means in practice is that Phoenix LiveView applications maintain a separate process for every website visitor. This would be a ridiculous, mind-melting prospect in Python, but it&#39;s a non-issue in Elixir - that&#39;s simply how things work. It doesn&#39;t require any configuration or plumbing to get going, it just works like that right out of the box, and it&#39;s awesome. You can even add new servers in a different region at any time, and the application distributes the load accordingly.
          </p><p>
            Writing Elixir applications feels a bit more like writing a &#34;system&#34; than it does an application the way you&#39;re probably used to. Tasks which would normally require complexity like messaging queues and external caches become just another part of your application. As a small example of what I mean, I wrote an application which has different game lobbies. In the last era of web development, you might have an API endpoint <code>api/games/state?=waiting</code> which clients would poll, and the server would return them. If 10,000 people are trying to find a game at once, that would mean 10,000 database queries every few seconds to fetch accurate data. Instead, it was trivial to write a process which would make that query, and then propagate the result to the clients via their LiveView subscriptions, requiring only a single database request rather than 10,000.
          </p><h2>
            The Elixir Language
          </h2><p>
            Now that I&#39;ve hopefully enticed you into wanting to learn a bit more, let&#39;s get into the nitty gritty of the language.
          </p><h2>
            Data Types
          </h2><p>
           Data types in Elixir are mostly what you&#39;d expect - integers, floats, booleans, lists, tuples, strings (UTF-8 encoded, thank the lord), and anonymous functions, which all behave like you&#39;d expect. There are no &#34;dictionaries&#34;, but there are &#34;maps&#34; which behave much the same way.
           </p><p>
            There&#39;s also one important type you might not have encountered before: the atom. Atoms are like special string constants whose values are their own names. You&#39;ll see them as words prefixed with a <code>:</code>, like <code>:apple</code>. Under the hood, <code>false</code>, <code>true</code> and <code>nil</code> are technically atoms, but as a convenience you don&#39;t need the <code>:</code> just for those. Atoms aren&#39;t scary, you&#39;ll see them all over the place as they&#39;re used extensively for the pattern matching features we&#39;ll explore later, and you&#39;ll grow to love them very quickly.
          </p><h2>
            Functionalism
          </h2><p>
            Elixir is a &#34;functional&#34; language. Though this might conjure scary thoughts of bearded wizards casting spells full of parentheses, I think the schism between functional and object-oriented programming has been wildly over-blown, and if you&#39;re comfortable lambdas in Python, you shouldn&#39;t have any issues at all with Elixir. One hangup you might encounter is that all data is immutable. In practice, this mostly means that you&#39;ll writing <code>new_thing = Thing.do(thing)</code> rather than <code>thing.do()</code>. This actually ends up being a relief, as in Python it&#39;s often unclear if a function will modify an object or return a modified version, leaving the original in tact. Life is simpler when this distinction doesn&#39;t exist.
          </p><p>
            What this allows for is some wonderful syntactic sugar that Elixir calls pipes, just like in UNIX shells. The pipe operator, <code>|&gt;</code>, passes the output of a function to the first argument of the next function. So, instead of writing something like:
          </p><p>
          You have the option to write:
          </p><p>
          The readability benefit is clear - you don&#39;t have to read the code &#34;backwards&#34; to understand what it really does.
          </p><p>
          You aren&#39;t forced to write code this way, but it becomes very convenient once you get used to it, and you&#39;ll see it used almost everywhere in code that you&#39;ll read, so it&#39;s good to be familiar with this style. It also pairs very nicely with <code>IO.inspect()</code>, which you&#39;ll want to use for print-debugging, as it returns its input, so it can be used inside of a long pipe, like so:
          </p><p>
Parentheses are also optional for functions with single arguments, so this can also be written like:
          </p><p>
          Although I actually don&#39;t like this style, as it can make it unclear what&#39;s a function and what&#39;s a variable.
          </p><p>
            Overall, I think pipes are excellent, and you&#39;ll soon miss them when you have to program in languages that don&#39;t have them.
          </p><h2>
            A Note on Data Immutability
          </h2><p>
          I&#39;d like to briefly clarify what I said about &#34;all data being immutable&#34; with a quick example. Consider this Python code:
          </p><p>
          Notice that when we change the value of x, the output of of the print function will change as well. Now let&#39;s see the same example in Elixir:
          </p><p>
          The behavior is different - the output doesn&#39;t change. This is because when the print function was defined, x was pointing to 10 in memory. Making x point to another value in memory later doesn&#39;t change the value that was held when the print function was defined.
          </p><p>
          In practice, it&#39;s not a problem you encounter all too often, but it is something to be mindful of if you are seeing some behavior you didn&#39;t expect.
          </p><h2>
            Control Flow
          </h2><p>
            One of the trickier differences between Python and Elixir is control flow. For starters, there is no return statement, so you can&#39;t break out of your function or loop early, which will seem very counter-intuitive initially. Functions always return the result of their last statement as their result. The effect of this is that you will end up writing a larger number of smaller functions for reasons which will be come more clear in the next section. There&#39;s also no <code>while</code> statement.
          </p><p>
            Similarly, since everything is a function that returns its last statement, that means that control statements like <code>if</code> do as well.  So, it&#39;s possible to write something like:
          </p><p>
        By convention, function names ending with a <code>?</code> mark return a boolean. Functions ended with a <code>!</code> raise an exception upon failure. Strings are interpolated with <code>#{}</code>. I suppose that was a silly example, but you get the idea.
        </p><p>
        Because of the data immutability I mentioned earlier, writing loops is a bit different. You can&#39;t do classic C-style for loops with <code>i++</code> since <code>i</code> is immutable. Python programmers should be familiar with generators, which work the same way in Elixir:
        </p><p>
        However, many times when you&#39;re reaching for a loop, it&#39;s because you want to iterate over some data and update it. In that case, you&#39;ll want to reach for the <code>Enum.map</code> and <code>Enum.reduce</code> functions.
        </p><p><code>Enum.map</code> applies a function to every value in a data structure and <code>Enum.reduce</code> produces an accumulated value for a function applied to every value in a data structure.
        </p><p>
        This might seem intimidating at first, but it becomes intuitive and convenient very quickly. There are also other useful functions of a similar nature in the <code>Enum</code> and <code>Map</code> modules in the standard library.
        </p><h2>
        Pattern Matching
        </h2><p>
        For cases which are more complex than a binary <code>if</code> statement, you can use the <code>case</code> statement. This brings us to the next major Elixir concept: pattern matching. This concept goes deep into the heart of Elixir - so much so that <code>=</code> isn&#39;t technically an assignment operator, but rather a match operator. If that doesn&#39;t make sense yet, that&#39;s okay, hopefully it will become clear by example. So, let&#39;s look at the <code>case</code> operator:
        </p><p>
        This example shows that we can create highly readable control flow without the need for messy if-and statements. The <code>_</code> or anything prefixed with <code>_</code> represents an unused variable, in this case the condition that nothing else matches.
        </p><p>
        The idea of pattern matching extends further than just control flow and applies to function definitions as well. For instance, this example from the Elixir documentation:
        </p><p>
This shows a few things to take note of. The function executed actually matches on the contents of the arguments passed in. When those things are variables, it can match on those things conditionally. When those variables don&#39;t match, the function is never executed at all.
        </p><p>
You&#39;ll this pattern a lot when creating your LiveView applications, like when handling different types of info events from another process:
        </p><h2>
        ETS
        </h2><p>
Another very cool thing I feel compelled to mention is ETS - Erlang Term Storage, which will let your store and retrieve in-memory data from anywhere in your application. It&#39;s like having a built in Redis server! It&#39;s great for caching data or for anything you&#39;d need to share between your processes.
        </p><p>
        Simple! ETS is incredibly handy and I use it all the time, particularly for tracking process IDs and dynamic configuration. I use it as an in-memory store, but you can easily configure it to use disk storage instead.
        </p><h2>
        GenServer
        </h2><p>
        One common use of ETS is to keep track of the process IDs of any processes you might be spawning. I mentioned how vital these processes are in Elixir, so let&#39;s see an example.
        </p><p>
        Most of the time, you&#39;ll be using GenServer, or generic server processes. These are a special type of process which implement standard functions you&#39;ll need for a client/server model. Here, we see a simple Key/Value store.
        </p><p>
        Then, to start it with an empty Map:
        </p><p>
        And to interact with it:
        </p><p>
If we store that PID in ETS, then we can retrieve it from anywhere else in the system and use the process at any time from anywhere. Cool! If we&#39;re running it inside of Phoenix, we can also start it at runtime by adding <code>{KeyValue, %{}},</code> to our <code>application.ex</code>, which defines all of the processes which start when the application launches.
        </p><h2>
        Phoenix LiveView
        </h2><p>
Okay, now you&#39;ve gotten a sense of the language, let&#39;s take a look at what you&#39;re really here for - Phoenix LiveView. If you just want a traditional web application, you don&#39;t have to use Phoenix with LiveView if you don&#39;t want to, but if you&#39;re reading this article then you probably do want to use LiveView, so we&#39;re going to dive straight in to it.
        </p><p>
I&#39;ll skip most of the the installing-Elixir stuff (just use your system&#39;s package manager), but I&#39;ll quickly say that Elixir ships with its own build tool called <code>mix</code>, which will act like <code>pip</code> and <code>django-admin</code> for our purposes. Package management seems a bit more sane than with <code>pip</code>, everything just gets installed to a local <code>deps</code> directory, so there&#39;s no need to deal with virtual environments. All the packages live on a service called Hex, which is like PyPI.
        </p><p>
        As we mentioned before, a LiveView application maintains a lightweight WebSocket connection to each client, every interaction with the page goes through a websocket, which automatically returns with a diff that is automatically applied to the client&#39;s page without a page reload.
        </p><p>
We&#39;re going to build a very simple lightswitch app, so let&#39;s start a new project by running <code>mix phx.new light_switch</code>.
        </p><h2>
        A Simple Example
        </h2><p>
        In the file <code>lib/light_switch/live/light_live.ex</code>, put:
        </p><p>
        and in <code>lib/light_switch/live/light_live.heex</code> (yes, templates can live in the same directory), put:
        </p><p>
        When we run the server and open our browser, we&#39;ll see a some buttons that will allow us to toggle the status of the light on and off. But what&#39;s going on here?
        </p><p>
        The first thing you&#39;ll see is the <code>mount</code> function. This is where the page is first loaded. In a LiveView, this function is actually executed twice - once when the basic HTTP page is loaded, and the once again when the WebSocket connection is initialized. (If you need to do different behaviors for each phase, use <code>connected?(socket)</code> to see if the WebSocket connection is established or not.)
        </p><p>
        The state of our interface is handled by assigning values to the socket, called &#34;assigns&#34;. These values can be assigned at any time, so whenever we send a <code>:noreply</code> back with an updated socket, that change will be reflected in the interface.
        </p><p>
        Next we see some <code>handle_event</code> functions. These are invoked from the client, in this case from <code>phx-click</code> events on buttons, but they can come from lots of other sources as well and are handled in the same way.
        </p><h2>
        Templates
        </h2><p>
        Just like the Django Template Language, Phoenix has its own template language. In fact, it&#39;s got a few: <code>Eex</code>, <code>Leex</code> and <code>Heex</code>. This is honestly kind of annoying, as Heex is pretty new and some older tutorials you might find will only use Leex, which has a slightly different syntax. Heex is the future, so just use Heex everywhere and forget about the others.
        </p><p>
        At first glance, Heex seems a lot less featureful than the Django Template Language, but it&#39;s ultimately more powerful since it can execute arbitrary Elixir but the Django Template Language can&#39;t execute arbitrary Python.
        </p><p>
        In our template, we see some ordinary HTML mixed with some Heex. Unlike Django templates, where only a subset of commands can be executed inside <code>{{ }}</code> tags, any Elixir code can be put inside <code>&lt;%=  %&gt;</code> tags, or <code>{ }</code> tags on DOM element properties. Variables assigned to your sockets will be accessible by prefixing an <code>@</code>.
        </p><p>
        So, in this example, we see the light state and two buttons, one of which will be <code>disabled</code> depending on the state of <code>bulb_on</code>. When we press the On button, <code>phx-click=&#34;on&#34;</code> is executed and <code>handle_event(&#34;on&#34;, _value, socket)</code> is executed on the server. We update the value assigned to the socket, which then gets sent back to the client and the values on the interface are updated.
        </p><h2>
        Template Inheritance and Components
        </h2><p>
        In Django, it&#39;s very common to have nested templates which <code>extend</code> each other. I&#39;ve found that this approach doesn&#39;t translate very well to Phoenix, and it&#39;s best to forget about extending templates at all. Instead, it&#39;s better to build reusable &#34;Components&#34; and use those where possible. So, rather than having a &#34;DashboardBase&#34; template that all of your sub-pages extend, it&#39;s better to build <code>TopBar</code> and <code>SideBar</code> components, and to use those where needed inside of a scaffold.
        </p><p>
        For instance, if we want to show a user in a list of users, we&#39;d make a <code>render_user</code> component:
        </p><p>
        (Note that <code>~H</code> is called a &#34;sigil&#34; - it just a way to say in our code that the following string is Heex.)
        </p><p>
        We&#39;d use in a template like this:
        </p><p>
        Not only does this make it easier to re-use code all over your application, it&#39;s actually more performant for very long lists.
        </p><h2>
        Ecto
        </h2><p>
        One of Django&#39;s primary strengths is the Django ORM, the object relational mapper, which is used to translate calls between Python objects and items in a database table. In Elixir/Phoenix, you&#39;ll be using an ORM called <code>Ecto</code> to handle your models and database calls.
        </p><p>
        Now we&#39;ll be able to use the <code>Repo</code> - which is created at runtime to provide our interface to the database - to fetch our objects, like so: <code>ted = Repo.get_by(User, username: &#34;ted&#34;)</code>.
        </p><p>
        You&#39;ll also see a <code>changeset</code> function. Changesets provide a pipeline for validating and manipulating data before it&#39;s stored in the database. From the documentation:
        </p><blockquote><p>
                    Changesets define a pipeline of transformations our data needs to undergo before it will be ready for our application to use. These transformations might include type-casting, user input validation, and filtering out any extraneous parameters. Often we&#39;ll use changesets to validate user input before writing it to the database. Ecto repositories are also changeset-aware, which allows them not only to refuse invalid data, but also perform the minimal database updates possible by inspecting the changeset to know which fields have changed.
                </p></blockquote><p>
        This changset is used by our <code>create_user</code> function, which we&#39;d use like <code>User.create_user(%{username: &#34;ted&#34;, bulb_on: false})</code>. If any of the fiends in <code>validate_required</code> aren&#39;t available, our user won&#39;t be created.
        </p><h2>
        Migrations
        </h2><p>
        One of the more annoying things about Phoenix coming from Django is the lack of <code>django-admin makemigrations</code>. Ecto makes you define migrations on your own. There is a <code>mix</code> function to make the file for you, but you have to define the changes manually. So, we&#39;d run something like <code>mix ecto.gen.migration add_users_table</code>. It&#39;ll make the file for us, but we&#39;ll have to define the contents ourselves:
        </p><p>
        It&#39;s annoying but not too bad. One thing to watch out for is foreign keys, where your migration will need to define a field like <code>add :user_owner_id, references(:users)</code> but the object schema definition drops the <code>_id</code>, so it&#39;s just <code>belongs_to :user_owner, User</code>.
        </p><h2>
        More Advanced Queries
        </h2><p>
        Of course, can write more complex queries than just fetching by a value. Somewhat annoyingly, there are a two different ways of doing that - &#34;keyword-based&#34; and &#34;macro-based&#34;. A keyword-based query looks like this:
        </p><p>
        and a macro-based query looks like this:
        </p><p>
        It&#39;s the same thing under the hood, I don&#39;t know why they did this. I think keyword-based queries are more common in examples, so maybe just use them.
        </p><h2>
        PubSub and Presence
        </h2><p>
One extremely useful thing that Phoenix provides is an internal PubSub mechanism, which allows a process - which for a LiveView, corresponds to a user&#39;s connection - to subscribe and publish to a stream of events. So in the <code>mount</code> function of our light-switch viewer, we can..
        </p><p>
        Then, we can send information on this channel to anybody subscribed to it like this:
        </p><p>
        and receive information by defining a function like this:
        </p><p>
        Now if we have &lt;%= @switch_count =&gt; in our template, the user&#39;s interface will be updated in real time whenever a a switch count message comes over the PubSub.
        </p><p>
        Phoenix also provides a special case called <code>Presence</code> which operates the same way, but provides some handy extra information related to user connections. This makes it perfect showing, for instance, how many users are currently browsing a page.
        </p><h2>
        Other Things I Should Mention
        </h2><p>
        We&#39;re getting close to wrapping up here, but here&#39;s a quick dump of things I should mention but couldn&#39;t fit anywhere else.
        </p><p>
        • Different functions can have the same name but take a different number of arguments. This is called &#34;arity&#34;. For instance, <code>String.split/2</code> has an arity of two. You get used it it.
        </p><p>
        • There is a REPL, it&#39;s called <code>iex</code>. It&#39;s okay.
        </p><p>
        • Strings are joined like this: <code>&#34;Hello &#34; &lt;&gt; &#34;World&#34;</code></p><p>
        • Lists are joined like this: <code>[1,2,3] ++ [4,5,6]</code></p><p>
        • and are subtracted like this: <code>[1,2,3,4,5,6] -- [2,4,6]</code></p><p>
        • Rather than <code>import pdb; pdb.set_trace()</code>, there&#39;s <code>require IEx; IEx.pry()</code>, but you&#39;ll have to make sure that you call your server with <code>iex -S mix phx.server</code> rather than just <code>mix phx.server</code>.
        </p><p>
        • If you use IceCream for debugging, there&#39;s an IceCream for Elixir. It&#39;s also called IceCream.
        </p><p>
        • Functions can have default arguments with <code>\\</code>, like so: <code>def funky(options \\ [])</code>. However, this can be annoying if you have multiple keyword arguments, so you can this pattern instead:
        </p><h2>
        In Conclusion
        </h2><p>
            Okay, well there you have it, a brain-dump of Elixir for Python programmers!
        </p><p>
        There&#39;s plenty more I&#39;d like to discuss, so if there&#39;s interest, I&#39;ll do a follow-up post covering things like releasing, deploying, clustering, and scaling, as well anything else I&#39;ve forgotten that I should have included here.
        </p><p><b>If you want to see a LiveView application in action, try Hibox!</b></p><p>
          A Hibox is a little snippet of JavaScript that you put on your website that lets you video chat with your visitors. In your Hibox dashboard, you&#39;ll see a Live interface of all of your website&#39;s visitors in real-time, and you&#39;ll be able to filter and sort them all without reloading the page. When you see a high-value sales opportunity, press the button to start a video call with that visitor and start selling!
        </p><p>
          It&#39;s totally free to try for 30 days, and it&#39;s only one-click to unsubscribe if it doesn&#39;t pay for itself.
        </p><p>
        Cheers!
        </p><div><p><a href="https://blog.plover.com/#pricing">Try Hibox for Free</a></p></div></div></section><section><div><div><h3>:) Hibox</h3><p>
          Made with ☕ in western Norway.
        </p></div><div><h3>Quick Links</h3><ul><li><a href="https://blog.plover.com/#pricing">Sign Up</a></li><li><a href="https://blog.plover.com/embed">Documentation</a></li><li><a href="https://blog.plover.com/#pricing">Pricing</a></li><li><a href="https://blog.plover.com/features">Features</a></li><li><a href="mailto:hi@hibox.live">Contact and Support</a></li><li><a href="https://blog.plover.com/security">Security</a></li><li><a href="https://blog.plover.com/terms">Terms and Conditions</a></li><li><a href="https://blog.plover.com/about_us">About Us</a></li></ul><h3>Useful Pages</h3><ul><li><a href="https://blog.plover.com/how-to-convert-more-paid-traffic">How to Convert More Paid Traffic</a></li><li><a href="https://blog.plover.com/how-to-get-feedback-for-your-startup">How to Get Feedback for Your Startup</a></li><li><a href="https://blog.plover.com/nerd-stuff">Nerd Stuff</a></li></ul></div><div><h3>Contact Us</h3><p>Reach us any time at <b>hi@hibox.live</b></p><div><p>
            Jones Digital </p></div></div></div><p>
  © 2023 Jones Digital. All rights reserved.
</p></section></div></div>
  </body>
</html>
