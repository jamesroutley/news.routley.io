<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/">Original</a>
    <h1>Tracking Java native memory with JDK flight recorder</h1>
    
    <div id="readability-page-1" class="page"><div>
		






		<div id="main-content">
			

			<div>
				<p>As regular readers of this blog will now, <a href="https://openjdk.org/jeps/328">JDK Flight Recorder</a> (JFR) is one of my favorite tools of the Java platform.
This low-overhead event recording engine built into the JVM is invaluable for observing the runtime characteristics of Java applications and identifying any potential performance issues.
JFR continues to become better and better with every new release,
with one recent addition being support for native memory tracking (NMT).</p>
<p><a href="https://docs.oracle.com/en/java/javase/21/vm/native-memory-tracking.html">NMT</a> by itself is not a new capability of the JVM:
it provides you with detailed insight into the memory consumption of your application,
which goes way beyond the well-known Java heap space.
NMT tells you how much memory the JVM uses for class metadata, thread stacks, the JIT compiler, garbage collection, memory-mapped files, and much more
(the one thing which NMT does not report, despite what the name might suggest, is any memory allocated by native libraries, for instance invoked via JNI).
To learn more about NMT, I highly recommend to read the excellent post <a href="https://blog.arkey.fr/2020/11/30/off-heap-reconnaissance/">Off-Heap memory reconnaissance</a> by Brice Dutheil.</p>
<p>Until recently, in order to access NMT,
you’d have to use the <a href="https://docs.oracle.com/en/java/javase/21/docs/specs/man/jcmd.html"><em>jcmd</em></a> command line tool for capturing the values of a running JVM in an ad-hoc way.
Whereas since Java 20,
you can record NMT data continuously with JFR,
thanks to two new JFR event types added for this purpose.
This makes it much easier to collect that data over a longer period of time and analyze it in a systematic way.
You could also expose a live stream of NMT data to remote clients via <a href="https://openjdk.org/jeps/349">JFR event streaming</a>,
for instance for integration with dashboards and monitoring solutions.</p>
<div>
<table>
<tbody><tr>
<td>
<i title="Note"></i>
</td>
<td>
<p>The list of JFR event types grows with every release.
If you’d like to learn which event types are available in which Java version, take a look at the <a href="https://sap.github.io/SapMachine/jfrevents/">JFR Events</a> list compiled by <a href="https://twitter.com/parttimen3rd">Johannes Bechberger</a> from the <a href="https://sapmachine.io">Java team at SAP</a>.
It also shows you the events added in a particular version, for instance <a href="https://sap.github.io/SapMachine/jfrevents/21.html">here</a> for the new events in Java 21.</p>
</td>
</tr>
</tbody></table>
</div>
<div>
<h2 id="_an_example">An Example</h2>
<div>
<p>So let’s see how NMT data is reported via JFR.
Here’s a simple example program which allocates some off heap memory,
once using a good old <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html#direct-vs-non-direct-buffers-heading">direct byte buffer</a>,
and once using the new <a href="https://openjdk.org/jeps/454">Foreign Memory API</a>,
finalized in Java 22 with JEP 454
(it feels <em>so</em> nice to be able to allocate 4GB at once, something you couldn’t do before):</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td><pre><span>import</span> <span>java.nio.ByteBuffer</span><span>;</span>
<span>import</span> <span>java.lang.foreign.Arena</span><span>;</span>
<span>import</span> <span>java.lang.foreign.MemorySegment</span><span>;</span>

<span>import</span> <span>static</span> <span>java</span><span>.</span><span>time</span><span>.</span><span>LocalDateTime</span><span>.</span><span>now</span><span>;</span>

<span>public</span> <span>void</span> <span>main</span><span>()</span> <span>throws</span> <span>Exception</span> <span>{</span>
  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>STR</span><span>.</span><span>&#34;\{ now() } Started&#34;</span><span>);</span>
  <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>);</span>

  <span>ByteBuffer</span> <span>buffer</span> <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocateDirect</span><span>(</span><span>1024</span> <span>*</span> <span>1024</span> <span>*</span> <span>1024</span><span>);</span>
  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>STR</span><span>.</span><span>&#34;\{ now() } Allocated (Direct)&#34;</span><span>);</span>
  <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>);</span>

  <span>try</span> <span>(</span><span>Arena</span> <span>arena</span> <span>=</span> <span>Arena</span><span>.</span><span>ofConfined</span><span>())</span> <span>{</span>
    <span>MemorySegment</span> <span>segment</span> <span>=</span> <span>arena</span><span>.</span><span>allocate</span><span>(</span><span>4L</span> <span>*</span> <span>1024L</span> <span>*</span> <span>1024L</span> <span>*</span> <span>1024L</span><span>);</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>STR</span><span>.</span><span>&#34;\{ now() } Allocated (FMI)&#34;</span><span>);</span>
    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>);</span>
  <span>}</span>

  <span>buffer</span> <span>=</span> <span>null</span><span>;</span>
  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>STR</span><span>.</span><span>&#34;\{ now() } Deallocated&#34;</span><span>);</span>
  <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>JFR records NMT events every second by default,
so I’ve sprinkled in some <code>sleep()</code> calls to make sure the program runs long enough and the different allocations are spread out a bit.
Just for the fun of it, I’m also using a top-level main method—as supported by <a href="https://openjdk.org/jeps/463">JEP 463</a>—and string templates for the log messages (<a href="https://openjdk.org/jeps/459">JEP 459</a>).</p>
<p>Let’s run this and see how those off-heap allocations are tracked by JFR.
Somewhat surprisingly, NMT in JFR is controlled via the <code>gc</code> setting, which must be set to a value of &#34;normal&#34;, &#34;detailed&#34;, &#34;high&#34;, or &#34;all&#34; for recording NMT data.
This is the case for the <em>default</em> and <em>profile</em> JFR configurations which ship with the SDK,
so using either configuration will give you the NMT data.
Note though that in addition, NMT itself must be enabled using the <code>-XX:NativeMemoryTracking</code> JVM option:</p>
<div>
<div>
<pre><code data-lang="bash"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td><pre>java <span>--enable-preview</span> <span>--source</span> 22 <span>\</span>
  <span>-XX</span>:StartFlightRecording<span>=</span><span>name</span><span>=</span>Profiling,filename<span>=</span>nmt-recording.jfr,settings<span>=</span>profile <span>\</span>
  <span>-XX</span>:NativeMemoryTracking<span>=</span>detail main.java
<span>[</span>0.316s][info][jfr,startup] Started recording 1. No limit specified, using <span>maxsize</span><span>=</span>250MB as default.
<span>[</span>0.316s][info][jfr,startup]
<span>[</span>0.316s][info][jfr,startup] Use jcmd 47194 JFR.dump <span>name</span><span>=</span>Profiling to copy recording data to file.
2023-12-17T18:31:00.475598 Started
2023-12-17T18:31:05.609319 Allocated <span>(</span>Direct<span>)</span>
2023-12-17T18:31:11.167484 Allocated <span>(</span>FMI<span>)</span>
2023-12-17T18:31:16.253059 Deallocated
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Let’s open the recording in JDK Mission Control and see what we find.
As of version 8.3, JMC doesn’t have a bespoke view for displaying NMT data,
but the NMT events show up in the generic event browser view.
There are two event types, the first one being <a href="https://sap.github.io/SapMachine/jfrevents/#nativememoryusagetotal">&#34;Total Native Memory Usage&#34;</a>:</p>
<div>
<p><img src="https://www.morling.dev/images/nmt_jfr_total.png" alt="nmt jfr total"/>
</p>
</div>
<p>The two off-heap allocations of 1 GB (direct byte buffer) and 4 GB (Foreign Memory API) show up as expected as increases to the reserved and committed memory of the program.
We also see one of the advantages of the new Foreign Memory API:
the memory is deallocated as soon as the <code>Arena</code> object is closed,
whereas the JVM holds on to the memory of the byte buffer also after discarding the reference.
There’s no control over when this memory will be released exactly,
it will be done via a <a href="https://stackoverflow.com/questions/36077641/java-when-does-direct-buffer-released">phantom-reference-based cleaner</a> some time after the GC has removed the associated buffer object.</p>
<p>The second new event type, <a href="https://sap.github.io/SapMachine/jfrevents/#nativememoryusage">&#34;Native Memory Usage Per Type&#34;</a>, provides a more fine grained view (when setting <code>-XX:NativeMemoryTracking</code> to <code>detail</code> rather than <code>summary</code>).
The off-heap allocations show up under the &#34;Other&#34; category there:</p>
<div>
<p><img src="https://www.morling.dev/images/nmt_jfr_per_type.png" alt="nmt jfr per type"/>
</p>
</div>
<p>As per the docs, NMT will cause a performance overhead of 5% - 10%
(how large the overhead actually is, <a href="https://stackoverflow.com/questions/73126185/what-is-overhead-of-java-native-memory-tracking-in-summary-mode/73167790">depends a lot</a> on the specific workload),
so it’s probably not something you’d want to do permanently in a production setting.
Luckily, Java 21 adds another JFR event type, <a href="https://sap.github.io/SapMachine/jfrevents/#residentsetsize">&#34;Resident Set Size&#34;</a> (RSS), which allows you to track the overall memory consumption of your application on an ongoing basis:</p>
<div>
<p><img src="https://www.morling.dev/images/nmt_jfr_rss.png" alt="nmt jfr rss"/>
</p>
</div>
<p>Of course you can retrieve the RSS, i.e. the physical memory allocated by a process, also using other tools like <code>ps</code>,
but recording it via JFR makes it really simple to analyze its development over time,
and also allows you to correlate it with other relevant JFR events, for instance for class (un-)loading or garbage collection.</p>
<p>With JFR event streaming, you could also expose a live feed of the value to remote monitoring clients,
allowing you to keep track visually using a dashboard.
But you also could apply some kind of pattern matching to this time series of values,
triggering an alert when it continues to grow also after the application’s warm-up phase.</p>
<p>I am planning to explore how to do this with a bit of SQL using <a href="https://github.com/moditect/jfr-analytics">JFR Analytics</a> in a future blog post.</p>
</div>
</div>
			</div>

			
		</div>


</div></div>
  </body>
</html>
