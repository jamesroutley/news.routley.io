<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/">Original</a>
    <h1>Tracking Java native memory with JDK flight recorder</h1>
    
    <div id="readability-page-1" class="page"><p>So let’s see how NMT data is reported via JFR.
Here’s a simple example program which allocates some off heap memory,
once using a good old <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html#direct-vs-non-direct-buffers-heading">direct byte buffer</a>,
and once using the new <a href="https://openjdk.org/jeps/454">Foreign Memory API</a>,
finalized in Java 22 with JEP 454
(it feels <em>so</em> nice to be able to allocate 4GB at once, something you couldn’t do before):</p><div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td><pre><span>import</span> <span>java.nio.ByteBuffer</span><span>;</span>
<span>import</span> <span>java.lang.foreign.Arena</span><span>;</span>
<span>import</span> <span>java.lang.foreign.MemorySegment</span><span>;</span>

<span>import</span> <span>static</span> <span>java</span><span>.</span><span>time</span><span>.</span><span>LocalDateTime</span><span>.</span><span>now</span><span>;</span>

<span>public</span> <span>void</span> <span>main</span><span>()</span> <span>throws</span> <span>Exception</span> <span>{</span>
  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>STR</span><span>.</span><span>&#34;\{ now() } Started&#34;</span><span>);</span>
  <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>);</span>

  <span>ByteBuffer</span> <span>buffer</span> <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocateDirect</span><span>(</span><span>1024</span> <span>*</span> <span>1024</span> <span>*</span> <span>1024</span><span>);</span>
  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>STR</span><span>.</span><span>&#34;\{ now() } Allocated (Direct)&#34;</span><span>);</span>
  <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>);</span>

  <span>try</span> <span>(</span><span>Arena</span> <span>arena</span> <span>=</span> <span>Arena</span><span>.</span><span>ofConfined</span><span>())</span> <span>{</span>
    <span>MemorySegment</span> <span>segment</span> <span>=</span> <span>arena</span><span>.</span><span>allocate</span><span>(</span><span>4L</span> <span>*</span> <span>1024L</span> <span>*</span> <span>1024L</span> <span>*</span> <span>1024L</span><span>);</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>STR</span><span>.</span><span>&#34;\{ now() } Allocated (FMI)&#34;</span><span>);</span>
    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>);</span>
  <span>}</span>

  <span>buffer</span> <span>=</span> <span>null</span><span>;</span>
  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>STR</span><span>.</span><span>&#34;\{ now() } Deallocated&#34;</span><span>);</span>
  <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div><p>JFR records NMT events every second by default,
so I’ve sprinkled in some <code>sleep()</code> calls to make sure the program runs long enough and the different allocations are spread out a bit.
Just for the fun of it, I’m also using a top-level main method—as supported by <a href="https://openjdk.org/jeps/463">JEP 463</a>—and string templates for the log messages (<a href="https://openjdk.org/jeps/459">JEP 459</a>).</p><p>Let’s run this and see how those off-heap allocations are tracked by JFR.
Somewhat surprisingly, NMT in JFR is controlled via the <code>gc</code> setting, which must be set to a value of &#34;normal&#34;, &#34;detailed&#34;, &#34;high&#34;, or &#34;all&#34; for recording NMT data.
This is the case for the <em>default</em> and <em>profile</em> JFR configurations which ship with the SDK,
so using either configuration will give you the NMT data.
Note though that in addition, NMT itself must be enabled using the <code>-XX:NativeMemoryTracking</code> JVM option:</p><div>
<div>
<pre><code data-lang="bash"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td><pre>java <span>--enable-preview</span> <span>--source</span> 22 <span>\</span>
  <span>-XX</span>:StartFlightRecording<span>=</span><span>name</span><span>=</span>Profiling,filename<span>=</span>nmt-recording.jfr,settings<span>=</span>profile <span>\</span>
  <span>-XX</span>:NativeMemoryTracking<span>=</span>detail main.java
<span>[</span>0.316s][info][jfr,startup] Started recording 1. No limit specified, using <span>maxsize</span><span>=</span>250MB as default.
<span>[</span>0.316s][info][jfr,startup]
<span>[</span>0.316s][info][jfr,startup] Use jcmd 47194 JFR.dump <span>name</span><span>=</span>Profiling to copy recording data to file.
2023-12-17T18:31:00.475598 Started
2023-12-17T18:31:05.609319 Allocated <span>(</span>Direct<span>)</span>
2023-12-17T18:31:11.167484 Allocated <span>(</span>FMI<span>)</span>
2023-12-17T18:31:16.253059 Deallocated
</pre></td></tr></tbody></table></code></pre>
</div>
</div><p>Let’s open the recording in JDK Mission Control and see what we find.
As of version 8.3, JMC doesn’t have a bespoke view for displaying NMT data,
but the NMT events show up in the generic event browser view.
There are two event types, the first one being <a href="https://sap.github.io/SapMachine/jfrevents/#nativememoryusagetotal">&#34;Total Native Memory Usage&#34;</a>:</p><p>The two off-heap allocations of 1 GB (direct byte buffer) and 4 GB (Foreign Memory API) show up as expected as increases to the reserved and committed memory of the program.
We also see one of the advantages of the new Foreign Memory API:
the memory is deallocated as soon as the <code>Arena</code> object is closed,
whereas the JVM holds on to the memory of the byte buffer also after discarding the reference.
There’s no control over when this memory will be released exactly,
it will be done via a <a href="https://stackoverflow.com/questions/36077641/java-when-does-direct-buffer-released">phantom-reference-based cleaner</a> some time after the GC has removed the associated buffer object.</p><p>The second new event type, <a href="https://sap.github.io/SapMachine/jfrevents/#nativememoryusage">&#34;Native Memory Usage Per Type&#34;</a>, provides a more fine grained view (when setting <code>-XX:NativeMemoryTracking</code> to <code>detail</code> rather than <code>summary</code>).
The off-heap allocations show up under the &#34;Other&#34; category there:</p><p><em>Update Dec 18:</em> As OpenJDK developer Eric Gahlin <a href="https://twitter.com/ErikGahlin/status/1736530559231201484">pointed out</a>,
you also can take a high-level view at the NMT events of a recording using the JDK’s <em>jfr</em> tool,
which provides two <a href="https://egahlin.github.io/2023/05/30/views.html">built-in views</a> for committed and reserved memory:</p><div>
<div>
<pre><code data-lang="bash"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td><pre><span>$JAVA_HOME</span>/bin/jfr view native-memory-committed recording.jfr

                            Native Memory Committed

Memory Type                    First Observed   Average Last Observed   Maximum
<span>------------------------------</span> <span>--------------</span> <span>---------</span> <span>-------------</span> <span>---------</span>
Other                                  1,8 MB    1,7 GB        1,0 GB    5,0 GB
Java Heap                            136,0 MB  136,0 MB      136,0 MB  136,0 MB
GC                                    54,2 MB   54,2 MB       54,2 MB   54,2 MB
Metaspace                             16,0 MB   16,0 MB       16,1 MB   16,1 MB
Tracing                               15,6 MB   15,7 MB       15,7 MB   15,7 MB
Code                                  12,6 MB   12,6 MB       12,6 MB   12,6 MB
Shared class space                    12,4 MB   12,4 MB       12,4 MB   12,4 MB
Arena Chunk                            8,5 MB    2,2 MB        2,0 kB    8,5 MB
Symbol                                 5,8 MB    5,8 MB        5,8 MB    5,8 MB
Class                                  2,7 MB    2,7 MB        2,7 MB    2,7 MB
Native Memory Tracking                 1,7 MB    1,7 MB        1,7 MB    1,7 MB
Synchronization                        1,2 MB    1,2 MB        1,2 MB    1,2 MB
Internal                             563,4 kB  561,9 kB      561,7 kB  563,4 kB
Compiler                             202,9 kB  206,4 kB      205,6 kB  238,5 kB
Module                               174,1 kB  174,1 kB      174,1 kB  174,1 kB
Thread                                86,0 kB   82,5 kB       81,4 kB   86,0 kB
Safepoint                             32,0 kB   32,0 kB       32,0 kB   32,0 kB
GCCardSet                             29,5 kB   29,5 kB       29,5 kB   29,5 kB
Serviceability                        17,6 kB   17,6 kB       17,6 kB   17,6 kB
Object Monitors                        1,0 kB    1,0 kB        1,0 kB    1,0 kB
String Deduplication                608 bytes 608 bytes     608 bytes 608 bytes
Arguments                           185 bytes 185 bytes     185 bytes 185 bytes
Statistics                          128 bytes 128 bytes     128 bytes 128 bytes
Logging                              32 bytes  32 bytes      32 bytes  32 bytes
Test                                  0 bytes   0 bytes       0 bytes   0 bytes
JVMCI                                 0 bytes   0 bytes       0 bytes   0 bytes
Thread Stack                          0 bytes   0 bytes       0 bytes   0 bytes
</pre></td></tr></tbody></table></code></pre>
</div>
</div></div>
  </body>
</html>
