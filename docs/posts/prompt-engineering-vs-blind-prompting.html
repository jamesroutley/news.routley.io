<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mitchellh.com/writing/prompt-engineering-vs-blind-prompting">Original</a>
    <h1>Prompt engineering vs. blind prompting</h1>
    
    <div id="readability-page-1" class="page"><div><p>&#34;Prompt Engineering&#34; emerged from the growth of language models to describe
the process of applying prompting to effectively extract information
from language models, typically for use in real-world applications.</p>
<p>A lot of people who claim to be doing prompt engineering today are
actually just <em>blind prompting.</em><sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup> &#34;Blind Prompting&#34; is a term I am using
to describe the method of creating prompts with a crude trial-and-error
approach paired with minimal or no testing and a very surface level
knowedge of prompting. <em>Blind prompting is not prompt engineering.</em></p>
<p>There is also a lot of skepticism about whether prompt engineering
can truly be described as &#34;engineering&#34; or if it&#39;s just
<a target="_blank" rel="noopener noreferrer" href="https://news.ycombinator.com/item?id=35524725">&#34;witchcraft&#34;</a> spouted by
hype-chasers.  I think in most cases the skepticism is rooted
in the fact that a lot of tweets and blog posts I&#39;ve seen claiming to
be on prompt engineering are really at best a thin layer above
blind prompting.</p>
<p>In this blog post, I will make the argument that prompt engineering
is a real skill that can be developed based on real experimental
methodologies. I will use a realistic example to walk through the
process of prompt engineering a solution to a problem that provides
practical value to an application.</p>
<div><p>This whole post will be biased towards expecting text output, since
text output is the primary use case I&#39;ve had with language models. Certain
techniques -- such as the testing techniques -- don&#39;t translate 1:1 to
other types of outputs such as images. Everything in this post does work
well for multi-modal <em>inputs</em>, however.</p></div>
<details open=""><summary>Table of Contents</summary></details>
<hr/>

<p>Feel free to skip this section if you&#39;re already very familiar with
the term &#34;prompting&#34; or understand what a &#34;prompt&#34; is.</p>
<p>For language models (imagine ChatGPT if this term is unfamiliar to you),
the <strong>&#34;prompt&#34;</strong> is the user-generated input to the model. In ChatGPT, it can
effectively be understood as the text box you type in. The language model
then &#34;infers&#34; a &#34;completion&#34; to your prompt. For example, if I type &#34;4 + 3 = &#34;
in ChatGPT, it will respond with &#34;7&#34; (probably). In this case, &#34;4 + 3 = &#34;
is the prompt, and &#34;7&#34; is the completion.</p>
<p><strong>&#34;Prompting&#34;</strong> is the act of using prompts as a way to extract desired information
from a model. It is an attractive approach to extracting information because
you don&#39;t need a large offline training set, you don&#39;t need offline access
to a model, and it feels intuitive even for non-engineers. Prompting is just
<a target="_blank" rel="noopener noreferrer" href="https://huyenchip.com/2023/04/11/llm-engineering.html#prompting_vs_finetuning_vs_alternatives">one method to tune a model</a>.</p>
<p>Finally, <strong>&#34;prompt engineering&#34;</strong> describes a more rigorous discipline (as
will be shown in this post) that aims to utilize prompting as a way to
build reliable functionality for real-world applications. It differs from
ChatGPT-style prompting because the prompts generated through prompt engineering
are usually meant to be used repeatedly in high-volume, diverse situations
in order to solve a specific problem reliably for an application.</p>
<hr/>

<p>To start, you must have a problem you&#39;re trying to build a solution for.
The problem can be used to assess whether prompting is the best solution
or if alternative approaches exist that may be better suited as a solution.
Engineering starts with not using a method for the method&#39;s sake, but
driven by the belief that it is the <em>right method</em>.</p>
<p>For this example, we will pretend that we&#39;re a company that builds a
calendar client. We&#39;d like users to be able to enter events using natural
language. For example:</p>
<blockquote>
<p>Dinner with Alice next Tuesday at Taco Bell</p>
</blockquote>
<blockquote>
<p>CorpConf on 11/4</p>
</blockquote>
<blockquote>
<p>1:1 with Bob tomorrow at 10 AM</p>
</blockquote>
<p>Language models might be a good solution to take this natural language
input and extract structured output to describe the event that we can then
use within our application.</p>
<p>There are obviously other potential solutions. We can utilize a set of
<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>
and string search to look for common phrases (<code>on &lt;Day of Week&gt;</code>, <code>tomorrow</code>,
<code>today</code>, <code>next week</code>, etc.).</p>
<p>Language models have their own benefits: they might
provide an approach that handles other languages better, or might
handle typos or grammatical errors better, or may at worst be a good
backstop if regular expressions fail. In any case, there is enough promise
to continue pursuing prompting as a potential solution.</p>
<hr/>

<p>Next, we have to put together a demonstration set. The demonstration set
contains an expected input along with an expected output. This set will serve
multiple goals:</p>
<ol>
<li>
<p>It will be used to measure the accuracy of our prompt. By using the
input of a single demonstration, we can assert that we receive the expected
output.</p>
</li>
<li>
<p>It specifies what we expect the prompt inputs and outputs to look like,
allowing us as engineers to determine if it is the right shape for our problem.</p>
</li>
<li>
<p>We can use a subset of this demonstration set as exemplars for
a few-shot approach if we choose to use a few-shot prompt. For those
unfamiliar with the term &#34;few-shot&#34;, few-shot is a style of prompt where
examples are given in addition to the prompt. See <a target="_blank" rel="noopener noreferrer" href="https://www.promptingguide.ai/techniques/fewshot">here for a good overview of Few-Shot vs
Zero-Shot prompting</a>.</p>
</li>
</ol>
<p>Point (2) above is extremely important. We need to have some general
understanding of what input we expect and what output we expect, because
on both sides of this is [usually] software that needs to ensure the data
is in a certain format and will expect a certain format back out.
This is no different from typical software engineering where we decompose
a problem into a set functions that have some input/output expectations.</p>
<p>We can utilize our examples from before and expand them to be complete
demonstrations:</p>
<div><pre><code><span>Q: Dinner with Alice next Tuesday at Taco Bell
</span><span>A: next Tuesday
</span><span>
</span><span>Q: CorpConf on 11/4
</span><span>A: 11/4
</span><span>
</span><span>Q: 1:1 with Bob tomorrow at 10 AM
</span><span>A: tomorrow
</span></code></pre></div>
<div><p><strong>A note on demonstration set size:</strong> For this blog post, we only have three
demonstrations. In reality, you probably want at least a dozen. The more
demonstrations you have the better testing you can do, but also the more
expensive it becomes due to token usage. At a certain size, it is often
more economical to <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/course/chapter7/3?fw=pt">fine-tune a language model</a>.</p></div>
<p>There are two important decisions made for the above demonstrations.
For any prompting problem, you&#39;ll have to make similar decisions.</p>
<p><strong>First, we are only extracting one piece of information.</strong> It may be
tempting to try to get the model to extract our entire event such as
event name, attendees, time, location, etc. and output
it as some beautiful ready-to-use JSON or some other format. The model
may be able to do this. But when approaching a new problem, I recommend
decomposing it into a single problem first. This makes the problem more
tractable, and will also eventually give you a baseline accuracy that you
can use to benchmark whether the multi-output approach is actually worth
it or not.</p>
<p><strong>Second, our output is not transformed.</strong> We aren&#39;t trying to turn
everything into a date or trying to ensure everything is capitalize
correctly or so on. We&#39;re doing literal text extraction. There are fantastic
deterministic libraries out there that can turn strings like &#34;next Tuesday&#34;
into timestamps with extremely high accuracy. This isn&#39;t something we need
a language model to do for us. So, let&#39;s just get out the rough date format
(&#34;next Tuesday&#34;, &#34;11/4&#34;, &#34;tomorrow&#34;) and solve the problem of turning this
into a timestamp using traditional programming methods because it is a
trivial problem. The simpler the output, the easier it will be to get
higher accuracy.</p>
<p><strong>Finally, a brief note on <em>output decoding</em>:</strong> LLMs will complete your prompt
in various ways: it may be a complete sentence, it may add a period,
it may be capitalized, etc. You should determine how perfect you want
your output from the LLM to be and how much you&#39;re willing to normalize
prior to validating your demonstration set.</p>
<p>For example, if I&#39;m doing text extraction, I typically find it reasonable to
trim whitespace and periods and lowercase the entire output. If I&#39;m doing
something more advanced like JSON generation, I might parse and re-encode
the JSON in some deterministic order and style so comparisons are deterministic.
And so on.</p>
<p>My recommendation: keep the output from the LLM as simple and flexible as
possible, and perform some normalization operations in your application.
Don&#39;t try to force the LLM to output <em>exactly perfect</em> formats to start.
Performing too much &#34;output shaping&#34; in the LLM early on makes it difficult
to separate an LLM&#39;s ability to perform some core task (information extraction
in this case) from its ability to structure the output.</p>
<hr/>

<p>We now come up with some prompt candidates. A prompt candidate is a
prompt that we feel may elicit the desired behavior we want from the
language model. We come up with multiple candidates because its unlikely
we&#39;ll choose the best prompt right away.</p>
<p>For the sake of being an introductory level text, we will come up with prompts
manually. To be effective, there is some basic knowledge prompt engineers
should use when building prompts.
For example, it is better to
be assertive than to be defensive. It is often better to be clear and concise
than it is to be repetitive and long. When building a few-shot prompt,
equal distribution of labels matters, demonstrating the full set of labels
matters, etc. When choosing exemplars, exemplars that the LLM was likely
to get wrong typically perform best, exemplars have been shown to often perform
best when ordered shortest to longest, etc.</p>
<div><p><strong>Citations required!</strong> I&#39;m sorry, I didn&#39;t cite the experimental research
to support these recommendations. The honest truth is that I&#39;m too lazy
to look up the papers I read about them (often multiple per point). If
you choose not to believe me, <em>that&#39;s fine</em>, the more important point
is that experimental studies on prompting techniques and their efficacy
exist. But, I promise I didn&#39;t make these up, though it may be possible
some are outdated with modern models.</p></div>
<p>It is a dedicated post on its own to go over some of these techniques and it
isn&#39;t the goal of this post. The goal of this
post is to show the high-level end to end process and to show that
<em>there is an engineering method to extracting value from LLMs</em>.</p>
<p>At this point, the goal is to come up with some good zero-shot prompts.
The zero-shot prompts can be transformed into few-shot and those can
be further transformed into chain of thought. And each of those can be further
turned into batched prompts and so on. Therefore, since zero-shot is a base
requirement to <em>try</em>, we focus on that.</p>
<p>Here are three prompt candidates I came up with:</p>
<blockquote>
<p>Identify the date or day mentioned in the given text and provide it as the output.</p>
</blockquote>
<blockquote>
<p>Identify the date or day mentioned in the given event description.</p>
</blockquote>
<blockquote>
<p>Determine the date or day from each input and provide the output accordingly as a single word or date.</p>
</blockquote>
<p>They&#39;re all reasonable prompts. Given any educated human, every prompt would likely
yield very high accuracy. But language models are not human, so we can&#39;t
automatically expect equivalent performance. I&#39;ve shown before how
<a target="_blank" rel="noopener noreferrer" href="https://twitter.com/mitchellh/status/1645562198935347205">very reasonable prompts can have abysmal performance</a>.
So our next step is to inform our decision by doing some testing and
taking some measurements.</p>
<hr/>

<p>With a set of candidate prompts as well as a demonstration set, we
can now measure accuracy. The best way I&#39;ve found to do this today is
to build a simple Python script using a library like LangChain. For my
testing, I usually run through each demonstration and perform the following
prompt template:</p>
<div><pre><code><span>{{prompt}}. Q: {{input}} A:
</span></code></pre></div>
<p>I always test zero-shot first. I want to get a baseline accuracy metric.
From there, you can then test few-shot and compare not only different
candidates but different prompting types. And so on.</p>
<p>This has to be done per-model. The same prompt even on a more powerful
model is not guaranteed to have the same or better accuracy; the accuracy
can go down<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup>.</p>
<p>The most basic result of prompt testing should be a table like below.
You may also have additonal dimensions such as model (GPT-3.5 vs GPT-4
for example).</p>
<div><pre><code><span>           | Zero-Shot | Few-Shot | ... |
</span><span>-----------------------------------------
</span><span>Prompt 1   | 64        | 68       | ... |
</span><span>-----------------------------------------
</span><span>Prompt ... | 44        | 52       | ... |
</span><span>-----------------------------------------
</span><span>Prompt N   | 23        | 22       | ... |
</span></code></pre></div>
<p>This table shows prompt candidates on the Y-axis, and prompt types
using those prompts on the X-axis. The value is the accuracy as a percentage
of correct answers. Continuing the calendar app example, &#34;prompt 1&#34; as
a zero-shot prompt with one demonstration may look like this:</p>
<blockquote>
<p>Identify the date or day mentioned in the given text and provide it as the
output. Q: CorpConf on 11/4 A:</p>
</blockquote>
<p>And we expect &#34;11/4&#34; as the answer. The few-shot version may look like this:</p>
<blockquote>
<p>Identify the date or day mentioned in the given text and provide it as the
output.</p>
<p>Q: Dinner with Alice next Tuesday at Taco Bell. A: next Tuesday</p>
<p>Q: 1:1 with Bob tomorrow at 10 AM. A: tomorrow</p>
<p>Q: CorpConf on 11/4. A:</p>
</blockquote>
<div><p><strong>A note for experienced prompters:</strong> the few-shot example doesn&#39;t say
something like &#34;mimic the examples below.&#34; Experimental research has shown
this doesn&#39;t reliably increase accuracy, so I like to test without it first
to limit tokens. Second, the few-shot example exemplars don&#39;t ever show
the &#34;MM/DD&#34; extraction as an example, which is poor form. In a real few-shot
setting, demonstrating all styles of extraction can be important (
<a target="_blank" rel="noopener noreferrer" href="https://arxiv.org/abs/2102.09690">Zhao, et al 2021</a>).</p></div>
<p>For certain types of problems, such as classification problems, you
can use a <a target="_blank" rel="noopener noreferrer" href="https://arxiv.org/pdf/2208.07852.pdf">confusion matrix (Strobelt, et al 2022)</a> to
visualize the probabilities of other labels and use that to determine
if your label set can potentially be better tuned.</p>
<p>In addition to accuracy, you also want to measure tokens used,
requests used, etc. All of this will have to be taken into consideration
when choosing your final prompt.</p>
<hr/>

<p>Finally, you choose one of the prompt candidates to integrate into your
application. This isn&#39;t necessarily the most accurate
prompt. This is a cost vs. accuracy analysis based on model used, tokens
required, and accuracy presented.</p>
<p>For example, you may find that the few-shot variant performs best, but
its only 4% more accurate on the test set and requires 200% more tokens
(effectively doubling the cost for current API-driven models). You may
determine for your business that its worth being 4% <em>less</em> accurate for
half the cost.</p>
<p>Or, you may decide to go back and test <strong>other approaches to increase
accuracy.</strong> For example, you may try a <a target="_blank" rel="noopener noreferrer" href="https://arxiv.org/abs/2203.11171">self-consistency decoding
strategy (Wang, et al 2022)</a> on a lower cost model to
see if that improves the accuracy enough. Sometimes, using more tokens
on a lower cost model will save significant money vs. low-token usage
on a higher cost model. For example, GPT-4 is ~15x more expensive than
GPT-3.5 today. That means that you effectively have 15x more token budget
to increase the GPT-3.5 prompt accuracy (caveats around rate limits noted).</p>
<p>For our example in this blog post, we may choose to go with the zero-shot
version of <code>Prompt 1</code> in our table because it has 64% accuracy with
likely significantly fewer tokens. Maybe we decide 64% accuracy is good
enough to at least populate an event template for our calendar application.
For this particular problem, I think we can do significantly better than
64%, but that&#39;s just the number I used in this post.</p>
<p>Most Importantly, you have the data to be make an informed decision.</p>
<hr/>

<p>Due to the probabilistic nature of generative AI, your prompt likely
has some issues. Even if your accuracy on your test set is 100%, there
are probably unknown inputs that produce incorrect outputs. Therefore,
you should <em>trust but verify</em> and <em>add verification failures to your
demonstration set</em> in order to develop new prompts and increase accuracy.</p>
<p>Verification is highly dependent on the problem. For our calendar application
example, we may want to explicitly ask users: &#34;is this event correct?&#34; And
if they say &#34;no,&#34; then log the natural language input for human review.
Or, we can maybe do better to automatically track any events our users
manually change after our automatic information extraction<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup>.</p>
<p>As a different example, if our prompt is generating code (such as a regular
expression or programming language text), we can -- at a minimum -- try to
<em>parse it</em>. Parsing should never be a security concern<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="true" aria-describedby="footnote-label">4</a></sup>, and it gives
at least the most basic validation that <em>at least syntax is correct</em>.
And again, if this verification fails, we can log the input and output,
grow our demonstration set, and develop better prompts.</p>
<p>Verification also helps against <a target="_blank" rel="noopener noreferrer" href="https://www.promptingguide.ai/risks/adversarial">adversarial prompting</a>.
Adversarial prompting is a whole topic unto itself, and I won&#39;t cover it
in this post.</p>
<hr/>

<p>This blog post demonstrates how developing a prompt can -- in my opinion --
be an engineering practice. It describes a systematic approach to identifying
a problem, forming solutions, validating those solutions, and applying
continuous improvement to refine those solutions.</p>
<p>Compare the approach in this post to &#34;Blind Prompting&#34; which relies on anecdotal experience and
pervasive trial-and-error to arrive at some proposed solution, and often doesn&#39;t
build the proper systematic infrastructure to reliably iterate on prompts
as time goes on.</p>
<p>I want to note that blog post is very elementary. There are multiple places
in this post that could be improved with more advanced techniques that
are already well-known. Further, I didn&#39;t cover important topics such as
adversarial prompting. As a specific example, there are more scientific approaches
to choosing the best examples for a few-shot prompt, but I wanted to keep
this post to the basics as much as possible. If you want to learn some
more advanced techniques, <a target="_blank" rel="noopener noreferrer" href="https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/">Prompt Engineering by Lilian Weng</a>
provides a fantastic overview.</p>
<p>Additionally, everyone is rapidly moving to higher-order LLM integrations: prompt chaining,
agents, etc. Some people argue that future innovations such as these and
more will make human prompting obsolete. Regardless of if this is true or not, I am someone
who believes learning things from <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/First_principle">&#34;first principles&#34;</a><sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="true" aria-describedby="footnote-label">5</a></sup>
is valuable and I think that learning prompting techniques such as this
has only improved my ability to utilize higher-order language model techniques.
I also believe basic prompting such as this still enables better
performance of higher-order concepts.</p>
</div></div>
  </body>
</html>
