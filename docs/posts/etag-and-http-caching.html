<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rednafi.com/misc/etag_and_http_caching/">Original</a>
    <h1>ETag and HTTP Caching</h1>
    
    <div id="readability-page-1" class="page"><div><p>One neat use case for the HTTP <code>ETag</code> header is client-side HTTP caching for <code>GET</code> requests.
Along with the <code>ETag</code> header, the caching workflow requires you to fiddle with other
conditional HTTP headers like <code>If-Match</code> or <code>If-None-Match</code>. However, their interaction can
feel a bit confusing at times.</p><p>Every time I need to tackle this, I end up spending some time browsing through the relevant
MDN docs<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup><sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup><sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> to jog my memory. At this point, I’ve done it enough times to justify
spending the time to write this.</p><h2 id="caching-the-response-of-a-get-endpoint">Caching the response of a <code>GET</code> endpoint</h2><p>The basic workflow goes as follows:</p><ul><li>The client makes a <code>GET</code> request to the server.</li><li>The server responds with a <code>200 OK</code> status, including the content requested and an
<code>ETag</code> header.</li><li>The client caches the response and the <code>ETag</code> value.</li><li>For subsequent requests to the same resource, the client includes the <code>If-None-Match</code>
header with the <code>ETag</code> value it has cached.</li><li>The server regenerates the <code>ETag</code> independently and checks if the <code>ETag</code> value sent by
the client matches the generated one.<ul><li>If they match, the server responds with a <code>304 Not Modified</code> status, indicating that
the client’s cached version is still valid, and the client serves the resource from
the cache.</li><li>If they don’t match, the server responds with a <code>200 OK</code> status, including the new
content and a new <code>ETag</code> header, prompting the client to update its cache.</li></ul></li></ul><div><pre tabindex="0"><code data-lang="txt"><span><span>Client                                 Server
</span></span><span><span>  |                                       |
</span></span><span><span>  |----- GET Request --------------------&gt;|
</span></span><span><span>  |                                       |
</span></span><span><span>  |&lt;---- Response 200 OK + ETag ----------|
</span></span><span><span>  |     (Cache response locally)          |
</span></span><span><span>  |                                       |
</span></span><span><span>  |----- GET Request + If-None-Match ----&gt;|  (If-None-Match == previous ETag)
</span></span><span><span>  |                                       |
</span></span><span><span>  |       Does ETag match?                |
</span></span><span><span>  |&lt;---- Yes: 304 Not Modified -----------|  (No body sent; Use local cache)
</span></span><span><span>  |       No: 200 OK + New ETag ----------|  (Update cached response)
</span></span><span><span>  |                                       |
</span></span></code></pre></div><p>We can test this workflow with GitHub’s REST API suite via the GitHub CLI<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>. If you’ve
installed the CLI and authenticated yourself, you can make a request like this:</p><p>This asks for the data associated with the user <code>rednafi</code>. The response looks as follows:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>HTTP/2.0 200 OK
</span></span><span><span>Etag: W/&#34;b8fdfabd59aed6e0e602dd140c0a0ff48a665cac791dede458c5109bf4bf9463&#34;
</span></span><span><span>
</span></span><span><span>{
</span></span><span><span>  &#34;login&#34;:&#34;rednafi&#34;,
</span></span><span><span>  &#34;id&#34;:30027932,
</span></span><span><span>  ...
</span></span><span><span>}
</span></span></code></pre></div><p>I’ve truncated the response body and omitted the headers that aren’t relevant to this
discussion. You can see that the HTTP status code is <code>200 OK</code> and the server has included an
ETag header.</p><p>The <code>W/</code> prefix indicates that a weak validator<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> is used to validate the content of the
cache. Using a weak validator means when the server compares the response payload to
generate the hash, it doesn’t do it bit-by-bit. So, if your response is JSON, then changing
the format of the JSON won’t change the value of the <code>ETag</code> header since two JSON payloads
with the same content but with different formatting are semantically the same thing.</p><p>Let’s see what happens if we make the same request again while passing the value of the
<code>ETag</code> in the <code>If-None-Match</code> header.</p><div><pre tabindex="0"><code data-lang="sh"><span><span>gh api -i -H <span>\
</span></span></span><span><span><span></span>    <span>&#39;If-None-Match: W/&#34;b8fdfabd59aed6e0e602dd140c0a0ff48a665cac791dede458c5109bf4bf9463&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span>    /users/rednafi
</span></span></code></pre></div><p>This returns:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>HTTP/2.0 304 Not Modified
</span></span><span><span>Etag: &#34;b8fdfabd59aed6e0e602dd140c0a0ff48a665cac791dede458c5109bf4bf9463&#34;
</span></span><span><span>
</span></span><span><span>gh: HTTP 304
</span></span></code></pre></div><p>This means that the cached response in the client is still valid and it doesn’t need to
refetch that from the server. So, the client can be coded to serve the previously cached
data to the users when asked for.</p><p>A few key points to keep in mind:</p><ul><li><p>Always wrap your <code>ETag</code> values in double quotes when sending them with the
<code>If-None-Match</code> header, just as the spec says<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>.</p></li><li><p>Using the <code>If-None-Match</code> header to pass the <code>ETag</code> value means that the client request
is considered successful when the <code>ETag</code> value from the client doesn’t match that of the
server. When the values match, the server will return <code>304 Not Modified</code> with no body.</p></li><li><p>If we’re writing a compliant server, when it comes to <code>If-None-Match</code>, the spec tells
us<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> to use a weak comparison for ETags. This means that the client will still be able
to validate the cache with weak ETags, even if there have been slight changes to the
representation of the data.</p></li><li><p>If the client is a browser, it’ll automatically manage the cache and send conditional
requests without any extra work.</p></li></ul><h2 id="writing-a-server-that-enables-client-side-caching">Writing a server that enables client-side caching</h2><p>If you’re serving static content, you can configure your load balancer to enable this
caching workflow. But for dynamic <code>GET</code> requests, the server needs to do a bit more work to
allow client-side caching.</p><p>Here’s a simple server in Go that enables the above workflow for a dynamic <code>GET</code> request:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>    <span>&#34;crypto/sha256&#34;</span>
</span></span><span><span>    <span>&#34;encoding/hex&#34;</span>
</span></span><span><span>    <span>&#34;fmt&#34;</span>
</span></span><span><span>    <span>&#34;net/http&#34;</span>
</span></span><span><span>    <span>&#34;strings&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// calculateETag generates a weak ETag by SHA-256-hashing the content
</span></span></span><span><span><span>// and prefixing it with W/ to indicate a weak comparison
</span></span></span><span><span><span></span><span>func</span> <span>calculateETag</span><span>(</span><span>content</span> <span>string</span><span>)</span> <span>string</span> <span>{</span>
</span></span><span><span>    <span>hasher</span> <span>:=</span> <span>sha256</span><span>.</span><span>New</span><span>()</span>
</span></span><span><span>    <span>hasher</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>content</span><span>))</span>
</span></span><span><span>    <span>hash</span> <span>:=</span> <span>hex</span><span>.</span><span>EncodeToString</span><span>(</span><span>hasher</span><span>.</span><span>Sum</span><span>(</span><span>nil</span><span>))</span>
</span></span><span><span>    <span>return</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;W/\&#34;%s\&#34;&#34;</span><span>,</span> <span>hash</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>http</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;/&#34;</span><span>,</span> <span>func</span><span>(</span><span>w</span> <span>http</span><span>.</span><span>ResponseWriter</span><span>,</span> <span>r</span> <span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>// Define the content within the handler
</span></span></span><span><span><span></span>        <span>content</span> <span>:=</span> <span>`{&#34;message&#34;: &#34;Hello, world!&#34;}`</span>
</span></span><span><span>        <span>eTag</span> <span>:=</span> <span>calculateETag</span><span>(</span><span>content</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>// Remove quotes and W/ prefix for If-None-Match header comparison
</span></span></span><span><span><span></span>        <span>ifNoneMatch</span> <span>:=</span> <span>strings</span><span>.</span><span>TrimPrefix</span><span>(</span>
</span></span><span><span>            <span>strings</span><span>.</span><span>Trim</span><span>(</span><span>r</span><span>.</span><span>Header</span><span>.</span><span>Get</span><span>(</span><span>&#34;If-None-Match&#34;</span><span>),</span> <span>&#34;\&#34;&#34;</span><span>),</span> <span>&#34;W/&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>// Generate a hash of the content without the W/ prefix for comparison
</span></span></span><span><span><span></span>        <span>contentHash</span> <span>:=</span> <span>strings</span><span>.</span><span>TrimPrefix</span><span>(</span><span>eTag</span><span>,</span> <span>&#34;W/&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>// Check if the ETag matches; if so, return 304 Not Modified
</span></span></span><span><span><span></span>        <span>if</span> <span>ifNoneMatch</span> <span>==</span> <span>strings</span><span>.</span><span>Trim</span><span>(</span><span>contentHash</span><span>,</span> <span>&#34;\&#34;&#34;</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>w</span><span>.</span><span>WriteHeader</span><span>(</span><span>http</span><span>.</span><span>StatusNotModified</span><span>)</span>
</span></span><span><span>            <span>return</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>// If ETag does not match, return the content and the ETag
</span></span></span><span><span><span></span>        <span>w</span><span>.</span><span>Header</span><span>().</span><span>Set</span><span>(</span><span>&#34;ETag&#34;</span><span>,</span> <span>eTag</span><span>)</span> <span>// Send weak ETag
</span></span></span><span><span><span></span>        <span>w</span><span>.</span><span>Header</span><span>().</span><span>Set</span><span>(</span><span>&#34;Content-Type&#34;</span><span>,</span> <span>&#34;application/json&#34;</span><span>)</span>
</span></span><span><span>        <span>w</span><span>.</span><span>WriteHeader</span><span>(</span><span>http</span><span>.</span><span>StatusOK</span><span>)</span>
</span></span><span><span>        <span>fmt</span><span>.</span><span>Fprint</span><span>(</span><span>w</span><span>,</span> <span>content</span><span>)</span>
</span></span><span><span>    <span>})</span>
</span></span><span><span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Server is running on http://localhost:8080&#34;</span><span>)</span>
</span></span><span><span>    <span>http</span><span>.</span><span>ListenAndServe</span><span>(</span><span>&#34;:8080&#34;</span><span>,</span> <span>nil</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><ul><li><p>The server generates a weak <code>ETag</code> for its content by creating a SHA-256 hash and adding
<code>W/</code> to the front, indicating it’s meant for weak comparison.</p><p>You could make the <code>calculateETag</code> function format-agnostic, so the hash stays the same
if the JSON format changes but the content does not. The current <code>calculateETag</code>
implementation is susceptible to format changes, and I kept it that way to keep the code
shorter.</p></li><li><p>When delivering content, the server includes this weak <code>ETag</code> in the response headers,
allowing clients to cache the content along with the <code>ETag</code>.</p></li><li><p>For subsequent requests, the server checks if the client has sent an <code>ETag</code> in the
<code>If-None-Match</code> header and weakly compares it with the current content’s <code>ETag</code> by
independently generating the hash.</p></li><li><p>If the ETags match, indicating no significant content change, the server replies with a
<code>304 Not Modified</code> status. Otherwise, it sends the content again with a <code>200 OK</code> status
and updates the ETag. When this happens, the client knows that the existing cache is
still warm and can be served without any changes to it.</p></li></ul><p>You can spin up the server by running <code>go run main.go</code> and from a different console start
making requests to it like this:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>curl -i  http://localhost:8080/foo
</span></span></code></pre></div><p>This will return the ETag header along with the JSON response:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>HTTP/1.1 200 OK
</span></span><span><span>Content-Type: application/json
</span></span><span><span>Etag: W/&#34;1d3b4242cc9039faa663d7ca51a25798e91fbf7675c9007c2b0470b72c2ed2f3&#34;
</span></span><span><span>Date: Wed, 10 Apr 2024 15:54:33 GMT
</span></span><span><span>Content-Length: 28
</span></span><span><span>
</span></span><span><span>{&#34;message&#34;: &#34;Hello, world!&#34;}
</span></span></code></pre></div><p>Now, you can make another request with the value of</p><p>the <code>ETag</code> in the <code>If-None-Match</code> header:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>curl -i -H <span>\
</span></span></span><span><span><span></span>    <span>&#39;If-None-Match: &#34;1d3b4242cc9039faa663d7ca51a25798e91fbf7675c9007c2b0470b72c2ed2f3&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span>    http://localhost:8080/foo
</span></span></code></pre></div><p>This will return a <code>304 Not Modified</code> response with no body:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>HTTP/1.1 304 Not Modified
</span></span><span><span>Date: Wed, 10 Apr 2024 15:57:25 GMT
</span></span></code></pre></div><p>In a real-life scenario, you’ll probably factor out the caching part in middleware so that
all of your HTTP <code>GET</code> requests can be cached from the client-side without repetition.</p><h2 id="one-thing-to-look-out-for">One thing to look out for</h2><p>While writing a cache-enabled server, make sure the system is set up so that the server
always sends back the same <code>ETag</code> for the same content, even when there are multiple servers
working behind a load balancer. If these servers give out different ETags for the same
content, it can mess up how clients cache that content.</p><p>Clients use ETags to decide if content has changed. If the <code>ETag</code> value hasn’t changed, they
know the content is the same and don’t download it again, saving bandwidth and speeding up
access. But if ETags are inconsistent across servers, clients might download content they
already have, wasting bandwidth and slowing things down.</p><p>This inconsistency also means servers end up dealing with more requests for content that
clients could have just used from their cache if ETags were consistent.</p><h2>Recent posts</h2><li><a href="https://rednafi.com/misc/crossing_the_cors_crossroad/">Crossing the CORS crossroad</a></li><li><a href="https://rednafi.com/go/dysfunctional_options_pattern/">Dysfunctional options pattern in Go</a></li><li><a href="https://rednafi.com/zephyr/einstellung_effect/">Einstellung effect</a></li><li><a href="https://rednafi.com/go/strategy_pattern/">Strategy pattern in Go</a></li><li><a href="https://rednafi.com/go/anemic_stack_traces/">Anemic stack traces in Go</a></li><li><a href="https://rednafi.com/go/retry_function/">Retry function in Go</a></li><li><a href="https://rednafi.com/go/type_assertion_vs_type_switches/">Type assertion vs type switches in Go</a></li><li><a href="https://rednafi.com/python/patch_pydantic_settings_in_pytest/">Patching pydantic settings in pytest</a></li><li><a href="https://rednafi.com/go/omit_dev_dependencies_in_binaries/">Omitting dev dependencies in Go binaries</a></li><li><a href="https://rednafi.com/misc/eschewing_black_box_api_calls/">Eschewing black box API calls</a></li></div></div>
  </body>
</html>
