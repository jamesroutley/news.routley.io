<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://digest.browsertech.com/archive/gpu-backed-user-interfaces/">Original</a>
    <h1>GPU-Backed User Interfaces</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    
                        <p>Welcome to issue #12 of the Browsertech Digest. Today’s issue is about the trend of applications rendering their entire UI directly on the GPU.</p>
<h2>The Good Old Days, When Apps were Apps</h2>
<p>Traditionally, if you wanted to write desktop software, you would use the operating system’s APIs to create a user interface. That’s why Windows apps looked like Windows apps, and Mac apps looked like Mac apps.</p>
<p>This also meant that if you wanted to turn a Windows app into a Mac app, it was an expensive and time-consuming process. As browser rendering engines became more powerful, developers realized they could be used as a foundation for a cross-platform UI framework, bypassing much (not all) of the work in maintaining a cross-platform app.</p>
<h2>Bloated Modern Apps</h2>
<p>The modern way to build a desktop application is to build a web application, bundle it together with a specific version of the Chromium browser, and ship it. I’m simplifying a bit, but that’s essentially the technique used by apps like <a href="https://engineering.atspotify.com/2021/04/building-the-future-of-our-desktop-apps/" target="_blank">Spotify</a>, <a href="https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox" target="_blank">Visual Studio Code</a>, and <a href="https://www.figma.com/blog/introducing-browserview-for-electron/" target="_blank">Figma</a>.</p>
<p>This is why (e.g.) Slack on Mac/PC doesn’t look like a Mac/PC app.</p>
<p>Not everybody loves this. Chromium is big. It feels pretty wasteful to ship an entire browser with every desktop application. Browsers are notorious memory hogs. It seems like a lot of overhead just to have a cross-platform way to, essentially, draw boxes with text in them.</p>
<p>One alternative to shipping a web browser with your application is to hook into a micro browser provided by the platform. Modern operating systems generally provide a way to embed a stripped-down WebKit view into a native application. This is what <a href="https://tauri.app/" target="_blank">Tauri</a> does, for example, to produce programs that are much smaller than their <a href="https://www.electronjs.org/" target="_blank">Electron</a> equivalents.</p>
<h2>Rendering UI on the GPU</h2>
<p>Another approach is to render the UI directly on a cross-platform GPU API, usually OpenGL.</p>
<p>Since OpenGL is cross-platform, if you write the UI of your app to target OpenGL, you can run it on any system that supports OpenGL. And since WebGL is just a flavor of OpenGL, the browser is one of those systems.</p>
<p>The downside is that OpenGL is basically just an API for drawing triangles very fast. Unlike the UIs provided by the operating system, where you can say “draw a button with the label ‘delete’”, you have to tell OpenGL how to make a button out of triangles.</p>
<p>It takes a lot of work to make a usable UI out of triangles, so most applications did not go this path. One big exception was games, which were already heavy GPU users, and usually had minimal UIs. The 3D renderer Blender is another example.</p>
<h2>GPU UI Resurgence</h2>
<p>Lately, I’ve seen more apps choosing to target the GPU directly, even for not-particularly-graphical applications:</p>
<ul>
<li><a href="https://makepad.dev/" target="_blank">Makepad</a> is a slick IDE that runs in the browser.</li>
</ul>
<p><img alt="Makepad screenshot" src="https://buttondown-attachments.s3.us-west-2.amazonaws.com/images/ea704f8b-6dcd-4eaa-a636-51c1afde5c0a.png"/> </p>
<ul>
<li><a href="http://Zed.dev" target="_blank">Zed.dev</a> is a collaborative editor. Its creators <a href="https://zed.dev/tech" target="_blank">write</a>:</li>
</ul>
<blockquote>
<p>We originally planned to use Electron as a convenient means of delivering a cross-platform GUI for Zed, while building the core of the application in Rust. But at every turn, we found that web technology was the bottleneck in achieving amazing performance. Finally, we decided to take full control and simply build a GPU-powered UI framework that met our needs.</p>
</blockquote>
<ul>
<li>
<p><a href="http://Rerun.io" target="_blank">Rerun.io</a> is building visualization tools for robotics. One of the founding members is the author of the Rust <a href="https://github.com/emilk/egui" target="_blank">egui</a> GPU GUI framework, which they are using.</p>
</li>
<li>
<p>Raph Linus, in his <a href="https://raphlinus.github.io/rust/gui/2022/05/07/ui-architecture.html" target="_blank">retrospective on the Xi editor</a>, wrote</p>
</li>
</ul>
<blockquote>
<p>These days, I consider GPU acceleration to be essentially required for good GUI performance.</p>
</blockquote>
<p>Raph is now working on the GPU-backed <a href="https://github.com/linebender/xilem" target="_blank">Xilem</a> GUI framework.</p>
<ul>
<li>The visual programming language <a href="https://github.com/enso-org/enso" target="_blank">Enso</a> is built on a <a href="https://github.com/enso-org/enso/tree/develop/lib/rust/ensogl" target="_blank">custom GL-based GUI framework</a>.</li>
</ul>
<p><img alt="Enso screenshot" src="https://buttondown-attachments.s3.us-west-2.amazonaws.com/images/f0b62734-fb4f-4edd-bb0b-34fc20c4af8d.png"/></p>
<ul>
<li><a href="http://Warp.dev" target="_blank">Warp.dev</a> is a modern terminal, using a UI framework <a href="https://twitter.com/nathansobo/status/1619398212712022017" target="_blank">originally forked</a> from Zed’s GPUI. It targets Apple’s Metal rather than OpenGL, although a WebGL backend is planned. From <a href="https://www.warp.dev/faq" target="_blank">their FAQ</a>:</li>
</ul>
<blockquote>
<p>Picking GPU acceleration has allowed us to be at way over 60fps on a 4K screen, with text and glyphs and rectangles.</p>
</blockquote>
<p>And:</p>
<blockquote>
<p>An early Warp prototype <em>did</em> use Electron and the team decided it would not be able to provide the level of performance that users should expect from their terminal.</p>
</blockquote>
<h2>a11y</h2>
<p>One setback of GPU-rendered UIs today is accessibility. When you hook into an operating system’s UI library, or use a browser to render a UI, your users get the benefit of accessibility tools built into those platforms.</p>
<p>When you draw the UI on the GPU, the host just hands you a framebuffer to draw into, and has no awareness of the text and click surfaces you’re rendering into it. If the user has set a larger system text size, your app won’t get it. If the user uses a screen reader, they won’t be able to navigate your app.</p>
<p>These are not technically insurmountable problems, but they do mean that as GPU-rendered apps seek a larger audience, developers will have to spend time on a11y functionality that native and web apps get for free.</p>
<p>Until next time,</p>
<p>– Paul</p>
<p>(PS. Thanks to Mish at <a href="https://twitter.com/ci_step/status/1619392882875715586" target="_blank">Step CI</a> on twitter for the tip on <a href="http://Warp.dev" target="_blank">Warp.dev</a> being GPU-backed)</p>
                    
                
            </div></div>
  </body>
</html>
