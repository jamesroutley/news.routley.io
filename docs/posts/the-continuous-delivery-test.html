<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sourceless.org/posts/the-continuous-delivery-test.html">Original</a>
    <h1>The Continuous Delivery Test</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
            


<a href="https://sourceless.org">index</a>

    <a href="https://sourceless.org/about.html">about</a>

    <a href="https://sourceless.org/contact.html">contact</a>


            <p>In 2000, Joel Spolsky published a piece on what he believed were the key factors that separated high-performing teams from the rest, in a post titled <a href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a>. It contains many insights that are still useful to this day; however, the world, software, and the teams that make it have moved on in the nearly 22 years since that post.</p><p>In 2015, John Kodumal of LaunchDarkly published an updated <a href="https://circleci.com/blog/joel-test-for-continuous-delivery/">Joel Test for Continuous Delivery</a>. While being far more up-to-date, it&#39;s still slipped a little in relevance.</p><p>If this post were to have an alternate title, it&#39;d be &#39;Front-load Your Risks&#39;. All of the advice below seeks to move risks away from the act of deployment and move them to earlier steps of the development process.</p><p>So, here&#39;s my best shot at a CI/CD Joel Test for the 2020s.</p><h3>1. Do you use a distributed version control system?</h3><p>Git, GitHub, and the ecosystems around them have eaten the software world, and for good reason. Beyond the usual advantages - branching, merging, and easy rollbacks, many of these hosted git servers now come with a whole slew of other productivity tooling.</p><p>Especially notable are those that move your CI closer to your source code, such as GitHub Actions, and GitLab CI/CD.</p><h3>2. Do you practice <a href="https://trunkbaseddevelopment.com/">trunk-based development</a>?</h3><p>Trunk-based development rolls up a bunch of good practices under one system.</p><p>It forces you to have one good <code>main</code> branch that is always deployable (and by implication, always able to roll back), and encourages merging small features one at a time.</p><p>Having an always-deployable <code>main</code> means that your deployment process becomes a lot more boring (which is great!), and is often indicative of a process that supports developers, rather than requiring long hours spent resolving merge conflicts and preparing release notes.</p><h3>3. Do you merge little and often?</h3><p>It&#39;s been known for some time now that large pull requests tend to get cursory reviews at best. On top of this, squirrelling away to work on a single feature for a long time means you are not spending adequate time making sure that you are building the right thing!</p><p>This also means using small, ticket-scoped feature branches, where the changes have a very tight scope.</p><h3>4. Do two people read code before it is merged?</h3><p>You&#39;ll notice I was very careful to avoid mentioning how this should take place. For some, pull requests are the right tool, but pairing and mob programming are also sufficient.</p><p>Nobody should be solely responsible for any code.</p><h3>5. Do you require changes to pass checks before they can be merged?</h3><p>One of the leading causes of outages is deployments. You should do your best to make sure that broken code never gets deployed in the first place.</p><h3>6. Can you test your changes in a production-like environment before you deploy them?</h3><p>There are many ways to go about this. You could spin up a small clone of your production env, run the tests, and then kill it. Where this is not possible, you can run tests against mirrored traffic or even run a canary.</p><h3>7. Do you deploy to production as soon as <code>main</code> is updated?</h3><p>Your deployments should be automated and happen right upon merge. This removes a burden from the team delivering a product and allows them to focus on features and reliability rather than long-winded release ceremonies. It can be hard to get here if you&#39;re currently releasing once a day, week, etc. â€“ a mature approach to managing the risks of deployment is required, as well as battle-tested deployment processes and tools.</p><p>The earlier you start doing this, the easier it will be.</p><h3>8. Does your deploy process self-heal?</h3><p>When a deployment fails, can you roll back automatically? In addition to this, you should be able to roll back manually where necessary (though it&#39;s generally best to fail forwards!)</p><p>This also necessitates the use of blue-green deploys, canarying, healthchecks, and myriad other strategies to mitigate outage risk. It&#39;s very powerful to be able to turn a possible outage into a mere degradation.</p><h3>9. Does your Infrastructure as Code live alongside the service it hosts?</h3><p>It&#39;s a good idea to colocate any IaC with the software it&#39;s running rather than keeping the two in separate repositories. This dodges any dependency management between the two, and in many cases will save you a pipeline or two.</p><p>It&#39;s an antipattern (in the author&#39;s opinion) to have all infrastructure code completely separate from the application it supports. Common or shared infrastructure could be argued to have its own place, but a product should have all its pieces as close together as possible.</p><p><a href="https://semaphoreci.com/blog/what-is-monorepo">Monorepos</a> are an extreme example of this philosophy.</p><h3>10. Do you use feature flags?</h3><p>Releases are a terrible mechanism for launching new features. You want to be able to run that shiny new feature in production as soon as possible, and you can&#39;t do that if you conflate a feature&#39;s launch with its release. This also means that you can preview and refine changes with flagship customers before rolling them out more widely.</p><h3>11. Do you include ticket IDs in your commits or branches?</h3><p>You need to be able to tie every commit back to the ticket that spawned it. It might not be you debugging a change that you merged, so it needs to be really easy to go back and find out <em>why</em> something was changed in order to make the right decision to fix it.</p><h3>12. Can you still deploy from your own machine?</h3><p>A key factor in developing software and infrastructure quickly is tight feedback loops. While it&#39;s probably not a great idea to be deploying directly to production from your own machine, having the ability to might be useful in a pinch, too.</p><p>You should be able to deploy to a dev environment (shared or ephemeral) so that you can easily validate your work in situ.</p><h3>13. Can you show what will happen when a branch is merged?</h3><p>Most IaC tools offer the ability to diff the changes they want to make. It&#39;s vitally important that when you go to merge some changes in, you know what the changes are, why you&#39;re making them (see point 11), and the effect the changes will have on the product or system.</p><p>This could be a <code>cdk diff</code>, or a visual diff if you&#39;re making a change to a frontend. Seldom is the code itself the interesting and crucial part of why you&#39;re making a change. The effect of your changeset should be evident not only to reviewers but also to bleary-eyed SREs at 4am.</p><p><em>Thanks to <a href="https://github.com/openfinch">Josh Finch</a> for his valuable feedback on this post.</em></p>
            </div></div>
  </body>
</html>
