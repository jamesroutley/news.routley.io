<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://authzed.com/blog/some-assembly-required/">Original</a>
    <h1>Dropping playground latency by porting SpiceDB to WASM</h1>
    
    <div id="readability-page-1" class="page"><div><p>In this post, we’ll go into detail about each of these steps to highlight the work behind the newly improved <a href="https://play.authzed.com">Authzed Playground</a> experience and perhaps inspire others to experiment with WebAssembly.</p>
<p><em>Interesting Note: Header image originally generated with DALL·E 2 with caption “purple database icon lifted by crane”, slightly modified afterwards</em></p>
<h3 id="tldr">TL;DR:</h3>
<div><p>
1. Compile SpiceDB Go source as WebAssembly.</p></div>
<h2 id="background">Background</h2>
<p>At Authzed, our goal is to empower authorization teams with the best tooling possible.</p>
<p>SpiceDB, our open source permissions database inspired by Google’s Zanzibar, provides a lot of power in configuring and defining a permission system.</p>
<p>However, this flexibility creates a need for tooling around development, testing and validation.</p>
<p>In a <a href="https://authzed.com/blog/learning-through-play/">previous blog post</a> I discussed how we built the <a href="https://play.authzed.com">Authzed Playground</a> to meet this need, with a section describing the server-side API provided by SpiceDB to run Playground operations against the <strong>real</strong> implementation of permissions resolution code: using the real SpiceDB code for the Playground was and continues to remain critical, ensuring that any operation which works in the Playground will work in a real API call (and vice versa).</p>
<p>While this approach has proven to be stable and relatively performant, it comes with a significant cost: the Playground relies on a shared server side component running with a distinct development API in order to be functional.</p>
<p>We wondered: was there a way to continue to use the real SpiceDB implementation in Playground, but without this limitation?</p>
<p>As SpiceDB is written in Go, Ideally, we’d run Go code directly in the user’s browser, but that is not possible… or is it?</p>
<h2 id="some-assembly-required">Some Assembly Required</h2>
<p><img src="https://authzed.com/images/blogs/some-assembly-required/webassembly.svg"/>
</p>
<p>Many words have been written about <a href="https://webassembly.org">WebAssembly</a> (WASM) and its potential impacts, ranging from whether it will eventually replace JavaScript in the browser to its use for serverless functions.</p>
<p>One benefit often missed, however, is the ability to share non-JavaScript implementations between clients and servers: so long as the toolchain for your preferred language supports compiling into WASM, subsets of code can be shared with browser-based applications!</p>
<p>Thanks to some amazing work by the Go team starting a few years ago, Go’s compiler now has support for compiling code to WebAssembly!</p>
<p>Creating a WASM bundle from a Go application is, on the surface, as simple as specifying the “operating system” as <code>JS</code> and the architecture as <code>wasm</code>:</p>
<div><pre tabindex="0"><code data-lang="shell"><span>GOOS</span>=js <span>GOARCH</span>=wasm go build -o main.wasm
</code></pre></div><p>We therefore had a viable plan: compile SpiceDB into a WebAssembly binary, load it in the browser, and make API calls directly to the now in-browser SpiceDB!</p>
<h2 id="an-early-roadblock">An early roadblock</h2>
<h3 id="adjusting-spicedb-to-compile-under-webassembly">Adjusting SpiceDB to compile under WebAssembly</h3>
<p>Getting SpiceDB to compile for WebAssembly ran into a roadblock almost immediately: not all of SpiceDB’s code is, itself, written in Go:</p>
<div><pre tabindex="0"><code data-lang="shell">package github.com/authzed/spicedb/pkg/development/wasm

imports github.com/dgraph-io/ristretto
imports github.com/dgraph-io/ristretto/z
imports golang.org/x/sys/unix: build constraints exclude all Go files in /go/pkg/mod/golang.org/x/sys@v0.0.0-20220722155257-8c9f86f7a55f/unix
</code></pre></div><p>For performance reasons, SpiceDB includes a select number of native libraries that rely upon platform-specific compilation.</p>
<p>One of these libraries, <a href="https://github.com/dgraph-io/ristretto">Ristretto</a>, is a very high performance cache used to cache results from various subproblems in SpiceDB.</p>
<p>Ristretto gets part of its performance by implementing platform-specific optimizations and, unfortunately, did not have a WASM implementation.</p>
<p>Thus, our first task was to extract out our caching code behind <a href="https://github.com/authzed/spicedb/blob/main/pkg/cache/cache.go">an interface</a>, and then implement a version solely for use when compiling under WASM.</p>
<p>As the caching code in SpiceDB is only used for production servers, we could simply change our cache into a no-op:</p>
<div><pre tabindex="0"><code data-lang="go"><span>package</span> cache

<span>import</span> (
 <span>&#34;fmt&#34;</span>
)

<span>// NewCache returns an error for caching.
</span><span>// This is used because ristretto cannot be built under WASM.
</span><span></span><span>func</span> <span>NewCache</span>(config *Config) (Cache, <span>error</span>) {
 <span>return</span> <span>nil</span>, fmt.<span>Errorf</span>(<span>&#34;caching is currently unsupported in WASM&#34;</span>)
}
</code></pre></div><p>By implementing the file as <code>cache_wasm.go</code> with the <code>_wasm.go</code> suffix, the Go compiler automatically only compiles the file for the <code>wasm</code> platform.</p>
<p>With the interface implemented, the next step was to now tell Go to ignore the Ristretto-based implementation when compiling for WASM: normally this could be accomplished with a similar platform-specific suffix on the source file, but as this implementation is intended for <strong>all</strong> platforms besides WASM, a different approach was necessary.</p>
<p>This was therefore accomplished by using the Go conditional compilation comments:</p>
<div><pre tabindex="0"><code data-lang="go"><span>//go:build !wasm
</span><span>// +build !wasm
</span></code></pre></div><p>The above conditional compilation comments tell the Go compiler to ignore the source file if <code>wasm</code> is the specified platform.</p>
<h2 id="loading-spicedb-in-javascript">Loading SpiceDB in JavaScript</h2>
<p>With SpiceDB now compiling into a WASM binary, the next step was to load the WASM code into the JavaScript runtime and determine a means of invoking the necessary functions for the development environment.</p>
<p>Here, the Go developers have helpfully provided a library to do just that: <a href="https://github.com/golang/go/blob/master/misc/wasm/wasm_exec.js">wasm_exec.js</a>.</p>
<p>As seen in the <a href="https://github.com/golang/go/blob/master/misc/wasm/wasm_exec.html">wasm_exec example</a>, the library is included and then a call to <code>instantiateStreaming</code> is used to load the compiled Go binary:</p>
<div><pre tabindex="0"><code data-lang="html">&lt;<span>script</span> <span>src</span>=<span>&#34;wasm_exec.js&#34;</span>&gt;&lt;/<span>script</span>&gt;
&lt;<span>script</span>&gt;
  <span>// Based on: https://github.com/golang/go/blob/master/misc/wasm/wasm_exec.html
</span><span></span>  <span>if</span> (WebAssembly) {
    <span>// WebAssembly.instantiateStreaming is not currently available in Safari
</span><span></span>    <span>if</span> (WebAssembly &amp;&amp; !WebAssembly.instantiateStreaming) {
      <span>// polyfill
</span><span></span>      WebAssembly.instantiateStreaming = <span>async</span> (resp, importObject) =&gt; {
        <span>const</span> source = <span>await</span> (<span>await</span> resp).arrayBuffer();
        <span>return</span> <span>await</span> WebAssembly.instantiate(source, importObject);
      };
    }

    <span>const</span> go = <span>new</span> Go();
    WebAssembly.instantiateStreaming(fetch(<span>&#34;main.wasm&#34;</span>), go.importObject).then(
      (result) =&gt; {
        go.run(result.instance);
      }
    );
  } <span>else</span> {
    console.log(<span>&#34;WebAssembly is not supported in your browser&#34;</span>);
  }
&lt;/<span>script</span>&gt;
</code></pre></div><p>Note the <code>fetch</code> call used to retrieve the binary data itself: this means that <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a> must be enabled or the same web server used.</p>
<p>It is also <strong>very important</strong> to enable caching and compression of the WASM binary being loaded, as these WASM binaries can be quite large (ours is 25MB uncompressed); fortunately, our frontend performance tests caught this issue</p>
<h2 id="calling-spicedb-from-javascript">Calling SpiceDB from JavaScript</h2>
<p>With SpiceDB loaded into the JavaScript context, the next step was determining a way that the two different environments could be connected.</p>
<p>Fortunately for us, the Go team also covered this use case via the <a href="https://pkg.go.dev/syscall/js">syscall/js</a> library, which provides methods for easily accessing the JavaScript environment, converting objects between the two environments, and error handling.</p>
<p>For SpiceDB, we chose to use a callback-based approach for invoking the development methods: the <a href="https://github.com/authzed/spicedb/blob/main/pkg/development/wasm/main.go">SpiceDB development package main</a> registers a single callback function <code>runSpiceDBDevelopmentOperations</code>, which is invoked with the set of operations to run, and invokes callbacks with its results.</p>
<p>Registering the callback via <code>syscall/js</code> proved to be very simple:</p>
<div><pre tabindex="0"><code data-lang="go">c := <span>make</span>(<span>chan</span> <span>struct</span>{}, <span>0</span>)
js.<span>Global</span>().<span>Set</span>(<span>&#34;runSpiceDBDevelopmentOperations&#34;</span>, js.<span>FuncOf</span>(runDevelopmentOperations))
fmt.<span>Println</span>(<span>&#34;Development interface initialized&#34;</span>)
&lt;-c
</code></pre></div><p>Note the use of <code>js.FuncOf</code> in the call, which converts the Go function into a JavaScript function: such conversion is necessary throughout the package, whenever a function or object needs to be serialized across the boundary of the environments:</p>
<div><pre tabindex="0"><code data-lang="go">operation := op.<span>Get</span>(<span>&#34;operation&#34;</span>).<span>String</span>()
parameters := op.<span>Get</span>(<span>&#34;parameters&#34;</span>).<span>String</span>()
callback := op.<span>Get</span>(<span>&#34;callback&#34;</span>)
</code></pre></div><p>With the ability to define arbitrary functions to be run inside the SpiceDB development package, we now had a complete toolset to use in the Playground:</p>
<div><pre tabindex="0"><code data-lang="js"><span>const</span> [devErrs, err] = runSpiceDBDevelopmentOperations(
  JSON.stringify({
    <span>&#39;schema&#39;</span>: <span>`definition user {}
</span><span>
</span><span>              definition document {
</span><span>                  relation viewer: user
</span><span>                  permission view = viewer
</span><span>              }`</span>,
    <span>&#39;relationships&#39;</span>: [
        {
            resource_and_relation: {
                namespace: <span>&#39;document&#39;</span>,
                object_id: <span>&#39;somedoc&#39;</span>,
                relation: <span>&#39;viewer&#39;</span>,
            },
            subject: {
                    namespace: <span>&#39;user&#39;</span>,
                    object_id: <span>&#39;foo&#39;</span>,
                    relation: <span>&#39;...&#39;</span>
            }
        }
    ],
  }),
  [
      {
          operation: <span>&#39;check&#39;</span>,
          parameters: JSON.stringify({
              resource: {
                  namespace: <span>&#39;document&#39;</span>,
                  object_id: <span>&#39;somedoc&#39;</span>,
                  relation: <span>&#39;view&#39;</span>,
              },
              subject: {
                  namespace: <span>&#39;user&#39;</span>,
                  object_id: <span>&#39;foo&#39;</span>,
                  relation: <span>&#39;...&#39;</span>,
              }
          }),
          callback: (result, err) =&gt; {
              console.log(result, err)
          }
      },
      ...
    ],
)
</code></pre></div><p>A complete example of invoking the package can be found in <a href="https://github.com/authzed/spicedb/blob/main/pkg/development/wasm/example/wasm.html">the example</a></p>
<h2 id="benefits">Benefits</h2>
<p>Conversion of the Playground to use these functions (instead of the previous grpc-web equivalents) proved very straightforward and immediately provided a number of benefits, such as the ability to use the playground’s tooling offline and for a good deal of code reduction and cleanup. A bonus was that we were able to remove some supporting back end services and simplify our architecture.</p>
<p>However, there was a major side benefit that was unexpected when we began this project: <strong>performance</strong>.</p>
<p>Previous calls from the playground were grpc-web requests made over the network to the development API<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> that was running within GCP. These calls could take over 50ms. Not necessarily slow but long enough to notice a delay, especially for large requests (schemas with many definitions and/or large test relationship data).</p>
<p>Currently with in-browser processing, the same requests often return in under 5ms, a 90% reduction in latency! But perhaps more importantly, latencies at this rate are perceived to be instant, which in the context of developing and iterating in the playground, can make the development experience more delightful by eliminating friction in the feedback loop. If Amazon famously found that an <a href="https://news.ycombinator.com/item?id=273900">extra 100ms of latency</a> had negative impacts, hopefully gaining 45ms will have the opposite, positive impact for our users.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>When we initially started the project, I expected far more rough edges than actually encountered, but the Go team has done an excellent job in making the use of Go via WASM straightforward, both in terms of compilation and invocation.</p>
<p>I recommend visiting <a href="https://play.authzed.com">https://play.authzed.com</a> now to give the new, faster playground a try!</p>
<p>Have questions about SpiceDB or the WASM integration? Visit the <a href="https://authzed.com/discord">Discord</a></p>
<h2 id="notes">Notes</h2>

</div></div>
  </body>
</html>
