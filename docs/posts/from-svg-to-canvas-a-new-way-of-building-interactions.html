<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://felt.com/blog/svg-to-canvas-part-2-building-interactions">Original</a>
    <h1>From SVG to Canvas – A new way of building interactions</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>While the DOM and React give you a lot of useful tools “for free”, that easy on-ramp starts to get very steep as you try to add more complex interactions.</p></div></div><div><div><div><div><p>In Part 1 of the post describing<a href="https://felt.com/blog/from-svg-to-canvas-part-1-making-felt-faster" target="_blank"> how we switched from SVG to Canvas</a>, we talked about how we render the elements in a performant way. But rendering performance was just one thing we aimed to achieve with the switchover. The other was a better way of writing our interaction-handling code.</p><p>In this part, we’re going to talk about how we wrote a new interaction handling system from the ground up, covering:</p><ul role="list"><li>the problems with our React approach</li><li>what we wanted to achieve with the new system</li><li>how it simplified our existing interaction code</li><li>how we solved a long-standing wishlist item that we couldn’t do with React</li></ul><h2>Interacting with SVGs in React</h2><p>As a quick reminder, here’s a simplified example of how our React components were structured in the SVG world:</p><p>Visually, it’s arranged roughly like this:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646d1289e6e1913989df3780_Triangles.jpeg" loading="lazy" alt=""/></p></figure><p>The different parts are:</p><ul role="list"><li>The &lt;p-inline&gt;Element&lt;p-inline&gt; itself (green)</li><li>The &lt;p-inline&gt;SelectionFrame&lt;p-inline&gt; which shows when the element is selected (pink)</li><li>The &lt;p-inline&gt;DragBox&lt;p-inline&gt;, which is a transparent DOM element that lets you drag the element when selected, but is “behind” other elements so they can be selected on top (blue)</li></ul><p>In the SVG world, we use CSS &lt;p-inline&gt;z-index&lt;p-inline&gt; to place the DragBox at the back and the SelectionFrame at the front.</p><p>With SVGs we get a lot of useful stuff “for free” which made it easy for us to get started developing Felt:</p><ul role="list"><li>the mouse only hits SVG elements inside their painted region, which is great for the &lt;p-inline&gt;Element&lt;p-inline&gt; portion</li><li>we could use things like &lt;p-inline&gt;pointer-events&lt;p-inline&gt; to disable certain interactions at certain times</li><li>because the interaction code and rendering code are together in a React component, simply not rendering the React component also disables the interactions.</li></ul><p>However, there are also some limitations of that model, which give us some problems.</p><h3>Performance</h3><p>Yes, we already covered performance last time, but it’s worth mentioning again with respect to interactions.</p><p>Having every element produce a whole load of DOM elements for React to manage becomes a problem for performance when every element attaches event handlers, has to manage their lifecycles, observe state, etc., etc.</p><p>Here’s an example of the layers created in the DOM for a map with just a handful of elements.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646d1301453508d076894f55_squares.jpeg" loading="lazy" alt=""/></p></figure><h3>Interactivity limitations</h3><p>With our SVG renderer, each element managed its own interactions, which made it impossible to drag elements that were underneath other elements. This is a surprisingly common when making complex maps.</p><p>In the example below, we have the red polygon selected, with some yellow text over the top of it.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646d13143724cc632a870e2f_Map.jpeg" loading="lazy" alt=""/></p></figure><p>Now, say we want to drag the red polygon – but with the text taking up so much space it’s very easy to accidentally drag the text instead, which is <strong>really</strong> irritating!</p><p>This was a very longstanding bug, which was very difficult to solve with DOM elements. With each element having a self-centered view of the world, having it know about every other element too would introduce a lot of extra complexity!</p><h3>Maintainability</h3><p>Another problem that affected us was our ability to fix bugs and make sure they stayed fixed.</p><p>Although we have a comprehensive suite of automated end-to-end Playwright tests, we can’t reasonably cover every single combination of interactions, so we rely on the code structure and cleanliness as a way to reduce bugs.</p><p>However, with every element attaching its own interactions, there is a tendency for every interaction to know about every other, checking if it should be enabled or not. This leads to code that looks a bit like this:</p><p>As you can see, we’re checking lots of other features to see if they’re “active” before continuing with our own work.</p><p>Another maintainability issue is the proliferation of &lt;p-inline&gt;event.stopPropagation()&lt;p-inline&gt; calls in the code. These are to stop events bubbling up through the complex DOM structure and allowing other components to handle events.</p><p>We also have a few places where we have awkward &lt;p-inline&gt;setTimeout()&lt;p-inline&gt; calls where we can’t actually stop the event reaching another part of the code, so instead have to signal that we’ve handled it and that someone else shouldn’t.</p><p>This type of complexity explodes as more features are added, and that’s not what we want to be dealing with – we want to be shipping the features our users are asking for!</p><h2>What we wanted from the new world</h2><p>Taking all our pain points into consideration, we set some goals for the new system.</p><ol role="list"><li>Features should not need to know about each other</li><li>We should be able to write precise, complex interactions with minimum fuss</li><li>Concepts and code should remain simple and not intertwined</li><li>Interactions should be performant</li></ol><h2>The new system: per-state InteractionHandlers</h2><p>OK, so the name is quite generic and doesn’t tell you much, but I’ll do my best to explain.</p><p>The general idea is this: there are <strong><em>a lot</em></strong> of different things you can do in Felt, but at any given time, the number of things you can do is limited. If we can therefore define <strong><em>which interactions are active at any given time</em></strong>, and also <strong>manage the flow of events through the handlers</strong> we should be in a good place.</p><p>Here, you can see an example of how our InteractionHandlers are set up for a given app mode.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646d3cdb0bc9061c35e7016c_image%2012.jpeg" loading="lazy" alt=""/></p></figure><p>As you can see, for a given &lt;p-inline&gt;AppMode&lt;p-inline&gt; there is a prioritized list of handlers that are active. Which ones are active depends on the &lt;p-inline&gt;AppMode&lt;p-inline&gt; and is specified in a &lt;p-inline&gt;handlerMap&lt;p-inline&gt;.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646d3cf50bc9061c35e74a62_image%2013.jpeg" loading="lazy" alt=""/></p></figure><p>The &lt;p-inline&gt;InteractionManager&lt;p-inline&gt; is responsible for:</p><ul role="list"><li>starting and stopping each handler when it becomes active or inactive</li><li>converting DOM events to &lt;p-inline&gt;InteractionHandler&lt;p-inline&gt; events.</li><li>For instance, we have &lt;p-inline&gt;onDragStart&lt;p-inline&gt; which is synthesized from raw &lt;p-inline&gt;onPointerDown&lt;p-inline&gt; and &lt;p-inline&gt;onPointerMove&lt;p-inline&gt; events</li><li>We also are able to stop &lt;p-inline&gt;onClick&lt;p-inline&gt; from being called if the mouse is dragged far enough</li><li>calling each relevant &lt;p-inline&gt;InteractionHandler&lt;p-inline&gt; with each event</li><li>dealing with the &lt;p-inline&gt;InteractionHandler&lt;p-inline&gt; responses</li></ul><p>Each &lt;p-inline&gt;InteractionHandler&lt;p-inline&gt; is responsible for:</p><ul role="list"><li>managing its own state</li><li>resetting or clearing that state as appropriate when the handler is started or stopped</li><li>responding to the events appropriately, especially:</li><li>requesting no further propagation to any other handlers</li><li>requesting no further propagation to any future events (e.g. to terminate a &lt;p-inline&gt;onPointerDown -&gt; onPointerUp -&gt; onClick&lt;p-inline&gt; sequence in the middle)</li></ul><p>Here is the full sequence of events that an &lt;p-inline&gt;InteractionHandler&lt;p-inline&gt; can process, with the ability to break the chain at any point, and prevent other handlers in the stack from being called.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646e34906208a680483b8dfa_Canvasimage.png" loading="lazy" alt=""/></p></figure><p>These &lt;p-inline&gt;InteractionHandlers&lt;p-inline&gt; are just objects satisfying a specific TypeScript interface. They’re not coupled to React or hooks or anything like that, which feels quite freeing, honestly. There’s no worrying about stale closures or dependencies or hooks rules - it really is just TypeScript.</p><p>This setup has some nice properties that speak to our goals. I’ll take each in turn and describe how it helps us.</p><h3>Goal 1: Interactions should be decoupled from each other</h3><p>Each interaction handler has no knowledge of any other. The knowledge about how to prevent “collisions” in interactions resides with the map of handlers and the manager.</p><p>There is no code in this system that has to check if other features are “busy” in order to decide to act or not. That “priority” is encoded in the map of app modes to handlers, and then each subsystem works independently.</p><p>One particularly nice aspect of this system is that key presses follow the same flow as pointer events, which is not how things work in the DOM. In the DOM, you usually bind key handlers globally, and pointer events per element. But here, we get all the benefits of stopping propagation centrally, which is a real help for adding keyboard shortcuts and modifier keys.</p><h3>Goal 2: Interactions should be performant</h3><p>Because there is only one handler per feature as opposed to a bunch of handlers per element, there is <strong><em>a lot</em></strong> less allocation of resources.</p><p>You can see in this Chrome DevTools Performance Monitor trace how the memory usage, DOM Node count and JS event listeners count explodes as we switch from Canvas back to DOM rendering.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646d634604b1c1c4ecf778eb_Image%20A.jpeg" loading="lazy" alt=""/></p></figure><h3>Goal 3: Interactions should be decoupled from access control</h3><p>Access control is now simply a case of writing a different list of interaction handlers for each access level. There’s no longer any &lt;p-inline&gt;isEditor&lt;p-inline&gt; code littered throughout.</p><p>Here is a sample of how the available interactions differ between users with edit capabilities and those with just viewer capabilities.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646d638430cc3ed8215a1580_Image%20B.jpeg" loading="lazy" alt=""/></p></figure><p>We also have an &lt;p-inline&gt;inert&lt;p-inline&gt; access level, where all interactions are disabled, simply by configuring empty lists of handlers for every possible app state. This would be very fiddly and error-prone to do with the previous system.</p><h3>Goal 4: Interactions should be decoupled from rendering</h3><p>None of the interactions depend on a particular rendering system. We can actually use the DOM as a render target with all its pointer events disabled, and use this interaction system on top, which is quite neat!</p><p>Aside from being quite fun, we also want this property for the future of Felt. As the gap between map elements and layer features narrows, there’s a strong chance we’ll elect to push all of our rendering of geographic elements into MapLibre to get even more performance, but leave all our app-specific rendering (selection frames, etc.) alone. With this system, we can leave all the interactions completely alone, which makes this possible migration a lot easier.</p><p>This is semantically how the app is separated right now.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646d63ad9296ebf2dd283b94_Image%20C.jpeg" loading="lazy" alt=""/></p></figure><p>And here’s how we could change that in the future, pushing element rendering down to the same technology as the basemap rendering. All of the interactions are left alone.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6122baa5c8ee4c2543565975/646d63bf6e41a4e6dc703e93_Image%20D.jpeg" loading="lazy" alt=""/></p></figure><p>This decoupling means that we don’t have a typical “object model” for the scene like many drawing or graphics systems have. Instead, each interaction handler acts on the whole scene, rather than being tied to an individual element.</p><p>Rather than having to deal with figuring out which elements are under the cursor, or which elements are locked, hidden, etc. our &lt;p-inline&gt;InteractionManager&lt;p-inline&gt; also handles all this, then this is passed into the handlers for easy access.</p><p>Each handler having an overarching view of the entire scene is what allows us to achieve one of some of our more complex interactions…</p><h3>Goal 5: Complex interactions should be achievable</h3><p>One small interaction that we had always wanted to add to Felt had been all but unattainable in the DOM world: being able to drag through unselected elements, but still being able to click them to select.</p><p>In the video, you can see that we select the red polygon, which is ordered beneath the white text. Then, we are still able to drag the red polygon <strong><em>through</em></strong> the white text, but also click on the white text to switch the selection to that.</p><p><iframe src="https://www.youtube.com/embed/eCkuW9KrjAU?rel=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></p><p>This happens a surprising amount in mapmaking, partly because of the many irregular shapes and large zoom ranges. And when it doesn’t work, it can be <strong>really</strong> frustrating.</p><p>Doing this with an element-centric approach is nigh-on impossible. There’s no way (as far as we know) to say to a DOM element: “receive clicks, but pass-through mousedowns and drags.”</p><p>In the behavior-centric approach, this is very straightforward. Because the &lt;p-inline&gt;dragHandler&lt;p-inline&gt; and selectionHandler don’t overlap in the events they handle, there’s really no interference at all.</p><p>This is all we need to achieve this with our new system!</p><p>OK, there are some hidden details there such as how we get the &lt;p-inline&gt;elementsUnderCursor&lt;p-inline&gt;, and the &lt;p-inline&gt;topElement&lt;p-inline&gt;. There’s a fair bit of supporting code that is out of scope for this post, but for those that are interested, we maintain a spatial index of our elements using <a href="https://www.npmjs.com/package/rbush">rbush</a> which we query for coarse intersections with the cursor before performing more accurate hit tests using <a href="https://turfjs.org/">Turf.js</a>.</p><p>Despite brushing over the details, you can hopefully see the elegance of this approach. By not attaching events to DOM nodes, we don’t have to worry about CSS &lt;p-inline&gt;pointer-events&lt;p-inline&gt;, &lt;p-inline&gt;z-index&lt;p-inline&gt; etc., and can focus on domain-specific code like: “am I starting to drag over an already selected element?”</p><h2>Trade-offs</h2><p>While our resulting system is certainly more manageable and with clearer code than the DOM-based solution, it’s not without its difficult parts.</p><p>Firstly, it takes a bit of getting used to thinking about interactions from an app-wide context rather than an element-specific one. It means that what can turn out to be easy solutions don’t seem obvious. The “drag-through unselected elements” interaction is a good example. I was so used to thinking about things in terms of elements and layers that I was overcomplicating the solution, until a coworker implemented it in a few lines, succinctly describing it as “click prioritizes z-index, drag prioritizes selection”.</p><p>Secondly, the browser does a lot of useful work with SVGs for hit testing. Getting to browser-native levels of performance for intersecting long paths hasn’t been straightforward. We’ve had to do a lot of spatial indexing, pruning and other optimisations in order to be able to quickly determine things like whether the mouse is over a line with 20,000 vertices!</p><h2>Conclusions</h2><p><a href="https://felt.com/blog/from-svg-to-canvas-part-1-making-felt-faster" target="_blank">I mentioned this in Part 1</a>, but I wouldn’t recommend undertaking a big change like this without feature flags, performance benchmarks and a good suite of end-to-end tests.</p><p>I would, however, definitely recommend considering whether it’s worth taking the leap away from the “default” way of doing things if something doesn’t feel right. While our interaction system isn’t completely novel and draws on a lot of things for inspiration (including the DOM APIs and concepts), it’s certainly a divergence from the norm.</p><p>While making the switchover, there were certain bits of functionality missed or forgotten, but fixing issues in this new system has felt a lot easier than fixing bugs in the previous system, and even some of the more fiddly fixes can be implemented cleanly without reaching for hacks.</p><p>Hopefully, this new baseline of maintainability, simplicity, and performance will survive all the new features we want to add to Felt for our users in the future.</p><p>And that’s what it’s all about, really: making sure we can spend more time focusing on what our users want and make Felt an even better way to work with maps.</p></div></div></div></div></div>
  </body>
</html>
