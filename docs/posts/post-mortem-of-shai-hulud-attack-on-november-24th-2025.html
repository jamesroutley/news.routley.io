<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://posthog.com/blog/nov-24-shai-hulud-attack-post-mortem">Original</a>
    <h1>Post-mortem of Shai-Hulud attack on November 24th, 2025</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>At 4:11 AM UTC on November 24th, a number of our SDKs and other packages were compromised, with a malicious self-replicating worm - <span data-state="closed"><a rel="noopener noreferrer" href="https://www.wiz.io/blog/shai-hulud-2-0-ongoing-supply-chain-attack" target="">Shai-Hulud 2.0</a></span>. New versions were published to npm, which contained a preinstall script that:</p><ol><li><p>Scanned the environment the install script was running in for credentials of any kind using Trufflehog, an open-source security tool that searches codebases, Git histories, and other data sources for secrets.</p></li><li><p>Exfiltrated those credentials by creating a new public repository on GitHub and pushing the credentials to it.</p></li><li><p>Used any npm credentials found to publish malicious packages to npm, propagating the breach.</p></li></ol><p>By 9:30 AM UTC, we had identified the malicious packages, deleted them, and revoked the tokens used to publish them. We also began the process of rolling all potentially compromised credentials pre-emptively, although we had not at the time established how our own npm credentials had been compromised (we have now, <span data-state="closed"><a rel="noopener noreferrer" href="#how-did-it-happen" target="">details below</a></span>).</p><p>The attack only affected our Javascript SDKs published in npm. The most relevant compromised packages and versions were:</p><ul><li><code>posthog-node</code> 4.18.1, 5.13.3 and 5.11.3</li><li><code>posthog-js</code> 1.297.3</li><li><code>posthog-react-native</code> 4.11.1</li><li><code>posthog-docusaurus</code> 2.0.6</li><li><code>posthog-react-native-session-replay</code>@1.2.2</li><li><code>@posthog/agent</code>@1.24.1</li><li><code>@posthog/ai</code>@7.1.2</li><li><code>@posthog/cli</code>@0.5.15</li></ul><p>If you are using the <code>script</code> version of PostHog <strong>you were not affected</strong> since the worm spread via the <code>preinstall</code> step when installing your dependencies on your development/CI/production machines.</p><p>If you are using one of our Javascript SDKs, our recommendations are to:</p><ol><li>Look for the malicious files locally, in your home folder, or your document roots:</li></ol><ol start="2"><li>Check npm logs for suspicious entries:</li></ol><ol start="3"><li>Delete any cached dependencies:</li></ol><p>Pin any dependencies to a known-good version (in our case, all the <strong>latest published versions</strong>, which have been published after we identified the attack, are known-good), and then reinstall your dependencies. </p><p>We also suggest you make use of the <code>minimumReleaseAge</code> setting present both in <code>yarn</code> and <code>pnpm</code>. By setting this to a high enough value (like 3 days), you can make sure you won&#39;t be hit by these vulnerabilities before researchers, package managers, and library maintainers have the chance to wipe the malicious packages.</p><p>PostHog&#39;s own package publishing credentials were not compromised by the worm described above. We were targeted directly, as were a number of other major vendors, to act as a &#34;patient zero&#34; for this attack. </p><p>The first step the attacker took was to steal the Github Personal Access Token of one of our bots, and then use that to steal the rest of the Github secrets available in our CI runners, which included this npm token. These steps were done days before the attack on the 24th of November.</p><p>At 5:40PM on November 18th, now-deleted user <code>brwjbowkevj</code> opened a pull request against our <code>posthog</code> repository, including <span data-state="closed"><a rel="noopener noreferrer" href="https://github.com/PostHog/posthog/commit/485ec6ce8068ee3846611840554001fe0bca4c43" target="">this commit</a></span>. This PR changed the code of a script executed by a workflow we were running against external contributions, modifying it to send the secrets available during that script&#39;s execution to a webhook controlled by the attacker. These secrets included the Github Personal Access Token of one of our bots, which had broad repo write permissions across our organization. The PR itself was deleted along with the fork it came from when the user was deleted, but the commit was not.</p><p>The PR was opened, the workflow run, and the PR closed within the space of 1 minute (screenshots include timestamps in UTC+2, the author&#39;s timezone):</p><p><span><span data-rmiz-wrap="visible"><img src="https://res.cloudinary.com/dmukukwp6/image/upload/w_1600,c_limit,q_auto,f_auto/initial_pr_logs_287a1790ee.png" alt="initial PR logs"/></span></span></p><p>At 3:28 PM UTC on November 23rd, the attacker used these credentials to delete a workflow run. We believe this was a test, to see if the stolen credentials were still valid (it was successful).</p><p>At 3:43 PM, the attacker used these credentials again, to create <span data-state="closed"><a rel="noopener noreferrer" href="https://github.com/PostHog/posthog/commit/0132974d901a78d11a58a3cca3665a680391f966" target="">another commit</a></span> masquerading, by chance, as the report&#39;s author (we believe this was a randomly chosen branch on which the author happened to be the last legitimate contributor given that the author does not possess any special privileges on his GitHub account).</p><p>This commit was pushed directly as a detached commit, not as part of a pull request or similar. In it, the attacker modified an arbitrary <code>Lint PR</code> workflow directly to exfiltrate all of our Github secrets. Unlike the previous PR attack, which could only modify the script called from the workflow, and as such could only exfiltrate our bot PAT, this commit had full write access to our repository given the ultra-permissive PAT which meant they could run arbitrary code on the scope of our Github Actions runners.</p><p>With that done, the attacker was able to run their modified workflow, and did so at 3:45 PM UTC:</p><p><span><span data-rmiz-wrap="visible"><img src="https://res.cloudinary.com/dmukukwp6/image/upload/w_1600,c_limit,q_auto,f_auto/follow_up_commit_c676c00451.png" alt="Follow up commit workflow runs"/></span></span></p><p>The principal associated with these workflow actions is <code>posthog-bot</code>, our Github bot user, whose PAT was stolen in the initial PR. We were only able to identify this specific commit as the pivot after the fact using Github audit logs, due to the attackers deletion of the workflow run following its completion.</p><p>At this point, the attacker had our npm publishing token, and 12 hours later, at 4:11 AM UTC the following morning, published the malicious packages to npm, starting the worm.</p><p>As noted, PostHog was not the only vendor used as an initial vector for this broader attack. We expect other vendors will be able to identify similar attack patterns in their own audit logs.</p><p>PostHog is proudly <span data-state="closed"><a rel="noopener noreferrer" href="https://github.com/posthog/posthog" target="">open-source</a></span>, and that means a lot of our repositories frequently receive external contributions (thank you). </p><p>For external contributions, we want to automatically assign reviewers depending on which parts of our codebase the contribution changed. GitHub&#39;s <code>CODEOWNERS</code> file is typically used for this, but we want the review to be a &#34;soft&#34; requirement, rather than blocking the PR for internal contributors who might be working on code they don&#39;t own. </p><p>We had a workflow, <code>auto-assign-reviewers.yaml</code>, which was supposed to do this, but it never really worked for external contributions since it required manual approval defeating the purpose of automatically tagging the right people without manual interference.</p><p>One of our engineers figured out this was because it triggered <code>on: pull_request</code> which means external contributions (which come from forks, rather than branches in the repo like internal contributions) would not have the workflow automatically run. The fix for this was changing the trigger to be <code>on: pull_request_target</code>, which runs the workflow <em>as it&#39;s defined in the PR target repo/branch</em>, and is therefore considered safe to auto-run. </p><p>Our engineer opened a PR to make this change, and also make some fixes to the script, including checking out the current branch, rather than the PR base branch, so that the diffing would work properly. This change seemed safe, as our understanding of <code>on: pull_request_target</code> was, roughly, &#34;ok, this runs the code as it is in master/the target repo&#34;. </p><p>This was a dangerous misconception, for a few reasons:</p><ul><li><p><code>on: pull_request_target</code> only ensures the <em>workflow</em> is being run as defined in the PR target, not the code being run - that&#39;s controlled by the checkout step.</p></li><li><p>This particular workflow executed code from within the repo - a script called <code>assign-reviewers.js</code>, which was initially developed for internal (and crucially, trusted) auto-assignment, but was now being used for external assignment too.</p></li><li><p>The workflow was modified to manually checkout the git commit of the PR head, rather than the PR base, so that the diffing would work correctly for external contributions, but this meant that the code being run was controlled by the PR author.</p></li></ul><p>These pieces together meant it was possible for a pull request which modified <code>assign-reviewers.js</code> to run arbitrary code, within the context of a trusted CI run, and therefore steal our bot token.</p><p>Why did this workflow change get merged? Honestly, security is unintuitive. </p><ol><li><p>The engineer making the change thought <code>pull_request_target</code> ensured that the version of <code>assign-reviewers.js</code> being executed, a script stored in <code>.github/scripts</code> in the repository, would be the one on master, rather than the one in the PR. </p></li><li><p>The engineer reviewing the PR thought the same.</p></li><li><p>None of us noticed the security hole in the month and a half between the PR being merged and the attack (the PR making this change was merged on the 11th of September). This workflow change was even flagged by one of our static analysis tools before merge, but we explicitly dismissed the alert because we mistakenly thought our usage was safe.</p></li></ol><p>Workflow rules, triggers and execution contexts are hard to reason about - so hard to reason about that <span data-state="closed"><a rel="noopener noreferrer" href="https://github.blog/changelog/2025-11-07-actions-pull_request_target-and-environment-branch-protections-changes/" target="">Github is actively making changes to make them simpler</a></span> and closer to our understanding above. Although, in our case, these changes would not have protected us against the initial attack.</p><p>Notably, we identified copycat attacks on the following day attempting to leverage the same vulnerability, and while we prevented those, we had to take frustratingly manual and uncertain measures to do so. The changes Github is making to the behaviour of <code>pull_request_target</code> would have prevented those copycats automatically for us.</p><p>This is the largest and most impactful security incident we&#39;ve ever had. We feel terrible about it, and we&#39;re doing everything we can to prevent something like this from happening again. </p><p>I won&#39;t enumerate all the process and posture changes we&#39;re implementing here, beyond saying:</p><ul><li><p>We&#39;ve significantly tightened our package release workflows (moving to the trusted publisher model).</p></li><li><p>Increased the scrutiny any PR modifying a workflow file gets (requiring a specific review from someone on our security team).  </p></li><li><p>Switched to pnpm 10 (to disable <code>preinstall</code>/<code>postinstall</code> scripts and use <code>minimumReleaseAge</code>).</p></li><li><p>Re-worked our Github secrets management to make our response to incidents like this faster and more robust.</p></li></ul><p>PostHog is, in many of our engineers minds, first and foremost a data company. We&#39;ve grown a lot in the last few years, and for that time, our focus has always been on data security - ensuring the data you send us is safe, that our cloud environments are secure, and that we never expose personal information. This kind of attack, being leveraged as an initial vector for an ecosystem-wide worm, simply wasn&#39;t something we&#39;d prepared for.</p><p>At a higher level, we&#39;ve started to take broad security a lot more seriously, even prior to this incident. In July, we hired <span data-state="closed"><a href="https://posthog.com/community/profiles/34651">Tom P</a></span>, who&#39;s been fully dedicated to improving our overall security posture. Both our incident response and the analysis in this post-mortem simply wouldn&#39;t have been possible without the tools and practices he&#39;s put in place, and while there&#39;s a huge amount still to do, we feel good about the progress we&#39;re making. We have to do better here, and we feel confident we will.</p><p>Given the prominence of this attack and our desire to take this work seriously, we wanted to use this as a chance to say that if you&#39;d like to work in our security team, and write post-mortems like these (or, better still, write analysis like this about attacks you stopped), we&#39;re always looking for new talent. Email <code>tom.p at posthog dot com</code>, or apply directly on our <span data-state="closed"><a href="https://posthog.com/careers">careers page</a></span>.</p></div></div></div>
  </body>
</html>
