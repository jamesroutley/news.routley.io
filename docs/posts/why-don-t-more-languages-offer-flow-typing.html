<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ayazhafiz.com/articles/22/why-dont-more-languages-offer-flow-typing">Original</a>
    <h1>Why don&#39;t more languages offer flow typing?</h1>
    
    <div id="readability-page-1" class="page"><article>
<ul id="toc">
<li><a href="#what-is-flow-typing%3F">What is flow typing?</a></li>
<li><a href="#why-should-i-care%3F">Why should I care?</a>
<ul>
<li><a href="#typescript-and-mypy">TypeScript and MyPy</a></li>
<li><a href="#ml-family-pattern-matching">ML-family pattern matching</a></li>
<li><a href="#narrowing-inheritance-hierarchies">Narrowing inheritance hierarchies</a></li>
</ul>
</li>
<li><a href="#design-in-context%2C-or-why-you-would-and-wouldn&#39;t-want-to-implement-this">Design in context, or why you would and wouldn&#39;t want to implement this</a>
<ul>
<li><a href="#implementation-typescript">TypeScript and MyPy</a>
<ul>
<li><a href="#bonus-round-ts">Bonus round: Implementing flow typing a-la TypeScript</a></li>
</ul>
</li>
<li><a href="#ml-family-languages">ML-family languages</a>
<ul>
<li><a href="#inconsistencies-with-closed-sum-types">Inconsistencies with closed sum types</a></li>
</ul>
</li>
<li><a href="#complication-of-the-compilation-model">Complication of the compilation model</a></li>
</ul>
</li>
<li><a href="#what-can-we-do-about-this%3F">What can we do about this?</a>
<ul>
<li><a href="#bonus-round%3A-why-do-polymorphic-variants-make-flow-typing-easier-to-implement%3F">Bonus round: why do polymorphic variants make flow typing easier to implement?</a></li>
</ul>
</li>
<li><a href="#theory-and-practice-of-flow-typing">Theory and practice of flow typing</a></li>
</ul>
<p>Some programming languages have a feature known as <a href="https://en.wikipedia.org/wiki/Flow-sensitive_typing">flow typing</a>.
Flow typing narrows types based on control flow, and I believe it
generally increases development productivity.
In this cc I&#39;ll outline the behavior of flow typing, explain why it works well
in some languages, would not work so well in others, and where flow typing can
fit nicely elsewhere.</p>
<h2 id="what-is-flow-typing%3F" tabindex="-1"><a href="#what-is-flow-typing%3F" aria-hidden="true"></a>What is flow typing?</h2>
<p>A type system observes flow typing when it refines values&#39; types due to control flow.
In this sense, flow typing avoids making you squint to see narrowed types.
As a simple example in TypeScript,</p>
<pre><p>ts</p><p><code><p><span>type</span><span> </span><span><data-lsp lsp="type ViewsResponse = {
    views: number;
} | {
    error: string;
}">ViewsResponse</data-lsp></span><span> = {</span><span><data-lsp lsp="(property) views: number">views</data-lsp></span><span>: </span><span>number</span><span>}|{</span><span><data-lsp lsp="(property) error: string">error</data-lsp></span><span>: </span><span>string</span><span>};</span></p><p><span>declare</span><span> </span><span>function</span><span> </span><span><data-lsp lsp="function getViewsOf(route: string): ViewsResponse">getViewsOf</data-lsp></span><span>(</span><span><data-lsp lsp="(parameter) route: string">route</data-lsp></span><span>: </span><span>string</span><span>): </span><span><data-lsp lsp="type ViewsResponse = {
    views: number;
} | {
    error: string;
}">ViewsResponse</data-lsp></span><span>;</span></p><p><span>const</span><span> </span><span><data-lsp lsp="const viewsResp: ViewsResponse">viewsResp</data-lsp></span><span> = </span><span><data-lsp lsp="function getViewsOf(route: string): ViewsResponse">getViewsOf</data-lsp></span><span>(</span><span>&#39;/cc&#39;</span><span>);</span></p><p><span>if</span><span> (</span><span>&#34;views&#34;</span><span> </span><span>in</span><span> </span><span><data-lsp lsp="const viewsResp: ViewsResponse">viewsResp</data-lsp></span><span>) {</span></p><p><span>    </span><span><data-lsp lsp="var console: Console">console</data-lsp></span><span>.</span><span><data-lsp lsp="(method) Console.log(...data: any[]): void">log</data-lsp></span><span>(</span><span>`Had </span><span>${</span><span><data-lsp lsp="const viewsResp: {
    views: number;
}">viewsResp</data-lsp></span><span>.</span><span><data-lsp lsp="(property) views: number">views</data-lsp></span><span>}</span><span> views`</span><span>)</span></p><p><span>                          </span><span>const viewsResp: {
    views: number;
}</span></p><p><span>} </span><span>else</span><span> {</span></p><p><span>    </span><span><data-lsp lsp="var console: Console">console</data-lsp></span><span>.</span><span><data-lsp lsp="(method) Console.error(...data: any[]): void">error</data-lsp></span><span>(</span><span>`Failed to get views: </span><span>${</span><span><data-lsp lsp="const viewsResp: {
    error: string;
}">viewsResp</data-lsp></span><span>.</span><span><data-lsp lsp="(property) error: string">error</data-lsp></span><span>}</span><span>`</span><span>)</span></p><p><span>                                             </span><span>const viewsResp: {
    error: string;
}</span></p><p><span>}</span></p></code></p></pre>
<p>The type of <code>viewsResp</code> here is refined based on the
conditional branch taken, because entry into one branch means <code>viewsResp</code> must
be of a narrower type than the one <code>getViewsOf</code> was declared to return.</p>
<h2 id="why-should-i-care%3F" tabindex="-1"><a href="#why-should-i-care%3F" aria-hidden="true"></a>Why should I care?</h2>
<p>Good question. I claim that because it makes programs stricter by enriching the
state of types with the possible runtime state,
flow typing makes software more expressive and its development safer.</p>
<p>Like everything else, there is some degree of pedantry here. But this is not an
armchair exercise; I genuinely believe that where they can, languages should
support this kind of type refinement. To motivate this further, let&#39;s walk
through why TypeScript and MyPy adopted it, and look at examples in other languages
where this kind of refinement would be useful.</p>
<h3 id="typescript-and-mypy" tabindex="-1"><a href="#typescript-and-mypy" aria-hidden="true"></a>TypeScript and MyPy</h3>
<p>Both TypeScript and MyPy employ type systems that permit anonymous structural
unions. For example, the TypeScript type <code>string|number</code> is the type that
is inhabited by all values that inhabit either <code>string</code> or <code>number</code><span><label for="python-str-int"></label></span><span>With Python&#39;s type hints, this is roughly <code>Union[str, int]</code>.</span>.</p>
<p>Now, supporting such a type system is not a light choice from an implementer&#39;s
perspective (we&#39;ll look <a href="#implementation-typescript">at why below</a>). But
contextually, it makes sense why these type systems do so. TypeScript and
Python&#39;s type hints
were built for languages where the runtime shapes of values can vary arbitrarily.
This means that if you want
someone using JavaScript or unannotated Python to start using your typechecker,
you have to meet them where there programs are. That may include being able to
specify the type of a single value that might be a string, an integer, a
dictionary with five keys, or a set. In time your users may refine their types,
even enough so that they can be statically type checked,
but you can&#39;t expect them to do so when they (or you) can&#39;t even yet express
what their types are!</p>
<p>Nevertheless, it&#39;s almost useless to know something is a <code>string|number</code> at a
specific point.
Really what you want to know is, &#34;is this value a string, or is it a
number?&#34;, and do some computation based on that result. It&#39;s nice when the type
system follows you when the question is answered on the result of some
condition, and so falls out flow typing!</p>
<p>The results of this typechecking have <a href="#implementation-typescript">no runtime cost</a>
in TypeScript and Python. So barring the <a href="#bonus-round-ts">implementation and checking
cost</a>, the significant benefit in developer
experience makes such a feature a huge win.</p>
<h3 id="ml-family-pattern-matching" tabindex="-1"><a href="#ml-family-pattern-matching" aria-hidden="true"></a>ML-family pattern matching</h3>
<p>Alright, so here&#39;s how this fits elsewhere. First up is pattern-matching on ADTs
a la Haskell, OCaml, etc. I&#39;ll just look at Rust here since that syntax will
probably be the most familiar.</p>
<p>The case study here is the compiler for the <a href="https://roc-lang.org">Roc programming
language</a>. Here is a small portion of our LLVM codegen
procedure for operator calls:</p>
<pre><p>rust</p><p><code><p><span>// ...</span></p><p><span>// &lt;previous branches&gt;</span></p><p><span><data-lsp lsp="NumAdd: LowLevel">NumAdd</data-lsp></span><span> | </span><span><data-lsp lsp="NumSub: LowLevel">NumSub</data-lsp></span><span> | </span><span><data-lsp lsp="NumMul: LowLevel">NumMul</data-lsp></span><span> </span><span>/* ... */</span><span> | </span><span><data-lsp lsp="NumMulChecked: LowLevel">NumMulChecked</data-lsp></span><span> =&gt; {</span></p><p><span>    </span><span><data-lsp lsp="core::macros

macro_rules! debug_assert_eq

---

Asserts that two expressions are equal to each other.

On panic, this macro will print the values of the expressions with their
debug representations.

Unlike [`assert_eq`](https://doc.rust-lang.org/nightly/core/macros/macro.assert_eq.html), `debug_assert_eq!` statements are only enabled in non
optimized builds by default. An optimized build will not execute
`debug_assert_eq!` statements unless `-C debug-assertions` is passed to the
compiler. This makes `debug_assert_eq!` useful for checks that are too
expensive to be present in a release build but may be helpful during
development. The result of expanding `debug_assert_eq!` is always type checked.

# Examples

let a = 3;
let b = 1 + 2;
debug_assert_eq!(a, b);">debug_assert_eq</data-lsp>!</span><span>(</span><span><data-lsp lsp="args: Vec&lt;Arg&gt;">args</data-lsp></span><span>.</span><span><data-lsp lsp="alloc::vec::Vec

pub fn len(&amp;self) -&gt; usize

---

Returns the number of elements in the vector, also referred to
as its &#39;length&#39;.

# Examples

let a = vec![1, 2, 3];
assert_eq!(a.len(), 3);">len</data-lsp></span><span>(), </span><span>2</span><span>);</span></p><p><span>    </span><span>let</span><span> (</span><span><data-lsp lsp="lhs_arg: Arg">lhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="lhs_layout: Layout">lhs_layout</data-lsp></span><span>) = </span><span><data-lsp lsp="cc

fn load_symbol_and_layout(arg: Arg) -&gt; (Arg, Layout)">load_symbol_and_layout</data-lsp></span><span>(</span><span><data-lsp lsp="args: Vec&lt;Arg&gt;">args</data-lsp></span><span>[</span><span>0</span><span>]);</span></p><p><span>    </span><span>let</span><span> (</span><span><data-lsp lsp="rhs_arg: Arg">rhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="rhs_layout: Layout">rhs_layout</data-lsp></span><span>) = </span><span><data-lsp lsp="cc

fn load_symbol_and_layout(arg: Arg) -&gt; (Arg, Layout)">load_symbol_and_layout</data-lsp></span><span>(</span><span><data-lsp lsp="args: Vec&lt;Arg&gt;">args</data-lsp></span><span>[</span><span>1</span><span>]);</span></p><p><span>    </span><span><data-lsp lsp="cc

fn build_num_binop(op: LowLevel, lhs_arg: Arg, lhs_layout: Layout, rhs_arg: Arg, rhs_layout: Layout)">build_num_binop</data-lsp></span><span>(</span><span><data-lsp lsp="let op: LowLevel">op</data-lsp></span><span>, </span><span><data-lsp lsp="lhs_arg: Arg">lhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="lhs_layout: Layout">lhs_layout</data-lsp></span><span>, </span><span><data-lsp lsp="rhs_arg: Arg">rhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="rhs_layout: Layout">rhs_layout</data-lsp></span><span>)</span></p><p><span>                    </span><span>let op: LowLevel</span></p><p><span>}</span></p><p><span><data-lsp lsp="NumBitwiseAnd: LowLevel">NumBitwiseAnd</data-lsp></span><span> | </span><span><data-lsp lsp="NumBitwiseOr: LowLevel">NumBitwiseOr</data-lsp></span><span> | </span><span><data-lsp lsp="NumBitwiseXor: LowLevel">NumBitwiseXor</data-lsp></span><span> =&gt; {</span></p><p><span>    </span><span><data-lsp lsp="core::macros

macro_rules! debug_assert_eq

---

Asserts that two expressions are equal to each other.

On panic, this macro will print the values of the expressions with their
debug representations.

Unlike [`assert_eq`](https://doc.rust-lang.org/nightly/core/macros/macro.assert_eq.html), `debug_assert_eq!` statements are only enabled in non
optimized builds by default. An optimized build will not execute
`debug_assert_eq!` statements unless `-C debug-assertions` is passed to the
compiler. This makes `debug_assert_eq!` useful for checks that are too
expensive to be present in a release build but may be helpful during
development. The result of expanding `debug_assert_eq!` is always type checked.

# Examples

let a = 3;
let b = 1 + 2;
debug_assert_eq!(a, b);">debug_assert_eq</data-lsp>!</span><span>(</span><span><data-lsp lsp="args: Vec&lt;Arg&gt;">args</data-lsp></span><span>.</span><span><data-lsp lsp="alloc::vec::Vec

pub fn len(&amp;self) -&gt; usize

---

Returns the number of elements in the vector, also referred to
as its &#39;length&#39;.

# Examples

let a = vec![1, 2, 3];
assert_eq!(a.len(), 3);">len</data-lsp></span><span>(), </span><span>2</span><span>);</span></p><p><span>    </span><span>let</span><span> (</span><span><data-lsp lsp="lhs_arg: Arg">lhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="lhs_layout: Layout">lhs_layout</data-lsp></span><span>) = </span><span><data-lsp lsp="cc

fn load_symbol_and_layout(arg: Arg) -&gt; (Arg, Layout)">load_symbol_and_layout</data-lsp></span><span>(</span><span><data-lsp lsp="args: Vec&lt;Arg&gt;">args</data-lsp></span><span>[</span><span>0</span><span>]);</span></p><p><span>    </span><span>let</span><span> (</span><span><data-lsp lsp="rhs_arg: Arg">rhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="rhs_layout: Layout">rhs_layout</data-lsp></span><span>) = </span><span><data-lsp lsp="cc

fn load_symbol_and_layout(arg: Arg) -&gt; (Arg, Layout)">load_symbol_and_layout</data-lsp></span><span>(</span><span><data-lsp lsp="args: Vec&lt;Arg&gt;">args</data-lsp></span><span>[</span><span>1</span><span>]);</span></p><p><span>    </span><span><data-lsp lsp="core::macros

macro_rules! debug_assert_eq

---

Asserts that two expressions are equal to each other.

On panic, this macro will print the values of the expressions with their
debug representations.

Unlike [`assert_eq`](https://doc.rust-lang.org/nightly/core/macros/macro.assert_eq.html), `debug_assert_eq!` statements are only enabled in non
optimized builds by default. An optimized build will not execute
`debug_assert_eq!` statements unless `-C debug-assertions` is passed to the
compiler. This makes `debug_assert_eq!` useful for checks that are too
expensive to be present in a release build but may be helpful during
development. The result of expanding `debug_assert_eq!` is always type checked.

# Examples

let a = 3;
let b = 1 + 2;
debug_assert_eq!(a, b);">debug_assert_eq</data-lsp>!</span><span>(</span><span><data-lsp lsp="lhs_layout: Layout">lhs_layout</data-lsp></span><span>, </span><span><data-lsp lsp="rhs_layout: Layout">rhs_layout</data-lsp></span><span>);</span></p><p><span>    </span><span>let</span><span> </span><span><data-lsp lsp="let int_width: IntWidth">int_width</data-lsp></span><span> = </span><span><data-lsp lsp="cc

fn intwidth_from_layout(layout: Layout) -&gt; IntWidth">intwidth_from_layout</data-lsp></span><span>(</span><span><data-lsp lsp="lhs_layout: Layout">lhs_layout</data-lsp></span><span>);</span></p><p><span>    </span><span><data-lsp lsp="cc

fn build_int_binop(op: LowLevel, int_width: IntWidth, lhs_arg: Arg, rhs_arg: Arg)">build_int_binop</data-lsp></span><span>(</span><span><data-lsp lsp="let op: LowLevel">op</data-lsp></span><span>, </span><span><data-lsp lsp="let int_width: IntWidth">int_width</data-lsp></span><span>, </span><span><data-lsp lsp="lhs_arg: Arg">lhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="rhs_arg: Arg">rhs_arg</data-lsp></span><span>)</span></p><p><span>                    </span><span>let op: LowLevel</span></p><p><span>}</span></p><p><span>// &lt;later branches&gt;</span></p><p><span>// ...</span></p></code></p></pre>
<p>In short, we&#39;re branching on some groups of operations, doing some intermediate
computation/validation, and then passing the operation to a continuation. Now
importantly, <code>NumAdd</code> and <code>NumBitwiseAnd</code> are both the same type - they are
variants of a sum <code>LowLevel</code>:</p>
<pre><p>rust</p><p><code><p><span>pub</span><span> </span><span>enum</span><span> </span><span><data-lsp lsp="cc

pub enum LowLevel">LowLevel</data-lsp></span><span> {</span></p><p><span>    // ...</span></p><p><span>    </span><span><data-lsp lsp="cc::LowLevel

NumAdd">NumAdd</data-lsp></span><span>,</span></p><p><span>    // ...</span></p><p><span>    </span><span><data-lsp lsp="cc::LowLevel

NumBitwiseAnd">NumBitwiseAnd</data-lsp></span><span>,</span></p><p><span>    // ...</span></p><p><span>}</span></p></code></p></pre>
<p>which is purely nominal, as sum types in most ML-family languages are. So the
type of <code>op</code> being passed to
<code>build_num_binop</code> and <code>build_int_binop</code> is the same, even though both of those
functions only need to worry about a subset of the variants in <code>LowLevel</code>! The
type system can&#39;t help these calls out, and so the functions enforce the values
they need to care about at runtime - indeed, both functions have a default case
of <code>unreachable!()</code> for the variants of <code>LowLevel</code> they aren&#39;t concerned with.
Wouldn&#39;t it be nice if instead, we had a way to say, &#34;in this branch, op is
<code>LowLevel::{NumBitwiseAnd|NumBitwiseOr|NumBitwiseXor}</code>&#34;?</p>
<p>A natural reaction is that the type of <code>LowLevel</code> is underspecified, and that
instead it should be arranged as something like</p>
<pre><p>rust</p><p><code><p><span>pub</span><span> </span><span>enum</span><span> </span><span><data-lsp lsp="cc

pub enum LowLevelAnyNum">LowLevelAnyNum</data-lsp></span><span> { </span><span><data-lsp lsp="cc::LowLevelAnyNum

NumAdd">NumAdd</data-lsp></span><span>, </span><span>/* ... */</span><span> }</span></p><p><span>pub</span><span> </span><span>enum</span><span> </span><span><data-lsp lsp="cc

pub enum LowLevelAnyInt">LowLevelAnyInt</data-lsp></span><span> { </span><span><data-lsp lsp="cc::LowLevelAnyInt

NumBitwiseAnd">NumBitwiseAnd</data-lsp></span><span>, </span><span>/* ... */</span><span> }</span></p><p><span>pub</span><span> </span><span>enum</span><span> </span><span><data-lsp lsp="cc

pub enum LowLevel">LowLevel</data-lsp></span><span> {</span></p><p><span>    </span><span><data-lsp lsp="cc::LowLevel

Num(LowLevelAnyNum)">Num</data-lsp></span><span>(</span><span><data-lsp lsp="cc

pub enum LowLevelAnyNum">LowLevelAnyNum</data-lsp></span><span>),</span></p><p><span>    </span><span><data-lsp lsp="cc::LowLevel

Int(LowLevelAnyInt)">Int</data-lsp></span><span>(</span><span><data-lsp lsp="cc

pub enum LowLevelAnyInt">LowLevelAnyInt</data-lsp></span><span>),</span></p><p><span>    // ...</span></p><p><span>}</span></p></code></p></pre>
<p>Which - I agree - in many cases is definitely the way you should structure these
types! But at the limit, you end up with an overspecified model<span><label for="overspecification"></label></span><span>For example, the Roc compiler has a generator that
produces a memory layout <code>Layout</code> for a type. We have a method
that takes a type we know is a number and gives us what we know is a
<code>Layout::Int</code> or <code>Layout::Float</code>. Should we group <code>Int</code> and <code>Float</code> in a nested <code>Layout::Number</code> variant?
Maybe, but then we also have
functions that only return or only operate on <code>Int</code>s, or
<code>Int</code>s and <code>TagUnion</code>s, and so on.
It turns out that <code>Layout</code> is the common denominator, and operating in terms of
its top-level variants feels the most natural.
Doing so reduces boilerplate in moving
things in and out of a layout, and alleviates the cognitive load
(read: annoyance) that comes with that.</span>
, which can lead to needlessly verbose software
and a rigid design. I don&#39;t think that&#39;s always
good software engineering. I want our tools should make software development easier,
and designs that are better for tools should only be considered if they are also
better for developers.</p>
<p>There is another problem here, which is that the reshaping of <code>LowLevel</code> in this
way takes an ADT that could be represented in a byte before (it has less than
256 variants) to something that requires at least two (one for the variant tag, e.g. <code>Num</code>, and one
for the payload, e.g. <code>LowLevelAnyNum</code>). A sufficiently smart compiler
could optimize this away to one byte, and maybe it doesn&#39;t even matter
in a world of 64-byte cache lines. But it&#39;s something we should at least
keep in the back of our minds.</p>
<h3 id="narrowing-inheritance-hierarchies" tabindex="-1"><a href="#narrowing-inheritance-hierarchies" aria-hidden="true"></a>Narrowing inheritance hierarchies</h3>
<p>As a last example, I want to show where this has a role in object-oriented languages. Here&#39;s a sketch of a browser rendering
engine:</p>
<pre><p>java</p><p><code><p><span>class</span><span> </span><span>Renderer</span><span> {</span></p><p><span>    </span><span>static</span><span> </span><span>class</span><span> </span><span>DomNode</span><span> {</span></p><p><span>        </span><span>interface</span><span> </span><span>Node</span><span> {}</span></p><p><span>        </span><span>static</span><span> </span><span>class</span><span> </span><span>Element</span><span> </span><span>implements</span><span> </span><span>Node</span><span> { </span><span>/* ... */</span><span> }</span></p><p><span>        </span><span>static</span><span> </span><span>class</span><span> </span><span>Comment</span><span> </span><span>implements</span><span> </span><span>Node</span><span> { </span><span>/* ... */</span><span> }</span></p><p><span>        </span><span>// ...</span></p><p><span>    };</span></p><p><span>    </span><span>static</span><span> </span><span>class</span><span> </span><span>RenderNode</span><span> {</span></p><p><span>        </span><span>interface</span><span> </span><span>Node</span><span> {}</span></p><p><span>        </span><span>static</span><span> </span><span>class</span><span> </span><span>Styled</span><span> </span><span>implements</span><span> </span><span>Node</span><span> { </span><span>/* ... */</span><span> }</span></p><p><span>        </span><span>static</span><span> </span><span>class</span><span> </span><span>Noop</span><span>   </span><span>implements</span><span> </span><span>Node</span><span> { </span><span>/* ... */</span><span> }</span></p><p><span>        </span><span>// ...</span></p><p><span>    };</span></p><p><span>    </span><span>RenderNode</span><span>.</span><span>Node</span><span> </span><span>render</span><span>(</span><span>DomNode</span><span>.</span><span>Node</span><span> </span><span>node</span><span>, </span><span>StyleSheet</span><span> </span><span>styles</span><span>) {</span></p><p><span>        </span><span>if</span><span> (node </span><span>instanceof</span><span> </span><span>DomNode</span><span>.</span><span>Element</span><span>) {</span></p><p><span>            </span><span>Layout</span><span> </span><span>layout</span><span> = ((</span><span>DomNode</span><span>.</span><span>Element</span><span>) node).</span><span>layout</span><span>;</span></p><p><span>            </span><span>// ...</span></p><p><span>            </span><span>return</span><span> </span><span>new</span><span> RenderNode.</span><span>Styled</span><span>(layout, </span><span>/* ... */</span><span>);</span></p><p><span>        }</span></p><p><span>        </span><span>return</span><span> </span><span>new</span><span> RenderNode.</span><span>Noop</span><span>(</span><span>/* ... */</span><span>);</span></p><p><span>    }</span></p><p><span>}</span></p></code></p></pre>
<p>Admittedly I am not a Java expert, but almost every enterprise Java codebase
I&#39;ve had to work with has observed this pattern of testing whether an object is
an instance of particular subclass, and using that to drive further computation.
Even in the presence of such tests, Java demands that the author cast their
objects appropriately. Of course you can always introduce an intermediate
variable after the test, but I argue that this is still too much - upon
verifying the instance of an object, the type system should be smart enough to
update the object&#39;s type appropriately!</p>
<p>C++ does alleviate redundancy here a little bit by permitting assignment
within conditionals, so you can do something like</p>
<pre><p>cpp</p><p><code><p><span>if</span><span> (</span><span>auto</span><span> root = </span><span>dynamic_cast</span><span>&lt;StyledBox*&gt;(root)) {</span><span> /* ... */</span><span> }</span></p></code></p></pre>
<p>And the newly-scope variable <code>root</code> will be typed as <code>StyledBox*</code> inside the
branch - which is a lot nicer, but why do I have to introduce a new variable?
Actually, there are decent reasons, which we&#39;ll now get to.</p>
<h2 id="design-in-context%2C-or-why-you-would-and-wouldn&#39;t-want-to-implement-this" tabindex="-1"><a href="#design-in-context%2C-or-why-you-would-and-wouldn&#39;t-want-to-implement-this" aria-hidden="true"></a>Design in context, or why you would and wouldn&#39;t want to implement this</h2>
<p>The thing with programming language design, like anything else, is that
you can&#39;t design features in isolation. And, there are many levels to your
features&#39; interactions that must be considered and balanced.</p>
<p>Platitudes aside, I think this feature is &#34;hard but worth it&#34; for
TypeScript, and &#34;mostly doesn&#39;t fit&#34; in the other languages we looked at. Let&#39;s
look at why.</p>
<h3 id="implementation-typescript" tabindex="-1"><a href="#implementation-typescript" aria-hidden="true"></a>TypeScript and MyPy</h3>
<p>We&#39;ve already noted that flow typing provides a nice developer experience in
these type systems, and often meets developers where they&#39;re at. A huge part of
the TypeScript and MyPy type systems is having anonymous, structural union
types, so this just fits naturally. There we go, a plus for flow typing!</p>
<p>As I mentioned, this is not the end of the story. The other big thing we
have to consider here is the runtime semantics that this type-level feature
introduces. In fact it doesn&#39;t change the runtime semantics at all! JavaScript
and Python runtimes typically act on values uniformly or examine their shape
at runtime. Moreover, TypeScript fully erases type information before lowering
to JavaScript, and Python&#39;s type hints are not used by runtimes to determine
value layouts<span><label for="python-type-hints-runtime-cost"></label></span><span>The difference with Python is that type hints are not erased during program
interpretation, so there is some cost to parsing and resolving symbols in type
hints. For all intents and purposes this cost is negligible, though.</span>.</p>
<h4 id="bonus-round-ts" tabindex="-1"><a href="#bonus-round-ts" aria-hidden="true"></a>Bonus round: Implementing flow typing a-la TypeScript</h4>
<p>Okay, bonus round - this is still not the end of the story. Turns out that
implementing flow typing for anonymous structural unions in the presence of
structural subtyping is a problem I would
characterize as &#34;hard&#34;. There are known techniques like
<a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">normalizing to a canonical form</a>
and using <a href="https://whileydave.com/publications/Pea13_VMCAI_preprint.pdf">polar type atoms</a>
to define subtyping, but at least for me, it doesn&#39;t feel like a walk in the
park. I don&#39;t want to dive deep into the challenges here<span><label for="flow-typing-problems"></label></span><span>If you are interested in a thorough introduction to the
context of this problem and algorithms for the kind of subtyping flow typing
must employ, I highly recommend this <a href="https://arxiv.org/pdf/1809.01427.pdf">tutorial-style paper by Castagna</a>.</span>,
but I&#39;ll lay out the high-level.</p>
<p>In a language like TypeScript where you can have arbitrary
unions (and intersections), the space of types forms a <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice</a>.
We&#39;re going to wave our hands a bit here and severely abuse the definition, but
this basically means you can take a square napkin, turn it 45 degrees, draw an
arbitrary curve through the resulting diamond, and say everything below
that line defines a type with a certain number of unions and intersections.
Here&#39;s an example, of some funky types $\tau_1$ and $\tau_2$.</p>
<figure><img src="https://ayazhafiz.com/assets/img/flow/t1-t2-diff.png"/><figcaption>$\tau_1$, $\tau_2$, and their difference</figcaption></figure>
<p>So let&#39;s say you have a value of type $\tau_1$, and in a positive branch you
check whether it fits in $\tau_2$. To flow, the type system must be able to
answer &#34;does the curve $\tau_2$ lie underneath $\tau_1$?&#34; And, in the negative
branch, it must be able to answer &#34;what does the region between them look like?&#34;</p>
<p>Now a human or CV program could look at this image and say, &#34;oh yeah, $\tau_2$
is definitely within $\tau_1$, and also here&#39;s what their difference looks like.&#34;
But of course we don&#39;t represent types as pictures inside compilers, and
we need a deterministic, efficient algorithm for this computation - which sounds
fun! And maybe clever! And also hard!</p>
<h3 id="ml-family-languages" tabindex="-1"><a href="#ml-family-languages" aria-hidden="true"></a>ML-family languages</h3>
<p>Flow typing doesn&#39;t work well with the designs of traditional ML-style
languages. I&#39;ll outline two reasons I am aware of.</p>
<h4 id="inconsistencies-with-closed-sum-types" tabindex="-1"><a href="#inconsistencies-with-closed-sum-types" aria-hidden="true"></a>Inconsistencies with closed sum types</h4>
<p>Most ML-style languages have ADTs that are nominal, not structural. This means
that, for example in Rust, I can have two sum types</p>
<pre><p>rust</p><p><code><p><span>enum</span><span> </span><span><data-lsp lsp="cc

enum Number">Number</data-lsp></span><span> { </span><span><data-lsp lsp="cc::Number

One">One</data-lsp></span><span>, </span><span><data-lsp lsp="cc::Number

OrMore">OrMore</data-lsp></span><span> }</span></p><p><span>enum</span><span> </span><span>Age</span><span>    { </span><span>One</span><span>, </span><span>OrMore</span><span> }</span></p></code></p></pre>
<p>Where <code>Number::One</code> and <code>Age::One</code> are not the same type because their
qualified names are different, even though their
structure (and even generated code layout) are the same!</p>
<p>This is antithetical to flow typing, which more-or-less demands the ability to
create anonymous sum types at any turn, which in turns demands that those sum
types be typed structurally<span><label for="anonymous-is-structural"></label></span><span>You can&#39;t
meaningfully give a user-facing name to an anonymous type!</span>.</p>
<p>Let&#39;s look back at a branch of the Rust example we motivated flow typing with
earlier:</p>
<pre><p>rust</p><p><code><p><span><data-lsp lsp="NumBitwiseAnd: LowLevel">NumBitwiseAnd</data-lsp></span><span> | </span><span><data-lsp lsp="NumBitwiseOr: LowLevel">NumBitwiseOr</data-lsp></span><span> | </span><span><data-lsp lsp="NumBitwiseXor: LowLevel">NumBitwiseXor</data-lsp></span><span> =&gt; {</span></p><p><span>    </span><span><data-lsp lsp="core::macros

macro_rules! debug_assert_eq

---

Asserts that two expressions are equal to each other.

On panic, this macro will print the values of the expressions with their
debug representations.

Unlike [`assert_eq`](https://doc.rust-lang.org/nightly/core/macros/macro.assert_eq.html), `debug_assert_eq!` statements are only enabled in non
optimized builds by default. An optimized build will not execute
`debug_assert_eq!` statements unless `-C debug-assertions` is passed to the
compiler. This makes `debug_assert_eq!` useful for checks that are too
expensive to be present in a release build but may be helpful during
development. The result of expanding `debug_assert_eq!` is always type checked.

# Examples

let a = 3;
let b = 1 + 2;
debug_assert_eq!(a, b);">debug_assert_eq</data-lsp>!</span><span>(</span><span><data-lsp lsp="args: Vec&lt;Arg&gt;">args</data-lsp></span><span>.</span><span><data-lsp lsp="alloc::vec::Vec

pub fn len(&amp;self) -&gt; usize

---

Returns the number of elements in the vector, also referred to
as its &#39;length&#39;.

# Examples

let a = vec![1, 2, 3];
assert_eq!(a.len(), 3);">len</data-lsp></span><span>(), </span><span>2</span><span>);</span></p><p><span>    </span><span>let</span><span> (</span><span><data-lsp lsp="lhs_arg: Arg">lhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="lhs_layout: Layout">lhs_layout</data-lsp></span><span>) = </span><span><data-lsp lsp="cc

fn load_symbol_and_layout(arg: Arg) -&gt; (Arg, Layout)">load_symbol_and_layout</data-lsp></span><span>(</span><span><data-lsp lsp="args: Vec&lt;Arg&gt;">args</data-lsp></span><span>[</span><span>0</span><span>]);</span></p><p><span>    </span><span>let</span><span> (</span><span><data-lsp lsp="rhs_arg: Arg">rhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="rhs_layout: Layout">rhs_layout</data-lsp></span><span>) = </span><span><data-lsp lsp="cc

fn load_symbol_and_layout(arg: Arg) -&gt; (Arg, Layout)">load_symbol_and_layout</data-lsp></span><span>(</span><span><data-lsp lsp="args: Vec&lt;Arg&gt;">args</data-lsp></span><span>[</span><span>1</span><span>]);</span></p><p><span>    </span><span><data-lsp lsp="core::macros

macro_rules! debug_assert_eq

---

Asserts that two expressions are equal to each other.

On panic, this macro will print the values of the expressions with their
debug representations.

Unlike [`assert_eq`](https://doc.rust-lang.org/nightly/core/macros/macro.assert_eq.html), `debug_assert_eq!` statements are only enabled in non
optimized builds by default. An optimized build will not execute
`debug_assert_eq!` statements unless `-C debug-assertions` is passed to the
compiler. This makes `debug_assert_eq!` useful for checks that are too
expensive to be present in a release build but may be helpful during
development. The result of expanding `debug_assert_eq!` is always type checked.

# Examples

let a = 3;
let b = 1 + 2;
debug_assert_eq!(a, b);">debug_assert_eq</data-lsp>!</span><span>(</span><span><data-lsp lsp="lhs_layout: Layout">lhs_layout</data-lsp></span><span>, </span><span><data-lsp lsp="rhs_layout: Layout">rhs_layout</data-lsp></span><span>);</span></p><p><span>    </span><span>let</span><span> </span><span><data-lsp lsp="let int_width: IntWidth">int_width</data-lsp></span><span> = </span><span>intwidth_from_layout</span><span>(</span><span><data-lsp lsp="lhs_layout: Layout">lhs_layout</data-lsp></span><span>);</span></p><p><span>    </span><span><data-lsp lsp="cc

fn build_int_binop(op: LowLevel, int_width: IntWidth, lhs_arg: Arg, rhs_arg: Arg)">build_int_binop</data-lsp></span><span>(</span><span><data-lsp lsp="op: LowLevel">op</data-lsp></span><span>, </span><span><data-lsp lsp="let int_width: IntWidth">int_width</data-lsp></span><span>, </span><span><data-lsp lsp="lhs_arg: Arg">lhs_arg</data-lsp></span><span>, </span><span><data-lsp lsp="rhs_arg: Arg">rhs_arg</data-lsp></span><span>)</span></p><p><span>}</span></p></code></p></pre>
<p>Recall that I said it would be nice if we had a way to express, &#34;in this branch, op
is <code>LowLevel::{NumBitwiseAnd|NumBitwiseOr|NumBitwiseXor}</code>.&#34; But I lied and
misled you! This is not nice at all! It would require a new syntactical model to
represent structural type unions, a whole new class of typing rules, and even a
model of <a href="https://en.wikipedia.org/wiki/Row_polymorphism">variant polymorphism</a>
so that I could call <code>build_int_binop</code> with a <code>LowLevel::{NumBitwiseAnd}</code> or
<code>LowLevel::{NumBitwiseAnd|NumBitwiseOr|NumBitwiseXor}</code>. Now, I&#39;m not saying
these are bad features to have in the type system. But they are a huge addition
to the language, and induce a shift in the programming model - which is not
necessarily something you may want!</p>
<p>The same problems would be present in Haskell and OCaml - though, OCaml already
has <a href="https://ocaml.org/manual/polyvariant.html">polymorphic variants</a>, which are
typed structurally. Why aren&#39;t those flow typed? I&#39;m not sure, but my
inclination is that OCaml&#39;s designers don&#39;t want to complicate type
inference rules or the compilation model. Which brings us to the next point.</p>
<h3 id="complication-of-the-compilation-model" tabindex="-1"><a href="#complication-of-the-compilation-model" aria-hidden="true"></a>Complication of the compilation model</h3>
<p>Another downside of flow typing is that languages which generate memory layouts
from types must perform implicit casts when types are narrowed. This is less
of a concern when a compiler generates uniform representations for all values,
or a language runtime has a system for dispatching common operations over
values with different memory layouts<span><label for="js-dispatch"></label></span><span>As JavaScript and
Python engines do.</span>. But Rust&#39;s <code>rustc</code> compiler<span><label for="rustc"></label></span><span>Basically the only one people use today</span>
does not generate code in either of these ways.</p>
<p>Let&#39;s look again at the value <code>op</code> of our running example, which prior to a
particular branch has the type <code>LowLevel</code>. Now say it enters a branch and we&#39;d
like to narrow the type of <code>op</code> to <code>LowLevel::{NumBitwiseAnd|NumBitwiseOr|NumBitwiseXor}</code>,
which is the type expected by <code>build_int_binop</code>. Well, <code>LowLevel</code> and
<code>LowLevel::{NumBitwiseAnd|NumBitwiseOr|NumBitwiseXor}</code> may have different
memory layouts in the generated code! And even if they have the same broad
memory layout, how their variants are represented may differ. For example,
suppose both are represented as a byte. Even in this case, <code>LowLevel</code>, the
variant <code>NumBitwiseAnd</code> may be represented by the byte value <code>53</code>, but in
<code>LowLevel::{NumBitwiseAnd|NumBitwiseOr|NumBitwiseXor}</code>, <code>NumBitwiseAnd</code> would be
represented by the byte value <code>0</code>.</p>
<p>So, the compiler cannot consider these two types transparently, and must instead
insert an implicit cast to narrow <code>op</code> at either the branch or call site<span><label for="implicit-cast"></label></span><span>This problem is alleviated if <code>build_int_binop</code> accepts a narrowed type that
varies polymorphically, but then we incur a code-size cost due to
monomorphization.</span>. We shouldn&#39;t expect such casts to be cheap in general.
The users of our language may not accept such a high implicit cost, and indeed,
we probably want to make high-cost operations explicit.</p>
<p>Actually, this is one area where I think C++&#39;s model for narrowing class
hierarchies is really nice. The code</p>
<pre><p>cpp</p><p><code><p><span>if</span><span> (</span><span>auto</span><span> root = </span><span>dynamic_cast</span><span>&lt;StyledBox*&gt;(root)) {</span><span> /* ... */</span><span> }</span></p></code></p></pre>
<p>which narrows <code>root</code> to <code>StyledBox*</code> from a superclass inside the branch is very
explicit about what it does - <code>dynamic_cast</code> incurs a runtime cost to verify the
legality of <code>root</code>&#39;s downcast. Yet, thanks to C++&#39;s permission of name shadowing
in nested scopes and the syntactic sugar of assignment in <code>if</code> conditions, the
code is still very readable and doesn&#39;t feel crufty.</p>
<h2 id="what-can-we-do-about-this%3F" tabindex="-1"><a href="#what-can-we-do-about-this%3F" aria-hidden="true"></a>What can we do about this?</h2>
<p>I still believe flow typing, in general, is a boon to software development, and
I would like to see judicious use of it more often in languages&#39; type systems.</p>
<p>But if we can&#39;t have flow typing in the presence of</p>
<ul>
<li>Nominal sum types</li>
<li>Implicit casts</li>
<li>A relatively-hard typechecker implementation (recall the <a href="#bonus-round-ts">bonus round</a>)</li>
</ul>
<p>when is it a good fit? Here&#39;s my pitch - in a ML-style language with structural
<a href="https://ocaml.org/manual/polyvariant.html">polymorphic variants</a> a la OCaml.
Replace closed, nominal sum types entirely with structural ones and the problems
of type consistencies and typechecker implementation are resolved<span><label for="polymorphic-variant-problems"></label></span><span>Of course, polymorphic variants <a href="https://ocaml.org/manual/polyvariant.html#s%3Apolyvariant-weaknesses">have their own
problems</a>.</span>.</p>
<p><a href="https://roc-lang.org">Roc</a> is such an up-and-coming language, but that doesn&#39;t
necessarily mean this feature is a good fit for Roc. For, we still need to deal
with implicit casts. Here I think either</p>
<ul>
<li>A special syntax for branches that narrow, making any implicit casts
strictly opt-in</li>
<li>Uniform operations on values, maybe via a performant technique like Swift&#39;s
witness tables (<a href="https://developer.apple.com/videos/play/wwdc2016/416">1</a>, <a href="https://www.youtube.com/watch?v=ctS8FzqcRug">2</a>)</li>
</ul>
<p>would work well. I have a prototype language that implements the former, but of
course that&#39;s just a toy. In any case, there is merit here, and let&#39;s hope we
see more flow typing across all kinds of language paradigms in the future!</p>
<h3 id="bonus-round%3A-why-do-polymorphic-variants-make-flow-typing-easier-to-implement%3F" tabindex="-1"><a href="#bonus-round%3A-why-do-polymorphic-variants-make-flow-typing-easier-to-implement%3F" aria-hidden="true"></a>Bonus round: why do polymorphic variants make flow typing easier to implement?</h3>
<p>I claimed this was the case, and now I must justify it. Like before, I&#39;ll
only provide a sketch.</p>
<p>Polymorphic variants are typically considered in the context of a
<a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner (HM)-style type system</a>,
so we&#39;ll do that here too. In an HM type system, types don&#39;t form a lattice, and
there is (usually) no notion of a subtyping operator. Instead, two types $\tau_1$
and $\tau_2$ are compatible if they &#34;unify&#34;, denoted $\tau_1 \sim \tau_2$, which
roughly corresponds to equivalence modulo instantiation of type
variables. A type variable, like $\alpha$ in the type of the identity function
$\tt{id}\co\alpha\to\alpha$, is universally quantified (polymorphic) and must
be instantiated to be compared to a concrete type.</p>
<p>What this means is that when two structural types are compared, they are always
compared by width and constructor. That means that a structural type union,
composed of some variants, can only ever be compared to other structural type
unions, and moreover two such unions unify only in the way described above.</p>
<p>So suppose a have a value <code>light</code> of structural union type <code>Red|Yellow|Green</code>,
and the branching</p>
<pre><p><code>match light with               # light is Red|Yellow|Green here
    Yellow =&gt; do_yellow light  # light is Yellow here
    _ =&gt; do_other light        # light is Red|Green here</code></p></pre>
<p>In the first branch, we need to do a set intersection to compute the narrowed
type, and in the second branch we must compute a set difference from the
previous branches. The difference is that unlike in the case of subtyping, where
we had a proper two-dimensional lattice, we now only need to operate on one
dimension, because our types are only compared by structural width.</p>
<figure><img src="https://ayazhafiz.com/assets/img/flow/t1-t2-diff-structural.png"/><figcaption>$\tau_1=\tt{Red|Yellow|Green}$, $\tau_2=\tt{Yellow}$, and their difference</figcaption></figure>
<p>That looks a lot easier to design algorithms for!</p>
<h2 id="theory-and-practice-of-flow-typing" tabindex="-1"><a href="#theory-and-practice-of-flow-typing" aria-hidden="true"></a>Theory and practice of flow typing</h2>
<p>I&#39;ve written about flow typing theory and implementation before (<a href="https://ayazhafiz.com/articles/21/lang-narrow">1</a>,
<a href="https://ayazhafiz.com/articles/21/type-inference-for-flow-typing">2</a>). Jake
Donham has a <a href="https://jaked.org/blog/2021-09-07-Reconstructing-TypeScript-part-0">nice blog series</a>
that builds up a type checker a la TypeScript&#39;s (their blog posts include a
sweet visualization tool of what the checker is doing). And of course, there is
no shortage of literature on flow typing (see <a href="https://www.irif.fr/~gc/papers/covcon-again.pdf">1</a>, <a href="https://whileydave.com/publications/Pea13_VMCAI_preprint.pdf">2</a> for starters).</p>
</article></div>
  </body>
</html>
