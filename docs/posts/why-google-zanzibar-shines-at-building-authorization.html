<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.warrant.dev/why-zanzibar-shines-at-building-authorization/">Original</a>
    <h1>Why Google Zanzibar shines at building authorization</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content" itemprop="articleBody"><p>Over the last couple years, authorization (AKA “authz”) has become a hot topic of debate. Proponents of various authz frameworks, libraries, and philosophies have voiced their opinions on how it should be implemented, jockeying for position to become <strong>the</strong> de facto way to implement authz. Among the contestants in this debate, <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/10683a8987dbf0c6d4edcafb9b4f05cc9de5974a.pdf" target="_blank" rel="noopener noreferrer">Google’s Zanzibar</a> has recently emerged as a popular way of not only modeling and enforcing authorization for modern, fine grained use cases, but also of scaling to meet the requirements of today’s large-scale, cloud-native applications.</p><p>When we started Warrant in 2021, we set out to build developer-friendly authorization infrastructure that all engineering teams could use. We knew that Warrant would be a core piece of infrastructure for our customers, so our authz service had to be (1) <strong>generic</strong> enough to model all of their use-cases and (2) <strong>scalable</strong> enough to support access checks across their authz models globally and with low latency. After reading the seminal <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/10683a8987dbf0c6d4edcafb9b4f05cc9de5974a.pdf" target="_blank" rel="noopener noreferrer">Zanzibar paper</a>, we decided to build Warrant’s core authorization engine based on many of the concepts described in the paper (e.g. tuples, namespaces, zookies, etc. – more on these concepts later). We believed that Zanzibar had zeroed in on a set of fundamental concepts and patterns that would help us build a generic solution to the authorization challenges of any application.</p><p>We launched Warrant <a href="https://news.ycombinator.com/item?id=32251305" target="_blank" rel="noopener noreferrer">to much discussion and debate</a> and have tackled a wide variety of authorization challenges since then, helping many companies build production-ready authz. In this post, I’ll talk about why we believe Zanzibar is a great foundation for implementing authorization, discuss some areas where it falls short, and share how we’ve addressed those shortcomings with enhancements of our own.</p><p>Zanzibar provides an intuitive and (more importantly) uniform data model for representing authorization. Its authorization paradigm, known as relationship based access control (ReBAC), is based on the principle that all resources in an application are related to each other via directed relationships (e.g. <code>[user:123] is [owner] of [report:abc]</code>), and the application’s authz rules (i.e. the abilities granted to users of the application) flow from these relationships either explicitly or implicitly. Representing authorization in this way feels intuitive because it’s similar to how most of us already design data models (e.g. relational database schemas) for our own applications, making it easy to understand and reason about authz models in Zanzibar. ReBAC is also extremely flexible, capable of representing any authz model you can throw at it, including other authz paradigms like role based access control (RBAC) and attribute based access control (ABAC).</p><blockquote><p>“Zanzibar provides a uniform data model and configuration language for expressing a wide range of access control policies from hundreds of client services at Google<!-- -->[...]<!-- -->”</p></blockquote><p>–from <strong>Zanzibar: Google’s Consistent, Global Authorization System</strong></p><p>In practice, each relationship between two resources is represented as a “tuple” composed of three parts:</p><ol><li>The <strong>object</strong> (resource) on which the relationship is being specified.</li><li>The <strong>relationship</strong> being specified.</li><li>The <strong>subject</strong> (a resource or group of resources) that will possess the specified relationship on the object.</li></ol><p><img loading="lazy" alt="Zanzibar Graph" src="https://blog.warrant.dev/assets/images/zanzibar-graph-d556d248e082f9b155f2b5d581b726f2.png" width="955" height="372"/></p><p>Together, the set of all tuples makes up a big graph of relationships in which the objects and subjects are the nodes, and the relationships between them are the edges. This graph is powerful because it can be traversed in various ways to determine the capabilities of users in an application. For example, a path between a user and a resource might mean that the user has write privileges on the resource. In another scenario, it might mean that the user is not allowed to perform writes on a different resource. To dictate how the graph can be traversed and to assign semantic meaning (for authz) to the relationships it represents, Zanzibar provides us with <em>namespaces</em>.</p><p>Namespaces allow us to assign meaning to the relationships represented by our graph for the purpose of authorization. Each namespace defines the available relationships (e.g. admin, writer, reader) on a type of resource (e.g. report), and optionally, a set of logical rules that specify how each relationship can be inferred from others (e.g. <code>an [editor] of a [report] is also a [viewer] of that report</code>). They are similar to database schemas in that they allow us to define the structure of an authorization model, but unlike database schemas, namespaces also allow us to express logic on top of that structure. For example, the namespace for a report object type might define three relationships: <code>admin</code>, <code>editor</code>, and <code>viewer</code>. In addition to defining these relationships, the namespace can also specify:</p><ul><li>A subject can only have the admin relationship on a report explicitly.</li><li>A subject can have the editor relationship on a report explicitly OR implicitly if it has the admin relationship on that report.</li><li>A subject can have the viewer relationship on a report explicitly OR implicitly if it has the editor relationship on that report.</li></ul><p>The ability for namespaces to specify logical rules (or policies) like these between relationships makes it possible to separate authorization logic from application logic. This makes application code much simpler. The application only needs to confirm that a user has a particular capability (e.g. editor) before executing a section of code (e.g. persisting a proposed edit on a document).</p><p>While modern, policy-driven authz solutions like Open Policy Agent (OPA) offer some of the features and benefits described so far, one thing remains unique to Zanzibar. It’s a <em>stateful</em>, <em>centralized</em> service, meaning that all tuples (the relationship graph) and namespaces are pieces of data that are stored and updated centrally. A major benefit of this design is the ability to query the data, not only to check if a particular subject has access to a specific resource, but also to get the list of resources a particular subject has access to. This is extremely useful in practice, for example, to audit a user’s privileges for regulatory compliance or to understand the impact of a change to the authorization model before applying it. In our opinion, having the ability to query permissions like this should be a requirement in any authorizaton system and can only be done in a stateful system with a global view of all authz data. However, as with any system design decision, this approach comes with its trade-offs.</p><p>Since Zanzibar stores all authorization data centrally, client applications must make requests to it to check permissions, making it a potential performance bottleneck for those applications. To minimize the end-to-end response times of authz queries, Zanzibar is distributed globally (as close to client applications as possible) and utilizes aggressive caching, responding to queries from cache (in single milliseconds) whenever possible. Because access patterns and freshness requirements for authorization data vary from application to application, Zanzibar has the concept of a “zookie” – a global, incrementing version number for each change made to the authorization data. Zookies make caching feasible while still allowing client applications to dictate when they favor correctness over speed.</p><p>While the concepts and features of Zanzibar are great, Google never built a publicly available implementation because they built Zanzibar to solve their own authorization needs for services like Drive, Docs, YouTube, and more. Fortunately, Warrant implements all of the concepts we’ve discussed so far, many of them with slight variations intended to either improve developer experience or add functionality that we feel Zanzibar lacks.</p><p>In Warrant, <em>tuples</em> are known as <em>warrants</em>. A warrant includes the same three major components (object, relationship, and subject) as a tuple but can also include an optional component that we call a <em>policy</em>. The policy component is a user-defined boolean expression that is evaluated at query-time to determine whether the warrant is available to the query or not. If a warrant matches a query <em>and</em> its policy evaluates to <code>true</code>, that warrant is considered during the query. Otherwise, the warrant is ignored.</p><p>Policies can reference dynamic contextual data that is passed in by the query (e.g. <code>[user:123] is an [approver] of [transaction:abc] [if transaction.amount &lt;= 100]</code>). Having the ability to do this makes Warrant capable of modeling attribute based access control (ABAC) scenarios in which external data (e.g. the transaction amount) is required to make an authorization decision, something Zanzibar’s purely ReBAC approach struggles with. You can learn more about warrants in our <a href="https://docs.warrant.dev/concepts/warrants/" target="_blank" rel="noopener noreferrer">documentation</a>.</p><pre tabindex="0"><code><p>namespaces : tuples :: object types : warrants</p></code></pre><p><em>Namespaces</em>, as described in Zanzibar, are known as <em>object types</em> in Warrant. Object types are represented as JSON and conform to a JSON schema specification. Unlike Zanzibar’s namespaces, object types support the ability to restrict the types of objects that can possess each relationship, making it easier for developers to reason about the scope of each object type’s relationships. Warrant also provides various pre-built object types to standardize and simplify the implementation of common authorization use cases like RBAC, feature entitlements, and multi-tenancy within Zanzibar’s ReBAC paradigm. You can learn more about object types and the various built-in models Warrant offers in our <a href="https://docs.warrant.dev/concepts/object-types/" target="_blank" rel="noopener noreferrer">documentation</a>.</p><p>More than two years after choosing to build Warrant atop Zanzibar’s core principles, we’re extremely happy with our decision. Doing so gave us a solid technical foundation on which to tackle the various complex authorization challenges companies face today. As we continue to encounter new scenarios and use cases, we’ll keep iterating on Warrant to ensure it’s the most capable authorization service. To share what we learn and what we build with the developer community, we recently open-sourced the core <a href="https://github.com/warrant-dev/warrant" target="_blank" rel="noopener noreferrer">authorization engine</a> that powers our fully managed authorization platform, <a href="https://warrant.dev/" target="_blank" rel="noopener noreferrer">Warrant Cloud</a>. If you’re interested in authorization (or Zanzibar), check it out and give it a star!</p></div></div>
  </body>
</html>
