<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/luqmana/be1af5b64d2cda5a533e3e23a7830b44">Original</a>
    <h1>Achievement unlocked: rustc segfault</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-inline-assembly-miscompilation-md">
      
      <div id="file-inline-assembly-miscompilation-md-readme">
    <article itemprop="text"><div><pre>$ <span>cargo build --example basic --features usdt-probes</span>
<span>[...snip...]</span>
<span>error: could not compile `dropshot`</span>

<span>Caused by:</span>
<span>  process didn&#39;t exit successfully: `rustc [...snip...]` (signal: 11, SIGSEGV: invalid memory reference)</span></pre></div>
<p dir="auto"><strong>Achievement unlocked: <code>rustc</code> segfault.</strong></p>
<details>
<summary>Stack trace</summary>
<pre><code>fffffc7fce3fcbc0 librustc_driver-77cef3efbfa7284c.so`llvm::BranchProbabilityInfo::computeEestimateBlockWeight(llvm::Function const&amp;, llvm::DominatorTree*, llvm::PostDominatorTree*)+0xd84()
fffffc7fce3fd370 librustc_driver-77cef3efbfa7284c.so`llvm::BranchProbabilityInfo::calculate(llvm::Function const&amp;, llvm::LoopInfo const&amp;, llvm::TargetLibraryInfo const*, llvm::DominatorTree*, llvm::PostDominatorTree*)+0x131()
fffffc7fce3fd3c0 librustc_driver-77cef3efbfa7284c.so`llvm::BranchProbabilityAnalysis::run(llvm::Function&amp;, llvm::AnalysisManager&lt;llvm::Function&gt;&amp;)+0x134()
fffffc7fce3fd5f0 librustc_driver-77cef3efbfa7284c.so`llvm::detail::AnalysisPassModel&lt;llvm::Function, llvm::BranchProbabilityAnalysis, llvm::PreservedAnalyses, llvm::AnalysisManager&lt;llvm::Function&gt;::Invalidator&gt;::run(llvm::Function&amp;, llvm::AnalysisManager&lt;llvm::Function&gt;&amp;)+0x2f()
fffffc7fce3fd6a0 librustc_driver-77cef3efbfa7284c.so`llvm::AnalysisManager&lt;llvm::Function&gt;::getResultImpl(llvm::AnalysisKey*, llvm::Function&amp;)+0x2de()
fffffc7fce3fd6d0 librustc_driver-77cef3efbfa7284c.so`llvm::BlockFrequencyAnalysis::run(llvm::Function&amp;, llvm::AnalysisManager&lt;llvm::Function&gt;&amp;)+0x3f()
fffffc7fce3fd710 librustc_driver-77cef3efbfa7284c.so`llvm::detail::AnalysisPassModel&lt;llvm::Function, llvm::BlockFrequencyAnalysis, llvm::PreservedAnalyses, llvm::AnalysisManager&lt;llvm::Function&gt;::Invalidator&gt;::run(llvm::Function&amp;, llvm::AnalysisManager&lt;llvm::Function&gt;&amp;)+0x26()
fffffc7fce3fd7c0 librustc_driver-77cef3efbfa7284c.so`llvm::AnalysisManager&lt;llvm::Function&gt;::getResultImpl(llvm::AnalysisKey*, llvm::Function&amp;)+0x2de()
fffffc7fce3fdc30 librustc_driver-77cef3efbfa7284c.so`llvm::AlwaysInlinerPass::run(llvm::Module&amp;, llvm::AnalysisManager&lt;llvm::Module&gt;&amp;)+0xa2c()
fffffc7fce3fdc50 librustc_driver-77cef3efbfa7284c.so`llvm::detail::PassModel&lt;llvm::Module, llvm::AlwaysInlinerPass, llvm::PreservedAnalyses, llvm::AnalysisManager&lt;llvm::Module&gt;&gt;::run(llvm::Module&amp;, llvm::AnalysisManager&lt;llvm::Module&gt;&amp;)+0x15()
fffffc7fce3fddc0 librustc_driver-77cef3efbfa7284c.so`llvm::PassManager&lt;llvm::Module, llvm::AnalysisManager&lt;llvm::Module&gt;&gt;::run(llvm::Module&amp;, llvm::AnalysisManager&lt;llvm::Module&gt;&amp;)+0x4b5()
fffffc7fce3ff170 librustc_driver-77cef3efbfa7284c.so`LLVMRustOptimizeWithNewPassManager+0x7f2()
fffffc7fce3ff3a0 librustc_driver-77cef3efbfa7284c.so`rustc_codegen_llvm::back::write::optimize_with_new_llvm_pass_manager+0x372()
fffffc7fce3ff5b0 librustc_driver-77cef3efbfa7284c.so`rustc_codegen_llvm::back::write::optimize+0x388()
fffffc7fce3ff900 librustc_driver-77cef3efbfa7284c.so`rustc_codegen_ssa::back::write::execute_work_item::&lt;rustc_codegen_llvm::LlvmCodegenBackend&gt;+0x1f3()
fffffc7fce3ffdb0 librustc_driver-77cef3efbfa7284c.so`std::sys_common::backtrace::__rust_begin_short_backtrace::&lt;&lt;rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_ssa::traits::backend::ExtraBackendMethods&gt;::spawn_named_thread&lt;rustc_codegen_ssa::back::write::spawn_work&lt;rustc_codegen_llvm::LlvmCodegenBackend&gt;::{closure#0}, ()&gt;::{closure#0}, ()&gt;+0xf7()
fffffc7fce3fff60 librustc_driver-77cef3efbfa7284c.so`&lt;&lt;std::thread::Builder&gt;::spawn_unchecked_&lt;&lt;rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_ssa::traits::backend::ExtraBackendMethods&gt;::spawn_named_thread&lt;rustc_codegen_ssa::back::write::spawn_work&lt;rustc_codegen_llvm::LlvmCodegenBackend&gt;::{closure#0}, ()&gt;::{closure#0}, ()&gt;::{closure#1} as core::ops::function::FnOnce&lt;()&gt;&gt;::call_once::{shim:vtable#0}+0xa9()
fffffc7fce3fffb0 libstd-ef15f81a900bedf3.so`std::sys::unix::thread::Thread::new::thread_start::h24133bfe318082b5+0x27()
fffffc7fce3fffe0 libc.so.1`_thrp_setup+0x6c(fffffc7fed642280)
fffffc7fce3ffff0 libc.so.1`_lwp_start()
</code></pre>
</details>
<p dir="auto">Ok, so we&#39;re faulting somewhere in LLVM it seems like. From Cliff&#39;s initial investigation:</p>
<blockquote>
<p dir="auto">Anyway, yeah, something about the CFG construction there is generating either an empty basic block or a basic block ending in an unexpected type of instruction (something that is not an LLVM IR terminator instruction) and triggering <a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/IR/BasicBlock.h#L121">https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/IR/BasicBlock.h#L121</a></p>
</blockquote>
<p dir="auto">First order of business then is to just check if the IR is valid. LLVM has a pass to do just that and we can ask <code>rustc</code> to run it first by passing <code>-Z verify-llvm-ir=yes</code> (note we need to switch to nightly to use <code>-Z</code> flags):</p>
<div><pre>$ <span>RUSTFLAGS=<span><span>&#34;</span>-Z verify-llvm-ir=yes<span>&#34;</span></span> cargo +nightly build --example basic --features usdt-probes</span></pre></div>
<p dir="auto">Haha, nope:</p>
<pre><code>Basic Block in function &#39;_ZN8dropshot6server24http_request_handle_wrap28_$u7b$$u7b$closure$u7d$$u7d$17h503b14ddd4edd1deE&#39; does not have terminator!
label %bb24
LLVM ERROR: Broken module found, compilation aborted!

# Demangle w/ rustfilt (c++filt works well enough too)
# Single quotes important to not misinterpret $ as shell vars!

$ rustfilt &#39;_ZN8dropshot6server24http_request_handle_wrap28_$u7b$$u7b$closure$u7d$$u7d$17h503b14ddd4edd1deE&#39;
dropshot::server::http_request_handle_wrap::{{closure}}
</code></pre>
<p dir="auto">The IR generated for a closure in <code>dropshot::server::http_request_handle_wrap</code> is invalid‚Äîsome basic block is missing a terminator.</p>
<p dir="auto">Ok, is it rustc generating the bad IR directly or the result of some transformation pass miscompiling it?</p>
<p dir="auto">But first, let&#39;s cheat and just get the final failing <code>rustc</code> command so we don&#39;t need to rebuild all the deps anytime we change <code>RUSTFLAGS</code>. Re-running the failing <code>cargo</code> command should just output the failing <code>rustc</code> invocation:</p>
<div><pre>$ <span>cargo +nightly build --example basic --features usdt-probes</span>
<span>   Compiling dropshot v0.6.1-dev (/src/dropshot/dropshot)</span>
<span>error: could not compile `dropshot`</span>

<span>Caused by:</span>
<span>  process didn&#39;t exit successfully: `rustc [...snip...]` (signal: 11, SIGSEGV: invalid memory reference)</span></pre></div>
<p dir="auto">From this point we can just directly run the <code>rustc</code> command as outputted with a few modifications:</p>
<ul dir="auto">
<li>add <code>+nightly</code> otherwise the <code>rustc</code> wrapper will attempt to use the rust version mentioned in <code>rust-toolchain.toml</code></li>
<li>remove the <code>--error-format=json</code> and <code>--json=...</code> flags for human-readable output</li>
<li>add <code>-Z verify-llvm-ir=yes</code></li>
<li>change the <code>--emit</code> argument to <code>--emit=llvm-ir</code> because that should be enough to trigger the issue and we&#39;d like to look at the IR later</li>
</ul>
<p dir="auto">Stick this in a simple shell script to easily modify it and run it; call it <code>repro.sh</code>. Verify it still fails as expected:</p>
<div><pre>$ <span>./repro.sh</span>
<span>Basic Block in function &#39;_ZN8dropshot6server24http_request_handle_wrap28_$u7b$$u7b$closure$u7d$$u7d$17h503b14ddd4edd1deE&#39; does not have terminator!</span>
<span>label %bb24</span>
<span>LLVM ERROR: Broken module found, compilation aborted!</span></pre></div>
<p dir="auto">Now back to figuring out where this invalid IR is coming from. Even though we&#39;re doing a debug build, there are still some LLVM passes that get run. So if we want to verify the IR that <code>rustc</code> directly generated, we need to make sure no LLVM passes are run at all (aside from the <code>verify</code> pass itself). The way to do that is via <code>-C no-prepopulate-passes</code> so let&#39;s edit our <code>repro.sh</code> and run it again:</p>

<p dir="auto">Ok <code>rustc</code> has been proven innocent. Looks like some LLVM pass generates invalid IR which really shouldn&#39;t happen! <g-emoji alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">‚ö†Ô∏è</g-emoji></p>
<p dir="auto">Well, now what? Let&#39;s try to find out what pass is responsible!</p>
<p dir="auto">Our first attempt is by asking LLVM to print the IR after each pass‚Äîmaybe we&#39;ll get lucky and see the offending pass last. We do this by modifying <code>repro.sh</code> again:</p>
<ul dir="auto">
<li>remove <code>-C no-prepopulate-passes</code> &amp; <code>-Z verify-llvm-ir=yes</code></li>
<li>add <code>-C llvm-args=--print-after-all</code> to print the IR after every pass</li>
<li>add <code>-C codegen-units=1 -Z no-parallel-llvm</code> to make the output a bit more readable</li>
</ul>
<p dir="auto">Alas, this doesn&#39;t go the way we want as we get the same segfault as before without any of the actual output we wanted :(</p>
<p dir="auto">Ok, new attempt. Let&#39;s skip <code>rustc</code> and see if we can just invoke the LLVM machinery directly via <code>opt</code>. For that, let&#39;s first install it:</p>
<div><pre>$ <span>rustup component add --toolchain nightly llvm-tools-preview</span></pre></div>
<p dir="auto">It is not the most discoverable because it just gets plopped somewhere into <code>rustc</code>&#39;s sysroot directory:</p>
<div><pre>$ <span>OPT=<span><span>$(</span>find <span><span>$(</span>rustc +nightly --print sysroot<span>)</span></span> -name opt<span>)</span></span></span></pre></div>
<p dir="auto">We also need the actual IR to pass to <code>opt</code> so let&#39;s go back and modify our <code>repro.sh</code> to only pass <code>-C no-prepopulate-passes</code>. We should find our initial <code>rustc</code> generated IR. It&#39;s also worth remove the <code>-C debuginfo=2</code> to make the IR a bit smaller:</p>
<div><pre>$ <span>ls ./target/debug/examples/basic<span>*</span>.ll</span>
<span>./target/debug/examples/basic-5f5f0491fbb5b7d3.ll</span></pre></div>
<p dir="auto">Let&#39;s try something simple first and just run the IR through <code>opt</code> without any flags as a smoke test:</p>
<div><pre>$ <span><span>$OPT</span> ./target/debug/examples/basic-5f5f0491fbb5b7d3.ll </span>
<span>opt: ./target/debug/examples/basic-5f5f0491fbb5b7d3.ll:425470:1: error: expected instruction opcode</span>
<span>bb25:                                             ; preds = %bb24</span>
<span>^</span></pre></div>
<p dir="auto"><g-emoji alias="neutral_face" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f610.png">üòê</g-emoji> Wat. Looking at the IR around that line, we find this:</p>
<div><pre>bb24:
<span>; [...snip...]</span>
  <span>%186</span> = <span>invoke</span> <span>i64</span> <span>asm</span> <span>sideeffect</span> inteldialect <span>&#34;990:   clr rax<span>\0A\0A</span>                    .pushsection set_dtrace_probes,<span>\22</span>aw<span>\22</span>,<span>\22</span>progbits<span>\22\0A</span>                    .balign 8<span>\0A</span>            991:<span>\0A</span>                    .4byte 992f-991b    // length<span>\0A</span>                    .byte 1<span>\0A</span>                    .byte 0<span>\0A</span>                    .2byte 1<span>\0A</span>                    .8byte 990b         // address<span>\0A</span>                    .asciz <span>\22</span>dropshot<span>\22\0A</span>                    .asciz <span>\22</span>request-start<span>\22\0A</span>                             // null-terminated strings for each argument<span>\0A</span>                    .balign 8<span>\0A</span>            992:    .popsection<span>\0A</span>                    <span>\0A</span>                    .pushsection yeet_dtrace_probes<span>\0A</span>                    .8byte 991b<span>\0A</span>                    .popsection<span>\0A</span>                <span>\0A</span>        &#34;</span>, <span>&#34;=&amp;{ax}&#34;</span>() #<span>23</span>
          <span>to</span> <span>label</span> <span>%bb25</span> <span>unwind</span> <span>label</span> <span>%cleanup26</span>, <span>!srcloc</span> <span>!38</span>
  <span>store</span> <span>i64</span> <span>%186</span>, <span>i64*</span> <span>%is_enabled</span>, <span>align</span> <span>8</span>

bb25:                                             <span>; preds = %bb24</span>
  <span>%_78</span> = <span>load</span> <span>i64</span>, <span>i64*</span> <span>%is_enabled</span>, <span>align</span> <span>8</span>
  <span>%187</span> = <span>icmp</span> <span>eq</span> <span>i64</span> <span>%_78</span>, <span>0</span>
  <span>br</span> <span>i1</span> <span>%187</span>, <span>label</span> <span>%bb46</span>, <span>label</span> <span>%bb26</span></pre></div>
<p dir="auto">Well that looks awfully like the error the LLVM IR verifier was telling us about (<code>%bb24</code> not having a terminator)!
So looks like our assumption about <code>rustc</code> not being the one generating valid IR is wrong. Where did we go wrong?</p>
<p dir="auto">Some light digging into the <code>rustc</code> source reveals that using the new LLVM pass manager (default for LLVM &gt;= 13 thus Rust &gt;= 1.56) means <code>-Z verify-llvm-ir=yes</code> is ignored when combined with <code>-C no-prepopulate-passes</code>. Whelp :/</p>
<p dir="auto">(To be clear, it&#39;s not really the new pass manager&#39;s fault but rather the way it is setup in <code>LLVMRustOptimizeWithNewPassManager</code>).</p>
<p dir="auto">So we&#39;ve found one (minor) <code>rustc</code> bug so far but that doesn&#39;t help solve our original question. No worries, we can either switch to the old pass manager (<code>-Z new-llvm-pass-manager=no</code>) or just manually add the verifier pass (<code>-C passes=&#34;verify&#34;</code>), either way we get the same ol error:</p>
<div><pre>$ <span>./repro.sh</span>
<span>Basic Block in function &#39;_ZN8dropshot6server24http_request_handle_wrap28_$u7b$$u7b$closure$u7d$$u7d$17h503b14ddd4edd1deE&#39; does not have terminator!</span>
<span>label %bb24</span>
<span>LLVM ERROR: Broken module found, compilation aborted!</span></pre></div>
<p dir="auto">This brings us back to the actual culprit: <code>rustc</code>!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/315eeec086ccf540d56d02e6f40698716c5769b308e0cb38a23bda3c5afe576d/68747470733a2f2f692e696d67666c69702e636f6d2f36633066786f2e6a7067"><img src="https://camo.githubusercontent.com/315eeec086ccf540d56d02e6f40698716c5769b308e0cb38a23bda3c5afe576d/68747470733a2f2f692e696d67666c69702e636f6d2f36633066786f2e6a7067" alt="Scooby Doo Mask Reveal Meme: Panel 1 w/ Mask on &#34;Invalid IR Generator&#34;. Panel 2 w/ Mask off &#34;rustc&#34;" data-canonical-src="https://i.imgflip.com/6c0fxo.jpg"/></a></p>
<p dir="auto">(We really should have suspected this after the brief foray with trying to print the resulting IR after every LLVM pass didn&#39;t give us anything: the IR we feed it was botched to begin with!).</p>
<p dir="auto">So back to the invalid IR: at the end of <code>bb24</code> we are using <code>invoke</code> (a terminator) with our inline assembly from the <a href="https://github.com/oxidecomputer/usdt">usdt</a> probes in <code>dropshot</code> followed by a <code>store</code> instruction. Clearly this is wrong because <code>store</code> isn&#39;t a terminator and thus we shouldn&#39;t end a basic block with it. Let&#39;s see what the corresponding MIR (Rust&#39;s Mid-level IR) looks like.</p>
<p dir="auto">Since the failing code is coming from <code>dropshot</code> and not the basic example itself, we can&#39;t use our <code>repro.sh</code> hack and so back we go to <code>cargo</code> and <code>RUSTFLAGS</code>:
Using <code>-Z dump-mir=&#39;http_request_handle_wrap&#39;</code>:</p>
<div><pre>$ <span>RUSTFLAGS=<span><span>&#34;</span>-Z dump-mir=&#39;http_request_handle_wrap&#39;<span>&#34;</span></span> cargo +nightly build --example basic --features usdt-probes</span>
<span>[...snip...]</span>
<span>(signal: 11, SIGSEGV: invalid memory reference)</span>
$ <span>ls mir_dump</span>
<span>mir_dump: No such file or directory</span></pre></div>
<p dir="auto">Ok, that isn&#39;t working as expected (<code>-Z dump-mir=F</code> should print just the MIR for functions matches the filter <code>F</code> and place it in a <code>mir_dump</code> folder). A bit annoying and we can only shave so many yaks right now but nothing a bigger hammer can&#39;t fix (just use <code>--emit=mir</code> to dump out all the mir into the target folder and find the corresponding one for <code>dropshot</code>):</p>
<div><pre>$ <span>RUSTFLAGS=<span><span>&#34;</span>--emit=mir<span>&#34;</span></span> cargo +nightly build --example basic --features usdt-probes</span>
$ <span>ls target/debug/deps/dropshot-<span>*</span>.mir</span>
<span>target/debug/deps/dropshot-30d947b7471013cc.mir</span></pre></div>
<p dir="auto">Ok, now this looks like reasonable:</p>
<div><pre>bb24: {
[...snip...]
        <span>asm!</span>(<span>&#34;990:   clr rax</span>
<span></span>
<span>                    .pushsection set_dtrace_probes,<span>\&#34;</span>aw<span>\&#34;</span>,<span>\&#34;</span>progbits<span>\&#34;</span></span>
<span>                    .balign 8</span>
<span>            991:</span>
<span>                    .4byte 992f-991b    // length</span>
<span>                    .byte 1</span>
<span>                    .byte 0</span>
<span>                    .2byte 1</span>
<span>                    .8byte 990b         // address</span>
<span>                    .asciz <span>\&#34;</span>dropshot<span>\&#34;</span></span>
<span>                    .asciz <span>\&#34;</span>request-start<span>\&#34;</span></span>
<span>                             // null-terminated strings for each argument</span>
<span>                    .balign 8</span>
<span>            992:    .popsection</span>
<span>                    </span>
<span>                    .pushsection yeet_dtrace_probes</span>
<span>                    .8byte 991b</span>
<span>                    .popsection</span>
<span>                </span>
<span>        &#34;</span>, <span>out</span>(<span>&#34;ax&#34;</span>) _77, <span>options</span>(NOMEM <span>|</span> PRESERVES_FLAGS <span>|</span> NOSTACK)) <span>-</span><span>&gt;</span> [<span>return</span>: bb25, unwind: bb217]; <span>// scope 10 at dropshot/src/lib.rs:581:1: 581:41</span>
    }

    bb25: {
        _78 <span>=</span> _77;                       <span>// scope 9 at dropshot/src/lib.rs:581:1: 581:41</span>
        <span>switchInt</span>(<span>move</span> _78) <span>-</span><span>&gt;</span> [<span>0_u64</span>: bb46, otherwise: bb26]; <span>// scope 9 at dropshot/src/lib.rs:581:1: 581:41</span>
    }</pre></div>
<p dir="auto">Note in MIR, <code>asm</code> itself is a terminator and so <code>bb24</code> here appropriately says that under normal control flow to go to <code>bb25</code> or if unwinding go to <code>bb217</code>. In <code>bb25</code> we see a simple statement, <code>_78 = _77;</code>, which is assigning the output (<code>_77</code> i.e. <code>is_enabled</code>) from the <code>asm</code> and this should correspond to the <code>store</code> we saw in the LLVM IR.</p>
<p dir="auto">So looks like something in the lowering from Rust MIR to LLVM IR is not quite right. Just eyeballing it, it seems like the store of the asm output is getting added to the wrong LLVM basic block. Wherein it should be part of the &#34;normal&#34; basic block taken by the <code>invoke</code> (indicated by the <code>to label %bb25</code> argument), instead it is incorrectly placed directly after the <code>invoke</code>.</p>
<p dir="auto">That seems to happens <a href="https://github.com/rust-lang/rust/blob/d32ce37a171663048a4c4a536803434e40f52bd6/compiler/rustc_codegen_llvm/src/asm.rs#L293-L306">here</a> in <code>rustc</code>.</p>
<p dir="auto">Now that we have a pretty good idea of why things fail we should be able to make a smaller repro (*):</p>
<div><pre>#![feature(asm_unwind)]

<span>fn</span> <span>main</span>() {
    <span>let</span> _x <span>=</span> <span>String</span><span>::</span><span>from</span>(<span>&#34;string here just cause we need something with a non-trivial drop&#34;</span>);
    <span>let</span> foo: <span>u64</span>;
    <span>unsafe</span> {
        std<span>::</span>arch<span>::</span><span>asm!</span>(
            <span>&#34;mov {}, 1&#34;</span>,
            <span>out</span>(reg) foo,
            <span>options</span>(may_unwind)
        );
    }
    <span>println!</span>(<span>&#34;{}&#34;</span>, foo);
}</pre></div>
<div><pre>$ <span>rustc +nightly asm-miscompile.rs</span>
<span>[1]    6057 segmentation fault (core dumped)  rustc +nightly asm-miscompile.rs</span></pre></div>
<p dir="auto">Cool, we&#39;ve got our smaller repro segfaulting, but is it the same issue? Let&#39;s take a look at what the LLVM IR says:</p>
<div><pre>$ <span>rustc +nightly asm-miscompile.rs --emit=llvm-ir -C no-prepopulate-passes</span></pre></div>
<div><pre>$ less <span>asm</span>-miscompile.ll

[...snip...]
bb1:                                              <span>; preds = %start</span>
  <span>%1</span> = <span>invoke</span> <span>i64</span> <span>asm</span> <span>sideeffect</span> <span>alignstack</span> inteldialect <span>unwind</span> <span>&#34;mov ${0:q}, 1&#34;</span>, <span>&#34;=&amp;r,~{dirflag},~{fpsr},~{flags},~{memory}&#34;</span>()
          <span>to</span> <span>label</span> <span>%bb2</span> <span>unwind</span> <span>label</span> <span>%cleanup</span>, <span>!srcloc</span> <span>!9</span>
  <span>store</span> <span>i64</span> <span>%1</span>, <span>i64*</span> <span>%foo</span>, <span>align</span> <span>8</span>

bb2:
[...snip...]</pre></div>
<p dir="auto">Would you look at that, we&#39;ve got a <code>store</code> as the last instruction in the basic block with the <code>asm</code>.</p>
<p dir="auto">Now that we have a small repro and know roughly where the issue is in <code>rustc</code> we can try fixing it:</p>
<div><pre><span>diff --git a/compiler/rustc_codegen_llvm/src/asm.rs b/compiler/rustc_codegen_llvm/src/asm.rs</span>
index 03c390b4bd4..91d132eb343 100644
<span>--- a/compiler/rustc_codegen_llvm/src/asm.rs</span>
<span>+++ b/compiler/rustc_codegen_llvm/src/asm.rs</span>
<span>@@ -290,6 +290,11 @@</span> fn codegen_inline_asm(
         }
         attributes::apply_to_callsite(result, llvm::AttributePlace::Function, &amp;{ attrs });
 
<span><span>+</span>        // Switch to the &#39;normal&#39; basic block if we did an `invoke` instead of a `call`</span>
<span><span>+</span>        if let Some((dest, _, _)) = dest_catch_funclet {</span>
<span><span>+</span>            self.switch_to_block(dest);</span>
<span><span>+</span>        }</span>
<span><span>+</span></span>
         // Write results to outputs
         for (idx, op) in operands.iter().enumerate() {
             if let InlineAsmOperandRef::Out { reg, place: Some(place), .. }</pre></div>
<p dir="auto">A little waiting later and we can try compiling our small repro again:</p>
<div><pre>$ <span>rustc +stage1 asm-miscompile.rs</span>
$ <span><span>echo</span> <span>$?</span></span>
<span>0</span></pre></div>
<p dir="auto"><g-emoji alias="tada" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png">üéâ</g-emoji> Success! So what does the LLVM IR look like now?</p>
<div><pre>$ <span>rustc +stage1 asm-miscompile.rs --emit=llvm-ir -C no-prepopulate-passes</span></pre></div>
<div><pre>$ less <span>asm</span>-miscompile.ll

[...snip...]
bb1:                                              <span>; preds = %start</span>
  <span>%1</span> = <span>invoke</span> <span>i64</span> <span>asm</span> <span>sideeffect</span> <span>alignstack</span> inteldialect <span>unwind</span> <span>&#34;mov ${0:q}, 1&#34;</span>, <span>&#34;=&amp;r,~{dirflag},~{fpsr},~{flags},~{memory}&#34;</span>()
          <span>to</span> <span>label</span> <span>%bb2</span> <span>unwind</span> <span>label</span> <span>%cleanup</span>, <span>!srcloc</span> <span>!9</span>

bb2:
  <span>store</span> <span>i64</span> <span>%1</span>, <span>i64*</span> <span>%foo</span>, <span>align</span> <span>8</span>
[...snip...]</pre></div>
<p dir="auto">The store has moved down into <code>%bb2</code> right where it should be.</p>
<p dir="auto">(*) <strong>Note</strong>: we had to add <code>options(may_unwind)</code> and an unused <code>String</code> variable to actually get it to fail. Removing either of those will stop it from segfaulting. The difference being, the LLVM IR that <code>rustc</code> generates. Without both pieces, <code>rustc</code> just uses a simple <code>call</code> instruction for the inline asm whereas in the broken case, it&#39;s using <code>invoke</code> which is considered a terminator unlike <code>call</code>. After the <code>invoke</code>, the control transfer goes to either the &#39;normal&#39; label or the &#39;unwind&#39; label. By marking our asm with <code>options(may_unwind)</code> we essentially tell <code>rustc</code> to opt our inline assembly into participating in unwinding. The unused string is there so that there&#39;s actually something to cleanup in the case that we do unwind.</p>
<p dir="auto">But, looking at the asm from the original failing code in <code>dropshot</code> there&#39;s no mention of <code>MAY_UNWIND</code>:</p>
<div><pre><span>asm!</span>(<span>&#34;[...snip...]&#34;</span>, <span>out</span>(<span>&#34;ax&#34;</span>) _77, <span>options</span>(NOMEM <span>|</span> PRESERVES_FLAGS <span>|</span> NOSTACK)) <span>-</span><span>&gt;</span> [<span>return</span>: bb25, unwind: bb217]; <span>// scope 10 at dropshot/src/lib.rs:581:1: 581:41</span></pre></div>
<p dir="auto"><a href="https://github.com/oxidecomputer/usdt/blob/c32ec7af3394eee0fbc5c539724f8a89e8a6be48/usdt-impl/src/no-linker.rs#L95">usdt</a> certainly isn&#39;t adding it so what gives?</p>
<p dir="auto">Poking through <code>rustc</code>, it seems like that may be due to the way MIR inlining is <a href="https://github.com/rust-lang/rust/blob/297dde9b1ad0c28922fac5046f77c2629cebf662/compiler/rustc_mir_transform/src/inline.rs#L963-L971">implemented</a>. A cleanup block may be assigned if a terminator (like inline asm) gets inlined. The lowering pass will use the presence of such a cleanup target to ultimately decide whether to use <code>call</code> or <code>invoke</code>.</p>
<p dir="auto">But that theory is quickly shot down because the MIR inliner is still disabled by default.</p>
<p dir="auto">Just searching through <code>rustc</code> for other places the unwind target of a terminator might be set yields something promising when it comes to <a href="https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler/rustc_mir_transform/src/generator.rs#L1098-L1102">generators</a>. This would track as the original <code>dropshot</code> failure case is in the context of an async method. Further confirmation that this is where our InlineAsm terminator is getting an unwind target set is that the <code>posion_block</code> mentioned in that bit of code lines up. It has a <a href="https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler/rustc_mir_transform/src/generator.rs#L1080">single statement</a> and if we hop back to the MIR of the failing <code>dropshot</code> example, lo and behold:</p>
<div><pre>    <span>asm!</span>(<span>&#34;[...snip...]&#34;</span>, <span>out</span>(<span>&#34;ax&#34;</span>) _77, <span>options</span>(NOMEM <span>|</span> PRESERVES_FLAGS <span>|</span> NOSTACK)) <span>-</span><span>&gt;</span> [<span>return</span>: bb25, unwind: bb217];

[...snip...]

<span>bb217</span> (cleanup): {
    <span>discriminant</span>((<span>*</span>(_1.<span>0</span>: <span>&amp;</span><span>mut</span> [<span>static</span> generator@dropshot<span>/</span>src<span>/</span>server.rs:<span>651</span>:<span>43</span>: <span>741</span>:<span>2</span>]))) <span>=</span> <span>2</span>; <span>// scope 0 at dropshot/src/server.rs:651:43: 741:2</span>
    resume;                          <span>// scope 0 at dropshot/src/server.rs:651:43: 741:2</span>
}</pre></div>
<p dir="auto"><code>bb217</code> there is the unwind target and it matches exactly with the <code>poison_block</code> as constructed in the <a href="https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler/rustc_mir_transform/src/generator.rs#L1079-L1083">rustc</a>.</p>
<p dir="auto">Armed with some new evidence, we can adapt our simple repro to more closely match the async scenario encountered in <code>dropshot</code>:</p>
<div><pre><span>extern</span> <span>crate</span> futures; <span>// 0.3.21</span>

<span>async</span> <span>fn</span> <span>bar</span>() {
    <span>let</span> foo: <span>u64</span>;
    <span>unsafe</span> {
        std<span>::</span>arch<span>::</span><span>asm!</span>(
            <span>&#34;mov {}, 1&#34;</span>,
            <span>out</span>(reg) foo,
        );
    }
    <span>println!</span>(<span>&#34;{}&#34;</span>, foo);
}

<span>fn</span> <span>main</span>() {
    futures<span>::</span>executor<span>::</span><span>block_on</span>(<span>bar</span>());
}</pre></div>
<p dir="auto">(Segfaults on <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1c7781c34dd4a3e80ae4bd936a0c82fc" rel="nofollow">playground</a>.)</p>
<p dir="auto">Thus all the mysteries are solved:</p>
<ol dir="auto">
<li>the MIR -&gt; LLVM IR lowering for inline assembly outputted invalid LLVM IR when generated with an <code>invoke</code> instruction (Fix submitted <a href="https://github.com/rust-lang/rust/pull/95864" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/95864/hovercard">here</a>).</li>
<li>every <code>async fn</code> in rust is implemented as a generator and as part of that, terminators in the basic blocks of such a function are modified to include a cleanup target if they can unwind (*) so as to poison the generator (**).</li>
<li>We also discovered a <a href="https://github.com/rust-lang/rust/issues/95874" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/95874/hovercard">bug</a> with <code>-Z verify-llvm-ir=yes</code> and <code>-C no-prepopulate-passes</code> along the way (Fix submitted <a href="https://github.com/rust-lang/rust/pull/95893" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/95893/hovercard">here</a>).</li>
</ol>
<p dir="auto">(*) note the segfault in the above <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1c7781c34dd4a3e80ae4bd936a0c82fc" rel="nofollow">playground</a> goes away if you remove the <code>println!</code> from <code>foo</code> because that is the only part that may actually unwind.</p>
<p dir="auto">(**) if you&#39;ve ever seen a panic saying &#34;<code>async fn</code> resumed after panicking&#34;, this is why.</p>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
