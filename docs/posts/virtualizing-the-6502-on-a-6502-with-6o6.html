<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://oldvcr.blogspot.com/2024/04/virtualizing-6502-with-6o6-and.html">Original</a>
    <h1>Virtualizing the 6502 on a 6502 with 6o6</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-984144946233837570" itemprop="description articleBody"><p>
Okay, promises, promises. Here&#39;s the first of my bucket list projects I&#39;m completing which I&#39;ve intermittently worked on for literally two decades. Now that I&#39;ve finally shaken out more bugs, tuned it up and cleaned it off, it&#39;s time to let people play with the source code.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEivDrcAdhwcwbu_tO6qS1D0mlHYugge1U_QwmL5fGvnv1YN-S33F5fevKDKMCrrKcv9U9HKsNU9zs_59MP_pfkkbaK-g9-du1JwGEwv-2PkalrqZdjMOwCwJD8EJrXMuK5AFxFz1YR-M8Jh5eJxuG1nkFE4HFF0Li7yehE8xFTPGCa6d4Lb_KDq472QEoA/s1556/kim10.png"><img alt="" data-original-height="1556" data-original-width="1498" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEivDrcAdhwcwbu_tO6qS1D0mlHYugge1U_QwmL5fGvnv1YN-S33F5fevKDKMCrrKcv9U9HKsNU9zs_59MP_pfkkbaK-g9-du1JwGEwv-2PkalrqZdjMOwCwJD8EJrXMuK5AFxFz1YR-M8Jh5eJxuG1nkFE4HFF0Li7yehE8xFTPGCa6d4Lb_KDq472QEoA/s320/kim10.png"/></a></p><p>

This is the official 1.0 release of the Incredible KIMplement, an emulator of the one kilobyte, 1MHz MOS/Commodore KIM-1 6502-based single board computer. It provides access to the KIM&#39;s built-in TTY support (even through your computer&#39;s <em>real</em> serial port) and has expanded RAM with 16K of addressing space, all on an unexpanded stock Commodore 64.
</p><p>
It&#39;s almost burying the lede to announce that, though, because the real meat in this entry is how the Commodore 64 manages to emulate a very different 6502-based system. That piece is &#34;6o6,&#34; for &#34;6502-on-6502,&#34; and is a full virtualized software NMOS 6502 CPU that runs on a 6502 CPU — which I&#39;ve open-sourced too. It has full control of guest code execution, including trapping undocumented and jam opcodes, and completely abstracts all memory access, making it possible to remap addresses, intercept illegal reads or writes, or even run entirely from virtual memory. On top of that, it&#39;s complete enough to not only pass a full functional test but also virtualize itself <em>virtualizing itself</em>:

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi0UGEePq0AVrKcwQdt3usgMqR5QSWttJPoirmMwG22o83p6x9eVik4bT2NRFtRF9GRu5MiNZ1MnKSyNy-SGJn67ULwBoyoMijmv0dAZ3ricDuKw10Yuet3-_vvID90cIh-sqhkx2pz1en7VMXCO9U11lE6VdsP3c0c-gte1ScyjTBRYz1jb5Ax_2FrGpM/s570/test.gif"><img alt="" data-original-height="480" data-original-width="570" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi0UGEePq0AVrKcwQdt3usgMqR5QSWttJPoirmMwG22o83p6x9eVik4bT2NRFtRF9GRu5MiNZ1MnKSyNy-SGJn67ULwBoyoMijmv0dAZ3ricDuKw10Yuet3-_vvID90cIh-sqhkx2pz1en7VMXCO9U11lE6VdsP3c0c-gte1ScyjTBRYz1jb5Ax_2FrGpM/s320/test.gif" width="320"/></a></p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjYI9ziuW-XUnTOShSG0fCb9vkcW_Ea5BHSww0IIISNWbWX0yprMd3bkgSYwDo0Wfx5nWkb6q77zFemoiMI7ZSNDuzBDUZ7mMM4G4gxY958coNrY33tdolPFzIUsKldb9-pSYMYnhvsfv6JE1IbV3A5YT2GR9tjQW1NT16rTV3AzGavYS07o3SAzcM_Pig/s557/a2.gif"><img alt="" data-original-height="380" data-original-width="557" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjYI9ziuW-XUnTOShSG0fCb9vkcW_Ea5BHSww0IIISNWbWX0yprMd3bkgSYwDo0Wfx5nWkb6q77zFemoiMI7ZSNDuzBDUZ7mMM4G4gxY958coNrY33tdolPFzIUsKldb9-pSYMYnhvsfv6JE1IbV3A5YT2GR9tjQW1NT16rTV3AzGavYS07o3SAzcM_Pig/s320/a2.gif" width="320"/></a></p><p>

These GIF screencasts are real-time with no tricks. Here a Commodore 64 and Apple IIe are both running a guest &#34;hello world&#34; payload within 6o6 (stage 1), which is nearly instantaneous, then 6o6 running the payload as a payload within another instance of 6o6 (stage 2), which is a little slower, then 6o6 running 6o6 running 6o6 running the payload (stage 3), which is glacial. But all of it works!
</p><p>
<a name="more"></a>

I think all nerds at a certain age want to design &#34;the ultimate operating system.&#34; I made a lot of attempts at this as a kid, mostly concentrating on windowing and menus, and none of them progressed much beyond the level of primitive tech demos. I have a few of these disks still around to smile at.
</p><p>
When I had my first taste of multiuser systems, it hadn&#39;t occurred to me before that people might (unwittingly or otherwise) try to run crap code. After all, I&#39;d grown up in an era where computers generally ran <em>one</em> program that had control of the entire machine, so operating systems — to naïve little me, at least — were more of an exercise in interface design. The program was <em>expected</em> to take over everything, so if the program misbehaved, you simply reset the computer. But people expect multiuser systems not to reboot randomly when they&#39;re in the middle of something. An effective system would either have to deal with the fallout, or actively protect you and others, from code that might (unwittingly or otherwise) corrupt other address spaces, run deleterious instructions or hog all the resources.
</p><p>
Naturally, the trick is how a little 6502 with less than 4,000 transistors can guard against all that. Although memory management with the 6502 was improved with bank-switching hardware — the C64 could have never juggled its own 84K of addressing space without the I/O port on its 6510 — few historical NMOS 6502 systems could move around the special zero page or the processor stack in memory (as it happens, the Commodore 128 is <a href="https://c128lib.github.io/Reference/D500">one of those systems</a> but little software takes advantage of it), and none could remap addresses such that program code could be moved to and run from an arbitrary location without fixups. It also could not comprehensively prohibit programs from accessing certain memory locations, and if any of the number of undocumented jam or &#34;KIL&#34; opcodes were executed, then the processor would lock up completely. (These opcodes are <a href="https://www.pagetable.com/?p=39">unintended consequences</a> of how the original NMOS 6502 decodes instructions, and CMOS versions of the 6502 make them into no-ops or repurpose them for other operations.)
</p><p>
Some other issues could also be conceivably mitigated with hardware. A process determined to monopolize the system by setting the interrupt flag (to disable interrupts) can still be halted externally with a source of periodic non-maskable interrupts (NMIs), which is how some multitasking 6502 kernels implement preemptive task switching, assuming that source exists. For mitigating dangerous instructions, in-circuit emulators did exist — the Eastern House Software &#34;Trap65&#34; comes to mind, which turned bogus opcodes into trappable <tt>BRK</tt>s — but they were very expensive and at the time weren&#39;t generally sophisticated enough to directly manipulate live bus lines in a complex fashion. And, of course, you&#39;d still need some sort of supervisor/hypervisor kernel to control all this.
</p><p>
So what if we just do it <em>all</em> in software? Even a simple-minded interpreter isn&#39;t completely nuts: the 6502 has few registers, so keeping track of the processor state is easy, with a manageable 56 instructions and only a handful of addressing modes. We can abstract memory access in any way we want, and we can throw controlled exceptions for bad instructions or protection faults instead of crashing or hanging.
</p><p>
The &#34;virtualization&#34; part comes in by 6o6 also using the host&#39;s ALU to do processor-internal operations on behalf of the guest. Again, this is facilitated by how simple the 6502&#39;s internal state is. If we&#39;re asked to add a value to the accumulator, we load the guest register and processor flags on the host 6502, run the same instruction the guest would have, record the result and processor flags and clean up. (This is how we avoid a guest with, say, the interrupt flag and decimal flag set from corrupting our own state.) Here&#39;s an example from the source code for the <tt>ADC #</tt> immediate (opcode $69) instruction.
</p><div><pre>-IMMPTR = hpadc69+1
opadc69 ARGIMM
        GETAP
hpadc69 adc #$00
        PUTAP
</pre></div>
<p>
This uses <tt>xa</tt> preprocessor macros to fetch an immediate argument from the instruction stream and store it as the operand to the immediate instruction at <tt>hpadc69</tt>, then loads the accumulator and processor state from the guest into the host CPU, runs the instruction, stores the accumulator and processor state and clears the I and D flags. (Do note this is self-modifying in case you wanted to put it in ROM.) Not only does this give us the answer without having to implement the logic ourselves, but we also get all the CPU flags precisely handled &#34;for free,&#34; and stuff like decimal mode (i.e., BCD) arithmetic just works as a natural consequence. Similarly, if we&#39;re asked to shift it, or subtract, or increment or decrement the X or Y registers, we do the same thing.
</p><p>
Even if we&#39;re just loading or operating on a value from memory, or transferring registers, we still do this because we still have to set the negative and zero flags. As an example, here&#39;s an indirect indexed <tt>LDA (),Y</tt> (opcode $b1), where we take the result from memory and then load it as an immediate. Notice we don&#39;t bother loading the guest accumulator since we&#39;ll immediately clobber it.
</p><div><pre>-IMMPTR = ipldab1+1
opldab1 ARGINYF
        GETP
ipldab1 lda #$00
        PUTAP
</pre></div>
<p>
Regardless of how we get there, the approach yields a result exactly the same as a 6502 <em>because a 6502 computed it</em>, and we get the results faster than doing the math and flags manually.
</p><p>
That, in a nutshell, was my first version of 6o6 in 2002. As a test case to emulate the simplest 6502 system I could think of, I added code to support the LEDs and TTY, and that became <a href="http://ana-3.lcs.mit.edu/~jnc/cctalk/2002-December/0273.html">the first version of the Incredible KIMplement</a>.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiz5GbBXD7SyCuH39S6UOhQukntuXNP-qjmb-J6fkslIj95BgKiqThssUhOiERDyr5AsXwIakvtYm3a2-b6-VBGxPgymozK7LIHDthOJ_UKX0KOEnr7AZD1y0zRXeBUNWNhD21_8o2GH1pCV6uPHRgY0PMc24KLhRI4xRjyMaPKh-4eUDGRKoLJYtGxM6M/s2804/6o6d.png"><img alt="" data-original-height="1350" data-original-width="2804" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiz5GbBXD7SyCuH39S6UOhQukntuXNP-qjmb-J6fkslIj95BgKiqThssUhOiERDyr5AsXwIakvtYm3a2-b6-VBGxPgymozK7LIHDthOJ_UKX0KOEnr7AZD1y0zRXeBUNWNhD21_8o2GH1pCV6uPHRgY0PMc24KLhRI4xRjyMaPKh-4eUDGRKoLJYtGxM6M/s320/6o6d.png" width="320"/></a></p><p>

In our little virtual world, the 6o6 VM is <em>not</em> the prime mover, just the engine. Since the original intent was to be part of a future operating system, I believed strongly that any 6o6-based environment should be highly modular, and this diagram reflects that. The <i>virtual machine</i> (in red) is almost completely hardware-agnostic other than assuming it runs on a real 6502. As such, in order to run an arbitrary <i>payload</i>, i.e., the guest, there are two other parts (in green) required to specify a complete system.
</p><p>
The first part is the <i>harness</i>, which is 6o6&#39;s interface to guest memory and the rest of the managed hardware. The harness has a standardized jump table that serves as its binary interface. It implements loads and stores for a given address, including instruction fetches, and maintains the hardware stack and stack pointer. The VM assumes nothing — not even the page size or that memory is even paged. (By the way, while the VM calls the harness to get and store the 8-bit stack pointer register using X, it also calls the harness for all pushes and pops because it deliberately doesn&#39;t touch the stack itself. That means the VM doesn&#39;t have an actual dependency on the location or size of the stack, so regardless of what you <em>say</em> is the stack pointer value, nothing says you couldn&#39;t implement a bigger stack internally.)
</p><p>
Converting a virtual to a physical address could be as simple as addition or bit shifts, but if you wanted to implement something more complex like a paged virtual memory scheme, you&#39;d also do it here: instead of generating page faults for something else to handle, the harness itself would do the paging in and out as part of a load or store. The harness can also raise protection exceptions. Here&#39;s an example store from the included demonstrations (we&#39;ll talk about it a little later too):
</p><div><pre>        * = HARNESS

        jmp mpeek
        jmp spush
        jmp spull
        jmp stsx
        jmp stxs

        ; these drivers should not change dptr

        ; poke .a into location indicated by dptr
        ; okay to clobber x and y
mpoke   tax
        lda dptr
        sta hhold0
        lda dptr+1
        cmp #&gt;KERNEL
        bcs mpokehi
        ; $0000 and $0100 go to EMURAM and EMURAM+0x100
mpokelo adc #&gt;EMURAM
        bcc mpokec      ; carry still clear
        ; accesses to kernel and up go to the payload
        ; add offset keeping in mind carry is set
mpokehi adc #(PAYLOAD &gt;&gt; 8)-(KERNEL &gt;&gt; 8)-1
        bcc mpokehj
        ; fault if the result wraps
mpokefa lda #R_MFAULT
        jmp BAILOUT
mpokehj ; fault if the result hits I/O
#ifdef C64
        ; VIC
        cmp #$d0
#else
        ; Apple II
        cmp #$c0
#endif
        bcs mpokefa
        ; OK to store
mpokec  sta hhold1
        txa
        ldy #0
        sta (hhold0),y
        rts
</pre></div>
<p>
I included the jump table so you can see the functions the harness is expected to provide. <tt>dptr</tt> is the virtual address pointer provided by 6o6 for the harness to dereference and <tt>hhold0/1</tt> are zero page work areas the harness can use for this task. <tt>EMURAM</tt> indicates where the bottom of guest memory is in physical memory, <tt>PAYLOAD</tt> indicates where the payload is in physical memory, and <tt>KERNEL</tt> is the address of the kernel, which in this case may or may not be a physical address (more later). Here, accesses to virtual zero page and the stack go to the same place offset by <tt>EMURAM</tt> and accesses to the kernel address and up are offset by the computation at <tt>mpokehi</tt>. If the resulting physical address wrapped or hits I/O, then this routine will raise an exception, though it could just as easily ignore it. Otherwise, having computed the physical address, it performs the store and returns to the VM. You should note that the way this scheme is constructed, memory above the stack but below the starting address of the payload may be aliased; also, the full 64K addressing space is not available beyond a certain point. Neither is an intrinsic limitation of 6o6, just how this particular harness was written for pedagogic purposes.
</p><p>
Now, suppose you <em>do</em> have an MMU or some other hardware assist for managing memory. The beauty of it is, you just write it into the harness and make the harness the driver for your hardware; 6o6&#39;s memory model is so completely abstracted that it won&#39;t notice the difference. I&#39;ll have an example of that later on.
</p><p>
The second part is the <i>kernel</i>, which is what actually kicks off the VM. The kernel and its associated headers define for the VM where the harness is located and what zero page locations it can use for registers, which are shared with the kernel so that the kernel can initialze and manipulate them. The kernel next calls the VM to run an instruction from the payload (or a group of instructions; more in a moment). The VM executes some portion of the instruction stream and returns a status code to the kernel, which may include an exception from either the harness or 6o6 itself that the kernel needs to act on, after which the kernel can inspect or modify the guest processor state and do any needed emulation tasks. For example, it might notice the PC is at a service routine it handles natively, so it does that task, adjusts the registers with any return value, and (I provide a utility routine for this) pulls the return address off the stack at the end. All necessary work having been done, it goes back to call the VM again for the next payload instruction or instruction group, and so on and so forth, looping until termination.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgng8Ts5YGgajtflXxNU3yvgcvGOozahC3RcX57FebfkNKhURp25AvxSssULEqJQatmg5RHxoaUVT4F7A89435rroU7OO-ok3PTFiyZ9ucXY3cC6ZbiVf3Fo6o6w6697MIogqNZOgn1aQE1G1PFuZfFfPxMGIhZPTqTSB3Kc4toark42jNTi8NeWk4p3YI/s1410/uh.png"><img alt="" data-original-height="1224" data-original-width="1410" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgng8Ts5YGgajtflXxNU3yvgcvGOozahC3RcX57FebfkNKhURp25AvxSssULEqJQatmg5RHxoaUVT4F7A89435rroU7OO-ok3PTFiyZ9ucXY3cC6ZbiVf3Fo6o6w6697MIogqNZOgn1aQE1G1PFuZfFfPxMGIhZPTqTSB3Kc4toark42jNTi8NeWk4p3YI/s320/uh.png" width="320"/></a></p><p>

Between calls to the VM the guest CPU is &#34;frozen,&#34; making it possible to completely capture the guest state for later reconstitution, or context-switch to a new task or environment by just swapping in a new set of registers. The kernel also determines when externally triggered events occur because the VM doesn&#39;t fire virtual IRQs or NMIs (or, for that matter, resets); the kernel decides when such events should take place and accordingly loads the stack (there&#39;s a routine for this too) and sets the guest program counter (PC) and any other needed registers. Although the VM supports the </p><tt>BRK</tt><p> instruction, traditionally treated as a &#34;software&#34; interrupt, the VM will set up the stack for you but instead of setting the PC to the new location returns an exception. Your kernel can handle it in the conventional way by setting the PC to the IRQ vector, or perhaps to some other vector, or perhaps handle the situation natively, or even just ignore it.
</p><p>
The harness in KIMplement provides a virtual standard 6502 stack in the usual location and a KIM-4 expansion device with read/write memory between $0000 and $17ff, ROM from $1800 to $1fff, RAM from $2000 to $3fff, unmapped unwriteable space from $4000 to $fff7, and mirroring $1ff8-$1fff to $fff8-$ffff for vectors. The host C64 stores the low 16K at $4000 through $7fff and the rest is synthesized by the harness, so in most cases computing the effective physical address is just bit twiddling and adds. Meanwhile, the KIMplement kernel handles emulating the RRIOTs (picking up the writes from the harness), drawing the LEDs, servicing the TTY, inserting NMIs for stops and the Single-Step Switch, and also trapping portions of the KIM-1 ROM monitor. After a VM run the KIMplement kernel examines 6o6&#39;s PC to see if we want to intercept the current routine, which is how the TTY and certain other features are implemented.
</p><p>
There are two other performance enhancements in 6o6. The clever among you will have already recognized the 6o6-harness edge as a potentially massive bottleneck, since even the simplest instructions will involve at least one fetch and things like indirect addressing could require many. To eliminate the overhead of a subroutine call (at least 12 cycles) on every byte, as part of KIMplement 0.2 I allowed memory loads in 6o6 to be partially inlined with preprocessor macros. These optional macros provide inlineable load routines both for any arbitrary virtual address and an optimized alternative for zero page which are linked right into 6o6. Doing so yielded substantial speedup, but at the cost of bloating the VM, so I chose to keep <em>stores</em> as subroutine calls since they happen less frequently and are usually more complicated than fetches. In this very latest iteration, I also cleaned up an inefficiency in how the inline macro accesses the program counter, which improves instruction fetches further.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi3BOrVsgtlpRedNC-P656fHmuUr1t_sN3Z4XhchEzGX2gxt89YwasSxEM438WNaKsMlU8c8jTpGzI6eaV_8dVQA9zaP5yAzoeAzNrlkKgKLN0ct-Grmd5nIgx2l8UKFsJyFKi7Bb9oycDJB3XEwx2ONX_00Xh3uJJgSOV5h8wQhky1ILUHcx6v8yeAy7w/s2165/fusops.png"><img alt="" data-original-height="2165" data-original-width="1735" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi3BOrVsgtlpRedNC-P656fHmuUr1t_sN3Z4XhchEzGX2gxt89YwasSxEM438WNaKsMlU8c8jTpGzI6eaV_8dVQA9zaP5yAzoeAzNrlkKgKLN0ct-Grmd5nIgx2l8UKFsJyFKi7Bb9oycDJB3XEwx2ONX_00Xh3uJJgSOV5h8wQhky1ILUHcx6v8yeAy7w/s320/fusops.png"/></a></p><p>

The other means is an optional and primitive form of instruction fusion I call &#34;extra helpings,&#34; which I added to 6o6 for KIMplement 0.3. For instructions that don&#39;t touch memory, instruction fetches notwithstanding, there&#39;s no need to return to the kernel <em>right away</em> because there would likely be no operation the kernel needs to observe yet. This includes immediates, accumulator oriented instructions, most implied instructions (anything that wouldn&#39;t call into the harness or access the processor stack), and branches if they are not taken. For example, something like </p><tt>clc:adc #32:tax:inx:cpx #50</tt><p> is otherwise handled all within the processor, so there&#39;s no reason from the kernel&#39;s perspective that these sorts of instructions couldn&#39;t all be taken together as a group. However, if an instruction does any loads or stores, or the PC changes to anything but the next instruction, or there&#39;s an exception (duh), then the effect is potentially observable by the kernel and the VM stops trying to cram in more. This doesn&#39;t make the VM any faster — in fact, if we have the &#34;extra helpings&#34; gated on where the PC is in a page, as KIMplement does to handle exact ROM traps, it&#39;s slightly slower — but it also means that the kernel doesn&#39;t have to run uselessly after every instruction where nothing could have changed, so instead it makes <em>everything else</em> faster. The approach is profitable, as we&#39;ll show in a moment, but it does interfere with applications that need precise control of the program counter and so there are options to progressively or completely disable it.
</p><p>
That&#39;s a good segue to talk about 6o6&#39;s built-in validation and testing, because we can directly test any optimizations we make and see if that lowers execution time or instruction count. As part of cleaning up the code I pulled down Klaus Dormann&#39;s <a href="https://github.com/Klaus2m5/6502_65C02_functional_tests">functional test suite</a>, using the binary he provides so that there&#39;s nothing up my sleeve. This is a widely accepted stress test for 6502 systems for <a href="http://forum.6502.org/viewtopic.php?f=2&amp;t=2241">over a decade</a>. <a href="https://github.com/Klaus2m5/6502_65C02_functional_tests/tree/master/bin_files">The provided binary</a> assumes nothing about the hardware and signals an exit by entering an infinite loop. If the loop isn&#39;t at the point marked as successful completion, then we conclude a failure has occurred.
</p><p>
So that I can test changes easily and quickly, the test suite uses Ian Piumarta&#39;s venerable <a href="https://www.piumarta.com/software/lib6502/"><tt>lib6502</tt> CPU emulator</a> and runs directly from the shell. To detect the testsuite&#39;s &#34;signal&#34; loops I modified David Schmenk&#39;s patch as part of his PLASMA project <a href="https://github.com/dschmenk/PLASMA/commit/db424e9fc739c2b0ddeebf6370741cf40e0f8186">to implement single-stepping</a>, and ran Klaus&#39; suite directly against <tt>lib6502</tt> to start with (after all, since 6o6 relies on the host CPU&#39;s ALU, it&#39;s only as accurate as the ALU that&#39;s present). Interestingly, <tt>lib6502</tt> <em>failed</em> due to an edge case in decimal mode which I also had to patch. I don&#39;t claim my patch is optimal or even correct, but it passes now.
</p><p>
Next we mix in 6o6. The binary Klaus provides is a full 64K, so there&#39;s no room in the basic 6502 address space for both 6o6 and the test suite at the same time. I solved this with <em>another</em> patch to <tt>lib6502</tt> to create a single bankswitched minimal system for $7000-$efff (32K), putting the first 32K of Klaus&#39; binary in the first bank and the second half in the other. The test harness will bank in the proper segment depending on which address is being referenced. The first stage of testing exercises this harness with a payload that stores to each bank and ensures the values are correct. We test this three different ways, one with no extra helpings and no inline fetch macros, then one with inline fetch macros but still no extra helpings, and then both extra helpings and inline fetch macros. If that passes, we move onto the same configurations tested against Klaus&#39; suite. I had to add a synthetic &#34;X&#34; bit to the status register and adjust the code for <tt>BRK</tt> slightly, but once done, it passed in all three forms.
</p><p>
The <tt>lib6502</tt> patch I added also reports the number of opcodes executed. (At some point I&#39;ll do cycle counts, but even just an instruction count is already useful information.) Against the test suite, the naked <tt>lib6502</tt> without 6o6 present executes the test suite in 30,646,178 instructions, while the three configurations of 6o6 from least to most optimized execute it in 2,188,322,914, 1,713,350,225 and 1,602,516,769 instructions respectively. Those are significant savings: at its fastest 6o6 is executing 36.5% fewer instructions than the least optimized version and an average of 52.3 instructions for every guest instruction. Considering those figures necessarily include the harness and the kernel as well as 6o6, I think that&#39;s a darn good number. Notice that while inline fetch macros make the biggest delta, the improvement with extra helpings is certainly no slouch, and the instructions per instruction should not be interpreted as a <em>speed</em> multiplier since different instructions have different cycle counts.
</p><p>
I&#39;ve included four examples with 6o6, not counting KIMplement, its original application. Three of the four will run on either an unexpanded Commodore 64 or on an Apple IIe with 64K (tested using DOS 3.3), and I&#39;ll discuss the fourth after that. (If someone wants to submit an Atari 8-bit port, open a pull request.) You&#39;ve already met one, so let&#39;s meet them all.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj9GfGLvH3qJ00OYJi1Q_Cy2UfyXBe9s3P2u3FcU38a1ZnE8gdvJcaqa3K1_r4uk4E4CMDTclReOggw7HTXxsAYVLpnxKAEeOixhbFX9Z-1VmPs0unjXiGPv7WMabiP7btVbDTiAnuRCU5-79DKNCTcTx9yjyfNsXR3QIZs1SN-dwYPIg4h4y45yvo1UJw/s1630/Screenshot%202024-04-17%20at%208.42.18%E2%80%AFPM.png"><img alt="" data-original-height="1556" data-original-width="1630" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj9GfGLvH3qJ00OYJi1Q_Cy2UfyXBe9s3P2u3FcU38a1ZnE8gdvJcaqa3K1_r4uk4E4CMDTclReOggw7HTXxsAYVLpnxKAEeOixhbFX9Z-1VmPs0unjXiGPv7WMabiP7btVbDTiAnuRCU5-79DKNCTcTx9yjyfNsXR3QIZs1SN-dwYPIg4h4y45yvo1UJw/s320/Screenshot%202024-04-17%20at%208.42.18%E2%80%AFPM.png" width="320"/></a></p>

<p><a href="https://github.com/classilla/6o6/tree/main/examples/helloworld/">The first, and simplest</a>, is a &#34;hello world.&#34; It runs a program which prints &#34;hello world&#34; first natively on the CPU, then through 6o6. </p><tt>xa</tt><p> handles the character set, so the </p><tt>Makefile</tt><p>s set the right options to make the string correct on either the Apple II or the C64. Here&#39;s the payload in nearly its entirety:
</p><div><pre>        * = KERNEL
        ; NOT payload!

        ldx #0
:       lda string,x
        beq :+
        jsr CHROUT
        inx
        bne :-
:       rts
        
        ; character set handled by xa
string  .asc &#34;hello world&#34;, CR, $00
</pre></div>
<p>
This is a very normal-looking blob of code (on the Apple II we intentionally <em>don&#39;t</em> end with a <tt>jmp $03d0</tt>, though that wouldn&#39;t be necessary for ProDOS, of course — I&#39;ll explain why in a second). You&#39;ll notice this calls a character-out routine, which maps to either $ffd2 on the Commodore or $fded on the Apple; when the kernel sees the call, it just passes it through to the ROM routine. The kernel is also small, and looks like this:
</p><div><pre>        * = KERNEL

cold    lda #&gt;KERNEL
        sta pc
        lda #&lt;KERNEL
        sta pc+1
        lda #0
        sta preg
        lda #$ff
        sta sptr

lup     jsr VMU

        ; if we get a stack underflow, treat as clean termination status
        cmp #R_STACKUNDER
        bne chekok
dun     rts             ; propagates up

        ; otherwise we don&#39;t handle any return status other than OK
chekok  cmp #R_OK
        beq chekpc
        ; err out, wait for a rescue
bail    sta $d020
        inc $d020
        jmp bail

        ; check for a call to $ffd2 and redirect to Kernal call
chekpc  lda pc+1
        cmp #&gt;CHROUT
        bne lup
        lda pc
        cmp #&lt;CHROUT
        bne lup

kffd2   lda areg
        jsr CHROUT      ; propagates up
        jsr DORTS
        cmp #R_STACKUNDER
        beq dun
        jmp lup
</pre></div>
<p>
Our cold start sets the start address and zaps both the processor status register and stack pointer, and then starts calling the VM. As the PC ticks along, if the kernel discovers that it points to <tt>CHROUT</tt>, it grabs the guest accumulator, calls that routine on behalf of the payload, pulls the return address off the stack and returns to the loop.
</p><p>
You&#39;ll have noticed that both the kernel and the payload have the same starting address of <tt>KERNEL</tt> — and that&#39;s because this kernel can also <em>be its own payload</em>! That&#39;s how <a href="https://github.com/classilla/6o6/tree/main/examples/inception/">it virtualized itself virtualizing itself</a> in those animated GIFs back at the beginning, using the <em>exact same</em> harness and kernel as this example. In fact, I&#39;ve symlinked them to make it clear they&#39;re exactly the same. Only the main program that kicks all that off is different because it has to shift things forward in memory. Here&#39;s how that looks (both the C64 and the Apple IIe use the same memory map):

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiHXhHZPyuqf6RFNsVzYgsRTkylONI-1a3cdga8idWZfcAnVFBazqOFR7AnrZlRSRdoAz0Jdpz7xlsnnXrohqqX5_tDTFFNX0H10QdTTdZrVipx0kXTYVoId14tOUGRs5ikRzHMoS2xT7pVGlT9WJ1bLTGLsFVs-2e1zUpfiCfMUbxg5DsYKeDyyg5mOEE/s5302/inception.png"><img alt="" data-original-height="3047" data-original-width="5302" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiHXhHZPyuqf6RFNsVzYgsRTkylONI-1a3cdga8idWZfcAnVFBazqOFR7AnrZlRSRdoAz0Jdpz7xlsnnXrohqqX5_tDTFFNX0H10QdTTdZrVipx0kXTYVoId14tOUGRs5ikRzHMoS2xT7pVGlT9WJ1bLTGLsFVs-2e1zUpfiCfMUbxg5DsYKeDyyg5mOEE/s320/inception.png" width="320"/></a></p><p>

The bright red &#34;caps&#34; on the right of each bar is the ultimate payload. Each little band has its own zero page and stack, and the payload for the previous stage overlaps with the kernel for the next stage. Because 6o6 currently uses self-modifying code for expediency, the main program (which I&#39;ve puckishly termed the &#34;hypervisor&#34;) just copies everything up in memory, since each stage needs its own copy of the VM. As the harness I showed you earlier computes the physical address with an add, the same harness works at each level to propel the virtual address to the right place and everything is seen in the same location by each preceding stage.
</p><p>
Consequentially, it should also be noted that by stage 3 the majority of memory usage here is given over to three entire copies of the VM, which with the inlined fetch macros weighs in at over ten kilobytes a pop. While I could probably cut out a few more executed instructions by even more aggressively inlining everything, I think I&#39;m currently at or near the point of diminishing returns with respect to memory usage. Twenty years occasionally refining your own code will do that.
</p><p>
Just like the movie, the deeper you get, the more levels you have to bubble up through. At stage 3, a call to <tt>CHROUT</tt> gets turned into a call to <tt>CHROUT</tt> at stage 2, which gets turned into a call to <tt>CHROUT</tt> at stage 1, which finally gets turned into a call to the native routine. Each is the same code and each handles the call the same way which percolates up to the lowest stage where the native call actually occurs.
</p><p>
Of course, when the payload completes, we&#39;ll need a &#34;<a href="https://inception.fandom.com/wiki/Kick">kick</a>&#34; to exit.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEic4Rrn5zjPQeejaGfnUWVw4IpJRMSAiGZ94HnZHvJUR_gh1kIQ0l9QFw4wTkslO2_S2E3x0TG1mJ8Imi_xqvaRaXWQLowL5o8c9HPGzLIg1x-Yk0gYEe6aP2JkSv34Sjm0nwL10OtaQXty3c3sODXht5-Gy2e7ekjoUycLjVGevdWJ6dV9bpGGwWNDxWI/s1200/kick.jpg"><img alt="" data-original-height="800" data-original-width="1200" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEic4Rrn5zjPQeejaGfnUWVw4IpJRMSAiGZ94HnZHvJUR_gh1kIQ0l9QFw4wTkslO2_S2E3x0TG1mJ8Imi_xqvaRaXWQLowL5o8c9HPGzLIg1x-Yk0gYEe6aP2JkSv34Sjm0nwL10OtaQXty3c3sODXht5-Gy2e7ekjoUycLjVGevdWJ6dV9bpGGwWNDxWI/s320/kick.jpg" width="320"/></a></p><p>

The &#34;kick&#34; is the </p><tt>RTS</tt><p> instruction — a </p><tt>BRK</tt><p> could also serve, and may even be more appropriately explosive, but I wanted the payload to be &#34;more or less normal&#34; code. You may have noticed we check for stack underflow in the kernel, which is a condition the harness can throw an exception for if it wants. (In KIMplement we don&#39;t; the stack just wraps, as it would on a real KIM-1.) Since we just &#34;start&#34; into the payload/kernel, there is no return address on the stack, so when the terminal payload wherever it is hits the </p><tt>RTS</tt><p> we have nothing to pull from. This gets reported up to the kernel that&#39;s supervising it which then does an </p><tt>RTS</tt><p> itself. At the deeper stages this too gets propagated back up and up until it reaches the native kernel, which then returns to the &#34;hypervisor.&#34;
</p><p>
After all three stages are run, the hypervisor cleans up so you can run it again — on the Apple II, <tt>CALL 2051</tt>; on the C64, just <tt>RUN</tt> it — and then terminates to BASIC. I note parenthetically that this program extends up into the resident DOS range on the Apple II above $9000, so you should reboot after you&#39;re done playing around. 
</p><p>
The third demo is <a href="https://github.com/classilla/6o6/tree/main/examples/tasks/">a tiny task-switching kernel</a> that jumps back and forth between two independent tasks. Each task has its own zero page and stack, along with a tiny address range for its code to live in. Each task is encapsulated and completely unaware of the other task or, indeed, of the VM actually running it.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiCsv4PcszjeaZKAwJkR7CVmjZenAqokEFZEuPEkTHg56hqYEXb2C8CPykaZ5YfLBOjyVENl5QhhNS83PDpCN3Vx83-zTTQXYF0rZZ8codAykjSaXWIqLv9EKc_C0x6W9m2Qk4LNFpcs3TxlSPrGbW0XmhN6NOHMiwRmWlC34gb1wg4k9fjqF94u4Cq2bY/s1344/Screenshot%202024-04-17%20at%208.44.48%E2%80%AFPM.png"><img alt="" data-original-height="1112" data-original-width="1344" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiCsv4PcszjeaZKAwJkR7CVmjZenAqokEFZEuPEkTHg56hqYEXb2C8CPykaZ5YfLBOjyVENl5QhhNS83PDpCN3Vx83-zTTQXYF0rZZ8codAykjSaXWIqLv9EKc_C0x6W9m2Qk4LNFpcs3TxlSPrGbW0XmhN6NOHMiwRmWlC34gb1wg4k9fjqF94u4Cq2bY/s320/Screenshot%202024-04-17%20at%208.44.48%E2%80%AFPM.png" width="320"/></a></p><p>

The two tasks are one displaying the letters of the alphabet, and one displaying numbers (in reverse video to make them visually distinct). Each time you press a key, the task switches. Even though each task uses the same location in zero page to track its state, their zero pages are independent, so they pick up where they last left off. If you hold down a key, then as the keypresses go through, the kernel switches back and forth between the two of them. (In fact, on the C64 version, the &#34;reverse video&#34; will bleed because it&#39;s possible for the numbers task to print the RVS ON sequence but get immediately swapped out after for the other task. This doesn&#39;t happen on the Apple II version where inverse video is a separate set of printable screen codes.)
</p><p>
All that&#39;s necessary to context-switch is to keep track of the current task and have storage areas for the processor state of each one (i.e., A, X, Y, P, S and PC). The harness looks at the task &#34;on CPU&#34; and selects the proper physical addresses for the zero page, stack and executable code accordingly; the kernel stores and loads the other state when instructed to swap and marks the other task as &#34;on processor.&#34; This demo runs until you stop it with RUN-STOP/RESTORE or Control-Break.
</p><p>
<a href="https://github.com/classilla/6o6/tree/main/examples/vmgr/">For the last demonstration</a>, which runs only on the Commodore 64 (though it could be adapted for 128K systems like the 128 or Apple IIe), we&#39;ll provide a full 64K addressing space that uses none of the system&#39;s own RAM — it&#39;s all external memory. Since the C64 has only 64K of RAM of its own, this will require some hardware.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBxalYd2uE5wZGhzrWF-w_3DVWx-cPPXS7K647Y3AH1HCZqKJMorOLtlUQH16FStMoIX0vf5kjC77iD2ihF_clYSenseCcUYfUhps4KLYHQhYh74__xQy1JBEGSERhrmuG6GD_SmpJepcEDliMXbIYVlHQ-0MvBnrDH4qVYQlTg-vmDna7P5LZwFCs39k/s4080/PXL_20240420_230456794.jpg"><img alt="" data-original-height="4080" data-original-width="3072" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBxalYd2uE5wZGhzrWF-w_3DVWx-cPPXS7K647Y3AH1HCZqKJMorOLtlUQH16FStMoIX0vf5kjC77iD2ihF_clYSenseCcUYfUhps4KLYHQhYh74__xQy1JBEGSERhrmuG6GD_SmpJepcEDliMXbIYVlHQ-0MvBnrDH4qVYQlTg-vmDna7P5LZwFCs39k/s320/PXL_20240420_230456794.jpg"/></a></p><p>

The geoRAM is a paged RAM device distinct from the Commodore-official RAM Expansion Unit (REU), which is DMA-oriented. REU memory is not accessible directly, only by operations that read from, overwrite or exchange it with main memory using the custom MOS 8726 REC. Commodore 64 GEOS is very memory-hungry and GEOS supports the REU to reduce dependence on the disk drive, but the proprietary REC chip was expensive and suffered from supply shortages, so Berkeley Softworks came up with a cheaper alternative of its own. (Ah, Shattuck Avenue, says this Berkeley Master&#39;s graduate.)
</p><p>
Similar to schemes like early LIM EMS, the geoRAM maps its memory into a &#34;window&#34; page — in this case a 256-byte page in the I/O range at $de00 — with its control registers at $dffe and $dfff to change which page is accessed. This is convenient since that block of I/O space doesn&#39;t take away any RAM. Pulling up the correct page is merely a matter of setting the registers to the one you want and the window page is instantaneously read-write, so you don&#39;t need to flush any caches to bank in another one. Though the geoRAM complicates this slightly by using 16K &#34;banks&#34; (64K would have been more convenient), overall the geoRAM was a very straightforward and inexpensive scheme that can be implemented with off-the-shelf components, and compatible modern clones now have capacities up to 4MB. VICE can easily emulate a geoRAM.
</p><p>
For this demo I wanted to emulate a simple terminal-based system with a full 64K. As it happens, for a period of time the <a href="https://rc2014.co.uk/">RC2014 Z80 kit computer</a> had <a href="http://ancientcomputing.blogspot.com/2017/05/a-6502-cpu-for-rc2014-part-1.html">a third-party 6502 processor module</a> available, for which a ROM was provided that <a href="https://ancientcomputing.blogspot.com/2017/06/a-6502-cpu-for-rc2014-software.html">has both a simple monitor and Lee Davison&#39;s EhBASIC</a> (<a href="http://www.6502.org/users/mycorner/index.html">rip</a>). Like before I wanted to use a pre-built ROM so that you can see there&#39;s &#34;nothing up my sleeve,&#34; and fortunately there&#39;s a set <a href="https://github.com/ancientcomputing/rc2014/tree/master/rom/6502/monitor_ehbasic">on Github</a>. We&#39;ll use the 6551 version, though we could use any of them (mutatis mutandis) since we&#39;re going to trap the terminal routines anyway.
</p><p>
Here&#39;s the harness store routine. As I mentioned, the geoRAM deals in 16K instead of 64K banks. We&#39;re going to just occupy the first 64K of what&#39;s there but we&#39;ll still need to handle the bank computation for anything between 16K and 64K.
</p><div><pre>        ; poke .a into location indicated by dptr
        ; okay to clobber x and y
mpoke   ldx dptr+1
        cpx #&gt;ROMSTART
        bcc :+
        ; no writes to emulated ROM, cheaters
        rts
        ; page unchanged? if so, skip all this nonsense
:       cpx curpage
        beq :++
        ; map the high byte maps onto the geoRAM page registers
        stx curpage     ; cache it
        cpx #64
        bcs :+
        ; below $4000, direct mapping
        stx $dffe
        ldx #0
        stx $dfff
        ldx dptr
        sta $de00,x
        rts
        ; $4000 and up indirect mapping, convert to block and bank
:       tay
        txa
        and #63
        sta $dffe
        txa
        and #192
        clc             ; carry is still set
        rol
        rol
        rol
        sta $dfff
        tya
:       ldx dptr
        sta $de00,x
        rts
</pre></div>
<p>
<tt>ROMSTART</tt> is the location of ROM in guest memory, which for the preassembled ROM image is $c100. Writes to it are simply ignored. For writes below 16K, we have a fast path; for everything else, there&#39;s <s>MasterCard</s> a quick banking adjust with masks and shifts. This isn&#39;t a slow calculation but it isn&#39;t necessary if we&#39;re already on the same page (particularly true for instruction fetches), so we always cache the current page the geoRAM is on.
</p><p>
The reason I wanted something with both a monitor and BASIC is so that you can mess around with the emulated machine&#39;s memory and any errors just bail out to the monitor. The main program and the kernel are one and the same in this example, so once the main program has checked that there&#39;s a geoRAM present and it seems to be working (by using its own harness, also a good self-test), it will copy the ROM image into geoRAM and begin execution. The relevant instruction loop looks like this:
</p><div><pre>lup     jsr VMU

        ; check status
        cmp #R_BRK
        beq dobrk
        cmp #R_BADINS
        beq doill
        cmp #R_UDI
        beq doill
        cmp #R_MFAULT   ; nb - current version can&#39;t generate this
        beq doill
        ; other conditions ignored
</pre></div>
<p>
<tt>BRK</tt> instructions go back to the monitor, as they do with most monitors.
</p><div><pre>        ; brk handler
dobrk   ; stack already set up by VM
        lda PAYLOAD+ROMSIZE-2
        sta pc
        lda PAYLOAD+ROMSIZE-1
        sta pc+1
        jmp lup
</pre></div>
<p>
But so that we can use the same machinery in the monitor, we &#34;forge&#34; a <tt>BRK</tt> for other failures like an illegal instruction or the special user-defined instruction trap (also notionally an illegal instruction).
</p><div><pre>        ; illegal failure handler
        ; effectively turn the faulting instruction into a brk
doill   ; do what VM opbrk would do, but wind the pc back one instruction
        ; since the bad opcode was already fetched
        lda pc
        clc
        adc #1          ; not 2
        sta hold0
        lda pc+1
        adc #0
        sta hold1       
        ; put high byte on first so it comes off last
        jsr SPUSH
        lda hold0
        jsr SPUSH
        lda preg
        ora #%00110000
        jsr SPUSH
        lda preg
        ora #%00010000  ; set bit 4 for B-flag, leave IRQs alone
        sta preg
        jmp dobrk
</pre></div>
<p>
The other main part of the kernel/main program is handling a simple emulated terminal. Since the RC2014 assumes a PC-type terminal, we intercept its serial vectors (for the other UARTs these values may need to be changed), translate to and from PETSCII and maintain a little cursor, twiddling the guest registers and flags according to the results. At any time you can do a &#34;three finger salute&#34; and reset the emulated system with CTRL-SHIFT-Commodore, leaving memory intact.
</p><div><pre>        ; check for emulated ROM routines
        ; these come from disassembling the reset routine at $ff0f
        ; use the targets rather than ff03, ff06, ff09, ff0c so that
        ; the vectors can be redirected to user code if desired
        ;
        ; f931 = init (no-op)
        ; f941 = input_char (wait) ($ff03 vectored at $03d0)
        ; f94c = input_char (no wait, carry flag) ($ff06 vectored at $03d2)
        ; f959 = output_char ($ff09 vectored at $03d4)
        ; fa05 = print string at a, x ($ff0c)

        lda pc+1
        cmp #$f9
        beq lowchek
        cmp #$fa
        bne lup
        ; $fa05 is the only routine in $faxx we patch
        lda pc
        cmp #$05
        bne lup
        jmp epstrax
        ; check $f9xx routines
lowchek lda pc
        cmp #$31
        beq euinit
        cmp #$41
        beq euinput
        cmp #$4c
        beq euscan
        cmp #$59
        beq euout
        jmp lup
</pre></div>
<p>
Let&#39;s pop it into VICE.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhrAd-ePNNHX_WMpKB42efKwVxXTXpMyPB1TYgAoMDCV6QTrN3aIG_yEpqNw_X467tJqyn1eFBy5Kgvt03hnQzV4xRCouzXmolulgWZNbk7r7TzUR8JRN-pEVz0Ad0zU6XRVtzpKuIDDY2c1chC9xg08NgC5jrDiXelZDjI7m8Lv15KH5c4Kq8oA5JMlJo/s1632/Screenshot%202024-04-17%20at%208.50.28%E2%80%AFPM.png"><img alt="" data-original-height="1556" data-original-width="1632" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhrAd-ePNNHX_WMpKB42efKwVxXTXpMyPB1TYgAoMDCV6QTrN3aIG_yEpqNw_X467tJqyn1eFBy5Kgvt03hnQzV4xRCouzXmolulgWZNbk7r7TzUR8JRN-pEVz0Ad0zU6XRVtzpKuIDDY2c1chC9xg08NgC5jrDiXelZDjI7m8Lv15KH5c4Kq8oA5JMlJo/s320/Screenshot%202024-04-17%20at%208.50.28%E2%80%AFPM.png" width="320"/></a></p><p>

The screenshot here shows starting it up and entering EhBASIC (from the monitor, </p><tt>g c100</tt><p> for cold start or </p><tt>g c103</tt><p> for warm). This particular version has been minimally patched by the RC2014-6502 author to implement a </p><tt>SYS</tt><p> command to return to the monitor. On a cold start, EhBASIC will ask for the memory size, or if you give it none, count it up itself. The unaccelerated C64 using geoRAM takes about a minute to discover that it has 32768 bytes free (it&#39;s actually more but this ROM was built with a hard cap at $8000, so you can put things at $8000 through $c0ff) because it has to swap the window back and forth between the instructions it fetches and the RAM locations it reads, or you can just type 32768 to skip all that. EhBASIC annoyingly does not accept lower-case commands or keywords and you must type everything in UPPERCASE. We run a simple little BASIC program to show it works, then intentionally try to foul the machine by storing and executing a jam instruction. The monitor is duly and swiftly invoked with the PC correctly pointing to the offender.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhLSj8sACqwLvcU_BC-puSEMuLsNPS73TdQQGpggdXiuzEct1p1I33z5K3fEzog8UIWHl8R5rvWJiCK2iLkkKlmgtRB-7X6X19hyphenhyphento30i4lD8Jzm_A7k0AYB9yBQgnaZ0bVhEgwpPxFuFDep0EsZxFQwOmKywc20M5F4-A5iT4xQa5KSNssRFpxYR1YZoQ/s4080/PXL_20240420_234728625.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhLSj8sACqwLvcU_BC-puSEMuLsNPS73TdQQGpggdXiuzEct1p1I33z5K3fEzog8UIWHl8R5rvWJiCK2iLkkKlmgtRB-7X6X19hyphenhyphento30i4lD8Jzm_A7k0AYB9yBQgnaZ0bVhEgwpPxFuFDep0EsZxFQwOmKywc20M5F4-A5iT4xQa5KSNssRFpxYR1YZoQ/s320/PXL_20240420_234728625.jpg" width="320"/></a></p><p>

And here it is on my real Commodore 128DCR with my real geoRAM cartridge installed. Notice that floating point math works just fine, too, and that the bad instruction is once again immediately intercepted in a controlled fashion. Other than the 256 byte window peeping through, none of what we&#39;re looking at here actually executes from the 6502&#39;s own address space. Even on this basic 512K geoRAM unit you could have eight entire 6502 system tasks, all separate and independent, with only a minimum of state for each one needing to be maintained on the actual processor.
</p><p>
What are some future improvements to 6o6? Naturally I&#39;d like it to be able to run from ROM, though this would require some refactoring and would possibly make it slower, so this would only ever be an option. Also, although I consider making something like this emulate a 65816 on an NMOS 6502 to be thoroughly out of scope, it might be possible to have it emulate CMOS instructions on the NMOS system, just as this will (mostly) act like an NMOS CPU when run on a CMOS system. Note that since the ALU is used, an NMOS 6502 emulating a CMOS 65C02 will still have flags set the way the NMOS system would do it and vice versa, and the addressing is currently written the way an NMOS CPU would do it, like indirect jumps to $xxff pulling the vector from $xxff and $xx00. Additionally, despite the performance improvements I&#39;ve implemented over the years, depending on how the inline memory macros are done there are peephole optimization opportunities that could potentially be accomplished with a &#34;post-preprocessor&#34; pass before actual assembly. That would make the tooling more complex, so I&#39;d have to see how much benefit that realizes in the general case.
</p><p>
Other than using 6o6 to power a custom operating system, though, another obvious use is running downloaded code without messing up what you&#39;re currently doing. My next application might be as part of a Gopher client where you can dynamically run what you download, like a networked file system. That could have possibilities!
</p><p>
If you&#39;re designing your own ultimate 6502 system, of course, 6o6 is not (primarily) meant for you — you can just implement the hardware you want to implement the features you need, and because you&#39;re in control of the design you&#39;d be able to do it faster. But if you&#39;re trying to do this on an NMOS CPU where you have fewer guardrails, or to do it with a minimum of added silicon, then here&#39;s another option that&#39;s designed to be flexible and adaptable.
</p><p>
Meanwhile, the updates for KIMplement 1.0 are just minor bug fixes and cleaning it up for public display. I&#39;ve also included Tiny PILOT courtesy of <a href="http://www.vanportmedia.com/PAL-1/utilities/index.html">Dave Hassler</a>, which originally appeared in <i>MICRO</i> magazine written by Nicholas Vrtis in 1979 with patches by Bob Applegate (<a href="http://oldvcr.blogspot.com/2023/06/rip-bob-applegate.html">rip</a>) and Dave himself. It runs splendidly and is a nice small implementation of <a href="https://en.wikipedia.org/wiki/PILOT">an interesting language</a> that ought to have a second life in scripting. Dave also ported ELIZA to it from the 1980 Atari PILOT implementation by Carol Shaw and Harry Stewart, which serves as a historically noteworthy demonstration.
</p><p>
The Incredible KIMplement is available <a href="http://www.floodgap.com/retrobits/kim-1/emu.html">from its homepage</a>, along with sourcecode <a href="https://github.com/classilla/kimplement">on Github</a>. 6o6 is also available <a href="https://github.com/classilla/6o6">on Github</a> and all four of the examples shown here. Both the KIMplement and 6o6 are under the <a href="http://www.floodgap.com/software/ffsl/">Floodgap Free Software License</a>.
</p>
</div></div>
  </body>
</html>
