<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.matthewbrunelle.com/testing-out-ble-beacons-with-beacondb/">Original</a>
    <h1>Testing out BLE beacons with BeaconDB</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<main>

        <article>

        

    <div>
        
<h2 id="what-on-earth-is-beacondb">What on earth is beaconDB?</h2>
<p>I&#39;ve been <a href="https://blog.matthewbrunelle.com/i-picked-a-really-weird-time-to-try-out-grapheneos/">using GrapheneOS</a> for about half a year now. Back in March they <a href="https://github.com/eylenburg/eylenburg.github.io/issues/126?ref=blog.matthewbrunelle.com#issue-2892178110">added support</a> for <a href="https://grapheneos.org/features?ref=blog.matthewbrunelle.com#network-location">network based location</a>.[^0] This means you no longer need to rely on Google&#39;s location services. Looking into how the system works sent me down yet another rabbit hole of reading. </p>
<p>Anyways, in 2013 Mozilla <a href="https://blog.mozilla.org/services/2013/10/28/introducing-the-mozilla-location-service/?ref=blog.matthewbrunelle.com">launched Mozilla Location Service (MLS)</a> as a pilot project to provide location lookup using observations of public cell towers, BLE Beacons and WiFi access points. Sadly, in 2024 Mozilla <a href="https://discourse.mozilla.org/t/retiring-the-mozilla-location-service/128693?ref=blog.matthewbrunelle.com">retired MLS</a>. Thankfully, <a href="https://beacondb.net/?ref=blog.matthewbrunelle.com">beaconDB</a> launched to continue the work! </p>
<p>I have been hacking away on a project for contributing observations to beaconDB and I wanted some BLE beacons I could use for testing. This experiment sort of spun off from that work.</p>
<p>The plan is simple:</p>
<ul>
<li>Buy some BLE beacons.</li>
<li>Get their MAC addresses.</li>
<li>Query the beaconDB API to confirm no location is currently associated with the beacons.</li>
<li>Place the beacons in my yard. </li>
<li>Take my dog on a walk around the block while running NeoStumbler.</li>
<li>Re-run the API query to see location estimates.</li>
</ul>
<hr/>
<h2 id="what-on-earth-are-ble-beacons">What on earth are BLE Beacons?</h2>
<p>I&#39;ve been writing the phrase BLE beacons a lot without describing what they are. So to disambiguate :</p>
<ul>
<li>Bluetooth - a wireless communication standard.</li>
<li>Bluetooth Low Energy - part of the Bluetooth 4.0 protocol, much lower power consumption, but also reduced transmission rates.</li>
<li>BLE beacons - BLE devices that are primarily transmit only.</li>
</ul>
<p>Stationary BLE beacons are often used to mark locations in places where GPS signals are weak, like inside malls. Also, there is no single BLE beacon standard. Instead we have:</p>
<p>iBeacon which was released by Apple in 2013. Apple generally still supports them.</p>
<p>In 2014 Google launched the experimental URIBeacon. Then in 2015 Google replaced that with Eddystone.  A one point Google was really into the concept of the <a href="https://google.github.io/physical-web/?ref=blog.matthewbrunelle.com">Physical Web</a>, but thankfully <a href="https://android-developers.googleblog.com/2018/10/discontinuing-support-for-android.html?ref=blog.matthewbrunelle.com">gave up on</a> spamming users with notifications in 2018. This effectively reduced Google&#39;s involvement with the standard. Eddystone also powers the Waze beacons that <a href="https://privacysos.org/blog/googles-bluetooth-beacons-massdot-tunnels-privacy/?ref=blog.matthewbrunelle.com">saves me from missing my exit</a> in the Ted Williams Tunnel.</p>
<p>AltBeacon was released in 2014 as an open standard. There are also other less used beacon standards out there.</p>
<p>Also, since BLE beacons are just BLE devices with extra details attached to the broadcast information, both iPhones and Android devices can scan for any standard. Best of all, most modern beacon devices should support broadcasting multiple beacon types at the same time.</p>
<p>In terms of collecting information about all these different types of beacons, Neostumbler uses the <a href="https://altbeacon.github.io/android-beacon-library/?ref=blog.matthewbrunelle.com">Android Beacon Library</a>, which can detect the three main beacon types. Though <a href="https://github.com/mjaakko/NeoStumbler/issues/478?ref=blog.matthewbrunelle.com">they want to</a> move away from the library so they can support custom scanning intervals.</p>
<hr/>
<h2 id="which-ble-beacons-did-i-choose">Which BLE beacons did I choose?</h2>
<p>When I was surveying the options I saw that many beacons included features like motion detection, lights, buttons, sound, etc. I wanted a stationary beacon with a long battery life, so I tried to avoid extra features if possible to keep the cost down. Additionally there are BLE beacons designed for broadcasting over extra long ranges. However the <a href="https://ichnaea.readthedocs.io/en/latest/algo/accuracy.html?ref=blog.matthewbrunelle.com#bluetooth-wifi">Bluetooth / WiFi accuracy</a> section of the MLS documentation notes:</p>
<blockquote>
<p>Bluetooth and WiFi networks have a fairly limited range. Bluetooth low-energy beacons typically reach just a couple meters and WiFi networks reach up to 100 meters. With obstacles like walls and people in the way, these distances get even lower.</p>
</blockquote>
<p>So in my case, I specifically do not want a long range beacon in order to improve location accuracy.</p>
<p>In the end I settled on the Feasy FSC-BP104D and bought two of them:</p>
<p>There is the <a href="https://play.google.com/store/apps/details?id=com.feasycom.feasybeacon&amp;hl=en_US&amp;ref=blog.matthewbrunelle.com">FeasyBeacon app</a> which leaves a lot to be desired, but is not totally useless.  I powered up the two beacons and changed the following settings:</p>
<ul>
<li>Set a new PIN.</li>
<li>I reduced the broadcast interval time from the default 1300ms to 1000ms. This will increase the batter usage, but allows for more frequent updates.</li>
<li>Changed the name of the beacons to something fun.</li>
<li>Updated the broadcast URL so that I was not advertising a Feasy store page. Sadly, the character limit was not long enough to broadcast my blogs address. So I chose the beaconDB website instead.</li>
<li>Checked for firmware updates.</li>
</ul>
<p>Then I uninstalled the app, hoping to never have to use it again.</p>
<hr/>
<h2 id="trying-out-the-api-and-confirming-the-beacons-are-not-associated-with-a-location">Trying out the API and confirming the beacons are not associated with a location</h2>
<p>beaconDB provides a <a href="https://ichnaea.readthedocs.io/en/latest/api/geolocate.html?ref=blog.matthewbrunelle.com">geolocate endpoint</a>. The old MLS version required an API key, but that is no longer needed:</p>
<blockquote>
<p>Instead of using API keys to control access like Mozilla did, beaconDB expects clients to be pre-configured with a reasonable user agent. Ideally this identifies the software the client is using and includes info that can be used to narrow things down in the event a bad configuration or bug causes significant load on the server.</p>
</blockquote>
<p>As a first step I wanted to confirm I could hit the API and get a valid location as a response. So I threw together a quick Python script:</p>
<pre><code>import requests  
  
url = &#34;https://api.beaconDB.net/v1/geolocate&#34;  
  
headers = {&#39;User-Agent&#39;: &#39;beaconDB test script, blog.matthewbrunelle.com&#39;,} 
  
body = {
    &#34;wifiAccessPoints&#34;: [{
        &#34;macAddress&#34;: &#34;01:23:45:67:89:ab&#34;,
        &#34;signalStrength&#34;: -51
    }, {
        &#34;macAddress&#34;: &#34;01:23:45:67:89:cd&#34;
    }]
} 
  
response = requests.post(url, json=body, headers=headers)  
  
if response.status_code != 200:  
    print(f&#34;Error: {response.status_code}&#34;)  
else:  
    print(response.json())

</code></pre>
<p>Note: The example code for the blog post uses the example MAC addresses from the documentation, not real ones.</p>
<p>The API is pretty simple and most fields are optional. The main information you need to provide are MAC addresses and the signal strength for the observation. If I input the MAC addresses for my home access points , I get a response like:</p>
<pre><code>{&#39;location&#39;: {&#39;lat&#39;: XX.XXXXXX, &#39;lng&#39;: -XX.XXXXXX}, &#39;accuracy&#39;: 132}
</code></pre>
<p>Which gives the location of the house directly across the street from me. The accuracy is measured in meters, so the circle with a radius of 132 meters centered on that position does, in fact, contain my apartment. Not bad for locating off a single observation. beaconDB works best when you can query with multiple device observations at once.</p>
<p>Next, I wanted to hit the same endpoint, but using my BLE beacons. The app provided the beacons information, but they also had their MAC addresses printed on their side. I changed the body in the script above to:</p>
<pre><code>body = {  
    &#34;considerIp&#34;: False,  
    &#34;bluetoothBeacons&#34;: [{
        &#34;macAddress&#34;: &#34;ff:23:45:67:89:ab&#34;,
        &#34;age&#34;: 2000,
        &#34;name&#34;: &#34;beacon&#34;,
        &#34;signalStrength&#34;: -110
    }],
    &#34;fallbacks&#34;: {  sdf10adfasdfasf
        &#34;lacf&#34;: False,  
        &#34;ipf&#34;: False  
    }  
}
</code></pre>
<p>Note that here I made sure to set <code>considerIp</code> and <code>fallbacks</code> to false, so that the API purely relies on the BLE beacon. From the docs:</p>
<blockquote>
<p>The <code>fallbacks</code> section allows some control over the more coarse grained position sources. If no exact match can be found, these can be used to return a “404 Not Found” rather than a coarse grained estimate with a large accuracy value.</p>
</blockquote>
<p>As expected, I get a 404 back from the API.</p>
<hr/>
<h2 id="collecting-observations-with-neostumbler-and-testing-the-api">Collecting observations with Neostumbler and testing the API</h2>
<p>This part was pretty easy. <a href="https://github.com/mjaakko/NeoStumbler?ref=blog.matthewbrunelle.com">NeoStumbler</a> is a great app for contributing observations to beaconDB. I started recording and took my dog for a walk around the block. At the end of the walk I uploaded my observations. Then I just needed to wait, but not for too long:</p>
<blockquote>
<p>note that submissions will take at least 5 minutes to become available in the beaconDB</p>
</blockquote>
<p>Except... I was still getting 404s for my BLE beacons.</p>
<p>Neostumbler has a mechanism <a href="https://github.com/mjaakko/NeoStumbler/blob/bec73e6a67117e86c4b3d5c495f94ac90db5f509/app/src/main/java/xyz/malkki/neostumbler/scanner/postprocess/AutoDetectingMovingWifiBluetoothFilterer.kt?ref=blog.matthewbrunelle.com#L19">for filtering out moving devices</a>, so the next thing I tried was disabling that. However I was still getting 404s...</p>
<hr/>
<h2 id="directly-submitting-observations-to-beacondb">Directly submitting observations to beaconDB</h2>
<p>OK, so at this point  I do not know if the issue is with Neostumbler submitting my observations, or beaconDB using them. Thankfully, Neostumbler lets you export your observations to csv.</p>
<p><img src="https://blog.matthewbrunelle.com/content/images/2025/10/Neo-stumbler-screenshot-export-to-csv.png" alt="Neostumbler screenshot export to csv" loading="lazy"/></p>
<p>So I was able to directly submit an observation using the <a href="https://ichnaea.readthedocs.io/en/latest/api/geosubmit2.html?ref=blog.matthewbrunelle.com">geosubmit v2 endpoint</a>. The export contains every piece of information you can submit, except for the GPS heading and the beacon name.</p>
<pre><code>import requests  
  
url = &#34;https://api.beacondb.net/v2/geosubmit&#34;  
  
headers = {&#39;User-Agent&#39;: &#39;BeaconDB test script, blog.matthewbrunelle.com&#39;,}  
  
{&#34;items&#34;: [{
    &#34;timestamp&#34;: 1405602028568,
    &#34;position&#34;: {
        &#34;latitude&#34;: -22.7539192,
        &#34;longitude&#34;: -43.4371081,
        &#34;accuracy&#34;: 10.0,
        &#34;age&#34;: 1000,
        &#34;altitude&#34;: 100.0,
        &#34;altitudeAccuracy&#34;: 50.0,
        #&#34;heading&#34;: 45.0,
        &#34;pressure&#34;: 1013.25,
        &#34;speed&#34;: 3.6,
        &#34;source&#34;: &#34;gps&#34;
    },
    &#34;bluetoothBeacons&#34;: [
        {
            &#34;macAddress&#34;: &#34;ff:23:45:67:89:ab&#34;,
            &#34;age&#34;: 2000,
            #&#34;name&#34;: &#34;beacon&#34;,
            &#34;signalStrength&#34;: -110
        }
    ],
}]}
  
response = requests.post(url, json=body, headers=headers)  
  
print(f&#34;Status code: {response.status_code}&#34;)  
if response.status_code == 200:  
    print(response.json())
</code></pre>
<p>Anyways, after running this script I wait again... and still a 404. At this point I realized that I had never run a test of a known good BLE beacon against the API to make sure I get a location back. So I dumped a full month of observations which contained a recent road trip I went on  and check some of those MAC addresses. Still nothing.</p>
<hr/>
<h2 id="double-checking-the-beacondb-source-and-final-thoughts">Double checking the beaconDB source and final thoughts</h2>
<p>So finally, I went to look at the beaconDB source to see what I could find. First I wanted to check if there was a minimum number of observations needed, sort of like the trilateration I learned about in <a href="https://www.instructables.com/HackerBox-0119-Geopositioning/?ref=blog.matthewbrunelle.com">HackerBox 0119 - Geopositioning</a>. A <a href="https://codeberg.org/beacondb/beacondb/src/branch/main/src/geolocate.rs?ref=blog.matthewbrunelle.com">comment from the repository</a> revealed:</p>
<blockquote>
<p>At least two WiFi networks have to been known to accurately determine the position.</p>
</blockquote>
<p>So I tried making the WiFi query I made before, but adding the BLE beacons to see if the accuracy improved... Nothing, the accuracy was the same. As I searched the codebase I realized the problem: beaconDB currently accepts and stores BLE beacons, but does not use them yet for geolocation. So I made <a href="https://codeberg.org/beacondb/beacondb/issues/140?ref=blog.matthewbrunelle.com">an issue</a>.</p>
<p>Not all projects end as expected. At the very least, I learned a lot along the way.  My initial question was &#34;how does beaconDB use BLE beacons&#34;. I should have probably checked if the answer was &#34;it currently doesn&#39;t&#34; before I set everything up.</p>



    </div>
</article>
                
                

</main>
    </div></div>
  </body>
</html>
