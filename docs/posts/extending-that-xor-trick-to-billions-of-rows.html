<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nochlin.com/blog/extending-that-xor-trick">Original</a>
    <h1>Extending That XOR Trick to Billions of Rows</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
      <section>
        
        <time>Jul 3, 2025</time>
        <article><p>Can we extend the XOR trick for finding one or two missing numbers in a list to finding thousands of missing IDs in a billion-row table?</p><p>Yes, we can! This is possible using a data structure called an Invertible Bloom Filter (IBF) that compares two sets with space complexity based only on the size of the difference. Using a generalization of the XOR trick [1], all the values that are identical cancel out, so the size of this data structure depends only on the size of the difference.</p><p>Most explanations of Invertible Bloom Filters start with standard Bloom filters, which support two operations: <code>insert</code> and <code>maybeContains</code>. Next, they extend to counting Bloom filters, which enables a <code>delete</code> operation. Finally, they introduce Invertible Bloom Filters, which add an exact <code>get</code> operation and a probabilistic <code>listing</code> operation. In this article, I will take a different approach and build up to an IBF from the XOR trick.</p><p>IBFs have remained relatively obscure in the software development community while the XOR trick is a well-known technique thanks to leetcode. My goal with this article is to connect IBFs to the XOR trick so that more developers understand this fascinating and powerful data structure.</p><h2 id="finding-3-missing-numbers"><span>
        <a aria-label="link to this heading" aria-describedby="Finding 3 Missing Numbers" href="#finding-3-missing-numbers">
            <i></i>
        </a>
    </span><span>Finding 3 Missing Numbers</span></h2><p>Let&#39;s start with a concrete example:</p><pre><code><span>A</span> <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>,</span><span>10</span><span>]</span>
<span>B</span> <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>10</span><span>]</span>
</code></pre>

<p>Set B is missing 3 numbers: {3, 6, 9}.</p><p>The classic XOR trick works for finding 1 or 2 missing numbers, but what about 3 or more? If we don&#39;t know how many numbers are missing, we can use a count field to detect when the usual XOR trick will fail:</p><pre><code><span>XOR</span><span>(</span><span>A</span><span>)</span> <span>=</span> <span>1</span> <span>^</span> <span>2</span> <span>^</span> <span>...</span> <span>^</span> <span>10</span> <span>=</span> <span>11</span>
<span>COUNT</span><span>(</span><span>A</span><span>)</span> <span>=</span> <span>10</span>
<span>COUNT</span><span>(</span><span>B</span><span>)</span> <span>=</span> <span>7</span>
</code></pre>

<p>Since B has 7 elements and A has 10, we know 3 numbers are missing—too many for the basic XOR trick.</p><p>To work around this limitation, we can partition our sets using a hash function. Let&#39;s try with 3 partitions:</p><pre><code>
<span>H</span><span>(</span><span>1</span><span>)</span> <span>=</span> <span>2</span><span>,</span> <span>H</span><span>(</span><span>2</span><span>)</span> <span>=</span> <span>1</span><span>,</span> <span>H</span><span>(</span><span>3</span><span>)</span> <span>=</span> <span>1</span><span>,</span> <span>H</span><span>(</span><span>4</span><span>)</span> <span>=</span> <span>0</span><span>,</span> <span>H</span><span>(</span><span>5</span><span>)</span> <span>=</span> <span>0</span>
<span>H</span><span>(</span><span>6</span><span>)</span> <span>=</span> <span>0</span><span>,</span> <span>H</span><span>(</span><span>7</span><span>)</span> <span>=</span> <span>2</span><span>,</span> <span>H</span><span>(</span><span>8</span><span>)</span> <span>=</span> <span>1</span><span>,</span> <span>H</span><span>(</span><span>9</span><span>)</span> <span>=</span> <span>2</span><span>,</span> <span>H</span><span>(</span><span>10</span><span>)</span> <span>=</span> <span>1</span>


<span>A_0</span> <span>=</span> <span>[</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>]</span>     <span>B_0</span> <span>=</span> <span>[</span><span>4</span><span>,</span><span>5</span><span>]</span>
<span>A_1</span> <span>=</span> <span>[</span><span>2</span><span>,</span><span>3</span><span>,</span><span>8</span><span>,</span><span>10</span><span>]</span>  <span>B_1</span> <span>=</span> <span>[</span><span>2</span><span>,</span><span>8</span><span>,</span><span>10</span><span>]</span>
<span>A_2</span> <span>=</span> <span>[</span><span>1</span><span>,</span><span>7</span><span>,</span><span>9</span><span>]</span>     <span>B_2</span> <span>=</span> <span>[</span><span>1</span><span>,</span><span>7</span><span>]</span>
</code></pre>

<p>Now each partition has at most 1 missing element, so we can apply the XOR trick to each:</p><pre><code><span>XOR</span><span>(</span><span>B_0</span><span>)</span> <span>^</span> <span>XOR</span><span>(</span><span>A_0</span><span>)</span> <span>=</span> <span>(</span><span>4</span> <span>^</span> <span>5</span><span>)</span> <span>^</span> <span>(</span><span>4</span> <span>^</span> <span>5</span> <span>^</span> <span>6</span><span>)</span> <span>=</span> <span>6</span>
<span>XOR</span><span>(</span><span>B_1</span><span>)</span> <span>^</span> <span>XOR</span><span>(</span><span>A_1</span><span>)</span> <span>=</span> <span>(</span><span>2</span> <span>^</span> <span>8</span> <span>^</span> <span>10</span><span>)</span> <span>^</span> <span>(</span><span>2</span> <span>^</span> <span>3</span> <span>^</span> <span>8</span> <span>^</span> <span>10</span><span>)</span> <span>=</span> <span>3</span>
<span>XOR</span><span>(</span><span>B_2</span><span>)</span> <span>^</span> <span>XOR</span><span>(</span><span>A_2</span><span>)</span> <span>=</span> <span>(</span><span>1</span> <span>^</span> <span>7</span><span>)</span> <span>^</span> <span>(</span><span>1</span> <span>^</span> <span>7</span> <span>^</span> <span>9</span><span>)</span> <span>=</span> <span>9</span>
</code></pre>

<p>Success! We recovered all 3 missing elements: {3, 6, 9}.</p><p>Unfortunately, this approach alone doesn&#39;t work in practice. Here, we got lucky with our hash function. Usually, elements will not distribute evenly across partitions, and some partitions might still have multiple differences.</p><h2 id="detecting-when-the-xor-trick-fails"><span>
        <a aria-label="link to this heading" aria-describedby="Detecting when the XOR trick fails" href="#detecting-when-the-xor-trick-fails">
            <i></i>
        </a>
    </span><span>Detecting when the XOR trick fails</span></h2><p>To fix the problems with naive partitioning, we will need to use a more sophisticated approach.</p><p>Let&#39;s generalize beyond &#34;missing numbers&#34; to the concept of symmetric difference. The symmetric difference of two sets A and B is the set of elements that are in either set but not in both: <code>(A \ B) ∪ (B \ A)</code>, often written as <code>A Δ B</code>.</p><p><img src="https://nochlin.com/images/ibf/Venn0110.svg" alt="Symmetric Difference Venn Diagram"/></p><p><em>Figure 1: The symmetric difference A Δ B includes elements that are in either set A or set B, but not in both sets.</em></p><p>Consider this example:</p><pre><code><span>A</span> <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>6</span><span>]</span>
<span>B</span> <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>4</span><span>,</span><span>5</span><span>]</span>
</code></pre>

<p>The symmetric difference is {3, 6, 5}—elements 3 and 6 are only in A, while element 5 is only in B.</p><p>The naive approach of checking <code>|COUNT(A) - COUNT(B)| = 1</code> fails here because the count difference is 1, but the symmetric difference has 3 elements. Applying the basic XOR trick gives a meaningless result.</p><p>To detect this case, we can use an additional accumulator with a hash function:</p><pre><code><span>COUNT</span><span>(</span><span>A</span><span>)</span> <span>=</span> <span>5</span><span>,</span> <span>XOR</span><span>(</span><span>A</span><span>)</span> <span>=</span> <span>2</span>
<span>COUNT</span><span>(</span><span>B</span><span>)</span> <span>=</span> <span>4</span><span>,</span> <span>XOR</span><span>(</span><span>B</span><span>)</span> <span>=</span> <span>2</span>
<span>XOR_HASH</span><span>(</span><span>A</span><span>)</span> <span>=</span> <span>H</span><span>(</span><span>1</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>2</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>3</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>4</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>6</span><span>)</span>
<span>XOR_HASH</span><span>(</span><span>B</span><span>)</span> <span>=</span> <span>H</span><span>(</span><span>1</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>2</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>4</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>5</span><span>)</span>

<span>XOR</span><span>(</span><span>B</span><span>)</span> <span>^</span> <span>XOR</span><span>(</span><span>A</span><span>)</span> <span>=</span> <span>0</span>
<span>XOR_HASH</span><span>(</span><span>B</span><span>)</span> <span>^</span> <span>XOR_HASH</span><span>(</span><span>A</span><span>)</span> <span>=</span> <span>H</span><span>(</span><span>3</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>5</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>6</span><span>)</span> 
<span>H</span><span>(</span><span>3</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>5</span><span>)</span> <span>^</span> <span>H</span><span>(</span><span>6</span><span>)</span> ≠ <span>H</span><span>(</span><span>0</span><span>)</span> 
</code></pre>

<p>While we can&#39;t yet recover the full symmetric difference, we can detect when the XOR result is unreliable by checking if the hash accumulators behave consistently.</p><h2 id="invertible-bloom-filters"><span>
        <a aria-label="link to this heading" aria-describedby="Invertible Bloom Filters" href="#invertible-bloom-filters">
            <i></i>
        </a>
    </span><span>Invertible Bloom Filters</span></h2><h3 id="the-core-idea"><span>
        <a aria-label="link to this heading" aria-describedby="The Core Idea" href="#the-core-idea">
            <i></i>
        </a>
    </span><span>The Core Idea</span></h3><p>The original XOR trick relies on an accumulator that stores the XOR aggregate of a list. Building on this, we&#39;ve introduced:</p><ol><li><strong>Partitioning</strong> to divide sets into smaller parts</li><li><strong>Additional accumulators</strong> that store the element count and hash of XOR aggregate</li></ol><p>To fully generalize this into a robust data structure, we need:</p><ol><li>A partitioning scheme that creates recoverable partitions with high probability</li><li>An iterative process that uses recovered values to unlock additional partitions</li></ol><p>This is exactly what Invertible Bloom Filters [2] provide. IBFs use a Bloom filter-style hashing scheme to assign elements to multiple partitions, then employ a graph algorithm called &#34;peeling&#34; to iteratively recover the symmetric difference with very high probability [3].</p><h3 id="structure"><span>
        <a aria-label="link to this heading" aria-describedby="Structure" href="#structure">
            <i></i>
        </a>
    </span><span>Structure</span></h3><p>An IBF consists of an array of cells, where each cell contains three accumulators:</p><ul><li><strong>idSum</strong>: XOR aggregate of element values</li><li><strong>hashSum</strong>: XOR aggregate of element hashes</li><li><strong>count</strong>: number of elements in the cell</li></ul><p><img src="https://nochlin.com/images/ibf/ibf.png" alt="IBF Structure"/> <em>Figure 2: Figure from [2] showing the process of encoding elements into IBF cells.</em></p><h3 id="operations"><span>
        <a aria-label="link to this heading" aria-describedby="Operations" href="#operations">
            <i></i>
        </a>
    </span><span>Operations</span></h3><p>For computing symmetric differences, IBFs support three key operations:</p><ol><li><strong>Encode</strong>: Build an IBF from a set of values</li><li><strong>Subtract</strong>: Subtract one IBF from another—identical values cancel out, leaving only the symmetric difference</li><li><strong>Decode</strong>: Recover stored values by finding &#34;pure&#34; cells (count = ±1 and H(idSum) = hashSum) and iteratively &#34;peeling&#34; them</li></ol><p>The IBF has one parameter <code>d</code>—the expected size of the symmetric difference. With proper sizing (typically <code>m &gt; 1.22d</code> cells), IBFs recover the full symmetric difference with very high probability.</p><p><img src="https://nochlin.com/images/ibf/encode_algorithm.png" alt="IBF Encode"/> <img src="https://nochlin.com/images/ibf/subtract_algorithm.png" alt="IBF Subtract"/> <img src="https://nochlin.com/images/ibf/decode_algorithm.png" alt="IBF Decode"/> <em>Algorithms for each IBF operation from [2].</em></p><h3 id="example-implementation"><span>
        <a aria-label="link to this heading" aria-describedby="Example Implementation" href="#example-implementation">
            <i></i>
        </a>
    </span><span>Example Implementation</span></h3><p>I have not found a solid, maintained library of IBFs in any language (if you know of any please let me know!), so I created a basic implementation in Python if you would like to play with it: <a href="https://gist.github.com/hundredwatt/a1e69ff300de941041d824e49249d3d7" target="_blank" rel="noopener noreferrer">https://gist.github.com/hundredwatt/a1e69ff300de941041d824e49249d3d7</a></p><p>Example usage:</p><pre><code>
a <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>]</span>
b <span>=</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>]</span>
set_a <span>=</span> <span>set</span><span>(</span>a<span>)</span>
set_b <span>=</span> <span>set</span><span>(</span>b<span>)</span>
ibf_size <span>=</span> <span>100</span>
k <span>=</span> <span>4</span>


ibf_a <span>=</span> IBF<span>(</span>size<span>=</span>ibf_size<span>,</span> k<span>=</span>k<span>)</span>
<span>for</span> item <span>in</span> a<span>:</span>
   ibf_a<span>.</span>insert<span>(</span>item<span>)</span>

ibf_b <span>=</span> IBF<span>(</span>size<span>=</span>ibf_size<span>,</span> k<span>=</span>k<span>)</span>
<span>for</span> item <span>in</span> b<span>:</span>
   ibf_b<span>.</span>insert<span>(</span>item<span>)</span>


diff_ibf <span>=</span> ibf_a<span>.</span>subtract_ibf<span>(</span>ibf_b<span>)</span>


success<span>,</span> decoded_added<span>,</span> decoded_removed <span>=</span> diff_ibf<span>.</span>decode<span>(</span><span>)</span>


<span>assert</span><span>(</span>success<span>)</span>
expected_added <span>=</span> set_a <span>-</span> set_b
expected_removed <span>=</span> set_b <span>-</span> set_a

<span>print</span><span>(</span><span>&#34;--- Verification ---&#34;</span><span>)</span>
<span>print</span><span>(</span><span><span>f&#34;Expected added (in A, not B): </span><span><span>{</span><span>len</span><span>(</span>expected_added<span>)</span><span>}</span></span><span> items&#34;</span></span><span>)</span>
<span>print</span><span>(</span><span><span>f&#34;Decoded added:                  </span><span><span>{</span><span>len</span><span>(</span>decoded_added<span>)</span><span>}</span></span><span> items&#34;</span></span><span>)</span>
<span>assert</span><span>(</span>expected_added <span>==</span> decoded_added<span>)</span>

<span>print</span><span>(</span><span><span>f&#34;Expected removed (in B, not A): </span><span><span>{</span><span>len</span><span>(</span>expected_removed<span>)</span><span>}</span></span><span> items&#34;</span></span><span>)</span>
<span>print</span><span>(</span><span><span>f&#34;Decoded removed:                  </span><span><span>{</span><span>len</span><span>(</span>decoded_removed<span>)</span><span>}</span></span><span> items&#34;</span></span><span>)</span>
<span>assert</span><span>(</span>expected_removed <span>==</span> decoded_removed<span>)</span>
</code></pre>

<h2 id="about-the-&#34;set-reconciliation&#34;-problem"><span>
        <a aria-label="link to this heading" aria-describedby="About the &#34;Set Reconciliation&#34; Problem" href="#about-the-&#34;set-reconciliation&#34;-problem">
            <i></i>
        </a>
    </span><span>About the &#34;Set Reconciliation&#34; Problem</span></h2><p>The general problem of efficiently comparing two sets without transferring their entire contents is called &#34;set reconciliation.&#34; Early research used polynomial approaches [4], while modern solutions typically employ either Invertible Bloom Filters or error-correction codes [5].</p><h2 id="conclusion"><span>
        <a aria-label="link to this heading" aria-describedby="Conclusion" href="#conclusion">
            <i></i>
        </a>
    </span><span>Conclusion</span></h2><p>IBFs are a powerful tool for comparing sets with space complexity based only on the size of the difference. I hope this article has helped you understand how IBFs work and how they can be used to solve real-world problems.</p><p>If you want to learn more about IBFs, I recommend reading the references below. The &#34;Further Reading&#34; section contains some additional, advanced papers that I found interesting.</p><p>If you have any questions or feedback, please feel free to reach out to me, contact info is in the footer.</p><h2 id="references"><span>
        <a aria-label="link to this heading" aria-describedby="References" href="#references">
            <i></i>
        </a>
    </span><span>References</span></h2><p>[1] Florian Hartmann, &#34;That XOR Trick&#34; (2020), <a href="https://florian.github.io/xor-trick/" target="_blank" rel="noopener noreferrer">https://florian.github.io/xor-trick/</a></p><p>[2] David Eppstein, Michael T. Goodrich, Frank Uyeda, and George Varghese, &#34;What&#39;s the Difference? Efficient Set Reconciliation without Prior Context,&#34; SIGCOMM (2011), <a href="https://ics.uci.edu/~eppstein/pubs/EppGooUye-SIGCOMM-11.pdf" target="_blank" rel="noopener noreferrer">https://ics.uci.edu/~eppstein/pubs/EppGooUye-SIGCOMM-11.pdf</a></p><p>[3] Michael Molloy, &#34;Cores in Random Hypergraphs and Boolean Formulas,&#34; Random Structures &amp; Algorithms (2003), <a href="https://utoronto.scholaris.ca/server/api/core/bitstreams/371257de-0a44-4702-afeb-542ae9a06986/content" target="_blank" rel="noopener noreferrer">https://utoronto.scholaris.ca/server/api/core/bitstreams/371257de-0a44-4702-afeb-542ae9a06986/content</a></p><p>[4] Yaron Minsky and Ari Trachtenberg, &#34;Set Reconciliation with Nearly Optimal Communication Complexity&#34; (2000), <a href="https://ecommons.cornell.edu/server/api/core/bitstreams/c3fff828-cfb8-416a-a28b-8afa59dd2d73/content" target="_blank" rel="noopener noreferrer">https://ecommons.cornell.edu/server/api/core/bitstreams/c3fff828-cfb8-416a-a28b-8afa59dd2d73/content</a></p><p>[5] Pengyu Gong, Lei Yang, and Liwei Wang, &#34;Space- and Computationally-Efficient Set Reconciliation via Parity Bitmap Sketch,&#34; VLDB (2021), <a href="https://vldb.org/pvldb/vol14/p458-gong.pdf" target="_blank" rel="noopener noreferrer">https://vldb.org/pvldb/vol14/p458-gong.pdf</a></p><h2 id="further-reading"><span>
        <a aria-label="link to this heading" aria-describedby="Further Reading" href="#further-reading">
            <i></i>
        </a>
    </span><span>Further Reading</span></h2><ul><li>Invertible Bloom Lookup Tables, Mitzenmacher (2011), <a href="https://people.cs.georgetown.edu/~clay/classes/fall2017/835/papers/IBLT.pdf" target="_blank" rel="noopener noreferrer">https://people.cs.georgetown.edu/~clay/classes/fall2017/835/papers/IBLT.pdf</a></li></ul><p>This paper extends the original IBF paper to support additional encoded fields (not just a single idSum) and a more robust decoding algorithm that I found to be necessary for production use.</p><ul><li>Simple Multi-Party Set Reconciliation, Mitzenmacher (2013), <a href="https://arxiv.org/abs/1311.2037" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1311.2037</a></li></ul><p>This paper shows how to extend IBF-based reconciliation to efficiently handle three or more parties. The implementation is neat, it encodes the IBFs on finite fields of a dimension equal to the number of parties.</p><ul><li>Simple Set Sketching, Bæk (2022), <a href="https://arxiv.org/abs/2211.03683" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2211.03683</a></li></ul><p>This paper reduces the size of the IBF by eliminating the hashSum field. Instead, it uses a hash function that calculates the cell index as a checksum and has some additional checks in the decoding process to deal with potential &#34;anomalies&#34; that show up in this approach.</p><ul><li>Practical Rateless Set Reconciliation, Yang (2024), <a href="https://dspace.mit.edu/handle/1721.1/156671" target="_blank" rel="noopener noreferrer">https://dspace.mit.edu/handle/1721.1/156671</a></li></ul><p>Standard IBFs require knowing the expected size of the symmetric difference beforehand to size the filter correctly. This recent work introduces &#34;rateless&#34; IBFs that adapt their size dynamically, making them more practical when the difference size is unknown or highly variable.</p></article>
      </section>
    </div></div>
  </body>
</html>
