<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fosskers.ca/en/blog/haskell-software-dev">Original</a>
    <h1>Software Development Languages: Haskell</h1>
    
    <div id="readability-page-1" class="page"><div><p>Welcome to the next installment of a series that discusses certain languages and their viability for long-term software development. If you missed the earlier articles, here they are:</p><ul><li>Part 1: <a href="https://www.youtube.com/en/blog/software-dev-langs">Software Development Languages</a></li><li>Part 2: <a href="https://www.youtube.com/en/blog/rust-software-dev">Rust</a></li></ul><p>This time we&#39;re talking about <a href="https://www.haskell.org/">Haskell</a>.</p><blockquote><p>Hey, don&#39;t you need a PhD to write anything in Haskell?</p></blockquote><p>Not at all! Haskell is an active language used all over the world by normal developers. Code is clean and fast, there are libraries for anything you&#39;d want to do, its concurrency idioms are nearly best-in-class, and maintenance/refactors are <i>much</i> cheaper than some other languages.</p><p>The sections below don&#39;t need to be read in order. Feel free to jump around to what interests you via the Table of Contents.</p><h2 id="orgb9b166">Haskell for Software Development</h2><h3 id="org2cdea5">Programming</h3><h4 id="org745b89">How are new projects created and compiled?</h4><p>Haskell has two main tools for managing projects, <a href="https://github.com/haskell/cabal">Cabal</a> and <a href="https://docs.haskellstack.org/en/stable/README/">Stack</a>. These tools share some internals and accomplish the same tasks of dependency management and project building, although they differ in some aspects of UI/UX.</p><p>By default, Cabal sources dependencies directly from <a href="http://hackage.haskell.org/">Hackage</a>, the official repository for all published Haskell packages. On the other hand, Stack works with fixed package sets defined on <a href="https://www.stackage.org/">Stackage</a>. These sets offer a stability guarantee that all packages in the set satisfy each other&#39;s version bounds, and they all compile and pass tests together. Even with Stack(age), dependency code itself is still pulled from Hackage in the end.</p><p>Which should you choose? It depends on your requirements:</p><ul><li>Do you want total control over your dependencies, with the newest available versions always at your fingertips? Then go with Cabal.</li><li>Do you want access to long-term community-curated package sets, even if that means you might not be getting the absolute newest dependency versions? Then go with Stack.</li><li><b>Addendum:</b> Are you on Arch Linux? Then use Stack installed via the <a href="https://aur.archlinux.org/packages/stack-static">stack-static</a> package. Unfortunately the Arch maintainers made an error in judgement several years ago which can result in <code>cabal</code> usage conflicting with system packages in ways that cause undefined breakage. This is not Cabal&#39;s fault per se, but everyone has long since moved to Stack to avoid the headache.</li></ul><p>Otherwise, toss a coin! Both tools work fine and have active communities. Usage examples for the rest of the guide (few as they are) will use <code>stack</code>, although comparable commands exist for <code>cabal</code>.</p><p>To create a new project:</p><pre>stack new &lt;project-name&gt; simple</pre><p>This generates:</p><pre>.
├── foobar.cabal
├── LICENSE
├── README.md
├── Setup.hs
├── src
│   └── Main.hs
└── stack.yaml</pre><p>Which can be compiled via <code>stack build</code>, tested with <code>stack test</code>, or ran as-is with <code>stack run</code>. Pass <code>--fast</code> to any of these to compile without optimizations.</p><h4 id="org885453">How is the moment-by-moment programming experience?</h4><p><a href="https://github.com/haskell/haskell-language-server">Haskell has an LSP</a>, which is most easily installed via <code>ghcup</code>:</p><pre>ghcup install hls</pre><p>Upon opening a Haskell file in your editor the LSP will detect your project setup and work as you&#39;d expect.</p><p>Alongside an LSP, it&#39;s often handy to have an open typechecking loop in a separate terminal. <a href="https://github.com/ndmitchell/ghcid">ghcid</a> fills this role nicely, listening for file changes and informing you immediately of errors without fully compiling:</p><pre>server/Main.hs:(62,10)-(64,41): warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In a case alternative: Patterns not matched: English
   |
62 |     ps = case l of
   |          ^^^^^^^^^...</pre><p>People say that prototyping is faster with dynamic languages. Others theorize that those feelings are born from years of type-trauma caused by Java and C++, where the contrast brought by Python/Lisp/etc. is so stark as to invoke a religious experience. On the other hand, I find &#34;Type-driven prototyping&#34; with Haskell to be quite efficient. Haskell&#39;s type system is truly on your side. Consider:</p><div><pre><code><span id="1"><a href="#1"></a><span>-- Perhaps we&#39;re not done with this type definition,</span></span>
<span id="2"><a href="#2"></a><span>-- but we at least know that we want a `name` field.</span></span>
<span id="3"><a href="#3"></a><span>data</span> <span>Person</span> <span>=</span> <span>Person</span> {<span> name ::</span> <span>String</span> }</span>
<span id="4"><a href="#4"></a></span>
<span id="5"><a href="#5"></a><span>-- We don&#39;t know what we want our `Family` type to contain,</span></span>
<span id="6"><a href="#6"></a><span>-- so we leave it blank for now.</span></span>
<span id="7"><a href="#7"></a><span>data</span> <span>Family</span></span>
<span id="8"><a href="#8"></a></span>
<span id="9"><a href="#9"></a><span>-- Given a name, try to lookup the corresponding `Person`.</span></span>
<span id="10"><a href="#10"></a><span>person ::</span> <span>String</span> <span>-&gt;</span> <span>IO</span> (<span>Maybe</span> <span>Person</span>)</span>
<span id="11"><a href="#11"></a>person <span>=</span> <span>undefined</span></span>
<span id="12"><a href="#12"></a></span>
<span id="13"><a href="#13"></a><span>-- If we have a person, we can then look up their family.</span></span>
<span id="14"><a href="#14"></a><span>-- Implementation details irrelevant for now.</span></span>
<span id="15"><a href="#15"></a><span>family</span><span> ::</span> <span>Person</span> <span>-&gt;</span> <span>IO</span> <span>Family</span></span>
<span id="16"><a href="#16"></a><span>family</span> <span>=</span> <span>undefined</span></span>
<span id="17"><a href="#17"></a></span>
<span id="18"><a href="#18"></a><span>-- Finally, &#34;purely&#34; form a graph of the `Person`</span></span>
<span id="19"><a href="#19"></a><span>-- relations in a `Family`.</span></span>
<span id="20"><a href="#20"></a><span>relations ::</span> <span>Family</span> <span>-&gt;</span> <span>Graph</span> <span>Person</span></span>
<span id="21"><a href="#21"></a>relations <span>=</span> <span>undefined</span></span></code></pre></div><p>It&#39;s common to continue this way and &#34;implement&#34; a good portion of a program without actually committing to details. This lets us iterate rapidly on changes to types and function signatures. And since Haskell is so compact, our program skeleton can end up being quite tidy.</p><h4 id="orge5e428">What language idioms are available?</h4><p>Firstly, Haskell is strongly-typed and has Garbage Collection managed by a runtime.</p><p>Learning Haskell will expand your mind as it is built upon foundational principles often not found in other languages. The critical three are:</p><ul><li>Immutability</li><li>Laziness</li><li>Function Purity</li></ul><p>When brought together these form a special world to program in. Let&#39;s expand on them to see why. First of all:</p><blockquote><p>Variables do not mutate.</p></blockquote><p>This isn&#39;t the opt-out mutability of Scala, or the opt-in mutability of Rust. In Haskell, variables <i>cannot</i> be mutated. Further, there are no loops, so the usual &#34;loop through an array and mutate some stuff&#34; approach to many problems is simply not possible. Luckily there are (superior) alternatives, and once you&#39;re used to them, you don&#39;t miss loops at all.</p><p>Next we have:</p><blockquote><p>All function calls are lazy.</p></blockquote><p>Function results are not computed until they&#39;re absolutely needed, and this is tracked by the runtime. This has wonderful implications for how data structures and recursion behave. Want to see a list of all the Fibonacci Numbers?</p><div><pre><code><span id="1"><a href="#1"></a><span>fibs ::</span> [<span>Integer</span>]</span>
<span id="2"><a href="#2"></a>fibs <span>=</span> <span>0</span> <span>:</span> <span>1</span> <span>:</span> <span>zipWith</span> (<span>+</span>) fibs (<span>tail</span> fibs)</span></code></pre></div><p>This is a list with a self-referential definition. How long is it? Infinitely, of course! But that doesn&#39;t stop us from passing it around like a normal list. We can get some elements from it easily enough:</p><pre>&gt; take 10 fibs
[0,1,1,2,3,5,8,13,21,34]

&gt; fibs !! 100
354224848179261915075</pre><p>We&#39;re fine so long as we don&#39;t try to <code>sum</code> it or calculate its <code>length</code>...</p><p>And lastly:</p><blockquote><p>All effects are tracked in the type system.</p></blockquote><p>This is another way of saying that &#34;functions are pure&#34;. Check out the following code:</p><div><pre><code><span id="1"><a href="#1"></a><span>-- | This function _cannot_ perform IO.</span></span>
<span id="2"><a href="#2"></a><span>add2 ::</span> <span>Int</span> <span>-&gt;</span> <span>Int</span></span>
<span id="3"><a href="#3"></a>add2 n <span>=</span> n <span>+</span> <span>2</span></span>
<span id="4"><a href="#4"></a></span>
<span id="5"><a href="#5"></a><span>-- | This function can!</span></span>
<span id="6"><a href="#6"></a><span>addThenPrint ::</span> <span>Int</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="7"><a href="#7"></a>addThenPrint n <span>=</span> <span>do</span></span>
<span id="8"><a href="#8"></a>  <span>let</span> m <span>=</span> add2 n</span>
<span id="9"><a href="#9"></a>  <span>print</span> m</span></code></pre></div><p><code>add2</code> has no &#34;side effects&#34;, something we can guarantee without actually looking at the internals of the function. The function signature tells us everything: <code>Int -&gt; Int</code>. Give an <code>Int</code>, get an <code>Int</code>. <code>addThenPrint</code> on the other hand can perform <code>IO</code> actions, and we can see this from its signature. There are of course more &#34;effects&#34; than <code>IO</code>, but it&#39;s the main one for doing real work.</p><p>Why be explicit with effects like this? It actually helps both you and the compiler. You, because it helps you keep your code better organised, reducing the cost of maintenance. The compiler, because it can inline things better.</p><p>Otherwise, Haskell has many of the modern conveniences: powerful structs and enums, pattern matching, powerful generics (i.e. Typeclasses and Type Families), and (typeclass) derivation. Bye-bye boilerplate! You may have heard of things like &#34;Monads&#34; before, but these and other features are nothing but facilities to help you pipe your effectful code together.</p><p>However, Haskell has something that almost no other language boasts: hole fits. I miss these most when I&#39;m working in other languages. Let the compiler tell you what it wants!</p><div><pre><code><span id="1"><a href="#1"></a><span>foo ::</span> <span>String</span> <span>-&gt;</span> _</span>
<span id="2"><a href="#2"></a>foo <span>=</span> <span>length</span> <span>.</span> (<span>&#34;Hello!&#34;</span> <span>&lt;&gt;</span>) <span>.</span> <span>reverse</span></span></code></pre></div><pre>Landing.hs:78:18: error:
    • Found type wildcard ‘_’ standing for ‘Int’
      To use the inferred type, enable PartialTypeSignatures
    • In the type ‘String -&gt; _’
      In the type signature: foo :: String -&gt; _
   |
78 | foo :: String -&gt; _
   |                  ^</pre><p>So it&#39;s an <code>Int</code>! Thanks Haskell. But wait, we can go the other way too. If we know the types we want but can&#39;t remember the functions...</p><div><pre><code><span id="1"><a href="#1"></a><span>foo ::</span> <span>String</span> <span>-&gt;</span> <span>Int</span></span>
<span id="2"><a href="#2"></a>foo <span>=</span> _ <span>.</span> (<span>&#34;Hello!&#34;</span> <span>&lt;&gt;</span>) <span>.</span> <span>reverse</span></span></code></pre></div><pre>Landing.hs:79:7: error:
    • Found hole: _ :: [Char] -&gt; Int
    • In the first argument of ‘(.)’, namely ‘_’
      In the expression: _ . (&#34;Hello!&#34; &lt;&gt;) . reverse
      In an equation for ‘foo’: foo = _ . (&#34;Hello!&#34; &lt;&gt;) . reverse
    • Valid hole fits include
        foo :: String -&gt; Int
        read :: forall a. Read a =&gt; String -&gt; a
        genericLength :: forall i a. Num i =&gt; [a] -&gt; i
        length :: forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
        unsafeCoerce :: forall a b. a -&gt; b
   |
79 | foo = _ . (&#34;Hello!&#34; &lt;&gt;) . reverse
   |       ^</pre><p>And sure enough it suggests <code>length</code>, exactly what I was looking for.</p><h4 id="orga0da66">Is it verbose? Is it alright to look at?</h4><p>Haskell is not a &#34;curly brace&#34; language, and is quite compact. A struct definition:</p><div><pre><code><span id="1"><a href="#1"></a><span>data</span> <span>OrgDateTime</span> <span>=</span> <span>OrgDateTime</span></span>
<span id="2"><a href="#2"></a>  {<span> dateDay       ::</span> <span>Day</span></span>
<span id="3"><a href="#3"></a>  ,<span> dateDayOfWeek ::</span> <span>DayOfWeek</span></span>
<span id="4"><a href="#4"></a>  ,<span> dateTime      ::</span> <span>Maybe</span> <span>OrgTime</span></span>
<span id="5"><a href="#5"></a>  ,<span> dateRepeat    ::</span> <span>Maybe</span> <span>Repeater</span></span>
<span id="6"><a href="#6"></a>  ,<span> dateDelay     ::</span> <span>Maybe</span> <span>Delay</span> }</span>
<span id="7"><a href="#7"></a>  <span>deriving</span> stock (<span>Eq</span>, <span>Show</span>)</span></code></pre></div><p>A date parser:</p><div><pre><code><span id="1"><a href="#1"></a><span>date ::</span> <span>Parser</span> <span>Day</span></span>
<span id="2"><a href="#2"></a>date <span>=</span> fromGregorian <span>&lt;$&gt;</span> decimal <span>&lt;*&gt;</span> slashDec <span>&lt;*&gt;</span> slashDec</span>
<span id="3"><a href="#3"></a>  <span>where</span></span>
<span id="4"><a href="#4"></a>    slashDec <span>=</span> char <span>&#39;-&#39;</span> <span>*&gt;</span> decimal</span></code></pre></div><p>Some HTML templating:</p><div><pre><code><span id="1"><a href="#1"></a><span>-- | Convert a parsed `OrgFile` into a full</span></span>
<span id="2"><a href="#2"></a><span>-- HTML document readable in a browser.</span></span>
<span id="3"><a href="#3"></a><span>html ::</span> <span>OrgStyle</span> <span>-&gt;</span> <span>OrgFile</span> <span>-&gt;</span> <span>Html</span> ()</span>
<span id="4"><a href="#4"></a>html os o<span>@</span>(<span>OrgFile</span> m _) <span>=</span> html_ <span>$</span> <span>do</span></span>
<span id="5"><a href="#5"></a>  head_ <span>$</span> title_ (<span>maybe</span> <span>&#34;&#34;</span> toHtml <span>$</span> M.lookup <span>&#34;TITLE&#34;</span> m)</span>
<span id="6"><a href="#6"></a>  body_ <span>$</span> body os o</span></code></pre></div><p>The Haskell LSP has a baked-in auto-formatter, so code stays neat.</p><h3 id="org63bc23">Testing</h3><h4 id="org9d9636">How does the language protect me from myself?</h4><p>Haskell has one of the strongest type systems. Thanks to explicit effect management and no mutability, it&#39;s very difficult to reach an undefined state with your data. <a href="https://hackage.haskell.org/package/stm-2.5.0.2/docs/Control-Concurrent-STM.html">STM</a> (Software Transactional Memory) can be used to share data reliably across threads.</p><h4 id="org64120f">How are tests written, and where?</h4><p>Unit tests are written in a separate file, and your project config needs to be told that there are tests there. It&#39;s customary to use a framework like <a href="https://hackage.haskell.org/package/tasty">tasty</a> to help write them:</p><div><pre><code><span id="1"><a href="#1"></a><span>import</span> <span>Test.Tasty</span></span>
<span id="2"><a href="#2"></a><span>import</span> <span>Test.Tasty.HUnit</span></span>
<span id="3"><a href="#3"></a></span>
<span id="4"><a href="#4"></a><span>main ::</span> <span>IO</span> ()</span>
<span id="5"><a href="#5"></a>main <span>=</span> <span>do</span></span>
<span id="6"><a href="#6"></a>  simple <span>&lt;-</span> T.readFile <span>&#34;test/simple.org&#34;</span></span>
<span id="7"><a href="#7"></a>  full   <span>&lt;-</span> T.readFile <span>&#34;test/test.org&#34;</span></span>
<span id="8"><a href="#8"></a>  defaultMain <span>$</span> suite simple full</span>
<span id="9"><a href="#9"></a></span>
<span id="10"><a href="#10"></a><span>suite ::</span> <span>T.Text</span> <span>-&gt;</span> <span>T.Text</span> <span>-&gt;</span> <span>TestTree</span></span>
<span id="11"><a href="#11"></a>suite simple full <span>=</span> testGroup <span>&#34;Unit Tests&#34;</span></span>
<span id="12"><a href="#12"></a>  [ testGroup <span>&#34;Basic Markup&#34;</span></span>
<span id="13"><a href="#13"></a>    [ testCase <span>&#34;Header&#34;</span> <span>$</span> parseMaybe (section <span>1</span>) <span>&#34;* A&#34;</span> <span>@?=</span> <span>Just</span> (titled (<span>Plain</span> <span>&#34;A&#34;</span>))</span>
<span id="14"><a href="#14"></a>    , testCase <span>&#34;Header - Subsection&#34;</span> <span>$</span> parseMaybe (section <span>1</span>) <span>&#34;* A\n** B&#34;</span></span>
<span id="15"><a href="#15"></a>      <span>@?=</span> <span>Just</span> ((titled (<span>Plain</span> <span>&#34;A&#34;</span>)) { sectionDoc <span>=</span> <span>OrgDoc</span> [] [titled (<span>Plain</span> <span>&#34;B&#34;</span>)] })</span>
<span id="16"><a href="#16"></a>    ]</span>
<span id="17"><a href="#17"></a>  ]</span></code></pre></div><p><code>stack test</code> then does what you&#39;d expect.</p><p>Unlike Rust, Haskell does not have first-class doctests, but they can be added via the <a href="https://hackage.haskell.org/package/doctest">doctest</a> library. Also unlike Rust, one can&#39;t write tests in the same file as the function they&#39;re testing, so writing tests for unexported functions is a notorious pain.</p><h4 id="orgd9095b">Is it easy to write slow code?</h4><p>Overall Haskell performs quite well, but there are some caveats involving laziness that professional Haskellers need to keep in mind when writing production software. Three that come to mind are:</p><blockquote><p>Always use strict folds.</p></blockquote><p>There are unfortunately some functions in the Standard Library that betray beginners with their laziness behaviour.</p><blockquote><p>Do streaming IO whenever possible.</p></blockquote><p>Use libraries like <a href="https://hackage.haskell.org/package/streaming">streaming</a> when dealing with large files or continuous flows of data. There are edge-cases involving Lazy IO that you don&#39;t want to involve yourself with.</p><blockquote><p>Avoid being overly generic.</p></blockquote><p>Unlike Rust, Haskell does not automatically monomorphise its generic functions. Sometimes there can be unexpected slowdowns in functions that specify their arguments in terms of typeclass parameters instead of concrete types.</p><h4 id="org5b7b70">What is the CI situation?</h4><p>Haskell has <a href="https://github.com/haskell/actions">good first-class Github Actions</a> that allow you to cleanly specify the exact versions of Stack/Cabal/GHC you wish to test with. In fact, I have <a href="https://www.youtube.com/en/blog/github-ci">another article all about it</a>.</p><h3 id="orga859bb">Collaborating</h3><h4 id="orge52753">Where do I find answers to my questions?</h4><p><a href="https://discourse.haskell.org/">The Haskell Discourse</a> is the official place for asking questions.</p><h4 id="orgf46e71">How do I track changes to Haskell itself?</h4><p>The <a href="https://discourse.haskell.org/c/announcements/10">Announcements</a> area of the Discourse is good for tracking a variety of ecosystem updates, not just the compiler. How the overall ecosystem is doing can be tracked by Gabriel Gonzalez&#39;s <a href="https://github.com/Gabriel439/post-rfc/blob/main/sotu.md">Haskell State of the Union</a> or <a href="https://github.com/krispo/awesome-haskell">Awesome Haskell</a>.</p><h4 id="orgda9def">Are there competing paradigms to write Haskell?</h4><p>There do exist a few &#34;microecosystems&#34; within Haskell. When starting a serious project, one must decide up-front:</p><ul><li>Are we using <a href="https://hackage.haskell.org/package/lens">lenses</a> at all? (See also <a href="https://hackage.haskell.org/package/microlens">microlens</a>)</li><li>Are we streaming via the <a href="https://hackage.haskell.org/package/streaming">streaming</a>, <a href="https://hackage.haskell.org/package/pipes">pipes</a>, or <a href="https://hackage.haskell.org/package/conduit">conduit</a> ecosystems?</li><li>Are we managing effects via <a href="https://hackage.haskell.org/package/rio">rio</a>, <a href="https://hackage.haskell.org/package/mtl">mtl</a>, or one of the Extensible Effects libs?</li></ul><p>It&#39;s also possible to use none of these, although they were all built to solve genuine problems that arose from real-world software development.</p><h4 id="org1b59d0">How do I depend on other libraries?</h4><p>Whether you use <code>cabal</code> or not, dependencies are specified in the <code>&lt;project-name&gt;.cabal</code> file. Here&#39;s a sample from this website (which is a Haskell server):</p><div><pre>executable server
  hs-source-dirs: server
  main-is: Main.hs
  ghc-options: -threaded -with-rtsopts=-N -rtsopts

  build-depends:
    , bytestring
    , directory  ^&gt;=1.3
    , filepath   ^&gt;=1.4
    , warp        &gt;=3.2 &amp;&amp; &lt;3.4</pre></div><p>Here we can see me setting some dependency ranges, which helps the build tools determine the best combination of dependency versions to pull. This is important, as for Haskell, only one copy of each dependency may be present in the build environment, and thus all the mutually dependent packages must agree on versions.</p><p>If that sounds like a headache and a potential source of problems, well, it was. <code>stack</code> and Stackage were invented to solve precisely this problem. Namely, they provide sets of package &#34;snapshots&#34; - listings of specific packages and versions that are known to compile and pass tests as a group. Not all available packages are present in these snapshots, but as of this writing, the most recent one has over 2700 packages, so what you want is almost certainly there.</p><p>If a package you need is missing, or you want a different version, you can specify an override within your project&#39;s <code>stack.yaml</code>:</p><div><pre><code><span id="1"><a href="#1"></a><span>resolver</span><span>:</span><span> lts-18.22</span></span>
<span id="2"><a href="#2"></a></span>
<span id="3"><a href="#3"></a><span>extra-deps</span><span>:</span></span>
<span id="4"><a href="#4"></a><span>  # --- Missing from Stackage --- #</span></span>
<span id="5"><a href="#5"></a><span>  </span><span>-</span><span> org-mode-1.1.1</span></span>
<span id="6"><a href="#6"></a><span>  </span><span>-</span><span> org-mode-lucid-1.6.0</span></span>
<span id="7"><a href="#7"></a><span>  </span><span>-</span><span> skylighting-lucid-1.0.1</span></span>
<span id="8"><a href="#8"></a><span>  </span><span>-</span><span> xmlbf-0.6.1</span></span></code></pre></div><p>A <code>stack.yaml</code> is also used to configure a project &#34;workspace&#34; - multiple libraries/executables in the same logical project. Cabal also accepts a <code>cabal.project</code> file for a similar purpose.</p><h3 id="orgb696ba">Releasing</h3><h4 id="org88796e">How are Haskell projects published?</h4><p>Haskell packages are hosted on <a href="https://hackage.haskell.org/">Hackage</a>. After making an account, a new package can be pushed (or updated) via:</p><pre>stack upload</pre><p>The result is a <a href="https://hackage.haskell.org/package/microlens-aeson">page like this</a> listing all available versions and other package metadata. Hackage even provides <a href="https://matrix.hackage.haskell.org/#/package/microlens-aeson">a build matrix</a> to show you how compatible your package is with various versions of the compiler!</p><h4 id="org900bf1">How do I document a project?</h4><p>Haskell is in the best-of-class category when it comes to documentation. Haskell&#39;s type system quickly earns your trust, and once it does, you almost never need to read someone else&#39;s code in order to understand it; you can just read the type signatures shown in the docs and get on with your life. There are languages whose type signatures do not tell you the full truth, which fosters fear and distrust, but Haskell is not like this.</p><p>Haskell provides two main doc tools, <code>Haddock</code> and <code>Hoogle</code>:</p><pre>stack haddock --open &lt;your-project&gt;</pre><p>This will build a local copy of your project&#39;s docs linked to the exact versions of all the dependencies you&#39;re using. The <code>--open</code> then opens them in your browser. This means you&#39;re never accidentally looking at stale (or too new!) versions of third-party APIs.</p><p>Here is an example from a library of mine. On a doc page you can view the source if you like, but the types often tell you all you need:</p><figure><img src="https://www.youtube.com/assets/images/haddock.png"/></figure><p>Now onto Hoogle.</p><pre>stack hoogle --server</pre><p>This runs a Hoogle Server based on your project and its dependencies. I have seen something like Hoogle in no other language; it lets you perform general API searches across libraries based on types, including function types. To the question &#34;is there any function, anywhere, that turns <code>SemVer</code> into <code>Text</code>? &#34; we can do:</p><figure><img src="https://www.youtube.com/assets/images/hoogle.png"/></figure><p>You can even add generic parameters to your searches. Hoogle even has <a href="https://hoogle.haskell.org/">an online
version</a> if you don&#39;t feel like running a local copy.</p><p>Overall the <i>ability to discover functionality</i> is very high in Haskell.</p><h4 id="orga7050a">Can a single old dependency hold the whole ecosystem back?</h4><p>Thanks to Stackage, this is generally not the case. And thanks to the effort of Stackage&#39;s tireless volunteers, package maintainers <a href="https://github.com/commercialhaskell/stackage/issues/6217">get early warning</a> of critical API changes and broken upstream dependency bounds.</p><h4 id="org1d8818">How do I produce an optimized release binary?</h4><p><code>stack build</code>. By default this builds your application with <code>-O2</code>. It also strips your binary for you.</p><p>To further reduce final binary size, it&#39;s a good idea to add the following to your <code>stack.yaml</code>:</p><div><pre><code><span id="1"><a href="#1"></a><span>ghc-options</span><span>:</span></span>
<span id="2"><a href="#2"></a><span>  </span><span>$everything</span><span>:</span><span> -split-sections</span></span></code></pre></div><p>This ensures that all dependencies are compiled with the <code>-split-sections</code> flag, allowing the compiler&#39;s specializer and inliner to do more effective work. This typically reduces final binary size by at least half.</p><h4 id="org9aef07">How do I develop and release Haskell on non-Linux systems?</h4><p><code>stack</code> and <code>cabal</code> commands are the same regardless of platform, although Haskell has had a troubled past with Windows. These days, versions of the compiler and tooling are available for ARM, Apple&#39;s newer M1 processor, you name it.</p><h3 id="orgc5d19c">Maintenance</h3><h4 id="org3dea78">Does Haskell code crash a lot?</h4><p>In general, Haskell programs are extremely stable.</p><p>Haskell has no concept of <code>null</code>, so errors are tracked through the type system using concrete types, like a number of modern languages do. We can mostly pretend there are no Exceptions either, although there do exist certain <code>IO</code> exceptions which are treated specially by the runtime. Otherwise, we can crash a program by:</p><p>... missing a pattern-match branch!</p><div><pre><code><span id="1"><a href="#1"></a><span>data</span> <span>Colour</span> <span>=</span> <span>Red</span> <span>|</span> <span>Green</span> <span>|</span> <span>Blue</span></span>
<span id="2"><a href="#2"></a></span>
<span id="3"><a href="#3"></a><span>-- I&#39;ve only matched two of the three possibilities. This is only</span></span>
<span id="4"><a href="#4"></a><span>-- a warning in Haskell, not a hard error like Rust or Elm!</span></span>
<span id="5"><a href="#5"></a><span>foo ::</span> <span>Colour</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="6"><a href="#6"></a>foo c <span>=</span> <span>case</span> c <span>of</span></span>
<span id="7"><a href="#7"></a>  <span>Red</span>   <span>-&gt;</span> <span>putStrLn</span> <span>&#34;It&#39;s red!&#34;</span></span>
<span id="8"><a href="#8"></a>  <span>Green</span> <span>-&gt;</span> <span>putStrLn</span> <span>&#34;It&#39;s green!&#34;</span></span>
<span id="9"><a href="#9"></a></span>
<span id="10"><a href="#10"></a><span>-- This will crash!</span></span>
<span id="11"><a href="#11"></a><span>main ::</span> <span>IO</span> ()</span>
<span id="12"><a href="#12"></a>main <span>=</span> foo <span>Blue</span></span></code></pre></div><p>... or by calling a function we forgot to implement!</p><div><pre><code><span id="1"><a href="#1"></a><span>-- </span><span>TODO</span><span> Implement later once I figure this out.</span></span>
<span id="2"><a href="#2"></a><span>solveWorldPeace ::</span> <span>Double</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="3"><a href="#3"></a>solveWorldPeace money <span>=</span> <span>undefined</span></span>
<span id="4"><a href="#4"></a></span>
<span id="5"><a href="#5"></a><span>-- This will crash!</span></span>
<span id="6"><a href="#6"></a><span>main ::</span> <span>IO</span> ()</span>
<span id="7"><a href="#7"></a>main <span>=</span> <span>do</span></span>
<span id="8"><a href="#8"></a>  money <span>&lt;-</span> getTheFunding</span>
<span id="9"><a href="#9"></a>  solveWorldPeace money</span></code></pre></div><p>... or by calling certain naughty functions!</p><pre>&gt; head $ take 0 [1..]
Exception: Prelude.head: empty list</pre><p>But:</p><ul><li>The compiler warns you loudly if you forget a match pattern.</li><li>A left-over <code>undefined</code> gets discovered almost immediately through your own tests or CI.</li><li>Working devs are well aware of pitfalls like <code>head</code> and are used to avoiding them.</li></ul><p>So these aren&#39;t a source of daily concern. And of course writing bad FFI code and mucking with exposed C pointers is a great way to crash, but that&#39;s also not a concern for most people.</p><h4 id="orga8d866">How much of a threat is bitrot? Will the ecosystem leave me behind?</h4><p>This is one of the most important aspects of development when considering software intended to last decades. As I described <a href="https://www.youtube.com/en/blog/wide-haskell">in another article</a>, a language&#39;s ecosystem can &#34;leave you behind&#34; if you wait too long to upgrade your toolchain / dependencies.</p><p><a href="https://www.stackage.org/">Stackage</a> has separate LTS major versions for each main compiler version. By setting your LTS...</p><p>... <code>stack</code> pulls down the corresponding compiler and all the deps your project needs. So long as you occasionally bump this LTS, you&#39;re guaranteed to stay current. And even if you don&#39;t, the entire premise of these snapshots is to ensure your project will compile far into the future!</p><p>The compiler itself is fairly backwards compatible. Changes to the bundled Standard Library come now and again, but they&#39;re done in controlled waves as to avoid breakage.</p><p>The relationship between the compiler, its changes, and Stackage <a href="https://www.youtube.com/en/blog/base">can be tracked
here</a>.</p><h4 id="orga0d40e">How does code stay readable?</h4><p>Unfortunately Haskell does not have &#34;methods&#34;, and all Record (struct) field accessors are actually functions whose names you must make unique.</p><div><pre><code><span id="1"><a href="#1"></a><span>data</span> <span>Person</span> <span>=</span> <span>Person</span> {<span> name ::</span> <span>String</span> }</span>
<span id="2"><a href="#2"></a></span>
<span id="3"><a href="#3"></a><span>reverseName ::</span> <span>Person</span> <span>-&gt;</span> <span>String</span></span>
<span id="4"><a href="#4"></a>reverseName p <span>=</span> <span>reverse</span> (name p)</span></code></pre></div><p><code>name</code> here is a top-level function of the type <code>Person -&gt; String</code>.</p><p>The <a href="https://ghc-proposals.readthedocs.io/en/latest/proposals/0282-record-dot-syntax.html">Record Dot Syntax Proposal</a> is aiming to rectify this, however. In the meantime, &#34;qualified imports&#34; are often used to maintain function name uniqueness within the imported namespace:</p><div><pre><code><span id="1"><a href="#1"></a><span>import</span> <span>qualified</span> <span>Data.Text</span> <span>as</span> <span>T</span></span>
<span id="2"><a href="#2"></a></span>
<span id="3"><a href="#3"></a><span>twoLengths ::</span> <span>String</span> <span>-&gt;</span> (<span>Int</span>, <span>Int</span>)</span>
<span id="4"><a href="#4"></a>twoLengths s <span>=</span> (<span>length</span> s, T.length t)</span>
<span id="5"><a href="#5"></a>  <span>where</span></span>
<span id="6"><a href="#6"></a><span>    t ::</span> <span>T.Text</span></span>
<span id="7"><a href="#7"></a>    t <span>=</span> T.pack s</span></code></pre></div><p>We&#39;ve called two different <code>length</code> functions, but it&#39;s clear to us (and the compiler) which is which. Here we can see also a <code>where</code> clause, used to keep details out of the main function body.</p><p>In general though, Haskell&#39;s readability comes from its terseness. The above <code>reverseName</code> function could instead be written:</p><div><pre><code><span id="1"><a href="#1"></a><span>reverseName ::</span> <span>Person</span> <span>-&gt;</span> <span>String</span></span>
<span id="2"><a href="#2"></a>reverseName <span>=</span> <span>reverse</span> <span>.</span> name</span></code></pre></div><p>Using what&#39;s called &#34;point-free syntax&#34;. <code>.</code> is the function composition operator.</p><h4 id="org29cce6">How do I get rid of code I don&#39;t need?</h4><p>Haskell has decent dead-code analysis and a good set of warnings. Here are the warnings I typically turn on, set in my Cabal file:</p><div><pre>ghc-options:
  -Wall -Wpartial-fields -Wincomplete-record-updates
  -Wincomplete-uni-patterns -Widentities -funclutter-valid-hole-fits</pre></div><p>Although it&#39;s strange that <code>-Wall</code> isn&#39;t actually everything! I think I prefer Rust&#39;s approach of &#34;warning about everything unless told not to&#34;.</p><h2 id="org1cd600">Conclusion</h2><p>Haskell is a powerful tool for real software development. It has an active core team, <a href="https://haskell.foundation/">Foundation</a>, community, and companies that use it all over the world. My experience with it has shaped who am I as a programmer, and has had no small part in landing me jobs, be they Haskell positions or not!</p><p>For Haskell, I say: try it. It will force you to program in a way you didn&#39;t know you needed to.</p><ul><li>Part 1: <a href="https://www.youtube.com/en/blog/software-dev-langs">Software Development Languages</a></li><li>Part 2: <a href="https://www.youtube.com/en/blog/rust-software-dev">Rust</a></li></ul><p>If you liked the article, consider <a href="https://www.buymeacoffee.com/fosskers">sending me a coffee</a>!</p></div></div>
  </body>
</html>
