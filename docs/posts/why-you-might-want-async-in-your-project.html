<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notgull.net/why-you-want-async/">Original</a>
    <h1>Why you might want async in your project</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>There is a common sentiment I’ve seen over and over in the Rust community that I think is ignorant at best and harmful at worst.</p>

<p>This blogpost is largely a response to <a href="https://bitbashing.io/async-rust.html">this post</a> by Matt Kline, but I’ve seen this kind of sentiment all over the Rust community. I’ve found that, in almost every case where <code>async</code>/<code>await</code> is mentioned, at least one person says this. It always gets on my nerves a little bit.</p>

<p>The guilty phrase is as follows: “<code>async</code> rust is only useful for a small number of programs, so why do library authors insist on using it in their APIs?”</p>

<p>I can understand where this kind of thinking comes from. Especially for newer Rustaceans, <code>async</code>/<code>await</code> is quite a bit of complexity up front. But, I think actively shying away from <code>async</code> is the wrong way to go.</p>

<p><strong>Disclaimer:</strong> I am one of the maintainers for <a href="https://crates.io/crates/smol"><code>smol</code></a>, a small and fast <code>async</code> runtime for Rust. So, obviously, I am somewhat biased. However, I think that <code>async</code> can be cool, small and fun; it’s just the presence of complicated <code>async</code> code used commonly across the ecosystem that scared people off.</p>

<h2 id="why-async">Why async?</h2>

<p><a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">Greenspun’s tenth rule</a> comes to mind quite often. For those unfamiliar, Greenspun’s tenth rule of programming is that every sufficiently complicated program contains a bug-ridden version of half of Common Lisp. Likewise, there are a worrying number of Rust programs that contain a bug-ridden version of half of an <code>async</code> runtime.</p>

<p>I call this “poor man’s <code>async</code>”. <code>async</code>/<code>await</code> is a natural pattern for doing multiple things at once; usually, non-<code>async</code> code tends to evolve into something closer and closer to <code>async</code> code, like <a href="https://en.wikipedia.org/wiki/Carcinisation">carcinisation</a>. It’s all over the place in the Rust ecosystem, once you start looking for it.</p>

<p>It happens like this: programs are naturally complicated. Even the simple, Unix-esque atomic programs can’t help but do two or three things at once. Okay, now you set it up so, instead of waiting on <a href="https://man7.org/linux/man-pages/man2/read.2.html"><code>read</code></a> or <a href="https://www.man7.org/linux/man-pages/man2/accept.2.html"><code>accept</code></a> or whatnot, you register your file descriptors into <a href="https://www.man7.org/linux/man-pages/man2/poll.2.html"><code>poll</code></a> and wait on that, then switching on the result of <a href="https://www.man7.org/linux/man-pages/man2/poll.2.html"><code>poll</code></a> to figure out what you actually want to do.</p>

<p>Eventually, two or three sockets becomes a hundred, or even an unlimited amount. Guess it’s time to bring in <a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code>epoll</code></a>! Or, if you want to be cross-platform, it’s now time to write a wrapper around that, <a href="https://en.wikipedia.org/wiki/Kqueue"><code>kqueue</code></a> and, if you’re brave, <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports">IOCP</a>.</p>

<p>Great, now you need a way to organize all of this work, because switching on it means you have to add two hundred lines to your program every time you want to handle some other corner case. No problem, let’s set up a queue of tasks. Whoops, turns out that queueing strategy is inefficient. Better make a new one. Let’s hope it’s thread safe!</p>

<p>At the end of this process, you’ve re-invented <a href="https://crates.io/crates/async-io"><code>async-io</code></a> and <a href="https://crates.io/crates/async-executor"><code>async-executor</code></a>, two of the core components of <a href="https://crates.io/crates/smol"><code>smol</code></a>.</p>

<p>This isn’t a knock on anyone in particular; this is a knock on me too! I’ve written quite a few Rust projects where I expect it to only involve blocking primitives, only to find out that, actually, I’m starting to do a lot of things at once, guess I’d better use <code>async</code>. The original <code>async</code> setup at the beginning of the project is somewhat annoying, but it’s a walk in the park compared to going back and rewriting my entire program setup to use <code>async</code>/<code>await</code>.</p>

<p>The point being, many people say that only five percent of Rust projects use <code>async</code>, and the remaining ninety-five percent have to put up with it. I disagree. Many of the remaining ninety-five percent (if that is an accurate number) are currently using <code>async</code>/<code>await</code>; they just haven’t admitted it yet!</p>

<h2 id="why-dont-people-like-async">Why don’t people like async?</h2>

<p>Now here’s where I speculate <em>why</em> this attitude is so pervasive in the Rust community. I personally think it’s a combination of poor advertising on the part of <code>async</code> combined with poor standard library support.</p>

<p>I’d argue that, if you walked up to your average Rustacean on the street and asked what they thought of <code>async</code> programming, they’d argue that it’s just a obtuse, niche way to create web servers.</p>

<p>That’s not true! Even if you ignore the benefits of using <code>async</code> from a network clients, you can still definitely use <code>async</code> for desktop apps. <a href="https://crates.io/crates/async-winit"><code>async-winit</code></a> is my attempt at bringing <code>async</code>/<code>await</code> to desktop apps in a managable way. I just think that too many people see <code>async</code>/<code>await</code> as part of Rust’s whole web shindig, instead of a reasonable way to structure highly concurrent applications.</p>

<p>In addition, the standard library is definitely built around synchronous code first and <code>async</code> code second. This means that a lot of <code>async</code> code that <em>should</em> be in the standard library ends up being pushed into external crates. This is definitely a problem that, thankfully, is being fixed as traits like <a href="https://docs.rs/futures-core/latest/futures_core/stream/trait.Stream.html"><code>Stream</code></a> are now finally making their way into <a href="https://doc.rust-lang.org/std/async_iter/trait.AsyncIterator.html">the standard library</a>.</p>

<p>Even if you’re writing one of the simple programs that doesn’t explicitly need <code>async</code>/<code>await</code>, it’s not too difficult to move between the two worlds. <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">Function colors</a> get brought up a lot in this area of debate. However, personally, I find it much easier to go from <code>async</code> to sync and vice versa than JavaScript does. For instance, to run an <code>async</code> function in synchronous code, you can bring in the zero-dependency <a href="https://crates.io/crates/pollster"><code>pollster</code></a> crate and run this:</p>

<div><div><pre><code><span>use</span> <span>pollster</span><span>::</span><span>FutureExt</span> <span>as</span> <span>_</span><span>;</span>

<span>async</span> <span>{</span> <span>&#34;Hello world!&#34;</span> <span>}</span><span>.block_on</span><span>();</span>
</code></pre></div></div>

<p>Likewise, to run sync code in the <code>async</code> world, it’s usually easy to spawn it onto a <a href="https://crates.io/crates/blocking"><code>blocking</code></a> task and then poll it from <code>async</code> code. There’s some thread-safety subtlety I’m papering over here, but overall it looks something like this:</p>

<div><div><pre><code><span>blocking</span><span>::</span><span>unblock</span><span>(||</span> <span>&#34;Hello world!&#34;</span><span>)</span><span>.await</span><span>;</span>
</code></pre></div></div>

<p>Another benefit of <code>async</code>/<code>await</code> that I don’t know how to bring up organically above: it translates a lot better to web targets. Blocking synchronous code isn’t allowed in WASM in browsers, so by using <code>async</code> code, you can be reasonably sure that your algorithm can be ported to the web very easily.</p>

<p>Generally, <code>async</code>/<code>await</code> makes things more portable and easier to work into different application setups. I think that, if more Rustaceans invested the effort into learning how <code>async</code>/<code>await</code> ticks, we’d see it used in much more programs.</p>

<h2 id="keeping-the-faith">Keeping the Faith</h2>

<p>I’ve been dancing around it for too long, let’s finally dive into <a href="https://bitbashing.io/async-rust.html">this post</a>.</p>

<p>The main complaint that the author has around <code>async</code>/<code>await</code> is that it requires your futures to be <code>Send</code> and <code>&#39;static</code>. This property tends to spread throughout the program.</p>

<div><div><pre><code>async fn foo(&amp;BIG_GLOBAL_STATIC_REF_OR_SIMILAR_HORROR, sendable_chungus.clone())
</code></pre></div></div>

<p>Except, this isn’t a problem with Rust’s <code>async</code>, it’s a problem with <a href="https://crates.io/crates/tokio"><code>tokio</code></a>. <a href="https://crates.io/crates/tokio"><code>tokio</code></a> uses a <code>&#39;static</code>, threaded runtime that has its benefits but requires its futures to be <code>Send</code> and <code>&#39;static</code>. In <a href="https://crates.io/crates/smol"><code>smol</code></a>, on the other hand, it’s perfectly possible to pass around things by reference.</p>

<div><div><pre><code><span>let</span> <span>big</span> <span>=</span> <span>/* ... */</span><span>;</span>
<span>let</span> <span>chungus</span> <span>=</span> <span>/* ... */</span><span>;</span>

<span>// With smol, you can create an executor...</span>
<span>let</span> <span>ex</span> <span>=</span> <span>smol</span><span>::</span><span>Executor</span><span>::</span><span>new</span><span>();</span>

<span>// ...and, as long as its captured variables outlive it, you can pass things around from the stack!</span>
<span>ex</span><span>.spawn</span><span>(</span><span>async</span> <span>{</span>
    <span>async</span> <span>fn</span> <span>foo</span><span>(</span><span>&amp;</span><span>big</span><span>,</span> <span>&amp;</span><span>chungus</span><span>)</span><span>.await</span>
<span>})</span><span>.detach</span><span>();</span>
</code></pre></div></div>

<p>Actually, the main draw here is that this particular executor isn’t multithreaded. But it’s very easy to make it multithreaded.</p>

<div><div><pre><code><span>// Create an executor.</span>
<span>let</span> <span>ex</span> <span>=</span> <span>smol</span><span>::</span><span>Executor</span><span>::</span><span>new</span><span>();</span>

<span>// Create a channel used to stop the threadpool.</span>
<span>let</span> <span>(</span><span>signal</span><span>,</span> <span>shutdown</span><span>)</span> <span>=</span> <span>smol</span><span>::</span><span>channel</span><span>::</span><span>bounded</span><span>::</span><span>&lt;</span><span>()</span><span>&gt;</span><span>(</span><span>1</span><span>);</span>

<span>// Create a threadpool to run this executor on.</span>
<span>std</span><span>::</span><span>thread</span><span>::</span><span>scope</span><span>(|</span><span>s</span><span>|</span> <span>{</span>
    <span>// Spawn 4 worker threads.</span>
    <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>4</span> <span>{</span>
        <span>let</span> <span>shutdown</span> <span>=</span> <span>shutdown</span><span>.clone</span><span>();</span>
        <span>let</span> <span>ex</span> <span>=</span> <span>&amp;</span><span>ex</span><span>;</span>
        <span>s</span><span>.spawn</span><span>(</span><span>move</span> <span>||</span> <span>smol</span><span>::</span><span>block_on</span><span>(</span><span>ex</span><span>.run</span><span>(</span><span>shutdown</span><span>)));</span>
    <span>}</span>

    <span>// Run a future on this executor.</span>
    <span>smol</span><span>::</span><span>block_on</span><span>(</span><span>ex</span><span>.spawn</span><span>(</span><span>async</span> <span>{</span>
        <span>// Variables can be passed along just like before!</span>
        <span>async</span> <span>fn</span> <span>foo</span><span>(</span><span>&amp;</span><span>big</span><span>,</span> <span>&amp;</span><span>chungus</span><span>)</span><span>.await</span>
    <span>}));</span>
<span>});</span>
</code></pre></div></div>

<p>Let’s say you don’t even want to use threads. You’re a fan of <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> and <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> so thread-safety doesn’t really fit your use-case. That’s okay too! <a href="https://docs.rs/async-executor/latest/async_executor/struct.LocalExecutor.html"><code>smol::LocalExecutor</code></a> doesn’t require anything to be <code>Send</code> at all.</p>

<div><div><pre><code><span>let</span> <span>my_thing</span> <span>=</span> <span>RefCell</span><span>::</span><span>new</span><span>(</span><span>4</span><span>);</span>
<span>let</span> <span>ex</span> <span>=</span> <span>smol</span><span>::</span><span>LocalExecutor</span><span>::</span><span>new</span><span>();</span>

<span>// Look, ma! A thread-unsafe task!</span>
<span>ex</span><span>.spawn</span><span>(</span><span>async</span> <span>{</span>
    <span>*</span><span>ex</span><span>.borrow_mut</span><span>()</span> <span>=</span> <span>5</span><span>;</span>
<span>})</span><span>.detach</span><span>();</span>
</code></pre></div></div>

<p>Really, <code>Send</code> and <code>&#39;static</code> are not intrinsic properties of <code>async</code> Rust; it’s just what the biggest runtime decided on. If you’re not a fan of that, consider taking <a href="https://crates.io/crates/smol"><code>smol</code></a> for a spin!</p>

<h2 id="wrap-it-up">Wrap it up</h2>

<p>Really, I think that most Rustacean’s fears of <code>async</code> are unjustified. Yes, there are complicated semantics at play, but really no more complicated than, say, a borrow checker. In exchange, you gain access to much more powerful program semantics (that you’re probably trying to use anyways!)</p>

<p>So, consider using <code>async</code>/<code>await</code> today! Even if you’ve been turned of by it in the past, there may be parts of the ecosystem that fit your use cases better.</p>


  </div></div>
  </body>
</html>
