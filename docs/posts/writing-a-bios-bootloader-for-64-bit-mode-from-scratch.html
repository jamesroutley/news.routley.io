<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thasso.xyz/2024/07/13/setting-up-an-x86-cpu.html">Original</a>
    <h1>Writing a BIOS bootloader for 64-bit mode from scratch</h1>
    
    <div id="readability-page-1" class="page"><article><p>People say there are things that are complex and there are things that are just complicated. Complexity is considered interesting, complicatedness is considered harmful. The process of setting up an x86_64 CPU is mostly complicated.</p><p>I’ll describe one way to go from a boot sector loaded by the BIOS with the CPU in 16-bit real mode to the CPU set up in 64-bit long mode. The setup is pretty bare-bones and there’s tons more to do.</p><p>To follow along, you need the <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer’s Manual</a>, an assembler (I used <a href="https://www.nasm.us/">nasm</a>), and <a href="https://www.qemu.org/">QEMU</a>. If you don’t have an x86_64 CPU, you should still be able to run everything I describe by emulating an x86 CPU in QEMU. I assume you know x86 assembly and the syntax that nasm uses. I like the <a href="https://cs.lmu.edu/~ray/notes/nasmtutorial/">nasm tutorial by Ray Toal</a> for getting started.</p><p>I was surprised by how readable some of the Intel manual is. The initial chapters in volume 1 do a really good job at providing an overview of the system and explaining the terms used throughout the other volumes. But volume 3: System Programming Guide is most relevant to this discussion. There is an overview of all the operating modes in volume 3, section 2.2 Modes of Operation. The path we’re taking is highlighted in red.</p><p><img src="https://thasso.xyz/public/figures/x86-mode-transitions.png" alt="Overview of x86 mode transitions"/></p><p>For everything up to 32-bit mode, take a look at <a href="https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf">“Writing a Simple Operating System – from Scratch”</a>. It’s unfinished but still very good.</p><p>After a reset, the x86 CPU is in “real mode”. That mode has a default operand size of 16 bits. You get a 20-bit address space and thus the ability to address 1MB of memory by using segmentation. Real mode is pretty much a backward compatibility mode for the Intel 8086 chip from 1978.</p><p>After the BIOS the first code that runs is that in the boot sector. The BIOS searches the system for a disk where the first sector ends in the magic number <code>0xaa55</code> (i.e., the byte <code>0x55</code> followed by the byte <code>0xaa</code>). It loads that “boot sector” to memory at address <code>0x7c00</code>.</p><p>So the BIOS gives us 512 bytes to work with. We need to use these bytes in order to bootstrap the rest of the bootloader. <a href="https://github.com/jart/sectorlisp">One can fit a surprising amount of stuff in 512 bytes</a>, but it’s easiest to just load some more data from disk first. Fortunately, routines defined by the BIOS remain available to us as long as we’re in real mode.</p><p>Let’s set up a simple boot sector. It will just print a message to the screen using BIOS routines and then hang. This way, we know that the tooling works.</p><p>This is the assembly we need:</p><div><div><pre><code><span>;; src/boot_sector.s</span>

    <span>section</span> <span>.boot_sector</span>
    <span>global</span> <span>__start</span>

    <span>[</span><span>bits</span> <span>16</span><span>]</span>

<span>__start:</span>
    <span>mov</span> <span>bx</span><span>,</span> <span>hello_msg</span>
    <span>call</span> <span>print_string</span>

<span>end:</span>
    <span>hlt</span>
    <span>jmp</span> <span>end</span>

<span>;; Uses the BIOS to print a null-termianted string. The address of the</span>
<span>;; string is found in the bx register.</span>
<span>print_string:</span>
    <span>pusha</span>
    <span>mov</span> <span>ah</span><span>,</span> <span>0x0e</span> <span>; BIOS &#34;display character&#34; function</span>

<span>print_string_loop:</span>
    <span>cmp</span> <span>byte</span> <span>[</span><span>bx</span><span>],</span> <span>0</span>
    <span>je</span> <span>print_string_return</span>

    <span>mov</span> <span>al</span><span>,</span> <span>[</span><span>bx</span><span>]</span>
    <span>int</span> <span>0x10</span> <span>; BIOS video services</span>

    <span>inc</span> <span>bx</span>
    <span>jmp</span> <span>print_string_loop</span>

<span>print_string_return:</span>
    <span>popa</span>
    <span>ret</span>

<span>hello_msg:</span> <span>db</span> <span>&#34;Hello, world!&#34;</span><span>,</span> <span>0</span>
</code></pre></div></div><p>Plus this <code>Makefile</code>:</p><div><div><pre><code><span># Makefile
</span>
<span>.PHONY</span><span>:</span> <span>all clean boot</span>

<span>NASM</span> <span>:=</span> nasm <span>-f</span> elf64

<span>BUILD_DIR</span> <span>:=</span> build
<span>SRC_DIR</span> <span>:=</span> src

<span>SRC</span> <span>:=</span> <span>$(</span><span>wildcard</span> <span>$(SRC_DIR)</span>/<span>*</span>.s<span>)</span>
<span>OBJS</span> <span>:=</span> <span>$(</span><span>patsubst</span> <span>$(SRC_DIR)</span>/%.s, <span>$(BUILD_DIR)</span>/%.o, <span>$(SRC)</span><span>)</span>
<span>BOOT_IMAGE</span> <span>:=</span> <span>$(BUILD_DIR)</span>/boot_image

<span>all</span><span>:</span> <span>$(BOOT_IMAGE)</span>

<span>boot</span><span>:</span> <span>$(BOOT_IMAGE)</span>
	qemu-system-x86_64 <span>-no-reboot</span> <span>-drive</span> <span>file</span><span>=</span><span>$&lt;</span>,format<span>=</span>raw,index<span>=</span>0,media<span>=</span>disk

<span>$(BOOT_IMAGE)</span><span>:</span> <span>$(BUILD_DIR)/linked.o</span>
	objcopy <span>-O</span> binary <span>$&lt;</span> <span>$@</span>

<span>$(BUILD_DIR)/linked.o</span><span>:</span> <span>$(OBJS)</span>
	ld <span>-T</span> linker.ld <span>-o</span> <span>$@</span> <span>$^</span>

<span>$(BUILD_DIR)/%.o</span><span>:</span> <span>$(SRC_DIR)/%.s</span>
	<span>@</span><span>mkdir</span> <span>-p</span> <span>$(</span><span>dir</span> <span>$@</span><span>)</span>
	<span>$(NASM)</span> <span>$&lt;</span> <span>-o</span> <span>$@</span>

<span>clean</span><span>:</span>
	<span>$(RM)</span> <span>-r</span> <span>$(BUILD_DIR)</span>
</code></pre></div></div><p>The linker script <code>linker.ld</code> is important because it makes sure that the code in our boot sector is relocated to the right address in the final image. Specifically, the bootloader loads the boot sector to address <code>0x7c00</code> in memory. So that’s the base address to relocate the boot sector to. In addition, the linker will add the magic number at the end of the boot sector. Other guides I’ve seen do both the offset and the magic number inside the boot sector assembly source file by using features of the assembler, but that’s somewhat hackish.</p><pre><code># linker.ld

MEMORY
{
    boot_sector (rwx) : ORIGIN = 0x7c00, LENGTH = 512
}

ENTRY(__start)
SECTIONS
{
    .boot_sector : { *(.boot_sector); } &gt; boot_sector
    .bootsign (0x7c00 + 510) :
    {
        BYTE(0x55)
        BYTE(0xaa)
    } &gt; boot_sector
}
</code></pre><p>Running <code>make boot</code> should result in a QEMU window and the “Hello, World!” message should be displayed.</p><p><img src="https://thasso.xyz/public/figures/qemu-hello-world-screenshot.png" alt="QEMU screenshot of the hello world message"/></p><p>We can split the bootloader into two stages. Stage 1 is the code in the boot sector. It is everything that the BIOS loads for us. The sole purpose of stage 1 is to load stage 2 into memory. Stage 1 does this by using BIOS-provided routines to load stage 2 into memory.</p><p>In stage 2, we’ll switch from 16-bit real mode to 32-bit protected mode. In protected mode, we can’t use BIOS routines anymore. Without BIOS routines, loading sectors from a disk would become much more involved. So we’ll load a number of sectors from disk into memory and hope for the best. Of course, this is an unsafe technique, but it works for now.</p><p>This is how one can access the disk using BIOS. There’s an <a href="https://wiki.osdev.org/Disk_access_using_the_BIOS_(INT_13h)">osdev.org page</a> on this.</p><div><div><pre><code><span>;; src/boot_sector.s</span>

<span>;; ...</span>

<span>__start:</span>
    <span>;; ...</span>

    <span>mov</span> <span>si</span><span>,</span> <span>di</span><span>sk_address_packet</span>
    <span>mov</span> <span>ah</span><span>,</span> <span>0x42</span> <span>; BIOS &#34;extended read&#34; function</span>
    <span>mov</span> <span>dl</span><span>,</span> <span>0x80</span> <span>; Drive number</span>
    <span>int</span> <span>0x13</span> <span>; BIOS disk services</span>
    <span>jc</span> <span>error_reading_disk</span>

<span>ignore_disk_read_error:</span>
    <span>SND_STAGE_ADDR</span><span> equ</span> <span>(</span><span>BOOT_LOAD_ADDR</span> <span>+</span> <span>SECTOR_SIZE</span><span>)</span>
    <span>jmp</span> <span>0</span><span>:</span><span>SND_STAGE_ADDR</span>

<span>error_reading_disk:</span>
    <span>;; We accept reading fewer sectors than requested</span>
    <span>cmp</span> <span>word</span> <span>[</span><span>dap_sectors_num</span><span>],</span> <span>READ_SECTORS_NUM</span>
    <span>jle</span> <span>ignore_disk_read_error</span>

    <span>mov</span> <span>bx</span><span>,</span> <span>error_reading_disk_msg</span>
    <span>call</span> <span>print_string</span>

    <span>end:</span>
    <span>;; ...</span>
</code></pre></div></div><p>And at the end of <code>boot_sector.s</code> put this data:</p><div><div><pre><code><span>;; src/boot_sector.s</span>

<span>;; ...</span>

    <span>align</span> <span>4</span>
<span>disk_address_packet:</span>
    <span>db</span> <span>0x10</span> <span>; Size of packet</span>
    <span>db</span> <span>0</span> <span>; Reserved, always 0</span>
<span>dap_sectors_num:</span>
    <span>dw</span> <span>READ_SECTORS_NUM</span> <span>; Number of sectors read</span>
    <span>dd</span> <span>(</span><span>BOOT_LOAD_ADDR</span> <span>+</span> <span>SECTOR_SIZE</span><span>)</span> <span>; Destination address</span>
    <span>dq</span> <span>1</span> <span>; Sector to start at (0 is the boot sector)</span>

<span>READ_SECTORS_NUM</span><span> equ</span> <span>64</span>
<span>BOOT_LOAD_ADDR</span><span> equ</span> <span>0x7c00</span>
<span>SECTOR_SIZE</span><span> equ</span> <span>512</span>

<span>hello_msg:</span> <span>db</span> <span>&#34;Hello, world!&#34;</span><span>,</span> <span>13</span><span>,</span> <span>10</span><span>,</span> <span>0</span>
<span>error_reading_disk_msg:</span> <span>db</span> <span>&#34;Error: failed to read disk with 0x13/ah=0x42&#34;</span><span>,</span> <span>13</span><span>,</span> <span>10</span><span>,</span> <span>0</span>
</code></pre></div></div><p>Lastly we need a stage 2 to jump to and we need to update the linker script. The <code>Makefile</code> remains unchanged.</p><div><div><pre><code><span>;; src/stage2.s</span>

    <span>section</span> <span>.stage2</span>

    <span>[</span><span>bits</span> <span>16</span><span>]</span>

    <span>mov</span> <span>bx</span><span>,</span> <span>stage2_msg</span>
    <span>call</span> <span>print_string</span>

<span>end:</span>
    <span>hlt</span>
    <span>jmp</span> <span>end</span>

    <span>print_string:</span>
        <span>;; ...</span>

<span>stage2_msg:</span> <span>db</span> <span>&#34;Hello from stage 2&#34;</span><span>,</span> <span>13</span><span>,</span> <span>10</span><span>,</span> <span>0</span>
</code></pre></div></div><p>I just copied the <code>print_string</code> function so we can test if the jump works. Because this specific function only works with BIOS in real mode, it won’t be of any use to stage 2 once we have switched to protected mode.</p><p>Finally the linker script:</p><pre><code># linker.ld

MEMORY
{
    boot_sector (rwx) : ORIGIN = 0x7c00, LENGTH = 512
    stage2 (rwx) : ORIGIN = 0x7e00, LENGTH = 32768 # 512 * 64
}

ENTRY(__start)
SECTIONS
{
    .boot_sector : { *(.boot_sector); } &gt; boot_sector
    .bootsign (0x7c00 + 510) :
    {
        BYTE(0x55)
        BYTE(0xaa)
    } &gt; boot_sector
    .stage2 : { *(.stage2); } &gt; stage2
}
</code></pre><p><img src="https://thasso.xyz/public/figures/qemu-hello-stage2-screenshot.png" alt="QEMU screenshot of the stage 2 message"/></p><p>Next, we’ll switch the CPU from real mode (16-bit) to protected mode (32-bit). In protected mode, segmentation is used by default to implement memory protection. Before switching to protected mode, you need to define a Global Descriptor Table (GDT) that contains segment descriptors for all the segments you want to define. Usually, paging is used in favor of segmentation. In fact, in 64-bit long mode, you need to use paging. But for the initial switch to protected mode, segmentation is required.</p><p>The Intel manual describes the “flat model” as a very simple segmentation model that can be implemented in the GDT. The “flat model” comprises a code segment and a data segment. Both of these segments are mapped to the entire linear address space (their base addresses and limits are identical). Using the simplest of all models is fine, since we just want to get to long mode and abandon segmentation in favor of paging.</p><p>The GDT is defined as a contiguous structure in memory. You fill a chunk of memory with the right data and give the CPU the address and the length of the memory chunk. The format of the GDT structure is described in the Intel manual.</p><p>From section “3.4.5 Segment Descriptors”:</p><p><img src="https://thasso.xyz/public/figures/segment-descriptor-layout.png" alt="Screenshot of segment descriptor layout"/></p><p>The GDT is just an array of segment descriptors with a “null descriptor” at the start that’s used to catch invalid translations. The fields in the segment descriptor are described in detail in section “3.4.5 Segment Descriptors” of volume 3 of the Intel manual.</p><p>We define the GDT like this:</p><div><div><pre><code><span>;; include/gdt32.s</span>

    <span>;; Base address of GDT should be aligned on an eight-byte boundary</span>
    <span>align</span> <span>8</span>

<span>gdt32_start:</span>
    <span>;; 8-byte null descriptor (index 0).</span>
    <span>;; Used to catch translations with a null selector.</span>
    <span>dd</span> <span>0x0</span>
    <span>dd</span> <span>0x0</span>

<span>gdt32_code_segment:</span>
    <span>;; 8-byte code segment descriptor (index 1).</span>
    <span>;; First 16 bits of segment limit</span>
    <span>dw</span> <span>0xffff</span>
    <span>;; First 24 bits of segment base address</span>
    <span>dw</span> <span>0x0000</span>
    <span>db</span> <span>0x00</span>
    <span>;; 0-3: segment type that specifies an execute/read code segment</span>
    <span>;;   4: descriptor type flag indicating that this is a code/data segment</span>
    <span>;; 5-6: Descriptor privilege level 0 (most privileged)</span>
    <span>;;   7: Segment present flag set indicating that the segment is present</span>
    <span>db</span> <span>10011010b</span>
    <span>;; 0-3: last 4 bits of segment limit</span>
    <span>;;   4: unused (available for use by system software)</span>
    <span>;;   5: 64-bit code segment flag indicates that the segment doesn&#39;t contain 64-bit code</span>
    <span>;;   6: default operation size of 32 bits</span>
    <span>;;   7: granularity of 4 kilobyte units</span>
    <span>db</span> <span>11001111b</span>
    <span>;; Last 8 bits of segment base address</span>
    <span>db</span> <span>0x00</span>

<span>gdt32_data_segment:</span>
    <span>;; Only differences are explained ...</span>
    <span>dw</span> <span>0xffff</span>
    <span>dw</span> <span>0x0000</span>
    <span>db</span> <span>0x00</span>
    <span>;; 0-3: segment type that specifies a read/write data segment</span>
    <span>db</span> <span>10010010b</span>
    <span>db</span> <span>11001111b</span>
    <span>dw</span> <span>0x00</span>

<span>gdt32_end:</span>

<span>;; Value for GDTR register that describes the above GDT</span>
<span>gdt32_pseudo_descriptor:</span>
    <span>;; A limit value of 0 results in one valid byte. So, the limit value of our</span>
    <span>;; GDT is its length in bytes minus 1.</span>
    <span>dw</span> <span>gdt32_end</span> <span>-</span> <span>gdt32_start</span> <span>-</span> <span>1</span>
    <span>;; Start address of the GDT</span>
    <span>dd</span> <span>gdt32_start</span>

<span>CODE_SEG32</span><span> equ</span> <span>gdt32_code_segment</span> <span>-</span> <span>gdt32_start</span>
<span>DATA_SEG32</span><span> equ</span> <span>gdt32_data_segment</span> <span>-</span> <span>gdt32_start</span>
</code></pre></div></div><p>Switching to protected mode is very easy now. We load the GDT pseudo-descriptor into the GDTR register so that the base address and length of our GDT are known to the system. Lastly, we do a far jump to flush the instruction pipeline.</p><div><div><pre><code><span>;; src/stage2.s</span>

    <span>section</span> <span>.stage2</span>

    <span>[</span><span>bits</span> <span>16</span><span>]</span>

<span>;; ...</span>

    <span>;; Load GDT and switch to protected mode</span>

    <span>cli</span> <span>; Can&#39;t have interrupts during the switch</span>
    <span>lgdt</span> <span>[</span><span>gdt32_pseudo_descriptor</span><span>]</span>

    <span>;; Setting cr0.PE (bit 0) enables protected mode</span>
    <span>mov</span> <span>eax</span><span>,</span> <span>cr0</span>
    <span>or</span> <span>eax</span><span>,</span> <span>1</span>
    <span>mov</span> <span>cr0</span><span>,</span> <span>eax</span>

    <span>;; The far jump into the code segment from the new GDT flushes</span>
    <span>;; the CPU pipeline removing any 16-bit decoded instructions</span>
    <span>;; and updates the cs register with the new code segment.</span>
    <span>jmp</span> <span>CODE_SEG32</span><span>:</span><span>start_prot_mode</span>


    <span>[</span><span>bits</span> <span>32</span><span>]</span>
<span>start_prot_mode:</span>
    <span>;; Old segments are now meaningless</span>
    <span>mov</span> <span>ax</span><span>,</span> <span>DATA_SEG32</span>
    <span>mov</span> <span>ds</span><span>,</span> <span>ax</span>
    <span>mov</span> <span>ss</span><span>,</span> <span>ax</span>
    <span>mov</span> <span>es</span><span>,</span> <span>ax</span>
    <span>mov</span> <span>fs</span><span>,</span> <span>ax</span>
    <span>mov</span> <span>gs</span><span>,</span> <span>ax</span>

<span>;; ...</span>
<span>
%include &#34;include/gdt32.s&#34;
</span></code></pre></div></div><p>Interrupts are disabled during the switch. After the entire setup is complete, interrupts can be enabled again. This would require extra setup work.</p><p>Now that we’re in protected mode, we can’t use the BIOS routines anymore. To print text, we can write straight to the VGA buffer instead.</p><div><div><pre><code><span>;; src/stage2.s</span>

<span>;; ...</span>

<span>;; Writes a null-terminated string straight to the VGA buffer.</span>
<span>;; The address of the string is found in the bx register.</span>
<span>print_string32:</span>
    <span>pusha</span>

    <span>VGA_BUF</span><span> equ</span> <span>0xb8000</span>
    <span>WB_COLOR</span><span> equ</span> <span>0xf</span>

    <span>mov</span> <span>edx</span><span>,</span> <span>VGA_BUF</span>

<span>print_string32_loop:</span>
    <span>cmp</span> <span>byte</span> <span>[</span><span>ebx</span><span>],</span> <span>0</span>
    <span>je</span> <span>print_string32_return</span>

    <span>mov</span> <span>al</span><span>,</span> <span>[</span><span>ebx</span><span>]</span>
    <span>mov</span> <span>ah</span><span>,</span> <span>WB_COLOR</span>
    <span>mov</span> <span>[</span><span>edx</span><span>],</span> <span>ax</span>

    <span>add</span> <span>ebx</span><span>,</span> <span>1</span>              <span>; Next character</span>
    <span>add</span> <span>edx</span><span>,</span> <span>2</span>              <span>; Next VGA buffer cell</span>
    <span>jmp</span> <span>print_string32_loop</span>

<span>print_string32_return:</span>
    <span>popa</span>
    <span>ret</span>
</code></pre></div></div><p>Best print something so that we know the switch worked. To do that, add a string with the message and a call to <code>print_string32</code> to the code. The <code>print_string32</code> function is super basic, so the message always shows up in the top left corner of the display.</p><p><img src="https://thasso.xyz/public/figures/qemu-prot-mode-screenshot.png" alt="QEMU screenshot of the protected mode message"/></p><p>For this part, refer to “10.8.5 Initializing IA-32e Mode”. Note that Intel calls the 64-bit mode “IA-32e” while AMD refers to it as “long mode” in the AMD64 manual.</p><p>Before switching to long mode, the CPU must be in protected mode and paging must be enabled. We have protected mode now, but we are missing paging.</p><p>I love paging. It’s just very cool. But I’d do a poor job at explaining the concept itself. Philipp Oppermann’s <a href="https://os.phil-opp.com/paging-introduction/">Introduction to Paging</a> from the “Writing an OS in Rust” blog was really useful for me personally. <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP</a> also talks about paging starting chapter 18, although it doesn’t go into the specifics of paging on x86 like Philipp Oppermann’s post does.</p><p>In long mode with Physical Address Extension enabled (PAE, we’ll do that below ), a four level page table is used. The below code generates such a page table at a given address.</p><div><div><pre><code><span>;; src/stage2.s</span>

<span>;; Builds a 4 level page table starting at the address that&#39;s passed in ebx.</span>
<span>build_page_table:</span>
    <span>pusha</span>

    <span>PAGE64_PAGE_SIZE</span><span> equ</span> <span>0x1000</span>
    <span>PAGE64_TAB_SIZE</span><span> equ</span> <span>0x1000</span>
    <span>PAGE64_TAB_ENT_NUM</span><span> equ</span> <span>512</span>

    <span>;; Initialize all four tables to 0. If the present flag is cleared, all other bits in any</span>
    <span>;; entry are ignored. So by filling all entries with zeros, they are all &#34;not present&#34;.</span>
    <span>;; Each repetition zeros four bytes at once. That&#39;s why a number of repetitions equal to</span>
    <span>;; the size of a single page table is enough to zero all four tables.</span>
    <span>mov</span> <span>ecx</span><span>,</span> <span>PAGE64_TAB_SIZE</span> <span>; ecx stores the number of repetitions</span>
    <span>mov</span> <span>edi</span><span>,</span> <span>ebx</span>             <span>; edi stores the base address</span>
    <span>xor</span> <span>eax</span><span>,</span> <span>eax</span>             <span>; eax stores the value</span>
    <span>rep</span> <span>stosd</span>

    <span>;; Link first entry in PML4 table to the PDP table</span>
    <span>mov</span> <span>edi</span><span>,</span> <span>ebx</span>
    <span>lea</span> <span>eax</span><span>,</span> <span>[</span><span>edi</span> <span>+</span> <span>(</span><span>PAGE64_TAB_SIZE</span> <span>|</span> <span>11b</span><span>)]</span> <span>; Set read/write and present flags</span>
    <span>mov</span> <span>dword</span> <span>[</span><span>edi</span><span>],</span> <span>eax</span>

    <span>;; Link first entry in PDP table to the PD table</span>
    <span>add</span> <span>edi</span><span>,</span> <span>PAGE64_TAB_SIZE</span>
    <span>add</span> <span>eax</span><span>,</span> <span>PAGE64_TAB_SIZE</span>
    <span>mov</span> <span>dword</span> <span>[</span><span>edi</span><span>],</span> <span>eax</span>

    <span>;; Link the first entry in the PD table to the page table</span>
    <span>add</span> <span>edi</span><span>,</span> <span>PAGE64_TAB_SIZE</span>
    <span>add</span> <span>eax</span><span>,</span> <span>PAGE64_TAB_SIZE</span>
    <span>mov</span> <span>dword</span> <span>[</span><span>edi</span><span>],</span> <span>eax</span>

    <span>;; Initialize only a single page on the lowest (page table) layer in</span>
    <span>;; the four level page table.</span>
    <span>add</span> <span>edi</span><span>,</span> <span>PAGE64_TAB_SIZE</span>
    <span>mov</span> <span>ebx</span><span>,</span> <span>11b</span>
    <span>mov</span> <span>ecx</span><span>,</span> <span>PAGE64_TAB_ENT_NUM</span>
<span>set_page_table_entry:</span>
    <span>mov</span> <span>dword</span> <span>[</span><span>edi</span><span>],</span> <span>ebx</span>
    <span>add</span> <span>ebx</span><span>,</span> <span>PAGE64_PAGE_SIZE</span>
    <span>add</span> <span>edi</span><span>,</span> <span>8</span>
    <span>loop</span> <span>set_page_table_entry</span>

    <span>popa</span>
    <span>ret</span>
</code></pre></div></div><p>Paging supersedes segmentation for managing virtual address spaces, permissions, etc. A Global Descriptor Table with segment descriptors is still needed though, and the segment descriptors must be modified slightly to enable long mode-specific features.</p><p>This is another GDT that also implements the flat model. It’s almost identical to the GDT for protected mode. Just two bits were changed.</p><div><div><pre><code><span>;; include/gdt64.s</span>

    <span>align</span> <span>16</span>
<span>gdt64_start:</span>
    <span>;; 8-byte null descriptor (index 0).</span>
    <span>dd</span> <span>0x0</span>
    <span>dd</span> <span>0x0</span>

<span>gdt64_code_segment:</span>
    <span>dw</span> <span>0xffff</span>
    <span>dw</span> <span>0x0000</span>
    <span>db</span> <span>0x00</span>
    <span>db</span> <span>10011010b</span>
    <span>;;   5: 64-bit code segment flag indicates that this segment contains 64-bit code</span>
    <span>;;   6: must be zero if L bit (bit 5) is set</span>
    <span>db</span> <span>10101111b</span>
    <span>db</span> <span>0x00</span>

<span>gdt64_data_segment:</span>
    <span>dw</span> <span>0xffff</span>
    <span>dw</span> <span>0x0000</span>
    <span>db</span> <span>0x00</span>
    <span>;; 0-3: segment type that specifies a read/write data segment</span>
    <span>db</span> <span>10010010b</span>
    <span>db</span> <span>10101111b</span>
    <span>dw</span> <span>0x00</span>

<span>gdt64_end:</span>

<span>gdt64_pseudo_descriptor:</span>
    <span>dw</span> <span>gdt64_end</span> <span>-</span> <span>gdt64_start</span> <span>-</span> <span>1</span>
    <span>dd</span> <span>gdt64_start</span>

<span>CODE_SEG64</span><span> equ</span> <span>gdt64_code_segment</span> <span>-</span> <span>gdt64_start</span>
<span>DATA_SEG64</span><span> equ</span> <span>gdt64_data_segment</span> <span>-</span> <span>gdt64_start</span>
</code></pre></div></div><p>With the page table and the GDT in place, the switch from protected mode to long mode can be performed.</p><div><div><pre><code><span>;; src/stage2.s</span>

<span>;; ...</span>

<span>start_prot_mode:</span>
    <span>;; ...</span>

    <span>;; Build 4 level page table and switch to long mode</span>
    <span>mov</span> <span>ebx</span><span>,</span> <span>0x1000</span>
    <span>call</span> <span>build_page_table</span>
    <span>mov</span> <span>cr3</span><span>,</span> <span>ebx</span>            <span>; MMU finds the PML4 table in cr3</span>

    <span>;; Enable Physical Address Extension (PAE). This is needed to allow the switch</span>
    <span>mov</span> <span>eax</span><span>,</span> <span>cr4</span>
    <span>or</span> <span>eax</span><span>,</span> <span>1</span> <span>&lt;&lt;</span> <span>5</span>
    <span>mov</span> <span>cr4</span><span>,</span> <span>eax</span>

    <span>;; The EFER (Extended Feature Enable Register) MSR (Model-Specific Register) contains fields</span>
    <span>;; related to IA-32e mode operation. Bit 8 if this MSR is the LME (long mode enable) flag</span>
    <span>;; that enables IA-32e operation.</span>
    <span>mov</span> <span>ecx</span><span>,</span> <span>0xc0000080</span>
    <span>rdmsr</span>
    <span>or</span> <span>eax</span><span>,</span> <span>1</span> <span>&lt;&lt;</span> <span>8</span>
    <span>wrmsr</span>

    <span>;; Enable paging (PG flag in cr0, bit 31)</span>
    <span>mov</span> <span>eax</span><span>,</span> <span>cr0</span>
    <span>or</span> <span>eax</span><span>,</span> <span>1</span> <span>&lt;&lt;</span> <span>31</span>
    <span>mov</span> <span>cr0</span><span>,</span> <span>eax</span>

    <span>mov</span> <span>ebx</span><span>,</span> <span>comp_mode_msg</span>
    <span>call</span> <span>print_string32</span>

    <span>;; New GDT has the 64-bit segment flag set. This makes the CPU switch from</span>
    <span>;; IA-32e compatibility mode to 64-bit mode.</span>
    <span>lgdt</span> <span>[</span><span>gdt64_pseudo_descriptor</span><span>]</span>

    <span>jmp</span> <span>CODE_SEG64</span><span>:</span><span>start_long_mode</span>

    <span>;; ...</span>

    <span>[</span><span>bits</span> <span>64</span><span>]</span>

<span>start_long_mode:</span>
    <span>htl</span>
    <span>jmp</span> <span>start_long_mode</span>

    <span>;; ...</span>
<span>
%include &#34;include/gdt64.s&#34;
</span>
    <span>;; ...</span>

<span>comp_mode_msg:</span> <span>db</span> <span>&#34;</span><span>Entered</span> <span>64</span><span>-</span><span>bit</span> <span>compatibility</span> <span>mode</span><span>&#34;</span><span>,</span> <span>0</span>
</code></pre></div></div><p>Again, the “success message” should show up in the top left corner. Write a small VGA driver if this annoys you.</p><p><img src="https://thasso.xyz/public/figures/qemu-comp-mode-screenshot.png" alt="QEMU screenshot of the success message"/></p><p>C code can easily be intergrated into this setup. E.g, this might become an OS kernel.</p><div><div><pre><code><span>/* src/kernel.c */</span>

<span>#define VGA_COLUMNS_NUM 80
#define VGA_ROWS_NUM 25
</span>
<span>#define ARRAY_SIZE(arr) ((int)sizeof(arr) / (int)sizeof((arr)[0]))
</span>
<span>void</span> <span>_start_kernel</span><span>(</span><span>void</span><span>)</span> <span>{</span>
	<span>volatile</span> <span>char</span> <span>*</span><span>vga_buf</span> <span>=</span> <span>(</span><span>char</span> <span>*</span><span>)</span><span>0xb8000</span><span>;</span>
	<span>const</span> <span>char</span> <span>msg</span><span>[]</span> <span>=</span> <span>&#34;Hello from C&#34;</span><span>;</span>
	<span>int</span> <span>i</span><span>;</span>

	<span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>VGA_COLUMNS_NUM</span> <span>*</span> <span>VGA_ROWS_NUM</span> <span>*</span> <span>2</span><span>;</span> <span>i</span><span>++</span><span>)</span>
		<span>vga_buf</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>

	<span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>ARRAY_SIZE</span><span>(</span><span>msg</span><span>)</span> <span>-</span> <span>1</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
		<span>vga_buf</span><span>[</span><span>i</span> <span>*</span> <span>2</span><span>]</span> <span>=</span> <span>msg</span><span>[</span><span>i</span><span>];</span>
		<span>vga_buf</span><span>[</span><span>i</span> <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>]</span> <span>=</span> <span>0x07</span><span>;</span> <span>/* White on black */</span>
	<span>}</span>
<span>}</span>
</code></pre></div></div><p>Update <code>src/stage2.s</code>:</p><div><div><pre><code><span>;; src/stage2.s</span>

    <span>;; ...</span>

    <span>[</span><span>bits</span> <span>64</span><span>]</span>

<span>start_long_mode:</span>
    <span>mov</span> <span>ebx</span><span>,</span> <span>long_mode_msg</span>
    <span>call</span> <span>print_string64</span>

    <span>extern</span> <span>_start_kernel</span>
    <span>call</span> <span>_start_kernel</span>

<span>end64:</span>
    <span>hlt</span>
    <span>jmp</span> <span>end64</span>

    <span>;; ...</span>
</code></pre></div></div><p>The linker script:</p><pre><code># linker.ld

MEMORY
{
    boot_sector (rwx) : ORIGIN = 0x7c00, LENGTH = 512
    stage2 (rwx) : ORIGIN = 0x7e00, LENGTH = 512
    kernel (rwx) : ORIGIN = 0x8000, LENGTH = 0x10000
}

ENTRY(__start)
SECTIONS
{
    .boot_sector : { *(.boot_sector); } &gt; boot_sector
    .bootsign (0x7c00 + 510) :
    {
        BYTE(0x55)
        BYTE(0xaa)
    } &gt; boot_sector
    .stage2 : { *(.stage2); } &gt; stage2
    .text : { *(.text); } &gt; kernel
    .data : { *(.data); } &gt; kernel
    .rodata : { *(.rodata); } &gt; kernel
    .bss :
    {
        *(.bss)
        *(COMMON)
    } &gt; kernel
}
</code></pre><p>Lastly, the <code>Makefile</code> needs to change. Here, I only included the lines that have changed.</p><pre><code># Makefile

# ...

CC := gcc
CFLAGS := -std=c99 -ffreestanding -m64 -mno-red-zone -fno-builtin -nostdinc -Wall -Wextra

# ...

SRC := $(wildcard $(SRC_DIR)/*)
OBJS := $(patsubst $(SRC_DIR)/%, $(BUILD_DIR)/%.o, $(SRC))

# ...

$(BUILD_DIR)/%.s.o: $(SRC_DIR)/%.s
	@mkdir -p $(dir $@)
	$(NASM) $&lt; -o $@

$(BUILD_DIR)/%.c.o: $(SRC_DIR)/%.c
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $&lt; -o $@

# ...
</code></pre><p><img src="https://thasso.xyz/public/figures/qemu-c-screenshot.png" alt="QEMU screenshot of the message printed by C code"/></p><p>Cool if you actually came along this far. The <a href="https://github.com/thass0/blog-code/tree/main/2024-07-13-setting-up-an-x86-cpu">code is on GitHub</a>.</p></article></div>
  </body>
</html>
