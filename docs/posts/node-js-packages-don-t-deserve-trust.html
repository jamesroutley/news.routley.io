<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://josephg.com/blog/node-sandbox/">Original</a>
    <h1>Node.js packages don&#39;t deserve trust</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<h2>A modest proposal</h2>
<p>Another week, another <a href="https://github.com/Yaffle/EventSource/blob/de137927e13d8afac153d2485152ccec48948a7a/src/eventsource.js#L1047-L1090">npm supply chain attack</a>. Yikes! People on hacker news are <a href="https://news.ycombinator.com/item?id=30963600">wringing their hands</a> about what should be done. The problem seems dire.</p>
<p>Apparently I couldn&#39;t help myself. At 2am the other night I woke up, staring at the ceiling. I couldn&#39;t stop thinking about this problem. It seems .. frankly, solvable. But how?</p>
<p>I think I came up with an answer. Or, the sketch of an answer. Is it any good? Will it work? I think it might... You be the judge.</p>
<h3>The problem</h3>
<p>The fundamental problem with npm is that any package you install has full access to do whatever it wants on your computer. For example, packages can:</p>
<ul>
<li>Read every file on your computer, including your email, passwords, everything.</li>
<li>Edit your files. Delete them. Cryptolocker them</li>
<li>Do anything it wants on the internet</li>
<li>Run child processes, change your OS settings, install key loggers</li>
</ul>
<p>You think you&#39;re installing <code>leftpad</code>. But you&#39;re actually letting a stranger into your house while you aren&#39;t at home. They can do basically whatever they want.</p>
<p>And its not just your home. We give package authors full access to our servers and our webpages. These systems store something much more precious: Our users&#39; personal data.</p>
<p>Most people are trustworthy. But occasionally people <a href="https://snyk.io/blog/peacenotwar-malicious-npm-node-ipc-package-vulnerability/">decide that if you&#39;re in Russia or Belarus, wiping your hard drive is fair play</a>. And if you let literally thousands of unknown people into your house unattended, its no surprise when someone does something you don&#39;t like. Frankly, I&#39;m surprised supply chain attacks don&#39;t happen more often.</p>
<p>We can&#39;t solve this by figuring out all the baddies and banning them. I learned this as a kid in the 90s playing a video game called <em>Theme Park</em>. Once you played it enough, some park visitors would start vandalizing the park. I remember reading a strategy guide which said &#34;You can&#39;t just hire a security guard and put them at the front gate. Security guards can only kick out visitors <em>after</em> they&#39;ve broken the rules.&#34;</p>
<p>We have the same problem. We can&#39;t preemptively figure out which developers don&#39;t deserve our trust.</p>
<p>Deno <a href="https://deno.land/manual/getting_started/permissions">tries to solve this problem</a>, but I don&#39;t think its good enough. Deno lets you specify at the command line what kinds of actions your program is allowed to perform. You need to explicitly give permission to your deno process to have access to the internet or your database files.</p>
<p>This is a start; but I don&#39;t think its good enough. Just because I&#39;m making a web server, that doesn&#39;t mean <code>leftpad</code> should be allowed to access the internet. If I&#39;m making a file server, the <code>leftpad</code> library shouldn&#39;t have access to my filesystem. Deno&#39;s permission model is a good start, but it just isn&#39;t fine grained enough. (That said, I&#39;d certainly take it over nodejs&#39;s current approach.)</p>
<h2>Capabilities to the rescue</h2>
<p>I think we can solve this problem entirely. But it might require some changes to how nodejs works.</p>
<p>I&#39;m taking inspiration here from an OpenBSD API called <a href="https://man.openbsd.org/pledge.2">pledge</a>. The way pledge works is that, when the program starts but before your program has done anything, you make a set of pledges. &#34;I promise this program will not access any files outside of <code>/some/path</code>, or make any network connections to peers except for <code>example.com</code>. If the program is later compromised, none of the compromised code can do anything nasty.</p>
<p>But I think we can take this a bit further. Here&#39;s my idea:</p>
<ol>
<li>We add a new builtin nodejs library called <a href="https://en.wikipedia.org/wiki/Capability-based_security"><code>capabilities</code></a>, which can hand out capability tokens. Capability tokens can only be created by the capabilities library.</li>
<li>To make any privileged action (access the filesystem, the network, hardware, spawn child processes, load native npm modules, etc!), the caller needs to pass in an appropriate capability token. Most functions in <code>fs</code>, <code>net</code>, <code>child_process</code> and others will need a capability field added. Most of these methods already take an options object, so it shouldn&#39;t be too hard to add a capability token there.</li>
<li>Every capability token has a <em>scope</em>. The scope specifies what the bearer of that token is allowed to do. For example, a capability might give you read/write access to the <code>/var/data</code> directory. The capability library lets you narrow a capability, but capabilities can never be widened. So if a library has a capability for arbitrary network access, it can create a <em>narrowed token</em> which only has network access to your database server. That capability can be then passed to the database client library.</li>
<li>When your program launches, your main package (and only your main package!) gets access to a wildcard &#34;do anything&#34; capability. You can narrow &amp; pass this capability token to other packages, depending on what you want them to do.</li>
</ol>
<p>So, something like this:</p>

<p>Express doesn&#39;t need to do anything fancy with the capability token. It just passes it to the <code>http</code> library behind the scenes. Whats new is that lots of things are <em>not</em> in the token. Because the token we passed <em>only</em> allows network access, express is banned from reading your filesystem, opening new network connections, running shell scripts, or really anything dangerous that we haven&#39;t explicitly allowed.</p>
<p>There&#39;s lots of things to nut out here, but I&#39;ve put a simple sketch of what the capability module might look like at the bottom of this post.</p>
<p>Unfortunately, its not that simple. There are a few other thorny details to figure out too!</p>
<h2>What about existing code?</h2>
<p>We make the entire capability system opt in at the command line level. If you don&#39;t pass <code>--strict-capabilities</code>, then nodejs works like it does now, where any script can do anything.</p>
<p>Production web servers should enable this flag, but existing code should keep working.</p>
<h2>How would your root package get the root capability token?</h2>
<p>The first idea is something simple like this:</p>

<p>But the danger of this approach is that attackers can run code before we get the root token. And if they can do that, they can probably get the root access token themselves and do nasty stuff.</p>

<p>Unfortunately, ES modules require all <code>import</code> statements to be at the top of your file, before any code executes. You could work around this restriction by importing a local file first, which immediately claims the root token. But thats super awkward. I don&#39;t want a hello world web server to need (at a minimum) 2 source code files.</p>
<p>There might be a way to fix that with some weird ES6 getters, or by some deep V8 wizardry or something:</p>

<p>Or maybe nodejs just passes it in via <code>module.capability</code> / <code>import.meta.capability</code> or something. For example:</p>

<p>One way or another, this seems technically solvable.</p>
<h2>What about packages which never get updated?</h2>
<p>We probably don&#39;t need to solve this for version 1.</p>
<p>But if we did, we might be able to add a method in the capability module to &#34;bless&#34; a package. Eg:</p>

<p>Then any direct system call from that library acts as if it had the capability we pass in. (And nothing else).</p>
<p>Its a bit hacky though. I mean, how can you tell if a method call comes from a specific package? Thats tricky, but it should be possible. The simplest answer is we could look at the call stack to see if the immediately preceeding item is in a blessed package. You can already inspect the call stack via <code>new Error().stack</code>, but thats slow, and probably corruptible from javascript code. I bet we could do something cleaner from native code.</p>
<p>There might also be scope for mischief via callbacks with this approach. Or someone could edit a package&#39;s methods.</p>
<h2>How can we prevent javascript&#39;s dynamism from making this security system swiss cheese?</h2>
<p>This is a real problem.</p>
<p>As an aside, I&#39;m worried if we wait for a perfectly secure solution before launching a capabilities system, then we&#39;ll never solve this problem at all. If &#34;mostly secure&#34; is as good as we can get, it still might be better than the current situation. (Though smart people may well disagree with me.)</p>
<p>Javascript is weird, and I&#39;m worried there might be ways to escape this little sandbox. For example:</p>
<ul>
<li>If an attacker knows <code>express</code> is blessed, could they do something like this?</li>
</ul>

<p>But this wouldn&#39;t work because the new function isn&#39;t part of the express package (even if its called via <code>app.listen()</code>. There may be a way around that. Maybe via an <code>eval()</code> call?</p>
<ul>
<li>Use <code>Object.defineProperty</code> to overwrite some built in methods. Then use that to target code which has a reference to the root token:</li>
</ul>

<p>This code fails, but I don&#39;t know how strong the protections are:</p>

<p>I might not be smart enough to figure out a way to pierce this security envelope, but maybe you are? This is a new security level. We need some smart security minds to have a play and see if they can bolt this thing down.</p>
<p>Directly editing the prototype of built in javascript classes like <code>String</code> and <code>Array</code> is considered bad form these days. I&#39;d be happy to ban some of that dynamism entirely if the result is better security. If we have to ban <code>eval</code> in strict capabilities mode, frankly I&#39;d be delighted.</p>
<p>If some packages in npm misbehave with capability based sandboxing enabled, thats fine. We can either fix them or boot them from our production systems. There is no shortage of excellent packages in npm. (If you can find them.)</p>
<h2>Package install scripts</h2>
<p>Npm packages are also allowed to run arbitrary shell scripts on your computer when you install them, via <a href="https://docs.npmjs.com/cli/v7/using-npm/scripts#npm-install">lifecycle events in <code>package.json</code></a>. I understand it - but I really wish this feature didn&#39;t exist, because there&#39;s almost no valid uses for it outside compiling your module. And modules should be compiled <em>before</em> they&#39;re published, not after.</p>
<p>There are vanishingly few legitimate uses for <code>npm install</code> scripts - almost no popular npm modules use them. But there&#39;s a mountain of malicious ways to abuse them.</p>
<p>Now, <code>npm install</code> already <em>sort of</em> has an answer to this problem - which is its <a href="https://docs.npmjs.com/cli/v8/commands/npm-install#ignore-scripts"><code>--ignore-scripts</code> option</a>. But I bet almost nobody knows about that option, or uses it.</p>
<p>This might be the most controversial (and difficult to change) recommendation here - I think npm should ignore <code>npm install</code> scripts by default. Or maybe, by default prompt the user instead of just doing this stuff blindly:</p>


<p>Anyway, thats the core idea. We add capability tokens to nodejs. Packages need a capability token in order to do any privileged actions - like spawn child processes, load native modules, run scripts, access the filesystem or the internet.</p>
<p>We have some problems to work out:</p>
<ul>
<li>How should a security token&#39;s scope be expressed?</li>
<li>How can we securely pass the root &#39;wildcard&#39; token to the main module?</li>
<li>Are there any nasty javascript tricks which would let someone easily dodge this whole system? Are there any ways we might need to lock javascript down some more in strict capability mode?</li>
</ul>
<p>But the javascript ecosystem has plenty of smart people. I think this is a challenge worth taking on. The security of our computers, and our users&#39; data depends on it.</p>
<p>(And as an added bonus, it would make it impossible to sneak dirty telemetry and things like that into npm modules.)</p>
<p>Nodejs has a massive, dynamic ecosystem of 3rd party packages. We should be able to depend on arbitrary libraries without giving them the keys to the kingdom. We just need to do some work to make it happen.</p>
<p>And when I say &#34;we&#34;, I mean &#34;you&#34;. I&#39;m too busy building CRDTs to join this fight. We only get this future if people like you step forward to build it. Are you up for the challenge?</p>

<p>Here is a rough sketch of what nodejs&#39;s capabilities library might look like:</p>


    </div></div>
  </body>
</html>
