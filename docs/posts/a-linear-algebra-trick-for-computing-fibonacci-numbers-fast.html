<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codeconfessions.substack.com/p/a-linear-algebra-trick-for-fibonacci-numbers">Original</a>
    <h1>A Linear Algebra Trick for Computing Fibonacci Numbers Fast</h1>
    
    <div id="readability-page-1" class="page"><div class=""><div><div dir="auto"><p><span>I’ve been attending an online reading group on the book “</span><a href="https://bookstore.ams.org/stml-53" rel="">Thirty-three Miniatures: Mathematical and Algorithmic Applications of Linear Algebra</a><span>” lead by </span><a href="https://www.neeldhara.com/" rel="">Prof. Neeldhara Misra</a><span> from IIT Gandhinagar. It is the most unconventional math book I’ve come across. The first two chapters are all about ways to quickly compute Fibonacci numbers. The conventional (memoization based, or iterative) method of computing Fibonacci numbers that we learn in our programming courses is linear in time. But, the book shows a technique for computing them in approximately logarithmic time complexity. It’s possible that some of you might be aware of this technique but this was news to me and I thought it’s worth sharing with the rest of you.</span></p><p>The conventional memoized recursive algorithm for computing Fibonacci numbers is this:</p><pre><code>table = {}
def fib(n):
    if n in table:
        return table[n]
    
    if n == 0 or n == 1:
        result = n
    else:
        result = fib(n - 1) + fib(n - 2)
    
    table[n] = result
    return result
</code></pre><p><span>This is a linear time algorithm because to compute the nth Fibonacci number, we need to compute all the previous </span><code>n - 1</code><span> numbers in the sequence. This leads us to the typical question asked — can we do better?</span></p><p><span>Let’s try to find out. One issue with the above algorithm is that computing an arbitrary value in the sequence requires us to compute all the previous values. Therefore, we need to arrive at a solution which is more general in nature and can compute the </span><code>nth</code><span> value directly.</span></p><p><span>One intuition we have is that we know the values of the base cases (0 and 1), so if we can express the computation of the </span><code>nth</code><span> Fibonacci number in terms of the base cases, we might achieve our goal. Let’s try to build on this intuition.</span></p><p>The base cases of the sequence are:</p><pre><code>F(0) = 0
F(1) = 1</code></pre><p>Computing F(2) using these two is trivial:</p><pre><code>F(2) = F(1) + F(0)</code></pre><p>Similarly, we can also express F(1) in terms of F(1) and F(0):</p><pre><code>F(1) = 1 * F(1) + 0 * F(0)</code></pre><p>We can conveniently express the computation of F(2) and F(1) in a single linear algebra operation, like so:</p><div data-component-name="Latex"><p><span>\(\begin{align}
\begin{bmatrix}
F(2) \\
F(1)
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 1 \\
1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
F(1) \\
F(0)
\end{bmatrix}

\\
\\
Or, 
\begin{bmatrix}
F(2) \\
F(1)
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 1 \\
1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
1 \\
0
\end{bmatrix}

\end{align}\)</span></p></div><p><span>Let’s try to do the same thing for </span><code>F(3)</code><span>:</span></p><pre><code>F(3) = F(2) + F(1)
F(2) = F(1) + F(0)</code></pre><p>And representing it in terms of matrix operation, we get this:</p><div data-component-name="Latex"><p><span>\(\begin{bmatrix}
F(3) \\
F(2)
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 1 \\
1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
F(2) \\
F(1)
\end{bmatrix}
\)</span></p></div><p><span>However, we know the value of the vector </span><code>[F(2), F(1)]</code><span> from the previous step, substituting that value gives us the following:</span></p><div data-component-name="Latex"><p><span>\(\begin{bmatrix}
F(3) \\
F(2)
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 1 \\
1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
1 &amp; 1 \\
1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
1 \\
0
\end{bmatrix}
\)</span></p></div><p>Let’s make it simpler:</p><div data-component-name="Latex"><p><span>\(Let&#39;s\ represent\ the\ matrix\
\begin{bmatrix}
1 &amp; 1 \\
1 &amp; 0
\end{bmatrix} as M
\)</span></p></div><p>Which gives us:</p><div data-component-name="Latex"><p><span>\(\begin{bmatrix}
F(3) \\
F(2)
\end{bmatrix}
=
M^2
\begin{bmatrix}
1 \\
0
\end{bmatrix}
\)</span></p></div><p><span>Looks like we are building a pattern for computing the numbers in terms of the matrix </span><code>M</code><span> and the base cases </span><code>F(1)</code><span>, and </span><code>F(0)</code><span>. Let’s see if this pattern holds for </span><code>F(4)</code><span>.</span></p><pre><code>F(4) = F(3) + F(2)
F(3) = F(2) + F(1)</code></pre><p>Again, representing these in the form of matrix operations:</p><div data-component-name="Latex"><p><span>\(\begin{align}
\begin{bmatrix}
F(4) \\
F(3)
\end{bmatrix}
&amp;=
\begin{bmatrix}
1 &amp; 1 \\
1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
F(3) \\
F(2)
\end{bmatrix} \\
\\
Or, 
\begin{bmatrix}
F(4) \\
F(3)
\end{bmatrix}
&amp;=
M
\begin{bmatrix}
F(3) \\
F(2)
\end{bmatrix}
\end{align}
\)</span></p></div><p><span>Substituting the value of the vector </span><code>[F(3), F(2)]</code><span> from the previous computation, we get the following result:</span></p><div data-component-name="Latex"><p><span>\(\begin{bmatrix}
F(4) \\
F(3)
\end{bmatrix}
=
M
.
M^2
\begin{bmatrix}
1 \\
0
\end{bmatrix}
\)</span></p></div><p>Which becomes:</p><div data-component-name="Latex"><p><span>\(\begin{bmatrix}
F(4) \\
F(3)
\end{bmatrix}
=
M^3
\begin{bmatrix}
1 \\
0
\end{bmatrix}
\)</span></p></div><p>In general we can find that this pattern repeats and generalizes to this form:</p><div data-component-name="Latex"><p><span>\(\begin{bmatrix}
F(n+1) \\
F(n)
\end{bmatrix}
=
M^n
\begin{bmatrix}
1 \\
0
\end{bmatrix}
\)</span></p></div><p><span>You can also prove to yourself that this holds true using </span><a href="https://en.wikipedia.org/wiki/Mathematical_induction" rel="">mathematical induction</a><span>. </span></p><p><span>Looks like we have an algorithm for computing the </span><code>nth</code><span> Fibonacci number without needing to compute all the previous </span><code>n-1</code><span> values in the sequence. However, it requires computing </span><code>nth</code><span> power of the matrix </span><code>M</code><span>. The naive algorithm for computing powers is also linear in </span><code>n</code><span>, which means this algorithm for computing Fibonacci numbers is also linear and we are back to the same spot. But it turns out there are faster ways for computing power, let’s take a look at them.</span></p><p data-attrs="{&#34;url&#34;:&#34;https://codeconfessions.substack.com/p/a-linear-algebra-trick-for-fibonacci-numbers?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;,&#34;action&#34;:null,&#34;class&#34;:null}" data-component-name="ButtonCreateButton"><a href="https://codeconfessions.substack.com/p/a-linear-algebra-trick-for-fibonacci-numbers?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share" rel=""><span>Share</span></a></p><p><span>The naive algorithm for evaluating the </span><code>nth</code><span> power requires </span><code>n</code><span> multiplications and is therefore linear in time. But there are faster algorithms for doing this. For instance, if </span><code>n</code><span> is a power of 2 then we can compute </span><code>M^n</code><span> by repeated squaring of </span><code>M</code><span>, and do it in </span><code>log2(n)</code><span> time. </span></p><p><span>In </span><em><a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html" rel="">volume 2</a></em><a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html" rel=""> of </a><em><a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html" rel="">The Art of Computer Programming</a></em><span>, Knuth shows a more generic algorithm for computing </span><code>x^n</code><span>. This algorithm relies on the fact that any number can be broken down into sums of powers of 2. For instance, 5 can be written as </span><code>2^2 + 2^0</code><span>, and 9 can be written as </span><code>2^3 + 2^0</code><span>. Therefore, we can write </span><code>x^n</code><span> as following:</span></p><div data-component-name="Latex"><p><span>\(x^n = x^{k_1} * x^{k_2} * x^{k_3}...x^{k_m}
\)</span></p></div><p><span>Where </span><code>k1, k2, …, km</code><span> are powers of 2 which all add up to </span><code>n</code><span>.</span></p><p><span>Even though the idea is simple, the actual algorithm for doing this is slightly more convoluted because there is no direct way to break down a number like this. Instead, we need to repeatedly divide the number by 2 and look at the remainder of the result. The 3rd edition of </span><em>The Art of Computer Programming, Volume 2 (page 462)</em><span> lists the following algorithm for computing </span><code>x^n</code><span>:</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png" width="864" height="475" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/b57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:475,&#34;width&#34;:864,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:102173,&#34;alt&#34;:&#34;Algorithm: For computing x^n. Taken from page 462 of The Art of Computer Programming, Volume 2, Third Edition.&#34;,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="Algorithm: For computing x^n. Taken from page 462 of The Art of Computer Programming, Volume 2, Third Edition." title="Algorithm: For computing x^n. Taken from page 462 of The Art of Computer Programming, Volume 2, Third Edition." srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb57d2158-e9b2-4b93-bfe3-eb9052f1f48d_864x475.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption>Algorithm: For computing x^n. Based on the algorithm shown on page 462 of The Art of Computer Programming, Volume 2, Third Edition.</figcaption></figure></div><p><span>If you are someone who prefers looking at code instead of abstract pseudo code, the </span><a href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.matrix_power.html" rel="">linalg.matrix_power</a><span> method in numpy implements this exact same algorithm (shown in the below image).</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png" width="1456" height="740" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/d3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:740,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:298991,&#34;alt&#34;:&#34;Numpy implementation of linalg.matrix_power function&#34;,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="Numpy implementation of linalg.matrix_power function" title="Numpy implementation of linalg.matrix_power function" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd3a018d6-6612-4a4f-afd7-7614ea64ba76_1900x966.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption>Numpy implementation of linalg.matrix_power function</figcaption></figure></div><p><span>What is the complexity of this algorithm? The loop runs no more than log2(n) number of steps because we are halving n at every step. And, during each step of the loop we are multiplying </span><code>Z</code><span> by itself,  resulting in </span><code>log2(n)</code><span> multiplications. Also, whenever we get the remainder as 1, we are also multiplying </span><code>Z</code><span> with </span><code>Y</code><span>, increasing the number of multiplications. Formally, the total number of multiplications performed by this algorithm is:</span></p><div data-component-name="Latex"><p><span>\(\lfloor \log_2(n) \rfloor + v(n)
\)</span></p></div><p><span>Where </span><code>v(n)</code><span> is the number of bits with value 1 in the binary representation of </span><code>n</code><span>.</span></p><p><span>This is also the complexity of our Fibonacci number algorithm because the only operation it is doing which depends on </span><code>n</code><span> is computing </span><code>M^n</code><span>. </span></p><p>It appears we have a more efficient algorithm on our hands. We should actually run and compare the performances of the algorithms before concluding victory. Before we do that, there is another alternative way of computing Fibonacci numbers, let’s look at that.</p><p>There is a closed form formula for directly computing the nth Fibonacci number, which uses the golden ratio:</p><div data-component-name="Latex"><p><span>\(F(n) = \frac{1}{\sqrt{5}} \left(\left(\frac{1 + \sqrt{5}}{2}\right)^n - \left(\frac{1 - \sqrt{5}}{2}\right)^n\right)
\)</span></p></div><p><span>This is probably a much more well known formula, and also derived in </span><em>The Art of Computer Programming, Volume 1 (page 99)</em><span>. The </span><em>thirty three miniatures</em><span> book shows an alternate proof of this form using linear algebra. I would not want to reproduce those proofs here in the interest of space and time, however, feel free to check out those books. I just wanted to show this technique so that we have a more complete benchmark to run. Let’s look at it in the next section.</span></p><p>So we have three different algorithms for computing Fibonacci numbers, it’s time we put them to test and compared their performances. The following plot shows the performance of the three techniques.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png" width="1000" height="600" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/b7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:600,&#34;width&#34;:1000,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:54762,&#34;alt&#34;:&#34;Execution time of the three algorithms for computing Fibonacci numbers for increasing values of n&#34;,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="Execution time of the three algorithms for computing Fibonacci numbers for increasing values of n" title="Execution time of the three algorithms for computing Fibonacci numbers for increasing values of n" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb7c4d9c2-9e87-46b7-956e-a994278ecad2_1000x600.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption>Execution time of the three algorithms for computing Fibonacci numbers for increasing values of n</figcaption></figure></div><p>Here:</p><ul><li><p><code>fib(n)</code><span> refers to the conventional linear time algorithm.</span></p></li><li><p><code>fib_fast(n)</code><span> refers to the faster algorithm we studied in 2nd section, which computes </span><code>M^n</code><span>. </span></p></li><li><p><code>fib_closed_form(n)</code><span> shows the performance of the closed form formula based on the golden ratio.</span></p></li></ul><p>This is a great example of the performance difference of linear vs logarithmic time algorithms. Compared to the performance of the linear time algorithm, the other algorithms look like flat lines.</p><p><span>Another interesting thing to note here is the performance of </span><code>fib_fast</code><span> and </span><code>fib_closed_form</code><span> algorithms. Both of these algorithms essentially compute the </span><code>nth</code><span> power of an expression and therefore their complexities in terms of </span><code>n</code><span> are same. However, the golden ratio based algorithm is computing the </span><code>nth</code><span> power of a scalar value which can be done much faster than computing the </span><code>nth</code><span> power of a </span><code>2X2</code><span> matrix, thus the difference in their </span><em>actual</em><span> run-time performance.</span></p><p><span>At the same time, it is also worth noting that the closed form formula is working with irrational numbers which can only be represented approximately in computers, and thus in some rare cases the method </span><em>may</em><span> produce incorrect result due to approximation errors. The matrix method has no such issues and will always give the right answer. Of course, when implementing any of these algorithms you need to handle the possibility of large numbers, which may cause overflow on fixed-width data types.</span></p><p><span>This brings us to the end of this whirlwind tour of Fibonacci number algorithms. When I first came across the linear algebraic formula for computing Fibonacci numbers, I found it magical. The author of the </span><em>thirty three miniatures</em><span> book, Matoušek, mentions that the original source of that technique is not known, so we may never know how was it discovered. I believe that when playing around with such sequences, you discover certain patterns which may lead you down the path of such discoveries, and there might not be an exact science behind how it was arrived at. I tried to show one way of how it could be arrived at but there might be better ways to do it. If any of you have better intuition behind it, please share with me in the comments.</span></p><p><span>I would like to credit Prof. Neeldhara Misra for leading the session on this topic and for providing intuition behind the math involved. If you are interested on discussions around CS and Math, you may want to follow her on </span><a href="https://twitter.com/neeldhara" rel="">X/Twitter</a><span>.</span></p><p><span>I would also like to thank </span></p><p><span> for reviewing and giving feedback on this article. He writes a wonderful Substack on topics related to computer science at</span></p><p><span>, you may want to check it out and subscribe!</span></p><ul><li><p><a href="https://www.youtube.com/watch?v=_CNLV8ngMQghttps://www.youtube.com/watch?v=_CNLV8ngMQghttps://www.youtube.com/watch?v=_CNLV8ngMQg" rel="">Recorded video of the session on chapter 1 of the thirty three miniatures book</a><span> </span></p></li><li><p><a href="https://github.com/abhinav-upadhyay/fast_fibonacci" rel="">Link to the Github repo with code</a></p></li></ul><p data-attrs="{&#34;url&#34;:&#34;https://codeconfessions.substack.com/p/a-linear-algebra-trick-for-fibonacci-numbers?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;,&#34;action&#34;:null,&#34;class&#34;:null}" data-component-name="ButtonCreateButton"><a href="https://codeconfessions.substack.com/p/a-linear-algebra-trick-for-fibonacci-numbers?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share" rel=""><span>Share</span></a></p></div></div></div></div>
  </body>
</html>
