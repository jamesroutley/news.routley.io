<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pedtsr.ca/2024/solving-domino-fit-using-constraint-programming.html">Original</a>
    <h1>Solving domino fit using constraint programming</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>
by Philippe Olivier</p>

<p>
Domino Fit is a domino tiling game, where you have to place dominoes on a board in such a way that the sum of the dots must match row and column numbers. There are two dominoes: a one-dot vertical domino and a two-dot horizontal domino. Dominoes may not be rotated. There are also a few black squares on which dominoes may not be placed. The board in its initial and solved states looks like this:<br/>
</p>



<p>
Domino Fit was discussed on Hacker News <a href="https://news.ycombinator.com/item?id=39420966">here</a>, and can be played <a href="https://dominofit.isotropic.us">here</a>. Let&#39;s write a constraint programming model to automatically solve the game.<br/>
</p>

<p>
The data given to us is the board size, the location of the black squares, and the row and column numbers. We use <code>(w, h)</code> with <code>w</code> the width and <code>h</code> the height to refer to a particular square. The top-left square is at position <code>(0, 0)</code>; the width increases when going right and the height increases when going down (I knowâ€¦).<br/>
</p>

<div>
<pre><span># </span><span>The (0, 0) position is at the top-left of the board</span>
<span>width</span> = 7
<span>height</span> = 7

<span># </span><span>Black squares (w, h)</span>
<span>blacks</span> = [(0, 6),
          (1, 0),
          (3, 5),
          (4, 1),
          (6, 0)]

<span># </span><span>Top numbers</span>
<span>top_numbers</span> = [3, 2, 4, 10, 4, 3, 9]

<span># </span><span>Side numbers</span>
<span>side_numbers</span> = [5, 5, 6, 5, 4, 4, 6]
</pre>
</div>

<p>
We import CP-SAT and create an empty model:<br/>
</p>

<div>
<pre><span>from</span> ortools.sat.python <span>import</span> cp_model

<span>model</span> = cp_model.CpModel()
</pre>
</div>

<p>
We can describe the state of a board (i.e., which types of dominoes are placed where) using two matrices of binary variables representing the positions of the one- and two-dot dominoes. For example, if cell <code>(4, 2)</code> of the <code>ones</code> matrix is set to 1, this means that the &#34;dot half&#34; of a one-dot vertical domino is placed at position <code>(4, 2)</code>. That cell of the <code>ones</code> matrix would be set to 0 in the alternate case.<br/>
</p>

<div>
<pre><span># </span><span>`ones[w][h]` indicates if the dot number of a one-dot vertical domino is at position (w, h)</span>
<span>ones</span> = [[model.NewBoolVar(f<span>&#34;ones_</span>{w}<span>_</span>{h}<span>&#34;</span>)
         <span>for</span> h <span>in</span> <span>range</span>(height)]
        <span>for</span> w <span>in</span> <span>range</span>(width)]

<span># </span><span>`twos[w][h]` indicates if the dot number of a two-dot vertical domino is at position (w, h)</span>
<span>twos</span> = [[model.NewBoolVar(f<span>&#34;twos_</span>{w}<span>_</span>{h}<span>&#34;</span>)
         <span>for</span> h <span>in</span> <span>range</span>(height)]
        <span>for</span> w <span>in</span> <span>range</span>(width)]
</pre>
</div>

<p>
We can now use these two matrices to sum the dots of the rows and the columns, and ensure that they match with the numbers of each row and column:<br/>
</p>

<div>
<pre><span># </span><span>The top numbers must match</span>
<span>for</span> w <span>in</span> <span>range</span>(width):
    model.Add(cp_model.LinearExpr.WeightedSum([ones[w][h] <span>for</span> h <span>in</span> <span>range</span>(height)],
                                              [1 <span>for</span> _ <span>in</span> <span>range</span>(height)]) +
              cp_model.LinearExpr.WeightedSum([twos[w][h] <span>for</span> h <span>in</span> <span>range</span>(height)],
                                              [2 <span>for</span> _ <span>in</span> <span>range</span>(height)])
              == top_numbers[w])

<span># </span><span>The side numbers must match</span>
<span>for</span> h <span>in</span> <span>range</span>(height):
    model.Add(cp_model.LinearExpr.WeightedSum([ones[w][h] <span>for</span> w <span>in</span> <span>range</span>(width)],
                                              [1 <span>for</span> _ <span>in</span> <span>range</span>(width)]) +
              cp_model.LinearExpr.WeightedSum([twos[w][h] <span>for</span> w <span>in</span> <span>range</span>(width)],
                                              [2 <span>for</span> _ <span>in</span> <span>range</span>(width)])
              == side_numbers[h])
</pre>
</div>

<p>
Finally, all that is left to do is to ensure that the dominoes don&#39;t overlap other dominoes or black squares. This is actually pretty easy to model, but a bit tiresome as we have to consider many special cases: each of the four corners, each of the four sides, and the center of the board. These cases have to be considered individually because, depending on the location, half of one or another domino could end up off-grid. We use simple inequalities to ensure that no conflicting dominoes are placed on the board. For instance, if we place a one-dot vertical domino at position <code>(w, h)</code>, the constraint <code>ones[w][h] + ones[w][h+1] &lt;= 1</code> ensures that the &#34;dot half&#34; of another one-dot vertical domino does not end up in the adjacent square below, as it would overlap the &#34;blank half&#34; of the domino above.<br/>
</p>

<div>
<pre><span># </span><span>The dominoes must fit</span>
<span>for</span> h <span>in</span> <span>range</span>(height):
    <span>for</span> w <span>in</span> <span>range</span>(width):
        <span># </span><span>Top-left corner</span>
        <span>if</span> (w, h) == (0, 0):
            <span>if</span> (w, h) <span>in</span> blacks:
                model.Add(ones[w][h] +
                          twos[w][h] +
                          twos[w+1][h]
                          == 0)
            <span>else</span>:
                model.Add(twos[w][h]
                          == 0)
                model.Add(ones[w][h] +
                          ones[w][h+1]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w+1][h]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w+1][h+1]
                          &lt;= 1)

        <span># </span><span>Top-right corner</span>
        <span>elif</span> (w, h) == (width-1, 0):
            <span>if</span> (w, h) <span>in</span> blacks:
                model.Add(ones[w][h] +
                          twos[w][h]
                          == 0)
            <span>else</span>:
                model.Add(ones[w][h] +
                          ones[w][h+1]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w][h]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w][h+1]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          twos[w-1][h]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          ones[w-1][h]
                          &lt;= 1)

        <span># </span><span>Bottom-left corner</span>
        <span>elif</span> (w, h) == (0, height-1):
            <span>if</span> (w, h) <span>in</span> blacks:
                model.Add(ones[w][h] +
                          ones[w][h-1] +
                          twos[w][h] +
                          twos[w+1][h]
                          == 0)
            <span>else</span>:
                model.Add(ones[w][h] +
                          twos[w][h]
                          == 0)

        <span># </span><span>Bottom-right corner</span>
        <span>elif</span> (w, h) == (width-1, height-1):
            <span>if</span> (w, h) <span>in</span> blacks:
                model.Add(ones[w][h] +
                          ones[w][h-1] +
                          twos[w][h]
                          == 0)
            <span>else</span>:
                model.Add(ones[w][h]
                          == 0)
                model.Add(twos[w][h] +
                          ones[w][h-1]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          twos[w-1][h]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          ones[w-1][h-1]
                          &lt;= 1)

        <span># </span><span>Top border</span>
        <span>elif</span> h == 0:
            <span>if</span> (w, h) <span>in</span> blacks:
                model.Add(ones[w][h] +
                          twos[w][h] +
                          twos[w+1][h]
                          == 0)
            <span>else</span>:
                model.Add(ones[w][h] +
                          twos[w][h]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w+1][h]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          twos[w+1][h]
                          &lt;= 1)

        <span># </span><span>Left border</span>
        <span>elif</span> w == 0:
            <span>if</span> (w, h) <span>in</span> blacks:
                model.Add(ones[w][h] +
                          ones[w][h-1] +
                          twos[w][h] +
                          twos[w+1][h]
                          == 0)
            <span>else</span>:
                model.Add(twos[w][h]
                          == 0)
                model.Add(ones[w][h] +
                          ones[w][h+1]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          ones[w][h-1]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w+1][h]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w+1][h+1]
                          &lt;= 1)


        <span># </span><span>Right border</span>
        <span>elif</span> w == width-1:
            <span>if</span> (w, h) <span>in</span> blacks:
                model.Add(ones[w][h] +
                          ones[w][h-1] +
                          twos[w][h]
                          == 0)
            <span>else</span>:
                model.Add(ones[w][h] +
                          ones[w][h+1]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          ones[w][h-1]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w][h]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w][h+1]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          ones[w-1][h]
                          &lt;= 1)

        <span># </span><span>Bottom border</span>
        <span>elif</span> h == height-1:
            <span>if</span> (w, h) <span>in</span> blacks:
                model.Add(ones[w][h] +
                          ones[w][h-1] +
                          twos[w][h] +
                          twos[w+1][h]
                          == 0)
            <span>else</span>:
                model.Add(ones[w][h]
                          == 0)
                model.Add(twos[w][h] +
                          twos[w+1][h]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          twos[w-1][h]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          ones[w][h-1]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          ones[w-1][h-1]
                          &lt;= 1)

        <span># </span><span>Everywhere else</span>
        <span>else</span>:
            <span>if</span> (w, h) <span>in</span> blacks:
                model.Add(ones[w][h] +
                          ones[w][h-1] +
                          twos[w][h] +
                          twos[w+1][h]
                          == 0)
            <span>else</span>:
                model.Add(ones[w][h] +
                          ones[w][h-1]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          ones[w][h+1]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w][h]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w][h+1]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w+1][h]
                          &lt;= 1)
                model.Add(ones[w][h] +
                          twos[w+1][h+1]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          twos[w+1][h]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          ones[w-1][h]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          ones[w][h-1]
                          &lt;= 1)
                model.Add(twos[w][h] +
                          ones[w-1][h-1]
                          &lt;= 1)
</pre>
</div>

<p>
Now that the problem is modeled, let&#39;s solve it:<br/>
</p>

<div>
<pre><span>solver</span> = cp_model.CpSolver()
<span>status</span> = solver.Solve(model)

<span># </span><span>Print the solution</span>
<span>for</span> h <span>in</span> <span>range</span>(height):
    <span>for</span> w <span>in</span> <span>range</span>(width):
        <span>if</span> solver.Value(ones[w][h]) == 1:
            <span>print</span>(1, end=<span>&#34;&#34;</span>)
        <span>elif</span> solver.Value(twos[w][h]) == 1:
            <span>print</span>(2, end=<span>&#34;&#34;</span>)
        <span>elif</span> (w, h) <span>in</span> blacks:
            <span>print</span>(<span>&#34;X&#34;</span>, end=<span>&#34;&#34;</span>)
        <span>elif</span> w &lt; width-1 <span>and</span> solver.Value(twos[w+1][h]) == 1:
            <span>print</span>(<span>&#34;-&#34;</span>, end=<span>&#34;&#34;</span>)
        <span>else</span>:
            <span>print</span>(<span>&#34;|&#34;</span>, end=<span>&#34;&#34;</span>)
    <span>print</span>()
</pre>
</div>

<p>
This gives us the following solution:<br/>
</p>

<pre>1X-2-2X
|1-2X-2
1|-21-2
|1-2|11
1|-21||
|-2X|-2
X-2-2-2
</pre>


<p>
We can see that this solution matches the one shown at the beginning of this article. The complete source code of the model can be found <a href="https://github.com/PhilippeOlivier/domino-fit-solver">here</a>.<br/>
</p>
</div><div id="postamble">
<div><p>This website is generated by Emacs.</p></div>
</div></div>
  </body>
</html>
