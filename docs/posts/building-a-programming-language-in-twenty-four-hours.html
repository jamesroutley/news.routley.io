<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ersei.net/en/blog/diy-programming-language">Original</a>
    <h1>Building a Programming Language in Twenty-Four Hours</h1>
    
    <div id="readability-page-1" class="page"><div><article><h2><a href="https://www.youtube.com/en/blog/diy-programming-language">Building a Programming Language in Twenty-Four Hours</a></h2><p><small> Published: [ <b><time datetime="2023-06-05T08:45:00-04:00">2023-06-05 08:45</time></b> ] </small></p><p>I know I <a href="https://www.youtube.com/en/blog/free-time">promised</a> to put out an article every week on a Sunday. I haven&#39;t been too good at sticking to that schedule. It&#39;s now Sunday morning at around 8:50 AM. I have a thing I have to be at by 4 PM. Naturally, I&#39;m going to pick something that will take a lot more than seven hours.</p><p>Enter: Building a programming language <em>from scratch</em> in six hours (or less).</p><p><em>Hey, future Ersei here. This took more than six hours. Just FYI.</em></p><p>Let&#39;s see how this goes.</p><p><a href="https://social.ersei.net/@ersei/110491701941410007">Discuss this post on Mastodon</a></p><p><em>This should <strong>not</strong> be used as a tutorial for how to create a programming language. It is my actual thought process and my failures while making one. Everything that I write is wrong, and if you copy it down then what you make will be wrong too (until you get to the part where I realize it&#39;s wrong and fix it). You have been warned.</em></p><p>My friend told me that I am not a real programmer because I have not made my own programming language yet. Because I can&#39;t take a joke, I decided to take her up on the challenge and make one. There were a few small issues with that, though.</p><p>I have no experience building a programming language.</p><p>Literally none.</p><p>But I know how to start projects! Set some goals!</p><p>This programming language must be able to:</p><ol><li>Be fast</li><li>Be able to call external C code</li><li>Look nice (kinda)</li><li>Portable</li><li>(Time permitting) have data structures like a dynamically allocated list</li></ol><p><em>Hey, future Ersei here. About two of these got implemented. Just FYI.</em></p><p>Let&#39;s do what every project starts with: searching the internet.</p><p><img alt="A DuckDuckGo search bar showing &#34;how to make a programming language&#34;" src="https://www.youtube.com/user/pages/03.blog/30.diy-programming-language/ddg-start.png"/></p><p>There are a lot of options! People have made their own hobby languages already! I opened up all of the links on the first page up in another tab.</p><p>The first link I clicked on gave me this:</p><blockquote><p>Over the past 6 months, I&#39;ve been working on a programming language called Pinecone. I wouldn&#39;t call it mature yet, but it already has enough features working to be usable, such as variables, functions and user defined structures <a href="https://www.freecodecamp.org/news/the-programming-language-pipeline-91d3f449c919">(freeCodeCamp)</a></p></blockquote><p>Uh, six <em>months</em>? I need to get all of that done in six <em>hours</em> (or less.)</p><p>I&#39;ve also just spent the last ten minutes writing all of that and putting in screenshots!</p><p>Anyway, there seem to be a few steps in making a programming language: first is picking the language that your language is built in. Let&#39;s go for Rust for no other reason than for the meme.</p><p>Next up is <em>lexing</em> (which is to take the programming language text and turn it into a set of &#34;tokens&#34; for the compiler to look at). The first link also told me that there are existing lexers that&#39;ll do it all for you. Let&#39;s search for a lexer in Rust. The first link is <a href="https://pest.rs">pest</a>. Might as well use it.</p><p>I am also now realizing that I need a name for my Git repo where I&#39;m gonna be putting all of this. Let&#39;s go with... Ersei-Lang, shortened to Erlang! No, that won&#39;t work. EPL? For Ersei-Programming-Language? Apparently it already exists for programming printers. Uh, how about picking a random word from the dictionary? Let&#39;s go with...</p><p><img alt="A random word generator returning the word &#34;Cane&#34;" src="https://www.youtube.com/user/pages/03.blog/30.diy-programming-language/random-word.png"/></p><p>Cane! Good enough for me. A cursory search returns no other project called &#34;Cane&#34;, so I think I&#39;m good.</p><p>Wow, I did really just spend ten more minutes picking a name.</p><p>Anyway, let&#39;s get started! Sit down behind the computer, open up Vim, and get typing!</p><p>If you really <em>want</em> to read the whole development story, go to the <a href="#development-hell">Development Hell</a> section.</p><p>To download the language, go to the <a href="https://sr.ht/~fd/cane-lang">Sourcehut page</a>.</p><p>To mess with the language online, go to the <a href="https://fd.srht.site">web playground</a>.</p><p>Without further ado, here&#39;s some code snippets!</p><pre><code>; Simple &#34;Hello, world!&#34; program ~

(`hello, &#39; `world\n&#39; add print)</code></pre><pre><code>;
It&#39;s pretty simple to define a variable
You need: the data, and a string as a name.
~

((1 2 3 4 add) `myvarname&#39; defvar)
(myvarname `\n&#39; print)
(myvarname `\n&#39; print)
(myvarname `\n&#39; print)
(myvarname `\n&#39; print)

; All variables are immutable! You can replace the variable, but you can&#39;t edit it. ~

((1 2 3 4 add) `myvarname&#39; defvar)
(myvarname `\n&#39; print)
((1 2 3 4 5 add) `myvarname&#39; defvar)
(myvarname `\n&#39; print)</code></pre><p>Pretty cool, huh?</p><p>How about something more <em>dynamic</em>? Make a function (I call them &#34;actions&#34; because why not)</p><pre><code>;
actions, or functions, are just strings that are executed. arguments passed are available
through the `args&#39; variable
~

([(args add)] `myaction&#39; defact) ; define an action called `myaction&#39; ~
(1 2 3 4 myaction print) ; call myaction with arguments 1 2 3 4 ~</code></pre><p>Now print the numbers from 1 to 100!</p><pre><code>; Prints the numbers from 1 to 100 ~

(1 `count&#39; defvar)
(
    [
        (count `\n&#39; print)
        (count 1 add `count&#39; defvar)
    ]
    100 repeat
)</code></pre><p>There are a lot more demos on the <a href="https://git.sr.ht/~fd/cane-lang/tree/main/item/demos">Git repo</a>.</p><h2 id="the-tl-dr">The TL;DR<a href="#the-tl-dr" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>Cane is a <em>weird</em> language. It&#39;s like if you showed me <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> and asked me to go crazy. It&#39;s got parentheses!</p><p>This is also technically a functional programming language. The whole program will evaluate to a state. Again, I have no idea how functional programming languages work. The most experience I have is with <a href="https://nixos.org">Nix</a> and even then I just copy-paste things into my config until it works.</p><p>I am probably the worst person to be making a Lisp-like functional-ish programming language. Mostly because I know just enough to be dangerous. And not enough to know any better. Additionally, I don&#39;t know enough <a href="https://www.rust-lang.org">Rust</a> to make this efficient, which is why there might be some, uh, <em>idiosyncrasies</em>.</p><p>But! I&#39;m a real programmer now üòé</p><p>This was certainly a journey, and I might come back in a few days/weeks/months to add a feature or three. But this was just a proof-of-concept, to prove that I can and to do it all without cheating (using external libraries/LLVM/looking at someone else&#39;s code). My journey consists of novice mistakes, rediscoveries of old programming paradigms (reverse polish notation ftw!), and mostly a lot of fun. Over the course of the past two months (I had final exams and then I took a break from computers so I could destress), this has been my project. I fell asleep thinking about this. I woke up with new ideas. The last three days especially have been so fun!</p><p>I recommend doing something like this yourself. Take on a project that can be as simple or as complicated or as easy or as hard as you want. Like building a programming language. Give yourself a time limit. See what happens. No stress like with hackathons or homeworks. Just time yourself. Estimate if you don&#39;t really care. Give it a shot. You&#39;ll have fun, I promise.</p><p>And then <a href="https://www.youtube.com/en/contact-me">email me</a> to show me what you&#39;ve made ‚ù§Ô∏è</p><p><em>None of this actually made it to the end project. Go down to the <a href="#designing-the-new-languag">Designing the New Language</a> section to see something more similar to the end result.</em></p><pre><code>$ cargo new cane-lang</code></pre><p>Let&#39;s also add in the lexer dependency into our <code>Cargo.toml</code>.</p><pre><code>$ cargo add pest</code></pre><p>Now let&#39;s waste precious time for Cargo to update the Crates index.</p><p>And while we&#39;re at it, let&#39;s update our Neovim configuration and hope it doesn&#39;t break. You can tell how I put off writing this until the last minute right?</p><p>Anyway, now what? We have a Git repository, we have a lexer <em>installed</em>, but what do we do after that?</p><p>Now we have to take our tokens and turn it into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>. If you don&#39;t know what that means, it&#39;s fine, neither do I. I think it&#39;s like, the map of your code as a tree or something. I don&#39;t know, I just read the first line in the Wikipedia article.</p><p><a href="https://github.com/mirdaki/theforce/blob/main/src/ast.rs">Oh good, someone has done a lot of the hard work for me</a></p><p>Let&#39;s do all of that.</p><p>I am also now realizing that my Rust skills are‚Ä¶ rusty. I forget how to do everything. Maybe Rust wasn&#39;t the best language to pick, but here I am.</p><pre><code>$ rm -rf cane-lang
$ cargo new cane-lang --lib
$ cd cane-lang
$ mkdir src/bin</code></pre><p>Now that we have some structure in our project, I can get started on actually doing work! Let&#39;s figure out what our programming language will look like (spoiler alert: it&#39;s gonna look like C). Yes, there will be semicolons and you can&#39;t stop me.</p><p>Looking at that <a href="https://github.com/mirdaki/theforce">theforce</a> programming language, it seems like I can just‚Ä¶ copy the code and change up the tokens in the lexer and the test and I will be done? See? Programming language in six hours (or less). It&#39;s more like five hours now because I&#39;ve spent so much time just researching and looking at documentation and I have zero idea what&#39;s going on.</p><p>Anyway, let&#39;s use that programming language as a help card, to draw inspiration from in the case of being stuck.</p><p>Let&#39;s poke around that repo and see what&#39;s going on. It&#39;s a very simple set of code, which is super nice.</p><p>Now let&#39;s get into programming language design. I&#39;m learning as I write this, so it might not be super accurate, but let&#39;s do this.</p><h2 id="introduction-to-asts">Introduction to ASTs<a href="#introduction-to-asts" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>An AST is a representation of the code in a &#34;tree&#34; format. The tree is made up of &#34;nodes&#34;. One node is an &#34;if&#34; statement, or declaring a string, or to call a function, or assigning a variable. Some nodes can be operations. There are two kinds of operations: <em>unary</em> and <em>binary</em>. Unary operations act on one node and one node only. Think of the &#34;not&#34; operator. It will invert one node. Binary operations act on two nodes, and thus can be recursive since they can act on themselves. Think of adding two nodes together.</p><p>Now, we have to take the program file and make it into an AST. We do that with a <a href="https://en.wikipedia.org/wiki/Formal_grammar">grammar</a>.</p><h2 id="introduction-to-grammar">Introduction to Grammar<a href="#introduction-to-grammar" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>Grammar represents how the programming language should look. That&#39;s it. That&#39;s what <code>pest</code> does. It defines a grammar for your language and you can use it to generate a lexer and AST. Let&#39;s take a look at what a part of a <code>.pest</code> file looks like (taken from <a href="https://github.com/mirdaki/theforce/blob/main/src/grammar.pest">theforce</a>):</p><pre><code>Statements = _{ Statement* }

Statement = _{
    DeclareBooleanStatement
    | DeclareFloatStatement
    | DeclareStringStatement
    | AssignStatement
    | AssignFromFunctionStatement
    | PrintStatement
    | ReadFloatStatement
    | ReadStringStatement
    | ReadBooleanStatement
    | ForStatement
    | WhileStatement
    | IfStatement
    | CallFunctionStatement
    | Noop
}</code></pre><p>I should probably read the <a href="https://docs.rs/pest/latest/pest">pest documentation</a> while I&#39;m at it.</p><p>Anyway, let&#39;s put together a basic grammar for Cane. I&#39;m gonna copy the boilerplate from <em>theforce</em>.</p><pre><code>Program = _{ SOI ~ Functions ~ EOI }

Functions = { Function* }

Function = _{ VoidFunction | NonVoidFunction | Main }

VoidFunction = {
    DeclareFunction ~ FunctionName
    ~ Parameters
    ~ Void
    ~ Statements
    ~ EndFunctionDeclaration
}

NonVoidFunction = {
    DeclareFunction ~ FunctionName
    ~ Parameters
    ~ Statements
    ~ ReturnStatement
    ~ EndFunctionDeclaration
}

Parameters = { (FunctionParameters ~ VariableName)* }

Main = {
    BeginMain
    ~ Statements
    ~ EndMain }

Statements = _{ Statement* }</code></pre><p>Now I have to find out what statements I want to declare and use. <em>theforce</em> uses the following statements:</p><ol><li><code>DeclareBooleanStatement</code></li><li><code>DeclareFloatStatement</code></li><li><code>DeclareStringStatement</code></li><li><code>AssignStatement</code></li><li><code>AssignFromFunctionStatement</code></li><li><code>PrintStatement</code></li><li><code>ReadFloatStatement</code></li><li><code>ReadStringStatement</code></li><li><code>ReadBooleanStatement</code></li><li><code>ForStatement</code></li><li><code>WhileStatement</code></li><li><code>IfStatement</code></li><li><code>CallFunctionStatement</code></li><li><code>Noop</code></li></ol><p>Of these, I don&#39;t want to have multiple <code>Declare</code> statements. I wish to have one strongly-typed declaration statement. Likewise, I don&#39;t want to have multiple <code>Read</code> statements for all of the supported types.</p><p>So, I add the following to my grammar:</p><pre><code>Statement = _{
    DeclareStatement
    | AssignStatement
    | AssignFromFunctionStatement
    | PrintStatement
    | ReadStatement
    | ForStatement
    | WhileStatement
    | IfStatement
    | CallFunctionStatement
    | Noop
}</code></pre><p>Now for the hard part: implementing all of these statements. Let&#39;s figure out how to implement types.</p><p>ooOOoooo Time Skip ooOOoOOoOo</p><p>Ok, it&#39;s been like an hour of researching pest grammar. To be honest, I don&#39;t understand it. Maybe a strongly-typed language isn&#39;t a &#34;six hour&#34; project. At the time of writing this sentence, I have exactly three hours left. Let&#39;s rethink how types ought to be implemented in this program.</p><p>There should be a set of &#34;atomic&#34; types‚Äîlike integer (split into unsigned int, signed int, unsigned long, and signed long), float (and double), and character. These are the smallest set of data that the language can handle. On top of these &#34;atomic&#34; types, there ought to be types that can combine the atomic types (and other types), like arrays. I don&#39;t want to do anything beyond that, as that&#39;ll add too much complexity. Being able to use arrays would make this language actually useful! Would&#39;ya look at that?</p><p>Enough talk, let&#39;s get into it. Instead of just a generic <code>DeclareStatement</code> and <code>AssignStatement</code>, I&#39;m going to use multiple: <code>DeclareAtomicStatement</code> and <code>DeclareArrayStatement</code> (and related).</p><p>So, I need something like the following:</p><pre><code>DeclareAtomicStatement = {
    DeclareAtomic ~ VariableName ~ TypePickerValue
    ~ PUSH(Types) ~ SetInitialValue ~ ( POP | VariableName )
}

VariableName = { Identifier }

FunctionName = { Identifier }

Identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC)* }

SetInitialValue = _{ &#34;=&#34; }
TypePickerValue = _{ &#34;:&#34; }</code></pre><p>ooOooOoOoooo Time Skip Again OoOOOoooO</p><p>So, I had a conversation with someone smarter than I am about making my own programming language. To have arrays, I need types. Type theory is hard.</p><p>So, I&#39;m starting over. Again. Let&#39;s redefine our goals. Our old goals looked something like this:</p><ol><li>Be fast</li><li>Be able to call external C code</li><li>Look nice (kinda)</li><li>Portable</li><li>(Time permitting) have data structures like a dynamically allocated list</li></ol><p>Let&#39;s change that up a little:</p><ol><li>Portable</li><li>Have lists</li></ol><p><em>Hey, future Ersei here. Those are actually what ended up happening.</em></p><p>Now, that brings me to my first &#34;aha&#34; moment: I can make a functional programming language! Maybe something like <a href="https://www.scheme.org">Scheme</a> or make my own <a href="https://en.wikipedia.org/wiki/Lisp_%5C(programming_language%5C)">Lisp</a> dialect‚Ä¶</p><p>Big issue: I don&#39;t know how to program in functional languages. Thus, I do not understand them. Keeping in line with my &#34;six hour&#34; time frame (of which I have like, two left), this might be difficult.</p><p>First, let&#39;s give myself a little crash course on Lisp-like languages (non-comprehensive, done in five minutes):</p><ol><li>It&#39;s got lots of parentheses</li><li>It uses a lot of singly-linked lists</li><li>Very recursive</li></ol><p>That&#39;s as far as I want to get with understanding Lisp. Let&#39;s get right into designing the language:</p><h2 id="designing-the-new-languag">Designing the New Language<a href="#designing-the-new-languag" data-anchor-icon="#" aria-label="Anchor"></a></h2><p><em>Most of this got changed up. Again. But we are a lot closer to what the final language will look like.</em></p><p>We can worry about how the language will be implemented later (but we&#39;re keeping it in mind so that it isn&#39;t too difficult later down the road).</p><p>Each program is a statement. Each statement can have more than one statement in it. This allows for recursion.</p><p>Each statement is of the following syntax: either <code>(action data)</code> or <code>(data)</code>. Data is of the following types: a statement, list, or atomic (string, int, float).</p><p>All numeric values are infinite precision.</p><p>Let&#39;s define some keywords:</p><p><em>Hi, future Ersei here. A lot of these have changed. This is not what the language will have in the end.</em></p><ol><li><code>add A...</code>: adds together all of the items in the data recursively. If any value is a <code>String</code>, then the output will begin to add every additional item as a string.</li><li><code>mult A...</code>: multiplies all of items in the data. If lists are passed, then matrix multiplication occurs. Two strings being multiplied must result in an error. A string multiplied by an integer <code>n</code> will return that string repeated <code>n</code> times.</li><li><code>div A...</code>: divides each value from the next in the data. If non-numeric values are passed, then the interpreter must halt.</li><li><code>dup N A...</code>: returns a list containing <code>N</code> of the same inputs. If more than one item is passed, then the items are put into a list and the list is duplicated.</li><li><code>defact NAME A...</code>: creates an action with name <code>NAME</code>. Will evaluate <code>A</code> in order when called. If more than one <code>A</code> is passed, then the function returns each output in a list. Names must be unique between actions and variables.</li><li><code>free NAME...</code>: frees all variables and actions with the following names, allowing that name to be reused. A variable that is not found will halt the interpreter.</li><li><code>print A...</code>: prints data.</li><li><code>write FILE</code>: writes a string to a file (clobber).</li><li><code>read FILE</code>: reads a file into a list of lines.</li><li><code>ext FILE</code>: import and execute another file.</li><li><code>if CONDITION THEN ELSE</code>: if the condition is non-zero when cast to a number, return the data in <code>THEN</code>. Otherwise, return the data in <code>ELSE</code>.</li><li><code>get RANGE</code>: where range is a set of integers, return those values from the list (inclusive). Zero-indexed.</li><li><code>eq A...</code>: checks if the values are equal. Casts to the first argument. Will return a <code>Number</code><code>0</code> if they are not equal. Will return <code>1</code> if they are equal.</li><li><code>eqq A...</code> checks if the values and types are equal. Will return a <code>Number</code><code>0</code> if they are not equal. Will return <code>1</code> if they are equal.</li><li><code>gt A...</code>: checks if the values are in descending order. Casts to the first argument. Will return a <code>Number</code><code>0</code> if they are not in order. Will return <code>1</code> if they are in order.</li><li><code>gtt A...</code> checks if the values are in descending order. Types must all match. Will return a <code>Number</code><code>0</code> if they are not in order or if types do not match. Will return <code>1</code> if they are in order.</li><li><code>lt A...</code>: checks if the values are in ascending order. Casts to the first argument. Will return a <code>Number</code><code>0</code> if they are not in order. Will return <code>1</code> if they are in order.</li><li><code>ltt A...</code> checks if the values are in ascending order. Types must all match. Will return a <code>Number</code><code>0</code> if they are not in order or if types do not match. Will return <code>1</code> if they are in order.</li></ol><p>There will be a few atomic types as well:</p><ol><li><code>String</code>: one or more chars. Empty string is considered <code>0</code>.</li><li><code>Number</code>: infinite precision.</li><li><code>Action</code>: refers to a set of instructions. If an <code>Action</code> is in a <code>List</code>, it will be ignored.</li></ol><p>There is one composition type:</p><ol><li><code>List</code>: a dynamically allocated array of items (including other lists). All lists are zero-indexed.</li></ol><p>There will also be a few reserved values:</p><ol><li><code>args</code>: a list of the arguments passed to the <code>Action</code>.</li></ol><p>All types will be implicitly cast to the other if needed:</p><ol><li>Number to list: <code>1</code> will convert to <code>(1)</code></li><li>String to list: <code>&#34;apple&#34;</code> will convert to <code>(&#34;a&#34;, &#34;p&#34;, &#34;p&#34;, &#34;l&#34;, &#34;e&#34;)</code></li><li>List to number: always will return the size of the list.</li><li>List to string: concatenates all items in list to a string, ie <code>(&#34;a&#34;, &#34;p&#34;, &#34;p&#34;, &#34;l&#34;, &#34;e&#34;)</code> will turn into <code>&#34;apple&#34;</code>. This is recursive.</li><li>Number to string: <code>1</code> will convert to <code>&#34;1&#34;</code>. Any floating point numbers will be represented as rational fractions.</li><li>String to number: all numerics will be converted into strings and all non-numerics will halt execution. <code>&#34;1&#34;</code> will convert to <code>1</code>, and <code>&#34;a&#34;</code> will stop the program. Expects rational fraction.</li></ol><p><code>Action</code>s cannot be cast. If attempted, the program must terminate.</p><p>The program will continue to execute until an unrecoverable error has occured.</p><p>Unrecoverable errors:</p><ol><li>Cast to and from <code>Action</code></li><li>Reached end of file and parentheses are not all matched</li><li>Undefined <code>Action</code> or variable</li><li>Undefined value</li><li>Same <code>Action</code> or variable is defined multiple times</li><li>Cast string to number when it is not possible to do so</li><li>Unexpected token (two types passed instead of a list containing both items)</li><li>The empty list is used <code>()</code></li><li>Two strings are multiplied together</li><li>Non-numbers are divided</li></ol><p>Comments all start with <code>=</code>. The interpreter must ignore all input until a <code>=</code> is reached. The exception to this is when the comment delimiters are in a string.</p><p>The <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">Hello, World</a> program would look something like this:</p><pre><code>(print &#34;hello, world&#34;)</code></pre><p>Alternatively, it could also be:</p><pre><code>(print &#34;hello, &#34; &#34;world&#34;)</code></pre><p>Or:</p><pre><code>(print (add (&#34;hello&#34;) (&#34;world&#34;)))</code></pre><p>I can figure out more examples later. Now that we have the (maybe broken) spec let&#39;s get to programming!</p><p>One hour remains. I might end up needing more time.</p><h2 id="designing-the-interpreter">Designing The Interpreter<a href="#designing-the-interpreter" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>This will be an interpreted language. This interpreter will memory-map the file (not required to do so) and read it character by character. As such, the file should not edited while it is being executed.</p><p>The interpreter will keep track of the state of the program:</p><ol><li>A list of all <code>Action</code>s as a hashmap of the action name and the location in memory where it is kept.</li><li>The call stack. This will be implemented as a linked list that grows backward. Every time that the program &#34;jumps&#34;, the previous location is added to the stack. When the &#34;jump&#34; is finished (the last parenthesis is closed), the program pops the call stack and continues from that location. If the stack is empty, the program exits.</li><li>The data list. This is a dynamic list that contains the current execution state of the program. The list must be comprised of either lists or atomics. As the program progresses, the list is recursively flattened from the bottom-left up.</li></ol><p>Sounds simple, right? Now for the hard part: implementing the interpreter.</p><p>Fifty minutes remain. I definitely will need more time.</p><h2 id="writing-the-interpreter">Writing the Interpreter<a href="#writing-the-interpreter" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>First, we have to erase everything we&#39;ve already written, which wasn&#39;t that much anyway.</p><p>Now, let&#39;s go from the ground up. First, we have to implement the three basic types: <code>List</code>s, <code>Number</code>s, and <code>String</code>s. They all have to be part of the same <code>struct</code> so we can use them anywhere. We can also implement casts while we are at it.</p><p>After spending a few minutes trying to figure out how to do Rust development on Nix (because I switched to NixOS a few days ago, writeup soon), I can get started.</p><p>In <code>src/stdtypes.rs</code>:</p><pre><code>#[derive(Clone)]
pub struct List(pub LinkedList&lt;Data&gt;);

#[derive(Clone)]
pub struct Number(Rational);

#[derive(Clone, Copy, PartialEq)]
pub enum Types {
    STRING,
    NUMBER,
    LIST
}

#[derive(Clone)]
pub struct Data {
    kind: Types, 
    val_string: String,
    val_number: Number,
    val_list: List,
}</code></pre><p>Next, we can implement the basic <code>Action</code>s: <code>add</code> and <code>print</code>. This is the minimum to implement a basic &#34;Hello world&#34; program. We will worry about the rest later.</p><p>A snippet of the <code>add</code> action:</p><pre><code>impl Data {
    pub fn add(&amp;mut self) {
        if self.get_kind() == Types::LIST {
            // The first value in the list will determine the type
            let first = self.get_list().0.pop_front();
            if first.is_none() {
                panic!(&#34;List is not allowed to be null!&#34;);
            }
            let mut sum: Data = first.unwrap();
            sum.add();
            while let Some(mut var) = self.get_list().0.pop_front() {
                if var.get_kind() == Types::LIST {
                    var.add();
                }
                sum = sum + &amp;mut var;
            }
            self.kind = sum.kind;
            self.val_number = sum.val_number;
            self.val_string = sum.val_string;
        }
    }
}

impl std::ops::Add&lt;&amp;mut Data&gt; for Data {
    type Output = Data;
    fn add(mut self, other: &amp;mut Data) -&gt; Data {
        if self.kind == Types::LIST &amp;&amp; other.kind == Types::LIST {
            self.as_list().val_list.0.append(&amp;mut other.as_list().val_list.0);
            return self;
        } else if self.kind == Types::LIST {
            // The clone is stupid
            // C would let me do this WITHOUT the clone
            // It&#39;s stupid because we are adding to the end of a linked list. This is a pointer to
            // an object. I should be allowed to add it to the list.
            self.as_list().val_list.0.push_back(other.clone());
            return self;
        } else if self.kind == Types::STRING || other.kind == Types::STRING {
            self.as_string().val_string += &amp;other.as_string().val_string;
            return self;
        } else {
            self.as_number().val_number.0 += &amp;other.as_number().val_number.0;
            return self;
        }
    }
}</code></pre><p>The remainder of the code is left as an exercise for the reader.</p><p>I have spent six hours on the basics and the <code>add</code> function alone. I don&#39;t think that this time limit is gonna work out.</p><p>I am on hour ten of six. It is also time to go to bed. I&#39;ll write a bunch of comments so I don&#39;t forget everything tomorrow.</p><p>ooOOOOoOooO Time Skip oOOOoooooOOoO</p><p>Anyway, now that we have a functioning action, we can start making the actual interpreter.</p><p>For this interpreter, we will need to keep track of a few things:</p><ol><li>The current position of the executor in the file.</li><li>The call stack and the positions to jump back to.</li><li>The current data in the program so far as a list. Because of how this language is structured, only one (recursive) list can be active at a time.</li><li>A map of each <code>Action</code> to the location in the file they can be found.</li><li>A map of each variable name to the data it represents.</li></ol><p>A struct that can keep track of this information could look something like this:</p><pre><code>struct Interpreter&lt;R: Read&gt; {
    reader: BufReader&lt;R&gt;,
    call_stack: Vec&lt;SeekFrom&gt;,
    data_state: Data,
    actions: HashMap&lt;String, SeekFrom&gt;,
    variables: HashMap&lt;String, Data&gt;,
}
impl&lt;R: Read&gt; Interpreter&lt;R&gt; {
    fn new(reader: BufReader&lt;R&gt;) -&gt; Interpreter&lt;R&gt; {
        Interpreter {
            reader,
            call_stack: Vec::new(),
            data_state: Data::new(Types::LIST),
            actions: HashMap::new(),
            variables: HashMap::new(),
        }
    }
}</code></pre><p>Now to make the actual interpreter‚Ä¶ this might take a while.</p><p>I have spent another thirty minutes so far. Currently at ten and a half hours. Maybe aim for 24? That sounds impressive, right?</p><p>So, the way that the interpreter will work is that it will start reading the file until it hits a token. The tokens are as follows:</p><ol><li>Open string with <code>`</code></li><li>End string with <code>&#39;</code></li><li>Begin comment with <code>;</code></li><li>End comment with <code>~</code></li><li>Begin expression with <code>(</code></li><li>End expression with <code>)</code></li></ol><p>All whitespace (including newlines) will be ignored unless part of a string. Therefore, all whitespace are considered delimiters.</p><p>These are in order of priority. A string should continue until it hits another end quote, and so on. Let&#39;s make a basic interpreter that will do the following:</p><ol><li>Read the input character by character <ol><li>If a &#34;begin&#34; comment is found, then read character by character until and &#34;end&#34; comment is found</li><li>Ignore any whitespace</li><li>If anything but an open parenthesis is found, terminate the program with &#34;unexpected token&#34;</li><li>When the first opening parenthesis is found, begin execution</li></ol></li></ol><p>In the process of writing the code, I realized that it would be a lot easier to make everything based on postfix notation (reverse polish notation):</p><pre><code>(`hello world&#39; print)</code></pre><p>instead of prefix notation</p><pre><code>(print `hello world&#39;)</code></pre><p>That does bring into question how functions will be handled. We can worry about that later. I have a couple of ideas.</p><p>The big question is how am I going handle recursion? After distracting myself and reading a random article on RSS, I came to the conclusion that the interpreter should hold a reference to a data object in the interpreter state. This should be done through the call stack. In addition to the previous position, it will also contain the location of the previous data object as a reference. In addition, the interpreter will also keep track of a &#34;working data&#34; state. Easy enough, right? Let&#39;s get started.</p><pre><code>pub fn execute(&amp;mut self) -&gt; Result&lt;(), io::Error&gt; {
    let mut buf: [u8; 1] = [0];
    loop {
        match self.reader.read_exact(&amp;mut buf) {
            Err(_) =&gt; break,
            _ =&gt; (),
        };
        match self.call_stack.last_mut() {
            Some(call) =&gt; match call.get_state() {
                Some(State::Wait) =&gt; {
                    // Waiting for program to begin
                    // Only a comment or starting data can begin
                    if buf[0] == Symbols::CommentStart as u8 {
                        self.call_stack.push(Call::new(State::Comment));
                    } else if buf[0] == Symbols::DataStart as u8 {
                        self.call_stack.push(Call::new(State::Data));
                    } else if WHITESPACE.contains(&amp;buf[0]) {
                        // Ignore whitespace
                    } else {
                        // Unexpected token
                        return Err(Error::new(ErrorKind::InvalidData, format!(
                            &#34;Unexpected token {} at position {}&#34;,
                            std::str::from_utf8(&amp;buf).unwrap(),
                            self.reader
                                .seek(SeekFrom::Current(0))
                                .expect(&#34;Could not get current position!&#34;)
                        )));
                    }
                }
                Some(State::Data) =&gt; {
                    // Read data into object until end of object
                    if buf[0] == Symbols::DataEnd as u8
                        &amp;&amp; self.call_stack.last_mut().unwrap().get_token().len() == 0
                    {
                        self.call_stack.pop();
                    } else if buf[0] == Symbols::StringStart as u8 {
                        self.call_stack.push(Call::new(State::String));
                    } else if !WHITESPACE.contains(&amp;buf[0]) &amp;&amp; buf[0] != Symbols::DataEnd as u8
                    {
                        self.call_stack
                            .last_mut()
                            .unwrap()
                            .get_token()
                            .push_str(std::str::from_utf8(&amp;buf).unwrap());
                    } else {
                        // Now that the item in the data is split, we can choose what to do
                        // with it
                        // There are a few options. First is to execute a function. Second is
                        // to parse the object as a number. Third is to parse the object as a
                        // string.

                        let mut reset = true;
                        match self.call_stack.last_mut().unwrap().get_token().as_str() {
                            &#34;add&#34; =&gt; self.call_stack.last_mut().unwrap().get_data().add(), // Add data
                            &#34;print&#34; =&gt; write!(
                                self.stdout,
                                &#34;{}&#34;,
                                self.call_stack.last_mut().unwrap().get_data()
                            )
                            .unwrap(),
                            _ =&gt; reset = false,
                        }

                        if reset {
                            // Reset token
                            let token = self.call_stack.last_mut().unwrap().get_token();
                            *token = &#34;&#34;.to_string();
                        }

                        if buf[0] == Symbols::DataEnd as u8 {
                            self.call_stack.pop();
                        }
                    }
                }
                Some(State::String) =&gt; {
                    // If the string is over, push it into the data object
                    if buf[0] == Symbols::StringEnd as u8 {
                        let string_stack_object = self.call_stack.pop().unwrap();
                        // We can unwrap here safely because the only way to get to a string is
                        // when Data calls it
                        self.call_stack
                            .last_mut()
                            .unwrap()
                            .get_data()
                            .get_list()
                            .push(string_stack_object.data);
                    } else if let Some(last) = self.call_stack.last_mut() {
                        // Read data into object until end of string
                        last.get_data()
                            .get_string()
                            .push_str(std::str::from_utf8(&amp;buf).unwrap());
                    }
                }
                Some(State::Comment) =&gt; {
                    // Ignore everything until we hit the comment end
                    if buf[0] == Symbols::CommentEnd as u8 {
                        self.call_stack.pop();
                    }
                }
                None =&gt; todo!(),
            },
            None =&gt; todo!(), // Parse stack is empty, catastrophic failure
        };
    }
    // End of file
    // Check if the program still needs to do anything
    match self.call_stack.last_mut().unwrap().get_state() {
        Some(State::Wait) =&gt; Ok(()),
        _ =&gt; return Err(Error::new(ErrorKind::UnexpectedEof, &#34;Unexpected EOF!&#34;.to_string())),
    }
}</code></pre><p>This (and the supporting data structures) took me like another eight hours to put together, mostly since Rust got in the way (but good thing it did otherwise hard-to-find errors would have popped up).</p><p>But it works.</p><p>It does hello world.</p><pre><code>(`hello, &#39; `world
&#39; add print)</code></pre><p>There is no string escaping (yet), so the newline has to be a part of the code and not as an escape character.</p><p>But it works.</p><p>The <em>relief</em>.</p><p>We are at 18.5 hours. Time to implement the other basic parts. Next up is numbers. It&#39;s not too hard, I just have to patch the token parsing to check for numbers.</p><pre><code>let mut reset = true;
match self.call_stack.last_mut().unwrap().get_token().as_str() {
    &#34;add&#34; =&gt; self.call_stack.last_mut().unwrap().get_data().add(), // Add data
    &#34;print&#34; =&gt; write!(
        self.stdout,
        &#34;{}&#34;,
        self.call_stack.last_mut().unwrap().get_data()
    )
    .unwrap(),
    _ =&gt; {
        match Rational::from_str_radix(self.call_stack.last_mut().unwrap().get_token().as_str(), 10) {
            Ok(val) =&gt; {
                let mut data = Data::new(Types::NUMBER);
                data.set_number(Number(val));
                self.call_stack.last_mut().unwrap().get_data().get_list().push(data);
            },
            Err(_) =&gt; {
                reset = false;
            },
        }
    },
}</code></pre><p>That took less than ten minutes. I&#39;m making good time here! What&#39;s next? Unwraps!</p><p>What are unwraps, you ask? Well, in a situation like this:</p><pre><code>(1 2 (3 4 add 1) add print)</code></pre><p>the language will add together the two numbers then add a list to it. Because this language is very poorly designed, the list will be coerced into a number. That will always return the size of the list. Therefore, this will return <code>5</code>.</p><p>Unwrapping would look something like this:</p><pre><code>(1 2 (3 4 add 1)? add print)</code></pre><p>First <code>1</code> and <code>2</code> will be added, then <code>3 4</code> will be added, then the contents of that inner list will be appended to the end of the outer list:</p><pre><code>(1 2 7 1 add print)</code></pre><p>which will act as expected.</p><pre><code>if buf[0] == Symbols::Unwrap as u8 {
    let last_val = self
        .call_stack
        .last_mut()
        .unwrap()
        .get_data()
        .get_list()
        .pop_back();
    match last_val {
        Some(data) =&gt; match data.get_kind() {
            Types::LIST =&gt; {
                self.call_stack.last_mut().unwrap().get_data().get_list().append(data);
            }
            _ =&gt; {
                self.call_stack.last_mut().unwrap().get_data().get_list().push(data);
            }
        },
        _ =&gt; {
            return Err(Error::new(
                ErrorKind::InvalidData,
                format!(
                    &#34;Invalid unwrap at position {}&#34;,
                    self.reader
                        .seek(SeekFrom::Current(0))
                        .expect(&#34;Could not get current position!&#34;)
                ),
            ))
        }
    }
}</code></pre><p>As I am writing code demos for the language, I am running into issues with newlines. There are no string escapes! I can&#39;t write in <code>\n</code>, I have to put in a newline. Let&#39;s fix that.</p><pre><code>Some(State::StringEscape) =&gt; {
    self.call_stack.pop();
    match buf[0] {
        b&#39;n&#39; =&gt; self
            .call_stack
            .last_mut()
            .unwrap()
            .get_data()
            .get_string()
            .push_str(&#34;\n&#34;),
        _ =&gt; {
            let unescape_buf: [u8; 2] = [Symbols::Escape as u8, buf[0]];
            self.call_stack
                .last_mut()
                .unwrap()
                .get_data()
                .get_string()
                .push_str(std::str::from_utf8(&amp;unescape_buf).unwrap());
        }
    };
}</code></pre><p>It should be pretty easy to add in more escape characters later on (like if I want to print a single quote). Another forty-five minutes have passed. I am now at 21 hours. I have three hours left to make this language useful.</p><p>Of the keywords I defined earlier, I have done exactly two of them: <code>print</code> and <code>add</code>. Who knew making a programming language would be so difficult? I have comments, strings, numbers, nests, unwraps, demos, tests, and internal error handling, so if I were to stop here, I could consider this a success.</p><p>But I&#39;m not satisfied yet. The big things remaining are variables and functions. Those would make this language actually useful.</p><p>Remember how I said earlier that reverse polish notation would make functions and variables hard? That is because the interpreter reads the file from left to right. It won&#39;t know whether to execute the code or save it for later if it&#39;s a function, since it hasn&#39;t gotten to that part yet.</p><p>Because I&#39;ve already thrown out all sensibility, my brain went to using more than parentheses. A function could be defined with square brackets. Because why not. The interpreter will read the function into memory as a string, then execute it when the function token is found.</p><p>Now I&#39;m thinking, why not just use a string? That can be the function! And then, the language can generate its own code to execute!</p><p>I am really going crazy here folks.</p><h2 id="things-get-truly-cursed">Things Get Truly Cursed<a href="#things-get-truly-cursed" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>Let&#39;s implement functions-that-are-strings-but-also-executable. It shouldn&#39;t be too difficult.</p><p>Here&#39;s the plan. When <code>defact</code> is hit, then the last item in the data is popped and used as the name, and the data before that is used as the action. Same deal with <code>defvar</code>:</p><p>To load the data into the hashmap (this is alongside <code>print</code>):</p><pre><code>&#34;defvar&#34; =&gt; {
    let key = self
        .call_stack
        .last_mut()
        .unwrap()
        .get_data()
        .get_list()
        .pop_back();
    if key.is_none() {
        return Err(Error::new(
            ErrorKind::InvalidData,
            &#34;No action name found&#34;.to_string(),
        ));
    }
    let var = self
        .call_stack
        .last_mut()
        .unwrap()
        .get_data()
        .get_list()
        .pop_back();
    if var.is_none() {
        return Err(Error::new(
            ErrorKind::InvalidData,
            &#34;No variable found&#34;.to_string(),
        ));
    }
    self.variables
        .insert(key.unwrap().to_string(), var.unwrap());
    println!(&#34;{:?}&#34;, self.variables);
}</code></pre><p>and to retrieve it (this is after the token to number check):</p><pre><code>match self
    .variables
    .get(self.call_stack.last_mut().unwrap().get_token())
{
    Some(data) =&gt; {
        println!(&#34;found {:?}&#34;, data);
        match data.get_kind() {
            Types::ACTION =&gt; {
                unimplemented!()
            }
            _ =&gt; {
                self.call_stack
                    .last_mut()
                    .unwrap()
                    .get_data()
                    .get_list()
                    .push(data.clone());
            reset = true;
            }
        }
    }
    None =&gt; (),
}</code></pre><p>That was just one more hour spent. Two hours remain.</p><pre><code>((1 2 3 4 add) `myvarname&#39; defvar)
(myvarname `\n&#39; print)

((1 2 3 4 5 add) `myvarname&#39; defvar)
(myvarname `\n&#39; print)</code></pre><p>This will print <code>10</code> then <code>15</code>.</p><p>Now for functions. There are two ways I can do this: functions can return data, or they can only act on the variables. It&#39;ll be easier to implement the second one, but the first one would be more useful.</p><p>I think I have enough time. Let&#39;s do it. I&#39;ve already implemented the code to save a string as an action (almost the exact same as the variable saving code, just with a few more lines to change the type to action).</p><p>Maybe the best (worst) way to do this is to start another interpreter with a shared variable state and to use a <code>Cursor</code> to read the function data.</p><pre><code>Types::ACTION =&gt; {
    let mut c = Cursor::new(Vec::new());

    c.write_all(data.to_string().as_bytes()).unwrap();
    let mut reader = BufReader::new(c);
    reader.rewind().unwrap();
    let mut action_interp = Interpreter::new(
        reader,
        self.stdout,
        self.variables,
        self.call_stack
            .last_mut()
            .unwrap()
            .get_data()
            .clone(),
    );
    // Delete old data (since it was copied into
    // args for new instance)
    self.call_stack.last_mut().unwrap().get_data().erase();
    match action_interp.execute() {
        Ok(data) =&gt; {
            self.call_stack
                .last_mut()
                .unwrap()
                .get_data()
                .get_list()
                .push(data);
            reset = true;
        }
        Err(e) =&gt; return Err(e),
    }
}</code></pre><p>It has now been two hours. I have hit the deadline.</p><p><a href="https://git.sr.ht/~fd/cane-lang/commit/04f8edab30b0158e2901877d6fa5f5f2ffdcd03a">This is the last commit in the 24 hour deadline</a>.</p><p>But since when did I care about deadlines? To make this language useful, there is one last thing that must be added: control flow.</p><h2 id="back-to-sanity-kinda">Back to Sanity (Kinda)<a href="#back-to-sanity-kinda" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>Implementing <code>eq</code>, <code>lt</code>, <code>gt</code>, and so on will be pretty easy. Each of these will take <code>n &gt;= 3</code> arguments. The first is the condition. The second is the output if the condition is true. The third is the output if the condition is false. Of course, to make it easier for myself, the output conditions are also strings that will be executed (who cares about Rust&#39;s call stack? I&#39;m on a deadline here!)</p><p>Furthermore, these comparisons will be made strictly. Casting will be implemented pretty easily:</p><pre><code>&#34;tolist&#34; =&gt; {
    self.call_stack.last_mut().unwrap().get_data().as_list();
    let data = self.call_stack.last_mut().unwrap().get_data();
    let mut changeme = data.get_list().pop_back().unwrap();
    changeme.as_list();
    data.get_list().push(changeme);
}
&#34;tostring&#34; =&gt; {
    let data = self.call_stack.last_mut().unwrap().get_data();
    let mut changeme = data.get_list().pop_back().unwrap();
    changeme.as_string();
    data.get_list().push(changeme);
}
&#34;tonum&#34; =&gt; {
    let data = self.call_stack.last_mut().unwrap().get_data();
    let mut changeme = data.get_list().pop_back().unwrap();
    changeme.as_number();
    data.get_list().push(changeme);
}</code></pre><p>We are popping the last value in the list, converting it, then pushing it back.</p><p>Converting a list to a number still returns the size of the list, so getting the size of lists and strings is pretty easy (ex: <code>(string tolist tonum)</code>).</p><p>Now to finish off what we started: conditionals.</p><p>Here&#39;s how it&#39;s going to work: if the conditional is found, pop the last two items (for the true and false conditions), then check the data. Based on the check, execute the true or false condition.</p><pre><code>&#34;eq&#34; | &#34;lt&#34; | &#34;gt&#34; | &#34;lte&#34; | &#34;gte&#34; =&gt; {
    let token = self.call_stack.last_mut().unwrap().get_token().clone();

    let data = self.call_stack.last_mut().unwrap().get_data();
    let mut false_exec = data.get_list().pop_back().unwrap();
    let mut true_exec = data.get_list().pop_back().unwrap();
    let mut c = Cursor::new(Vec::new());

    let is_true = match token.as_str() {
        &#34;eq&#34; =&gt; data.is_eq(),
        &#34;lt&#34; =&gt; data.is_sorted_asc(),
        &#34;lte&#34; =&gt; data.is_sorted_asc_eq(),
        &#34;gt&#34; =&gt; data.is_sorted_desc(),
        &#34;gte&#34; =&gt; data.is_sorted_desc_eq(),
        _ =&gt; unreachable!(),
    };

    if is_true {
        c.write_all(true_exec.get_string().as_bytes()).unwrap();
    } else {
        c.write_all(false_exec.get_string().as_bytes()).unwrap();
    }

    let mut reader = BufReader::new(c);
    reader.rewind().unwrap();
    let mut action_interp = Interpreter::new(
        reader,
        self.stdout,
        self.variables,
        self.args.clone(),
    );
    self.call_stack.last_mut().unwrap().get_data().erase();
    match action_interp.execute() {
        Ok(data) =&gt; {
            self.call_stack
                .last_mut()
                .unwrap()
                .get_data()
                .get_list()
                .push(data);
            reset = true;
        }
        Err(e) =&gt; return Err(e),
    }
}</code></pre><p>I have also realized that the syntax for conditionals is ugly. If you want to return a string, then it looks so gross:</p><pre><code>(1 2 3 4 `(`this is ascending!\&#39;)&#39; `(`this is not ascending :(\&#39;)&#39; lt `\n&#39; print)</code></pre><p>Instead, let&#39;s make it look better:</p><pre><code>(1 2 3 4 `this is ascending!&#39; `this is not ascending :(&#39; lt `\n&#39; print)</code></pre><p>Simple! Just have the interpreter treat all unknown characters as a string to save! (This code is left as an exercise to the reader (or just look at the source (wow this sentence looks like the programming language)))</p><p>We are now on hour 26 of 24. This programming language is more or less done. I could implement more features, but at this point I wanna make cool shit with Cane.</p><h2 id="dogfooding">Dogfooding<a href="#dogfooding" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>Let&#39;s make a simple loop. Print the numbers from 1 to 100.</p><pre><code>(1 `counter&#39; defvar)
(
    `(counter 100 `(counter `\n\\\&#39; print) (1 counter add `counter\\\&#39; defvar) (body)\&#39; `\&#39; lte)&#39; 
    `body&#39; defact
)
(body)</code></pre><p>Now that I&#39;m writing code in this language, I can see how using strings is a bad idea. Maybe a slightly different syntax is needed?</p><p>How about using brackets to signify that?</p><pre><code>(1 `counter&#39; defvar)
(
    [(counter 100 [(counter `\n&#39; print) (1 counter add `counter&#39; defvar) (body)] 0 lte)]
    `body&#39; defact
)
(body)</code></pre><p>It will act almost exactly like a string, but it will match the brackets so no escaping is needed. If a bracket is found in a string, nothing will happen.</p><p>It will still return a string though.</p><p>Furthermore, I think the current model of creating a new interpreter every time recursion happens (which will happen a lot) is stupid and inefficient. I have a <em>little bit</em> of pride in my work. After the bracket bit though.</p><p>Maybe it was a mistake to have the call stack and the parse stack merged...</p><p>Anyway, two hours later I have this:</p><pre><code>Some(State::LazyEval) =&gt; {
    if buf[0] == Symbols::StringStart as u8 {
        self.call_stack
            .last_mut()
            .unwrap()
            .get_data()
            .get_list()
            .last_mut()
            .unwrap()
            .get_string()
            .push_str(&#34;`&#34;);
        self.call_stack.push(Call::new(State::String));
    } else if buf[0] == Symbols::LazyStart as u8 {
        open_count += 1;
        self.call_stack
            .last_mut()
            .unwrap()
            .get_data()
            .get_list()
            .last_mut()
            .unwrap()
            .get_string()
            .push_str(&#34;`&#34;);
    } else if buf[0] == Symbols::LazyEnd as u8 {
        close_count += 1;
        // We only want to add the end quote if we are at least one layer deep
        if open_count - close_count &gt; 0 {
            self.call_stack
                .last_mut()
                .unwrap()
                .get_data()
                .get_list()
                .last_mut()
                .unwrap()
                .get_string()
                .push_str(&amp;(&#34;\\&#34;.repeat(open_count - close_count - 1) + &#34;&#39;&#34;));
        }
    } else if open_count == close_count {
        // If the string is over, push it into the data object
        let mut string_stack_object = self.call_stack.pop().unwrap();
        // Merge the string fragments
        string_stack_object.get_data().as_string();
        // We can unwrap here safely because the only way to get to a string is
        // when Data calls it
        self.call_stack
            .last_mut()
            .unwrap()
            .get_data()
            .get_list()
            .push(string_stack_object.data);
    } else {
        let last = self.call_stack.last_mut().unwrap();
        // Read data into object until end of string
        last.get_data()
            .get_string()
            .push_str(from_utf8(&amp;buf).unwrap());
    }
}</code></pre><p>Of course, the rest of the code was tweaked to get this working too.</p><p>I am now at hour 28 of 24. I feel exhausted. Optimization be damned, I&#39;m gonna get this ready for release. What a ride.</p><p>Butttt, I could release this as WASM and have people be able to mess with it on the web‚Ä¶ maybe later.</p><p>Also, everything is happening on the stack. Nothing is on the heap. This means that recursion (being so inefficient), can really only go so deep. The loop will max out at around ~760 iterations.</p><p>Now that I think about it, I did spend the first six hours or so doing nothing and messing around with AST and LLVM.</p><p>I am now at hour 22 of 24 &gt;:3</p><p>I think that I need to add more functionality:</p><ol><li><code>DATA N repeat</code> will execute <code>DATA</code><code>n</code> times</li><li><code>DATA... N duplicate</code> will duplicate <code>DATA...</code><code>n</code> times</li><li><code>DATA... drop</code> will remove the data from the object</li><li><code>DATA... flatten</code> will recursively unwrap the data until no lists remain</li></ol><p>This should get rid of the recursion issue with loops!</p><p>For example, <code>flatten</code> is implemented like so:</p><pre><code>pub fn make_flat(&amp;mut self) {
    let mut flattened: LinkedList&lt;Data&gt; = LinkedList::new();
    if self.kind == Types::LIST {
        while let Some(mut item) = self.get_list().0.pop_front() {
            flattened.append(&amp;mut item.val_list.0);
        }
        self.set_list(List::new(flattened));
    }
}</code></pre><p>mmmm recursion. Tasty. Can you tell I&#39;m losing my sanity over this project?</p><pre><code>; Prints the numbers from 1 to 100 ~

(1 `count&#39; defvar)
(
    [
        (count `\n&#39; print)
        (count 1 add `count&#39; defvar)
    ]
    1000000 repeat
)</code></pre><p>It has been another hour and a half. I should probably add the last two features I have been thinking about: <code>join</code> and <code>split</code>.</p><ol><li><code>DATA... String join</code> will join the data with the string (think python <code>&#34;stringhere&#34;.join(array)</code>)</li><li><code>String String split</code> will split the first string with the second. Should return a list.</li></ol><p>Join was easy:</p><pre><code>pub fn join_string(&amp;mut self, joiner: &amp;str) {
    if self.kind != Types::LIST {
        return;
    }
    let mut new_string = String::new();
    let mut should_strip: bool = false;
    for val in self.iter() {
        should_strip = true;
        new_string.push_str(&amp;(val.to_string() + joiner));
    }
    if should_strip {
        new_string = new_string.strip_suffix(joiner).unwrap().to_string();
    }

    self.set_string(new_string);
    self.kind = Types::STRING;
}</code></pre><p>along with the interpreter side of things:</p><pre><code>&#34;join&#34; =&gt; {
    let joiner = self
        .call_stack
        .last_mut()
        .unwrap()
        .get_data()
        .get_list()
        .pop_back();
    let data = self.call_stack.last_mut().unwrap().get_data();
    if joiner.is_none() {
        return Err(Error::new(
            ErrorKind::InvalidData,
            &#34;Joiner is missing&#34;.to_string(),
        ));
    }
    if joiner.as_ref().unwrap().get_kind() != Types::STRING {
        return Err(Error::new(
            ErrorKind::InvalidData,
            &#34;Joiner must be a string&#34;.to_string(),
        ));
    }
    data.join_string(joiner.unwrap().get_string());
}</code></pre><p>Splitting was much the same. This post is already very code-heavy, but here goes anyway:</p><pre><code>&#34;split&#34; =&gt; {
    let splitter = self
        .call_stack
        .last_mut()
        .unwrap()
        .get_data()
        .get_list()
        .pop_back();
    let splitme = self
        .call_stack
        .last_mut()
        .unwrap()
        .get_data()
        .get_list()
        .pop_back();
    if splitter.is_none() {
        return Err(Error::new(
            ErrorKind::InvalidData,
            &#34;Splitter is missing&#34;.to_string(),
        ));
    }
    if splitter.as_ref().unwrap().get_kind() != Types::STRING {
        return Err(Error::new(
            ErrorKind::InvalidData,
            &#34;Splitter must be a string&#34;.to_string(),
        ));
    }
    if splitme.is_none() {
        return Err(Error::new(
            ErrorKind::InvalidData,
            &#34;Splittee is missing&#34;.to_string(),
        ));
    }
    if splitme.as_ref().unwrap().get_kind() != Types::STRING {
        return Err(Error::new(
            ErrorKind::InvalidData,
            &#34;Splittee must be a string&#34;.to_string(),
        ));
    }
    for item in splitme
        .unwrap()
        .get_string()
        .split(splitter.unwrap().get_string().as_str())
    {
        let mut data = Data::new(Types::STRING);
        data.set_string(item.to_string());
        self.call_stack
            .last_mut()
            .unwrap()
            .get_data()
            .get_list()
            .push(data);
    }
}</code></pre><p>I have now hit 24 hours for the second time. I should be done now.</p><h2 id="the-aftermath">The Aftermath<a href="#the-aftermath" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>The <a href="#tl-dr">TL;DR</a> is a pretty good summary of how I felt after all of this. But you read the whole thing (or scrolled to the bottom), so I should probably have something else here for you.</p><p>Since I would consider this an <a href="https://en.wikipedia.org/wiki/Esoteric_programming_language">esolang</a>, I need to do funky esolang things with it, like prove <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-completeness</a> or write a <a href="https://en.wikipedia.org/wiki/Quine_(computing)">quine</a>. I&#39;m sure it&#39;s possible, but I am not good enough at computers to figure out those just yet. I need a break from doing computer things like this. My brain is mush enough already.</p><h3 id="so-what-did-i-learn">So what did I learn?<a href="#so-what-did-i-learn" data-anchor-icon="#" aria-label="Anchor"></a></h3><p>Rust. Mostly Rust. As I stopped searching for things on the internet (beyond Rust things) once I gave up on using LLVM, I did not learn much else from this project. But it was fun!</p><h3 id="what-next">What Next?<a href="#what-next" data-anchor-icon="#" aria-label="Anchor"></a></h3><p>Probably nothing. Maybe I&#39;ll add in some list manipulation features later, but I&#39;ve already stretched those 24 hours far enough.</p><p>Maybe I&#39;ll add support for this on <a href="https://replit.com">Replit</a> with Nix trickery (once I figure out how to use Nix (which is kinda sad considering that I have been using NixOS for a few months now (wow this sentence is also looking like Cane (since it has a lot of parentheses)))). The possibilities are endless.</p><p>Is this language stupid? Yes. Could I have done better with more time? No, since I would have gotten bored or burnt out or a combination of the two. I&#39;m glad I put a time limit on this.</p><h3 id="the-part-in-which-i-keep-">The Part in which I Keep Working<a href="#the-part-in-which-i-keep-" data-anchor-icon="#" aria-label="Anchor"></a></h3><p>I could not put down the language and now I ported it to WASM. It required a restructure of the crates, libraries, and then swap out the only dependency for another similar one.</p><p>So yeah. Cane is now Web-Ready. Like Java.</p><p>And then <a href="https://mastodon.lilysthings.org/users/i_lost_my_bagel">my friend</a> tells me that Cane does not work on Windows! Turns out that Windows has <a href="https://en.wikipedia.org/wiki/Newline#Representation">different line endings</a> than *nix, so I just needed to add <code>\r</code> to the list of whitespace.</p><p>See, now I want to implement even more features. I wanna add some proper math support. Multiplication, exponentiation, division, subtraction, etc)</p><ol><li><code>sub</code>: subtracts the data one after another. All data must be numbers.</li><li><code>mult</code>: multiplies the data one after another. All data must be numbers.</li><li><code>div</code>: divides the numbers one after another. All data must be numbers.</li><li><code>neg</code>: negates the last number.</li><li><code>floor</code>: rounds down to the nearest integer.</li><li><code>ceil</code>: rounds up to the nearest integer.</li><li><code>abs</code>: absolute value of the last number.</li></ol><p>Ok, that took like another hour. Now I&#39;m done, I swear.</p><p>But there&#39;s no way to read stdin‚Ä¶ no no no no no no. I am done. Finished.</p><p>Aaaand one hour later I could not hold myself back and decided to implement stdin. And <code>forever</code> loops. The loops were easy. It was implementing stdin that was too difficult. I blame Javascript. I could not, for the life of me, get stdin to work on the web playground properly. So the web playground has a non-interactive stdin. Heartbreaking. Maybe when I have more time and energy I can look into something else, like <a href="https://xtermjs.org">xterm.js</a>.</p><p>See, now it&#39;s 8:37 in the morning on Monday. I am getting this blog post out at 9:00, regardless of whether it&#39;s finished or not.</p><p>I think it&#39;s finished.</p><p>Grand total: 6 hours (messing around with old stuff), 25 hours (language), 4 hours (web playground), 1 hour (blog post).</p><p>Hmm, let&#39;s figure out how much that is:</p><pre><code>((6 25 4 1) `data&#39; defvar)
((data ? ` + &#39; join) ` = &#39; (data ? add) println)</code></pre><pre><code>6 + 25 + 4 + 1 = 36</code></pre><p>Isn&#39;t this nice? A programming language in thirty-six hours (but also actually just 25 hours for the actual language). I think this is a 24-hour-ish project, right?</p><p>Right?</p><hr/><p>Corrections? Comments? Just wanna say hi? <a href="https://www.youtube.com/en/contact-me">Get in touch!</a></p><p>Follow me on <a href="https://social.ersei.net/users/ersei">Mastodon</a></p></article></div></div>
  </body>
</html>
