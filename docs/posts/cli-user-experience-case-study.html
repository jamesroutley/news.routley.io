<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tweag.io/blog/2023-10-05-cli-ux-in-topiary/">Original</a>
    <h1>CLI user experience case study</h1>
    
    <div id="readability-page-1" class="page"><div><div><!-- Make images default to their pixel dimensions -->

<p>Command line interface (CLI) tools have a reputation for being difficult
to use.</p>
<p><a href="https://xkcd.com/1168"><img src="https://imgs.xkcd.com/comics/tar.png" alt="XKCD 1168: tar"/></a></p>
<p>Whilst powerful once mastered, a CLI inherently lacks a litany of user
interface “nice-to-haves”, simply by virtue of its medium:</p>
<ul>
<li>
<p><strong>Simplicity:</strong> Common tasks should be easy to perform. This is often
not the case, but worse is when tasks can be tweaked in myriad ways,
leading to a combinatorial explosion of flags, options and modifiers.</p>
</li>
<li>
<p><strong>Memorability:</strong> How does one remember all those different options?
It’s not realistic, which is why we so often resort to double-checking
the usage text, <code>man</code> pages, or search engine/generative AI du jour.</p>
</li>
<li>
<p><strong>Discoverability:</strong> Reminding ourselves how to perform what we know
(or assume) can be done isn’t the same as guiding us towards the full
gamut of what’s possible. Even when reading the entire reference
manual (or source code), this isn’t a sure thing: useful emergent
behaviour often goes undocumented.</p>
</li>
<li>
<p><strong>Familiarity:</strong> So we effectively resort to guessing. <code>--help</code> <em>must</em>
give us the usage text, right? There are common idioms that are
pervasive, but even this is not a guarantee.</p>
</li>
</ul>
<p><span>
      <a href="http://ablwr.github.io/static/d66a89d1aa044d753cad97c26baae38f/914ae/mysterytool.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Thanks for that" title="Thanks for that" src="http://ablwr.github.io/static/d66a89d1aa044d753cad97c26baae38f/fcda8/mysterytool.png" srcset="/static/d66a89d1aa044d753cad97c26baae38f/12f09/mysterytool.png 148w,
/static/d66a89d1aa044d753cad97c26baae38f/e4a3f/mysterytool.png 295w,
/static/d66a89d1aa044d753cad97c26baae38f/fcda8/mysterytool.png 590w,
/static/d66a89d1aa044d753cad97c26baae38f/914ae/mysterytool.png 860w" sizes="(max-width: 590px) 100vw, 590px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<ul>
<li><strong>Clarity:</strong> Open, meaningful communication is generally a good idea
in all walks of life. How often have you run a CLI command to be
presented with zero output, relying on <code>echo $?</code> to see if it even
succeeded? Or, at the other extreme, so much logging noise flooding
your terminal that you can’t tell what’s going on?</li>
</ul>
<p><code>tar</code>, lampooned in the above XKCD, is — at nearly 45-years-old — a
product of its age. The current GNU (and, to a lesser extent, BSD) <code>tar</code>
implementations go some way to improve things, but old habits die hard
and it’s still very common to see <code>tar chzPf</code>-and-friends in the wild.
Regardless, more modern tools also suffer from similar problems; anyone
who has used Git, or <em>shudder</em> GnuPG will attest to this.</p>
<p>As <a href="https://topiary.tweag.io">Topiary</a> — Tweag’s code formatting engine — matures, I took the
opportunity to modernise its CLI before suboptimal patterns become
entrenched.</p>

<p>In its early development, Topiary’s CLI was largely motivated by need.
When features were added, they were often exposed as command line
arguments, with little thought about the overall experience.</p>
<p>This is what it had organically grown into:</p>
<div data-language="text"><pre><code>CLI app for Topiary, the universal code formatter.

Usage: topiary [OPTIONS] &lt;--language &lt;LANGUAGE&gt;|--input-files [&lt;INPUT_FILES&gt;...]&gt;

Options:
  -l, --language &lt;LANGUAGE&gt;
          Which language to parse and format [possible values: json,
          nickel, ocaml, ocaml-interface, ocamllex, toml]
  -f, --input-files [&lt;INPUT_FILES&gt;...]
          Path to an input file or multiple input files. If omitted, or
          equal to &#34;-&#34;, read from standard input. If multiple files are
          provided, `in_place` is assumed [default: -]
  -q, --query &lt;QUERY&gt;
          Which query file to use
  -o, --output-file &lt;OUTPUT_FILE&gt;
          Path to an output file. If omitted, or equal to &#34;-&#34;, write to
          standard output
  -i, --in-place
          Format the input files in place
  -v, --visualise[=&lt;OUTPUT_FORMAT&gt;]
          Visualise the syntax tree, rather than format [possible
          values: json, dot]
  -s, --skip-idempotence
          Do not check that formatting twice gives the same output
      --output-configuration
          Output the full configuration to stderr before continuing
  -t, --tolerate-parsing-errors
          Format as much as possible even if some of the input causes
          parsing errors
      --configuration-override &lt;CONFIGURATION_OVERRIDE&gt;
          Override all configuration with the provided file [env:
          TOPIARY_CONFIGURATION_OVERRIDE=]
  -c, --configuration-file &lt;CONFIGURATION_FILE&gt;
          Add the specified configuration file with the highest priority
          [env: TOPIARY_CONFIGURATION_FILE=]
  -h, --help
          Print help
  -V, --version
          Print version</code></pre></div>
<p>Syntax tree visualisation is a good example: This was toggled with the
<code>--visualise</code> argument, which took an optional parameter to switch the
output format between GraphViz DOT and JSON. Visualisation was designed
as a different mode of operation, to aid the development of formatting
queries, but being expressed as an argument could imply to users that
formatting should still happen. This implication is reinforced by the
presence of formatting-specific arguments, such as <code>--skip-idempotence</code>
and <code>--tolerate-parsing-errors</code>; run together with <code>--visualise</code> is
meaningless, but it worked regardless.</p>
<p>At a more fundamental level, there’s the question of I/O: From where is
input read, and to where is it written? The input to a formatting tool
is kind of important, to say the least, and if Topiary is to do anything
besides cooking silicon wafers, it’s probably a good idea to do
something with its result. Yet an awkward dance of <code>--input-file</code>,
<code>--output-file</code> and <code>--in-place</code> was imposed. Those <em>may</em> seem
self-explanatory — and they were, in the beginning — but things
change:</p>
<ul>
<li>
<p>When support for formatting multiple inputs was added, <code>--input-file</code>
became <code>--input-files</code>. However, what happens if I try to visualise
multiple inputs?</p>
</li>
<li>
<p>How do multiple inputs map to outputs? The usage text says that
<code>--in-place</code> is assumed in this case, but what if I also specify an
<code>--output-file</code>?</p>
</li>
<li>
<p>What if I want to work with standard input or standard output? What
about read-only files? Is <code>--in-place</code> permitted in these cases?</p>
</li>
<li>
<p>Why do I even have to specify <code>--input-files</code> (or its short form,
<code>-f</code>)? Of course I’m going to be providing an input of some kind, so
it’s a bit redundant.</p>
</li>
</ul>
<p>While some of these questions were answered by the usage text, to really
know the behaviour of edge cases, you’d have to experiment or start
reading the source code.</p>
<p>Then there are the little things. Like when providing custom
configuration, how do <code>--configuration-file</code> and
<code>--configuration-override</code> interact? (I actually did have to read the
source code to figure that one out!) What about logging output,
presuming there is any; how does one access that?</p>
<p>Death by a thousand cuts.</p>
<p>Don’t get me wrong: Topiary’s CLI was certainly functional in this
state. However, it leant too heavily on assumptions and the Topiary
team’s collective (but inscrutable) knowledge. This made it clumsy,
sometimes surprising and, overall, imposed too much friction on new
users.</p>

<p>So I decided to fully rework the CLI. My mandate was clear:</p>
<h3 id="make-illegal-states-unrepresentable"><a href="#make-illegal-states-unrepresentable" aria-label="make illegal states unrepresentable permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Make illegal states unrepresentable</h3>
<p>This is a classic idiom from strongly typed functional programming,
where the type system is leveraged to forbid invalid input. The same
logic applies to command line arguments and, as Topiary is written in
Rust, I was able to achieve this using the same mechanism.</p>
<p>Topiary uses the excellent <a href="https://docs.rs/clap/latest/clap">clap</a> command line argument parser library,
which has a feature to derive the parser directly from your types and
their annotations (such as doc comments). This makes the definition of
the CLI arguments purely declarative, leaving you with only the work of
setting up your types correctly. All my other CLI modernisation work
stems from here.</p>
<p>To give some examples of what’s now unrepresentable (i.e., will fail):</p>
<ul>
<li>Attempting to visualise multiple files;</li>
<li>Specifying a formatting language when formatting files (which instead
use inference on the filename, driven by the configuration) or, vice
versa, specifying an input file when formatting standard input;</li>
<li>Specifying a formatting query file without a formatting language when
formatting standard input.</li>
</ul>
<h3 id="separate-modes-of-operation"><a href="#separate-modes-of-operation" aria-label="separate modes of operation permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Separate modes of operation</h3>
<p>Formatting and visualisation are two distinct modes of operation; they
do different things and take different options. Visualisation with
<code>--in-place</code> wouldn’t only be wrong, it would be catastrophic! The
former CLI also had an additional “pseudo-mode” of outputting the raw
configuration to standard error, for debugging purposes.</p>
<p>The old-fashioned way of separating modes in non-interactive CLI tools
was to have multiple binaries. This tends to both pollute the global
command namespace (ImageMagick’s <code>convert</code>, anyone?) and can be hindered
by a lack of consistency amongst related tools.</p>
<p>The new hotness — and by “new”, I mean “for the last decade, or two”
— is to use subcommands to mark this separation. So that’s what I did:</p>
<ul>
<li><code>topiary format</code> formats your code.</li>
<li><code>topiary visualise</code> visualises your code.</li>
<li><code>topiary config</code> outputs the computed configuration, as TOML.
(Formatted, of course!)</li>
<li><code>topiary completion</code> is a new feature, which generates shell
completion scripts to aid discoverability.</li>
</ul>
<p>All have common options and each have specific options, facilitated by
the types I defined. If a new mode is developed in the future, it can
just be added without breaking backwards compatibility.</p>
<h3 id="make-use-of-familiar-idioms"><a href="#make-use-of-familiar-idioms" aria-label="make use of familiar idioms permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Make use of familiar idioms</h3>
<p>Interaction with a CLI tool, that misses out on the visual cues and
metaphors that a GUI can provide, should be like a dialogue. (Preferably
a productive and friendly one, rather than one that ends up with you
questioning your life choices.) To that end, a de facto lexicon exists
amongst CLI tools with common behaviours that should be adhered to. It
would be weird, for example, if <code>--assist</code> was the option to show the
usage text, rather than <code>--help</code>.</p>
<p>There are a few things I’ve done in the new Topiary CLI to improve its
conversation skills:</p>
<ul>
<li>
<p>While <code>--input-file</code> and the likes are not unheard of, it’s far more
common, when input is required, to use positional <code>FILE</code> arguments.
This also plays nicely with, say, scripts that one may wish to write.</p>
</li>
<li>
<p>The point of a formatter is to format its input, it therefore stands
to reason that <code>--in-place</code> is implied when dealing with files. (A
notable exception to this is <code>sed</code>, but as a “stream editor” first,
it has a little more right to an <code>--in-place</code> option, which is not
its default.)</p>
</li>
<li>
<p>The ability to format standard input is still important, though. In
which case, rather than using the <code>-</code> file convention, files are
simply omitted. This allows Topiary to be put into a script pipeline
and enables this common interaction:</p>
<div data-language="console"><pre><code>$ topiary format --language json   ⟵ Invocation
{&#34;type&#34;:&#34;your code here&#34;}          ⟵ Standard input
&lt;Ctrl+D&gt;                           ⟵ EOF
{ &#34;type&#34;: &#34;your code here&#34; }       ⟵ Formatted standard output</code></pre></div>
</li>
<li>
<p>Logging information has always existed in Topiary, but you wouldn’t
know unless you read the <code>README</code> fairly thoroughly. It used to be
exposed through the <code>RUST_LOG</code> environment variable, which is an
artefact of the <code>env_logger</code> library. This has been changed to a
<code>--verbose</code> flag, following the common idiom of “more occurrences
means more output” (e.g., <code>-vvv</code> maps to <code>debug</code> logging).</p>
</li>
</ul>
<h3 id="make-common-tasks-easy-and-unsurprising"><a href="#make-common-tasks-easy-and-unsurprising" aria-label="make common tasks easy and unsurprising permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Make common tasks easy and unsurprising</h3>
<p>Topiary exposes a number of options. These knobs allow you to change its
behaviour in various ways and, while they shouldn’t be hidden away, they
shouldn’t obstruct the “happy path”. This echoes the design principles
that were laid out for Topiary’s formatting styles: uniform and “good
enough”. The same can be said for the CLI: Simplicity, over steampunk.</p>
<p>Some examples I’ve implemented:</p>
<ul>
<li>
<p>Formatting all your project’s files is just a matter of running
<code>topiary format PROJECT_DIR</code>. Topiary will recursively walk the
directory (no longer having to rely on shell expansion) and format
every file it understands.</p>
</li>
<li>
<p>Visualisation defaults to GraphViz DOT output, rather than JSON. A PDF
of the syntax tree can now be created with the very natural:</p>
<div data-language="sh"><pre><code>topiary visualise /path/to/my.file <span>\</span>
<span>|</span> dot <span>-Tpdf</span> <span>\</span>
<span>&gt;</span> syntax-tree.pdf</code></pre></div>
</li>
<li>
<p>Topiary’s configuration is sourced from a priority list and then
collated in one of three ways. This affords a high degree of
customisation, but can make it difficult to introspect the runtime
configuration. However, <code>topiary config</code> will not only output the
computed configuration — which can then be reused, for
reproducibility’s sake — but Topiary will also annotate it in a way
that lets you understand where it came from:</p>
<div data-language="toml"><pre><code>








<span>[</span><span>[</span><span>language</span><span>]</span><span>]</span>
<span>name</span> <span>=</span> <span>&#34;json&#34;</span>
<span>extensions</span> <span>=</span> <span>[</span>
    <span>&#34;json&#34;</span><span>,</span>
<span>]</span>

</code></pre></div>
</li>
</ul>
<h3 id="dont-paint-yourself-into-a-corner"><a href="#dont-paint-yourself-into-a-corner" aria-label="dont paint yourself into a corner permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Don’t paint yourself into a corner</h3>
<p>You may be thinking:</p>
<blockquote>
<p>If Topiary is primarily a formatter, why can’t I just skip the
<code>format</code> subcommand and have the CLI assume that as the default?</p>
</blockquote>
<p>It’s a good question and one which I asked myself. The most common task
for the Topiary CLI will be formatting, so by my earlier admission of
“making common tasks easy”, surely this optimisation would be
beneficial?</p>
<p>The answer to this has two parts:</p>
<ol>
<li>
<p><del>Firstly, clap doesn’t make this easy to do, when using its
derivation feature. Subcommands can certainly be optional, but to
force the parser into a “default path or subcommand path” state
machine, while maintaining coherent usage text, significantly goes
against its grain.</del></p>
<p>Shortly after publishing this article, Ed Page — the principal
contributor of clap — reached out to let me know that clap can
actually do this, and quite straightforwardly. As to my second point,
below, while generally true, he also suggested an interesting
<a href="https://github.com/tweag/topiary/issues/641">compromise</a>, which the Topiary team will work on
implementing.</p>
</li>
<li>
<p>More importantly, however, is that if Topiary commits to providing a
stable interface — which it certainly does — then other subcommands
(current and future) are effectively blocked by virtue of the
positional and arbitrary file inputs. What happens, for example, if
you want to format a file called <code>config</code>?</p>
</li>
</ol>
<p>This second point is crucial. Not only does it have the effect of
prohibiting legitimate subcommands, but users will come to rely on this
shorthand which fossilises the interface with suboptimal behaviour.</p>
<p><a href="https://xkcd.com/1172"><img src="https://imgs.xkcd.com/comics/workflow.png" alt="XKCD 1172: Workflow"/></a></p>
<p>For the same reason, I don’t allow subcommand or long option inference
(that is, expanding partial CLI arguments when there are no
ambiguities). There are, however, a handful of subcommand aliases which
are helpful to make common tasks quicker to type (e.g., <code>fmt</code> for
<code>format</code>), or when alternative spellings are common.</p>

<p>The full usage text for what I ended up with is too long to paste into
this article, but it can of course be <a href="https://github.com/tweag/topiary#usage">found in Topiary’s
documentation</a>. Besides, maybe a little demo would be
more illustrative. Here’s how it looks with completion in <code>zsh</code> (i.e.,
don’t blame Topiary for the clipping):</p>
<!--
The blog won't allow the Asciinema player to be embedded, hence the SVG.

NOTE TO REVIEWERS: This demo was rather expensive to produce. It thus
requires a *very* good reason to re-shoot!
-->
<p><a href="https://asciinema.org/a/608133"><img src="http://ablwr.github.io/81fae7fae934c493d13a1c7ff27d470c/demo.svg" alt="Topiary CLI demo"/></a></p>
<p>The path trod to arrive at this destination was not random. It was
informed by my own experience with CLI tools, guided by the direction
in which clap steers you. Further polish was added on the advice of the
<a href="https://clig.dev">Command Line Interface Guidelines</a> book. That said, UX research
is a legitimate discipline — involving testing and analytics on, you
know, <em>users</em> — which is usually the purview of GUIs. I’m not aware of
any UX research done in the realm of CLIs, but this may be an
interesting lead to follow.</p>
<p>In the meantime, the changes discussed in this article, as well as
numerous “quality of life” improvements to the CLI codebase — and other
enhancements to Topiary, as a whole — landed in <a href="https://github.com/tweag/topiary/releases/v0.3.0">Topiary
v0.3</a>. Making such sweeping changes was a big job that
required careful planning and review. However, I think the results speak
for themselves and that this upfront investment will pay off as Topiary
blooms.</p>
<!-- Acknowledgements (alphabetical by surname) -->
<p><em>Thanks to Nicolas Jeannerod and Erin van der Veen for their reviews of
this article.</em></p>
<!-- Links --></div></div></div>
  </body>
</html>
