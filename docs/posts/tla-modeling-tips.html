<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://muratbuffalo.blogspot.com/2025/12/tla-modeling-tips.html">Original</a>
    <h1>TLA&#43; Modeling Tips</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-6023861270150914222">
<h3>Model minimalistically</h3><p>Start from a tiny core, and always keep a working model as you extend. Your default should be omission. Add a component only when you can explain why leaving it out would not work. Most models are about a slice of behavior, not the whole system in full glory: E.g., Leader election, repair, reconfiguration. Cut entire layers and components if they do not affect that slice. <a href="https://muratbuffalo.blogspot.com/2023/09/beyond-code-tla-and-art-of-abstraction.html">Abstraction is the art of knowing what to cut</a>. Deleting should spark joy. </p><h3>Model specification, not implementation</h3><p>Write declaratively. State what must hold, not how it is achieved. If your spec mirrors control flow, loops, or helper functions, you are simulating code. Cut it out. Every variable must earn its keep. Extra variables multiply the state space (model checking time) and hide bugs. Ask yourself repeatedly: can I derive this instead of storing it? For example, you do not need to maintain a <span>WholeSet</span> variable if you can define it as a state function of existing variables: <span>WholeSet == provisionalItems \union nonProvisionalItems</span>.</p><h3>Review the model for illegal knowledge</h3><p>Do a full read-through of your model and check what each process can really see. TLA+ makes it easy to read global state (or another process&#39;s state) that no real distributed process could ever observe atomically. This is one of the most common modeling errors. Make a dedicated pass to eliminate illegal global knowledge.</p><h3>Check atomicity granularity</h3><p>Push actions to be as fine-grained as correctness allows. Overly large atomic actions hide races and invalidate concurrency arguments. Fine-grained actions expose the real interleavings your protocol must tolerate. </p><h3>Think in guarded commands, not procedures </h3><p>Each action should express one logical step in <a href="https://en.wikipedia.org/wiki/Guarded_Command_Language">guarded-command style</a>. The guard should ideally define the meaning of the action. Put all enablement conditions in the guard. If the guard holds, the action may fire at any time in true event-driven style. This is why I now prefer writing TLA+ directly over PlusCal: TLA+ forces you to think in guarded-command actions, which is how distributed algorithms are meant to be designed. Yes, PlusCal is easier for developers to read, but it also nudges you toward sequential implementation-shaped thinking. And recently, with tools like <a href="https://github.com/will62794/spectacle">Spectacle</a>, sharing and visually exploring TLA+ specs <a href="https://muratbuffalo.blogspot.com/2025/11/tla-modeling-of-aws-outage-dns-race.html">got much easier</a>.</p><h3>Step back and ask what you forgot to model</h3><p>There is no substitute for thinking hard about your system. TLA+ modeling is only there to help you think hard about your system, and cannot substitute thinking about it. Check that you incorporated all relevant aspects: failures, message reordering, repair, reconfiguration.</p><h3>Write TypeOK invariants </h3><p>TLA+ is not typed, so you should state types explicitly and early by writing TypeOK invariants. A good TypeOK invariant provides an executable documentation for your model. Writing this in seconds can save you many minutes of hunting runtime bugs through TLA+ counterexample logs.</p><h3>Write as many invariants as you can</h3><p>If a property matters, make it explicit as an invariant. Write them early. Expand them over time. Try to keep your invariants as tight as possible. Document your learnings about invariants and non-invariants. A TLA+ spec is a communication artifact. Write it for readers, not for the TLC model checker. Be explicit and boring for the sake of clarity.</p><h3>Write progress properties</h3><p>Safety invariants alone are not enough. Check that things eventually happen: requests complete, leaders emerge, and goals accomplished. Many &#34;correct&#34; models may quietly do nothing forever. Checking progress properties catch paths that stall.</p><h3>Be suspicious of success</h3><p>A successful TLC run proves nothing unless the model explores meaningful behavior. Low coverage or tiny state spaces usually mean the model is over-constrained or wrong. Break the spec on purpose to check that your spec is actually doing some real work, and not giving up in a vacuous/trivial way. Inject bugs on purpose. If your invariants do not fail, they are too weak. Test the spec by sabotaging it.</p><h3>Optimize model checking efficiency last</h3><p>Separate the model from the model checker. The spec should stand on its own. Using the cfg file, you can optimize for model checking by using appropriate configuration, constraints, bounds for counters, and symmetry terms.</p><p>You can find many examples and walkthroughs of <a href="https://muratbuffalo.blogspot.com/search/label/tla">TLA+ specifications on my blog</a>.</p><p>There are many more in the<a href="https://github.com/tlaplus/Examples"> TLA+ repo</a> as well.</p>
</div></div>
  </body>
</html>
