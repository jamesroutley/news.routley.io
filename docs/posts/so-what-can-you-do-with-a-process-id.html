<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://will-keleher.com/posts/What-can-you-do-with-a-pid.html">Original</a>
    <h1>So, what can you do with a process ID?</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
      
<p>For the longest time, the only thing I knew how to do with the process ID (PID) for a running process was kill it. It turns out, if you have a PID, you can gather a ton of info about what that process is up to!</p>
<p>I&#39;m sure these commands will seem blindingly obvious to someone more of sysadmin background. This is all coming from the perspective of someone who occasionally hops on to a machine and has a lot of trouble navigating around and exploring what the machine is up to and why. If that describes you too, I hope this is useful!</p>
<p>Let&#39;s start a process and grab its PID:</p>
<pre><code><span>&gt; </span><span>python3 -m http.server &amp;</span>
[1] 41186
<span>&gt; </span><span>PID=$!</span>
<span>&gt; </span><span><span>echo</span> <span>&#34;PID is <span>${PID}</span>&#34;</span></span>
PID is 41186
</code></pre>
<h3>ps -f $PID</h3>
<p><code>ps -f $PID</code> gives an amazing high-level overview of what a process is doing. Being able to see the PID of the parent, uptime, and the actual command that&#39;s being run can really help debugging work.</p>
<pre><code><span>&gt; </span><span>ps -f 41186</span>
UID   PID  PPID   C STIME   TTY           TIME CMD
501 41186 35891   0 12:33PM ttys001    0:00.16 /usr/local/Cellar/python@3.10/3.10.6_1/Frameworks/Python.framework/Versions/3.10/Resources/Python.app/Contents/MacOS/Python -m http.server
</code></pre>
<ul>
<li><code>PPID</code>: the PID of the parent. If you&#39;re trying to understand why a process started, running <code>ps -f</code> on the PPID can give you some good clues!</li>
<li><code>UID</code>: the user who started the process. <code>id -nu 501</code> will give you the username of the user who started the process.</li>
<li><code>CMD</code>: the full command that&#39;s running!</li>
<li><code>TTY</code>: the location of the TTY. As far as I know, there&#39;s no easy way to tail the TTY. Injecting output into it works though! <code>echo &#34;hello tty&#34; &gt; /dev/ttys001</code> will make &#34;hello tty&#34; show up in the terminal that ran the initial command.</li>
</ul>
<h3>lsof -p $PID -P</h3>
<p><a href="https://en.wikipedia.org/wiki/Lsof"><code>lsof</code></a> means &#34;list open files.&#34; If you provide a PID, you can see all of the files, pipes, network sockets, and devices that the process is using. If you add <code>-P</code>, it will show port numbers rather than port names.</p>
<pre><code><span>&gt; </span><span>lsof -p <span>$PID</span> -P</span>
COMMAND   PID USER   FD    TYPE            DEVICE SIZE/OFF                NODE NAME
Python  41186 will  cwd     DIR               1,4      192            51860960 /Users/will/tmp
Python  41186 will  txt     REG               1,4    49400            78478046 /usr/local/Cellar/python@3.10/3.10.6_1/Frameworks/Python.framework/Versions/3.10/Resources/Python.app/Contents/MacOS/Python
<span># </span><span>...omitting a long list of text files</span>
Python  41186 will  txt     REG               1,4  2177216 1152921500312782996 /usr/lib/dyld
Python  41186 will    0u    CHR              16,1  0t12464                1095 /dev/ttys001
Python  41186 will    1u    CHR              16,1  0t12464                1095 /dev/ttys001
Python  41186 will    2u    CHR              16,1  0t12464                1095 /dev/ttys001
Python  41186 will    3u  systm 0x60e5bd939a75061      0t0                     [ctl com.apple.netsrc id 6 unit 50]
Python  41186 will    4u   IPv6 0x60e5bd936095681      0t0                 TCP *:8000 (LISTEN)
Python  41186 will    6u   unix 0x60e5bde017a4a71      0t0                     -&gt;0x60e5bde017a1d91
</code></pre>
<p><code>lsof</code> supports a ton of amazing options. Do you have a port and want to get the PID of what&#39;s using it? Try <code>lsof -i :8000</code>! Or you can use <code>-i</code> to keep an eye on network traffic for a process: <code>lsof -i -r 2 | awk &#39;$2 == 41186&#39;</code></p>
<blockquote>
<p>Extra trick: if you&#39;re on Linux, <a href="https://linux.die.net/man/1/pwdx"><code>pwdx</code></a> can report the current working directory of a process.</p>
</blockquote>
<h3>top -pid $PID</h3>
<p>Want to keep an eye on CPU and memory of a process? <code>top</code> can narrow in on a single process if you provide a PID.</p>
<pre><code><span>&gt; </span><span>top -pid 41186</span>
PID    COMMAND      %CPU TIME     #TH  #WQ  #POR MEM  PURG CMPR
41186  Python       0.0  00:00.34 2    0    19   10M  0B   0B
</code></pre>
<h3>dtruss -p $PID or strace -p $PID</h3>
<p>I&#39;m a complete novice when it comes to tracing, but it&#39;s something I&#39;m trying to learn more about! On macs, you can use <code>dtruss</code> to follow the system calls of a running process. It&#39;s cool to see what a process is up to in detail! (<code>strace</code> is the linux equivalent)</p>
<pre><code><span>&gt; </span><span>dtruss -p 41186</span>
...
stat64(&#34;/Users/will/tmp/index.html\0&#34;, 0x70000A3F8678, 0x0)        = -1 2
stat64(&#34;/Users/will/tmp/index.htm\0&#34;, 0x70000A3F8678, 0x0)         = -1 2
open_nocancel(&#34;/Users/will/tmp/\0&#34;, 0x1100004, 0x0)              = 7 0
fstatfs64(0x7, 0x70000A3F7E80, 0x0)              = 0 0
getdirentries64(0x7, 0x7F95E7058E00, 0x2000)             = 240 0
close_nocancel(0x7)              = 0 0
</code></pre>
<h3>kill -HUP $PID</h3>
<p>If you want to communicate with a running process, you can send that process signals! Deciding what to do with (non-SIGKILL) signals is up to the process, so you can add code to respond to a signal however you&#39;d like and enable some simple inter-process communication.</p>
<pre><code><span>const</span> interval = <span>setInterval</span>(<span>() =&gt;</span> <span>null</span>, <span>60_000</span>); 
process.<span>on</span>(<span>&#34;SIGHUP&#34;</span>, <span>() =&gt;</span> {
  <span>console</span>.<span>log</span>(<span>&#34;received SIGHUP :)&#34;</span>);
});
process.<span>on</span>(<span>&#34;SIGTERM&#34;</span>, <span>() =&gt;</span> {
  <span>console</span>.<span>log</span>(<span>&#34;received SIGTERM. Stopping work&#34;</span>);
  <span>clearInterval</span>(interval); 
});
</code></pre>
<pre><code><span>&gt; </span><span>node ./listen_to_signals.js &amp;</span>
[1] 51019
<span>&gt; </span><span><span>kill</span> -HUP 51019</span>
received SIGHUP :)
<span>&gt; </span><span><span>kill</span> -TERM 51019</span>
received SIGTERM. Shutting down
[1]  + 51019 done       node ./listen_to_signals.js
</code></pre>
<h3>wait $PID</h3>
<p>If you&#39;re writing a script that starts a process, you can wait for that process to complete using <code>wait</code>. If you provide the PID, <code>wait</code> will return with the exit code from that process. This can enable some easy parallelization in shell scripts.</p>
<pre><code>pids=()
<span>sleep</span> 1 &amp;
pids+=($!)
<span>false</span> &amp; 
pids+=($!)
<span>true</span> &amp;
pids+=($!)
status=0
<span>for</span> pid <span>in</span> <span>&#34;<span>${pids[@]}</span>&#34;</span>; <span>do</span>
    <span>wait</span> <span>&#34;<span>$pid</span>&#34;</span> || status=$?
<span>done</span>
<span>exit</span> <span>&#34;<span>${status}</span>&#34;</span>
</code></pre>

      </div></div>
  </body>
</html>
