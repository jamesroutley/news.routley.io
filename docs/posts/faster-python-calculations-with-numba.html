<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pythonspeed.com/articles/numba-faster-python/">Original</a>
    <h1>Faster Python calculations with Numba</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      <p>Python is a slow language, so computation is best delegated to code written in something faster.
You can do this with existing libraries like NumPy and SciPy, but what happens when you need to implement a new algorithm, and you don’t want to <a href="https://pythonspeed.com/articles/rust-cython-python-extensions/">write code in a lower-level language</a>?</p>

<p>For certain types of computation, in particular array-focused code, the Numba library can significantly speed up your code.
Sometimes you’ll need to tweak it a bit, sometimes it’ll just work with no changes.
And when it works, it’s a very transparent speed fix.</p>

<p>In this article we’ll cover:</p>

<ul>
  <li>Why using NumPy on its own is sometimes not enough.</li>
  <li>The basics of using Numba.</li>
  <li>How Numba works, at a high-level, and the difference that makes to how your code runs.</li>
</ul>

<h2 id="when-numpy-doesnt-help">When NumPy doesn’t help</h2>

<p>Let’s say you have a very large array, and you want to calculate the monotonically increasing version: values can go up, but never down.
For example:</p>

<div><div><pre><code><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>]</span> <span>→</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span>
</code></pre></div></div>

<p>Here’s a straightforward in-place implementation:</p>

<div><div><pre><code><span>def</span> <span>monotonically_increasing</span><span>(</span><span>a</span><span>):</span>
    <span>max_value</span> <span>=</span> <span>0</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>a</span><span>)):</span>
        <span>if</span> <span>a</span><span>[</span><span>i</span><span>]</span> <span>&gt;</span> <span>max_value</span><span>:</span>
            <span>max_value</span> <span>=</span> <span>a</span><span>[</span><span>i</span><span>]</span>
        <span>a</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>max_value</span>
</code></pre></div></div>

<p>There’s a problem, though.
NumPy is fast because it can do all its calculations without calling back into Python.
Since this function involves looping in Python, we lose all the performance benefits of using NumPy.</p>

<p>For a 10,000,000-entry NumPy array, this functions takes 2.5 seconds to run on my computer.
Can we do better?</p>

<h2 id="numba-can-speed-things-up">Numba can speed things up</h2>

<p><a href="https://numba.readthedocs.io/">Numba</a> is a just-in-time compiler for Python specifically focused on code that runs in loops over NumPy arrays.
Exactly what we need!</p>

<p>All we have to do is add two lines of code:</p>

<div><div><pre><code><span>from</span> <span>numba</span> <span>import</span> <span>njit</span>

<span>@</span><span>njit</span>
<span>def</span> <span>monotonically_increasing</span><span>(</span><span>a</span><span>):</span>
    <span>max_value</span> <span>=</span> <span>0</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>a</span><span>)):</span>
        <span>if</span> <span>a</span><span>[</span><span>i</span><span>]</span> <span>&gt;</span> <span>max_value</span><span>:</span>
            <span>max_value</span> <span>=</span> <span>a</span><span>[</span><span>i</span><span>]</span>
        <span>a</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>max_value</span>
</code></pre></div></div>

<p>This runs in 0.19 seconds, about 13× faster; not bad for just reusing the same code!</p>

<p>Of course, it turns out that NumPy has a function that will do this already, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ufunc.accumulate.html"><code>numpy.maximum.accumulate</code></a>.
Using that, running only takes 0.03 seconds.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Runtime</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Python <code>for</code> loop</td>
      <td>2560ms</td>
    </tr>
    <tr>
      <td>Numba <code>for</code> loop</td>
      <td>190ms</td>
    </tr>
    <tr>
      <td><code>np.maximum.accumulate</code></td>
      <td>30ms</td>
    </tr>
  </tbody>
</table>

<h2 id="introducing-numba">Introducing Numba</h2>

<p>When you can find a NumPy or SciPy function that does what you want, problem solved.
But what if <code>numpy.maximum.accumulate</code> hadn’t existed?
At that point the other option if you wanted a fast result would be to <a href="https://pythonspeed.com/articles/rust-cython-python-extensions/">write some low-level code</a>, but that means switching programming languages, a more complex build system, and more complexity in general.</p>

<p>With Numba you can:</p>

<ul>
  <li>Run the same code both in normal Python, and in a faster compiled version, from inside the normal interpreter runtime.</li>
  <li>Easily and quickly iterate on algorithms.</li>
</ul>

<p>Numba parses the code, and then compiles it in a just-in-time manner depending on the inputs.
You will get different versions of the code depending on whether the input is an array of <code>u64</code> vs an array of floats, for example.</p>

<p>Numba can also target runtimes other than CPUs; you can <a href="https://numba.readthedocs.io/en/stable/cuda/index.html">run the code on a GPU</a>, for example.
Additionally, the above example is just the most minimal usage pattern for Numba; it has <a href="https://numba.readthedocs.io/en/stable/user/index.html">many more features covered in the documentation</a>.</p>

<h2 id="some-limitations-of-numba">Some limitations of Numba</h2>

<h3 id="the-one-time-cost-of-just-in-time-compilation">The one-time cost of just-in-time compilation</h3>

<p>The first time you call a function decorated with Numba, it will need to generate the appropriate machine code, which can take some time.
For example, we can use IPython’s <code>%time</code> command to measure how long it takes to run a Numba-decorated function:</p>

<div><div><pre><code><span>In</span> <span>[</span><span>1</span><span>]:</span> <span>from</span> <span>numba</span> <span>import</span> <span>njit</span>

<span>In</span> <span>[</span><span>2</span><span>]:</span> <span>@</span><span>njit</span>
   <span>...:</span> <span>def</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>):</span> <span>a</span> <span>+</span> <span>b</span>

<span>In</span> <span>[</span><span>3</span><span>]:</span> <span>%</span><span>time</span> <span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span>CPU</span> <span>times</span><span>:</span> <span>user</span> <span>320</span> <span>ms</span><span>,</span> <span>sys</span><span>:</span> <span>117</span> <span>ms</span><span>,</span> <span>total</span><span>:</span> <span>437</span> <span>ms</span>
<span>Wall</span> <span>time</span><span>:</span> <span>207</span> <span>ms</span>

<span>In</span> <span>[</span><span>4</span><span>]:</span> <span>%</span><span>time</span> <span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span>CPU</span> <span>times</span><span>:</span> <span>user</span> <span>17</span> <span>µs</span><span>,</span> <span>sys</span><span>:</span> <span>0</span> <span>ns</span><span>,</span> <span>total</span><span>:</span> <span>17</span> <span>µs</span>
<span>Wall</span> <span>time</span><span>:</span> <span>24.3</span> <span>µs</span>

<span>In</span> <span>[</span><span>5</span><span>]:</span> <span>%</span><span>time</span> <span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span>CPU</span> <span>times</span><span>:</span> <span>user</span> <span>8</span> <span>µs</span><span>,</span> <span>sys</span><span>:</span> <span>2</span> <span>µs</span><span>,</span> <span>total</span><span>:</span> <span>10</span> <span>µs</span>
<span>Wall</span> <span>time</span><span>:</span> <span>13.6</span> <span>µs</span>
</code></pre></div></div>

<p>The first call is extremely slow (milliseconds rather than microseconds )because it needs to compile the code; after that it runs quickly.</p>

<p>This is a one-time cost, per type of input.
For example, we’ll have to pay it again if we pass in floats:</p>

<div><div><pre><code><span>In</span> <span>[</span><span>8</span><span>]:</span> <span>%</span><span>time</span> <span>add</span><span>(</span><span>1.5</span><span>,</span> <span>2.5</span><span>)</span>
<span>CPU</span> <span>times</span><span>:</span> <span>user</span> <span>40.3</span> <span>ms</span><span>,</span> <span>sys</span><span>:</span> <span>1.14</span> <span>ms</span><span>,</span> <span>total</span><span>:</span> <span>41.5</span> <span>ms</span>
<span>Wall</span> <span>time</span><span>:</span> <span>41</span> <span>ms</span>

<span>In</span> <span>[</span><span>9</span><span>]:</span> <span>%</span><span>time</span> <span>add</span><span>(</span><span>1.5</span><span>,</span> <span>2.5</span><span>)</span>
<span>CPU</span> <span>times</span><span>:</span> <span>user</span> <span>16</span> <span>µs</span><span>,</span> <span>sys</span><span>:</span> <span>3</span> <span>µs</span><span>,</span> <span>total</span><span>:</span> <span>19</span> <span>µs</span>
<span>Wall</span> <span>time</span><span>:</span> <span>26</span> <span>µs</span>
</code></pre></div></div>

<blockquote>
  <p>There’s no reason to use Numba to add two numbers, but given the function does so little, this is a good demonstration of the unavoidable one-time compilation overhead.</p>
</blockquote>

<h3 id="a-different-implementation-of-python-and-numpy">A different implementation of Python and NumPy</h3>

<p>Numba re-implements a subset of Python, and a subset of the NumPy APIs.
This leads to potential issues:</p>

<ul>
  <li>Some features aren’t supported, both in the Python language and in NumPy APIs.</li>
  <li>Because Numba re-implements NumPy’s APIs from scratch, you may get:
    <ul>
      <li>Different performance behavior, due to using a different algorithm.</li>
      <li>Potentially, different results due to bugs.</li>
    </ul>
  </li>
</ul>

<p>In addition, when Numba fails to compile some code, my experience is that the error messages can often be difficult to understand.</p>

<h2 id="numba-vs-alternatives">Numba vs. alternatives</h2>

<p>How does Numba compare to other options?</p>

<ul>
  <li>If you can use fast NumPy or Scipy APIs exclusively, you can write your code in Python and get the benefit and speed of a low-level compiled language.
Sometimes you will need to revert to slow <code>for</code> loops in Python, which will lose much of the performance benefits.</li>
  <li>You can write code in a <a href="https://pythonspeed.com/articles/rust-cython-python-extensions/">low-level language directly</a>; this means you can optimize all your code paths, but you are now leaving Python for a different language.</li>
  <li>With Numba, you can get fast code from regular Python <code>for</code> loops, but you’re limited in which language features and NumPy APIs you can use.</li>
</ul>

<p>The nicest thing about Numba is how easy it is to try out.
So whenever you have a slow <code>for</code> loop doing some math, give Numba a spin; with any luck it’ll speed things with just two lines of code.</p>

  </div></div>
  </body>
</html>
