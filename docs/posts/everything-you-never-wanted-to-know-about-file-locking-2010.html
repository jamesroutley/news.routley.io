<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://apenwarr.ca/log/20101213">Original</a>
    <h1>Everything you never wanted to know about file locking (2010)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><b>Everything you never wanted to know about file locking</b></p>
<p>(Foreshadowing: I found a bug in MacOS X 10.6&#39;s fcntl(F_SETLK) locking that
could cause corruption of sqlite databases.  To see if your system has the
bug, compile and run <a href="https://apenwarr.ca/diary/locky.c">locky.c</a>.)</p>
<p>I&#39;ve never previously had the (mis)fortune of writing a program that relied
on file locking.  Well, I&#39;ve used databases and gdbm and whatnot, and they
&#34;use&#34; file locking, but they&#39;ve always hidden it behind an API, so I&#39;ve
never had to actually lock my own files.</p>
<p>I heard file locking is terribly messy and arcane and varies wildly between
operating systems, even between different Unix systems; even between
different versions of the same system (like Linux).  After some
experimentation, I can confirm: it really is that arcane, and it really is
that variable between systems, and it really is untrustworthy.  I&#39;m normally
a pessimist when it comes to computers, but Unix file locking APIs have
actually outdone even my own pessimism: they&#39;re worse than I ever imagined.</p>
<p>Other than simple lockfiles, which I won&#39;t go into (but which you might just
want to use from now on, after reading this article :)), there are three
Unix file locking APIs: flock(), fcntl(), and lockf().</p>
<p><b>flock() locking</b></p>
<p>flock() is the simplest sort of lock.  According to my Linux man page, it
dates back to BSD.  It is <em>not</em> standardized by POSIX, which means that some
Unix systems (probably SysV-related ones, I guess) don&#39;t support flock().</p>
<p>flock() locks an entire file at a time.  It supports shared locks (LOCK_SH:
multiple people can have the file locked for read at the same time) and
exclusive locks (LOCK_EX: only one person can make an exclusive lock on the
file; shared and exclusive locks are not allowed to coexist).  If you
learned about concurrency in textbooks, flock() locks are &#34;reader/writer&#34;
locks.  A shared lock is a reader lock, and an exclusive lock is a writer
lock.</p>
<p>According to the Linux man page for flock(), flock() does not work over NFS.</p>
<p>Upgrading from a shared flock() lock to an exclusive one is racy.  If you
own a shared lock, then trying to upgrade it to an exclusive lock, behind
the scenes, actually involves releasing your lock and acquiring a new one. 
Thus, you can&#39;t be guaranteed that someone else hasn&#39;t acquired the
exclusive lock, written to the file, and unlocked it before your attempt at
upgrading the lock returns.  Moreover, if you try to upgrade from shared to
exclusive in a non-blocking way (LOCK_NB), you might lose your shared lock
entirely.</p>
<p>Supposedly, flock() locks persist across fork() and (unlike fcntl locks, see
below) won&#39;t disappear if you close unrelated files.  <b>HOWEVER</b>, you
can&#39;t depend on this, because some systems - notably earlier versions of
Linux - emulated flock() using fcntl(), which has totally different
semantics.  If you fork() or if you open the same file more than once,
you should assume the results with flock() are undefined.</p>
<p><b>fcntl() locking</b></p>
<p>POSIX standardized the fcntl(F_SETLK) style of locks, so you should
theoretically find them on just about any Unix system.  The Linux man page
claims that they&#39;ve been around since 4.3BSD and SVr4.</p>
<p>fcntl() locks are much more powerful than flock() locks.  Like flock(),
there are both shared and exclusive locks.  However, unlike flock(), each
lock has a byte range associated with it: different byte ranges
are completely independent.  One process can have an exclusive lock on byte
7, and another process can have an exclusive lock on byte 8, and several
processes can have a shared lock on byte 9, and that&#39;s all okay.</p>
<p>Note that calling them &#34;byte ranges&#34; is a bit meaningless; they&#39;re really
just numbers.  You can lock bytes past the end of the file, for example. 
You could lock bytes 9-12 and that might mean &#34;records 9-12&#34; if you want,
even if records have variable length.  The meaning of a fcntl() byte range
is up to whoever defines the file format you&#39;re locking.</p>
<p>As with all the locks discussed in this article, these byterange locks are
&#34;advisory&#34; - that is, you can read and write the file all day long even if
someone other than you has an exclusive lock.  You&#39;re just not supposed to
do that.  A properly written program will try to acquire the lock first, at
which time it will be &#34;advised&#34; by the kernel whether everything is good or
not.</p>
<p>The locks are advisory, which is why the byte ranges don&#39;t have to refer to
actual bytes.  The person acquiring the lock can interpret it however you
want.</p>
<p>fcntl() locks are supposedly supported by NFSv3 and higher, but
different kernels do different random things with it.  Some kernels just
lock the file locally, and don&#39;t notify the server.  Some notify the server,
but do it wrong.  So you probably can&#39;t trust it.</p>
<p>According to various pages on the web that I&#39;ve seen, fcntl() locks don&#39;t
work on SMB (Windows file sharing) filesystems mounted on MacOS X.  I don&#39;t
know if this is still true in the latest versions of MacOS; I also don&#39;t
know if it&#39;s true on Linux.  Note that since flock() doesn&#39;t work on NFS,
and fcntl() doesn&#39;t work on SMB fs, that there is no locking method that
works reliably on all remote filesystems.</p>
<p>It doesn&#39;t seem to be explicitly stated anywhere, but it seems that fcntl()
shared locks can be upgraded atomically to fcntl() exclusive locks.  That
is, if you have a shared lock and you try to upgrade it to an exclusive
lock, you can do that without first releasing your shared lock.  If you
request a non-blocking upgrade and it fails, you still have your shared
lock.</p>
<p>(Trivia: sqlite3 uses fcntl() locks, but it never uses <em>shared</em> fcntl()
locks.  Instead, it exclusively locks a random byte inside a byterange. 
This is apparently because some versions of Windows don&#39;t understand shared
locks.  As a bonus, it also doesn&#39;t have to care whether upgrading a lock
from shared to exclusive is atomic or not.  Update 2010/12/13: specifically,
pre-NT versions of Windows had LockFile, but not LockFileEx.)</p>
<p>fcntl() locks have the handy feature of being able to tell you which pid
owns a lock, using F_GETLK.  That&#39;s pretty cool - and potentially useful for
debugging - although it might be meaningless on NFS, where the pid could be
on another computer.  I don&#39;t know what would happen in that case.</p>
<p>fcntl() locks have two very strange behaviours.  The first is merely an
inconvenience: unlike nearly everything else about a process, fcntl() locks
are not shared across fork().  That means if you open a file, lock some byte
ranges, and fork(), the child process will still have the file, but it won&#39;t
own any locks.  The parent will still own all the locks.  This is weird, but
manageable, once you know about it.  It also makes sense, in a perverse sort
of way: this makes sure that no two processes have an exclusive lock on the
same byterange of the same file.  If you think about it, exclusively locking
a byte range, then doing fork(), would mean that <em>two</em> processes have the
same exclusive lock, so it&#39;s not all that exclusive any more, is it?</p>
<p>Maybe you don&#39;t care about these word games, but one advantage of this
absolute exclusivity guarantee is that fcntl() locks can detect deadlocks. 
If process A has a lock on byte 5 and tries to lock byte 6, and process B
has a lock on byte 6 and tries to lock byte 5, the kernel can give you
EDEADLK, which is kind of cool.  If it were possible for more than one
process to own the same exclusive locks, the algorithm for this would be
much harder, which is probably why flock() locks can&#39;t do it.</p>
<p>The second strange behaviour of fcntl() locks is this: the lock doesn&#39;t
belong to a file descriptor, it belongs to a (pid,inode) pair.  Worse, if
you close <em>any</em> fd referring to that inode, it releases all your locks on
that inode.  For example, let&#39;s say you open /etc/passwd and lock some
bytes, and then call getpwent() in libc, which usually opens /etc/passwd,
reads some stuff, and closes it again.  That process of opening /etc/passwd
and closing it - which has nothing to do with your existing fd open on
/etc/passwd - will cause you to lose your locks!</p>
<p>That behaviour is certifiably insane, and there&#39;s no possible justification
for why it should work that way.  But it&#39;s how it&#39;s always worked, and POSIX
standardized it, and now you&#39;re stuck with it.</p>
<p>An even worse example: let&#39;s say you have two sqlite databases, db1 and db2. 
But let&#39;s say you&#39;re being mean, and you actually make db1 a hardlink to
db2, so they&#39;re actually the same inode.  If you open both databases in
sqlite at the same time, then close the second one, all your open sqlite
locks on the first one will be lost!  Oops!  Except, actually, the <a href="http://www.sqlite.org/src/artifact/0240c5b547b4cf585c8cac351a95c3e85ce00772">sqlite
people have already thought of this</a>, and it does the right thing.  But if
you&#39;re writing your own file locking routines, beware.</p>
<p>(Update 2014/06/09: the primary sqlite developer emailed me to say that they
recently found a problem with the technique sqlite uses.  They use global
variables to make sure lock objects are shared across all sqlite databases,
even if you have two open on the same inode, even if that inode has more
than one filename, so that they can bypass this insanity.  But this
mechanism is defeated if you manage to link your program with <em>two</em> copies
of sqlite which can&#39;t see each other (eg. in two shared libraries with no
sqlite symbols exported) and which access the same database.  Don&#39;t do
that.)</p>
<p>So anyway, beware of that insane behaviour.  Also beware of flock(), which
on some systems is implemented as a call to fcntl(), and thus inherits the
same insane behaviour.</p>
<p>Bonus insanity feature: the struct you use to talk to fcntl() locks is
called &#39;struct flock&#39;, even though it has nothing to do with flock().  Ha
ha!</p>
<p><b>lockf() locking</b></p>
<p>lockf() is also standardized by POSIX.  The Linux man page also mentions
SVr4, but it doesn&#39;t mention BSD, which presumably means that some versions
of BSD don&#39;t do lockf().</p>
<p>POSIX is also, apparently, unclear on whether lockf() locks are the same
thing as fcntl() locks or not.  On Linux and MacOS, they are documented to
be the same thing.  (In fact, lockf() is a libc call on Linux, not a system
call, so we can assume it makes the same system calls as fcntl().)</p>
<p>The API of lockf() is a little easier than fcntl(), because you don&#39;t have
to mess around with a struct.  However, there is no way to query a lock to
find out who owns it.</p>
<p>Moreover, lockf() may not be supported by pre-POSIX BSD systems, it seems,
so this little bit of convenience also costs you in portability.  I
recommend you avoid lockf().</p>
<p><b>Interaction between different lock types</b></p>
<p>...is basically undefined.  Don&#39;t use multiple types of locks - flock(),
fcntl(), lockf() - on the same file.</p>
<p>The MacOS man pages for the three functions proudly proclaim that on MacOS
(and maybe on whatever BSD MacOS is derived from), the three types of locks
are handled by a unified locking implementation, so in fact, you <em>can</em> mix
and match different lock types on the same file.  That&#39;s great, but on other
systems, they <em>aren&#39;t</em> unified, so doing so will just make your program fail
strangely on other systems.  It&#39;s non-portable, and furthermore, there&#39;s no
reason to do it.  So don&#39;t.</p>
<p>When you define a new file format that uses locking, be sure to document
exactly which kind of locking you mean: flock(), fcntl(), or lockf().  And
don&#39;t use lockf().</p>
<p><b>Mandatory locking</b></p>
<p>Mandatory locks are the ones that are self-enforcing: if I have an exclusive
lock on (a section of) the file, you can&#39;t read or write it until I release
the lock, even if your program doesn&#39;t understand locks.  It sounds good,
but it&#39;s bad.</p>
<p>Stay far, far away, for total insanity lies in wait.</p>
<p>Seriously, don&#39;t do it.  Advisory locks are the only thing that makes any
sense whatsoever.  In any application.  I mean it.</p>
<p>Need another reason?  The docs say that mandatory locking in Linux is
&#34;unreliable.&#34;  In other words, they&#39;re not as mandatory as they&#39;re
documented to be.  &#34;Almost mandatory&#34; locking?  Look.  Just stay away.</p>
<p>Still not convinced?  Man, you really must like punishment.  Look, imagine
someone is holding a mandatory lock on a file, so you try to read() from it
and get blocked.  Then the other person releases their lock, and your read() finishes, but
some third person reacquires the lock.  You fiddle with your block,
modify it, and try to write() it back, but you get held up for a bit,
because the third person holding the lock isn&#39;t done yet.  They do their own write() to
that section of the file, and releases their lock, so your write() promptly
resumes and overwrites what they just did.</p>
<p>What good does that do anyone?  Come on.  If you want locking to do you any
good whatsoever, you&#39;re just going to have to acquire and release your own
locks.  Just do it.  If you don&#39;t, you might as well not be using locks at
all, because your program will be prone to horrible race conditions and
they&#39;ll be extra hard to find, because mandatory locks will make it <em>mostly</em>
seem to work right.  If there&#39;s one thing I&#39;ve learned about programming,
it&#39;s that &#34;mostly right&#34; programs are <em>way</em> worse than &#34;entirely wrong&#34;
programs.  You don&#39;t want to be mostly right.  Don&#39;t use mandatory locks.</p>
<p><b>Bonus feature: file locking in python</b></p>
<p>python has a module called &#34;fcntl&#34; that actually includes - or rather, seems
to include - all three kinds of locks: flock(), fcntl(), and lockf().  If
you like, <a href="http://svn.python.org/view/python/trunk/Modules/fcntlmodule.c?view=markup">follow
along in the python source code</a> to see how it works.</p>
<p>However, all is not as it seems.  First of all, flock() doesn&#39;t exist on all
systems, apparently.  If you&#39;re on a system without flock(), python will
still provide a fcntl.flock() function...  by calling fcntl() for you.  So
you have no idea if you&#39;re actually getting fcntl() locks or flock() locks. 
Bad idea.  Don&#39;t do it.</p>
<p>Next is fcntl.fcntl().  Although it pains me to say it, you can&#39;t use this
one either.  That&#39;s because it takes a binary data structure as a parameter. 
You have to create that data structure using struct.pack(), and parse it
using struct.unpack().  No problem, right?  Wrong.  How do you know what the
data structure looks like?  The <a href="http://docs.python.org/library/fcntl.html">python fcntl module
docs</a> outright lie to you here, by providing an example of how to build
the struct flock...  but they just made assumptions about what it looks
like.  Those assumptions are definitely wrong if your system has 64-bit file
offset support, which most of them do nowadays, so trying to use the example
will just give an EINVAL.  Moreover, POSIX doesn&#39;t guarantee that struct
flock won&#39;t have other fields before/after the documented ones, or that the
fields will be in a particular order, so even without 64-bit file offsets,
your program is completely non-portable.  And python doesn&#39;t offer any other
option for generating that struct flock, so the whole function is useless. 
Don&#39;t do it.  (You can still safely use fcntl.fcntl() for
non-locking-related features, like F_SETFD.)</p>
<p>The only one left is fcntl.lockf().  This is the one you should use.  Yeah,
I know, up above I said you should avoid lockf(), because BSD systems might
not have it, right?  Well yeah, but that&#39;s C lockf(), not python&#39;s
fcntl.lockf().  The python fcntl module documentation says of fcntl.lockf(),
&#34;This is essentially a wrapper around the fcntl() locking calls.&#34;  But
looking at the source, that&#39;s not quite true: in fact, it is <em>exactly</em> a
wrapper around the fcntl() locking calls.  fcntl.lockf() doesn&#39;t call C
lockf() at all!  It just fills in a struct flock and then calls fcntl()!</p>
<p>And that&#39;s exactly what you want.  In short:</p>
<ul>
<li>in C, use fcntl(), but avoid lockf(), which is not necessarily the same thing.</li>
<li>in python, use fcntl.lockf(), which is the same thing as fcntl() in C.</li>
</ul>
<p>(Unfortunately, although calling fnctl.lockf() actually uses fcntl() locks,
there is no way to run F_GETLK, so you can&#39;t find out which pid owns the
lock.)</p>
<p>Bonus insanity feature: instead of using the C lockf() constants (F_LOCK,
F_TLOCK, F_ULOCK, F_TEST), fcntl.lockf() actually uses the C flock()
constants (LOCK_SH, LOCK_EX, LOCK_UN, LOCK_NB).  There is no conceivable
reason for this; it literally just takes in the wrong contants, and converts
them to the right ones before calling fcntl().</p>
<p>So that means python gives you three locks in one! The constants from
flock(), the functionality of fcntl(), and the name lockf().  Thanks,
python, for making my programming world so simple and easy to unravel.</p>
<p><b>Epilogue</b></p>
<p>I learned all this while writing a program (in python, did you
guess?) that uses file locking to control concurrent access to files. 
Naturally, I wanted to pick exactly the right kind of locks to solve my
problem.  Using the logic above, I settled on fcntl() locks, which in my
python program means calling fcntl.lockf().</p>
<p>So far, so good.  After several days of work - darn it, I really hate
concurrent programming - I got it all working perfectly.  On Linux.</p>
<p>Then I tried to port my program to MacOS.  It&#39;s python, so porting was
pretty easy - ie. I didn&#39;t change anything - but the tests failed.  Huh? 
Digging deeper, it seems that some subprocesses were acquiring a lock, and
sometime later, they just didn&#39;t own that lock anymore.  I thought it might
be one of the well-known fcntl() weirdnesses.  Maybe I fork()ed, or maybe I
opened/closed the file without realizing it.  But no, it only happens when
<em>other</em> processes are locking byteranges on the same file.  It appears the
MacOS X (10.6.5 in my test) kernel is missing a mutex somewhere.</p>
<p>I wrote a <a href="https://apenwarr.ca/diary/locky.c">minimal test case</a>
and filed a bug with Apple.  If you work at Apple, you can find my bug
report as number 8760769.</p>
<p>Dear Apple: please fix it.  As far as I know, with this bug in place, any
program that uses fcntl() locks is prone to silent file corruption.  That
includes anything using sqlite.</p>
<p><b>Super Short Summary</b></p>
<ul>
<li>don&#39;t use flock() (python: fcntl.flock()) because it&#39;s not in POSIX and it doesn&#39;t work over NFS.</li>
<li>don&#39;t use lockf() (python: does not exist) because it&#39;s not in BSD, and probably just wraps fcntl().</li>
<li>don&#39;t use fcntl() (python: fcntl.lockf()) because it doesn&#39;t work over SMB on MacOS, and actually, on MacOS it doesn&#39;t work right at all.</li>
</ul>
<p>Oh, and by the way, none of this applies on win32.</p>
<p>Are we having fun yet?  I guess lockfiles are the answer after all.</p>
<p>I bet you&#39;re really glad you read this all the way to the end.</p>
<p><b>Update 2010/12/15:</b> Via cpirate, an interesting <a href="http://www.samba.org/samba/news/articles/low_point/tale_two_stds_os2.html">article
by Jeremy Allison of the samba project</a> that discusses a bit of how
Unix&#39;s insane locking came to be standardized.</p>
<p><b>Update 2019/01/02:</b> Progress! In 2015, Linux gained a new kind of
fcntl() lock, F_OFD_SETLK (&#34;Open File Description&#34; locks), which work the
way you might have expected fcntl() locks to work in the first place.  Of
course, for backward compatibility, they can never change how the old way
worked, so they had to add a new API, which unfortunately means every
program will have to choose between a new+sane API and an old+portable API.
Hopefully other OSes will copy this feature eventually.  You can read about
it here: <a href="https://lwn.net/Articles/640404/">https://lwn.net/Articles/640404/</a>.</p>
<p>Meanwhile, Windows 10 WSL (&#34;Windows Subsystem for Linux&#34;) has come out, and
it &#34;implements&#34; fcntl() locks by just always returning success, leading to
file corruption everywhere.  The above <a href="https://apenwarr.ca/diary/locky.c">locky.c</a>
can detect this failure as well.</p>
<p>And, some time after this article was written, MacOS was fixed, so now
fcntl() locks seem to work as expected.  Yay!</p>




</div></div>
  </body>
</html>
