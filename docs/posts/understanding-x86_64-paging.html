<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zolutal.github.io/understanding-paging/">Original</a>
    <h1>Understanding x86_64 Paging</h1>
    
    <div id="readability-page-1" class="page"><section itemprop="text">
        
        <p>I’ve spent quite a lot of time messing with x86_64 page tables, understanding address translation is not easy and when I started learning about it I felt like a lot of the material out there on how it works was hard for me to wrap my head around. So in this blog post I am going to attempt to provide a kind of “what I wish I had when learning about paging”.</p>

<p>Quick note, I’ll only be discussing paging in the context of PML4 (Page Map Level 4) since it’s currently the dominant x86_64 paging scheme and probably will be for a while still.</p>

<h2 id="environment">environment</h2>

<p>Its not necessary, but I recommend that you have a Linux kernel debugging setup with QEMU + gdb prepared to follow along with. If you’ve never done this, maybe give this repo a shot: <a href="https://github.com/deepseagirl/easylkb">easylkb</a> (I’ve never used it, but I’ve heard good things) or if you want to avoid having to setup the environment yourself, the practice mode on any of the Kernel Security challenges on <a href="https://pwn.college/">pwn.college</a> would also work (<code>vm connect</code> and <code>vm debug</code> are the commands to know).</p>

<p>I suggest this because I think running the same commands I am on your own and being able to perform a page walk based on what you can see in gdb is a good test of understanding.</p>

<h2 id="wtf-is-a-page">wtf is a page</h2>

<p>On x86_64 a page is a 0x1000 byte slice of memory which is 0x1000 byte aligned.</p>

<p>This is the reason why if you ever look at /proc/&lt;pid&gt;/maps you see that all the address ranges will start and end with an address ending with 0x000 because the minimum size of a memory mapping on x86_64 is page size (0x1000 bytes) and pages are required to be ‘page aligned’ (the last 12 bits must be zero).</p>

<p>A ‘Virtual Page’ will be resolved to a single ‘Physical Page’ (aka ‘Page Frame’) by your MMU though many Virtual Pages may refer to the same Physical Page.</p>

<h2 id="what-is-in-a-virtual-address">what is in a virtual address</h2>

<p>PML4, as one might guess, has four level of paging structures, these paging structures are called ‘Page Tables’. A page table is a page-sized memory region which contains 512 8-byte page table entries. Each entry of a page table will refer to either the next level page table or to the final physical address a virtual address resolves to.</p>

<p>The entry from a page table that is used for address translation is based on the virtual address of the memory access. With 512 entries per level, that means 9-bits of the virtual address are used at every level to index into the corresponding page table.</p>

<p>Say we have an address like this:</p>

<p><code>0x7ffe1c9c9000</code></p>

<p>The last 12 bits of this address represent the offset within the physical page:</p>

<p><code>0x7ffe1c9c9000 &amp; 0xfff = 0x0</code></p>

<p>This means that once we determine the physical address of the page this virtual address resolves to, we will add zero to the result to get the final physical address.</p>

<p>After the last 12 bits, which is again just the offset within the final page, a virtual address is comprised of indicies into the page tables. As mentioned each level of paging uses 9 bits of the virtual address, so the lowest level of the paging structures, a Page Table, is indexed by the next 9 bits of the address (by bit masking with <code>&amp; 0x1ff</code> on the shifted value). For the following levels we just need to shift right by another nine bits each time and again mask off the lower nine bits as our index. Doing this for the address above gives us these indicies:</p>

<div><div><pre><code>Level 1, Page Table (PT):
Index = (0x7ffe1c9c9000 &gt;&gt; 12) &amp; 0x1ff = 0x1c9

Level 2, Page Middle Directory (PMD):
Index = (0x7ffe1c9c9000 &gt;&gt; 21) &amp; 0x1ff = 0x0e4

Level 3, Page Upper Directory (PUD):
Index = (0x7ffe1c9c9000 &gt;&gt; 30) &amp; 0x1ff = 0x1f8

Level 4, Page Global Directory (PGD):
Index = (0x7ffe1c9c9000 &gt;&gt; 39) &amp; 0x1ff = 0x0ff
</code></pre></div></div>

<h2 id="all-your-base">all your base</h2>

<p>Now that we know how to index into page tables and vaguely what they contain, where actually are they???</p>

<p>Well each thread of your CPU has a page table base register called <code>cr3</code>.</p>

<p><code>cr3</code> holds the physical address of the highest level of the paging structure, aka the Page Global Directory (PGD).</p>

<p>From gdb, when debugging the kernel, you can read the contents of <code>cr3</code> like this:</p>

<div><div><pre><code>gef➤  p/x $cr3
$1 = 0x10d664000
</code></pre></div></div>

<p>The <code>cr3</code> register can hold some additional information besides just the PGD address depending on what processor features are in use, so a more general way of getting the physical address of the PGD from the <code>cr3</code> register is to mask off the lower 12 bits of its contents like so:</p>

<div><div><pre><code>gef➤  p/x $cr3 &amp; ~0xfff
$2 = 0x10d664000
</code></pre></div></div>

<h2 id="page-table-entries">page table entries</h2>

<p>Lets look at what is at that physical address we got from <code>cr3</code> in gdb. The <code>monitor xp/...</code> command that is exposed to gdb by the QEMU Monitor lets us print out the physical memory of the vm and doing <code>monitor xp/512gx ...</code> will print the entire contents, all 512 entries, of the PGD referred to by <code>cr3</code>:</p>

<div><div><pre><code>gef➤  monitor xp/512gx 0x10d664000
...
000000010d664f50: 0x0000000123fca067 0x0000000123fc9067
000000010d664f60: 0x0000000123fc8067 0x0000000123fc7067
000000010d664f70: 0x0000000123fc6067 0x0000000123fc5067
000000010d664f80: 0x0000000123fc4067 0x0000000123fc3067
000000010d664f90: 0x0000000123fc2067 0x000000000b550067
000000010d664fa0: 0x000000000b550067 0x000000000b550067
000000010d664fb0: 0x000000000b550067 0x0000000123fc1067
000000010d664fc0: 0x0000000000000000 0x0000000000000000
000000010d664fd0: 0x0000000000000000 0x0000000000000000
000000010d664fe0: 0x0000000123eab067 0x0000000000000000
000000010d664ff0: 0x000000000b54c067 0x0000000008c33067
</code></pre></div></div>

<p>This produces a lot of output and most of it is zero, so I’m only including the tail of the output here.</p>

<p>This output probably doesn’t mean much to you yet, but we can observe some patterns in the data, lots of the 8-byte entries end in <code>0x67</code>, for example.</p>

<h2 id="decoding-a-pgd-entry">decoding a PGD entry</h2>

<p>From the PGD output above, lets take the PGD entry at <code>0x000000010d664f50</code> with value <code>0x0000000123fca067</code> as an example to see how to decode an entry.</p>

<p>and lets do this with the binary representation of that entry’s value:</p>

<div><div><pre><code>gef➤  p/t 0x0000000123fca067
$6 = 100100011111111001010000001100111
</code></pre></div></div>

<p>Here is a little diagram to show what each bit in the entry represents:</p>

<div><div><pre><code>~ PGD Entry ~                                                   Present ──────┐
                                                            Read/Write ──────┐|
                                                      User/Supervisor ──────┐||
                                                  Page Write Through ──────┐|||
                                               Page Cache Disabled ──────┐ ||||
                                                         Accessed ──────┐| ||||
                                                         Ignored ──────┐|| ||||
                                                       Reserved ──────┐||| ||||
┌─ NX          ┌─ Reserved                             Ignored ──┬──┐ |||| ||||
|┌───────────┐ |┌──────────────────────────────────────────────┐ |  | |||| ||||
||  Ignored  | ||               PUD Physical Address           | |  | |||| ||||
||           | ||                                              | |  | |||| ||||
0000 0000 0000 0000 0000 0000 0000 0001 0010 0011 1111 1100 1010 0000 0110 0111
       56        48        40        32        24        16         8         0
</code></pre></div></div>

<p>and here’s a key for what each of those label mean:</p>

<ul>
  <li>NX (Not Executable) – if this bit is set, no memory mapping that is a descendant of this PGD entry will be executable.</li>
  <li>Reserved – these values must be zero.</li>
  <li>PUD Physical Address – the physical address of the PUD associated with this PGD entry.</li>
  <li>Accessed –  If any pages referred to by this entry or its descendants, this bit will be set by the MMU, and can be cleared by the OS.</li>
  <li>Page Cache Disabled (PCD) – pages descendant of this PGD entry should not enter the CPU’s cache hierarchy, sometimes also called the ‘Uncacheable’ (UC) bit.</li>
  <li>Page Write Through (WT) – writes to pages descendant of this PGD entry should immediately write to RAM rather than buffering writes to CPU cache before eventually updating RAM.</li>
  <li>User/Supervisor – if this bit is unset, pages descendant of this PGD cannot be accessed unless in supervisor mode.</li>
  <li>Read/Write – if this bit is unset, pages descendant of this PGD cannot be written to.</li>
  <li>Present – if this bit is unset then the processor will not use this entry for address translation and none of the other bits will apply.</li>
</ul>

<p>The bits that we really care about here are the the Present bit, the ones representing the physical address of the next level of the paging structures, the PUD Physical Address bits, and the permission bits: NX, User/Supervisor, and Read/Write.</p>

<ul>
  <li>The Present bit is super important because without it set the rest of the entry is ignored.</li>
  <li>The PUD Physical Address lets us continue page walking by telling us where the physical address of the next level of the paging structures is at.</li>
  <li>The Permission bits all apply to pages which are descendants of the PGD entry and determine how those pages are able to be accesssed.</li>
</ul>

<p>The remaining bits are not as important for our purposes:</p>
<ul>
  <li>The Accessed bit is set if the entry was used in translating a memory access, its not important for page walking.</li>
  <li>Page Cache Disabled and Page Write Through are not used for normal memory mappings and do not affect page translation or permissions so lets ignore them.</li>
</ul>

<p>So decoding this entry, we learn:</p>

<p>The PUD is Present:</p>
<div><div><pre><code>gef➤  p/x 0x0000000123fca067 &amp; 0b0001
$18 = 0x1
</code></pre></div></div>
<p>The mappings in the PUD and below may be able to be Writable:</p>
<div><div><pre><code>gef➤  p/x 0x0000000123fca067 &amp; 0b0010
$19 = 0x2
</code></pre></div></div>
<p>The mappings in the PUD and below may be able to be User accessible:</p>
<div><div><pre><code>gef➤  p/x 0x0000000123fca067 &amp; 0b0100
$20 = 0x4
</code></pre></div></div>
<p>The PUD’s physical address ( bits (51:12] ) is <code>0x123fca000</code>:</p>
<div><div><pre><code>gef➤  p/x 0x0000000123fca067 &amp; ~((1ull&lt;&lt;12)-1) &amp; ((1ull&lt;&lt;51)-1)
$21 = 0x123fca000
</code></pre></div></div>
<p>The mappings in the PUD and below may be able to be Executable:</p>
<div><div><pre><code>gef➤  p/x 0x0000000123fca067 &amp; (1ull&lt;&lt;63)
$22 = 0x0
</code></pre></div></div>

<h2 id="decoding-entries-for-all-levels">decoding entries for all levels</h2>

<p>Now that we’ve seen how to decode a PGD entry, decoding the rest of the levels aren’t so much different, at least in the common case.</p>

<p>For all of these diagrams ‘X’ means the bit can be either zero or one, otherwise, if a bit is set to a specific value then that value is either required by the architecture or by the specific encoding shown by the diagram.</p>

<h3 id="pgd">PGD</h3>

<div><div><pre><code>~ PGD Entry ~                                                   Present ──────┐
                                                            Read/Write ──────┐|
                                                      User/Supervisor ──────┐||
                                                  Page Write Through ──────┐|||
                                               Page Cache Disabled ──────┐ ||||
                                                         Accessed ──────┐| ||||
                                                         Ignored ──────┐|| ||||
                                                       Reserved ──────┐||| ||||
┌─ NX          ┌─ Reserved                             Ignored ──┬──┐ |||| ||||
|┌───────────┐ |┌──────────────────────────────────────────────┐ |  | |||| ||||
||  Ignored  | ||               PUD Physical Address           | |  | |||| ||||
||           | ||                                              | |  | |||| ||||
XXXX XXXX XXXX 0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 0XXX XXXX
       56        48        40        32        24        16         8         0
</code></pre></div></div>

<p>This one we’ve already seen, I described it in detail in the previous section, but here it is without that specific PGD entry filled in.</p>

<h3 id="pud">PUD</h3>

<div><div><pre><code>~ PUD Entry, Page Size unset ~                                  Present ──────┐
                                                            Read/Write ──────┐|
                                                      User/Supervisor ──────┐||
                                                  Page Write Through ──────┐|||
                                               Page Cache Disabled ──────┐ ||||
                                                         Accessed ──────┐| ||||
                                                         Ignored ──────┐|| ||||
                                                      Page Size ──────┐||| ||||
┌─ NX          ┌─ Reserved                             Ignored ──┬──┐ |||| ||||
|┌───────────┐ |┌──────────────────────────────────────────────┐ |  | |||| ||||
||  Ignored  | ||               PMD Physical Address           | |  | |||| ||||
||           | ||                                              | |  | |||| ||||
XXXX XXXX XXXX 0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 0XXX XXXX
       56        48        40        32        24        16         8         0
</code></pre></div></div>

<p>As you can see the diagram above for the PUD is very similar to the one for the PGD, the only difference is the introduction of the ‘Page Size’ bit. The Page Size bit being set changes how we need to interpret a PUD entry quite a lot. For this diagram we are assuming it is unset, which is the most common case.</p>

<h3 id="pmd">PMD</h3>

<div><div><pre><code>~ PMD Entry, Page Size unset ~                                  Present ──────┐
                                                            Read/Write ──────┐|
                                                      User/Supervisor ──────┐||
                                                  Page Write Through ──────┐|||
                                               Page Cache Disabled ──────┐ ||||
                                                         Accessed ──────┐| ||||
                                                         Ignored ──────┐|| ||||
                                                      Page Size ──────┐||| ||||
┌─ NX          ┌─ Reserved                             Ignored ──┬──┐ |||| ||||
|┌───────────┐ |┌──────────────────────────────────────────────┐ |  | |||| ||||
||  Ignored  | ||                PT Physical Address           | |  | |||| ||||
||           | ||                                              | |  | |||| ||||
XXXX XXXX XXXX 0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 0XXX XXXX
       56        48        40        32        24        16         8         0
</code></pre></div></div>

<p>Again, the PMD diagram is very similar to the previous diagram, and like with the PUD entry, we are ignoring the Page Size bit for now.</p>

<h3 id="pt">PT</h3>

<div><div><pre><code>~ PT Entry ~                                                    Present ──────┐
                                                            Read/Write ──────┐|
                                                      User/Supervisor ──────┐||
                                                  Page Write Through ──────┐|||
                                               Page Cache Disabled ──────┐ ||||
                                                         Accessed ──────┐| ||||
┌─── NX                                                    Dirty ──────┐|| ||||
|┌───┬─ Memory Protection Key              Page Attribute Table ──────┐||| ||||
||   |┌──────┬─── Ignored                               Global ─────┐ |||| ||||
||   ||      | ┌─── Reserved                          Ignored ───┬─┐| |||| ||||
||   ||      | |┌──────────────────────────────────────────────┐ | || |||| ||||
||   ||      | ||            4KB Page Physical Address         | | || |||| ||||
||   ||      | ||                                              | | || |||| ||||
XXXX XXXX XXXX 0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX
       56        48        40        32        24        16         8         0
</code></pre></div></div>

<p>At the Page Table entry things get more interesting, there are some new fields/attributes that weren’t there in the previous levels.</p>

<p>Those new fields/attributes are:</p>

<ul>
  <li>Memory Protection Key (MPK or PK): This is an x86_64 extension that allows assigning a 4-bit keys to pages which can be used to configure memory permissions for all pages with that key.</li>
  <li>Global: This has to do with how the TLB (Translation Lookaside Buffer, the MMU’s cache for virtual to physical address translations) caches the translation for th page, this bit being set means the page will not be flushed from the TLB on context switch, this is commonly enabled on Kernel pages to reduce TLB misses.</li>
  <li>Page Attribute Table (PAT): If set, the MMU should consult the Page Attribute Table MSR when determining whether the ‘Memory Type’ of the page, e.g. whether this page is ‘Uncacheable’, ‘Write Through’, or one of a few other memory types.</li>
  <li>Dirty: This bit is similar to the accessed bit, it gets set by the MMU if this page was written to and must be reset by the OS.</li>
</ul>

<p>None of these actually affect the address translation itself, but the configuration of the Memory Protection Key can mean that the expected memory access permissions for the page referred to by this entry may be stricter than what is encoded by the entry itself.</p>

<p>Unlike the previous levels, since this is the last level, the entry holds the final physical address of the page associated with the virtual address we are translating. Once you apply a bit-mask to get the physical address bytes and add the last 12 bits of the original virtual address (the offset within the page), you have your physical address!</p>

<p>Hopefully, this doesn’t seem so bad, the general case of page walking is just a few steps:</p>
<ul>
  <li>Convert the virtual address to indicies and a page offset by shifting the address and applying bitmasks</li>
  <li>Read <code>cr3</code> to get the physical address of the PGD</li>
  <li>For each level until the last:
    <ul>
      <li>Use the indicies calculated from the virtual address to know what entry from the page table to use</li>
      <li>Apply a bitmask to the entry to get the physical address of the next level</li>
    </ul>
  </li>
  <li>On the final level, again find the entry corresponding with the index from the virtual address</li>
  <li>Apply a bitmask to get the physical address of the page associated with the virtual address</li>
  <li>Add offset within the page from the virtual address to the page’s physical address</li>
  <li>Done!</li>
</ul>

<h2 id="hugeify">hugeify</h2>

<p>As mentioned, the previous diagrams for the PUD and PMD are for the common case, when the Page Size bit is not set.</p>

<p>So, what about when it is set?</p>

<p>When it is set that is effectively telling the MMU, pack it up, we’re done here, don’t keep page walking, the current entry holds the physical address of the page we are looking for.</p>

<p>But there is a bit more to it than that, the physical address of the page in entries where the Page Size bit is set isn’t for a normal 4KB (0x1000 byte) page, it is a ‘Huge Page’ which comes in two variants: 1GB Huge Pages and 2MB Huge Pages.</p>

<p>When a PUD entry has the Page Size bit set then it refers to a 1GB Huge Page, and when a PMD has the Page Size bit set it refers to a 2MB Huge Page.</p>

<p>But where do the 1GB and 2MB numbers come from?</p>

<p>Each page table level holds up to 512 entries, that means a PT can refer to at most 512 pages and <code>512 * 4KB = 2MB</code>. So a Huge Page at the PMD level effectively means that the entry refers to a page that is the same size as a full PT.</p>

<p>Extending this to the PUD level, we just multiply by 512 again to get the size of a full PMD that has full PTs: <code>512 * 512 * 4KB = 1GB</code>.</p>

<h3 id="huge-page-pud">Huge Page PUD</h3>

<div><div><pre><code>~ PUD Entry, Page Size set ~                                     Present ─────┐
                                                             Read/Write ─────┐|
                                                       User/Supervisor ─────┐||
                                                   Page Write Through ─────┐|||
                                                Page Cache Disabled ─────┐ ||||
                                                          Accessed ─────┐| ||||
                                                            Dirty ─────┐|| ||||
┌─── NX                                                Page Size ─────┐||| ||||
|┌───┬─── Memory Protection Key                         Global ─────┐ |||| ||||
||   |┌──────┬─── Ignored                             Ignored ───┬─┐| |||| ||||
||   ||      | ┌─── Reserved           Page Attribute Table ───┐ | || |||| ||||
||   ||      | |┌────────────────────────┐┌───────────────────┐| | || |||| ||||
||   ||      | || 1GB Page Physical Addr ||      Reserved     || | || |||| ||||
||   ||      | ||                        ||                   || | || |||| ||||
XXXX XXXX XXXX 0XXX XXXX XXXX XXXX XXXX XX00 0000 0000 0000 000X XXXX 1XXX XXXX
       56        48        40        32        24        16         8         0
</code></pre></div></div>

<p>When the page size bit is set notice that the PUD entry looks more like a PT entry than a normal PUD entry, which makes sense because it is also referring to a page rather than a page table.</p>

<p>There are some distinctions from a PT entry though:</p>
<ol>
  <li>The Page Size bit is where the Page Attribute Table (PAT) bit is at on a PT, so the PAT bit is relocated to bit 12.</li>
  <li>The physical address of a 1GB Huge Page is required to have 1GB alignment in physical memory, this is why the new reserved bits exist and why bit 12 is able to be repurposed as the PAT bit.</li>
</ol>

<p>Overall, not too much new here, the only other differences when dealing with huge pages really is that a different bitmask needs to be applied to the address to get the bits for the physical address of the page, also the 1GB alignment means when calculating the physical address of a virtual address within the page we need to use a mask based on 1GB alignment instead of 4KB alignment.</p>

<h3 id="huge-page-pmd">Huge Page PMD</h3>

<div><div><pre><code>~ PMD Entry, Page Size set ~                                     Present ─────┐
                                                             Read/Write ─────┐|
                                                       User/Supervisor ─────┐||
                                                   Page Write Through ─────┐|||
                                                Page Cache Disabled ─────┐ ||||
                                                          Accessed ─────┐| ||||
                                                            Dirty ─────┐|| ||||
┌─── NX                                                Page Size ─────┐||| ||||
|┌───┬─── Memory Protection Key                         Global ─────┐ |||| ||||
||   |┌──────┬─── Ignored                             Ignored ───┬─┐| |||| ||||
||   ||      | ┌─── Reserved         Page Attribute Table ─────┐ | || |||| ||||
||   ||      | |┌───────────────────────────────────┐┌────────┐| | || |||| ||||
||   ||      | ||     2MB Page Physical Address     ||Reserved|| | || |||| ||||
||   ||      | ||                                   ||        || | || |||| ||||
XXXX XXXX XXXX 0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXX0 0000 000X XXXX 1XXX XXXX
       56        48        40        32        24        16         8         0
</code></pre></div></div>

<p>This is very similar to the PUD entry with the Page Size bit set, the only thing that has changed is that since the alignment is smaller for the 2MB pages at this level, there are less reserved bits set.</p>

<p>The 2MB alignment means the offset within the huge page should be calculated using a mask based on 2MB alignment.</p>

<h2 id="going-for-a-walk">going for a walk</h2>

<p>So the last section was a lot of diagrams, in this section lets look at how to actually do a page walk manually in gdb.</p>

<h3 id="preparation">preparation</h3>

<p>With a booted up vm and gdb attached I first will pick an address to do a page walk on, as an example I’ll use the current stack pointer while running in the kernel:</p>

<div><div><pre><code>gef➤  p/x $rsp
$42 = 0xffffffff88c07da8
</code></pre></div></div>

<p>Now we have the address we are going to walk, lets also get the physical address of the PGD from <code>cr3</code>:</p>

<div><div><pre><code>gef➤  p/x $cr3 &amp; ~0xfff
$43 = 0x10d664000
</code></pre></div></div>

<p>I’ll use this little python function to extract the page table offsets from the virtual address:</p>

<div><div><pre><code><span>def</span> <span>get_virt_indicies</span><span>(</span><span>addr</span><span>):</span>
    <span>pageshift</span> <span>=</span> <span>12</span>
    <span>addr</span> <span>=</span> <span>addr</span> <span>&gt;&gt;</span> <span>pageshift</span>
    <span>pt</span><span>,</span> <span>pmd</span><span>,</span> <span>pud</span><span>,</span> <span>pgd</span> <span>=</span> <span>(((</span><span>addr</span> <span>&gt;&gt;</span> <span>(</span><span>i</span><span>*</span><span>9</span><span>))</span> <span>&amp;</span> <span>0x1ff</span><span>)</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>4</span><span>))</span>
    <span>return</span> <span>pgd</span><span>,</span> <span>pud</span><span>,</span> <span>pmd</span><span>,</span> <span>pt</span>
</code></pre></div></div>

<p>which outputs this:</p>
<div><div><pre><code><span>In</span> <span>[</span><span>2</span><span>]:</span> <span>get_virt_indicies</span><span>(</span><span>0xffffffff88c07da8</span><span>)</span>
<span>Out</span><span>[</span><span>2</span><span>]:</span> <span>(</span><span>511</span><span>,</span> <span>510</span><span>,</span> <span>70</span><span>,</span> <span>7</span><span>)</span>
</code></pre></div></div>

<h3 id="pgd-1">PGD</h3>

<p>The index we got for the PGD based on the virtual address was 511, multiplying 511 by 8 will let us get the byte offset into the PGD that the PGD entry for our virtual address starts at:</p>

<div><div><pre><code>gef➤  p/x 511*8
$44 = 0xff8
</code></pre></div></div>

<p>adding that offset to the PGD’s physical address gets us the physical address of the PGD entry:</p>

<div><div><pre><code>gef➤  p/x 0x10d664000+0xff8
$45 = 0x10d664ff8
</code></pre></div></div>

<p>and reading the physical memory at that address gets us the PGD entry itself:</p>
<div><div><pre><code>gef➤  monitor xp/gx 0x10d664ff8
000000010d664ff8: 0x0000000008c33067
</code></pre></div></div>

<p>Looks like the entry has the last three bits (present, user, and writeable) set, and the top bit (NX) is unset, meaning there aren’t any restrictions so far on the permissions of the pages associated with this virtual address.</p>

<p>Masking the bits [12, 51) gives us the physical address of the PUD:</p>

<div><div><pre><code>gef➤  p/x 0x0000000008c33067 &amp; ~((1&lt;&lt;12)-1) &amp; ((1&lt;&lt;51) - 1)
$46 = 0x8c33000
</code></pre></div></div>

<h3 id="pud-1">PUD</h3>

<p>The index we got for the PUD based on the virtual address was 510, multiplying 510 by 8 will let us get the byte offset into the PUD that the PUD entry for our virtual address starts at:</p>

<div><div><pre><code>gef➤  p/x 510*8
$47 = 0xff0
</code></pre></div></div>

<p>adding that offset to the PUD’s physical address gets us the physical address of the PUD entry:</p>

<div><div><pre><code>gef➤  p/x 0x8c33000+0xff0
$48 = 0x8c33ff0
</code></pre></div></div>

<p>and reading the physical memory at that address gets us the PUD entry itself:</p>
<div><div><pre><code>gef➤  monitor xp/gx 0x8c33ff0
0000000008c33ff0: 0x0000000008c34063
</code></pre></div></div>

<p>At this level we need to start paying attention to the Size Bit (bit 7), because if it is a 1GB page we would stop our page walk here.</p>

<div><div><pre><code>gef➤  p/x 0x0000000008c34063 &amp; (1&lt;&lt;7)
$49 = 0x0
</code></pre></div></div>

<p>Seems it is unset on this entry so we will continue page walking.</p>

<p>Notice also that the PUD entry ends in 0x3 and not 0x7 like the previous level, the bottom two bits (present, writeable) are still set but the third bit, the user bit is now unset. That means that usermode accesses to pages belonging to this PUD entry will result in a page fault due to the failed permission check on the access.</p>

<p>The NX bit is still unset, so pages belonging to this PUD can still be executable.</p>

<p>Masking the bits [12, 51) gives us the physical address of the PMD:</p>

<div><div><pre><code>gef➤  p/x 0x0000000008c34063 &amp; ~((1ull&lt;&lt;12)-1) &amp; ((1ull&lt;&lt;51)-1)
$50 = 0x8c34000
</code></pre></div></div>

<h3 id="pmd-1">PMD</h3>

<p>The index we got for the PMD based on the virtual address was 70, multiplying 70 by 8 will let us get the byte offset into the PMD that the PMD entry for our virtual address starts at:</p>

<div><div><pre><code>gef➤  p/x 70*8
$51 = 0x230
</code></pre></div></div>

<p>adding that offset to the PMD’s physical address gets us the physical address of the PMD entry:</p>

<div><div><pre><code>gef➤  p/x 0x8c34000+0x230
$52 = 0x8c34230
</code></pre></div></div>

<p>and reading the physical memory at that address gets us the PMD entry itself:</p>
<div><div><pre><code>gef➤  monitor xp/gx 0x8c34230
0000000008c34230: 0x8000000008c001e3
</code></pre></div></div>

<p>Again, at this level we need paying attention to the Size Bit, because if it is a 2MB page we will stop our page walk here.</p>

<div><div><pre><code>gef➤  p/x 0x8000000008c001e3 &amp; (1&lt;&lt;7)
$53 = 0x80
</code></pre></div></div>

<p>Looks like our virtual address refers to a 2MB Huge Page! so the physical address in this PMD entry is the physical address of that Huge Page.</p>

<p>Also, looking at the permission bits, looks like the page is still present and writeable and the user bit is still unset, so this page is only accessible from supervisor mode (ring-0).</p>

<p>Unlike the previous levels, the top bit, the NX bit, is set:</p>

<div><div><pre><code>gef➤  p/x 0x8000000008c001e3 &amp; (1ull&lt;&lt;63)
$54 = 0x8000000000000000
</code></pre></div></div>

<p>So this Huge Page is not executable memory.</p>

<p>Applying a bitmask on bits [21:51) gets us the physical address of the huge page:</p>

<div><div><pre><code>gef➤  p/x 0x8000000008c001e3 &amp; ~((1ull&lt;&lt;21)-1) &amp; ((1ull&lt;&lt;51)-1)
$56 = 0x8c00000
</code></pre></div></div>

<p>Now we need to apply a mask to the virtual address based on 2MB page alignment to get the offset into the Huge Page.</p>

<p>2MB is equivalent to <code>1&lt;&lt;21</code> so applying a bitmask of <code>(1ull&lt;&lt;21)-1</code> will get us the offset:</p>

<div><div><pre><code>gef➤  p/x 0xffffffff88c07da8 &amp; ((1ull&lt;&lt;21)-1)
$57 = 0x7da8
</code></pre></div></div>

<p>Now adding this offset to the base address of the 2MB Huge Page will get us the physical address associated with the virtual address we started with:</p>

<div><div><pre><code>gef➤  p/x 0x8c00000 + 0x7da8
$58 = 0x8c07da8
</code></pre></div></div>

<p>Looks like the Virtual Address: <code>0xffffffff88c07da8</code> has a Physical Address of: <code>0x8c07da8</code>!</p>

<h3 id="checking-ourselves">checking ourselves</h3>

<p>There are a few ways to test that we page walked correctly, an easy check is to just dump the memory at the virtual and physical address and compare them, if they look the same we were probably right:</p>

<p>Physical:</p>
<div><div><pre><code>gef➤  monitor xp/10gx 0x8c07da8
0000000008c07da8: 0xffffffff810effb6 0xffffffff88c07dc0
0000000008c07db8: 0xffffffff810f3685 0xffffffff88c07de0
0000000008c07dc8: 0xffffffff8737dce3 0xffffffff88c3ea80
0000000008c07dd8: 0xdffffc0000000000 0xffffffff88c07e98
0000000008c07de8: 0xffffffff8138ab1e 0x0000000000000000
</code></pre></div></div>

<p>Virtual:</p>
<div><div><pre><code>gef➤  x/10gx 0xffffffff88c07da8
0xffffffff88c07da8:	0xffffffff810effb6	0xffffffff88c07dc0
0xffffffff88c07db8:	0xffffffff810f3685	0xffffffff88c07de0
0xffffffff88c07dc8:	0xffffffff8737dce3	0xffffffff88c3ea80
0xffffffff88c07dd8:	0xdffffc0000000000	0xffffffff88c07e98
0xffffffff88c07de8:	0xffffffff8138ab1e	0x0000000000000000
</code></pre></div></div>

<p>Looks good to me!</p>

<p>Another way to check is using the <code>monitor gva2gpa</code> (guest virtual address to guest physical address) command exposed to gdb by the QEMU Monitor:</p>

<div><div><pre><code>gef➤  monitor gva2gpa 0xffffffff88c07da8
gpa: 0x8c07da8
</code></pre></div></div>

<p>Assuming QEMU is doing address translation correctly (probably a fair assumption), then looks like we have double confirmation that our page walk was successful!</p>

<h2 id="wrapping-up">wrapping up</h2>

<p>Hopefully by the end of this you have a pretty solid understanding of how paging works on x86_64 systems. I wanted to pack a lot of information into the post so it took some thought to figure out how to organize all of it and I’m still not sure if this was a great way to go about it.</p>

<p>Anyways, I think paging is pretty neat and I think its one of those things where once you get it you’ve got it, but getting to that point can take some time and some screwing around in gdb.</p>

<p>I’d also like to mention that the inspiration for the diagrams of the various page table entries I made for this post came from the documentation of the <a href="https://github.com/jart/blink/">blink</a> project: <a href="https://github.com/jart/blink/blob/46d82a0ced97c0df1fc645c5d81a88f0d142fbfd/blink/machine.h#L61">blink/machine.h</a>.</p>

<p>Thanks for reading!</p>

        
      </section></div>
  </body>
</html>
