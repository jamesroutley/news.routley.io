<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bell-labs.com/usr/dmr/www/hopl.html">Original</a>
    <h1>Five Little Languages and How They Grew: Talk at HOPL (1993)</h1>
    
    <div id="readability-page-1" class="page"><div>

<hr/>
<p>

Thank you.  Before I begin the talk, I will put forth a little idea I
thought of in the last day or so.  It&#39;s a programming problem having
to do with Graph Theory: you have a graph.  The nodes contain a record
with a language and a person, and, just to make the example concrete:
the nodes might be (C, Ritchie), (ADA, Ichbiah), (Pascal, Wirth), or
Brinch-Hansen perhaps.  (Lisp, Steele), (C++, Stroustrup) might also
be part of the population.  There is an edge from X to Y, whenever
X.Person will throw a barb in public at Y.Language.  And the questions
are: is this a complete graph?  Does it have self-edges?  If it&#39;s not
complete, what cliques exist?  There are all sorts of questions you
can ask.  I guess if it were a finite state machine, you could ask
about diagnosability, too.  Can you push at the people and get them to
throw these barbs?
</p><p>
<img src="https://www.bell-labs.com/usr/dmr/www/hoplgifs/y.1.gif" "="" alt="Slide 1" height="340" width="440"/>
[Slide 1] The paper itself tells the history of C, so I don&#39;t want to
do it again.  Instead, I want to do a small comparative language
study, although it&#39;s not really that either.  I&#39;m going to talk about
a bunch of twenty-year old languages.  Other people can discuss what
the languages contain.  These were things that were around at the
time, and I&#39;m going to draw some comparisons between them just to show
the way we were thinking and perhaps explain some things about C.
Indirectly, I want to explain why C is as it is.  So the actual title
of the talk, as opposed to the paper, is `Five Little Languages and
How They Grew.&#39;

</p><p>
Mostly they were designed (speaking broadly) for `systems
programming.&#39;  Certainly some of them, like BCPL and C and Bliss, are
explicitly system programming languages, and Pascal has been used for
that.  Algol 68 didn&#39;t really have that in mind, but it really can be
used for the purpose; when Steve Bourne came to Bell Labs with the
Algol 68C compiler, he made it do the same things that C could do; it
had Unix system call interfaces and so forth.  The point is, that
`system&#39; can be understood in a fairly broad sense, not just operating
systems.

</p><p>
Bliss was innovative in a variety of ways.  It was goto-less; it was
an expression language.  A lot of things that are built in to other
languages were not built into Bliss; instead there were syntax macros
used for giving meaning to arrays, particularly multi-dimensional
arrays, and structures.  An array or structure was represented by the
programmer as a sort of inline function to access the members, instead
of being built in as a data type.

</p><p>
What were the problems of Bliss?  Really, that it never transcended
its original environments.  The programs tended to be non-portable.
There was a notation for the bit extraction to get characters, but
there were also notations that created PDP-10 specific byte pointers,
because they couldn&#39;t resist using this feature of the PDP-10.  And
this (and other things) made programs tend to be non-portable because
they were either PDP-11 dialect, or the PDP-10 dialect.  And perhaps
equally important, the compilers were nonportable; in particular, the
compiler never ran on the PDP-11
[Slide 6].
</p><p>
Whatever the motivation for Bliss as a language, much of the interest
in it actually came because of a sequence of optimizers for its
compilers created by a succession of students.  In other words, its
legacy is a multi-phase optimizing compiler that ran on the PDP-10.
It was a project that could be divided up phases, in which each
student gets a phase and writes a thesis on this particular kind of
optimization.  Altogether very CMU-like way of operating--a series of
programs that collectively could be called C.PhD.  A good way of
working, I think.  [It was used as well in C.mmp and Mach, as well.]

</p><p>
This is in spite of the fact Wirth&#39;s intent in creating Pascal was
very different from ours in C. He was was creating a language for
teaching, so that he had a didactic purpose.  And in particular, I
take it both from Pascal and from his later languages that he&#39;s
interested in trying to constrain expression as much as possible,
although no more.  In general, he explores where the line should go
between constraints that are there for safety, and expressiveness.
He&#39;s really a very parsimonious fellow, I think, and so am I.

</p><p>
Even some of the characteristic problems of Pascal and C are very
similar.  In particular, in treatment of arrays with varying bounds:
this is worth discussing a bit.

</p><p>
C has always provided for open-ended, that is, variable-sized, arrays
(one-dimensional arrays, or vectors).  In particular, C has been able
to subsume strings under the same set of general rules as integer
arrays.  Pascal, certainly in the original form, did not allow even
that.  In other words, even one-dimensional arrays had a fixed size
known at compile time.  There have been, in at least some of the
dialects, a notion of `conformant&#39; arrays so that procedures can take
arrays of different sizes.  But still the issue isn&#39;t fully resolved;
the status of this is not really clear.

</p><p>
C&#39;s solution to this has real problems, and people who are complaining
about safety definitely have a point.  Nevertheless, C&#39;s approach has
in fact lasted, and actually does work.  In Pascal&#39;s case, certainly
in the original language, and perhaps even in some of the following
ones, the language needs extensions in order to be really useful.  You
can&#39;t take the pure language and use it, for example, as a system
programming language.  It needs other things.

</p><p>
Here&#39;s an aphorism I didn&#39;t create for this conference, but several
years ago.  It seems particularly apt, given the people present [Stu
Feldman and Niklaus Wirth]: `` `Make&#39; is like Pascal.  Everybody likes
it, so they want to change it.&#39;&#39;  In both cases, a very good idea
wasn&#39;t quite right at the start.

</p><p>
Here&#39;s another anecdote, based on something that happened yesterday
afternoon.  During the coffee break.  Wirth said to me, `Sometimes you
can be too strict...&#39;  Interestingly, he was not talking about
language design and implementation, but instead about the type- and
bounds-checking that was occurring within the conference.  [That is,
to the insistence on written-down questions to speakers and strongly
enforced time limits on speakers and questioners].

</p><p>
First, a further example of the way Bliss works.  In the first
statement, you&#39;ve simply assigned a value 1 to A. In the second
statement when you say `B gets A&#39;, what you have assigned is the
address at which A is located.  So, if you print the value B at this
point, you&#39;ll see a number representing some memory address.  However,
if you do this assignment with the dot, as in the third statement,
then you have assigned the value 1 that came from the assignment on
the first line.  That means that `dereferencing&#39; (a word that came
from Algol 68) is always explicit in Bliss, and it&#39;s necessary because
in Bliss a simple name is a reference, not a value.

</p><p>
Later, you write, in line 4, `A gets 1&#39;.  The rules of the language
see a reference to an int on the left, an int on the right, and do the
appropriate magic (called `coercion&#39;) that puts 1 into the cell
referred to by A. In line 5, because B is declared as a reference to a
reference to an integer, B is assigned the address of A, while in line
6, C gets the value (the number 1) stored in A. On the last line, the
same 1 is stored again, this time indirectly through the reference in
B.

</p><p>
So the two A&#39;s, on lines 5 and 6, are coerced in different ways,
depending on the context in which they appear.  `Dereferencing&#39;, or
turning an address into the value stored in it, happens automatically,
according to explicit rules, when appropriate; even though the
underlying semantics resemble those Bliss, one doesn&#39;t have have to
write the dots.

</p><p>
These languages (Bliss, Algol 68, and BCPL/B/C), show three different
approaches to the question `What is the meaning of a name when it
appears in a program?&#39;  Bliss says: `It means the location of a value;
to find the value itself, you must be explicit.&#39;  Algol 68 says: `It
means the location of a value; the language, however, supplies
coercion rules such that you will always get the value itself, or its
location, as appropriate.  Otherwise you have made a error that will
be diagnosed.&#39;  BCPL, B, C, and Pascal say, `A name means a value.
You must be explicit if you wish to get the location in which that
value is stored, and also if the value happens to represent a
reference to another value.&#39;

</p><p>
Naturally I prefer the approach that C has taken, but I appreciate how
Algol 68 has clarified thinking about these issues of naming and
reference.

</p><p>
I&#39;ll make another side point, a comparison that doesn&#39;t have a slide
either.  Of these languages, only Pascal does anything interesting
about numerical precision control.  Algol 68 really thought about
static semantics of names, and in most cases, dynamic semantics of
things.  But one thing it just didn&#39;t talk about at all in a
meaningful sense, is: what numbers go out or go in?  It has `int&#39;s and
`long ints&#39;s and `long long int&#39;s and so forth, but the language
doesn&#39;t tell you how big these things are; there&#39;s no control over
them.  In B and BCPL, there is nothing but the `word&#39;.  What&#39;s a word?
It depends on the machine.  C is similar to Algol 68, in the sense
that it has type modifiers like `long&#39;.  The C standard does say,
`Here is the minimal size you can expect for `int&#39;, for `long&#39;, for
`short&#39;.  But this is still fairly weak.  Pascal has ranges, so that
you can be explicit about the range of values you expect to store.  Of
course, you hit against limits, and you can&#39;t have numbers that are
too big.

</p><p>
Other languages allow you to use very big numbers.  Various
predecessors of these languages, like PL/1, were very explicit about
numerical precision, and successors like ADA make it possible say
similar things in a different way.  The question: `How can you be
portable if you don&#39;t know how big an integer is?,&#39; is continually
raised.  The interesting fact, and it&#39;s one that&#39;s surprising to me,
is how little this actually matters.  In other words, though you have
to do some thinking about program design, it&#39;s fairly seldom that this
issue turns out to be the important source of bugs, at least in my
experience.

</p><p>
Let me go back to talk about influences of these languages on the world.
Bliss has pretty much disappeared.  Its optimization ideas have
remained useful, and some of the companies that worked with it have
survived.  Digital Equipment Corp.  still has a lot of Bliss code that
they&#39;re wondering what to do with.

</p><p>
Pascal is definitely alive, and it has many direct descendants and
other languages strongly influenced by it.  Algol 68 and BCPL as
languages are moribund, but their influence continues: Algol 68
influences in a broad way, and BCPL rather directly through through
its influence on C. C remains lively, obviously.

</p><p>
C&#39;s own descendants, by which I mainly mean C++, may very well be even
livelier in the next few years.  Aside from languages that are
directly descended from C, (particularly C++ but also some others),
C&#39;s intellectual influence on the semantic design of new languages has
been small.  On the other hand, it has influenced notation: even
pseudo-code these days tends to contain curly braces.

</p><p>
Elegance and formality of definition may be necessary, according to
some, but it&#39;s certainly not sufficient.  It&#39;s important that people
really be able to understand the the language.  One
of the problems with Algol 68, despite the efforts of Charles Lindsay
and others, was that its definition was hard to read.  More
fundamentally, though, a language has to be able to connect with and
facilitate what people need to do, and potential users have to be able
to get an implementation of it.

</p><p>
So, you need to be able to get a compiler: the language has to be
implementable in the compiler technology of the day, on the systems
they have available to them.

</p><p>
When you design a language with new ideas before implementing it, you
are taking a chance that you&#39;re pushing compiler technology.  This may
be a social good, but it may not do your language any good.  It has to
have an implementation, so that people can try it, and it needs
distribution.  As I&#39;ve mentioned, the definition of both Algol 68, and
Algol 60 before it, held surprises for implementers.

</p><p>
Also, languages need to provide appropriate interaction with a real
environment.  Computer languages exist to perform useful things that
affect the world in some way, not just to express algorithms, and so
their success depends in part on their utility.  Environments vary.
The one that we created in the Unix System had a particular flavor,
and we took full advantage of the ability of the C language to express
the software tools appropriate for the environment.  As an old
example, suppose you want to search many files for strings described
by regular expressions, in the manner of the Unix `grep&#39; program.

</p><p>
What languages could you write grep in?  As an example, there are
really neat ways of expressing the regular expression search algorithm
in the APL language.  However, traditional APL systems are usually set
up as a closed environment, and give you no help in creating a tool
for text searching in a more general setting.

</p><hr/>
<em>
March 19, 2002

</em>

</div></div>
  </body>
</html>
