<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jepsen.io/analyses/radix-dlt-1.0-beta.35.1">Original</a>
    <h1>Jepsen: Radix DLT 1.0-Beta.35.1</h1>
    
    <div id="readability-page-1" class="page"><p><a href="https://radixdlt.com/">Radix DLT</a> is a distributed, byzantine-fault-tolerant ledger for cryptocurrencies based on delegated proof-of-stake. We evaluated <a href="https://github.com/radixdlt/radixdlt">Radix DLT</a> at version 1.0-beta.35.1, 1.0.0, 1.0.1, and 1.0.2, as well as various development builds—all versions associated with Radix’s Olympia technology milestone. We found 11 safety errors, ranging from stale reads which violated per-server monotonicity, to aborted and intermediate reads, as well as the partial or total loss of committed transactions. At least some of these issues affected users of the Radix Olympia Public Network. We also observed what appeared to be liveness issues with indeterminate transactions and performance degradation during single-node faults. RDX Works reports that all safety issues we found had been resolved in version 1.1.0, in large part by replacing the archive API subsystem with a new <a href="https://www.radixdlt.com/post/archive-nodes-shutting-down-on-feb-18th">Gateway API</a>. RDX Works also reports that their internal load tests show they have resolved the issue with indeterminate transactions. Jepsen has not verified these claims. RDX Works has also written <a href="https://www.radixdlt.com/post/radix-olympia-tested-by-jepsen">a companion blog post</a> to this report. This work was funded by <a href="https://radixdlt.com">Radix Tokens (Jersey) Limited</a>, and conducted in collaboration with <a href="https://www.radixdlt.com/post/welcome-to-rdx-works">RDX Works Ltd</a>, in accordance with the <a href="https://jepsen.io/ethics.html">Jepsen ethics policy</a>.</p><article>
  <div>

<p>Radix DLT (Distributed Ledger Technology) is a distributed ledger: a serializable log of transactions over a state machine, along with mechanisms for querying that state. Throughout this report, “Radix” refers to the <a href="https://github.com/radixdlt">Radix DLT software</a>.</p>
<p>RDX Works, the makers of Radix, intend to develop and release a <a href="https://assets.website-files.com/6053f7fca5bf627283b582c2/60870dd57116a30d877abe57_DeFi-Whitepaper-v1.0-3.pdf">smart contract system</a> à la <a href="https://ethereum.org/en/developers/docs/smart-contracts/">Ethereum</a>—a feature which is now available as a part of the <a href="https://www.radixdlt.com/post/alexandria-scrypto-is-here">Alexandria developer preview</a>. The implementation discussed in this report, and which is presently deployed as the <a href="https://www.radixdlt.com/post/radix-olympia-mainnet-is-here">Radix Olympia Public Network</a>, does not include smart contracts. Instead, it provides a set of <em>accounts</em> which can hold and transfer units of virtual currencies, called <em>tokens</em>. A “native token” called <em>XRD</em> is used for core Radix operations like paying network fees. Users can create their own tokens as well.</p>
<p>Radix’s <a href="https://www.radixdlt.com/post/replaying-bitcoin">homepage</a> advertises “1000x More Scalability than Ethereum / Solana / Polkadot / Avalanche / …,” which refers to their parallelized Byzantine-fault-tolerant (BFT) consensus protocol named <a href="https://assets.website-files.com/6053f7fca5bf627283b582c2/608811e3f5d21f235392fee1_Cerberus-Whitepaper-v1.01.pdf">Cerberus</a>. Rather than serialize all operations through a single instance of a consensus system, Cerberus runs several independent shards of consensus, each based on the <a href="https://arxiv.org/abs/1803.05069">HotStuff</a> BFT consensus protocol. For cross-shard operations, Cerberus establishes transient consensus instances which “braid” those shards together. This should allow Radix to offer linearly scalable transaction throughput.</p>
<p>From <a href="https://web.archive.org/web/20210526053236/https://www.radixdlt.com/">May</a> through <a href="https://web.archive.org/web/20211124083358/https://www.radixdlt.com/">November 2021</a>, Radix’s homepage advertised 1.4 million transactions per second using a <a href="https://www.radixdlt.com/post/test-method-part1">2019 sharded consensus prototype</a>.</p>
<blockquote>
<p>1.4m TPS on a DLT</p>
<p>Radix’ last consensus algorithm ‘Tempo’ publicly achieved 1.4m TPS in 2018, the current world record. The new algorithm ‘Cerberus’ is theoretically infinitely scalable and builds on many of the insights we learnt from replaying the entire history of Bitcoin in less than 30 minutes!</p>
</blockquote>
<p>There appears to be some confusion over these prototype test results versus the behavior of the <a href="https://github.com/radixdlt/radixdlt">Radix DLT software</a> which currently runs the Radix Olympia Public Network. <a href="https://twitter.com/RadixCommunity/status/1332914845151203328">Claims</a> <a href="https://twitter.com/arnaud_varela/status/1475450416745914369">of</a> <a href="https://twitter.com/XRPFreedomFyter/status/1363516375285792768">1.4 million</a> <a href="https://twitter.com/Inspectr_Crypto/status/1337487366508961797">transactions</a> <a href="https://twitter.com/QuintenFrancois/status/1328740279034195968">per</a> <a href="https://twitter.com/Altcoinbuzznews/status/1154143546200301568">second</a> <a href="https://twitter.com/Inspectr_Crypto/status/1464835564834799616">and</a> <a href="https://twitter.com/fatcookiesss/status/1460557224925806598">unlimited</a> <a href="https://twitter.com/a_vaunt/status/1452353781098815501">scalability</a> <a href="https://twitter.com/thingdodo/status/1451164578109296642">are</a> <a href="https://twitter.com/Radix_SC/status/1424598725394145284">frequently</a> <a href="https://twitter.com/RadBullXRD/status/1365006228200574979">repeated</a> <a href="https://twitter.com/StrongHandzSP90/status/1463127242956021760">by</a> <a href="https://twitter.com/CptCharles_/status/1452305256994557962">proponents</a> <a href="https://twitter.com/migdsb/status/1351264242498998272">of</a> <a href="https://twitter.com/JaMie___17/status/1343274435822944259">Radix</a> <a href="https://twitter.com/CryptoAffray/status/1480116633620430851">on</a> <a href="https://twitter.com/PatriotBlok/status/1324677857893736450">Twitter</a>. For example, <a href="https://twitter.com/StrongHandzSP90/status/1458388957268520960">StrongHandzSP90 writes</a>:</p>
<blockquote>
<p>Radix DLT #XRD is an innately sharded DLT that is NOT a blockchain and has infinite scalability (1.4million TPS confirmed and verifiable), enhanced security and decentralised all WITHOUT BREAKING COMPOSABILITY. This is the future of #DeFi!</p>
</blockquote>
<p>When asked, RDX Works executives informed Jepsen that blockchain/DLT readers would normally understand present-tense English statements like these to be referring to potential future behavior, rather than the present.</p>
<p>Jepsen is no stranger to ambitious claims, and aims to understand, analyze, and report on systems as they presently behave—in the context of their documentation, marketing, and community understanding. Jepsen encourages vendors and community members alike to take care with this sort of linguistic ambiguity.</p>
<p>Indeed, as the <a href="https://www.radixdlt.com/#radix-roadmap">Radix Roadmap</a> clarifies, the Cerberus sharded consensus system is not yet implemented. Instead Radix currently processes all transactions through a single consensus instance, also based on HotStuff. This means the Olympia Public Network has constant, rather than linear scalability. The roadmap indicates that Olympia offers <a href="https://web.archive.org/web/20211215023129/https://www.radixdlt.com/">50 transactions per second</a>, and while Radix presently declines to publish network throughput statistics, <a href="https://www.radixscan.io/NetworkUtilization.shtml">an independent dashboard</a> indicates the Olympia Public Radix network is currently processing three to five transactions per second. In our testing with five to ten-node clusters of m5.large instances, we saw transactions start timing out with as little as one request per second, and <a href="https://en.wikipedia.org/wiki/Goodput">goodput</a> generally peaked at ~16 transactions per second.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>During our analysis, Radix’s documentation explained that Radix nodes <a href="https://web.archive.org/web/20210613133702/https://docs.radixdlt.com/main/radix-nodes/introduction-to-radix-nodes.html">can run in three principal ways</a>:</p>
<blockquote>
<p>An individual Radix Node has its own account on the Radix network. It can be configured in three different ways depending on its purpose:</p>
<p>A Full Node simply connects to the network, synchronizes ledger state, and observes the status of the network. It can be thought of as a kind of “wallet” that is connected directly to the network, with the Node’s own account available for programmatic control.</p>
<p>A Validator Node starts life as a Full Node, but has also “registered” itself to the network as a Validator by submitting a special transaction from its account. Registration means that it may now accept XRD token “stake” and potentially be included in the validator set of 100 nodes that conduct network consensus.</p>
<p>An Archive Node not only synchronizes ledger state (as with a Full Node) but also heavily indexes that state to support the JSON-RPC API endpoint the Archive Node offers. The Node API is useful for client applications, like wallets or exchange integrations, as well as general account/transaction queries and programmatic control of accounts.</p>
</blockquote>
<p>Both full and validator nodes can also be archive nodes. Archive nodes are simply those which <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/db.clj#L303">have set</a> <code>api.archive.enable = true</code>.</p>
<p>Validators do the work of consensus. Accounts on a Radix network can <em>stake</em> a portion of their XRD to one or more validators, indicating they believe those validators to be trustworthy network participants. In the Radix Olympia Public Network, <a href="https://radixdlt.com/post/radix-staking-and-incentive-rewards-guide">the 100 validators with the highest stake are selected to execute the consensus protocol</a>. Every <em>epoch</em> (a period determined by the number of consensus rounds) a fresh set of validators is selected. The Radix protocol is intended to guarantee the safety of the ledger state and the liveness of the network at large, under the condition that no more than 1/3 of active stake supports nodes which are either unresponsive or malicious.</p>
<p>Radix transactions (in the Olympia series of releases) are an ordered series of operations performed by a single account. The most common operations come in three basic flavors:</p>
<ol type="1">
<li>Transferring tokens to another account.</li>
<li>Staking XRD to a validator.</li>
<li>Unstaking XRD from a validator.</li>
</ol>
<p>Transactions can not perform read operations. However, clients can observe the state of the Radix ledger by querying a node’s <a href="https://learn.radixdlt.com/article/whats-the-difference-between-a-full-node-validator-node-and-archive-node">archive API</a>, which provides methods for fetching the status of a transaction, the balance of a single account, and the complete history of transactions on a single account. The archive API is essentially a read-only layer around Radix’s ledger, and during our testing was the primary way for users to observe Radix state.<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h2 data-number="1.1" id="safety-and-liveness"> Safety and Liveness</h2>
<p>This report discusses safety and liveness properties. As Lamport’s 1977 <a href="https://www.microsoft.com/en-us/research/publication/2016/12/Proving-the-Correctness-of-Multiprocess-Programs.pdf">Proving the Correctness of Multiprocess Programs</a> succinctly put it:</p>
<blockquote>
<p>A safety property is one which states that something [bad] will <em>not</em> happen.</p>
<p>A liveness property is one which states that something [good] <em>must</em> happen.</p>
</blockquote>
<p>These senses have been standard in concurrent and distributed systems verification for several decades; <a href="https://en.wikipedia.org/wiki/Liveness">their</a> <a href="https://en.wikipedia.org/wiki/Safety_property">definitions</a> <a href="https://www.oreilly.com/library/view/concurrency-state-models/9780470093559/ch07.html">are</a> <a href="https://will62794.github.io/formal-methods/2020/08/01/safety-and-liveness.html">widely</a> <a href="http://www.bailis.org/blog/safety-and-liveness-eventual-consistency-is-not-safe/">understood</a> <a href="https://dl.acm.org/doi/10.1145/2767386.2767401">throughout</a> <a href="http://pi1.informatik.uni-mannheim.de/filepool/teaching/dependablesystems-2007/PDS_20070306.pdf">the</a> <a href="https://www.cs.purdue.edu/homes/peugster/classes/CS505Spring09/4-Definitions.pdf">field</a>. We use these senses throughout Jepsen reports.</p>
<p>Four days prior to publication, RDX Works informed Jepsen that the blockchain/DLT community had developed idiosyncratic definitions of safety and liveness. Their definitions are:</p>
<blockquote>
<p>A <em>safety violation</em> is defined as two healthy consensus nodes disagreeing on what is the correct ledger state. Most notably, this is a result of a <em>double-spend</em> having been permitted. Specifically in the Radix Olympia Network, this means a single substate being successfully “downed” more than once in the ledger.</p>
<p>A <em>liveness break</em> is defined as the network halting and being unable to process further transactions.</p>
</blockquote>
<p>These definitions are of course specific examples of safety and liveness properties, but they allow many behaviors which would reasonably be termed safety or liveness issues. For example, a system which acknowledges user transactions and then throws them away on every node trivially satisfies this safety property, but one would be hard-pressed to call such a system <em>safe</em>.</p>
<p>To Jepsen’s surprise, RDX Works asserted that phenomena such as aborted read, intermediate read, and lost writes do not constitute safety violations (in the blockchain sense). RDX Works claims that to describe these errors as safety violations would not be understood by readers from a blockchain background; this report is therefore “factually incorrect”. On these grounds, RDX Works requested that Jepsen delete any mention of our findings from the abstract of this report.</p>
<p>Jepsen respectfully declines to do so.</p>
<h2 data-number="1.2" id="consistency"> Consistency</h2>
<p>As of November 5, 2021, Radix’s <a href="https://docs.radixdlt.com/main/">documentation</a> offered essentially no description of Radix’s consistency guarantees or behavior during faults. However, in our initial conversations RDX Works staff indicated that transactions should be <a href="https://jepsen.io/consistency/models/strict-serializable">strict serializable</a>. This means that transactions appear to execute in a total order, such that each transaction takes effect at some point in time between that transaction’s submission and confirmation.</p>
<p>On the other hand, RDX Works indicated that read operations are <em>not</em> intended to be strict serializable. Instead they read from a snapshot of committed state on the local node. This means that histories of transactions and reads should still be <a href="https://jepsen.io/consistency/models/serializable">serializable</a>, but reads may observe stale state.</p>
<p>Moreover, each archive node is supposed to enforce a sort of local sequential consistency: reads against a single node should observe monotonically increasing states, and successive transactions and reads to the same node should be executed in order. When a node says that a transaction is confirmed, any future read on that same node is guaranteed to reflect that transaction.</p>

<p>We designed a <a href="https://github.com/jepsen-io/radix-dlt">test suite</a> for <a href="https://github.com/radixdlt/radixdlt">Radix DLT</a> using the <a href="https://github.com/jepsen-io/jepsen">Jepsen testing library</a>. Our test suite created local clusters of Radix DLT nodes, completely independent from public Radix networks, and could also (with limitations) interact with Stokenet: a public test network. Our tests ran on 5–10 node clusters of Debian Buster machines, in both LXC and on EC2 virtual machines. Our LXC tests ran on a single 48-way Xeon with 128 GB of RAM. In EC2, we used m5.large instances backed by EBS for each node. Every node in our local clusters <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/db.clj#L289-L379">was configured</a> as a validator node with the archive API enabled.</p>
<p>We tested Radix version 1.0-beta.35.1, and moved on to versions 1.0.0, 1.0.1, 1.0.2, and a series of development builds from June 15 through November 5, 2021. This series of production releases were associated with Radix’s <a href="https://learn.radixdlt.com/article/what-is-the-radix-roadmap">Olympia</a> technology milestone: the first iteration of the Radix Public Network.</p>
<p>Our tests submitted transactions and read the state of accounts <a href="https://github.com/radixdlt/radixdlt/blob/0df5f95db20e89cf5da5befc130b4dd5162e1b20/radixdlt-java/radixdlt-java/src/main/java/com/radixdlt/client/lib/api/sync/RadixApi.java">using the Radix Java client library</a>, which talks to Radix’s archive API via JSON-RPC. We began with version 1.0-beta.35-SNAPSHOT and proceeded through several development builds as the API evolved.</p>
<p>Our <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/workload.clj">principal workload</a> submitted <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/workload.clj#L264-L314">randomly generated transactions</a> which transferred XRD from a single account to 1-4 others. Accounts were selected from an exponential distribution, and generally limited to 64 transactions per account to limit the quadratic cost of reading and verifying long transaction logs. Meanwhile, we issued single-account <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/workload.clj#L403-L404">balance</a> and <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/workload.clj#L393-L394">transaction-log</a> reads across that same pool of accounts.</p>
<p>Radix transactions frequently timed out, remaining in state <code>PENDING</code> after 10 seconds of polling. Because indeterminate transactions reduce the accuracy and increase the cost of our analyses, we attempted to resolve these whenever possible. We maintained a <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/workload.clj#L498-L534">cyclic buffer of all pending transactions</a>, and periodically checked transactions from that buffer to see if they’d resolved to a <code>CONFIRMED</code> or <code>FAILED</code> state.</p>
<h2 data-number="2.1" id="transaction-ordering"> Transaction Ordering</h2>
<p>Instead of designing a new dedicated safety checker for Radix’s data model, we <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/checker.clj#L31-L151">translated</a> Radix transactions, balance reads, and transaction-log reads into histories Jepsen can already check: transactions made up of reads and appends to lists, where each list is identified by a unique key. To do this, we interpret Radix accounts as lists of <em>transaction IDs</em>, which are uniquely generated by Jepsen and stored in each transaction’s <code>message</code> field.</p>
<p>We rewrite each Radix transaction <span><em>T</em><sub><em>i</em></sub></span> to an abstract <em>list-append transaction</em> comprising a series of operations which appended <span><em>T</em><sub><em>i</em></sub></span> to every account <span><em>T</em><sub><em>i</em></sub></span> touches. We rewrite each read of an account’s transaction log to a transaction which performed a single read of that account ID, returning the list of transaction IDs extracted from the <code>message</code> field of each transaction in the log. Finally, we take the longest transaction log for each account and play forward its sequence of transactions to derive a sequence of balances the account took on during the test. This allows us to map most (though not necessarily all) balance reads to a “virtual” read of some prefix of the transaction log.</p>

<p>For example, in this diagram we take a Radix history involving three transactions numbered 1, 3, and 4. Transaction 1 transfers 50 XRD from account <span><em>x</em></span> to account <span><em>y</em></span>, transaction 3 transfers 30 XRD from <span><em>y</em></span> to <span><em>x</em></span>, and transaction 4 transfers 10 XRD from <span><em>z</em></span> to <span><em>x</em></span>. An early read of <span><em>x</em></span>’s transaction log shows transaction 1, and a second read shows transactions 1, 3, and 4. Finally, a read of <span><em>x</em></span>’s balance shows 80 XRD.</p>
<p>Transfers and transaction-log reads are directly translated to list-append transactions. Transaction 1 is rewritten as a list-append transaction which appends 1 (the transaction ID) to keys <span><em>x</em></span> and <span><em>y</em></span> (the two accounts involved). The transaction-log read of transactions 1, 3, and 4 becomes a list-append read of key <span><em>x</em></span>, returning the list <code>[1 3 4]</code>.</p>
<p>To analyze balance reads of account <span><em>x</em></span>, we take the longest transaction log for <span><em>x</em></span> and simulate the effects of applying each of those transactions to <span><em>x</em></span> in turn. Knowing the initial balance of <span><em>x</em></span> is 100 XRD, we obtain successive balances of 50, 80, and 90 XRD by applying transactions 1, 3, and 4.</p>
<p>We then examine the balance read of <span><em>x</em> = 80</span> XRD. Since 80 appears only once in the computed series of balances, we know that this balance read should have observed the state of <span><em>x</em></span> resulting from applying transaction 1, then 3. We translate this transaction to a list-append read of <span><em>x</em></span> returning <code>[1 3]</code>.</p>
<p>There were some additional subtleties here. Each transaction costs a fee which is destroyed as a part of execution—we recorded fees as a part of transaction submission and took them into account when computing balances. Because Radix histories with reads are only serializable rather than strict serializable, we could fail to observe some transactions which actually executed. Furthermore, not all balances may have been uniquely resolvable to specific transactions. However, these ambiguities did not prevent our inference from being sound—they only reduced completeness. In general, only a handful of unobserved or ambiguous transactions occur during a test.</p>
<p>With transactions encoded as appends and reads of lists, we use <a href="https://github.com/jepsen-io/elle">Elle</a> to check that the resulting history is serializable. We additionally construct a graph of real-time dependency edges between non-concurrent transactions: if <span><em>T</em><sub>1</sub></span> is confirmed before <span><em>T</em><sub>2</sub></span> is submitted, <span><em>T</em><sub>1</sub></span> must precede <span><em>T</em><sub>2</sub></span> in the serialization order. We also compute dependencies between all non-concurrent operations on a single node: this allows us to check (for example) that two reads against node <code>n1</code> observe logically increasing states of the system. Elle then merges these dependency graphs together, along with inferred read-write, write-write, and write-read dependencies derived from transaction structure, and looks for cycles in the resulting graph. Each cycle <a href="https://pmg.csail.mit.edu/papers/icde00.pdf">corresponds to a consistency anomaly</a>.</p>
<h2 data-number="2.2" id="additional-checks"> Additional Checks</h2>
<p>Projecting transactions into list-append operations allows us to check for aborted reads, transaction ordering, etc. However, this projection focuses primarily on ordering, and mostly ignores the semantic meaning of transfers and account balances. We therefore complement our list-append checker with additional safety checks. For instance, we verify that <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/checker.clj#L473-L502">transactions are faithfully represented</a> in transaction logs: they have the same number of operations as the transactions which were submitted, they interact with the same accounts, transfer the same amounts, and so on. We compute the set of all possible balances for each account over time, and make sure that <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/checker.clj#L386-L401">balance reads always observe some plausible amount</a>. We check to make sure that account balances (both via balance reads and those implied by transaction logs) <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/checker.clj#L403-L430">never become negative</a>.</p>
<h2 data-number="2.3" id="raw-reads"> Raw Reads</h2>
<p>To distinguish between issues in the underlying transaction log versus those in the per-account indices derived from that log, RDX Works team members added an API for <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/client.clj#L872-L886">querying the raw transaction log directly</a>. Our tests integrated that API and <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/checker.clj#L354-L384">verified</a> that the raw transaction log was consistent with submitted transactions, exhibited a total order, etc. We also projected the raw transaction log into per-account logs, and used that information as a part of our transaction ordering inference.</p>
<p>We added similar support for a testing-only API which exposed the raw balances of accounts.</p>
<h2 data-number="2.4" id="faults"> Faults</h2>
<p>Throughout our tests we injected <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/nemesis.clj">a variety of faults</a> into our clusters, including process crashes, process pauses, network partitions, clock errors, and membership changes.</p>
<p>Membership changes were particularly tricky: the membership state machine is complex, highly asynchronous, and easy to get into “stuck” states where no transactions can proceed. For example, our original tactic for removing nodes simply killed the node and deleted its data files, as might happen if a validator node caught on fire and backups of its keys were not available, or the organization running it closed down shop unexpectedly. In Radix, validators are generally expected to politely remove themselves, then remain on the network until the end of the current epoch, or ensure that fewer than 1/3 of current validators (by stake) have also removed themselves: the concurrent loss of 1/3 of validators by stake causes Radix to halt. Although we <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/nemesis.clj#L163">attempted to preserve</a> a 2/3 supermajority of active stake through each membership transition, our test harness struggled with liveness breaks when nodes were removed impolitely. To address this, we introduced new membership transitions for <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/nemesis.clj#L189-L213">registering and unregistering validators</a>, and had our nodes politely unregister themselves before shutting down.</p>
<p>In the Radix Olympia Public Network, three factors help ensure liveness. First, RDX Works encourages users to stake their XRD on validators with a small stake, to prevent a few nodes from holding 1/3 of all stake. Second, validators which do not participate in rounds do not receive XRD rewards, which provides incentive for stakers to redistribute their stake away from failed validators. Third, if a network suffers the loss of more than 1/3rd of validators by stake, it can be restarted through a manual process involving political coordination.</p>
<h2 data-number="2.5" id="stokenet"> Stokenet</h2>
<p>Due to differences in network size, latency, and workload, we suspected that issues identified in local test networks might not manifest in large-scale deployments of Radix. To that end, we adapted our test workload to run on the “Stokenet” public test network. While transaction fees limited the amount of testing we could perform, we were able to use this mechanism to reproduce key results, such as lost updates.</p>
<h2 data-number="2.6" id="mainnet"> Mainnet</h2>
<p>We also designed a passive checker which performed read-only queries against the Radix Olympia Public Network in order to look for traces of consistency anomalies. Our public-network checker started with a single validator account address, and used transaction log queries to traverse approximately six thousand reachable addresses and fifty thousand transactions.</p>
<p>We compared those transaction logs to search for cases where a transaction between accounts <span><em>a</em></span> and <span><em>b</em></span> was present in <span><em>a</em></span>’s log, but not in <span><em>b</em></span>’s log: a lost update. We also checked the status of each transaction to identify those which were in state <code>FAILED</code>, but which nonetheless appeared in transaction logs: aborted reads.</p>

<h2 data-number="3.1" id="indeterminate-transactions-during-normal-operation-1"> Indeterminate Transactions During Normal Operation (#1)</h2>
<p>As of summer 2021, RDX Works was aiming for a maximum transaction confirmation time of roughly five seconds, assuming the network was not overloaded. Transactions in our low-latency, five-to-ten node clusters generally took 100–1,000 ms to execute. However, even under healthy conditions a significant number of transactions took hundreds of seconds to definitively commit or fail. Consider this timeseries plot of transaction latencies during one 11-hour test run:</p>
<p><img src="https://jepsen.io/analyses/radix-dlt-1.0-beta.35.1/long-running-latency.png" alt="A timeseries plot of transaction latencies."/><br/>
</p>
<p>Even at only ~3 transactions per second, a significant number of transactions (the orange streak) timed out after 10 seconds. A few of those could eventually be resolved to a successful or failed state (see points above 10 seconds), but the time it took to resolve them increased exponentially over time.<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> Eventually timed-out transactions failed to resolve altogether—perhaps by falling out of cache.</p>
<p>High latencies are frustrating for users, but in theory tolerable so long as transactions eventually resolve to a definitive state: e.g. <code>CONFIRMED</code> or <code>FAILED</code>. However, at roughly five transactions per second, approximately 5–10% of submitted transactions never resolved.</p>
<p>This poses a hazard for Radix users: when one submits a transaction, there is a good chance that one simply will never know whether it took place or not. Users cannot assume it committed without running the risk that it actually failed (and presumably, their payment never going through). They also cannot assume the transaction failed and resubmit their transfer request: if the transaction <em>did</em> commit, they could pay twice as much as intended. Clients could theoretically save the computed raw transaction to resubmit it on the user’s behalf: using the same UTXO states should prevent double-spending. However, this assumes that the client is smart enough to save those raw transaction states, detect user retries, reliably differentiate them from intentional submission of duplicate transactions, and resubmit the saved transaction when desired.</p>
<p>After our work together, RDX Works replaced the archive API with a new Core API and Network Gateway. RDX Works asserts that this issue is resolved as of version 1.1.0. Since this system was developed after our testing, Jepsen has not evaluated it.</p>
<h2 data-number="3.2" id="high-latencies-during-single-faults-2"> High Latencies During Single Faults (#2)</h2>
<p>Another potentially surprising finding: when even a single node is unavailable due to a crash, pause, or network partition, median transaction latencies on the remaining nodes remain dramatically elevated for the duration of the fault. In our tests, a single fault in a five-node cluster with the default tuning options caused transaction latencies to rise by roughly 1.5 orders of magnitude.</p>
<p><img src="https://jepsen.io/analyses/radix-dlt-1.0-beta.35.1/partition-latency.png" alt="A timeseries plot of latencies broken down by operation type."/><br/>
</p>
<p>The above plot shows the latency distribution of transactions over time from a test where we submitted roughly five transactions per second, while periodically isolating a single node via a network partition. Partitions are represented by shaded tan bars from 2 to 117 seconds, from 485 to 2,135 seconds, and 2,957 to 3,612 seconds. During each of these intervals, median transaction latency jumped from ~90 ms to 5–10 seconds. A good number of operations timed out after 10 seconds: Radix does this normally, but more operations time out during faults.</p>
<p>RDX Works believes this behavior is a consequence of Radix’s consensus design. Consensus proceeds in rounds, and each round is coordinated by a single validator: the <em>leader</em>. Validators take turns being the leader, proportional to their stake. When a validator is down, the consensus rounds which that validator should have led will fail, blocking transactions from committing until the next round led by a healthy validator begins. There is presently no mechanism for detecting faulty nodes and skipping them: every time a faulty node takes a turn as the leader, the network must wait for that node to time out before proceeding to the next round.</p>
<p>One might expect that with five evenly-staked validators a single-node fault would cause only ~20% of transactions to experience high latencies. Instead, it appeared that a single-node fault affected almost every transaction. This could be because healthy leaders complete their rounds in a handful of milliseconds, but a faulty leader blocks consensus for several seconds before the cluster moves on to the next leader. If requests arrive uniformly over time, almost all requests will arrive during the faulty leader’s round, and must wait for that round to complete before a healthy leader can process them. A single faulty node can therefore affect almost all requests!</p>
<p>We suspect that two factors mitigate this issue in the Radix Olympia Public Network today. First, a large pool of validators (e.g. 100 rather than 5) increases the number of rounds led by healthy nodes. Second, higher inter-node latencies increase the time it takes for each healthy round of consensus, which means a smaller fraction of requests arrive during the unhealthy round. By contrast, our test environment featured low latencies and a small pool of validators, both of which amplify the effects of single-node faults.</p>
<p>RDX Works also has ideas for improving latency in the future. The present leader timeout is set to a relatively conservative three seconds. In our tests, lowering this timeout to 300 milliseconds cuts the upper bound on transaction latency from 10 seconds to roughly 1 second. RDX Works may be able to reduce this time-out through an update to the Radix Olympia consensus protocol, to reduce the duration of consensus rounds led by an unavailable validator. RDX Works also reports unfinished designs for mechanisms to reduce the number of proposals a seemingly faulty leader is called upon to make by allowing a validator which is timing out to be gradually reduced to zero participation, regardless of stake. Validators could fully rejoin consensus once in good health.</p>
<h2 data-number="3.3" id="non-monotonic-reads-3"> Non-Monotonic Reads (#3)</h2>
<p>Under normal operation, the transaction history of an account can fail to include committed transactions—even when those transactions are already known to be committed by that node! For instance, consider <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20210622T141905.000-0400.zip">this test run</a> in which Jepsen process #9, talking to node <code>n5</code>, submitted and confirmed transaction 4 (<code>t4</code>), which transferred 99 XRD from account 4 to account 3.</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>{<span>:process</span> <span>9</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span>:type</span>    <span>:invoke</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span>:f</span>       <span>:txn</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span>:value</span>   {<span>:id</span> <span>4</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>           <span>:from</span> <span>4</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>           <span>:ops</span> [[<span>:transfer</span> <span>4</span> <span>3</span> <span>99</span>]]}</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span>:time</span>    <span>424827567</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span>:index</span>   <span>15</span>}</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>{<span>:process</span> <span>9</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span>:type</span>    <span>:ok</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> <span>:f</span>       <span>:txn</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> <span>:value</span>   {<span>:id</span> <span>4</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>           <span>:from</span> <span>4</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>           <span>:ops</span> [[<span>:transfer</span> <span>4</span> <span>3</span> <span>99</span>]]}</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a> <span>:time</span>    <span>542953296</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a> <span>:index</span>   <span>23</span></span></code></pre></div>
<p>0.032 seconds after that transaction was known to be committed on n5, process 9 initiated a read of account 4’s transaction history. That read returned two transactions:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>{<span>:f</span>       <span>:txn-log</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a> <span>:value</span>   {<span>:account</span> <span>3</span>}</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a> <span>:time</span>    <span>575230138</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a> <span>:process</span> <span>9</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a> <span>:type</span>    <span>:invoke</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a> <span>:index</span>   <span>27</span>}</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>{<span>:f</span>       <span>:txn-log</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a> <span>:value</span>  {<span>:account</span> <span>3</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>          <span>:txns</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>          [{<span>:fee</span>     0N</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span>:message</span> <span>nil</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span>:actions</span> [...]}</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>           {<span>:fee</span>     100000000000000000N</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            <span>:message</span> <span>&#34;t1&#34;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span>:actions</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            [{<span>:type</span>      <span>:transfer</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>              <span>:to</span>        <span>&#34;brx...wq5&#34;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>              <span>:rri</span>       <span>&#34;xrd_rb1qya85pwq&#34;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>              <span>:validator</span> <span>nil</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>              <span>:from</span>      <span>&#34;brx...ahh&#34;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>              <span>:amount</span>    68N}]}]}</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a> <span>:time</span>    <span>592084345</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a> <span>:process</span> <span>9</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a> <span>:type</span>    <span>:ok</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a> <span>:index</span>   <span>30</span>}</span></code></pre></div>
<p>The first transaction affecting account 3 was an initial setup transaction and not a part of our test workload. The second transaction was a Jepsen-initiated transfer transaction labelled <code>t1</code>. So node n5 knew that <code>t4</code> was committed, and that t4 affected account 3, but also failed to show <code>t4</code> in account 3’s history! This is a stale read—not only from the perspective of the cluster as a whole, but also as viewed by n5 alone. We call this a <em>non-monotonic read</em> because successive reads performed against a single node may appear to go “backwards in time”: observing then un-observing the effects of a transaction.<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>Our Elle-based checker renders this anomaly as a cycle involving three operations. The top operation is the read of account 3 observing only <code>t1</code>. The middle operation was <code>t3</code>, which transferred funds from account 3 to account 1. Like <code>t4</code>, it must have logically occurred after the top read, because the top read did not observe <code>t3</code>: we render this as a read-write dependency labeled <code>rw</code>. The bottom operation is <code>t4</code>, which transferred funds from account 4 to account 3. We know that <code>t4</code> executed after <code>t3</code> thanks to a later read not shown here: since <code>t4</code> overwrote <code>t3</code>, there is a write-write (<code>ww</code>) dependency between them. Finally, since the top and bottom transactions took place on the same node in strict order, there is a per-process edge (<code>p</code>) between them.</p>

<p>In our testing of 1.0-beta.35.1, 1.0.0, 1.0.1, and 1.0.2, non-monotonic reads occurred frequently in healthy clusters, but were generally no more than a quarter-second out of date.</p>
<p>As of version 655dad3, balance and transaction-log reads on single nodes appeared (mostly) monotonic in our tests. In version 1.1.0, RDX Works asserts that the new Network Gateway in 1.1.0 does not exhibit this behavior.</p>

<p>Radix’s archive transaction logs may not faithfully represent the transactions which are submitted. As of 1.0.0 (but not in 1.0-beta.35.1) the transaction log always eliminates transfers from an account to itself. Moreover, Radix archive nodes would occasionally insert actions into transactions with type <code>UNKNOWN</code> and no values for the <code>from</code>, <code>to</code>, <code>validator</code>, <code>rri</code>, or <code>amount</code> field. For example, consider this transaction as it was submitted to Radix:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>{<span>:message</span> <span>&#34;t53265&#34;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a> <span>:actions</span> [{<span>:type</span> <span>:transfer</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>2902</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            <span>:to</span> <span>2901</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>            <span>:amount</span> 300000000000000000N</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span>:rri</span> <span>&#34;xrd_dr1qyrs8qwl&#34;</span>}</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>           {<span>:type</span> <span>:transfer</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>2902</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span>:to</span> <span>2901</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span>:amount</span> 8400000000000000000N</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            <span>:rri</span> <span>&#34;xrd_dr1qyrs8qwl&#34;</span>}]}</span></code></pre></div>
<p>… versus that same transaction’s representation in the archive transaction log:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>{<span>:fee</span> <span>177200000000000000</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a> <span>:message</span> <span>&#34;t53265&#34;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a> <span>:actions</span> [{<span>:amount</span> <span>300000000000000000</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>            <span>:validator</span> <span>nil</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>            <span>:type</span> <span>:transfer</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            <span>:rri</span> <span>&#34;xrd_dr1qyrs8qwl&#34;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>2902</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span>:to</span> <span>2901</span>}</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>           {<span>:amount</span> <span>8400000000000000000</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            <span>:validator</span> <span>nil</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            <span>:type</span> <span>:transfer</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            <span>:rri</span> <span>&#34;xrd_dr1qyrs8qwl&#34;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>2902</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span>:to</span> <span>2901</span>}</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>           {<span>:amount</span> <span>nil</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span>:validator</span> <span>nil</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span>:type</span> <span>:unknown</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            <span>:rri</span> <span>nil</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>nil</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            <span>:to</span> <span>nil</span>}]}</span></code></pre></div>
<p>Transaction 53265 somehow gained an extra <code>unknown</code> action. This behavior occurred in healthy clusters running version 1.0.0, but was (initially) relatively infrequent. In recent development builds, we observed these anomalies in up to ~50% of submitted transactions.</p>
<p>Both the omission of self-transfers and the insertion of spurious <code>unknown</code> actions seem like relatively minor problems: self-transfers don’t (by definition) affect the overall balance of an account, and the <code>unknown</code> actions don’t either. However, this could be surprising for Radix users who expected to see the transactions they originally submitted.</p>
<p>The omission of self-transfers is a consequence of how Radix’s archive subsystem interpreted unspent transaction outputs: the encoding of self-transfers in Radix’s ledger makes them indistinguishable from “getting change back” from another transfer. Radix is unsure why the archive API inserts spurious unknown actions into transaction logs.</p>
<p>These questions are largely moot: RDX Works has removed the archive subsystem altogether in version 1.1.0. The Network Gateway now infers the structure of actions in transaction logs from Radix’s ledger.</p>
<h2 data-number="3.5" id="premature-commits-in-development-builds-5"> Premature Commits in Development Builds (#5)</h2>
<p>The unreleased development build 48461c4 dramatically improved Radix latencies—but also exhibited a new class of anomaly: the write order of transactions could be contrary to the real-time order in which they were submitted. These issues manifested within minutes in healthy clusters, and were exemplified by cycles like the following:</p>

<p>Here transaction 5581 was confirmed 9 milliseconds before transaction 5582 was even submitted: we have a real-time (<code>rt</code>) edge from 5581 to 5582. However, later reads of the raw transaction log returned values like <code>(... 5577 5579 5582 5581)</code>, which tells us that 5582 committed before 5581: a write-write (<code>ww</code>) dependency. Transactions in Radix were supposed to be <a href="https://jepsen.io/consistency/models/strict-serializable">strict serializable</a>, which means they should appear to take effect in an order consistent with the real-time order in which they were submitted. However, transaction 5582 took effect before 5581, even though 5581 was (apparently) committed before 5582 even began!</p>
<p>We also frequently observed cases in version 48461c4 where two transactions which conflicted with one another would both appear to commit. This allowed a form of <a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf">double-spend attack</a>: Alexis could pay Brendan $1,000 for a laptop using Radix, and both Alexis and Brendan would see that payment transaction as committed in Radix.<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a> Brendan would then ship Alexis the laptop. Contemporaneously, Alexis could stash their entire (pre-payment) account balance in another account they controlled. If the stash transaction committed, Alexis would retain all their money <em>and</em> get a free laptop.</p>
<p>We wrote a test workload to perform this attack and found that frequently, both spend and stash transactions would be successfully confirmed—even though at most one could have possibly succeeded. Spend and stash transactions could be conducted concurrently, or the stash could be executed strictly after the payment was confirmed, or vice-versa. All approaches <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20210819T082406.000-0400.zip">allowed double-spend</a>, but the most successful approach was to submit the stash transaction first—doing so allowed roughly 8% of payments to appear to succeed, but for Alexis to actually keep their money.</p>
<p>Both of these problems stemmed from a <a href="https://github.com/radixdlt/radixdlt/commit/350ac777a09452a636839d4ffb3267eba0a57b52">bug in the transaction status service</a> which returned <code>CONFIRMED</code> for pending transactions, not just confirmed transactions. This allowed transactions to be reported as confirmed before their actual commit time (causing G0-real-time) and for transactions to be reported as confirmed when they would later go on to fail. That bug was patched in <a href="https://github.com/radixdlt/radixdlt/commit/350ac777a09452a636839d4ffb3267eba0a57b52">350ac77</a>, which appears to have resolved the issue and returned commit latencies to their previous range. Version 48461c4 never made it into a release, and users should not have been affected.</p>
<h2 data-number="3.6" id="committed-transactions-could-have-status-failed-6"> Committed Transactions Could Have Status <code>FAILED</code> (#6)</h2>
<p>Under normal operation without faults, transactions with status <code>FAILED</code> could actually be committed. In <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20210804T084751.000-0400.zip">this test run</a> with no faults, a cluster of transactions were reported as <code>FAILED</code> but were actually visible in the transaction log. Here is transaction 10750, which had status <code>FAILED</code>…</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>{<span>:time</span>    <span>927331078170</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a> <span>:process</span> <span>886</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a> <span>:type</span>    <span>:fail</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a> <span>:f</span>       <span>:txn</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a> <span>:value</span>   {<span>:id</span>     <span>10750</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>           <span>:from</span>   <span>570</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>           <span>:ops</span>    [...]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>           <span>:txn-id</span> <span>&#34;c33...6d9&#34;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>           <span>:fee</span>    162600000000000000N}</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a> <span>:index</span>   <span>54689</span>}</span></code></pre></div>
<p>… but also appeared in subsequent reads of the transaction log!</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>{<span>:time</span> <span>928355977217</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a> <span>:process</span> <span>12</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a> <span>:type</span> <span>:ok</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a> <span>:f</span> <span>:txn-log</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a> <span>:value</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a> {<span>:account</span> <span>570</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span>:txns</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  [...</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>   {<span>:fee</span> 162600000000000000N</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span>:message</span> <span>&#34;t10750&#34;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span>:actions</span> [...]}]}</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a> <span>:index</span> <span>54743</span>}}</span></code></pre></div>
<p>This applied both to the archive API and the raw transaction logs. Version 1.0.0 was affected; 1.0.1 and 1.0.2 were likely susceptible as well. Since failed transactions were visible to reads, this anomaly is akin to phenomenon G1a: aborted read.</p>
<p>This issue was reproducible in our test clusters with as few as 1.5 transactions per second. It also occurred in the Radix Olympia Public Network. For example, <a href="https://explorer.radixdlt.com/#/transactions/50c46b111ba2f3e2d53a4399486ed0ad0f0c6e91dccce3e161d118d8346df347">transaction 50c46b1</a>, submitted on October 1 2021, appeared in the transaction logs for <a href="https://explorer.radixdlt.com/#/accounts/rdx1qspg0e9d6mqplasehhhrrh3a5xsnhy8y0w3d25rc4j0fhuqf7ldsa2q8tuvcj">both</a> <a href="https://explorer.radixdlt.com/#/accounts/rdx1qspghqm82jgvkjy8tpq3zqggxdtwkp22spnhqy6u7ugjqfu62my42yc32xvqx">involved</a> accounts. However, its transaction state on October 1 (read after observing that transaction in account logs) was <code>FAILED</code>. Two days later, on October 3rd, its state flipped to <code>CONFIRMED</code>.</p>
<p>On October 4th we ran our public-network checker again and found <em>four</em> apparently-failed-but-actually-committed transactions (<a href="https://explorer.radixdlt.com/#/transactions/6ebb247d2fad3662ca950038f5ff50dc417bfbce1f7f29b96be97d269fd5e4c5">6ebb247</a>, <a href="https://explorer.radixdlt.com/#/transactions/8d054880cb31a0e103419b563f93afff601047397848a341a6c84fd6d96bc941">8d05488</a>, <a href="https://explorer.radixdlt.com/#/transactions/ab8a78a8c7a0db716997b81e3a120f0ef945e5c889098ce17ddcd73459f877ac">ab8a78a</a>, and <a href="https://explorer.radixdlt.com/#/transactions/5428543ab3de7e50150d64fe0bee4a77e7144f27699231c5a0af751d781f46f0">5428543</a>) submitted in a ten-minute window; all had status <code>FAILED</code> roughly an hour after submission, but flipped to <code>CONFIRMED</code> shortly thereafter. A fifth committed transaction (<a href="https://explorer.radixdlt.com/#/transactions/e563bad72d2e14486d82d6f7e55f7ca8152c2a9ec10e9c77ca2ae1f3e865ba31">e563bad</a>) persisted in state <code>FAILED</code> for several hours.</p>
<p>RDX Works suspects this issue occurred when a transaction committed normally but had been gossipped to other nodes’ mempools; if those nodes then gossiped the transaction <em>back</em> to the original node, that node would recognize that the transaction had already committed and reject the gossip message. Concluding the transaction was rejected, Radix would then overwrite the transaction’s status to flag it as <code>FAILED</code>. When the transaction later fell out of cache, subsequent reads would query the log directly, and observe its state as <code>CONFIRMED</code>.</p>
<p>This issue was initially resolved in 48461c4. RDX Works asserts it does not appear in version 1.1.0’s Network Gateway service either.</p>
<h2 data-number="3.7" id="missing-transactions-7"> Missing Transactions (#7)</h2>
<p>Under normal operation, committed transactions may fail to appear in transaction logs. A validator will insist that the transaction is confirmed, and the balances of involved accounts will change, but some (but not necessarily all!) of those accounts’ transaction logs will never contain the transaction. For example, consider <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/small-g0-20210625T164951.000-0400.zip">this test run</a>, in which transaction-log reads of account 4 all began with the following:<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>{<span>:account</span> <span>4</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a> <span>:txns</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a> [...</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  {<span>:message</span> <span>&#34;t0&#34;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>1</span>, <span>:to</span> <span>4</span>, <span>:amount</span> 46N}]}</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  {<span>:message</span> <span>&#34;t8&#34;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>1</span>, <span>:to</span> <span>4</span>, <span>:amount</span> 36N}]}</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  {<span>:message</span> <span>&#34;t10&#34;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>4</span>, <span>:to</span> <span>1</span>, <span>:amount</span> 1N}</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    {<span>:type</span> <span>:transfer</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>4</span>, <span>:to</span> <span>5</span>, <span>:amount</span> 28N}]}</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  {<span>:message</span> <span>&#34;t12&#34;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>4</span>, <span>:to</span> <span>4</span>, <span>:amount</span> 85N}</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    {<span>:type</span> <span>:transfer</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>4</span>, <span>:to</span> <span>4</span>, <span>:amount</span> 7N}]}</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>  {<span>:message</span> <span>&#34;t14&#34;</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>5</span>, <span>:to</span> <span>4</span>, <span>:amount</span> 43N}]}</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a> ...]}</span></code></pre></div>
<p>Meanwhile, transaction logs of account 5 all began with:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>{<span>:account</span> <span>5</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a> <span>:txns</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a> [{<span>:message</span> <span>&#34;t4&#34;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>3</span>, <span>:to</span> <span>5</span>, <span>:amount</span> 28N}]}</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  {<span>:message</span> <span>&#34;t7&#34;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>2</span>, <span>:to</span> <span>5</span>, <span>:amount</span> 81N}</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    {<span>:type</span> <span>:transfer</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>2</span>, <span>:to</span> <span>5</span>, <span>:amount</span> 94N}]}</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  {<span>:message</span> <span>&#34;t9&#34;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>5</span>, <span>:to</span> <span>4</span>, <span>:amount</span> 42N}]}</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  {<span>:message</span> <span>&#34;t10&#34;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>4</span>, <span>:to</span> <span>1</span>, <span>:amount</span> 1N}</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    {<span>:type</span> <span>:transfer</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>4</span>, <span>:to</span> <span>5</span>, <span>:amount</span> 28N}]}</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>  {<span>:message</span> <span>&#34;t14&#34;</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>   <span>:actions</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>   [{<span>:type</span> <span>:transfer</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>     <span>:from</span> <span>5</span>, <span>:to</span> <span>4</span>, <span>:amount</span> 43N}]}]}</span></code></pre></div>
<p>The problem here is not immediately apparent—but on closer inspection transaction 9 (<code>t9</code>), which transferred 42 XRD from account 5 to 4, was present in account 5’s log but missing from account 4. Account 4 skips directly from <code>t8</code> to <code>t10</code>!</p>
<p>If we take these transaction logs at face value, then we must conclude that on account 4 <code>t9</code> must have executed after <code>t14</code>. It certainly can’t have executed before, or it would have appeared in the log. On account 5, <code>t9</code> executes directly before <code>t10</code>. In list-append terms, we have the following cycle:</p>

<p>From account 5 we know <code>t9</code> (bottom) executed on account 5 before <code>t10</code> (top), and it was followed by <code>t14</code> (middle). However, on account 4, <code>t14</code> must have executed before <code>t9</code>: a cycle. Since all of the edges in this cycle are write-write dependencies, this anomaly is called G0, or <em>write cycle</em>, and it implies this history violates read-uncommitted. It is also therefore not serializable.</p>
<p>In this particular example <code>t9</code> appeared to have committed. The transaction status API claimed that <code>t9</code> committed, and account 4’s balance increased by 42 XRD during <code>t9</code>’s window of execution. It could be that this issue is limited only to transaction-log reads, and the internal transactions themselves are still strict serializable.</p>
<p>However, even a read-only omission of a transaction has serious consequences. The balance of a Radix account, as visible to users, might not be the sum of its recorded transactions: it is possible to gain or lose tokens and not be able to explain why. Two account histories can disagree on whether a transaction took place. From an accounting perspective, this is a violation of double-ledger bookkeeping principles. Balances can also (at least according to the transaction log) become negative—withdrawing more money from an account than the account ever contained.</p>
<p>This problem occurred in healthy clusters running version 1.0-beta.35.1, 1.0.0, 1.0.1, 1.0.2, and numerous development builds. It affected all nodes equally—when a transaction disappeared, clients could not recover it by reading from another node. It occurred even at low throughputs: at just 0.125 transactions per second, we were <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20211003T125820.000-0400.zip">able to observe</a> dozens of “confirmed” transactions which failed to appear in some or all transaction logs. We were also able to reproduce this issue in Stokenet, Radix’s public test network: even at rates as low as 1 transaction per second, 5–10% of transactions vanished from some (but not necessarily all!) account transaction logs.</p>
<p>At least one transaction has already gone missing from account histories in the Radix Olympia Public Network. For instance, transaction <a href="https://explorer.radixdlt.com/#/transactions/63b848520727a32d9da405c2c6f8b5ec8b58cb85b675dda7e188f143655af2e6">63b8485…</a> transferred 0.9 XRD from <a href="https://explorer.radixdlt.com/#/accounts/rdx1qspazklduee55nkcsr6qexpphavu2cny86scz24esze3aegrr0j5suq96rxfx">rdx…q96rxfx</a> to <a href="https://explorer.radixdlt.com/#/accounts/rdx1qspsgtz8wxzhs7h3m5dxz4uw0a350qp567zz4v9xgamcag8kavsxvpctcgge2">rdx…ctcgge2</a>. As of October 1, 2021, that transaction appeared in <code>suq96rxfx</code>’s transaction log, but did <em>not</em> appear in <code>ctcgge2</code>’s log.</p>
<p>These issues were addressed by replacing the transaction log archive system in version 655dad3. RDX Works asserts this issue does not appear in the Network Gateway, as of version 1.1.0.</p>
<h2 data-number="3.8" id="contradictory-logs-8"> Contradictory Logs (#8)</h2>
<p>Transaction log anomalies were not limited to simple omissions. Two reads of an account’s transaction log executed against a single node could contradict one another. For example, take <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20210709T105533.000-0400.zip">this test run</a> where process 39, making a series of transaction-log requests to node <code>n5</code>, observed the following logs for account 27:</p>
<table>
<thead>
<tr>
<th>Process</th>
<th>Time (s)</th>
<th>Transaction IDs</th>
</tr>
</thead>
<tbody>
<tr>
<td>39</td>
<td>289.03</td>
<td>()</td>
</tr>
<tr>
<td>39</td>
<td>292.85</td>
<td>()</td>
</tr>
<tr>
<td>39</td>
<td>293.82</td>
<td>()</td>
</tr>
<tr>
<td>39</td>
<td>296.54</td>
<td>(5310)</td>
</tr>
<tr>
<td>39</td>
<td>297.29</td>
<td>(5310)</td>
</tr>
<tr>
<td>39</td>
<td>297.51</td>
<td>(5310)</td>
</tr>
<tr>
<td>39</td>
<td>297.63</td>
<td>(5310)</td>
</tr>
<tr>
<td>39</td>
<td>298.55</td>
<td>(5310)</td>
</tr>
<tr>
<td>39</td>
<td>298.83</td>
<td>(5310)</td>
</tr>
<tr>
<td>39</td>
<td>299.15</td>
<td>(5310)</td>
</tr>
<tr>
<td>39</td>
<td>300.41</td>
<td>(5310)</td>
</tr>
<tr>
<td>39</td>
<td>300.62</td>
<td>(5310, <em>5336</em>)</td>
</tr>
<tr>
<td>39</td>
<td>301.64</td>
<td>(5310, 5334)</td>
</tr>
<tr>
<td>39</td>
<td>302.69</td>
<td>(5310, 5334)</td>
</tr>
<tr>
<td>39</td>
<td>305.30</td>
<td>(5310, 5334)</td>
</tr>
<tr>
<td>39</td>
<td>307.58</td>
<td>(5310, 5334, 5345)</td>
</tr>
<tr>
<td>39</td>
<td>307.97</td>
<td>(5310, 5334, 5345)</td>
</tr>
</tbody>
</table>
<p>Transaction 5336 was briefly visible in the transaction log, then replaced by transaction 5334. This should be impossible: if transactions are only appended to the log for a given account, they should never disappear; nor should two views of the transaction log disagree about the transaction at a particular index. This is worse than simply omitting a transaction from the log!</p>
<p>These errors occurred in 1.0-beta.35.1 and 1.0.0, in healthy clusters under normal operation. They likely affected 1.0.1 and 1.0.2 as well. However, they appeared infrequently: roughly one in 20,000 transaction log requests. They also seemed to be transient—a transaction would appear for a single read, then immediately disappear and never be seen again. They appeared not only in the archive API’s view of a single account’s transactions, but also in the raw transaction log.</p>
<p>We don’t know what caused this issue, but it was no longer reproducible as of version 655dad3. It’s possible that raising the BerkeleyDB safety level (which also allowed transaction loss) resolved this problem in raw logs, and replacing the archive subsystem for transaction logs addressed its occurrence in per-account logs.</p>
<p>After our work together, RDX Works completely replaced the archive node system with their new Core API/Network Gateway architecture. Transaction logs no longer exist in 1.1.0; RDX Works believes this issue no longer applies.</p>
<h2 data-number="3.9" id="split-brain-transaction-loss-9"> Split-Brain Transaction Loss (#9)</h2>
<p>In version 1.0.0, process crashes could lead some (but not all!) nodes to lose a committed transaction from the history for an account. Queries for transaction history on that node would omit that transaction, but queries against other nodes would reflect it. This state would persist indefinitely. For example consider <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20210802T092122.000-0400.zip">this test run</a>, in which reads of account 16, performed on various nodes, observed the following transaction logs:</p>
<table>
<thead>
<tr>
<th>Node</th>
<th>Time</th>
<th>Transaction IDs</th>
</tr>
</thead>
<tbody>
<tr>
<td>n1</td>
<td>72</td>
<td>(264)</td>
</tr>
<tr>
<td>n3</td>
<td>74</td>
<td>(264)</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>n4</td>
<td>96</td>
<td>(264)</td>
</tr>
<tr>
<td>n5</td>
<td>98</td>
<td>(264, 267)</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>n5</td>
<td>127</td>
<td>(264, 267, 474)</td>
</tr>
<tr>
<td>n4</td>
<td>127</td>
<td>(264, 267, 474)</td>
</tr>
<tr>
<td>n5</td>
<td>128</td>
<td>(264, 267, 474)</td>
</tr>
<tr>
<td>n2</td>
<td>134</td>
<td>(264, 267, 474)</td>
</tr>
<tr>
<td>n1</td>
<td>134</td>
<td>(264)</td>
</tr>
<tr>
<td>n1</td>
<td>138</td>
<td>(264, <em>474</em>)</td>
</tr>
<tr>
<td>n4</td>
<td>138</td>
<td>(264, 267, 474)</td>
</tr>
<tr>
<td>n1</td>
<td>139</td>
<td>(264, <em>474</em>)</td>
</tr>
<tr>
<td>n5</td>
<td>141</td>
<td>(264, 267, 474)</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>n4</td>
<td>333</td>
<td>(264, 267, 474, 812, 831, 1022, 1075)</td>
</tr>
<tr>
<td>n1</td>
<td>335</td>
<td>(264, <em>474</em>, 812, 831, 1022, 1075)</td>
</tr>
<tr>
<td>n5</td>
<td>339</td>
<td>(264, 267, 474, 812, 831, 1022, 1075)</td>
</tr>
<tr>
<td>n3</td>
<td>340</td>
<td>(264, 267, 474, 812, 831, 1022, 1075)</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>n1</td>
<td>592</td>
<td>(264, <em>474</em>, 812, 831, 1022, 1075, …)</td>
</tr>
</tbody>
</table>
<p>Transaction 267 was submitted at 64 seconds, confirmed as committed by 98.95 seconds, and visible in transaction histories on nodes <code>n2</code>, <code>n3</code>, <code>n4</code>, and <code>n5</code> beginning at 98 seconds. However, node <code>n1</code> (which was killed 114 seconds into the test) never observed transaction 267—despite recording additional transactions over the next several hundred seconds.</p>
<p>We never identified the cause of this issue. It was initially resolved in version 655dad3 by completely rewriting the archive transaction log subsystem. RDX Works asserts that this issue is also resolved in the new Core API/Gateway design.</p>
<h2 data-number="3.10" id="raw-log-write-loss-on-crash-10"> Raw Log Write Loss On Crash (#10)</h2>
<p>During process crashes, Radix 1.0.0’s raw transaction log could lose committed transactions—even those which were universally agreed upon. For example take <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20210805T013212.000-0400.zip">this test</a>, where transaction 4643 committed between 354 and 359 seconds into the test. At 362 seconds, Jepsen killed every node in the cluster. Reads of the raw transaction log returned the following lists of transactions:</p>
<table>
<thead>
<tr>
<th>Node</th>
<th>Time</th>
<th>Transaction IDs</th>
</tr>
</thead>
<tbody>
<tr>
<td>n3</td>
<td>359</td>
<td>(3766, 3767, 4643)</td>
</tr>
<tr>
<td>n4</td>
<td>359</td>
<td>(3766, 3767, 4643)</td>
</tr>
<tr>
<td>n2</td>
<td>359</td>
<td>(3766, 3767, 4643, 4640, 4647)</td>
</tr>
<tr>
<td>n2</td>
<td>359</td>
<td>(3766, 3767, 4643, 4640, 4647)</td>
</tr>
<tr>
<td>n1</td>
<td>359</td>
<td>(3766, 3767, 4643, 4640, 4647)</td>
</tr>
<tr>
<td>n5</td>
<td>359</td>
<td>(3766, 3767, 4643, 4640, 4647)</td>
</tr>
<tr>
<td>n3</td>
<td>359</td>
<td>(3766, 3767, 4643, 4640, 4647, 4648)</td>
</tr>
<tr>
<td>n2</td>
<td>360</td>
<td>(3766, 3767, 4643, 4640, 4647, 4648)</td>
</tr>
<tr>
<td>n2</td>
<td>360</td>
<td>(3766, 3767, 4643, 4640, 4647, 4648)</td>
</tr>
<tr>
<td>n5</td>
<td>369</td>
<td>(3766, 3767)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n5</td>
<td>375</td>
<td>(3766, 3767, 4894, 4904, 4905)</td>
</tr>
</tbody>
</table>
<p>Despite transaction <code>t4643</code> being visible on every node, <code>t4643</code> (along with <code>t4640</code>, <code>t4647</code>, and <code>t4648</code>) was lost after Jepsen killed the entire cluster. <code>t4643</code> never reappeared, and Radix continued as if it had never happened.</p>
<p>This problem occurred only in cases where every node was killed at roughly the same time. This suggested a problem with disk persistence: perhaps validators did not actually write transactions to disk before considering them acknowledged. Indeed, RDX Works had chosen <code>COMMIT_NO_SYNC</code> when configuring the ledger’s underlying BerkeleyDB storage system. <a href="https://github.com/radixdlt/radixdlt/commit/704ee58fe9fefa92a2324a40d21483e96f5f4658">Changing the durability level to <code>COMMIT_SYNC</code></a> appears to have addressed the issue. This fix was first available in version 1.1.0.</p>

<p>Under normal operation, Radix regularly returned balances for accounts which did not correspond to any point in the transaction log—or indeed, to <em>any</em> combination of possible transactions. For example, consider account 52 from <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20210707T155344.000-0400.zip">this test run</a>, whose first two transactions were:<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>{<span>:fee</span> <span>1</span>,</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a> <span>:actions</span> ({<span>:amount</span> <span>75</span>, <span>:type</span> <span>:transfer</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>51</span>, <span>:to</span> <span>52</span>}</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>           {<span>:amount</span> <span>29</span>, <span>:type</span> <span>:transfer</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>51</span>, <span>:to</span> <span>50</span>}</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>           {<span>:amount</span> <span>67</span>, <span>:type</span> <span>:transfer</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>51</span>, <span>:to</span> <span>52</span>}),</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a> <span>:id</span> <span>717</span>,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a> <span>:balance</span> <span>0</span>,</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a> <span>:balance</span>&#39; <span>142</span>}</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>{<span>:fee</span> <span>1</span>,</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a> <span>:actions</span> ({<span>:amount</span> <span>26</span>, <span>:type</span> <span>:transfer</span>,</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>51</span>, <span>:to</span> <span>51</span>}</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>           {<span>:amount</span> <span>66</span>, <span>:type</span> <span>:transfer</span>,</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>51</span>, <span>:to</span> <span>52</span>}</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>           {<span>:amount</span> <span>69</span>, <span>:type</span> <span>:transfer</span>,</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>51</span>, <span>:to</span> <span>52</span>}</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>           {<span>:amount</span> <span>48</span>, <span>:type</span> <span>:transfer</span>,</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            <span>:from</span> <span>51</span>, <span>:to</span> <span>51</span>}),</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a> <span>:id</span> <span>720</span>,</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a> <span>:balance</span> <span>142</span>,</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a> <span>:balance</span>&#39; <span>277</span>}</span></code></pre></div>
<p>No other transactions were concurrent during this time, so the only possible values account 52 could have taken on were 0 (the initial state), 142 (after transaction 717), and 277 (after transaction 720). Yet after transaction 720, a read of account 52 observed a balance of 208!</p>
<p>A close look at <code>t720</code> reveals the problem. It began with an inferred balance of 142: the result of applying <code>t717</code>. It then transferred 66 XRD from account 51 to account 52, which would have resulted in a balance of 208—before moving on to transfer another 69 XRD to 52, resulting in a final balance of 277. It appears that this balance read observed a value from <em>partway through</em> <code>t720</code>: an intermediate read. This implies Radix was not actually read committed.</p>
<p>This behavior occurred regularly in healthy clusters. At just ten transactions per second, roughly one in three hundred reads observed an intermediate state. They were present in 1.0-beta.35.1 as well as 1.0.0. RDX Works initially fixed this issue in fb1bc43 by <a href="https://github.com/radixdlt/radixdlt/pull/486">rewriting the account info storage service</a>. RDX Works asserts that this issue is also resolved in the new Core API/Gateway design.</p>
<h2 data-number="3.12" id="more-committed-transactions-with-status-failed-12"> More Committed Transactions With Status <code>FAILED</code> (#12)</h2>
<p>Version 655dad3 addressed many of the most frequent problems with transaction logs. However it still exhibited aborted reads in which transactions could (very rarely) have status <code>FAILED</code> but appear in transaction logs. For instance, consider <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20211006T154521.000Z.zip">this test run</a>, in which transaction 4743 was submitted to node n3 at 296.27 seconds, checked on n5 at 330.65 seconds, and found to be <code>FAILED</code>. However, every subsequent read of account 28 included transaction 4743, beginning at 331.53 seconds.</p>
<p>This problem appeared to be much rarer than previous aborted reads: we observed it only four times in ~20 hours of testing. Thus far it has appeared only in tests which included network partitions, or with combined process crashes and membership changes.</p>
<p>RDX Works did not report a cause for this issue. However, they assert the new Core API/Network Gateway architecture in version 1.1.0 resolves it.</p>
<h2 data-number="3.13" id="more-non-monotonic-reads-13"> More Non-Monotonic Reads (#13)</h2>
<p>In tests of version 655dad3 with membership changes and process crashes, a pair of reads performed sequentially against a single recently-joined Radix node could observe a later state <em>before</em> an earlier state. For instance, <a href="http://jepsen.io.s3.amazonaws.com/analyses/radix-dlt-1.0-beta.35.1/20211020T121634.000-0400.zip">this test run</a> contained the following cycle:</p>

<p>The bottom-most transaction in this cycle was a balance read of account 1, which observed a balance that could only have resulted from applying transactions 0, 3, and 52. At the top of the cycle, two subsequent transactions performed on the same node observed no balance at all for account 92, and an empty transaction log for account 14. However, that empty state of account 14 must have <em>preceded</em> transaction 52 on account 1, through a chain of read-write (rw) and write-write (ww) dependencies. This implies that the state of this single node “went backwards” relative to the transaction-log order.</p>
<p>RDX Works did not report a cause for this issue. However, they assert that it does not appear in their new Core API/Network Gateway architecture, in version 1.1.0.</p>
<table>
<thead>
<tr>
<th>№</th>
<th>Summary</th>
<th>Event Required</th>
<th>Reported Fixed</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Indeterminate transactions during normal operation</td>
<td>None</td>
<td>1.1.0</td>
</tr>
<tr>
<td>2</td>
<td>High latencies during single faults</td>
<td>Single crash, partition, etc.</td>
<td>Unresolved</td>
</tr>
<tr>
<td>3</td>
<td>Non-monotonic reads</td>
<td>None</td>
<td>1.1.0</td>
</tr>
<tr>
<td>4</td>
<td>Missing &amp; extra actions in transaction logs</td>
<td>None</td>
<td>1.1.0</td>
</tr>
<tr>
<td>5</td>
<td>Premature commits in development builds</td>
<td>None</td>
<td>350ac77</td>
</tr>
<tr>
<td>6</td>
<td>Committed transactions have status <code>FAILED</code></td>
<td>None</td>
<td>1.1.0</td>
</tr>
<tr>
<td>7</td>
<td>Missing transactions in transaction logs</td>
<td>None</td>
<td>1.1.0</td>
</tr>
<tr>
<td>8</td>
<td>Contradictory transaction logs</td>
<td>None</td>
<td>1.1.0</td>
</tr>
<tr>
<td>9</td>
<td>Split-brain transaction loss</td>
<td>Single-node crash</td>
<td>1.1.0</td>
</tr>
<tr>
<td>10</td>
<td>Loss of committed transactions from raw log</td>
<td>All nodes crash</td>
<td>1.1.0</td>
</tr>
<tr>
<td>11</td>
<td>Intermediate balance reads</td>
<td>None</td>
<td>1.1.0</td>
</tr>
<tr>
<td>12</td>
<td>More committed transactions with status <code>FAILED</code></td>
<td>Network partitions</td>
<td>1.1.0</td>
</tr>
<tr>
<td>13</td>
<td>More non-monotonic reads</td>
<td>Membership changes and crashes</td>
<td>1.1.0</td>
</tr>
</tbody>
</table>

<p>RDX Works intended to offer a distributed ledger with strict-serializable transactions and per-node monotonicity. However, under normal operation, our Radix test clusters exhibited stale reads of balances and transaction logs, intermediate reads of balances, transient and long-lasting loss of transactions from account histories, and aborted reads where failed transactions could actually commit. We observed transaction loss and aborted reads in the Radix Olympia Public Network. Transaction logs failed to faithfully represent submitted transactions by omitting some actions and spuriously inserting <code>UNKNOWN</code> actions. Nodes could lose transactions and enter permanent split-brain in response to process crashes.</p>
<p>Many of these issues stemmed from the archive API’s index structures, which failed to properly track the underlying ledger. However, Radix could also lose transactions from the raw ledger itself when all nodes crashed concurrently, due to an inappropriate choice of <code>COMMIT_NO_SYNC</code> as the safety level for the underlying BerkeleyDB storage system.<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>In addition, we found significant liveness and performance issues. Transaction throughput peaked at ~16 transactions per second in five- to ten-node clusters with near-zero latency. A significant fraction of transactions in our testing took tens or even hundreds of seconds to resolve to <code>CONFIRMED</code> or <code>FAILED</code>; far more never resolved at all. Single-node faults caused significantly elevated latencies for almost all transactions, though this behavior may be specific to our low-latency, 5–10-node test clusters.</p>
<p>In response to these issues, RDX Works opted to replace their archive node system with a different architecture. The updated architecture involves a split between a low-level event stream exposed by one or more Radix nodes (the <em>Core API</em>), and a new network service which consumes and aggregates Core API information, and exposes it to clients via HTTP (the <a href="https://docs.radixdlt.com/main/apis/gateway-api.html"><em>Gateway API</em></a>).</p>
<p>The Core API was released in <a href="https://github.com/radixdlt/radixdlt/releases/tag/1.1.0">Radix 1.1.0</a>, on January 17, 2022. The Gateway API was released with <a href="https://github.com/radixdlt/radixdlt-network-gateway/releases/tag/1.0.0">Network Gateway 1.0.0</a> on January 20, 2022. A Radix Wallet which integrated the Gateway API was released at version 1.3.0 on January 27, 2022, and an updated version of the <a href="https://explorer.radixdlt.com/">Radix Explorer</a> web site was released on the same date.</p>
<p>RDX Works asserts that as of January 27, 2022, all identified safety issues have been fixed, liveness issues with individual transactions have been fixed, and one issue relating to performance in networks with non-participating validators remains. They also report that with multiple test passes running hundreds of thousands of transactions across multiple test networks, RDX Works is no longer able to reproduce the resolved issues. Jepsen congratulates RDX Works on these advances.</p>
<p>Jepsen has verified none of RDX Works’s claims since the end of our testing on November 5, 2021.</p>
<h2 data-number="4.1" id="ordering"> Ordering</h2>
<p>By design, Radix does not offer strict serializability: reads of the transaction log or balances do not go through consensus, but instead return whatever state the local node happens to have. This state could be arbitrarily stale. If a client issued queries to multiple nodes it could observe a transaction commit, then fail to see that transaction’s effects; under normal operation we routinely observed stale reads. Since this is not documented, we believe it is worth stating explicitly. Users should be aware that reads from archive nodes may not reflect the most recent state of Radix. Confirmed transactions may not be visible depending on which validator one is talking to. RDX Works states that they do not believe this behavior is acceptable.</p>
<p>RDX Works reports the new Gateway API includes a ledger state object with all read responses. This ledger state includes the epoch, round number, and state version which the request observed. Clients can employ these numbers as a causality token to obtain monotonic views of the ledger, even across gateways and validators. This is not sufficient to prevent stale reads in general, but Jepsen (from a cursory discussion of the feature) suspects it might be sufficient for <a href="https://jepsen.io/consistency/models/sequential">sequential consistency</a>—and, by extension, <a href="https://jepsen.io/consistency/models/read-your-writes">read your writes</a>.</p>
<h2 data-number="4.2" id="performance"> Performance</h2>
<p>As of July 2021, the Radix Olympia Public Mainnet targeted ~50 transactions per second on a globally distributed network of 100 validator nodes, with transactions confirmed on ledger generally within five seconds, so long as the network is not overloaded. In our testing with five to ten validators, transaction throughput rarely exceeded 16 transactions per second. Even request rates as low as 1 transaction per second resulted in strongly bimodal latencies: most transactions confirming or failing within ~100–1000 ms, and ~5–10% taking tens or even hundreds of seconds to resolve—or never resolving at all. We routinely observed transactions get “stuck” in a pending state for at least 11 hours.<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<p>As of February 2, 2022, RDX Works assserts that the issue with some transactions taking abnormally long to process has been resolved (when the network is operating within capacity). Jepsen has not verified this assertion. Whenever possible, clients should cache the finalized transaction just prior to submission and save it for resubmission in the event that it does not resolve—as well as providing explicit workflows for retries. The alternative is to risk transactions never going through, or to potentially pay twice (or three times!) the required amount.</p>
<p>RDX Works states that they consistently observe sustained throughput of 40–50 transactions per second in globally distributed Olympia test networks, and believe that our lower observed throughput is a consequence of our testing methodology rather than the network being incapable of processing a greater throughput. In particular, RDX Works points to the fact that our test harness used Radix’s Java client and HTTP APIs to construct and submit transactions from outside the network, and that these transactions might have higher contention.</p>
<p>RDX Works also reports they have conducted sustained stress tests using their new <a href="https://docs.radixpool.com/bleeding-edge/core-api-and-network-gateway-overview">Core API/Network Gateway architecture</a>, which replaced the archive API used in this test. With independent worker processes submitting transactions “far beyond network throughput capacity,” RDX Works observed a maximum transaction latency—a far outlier—of 81 seconds.</p>
<p>Most classic fault-tolerant consensus systems can handle the failure of a minority of nodes without significant impact on latencies. Radix behaved differently: in our tests, a single node failure increased latencies for almost every transaction from ~100 ms up to 5–10 seconds. The fraction of affected requests and the magnitude of the latency increase likely depend on the number of validators and the inter-node latency. The Radix Olympia Public Network has 100 rather than 10 validators, which increases the probability that a single node is down at any time, but also increases the number of healthy consensus rounds that can occur during a single-node fault. The public network’s higher inter-node latencies might also mask the impact of faults by slowing down healthy consensus rounds relative to the faulty validator timeout. Users may need to plan for latency spikes, but without long-running measurements of Radix public networks, we can’t say for sure.</p>
<p>Jepsen typically tests systems capable of hundreds to tens of thousands of operations per second, with nominal latencies on the order of 1–100 milliseconds. Higher throughput and lower latencies generally make it possible to find more bugs: we have more chances for race conditions to occur, and finer-grained temporal resolution to identify timing anomalies. Radix’s low throughput and high latency may have masked safety violations. In particular, our tests required several hours to reproduce e.g. aborted read (#13). Improving Radix performance may make it possible to identify and fix bugs faster.</p>
<h2 data-number="4.3" id="public-impact"> Public Impact</h2>
<p>We began testing Radix 1.0-beta.35.1 on June 15, 2021. Jepsen reported significant safety issues to the RDX Works team, including missing transactions in transaction logs by June 28, intermediate balance reads by July 6, and contradictory transaction logs by July 9. Aware that these issues occurred in healthy clusters, RDX Works chose to launch their public “Olympia” mainnet running version 1.0.0 on July 28.</p>
<p>Since 1.0.0, 1.0.1, and 1.0.2 did not address any of the issues we identified, Radix users who made requests from July 28, 2021 to January 27, 2022 may have observed non-monotonic states on single nodes, intermediate balances, aborted reads, missing and spurious actions in transactions, inconsistency between account logs, transient or permanent loss of committed transactions, and long-lasting split-brain in which transaction logs disagree about the order of transactions. Transaction logs could appear to sum to negative balances. Transaction logs could disagree on whether a transaction happened or not. Clients could execute a transaction, see its state as <code>CONFIRMED</code>, observe it in account logs, then have it vanish later.</p>
<p>These issues were not merely theoretical: we were able to reproduce the omission of committed transactions from transaction logs on Stokenet, a Radix public test network, within seconds. Even at less than 1 transaction/sec and with no concurrency, roughly 5–10% of our transactions went missing from transaction logs. We also passively observed both transaction loss and aborted reads in the Radix Olympia Public Network.<a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<p>RDX Works reports that during the course of our testing, RDX Works undertook their own concerted testing efforts to attempt to reproduce the identified safety issues using the <a href="https://wallet.radixdlt.com/">Radix Wallet</a>, and were unable to do so. They were able to reproduce them when submitting transactions programmatically, at “the fastest possible speed”.</p>
<p>RDX Works’s position is that adversarial actions are extraordinarily common on public ledgers, both in the forms of technical and social engineering attacks. Given their inability to reproduce issues from within the Radix Wallet, they determined that the risk of harm to the end user was greater if any disclosure was made ahead of a fix being successfully implemented, tested, and deployed.</p>
<p>Bitfinex, the first exchange to integrate with the Radix Olympia Public Network, and the sole known candidate for expected high-rate usage, enabled the purchase and sale of XRD on <a href="https://www.bitfinex.com/posts/688">August 23, 2021</a>. RDX Works reports that Bitfinex was made aware of the aborted read issue prior to launch, and adjusted their use profile to avoid it.</p>
<p>Jepsen asked whether these issues might have affected transactions processed through the <a href="https://www.instabridge.io/">Instabridge</a> Ethereum-Radix bridge. RDX Works relays that Metaverse Ltd examined Instabridge system records to search for cases where a submitted transaction appeared to fail but was later recorded as successful. No such cases were found. Instabridge does not automatically retry in the case of failure, so RDX Works believes there is no chance of such an event being “hidden” by a successful retry.</p>
<p>RDX Works asserts that the Network Gateway (which is now in use by the Radix Wallet and Explorer) provides an accurate view to clients of network state, including accurate transaction histories for all accounts which may have had incorrect information reported by the preceding archive node system.</p>
<p>Our collaboration concluded on November 5, 2021. RDX Works declined to inform the public of these occurrences until the release of this report on February 5, 2022.</p>
<h2 data-number="4.4" id="future-work"> Future Work</h2>
<p>The RDX Works team plans to continue work towards their language for smart contracts (Scrypto) and sharded consensus implementation (Cerberus). Future testing could investigate Scrypto semantics and verify that Cerberus provides the same ordering guarantees as the current (non-sharded) HotStuff consensus system.</p>
<p>Our testing with membership changes was limited in scope: while our fault injection system added, registered, staked, unregistered, and removed nodes, the asynchronous nature of Radix’s cluster view, the complexity of the membership state machine and the lack of guardrails within Radix to prevent (e.g.) unregistering <em>every</em> validator from the system meant that tests with membership changes tended to render the cluster unusable after a few dozen transitions—despite attempting to preserve a 2/3 majority of stake. While sufficient for basic testing, further work could improve the robustness of the membership fault scheduler.</p>
<p>The performance issues we identified in local testing suggest the need for ongoing monitoring of Radix Public Network latencies and transaction outcomes. In particular, it would be helpful to know how the failure of a single production Radix validator impacts user-facing latencies, the distribution of finality times, and what fraction of submitted transactions can be expected to get stuck in an indeterminate state indefinitely.</p>
<p>As typical for Jepsen reports, our work here focused on accidental faults: partitions, crashes, pauses, etc. Jepsen has not evaluated the robustness of Radix against malicious attackers. Future work might include writing intentionally malicious versions of the Radix validator and verifying that safety properties hold regardless.</p>
<h2 data-number="4.5" id="toward-a-culture-of-safety"> Toward a Culture of Safety</h2>
<p>These findings suggest important questions for the cryptocurrency, blockchain, and distributed ledger (DLT) community. What are distributed ledgers supposed to <em>do</em> in terms of safety properties? What do they actually do? Where should we measure them? And what do users expect, anyway? These questions (and Jepsen’s suggestions) are hardly novel, but we present them in the hopes that they might prove a helpful jumping-off point for DLT engineers, marketers, and community members.</p>
<p>First, Jepsen believes distributed ledgers—like all distributed systems—might benefit from publishing more formal descriptions of their consistency semantics. For ledgers powered by consensus a range of powerful <a href="https://jepsen.io/consistency">consistency models</a> are possible. A DLT could opt for <a href="https://jepsen.io/consistency/models/strict-serializable">strict serializability</a>, which ensures a global real-time order of all operations. Or <a href="https://jepsen.io/consistency/models/serializable">serializability</a>, which ensures only a total order regardless of real-time. There are concrete benefits to each: strict serializability ensures that users must immediately observe any confirmed transaction, whereas serializability allows much faster (but stale!) reads. Session-related models might also be applicable: <a href="https://cs.uwaterloo.ca/~kmsalem/pubs/DaudjeeICDE04.pdf">strong session serializable</a> would ensure each client observes a monotonically increasing state and never fails to observe their own prior transactions.</p>
<p>DLTs often reify a separation between write and read paths. In some systems, writes (DLT transactions) go through consensus and mutate the ledger, whereas reads are serviced by any node’s local state and may therefore observe any point in time. Reads might be made stronger through the use of a <a href="https://en.wikipedia.org/wiki/Logical_clock#">logical clock</a>, allowing clients to enforce per-session or causal orders. Some reads could even be strict serializable: waiting on the underlying consensus system’s incidental transaction flow to ensure recency. As in Zookeeper, <a href="https://iditkeidar.com/wp-content/uploads/files/ftp/KfirLevAriPhDThesis.pdf">Ordered Sequential Consistency</a> might allow DLTs to describe the consistency semantics of interacting writes and reads.</p>
<p>When a DLT clearly defines its intended safety properties, we can investigate whether it satisfies those claims. A <a href="https://queue.acm.org/detail.cfm?id=2889274">broad spectrum of software assurance techniques</a> are available: from proofs to model checking to types to unit tests to end-to-end integration tests—like Jepsen. These techniques build confidence in different ways: a model checker for any nontrivial distributed system is rarely exhaustive, and an end-to-end test like Jepsen is even less likely to explore unusual corners of the state space. A solid proof, on the other hand, provides strong confidence in correctness—but it may not map perfectly to an implementation’s behavior. For this we need tests.</p>
<p>Like any database, DLTs stand to benefit not only from example-based tests, but also by writing property-based tests which generate randomized inputs to explore paths <a href="https://blog.acolyer.org/2018/01/23/why-is-random-testing-effective-for-partition-tolerance-bugs/">hand-written tests might not have thought to travel</a>. As distributed systems DLTs may find particular value in <a href="http://alex-ii.github.io/notes/2018/04/29/distributed_systems_with_deterministic_simulation.html">simulation</a> or <a href="https://people.eecs.berkeley.edu/~apanda/assets/papers/nsdi16.pdf">scheduler interposition</a> techniques which explore novel orderings of events, and from <a href="https://www.gremlin.com/blog/what-is-fault-injection/">fault injection</a>, which deliberately causes network, node, and other failures to drive the system into atypical regimes. Since large-scale distributed systems experience faults frequently, this type of testing is an important part of creating safety.</p>
<p>As RDX Works aptly observes, DLTs are complex, multi-layered systems. In Radix, for example, a core consensus protocol running the ledger state machine was coupled to an ancillary index (the archive subsystem), which in turn provided an HTTP API for clients. Those clients, in turn, connected the ledger to other software systems and human beings.</p>
<p>Although a DLT specialist might not phrase it this way, each layer of this architecture is in fact a <a href="https://people.cs.rutgers.edu/~pxk/417/notes/content/consensus.html">consensus system</a>. The core ledger is often built explicitly as a consensus system: one where validators serve as proposers, acceptors, and learners. But by coming to <a href="https://lamport.azurewebsites.net/pubs/consensus-bounds.pdf">eventual, nontrivial, single-valued agreement</a> on the outcome of transactions, the archive API (in conjunction with the validators) is <em>also</em> a consensus system: the archive’s internal data structures serve as additional learners. So too is the composition of clients, the archive, and validators: clients serve as both proposers and learners. In this consensus system clients ought to agree on whether or not transactions happened, what those transactions did, and what their order was. At the end of the day, human beings (and external software systems) want to use the ledger to help them agree.</p>
<p>When defining and measuring safety we should consider each of these layers. A core ledger system which violates consensus is, of course, likely to break consensus for clients as well. What is not so obvious is that a ledger can be perfectly correct and yet fail to provide consensus for clients—if, for example, its behavior is masked by a faulty intermediary. This is precisely the situation we observed throughout this report, and hints at why the scope of safety properties matters.</p>
<p>Jepsen <a href="https://jepsen.io/analyses">typically explores</a> the behavior of software deployed in a local testing cluster, rather than a public network. Following our discovery of anomalies in local clusters we designed a checker which passively explored the Radix Olympia Public Network by making HTTP read requests to public archive nodes. We began with a single account (taken from a public validator page) and traversed as many accounts and transaction logs as we could find from there, checking to make sure that transaction states and logs <a href="https://github.com/jepsen-io/radix-dlt/blob/e599477376ea4b8a6b0c86368d28dc4efb447b8f/src/jepsen/radix_dlt/pubcheck.clj">all lined up with one another</a>. Since reads are free and open to everyone, this analysis was easy to perform—and it observed two bugs! Jepsen wonders whether other DLT teams or third-party evaluators might design their own crawlers to passively verify safety properties in public networks.</p>
<p>No non-trivial software is perfectly correct. There will always be bugs, and sometimes design shortcomings which impact safety. DLTs sit at the intersection of distributed systems, concurrency control, consensus, caching, and security. Systems which implement smart contracts must also tackle language, VM, and compiler design. These are challenging problems: it would be surprising if any system did not exhibit at least some safety violations.</p>
<p>This raises the question: to what extent do DLT users—from high-frequency automated exchanges to individuals—expect safety? Are they accustomed to aborted reads and forgiving of lost transactions? Or do they expect strict serializability at all times? If safety violations occur, what frequency are users willing to accept? These questions depend on workload throughput, latency, and concurrency demands, and are modulated by the probability and severity of anomalies. Still, it would be helpful to have some idea of what these expectations <em>are</em> for various use cases, so we can find out if systems live up to them.</p>
<p>On the other hand, users attempting to select a DLT for writing applications or for use as a <a href="https://www.radixdlt.com/#use-caseshttps://www.radixdlt.com/#use-cases">financial network</a> are confronted with a dizzying array of potential options. What safety guarantees does each ledger offer? Since vendors and users frequently have a financial or affiliative stake in these networks, there exist significant incentives to paint an optimistic picture of the technology. Marketing claims leverage ambiguity. Future plans are conflated with present behavior. Systems which have not undergone rigorous testing may operate under the presumption of safety. Moreover, even people with the best intentions may struggle to communicate safety invariants clearly. They’re just plain <em>tough</em> to reason about—for end users, marketers, and engineers alike. All of this makes evaluating technologies more difficult.</p>
<p>If this sounds familiar, you’re not alone. Roughly twelve years ago the rise of NoSQL accompanied an explosion of interest in distributed databases, queues, and other systems. Homegrown consensus algorithms which <a href="http://jepsen.io/analyses">lost data during network partitions</a> flourished, marketing claims soared to fantastic heights, and systems cut corners on safety to achieve better benchmark results. More than one system claimed to <a href="https://groups.google.com/g/cloud-computing/c/nn7Sw5T0eSE/m/NxOTUwD_0ykJ">beat</a> the <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a>, or asserted that <a href="https://web.archive.org/web/20130729041308/https://www.rabbitmq.com/partitions.html">network partitions</a> or <a href="https://docs.mongodb.com/v2.4/tutorial/manage-mongodb-processes/#use-kill">power failures</a> fell outside their fault model.</p>
<p>As this cohort of the distributed database industry matured they developed a more nuanced and rigorous engineering culture. Their engineers learned through experience at scale and from the distributed systems literature. They expanded their fault models and adapted more robust algorithms. They more formally codified their safety guarantees, and began to explore formal models, simulation, and testing to gain confidence that those guarantees held. Users began to request stronger safety properties from their systems and developed a more nuanced view of performance, availability, and consistency tradeoffs. Marketing claims—while ever-optimistic—cooled somewhat. The distributed database community is far from perfect, but has made significant strides towards building, discussing, and evaluating safer systems. Jepsen is proud to have been a small part of that process, and looks forward to watching the DLT community build their own culture of safety.</p>

<p>This report is provided for informational purposes only, and does not constitute financial advice. Neither Jepsen nor the author have any financial position involving XRD, eXRD, other Radix tokens, or shares in Radix Tokens (Jersey) Limited, RDX Works, or any other Radix-related entity.</p>
<p>As always, we note that Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. While we try hard to find problems, we cannot prove the correctness of any distributed system.</p>
<p><em>This work was funded by <a href="https://www.radixdlt.com/">Radix Tokens (Jersey) Limited</a>, and conducted in collaboration with <a href="https://www.radixdlt.com/post/welcome-to-rdx-works">RDX Works Ltd</a>, in accordance with the <a href="https://jepsen.io/ethics.html">Jepsen ethics policy</a>. Jepsen wishes to thank the RDX Works team for their assistance—especially Russell Harvey, Matthew Hine, Joshua Primero, Shambu Pujar, Piers Ridyard, and Sergiy Yevtushenko. We would also like to thank Irene Kannyo for her editorial support during preparation of this manuscript.</em></p>

  </div>
</article></div>
  </body>
</html>
