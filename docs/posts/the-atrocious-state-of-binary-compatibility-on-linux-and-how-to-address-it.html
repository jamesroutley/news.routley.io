<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jangafx.com/insights/linux-binary-compatibility">Original</a>
    <h1>The atrocious state of binary compatibility on Linux and how to address it</h1>
    
    <div id="readability-page-1" class="page"><div id="linuxBinaryCompatibilityPage"><div>
<p>By Dale Weiler <a href="https://github.com/graphitemaster/">GitHub</a></p>
<ul>
<li>Time To Read: ~30 Minutes</li>
<li>Last Updated: Monday, March 17th 2025</li>
</ul>
<h2>Summary</h2>
<p>Linux binary compatibility is plagued by one thing that is often overlooked when evaluating shipping software on Linux. This article will deconstruct how to arrive to that conclusion, how to address it when shipping software today and what needs to be done to actually fix it.</p>
<p>Table of contents</p>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#containers">Containers</a></li>
<li><a href="#versioning">Versioning</a></li>
<li><a href="#system-libraries">System Libraries</a></li>
<li><a href="#our-approach">Our Approach</a></li>
<li><a href="#fixing-it">Fixing It</a></li>
<li><a href="#questioning-it">Questioning It</a></li>
</ul>
<h2>Introduction</h2>
<p>At JangaFX, we make several products that run natively on Linux. We love the flexibility and power that Linux offers our developers, but shipping software on it is a whole different challenge.</p>
<p>Linux is an incredibly powerful platform, but when it comes to shipping software, it can feel like a minefield. Unlike other operating systems, Linux isn’t just one system—it’s a chaotic mix of different services, libraries, and even philosophies. Every distribution does things a little differently, and that means the same executable that works flawlessly on one system might completely break on another.</p>
<p>This shouldn’t even be a problem. The Linux kernel itself has maintained relatively stable system calls. But everything built on top of it changes constantly in ways that break compatibility, making it incredibly frustrating to ship software that &#34;just works.&#34; If you’re developing for Linux, you’re not targeting a single platform—you’re navigating an ecosystem that has evolved without much concern for binary compatibility.</p>
<p>Some of us, coming from the game industry before moving into VFX have dealt with this problem before. Shipping games on Linux has always been a nightmare, and the same issues persists regardless of industry. In this article, We&#39;re going to explain why we think containers are <strong>the wrong approach</strong>, how we build and ship Linux software in a way that actually works, what we think is responsible for Linux&#39;s binary compatibility problem and what needs to change to fix it.</p>
<h4>The latter part of this article will get deeply technical about what exactly the problem is and how it can be fixed.</h4>
<h2>Containers</h2>
<p>Tools like <a href="https://flatpak.org/">Flatpak</a>, <a href="https://appimage.org/">AppImage</a>, and similar solutions attempt to simplify shipping executables by creating &#34;containers&#34;—or as as we&#39;ve recently taken to calling them, <strong>&#34;a Linux Environment inside a Linux&#34;</strong> Using Linux features like <a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespaces</a> and <a href="https://en.wikipedia.org/wiki/Chroot">chroots</a>, these solutions package an entire Linux environment, complete with all required dependencies, into a single self-contained bundle. In extreme cases, this means shipping an entire Linux user-space just for one application.</p>
<p>One of the major challenges with these containerized solutions is that they
often don’t work well with applications that need to interact with the rest of
the system. To access hardware-accelerated APIs like
<a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a>,
<a href="https://en.wikipedia.org/wiki/Vulkan_(API)">Vulkan</a>,
<a href="https://en.wikipedia.org/wiki/VDPAU">VDPAU</a> or
<a href="https://developer.nvidia.com/cuda-zone">CUDA</a>, an application must dynamically
link against the system&#39;s graphics driver libraries. Since these libraries exist
outside the container and cannot be shipped with the application, various
&#34;pass-through&#34; techniques have been developed to work around this, some of which
introduce runtime overhead (e.g., shimming libraries). Because containerized applications are isolated from the system, they often <strong>feel</strong> isolated too. This creates consistency issues, where the application may not recognize the user’s name, home directory, system settings, desktop environment preferences, or even have proper access to the filesystem.</p>
<p>To work around these limitations, many containerized environments rely on the
<a href="https://wiki.archlinux.org/title/XDG_Desktop_Portal"><strong>XDG Desktop Portal</strong></a>
protocol, which introduces yet another layer of complexity. This system requires
IPC (inter-process communication) through
<a href="https://en.wikipedia.org/wiki/D-Bus"><strong>DBus</strong></a> just to grant applications
access to basic system features like file selection, opening URLs, or reading
system settings—problems that wouldn’t exist if the application weren’t
artificially sandboxed in the first place.</p>
<p>We don’t believe that piling on more layers is an acceptable solution. As engineers, we need to stop and ask ourselves: &#34;should we keep adding to this tower of Babel?&#34;, or is it time to peel back some of these abstractions and reevaluate them? At some point, the right solution isn’t more complexity—it’s less.</p>
<p>While containerized solutions can work under certain conditions, we believe that shipping lean, native executables—without containers—provides a more seamless and integrated experience that better aligns with user expectations.</p>
<h2>Versioning</h2>
<p>When you compile your application, it links against the specific library versions present on the build machine. This means that by default, the versions on a user&#39;s system may not match, causing compatibility issues. Let’s assume the user has all the necessary libraries installed, but the versions don’t match what your application was built against. This is where the real problem begins.
Short of shipping the exact machine used to deploy your application, how do you ensure compatibility with the versions installed on a user’s system?</p>
<p>We believe there are two ways to solve this problem, and we&#39;ve given them our own names:</p>
<ol>
<li><strong>Replication Approach</strong> – This means bundling all the libraries from the build machine and shipping them with your application. This is the philosophy behind Flatpak and AppImage. We do <strong>not</strong> use this approach at JangaFX.</li>
<li><strong>Relaxation Approach</strong> – Instead of relying on specific or newer library versions, you link against versions that are so old they’re almost guaranteed to be compatible everywhere. This minimizes the risk of incompatibility on a user’s system.</li>
</ol>
<p>The first approach works well in cases where the necessary libraries may not exist on a user’s machine, but it fails for libraries that cannot be shipped (we call these &#34;system libraries&#34;) The second approach is particularly effective for system libraries and is the approach we use at JangaFX.</p>
<h2>System Libraries</h2>
<p>There are various libraries present on a Linux machine that cannot be shipped because they are system libraries. These are libraries tied to the system itself and cannot be provided in a container. Typically these include things like user-space drivers for the GPU, enterprise installed components for security, and of course, <a href="https://en.wikipedia.org/wiki/C_standard_library">libc</a> itself.</p>
<p>If you’ve ever tried to distribute Linux binaries, you may have encountered an error message like this:</p>
<pre><code>/lib64/libc.so.6: version `GLIBC_2.18&#39; not found
</code></pre>
<blockquote>
<p>For those unaware, <strong>glibc</strong> (GNU C Library) provides the C standard library, POSIX APIs, and the dynamic linker responsible for loading shared libraries, and itself.</p>
</blockquote>
<p>GLIBC is an example of a &#34;system library&#34; that cannot be bundled with your
application because it includes the dynamic linker itself. This linker is
responsible for loading other libraries, some of which may also depend on
GLIBC—but not always. Complicating matters further, since GLIBC is a dynamic
library, it must also load itself. This self-referential, chicken-and-egg
problem highlights GLIBC’s complexity and monolithic design, as it attempts to
fulfill multiple roles simultaneously. A large downside to this monolithic
design is that upgrading GLIBC often requires upgrading the entire system. Later in this article, we will
explain why this structure needs to change to truly solve Linux’s binary
compatibility problem.</p>
<p>Before you suggest statically linking GLIBC—<strong>that’s not an option.</strong> GLIBC relies on dynamic linking for features like <a href="https://en.wikipedia.org/wiki/Name_Service_Switch">NSS</a> modules, which handle hostname resolution, user authentication, and network configuration, among other dynamically loaded components. Static linking breaks this because it does not include the dynamic linker, which is why GLIBC does not officially support it. Even if you managed to statically link GLIBC—or used an alternative like <a href="https://musl.libc.org/">musl</a>—your application would be unable to load any dynamic libraries at runtime. Static linking the dynamic linker itself is not possible, for reasons that will be explained later. In short, this would prevent your application from dynamically linking against any system libraries at all.</p>
<h2>Our Approach</h2>
<p>Since our application relies on many non-system libraries that may not be installed on the user’s system, we need a way to include them. The most straightforward approach is the <strong>Replication Approach</strong>, where we ship these libraries alongside our application. However, this negates the benefits of dynamic linking, such as shared memory usage and system-wide updates. In such cases, statically linking these libraries into the application is a better choice, as it eliminates dependency issues entirely. It also enables additional optimizations, such as <a href="https://en.wikipedia.org/wiki/Interprocedural_optimization">LTO</a>, and results in a smaller package by stripping unused components from the included libraries.</p>
<p>Instead, we take a different approach: <strong>statically linking everything we can</strong>. When doing so, special care is needed if a dependency embeds another dependency within its static library. We&#39;ve encountered static libraries that include object files from other static libraries (e.g., libcurl), but we still need to link them separately. This duplication is conveniently avoided with dynamic libraries, but with static libraries, you may need to extract all object files from the archive and remove the embedded ones manually. Similarly, compiler runtimes like <code>libgcc</code> default to dynamic linking. We recommend using <code>-static-libgcc</code>.</p>
<p>Finally, when it comes to dealing with system libraries, we use the <strong>Relaxation Approach</strong>. Rather than requiring exact or newer versions of system libraries, we link against versions that are old enough to be nearly universally compatible. This increases the likelihood that the user’s system libraries will work with our application, reducing dependency issues without the need for containerization or bundling system components and shims.</p>
<p>The method we suggest when linking against older system libraries is to obtain a corresponding older Linux environment. You don’t need to install an old Linux version on physical hardware or even set up a full virtual machine. Instead, a <strong>chroot</strong> provides a lightweight, isolated environment within an existing Linux installation, allowing you to build against an older system without the overhead of full virtualization. Ironically, this suggests that containers were the right solution all along—just not at runtime, but at build time.</p>
<p>To achieve this, we use <a href="https://salsa.debian.org/installer-team/debootstrap">debootstrap</a>, an excellent script that creates a minimal Debian installation from scratch. Debian is particularly suited for this approach due to its stability and long-term support for older releases, making it a great choice for ensuring compatibility with older system libraries.</p>
<p>Of course, once you have an older Linux setup, you may find that its binary package toolchains are too outdated to build your software. To address this, we compile a modern LLVM toolchain from source and use it to build both our dependencies and our software. The details of this process are beyond the scope of this article.</p>
<p>Finally, we automate the entire debootstrap process with a Python script, which we&#39;ve included here for reference.</p>
<pre><p><code><span>#!/bin/env python3</span><span>
</span><span></span><span>import</span><span> os</span><span>,</span><span> subprocess</span><span>,</span><span> shutil</span><span>,</span><span> multiprocessing
</span>
<span>PACKAGES </span><span>=</span><span> </span><span>[</span><span> </span><span>&#39;build-essential&#39;</span><span> </span><span>]</span><span>
</span><span>DEBOOSTRAP </span><span>=</span><span> </span><span>&#39;https://salsa.debian.org/installer-team/debootstrap.git&#39;</span><span>
</span><span>ARCHIVE </span><span>=</span><span> </span><span>&#39;http://archive.debian.org/debian&#39;</span><span>
</span><span>VERSION </span><span>=</span><span> </span><span>&#39;jessie&#39;</span><span> </span><span># Released in 2015</span><span>
</span>
<span></span><span>def</span><span> </span><span>chroot</span><span>(</span><span>pipe</span><span>)</span><span>:</span><span>
</span><span>  </span><span>try</span><span>:</span><span>
</span><span>    os</span><span>.</span><span>chroot</span><span>(</span><span>&#39;chroot&#39;</span><span>)</span><span>
</span><span>    os</span><span>.</span><span>chdir</span><span>(</span><span>&#39;/&#39;</span><span>)</span><span>
</span>
<span>    </span><span># Setup an environment for the chroot</span><span>
</span><span>    env </span><span>=</span><span> </span><span>{</span><span>
</span><span>      </span><span>&#39;HOME&#39;</span><span>:</span><span> </span><span>&#39;/root&#39;</span><span>,</span><span>
</span><span>      </span><span>&#39;TERM&#39;</span><span>:</span><span> </span><span>&#39;xterm&#39;</span><span>,</span><span>
</span><span>      </span><span>&#39;PATH&#39;</span><span>:</span><span> </span><span>&#39;/bin:/usr/bin:/sbin:/usr/sbin&#39;</span><span>
</span><span>    </span><span>}</span><span>
</span>
<span>    </span><span># The Debian is going to be quite old and so the keyring keys will likely be</span><span>
</span><span>    </span><span># expired. To work around this we will replace the sources.list to contain</span><span>
</span><span>    </span><span># &#39;[trusted=yes]&#39;</span><span>
</span><span>    </span><span>with</span><span> </span><span>open</span><span>(</span><span>&#39;/etc/apt/sources.list&#39;</span><span>,</span><span> </span><span>&#39;w&#39;</span><span>)</span><span> </span><span>as</span><span> fp</span><span>:</span><span>
</span><span>      fp</span><span>.</span><span>write</span><span>(</span><span>f&#39;deb [trusted=yes] http://archive.debian.org/debian </span><span>{</span><span>VERSION</span><span>}</span><span> main\n&#39;</span><span>)</span><span>
</span>
<span>    </span><span># Update and install packages</span><span>
</span><span>    subprocess</span><span>.</span><span>run</span><span>(</span><span>[</span><span>&#39;apt&#39;</span><span>,</span><span> </span><span>&#39;update&#39;</span><span>]</span><span>,</span><span> env</span><span>=</span><span>env</span><span>)</span><span>
</span><span>    subprocess</span><span>.</span><span>run</span><span>(</span><span>[</span><span>&#39;apt&#39;</span><span>,</span><span> </span><span>&#39;install&#39;</span><span>,</span><span> </span><span>&#39;-y&#39;</span><span>,</span><span> </span><span>*</span><span>PACKAGES</span><span>]</span><span>,</span><span> env</span><span>=</span><span>env</span><span>)</span><span>
</span>
<span>    </span><span>#</span><span>
</span><span>    </span><span># Script your Linux here, remember to pass `env=env` to subprocess.run.</span><span>
</span><span>    </span><span>#</span><span>
</span><span>    </span><span># We suggest downloading GCC 7.4.0, compiling from source, and installing</span><span>
</span><span>    </span><span># it since it&#39;s the minimum version required to compile the latest LLVM from</span><span>
</span><span>    </span><span># source. We then suggest downloading, compiling from source, and installing</span><span>
</span><span>    </span><span># the latest LLVM, which as of time of writing is 20.1.0.</span><span>
</span><span>    </span><span>#</span><span>
</span><span>    </span><span># You can then compile and install all other source packages your software</span><span>
</span><span>    </span><span># requires from source using this modern LLVM toolchain.</span><span>
</span><span>    </span><span>#</span><span>
</span><span>    </span><span># You can also enter the chroot with an interactive shell from this script</span><span>
</span><span>    </span><span># by uncommenting the following and running this script as usual.</span><span>
</span><span>    </span><span>#  subprocess.run([&#39;bash&#39;])</span><span>
</span><span>    </span><span>#</span><span>
</span>
<span>    </span><span># You can send messages to the parent with pipe.send()</span><span>
</span><span>    pipe</span><span>.</span><span>send</span><span>(</span><span>&#39;Done&#39;</span><span>)</span><span> </span><span># This one has special meaning in main</span><span>
</span><span>  </span><span>except</span><span> Exception </span><span>as</span><span> exception</span><span>:</span><span>
</span><span>    pipe</span><span>.</span><span>send</span><span>(</span><span>exception</span><span>)</span><span>
</span>
<span></span><span>def</span><span> </span><span>main</span><span>(</span><span>)</span><span>:</span><span>
</span><span>  </span><span># We need to run as root to use &#39;mount&#39;, &#39;umount&#39;, and &#39;chroot&#39;</span><span>
</span><span>  </span><span>if</span><span> os</span><span>.</span><span>geteuid</span><span>(</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>:</span><span>
</span><span>    </span><span>print</span><span>(</span><span>&#39;Script must be run as root&#39;</span><span>)</span><span>
</span><span>    </span><span>return</span><span> </span><span>False</span><span>
</span>
<span>  </span><span>with</span><span> multiprocessing</span><span>.</span><span>Manager</span><span>(</span><span>)</span><span> </span><span>as</span><span> manager</span><span>:</span><span>
</span><span>    mounts </span><span>=</span><span> manager</span><span>.</span><span>list</span><span>(</span><span>)</span><span>
</span><span>    pipe </span><span>=</span><span> multiprocessing</span><span>.</span><span>Pipe</span><span>(</span><span>)</span><span>
</span><span>    </span><span>def</span><span> </span><span>mount</span><span>(</span><span>parts</span><span>)</span><span>:</span><span>
</span><span>      subprocess</span><span>.</span><span>run</span><span>(</span><span>[</span><span>&#39;mount&#39;</span><span>,</span><span> </span><span>*</span><span>parts</span><span>]</span><span>)</span><span>
</span><span>      mounts</span><span>.</span><span>append</span><span>(</span><span>parts</span><span>[</span><span>-</span><span>1</span><span>]</span><span>)</span><span>
</span>
<span>    </span><span># Ensure we have a fresh chroot and clone of debootstrap</span><span>
</span><span>    shutil</span><span>.</span><span>rmtree</span><span>(</span><span>&#39;chroot&#39;</span><span>,</span><span> ignore_errors</span><span>=</span><span>True</span><span>)</span><span>
</span><span>    shutil</span><span>.</span><span>rmtree</span><span>(</span><span>&#39;debootstrap&#39;</span><span>,</span><span> ignore_errors</span><span>=</span><span>True</span><span>)</span><span>
</span><span>    os</span><span>.</span><span>mkdir</span><span>(</span><span>&#39;chroot&#39;</span><span>)</span><span>
</span>
<span>    </span><span># Clone debootstrap</span><span>
</span><span>    subprocess</span><span>.</span><span>run</span><span>(</span><span>[</span><span>&#39;git&#39;</span><span>,</span><span> </span><span>&#39;clone&#39;</span><span>,</span><span> DEBOOSTRAP</span><span>]</span><span>)</span><span>
</span><span>    subprocess</span><span>.</span><span>run</span><span>(</span><span>[</span><span>&#39;debootstrap&#39;</span><span>,</span><span> </span><span>&#39;--arch&#39;</span><span>,</span><span> </span><span>&#39;amd64&#39;</span><span>,</span><span> VERSION</span><span>,</span><span> </span><span>&#39;../chroot&#39;</span><span>,</span><span> ARCHIVE</span><span>]</span><span>,</span><span>
</span><span>                    env</span><span>=</span><span>{</span><span>**</span><span>os</span><span>.</span><span>environ</span><span>,</span><span> </span><span>&#39;DEBOOTSTRAP_DIR&#39;</span><span>:</span><span> </span><span>&#39;.&#39;</span><span>}</span><span>,</span><span>
</span><span>                    cwd</span><span>=</span><span>&#39;debootstrap&#39;</span><span>)</span><span>
</span>
<span>    </span><span># Mount nodes needed for the chroot</span><span>
</span><span>    mount</span><span>(</span><span>[</span><span>&#39;-t&#39;</span><span>,</span><span> </span><span>&#39;proc&#39;</span><span>,</span><span> </span><span>&#39;/proc&#39;</span><span>,</span><span> </span><span>&#39;chroot/proc&#39;</span><span>]</span><span>)</span><span>
</span><span>    mount</span><span>(</span><span>[</span><span>&#39;--rbind&#39;</span><span>,</span><span> </span><span>&#39;/sys&#39;</span><span>,</span><span> </span><span>&#39;chroot/sys&#39;</span><span>]</span><span>)</span><span>
</span><span>    mount</span><span>(</span><span>[</span><span>&#39;--make-rslave&#39;</span><span>,</span><span> </span><span>&#39;chroot/sys&#39;</span><span>]</span><span>)</span><span>
</span><span>    mount</span><span>(</span><span>[</span><span>&#39;--rbind&#39;</span><span>,</span><span> </span><span>&#39;/dev&#39;</span><span>,</span><span> </span><span>&#39;chroot/dev&#39;</span><span>]</span><span>)</span><span>
</span><span>    mount</span><span>(</span><span>[</span><span>&#39;--make-rslave&#39;</span><span>,</span><span> </span><span>&#39;chroot/dev&#39;</span><span>]</span><span>)</span><span>
</span>
<span>    </span><span># Setup the chroot in a separate process</span><span>
</span><span>    process </span><span>=</span><span> multiprocessing</span><span>.</span><span>Process</span><span>(</span><span>target</span><span>=</span><span>chroot</span><span>,</span><span> args</span><span>=</span><span>(</span><span>pipe</span><span>[</span><span>1</span><span>]</span><span>,</span><span>)</span><span>)</span><span>
</span><span>    process</span><span>.</span><span>start</span><span>(</span><span>)</span><span>
</span><span>    </span><span>try</span><span>:</span><span>
</span><span>      </span><span>while</span><span> </span><span>True</span><span>:</span><span>
</span><span>        data </span><span>=</span><span> pipe</span><span>[</span><span>0</span><span>]</span><span>.</span><span>recv</span><span>(</span><span>)</span><span>
</span><span>        </span><span>if</span><span> </span><span>isinstance</span><span>(</span><span>data</span><span>,</span><span> Exception</span><span>)</span><span>:</span><span>
</span><span>          </span><span>raise</span><span> data
</span><span>        </span><span>else</span><span>:</span><span>
</span><span>          </span><span>print</span><span>(</span><span>data</span><span>)</span><span>
</span><span>          </span><span>if</span><span> data </span><span>==</span><span> </span><span>&#39;Done&#39;</span><span>:</span><span>
</span><span>            </span><span>break</span><span>
</span><span>    </span><span>finally</span><span>:</span><span>
</span><span>      process</span><span>.</span><span>join</span><span>(</span><span>)</span><span>
</span><span>      </span><span>for</span><span> umount </span><span>in</span><span> </span><span>reversed</span><span>(</span><span>list</span><span>(</span><span>set</span><span>(</span><span>mounts</span><span>)</span><span>)</span><span>)</span><span>:</span><span>
</span><span>        subprocess</span><span>.</span><span>run</span><span>(</span><span>[</span><span>&#39;umount&#39;</span><span>,</span><span> </span><span>&#39;-R&#39;</span><span>,</span><span> umount</span><span>]</span><span>)</span><span>
</span><span>        subprocess</span><span>.</span><span>run</span><span>(</span><span>[</span><span>&#39;sync&#39;</span><span>]</span><span>)</span><span>
</span>
<span></span><span>if</span><span> __name__ </span><span>==</span><span> </span><span>&#39;__main__&#39;</span><span>:</span><span>
</span><span>  </span><span>try</span><span>:</span><span>
</span><span>    main</span><span>(</span><span>)</span><span>
</span><span>  </span><span>except</span><span> KeyboardInterrupt</span><span>:</span><span>
</span><span>    </span><span>print</span><span>(</span><span>&#39;Cancelled&#39;</span><span>)</span></code></p></pre>
<h2>Fixing it</h2>
<p>Generally, most applications do not link directly against system libraries, and instead load which ever is present on the user&#39;s machine already at runtime. So while these libraries are considered system components, they typically have few system dependencies beyond libc itself. This is what makes libc—specifically <strong>GLIBC</strong>—the real source of compatibility issues, it&#39;s essentially the only system component directly linked against.</p>
<p>In just the past two years, our team has encountered three separate <strong>GLIBC-specific</strong> compatibility issues, each directly impacting our products:</p>
<ol>
<li><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=29456">https://sourceware.org/bugzilla/show_bug.cgi?id=29456</a></li>
<li><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=32653">https://sourceware.org/bugzilla/show_bug.cgi?id=32653</a></li>
<li><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=32786">https://sourceware.org/bugzilla/show_bug.cgi?id=32786</a></li>
</ol>
<p>From our perspective, the core issue with <strong>GLIBC</strong> is that it tries to do far too much. It’s a massive, monolithic system that handles everything—from system calls and memory management to threading and even the dynamic linker. This tight coupling is why upgrading <strong>GLIBC</strong> often means upgrading the entire system; everything is intertwined. If it were broken into smaller, more focused components, users could update only the parts that change, rather than dragging their whole system along with it.</p>
<p>More importantly, separating the dynamic linker from the <strong>C library</strong> itself would allow multiple versions of <strong>libc</strong> to coexist, eliminating a major source of compatibility issues. This is exactly how <strong>Windows</strong> handles it, which is one of the reasons Windows maintains such strong binary compatibility. You can still run decades-old Windows software today because Microsoft doesn’t force everything to be tied to a single, ever-changing libc.</p>
<p>Of course, this isn’t as simple as just splitting things apart. GLIBC has deep cross-cutting concerns, particularly with threading, TLS (Thread-Local Storage), and global memory management.</p>
<p>For example, even if you managed to get two versions of GLIBC to coexist, returning allocated memory from one and attempting to free it in another would likely lead to serious issues. Their heaps would be unaware of each other, potentially using different allocation strategies, causing unpredictable failures. To avoid this, even the heap would likely need to be separated into its own dedicated <strong>libheap</strong>.</p>
<p>We think a better approach would be breaking GLIBC into distinct libraries, something like this:</p>
<ul>
<li><strong>libsyscall</strong> – Handles making system calls and nothing else. This is
provided as a static library only. Used by <code>libheap</code>, <code>libthread</code> and <code>libc</code> to gain access to shared system call code. Since it&#39;s static it&#39;s embedded in all three. You can pretend this library otherwise does not exist.</li>
<li><strong>libdl (Dynamic Linker)</strong> – A standalone linker that loads shared libraries.
Links only against <code>libsyscall</code> statically. Is a true, free-standing library, depending on nothing. Provided as both a static and dynamic library. When you link against it statically you can still load things with it dynamically. You just end up with a dynamic linker inside your executable.</li>
<li><strong>libheap</strong> - The single heap shared by all below. Links against <code>libsyscall</code>
statically. Provided only as a dynamic library. Cannot ever be linked against statically.</li>
<li><strong>libthread</strong> – Deals with threading and TLS, links against
<code>libheap</code>. Provided only as a dynamic library. Cannot ever be linked against statically.</li>
<li><strong>libc</strong> – Links against <code>libthread</code>, and thus <code>libheap</code>, and <code>libdl</code> transitively. Provided as both a static and dynamic library. When linking statically it links <code>libdl</code> statically. The linking of <code>libthread</code> and <code>libheap</code> is always done dynamically though through the included <code>libdl</code> if linked statically or through <code>libdl</code> program loader if linked dynamically.</li>
</ul>
<p>These libraries would be aware of each other and allow multiple versions to
coexist in the same address space. That way, we don’t end up with this brittle
mess where upgrading GLIBC can break everything. The actual structure would look
something like</p>
<blockquote>
<p>This architecture is quite similar to Windows, where the equivalents of
<code>libsyscall</code>, <code>libdl</code>, <code>libheap</code>, and <code>libthread</code> are all bundled within a single
<code>kernel32.dll</code>. This DLL is pre-mapped and automatically loaded into the
address space of every executable on Windows.</p>
</blockquote>
<h3><strong>Statically Linked <code>libc</code></strong></h3>
<ul>
<li>Application statically links <code>libc</code> and <code>libdl</code> (it is not the program loader).</li>
<li>Application starts execution and dynamically loads <code>libheap</code> and <code>libthread</code> using embedded <code>libdl</code>.</li>
</ul>
<pre><code>[Application]
   │
   ▼
[libc (static)]
   │
   ▼
[libdl (static)]
   ├── [libheap (dynamic)]
   └── [libthread (dynamic)]
          └── [libheap (dynamic)]
</code></pre>
<ul>
<li><code>libc</code> and <code>libdl</code> are embedded in the executable, meaning the application itself starts execution.</li>
<li>The embedded <code>libdl</code> dynamically loads <code>libthread</code> and <code>libheap</code>.</li>
</ul>
<hr/>
<h3><strong>Dynamically Linked <code>libc</code></strong></h3>
<ul>
<li>Application starts execution via the program interpreter (<code>libdl</code>).</li>
<li><code>libdl</code> (program loader) loads the application and resolves dependencies.</li>
<li>Application dynamically links <code>libc</code>, <code>libheap</code>, and <code>libthread</code>.</li>
</ul>
<pre><code>[Application (interpreter entry)]
   │
   ▼
[libdl (program loader)]
   │
   ▼
[libc (dynamic)]
   ├── [libheap (dynamic)]
   ├── [libthread (dynamic)]
   │      └── [libheap (dynamic)]
   ▼
[Application (regular entry)]
</code></pre>
<h3><strong>Comparison Table</strong></h3>
<table><thead><tr><th>Scenario</th><th><code>libdl</code> (included by)</th><th><code>libc</code> (how it loads)</th><th><code>libthread</code> (via <code>libdl</code>)</th><th><code>libheap</code> (via <code>libdl</code>)</th></tr></thead><tbody><tr><td><strong>Static <code>libc</code></strong></td><td>Static linking</td><td>Static linking</td><td><strong>Linked by <code>libdl</code></strong></td><td><strong>Linked by <code>libdl</code></strong></td></tr><tr><td><strong>Dynamic <code>libc</code></strong></td><td>Program interpreter</td><td><strong>Linked by <code>libdl</code></strong></td><td><strong>Linked by <code>libdl</code></strong></td><td><strong>Linked by <code>libdl</code></strong></td></tr></tbody></table>
<p>This architecture effectively reduces the binary compatibility problem to two key <strong>system libraries</strong>: <code>libheap</code> and <code>libthread</code>. These cannot be statically linked because they manage shared resources critical to the entire system.</p>
<p>The reason is straightforward—heap memory must be shared across all components, ensuring compatibility between allocations and deallocations. Similarly, TLS and threading require a unified system-wide approach, as they involve complex initialization and finalization logic, particularly for global constructors and destructors. However, these components are relatively small and stable, meaning they undergo fewer changes that would necessitate version updates.</p>
<h2>Questioning it</h2>
<p>This is, of course, a non-trivial amount of rearchitecting, which naturally raises the question: why is libc implemented the way it is instead of this alternative approach?</p>
<p>Setting historical reasons aside, attempting to solve this problem quickly
becomes difficult the moment you start writing any code using libc. Here is a trivial example of the issues that arise when trying to support multiple
versions of libc.</p>
<p>Suppose you have a dynamic library that contains the following C code.</p>
<pre><p><code><span>#</span><span>include</span><span> </span><span>&lt;stdio.h&gt;</span><span>
</span><span>FILE</span><span>*</span><span> </span><span>open_thing</span><span>(</span><span>)</span><span> </span><span>{</span><span>
</span><span>  </span><span>return</span><span> </span><span>fopen</span><span>(</span><span>&#34;thing.bin&#34;</span><span>,</span><span> </span><span>&#34;r&#34;</span><span>)</span><span>;</span><span>
</span><span></span><span>}</span></code></p></pre>
<p>And your application links against this library and calls <code>open_thing</code>. Your application would be responsible for calling <code>fclose</code> on the returned <code>FILE*</code>. If your code links against a different version of libc from the version the library links against, then it would be calling the wrong implementation of <code>fclose</code>!</p>
<p>Suppose though, that libc was written in such a way that the <code>FILE*</code> returned always required a version field or a pointer to a <a href="https://en.wikipedia.org/wiki/Virtual_method_table">vtable</a> containing the implementation of <code>fclose</code> (and other functions) and every version of libc agreed on this so that it could always call the correct one across this ABI boundary. This would solve this compatibility issue, but now lets say your code calls <code>fflush</code>.</p>
<pre><p><code><span>// Defined in header &lt;stdio.h&gt;</span><span>
</span><span></span><span>int</span><span> </span><span>fflush</span><span>(</span><span>FILE </span><span>*</span><span>fp</span><span>)</span><span>;</span></code></p></pre>
<p>Except it doesn&#39;t flush the file, and instead passes <code>NULL</code>.</p>
<pre><p><code><span>fflush</span><span>(</span><span>NULL</span><span>)</span><span>;</span></code></p></pre>
<p>If you&#39;re not familiar with C&#39;s <code>fflush</code> function, passing <code>NULL</code> to it requires flushing all open files (every <code>FILE*</code>). However, in this scenario, it would only flush files seen by the libc version your application is linked against, not those opened by other libc versions (such as the one used by <code>open_thing</code>).</p>
<p>To handle this correctly, each libc version would need a way to enumerate files across all other libc instances, including dynamically loaded ones, ensuring that every file is visited exactly once without forming cycles. This enumeration must also be thread-safe. Additionally, while enumeration is in progress, another libc could be dynamically loaded (e.g., via <code>dlopen</code>) on a separate thread, or a new file could be opened (e.g., a global constructor in a dynamically loaded library calling <code>fopen</code>).</p>
<p>This global list of things owned by libc shows up in multiple places. Take for instance:</p>
<pre><p><code><span>// Defined in header &lt;stdlib.h&gt;</span><span>
</span><span></span><span>int</span><span> </span><span>atexit</span><span>(</span><span>void</span><span> </span><span>(</span><span>*</span><span>func</span><span>)</span><span>(</span><span>void</span><span>)</span><span>)</span><span>;</span></code></p></pre>
<blockquote>
<p>Registers the function pointed to by <em>func</em> to be called on normal program termination (via <code>exit()</code> or returning from <code>main()</code>). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.</p>
</blockquote>
<blockquote>
<p>There is also another variant of this called <code>at_quick_exit</code>.</p>
</blockquote>
<p>This implies that somewhere within libc, there must be a list of functions registered via <code>atexit</code> that need to be executed in reverse order. For multiple libc implementations to coexist, any system handling <code>atexit</code> must not only enumerate and call all registered functions, but also establish a total order for how they were inserted across all instances of libc.</p>
<p>Essentially, any resource owned by one libc would need to be sharable and accessible from any other version of libc. This turns out to be quite a lot of things. For the sake of our argument we&#39;ve actually gone through all of the standard C (not POSIX) functions which produce or operate on a resource which has an opaque implementation where careful considerations would need to be made.</p>
<table><thead><tr><th>Header</th><th>Function</th><th>Resource</th><th>Notes</th></tr></thead><tbody><tr><td><code>&lt;fenv.h&gt;</code></td><td>N/A</td><td><code>fexcept_t</code></td><td>Float environment exceptions need to be stable across libc.</td></tr><tr><td><code>&lt;fenv.h&gt;</code></td><td><code>*</code></td><td><code>fexcept_t</code></td><td>Any functions using this type</td></tr><tr><td><code>&lt;fenv.h&gt;</code></td><td><code>fegetenv</code></td><td><code>fenv_t</code></td><td>Float environment needs to be stable across libc.</td></tr><tr><td><code>&lt;fenv.h&gt;</code></td><td><code>*</code></td><td><code>fenv_t</code></td><td>Any functions using this type</td></tr><tr><td><code>&lt;locale.h&gt;</code></td><td><code>localeconv</code></td><td><code>struct lconv</code></td><td>Common initial sequence needs to be stable across libc.</td></tr><tr><td><code>&lt;math.h&gt;</code></td><td>N/A</td><td><code>int</code></td><td>Math defines need to have a stable set of integer values across libc.</td></tr><tr><td><code>&lt;setjmp.h&gt;</code></td><td>N/A</td><td><code>jmp_buf</code></td><td>Usually defined by compiler</td></tr><tr><td><code>&lt;setjmp.h&gt;</code></td><td><code>*</code></td><td><code>jmp_buf</code></td><td>Usually defined by compiler intrinsic</td></tr><tr><td><code>&lt;signal.h&gt;</code></td><td>N/A</td><td><code>int</code></td><td>Signal defines need to have a stable set of integer values across libc.</td></tr><tr><td><code>&lt;signal.h&gt;</code></td><td>N/A</td><td><code>sig_atomic_t</code></td><td>Stable type across libc</td></tr><tr><td><code>&lt;stdarg.h&gt;</code></td><td>N/A</td><td><code>va_list</code></td><td>Usually defined by compiler</td></tr><tr><td><code>&lt;stdarg.h&gt;</code></td><td><code>va_start</code></td><td><code>va_list</code></td><td>Usually defined by compiler intrinsic</td></tr><tr><td><code>&lt;stdarg.h&gt;</code></td><td><code>*</code></td><td><code>va_list</code></td><td>Any functions or macros using this type</td></tr><tr><td><code>&lt;stdatomic.h&gt;</code></td><td><code>*</code></td><td><code>_Atomic T</code></td><td>Stable type across libc</td></tr><tr><td><code>&lt;stdatomic.h&gt;</code></td><td>N/A</td><td><code>int</code></td><td>Atomic defines need to have a stable set of integer values across libc.</td></tr><tr><td><code>&lt;stdatomic.h&gt;</code></td><td>N/A</td><td><code>typedef</code></td><td>Many typedefs need to have a stable set of types across libc.</td></tr><tr><td><code>&lt;stddef.h&gt;</code></td><td>N/A</td><td><code>typedef</code></td><td>Many typedefs need to have a stable set of types across libc.</td></tr><tr><td><code>&lt;stdint.h&gt;</code></td><td>N/A</td><td><code>typedef</code></td><td>Many typedefs need to have a stable set of types across libc.</td></tr><tr><td><code>&lt;stdint.h&gt;</code></td><td>N/A</td><td><code>int</code></td><td>Many defines need to have a stable set of types across libc.</td></tr><tr><td><code>&lt;stdio.h&gt;</code></td><td><code>*</code></td><td><code>FILE</code></td><td>Many functions (any taking <code>FILE*</code> or returning <code>FILE*</code>)</td></tr><tr><td><code>&lt;stdio.h&gt;</code></td><td>N/A</td><td><code>typedef</code></td><td>Many types need to have a stable set of types across libc.</td></tr><tr><td><code>&lt;stdio.h&gt;</code></td><td>N/A</td><td><code>int</code></td><td>Many defines need to have a stable set of integer values across libc.</td></tr><tr><td><code>&lt;stdio.h&gt;</code></td><td>N/A</td><td>N/A</td><td>Locale for string formatting needs to be shared across libc</td></tr><tr><td><code>&lt;stdio.h&gt;</code></td><td><code>stderr</code></td><td>N/A</td><td>Needs to be a macro that expands to a function call like <code>__stdio(STDERR_FILENO)</code></td></tr><tr><td><code>&lt;stdio.h&gt;</code></td><td><code>stdout</code></td><td>N/A</td><td>Needs to be a macro that expands to a function call like <code>__stdio(STDOUT_FILENO)</code></td></tr><tr><td><code>&lt;stdio.h&gt;</code></td><td><code>stdin</code></td><td>N/A</td><td>Needs to be a macro that expands to a function call like <code>__stdio(STDIO_FILENO)</code></td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td>N/A</td><td><code>div_t</code>,</td><td>Needs to have a stable definition across libc.</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td>N/A</td><td><code>ldiv_t</code>,</td><td>Needs to have a stable definition across libc.</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td>N/A</td><td><code>lldiv_t</code></td><td>Needs to have a stable definition across libc.</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td>N/A</td><td><code>int</code></td><td>Many defines need to have a stable set of integer values across libc.</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>call_once</code></td><td><code>once_flag</code></td><td>Needs to be stable across libc and also libthread</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>rand</code></td><td>N/A</td><td>Global PRNG needs to be shared across libc.</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>srand</code></td><td>N/A</td><td>Global PRNG needs to be shared across libc.</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>aligned_alloc</code></td><td><code>void*</code></td><td>Shared heap</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>calloc</code></td><td><code>void*</code></td><td>Shared heap</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>free</code></td><td><code>void*</code></td><td>Shared heap</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>free_sized</code></td><td><code>void*</code></td><td>Shared heap</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>free_aligned_size</code></td><td><code>void*</code></td><td>Shared heap</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>malloc</code></td><td><code>void*</code></td><td>Shared heap</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>realloc</code></td><td><code>void*</code></td><td>Shared heap</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>atexit</code></td><td>N/A</td><td>Global list needs to be shared across libc.</td></tr><tr><td><code>&lt;stdlib.h&gt;</code></td><td><code>at_quick_exit</code></td><td>N/A</td><td>Global list needs to be shared across libc.</td></tr><tr><td><code>&lt;string.h&gt;</code></td><td><code>strcoll</code></td><td>N/A</td><td><code>LC_COLLATE</code> locale needs to be shared across libc</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td>N/A</td><td><code>cnd_t</code></td><td>Any opaque method</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td>N/A</td><td><code>thrd_t</code></td><td>Any opaque method</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td>N/A</td><td><code>tss_t</code></td><td>Any opaque method</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td>N/A</td><td><code>mtx_t</code></td><td>Any opaque method</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td><code>*</code></td><td><code>cnd_t</code></td><td>Many functions using this type</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td><code>*</code></td><td><code>thrd_t</code></td><td>Many functions using this type</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td><code>*</code></td><td><code>tss_t</code></td><td>Many functions using this type</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td><code>*</code></td><td><code>mtx_t</code></td><td>Many functions using this type</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td><code>*</code></td><td><code>typedef</code></td><td>Many types need to have a stable set of types across libc.</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td>N/A</td><td><code>int</code></td><td>Many defines need to have a stable set of integer values across libc.</td></tr><tr><td><code>&lt;threads.h&gt;</code></td><td><code>call_once</code></td><td><code>once_flag</code></td><td>See <code>&lt;stdlib.h&gt;</code> above</td></tr><tr><td><code>&lt;time.h&gt;</code></td><td>N/A</td><td><code>typedef</code></td><td>Many types need to have a stable set of types across libc.</td></tr><tr><td><code>&lt;time.h&gt;</code></td><td>N/A</td><td><code>struct tm</code></td><td>Common initial sequence needs to be stable across libc.</td></tr><tr><td><code>&lt;uchar.h&gt;</code></td><td>N/A</td><td><code>char8_t</code></td><td>Needs to be same across libc</td></tr><tr><td><code>&lt;uchar.h&gt;</code></td><td>N/A</td><td><code>char16_t</code></td><td>Needs to be same across libc</td></tr><tr><td><code>&lt;uchar.h&gt;</code></td><td>N/A</td><td><code>char32_t</code></td><td>Needs to be same across libc</td></tr><tr><td><code>&lt;uchar.h&gt;</code></td><td><code>*</code></td><td><code>char8_t</code></td><td>Many functions using this type</td></tr><tr><td><code>&lt;uchar.h&gt;</code></td><td><code>*</code></td><td><code>char16_t</code></td><td>Many functions using this type</td></tr><tr><td><code>&lt;uchar.h&gt;</code></td><td><code>*</code></td><td><code>char32_t</code></td><td>Many functions using this type</td></tr><tr><td><code>&lt;uchar.h&gt;</code></td><td>N/A</td><td><code>mbstate_t</code></td><td>Any opaque method</td></tr><tr><td><code>&lt;uchar.h&gt;</code></td><td><code>*</code></td><td><code>mbstate_t</code></td><td>Many functions using this type.</td></tr><tr><td><code>&lt;wchar.h&gt;</code></td><td><code>*</code></td><td><code>*</code></td><td>Repeat of <code>&lt;uchar.h&gt;</code> essentially</td></tr><tr><td><code>&lt;wctype.h&gt;</code></td><td>N/A</td><td><code>wctrans_t</code></td><td>Need to be same across libc</td></tr><tr><td><code>&lt;wctype.h&gt;</code></td><td>N/A</td><td><code>wctype_t</code></td><td>Need to be same across libc</td></tr><tr><td><code>&lt;wctype.h&gt;</code></td><td><code>*</code></td><td><code>wctrans_t</code></td><td>Many functions using this type</td></tr><tr><td><code>&lt;wctype.h&gt;</code></td><td><code>*</code></td><td><code>wctype_t</code></td><td>Many functions using this type</td></tr></tbody></table>
<p>Most defines (of constants), ABI-exposed types (and typedefs) should just be stable across libc implementations for this to work reliably. Since these are baked into executables there&#39;s no real way to modify or change them without breaking stuff anyways. When discussing stuff that is opaque (listed as <code>Any opaque method</code>) we propose affixing a pointer to a vtable containing the implementation as the first value in the type, this way functions operating on it can always recover the correct implementation and dispatch it indirectly through the vtable. Other methods like using a version field can also work here too.</p>
<p>Regardless, certain aspects of libc introduce complexity, particularly global and thread-local elements like <a href="https://en.wikipedia.org/wiki/Errno.h">errno</a> and <a href="https://en.wikipedia.org/wiki/Locale_(computer_software)">locale</a>. However, with a well-designed architecture, these challenges can be effectively addressed.</p>
<p>Memory allocation functions—<code>calloc</code>, <code>malloc</code>, <code>aligned_alloc</code>, <code>realloc</code>, and <code>free</code>—from <code>&lt;stdlib.h&gt;</code> pose another difficulty. Since they can return any pointer, tracking them is non-trivial. One possible approach is to store a pointer to a vtable in the allocation header, allowing each allocation to reference its implementation. However, this method incurs significant performance and memory overhead. Instead, we propose centralizing heap management in a dedicated <code>libheap</code>. This would also contain implementation of the POSIX extensions like <code>posix_memalign</code>.</p>
<p>Things get even more interesting when moving from standard C to POSIX, which introduces unique challenges that require libc support. Some of these functionalities might be better split into separate libraries (for example, why is the DNS resolver in libc?). Among these challenges though, <code>setxid</code> stands out.</p>
<p>For those unfamiliar, permissions in POSIX—such as the <a href="https://en.wikipedia.org/wiki/User_identifier">real, effective, and saved user/group IDs</a>—apply at the process level. However, Linux treats threads as independent processes that share memory, meaning these permissions are managed per thread rather than per process. To comply with POSIX semantics, libc must interrupt every thread, forcing them to execute code that invokes the system call to modify their thread-local permissions. This must be done atomically, without failure, and while remaining <a href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">async-signal safe</a>. This is a nightmare to implement and has proven to be <a href="https://ewontfix.com/17/">a major challenge</a>. More importantly, getting it right is crucial for security.</p>
<p>Ultimately, this means libc must track every thread and provide a way to synchronously execute code across all threads. To address this, we propose consolidating threading, TLS, and the necessary POSIX compliance mechanisms within a single <code>libthread</code>.</p>
<p>There are many additional complexities we’ve glossed over and many alternative ways this can be implemented. The key takeaway is that these issues are solvable—they just require significant architectural changes. This necessitates reevaluating this aspect of the Linux userspace from the ground up with binary compatibility as a core design principle. GLIBC has never seriously attempted this. Until someone decides, &#34;enough is enough, let’s fix this,&#34; binary compatibility on Linux will remain an unsolved problem; we strongly believe this is a problem worth solving.</p></div></div></div>
  </body>
</html>
