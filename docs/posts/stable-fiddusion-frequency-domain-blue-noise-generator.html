<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://acko.net/blog/stable-fiddusion/">Original</a>
    <h1>Stable Fiddusion: Frequency-domain blue noise generator</h1>
    
    <div id="readability-page-1" class="page"><article>

  
    <img src="https://acko.net/files/fiddusion/cover.jpg" alt="Stable Fiddusion"/>
  

  
  
    





<div><p>
  <h2>Frequency-domain blue noise generator</h2>
</p></div>





<img src="https://acko.net/files/fiddusion/cover.jpg" alt="Cover Image - Live effect run-time inspector"/>

<div><div>

<p>In computer graphics, <b>stochastic methods are <em>so hot right now</em></b>. All rendering turns into calculus, except you solve the integrals by numerically sampling them.</p>

<p>As I showed with <a href="https://acko.net/blog/teardown-frame-teardown/" target="_blank">Teardown</a>, this is all based on random noise, hidden with a ton of spatial and temporal smoothing. For this, you need a good source of high quality noise. There have been a few interesting developments in this area, such as <a href="https://blog.demofox.org/">Alan Wolfe</a> et al.&#39;s <a href="https://developer.nvidia.com/blog/rendering-in-real-time-with-spatiotemporal-blue-noise-textures-part-1/">Spatio-Temporal Blue Noise</a>.</p>

<p>This post is about how I <b>designed noise in frequency space</b>. I will cover:</p>

<ul>
<li>What is <b>blue noise</b>?</li>
<li>Designing <b>indigo noise</b></li>
<li><b>How swap works</b> in the frequency domain</li>
<li>Heuristics and analysis to <b>speed up search</b></li>
<li>Implementing it in <b>WebGPU</b></li>
</ul>

<p>Along the way I will also show you some <b>&#34;street&#34; DSP math</b>. This illustrates how getting comfy in this requires you to develop deep intuition about complex numbers. But complex doesn&#39;t mean complicated. It can all be done on a paper napkin.</p>

</div></div>

<div><div>
  <p><a href="https://acko.net/files/bluebox/#!/" target="_blank"><img src="https://acko.net/files/fiddusion/app-ui.png" title="Stable Fiddusion - UI"/></a></p><p><em>The WebGPU interface I built</em></p>
</div></div>

<div><div>

<p>What I&#39;m going to make is this:</p>

<p>
  <img src="https://acko.net/files/fiddusion/indigo-256x256x1@1x.png" srcset="https://acko.net/files/fiddusion/indigo-256x256x1@1x.png 1x, https://acko.net/files/fiddusion/indigo-256x256x1@2x.png 2x"/>
</p>

<p>If properly displayed, this image should look eerily even. But if your browser is rescaling it incorrectly, it may not be exactly right.</p>

<h2>Colorless Blue Ideas</h2>

<p>I will start by just recapping the essentials. If you&#39;re familiar, skip to the next section.</p>

<p>Ordinary random generators produce uniform white noise: every value is equally likely, and the average frequency spectrum is flat.</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/white-128x128x1.png" title="White noise - Gamma correct"/></p><p><em>Time domain</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/white-128x128x1-freq.png" title="White noise - Gamma correct"/></p><p><em>Frequency domain</em></p>
</div></div>

<div><div>

<p>To a person, this doesn&#39;t actually seem fully &#39;random&#39;, because it has clusters and voids. Similarly, a uniformly random list of coin flips will still have long runs of heads or tails in it occasionally.</p>

<p>What a person would consider evenly random is usually <em>blue</em> noise: it prefers to <em>alternate</em> between heads and tails, and avoids long runs entirely. It is &#39;more random than random&#39;, biased towards the upper frequencies, i.e. the blue part of the spectrum.</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/blue-128x128x1.png" title="Blue noise - Gamma correct"/></p><p><em>Time domain</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/blue-128x128x1-freq.png" title="Blue noise - Spectrum"/></p><p><em>Frequency domain</em></p>
</div></div>



<div><p>Blue noise is great for e.g. dithering, because when viewed from afar, or blurred, it tends to disappear. With white noise, clumps remain after blurring:</p></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/white-128x128x1-blur.png" title="Blurred white noise"/></p><p><em>Blurred white noise</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/blue-128x128x1-blur.png" title="Blurred blue noise"/></p><p><em>Blurred blue noise</em></p>
</div></div>



<div><p>Blueness is a delicate property. If you have e.g. 3D blue noise in a volume XYZ, then a single 2D XY slice is not blue at all:</p></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/blue3d-64x64x16-freq.png" title="3D blue noise spectrum"/></p><p><em>XYZ spectrum</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/blue3d-64x64x16-1.png" title="3D blue noise XY slice"/></p><p><em>XY slice</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/blue3d-64x64x16-1-freq.png" title="3D blue noise XY spectrum"/></p><p><em>XY spectrum</em></p>
</div></div>



<div><div>

<p>The samples are only evenly distributed in 3D, i.e. when you consider each slice in front and behind it too.</p>

<p>Blue noise being delicate means that nobody really knows of a way to generate it statelessly, i.e. as a pure function <code>f(x,y,z)</code>. Algorithms to generate it must factor in the whole, as noise is only blue if every <em>single sample</em> is evenly spaced. You can make blue noise images that tile, and sample those, but the resulting repetition may be noticeable.</p>

<p>Because blue noise is constructed, you can make special variants.</p>

<ul>
  <li><p><b>Uniform Blue Noise</b> has a uniform distribution of values, with each value equally likely. An 8-bit 256x256 UBN image will have each unique byte appear exactly 256 times.</p></li>
  <li><p><b>Projective Blue Noise</b> can be projected down, so that a 3D volume XYZ flattened into either XY, YZ or ZX is still blue in 2D, and same for X, Y and Z in 1D.</p></li>
  <li><p><b>Spatio-Temporal Blue Noise</b> (STBN) is 3D blue noise created specifically for use in real-time rendering:
    </p><ul>
        <li>Every 2D slice XY is 2D blue noise</li>
        <li>Every Z row is 1D blue noise</li>
    </ul>
  </li>
</ul>

<p>This means XZ or YZ slices of STBN are not blue. Instead, it&#39;s designed so that when you average out all the XY slices over Z, the result is uniform gray, again without clusters or voids. This requires the noise in all the slices to perfectly complement each other, a bit like overlapping slices of translucent swiss cheese.</p>

<p>This is the sort of noise I want to generate.</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/stbn-64x64x16.png" title="STBN"/></p><p><em>Indigo STBN 64x64x16</em></p>

  <p><img src="https://acko.net/files/fiddusion/stbn-64x64x16-freq.png" title="STBN XYZ spectrum"/></p><p><em>XYZ spectrum</em></p>
</div></div>



<div><div>


<h2>Sleep Furiously</h2>

<p>A blur filter&#39;s spectrum is the opposite of blue noise: it&#39;s concentrated in the lowest frequencies, with a bump in the middle.</p>

<p>
  <img src="https://acko.net/files/fiddusion/blur-filter-128x128x1.png" title="Indigo noise - Gamma correct"/>
</p>

<p>If you blur the noise, you multiply the two spectra. Very little is left: only the ring-shaped overlap, creating a band-pass area.</p>

<p>
  <img src="https://acko.net/files/fiddusion/blur-bandpass-128x128x1.png" title="Indigo noise - Gamma correct"/>
</p>

<p>This is why blue noise looks good when smoothed, and is used in rendering, with both spatial (2D) and temporal smoothing (1D) applied.</p>

<p>Blur filters can be designed. If a blur filter is <em>perfectly</em> low-pass, i.e. ~zero amplitude for all frequencies &gt; $ f_{\rm{lowpass}} $ , then nothing is left of the upper frequencies past a point.</p>

<p>If the noise is shaped to minimize any overlap, then the result is actually noise free. The dark part of the noise spectrum should be <em>large</em> and <em>pitch black</em>. The spectrum shouldn&#39;t just be blue, it should be <em>indigo</em>.</p>

<p>When people say you can&#39;t design noise in frequency space, what they mean is that you can&#39;t merely apply an inverse FFT to a given target spectrum. The resulting noise is gaussian, not uniform. The missing ingredient is the phase: all the frequencies need to be precisely aligned to have the right value distribution.</p>

<p>This is why you need a specialized algorithm.</p>

<p>The STBN paper describes two: void-and-cluster, and swap. Both of these are driven by an energy function. It works in the spatial/time domain, based on the distances between pairs of samples. It uses a &#34;fall-off parameter&#34; <em>sigma</em> to control the effective radius of each sample, with a gaussian kernel.</p>

<p>
  $$ E(M) = \sum E(p,q) = \sum \exp \left( - \frac{||\mathbf{p} - \mathbf{q}||^2}{\sigma^2_i}-\frac{||\mathbf{V_p} - \mathbf{V_q}||^{d/2}}{\sigma^2_s} \right) $$
</p>

<div>
  <p><img src="https://acko.net/files/fiddusion/stbn-wolfe.jpg" title="STBN Blue noise - Wolfe et al"/></p>
  <p><em>STBN (Wolfe et al.)</em></p>
</div>

<p>The swap algorithm is trivially simple. It starts from white noise and shapes it:</p>

<ol>
    <li>Start with e.g. 256x256 pixels initialized with the bytes 0-255 repeated 256 times in order</li>
    <li>Permute all the pixels into ~white noise using a random order</li>
    <li>Now iterate: randomly try swapping two pixels, check if the result is &#34;more blue&#34;</li>
  </ol>


<p>This is guaranteed to preserve the uniform input distribution perfectly.</p>

<p>The resulting noise patterns are blue, but they still have some noise in <em>all</em> the lower frequencies. The only blur filter that could get rid of it all, is one that blurs away all the signal too. My &#39;simple&#39; fix is just to score swaps in the frequency domain instead.</p>

<p>If this seems too good to be true, you should know that a permutation search space is catastrophically huge. If any pixel can be swapped with any other pixel, the number of possible swaps at any given step is O(N²). In a 256x256 image, it&#39;s ~2 billion.</p>

<p>The goal is to find a sequence of thousands, millions of random swaps, to turn the white noise into blue noise. This is basically stochastic bootstrapping. It&#39;s the bulk of <em>good old fashioned AI</em>, using simple heuristics, queues and other tools to dig around large search spaces. If there are local minima in the way, you usually need more noise and simulated annealing to tunnel over those. Usually.</p>

<p>This set up is somewhat simplified by the fact that swaps are symmetric (i.e. <code>(A,B)</code> = <code>(B,A)</code>), but also that applying swaps S1 and S2 is the same as applying swaps S2 and S1 as long as they don&#39;t overlap.</p>

<h2>Good Energy</h2>

<p>Let&#39;s take it one hurdle at a time.</p>

<p>It&#39;s not obvious that you can change a signal&#39;s spectrum just by re-ordering its values over space/time, but this is easy to illustrate.</p>

</div></div>



<div><p><img src="https://acko.net/files/fiddusion/graph-reorder-1.png" alt="Random signal"/>
</p></div>

<div><p>Take any finite 1D signal, and order its values from lowest to highest. You will get some kind of ramp, approximating a sawtooth wave. This concentrates most of the energy in the first non-DC frequency:</p></div>



<div><p><img src="https://acko.net/files/fiddusion/graph-reorder-2.png" alt="Random signal - re-ordered"/>
</p></div>



<div><p>Now split the odd values from the even values, and concatenate them. You will now have two ramps, with twice the frequency:</p></div>



<div><p><img src="https://acko.net/files/fiddusion/graph-reorder-3.png" alt="Random signal - re-ordered and split into odd/even"/>
</p></div>



<div><p>You can repeat this to double the frequency all the way up to Nyquist. So you have a lot of design freedom to transfer energy from one frequency to another.</p></div>

<div><p><img src="https://acko.net/files/fiddusion/graph-reorder-4.png" alt="Random signal - re-ordered and split into odd/even x2"/>
</p></div>



<div><div>

<p>In fact the Fourier transform has the property that energy in the time and frequency domain is conserved:</p>

<p>
  $$ \int_{-\infty}^\infty |f(x)|^2 \, dx = \int_{-\infty}^\infty |\widehat{f}(\xi)|^2  \, d\xi $$
</p>

<p>This means the sum of $ |\mathrm{spectrum}_k|^2 $ remains constant over pixel swaps. We then design a target curve, e.g. a high-pass cosine:</p>

<p>
  $$ \mathrm{target}_k = \frac{1 - \cos \frac{k \pi}{n} }{2} $$
</p>

<p>This can be fit and compared to the current noise spectrum to get the error to minimize.</p>

<p>However, I don&#39;t measure the error in energy $ |\mathrm{spectrum}_k|^2 $ but in amplitude $ |\mathrm{spectrum}_k| $. I normalize the spectrum and the target into distributions, and take the L2 norm of the difference, i.e. a <code>sqrt</code> of the sum of squared errors:</p>

<p>
  $$ \mathrm{error}_k = \frac{\mathrm{target}_k}{||\mathbf{target}||} - \frac{|\mathrm{spectrum}_k|}{||\mathbf{spectrum}||} $$
  $$ \mathrm{loss}^2 = ||\mathbf{error}||^2 $$
</p>

<p>This keeps the math simple, but also helps target the noise in the ~zero part of the spectrum. Otherwise, deviations near zero would count for less than deviations around one.</p>


</div></div>

<div><p><img src="https://acko.net/files/fiddusion/blue-128x128x1-approx.png" title="Approximate blue noise"/>
</p></div>

<div><div>

<h2>Go Banana</h2>

<p>So I tried it.</p>

<p>With a lot of patience, you can make 2D blue noise images up to 256x256 on a single thread. A naive random search with an FFT for every iteration is not fast, but computers are.</p>

<p>Making a 64x64x16 with this is possible, but it&#39;s certainly like watching paint dry. It&#39;s the same number of pixels as 256x256, but with an extra dimension worth of FFTs that need to be churned.</p>

<p>Still, it works and you can also make 3D STBN with the spatial and temporal curves controlled independently:</p>

</div></div>





<div><p><img src="https://acko.net/files/fiddusion/stbn-curve1.png" title="STBN spectrum 1"/>
</p></div>


<div><p><img src="https://acko.net/files/fiddusion/stbn-curve2.png" title="STBN spectrum 2"/>
</p></div>


<div><div>
  <p><img src="https://acko.net/files/fiddusion/stbn-curve3.png" title="STBN spectrum 3"/></p><p><em>Converged spectra</em></p>
</div></div>



<div><div>

<p>I built command-line scripts for this, with a bunch of quality of life things. If you&#39;re going to sit around waiting for numbers to go by, you have a lot of time for this...</p>

<ul>
  <li>Save and load byte/float-exact state to a .png, save parameters to .json</li>
  <li>Save a bunch of debug viz as extra .pngs with every snapshot</li>
  <li>Auto-save state periodically during runs</li>
  <li>Measure and show rate of convergence every N seconds, with smoothing</li>
  <li>Validate the histogram before saving to detect bugs and avoid corrupting expensive runs</li>
</ul>

<p>I could fire up a couple of workers to start churning, while continuing to develop the code liberally with new variations. I could also stop and restart workers with new heuristics, continuing where it left off.</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/scripts.png" title="CLI scripts"/></p><p><em>Protip: you can write C in JavaScript</em></p>
</div></div>



<div><div>
  
<p>Drunk with power, I tried various sizes and curves, which created... okay noise. Each has the exact same uniform distribution so it&#39;s difficult to judge other than comparing to other output, or earlier versions of itself.</p>

<p>To address this, I visualized the blurred result, using a [1 4 6 4 1] kernel as my base line. After adjusting levels, structure was visible:</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-approx-time.png" title="Blue noise - Approx"/></p><p><em>Semi-converged</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-approx-blur.png" title="Blue noise - Blurred"/></p><p><em>Blurred</em></p>
</div></div>



<div><p>The resulting spectra show what&#39;s actually going on:</p></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-approx-freq.png" title="Blue noise - Approx"/></p><p><em>Semi-converged</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-approx-1-freq.png" title="Blue noise - Blurred"/></p><p><em>Blurred</em></p>
</div></div>


<div><div>

<p>The main component is the expected ring of bandpass noise, the 2D equivalent of ringing. But in between there is also a ton of redder noise, in the lower frequencies, which all remains after a blur. This noise is as strong as the ring.</p>

<p>So while it&#39;s easy to make a blue-ish noise pattern that looks okay at first glance, there is a vast gap between having a noise floor and not having one. So I kept iterating:</p>

</div></div>




<div><p><img src="https://acko.net/files/fiddusion/blur-approx-2-freq.png" title="Blue noise - Blurred"/>
</p></div>

<div><p><img src="https://acko.net/files/fiddusion/blur-approx-3-freq.png" title="Blue noise - Blurred"/>
</p></div>

<div><p><img src="https://acko.net/files/fiddusion/blur-approx-4-freq.png" title="Blue noise - Blurred"/>
</p></div>


<div><p>It takes a very long time, but if you wait, all those little specks will slowly twinkle out, until quantization starts to get in the way, with a loss of about 1/255 per pixel (0.0039).</p></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-approx-blur.png" title="Blue noise - Converged"/></p><p><em>Semi converged</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-exact-blur.png" title="Blue noise - Converged &amp; Blurred"/></p><p><em>Fully converged</em></p>
</div></div>


<div><div>

<p>The effect on the blurred output is remarkable. All the large scale structure disappears, as you&#39;d expect from spectra, leaving only the bandpass ringing. That goes away with a strong enough blur, or a large enough dark zone.</p>

<p>The visual difference between the two is slight, but nevertheless, the difference is significant and pervasive when amplified:</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-approx-time.png" title="Blue noise - Semi-Converged"/></p><p><em>Semi converged</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-exact-time.png" title="Blue noise - Converged"/></p><p><em>Fully converged</em></p>
</div></div>



<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-exact-diff.png" title="Blue noise - Diff"/></p><p><em>Difference</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/blur-exact-freq.png" title="Blue noise - Converged Spectrum"/></p><p><em>Final spectrum</em></p>
</div></div>


<div><div>

<p>I tried a few indigo noise curves, with different % of the curve zero. The resulting noise is all extremely equal, even after a blur and amplify. The only visible noise left is bandpass, and the noise floor is so low it may as well not be there.</p>

<p>As you make the black exclusion zone bigger, the noise gets concentrated in the edges and corners. It becomes a bit more linear and squarish, a contender for <em>violet</em> noise. This is basically a smooth evolution towards a pure pixel checkboard in the limit. Using more than 50% zero seems inadvisable for this reason:</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/violet-128x128x1.png" title="Violet noise - Gamma correct"/></p><p><em>Time domain</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/violet-128x128x1-freq.png" title="Violet noise - Spectrum"/></p><p><em>Frequency domain</em></p>
</div></div>



<div><div>

<p>At this point the idea was validated, but it was dog slow. Can it be done faster?</p>


<h2>Spatially Sparse</h2>

<p>An FFT scales like O(N log N). When you are dealing with images and volumes, that N is actually an N² or N³ in practice.</p>

<p>The early phase of the search is the easiest to speed up, because you can find a good swap for any pixel with barely any tries. There is no point in being clever. Each sub-region is very non-uniform, and its spectrum nearly white. Placing pixels roughly by the right location is plenty good enough.</p>

<p>You might try splitting a large volume into separate blocks, and optimize each block separately. That wouldn&#39;t work, because all the boundaries remain fully white. Overlapping doesn&#39;t fix this, because they will actively create new seams. I tried it.</p>

<p>What does work is a windowed scoring strategy. It avoids a full FFT for the entire volume, and only scores each NxN or NxNxN region around each swapped point, with N-sized FFTs in each dimension. This is enormously faster and can rapidly dissolve larger volumes of white noise into approximate blue even with e.g. N = 8 or N = 16. Eventually it stops improving and you need to bump the range or switch to a global optimizer.</p>

<p>Here&#39;s the progression from white noise, to when sparse 16x16 gives up, followed by some additional 64x64:</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/sparse-1.png" title="Sparse mode - Initial state"/></p><p><em>Time domain</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/sparse-1-freq.png" title="Sparse mode - Initial spectrum"/></p><p><em>Frequency domain</em></p>
</div></div>



<div><div>
  <p><img src="https://acko.net/files/fiddusion/sparse-2.png" title="Sparse mode - End state"/></p><p><em>Time domain</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/sparse-2-freq.png" title="Sparse mode - End spectrum"/></p><p><em>Frequency domain</em></p>
</div></div>



<div><div>
  <p><img src="https://acko.net/files/fiddusion/sparse-3.png" title="Sparse mode - End state"/></p><p><em>Time domain</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/sparse-3-freq.png" title="Sparse mode - End spectrum"/></p><p><em>Frequency domain</em></p>
</div></div>



<div><div>

<p>A naive solution does not work well however. This is because the spectrum of a subregion does not match the spectrum of the whole.</p>

<p>The Fourier transform assumes each signal is periodic. If you take a random subregion and forcibly repeat it, its new spectrum will have aliasing artifacts. This would cause you to consistently misjudge swaps.</p>

<p>To fix this, you need to window the signal in the space/time-domain. This forces it to start and end at 0, and eliminates the effect of non-matching boundaries on the scoring. I used a <code>smoothStep</code> window because it&#39;s cheap, and haven&#39;t needed to try anything else:</p>

<p><img src="https://acko.net/files/fiddusion/window-data.png" title="Windowed data"/></p>
<p><em>16x16 windowed data</em></p>

<p>
  $$ w(t) = 1 - (3|t|^2 - 2|t|^3) , t=-1..1 $$
</p>

<p>This still alters the spectrum, but in a predictable way. A time-domain window is a convolution in the frequency domain. You don&#39;t actually have a choice here: <em>not</em> using a window is mathematically equivalent to using a <em>very bad</em> window. It&#39;s effectively a box filter covering the cut-out area inside the larger volume, which causes spectral ringing.</p>

<p>The effect of the chosen window on the target spectrum can be modeled via convolution of their spectral magnitudes:</p>

<p>$$ \mathbf{target}&#39; = |\mathbf{target}| \circledast |\mathcal{F}(\mathbf{window})| $$</p>

<p>This can be done via the time domain as:</p>

<p>$$ \mathbf{target}&#39; = \mathcal{F}(\mathcal{F}^{-1}(|\mathbf{target}|) \cdot \mathcal{F}^{-1}(|\mathcal{F}(\mathbf{window})|)) $$</p>

<p>Note that the forward/inverse Fourier pairs are not redundant, as there is an absolute value operator in between. This discards the phase component of the window, which is irrelevant.</p>

<p>Curiously, while it is important to window the noise data, it isn&#39;t very important to window the target. The effect of the spectral convolution is small, amounting to a small blur, and the extra error is random and absorbed by the smooth scoring function.</p>

<p>The resulting local loss tracks the global loss function pretty closely. It massively speeds up the search in larger volumes, because the large FFT is the bottleneck. But it stops working well before anything resembling convergence in the frequency-domain. It does not make true blue noise, only a lookalike.</p>

<p>The overall problem is still that we can&#39;t tell good swaps from bad swaps without trying them and verifying.</p>


<h2>Sleight of Frequency</h2>

<p>So, let&#39;s characterize the effect of a pixel swap.</p>

<p>Given a signal <code>[A B C D E F G H]</code>, let&#39;s swap C and F.</p>

<p>Swapping the two values is the same as adding <code>F - C = Δ</code> to <code>C</code>, and subtracting that same delta from <code>F</code>. That is, you add the vector:</p>

<pre><code>V = [0 0 Δ 0 0 -Δ 0 0]</code></pre>


<p>This remains true if you apply a Fourier transform and do it in the frequency domain.</p>

<p>To best understand this, you need to develop some intuition around FFTs of Dirac deltas.</p>

<p>Consider the short filter kernel <code>[1 4 6 4 1]</code>. It&#39;s a little known fact, but you can actually sight-read its frequency spectrum directly off the coefficients, because the filter is symmetrical. I will teach you.</p>

<p>The extremes are easy:</p>

<ul>
<li>The DC amplitude is the sum 1 + 4 + 6 + 4 + 1 = 16</li>
<li>The Nyquist amplitude is the modulated sum 1 - 4 + 6 - 4 + 1 = 0</li>
</ul>

<p>So we already know it&#39;s an &#39;ideal&#39; lowpass filter, which reduces the Nyquist signal +1, -1, +1, -1, ... to exactly zero. It also has 16x DC gain.</p>

<p>Now all the other frequencies.</p>

<p>First, remember the Fourier transform works in symmetric ways. Every statement <em>&#34;____ in the time domain = ____ in the frequency domain&#34;</em> is still true if you swap the words <em>time</em> and <em>frequency</em>. This has lead to the grotesquely named sub-field of <em>cepstral</em> processing where you have <em>quefrencies</em> and <em>vawes</em>, and it kinda feels like you&#39;re having a stroke. The cepstral convolution filter from earlier is called a <em>lifter</em>.</p>

<p>Usually cepstral processing is applied to the real magnitude of the spectrum, i.e. $ |\mathrm{spectrum}| $, instead of its true complex value. This is a coward move.</p>

<p>So, decompose the kernel into symmetric pairs:</p>

<pre><code>[· · 6 · ·]
[· 4 · 4 ·]
[1 · · · 1]</code></pre>


<p>All but the first row is a pair of real Dirac deltas in the time domain. Such a row is normally what you get when you Fourier transform a <em>cosine</em>, i.e.:</p>

<p>$$ \cos \omega = \frac{\mathrm{e}^{i\omega} + \mathrm{e}^{-i\omega}}{2} $$</p>

<p>A cosine in time is a <em>pair</em> of Dirac deltas in the frequency domain. The phase of a (real) cosine is zero, so both its deltas are real.</p>

<p>Now flip it around. The Fourier transform of a <em>pair</em> <code>[x 0 0 ... 0 0 x]</code> is a <em>real cosine</em> in frequency space. Must be true. Each new pair adds a new higher cosine on top of the existing spectrum. For the central <code>[... 0 0 x 0 0 ...]</code> we add a DC term. It&#39;s just a Fourier transform in the other direction:</p>

<pre><code>|FFT([1 4 6 4 1])| =

  [· · 6 · ·] =&gt; 6 
  [· 4 · 4 ·] =&gt; 8 cos(ɷ)
  [1 · · · 1] =&gt; 2 cos(2ɷ)
  
 = |6 + 8 cos(ɷ) + 2 cos(2ɷ)|</code></pre>


<p>Normally you have to use the z-transform to analyze a digital filter. But the above is a shortcut. FFTs and inverse FFTs do have opposite phase, but that doesn&#39;t matter here because <code>cos(ɷ) = cos(-ɷ)</code>.</p>

<p>This works for the symmetric-even case too: you offset the frequencies by half a band, ɷ/2, and there is no DC term in the middle:</p>

<pre><code>|FFT([1 3 3 1])| =

  [· 3 3 ·] =&gt; 6 cos(ɷ/2)
  [1 · · 1] =&gt; 2 cos(3ɷ/2)

 = |6 cos(ɷ/2) + 2 cos(3ɷ/2)|</code></pre>


<p>So, symmetric filters have spectra that are made up of regular cosines. Now you know.</p>

<p>For the purpose of this trick, we centered the filter around $ t = 0 $. FFTs are typically aligned to <em>array index</em> 0. The difference between the two is however just phase, so it can be disregarded.</p>

<p>What about the delta vector <code>[0 0 Δ 0 0 -Δ 0 0]</code>? It&#39;s not symmetric, so we have to decompose it:</p>

<pre><code>V1 = [· · · · · Δ · ·]
V2 = [· · Δ · · · · ·]

V = V2 - V1</code></pre>


<p>Each is now an unpaired Dirac delta. Each vector&#39;s Fourier transform is a complex wave $ Δ \cdot \mathrm{e}^{-i \omega k} $ in the frequency domain (the k&#39;th <em>quefrency</em>). It lacks the usual complementary oppositely twisting wave $ Δ \cdot \mathrm{e}^{i \omega k} $, so it&#39;s <em>not</em> real-valued. It has constant magnitude Δ and varying phase:</p>

<pre><code>FFT(V1) = []
FFT(V2) = []</code></pre>


<p>These are <em>vawes</em>.</p>

<p>The effect of a swap is still just to add <code>FFT(V)</code>, aka <code>FFT(V2) - FFT(V1)</code> to the (complex) spectrum. The effect is to transfer energy between all the bands simultaneously. Hence, <code>FFT(V1)</code> and <code>FFT(V2)</code> function as a <em>source</em> and <em>destination</em> mask for the transfer.</p>

<p>However, &#39;mask&#39; is the wrong word, because the magnitude of $ \mathrm{e}^{i \omega k} $ is always 1. It doesn&#39;t have varying amplitude, only varying phase. <code>-FFT(V1)</code> and <code>FFT(V2)</code> define the complex <em>direction</em> in which to add/subtract energy.</p>

<p>When added together their phases interfere constructively or destructively, resulting in an amplitude that varies between 0 and 2Δ: an actual mask. The resulting phase will be halfway between the two, as it&#39;s the sum of two equal-length complex numbers.</p>

<pre><code>FFT(V) = []</code></pre>


<p>For any given pixel A and its delta <code>FFT(V1)</code>, it can pair up with other pixels B to form N-1 different interference masks <code>FFT(V2) - FFT(V1)</code>. There are N(N-1)/2 unique interference masks, if you account for (A,B) (B,A) symmetry.</p>

<p>Worth pointing out, the FFT of the first index:</p>

<pre><code>FFT([Δ 0 0 0 0 0 0 0]) = [Δ Δ Δ Δ Δ Δ Δ Δ]</code></pre>


<p>This is the DC quefrency, and the fourier symmetry continues to work. Moving values in time causes the vawe&#39;s quefrency to change in the frequency domain. This is the upside-down version of how moving energy to another frequency band causes the wave&#39;s frequency to change in the time domain.</p>


<h2>What&#39;s the Gradient, Kenneth?</h2>

<p>Using vectors as masks... shifting energy in directions... this means gradient descent, no?</p>

<p>Well.</p>

<p>It&#39;s indeed possible to calculate the derivative of your loss function as a function of input pixel brightness, with the usual bag of automatic differentiation/backprop tricks. You can also do it numerically. </p>

<p>But, this doesn&#39;t help you directly because the only way you can act on that per-pixel gradient is by swapping a <em>pair</em> of pixels. You need to find two quefrencies <code>FFT(V1)</code> and <code>FFT(V2)</code> which interfere in <em>exactly</em> the right way to decrease the loss function across all bad frequencies simultaneously, while leaving the good ones untouched. Even if the gradient were to help you pick a good starting pixel, that still leaves the problem of finding a good partner.</p>

<p>There are still O(N²) possible pairs to choose from, and the entire spectrum changes a little bit on every swap. Which means new FFTs to analyze it.</p>

<p>Random greedy search is actually tricky to beat in practice. Whatever extra work you spend on getting better samples translates into less samples tried per second. e.g. Taking a best-of-3 approach is worse than just trying 3 swaps in a row. Swaps are almost always orthogonal.</p>

<p>But <code>random()</code> still samples unevenly because it&#39;s white noise. If only we had.... oh wait. Indeed if you already have blue noise of the right size, you can use that to mildly speed up the search for more. Use it as a random permutation to drive sampling, with some inevitable whitening over time to keep it fresh. You can&#39;t however use the noise you&#39;re generating to accelerate its own search, because the two are highly correlated.</p>

<p>What&#39;s really going on is all a consequence of the loss function.</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/loss-amplitude-target.png" alt="Loss amplitude"/>
</p></div>

<div><div>

<p>Given any particular frequency band, the loss function is only affected when its magnitude changes. Its phase can change arbitrarily, <em>rolling</em> around without friction. The complex gradient must point in the radial direction. In the tangential direction, the partial derivative is zero.</p>

<p>The value of a given interference mask <code>FFT(V1) - FFT(V2)</code> for a given frequency is also complex-valued. It can be projected onto the current phase, and split into its radial and tangential component with a dot product.</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/loss-amplitude-frame.png" alt="Loss amplitude vector basis"/>
</p></div>

<div><div>

<p>The interference mask has a dual action. As we saw, its magnitude varies between 0 and 2Δ, as a function of the two indices k1 and k2. This creates a window that is independent of the specific state or data. It defines a smooth &#39;hash&#39; from the interference of two quefrency bands.</p>

<p>But its phase adds an <em>additional</em> selection effect: whether the interference in the mask is aligned with the current band&#39;s phase: this determines the split between radial and tangential. This defines a smooth phase &#39;hash&#39; on top. It cycles at the average of the two quefrencies, i.e. a different, third one.</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/loss-amplitude-curved.png" alt="Loss amplitude vector basis"/>
</p></div>

<div><div>

<p>Energy is only added/subtracted if both hashes are non-zero. If the phase hash is zero, the frequency band only turns. This does not affect loss, but changes how each mask will affect it in the future. This then determines how it is coupled to other bands when you perform a particular swap.</p>

<p>Note that this is only true differentially: for a finite swap, the curvature of the complex domain comes into play.</p>

<p>The loss function is actually a hyper-cylindrical skate bowl you can ride around. Just the movement of all the bands is tied together.</p>

</div></div>



<div><div>

<p>Frequency bands with significant error may &#39;random walk&#39; freely clockwise or counterclockwise when subjected to swaps. A band can therefor drift until it gets a turn where its phase is in alignment with enough similar bands, where the swap makes them all descend along the local gradient, enough to counter any negative effects elsewhere.</p>

<p>In the time domain, each frequency band is a wave that oscillates between -1...1: it &#39;owns&#39; some of the value of each pixel, but there are places where its weight is ~zero (the knots).</p>

<p>So when a band shifts phase, it changes how much of the energy of each pixel it &#39;owns&#39;. This allows each band to &#39;scan&#39; different parts of the noise in the time domain. In order to fix a particular peak or dent in the frequency spectrum, the search must rotate that band&#39;s phase so it strongly owns <em>any</em> defect in the noise, and then perform a swap to fix that defect.</p>

<p>Thus, my mental model of this is not actually disconnected <em>pixel swapping</em>.</p>

<p>It&#39;s more like one of those Myst puzzles where flipping a switch flips some of the neighbors too. You press one pair of buttons at a time. It&#39;s a giant haunted dimmer switch.</p>

<p>We&#39;re dealing with complex amplitudes, not real values, so the light also has a color. Mechanically it&#39;s like a slot machine, with dials that can rotate to display different sides. The cherries and bells are the color: they determine how the light gets brighter or darker. If a dial is set just right, you can use it as a /dev/null to &#39;dump&#39; changes.</p>

<p>That&#39;s what theory predicts, but does it work? Well, here is a (blurred noise) spectrum being late-optimized. The search is trying to eliminate the left-over lower frequency noise in the middle:</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/phase-freq.png" title="Sparse mode - Initial state"/></p><p><em>Semi converged</em></p>
</div></div>



<div><p>Here&#39;s the phase difference from the late stages of search, each a good swap. Left to right shows 4 different value scales:</p></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-1-2.png" title="Phase delta 1"/></p><p><em>x2</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-1-16.png" title="Phase delta 2"/></p><p><em>x16</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-1-256.png" title="Phase delta 3"/></p><p><em>x256</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-1-4096.png" title="Phase delta 4"/></p><p><em>x4096</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-2-2.png" title="Phase delta 1"/></p><p><em>x2</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-2-16.png" title="Phase delta 2"/></p><p><em>x16</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-2-256.png" title="Phase delta 3"/></p><p><em>x256</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-2-4096.png" title="Phase delta 4"/></p><p><em>x4096</em></p>
</div></div>



<div><div>

<p>At first it looks like just a few phases are changing, but amplification reveals it&#39;s the opposite. There are several plateaus. Strongest are the bands being actively modified. Then there&#39;s the circular error area around it, where other bands are still swirling into phase. Then there&#39;s a sharp drop-off to a much weaker noise floor, present everywhere. These are the bands that are already converged.</p>

<p>Compare to a random bad swap:</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-bad-2.png" title="Diff phase delta 1"/></p><p><em>x2</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-bad-16.png" title="Diff phase delta 2"/></p><p><em>x16</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-bad-256.png" title="Diff phase delta 3"/></p><p><em>x256</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/diff-phase-bad-4096.png" title="Diff phase delta 4"/></p><p><em>x4096</em></p>
</div></div>



<div><div>

<p>Now there is strong noise all over the center, and the loss immediately gets worse, as a bunch of amplitudes start shifting in the wrong direction randomly.</p>

<p>So it&#39;s true. Applying the swap algorithm with a spectral target naturally cycles through focusing on different parts of the target spectrum as it makes progress. This information is positionally encoded in the phases of the bands and can be &#39;queried&#39; by attempting a swap.</p>

<p>This means the constraint of a fixed target spectrum is actually a constantly moving target in the complex domain.</p>

<p>Frequency bands that reach the target are locked in. Neither their magnitude nor phase changes in aggregate. The random walks of such bands must have no DC component... they must be complex-valued blue noise with a tiny amplitude.</p>

<p>Knowing this doesn&#39;t help directly, but it does explain why the search is so hard. Because the interference masks function like hashes, there is no simple pattern to how positions map to errors in the spectrum. And once you get close to the target, finding new good swaps is equivalent to digging out information encoded deep in the phase domain, with O(N²) interference masks to choose from.</p>



<h2>Gradient Sampling</h2>

<p>As I was trying to optimize for evenness after blur, it occurred to me to simply try selecting bright or dark spots in the blurred after-image.</p>

<p>This is the situation where frequency bands are in coupled alignment: the error in the spectrum has a relatively concentrated footprint in the time domain. But, this heuristic merely picks out good swaps that are already &#39;lined up&#39; so to speak. It only works as a low-hanging fruit sampler, with rapidly diminishing returns.</p>

<p>Next I used the gradient in the frequency domain.</p>

<p>The gradient points towards increasing loss, which is the sum of squared distance $ (…)^2 $. So the slope is $ 2(…) $, proportional to distance to the goal:</p>

<p>$$ |\mathrm{gradient}_k| = 2 \cdot \left( \frac{|\mathrm{spectrum}_k|}{||\mathbf{spectrum}||} - \frac{\mathrm{target}_k}{||\mathbf{target}||} \right) $$</p>

<p>It&#39;s radial, so its phase matches the spectrum itself:</p>

<p>$$ \mathrm{gradient}_k = \mathrm{|gradient_k|} \cdot \left(1 ∠ \mathrm{arg}(\mathrm{spectrum}_k) \right) $$</p>

<p>Eagle-eyed readers may notice the <code>sqrt</code> part of the L2 norm is missing here. It&#39;s only there for normalization, and in fact, you generally want a gradient that decreases the closer you get to the target. It acts as a natural stabilizer, forming a convex optimization problem.</p>

<p>You can transport this gradient backwards by applying an inverse FFT. Usually derivatives and FFTs don&#39;t commute, but that&#39;s only when you are deriving in the same dimension as the FFT. The partial derivative here is neither over time nor frequency, but by signal value.</p>

<p>The resulting time-domain gradient tells you how fast the (squared) loss would change if a given pixel changed. The sign tells you whether it needs to become lighter or darker. In theory, a pixel with a large gradient can enable larger score improvements per step.</p>

<p>It says little about what&#39;s a suitable pixel to pair with though. You can infer that a pixel needs to be paired with one that is brighter or darker, but not how much. The gradient only applies differentially. It involves two pixels, so it will cause interference between the two deltas, and also with the signal&#39;s own phase.</p>

<p>The time-domain gradient does change slowly after every swap—mainly the swapping pixels—so this only needs to add an extra IFFT every N swap attempts, reusing it in between.</p>

<p>I tried this in two ways. One was to bias random sampling towards points with the largest gradients. This barely did anything, when applied to one or both pixels.</p>

<p>Then I tried going down the list in order, and this worked better. I tried a bunch of heuristics here, like adding a retry until paired, and a &#39;dud&#39; tracker to reject known unpairable pixels. It did lead to some minor gains in successful sample selection. But beating random was still not a sure bet in all cases, because it comes at the cost of ordering and tracking all pixels to sample them.</p>

<p>All in all, it was quite mystifying.</p>

<h2>Pair Analysis</h2>

<p>Hence I analyzed <em>all</em> possible swaps <code>(A,B)</code> inside one 64x64 image at different stages of convergence, for 1024 pixels A (25% of total).</p>

<p>The result was quite illuminating. There are 2 indicators of a pixel&#39;s suitability for swapping:</p>

<ul>
<li>% of all possible swaps (A,_) that are good</li>
<li>score improvement of best possible swap (A,B)</li>
</ul>

<p>They are highly correlated, and you can take the geometric average to get a single quality score to order by:</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-1.png" alt="Pixel A quality"/>
</p></div>


<div><div>

<p>The curve shows that the best possible candidates are rare, with a sharp drop-off at the start. Here the average candidate is ~1/3rd as good as the best, though every pixel is pairable. This represents the typical situation when you have unconverged blue-ish noise.</p>

<p>Order all pixels by their (signed) gradient, and plot the quality:</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-2.png" alt="Pixel A quality by gradient"/>
</p></div>

<div><div>

<p>The distribution seems biased towards the ends. A larger absolute gradient at A can indeed lead to both better scores and higher % of good swaps.</p>

<p>Notice that it&#39;s also noisier at the ends, where it dips below the middle. If you order pixels by their quality, and then plot the absolute gradient, you see:</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-3.png" alt="Pixel A gradient by quality"/>
</p></div>

<div><div>

<p>Selecting for large gradient at A will select both the <em>best</em> and the <em>worst</em> possible pixels A. This implies that there are pixels in the noise that are very significant, but are nevertheless currently &#39;unfixable&#39;. This corresponds to the &#39;focus&#39; described earlier.</p>

<p>By drawing from the &#39;top&#39;, I was mining the imbalance between the good/left and bad/right distribution. Selecting for a vanishing gradient would instead select the average-to-bad pixels A.</p>

<p>I investigated one instance of each: very good, average or very bad pixel A. I tried every possible swap (A, B) and plotted the curve again. Here the quality is just the actual score improvement:</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-4p.png" alt="Pixel B quality for good pixel A"/>
</p></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-4m.png" alt="Pixel B quality for average pixel A"/>
</p></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-4n.png" alt="Pixel B quality for bad pixel A"/>
</p></div>

<div><div>

<p>The three scenarios have similar curves, with the bulk of swaps being negative. Only a tiny bit of the curve is sticking out positive, even in the best case. The potential benefit of a good swap is dwarfed by the potential harm of bad swaps. The main difference is just how many positive swaps there are, if any.</p>

<p>So let&#39;s focus on the positive case, where you can see best.</p>

<p>You can order by score, and plot the gradient of all the pixels B, to see another correlation.</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-5a.png" alt="Pixel B gradient by quality for good pixel A"/>
</p></div>

<div><div>

<p>It looks kinda promising. Here the sign matters, with left and right being different. If the gradient of pixel A is the opposite sign, then this graph is mirrored.</p>

<p>But if you order by (signed) gradient and plot the score, you see the real problem, caused by the noise:</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-5b.png" alt="Pixel B quality by gradient for good pixel A"/>
</p></div>

<div><div>

<p>The good samples are mixed freely among the bad ones, with only a very weak trend downward. This explains why sampling improvements based purely on gradient for pixel B are impossible.</p>

<p>You can see what&#39;s going on if you plot <code>Δv</code>, the difference in value between A and B:</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-5c.png" alt="Pixel B value by quality for good pixel A"/>
</p></div>

<div><div>

<p>For a given pixel A, all the good swaps have a similar value for B, which is not unexpected. Its mean is the ideal value for A, but there is a lot of variance. In this case pixel A is nearly white, so it is brighter than almost every other pixel B.</p>

<p>If you now plot <code>Δv * -gradient</code>, you see a clue on the left:</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-5d.png" alt="Pixel B value by quality for good pixel A"/>
</p></div>

<div><div>

<p>Almost all of the successful swaps have a small but positive value.</p>

<p>This represents what we already knew: the gradient&#39;s sign tells you if a pixel should be brighter or darker. If <code>Δv</code> has the opposite sign, the chances of a successful swap are slim.</p>

<p>Ideally both pixels &#39;face&#39; the right way, so the swap is beneficial on both ends. But only the combined effect on the loss matters: i.e. <code>Δv * Δgradient &lt; 0</code>.</p>

<p>It&#39;s only true differentially so it can misfire. But compared to blind sampling of pairs, it&#39;s easily 5-10x better and faster, racing towards the tougher parts of the search.</p>

<p>What&#39;s more... while this test is just binary, I found that any effort spent on trying to further prioritize swaps by the magnitude of the gradient is entirely wasted. Maximizing <code>Δv * Δgradient</code> by repeated sampling is counterproductive, because it selects more bad candidates on the right. Minimizing <code>Δv * Δgradient</code> creates more successful swaps on the left, but lowers the average improvement per step so the convergence is net slower. Anything more sophisticated incurs too much computation to be worth it.</p>

<p>It does have a limit. This is what it looks like when an image is practically fully converged:</p>

</div></div>

<div><p><img src="https://acko.net/files/fiddusion/sample-run-6.png" alt="Pixel B value by quality in late convergence"/>
</p></div>

<div><div>

<p>Eventually you reach the point where there are only a handful of swaps with any real benefit, while the rest is just shaving off a few bits of loss at a time. It devolves back to pure random selection, only skipping the coin flip for the gradient. It is likely that more targeted heuristics can still work here.</p>

<p>The gradient also works in the early stages. As it barely changes over successive swaps, this leads to a different kind of sparse mode. Instead of scoring only a subset of pixels, simply score multiple swaps as a group over time, without re-scoring intermediate states. This lowers the success rate roughly by a power (e.g. 0.8 -&gt; 0.64), but cuts the number of FFTs by a constant factor (e.g. 1/2). Early on this trade-off can be worth it.</p>

<p>Even faster: don&#39;t score steps at all. In the very early stage, you can easily get up to 80-90% successful swaps just by filtering on values and gradients. If you just swap a bunch in a row, there is a very good chance you will still end up better than before.</p>

<p>It works better than sparse scoring: using the gradient of your true objective approximately works better than using an approximate objective exactly.</p>

<p>The latter will miss the true goal by design, while the former continually re-aims itself to the destination despite inaccuracy.</p>

<p>Obviously you can mix and match techniques, and gradient + sparse is actually a winning combo. I&#39;ve only scratched the surface here.</p>


<h2>Warp Speed</h2>

<p>Time to address the elephant in the room. If the main bottleneck is an FFT, wouldn&#39;t this work better on a GPU?</p>

<p>The answer to that is an unsurprising yes, at least for large sizes where the overhead of async dispatch is negligible. However, it would have been endlessly more cumbersome to discover all of the above based on a GPU implementation, where I can&#39;t just log intermediate values to a console.</p>

<p>After checking everything, I pulled out my bag of tricks and ported it to Use.GPU. As a result, the algorithm runs entirely on the GPU, and provides live visualization of the entire process. It requires a WebGPU-enabled browser, which in practice means Chrome on Windows or Mac, or a dev build elsewhere.</p>

</div></div>




<div><p><a href="https://acko.net/files/bluebox/#!/" target="_blank"><img src="https://acko.net/files/fiddusion/app-viz.jpg" title="Stable Fiddusion - Visualization UI"/></a>
</p></div>



<div><div>

<p>I haven&#39;t particularly optimized this—the FFT is vanilla textbook—but it works. It provides an easy ~8x speed up on an M1 Mac on beefier target sizes. With a desktop GPU, 128x128x32 and larger become very feasible.</p>

<p>It lacks a few goodies from the scripts, and only does gradient + optional sparse. You can however freely exchange PNGs between the CPU and GPU version via drag and drop, as long as the settings match.</p>
  
</div></div>




<div><div>
  <p><img src="https://acko.net/files/fiddusion/app-tree-2.png" alt="Live Effect Run-time - Layout"/></p><p><em>Layout components</em></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/fiddusion/app-tree-1.png" alt="Live Effect Run-time - Compute Loop"/></p><p><em>Compute components</em></p>
</div></div>

<div><div>

<p>Worth pointing out: this visualization is built using Use.GPU&#39;s HTML-like layout system. I can put div-like blocks inside a flex box wrapper, and put text beside it... while at the same time using raw WGSL shaders as the contents of those divs. These visualization shaders sample and colorize the algorithm state on the fly, with no CPU-side involvement other than a static dispatch. The only GPU -&gt; CPU readback is for the stats in the corner, which are classic React and real HTML, along with the rest of the controls.</p>

<p>I can then build an <code>&lt;FFT&gt;</code> component and drop it inside an async <code>&lt;ComputeLoop&gt;</code>, and it does exactly what it should. The rest is just a handful of <code>&lt;Dispatch&gt;</code> elements and the ordinary headache of writing compute shaders. <code>&lt;Suspense&gt;</code> ensures all the shaders are compiled before dispatching.</p>

<p>While running, the bulk of the tree is inert, with only a handful of reducers triggering on a loop, causing a mere 7 live components to update per frame. The compute dispatch fights with the normal rendering for GPU resources, so there is an auto-batching mechanism that aims for approximately 30-60 FPS.</p>

<p>The display is fully anti-aliased, including the pixelized data. I&#39;m using the usual per-pixel SDF trickery to do this... it&#39;s applied as a <a href="https://gitlab.com/unconed/bluebox/-/blob/master/src/wgsl/viz-aa.wgsl?ref_type=heads" target="_blank">generic wrapper shader</a> for any UV-based sampler.</p>

<p>It&#39;s a good showcase that Use.GPU really is React-for-GPUs with less hassle, but still with all the goodies. It bypasses most of the browser once the canvas gets going, and it isn&#39;t just for UI: you can express async compute just fine with the right component design. The robust layout and vector plotting capabilities are just extra on top.</p>

<p>I won&#39;t claim it&#39;s the world&#39;s most elegant abstraction, because it&#39;s far too pragmatic for that. But I simply don&#39;t know any other programming environment where I could even try something like this and not get bogged down in GPU binding hell, or have to round-trip everything back to the CPU.</p>

<p>* * *</p>

<p>So there you have it: blue and indigo noise à la carte.</p>

<p>What I find most interesting is that the problem of <em>generating</em> noise in the time domain has been recast into shaping and <em>denoising</em> a spectrum in the frequency domain. It starts as white noise, and gets turned into a pre-designed picture. You do so by swapping pixels in the other domain. The state for this process is kept in the phase channel, which is not directly relevant to the problem, but drifts into alignment over time.</p>

<p>Hence I called it Stable Fiddusion. If you swap the two domains, you&#39;re turning noise into a picture by swapping <em>frequency bands</em> without changing their values. It would result in a complex-valued picture, whose magnitude is the target, and whose phase encodes the progress of the convergence process.</p>

<p>This is approximately what you get when you add a hidden layer to a diffusion model.</p>

<p>What I also find interesting is that the notion of swaps naturally creates a space that is O(N²) big with only N samples of actual data. Viewed from the perspective of a single step, every pair <code>(A,B)</code> corresponds to a unique information mask in the frequency domain that extracts a unique delta from the same data. There is redundancy, of course, but the nature of the Fourier transform smears it out into one big superposition. When you do multiple swaps, the space grows, but not quite that fast: any permutation of the same non-overlapping swaps is equivalent. There is also a notion of entanglement: frequency bands / pixels are linked together to move as a whole by default, but parts will diffuse into being locked in place.</p>

<p>Phase is kind of the bugbear of the DSP world. Everyone knows it&#39;s there, but they prefer not to talk about it unless its content is neat and simple. Hopefully by now you have a better appreciation of the true nature of a Fourier transform. Not just as a spectrum for a real-valued signal, but as a complex-valued transform of a complex-valued input.</p>

<p>During a swap run, the phase channel continuously looks like noise, but is actually highly structured when queried with the right quefrency hashes. I wonder what other things look like that, when you flip them around.</p>

<p>
  <b>More:</b>
  </p><ul>
    <li><a href="https://acko.net/files/bluebox/#!/" target="_blank">Stable Fiddusion app</a></li>
    <li><a href="https://gitlab.com/unconed/bluebox-js" target="_blank">CPU-side source code</a></li>
    <li><a href="https://gitlab.com/unconed/bluebox" target="_blank">WebGPU source code</a></li>
  </ul>





</div></div>


  

  
</article></div>
  </body>
</html>
