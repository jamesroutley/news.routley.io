<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lesswrong.com/posts/h99tRkpQGxwtb9Dpv/my-clients-the-liars">Original</a>
    <h1>My Clients, the Liars</h1>
    
    <div id="readability-page-1" class="page"><div>
     

<p>Hello! The other day I ran a Mastodon poll asking people how confident they
were that they understood how HEAD works in Git. The results (out of 1700
votes) were a little surprising to me:</p>

<ul>
<li>10% “100%”</li>
<li>36% “pretty confident”</li>
<li>39% “somewhat confident?”</li>
<li>15% “literally no idea”</li>
</ul>

<p>I was surprised that people were so unconfident about their understanding –
I’d been thinking of <code>HEAD</code> as a pretty straightforward topic.</p>

<p>Usually when people say that a topic is confusing when I think it’s not, the
reason is that there’s actually some hidden complexity that I wasn’t
considering. And after some follow up conversations, it turned out that <code>HEAD</code>
actually <em>was</em> a bit more complicated than I’d appreciated!</p>

<p>Here’s a quick table of contents:</p>

<ul>
<li><a href="#head-is-actually-a-few-different-things">HEAD is actually a few different things</a></li>
<li><a href="#the-file-git-head">the file .git/HEAD</a></li>
<li><a href="#head-as-in-git-show-head">HEAD as in git show HEAD</a></li>
<li><a href="#next-all-the-output-formats">next: all the output formats</a>

<ul>
<li><a href="#git-status-on-branch-main-or-head-detached">git status: “on branch main” or “HEAD detached”</a></li>
<li><a href="#detached-head-state">detached HEAD state</a></li>
<li><a href="#git-log-head-main">git log: (HEAD -&gt; main)</a></li>
<li><a href="#merge-conflicts-head-is-just-confusing">merge conflicts: &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD is just confusing</a></li>
</ul></li>
</ul>

<h3 id="head-is-actually-a-few-different-things">HEAD is actually a few different things</h3>

<p>After talking to a bunch of different people about <code>HEAD</code>, I realized that
<code>HEAD</code> actually has a few different closely related meanings:</p>

<ol>
<li>The file <code>.git/HEAD</code></li>
<li><code>HEAD</code> as in <code>git show HEAD</code> (git calls this a “revision parameter”)</li>
<li>All of the ways git uses <code>HEAD</code> in the output of various commands (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</code>, <code>(HEAD -&gt; main)</code>, <code>detached HEAD state</code>, <code>On branch main</code>, etc)</li>
</ol>

<p>These are extremely closely related to each other, but I don’t think the
relationship is totally obvious to folks who are starting out with git.</p>

<h3 id="the-file-git-head">the file <code>.git/HEAD</code></h3>

<p>Git has a very important file called <code>.git/HEAD</code>. The way this file works is that it contains either:</p>

<ol>
<li>The name of a <strong>branch</strong> (like <code>ref: refs/heads/main</code>)</li>
<li>A <strong>commit ID</strong> (like <code>96fa6899ea34697257e84865fefc56beb42d6390</code>)</li>
</ol>

<p>This file is what determines what your “current branch” is in Git. For example, when you run <code>git status</code> and see this:</p>

<pre><code>$ git status
On branch main
</code></pre>

<p>it means that the file <code>.git/HEAD</code> contains <code>ref: refs/heads/main</code>.</p>

<p>If <code>.git/HEAD</code> contains a commit ID instead of a branch, git calls that
“detached HEAD state”. We’ll get to that later.</p>

<p><small>
(People will sometimes say that HEAD contains a name of a <strong>reference</strong> or a
commit ID, but I’m pretty sure that that the reference has to be a <strong>branch</strong>.
You <em>can</em> technically make <code>.git/HEAD</code> contain the name of a reference that
isn’t a branch by manually editing <code>.git/HEAD</code>, but I don’t think you can do it
with a regular git command. I’d be interested to know if there is a
regular-git-command way to make .git/HEAD a non-branch reference though, and if
so why you might want to do that!)
</small></p>

<h3 id="head-as-in-git-show-head"><code>HEAD</code> as in <code>git show HEAD</code></h3>

<p>It’s very common to use <code>HEAD</code> in git commands to refer to a commit ID, like:</p>

<ul>
<li><code>git diff HEAD</code></li>
<li><code>git rebase -I HEAD^^^^</code></li>
<li><code>git diff main..HEAD</code></li>
<li><code>git reset --hard HEAD@{2}</code></li>
</ul>

<p>All of these things (<code>HEAD</code>, <code>HEAD^^^</code>, <code>HEAD@[2}</code>) are called “revision parameters”. They’re documented in <a href="https://git-scm.com/docs/gitrevisions">man
gitrevisions</a>, and Git will try to
resolve them to a commit ID.</p>

<p>(I’ve honestly never actually heard the term “revision parameter” before, but
that’s the term that’ll get you to the documentation for this concept)</p>

<p>HEAD in <code>git show HEAD</code> has a pretty simple meaning: it resolves to the
<strong>current commit</strong> you have checked out! Git resolves <code>HEAD</code> in one of two ways:</p>

<ol>
<li>if <code>.git/HEAD</code> contains a branch name, it’ll be the latest commit on that branch (for example by reading it from <code>.git/refs/heads/main</code>)</li>
<li>if <code>.git/HEAD</code> contains a commit ID, it’ll be that commit ID</li>
</ol>

<h3 id="next-all-the-output-formats">next: all the output formats</h3>

<p>Now we’ve talked about the file <code>.git/HEAD</code>, and the “revision parameter”
<code>HEAD</code>, like in <code>git show HEAD</code>. We’re left with all of the various ways git
uses <code>HEAD</code> in its output.</p>

<h3 id="git-status-on-branch-main-or-head-detached"><code>git status</code>: “on branch main” or “HEAD detached”</h3>

<p>When you run <code>git status</code>, the first line will always look like one of these two:</p>

<ol>
<li><code>on branch main</code>. This means that <code>.git/HEAD</code> contains a branch.</li>
<li><code>HEAD detached at 90c81c72</code>. This means that <code>.git/HEAD</code> contains a commit ID.</li>
</ol>

<p>I promised earlier I’d explain what “HEAD detached” means, so let’s do that now.</p>

<h3 id="detached-head-state">detached HEAD state</h3>

<p>“HEAD is detached” or “detached HEAD state” mean that you have no current branch.</p>

<p>Having no current branch is a little dangerous because if you make new commits,
those commits won’t be attached to any branch – they’ll be orphaned! Orphaned
commits are a problem for 2 reasons:</p>

<ol>
<li>the commits are more difficult to find (you can’t run <code>git log somebranch</code> to find them)</li>
<li>orphaned commits will eventually be deleted by git’s garbage collection</li>
</ol>

<p>Personally I’m very careful about avoiding creating commits in detached HEAD state, though some people <a href="https://github.com/arxanas/git-branchless">prefer to work that way</a>.
Getting out of detached HEAD state is pretty easy though, you can either:</p>

<ol>
<li>Go back to a branch (<code>git checkout main</code>)</li>
<li>Create a new branch at that commit (<code>git checkout -b newbranch</code>)</li>
<li>If you’re in detached HEAD state because you’re in the middle of a rebase, finish or abort the rebase (<code>git rebase --abort</code>)</li>
</ol>

<p>Okay, back to other git commands which have <code>HEAD</code> in their output!</p>

<h3 id="git-log-head-main"><code>git log</code>: <code>(HEAD -&gt; main)</code></h3>

<p>When you run <code>git log</code> and look at the first line, you might see one of the following 3 things:</p>

<ol>
<li><code>commit 96fa6899ea (HEAD -&gt; main)</code></li>
<li><code>commit 96fa6899ea (HEAD, main)</code></li>
<li><code>commit 96fa6899ea (HEAD)</code></li>
</ol>

<p>It’s not totally obvious how to interpret these, so here’s the deal:</p>

<ul>
<li>inside the <code>(...)</code>, git lists every reference that points at that commit, for example <code>(HEAD -&gt; main, origin/main, origin/HEAD)</code> means <code>HEAD</code>, <code>main</code>, <code>origin/main</code>, and <code>origin/HEAD</code> all point at that commit (either directly or indirectly)</li>
<li><code>HEAD -&gt; main</code> means that your current branch is <code>main</code></li>
<li>If that line says <code>HEAD,</code> instead of <code>HEAD -&gt;</code>, it means you’re in detached HEAD state (you have no current branch)</li>
</ul>

<p>if we use these rules to explain the 3 examples above: the result is:</p>

<ol>
<li><code>commit 96fa6899ea (HEAD -&gt; main)</code> means:

<ul>
<li><code>.git/HEAD</code> contains <code>ref: refs/heads/main</code></li>
<li><code>.git/refs/heads/main</code> contains <code>96fa6899ea</code></li>
</ul></li>
<li><code>commit 96fa6899ea (HEAD, main)</code> means:

<ul>
<li><code>.git/HEAD</code> contains <code>96fa6899ea</code> (HEAD is “detached”)</li>
<li><code>.git/refs/heads/main</code> also contains <code>96fa6899ea</code></li>
</ul></li>
<li><code>commit 96fa6899ea (HEAD)</code> means:

<ul>
<li><code>.git/HEAD</code> contains <code>96fa6899ea</code> (HEAD is “detached”)</li>
<li><code>.git/refs/heads/main</code> either contains a different commit ID or doesn’t exist</li>
</ul></li>
</ol>

<h3 id="merge-conflicts-head-is-just-confusing">merge conflicts: <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> is just confusing</h3>

<p>When you’re resolving a merge conflict, you might see something like this:</p>

<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
def parse(input):
    return input.split(&#34;\n&#34;)
=======
def parse(text):
    return text.split(&#34;\n\n&#34;)
&gt;&gt;&gt;&gt;&gt;&gt;&gt; somebranch
</code></pre>

<p>I find <code>HEAD</code> in this context extremely confusing and I basically just ignore it. Here’s why.</p>

<ul>
<li>When you do a <strong>merge</strong>, <code>HEAD</code> in the merge conflict is the same as what <code>HEAD</code> when you ran <code>git merge</code>. Simple.</li>
<li>When you do a <strong>rebase</strong>, <code>HEAD</code> in the merge conflict is something totally different: it’s the <strong>other commit</strong> that you’re rebasing on top of. So it’s totally different from what <code>HEAD</code> was when you ran <code>git rebase</code>. It’s like this because rebase works by first checking out the other commit and then repeatedly cherry-picking commits on top of it.</li>
</ul>

<p>Similarly, the meaning of “ours” and “theirs” are flipped in a merge and rebase.</p>

<p>The fact that the meaning of <code>HEAD</code> changes depending on whether I’m doing a
rebase or merge is really just too confusing for me and I find it much simpler
to just ignore <code>HEAD</code> entirely and use another method to figure out which part
of the code is which.</p>

<h3 id="some-thoughts-on-consistent-terminology">some thoughts on consistent terminology</h3>

<p>I think HEAD would be more intuitive if git’s terminology around HEAD were a
little more internally consistent.</p>

<p>For example, git talks about “detached HEAD state”, but never about “attached
HEAD state” – git’s documentation never uses the term “attached” at all to
refer to <code>HEAD</code>. And git talks about being “on” a branch, but never “not on” a
branch.</p>

<p>So it’s very hard to guess that <code>on branch main</code> is actually the opposite of
<code>HEAD detached</code>. How is the user supposed to guess that <code>HEAD detached</code> has
anything to do with branches at all, or that “on branch main” has anything to
do with <code>HEAD</code>?</p>

<h3 id="that-s-all">that’s all!</h3>

<p>If I think of other ways <code>HEAD</code> is used in Git (especially ways HEAD appears in
Git’s output), I might add them to this post later.</p>

<p>If you find HEAD confusing, I hope this helps a bit!</p>

</div></div>
  </body>
</html>
