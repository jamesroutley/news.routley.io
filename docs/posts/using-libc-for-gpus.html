<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://libc.llvm.org/gpu/using.html">Original</a>
    <h1>Using Libc for GPUs</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <div>
          

          <div role="main">
            
  <section id="using-libc-for-gpus">
<span id="libc-gpu-usage"></span>
<nav id="table-of-contents">
<p>Table of Contents</p>
<ul>
<li><p><a href="#using-the-gpu-c-library" id="id1">Using the GPU C library</a></p>
<ul>
<li><p><a href="#offloading-usage" id="id2">Offloading usage</a></p>
<ul>
<li><p><a href="#openmp-offloading-example" id="id3">OpenMP Offloading example</a></p></li>
<li><p><a href="#binary-format" id="id4">Binary format</a></p></li>
</ul>
</li>
<li><p><a href="#direct-compilation" id="id5">Direct compilation</a></p>
<ul>
<li><p><a href="#building-for-amdgpu-targets" id="id6">Building for AMDGPU targets</a></p></li>
<li><p><a href="#building-for-nvptx-targets" id="id7">Building for NVPTX targets</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="using-the-gpu-c-library">
<h2><a href="#id1" role="doc-backlink">Using the GPU C library</a><a href="#using-the-gpu-c-library" title="Permalink to this heading">¶</a></h2>
<p>Once you have finished <a href="https://libc.llvm.org/gpu/building.html#libc-gpu-building"><span>building</span></a> the GPU C library it
can be used to run libc or libm functions directly on the GPU. Currently, not
all C standard functions are supported on the GPU. Consult the <a href="https://libc.llvm.org/gpu/support.html#libc-gpu-support"><span>list of
supported functions</span></a> for a comprehensive list.</p>
<p>The GPU C library supports two main usage modes. The first is as a supplementary
library for offloading languages such as OpenMP, CUDA, or HIP. These aim to
provide standard system utilities similarly to existing vendor libraries. The
second method treats the GPU as a hosted target by compiling C or C++ for it
directly. This is more similar to targeting OpenCL and is primarily used for
exported functions on the GPU and testing.</p>
<section id="offloading-usage">
<h3><a href="#id2" role="doc-backlink">Offloading usage</a><a href="#offloading-usage" title="Permalink to this heading">¶</a></h3>
<p>Offloading languages like CUDA, HIP, or OpenMP work by compiling a single source
file for both the host target and a list of offloading devices. In order to
support standard compilation flows, the <code><span>clang</span></code> driver uses fat binaries,
described in the <a href="https://clang.llvm.org/docs/OffloadingDesign.html">clang documentation</a>. This linking mode is used
by the OpenMP toolchain, but is currently opt-in for the CUDA and HIP toolchains
through the <code><span>--offload-new-driver`</span></code> and <code><span>-fgpu-rdc</span></code> flags.</p>
<p>In order or link the GPU runtime, we simply pass this library to the embedded
device linker job. This can be done using the <code><span>-Xoffload-linker</span></code> option, which
forwards an argument to a <code><span>clang</span></code> job used to create the final GPU executable.
The toolchain should pick up the C libraries automatically in most cases, so
this shouldn’t be necessary.</p>
<div><div><pre><span></span>$&gt;<span> </span>clang<span> </span>openmp.c<span> </span>-fopenmp<span> </span>--offload-arch<span>=</span>gfx90a<span> </span>-Xoffload-linker<span> </span>-lc
$&gt;<span> </span>clang<span> </span>cuda.cu<span> </span>--offload-arch<span>=</span>sm_80<span> </span>--offload-new-driver<span> </span>-fgpu-rdc<span> </span>-Xoffload-linker<span> </span>-lc
$&gt;<span> </span>clang<span> </span>hip.hip<span> </span>--offload-arch<span>=</span>gfx940<span> </span>--offload-new-driver<span> </span>-fgpu-rdc<span> </span>-Xoffload-linker<span> </span>-lc
</pre></div>
</div>
<p>This will automatically link in the needed function definitions if they were
required by the user’s application. Normally using the <code><span>-fgpu-rdc</span></code> option
results in sub-par performance due to ABA linking. However, the offloading
toolchain supports the <code><span>--foffload-lto</span></code> option to support LTO on the target
device.</p>
<p>Offloading languages require that functions present on the device be declared as
such. This is done with the <code><span>__device__</span></code> keyword in CUDA and HIP or the
<code><span>declare</span> <span>target</span></code> pragma in OpenMP. This requires that the LLVM C library
exposes its implemented functions to the compiler when it is used to build. We
support this by providing wrapper headers in the compiler’s resource directory.
These are located in <code><span>&lt;clang-resource-dir&gt;/include/llvm-libc-wrappers</span></code> in your
installation.</p>
<p>The support for HIP and CUDA is more experimental, requiring manual intervention
to link and use the facilities. An example of this is shown in the <a href="https://libc.llvm.org/gpu/rpc.html#libc-gpu-cuda-server"><span>CUDA
server example</span></a>. The OpenMP Offloading toolchain is
completely integrated with the LLVM C library however. It will automatically
handle including the necessary libraries, define device-side interfaces, and run
the RPC server.</p>
<section id="openmp-offloading-example">
<h4><a href="#id3" role="doc-backlink">OpenMP Offloading example</a><a href="#openmp-offloading-example" title="Permalink to this heading">¶</a></h4>
<p>This section provides a simple example of compiling an OpenMP program with the
GPU C library.</p>
<div><div><pre><span></span><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span>

<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>FILE</span><span> </span><span>*</span><span>file</span><span> </span><span>=</span><span> </span><span>stderr</span><span>;</span>
<span>#pragma omp target teams num_teams(2) thread_limit(2)</span>
<span>#pragma omp parallel num_threads(2)</span>
<span>  </span><span>{</span><span> </span><span>fputs</span><span>(</span><span>&#34;Hello from OpenMP!</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>file</span><span>);</span><span> </span><span>}</span>
<span>}</span>
</pre></div>
</div>
<p>This can simply be compiled like any other OpenMP application to print from two
threads and two blocks.</p>
<div><div><pre><span></span>$&gt;<span> </span>clang<span> </span>openmp.c<span> </span>-fopenmp<span> </span>--offload-arch<span>=</span>gfx90a
$&gt;<span> </span>./a.out
Hello<span> </span>from<span> </span>OpenMP!
Hello<span> </span>from<span> </span>OpenMP!
Hello<span> </span>from<span> </span>OpenMP!
Hello<span> </span>from<span> </span>OpenMP!
</pre></div>
</div>
<p>Including the wrapper headers, linking the C library, and running the <a href="https://libc.llvm.org/gpu/rpc.html#libc-gpu-rpc"><span>RPC
server</span></a> are all handled automatically by the compiler and runtime.</p>
</section>
<section id="binary-format">
<h4><a href="#id4" role="doc-backlink">Binary format</a><a href="#binary-format" title="Permalink to this heading">¶</a></h4>
<p>The <code><span>libcgpu.a</span></code> static archive is a fat-binary containing LLVM-IR for each
supported target device. The supported architectures can be seen using LLVM’s
<code><span>llvm-objdump</span></code> with the <code><span>--offloading</span></code> flag:</p>
<div><div><pre><span></span>$&gt;<span> </span>llvm-objdump<span> </span>--offloading<span> </span>libcgpu-amdgpu.a
libcgpu-amdgpu.a<span>(</span>strcmp.cpp.o<span>)</span>:<span>    </span>file<span> </span>format<span> </span>elf64-x86-64

OFFLOADING<span> </span>IMAGE<span> </span><span>[</span><span>0</span><span>]</span>:
kind<span>            </span>llvm<span> </span>ir
arch<span>            </span>generic
triple<span>          </span>amdgcn-amd-amdhsa
producer<span>        </span>none
...
</pre></div>
</div>
<p>Because the device code is stored inside a fat binary, it can be difficult to
inspect the resulting code. This can be done using the following utilities:</p>
<div><div><pre><span></span>$&gt;<span> </span>llvm-ar<span> </span>x<span> </span>libcgpu.a<span> </span>strcmp.cpp.o
$&gt;<span> </span>clang-offload-packager<span> </span>strcmp.cpp.o<span> </span>--image<span>=</span><span>arch</span><span>=</span>generic,file<span>=</span>strcmp.bc
$&gt;<span> </span>opt<span> </span>-S<span> </span>out.bc
...
</pre></div>
</div>
<p>Please note that this fat binary format is provided for compatibility with
existing offloading toolchains. The implementation in <code><span>libc</span></code> does not depend
on any existing offloading languages and is completely freestanding.</p>
</section>
</section>
<section id="direct-compilation">
<h3><a href="#id5" role="doc-backlink">Direct compilation</a><a href="#direct-compilation" title="Permalink to this heading">¶</a></h3>
<p>Instead of using standard offloading languages, we can also target the CPU
directly using C and C++ to create a GPU executable similarly to OpenCL. This is
done by targeting the GPU architecture using <a href="https://clang.llvm.org/docs/CrossCompilation.html">clang’s cross compilation
support</a>. This is the
method that the GPU C library uses both to build the library and to run tests.</p>
<p>This allows us to easily define GPU specific libraries and programs that fit
well into existing tools. In order to target the GPU effectively we rely heavily
on the compiler’s intrinsic and built-in functions. For example, the following
function gets the thread identifier in the ‘x’ dimension on both GPUs supported
GPUs.</p>
<div><div><pre><span></span><span>uint32_t</span><span> </span><span>get_thread_id_x</span><span>()</span><span> </span><span>{</span>
<span>#if defined(__AMDGPU__)</span>
<span>  </span><span>return</span><span> </span><span>__builtin_amdgcn_workitem_id_x</span><span>();</span>
<span>#elif defined(__NVPTX__)</span>
<span>  </span><span>return</span><span> </span><span>__nvvm_read_ptx_sreg_tid_x</span><span>();</span>
<span>#else</span>
<span>#error &#34;Unsupported platform&#34;</span>
<span>#endif</span>
<span>}</span>
</pre></div>
</div>
<p>We can then compile this for both NVPTX and AMDGPU into LLVM-IR using the
following commands. This will yield valid LLVM-IR for the given target just like
if we were using CUDA, OpenCL, or OpenMP.</p>
<div><div><pre><span></span>$&gt;<span> </span>clang<span> </span>id.c<span> </span>--target<span>=</span>amdgcn-amd-amdhsa<span> </span>-mcpu<span>=</span>native<span> </span>-nogpulib<span> </span>-flto<span> </span>-c
$&gt;<span> </span>clang<span> </span>id.c<span> </span>--target<span>=</span>nvptx64-nvidia-cuda<span> </span>-march<span>=</span>native<span> </span>-nogpulib<span> </span>-flto<span> </span>-c
</pre></div>
</div>
<p>We can also use this support to treat the GPU as a hosted environment by
providing a C library and startup object just like a standard C library running
on the host machine. Then, in order to execute these programs, we provide a
loader utility to launch the executable on the GPU similar to a cross-compiling
emulator. This is how we run <a href="https://libc.llvm.org/gpu/testing.html#libc-gpu-testing"><span>unit tests</span></a> targeting the
GPU. This is clearly not the most efficient way to use a GPU, but it provides a
simple method to test execution on a GPU for debugging or development.</p>
<section id="building-for-amdgpu-targets">
<h4><a href="#id6" role="doc-backlink">Building for AMDGPU targets</a><a href="#building-for-amdgpu-targets" title="Permalink to this heading">¶</a></h4>
<p>The AMDGPU target supports several features natively by virtue of using <code><span>lld</span></code>
as its linker. The installation will include the <code><span>include/amdgcn-amd-amdhsa</span></code>
and <code><span>lib/amdgcn-amd-amdha</span></code> directories that contain the necessary code to use
the library. We can directly link against <code><span>libc.a</span></code> and use LTO to generate the
final executable.</p>
<div><div><pre><span></span><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span>

<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span> </span><span>printf</span><span>(</span><span>&#34;Hello from AMDGPU!</span><span>\n</span><span>&#34;</span><span>);</span><span> </span><span>}</span>
</pre></div>
</div>
<p>This program can then be compiled using the <code><span>clang</span></code> compiler. Note that
<code><span>-flto</span></code> and <code><span>-mcpu=</span></code> should be defined. This is because the GPU
sub-architectures do not have strict backwards compatibility. Use <code><span>-mcpu=help</span></code>
for accepted arguments or <code><span>-mcpu=native</span></code> to target the system’s installed GPUs
if present. Additionally, the AMDGPU target always uses <code><span>-flto</span></code> because we
currently do not fully support ELF linking in <code><span>lld</span></code>. Once built, we use the
<code><span>amdhsa-loader</span></code> utility to launch execution on the GPU. This will be built if
the <code><span>hsa_runtime64</span></code> library was found during build time.</p>
<div><div><pre><span></span>$&gt;<span> </span>clang<span> </span>hello.c<span> </span>--target<span>=</span>amdgcn-amd-amdhsa<span> </span>-mcpu<span>=</span>native<span> </span>-flto<span> </span>-lc<span> </span>&lt;install&gt;/lib/amdgcn-amd-amdhsa/crt1.o
$&gt;<span> </span>amdhsa-loader<span> </span>--threads<span> </span><span>2</span><span> </span>--blocks<span> </span><span>2</span><span> </span>a.out
Hello<span> </span>from<span> </span>AMDGPU!
Hello<span> </span>from<span> </span>AMDGPU!
Hello<span> </span>from<span> </span>AMDGPU!
Hello<span> </span>from<span> </span>AMDGPU!
</pre></div>
</div>
<p>This will include the <code><span>stdio.h</span></code> header, which is found in the
<code><span>include/amdgcn-amd-amdhsa</span></code> directory. We define out <code><span>main</span></code> function like a
standard application. The startup utility in <code><span>lib/amdgcn-amd-amdhsa/crt1.o</span></code>
will handle the necessary steps to execute the <code><span>main</span></code> function along with
global initializers and command line arguments. Finally, we link in the
<code><span>libc.a</span></code> library stored in <code><span>lib/amdgcn-amd-amdhsa</span></code> to define the standard C
functions.</p>
<p>The search paths for the include directories and libraries are automatically
handled by the compiler. We use this support internally to run unit tests on the
GPU directly. See <a href="https://libc.llvm.org/gpu/testing.html#libc-gpu-testing"><span>Testing the GPU C library</span></a> for more information. The installation
also provides <code><span>libc.bc</span></code> which is a single LLVM-IR bitcode blob that can be
used instead of the static library.</p>
</section>
<section id="building-for-nvptx-targets">
<h4><a href="#id7" role="doc-backlink">Building for NVPTX targets</a><a href="#building-for-nvptx-targets" title="Permalink to this heading">¶</a></h4>
<p>The infrastructure is the same as the AMDGPU example. However, the NVPTX binary
utilities are very limited and must be targeted directly. A utility called
<code><span>clang-nvlink-wrapper</span></code> instead wraps around the standard link job to give the
illusion that <code><span>nvlink</span></code> is a functional linker.</p>
<div><div><pre><span></span><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span>

<span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>,</span><span> </span><span>char</span><span> </span><span>**</span><span>argv</span><span>,</span><span> </span><span>char</span><span> </span><span>**</span><span>envp</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>printf</span><span>(</span><span>&#34;Hello from NVPTX!</span><span>\n</span><span>&#34;</span><span>);</span>
<span>}</span>
</pre></div>
</div>
<p>Additionally, the NVPTX ABI requires that every function signature matches. This
requires us to pass the full prototype from <code><span>main</span></code>. The installation will
contain the <code><span>nvptx-loader</span></code> utility if the CUDA driver was found during
compilation. Using link time optimization will help hide this.</p>
<div><div><pre><span></span>$&gt;<span> </span>clang<span> </span>hello.c<span> </span>--target<span>=</span>nvptx64-nvidia-cuda<span> </span>-mcpu<span>=</span>native<span> </span>-flto<span> </span>-lc<span> </span>&lt;install&gt;/lib/nvptx64-nvidia-cuda/crt1.o
$&gt;<span> </span>nvptx-loader<span> </span>--threads<span> </span><span>2</span><span> </span>--blocks<span> </span><span>2</span><span> </span>a.out
Hello<span> </span>from<span> </span>NVPTX!
Hello<span> </span>from<span> </span>NVPTX!
Hello<span> </span>from<span> </span>NVPTX!
Hello<span> </span>from<span> </span>NVPTX!
</pre></div>
</div>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      
      
    </div></div>
  </body>
</html>
