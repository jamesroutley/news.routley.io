<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.winter.dev/2020/gjk-algorithm/">Original</a>
    <h1>GJK: Collision detection algorithm in 2D/3D</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>In my last article, I only covered sphere <em>vs</em>. sphere collisions because they are the simplest to compute. Spheres are nice and all, but there comes a time when more complex shapes are needed. One popular algorithm for testing collisions is the Gilbert–Johnson–Keerthi algorithm, or GJK for short. With it we can detect collisions between any two convex polygons.</p>



<p>The GJK algorithm is very useful and widely used, but no good visualization or concise explanations exist for some reason. A few years ago, I listened and relistened to a video by <a href="https://www.youtube.com/watch?v=Qupqu1xe7Io">Casey Muratori</a> that explains the algorithm in great detail and goes through some smart insights that give a good mental image of how it works. Yet I have found no full interactive visualizations. Let’s jump into it!</p>



<p><strong>Difference between spheres and polygons</strong></p>



<p>Testing for a collision between spheres is easy because there are only two points in the system. This leaves us with a single vector that we can compare against the sum of their radii to determine if there is a collision.</p>



<div><figure><img src="https://blog.winter.dev/wp-content/uploads/2020/08/circles.jpg" alt="" srcset="https://blog.winter.dev/wp-content/uploads/2020/08/circles.jpg 503w, https://blog.winter.dev/wp-content/uploads/2020/08/circles-300x138.jpg 300w" sizes="(max-width: 503px) 100vw, 503px"/></figure></div>



<p>With polygons we cannot make such simplifications. They are made from multiple vertices, removing any apparent way of finding their distance and clear radius property to compare against. We need a smarter way of testing for a collision.</p>



<p>Like we subtracted the points in the sphere system, let’s see what happens if we subtract the vertices of the polygons.</p>



<div><figure><img src="https://blog.winter.dev/wp-content/uploads/2020/08/polygons.jpg" alt="" srcset="https://blog.winter.dev/wp-content/uploads/2020/08/polygons.jpg 427w, https://blog.winter.dev/wp-content/uploads/2020/08/polygons-300x184.jpg 300w" sizes="(max-width: 427px) 100vw, 427px"/></figure></div>



<p>Subtracting two polygons with the same number of vertices is straightforward, but if we want to support various polygons, we need to subtract each vertex from <em>every</em> vertex on the other polygon. Because there are multiple vertices, we are not left with a single vector, but many that form another polygon. This results in a cloud of <span data-katex-display="false">A*B</span> number vertices that we need to process further to select the outer convex hull from.</p>



<p>This outer hull is known as the <a href="https://en.wikipedia.org/wiki/Minkowski_addition">Minkowski difference</a>. It represents the distance between every point of the two polygons. We are going to use it to turn two polygons into one that we can analyze to detect a collision. <strong>The key is that if the origin is inside the difference, there must have been two points that subtracted to 0; meaning there is overlap somewhere.</strong></p>



<p>Move around the <span data-katex-display="false">B</span> polygon to get an idea of how this works. - This works to various degrees on mobile 🙁</p>







<p><strong>Abstracting shapes into supporting points</strong></p>



<p>The Minkowski difference is nice for visualization, but far too expensive to compute in real time; we need a way to simplify it.</p>



<p>The GJK algorithm is only concerned with the outer hull of our cloud of vertices, so it would give a substantial speed up if we could cut down on the time spent finding them. Let’s think about what puts a vertex on the hull. If we look closer, notice that those vertices have the most extreme components. They got to their locations from subtraction between two other vertices, so for one to be the most extreme, it must have come from the most extreme vertices on the source polygons. If we define ‘most extreme’ as the furthest in some direction, we can play with the math to get this speed increase.</p>



<p>Finding the furthest vertex is done by iterating over the set of vertices and finding the one with the largest dot product in a direction. Let <span data-katex-display="false">\vec{D}</span> be the direction and <span data-katex-display="false">A-B</span> be the cloud of vertices.</p>



<p><span data-katex-display="true">\max\{\vec{D}\cdot{(A-B)}\}</span></p><p>Computing <span data-katex-display="false">A-B</span> took <span data-katex-display="false">A*B</span> number of steps; making this function an <span data-katex-display="false">O(n^2)</span> operation. Luckily for us, we can distribute and never have to compute the full difference.</p>



<p>If we distribute the dot product and max function we’re left with this:</p>



<p><span data-katex-display="true">\max\{(\vec{D}\cdot{A})-(\vec{D}\cdot{B})\}</span>



<span data-katex-display="true">\max\{\vec{D}\cdot{A}\}-\max\{(-\vec{D})\cdot{B}\}</span></p><p>Now all we need is <span data-katex-display="false">A+B</span> steps; turning our quadratic time function into a linear one.</p>



<p>We need to reverse the direction for <span data-katex-display="false">A</span> when we distribute max because we want to retain the max value. We want the lest extreme vertex from <span data-katex-display="false">B</span> to subtract from the most extreme vertex from <span data-katex-display="false">A</span>.</p>



<div><figure><img src="https://blog.winter.dev/wp-content/uploads/2020/08/suppoints-1.jpg" alt="" srcset="https://blog.winter.dev/wp-content/uploads/2020/08/suppoints-1.jpg 2242w, https://blog.winter.dev/wp-content/uploads/2020/08/suppoints-1-300x99.jpg 300w, https://blog.winter.dev/wp-content/uploads/2020/08/suppoints-1-1024x338.jpg 1024w, https://blog.winter.dev/wp-content/uploads/2020/08/suppoints-1-768x253.jpg 768w, https://blog.winter.dev/wp-content/uploads/2020/08/suppoints-1-1536x507.jpg 1536w, https://blog.winter.dev/wp-content/uploads/2020/08/suppoints-1-2048x676.jpg 2048w" sizes="(max-width: 2242px) 100vw, 2242px"/></figure></div>



<p>These vertices are referred to as <a href="https://en.wikipedia.org/wiki/Support_function">supporting points</a>, and give a view into the Minkowski difference without ever calculating more than we need.</p>



<p>Let’s look at the implementation -- I’m going to continue to use the <em>Collider</em> structs from the <a href="https://blog.winter.dev/2020/designing-a-physics-engine/">last article</a> for consistency, but will only include the new pieces from this article.</p>



<p>We’ll start by adding a function that finds the support point in a given direction. Let’s call it <em>FindFurthestPoint</em>. If we have other special types of colliders like spheres, capsules, or planes, we can override this function allowing them to be used with GJK as well.</p>



<pre><span>struct</span> <span>Collider</span> <span>{</span>
	<span>virtual</span> <span>vector3</span> <span>FindFurthestPoint</span><span>(</span>
		<span>vector3</span> <span>direction</span><span>)</span> <span>const</span> <span>=</span> <span>0</span><span>;</span>
<span>};</span></pre>



<p>Next, we’ll make a <em>MeshCollider</em> with a list of vertices to act as our polygon. <em>FindFurthestPoint</em> needs to loop over each vertex and compare the distance along the direction. We’ll keep track of the max vertex &amp; distance to compare. Once we have iterated over all the points, we’ll return the max point.</p>



<pre><span>struct</span> <span>MeshCollider</span>
	<span>:</span> <span>Collider</span>
<span>{</span>
<span>private</span><span>:</span>
	<span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>vector3</span><span>&gt;</span> <span>m_vertices</span><span>;</span>
 
<span>public</span><span>:</span>
	<span>vector3</span> <span>FindFurthestPoint</span><span>(</span>
		<span>vector3</span> <span>direction</span><span>)</span> <span>const</span> <span>override</span>
	<span>{</span>
		<span>vector3</span> <span>maxPoint</span><span>;</span>
		<span>float</span>   <span>maxDistance</span> <span>=</span> <span>-</span><span>FLT_MAX</span><span>;</span>
 
		<span>for</span> <span>(</span><span>vector3</span> <span>vertex</span> <span>:</span> <span>m_vertices</span><span>)</span> <span>{</span>
			<span>float</span> <span>distance</span> <span>=</span> <span>vertex</span><span>.</span><span>dot</span><span>(</span><span>direction</span><span>);</span>
			<span>if</span> <span>(</span><span>distance</span> <span>&gt;</span> <span>maxDistance</span><span>)</span> <span>{</span>
				<span>maxDistance</span> <span>=</span> <span>distance</span><span>;</span>
				<span>maxPoint</span> <span>=</span> <span>vertex</span><span>;</span>
			<span>}</span>
		<span>}</span>
 
		<span>return</span> <span>maxPoint</span><span>;</span>
	<span>}</span>
<span>};</span></pre>



<p>We can roll all of this into a function called <em>Support</em> that will take two colliders and a direction and return the vertex on the Minkowski difference.</p>



<pre><span>vector3</span> <span>Support</span><span>(</span>
	<span>const</span> <span>Collider</span><span>*</span> <span>colliderA</span><span>,</span>
	<span>const</span> <span>Collider</span><span>*</span> <span>colliderB</span><span>,</span>
	<span>vector3</span> <span>direction</span><span>)</span>
<span>{</span>
	<span>return</span> <span>colliderA</span><span>-&gt;</span><span>FindFurthestPoint</span><span>(</span> <span>direction</span><span>)</span>
		<span>-</span> <span>colliderB</span><span>-&gt;</span><span>FindFurthestPoint</span><span>(</span><span>-</span><span>direction</span><span>);</span>
<span>}</span></pre>



<p>With these functions, we have abstracted away not only any convex polygon, but any collider type that implements <em>FindFurthestPoint</em> into a single function that we can use in the algorithm.</p>



<p><strong>GJK: Surrounding the origin</strong></p>



<p>The goal of the GJK algorithm is to determine if the origin is within the Minkowski difference. This would be easy, but we’ve thrown out the complete difference for the sake of performance. We only have the <em>Support</em> function that gives us one vertex at a time. We need to iteratively search for and build up what’s referred to as a <a href="https://en.wikipedia.org/wiki/Simplex">simplex</a> around the origin.</p>



<p>A simplex is defined as a shape that has <span data-katex-display="false">N+1</span> number of vertices with <span data-katex-display="false">N</span> being the number of dimensions. Practically, this represents the simplest shape that can ‘select’ a region in space. For example, in 2D a triangle is the simplest shape that can select an area containing a specific point. These shapes have simple tests that we can use to determine which vertex, edge, or face is closest to the origin. Depending on which feature is closest, we’ll remove, add, or swap points to make the simplex closer to the origin. If we find that the closest feature is already the closest possible, but the origin is not inside, we know there is no collision. Otherwise, if we find the origin inside the simplex we know there has been a collision.</p>



<p>We get the vertices for the simplex from the <em>Support</em> function, so we need to find the direction to the origin from the closest feature. Searching towards the origin allows the algorithm to converge quickly. Let’s look an example. We’ll start with an arbitrary vertex then add or remove vertices every iteration until we surround the origin or find it’s impossible.</p>



<figure></figure>



<p>We can see that there are two cases that we need to deal with: a line and triangle. We need one more case in the form of a tetrahedron to select a volume if we want 3D collision detection.</p>



<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 214.72 64.21"><defs></defs><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><circle cx="3" cy="40.8" r="2.5"></circle><circle cx="52.28" cy="59.57" r="2.5"></circle><circle cx="60.28" cy="18.74" r="2.5"></circle><line x1="60.28" y1="18.74" x2="52.28" y2="59.57"></line><circle cx="104.18" cy="61.21" r="2.5"></circle><circle cx="112.18" cy="20.38" r="2.5"></circle><line x1="112.18" y1="20.38" x2="104.18" y2="61.21"></line><circle cx="138.39" cy="34.85" r="2.5"></circle><line x1="112.18" y1="20.38" x2="138.39" y2="34.85"></line><line x1="104.18" y1="61.21" x2="138.39" y2="34.85"></line><circle cx="177.51" cy="61.05" r="2.5"></circle><circle cx="185.51" cy="20.21" r="2.5"></circle><line x1="185.51" y1="20.21" x2="177.51" y2="61.05"></line><circle cx="211.72" cy="34.69" r="2.5"></circle><line x1="185.51" y1="20.21" x2="211.72" y2="34.69"></line><line x1="177.51" y1="61.05" x2="211.72" y2="34.69"></line><circle cx="198" cy="37.35" r="1.5"></circle><circle cx="198" cy="37.35" r="1.5"></circle><line x1="185.51" y1="20.21" x2="198" y2="37.35"></line><line x1="177.51" y1="61.05" x2="198" y2="37.35"></line><line x1="211.72" y1="34.69" x2="198" y2="37.35"></line><line x1="39.53" y1="40.77" x2="19.17" y2="40.63"></line><polygon points="38.67 37.77 43.83 40.8 38.63 43.75 38.67 37.77"></polygon><line x1="90.26" y1="48.68" x2="69.89" y2="48.55"></line><polygon points="89.4 45.69 94.56 48.71 89.36 51.67 89.4 45.69"></polygon><line x1="168.7" y1="41.21" x2="148.33" y2="41.08"></line><polygon points="167.84 38.22 173 41.24 167.8 44.2 167.84 38.22"></polygon><line x1="74.25" y1="41" x2="94.61" y2="41.14"></line><polygon points="75.11 44 69.94 40.97 75.15 38.02 75.11 44"></polygon><line x1="152.64" y1="49.11" x2="173" y2="49.24"></line><polygon points="153.5 52.1 148.34 49.08 153.54 46.12 153.5 52.1"></polygon><path d="M48,29l-1.57-2c-.81-1.17-4.41-6.62-3-13.26C45.14,5.91,53.06.28,61.14.69c9.75.49,16.88,9.63,16.66,18a16.35,16.35,0,0,1-4.74,10.7C67.73,34.72,58.87,36,50.64,32.35"></path><polygon points="49.75 26.44 50.64 32.35 45.07 30.16 49.75 26.44"></polygon><path d="M99.51,31.07a12.3,12.3,0,0,1-1.62-1.55c-4.36-5.07-2.62-12.11-2.33-13.25,2.43-9.8,13.58-13.84,15-14.33,13.1-4.54,30.1,2,36.91,15,.77,1.46,6.43,12.26,1.95,19-5.4,8.06-24.15,8.17-46.11-2.8"></path><polygon points="100.3 27.93 103.31 33.1 97.32 33.12 100.3 27.93"></polygon></g></g></svg>



<p>To represent the simplex, let’s make a wrapper struct around an <em>std::array</em>. This will allow us to keep track of the number of points, while keeping the memory on the stack for quick access.</p>



<pre><span>struct</span> <span>Simplex</span> <span>{</span>
	<span>private</span><span>:</span>
		<span>std</span><span>::</span><span>array</span><span>&lt;</span><span>vector3</span><span>,</span> <span>4</span><span>&gt;</span> <span>m_points</span><span>;</span>
		<span>unsigned</span> <span>m_size</span><span>;</span>

	<span>public</span><span>:</span>
		<span>Simplex</span><span>()</span>
			<span>:</span> <span>m_points</span><span>({</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span> <span>})</span>
			<span>,</span> <span>m_size</span><span>(</span><span>0</span><span>)</span>
		<span>{}</span>

		<span>Simplex</span><span>&amp;</span> <span>operator</span><span>=</span><span>(</span><span>std</span><span>::</span><span>initializer_list</span><span>&lt;</span><span>vector3</span><span>&gt;</span> <span>list</span><span>)</span> <span>{</span>
			<span>for</span> <span>(</span><span>auto</span> <span>v</span> <span>=</span> <span>list</span><span>.</span><span>begin</span><span>();</span> <span>v</span> <span>!=</span> <span>list</span><span>.</span><span>end</span><span>();</span> <span>v</span><span>++)</span> <span>{</span>
				<span>m_points</span><span>[</span><span>std</span><span>::</span><span>distance</span><span>(</span><span>list</span><span>.</span><span>begin</span><span>(),</span> <span>v</span><span>)</span><span>]</span> <span>=</span> <span>*</span><span>v</span><span>;</span>
			<span>}</span>
			<span>m_size</span> <span>=</span> <span>list</span><span>.</span><span>size</span><span>();</span>

			<span>return</span> <span>*</span><span>this</span><span>;</span>
		<span>}</span>

		<span>void</span> <span>push_front</span><span>(</span><span>vector3</span> <span>point</span><span>)</span> <span>{</span>
			<span>m_points</span> <span>=</span> <span>{</span> <span>point</span><span>,</span> <span>m_points</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>m_points</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>m_points</span><span>[</span><span>2</span><span>]</span> <span>};</span>
			<span>m_size</span> <span>=</span> <span>std</span><span>::</span><span>min</span><span>(</span><span>m_size</span> <span>+</span> <span>1</span><span>,</span> <span>4u</span><span>);</span>
		<span>}</span>

		<span>vector3</span><span>&amp;</span> <span>operator</span><span>[]</span><span>(</span><span>unsigned</span> <span>i</span><span>)</span> <span>{</span> <span>return</span> <span>m_points</span><span>[</span><span>i</span><span>]</span><span>;</span> <span>}</span>
		<span>unsigned</span> <span>size</span><span>()</span> <span>const</span> <span>{</span> <span>return</span> <span>m_size</span><span>;</span> <span>}</span>

		<span>auto</span> <span>begin</span><span>()</span> <span>const</span> <span>{</span> <span>return</span> <span>m_points</span><span>.</span><span>begin</span><span>();</span> <span>}</span>
		<span>auto</span> <span>end</span><span>()</span>   <span>const</span> <span>{</span> <span>return</span> <span>m_points</span><span>.</span><span>end</span><span>()</span> <span>-</span> <span>(</span><span>4</span> <span>-</span> <span>m_size</span><span>);</span> <span>}</span>
	<span>};</span>
</pre>



<p>We need at least one vertex to start, so we’ll manually add it. The search direction for the first vertex doesn’t matter, but you may get less iterations with a smarter choice. I’m going to use unit x (1, 0, 0) for no particular reason.</p>



<pre><span>bool</span> <span>GJK</span><span>(</span>
	<span>const</span> <span>Collider</span><span>*</span> <span>colliderA</span><span>,</span>
	<span>const</span> <span>Collider</span><span>*</span> <span>colliderB</span><span>)</span>
<span>{</span>
	<span>// Get initial support point in any direction</span>
	<span>vector3</span> <span>support</span> <span>=</span> <span>Support</span><span>(</span><span>colliderA</span><span>,</span> <span>colliderB</span><span>,</span> <span>vector3</span><span>::</span><span>unit_x</span><span>);</span></pre>



<p>Now that we have one point, we can add it to the simplex and set the search direction towards the origin.</p>



<pre>	<span>// Simplex is an array of points, max count is 4</span>
	<span>Simplex</span> <span>points</span><span>;</span>
	<span>points</span><span>.</span><span>push_front</span><span>(</span><span>support</span><span>);</span>

	<span>// New direction is towards the origin</span>
	<span>vector3</span> <span>direction</span> <span>=</span> <span>-</span><span>support</span><span>;</span></pre>



<p>In a loop, we’ll add another point. The exit condition is that this new point is not in front of the search direction. This would exit if the direction finds a vertex that was already the furthest one along it. </p>



<pre>	<span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
		<span>support</span> <span>=</span> <span>Support</span><span>(</span><span>colliderA</span><span>,</span> <span>colliderB</span><span>,</span> <span>direction</span><span>);</span>
 
		<span>if</span> <span>(</span><span>support</span><span>.</span><span>dot</span><span>(</span><span>direction</span><span>)</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
			<span>return</span> <span>false</span><span>;</span> <span>// no collision</span>
		<span>}</span>

		<span>points</span><span>.</span><span>push_front</span><span>(</span><span>support</span><span>);</span></pre>



<p>Now that we have a line, we’ll feed it into a function that updates the simplex and search direction. It’ll return <em>true</em> or <em>false</em> to signify a collision.</p>



<pre>		<span>if</span> <span>(</span><span>NextSimplex</span><span>(</span><span>points</span><span>,</span> <span>direction</span><span>))</span> <span>{</span>
			<span>return</span> <span>true</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span></pre>



<p>That’s all for the main loop. It’s dead simple in the world of algorithms, but the real work is in the <em>NextSimplex</em> function. We need a series of different checks for each shape of simplex to see what the new simplex should be and what direction we’ll search in next.</p>



<p>The <em>NextSimplex</em> function will act as a dispatcher to three other functions, one for each shape.</p>



<pre><span>bool</span> <span>NextSimplex</span><span>(</span>
	<span>Simplex</span><span>&amp;</span> <span>points</span><span>,</span>
	<span>vector3</span><span>&amp;</span> <span>direction</span><span>)</span>
<span>{</span>
	<span>switch</span> <span>(</span><span>points</span><span>.</span><span>size</span><span>())</span> <span>{</span>
		<span>case</span> <span>2</span><span>:</span> <span>return</span> <span>Line</span>       <span>(</span><span>points</span><span>,</span> <span>direction</span><span>);</span>
		<span>case</span> <span>3</span><span>:</span> <span>return</span> <span>Triangle</span>   <span>(</span><span>points</span><span>,</span> <span>direction</span><span>);</span>
		<span>case</span> <span>4</span><span>:</span> <span>return</span> <span>Tetrahedron</span><span>(</span><span>points</span><span>,</span> <span>direction</span><span>);</span>
	<span>}</span>
 
	<span>// never should be here</span>
	<span>return</span> <span>false</span><span>;</span>
<span>}</span></pre>



<p>We can add one more helper function to help lessen the headache from these next functions.</p>



<pre><span>bool</span> <span>SameDirection</span><span>(</span>
	<span>const</span> <span>vector3</span><span>&amp;</span> <span>direction</span><span>,</span>
	<span>const</span> <span>vector3</span><span>&amp;</span> <span>ao</span><span>)</span>
<span>{</span>
	<span>return</span> <span>direction</span><span>.</span><span>dot</span><span>(</span><span>ao</span><span>)</span> <span>&gt;</span> <span>0</span><span>;</span>
<span>}</span></pre>



<p>We’ll start with the line case. There are three possible regions that the origin could be in, but realistically only two. We started with point B, and searched in the direction of A, which means that the origin cannot be in the red region. This leaves us with one check between the vector AB and AO. If AO is inside the green region, we move on. If AO is in the blue region, we’ll come back to the line case, but B will be replaced.</p>



<pre><span>bool</span> <span>Line</span><span>(</span>
	<span>Simplex</span><span>&amp;</span> <span>points</span><span>,</span>
	<span>vector3</span><span>&amp;</span> <span>direction</span><span>)</span>
<span>{</span>
	<span>vector3</span> <span>a</span> <span>=</span> <span>points</span><span>[</span><span>0</span><span>]</span><span>;</span>
	<span>vector3</span> <span>b</span> <span>=</span> <span>points</span><span>[</span><span>1</span><span>]</span><span>;</span>

	<span>vector3</span> <span>ab</span> <span>=</span> <span>b</span> <span>-</span> <span>a</span><span>;</span>
	<span>vector3</span> <span>ao</span> <span>=</span>   <span>-</span> <span>a</span><span>;</span>
 
	<span>if</span> <span>(</span><span>SameDirection</span><span>(</span><span>ab</span><span>,</span> <span>ao</span><span>))</span> <span>{</span>
		<span>direction</span> <span>=</span> <span>ab</span><span>.</span><span>cross</span><span>(</span><span>ao</span><span>).</span><span>cross</span><span>(</span><span>ab</span><span>);</span>
	<span>}</span>

	<span>else</span> <span>{</span>
		<span>points</span> <span>=</span> <span>{</span> <span>a</span> <span>};</span>
		<span>direction</span> <span>=</span> <span>ao</span><span>;</span>
	<span>}</span>

	<span>return</span> <span>false</span><span>;</span>
<span>}</span></pre>



<div><figure><img src="https://blog.winter.dev/wp-content/uploads/2020/08/line.jpg" alt="" width="459" height="344" srcset="https://blog.winter.dev/wp-content/uploads/2020/08/line.jpg 841w, https://blog.winter.dev/wp-content/uploads/2020/08/line-300x225.jpg 300w, https://blog.winter.dev/wp-content/uploads/2020/08/line-768x577.jpg 768w" sizes="(max-width: 459px) 100vw, 459px"/></figure></div>



<p>In this case, AO is in the same direction as AB, so we know it’s in the green region. We’ll set the search direction pointing towards the origin and move on. In 2D, you would not need to use cross products, but in 3D the origin could be anywhere in a cylinder around the line, so we need them to get the correct direction.</p>



<p>The triangle case has seven regions, but again we can cull out some impossibilities. Yellow, red, and purple cannot have the origin because the new point we added was A, meaning that the origin cannot be in the direction of the BC face. That leaves us with four regions we need to check.</p>



<p>If the origin is outside the triangle on the AC face, we’ll check if it’s also in the direction of AC. If it is, then we’ll remove B from the simplex and move on, if not, we’ll do a line case between AB. If the origin was not in the direction of the AC face, we’ll check the AB face. If it’s there, we’ll do the same line case between AB. Finally, if both checks fail, we know it must be inside the triangle. In 2D we would be done and could return <em>true</em>, but in 3D we need to check if the origin is above or below the triangle and move on.</p>



<pre><span>bool</span> <span>Triangle</span><span>(</span>
	<span>Simplex</span><span>&amp;</span> <span>points</span><span>,</span>
	<span>vector3</span><span>&amp;</span> <span>direction</span><span>)</span>
<span>{</span>
	<span>vector3</span> <span>a</span> <span>=</span> <span>points</span><span>[</span><span>0</span><span>]</span><span>;</span>
	<span>vector3</span> <span>b</span> <span>=</span> <span>points</span><span>[</span><span>1</span><span>]</span><span>;</span>
	<span>vector3</span> <span>c</span> <span>=</span> <span>points</span><span>[</span><span>2</span><span>]</span><span>;</span>

	<span>vector3</span> <span>ab</span> <span>=</span> <span>b</span> <span>-</span> <span>a</span><span>;</span>
	<span>vector3</span> <span>ac</span> <span>=</span> <span>c</span> <span>-</span> <span>a</span><span>;</span>
	<span>vector3</span> <span>ao</span> <span>=</span>   <span>-</span> <span>a</span><span>;</span>
 
	<span>vector3</span> <span>abc</span> <span>=</span> <span>ab</span><span>.</span><span>cross</span><span>(</span><span>ac</span><span>);</span>
 
	<span>if</span> <span>(</span><span>SameDirection</span><span>(</span><span>abc</span><span>.</span><span>cross</span><span>(</span><span>ac</span><span>),</span> <span>ao</span><span>))</span> <span>{</span>
		<span>if</span> <span>(</span><span>SameDirection</span><span>(</span><span>ac</span><span>,</span> <span>ao</span><span>))</span> <span>{</span>
			<span>points</span> <span>=</span> <span>{</span> <span>a</span><span>,</span> <span>c</span> <span>};</span>
			<span>direction</span> <span>=</span> <span>ac</span><span>.</span><span>cross</span><span>(</span><span>ao</span><span>).</span><span>cross</span><span>(</span><span>ac</span><span>);</span>
		<span>}</span>

		<span>else</span> <span>{</span>
			<span>return</span> <span>Line</span><span>(</span><span>points</span> <span>=</span> <span>{</span> <span>a</span><span>,</span> <span>b</span> <span>},</span> <span>direction</span><span>);</span>
		<span>}</span>
	<span>}</span>
 
	<span>else</span> <span>{</span>
		<span>if</span> <span>(</span><span>SameDirection</span><span>(</span><span>ab</span><span>.</span><span>cross</span><span>(</span><span>abc</span><span>),</span> <span>ao</span><span>))</span> <span>{</span>
			<span>return</span> <span>Line</span><span>(</span><span>points</span> <span>=</span> <span>{</span> <span>a</span><span>,</span> <span>b</span> <span>},</span> <span>direction</span><span>);</span>
		<span>}</span>

		<span>else</span> <span>{</span>
			<span>if</span> <span>(</span><span>SameDirection</span><span>(</span><span>abc</span><span>,</span> <span>ao</span><span>))</span> <span>{</span>
				<span>direction</span> <span>=</span> <span>abc</span><span>;</span>
			<span>}</span>

			<span>else</span> <span>{</span>
				<span>points</span> <span>=</span> <span>{</span> <span>a</span><span>,</span> <span>c</span><span>,</span> <span>b</span> <span>};</span>
				<span>direction</span> <span>=</span> <span>-</span><span>abc</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>return</span> <span>false</span><span>;</span>
<span>}</span></pre>



<div><figure><img src="https://blog.winter.dev/wp-content/uploads/2020/08/triangle.jpg" alt="" width="493" height="405" srcset="https://blog.winter.dev/wp-content/uploads/2020/08/triangle.jpg 706w, https://blog.winter.dev/wp-content/uploads/2020/08/triangle-300x247.jpg 300w" sizes="(max-width: 493px) 100vw, 493px"/></figure></div>



<p>The tetrahedron case is the most complex, but almost entirely made up of triangle cases. We don’t need to test for the origin below the tetrahedron for the same reason as before. We only need to determine which face, if any, the origin is in the direction of. If there is one, we’ll go back to the triangle case with that face as the simplex, but if not, we know it must be inside the tetrahedron and we’ll return <em>true</em>.</p>



<pre><span>bool</span> <span>Tetrahedron</span><span>(</span>
	<span>Simplex</span><span>&amp;</span> <span>points</span><span>,</span>
	<span>vector3</span><span>&amp;</span> <span>direction</span><span>)</span>
<span>{</span>
	<span>vector3</span> <span>a</span> <span>=</span> <span>points</span><span>[</span><span>0</span><span>]</span><span>;</span>
	<span>vector3</span> <span>b</span> <span>=</span> <span>points</span><span>[</span><span>1</span><span>]</span><span>;</span>
	<span>vector3</span> <span>c</span> <span>=</span> <span>points</span><span>[</span><span>2</span><span>]</span><span>;</span>
	<span>vector3</span> <span>d</span> <span>=</span> <span>points</span><span>[</span><span>3</span><span>]</span><span>;</span>

	<span>vector3</span> <span>ab</span> <span>=</span> <span>b</span> <span>-</span> <span>a</span><span>;</span>
	<span>vector3</span> <span>ac</span> <span>=</span> <span>c</span> <span>-</span> <span>a</span><span>;</span>
	<span>vector3</span> <span>ad</span> <span>=</span> <span>d</span> <span>-</span> <span>a</span><span>;</span>
	<span>vector3</span> <span>ao</span> <span>=</span>   <span>-</span> <span>a</span><span>;</span>
 
	<span>vector3</span> <span>abc</span> <span>=</span> <span>ab</span><span>.</span><span>cross</span><span>(</span><span>ac</span><span>);</span>
	<span>vector3</span> <span>acd</span> <span>=</span> <span>ac</span><span>.</span><span>cross</span><span>(</span><span>ad</span><span>);</span>
	<span>vector3</span> <span>adb</span> <span>=</span> <span>ad</span><span>.</span><span>cross</span><span>(</span><span>ab</span><span>);</span>
 
	<span>if</span> <span>(</span><span>SameDirection</span><span>(</span><span>abc</span><span>,</span> <span>ao</span><span>))</span> <span>{</span>
		<span>return</span> <span>Triangle</span><span>(</span><span>points</span> <span>=</span> <span>{</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span> <span>},</span> <span>direction</span><span>);</span>
	<span>}</span>
		
	<span>if</span> <span>(</span><span>SameDirection</span><span>(</span><span>acd</span><span>,</span> <span>ao</span><span>))</span> <span>{</span>
		<span>return</span> <span>Triangle</span><span>(</span><span>points</span> <span>=</span> <span>{</span> <span>a</span><span>,</span> <span>c</span><span>,</span> <span>d</span> <span>},</span> <span>direction</span><span>);</span>
	<span>}</span>
 
	<span>if</span> <span>(</span><span>SameDirection</span><span>(</span><span>adb</span><span>,</span> <span>ao</span><span>))</span> <span>{</span>
		<span>return</span> <span>Triangle</span><span>(</span><span>points</span> <span>=</span> <span>{</span> <span>a</span><span>,</span> <span>d</span><span>,</span> <span>b</span> <span>},</span> <span>direction</span><span>);</span>
	<span>}</span>
 
	<span>return</span> <span>true</span><span>;</span>
<span>}</span></pre>



<div><figure><img src="https://blog.winter.dev/wp-content/uploads/2020/08/tetrahedron-1-906x1024.jpg" alt="" width="442" height="499" srcset="https://blog.winter.dev/wp-content/uploads/2020/08/tetrahedron-1-906x1024.jpg 906w, https://blog.winter.dev/wp-content/uploads/2020/08/tetrahedron-1-266x300.jpg 266w, https://blog.winter.dev/wp-content/uploads/2020/08/tetrahedron-1-768x868.jpg 768w, https://blog.winter.dev/wp-content/uploads/2020/08/tetrahedron-1.jpg 962w" sizes="(max-width: 442px) 100vw, 442px"/></figure></div>



<p>With that final case, we have completed the GJK algorithm. As you can see it is not that complex looking at it from a geometric point of view. This algorithm only gives you a yes/no answer about a collision, so you cannot respond to it. In the next article I will cover an algorithm that uses the simplex and similar principles to find the collision normal then maybe get into rotational physics. Thanks for reading!</p>



<p>Here is a demo that will let you play around with the algorithm and let you inspect each iteration, here&#39;s the <a href="https://winter.dev/lilapps/gjk/index.html">full version</a> if you want a better look…</p>








</div></div>
  </body>
</html>
