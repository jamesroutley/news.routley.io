<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mailbox.my/blog/posts/why-enterprise-software-is-bloated/">Original</a>
    <h1>Why enterprise software is bloated</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p><img src="https://www.mailbox.my/blog/img/software-bloat.jpg" alt="Software Bloat"/></p>
<h2 id="background">Background</h2>
<p>People are often baffled why enterprise software is slow, uses lots of memory, and is generally a pain to work with. Before starting  <a href="https://www.mailbox.my">mailbox.my</a>, I did work at a large enterprise software company, so I hope to offer some insights with this post. Most of this actually applies to software in general.</p>
<h2 id="what-is-software-bloat">What is Software Bloat?</h2>
<p>Bloated software uses much more resources than necessary to do its job, the most important resources being CPU time, memory, I/O, and disk space. Furthermore, software with lots of features can also be called bloated since it is harder to learn and use, and naturally requires more resources than software with only the desired features would.</p>
<h2 id="why-is-software-bloat-an-issue">Why is Software Bloat an Issue?</h2>
<p>Bloated software often is the reason you become frustrated with your computer. It slows down your daily work, drains the battery of your laptop, or even forces you to buy a more powerful machine. High CPU usage directly leads to increased energy consumption: Normally the processor in your computer is able <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface#Processor_states">to go to sleep when idle</a>, saving energy. An inefficient algorithm that runs twice as long will consume nearly twice as much power. The same is true for other hardware in your computer. Besides, the obsolescence of hardware caused by resource-hungry software leads to electronic waste.</p>
<h2 id="reasons-for-software-bloat">Reasons for Software Bloat</h2>
<h3 id="organizational-reasons">Organizational Reasons</h3>

<p>Software development in the industry often happens in teams working on distinct functionality. While the developers of one team often share an office, or at least a time zone, each team may reside on a different continent. Therefore communication between teams is much harder then within the team. Software organizations are also mostly top-down: Each team has a manager that controls what the team is working on. All these traits hinder software reuse or sharing of code. In many cases it is easier to develop functionality that could be shared among teams on your own. Delegating it to another team would come with significant communication/planning overhead, and would make your development schedule dependent on that team. So you roll your own. But this way the code base grows more than necessary, and in most cases so do the resource requirements (since more code is written, this also leads to more bugs, although integration bugs when sharing functionality would have to be accounted for).</p>
<h3 id="business-reasons">Business Reasons</h3>
<h4 id="go-to-market">Go to Market</h4>
<p>For most products it is critical to release them quickly in order to capture market share or be seen as an innovator. Often this trumps most other concerns, even features or quality. This can lead to inefficient software since developers and architects will take all kinds of shortcuts, like gluing together existing systems, using simple algorithms or suboptimal representations of data in memory, and not optimizing bottlenecks.</p>
<p>An example of this: Many applications nowadays have to be multi-platform - they have to run on desktop operating systems like macOS and Windows, as an app on iOS/iPadOS and Android, and on the Internet. Only large companies can afford to have one dedicated team per platform. So the popular alternative are frameworks targeting multiple platforms with one code base, like <a href="https://en.wikipedia.org/wiki/Electron_(software_framework)">Electron</a> (used by <a href="https://www.git-tower.com/blog/developing-for-the-desktop-vscode/">VS Code</a>) or <a href="https://en.wikipedia.org/wiki/Progressive_web_application">Progressive Web Apps</a> (used by <a href="https://medium.com/dev-channel/a-pinterest-progressive-web-app-performance-case-study-3bd6ed2e6154">Pinterest</a> and <a href="https://blog.twitter.com/engineering/en_us/topics/open-source/2017/how-we-built-twitter-lite">Twitter</a>). These frameworks are heavy-weight and need a full browser and JavaScript engine to run, which already take up a considerable amount of resources.</p>
<h4 id="acquisitions">Acquisitions</h4>
<p>As businesses get acquired, software gets integrated and bundled. Usually only the minimal amount of work will be done to get an integration to work, skipping the refactoring or code changes to internal data structures or algorithms, so the “new” product will be the sum of its parts also from a resource consumption point of view. Apart from the refactoring costs themselves and go-to-market time pressure, there may be users of the individual pieces of software that would be affected negatively by the refactoring. But with a glued-together system, everyone suffers from high resource consumption due to things like data format conversion, duplication or reprocessing of data, and higher latency.</p>
<h4 id="maintenance-contracts">Maintenance Contracts</h4>
<p>Often there are customers still depending on old functionality that could otherwise be removed. That dependence is often set in stone in the form of contracts, which in most companies is a definite no-no for any changes.</p>
<h4 id="diverse-customer-base">Diverse Customer Base</h4>
<p>A product serving a lot of customers, or a market where only a subset of users need each of the features, will often accrue many features over its lifetime. These have an effect at least on disk space, which is not that critical, but also lead to overhead when working with the software. As the code base gets large, bugs will creep in and become harder to fix. Developers become more reluctant to do refactoring since the cost/benefit gets worse, or the cost is so prohibitive that management will not allot time. Features will also require more general data structures and abstractions, increasing resource consumption.</p>
<h4 id="partner-integrations">Partner Integrations</h4>
<p>Integrating your software with other companies&#39; software can be a great thing: You gain more features, and both sides will probably benefit by gaining users and sales. Unfortunately this also leads to more code, more abstractions, data conversions and so on, furthering bloat. From a technical point of view this is comparable to “Acquisitions” above.</p>
<h3 id="software-development-reasons">Software Development Reasons</h3>
<h4 id="higher-level-languages">Higher-Level Languages</h4>
<p>Programming languages and frameworks for a project are mostly chosen based on these factors:</p>
<ul>
<li>Availability of engineers</li>
<li>Possible development velocity</li>
<li>Ease of integration with other systems</li>
<li>Ease of writing extensions</li>
</ul>
<p>For many kinds of software, the runtime efficiency of the code produced seldom factors into that decision. Languages which score high on the above criteria are:</p>
<ul>
<li><strong>JavaScript/Web Stack</strong> Being the only language that allowed portable client-side coding on the Internet has made JavaScript extremely popular, even taking over the server. Although it is an interpreted language, extensive optimizations and <a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/">research on JITs</a> have made it acceptably fast. But memory requirements are <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/node-gpp.html">still quite high</a>.</li>
<li><strong>Python</strong> It’s a great language to Quickly Get Things Done, but is <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/gpp-python3.html">quite slow and relatively memory hungry</a>.</li>
</ul>
<p>In contrast, languages like Rust or C++ often produce pretty efficient software, but at a markedly slower development velocity, and fewer engineers available that can produce quality software.</p>
<p>Of course the language is just one factor, and it is possible to write bloated software in any language.</p>
<h4 id="complexity-and-abstractions">Complexity and Abstractions</h4>
<p><a href="https://en.wikipedia.org/wiki/Tony_Hoare">Sir Tony Hoare</a> famously said:</p>
<blockquote>
<p>“Premature optimization is the root of all evil.”</p>
</blockquote>
<p>I prefer considering <em>complexity</em> as the root of all evil: Premature optimization introduces more complexity, so that is covered. But complexity also touches other issues:</p>
<ul>
<li>All the technical standards the software has to adhere to (<a href="https://en.wikipedia.org/wiki/Comparison_of_web_browsers#HTML5_support">web browsers being the prime example</a>)</li>
<li>The amount of features available</li>
<li>Over-engineered software built to flexibly support possible future enhancements</li>
</ul>
<p>Complexity often, but not always, leads to software bloat. For example, adding a second algorithm so that a special case can run an order of magnitude faster will increase complexity and disk footprint, but lower CPU consumption and the memory integral, and likely be a net bloat reduction..</p>
<h4 id="no-time-for-better-code">No Time for Better Code</h4>
<p>In a lot of companies, feature development trumps optimizing, refactoring or removal of legacy code. In many cases this makes business sense, as customers do not care as much about hardware requirements as they do about features. However, with many workloads shifting to the cloud, this does not apply as much anymore, since the cloud provider offering a database solution bears the costs of operating it, having a vested interest in running non-bloated software.</p>
<h4 id="logging">Logging</h4>
<p>Enterprise software in particular needs to be easily supportable. It might run on a customers&#39; locked-down server and you can only get log files for analyzing bugs. As a result, such software tends to have lots of logging code that can be activated to gain insight into the system. In the best case, the bloat will only affect the size of the binary and not memory consumption and runtime performance.</p>
<h4 id="error-handling">Error Handling</h4>
<p>Enterprise software must be much more robust in the face of errors. Imagine a database server that keeps running for months and must not crash or leak memory: It must be able to handle all kinds of out-of-memory situations or malfunctions properly. Such resilient software can be extremely bloated due to the amount of code needed to handle all corner cases. Similar to logging, good coding practices can reduce the impact this has on runtime and memory consumption.</p>
<h4 id="accessibility-and-legal-requirements">Accessibility and Legal Requirements</h4>
<p>Enterprise software has to fulfill all kinds of legal requirements, the most important with regards to this discussion being <a href="https://en.wikipedia.org/wiki/Web_accessibility#Web_accessibility_legislation">accessibility</a>. This is a must-have feature and leads to more code, and usually higher resource consumption. Open-source projects often avoid dealing with these requirements.</p>
<h2 id="what-now">What Now?</h2>
<p>Don’t like using bloated software? Luckily, there are often <a href="https://alternativeto.net/">great alternatives available</a>.</p>
<p>Don’t like developing bloated software? There are certain pockets in the industry that do not either:</p>
<ul>
<li><strong>Cloud Service Backends</strong> The profit of the service provider is directly tied to the footprint of the service, so there is a vested interest to keep it low. Since many people worldwide are using a given service, even small optimizations can increase profits considerably. In addition, in a cloud scenario it is easy to profile and analyze workloads, making it straightforward to pick the most rewarding optimizations.</li>
<li><strong>Mobile Devices</strong> For these, battery life is paramount, so CPU usage needs to be minimized.</li>
<li><strong>Embedded Systems</strong> These are either so small that the hardware can’t be very powerful, or they are manufactured at such a large volume that it makes economic sense to build optimized software, and less powerful hardware, increasing profits.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>In the end, many causes for software bloat boil down to business reasons. In a perfect world where software development is free and does not need any time, everyone would ship optimal software. Since that is obviously not the case, companies have to make trade-offs. Actually it is very hard to make the correct trade-off, and one that is correct in the short term can be detrimental in the long run. For example, quickly shipping bloated software may allow to capture relevant market share, but lead to lots of quality issues as customers start using the product. However, shipping late may have impeded any adoption. So most companies will prioritize shipping early, and shipping new features, over fixing bloat. Open-source projects by enthusiasts who are not bound by such constraints often provide great alternatives to enterprise offerings.</p>

  </div></div>
  </body>
</html>
