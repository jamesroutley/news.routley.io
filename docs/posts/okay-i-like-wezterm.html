<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexplescan.com/posts/2024/08/10/wezterm/">Original</a>
    <h1>Okay, I Like WezTerm</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
      <div>
        <article role="article">
  

  <div><p>A while back <a href="https://blog.lambo.land/">my friend</a> recommended that I try <a href="https://wezfurlong.org/wezterm/">WezTerm</a>. I’d been an iTerm 2 stalwart for the better part of a decade, but not to be <em>too</em> narrow-minded I conceded, started it up, and saw this:</p>

<picture><source srcset="/generated/assets/posts/wezterm/01_default_look-720-7c9bad525.webp 1.0x, /generated/assets/posts/wezterm/01_default_look-1440-7c9bad525.webp 2.0x, /generated/assets/posts/wezterm/01_default_look-1520-7c9bad525.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/01_default_look-720-7c9bad525.jpg 1.0x, /generated/assets/posts/wezterm/01_default_look-1440-7c9bad525.jpg 2.0x, /generated/assets/posts/wezterm/01_default_look-1520-7c9bad525.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/01_default_look-800-dd3151c15.png" alt="screenshot of WezTerm&#39;s default look"/></picture>

<p>Does the job, sure, but doesn’t feel quite right. Okay then, experiment over. Back to iTerm…</p>

<p>Fast forward a couple of months and I got the itch to try a new terminal again. I wanted to use one whose config was entirely text based so I could pop it in to my dotfiles and share it across my work and personal machines. A few terminals already do this, but whispers of WezTerm’s powerful API and Lua config got me particularly interested.</p>

<p>I tried it again with a bit more patience and I’m glad I did. My terminal is prettier than it’s ever been, more functional, and I can finally justify my mechanical keyboard purchase with all the keybindings I’ve configured.</p>

<p>This post is an introduction to configuring WezTerm based on the setup that I eventually landed on. I’d consider it relatively low-frills. Most of what I talk about here can already be found in WezTerm’s <a href="https://wezfurlong.org/wezterm/config/lua/general.html">docs</a>, but as they’ve got a large surface area, I’m hoping this post will be a useful jumping off point for WezTerm beginners.</p>

<p>We <em>won’t</em> be looking at some of WezTerm’s key features, like custom hyperlinks highlighting rules, searchable scrollback, quick copy mode, and image support (you can find <a href="https://wezfurlong.org/wezterm/features.html">more details here</a>).</p>

<p>The feature I find most exciting about WezTerm is the flexibility of its Lua config, so we’ll be focusing on that. This includes configuring appearance, keybindings, multiplexing, workspace navigation, status bar setup, and dynamic theming. By the end of it all, we’ll have a terminal that looks like this:</p>

<picture><source srcset="/generated/assets/posts/wezterm/02_pretty_look-720-7c6c65470.webp 1.0x, /generated/assets/posts/wezterm/02_pretty_look-1440-7c6c65470.webp 2.0x, /generated/assets/posts/wezterm/02_pretty_look-1518-7c6c65470.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/02_pretty_look-720-7c6c65470.jpg 1.0x, /generated/assets/posts/wezterm/02_pretty_look-1440-7c6c65470.jpg 2.0x, /generated/assets/posts/wezterm/02_pretty_look-1518-7c6c65470.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/02_pretty_look-800-df2e5e6df.png" alt="screenshot of the WezTerm look we&#39;ll end up with at the end of this post"/></picture>

<p>Subtly prettier than the default, and with some great features to boot.</p>

<p>I use macOS, so what follows is focused on ergonomics that make WezTerm great there. I haven’t tested my config on other systems, but I’m not doing anything too bespoke so things should be portable (WezTerm works pretty much everywhere).</p>

<p><strong>tl;dr</strong>? Here’s <a href="https://gist.github.com/alexpls/83d7af23426c8928402d6d79e72f9401">a gist</a> containing the config we’ll end up with.</p>

<h2 id="pre-flight-checks">Pre-flight checks</h2>

<p>Start by installing WezTerm. Instructions for this are on <a href="https://wezfurlong.org/wezterm/installation.html">WezTerm’s site</a>. If you’re on macOS and reading this you probably have Homebrew installed, so <code>$ brew install wezterm</code> will do the trick.</p>

<p>Now launch WezTerm, and you’re already winning.</p>

<h3 id="a-note-on-lua">A note on Lua</h3>

<p>My favourite WezTerm feature is its use of Lua for defining config. Unlike terminals where your settings are adjusted via the UI (iTerm 2), your WezTerm config lives in your dotfiles and is portable across all your machines.</p>

<p>And unlike other terminals where your configuration is written using a data serialization format like YAML or TOML (Alacritty, kitty), with Lua you can more easily achieve complex configs by leveraging dynamic scripts.</p>

<p>Granted, Lua is a programming language so it is trickier to learn than YAML or TOML, but it’s still remarkably simple. If you’ve used another dynamic programming language (e.g. Ruby, Python, JavaScript) - you should be able to read the Lua code in this post easily. For achieving more complex configs, I’d recommend diving deeper into the language. Its <a href="https://www.lua.org/start.html">Getting Started guide</a> is a good place to… get started.</p>

<h3 id="config-files-and-the-best-feedback-loop-in-town">Config files, and the best feedback loop in town</h3>

<p>WezTerm supports loading in its config from all the usual places on your system (<a href="https://wezfurlong.org/wezterm/config/files.html#configuration-files">docs</a>). For this guide we’re going to be creating our config in <code>$XDG_CONFIG_HOME/wezterm/wezterm.lua</code>. On most systems (including macOS) this resolves to <code>~/.config/wezterm/wezterm.lua</code>. Using a directory to store our config instead of dumping it in <code>~/.wezterm.lua</code> will let us keep our config logically grouped as we split some of it out into different files.</p>

<p>Create the <code>wezterm.lua</code> file on that path, and add this boilerplate to it:</p>

<div><div><pre><code><span>-- Import the wezterm module</span>
<span>local</span> <span>wezterm</span> <span>=</span> <span>require</span> <span>&#39;wezterm&#39;</span>
<span>-- Creates a config object which we will be adding our config to</span>
<span>local</span> <span>config</span> <span>=</span> <span>wezterm</span><span>.</span><span>config_builder</span><span>()</span>

<span>-- (This is where our config will go)</span>

<span>-- Returns our config to be evaluated. We must always do this at the bottom of this file</span>
<span>return</span> <span>config</span>
</code></pre></div></div>

<p>Save the file and all going well… nothing will happen. Well, at least nothing <em>appeared</em> to happen, but what WezTerm did behind the scenes is quite magical. It watched your config file, and when it changed it auto-reloaded instantly. This feature makes for a wonderfully tight feedback loop where you don’t need to restart your terminal to see the effects of your new config.</p>

<p>We can quickly test this auto-reload by adding some invalid syntax and seeing what happens. Replace the call to <code>wezterm.config_builder()</code> with <code>wezterm.config_builderZ()</code>, save, and you should immediately see a window pop-up with:</p>

<div><div><pre><code>runtime error: [string &#34;/Users/alex/.config/wezterm/wezterm.lua&#34;]:2: attempt
to call a nil value (field &#39;config_builderZ&#39;)
stack traceback:
        [string &#34;/Users/alex/.config/wezterm/wezterm.lua&#34;]:2: in main chunk
</code></pre></div></div>

<p>How’s that for a feedback loop? Fix the error and save the file again.</p>

<p>This time, have your config log something:</p>

<div><div><pre><code><span>wezterm</span><span>.</span><span>log_info</span><span>(</span><span>&#34;hello world! my name is &#34;</span> <span>..</span> <span>wezterm</span><span>.</span><span>hostname</span><span>())</span>
</code></pre></div></div>

<p>Save. Now… where did that log go? Press <code>CTRL + SHIFT + L</code> to bring up the debug overlay (<a href="https://wezfurlong.org/wezterm/troubleshooting.html#debug-overlay">docs</a>) and lo and behold, your beautiful log was waiting for you all along. Not only that but what you’re looking at is a full Lua REPL. Enter <code>1 + 1</code> and you’ll see the result. Enter <code>wezterm.home_dir</code> and you’ll see the result of accessing the <code>home_dir</code> entry on the <code>wezterm</code> module (<a href="https://wezfurlong.org/wezterm/config/lua/wezterm/home_dir.html">docs</a>).</p>

<picture><source srcset="/generated/assets/posts/wezterm/03_debug_overlay-720-5d57e63cc.webp 1.0x, /generated/assets/posts/wezterm/03_debug_overlay-1440-5d57e63cc.webp 2.0x, /generated/assets/posts/wezterm/03_debug_overlay-1520-5d57e63cc.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/03_debug_overlay-720-5d57e63cc.jpg 1.0x, /generated/assets/posts/wezterm/03_debug_overlay-1440-5d57e63cc.jpg 2.0x, /generated/assets/posts/wezterm/03_debug_overlay-1520-5d57e63cc.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/03_debug_overlay-800-31f78c8d4.png" alt="screenshot of the WezTerm&#39;s debug overlay"/></picture>

<p>The combination of hot reloading and the debug overlay makes experimenting with WezTerm configs extremely low friction and low consequence. The feedback loop is so tight now it’s more like a feedback lp.</p>

<h2 id="configuring-appearance">Configuring appearance</h2>

<p>Okay enough gushing - let’s cut to the chase and make this thing prettier. Add a few lines to the config to start customising the look of the terminal. We’ll start with a colour scheme (<a href="https://wezfurlong.org/wezterm/config/appearance.html">docs</a>):</p>

<div><div><pre><code><span>-- Pick a colour scheme. WezTerm ships with more than 1,000!</span>
<span>-- Find them here: https://wezfurlong.org/wezterm/colorschemes/index.html</span>
<span>config</span><span>.</span><span>color_scheme</span> <span>=</span> <span>&#39;Tokyo Night&#39;</span>
</code></pre></div></div>

<p>Save, and you should immediately see it update. Thanks Wez!</p>

<picture><source srcset="/generated/assets/posts/wezterm/04_colour_scheme-720-5ed5e3bf1.webp 1.0x, /generated/assets/posts/wezterm/04_colour_scheme-1440-5ed5e3bf1.webp 2.0x, /generated/assets/posts/wezterm/04_colour_scheme-1520-5ed5e3bf1.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/04_colour_scheme-720-5ed5e3bf1.jpg 1.0x, /generated/assets/posts/wezterm/04_colour_scheme-1440-5ed5e3bf1.jpg 2.0x, /generated/assets/posts/wezterm/04_colour_scheme-1520-5ed5e3bf1.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/04_colour_scheme-800-b30942129.png" alt="screenshot of applying a colour scheme to WezTerm"/></picture>

<p>(if the hot config reload doesn’t work for whatever reason, you can manually reload it by pressing <code>CMD + R</code>).</p>

<h3 id="many-colours-all-at-once">Many colours, all at once</h3>

<p>With over 1,000 colour choices to choose from, it’s tough to decide on your favourite. Why not outsource that work to your computer? Let’s explore the power of WezTerm’s dynamic config by randomly assigning a colour scheme for each new window you open:</p>

<div><div><pre><code><span>-- Creates a lua table containing the name of every color scheme WezTerm</span>
<span>-- ships with.</span>
<span>local</span> <span>scheme_names</span> <span>=</span> <span>{}</span>
<span>for</span> <span>name</span><span>,</span> <span>scheme</span> <span>in</span> <span>pairs</span><span>(</span><span>wezterm</span><span>.</span><span>color</span><span>.</span><span>get_builtin_schemes</span><span>())</span> <span>do</span>
  <span>table.insert</span><span>(</span><span>scheme_names</span><span>,</span> <span>name</span><span>)</span>
<span>end</span>

<span>-- When the config for a window is reloaded (i.e. when you save this file</span>
<span>-- or open a new window)...</span>
<span>wezterm</span><span>.</span><span>on</span><span>(</span><span>&#39;window-config-reloaded&#39;</span><span>,</span> <span>function</span><span>(</span><span>window</span><span>,</span> <span>pane</span><span>)</span>
  <span>-- Don&#39;t proceed if the config has already been overriden, otherwise</span>
  <span>-- we&#39;ll enter an infinite loop of neverending colour scheme changes.</span>
  <span>-- If that sounds like your kinda thing, then remove this line ;) - but</span>
  <span>-- don&#39;t say you haven&#39;t been warned.</span>
  <span>if</span> <span>window</span><span>:</span><span>get_config_overrides</span><span>()</span> <span>then</span> <span>return</span> <span>end</span>
  <span>-- Pick a random colour scheme name.</span>
  <span>local</span> <span>scheme</span> <span>=</span> <span>scheme_names</span><span>[</span><span>math.random</span><span>(</span><span>#</span><span>scheme_names</span><span>)]</span>
  <span>-- Assign it as an override for this window.</span>
  <span>window</span><span>:</span><span>set_config_overrides</span> <span>{</span> <span>color_scheme</span> <span>=</span> <span>scheme</span> <span>}</span>
  <span>-- And log it for good measure</span>
  <span>wezterm</span><span>.</span><span>log_info</span><span>(</span><span>&#34;Your colour scheme is now: &#34;</span> <span>..</span> <span>scheme</span><span>)</span>
<span>end</span><span>)</span>
</code></pre></div></div>

<p>Open up a few windows (<code>CMD + N</code> on macOS) and each one will have a different colour scheme. A cornucopia of terminals, each more surprising than the last. We, my friends, are truly innovating now.</p>

<picture><source srcset="/generated/assets/posts/wezterm/05_cornucopia-720-bfc375d64.webp 1.0x, /generated/assets/posts/wezterm/05_cornucopia-1440-bfc375d64.webp 2.0x, /generated/assets/posts/wezterm/05_cornucopia-1520-bfc375d64.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/05_cornucopia-720-bfc375d64.jpg 1.0x, /generated/assets/posts/wezterm/05_cornucopia-1440-bfc375d64.jpg 2.0x, /generated/assets/posts/wezterm/05_cornucopia-1520-bfc375d64.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/05_cornucopia-800-06950f034.png" alt="screenshot of many WezTerm terminal windows, each with a distinctive colour scheme"/></picture>

<p>But really, that was kind of a dumb idea meant to prove a point. Now that you’ve gotten a taste for dynamic config, you probably wanna remove those lines and stick to a colour scheme you <em>do</em> like.</p>

<p>(You may find that after you remove that code and add your static <code>color_scheme</code> config back in, it doesn’t hot reload. That’s because our script set an <em>override</em> on the config specific to each window. To clear your overrides, you can go to your debug terminal and type <code>window:set_config_overrides({})</code> - or you can just close and reopen your WezTerm window).</p>

<h3 id="respecting-the-systems-appearance">Respecting the system’s appearance</h3>

<p>Light themes, dark themes… why not both? Let’s have the terminal’s colour scheme automatically change when the operating system’s appearance changes. While we’re at it, we’ll learn how to split up WezTerm config into different modules.</p>

<p>Create a new file alongside <code>wezterm.lua</code> and call it <code>appearance.lua</code>. Add this to it:</p>

<div><div><pre><code><span>-- We almost always start by importing the wezterm module</span>
<span>local</span> <span>wezterm</span> <span>=</span> <span>require</span> <span>&#39;wezterm&#39;</span>
<span>-- Define a lua table to hold _our_ module&#39;s functions</span>
<span>local</span> <span>module</span> <span>=</span> <span>{}</span>

<span>-- Returns a bool based on whether the host operating system&#39;s</span>
<span>-- appearance is light or dark.</span>
<span>function</span> <span>module</span><span>.</span><span>is_dark</span><span>()</span>
  <span>-- wezterm.gui is not always available, depending on what</span>
  <span>-- environment wezterm is operating in. Just return true</span>
  <span>-- if it&#39;s not defined.</span>
  <span>if</span> <span>wezterm</span><span>.</span><span>gui</span> <span>then</span>
    <span>-- Some systems report appearance like &#34;Dark High Contrast&#34;</span>
    <span>-- so let&#39;s just look for the string &#34;Dark&#34; and if we find</span>
    <span>-- it assume appearance is dark.</span>
    <span>return</span> <span>wezterm</span><span>.</span><span>gui</span><span>.</span><span>get_appearance</span><span>():</span><span>find</span><span>(</span><span>&#34;Dark&#34;</span><span>)</span>
  <span>end</span>
  <span>return</span> <span>true</span>
<span>end</span>

<span>return</span> <span>module</span>
</code></pre></div></div>

<p>Back in <code>wezterm.lua</code>:</p>

<div><div><pre><code><span>-- Import our new module (put this near the top of your wezterm.lua)</span>
<span>local</span> <span>appearance</span> <span>=</span> <span>require</span> <span>&#39;appearance&#39;</span>

<span>-- Use it!</span>
<span>if</span> <span>appearance</span><span>.</span><span>is_dark</span><span>()</span> <span>then</span>
  <span>config</span><span>.</span><span>color_scheme</span> <span>=</span> <span>&#39;Tokyo Night&#39;</span>
<span>else</span>
  <span>config</span><span>.</span><span>color_scheme</span> <span>=</span> <span>&#39;Tokyo Night Day&#39;</span>
<span>end</span>
</code></pre></div></div>

<p>Toggle your system appearance between dark mode and light mode, and watch your theme change right before your eyes.</p>

<!-- hackily putting this into a p to have the margin to next heading look good. need to review
     stylesheet to fix this properly -->
<p><picture><source srcset="/generated/assets/posts/wezterm/06_light_v_dark-720-807cf36b1.webp 1.0x, /generated/assets/posts/wezterm/06_light_v_dark-1440-807cf36b1.webp 2.0x, /generated/assets/posts/wezterm/06_light_v_dark-1520-807cf36b1.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/06_light_v_dark-720-807cf36b1.jpg 1.0x, /generated/assets/posts/wezterm/06_light_v_dark-1440-807cf36b1.jpg 2.0x, /generated/assets/posts/wezterm/06_light_v_dark-1520-807cf36b1.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/06_light_v_dark-800-1e54dcccb.png" alt="screenshot of WezTerm in light and dark mode"/></picture>
</p>

<h3 id="fonts">Fonts</h3>

<p>Next up let’s look at fonts. WezTerm ships with the lovely JetBrains Mono, and Nerd Font Symbols (<a href="https://wezfurlong.org/wezterm/config/fonts.html">docs</a>) so there’s nothing to complain about there. I do prefer Berkeley Mono at 13 points though, so:</p>

<div><div><pre><code><span>-- Choose your favourite font, make sure it&#39;s installed on your machine</span>
<span>config</span><span>.</span><span>font</span> <span>=</span> <span>wezterm</span><span>.</span><span>font</span><span>({</span> <span>family</span> <span>=</span> <span>&#39;Berkeley Mono&#39;</span> <span>})</span>
<span>-- And a font size that won&#39;t have you squinting</span>
<span>config</span><span>.</span><span>font_size</span> <span>=</span> <span>13</span>
</code></pre></div></div>

<p>There’s good support for ligatures and other fancy font settings if you’re into that (<a href="https://wezfurlong.org/wezterm/config/font-shaping.html">docs</a>), but I’m not so let’s move on.</p>

<h3 id="window-styling">Window styling</h3>

<p>Let’s style our terminal’s window. This controls the chrome that appears around it, and can vary between operating systems. On macOS, I like the below:</p>

<div><div><pre><code><span>-- Slightly transparent and blurred background</span>
<span>config</span><span>.</span><span>window_background_opacity</span> <span>=</span> <span>0</span><span>.</span><span>9</span>
<span>config</span><span>.</span><span>macos_window_background_blur</span> <span>=</span> <span>30</span>
<span>-- Removes the title bar, leaving only the tab bar. Keeps</span>
<span>-- the ability to resize by dragging the window&#39;s edges.</span>
<span>-- On macOS, &#39;RESIZE|INTEGRATED_BUTTONS&#39; also looks nice if</span>
<span>-- you want to keep the window controls visible and integrate</span>
<span>-- them into the tab bar.</span>
<span>config</span><span>.</span><span>window_decorations</span> <span>=</span> <span>&#39;RESIZE&#39;</span>
<span>-- Sets the font for the window frame (tab bar)</span>
<span>config</span><span>.</span><span>window_frame</span> <span>=</span> <span>{</span>
  <span>-- Berkeley Mono for me again, though an idea could be to try a</span>
  <span>-- serif font here instead of monospace for a nicer look?</span>
  <span>font</span> <span>=</span> <span>wezterm</span><span>.</span><span>font</span><span>({</span> <span>family</span> <span>=</span> <span>&#39;Berkeley Mono&#39;</span><span>,</span> <span>weight</span> <span>=</span> <span>&#39;Bold&#39;</span> <span>}),</span>
  <span>font_size</span> <span>=</span> <span>11</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<picture><source srcset="/generated/assets/posts/wezterm/07_window_styling-720-87031f878.webp 1.0x, /generated/assets/posts/wezterm/07_window_styling-1440-87031f878.webp 2.0x, /generated/assets/posts/wezterm/07_window_styling-1520-87031f878.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/07_window_styling-720-87031f878.jpg 1.0x, /generated/assets/posts/wezterm/07_window_styling-1440-87031f878.jpg 2.0x, /generated/assets/posts/wezterm/07_window_styling-1520-87031f878.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/07_window_styling-800-4b12b9e39.png" alt="screenshot of WezTerm after we&#39;ve styled its window"/></picture>

<p>Now, let’s do something a little kitsch. See that empty space to the right of our terminal’s tab bar? Let’s fill it with a powerline looking status bar. We’ll add an <code>update-status</code> callback:</p>

<div><div><pre><code><span>wezterm</span><span>.</span><span>on</span><span>(</span><span>&#39;update-status&#39;</span><span>,</span> <span>function</span><span>(</span><span>window</span><span>)</span>
  <span>-- Grab the utf8 character for the &#34;powerline&#34; left facing</span>
  <span>-- solid arrow.</span>
  <span>local</span> <span>SOLID_LEFT_ARROW</span> <span>=</span> <span>utf8.char</span><span>(</span><span>0xe0b2</span><span>)</span>

  <span>-- Grab the current window&#39;s configuration, and from it the</span>
  <span>-- palette (this is the combination of your chosen colour scheme</span>
  <span>-- including any overrides).</span>
  <span>local</span> <span>color_scheme</span> <span>=</span> <span>window</span><span>:</span><span>effective_config</span><span>().</span><span>resolved_palette</span>
  <span>local</span> <span>bg</span> <span>=</span> <span>color_scheme</span><span>.</span><span>background</span>
  <span>local</span> <span>fg</span> <span>=</span> <span>color_scheme</span><span>.</span><span>foreground</span>

  <span>window</span><span>:</span><span>set_right_status</span><span>(</span><span>wezterm</span><span>.</span><span>format</span><span>({</span>
    <span>-- First, we draw the arrow...</span>
    <span>{</span> <span>Background</span> <span>=</span> <span>{</span> <span>Color</span> <span>=</span> <span>&#39;none&#39;</span> <span>}</span> <span>},</span>
    <span>{</span> <span>Foreground</span> <span>=</span> <span>{</span> <span>Color</span> <span>=</span> <span>bg</span> <span>}</span> <span>},</span>
    <span>{</span> <span>Text</span> <span>=</span> <span>SOLID_LEFT_ARROW</span> <span>},</span>
    <span>-- Then we draw our text</span>
    <span>{</span> <span>Background</span> <span>=</span> <span>{</span> <span>Color</span> <span>=</span> <span>bg</span> <span>}</span> <span>},</span>
    <span>{</span> <span>Foreground</span> <span>=</span> <span>{</span> <span>Color</span> <span>=</span> <span>fg</span> <span>}</span> <span>},</span>
    <span>{</span> <span>Text</span> <span>=</span> <span>&#39; &#39;</span> <span>..</span> <span>wezterm</span><span>.</span><span>hostname</span><span>()</span> <span>..</span> <span>&#39; &#39;</span> <span>},</span>
  <span>}))</span>
<span>end</span><span>)</span>
</code></pre></div></div>

<picture><source srcset="/generated/assets/posts/wezterm/08_status_bar-720-716b8e09a.webp 1.0x, /generated/assets/posts/wezterm/08_status_bar-1440-716b8e09a.webp 2.0x, /generated/assets/posts/wezterm/08_status_bar-1520-716b8e09a.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/08_status_bar-720-716b8e09a.jpg 1.0x, /generated/assets/posts/wezterm/08_status_bar-1440-716b8e09a.jpg 2.0x, /generated/assets/posts/wezterm/08_status_bar-1520-716b8e09a.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/08_status_bar-800-7eee51cfe.png" alt="screenshot of WezTerm with a right status bar showing the system&#39;s hostname"/></picture>

<p>A few interesting things happening here:</p>
<ol>
  <li>We just used WezTerm’s events API with <code>wezterm.on</code>. Events are things that happen to the terminal (e.g. window resize) that we can define callbacks for. The <code>update-status</code> event is emitted periodically when the terminal is ready to have its status updated. WezTerm manages this cleverly to ensure that only one such update can run at any given time, and if your code takes too long to execute, a timeout will be hit and your handler will be abandoned… protecting your terminal from bogging down.</li>
  <li>We’re grabbing the <code>effective_config()</code> of the window to get the “effective” configuration, which is the config with any overrides applied. From this we can get the <code>resolved_palette</code>, which is the currently active colour scheme. To see what this data looks like you can enter the debug overlay (<code>CTRL + SHIFT + L</code>) and execute <code>window:effective_config().resolved_palette</code>.</li>
  <li>We’re using the <code>wezterm.format</code> function (<a href="https://wezfurlong.org/wezterm/config/lua/wezterm/format.html">docs</a>) to style our string with colours. Other ways you could format text include setting font weight, underlining text, and more.</li>
  <li>Finally, the <code>wezterm.hostname()</code> function (<a href="https://wezfurlong.org/wezterm/config/lua/wezterm/hostname.html">docs</a>) gives us the hostname of the machine we’re running on. WezTerm ships with a bunch of useful functions for getting the state of your system, and also… we’re doing stuff in Lua - so you have full access to your file system, are able to make network requests, etc.</li>
</ol>

<p>Altogether this gives us a powerline…ish. It’s a bit sad with only one segment isn’t it? Don’t you worry, we’ll be adding more soon…</p>

<h2 id="keys">Keys</h2>

<p>Here’s the part where we justify our mechanical keyboard purchases. Let’s set up some key assignments. During this section we’ll look at WezTerm’s deep key handling capabilities and ability to take action based on your input.</p>

<p>By default, WezTerm defines some standard key assignments (<a href="https://wezfurlong.org/wezterm/config/default-keys.html">docs</a>). I leave them on because they’re very sensible, but if you wanna <em>really</em> wrest total control of your config, you can turn them off with <code>config.disable_default_key_bindings = true</code>.</p>

<p>Our first key assignment will be a humble start for us macOS users… you might be used to <code>Option + Left Arrow</code> and <code>Option + Right Arrow</code> jumping between words on your terminal. That’s the default in iTerm 2 and Terminal.app, but not in WezTerm. However, we can map it!</p>

<p>We do this by adding a <code>keys</code> table to our <code>config</code>:</p>

<div><div><pre><code><span>-- Table mapping keypresses to actions</span>
<span>config</span><span>.</span><span>keys</span> <span>=</span> <span>{</span>
  <span>-- Sends ESC + b and ESC + f sequence, which is used</span>
  <span>-- for telling your shell to jump back/forward.</span>
  <span>{</span>
    <span>-- When the left arrow is pressed</span>
    <span>key</span> <span>=</span> <span>&#39;LeftArrow&#39;</span><span>,</span>
    <span>-- With the &#34;Option&#34; key modifier held down</span>
    <span>mods</span> <span>=</span> <span>&#39;OPT&#39;</span><span>,</span>
    <span>-- Perform this action, in this case - sending ESC + B</span>
    <span>-- to the terminal</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>SendString</span> <span>&#39;\x1bb&#39;</span><span>,</span>
  <span>},</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;RightArrow&#39;</span><span>,</span>
    <span>mods</span> <span>=</span> <span>&#39;OPT&#39;</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>SendString</span> <span>&#39;\x1bf&#39;</span><span>,</span>
  <span>},</span>
<span>}</span>
</code></pre></div></div>

<p>By now you’ve probably figured out that you’re gonna be spending more time configuring WezTerm than doing actual work. There’s no shame in admitting this reality, so let’s encode it into our config. On macOS, the default shortcut for opening an application’s preferences is <code>CMD + ,</code> - let’s make it so when we press this, our favourite editor opens up the WezTerm config. I’m using neovim, but feel free to substitute with your own:</p>

<div><div><pre><code><span>config</span><span>.</span><span>keys</span> <span>=</span> <span>{</span>
  <span>-- ... add these new entries to your config.keys table</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;,&#39;</span><span>,</span>
    <span>mods</span> <span>=</span> <span>&#39;SUPER&#39;</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>SpawnCommandInNewTab</span> <span>{</span>
      <span>cwd</span> <span>=</span> <span>wezterm</span><span>.</span><span>home_dir</span><span>,</span>
      <span>args</span> <span>=</span> <span>{</span> <span>&#39;nvim&#39;</span><span>,</span> <span>wezterm</span><span>.</span><span>config_file</span> <span>},</span>
    <span>},</span>
  <span>},</span>
<span>}</span>
</code></pre></div></div>

<p>Try that out, but you may see an error along the lines of:</p>

<div><div><pre><code>Unable to spawn nvim because:
No viable candidates found in PATH &#34;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin&#34;
</code></pre></div></div>

<p>If that error showed up, it’s typically because the process that launched WezTerm didn’t include a <code>PATH</code> environment variable that led to your editor’s binary (e.g. on macOS, Finder is usually WezTerm’s parent). We can work around this by specifying the full path to your editor in the <code>SpawnCommandInNewTab</code> properties (<a href="https://wezfurlong.org/wezterm/config/lua/SpawnCommand.html">docs</a>), or by updating the default environment variables WezTerm spawns commands with. I prefer the latter, since it means that any other places in our config where we might spawn new commands will also inherit the same env vars:</p>

<div><div><pre><code><span>config</span><span>.</span><span>set_environment_variables</span> <span>=</span> <span>{</span>
  <span>PATH</span> <span>=</span> <span>&#39;/opt/homebrew/bin:&#39;</span> <span>..</span> <span>os.getenv</span><span>(</span><span>&#39;PATH&#39;</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>Try that again, and it should work.</p>

<p>We really are just scratching the surface of all the commands available (<a href="https://wezfurlong.org/wezterm/config/lua/keyassignment/index.html">WezTerm supports a lot</a>). In the next section, we’ll be growing our key bindings further.</p>

<h2 id="multiplexing-terminals-levelling-up-key-assignments">Multiplexing terminals, levelling up key assignments</h2>

<p>Let’s move on to WezTerm’s multiplexing capabilities. If you make use of a multiplexer (i.e. tmux) then you may consider using WezTerm’s builtin capabilities instead. They’ll generally give you a more integrated experience, with individual scrollback buffers per pane, better mouse control, easier selection functionality, and generally faster performance.</p>

<p>Hit <code>CTRL + SHIFT + P</code> to bring up WezTerm’s command palette. (Yes, WezTerm has a command palette. Yes, it’s as customisable as everything else we’ve seen so far. No, we won’t dwell on it here). Type <code>split horizontally</code> until the “Shell: Split Horizontally” option is selected and hit <code>ENTER</code>. Ta-da! Your shell split horizontally! Do the same for <code>split vertically</code> and… you get the idea.</p>

<picture><source srcset="/generated/assets/posts/wezterm/09_command_palette-720-5e12352ea.webp 1.0x, /generated/assets/posts/wezterm/09_command_palette-1440-5e12352ea.webp 2.0x, /generated/assets/posts/wezterm/09_command_palette-1520-5e12352ea.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/09_command_palette-720-5e12352ea.jpg 1.0x, /generated/assets/posts/wezterm/09_command_palette-1440-5e12352ea.jpg 2.0x, /generated/assets/posts/wezterm/09_command_palette-1520-5e12352ea.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/09_command_palette-800-74d2ff2ad.png" alt="screenshot of WezTerm&#39;s command palette"/></picture>

<p>You may have noticed that the command palette displays the keyboard shortcut assigned to each action. The ones for splitting are quite a fingerful, e.g. <code>SHIFT + CTRL + OPTION + &#34;</code>. I get why they’re this complicated - because they’re trying not to clash with any other shortcuts you may have on your system, but we can do a lot better - and WezTerm gives us the tools do so easily!</p>

<h3 id="splitting-panes-leader-key">Splitting panes, leader key</h3>

<p>A leader key (<a href="https://wezfurlong.org/wezterm/config/keys.html#leader-key">docs</a>) is a special key combination that you press first, followed by another key combination, to perform a specific action. It can help you create complex shortcuts without needing to push a lot of keys all at once.</p>

<p>Sounds like a perfect fit for splitting panes, right? We’ll bind our leader to <code>CTRL + A</code>, and in case you accidentally type the leader without following it up with another key, we’ll have it automatically deactivate after 1,000 milliseconds.</p>

<div><div><pre><code><span>-- If you&#39;re using emacs you probably wanna choose a different leader here,</span>
<span>-- since we&#39;re gonna be making it a bit harder to CTRL + A for jumping to </span>
<span>-- the start of a line</span>
<span>config</span><span>.</span><span>leader</span> <span>=</span> <span>{</span> <span>key</span> <span>=</span> <span>&#39;a&#39;</span><span>,</span> <span>mods</span> <span>=</span> <span>&#39;CTRL&#39;</span><span>,</span> <span>timeout_milliseconds</span> <span>=</span> <span>1000</span> <span>}</span>
</code></pre></div></div>

<p>Next let’s define some key assignments for splitting panes:</p>

<div><div><pre><code><span>config</span><span>.</span><span>keys</span> <span>=</span> <span>{</span>
  <span>-- ... add these new entries to your config.keys table</span>
  <span>{</span>
    <span>-- I&#39;m used to tmux bindings, so am using the quotes (&#34;) key to</span>
    <span>-- split horizontally, and the percent (%) key to split vertically.</span>
    <span>key</span> <span>=</span> <span>&#39;&#34;&#39;</span><span>,</span>
    <span>-- Note that instead of a key modifier mapped to a key on your keyboard</span>
    <span>-- like CTRL or ALT, we can use the LEADER modifier instead.</span>
    <span>-- This means that this binding will be invoked when you press the leader</span>
    <span>-- (CTRL + A), quickly followed by quotes (&#34;).</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>SplitHorizontal</span> <span>{</span> <span>domain</span> <span>=</span> <span>&#39;CurrentPaneDomain&#39;</span> <span>},</span>
  <span>},</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;%&#39;</span><span>,</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>SplitVertical</span> <span>{</span> <span>domain</span> <span>=</span> <span>&#39;CurrentPaneDomain&#39;</span> <span>},</span>
  <span>},</span>
<span>}</span>
</code></pre></div></div>

<p>Give it a go now. Press <code>CTRL + A</code>, quickly followed by <code>&#34;</code>, and you’ll get a horizontal split. Use the other assignment and you’ll get a vertical split.</p>

<picture><source srcset="/generated/assets/posts/wezterm/10_splits-720-79750a1ee.webp 1.0x, /generated/assets/posts/wezterm/10_splits-1440-79750a1ee.webp 2.0x, /generated/assets/posts/wezterm/10_splits-1520-79750a1ee.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/10_splits-720-79750a1ee.jpg 1.0x, /generated/assets/posts/wezterm/10_splits-1440-79750a1ee.jpg 2.0x, /generated/assets/posts/wezterm/10_splits-1520-79750a1ee.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/10_splits-800-8e0e76173.png" alt="screenshot of WezTerm&#39;s with split panes"/></picture>

<p>Before we move on - you might be wondering what happens if you actually want to send the <code>CTRL + A</code> keypress <em>without</em> invoking the leader? <code>CTRL + A</code> is useful in and of its own as pressing it jumps to the start of a line on your shell (and on operating systems like Emacs).</p>

<p>Well there’s a solution for that. We can map <code>CTRL + A</code> quickly followed by <code>CTRL + A</code> to send a <code>CTRL + A</code> to our terminal. That’s a confusing sentence! It’ll be simpler to just look at the config:</p>

<div><div><pre><code><span>config</span><span>.</span><span>keys</span> <span>=</span> <span>{</span>
  <span>-- ... add these new entries to your config.keys table</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;a&#39;</span><span>,</span>
    <span>-- When we&#39;re in leader mode _and_ CTRL + A is pressed...</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER|CTRL&#39;</span><span>,</span>
    <span>-- Actually send CTRL + A key to the terminal</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>SendKey</span> <span>{</span> <span>key</span> <span>=</span> <span>&#39;a&#39;</span><span>,</span> <span>mods</span> <span>=</span> <span>&#39;CTRL&#39;</span> <span>},</span>
  <span>},</span>
<span>},</span>
</code></pre></div></div>

<h3 id="moving-around-panes">Moving around panes</h3>

<p>Okay with that done, let’s get back to multiplexing. Next up, navigating our splits. I like to use vim direction keybindings, but feel free to replace with arrow keys instead.</p>

<div><div><pre><code><span>config</span><span>.</span><span>keys</span> <span>=</span> <span>{</span>
  <span>-- ... add these new entries to your config.keys table</span>
  <span>{</span>
    <span>-- I like to use vim direction keybindings, but feel free to replace</span>
    <span>-- with directional arrows instead.</span>
    <span>key</span> <span>=</span> <span>&#39;j&#39;</span><span>,</span> <span>-- or DownArrow</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>ActivatePaneDirection</span><span>(</span><span>&#39;Down&#39;</span><span>),</span>
  <span>},</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;k&#39;</span><span>,</span> <span>-- or UpArrow</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>ActivatePaneDirection</span><span>(</span><span>&#39;Up&#39;</span><span>),</span>
  <span>},</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;h&#39;</span><span>,</span> <span>-- or LeftArrow</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>ActivatePaneDirection</span><span>(</span><span>&#39;Left&#39;</span><span>),</span>
  <span>},</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;l&#39;</span><span>,</span> <span>-- or RightArrow</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>ActivatePaneDirection</span><span>(</span><span>&#39;Right&#39;</span><span>),</span>
  <span>},</span>
<span>}</span>
</code></pre></div></div>

<p>Look at all that duplication - We’re using a dynamic language for our config here, we don’t need to stand for that! Let’s go on a little side quest and see if we can extract it to a function.</p>

<div><div><pre><code><span>local</span> <span>function</span> <span>move_pane</span><span>(</span><span>key</span><span>,</span> <span>direction</span><span>)</span>
  <span>return</span> <span>{</span>
    <span>key</span> <span>=</span> <span>key</span><span>,</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>ActivatePaneDirection</span><span>(</span><span>direction</span><span>),</span>
  <span>}</span>
<span>end</span>

<span>config</span><span>.</span><span>keys</span> <span>=</span> <span>{</span>
  <span>-- ... remove the previous move bindings, and replace with</span>
  <span>move_pane</span><span>(</span><span>&#39;j&#39;</span><span>,</span> <span>&#39;Down&#39;</span><span>),</span>
  <span>move_pane</span><span>(</span><span>&#39;k&#39;</span><span>,</span> <span>&#39;Up&#39;</span><span>),</span>
  <span>move_pane</span><span>(</span><span>&#39;h&#39;</span><span>,</span> <span>&#39;Left&#39;</span><span>),</span>
  <span>move_pane</span><span>(</span><span>&#39;l&#39;</span><span>,</span> <span>&#39;Right&#39;</span><span>),</span>
<span>}</span>
</code></pre></div></div>

<p>Ooh so much smaller, but it could be smaller still. I dare you to keep code golfing this down to 6 lines. Go on - I believe in you!</p>

<h3 id="resizing-panes-and-introducing-key-tables">Resizing panes, and introducing key tables</h3>

<p>You might’ve figured out that you can resize panes by dragging the edge of one with your mouse, but we’re developers here, not olympic athletes. What’re we expected to <em>move</em> our hands away from the safety of our keyboard and over to the mouse?! No! I won’t stand for it and neither should you!</p>

<p>It’d be really nice to use the same keys that we use for moving between the panes for resizing (h, j, k, l)… but they’ve already been mapped… we <em>could</em> add another key modifier that needs to be held down when we want to resize vs. move between the panes:</p>

<div><div><pre><code><span>config</span><span>.</span><span>keys</span> <span>=</span> <span>{</span>
  <span>-- ... add this new entry to your config.keys table</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;h&#39;</span><span>,</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER|CTRL&#39;</span><span>,</span>
    <span>-- &#34;3&#34; here is the amount of cells we wish to resize</span>
    <span>-- the terminal by</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>AdjustPaneSize</span> <span>{</span> <span>&#39;Left&#39;</span><span>,</span> <span>3</span> <span>},</span>
  <span>},</span>
<span>}</span>
</code></pre></div></div>

<p>But that’s no good really. We have to first push our leader <code>CTRL + A</code>, then push <code>CTRL + H</code>, and keep repeating that each time we wanna resize the pane to the left. Fingers getting sore. Send help. Oh, here comes WezTerm with the antidote: <a href="https://wezfurlong.org/wezterm/config/key-tables.html">key tables</a>.</p>

<p>When you activate a key table you’re entering a different mode with its own set of assignments for whatever you’re doing. This allows you to have multiple layers of assignments that are context specific.</p>

<p>It’s a similar kind of concept to the leader key, but unlike it, our key table will not automatically deactivate after an action is invoked, so it’ll be a good fit for resizing, where we want to keep pressing the same button over and over again until we’re happy with our pane’s new size.</p>

<p>With all that… this is easier <em>done</em> that said, so let’s check out the code:</p>

<div><div><pre><code><span>local</span> <span>function</span> <span>resize_pane</span><span>(</span><span>key</span><span>,</span> <span>direction</span><span>)</span>
  <span>return</span> <span>{</span>
    <span>key</span> <span>=</span> <span>key</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>AdjustPaneSize</span> <span>{</span> <span>direction</span><span>,</span> <span>3</span> <span>}</span>
  <span>}</span>
<span>end</span>

<span>config</span><span>.</span><span>keys</span> <span>=</span> <span>{</span>
  <span>-- ... remove the yucky keybinding from above and replace it with this</span>
  <span>{</span>
    <span>-- When we push LEADER + R...</span>
    <span>key</span> <span>=</span> <span>&#39;r&#39;</span><span>,</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>-- Activate the `resize_panes` keytable</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>ActivateKeyTable</span> <span>{</span>
      <span>name</span> <span>=</span> <span>&#39;resize_panes&#39;</span><span>,</span>
      <span>-- Ensures the keytable stays active after it handles its</span>
      <span>-- first keypress.</span>
      <span>one_shot</span> <span>=</span> <span>false</span><span>,</span>
      <span>-- Deactivate the keytable after a timeout.</span>
      <span>timeout_milliseconds</span> <span>=</span> <span>1000</span><span>,</span>
    <span>}</span>
  <span>},</span>
<span>}</span>

<span>config</span><span>.</span><span>key_tables</span> <span>=</span> <span>{</span>
  <span>resize_panes</span> <span>=</span> <span>{</span>
    <span>resize_pane</span><span>(</span><span>&#39;j&#39;</span><span>,</span> <span>&#39;Down&#39;</span><span>),</span>
    <span>resize_pane</span><span>(</span><span>&#39;k&#39;</span><span>,</span> <span>&#39;Up&#39;</span><span>),</span>
    <span>resize_pane</span><span>(</span><span>&#39;h&#39;</span><span>,</span> <span>&#39;Left&#39;</span><span>),</span>
    <span>resize_pane</span><span>(</span><span>&#39;l&#39;</span><span>,</span> <span>&#39;Right&#39;</span><span>),</span>
  <span>},</span>
<span>}</span>
</code></pre></div></div>

<p>Now you can push <code>CTRL + A</code> to activate leader, then <code>R</code> to activate the resizing layer… and movement keys to resize to your heart’s content. When 1,000 milliseconds have elapsed, you’ll automatically exit the resizing layer and be back to the default keytable.</p>

<p>WezTerm intensifies…</p>

<p>(While we’re on multiplexing, if you’re using neovim, I’d recommend checking out <a href="https://github.com/mrjones2014/smart-splits.nvim">smart-splits.nvim</a> - that’ll let you jump between your vim panes and your WezTerm ones).</p>

<h2 id="project-workspaces">Project workspaces</h2>

<p>Okay let’s graduate from WezTerm university with one final assignment… project workspaces.</p>

<p>I’m often working across a few different projects at a time, and need to be able to quickly switch between them. I want each project to maintain its own multiplexer instance with its own windows, panes, and tabs. In tmux you might achieve this with different sessions. In WezTerm we’ll do it with <a href="https://wezfurlong.org/wezterm/recipes/workspaces.html">workspaces</a>.</p>

<h3 id="creating-and-switching-between-workspaces">Creating and switching between workspaces</h3>

<p>Create a new file in your config directory and call it <code>projects.lua</code>. We’ll use this to provide some project switching functions to our main config file.</p>

<div><div><pre><code><span>local</span> <span>wezterm</span> <span>=</span> <span>require</span> <span>&#39;wezterm&#39;</span>
<span>local</span> <span>module</span> <span>=</span> <span>{}</span>

<span>local</span> <span>function</span> <span>project_dirs</span><span>()</span>
  <span>return</span> <span>{</span>
    <span>&#39;~/Projects/mailgrip&#39;</span><span>,</span>
    <span>&#39;~/Projects/alexplescan.com&#39;</span><span>,</span>
    <span>&#39;~/Projects/wezterm_love_letters&#39;</span><span>,</span>
    <span>-- ... keep going, list all your projects</span>
    <span>-- (or don&#39;t if you value your time. we&#39;ll improve on this soon)</span>
  <span>}</span>
<span>end</span>

<span>function</span> <span>module</span><span>.</span><span>choose_project</span><span>()</span>
  <span>local</span> <span>choices</span> <span>=</span> <span>{}</span>
  <span>for</span> <span>_</span><span>,</span> <span>value</span> <span>in</span> <span>ipairs</span><span>(</span><span>project_dirs</span><span>())</span> <span>do</span>
    <span>table.insert</span><span>(</span><span>choices</span><span>,</span> <span>{</span> <span>label</span> <span>=</span> <span>value</span> <span>})</span>
  <span>end</span>

  <span>-- The InputSelector action presents a modal UI for choosing between a set of options</span>
  <span>-- within WezTerm.</span>
  <span>return</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>InputSelector</span> <span>{</span>
    <span>title</span> <span>=</span> <span>&#39;Projects&#39;</span><span>,</span>
    <span>-- The options we wish to choose from</span>
    <span>choices</span> <span>=</span> <span>choices</span><span>,</span>
    <span>-- Yes, we wanna fuzzy search (so typing &#34;alex&#34; will filter down to</span>
    <span>-- &#34;~/Projects/alexplescan.com&#34;)</span>
    <span>fuzzy</span> <span>=</span> <span>true</span><span>,</span>
    <span>-- The action we want to perform. Note that this doesn&#39;t have to be a</span>
    <span>-- static definition as we&#39;ve done before, but can be a callback that</span>
    <span>-- evaluates any arbitrary code.</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action_callback</span><span>(</span><span>function</span><span>(</span><span>child_window</span><span>,</span> <span>child_pane</span><span>,</span> <span>id</span><span>,</span> <span>label</span><span>)</span>
      <span>-- As a placeholder, we&#39;ll log the name of what you picked</span>
      <span>wezterm</span><span>.</span><span>log_info</span><span>(</span><span>&#34;you chose &#34;</span> <span>..</span> <span>label</span><span>)</span>
    <span>end</span><span>),</span>
  <span>}</span>
<span>end</span>

<span>return</span> <span>module</span>
</code></pre></div></div>

<p>… and in your <code>wezterm.lua</code>:</p>

<div><div><pre><code><span>local</span> <span>projects</span> <span>=</span> <span>require</span> <span>&#39;projects&#39;</span>

<span>config</span><span>.</span><span>keys</span> <span>=</span> <span>{</span>
  <span>-- ... add these new entries to your config.keys table</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;p&#39;</span><span>,</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>-- Present in to our project picker</span>
    <span>action</span> <span>=</span> <span>projects</span><span>.</span><span>choose_project</span><span>(),</span>
  <span>},</span>
  <span>{</span>
    <span>key</span> <span>=</span> <span>&#39;f&#39;</span><span>,</span>
    <span>mods</span> <span>=</span> <span>&#39;LEADER&#39;</span><span>,</span>
    <span>-- Present a list of existing workspaces</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>ShowLauncherArgs</span> <span>{</span> <span>flags</span> <span>=</span> <span>&#39;FUZZY|WORKSPACES&#39;</span> <span>},</span>
  <span>},</span>
<span>}</span>
</code></pre></div></div>

<p>Lots going on here, take your time to read it and the comments. And give it a go! Push <code>LEADER + P</code>, and you’ll see the project input selector come up. Pick a project by highlighting one and pushing <code>ENTER</code>, or push <code>CTRL + C</code> to close the picker. Once you’ve picked a project you’ll see its directory logged to your debug overlay (<code>CTRL + SHIFT + L</code>).</p>

<picture><source srcset="/generated/assets/posts/wezterm/11_workspace_switcher-720-835177f65.webp 1.0x, /generated/assets/posts/wezterm/11_workspace_switcher-1440-835177f65.webp 2.0x, /generated/assets/posts/wezterm/11_workspace_switcher-1520-835177f65.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/11_workspace_switcher-720-835177f65.jpg 1.0x, /generated/assets/posts/wezterm/11_workspace_switcher-1440-835177f65.jpg 2.0x, /generated/assets/posts/wezterm/11_workspace_switcher-1520-835177f65.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/11_workspace_switcher-800-86fb3a529.png" alt="screenshot of WezTerm&#39;s with the workspace switcher we&#39;ve configured"/></picture>

<p>Still a couple of issues though… it’s really annoying to type out all your projects by hand in that file, and, uh, what was the other issue? Oh yeah! When you pick a project nothing happens. Okay, let’s fix these. Back in <code>projects.lua</code>, we’ll start by having the list of projects automatically populate.</p>

<div><div><pre><code><span>-- The directory that contains all your projects.</span>
<span>local</span> <span>project_dir</span> <span>=</span> <span>wezterm</span><span>.</span><span>home_dir</span> <span>..</span> <span>&#34;/Projects&#34;</span>

<span>local</span> <span>function</span> <span>project_dirs</span><span>()</span>
  <span>-- Start with your home directory as a project, &#39;cause you might want</span>
  <span>-- to jump straight to it sometimes.</span>
  <span>local</span> <span>projects</span> <span>=</span> <span>{</span> <span>wezterm</span><span>.</span><span>home_dir</span> <span>}</span>

  <span>-- WezTerm comes with a glob function! Let&#39;s use it to get a lua table</span>
  <span>-- containing all subdirectories of your project folder.</span>
  <span>for</span> <span>_</span><span>,</span> <span>dir</span> <span>in</span> <span>ipairs</span><span>(</span><span>wezterm</span><span>.</span><span>glob</span><span>(</span><span>project_dir</span> <span>..</span> <span>&#39;/*&#39;</span><span>))</span> <span>do</span>
    <span>-- ... and add them to the projects table.</span>
    <span>table.insert</span><span>(</span><span>projects</span><span>,</span> <span>dir</span><span>)</span>
  <span>end</span>

  <span>return</span> <span>projects</span>
<span>end</span>
</code></pre></div></div>

<p>(This all assumes that you like to keep your projects grouped together in a folder, if not… well you’ve got Lua at your fingertips to implement whatever you want!)</p>

<p>Now launch the project picker, and what do you see? All those projects staring back at thee.</p>

<p>One thing left to do, let’s add the functionality that opens your project in a new WezTerm workspace. Still in <code>projects.lua</code> let’s change up <code>choose_project</code>:</p>

<div><div><pre><code><span>function</span> <span>module</span><span>.</span><span>choose_project</span><span>()</span>
  <span>local</span> <span>choices</span> <span>=</span> <span>{}</span>
  <span>for</span> <span>_</span><span>,</span> <span>value</span> <span>in</span> <span>ipairs</span><span>(</span><span>project_dirs</span><span>())</span> <span>do</span>
    <span>table.insert</span><span>(</span><span>choices</span><span>,</span> <span>{</span> <span>label</span> <span>=</span> <span>value</span> <span>})</span>
  <span>end</span>

  <span>return</span> <span>wezterm</span><span>.</span><span>action</span><span>.</span><span>InputSelector</span> <span>{</span>
    <span>title</span> <span>=</span> <span>&#34;Projects&#34;</span><span>,</span>
    <span>choices</span> <span>=</span> <span>choices</span><span>,</span>
    <span>fuzzy</span> <span>=</span> <span>true</span><span>,</span>
    <span>action</span> <span>=</span> <span>wezterm</span><span>.</span><span>action_callback</span><span>(</span><span>function</span><span>(</span><span>child_window</span><span>,</span> <span>child_pane</span><span>,</span> <span>id</span><span>,</span> <span>label</span><span>)</span>
      <span>-- &#34;label&#34; may be empty if nothing was selected. Don&#39;t bother doing anything</span>
      <span>-- when that happens.</span>
      <span>if</span> <span>not</span> <span>label</span> <span>then</span> <span>return</span> <span>end</span>

      <span>-- The SwitchToWorkspace action will switch us to a workspace if it already exists,</span>
      <span>-- otherwise it will create it for us.</span>
      <span>child_window</span><span>:</span><span>perform_action</span><span>(</span><span>wezterm</span><span>.</span><span>action</span><span>.</span><span>SwitchToWorkspace</span> <span>{</span>
        <span>-- We&#39;ll give our new workspace a nice name, like the last path segment</span>
        <span>-- of the directory we&#39;re opening up.</span>
        <span>name</span> <span>=</span> <span>label</span><span>:</span><span>match</span><span>(</span><span>&#34;([^/]+)$&#34;</span><span>),</span>
        <span>-- Here&#39;s the meat. We&#39;ll spawn a new terminal with the current working</span>
        <span>-- directory set to the directory that was picked.</span>
        <span>spawn</span> <span>=</span> <span>{</span> <span>cwd</span> <span>=</span> <span>label</span> <span>},</span>
      <span>},</span> <span>child_pane</span><span>)</span>
    <span>end</span><span>),</span>
  <span>}</span>
<span>end</span>
</code></pre></div></div>

<p>Try that out, select a new project, and you’ll see a workspace get created for it. Switch back to your default workspace (we bound so <code>LEADER, CTRL + F</code>  to show you a list of active workspaces) and you’ll see everything is right where you left it.</p>

<h3 id="bonus-improving-the-powerline-and-more-colour-stuff">Bonus: improving the powerline, and more colour stuff</h3>

<p>Let’s add a couple of polishing touches to this workflow and then I promise we’ll be done…</p>

<p>Remember that sad powerline we set up earlier? Let’s make it happier by adding another segment to it which contains the name of the current workspace. In true powerline fashion, each subsequent segment on the powerline will display in a different colour. We’ll explore some of WezTerm’s colour maths support and do this all dynamically based on our theme. Back in <code>wezterm.lua</code>:</p>

<div><div><pre><code><span>-- Replace the old wezterm.on(&#39;update-status&#39;, ... function with this:</span>

<span>local</span> <span>function</span> <span>segments_for_right_status</span><span>(</span><span>window</span><span>)</span>
  <span>return</span> <span>{</span>
    <span>window</span><span>:</span><span>active_workspace</span><span>(),</span>
    <span>wezterm</span><span>.</span><span>strftime</span><span>(</span><span>&#39;%a %b %-d %H:%M&#39;</span><span>),</span>
    <span>wezterm</span><span>.</span><span>hostname</span><span>(),</span>
  <span>}</span>
<span>end</span>

<span>wezterm</span><span>.</span><span>on</span><span>(</span><span>&#39;update-status&#39;</span><span>,</span> <span>function</span><span>(</span><span>window</span><span>,</span> <span>_</span><span>)</span>
  <span>local</span> <span>SOLID_LEFT_ARROW</span> <span>=</span> <span>utf8.char</span><span>(</span><span>0xe0b2</span><span>)</span>
  <span>local</span> <span>segments</span> <span>=</span> <span>segments_for_right_status</span><span>(</span><span>window</span><span>)</span>

  <span>local</span> <span>color_scheme</span> <span>=</span> <span>window</span><span>:</span><span>effective_config</span><span>().</span><span>resolved_palette</span>
  <span>-- Note the use of wezterm.color.parse here, this returns</span>
  <span>-- a Color object, which comes with functionality for lightening</span>
  <span>-- or darkening the colour (amongst other things).</span>
  <span>local</span> <span>bg</span> <span>=</span> <span>wezterm</span><span>.</span><span>color</span><span>.</span><span>parse</span><span>(</span><span>color_scheme</span><span>.</span><span>background</span><span>)</span>
  <span>local</span> <span>fg</span> <span>=</span> <span>color_scheme</span><span>.</span><span>foreground</span>

  <span>-- Each powerline segment is going to be coloured progressively</span>
  <span>-- darker/lighter depending on whether we&#39;re on a dark/light colour</span>
  <span>-- scheme. Let&#39;s establish the &#34;from&#34; and &#34;to&#34; bounds of our gradient.</span>
  <span>local</span> <span>gradient_to</span><span>,</span> <span>gradient_from</span> <span>=</span> <span>bg</span>
  <span>if</span> <span>appearance</span><span>.</span><span>is_dark</span><span>()</span> <span>then</span>
    <span>gradient_from</span> <span>=</span> <span>gradient_to</span><span>:</span><span>lighten</span><span>(</span><span>0</span><span>.</span><span>2</span><span>)</span>
  <span>else</span>
    <span>gradient_from</span> <span>=</span> <span>gradient_to</span><span>:</span><span>darken</span><span>(</span><span>0</span><span>.</span><span>2</span><span>)</span>
  <span>end</span>

  <span>-- Yes, WezTerm supports creating gradients, because why not?! Although</span>
  <span>-- they&#39;d usually be used for setting high fidelity gradients on your terminal&#39;s</span>
  <span>-- background, we&#39;ll use them here to give us a sample of the powerline segment</span>
  <span>-- colours we need.</span>
  <span>local</span> <span>gradient</span> <span>=</span> <span>wezterm</span><span>.</span><span>color</span><span>.</span><span>gradient</span><span>(</span>
    <span>{</span>
      <span>orientation</span> <span>=</span> <span>&#39;Horizontal&#39;</span><span>,</span>
      <span>colors</span> <span>=</span> <span>{</span> <span>gradient_from</span><span>,</span> <span>gradient_to</span> <span>},</span>
    <span>},</span>
    <span>#</span><span>segments</span> <span>-- only gives us as many colours as we have segments.</span>
  <span>)</span>

  <span>-- We&#39;ll build up the elements to send to wezterm.format in this table.</span>
  <span>local</span> <span>elements</span> <span>=</span> <span>{}</span>

  <span>for</span> <span>i</span><span>,</span> <span>seg</span> <span>in</span> <span>ipairs</span><span>(</span><span>segments</span><span>)</span> <span>do</span>
    <span>local</span> <span>is_first</span> <span>=</span> <span>i</span> <span>==</span> <span>1</span>

    <span>if</span> <span>is_first</span> <span>then</span>
      <span>table.insert</span><span>(</span><span>elements</span><span>,</span> <span>{</span> <span>Background</span> <span>=</span> <span>{</span> <span>Color</span> <span>=</span> <span>&#39;none&#39;</span> <span>}</span> <span>})</span>
    <span>end</span>
    <span>table.insert</span><span>(</span><span>elements</span><span>,</span> <span>{</span> <span>Foreground</span> <span>=</span> <span>{</span> <span>Color</span> <span>=</span> <span>gradient</span><span>[</span><span>i</span><span>]</span> <span>}</span> <span>})</span>
    <span>table.insert</span><span>(</span><span>elements</span><span>,</span> <span>{</span> <span>Text</span> <span>=</span> <span>SOLID_LEFT_ARROW</span> <span>})</span>

    <span>table.insert</span><span>(</span><span>elements</span><span>,</span> <span>{</span> <span>Foreground</span> <span>=</span> <span>{</span> <span>Color</span> <span>=</span> <span>fg</span> <span>}</span> <span>})</span>
    <span>table.insert</span><span>(</span><span>elements</span><span>,</span> <span>{</span> <span>Background</span> <span>=</span> <span>{</span> <span>Color</span> <span>=</span> <span>gradient</span><span>[</span><span>i</span><span>]</span> <span>}</span> <span>})</span>
    <span>table.insert</span><span>(</span><span>elements</span><span>,</span> <span>{</span> <span>Text</span> <span>=</span> <span>&#39; &#39;</span> <span>..</span> <span>seg</span> <span>..</span> <span>&#39; &#39;</span> <span>})</span>
  <span>end</span>

  <span>window</span><span>:</span><span>set_right_status</span><span>(</span><span>wezterm</span><span>.</span><span>format</span><span>(</span><span>elements</span><span>))</span>
<span>end</span><span>)</span>
</code></pre></div></div>

<picture><source srcset="/generated/assets/posts/wezterm/12_status_bar_enhanced-720-d88a78af8.webp 1.0x, /generated/assets/posts/wezterm/12_status_bar_enhanced-1440-d88a78af8.webp 2.0x, /generated/assets/posts/wezterm/12_status_bar_enhanced-1520-d88a78af8.webp 2.11x" type="image/webp"/><source srcset="/generated/assets/posts/wezterm/12_status_bar_enhanced-720-d88a78af8.jpg 1.0x, /generated/assets/posts/wezterm/12_status_bar_enhanced-1440-d88a78af8.jpg 2.0x, /generated/assets/posts/wezterm/12_status_bar_enhanced-1520-d88a78af8.jpg 2.11x" type="image/jpeg"/><img src="https://alexplescan.com/generated/assets/posts/wezterm/12_status_bar_enhanced-800-df09b5aaf.png" alt="screenshot of WezTerm with an enhanced status line, showing multiple segments in different colours"/></picture>

<p>WezTerm delivers yet again. This updated callback supports arbitrary numbers of segments for its powerline. We’ve specified 3 but you could add way more. All this without needing to manually configure what colour we want on each segment, but rather have WezTerm do it for us by creating a gradient based on the currently active theme. Some highlights:</p>

<ul>
  <li>We use <code>wezterm.color.parse</code> to convert a string containing a hex colour code into a <code>Color</code> object (<a href="https://wezfurlong.org/wezterm/config/lua/color/index.html">docs</a>) - this lets us perform more advanced operations on the color.</li>
  <li>The colour scheme’s background colour is still what we want to use as the value that our gradient draws <em>to</em>, but to figure out where the gradient should start, we use either <code>color:darken</code> (<a href="https://wezfurlong.org/wezterm/config/lua/color/darken.html">docs</a>) or <code>color:lighten</code> to create a new colour.</li>
  <li>The gradient itself is made with <code>wezterm.color.gradient</code> (<a href="https://wezfurlong.org/wezterm/config/lua/wezterm.color/gradient.html">docs</a>), which returns a table containing a evenly spaced colours between our <code>gradient_to</code> and <code>gradient_from</code>.</li>
  <li>We then iterate over our powerline segments to create the items required for <code>wezterm.format</code>.</li>
</ul>

<h2 id="where-to-from-here">Where to from here?</h2>

<p>There’s a <a href="https://wezfurlong.org/wezterm/features.html">lot more that WezTerm does</a> and that <a href="https://wezfurlong.org/wezterm/config/lua/general.html">you can do with WezTerm</a>. By now you’ll have a good understanding of WezTerm config fundamentals, but I encourage you to keep exploring!</p>

<p>If you’ve followed this guide step by step, I’d recommend pruning the config down to things that you’ll actually use, rewriting it in your own style, then start sprinkling in your own stuff. Take ownership of this thing! Make your own beautiful WezTerm snowflake!</p>

<p>When you want some inspiration for what you could do next, browse through the <a href="https://wezfurlong.org/wezterm/config/lua/general.html">WezTerm API docs</a> to see what’s possible.</p>

<p>And if you find that you too really like WezTerm, please consider <a href="https://wezfurlong.org/sponsor/">supporting Wez</a> for his great open-source work.</p>
</div>

  
</article>

      </div>
    </div></div>
  </body>
</html>
