<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://olegtarasov.me/opentherm-thermostat-esphome/">Original</a>
    <h1>DIY Wi-Fi thermostat from scratch with ESPHome and Home Assistant</h1>
    
    <div id="readability-page-1" class="page"><div>
         
        <p>In this series of posts I describe my journey of automating a heating system in my suburban home. This particular post is about a simple, but fully functional thermostat that uses a PID controller to maintain a target room temperature. I  use this thermostat with an OpenTherm gas boiler, but most of the ESPHome configuration is universal and can be reused with other boilers, if they have a ESPHome component.</p><p>In the <a href="https://olegtarasov.me/opentherm-thermostat-esphome-prototype1/" rel="noreferrer">previous post</a> I left off with a prototype interface board for an OpenTherm boiler, which was loosely connected to a ESP32 dev board by a bunch of jumper wires. In this post I am going to build a first useful device using ESPHome and Home Assistant.</p><h2 id="the-water-heating-system">The water heating system</h2><p>It&#39;s always good to plan in advance and gather requirements before you heat up the soldering iron. First of all, let&#39;s take a look at the system I am dealing with:</p><figure><div><div><p><img src="https://olegtarasov.me/content/images/2024/04/IMG_7385.jpeg" width="2000" height="1500" loading="lazy" alt="" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/IMG_7385.jpeg 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/IMG_7385.jpeg 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/IMG_7385.jpeg 1600w, https://olegtarasov.me/content/images/size/w2400/2024/04/IMG_7385.jpeg 2400w" sizes="(min-width: 720px) 720px"/></p><p><img src="https://olegtarasov.me/content/images/2024/04/IMG_7385--1-.jpeg" width="2000" height="1500" loading="lazy" alt="" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/IMG_7385--1-.jpeg 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/IMG_7385--1-.jpeg 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/IMG_7385--1-.jpeg 1600w, https://olegtarasov.me/content/images/size/w2400/2024/04/IMG_7385--1-.jpeg 2400w" sizes="(min-width: 720px) 720px"/></p></div></div></figure><p>At first glance it looks really intimidating, and it took me a good portion of a week to figure out how it works. I had no prior experience with heating systems, so I had to read up quite a lot theory before I could make heads or tails of it. It really helps to remember that it&#39;s all just water, flowing in the direction of lower pressure üòÑ</p><p>Anyway, here I have 3 subsystems:</p><ol><li>Wall-mounted radiators that do the bulk of heating.</li><li>Heated floor, with one or two individual loops in each room.</li><li>Indirect water heater that prepares domestic hot water for use in showers and faucets.</li></ol><p>Radiators and heated floors are merged into one branch, and water heater uses a separate branch. Natural gas boiler can operate only one branch at a time, switching between them when necessary. Hot water for showers and faucets has priority (it&#39;s hardwired), so when it becomes colder, the boiler stops heating the house and starts heating the water tank. These two heating branches are closed loops which contain water under pressure of 1.5 atm. So a gas boiler heats up  the water in these branches and moves it around the loop with electric pumps. When heated water passes radiators, heated floor pipes or water heater, it transfers its heat, gets colder, and then comes back to the boiler to be heated again. Whew, easy!</p><p>Another branch goes to the indirect water heater that transfers heat from boiler to cold water stored in the tank. This way, faucet water never enters the boiler itself, so that boiler heating loop maintains its own pressure at all times. Here is a simple schematic of how indirect water heater operates:</p><figure><img src="https://olegtarasov.me/content/images/2024/04/indirect-hwh.png" alt="" loading="lazy" width="637" height="530" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/indirect-hwh.png 600w, https://olegtarasov.me/content/images/2024/04/indirect-hwh.png 637w"/><figcaption><span>Image from </span><a href="https://sippin.com/hvac/hot-water-systems/indirect-water-heaters/?ref=olegtarasov.me"><span>https://sippin.com/hvac/hot-water-systems/indirect-water-heaters/</span></a></figcaption></figure><h2 id="boiler-control-signals">Boiler control signals</h2><p>Controlling such a system would seem like a great challenge, but luckily a lot of low-level logic is hidden inside the boiler itself. It turns out, thermostat needs to provide only two control signals to the boiler:</p><ol><li>Central Heating setpoint, which is the temperature of heated water coming out of the boiler in a central heating loop. For example, I can tell the boiler that I want water to be 60¬∞ C at all times, and it will control its burning intensity and on-off cycles to match this temperature to the best of its ability. So I would always get water entering my heating system at 60¬∞.</li><li>Domestic Hot Water (DHW) setpoint, which is the temperature of hot water coming out of the water heater to showers and faucets. Since domestic hot water never enters the boiler and heat transfer is happening inside the storage tank, the boiler needs an additional temperature sensor that needs to be placed in a special slot in the water heater. That way boiler knows when hot water stored in the tank becomes cooler and it&#39;s time to switch to DHW loop from central heating.</li></ol><p>In theory, I could tell the boiler to always support each setpoint temperature constant, and it&#39;s usually OK with DHW. But this approach is suboptimal for central heating, especially when weather is not that cold yet. Wall-mounted radiators would run for a short period of time at full capacity, overshoot target room temperature by 1-2 degrees and then turn off for a long time to wait for temperature to drop. This leads to unnecessary temperature fluctuations, which can easily be avoided. In order to control target room temperature more smoothly, I can vary Central Heating setpoint so that radiators and heated floors don&#39;t blast with full power, but rather stay just warm enough to support a comfortable room temperature.</p><h2 id="monitoring">Monitoring</h2><p>It&#39;s always a good idea to monitor production systems, and water heating is no exception. There is not much variety in what I can monitor:</p><ol><li><strong>Temperature</strong>. Placing temperature sensors strategically can help ‚Äûdebug‚Äù heating systems and tune some hard to guess parameters like water pump power.</li><li><strong>Pressure</strong>. Maintaining near-constant pressure is critical for a heating system. It&#39;s usually achieved by installing expansion tanks, but it&#39;s always a good idea to be able to monitor system pressure remotely.</li><li><strong>Various boiler parameters</strong>, like whether it&#39;s currently burning, or what heating loop is active.</li></ol><p>In this prototype I decided to limit monitoring to temperature and boiler parameters, since I wasn&#39;t able to find an affordable and reliable digital pressure sensor. In order to monitor temperature, I decided to use widely popular <a href="https://www.analog.com/media/en/technical-documentation/data-sheets/ds18b20.pdf?ref=olegtarasov.me" rel="noreferrer">DS18B20</a> temperature sensor. I like its simplicity and ability to daisy-chain several sensors on a single 1-Wire bus.</p><h2 id="schematics-and-soldering">Schematics and soldering</h2><p>It&#39;s time to design a schematic for my thermostat. I am using a variation of <a href="https://www.reddit.com/r/esp8266/comments/a93raj/wemos_ttgo_mini_d1_esp32/?ref=olegtarasov.me" rel="noreferrer">Wemos D1 Mini ESP32</a> development boards in this design. You can use any ESP32 dev board that is <a href="https://esphome.io/components/esp32?ref=olegtarasov.me" rel="noreferrer">supported by ESPHome</a>, or even roll with a bare bones ESP32 SoC. I find dev boards exceptionally handy during prototyping phase. I even contemplate using dev boards in my final designs due to their small footprint and ease of soldering. Another perk of using a dev board is on-board USB and voltage conversion support. You can power your whole device with any 5V USB power supply and easily debug it if something goes wrong.</p><figure><img src="https://olegtarasov.me/content/images/2024/04/image.png" alt="" loading="lazy" width="2000" height="1478" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/image.png 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/image.png 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/image.png 1600w, https://olegtarasov.me/content/images/2024/04/image.png 2306w" sizes="(min-width: 720px) 720px"/></figure><p>As you can see here, most of the schematic is an implementation of <a href="https://ihormelnyk.com/opentherm_adapter?ref=olegtarasov.me" rel="noreferrer">Ihor Melnik&#39;s OpenTherm adapter</a>. I also added one 4-pin connector for a Nextion Display (will be covered in one of the next posts) and 10 3-pin connectors for various temperature sensors I plan to install into my system.</p><p>Long story short, this is the final prototype PCB:</p><figure><div><div><p><img src="https://olegtarasov.me/content/images/2024/04/IMG_7901.jpeg" width="2000" height="1500" loading="lazy" alt="" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/IMG_7901.jpeg 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/IMG_7901.jpeg 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/IMG_7901.jpeg 1600w, https://olegtarasov.me/content/images/size/w2400/2024/04/IMG_7901.jpeg 2400w" sizes="(min-width: 720px) 720px"/></p><p><img src="https://olegtarasov.me/content/images/2024/04/IMG_7902.jpeg" width="2000" height="1500" loading="lazy" alt="" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/IMG_7902.jpeg 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/IMG_7902.jpeg 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/IMG_7902.jpeg 1600w, https://olegtarasov.me/content/images/size/w2400/2024/04/IMG_7902.jpeg 2400w" sizes="(min-width: 720px) 720px"/></p></div></div></figure><p>It&#39;s definitely not a pinnacle of soldering mastery, but it works üòÑ You can notice that there is a second screw terminal that is absent from the schematics. This an additional 5V power terminal that can be used to power the PCB instead of ESP32 board USB connector. I&#39;m not sure whether it will be used in the final design, so I omitted it from the schematics. Here&#39;s how it looks in a temporary enclosure with boiler and one temperature sensor connected:</p><figure><img src="https://olegtarasov.me/content/images/2024/04/IMG_7982.jpeg" alt="" loading="lazy" width="2000" height="2667" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/IMG_7982.jpeg 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/IMG_7982.jpeg 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/IMG_7982.jpeg 1600w, https://olegtarasov.me/content/images/2024/04/IMG_7982.jpeg 2000w" sizes="(min-width: 720px) 720px"/></figure><p>I also made 8 or 9 screw-in temperature sensors to monitor temperature in various point in my system. I bought super cheap analogue gauge thermometers, threw out the thermometers and glued a bunch of <a href="https://www.analog.com/media/en/technical-documentation/data-sheets/ds18b20.pdf?ref=olegtarasov.me" rel="noreferrer">DS18B20</a> sensors into screw-in enclosures. I used a thermal glue which is also used to glue CPU heat sinks, and later filled it all with heat-resistant resin. Here is an individual temperature sensor and the whole rat&#39;s nest of wires when they are all connected:</p><figure><div><div><p><img src="https://olegtarasov.me/content/images/2024/04/IMG_7794-1.jpeg" width="2000" height="2667" loading="lazy" alt="" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/IMG_7794-1.jpeg 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/IMG_7794-1.jpeg 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/IMG_7794-1.jpeg 1600w, https://olegtarasov.me/content/images/size/w2400/2024/04/IMG_7794-1.jpeg 2400w" sizes="(min-width: 720px) 720px"/></p><p><img src="https://olegtarasov.me/content/images/2024/04/IMG_7795-2.jpeg" width="2000" height="2667" loading="lazy" alt="" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/IMG_7795-2.jpeg 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/IMG_7795-2.jpeg 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/IMG_7795-2.jpeg 1600w, https://olegtarasov.me/content/images/size/w2400/2024/04/IMG_7795-2.jpeg 2400w" sizes="(min-width: 720px) 720px"/></p><p><img src="https://olegtarasov.me/content/images/2024/04/IMG_8083-2.jpeg" width="2000" height="1500" loading="lazy" alt="" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/IMG_8083-2.jpeg 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/IMG_8083-2.jpeg 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/IMG_8083-2.jpeg 1600w, https://olegtarasov.me/content/images/size/w2400/2024/04/IMG_8083-2.jpeg 2400w" sizes="(min-width: 720px) 720px"/></p></div></div></figure><h2 id="configuring-esphome">Configuring ESPHome</h2><p>The final step in this little adventure is configuring and uploading ESPHome firmware to the device. But first we need to install ESPHome.</p><h3 id="installing-esphome-in-home-assistant">Installing ESPHome in Home Assistant</h3><p>The great advantage of ESPHome is its tight integration with Home Assistant. While you can install ESPHome on your machine and don&#39;t use HA at all, it&#39;s much easier to start with HA integration, if using your device in HA is ultimately your goal.</p><p>To install ESPHome in HA, I went to <code>Settings</code> ‚Üí <code>Add-ons</code> ‚Üí <code>Add-on store</code>. I found <code>ESPHome</code> in the add-on list and installed it. It&#39;s also a good idea to turn on the ‚ÄúShow in sidebar‚Äù checkbox in order to find ESPHome dashboard more easily. I am running Home Assistant in its Operating System form, so I&#39;m able to install and maintain add-ons easily. If you are not using HA OS, then you probably can&#39;t install ESPHome add-on from the store. Your other option might be installing ESPHome on your machine by following <a href="https://esphome.io/guides/installing_esphome?ref=olegtarasov.me" rel="noreferrer">the docs</a>.</p><h3 id="creating-a-new-configuration">Creating a new configuration</h3><p>Creating a new device in ESPHome dashboard is really easy. I followed the wizard and after a little while ended up with a basic firmware uploaded to my prototype device. After that first upload updating the device is usually performed over the Wi-Fi. If you are not sure about this step, be sure to consult the <a href="https://esphome.io/guides/getting_started_hassio?ref=olegtarasov.me" rel="noreferrer">official docs</a> for the most up-to-date instructions.</p><p>In the next few sections I will gradually build up ESPHome configuration to get a minimally functioning thermostat with PID control.</p><h3 id="basic-setup">Basic setup</h3><p>First of all, I declare some basic stuff: dev board configuration, wi-fi credentials and API keys:</p><pre><code>esphome:
  name: boilotron
  friendly_name: Boilotron

esp32:
  board: mhetesp32minikit
  framework:
    type: arduino

external_components:
  - source: github://olegtarasov/esphome-opentherm@new_lib

# Enable logging
logger:
  level: INFO
  logs:
    component: ERROR
    sensor: WARN
    opentherm.output: INFO

# Enable Home Assistant API
api:
  encryption:
    key: &#34;&lt;your key&gt;&#34;

ota:
  password: &#34;&lt;your password&gt;&#34;

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password</code></pre><p>Note the <code>external_components</code> section. Since there is no built-in support for OpenTherm in ESPHome, I need to reference an external component. I will be using <a href="https://github.com/olegtarasov/esphome-opentherm/tree/new_lib?ref=olegtarasov.me" rel="noreferrer">my fork</a> of the <code>esphome-opentherm</code> component. As I&#39;ve mentioned in a previous post, the upstream component seems to be abandoned and doesn&#39;t even compile with latest versions of ESPHome. Nevertheless, this component seems to be the most mature, so I decided to fork it, integrate several outstanding pull requests and replace the underlying OpenTherm protocol library. More on this in one of the next posts üòÉ Here we just reference the external component.</p><h3 id="opentherm-configuration">OpenTherm configuration</h3><p>Next I declare OpenTherm configuration with its controls and sensors:</p><pre><code># Declare the phisical pins that OpenTherm adapter is connected to
opentherm:
  in_pin: 21
  out_pin: 26

# Outputs are controlled by some other components, not manually
output:
  - platform: opentherm
    t_set:
      id: boilotron_ch_setpoint
      min_value: 40
      max_value: 60
      zero_means_zero: true

# Values that can be set maually from HA interface
number:
  - platform: opentherm
    t_dhw_set:
      id: boilotron_dhw_setpoint
      name: &#34;Hot Water target temperature&#34;
      min_value: 20
      max_value: 60
      restore_value: true
      initial_value: 60

# Switches that can be operated manually from HA interface
switch:
  - platform: opentherm
    ch_enable:
      id: boilotron_ch_enable
      name: &#34;Central Heating enabled&#34;
      restore_mode: RESTORE_DEFAULT_OFF
    dhw_enable:
      id: boilotron_dhw_enable
      name: &#34;Hot Water enabled&#34;
      restore_mode: RESTORE_DEFAULT_OFF

# Boiler numeric sensors
sensor:
  - platform: opentherm
    rel_mod_level:
      id: boilotron_rel_mod_level
      name: &#34;Boiler Relative modulation level&#34;
    t_boiler:
      id: boilotron_temperature_ch
      name: &#34;Boiler Feed Temperature&#34;

# Boiler binary (True/False) sensors
binary_sensor:
  - platform: opentherm
    ch_active:
      id: boilotron_ch_active
      name: &#34;Boiler Central Heating active&#34;
    dhw_active:
      id: boilotron_dhw_active
      name: &#34;Boiler Hot Water active&#34;
    flame_on:
      id: boilotron_boiler_flame_on
      name: &#34;Boiler Flame on&#34;
    fault_indication:
      id: boilotron_boiler_fault
      name: &#34;Boiler Fault&#34;
      entity_category: diagnostic
    diagnostic_indication:
      id: boilotron_boiler_diagnostic
      name: &#34;Boiler Diagnostic&#34;
      entity_category: diagnostic</code></pre><p>There is a lot to process here, but let&#39;s dissect this config step-by-step. First of all, on the top level you can see <code>components</code>: outputs, numbers, switches etc. These are sometimes confusing, because a component can live on the top level, like <code>opentherm</code> here, but in other cases top-level statements represent component ‚Äûclasses‚Äù, with components nested underneath, like switches and sensors. There is no apparent system to this, you just need to consult <a href="https://esphome.io/?ref=olegtarasov.me" rel="noreferrer">ESPHome documentation</a> a lot üòÉ </p><p>First of all I&#39;m configuring base OpenTherm hub component to let ESPHome know which pins my adapter is connected to.</p><p>Next I declare several components that let me control the boiler and read its state. The most important is <code>t_set</code> component of class <code>output</code>. It corresponds to central heating setpoint, and declaring it as <code>output</code> means that I will not set its value manually, but rather through some other component. In a couple of moments I will connect a software PID controller to this output. There are some additional properties like min and max values. Recommended maximum temperature for heating system with wall-mounted radiators is usually 60¬∞ C and minimum temperature needs to be discovered empirically. I found that 40¬∞ is the minimum temperature that my boiler can sustain on its lowest burn intensity without turning off and on again. </p><p>Note that <code>esphome-opentherm</code> allows to declare any non-sensor component as a <code>number</code> ‚Äî that way you will be able to set its value manually using Home Assistant UI. This is exactly what happens with <code>t_dhw_set</code> component ‚Äî as noted earlier, we usually want faucet water to be roughly the same temperature, so I just need to set this temperature once and let boiler handle the rest. </p><p>I also declare two switches that allow me turn central heating and DHW on or off completely: <code>ch_enable</code> and <code>dhw_enable</code>. The state of these switches can be restored by ESPHome after reboot and I also prefer to set them to ‚Äûoff‚Äù in case no saved value is present. <code>RESTORE_DEFAULT_OFF</code> allows me to do just that.</p><p>After that I declare a bunch of sensors that can be read from the boiler. <code>rel_mod_level</code> shows current burn intensity and <code>t_boiler</code> shows the temperature of the water coming out of the boiler (this is the temperature that we set with <code>t_set</code>). There is also a bunch of binary flags that indicate current state of the boiler.</p><p>OpenTherm is a common standard with many vendors and boilers implementing it to a different degree. My boiler is one of the simpler ones, and this is all the info that I can get out of it. Other boilers support more sensors, and you can find the whole list in the <a href="https://github.com/olegtarasov/esphome-opentherm/blob/new_lib/README.md?ref=olegtarasov.me" rel="noreferrer">library readme</a> on GitHub.</p><h3 id="adding-room-temperature-sensor">Adding room temperature sensor</h3><p>My goal is to maintain a fixed room temperature with minimum variation. In order to do that, I need to get this temperature from somewhere. In my target design I will place climate sensors in every room and connect them all to Home Assistant. It will be a complex control system which will have an ability to control temperature in each room individually with TRVs placed on radiators. But I should also plan for failure and make sure that my heating system can operate on a basic level when Home Assistant and even Wi-Fi are down. It&#39;s also impractical to try and build a complex system right off the bat. I better start with something simple, and then iterate to add complexity.</p><p>The most self-contained way to measure room temperature that will be resilient to network failure is to connect a temperature sensor to the thermostat itself. So it&#39;s time to connect a sensor to one of the temperature connectors that I left on the board and add some more ESPHome configuration (I omitted all the screw-in temperature sensors for the sake of simplicity):</p><pre><code># Temperature sensor hub
dallas:
  - pin: GPIO18
    update_interval: 30s

sensor:
  # [.. boiler sensors omitted ..]
  
  # Temperature sensors
  - platform: dallas
    address: 0x2001229265635128
    name: &#34;Room Temperature&#34;
    id: boilotron_temp_room
    accuracy_decimals: 2
    filters:
      - sliding_window_moving_average:
          window_size: 5 # Average over this number of last measurements
          send_every: 2 # When sensor update interval is 30s, new value will be pushed every minute 
      # PID controller updates its parameters only on sensor signal, so we push the last value every second
      # We don&#39;t want to actually read the sensor temperature every second, since it would hurt performance.
      - heartbeat: 1s</code></pre><p>First of all, I declared a <code>dallas</code> component, which contains pin number for all the temperature sensors that are daisy-chained on a single 1-Wire bus. I also set <code>update_interval</code> so that all sensors on that bus will be polled once every 30 seconds. I wouldn&#39;t recommend decreasing this interval by much, since 1-Wire communication seems to hurt performance and even interfere with OpenTherm protocol (more on this in a separate post).</p><p>Next I setup individual temperature sensors. It&#39;s important to note that this configuration goes into the existing <code>sensor</code> section, where I placed some OpenTherm sensors earlier. The most important here is sensor address. You can find out your sensor addresses by temporarily setting <code>logger</code> <code>level</code> to <code>DEBUG</code> and rebooting your device. ESPHome will print out addresses of all found sensors, so in order to determine an individual address you need to connect your sensors one by one and reboot after each new sensor is connected.</p><p>I also want to add several filters to this particular sensor. I&#39;m going to use a PID controller to calculate target <code>t_set</code> temperature based on <code>boilotron_temp_room</code> temperature and there is a couple of considerations here:</p><ol><li>Digital temperature sensors can be rather noisy. For example, you can observe random small changes from one measurement to the next. These are OK when you just print your temperature reading to a dashboard, but for a PID controller every input change is a trigger to adjust the control signal. Such noise doesn&#39;t reflect well on the resulting signal, so you typically want to make your  temperature readings smoother. That&#39;s why I added a <code>sliding_window_moving_average</code> filter which does just that: it takes last 5 measurements, averages them, and reports every other one to ESPHome. So if my <code>update_interval</code> is 30 seconds, every minute I will get a new measurement averaged over last 2.5 minutes. These values are eyeballed empirically and you might need different values based on how your particular sensors behave.</li><li>PID controller output is adjusted only when new input value is received. PID controller works is by making small changes to current output value, so pushing a new input each minute will be ineffective: we would wait for a very long time for <code>t_set</code> to change even a little bit. To combat that I apply a <code>heartbeat</code> filter to my temperature sensor. It remembers last known temperature reading and pushes it out every second. So effectively I will drive my PID controller every second with the same input, and each minute that input has a chance of updating if room temperature actually changes enough to go through the sliding average filter.</li></ol><p>I know, all these settings seem a bit arbitrary ‚Äî that&#39;s because they are. Finding the right combination of filters and coefficients took me some time of just running this system and staring at Home Assistant dashboard. If you try to reproduce this design, you might get lucky and these numbers work for you too. If they don&#39;t ‚Äî don&#39;t despair, you can probably tune it to your environment in a couple of hours üòÉ</p><h3 id="adding-pid-control">Adding PID control</h3><p>OK, this is a super long post already, but bear with me ‚Äî we are almost there. It&#39;s time to put all these things together by adding a PID controller. It will take room temperature as an input and output a single number in range of <code>[0..1]</code>, which is then scaled to fit the range of <code>[min_value..max_value]</code> in our <code>t_set</code> component.</p><p>The most useful example to help you understand a PID controller is cruise control in a car. You tell the car its desired speed and an onboard computer slowly tunes fuel intake and other parameters to reach that speed over a period of time. It&#39;s important to understand that no control system reaches its target instantaneously (you can&#39;t accelerate from 0 to 100 in 0 seconds) and it&#39;s usually not desirable to change control signals by large amount (you can shift from first to fourth gear, but you car won&#39;t thank you). </p><p>PID  controller is a vital part of large and complex fields of control theory and industrial automation. People actually get degrees in this stuff, and that&#39;s exactly what I did more than a decade ago üòÄ But the truth is that most of this theoretical apparatus is very rarely used and people are just eyeballing the coefficients, even at serious establishments like oil refineries and nuclear plants. If you want to dive deeper into the theory, I suggest starting at <a href="https://esphome.io/components/climate/pid?ref=olegtarasov.me" rel="noreferrer">ESPHome documentation for PID controller</a>. It&#39;s a good idea to understand how it works in detail, but it&#39;s not required right away. You can try my values and see if they make sense in your environment.</p><p>Here is how I configure a PID controller:</p><pre><code>climate:
  - platform: pid
    id: boilotron_boiler_pid
    name: &#34;Central heating&#34;
    heat_output: boilotron_ch_setpoint
    default_target_temperature: 23
    sensor: boilotron_temp_room
    visual:
      min_temperature: 15
      max_temperature: 30
      temperature_step:
        target_temperature: 0.5
        current_temperature: 0.1
    control_parameters: 
      kp: 0.76394
      ki: 0.00050
      kd: 0 # Derivative term reacts too much to small changes in temperature, effectively turning off the boiler while target temperature is still far
      output_averaging_samples: 10
    deadband_parameters:
      threshold_high: 0.5
      threshold_low: -0.5
      # Will try to turn off any control signal inside the deadband in order to minimize flame jerking
      kp_multiplier: 0   # Added proportional gain since integral alone doesn&#39;t seem to fall fast enough when target is reached (but removed again after changing min feed temperature to 40 deg)
      ki_multiplier: 0.15  # integral accumulates at only 20% of normal ki
      kd_multiplier: 0.0   # derviative is turned off inside deadband
      deadband_output_averaging_samples: 15   # average the output over 15 samples within the deadband</code></pre><p>The most important settings are these:</p><ul><li><code>sensor</code> ‚Äî this is the input that is used to calculate the control signal. I put <code>boilotron_temp_room</code> there to point to my temperature sensor.</li><li><code>heat_output</code> ‚Äî the component that I want to control. I put <code>boilotron_ch_setpoint</code> there to control <code>t_set</code> value.</li><li><code>default_target_temperature</code> ‚Äî default temperature that I would like to have in my room. This is a starting point, and I can change target temperature in home Assistant UI later.</li></ul><p>There is a <code>visual</code> section that configures how the component will render in Home Assistant UI. I put some sensible boundaries on target temperature and adjust step size.</p><p><code>control_parameters</code> and <code>deadband_parameters</code> sections contain the actual coefficients that are used for PID control algorithm. In ideal world of control theory you would use complicated methods to measure you particular system&#39;s response to various control signals, maybe solve a couple of partial differential equations and arrive at perfect values that work for you flawlessly. But in the real world these methods are seldomly used and you can try to reuse my values as they are. </p><p>The main idea here is that PID regulator outputs lower temperature when room temperature is close to target, and higher temperature if it&#39;s further from target. For example, if my target is 23¬∞ and current room temperature is 22.7¬∞, PID controller might output 40¬∞, which is the lower bound in <code>t_set</code> component, heating my radiators just a little bit so that target temperature is reached slowly without little overshoot. But if my current temperature is 19¬∞, the controller will likely output 60¬∞ in order to make radiators go full blast and heat the room faster.</p><h3 id="uploading-the-firmware">Uploading the firmware</h3><p>After all this was done I compiled and uploaded new firmware to my device wirelessly using the ‚ÄûInstall‚Äù button in ESPHome dashboard. After a couple of seconds, my device showed up in Home Assistant device list and this is roughly what I see if I open it:</p><figure><img src="https://olegtarasov.me/content/images/2024/04/image-1.png" alt="" loading="lazy" width="2000" height="1387" srcset="https://olegtarasov.me/content/images/size/w600/2024/04/image-1.png 600w, https://olegtarasov.me/content/images/size/w1000/2024/04/image-1.png 1000w, https://olegtarasov.me/content/images/size/w1600/2024/04/image-1.png 1600w, https://olegtarasov.me/content/images/2024/04/image-1.png 2122w" sizes="(min-width: 720px) 720px"/></figure><p>If I click on ‚ÄûCentral Heating‚Äù, I get a nice Home Assistant thermostat UI:</p><figure><img src="https://olegtarasov.me/content/images/2024/04/Xnip2024-04-12_22-37-04.png" alt="" loading="lazy" width="582" height="609"/></figure><p>Now I can add some of these items to my dashboard and control my heating system from my phone!</p><h2 id="conclusion">Conclusion</h2><p>This turned out to be a much larger post than I anticipated. I didn&#39;t cover a lot of topics like adding an LCD display or rewriting half of the OpenTherm library. Stay tuned for more posts with hairy details üòÉ</p>
    </div></div>
  </body>
</html>
