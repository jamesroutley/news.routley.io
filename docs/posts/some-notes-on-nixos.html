<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2024/01/01/some-notes-on-nixos/">Original</a>
    <h1>Some notes on NixOS</h1>
    
    

<p>Hello! Over the holidays I decided it might be fun to run NixOS on one of my
servers, as part of my continuing experiments with Nix.</p>

<p>My motivation for this was that previously I was using <a href="https://www.ansible.com/">Ansible</a> to
provision the server, but then I&rsquo;d ad hoc installed a bunch of stuff on the
server in a chaotic way separately from Ansible, so in the end I had no real
idea of what was on that server and it felt like it would be a huge pain to
recreate it if I needed to.</p>

<p>This server just runs a few small personal Go services, so it seemed like a
good candidate for experimentation.</p>

<p>I had trouble finding explanations of how to set up NixOS and I needed to
cobble together instructions from a bunch of different places, so here&rsquo;s a
very short summary of what worked for me.</p>

<h3 id="why-nixos-instead-of-ansible">why NixOS instead of Ansible?</h3>

<p>I think the reason NixOS feels more reliable than Ansible to me is that NixOS <strong>is</strong>
the operating system. It has full control over all your users and services and
packages, and so it&rsquo;s easier for it to reliably put the system into the state
you want it to be in.</p>

<p>Because Nix has so much control over the OS, I think that if I tried to make
any ad-hoc changes at all to my Nix system, Nix would just blow them away the
next time I ran <code>nixos-rebuild</code>. But with Ansible, Ansible only controls a few
small parts of the system (whatever I explicitly tell it to manage), so it&rsquo;s
easy to make changes outside Ansible.</p>

<p>That said, here&rsquo;s what I did to set up NixOS on my server and run a Go service on it.</p>

<h3 id="step-1-install-nixos-with-nixos-infect">step 1: install NixOS with nixos-infect</h3>

<p>To install NixOS, I created a new Hetzner instance running Ubuntu, and then ran <a href="https://github.com/elitak/nixos-infect/tree/master#hetzner-cloud">nixos-infect</a> on it to convert the Ubuntu installation into a NixOS install, like this:</p>

<pre><code>curl https://raw.githubusercontent.com/elitak/nixos-infect/master/nixos-infect | PROVIDER=hetznercloud NIX_CHANNEL=nixos-23.11 bash 2&gt;&amp;1 | tee /tmp/infect.log
</code></pre>

<p>I originally tried to do this on DigitalOcean, but it didn&rsquo;t work for some
reason, so I went with Hetzner instead and that worked.</p>

<p>This isn&rsquo;t the only way to install NixOS (<a href="https://nixos.wiki/wiki/NixOS_friendly_hosters">this wiki page</a> lists options for setting up NixOS cloud servers), but it seemed to work.
It&rsquo;s possible that there are problems with installing that way that I don&rsquo;t
know about though. It does feel like using an ISO is probably better because that way you don&rsquo;t have to do this transmogrification of Ubuntu into NixOS.</p>

<p>I definitely skipped Step 1 in <code>nixos-infect</code>&rsquo;s README (&ldquo;Read and understand
<a href="https://github.com/elitak/nixos-infect/blob/master/nixos-infect">the script</a>&rdquo;), but I didn&rsquo;t feel too worried because I was running it on a
new instance and I figured that if something went wrong I&rsquo;d just delete it.</p>

<h3 id="step-2-copy-the-generated-nix-configuration">step 2: copy the generated Nix configuration</h3>

<p>Next I needed to copy the generated Nix configuration to a new local Git
repository, like this:</p>

<pre><code>scp root@SERVER_IP:/etc/nixos/* .
</code></pre>

<p>This copied 3 files: <code>configuration.nix</code>, <code>hardware-configuration.nix</code>, and <code>networking.nix</code>. <code>configuration.nix</code> is the main file. I didn&rsquo;t touch anything in <code>hardware-configuration.nix</code> or <code>networking.nix</code>.</p>

<h3 id="step-3-create-a-flake">step 3: create a flake</h3>

<p>I created a flake to wrap <code>configuration.nix</code>. I don&rsquo;t remember why I did this
(I have some idea of what the advantages of flakes are, but it&rsquo;s not clear to
me if any of them are actually relevant in this case) but it seems to work. Here&rsquo;s
my <code>flake.nix</code>:</p>

<pre><code>{ inputs.nixpkgs.url = &quot;github:NixOS/nixpkgs/23.11&quot;;

  outputs = { nixpkgs, ... }: {
    nixosConfigurations.default = nixpkgs.lib.nixosSystem {
      system = &quot;x86_64-linux&quot;;

      modules = [ ./configuration.nix ];
    };
  };
}
</code></pre>

<p>The main gotcha about flakes that I needed to remember here was that you need
to <code>git add</code> every <code>.nix</code> file you create otherwise Nix will pretend it doesn&rsquo;t
exist.</p>

<p>The rules about git and flakes seem to be:</p>

<ul>
<li>you do need to <code>git add</code> your files</li>
<li>you <strong>don&rsquo;t</strong> need to commit your changes</li>
<li>unstaged changes to files are also fine, as long as the file has been <code>git add</code>ed</li>
</ul>

<p>These rules feel very counterintuitive to me (why require that you <code>git add</code>
files but allow unstaged changes?) but that&rsquo;s how it works. I think it might be
an optimization because Nix has to copy all your <code>.nix</code> files to the Nix store for some
reason, so only copying files that have been <code>git add</code>ed makes the copy faster.</p>

<h3 id="step-4-figure-out-how-to-deploy-my-configuration">step 4: figure out how to deploy my configuration</h3>

<p>Next I needed to figure out how to deploy changes to my configuration.  There are a bunch
of tools for this, but I found the blog post <a href="https://www.haskellforall.com/2023/01/announcing-nixos-rebuild-new-deployment.html">Announcing nixos-rebuild: a &ldquo;new&rdquo; deployment tool for NixOS</a>
that said you can just use the built-in <code>nixos-rebuild</code>, which has
<code>--target-host</code> and <code>--build-host</code> options so that you can specify which host
to build on and deploy to, so that&rsquo;s what I did.</p>

<p>I wanted to be able to get Go repositories and build the Go code on the target
host, so I created a bash script that runs this command:</p>

<pre><code>nixos-rebuild switch --fast --flake .#default --target-host my-server --build-host my-server --option eval-cache false
</code></pre>

<p>This <code>--option eval-cache false</code> is because Nix kept not showing me my errors
because they were cached &ndash; it would just say <code>error: cached failure of
attribute 'nixosConfigurations.default.config.system.build.toplevel'</code> instead
of showing me the actual error message. Setting <code>--option eval-cache false</code>
turned off caching so that I could see the error messages.</p>

<p>Now I could run <code>bash deploy.sh</code> on my laptop and deploy my configuration to the server! Hooray!</p>

<h3 id="step-5-update-my-ssh-config">step 5: update my ssh config</h3>

<p>I also needed to set up a <code>my-server</code> host in my <code>~/.ssh/config</code>. I set up SSH
agent forwarding so that the server could download the private Git repositories
it needed to access.</p>

<pre><code>Host my-server
   Hostname MY_IP_HERE
   User root
   Port 22
   ForwardAgent yes

AddKeysToAgent yes
</code></pre>

<h3 id="step-6-set-up-a-go-service">step 6: set up a Go service</h3>

<p>The thing I found the hardest was to figure out how to compile and configure a
Go web service to run on the server. The norm seems to be to define your package and define your
service&rsquo;s configuration in 2 different files, but I didn&rsquo;t feel like doing that
&ndash; I wanted to do it all in one file. I couldn&rsquo;t find a simple example of how
to do this, so here&rsquo;s what I did.</p>

<p>I&rsquo;ve replaced the actual repository name with <code>my-service</code> because it&rsquo;s a
private repository and you can&rsquo;t run it anyway.</p>

<pre><code>{ pkgs ? (import &lt;nixpkgs&gt; { }), lib, stdenv, ... }: 
let myservice = pkgs.callPackage pkgs.buildGoModule {
  name = &quot;my-service&quot;;
  src = fetchGit {
    url = &quot;git@github.com:jvns/my-service.git&quot;;
    rev = &quot;efcc67c6b0abd90fb2bd92ef888e4bd9c5c50835&quot;; # put the right git sha here
  };
  vendorHash = &quot;sha256-b+mHu+7Fge4tPmBsp/D/p9SUQKKecijOLjfy9x5HyEE&quot;; # nix will complain about this and tell you the right value
}; in { 
  services.caddy.virtualHosts.&quot;my-service.example.com&quot;.extraConfig = ''
    reverse_proxy localhost:8333
  '';

  systemd.services.my-service = {
    enable = true;
    description = &quot;my-service&quot;;
    after = [&quot;network.target&quot;];
    wantedBy = [&quot;multi-user.target&quot;];
    script = &quot;${myservice}/bin/my-service&quot;;
    environment = {
      DB_FILENAME = &quot;/var/lib/my-service/db.sqlite&quot;;
    };
    serviceConfig = {
      DynamicUser = true;
      StateDirectory = &quot;my-service&quot;; # /var/lib/my-service
    };
  };
}
</code></pre>

<p>Then I just needed to do 2 more things:</p>

<ol>
<li>add <code>./my-service.nix</code> to the imports section of <code>configuration.nix</code></li>
<li>add <code>services.caddy.enable = true;</code> to <code>configuration.nix</code> to enable Caddy</li>
</ol>

<p>and everything worked!!</p>

<p>Some notes on this service configuration file:</p>

<ol>
<li>I used <code>extraConfig</code> to configure Caddy because I didn&rsquo;t feel like learning
Nix&rsquo;s special Caddy syntax &ndash; I wanted to just be able to refer to the Caddy
documentation directly.</li>
<li>I used systemd&rsquo;s <code>DynamicUser</code> to create a user dynamically to run the
service. I&rsquo;d never used this before but it seems like a great simple way to
create a different user for every service without having to write a bunch of
repetitive boilerplate and being really careful to choose unique UID and
GIDs. The blog post <a href="https://0pointer.net/blog/dynamic-users-with-systemd.html">Dynamic Users with systemd</a> talks
about how it works.</li>
<li>I used <code>StateDirectory</code> to get systemd to create a persistent directory where I could store a SQLite database. It creates a directory at <code>/var/lib/my-service/</code></li>
</ol>

<p>I&rsquo;d never heard of <code>DynamicUser</code> or <code>StateDirectory</code> before Kamal told me about
them the other day but they seem like cool systemd features and I wish
I&rsquo;d known about them earlier.</p>

<h3 id="why-caddy">why Caddy?</h3>

<p>One quick note on <a href="https://caddyserver.com/">Caddy</a>: I switched to Caddy a while back from nginx
because it automatically sets up Let&rsquo;s Encrypt certificates. I&rsquo;ve only been
using it for tiny hobby services, but it seems pretty great so far for that,
and its configuration language is simpler too.</p>

<h3 id="problem-fetchtree-requires-a-locked-input">problem: &ldquo;fetchTree requires a locked input&rdquo;</h3>

<p>One problem I ran into was this error message:</p>

<pre><code>error: in pure evaluation mode, 'fetchTree' requires a locked input, at «none»:0
</code></pre>

<p>I found this really perplexing &ndash; what is <code>fetchTree</code>? What is <code>«none»:0</code>? What did I do wrong?</p>

<p>I learned 4 things from debugging this (with help from the folks in the Nix discord):</p>

<ol>
<li>In Nix, <code>fetchGit</code> calls an internal function called <code>fetchTree</code>. So errors that say <code>fetchTree</code> might actually be referring to <code>fetchGit</code>.</li>
<li>Nix truncates long stack traces by default. Sometimes you can get more information with <code>--show-trace</code>.</li>
<li>It seems like Nix doesn&rsquo;t always give you the line number in your code which caused the error, even if you use <code>--show-trace</code>. I&rsquo;m not sure why this is.</li>
<li>Like I mentioned before, you can pass <code>--option eval-cache false</code> to turn off caching so that Nix will always show you the error message instead of <code>error: cached failure of attribute 'nixosConfigurations.default.config.system.build.toplevel'</code></li>
</ol>

<p>Ultimately the problem turned out to just be that I forgot to pass the Github
revision ID (<code>rev = &quot;efcc67c6b0abd90fb2bd92ef888e4bd9c5c50835&quot;;</code>) to <code>fetchGit</code>
which was really easy to fix.</p>

<h3 id="nix-syntax-is-still-pretty-confusing-to-me">nix syntax is still pretty confusing to me</h3>

<p>I still don&rsquo;t really understand the nix language syntax that well, but I
haven&rsquo;t felt motivated to get better at it yet &ndash; I guess learning new language
syntax just isn&rsquo;t something I find fun. Maybe one day I&rsquo;ll learn it. My plan
for now with NixOS is to just keep copying and pasting that <code>my-service.nix</code>
file above forever.</p>

<h3 id="some-questions-i-still-have">some questions I still have</h3>

<p>I think my main outstanding questions are:</p>

<ul>
<li>When I run <code>nixos-rebuild</code>, Nix checks that my systemd services are still
working in some way. What does it check exactly? My best guess is that it
checks that the systemd service <strong>starts</strong> successfully, but if the service
starts and then immediately crashes, it won&rsquo;t notice.</li>
<li>Right now to deploy a new version of one of my services, I need to manually
copy and paste the Git SHA of the new revision. There&rsquo;s probably a better
workflow but I&rsquo;m not sure what it is.</li>
</ul>

<h3 id="that-s-all">that&rsquo;s all!</h3>

<p>I really do like having all of my service configuration defined in one file,
and the approach Nix takes does feel more reliable than the approach I was
taking with Ansible.</p>

<p>I just started doing this a week ago and as with all things Nix I have no idea
if I&rsquo;ll end up liking it or not. It seems pretty good so far though!</p>

<p>I will say that I find using Nix to be very difficult and I really struggle
when debugging Nix problems (that <code>fetchTree</code> problem I mentioned sounds
simple, but it was SO confusing to me at the time), but I kind of like it
anyway. Maybe because I&rsquo;m not using Linux on my laptop right now I miss having
<a href="https://fabiensanglard.net/a_linux_evening/">linux evenings</a> and Nix feels
like a replacement for that :)</p>

  </body>
</html>
