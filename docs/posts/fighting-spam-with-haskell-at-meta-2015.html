<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2015/06/26/security/fighting-spam-with-haskell/">Original</a>
    <h1>Fighting spam with Haskell at Meta (2015)</h1>
    
    <div id="readability-page-1" class="page"><div>

		<p>One of our weapons in the fight against spam, malware, and other abuse on Facebook is a system called Sigma. Its job is to proactively identify malicious actions on Facebook, such as spam, phishing attacks, posting links to malware, etc. Bad content detected by Sigma is removed automatically so that it doesn’t show up in your News Feed.</p>
<p>We recently completed a two-year-long major redesign of Sigma, which involved replacing the <a href="https://www.facebook.com/notes/facebook-engineering/fighting-spam-with-pure-functions/10151254986618920"> in-house FXL language</a> previously used to program Sigma with <a href="http://www.haskell.org/">Haskell</a>. The Haskell-powered Sigma now runs in production, serving more than one million requests per second.</p>
<p>Haskell isn’t a common choice for large production systems like Sigma, and in this post, we’ll explain some of the thinking that led to that decision. We also wanted to share the experiences and lessons we learned along the way. We made several improvements to GHC (the Haskell compiler) and fed them back upstream, and we were able to achieve better performance from Haskell compared with the previous implementation.</p>
<h2>How does Sigma work?</h2>
<p>Sigma is a <em>rule engine</em>, which means it runs a set of rules, called policies. Every interaction on Facebook — from posting a status update to clicking “like” — results in Sigma evaluating a set of policies specific to that type of interaction. These policies make it possible for us to identify and block malicious interactions before they affect people on Facebook.</p>
<p>Policies are continuously deployed. At all times, the source code in the repository is the code running in Sigma, allowing us to move quickly to deploy policies in response to new abuses. This also means that safety in the language we write policies in is important. We don’t allow code to be checked into the repository unless it is type-correct.</p>
<p><iframe src="https://youtube.com/embed/UMbc6iyH-xQ" width="500" height="281" frameborder="0"></iframe></p>
<p><em>Louis Brandy of Facebook’s Site Integrity team discusses scalable spam fighting and the anti-abuse structure at Facebook and Instagram in a 2014 <a href="https://engineering.fb.com/posts/1572237063054093/save-the-date-the-2015-scale-conference/">@Scale</a> talk.</em></p>
<h2>Why Haskell?</h2>
<p>The original language we designed for writing policies, FXL, was not ideal for expressing the growing scale and complexity of Facebook policies. It lacked certain abstraction facilities, such as user-defined data types and modules, and its implementation, based on an interpreter, was slower than we wanted. We wanted the performance and expressivity of a fully fledged programming language. Thus, we decided to migrate to an existing language rather than try to improve FXL.</p>
<p>The following features were at the top of our list when we were choosing a replacement:</p>
<p>1. <strong>Purely functional and strongly typed.</strong> This ensures that policies can’t inadvertently interact with each other, they can’t crash Sigma, and they are easy to test in isolation. Strong types help eliminate many bugs before putting policies into production.</p>
<p>2. <strong>Automatically batch and overlap data fetches.</strong> Policies typically fetch data from other systems at Facebook, so we want to employ concurrency wherever possible for efficiency. We want concurrency to be implicit, so that engineers writing policies can concentrate on fighting spam and not worry about concurrency. Implicit concurrency also prevents the code from being cluttered with efficiency-related details that would obscure the functionality, and make the code harder to understand and modify.</p>
<p>3. <strong>Push code changes to production in minutes.</strong> This enables us to deploy new or updated policies quickly.</p>
<p>4. <strong>Performance.</strong> FXL’s slower performance meant that we were writing anything performance-critical in C++ and putting it in Sigma itself. This had a number of drawbacks, particularly the time required to roll out changes.</p>
<p>5. <strong>Support for interactive development.</strong> Developers working on policies want to be able to experiment and test their code interactively, and to see the results immediately.</p>
<p><a href="http://www.haskell.org/">Haskell</a> measures up quite well: It is a purely functional and strongly typed language, and it has a mature optimizing compiler and an interactive environment (GHCi). It also has all the abstraction facilities we would need, it has a rich set of libraries available, and it’s backed by an active developer community.</p>
<p>That left us with two features from our list to address: (1) automatic batching and concurrency, and (2) hot-swapping of compiled code.</p>
<h2>Automatic batching and concurrency: The Haxl framework</h2>
<p>All the existing concurrency abstractions in Haskell are explicit, meaning that the user needs to say which things should happen concurrently. For data-fetching, which can be considered a purely functional operation, we wanted a programming model in which the system just exploits whatever concurrency is available, without the programmer having to use explicit concurrency constructs. We developed the Haxl framework to address this issue: Haxl enables multiple data-fetching operations to be automatically batched and executed concurrently.</p>
<p>We discussed Haxl in <a href="https://engineering.fb.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/">an earlier blog post</a>, and we published a <a href="https://research.facebook.com/publications/251014561758092/there-is-no-fork-an-abstraction-for-efficient-concurrent-and-concise-data-access/">paper on Haxl</a> at the ICFP 2014 conference. Haxl is open source and available on <a href="https://github.com/facebook/Haxl">GitHub</a>.</p>
<p>In addition to the Haxl framework, we needed help from the Haskell compiler in the form of the <a href="https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo">Applicative do-notation</a>. This allows programmers to write sequences of statements that the compiler automatically rearranges to exploit concurrency. We also designed and implemented Applicative do-notation in GHC.</p>
<h2>Hot-swapping of compiled code</h2>
<p>Every time someone checks new code into the repository of policies, we want to have that code running on every machine in the Sigma fleet as quickly as possible. Haskell is a compiled language, so that involves compiling the code and distributing the new compiled code to all the machines running Sigma.</p>
<p>We want to update the compiled rules in a running Sigma process on the fly, while it is serving requests. Changing the code of a running program is a tricky problem in general, and it has been the subject of a great deal of research in the academic community. In our case, fortunately, the problem is simpler: Requests to Sigma are short-lived, so we don’t need to switch a running request to new code. We can serve new requests on the new code and let the existing requests finish before we discard the old code. We’re careful to ensure that we don’t change any code associated with persistent state in Sigma.</p>
<p>Loading and unloading code currently uses GHC’s built-in runtime linker, although in principle, we could use the system dynamic linker. To unload the old version of the code, the <a href="https://phabricator.haskell.org/rGHCbdfefb3b72a71cd0afca6e7766456c0d97c47c86">garbage collector gets involved</a>. The garbage collector detects when old code is no longer being used by a running request, so we know when it is safe to unload it from the running process.</p>
<h2>How Haskell fits in</h2>
<p>Haskell is sandwiched between two layers of C++ in Sigma. At the top, we use the C++ thrift server. In principle, Haskell can act as a thrift server, but the C++ thrift server is more mature and performant. It also supports more features. Furthermore, it can work seamlessly with the Haskell layers below because we can call into Haskell from C++. For these reasons, it made sense to use C++ for the server layer.</p>
<p>At the lowest layer, we have existing C++ client code for talking to other internal services. Rather than rewrite this code in Haskell, which would duplicate the functionality and create an additional maintenance burden, we wrapped each C++ client in a Haxl data source using Haskell’s Foreign Function Interface (FFI) so we could use it from Haskell.</p>
<p>Haskell’s FFI is designed to call C rather than C++, so calling C++ requires an intermediate C layer. In most cases, we were able to avoid the intermediate C layer by using a compile-time tool that demangles C++ function names so they can be called directly from Haskell.</p>
<h2>Performance</h2>
<p>Perhaps the biggest question here is “Does it run fast enough?” Requests to Sigma result from users performing actions on Facebook, such as sending a message on Messenger, and Sigma must respond before the action can take place. So we wanted to serve requests fast enough to avoid interruptions to the user experience.</p>
<p>The graph below shows the relative throughput performance between FXL and Haskell for the 25 most common types of requests served by Sigma (these requests account for approximately 95 percent of Sigma’s typical workload).</p>
<p><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2015/06/GKsHrgBMRytm82gBAHg6LDAAAAAAbj0JAAAD.png" width="1478" height="804"/></p>
<p>Haskell performs as much as three times faster than FXL for certain requests. On a typical workload mix, we measured a 20 percent to 30 percent improvement in overall throughput, meaning we can serve 20 percent to 30 percent more traffic with the same hardware. We believe additional improvements are possible through performance analysis, tuning, and optimizing the GHC runtime for our workload.</p>
<p>Achieving this level of performance required a lot of hard work, profiling the Haskell code, and identifying and resolving performance bottlenecks.</p>
<p>Here are a few specific things we did:</p>
<ul>
<li>We implemented automatic memoization of top-level computations using a source-to-source translator. This is particularly beneficial in our use-case where multiple policies can refer to the same shared value, and we want to compute it only once. Note, this is per-request memoization rather than global memoization, which lazy evaluation already provides.</li>
<li>We made a <a href="https://phabricator.haskell.org/rGHC452eb80f15fce8665df52bc9facebfafb5b6267b">change to the way GHC manages the heap</a>, to reduce the frequency of garbage collections on multicore machines. GHC’s default heap settings are frugal, so we also use a larger allocation area size of at least 64 MB per core.</li>
<li>Fetching remote data usually involves marshaling the data structure across the C++/Haskell boundary. If the whole data structure isn’t required, it is better to marshal only the pieces needed. Or better still, don’t fetch the whole thing — although that’s only possible if the remote service implements an appropriate API.</li>
<li>We uncovered a nasty performance bug in aeson, the Haskell JSON parsing library. Bryan O’Sullivan, the author of aeson, wrote a nice <a href="http://www.serpentine.com/blog/2015/05/13/sometimes-the-old-ways-are-the-best/">blog post</a> about how he fixed it. It turns out that when you do things at Facebook scale, those one-in-a-million corner cases tend to crop up all the time.</li>
</ul>
<h2>Resource limits</h2>
<p>In a latency-sensitive service, you don’t want a single request using a lot of resources and slowing down other requests on the same machine. In this case, the “resources” include everything on the machine that is shared by the running requests — CPU, memory, network bandwidth, and so on.</p>
<p>A request that uses a lot of resources is normally a bug that we want to fix. It does happen from time to time, often as a result of a condition that occurs in production that wasn’t encountered during testing — perhaps an innocuous operation provided with some unexpectedly large input data, or pathological performance of an algorithm on certain rare inputs, for example. When this happens, we want Sigma to terminate the affected request with an error (that will subsequently result in the bug being fixed) and continue without any impact on the performance of other requests being served.</p>
<p>To make this possible, we implemented <a href="https://phabricator.haskell.org/rGHCb0534f78a73f972e279eed4447a5687bd6a8308e"><em>allocation limits</em></a> in GHC, which places a bound on the amount of memory a thread can allocate before it is terminated. Terminating a computation safely is a hard problem in general, but Haskell provides a safe way to abort a computation in the form of asynchronous exceptions. Asynchronous exceptions allow us to write most of most of our code ignoring the potential for summary termination and still have all the nice guarantees that we need in the event that the limit is hit, including safe releasing of resources, closing network connections, and so forth.</p>
<p>The following graph illustrates of how well allocation limits work in practice. It tracks the maximum live memory across various groups of machines in the Sigma fleet. When we enabled one request that had some resource-intensive outliers, we saw large spikes in the maximum live memory, which disappeared when we enabled allocation limits.</p>
<p><img loading="lazy" decoding="async" src="https://engineering.fb.com/wp-content/uploads/2015/06/GFYrrgADt1EErF8BAKkwXXAAAAAAbj0JAAAB.jpg" width="736" height="433"/></p>
<h2>Enabling interactive development</h2>
<p>Facebook engineers develop policies interactively, testing code against real data as they go. To enable this workflow in Haskell, we needed the GHCi environment to work with our full stack, including making requests to other back-end services from the command line.</p>
<p>To make this work, we had to make our build system link all the C++ dependencies of our code into a shared library that GHCi could load. We also customized the GHCi front end to implement some of our own commands and streamline the desired workflows. The result is an interactive environment in which developers can load their code from source in a few seconds and work on it with a fast turnaround time. They have the full set of APIs available and can test against real production data sources.</p>
<p>While GHCi isn’t as easy to customize as it could be, we’ve already made several improvements and contributed them upstream. We hope to make more improvements in the future.</p>
<h2>Packages and build systems</h2>
<p>In addition to GHC itself, we make use of a lot of open-source Haskell library code. Haskell has its own packaging and build system, Cabal, and the open-source packages are all hosted on <a href="http://hackage.haskell.org/">Hackage</a>. The problem with this setup is that the pace of change on Hackage is fast, there are often breakages, and not all combinations of packages work well together. The system of version dependencies in Cabal relies too much on package authors getting it right, which is hard to ensure, and the tool support isn’t what it could be. We found that using packages directly from Hackage together with Facebook’s internal build tools meant adding or updating an existing package sometimes led to a <a href="http://en.wiktionary.org/wiki/yak_shaving">yak-shaving exercise</a> involving a cascade of updates to other packages, often with an element of trial and error to find the right version combinations.</p>
<p>As a result of this experience, we switched to <a href="https://www.stackage.org/">Stackage</a> as our source of packages. Stackage provides a set of package versions that are known to work together, freeing us from the problem of having to find the set by trial and error.</p>
<h2>Did we find bugs in GHC?</h2>
<p>Yes, most notably:</p>
<ul>
<li>We fixed a <a href="https://phabricator.haskell.org/rGHCa11f71eff15ba2706cbb2ee29aaf7350909e0d2f">bug</a> in GHC’s garbage collector that was causing our Sigma processes to crash every few hours. The bug had gone undetected in GHC for several years.</li>
<li>We fixed a <a href="https://phabricator.haskell.org/rGHCdfdc50d666498c5a1118557d67209fe067c61cc1">bug</a> in GHC’s handling of finalizers that occasionally caused crashes during process shutdown.</li>
</ul>
<p>Following these fixes, we haven’t seen any crashes in either the Haskell runtime or the Haskell code itself across our whole fleet.</p>
<h2>What else?</h2>
<p>At Facebook, we’re using Haskell at scale to fight spam and other types of abuse. We’ve found it to be reliable and performant in practice. Using the Haxl framework, our engineers working on spam fighting can focus on functionality rather than on performance, while the system can exploit the available concurrency automatically.</p>
<p>For more information on spam fighting at Facebook, check out our <a href="http://www.facebook.com/protectthegraph">Protect the Graph</a> page, or watch videos from our recent <a href="https://engineering.fb.com/posts/1586836328241009/spam-fighting-scale-recap/">Spam Fighting @Scale</a> event.</p>

		
	</div></div>
  </body>
</html>
