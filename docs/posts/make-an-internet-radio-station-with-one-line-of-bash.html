<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://schollz.com/blog/radio/">Original</a>
    <h1>Make an internet radio station with one line of bash</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
        
        <p><img src="https://schollz.com/img/online.jpg"/>
    </p></div>
    
    
    
    
    <p>Use common Linux utilities and a simple server to easily make an internet radio stations that anyone can access.</p>
    <p>For several years I’ve been interested in <em>easily</em> making an internet broadcast of live audio or recorded audio without using social media apps (i.e. Instagram/Youtube/Twitch/etc). The most problematic for me thing about broadcasting audio is port forwarding (I’m often on devices that don’t have access to routers). To solve this problem I wrote a simple server that runs in the cloud which can handle any number of realtime broadcasts uploaded using a simple <code>curl</code> command. This allows you to essentially <a href="#method-1-of-2-broadcasting-with-ffmpeg-one-line-of-code">broadcast radio feeds with a single line</a>.</p>
<h2 id="publicizing-internet-streams-without-port-forwarding">Publicizing internet streams without port forwarding</h2>
<p>For me, the hardest part about making an internet radio is opening it up to the public internet. I don’t have access to port-forwarding in many scenarios where I want to broadcast (i.e. broadcasting from friends places, or from a <a href="https://monome.org/norns">music device</a>). My solution to the problem of broadcasting audio without port-forwarding was to create a free and public “dummy” server that handles any incoming traffic and forwards to any number of connected clients. This server keeps track of connected clients and routes incoming packets to them, otherwise discarding the packets.</p>
<p>You could then simply use a common utility like <code>curl</code> to stream data to this server to those peers. This is essentially what Twitch/Youtube/Instagram do, but I designed a server without any social aspects, its just a dumb URL endpoint that can consume and produce audio streams (or any stream).</p>
<p>The server itself lives at <a href="https://broadcast.schollz.com">broadcast.schollz.com</a>. The code is open-source and available on Github at <a href="https://github.com/schollz/broadcast-server/">schollz/broadcast-server</a>. The code is less than 400 lines, and exceedingly simple. You <code>POST</code> data streams to any endpoint you want, and processing <code>GET</code> requests to that endpoint just return the data in that stream. There are special flags if you want to advertise or archive your stream.</p>
<p>Now using this really dumb server which just lives on a DigitalOcean droplet you can easily create internet streams from anywhere, with anything, using a variety of methods:</p>
<h2 id="method-1-of-2-broadcasting-with-ffmpeg-one-line-of-code">Method 1 of 2: Broadcasting with <code>ffmpeg</code> (one line of code!)</h2>
<p>As I mentioned the above can be done pretty easily with one line. You first need a common Linux utility: <code>ffmpeg</code>. The <code>ffmpeg</code> program will do the conversion and read from live input or files. Forwarding the local stream is done by just piping the output of <code>ffmpeg</code> to the dummy broadcast server (<a href="https://github.com/schollz/broadcast-server">schollz/broadcast</a>).</p>
<h3 id="live-station">Live station</h3>
<p>To make a live internet radio from the input of your computer, you can do it in one line (albeit long line):</p>
<div><pre><code data-lang="bash">ffmpeg -f alsa -i hw:0 -f mp3 - <span>|</span> <span>\
</span><span></span>    curl -s -k -H <span>&#34;Transfer-Encoding: chunked&#34;</span> -X POST -T - <span>\
</span><span></span>    <span>&#34;https://broadcast.schollz.com/YOURSTATIONNAME.mp3?stream=true&amp;advertise=true&#34;</span>
</code></pre></div><p>That one-liner takes input from your default input <code>hw:0</code> and streams it into a <code>POST</code> request to the dummy server making the stream available at <code>broadcast.schollz.com/YOURSTATIONNAME.mp3</code>. Make sure you wear headphones if you create a stream on the same computer you are listening to the stream (because feedback)!</p>
<h3 id="playlist-station">Playlist station</h3>
<p>Creating an internet radio station from a music playlist is also easily done. You need one extra common utility: <code>cstream</code> which will make sure the stream is sent in realtime, so its not loaded into memory. Here’s a one liner that will take any folder and create a randomly shuffled playlist and stream it to the station:</p>
<div><pre><code data-lang="bash">find ~/Music/ <span>|</span> grep <span>&#39;wav\|mp3\|flac&#39;</span> <span>|</span> shuf <span>|</span> sed -e <span>&#34;s/^/file &#39;/&#34;</span> <span>|</span> <span>\
</span><span></span>    sed -e <span>&#34;s/</span>$<span>/&#39;/&#34;</span> &gt; /tmp/playlist.txt <span>&amp;&amp;</span> <span>\
</span><span></span>    ffmpeg -f concat -safe <span>0</span> -i /tmp/playlist.txt -f mp3 -ar <span>44100</span> -b:a 256k - <span>|</span> <span>\
</span><span></span>    cstream -t 32k <span>|</span> <span>\
</span><span></span>    curl -s -k -H <span>&#34;Transfer-Encoding: chunked&#34;</span> -X POST -T -  <span>\
</span><span></span>    <span>&#34;https://broadcast.schollz.com/YOURSTATIONNAME.mp3?stream=true&amp;advertise=true&#34;</span>
</code></pre></div><p>In this case we are streaming at 256 kbps, which is 32 KB/s, so <code>cstream</code> is set to throttle the data to that rate so it transfers in “realtime”.</p>
<h2 id="method-2-of-2-broadcasting-using-icecast2-and-darkice">Method 2 of 2: Broadcasting using <code>icecast2</code> and <code>darkice</code></h2>
<p>The <code>icecast2</code> and <code>darkice</code> utilities are installed via <code>apt-get</code> and really powerful when it comes to streaming. I won’t go into much detail with these two, because there are a lot of guides for it at other places. Here is a <a href="https://maker.pro/raspberry-pi/projects/how-to-build-an-internet-radio-station-with-raspberry-pi-darkice-and-icecast">great guide for doing live radio</a> on a Raspberry Pi.</p>
<p>If you are on Linux, you can also make your entire computer audio part of the stream (i.e. your browser, VLC, etc.). You can do this with JACK. Simply install JACK:</p>
<div><pre><code data-lang="bash">sudo apt install jackd pulseaudio-module-jack 
</code></pre></div><p>Then start JACK and load the sink/source for pulse audio:</p>
<div><pre><code data-lang="bash">jackd -R -dalsa -dhw:0,0 <span>&amp;</span>
pactl load-module module-jack-sink <span>channels</span><span>=</span><span>2</span>
pactl load-module module-jack-source <span>channels</span><span>=</span><span>2</span>
pacmd set-default-sink jack_out
pacmd set-default-source jack_in
</code></pre></div><p>Now start <code>icecast2</code> and <code>darkice</code> with a JACK configuration.</p>
<div><pre><code data-lang="bash">wget https://raw.githubusercontent.com/schollz/broadcast/main/icecast.xml
wget https://raw.githubusercontent.com/schollz/broadcast/main/darkice.cfg
icecast2 -c icecast.xml <span>&amp;</span> 
darkice -c darkice.cfg
</code></pre></div><p>Now simply connect <code>darkice</code> into JACK!</p>
<div><pre><code data-lang="bash">jack_connect <span>&#39;PulseAudio JACK Sink:front-right&#39;</span> darkice:right
jack_connect <span>&#39;PulseAudio JACK Sink:front-left&#39;</span> darkice:left
</code></pre></div><h3 id="making-a-darkice-stream-public">Making a <code>darkice</code> stream public</h3>
<p>Once you have your <code>darkice</code>/<code>icecast2</code> stream, you can make it public by port forwarding. There are lots of guides for that. But another way you could do it is using the dummy broadcast server I mention above. Simply pipe the output from <code>darkice</code> and <code>POST</code> it to the server!</p>
<div><pre><code data-lang="bash">curl http://localhost:8000/radio.mp3 <span>|</span> <span>\
</span><span></span>    curl -H <span>&#34;Transfer-Encoding: chunked&#34;</span> -X POST -T -  <span>\
</span><span></span>    <span>&#39;https://broadcast.schollz.com/YOURSTATIONNAME.mp3?stream=true&#39;</span>
</code></pre></div><p>That’s it! Now your stream will be available at <code>broadcast.schollz.com/YOURSTATIONNAME.mp3</code>.</p>

<p>I do <a href="https://schollz.com/tags/norns/">a lot of projects</a> with the pi-based sound computer called “<a href="https://monome.org/norns/">norns</a>” which lets you define its behavior with scripts and DSP and basically functions as a sample-cutter, polysynth, drum machine, drone box, granulator, etc.</p>
<p>The norns music tool is based in Linux, so the above methods are just as applicable. This means that the norns can be turned into a broadcast station, while retaining all the functionality as a DSP device! Here’s <a href="https://github.com/schollz/broadcast">my little script</a> that converts live audio into a broadcast, directly from your house or live music venue (as long as you have WiFi).</p>
<p><img src="https://schollz.com/img/online.jpg" alt="norns broadcasting internet radio"/></p>
<p>The above norns script uses the <code>darkice</code>/<code>icecast2</code> because it is based around JACK, but it works beautifully despite running on a Raspberry Pi 3+ and simultaneously running a sample-cutter and SuperCollider synthesizers.</p>

    <p>
        <a href="https://schollz.com/blog/radio/">
            <postamble datetime="2022-01-12" 2018-09-04=""><time datetime="2022-01-12 08:00:46">January 12, 2022</time></postamble>
        </a>
         / <a href="https://schollz.com/tags/music">#music</a> <a href="https://schollz.com/tags/software">#software</a> <a href="https://schollz.com/tags/raspberrypi">#raspberrypi</a> 
    </p>
</div></div>
  </body>
</html>
