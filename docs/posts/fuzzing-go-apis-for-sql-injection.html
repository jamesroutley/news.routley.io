<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.fuzzbuzz.io/fuzzing-go-apis-for-sql-injection/">Original</a>
    <h1>Fuzzing Go APIs for SQL Injection</h1>
    
    <div id="readability-page-1" class="page"><div id="___gatsby"><div tabindex="-1" id="gatsby-focus-wrapper"><div data-is-root-path="false"><main><article itemscope="" itemtype="http://schema.org/Article"><section itemprop="articleBody"><p>Fuzzing is a powerful tool that finds subtle bugs and vulnerabilities by running millions of procedurally generated tests on your code. It’s been used to great effect on self-contained pieces of code like parsers and libraries, but can also be incredibly effective when testing larger systems with multiple components.</p>
<p>In this post we’ll walk through some techniques for fuzz testing a REST API written in Go and backed by a SQLite database. With a single test, we’ll simulate how millions of users may interact with our API and uncover SQL injection, logical, and data integrity bugs that would’ve otherwise been shipped to production.</p>
<p><em>Note: This is the third in a series of posts about Go’s new fuzz testing tools. If you’re new to fuzzing with Go, we recommend starting with our <a href="https://blog.fuzzbuzz.io/go-fuzzing-basics">Go Fuzzing Basics post</a> first.</em></p>
<h2>The Case for Fuzzing REST APIs</h2>
<p>The conventional wisdom for fuzzing is to rigorously test all <strong>trust boundaries</strong> in your code. Put simply, any point in your codebase where data is taken from an untrusted source such as a user, and processed by your application is worth fuzzing. REST APIs are some of the largest trust boundaries in modern web apps, and need to be secure from attacks like SQL Injection and Denial of Service, as well as logical state-related issues.</p>
<p>It’s impossible to come up with and build a separate test for every potential user interaction, especially when considering sequences of API calls users can make to put your data model into unexpected states. Fuzzing allows us to write a single test that can generate malicious and destructive API call sequences, covering a wide array of potentially problematic code paths. </p>
<h2>API Project Layout</h2>
<p>Let’s start by taking a quick look at the REST API we’ll be testing: A simple CRUD API that simulates a basic phonebook.</p>
<p><code>User</code>s consisting of names, email addresses and phone numbers can be created, viewed and deleted, and their phone numbers can be updated.</p>
<p>All of the code for this project can be found at <a href="https://github.com/fuzzbuzz/go-fuzzing-tutorial" target="_blank" rel="nofollow">https://github.com/fuzzbuzz/go-fuzzing-tutorial</a>, under <code>03-rest-api</code>. The project is laid out in a simple structure:</p>
<div data-language="shell"><pre><code><span>.</span>
├── cmd
│   └── server
│   	└── main.go
└── handlers
	├── db.go
	├── handlers.go
	├── handlers_sequence_test.go
	├── handlers_test.go</code></pre></div>
<p>The <code>main.go</code> under cmd/server handles setting up the HTTP server, wiring up routes to their respective handlers, and initializing &amp; migrating the SQLite database. We’re using SQLite to keep things simple, but you can of course use any type of database in the same way.</p>
<p>The <code>handlers/</code> directory contains the meat of the project - handlers for creating, deleting, updating and getting a <code>User</code>, as well as unit tests in the <code>_test.go</code> files.</p>
<p>We won’t go over every file in detail, but the key takeaway is that there are four HTTP handlers: <code>AddUser</code>, <code>GetUser</code>, <code>DeleteUser</code>, and <code>UpdateUser</code>. To get an idea of how they are used, we can take a look at <code>TestInsertUser</code> in <code>handlers/handlers_test.go</code>:</p>
<div data-language="go"><pre><code><span>func</span> <span>TestInsertUser</span><span>(</span>t <span>*</span>testing<span>.</span>T<span>)</span> <span>{</span>
    db <span>:=</span> <span>initDb</span><span>(</span>t<span>)</span>
    handlers <span>:=</span> <span>NewHandlers</span><span>(</span>db<span>)</span>

    
    input <span>:=</span> AddUserRequest<span>{</span>
   	 User<span>{</span>
   		 Name<span>:</span>    	<span>&#34;John Smith&#34;</span><span>,</span>
   		 Email<span>:</span>   	<span>&#34;<a href="https://blog.fuzzbuzz.io/cdn-cgi/l/email-protection" data-cfemail="365c595e5876455b5f425e1855595b">[email protected]</a>&#34;</span><span>,</span>
   		 PhoneNumber<span>:</span> <span>&#34;+1 650 750 8505&#34;</span><span>,</span>
   	 <span>}</span><span>,</span>
    <span>}</span>

    
    r <span>:=</span> <span>callAddUser</span><span>(</span>t<span>,</span> handlers<span>,</span> input<span>)</span>
    <span>if</span> r<span>.</span><span>Result</span><span>(</span><span>)</span><span>.</span>StatusCode <span>!=</span> <span>200</span> <span>{</span>
   	 t<span>.</span><span>Fatal</span><span>(</span><span>&#34;Expected insert user to work&#34;</span><span>)</span>
    <span>}</span>

    
    r <span>=</span> <span>callGetUser</span><span>(</span>t<span>,</span> handlers<span>,</span> input<span>.</span>Email<span>)</span>
    <span>if</span> r<span>.</span><span>Result</span><span>(</span><span>)</span><span>.</span>StatusCode <span>!=</span> <span>200</span> <span>{</span>
   	 t<span>.</span><span>Fatal</span><span>(</span><span>&#34;Expected to get user back&#34;</span><span>)</span>
    <span>}</span>

    
    result <span>:=</span> <span>&amp;</span>GetUserResponse<span>{</span><span>}</span>
    err <span>:=</span> json<span>.</span><span>Unmarshal</span><span>(</span>r<span>.</span>Body<span>.</span><span>Bytes</span><span>(</span><span>)</span><span>,</span> result<span>)</span>
    <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
   	 t<span>.</span><span>Fatal</span><span>(</span><span>&#34;Expected proper json response:&#34;</span><span>,</span> err<span>)</span>
    <span>}</span>
    <span>if</span> result<span>.</span>User<span>.</span>Name <span>!=</span> input<span>.</span>Name <span>{</span>
   	 t<span>.</span><span>Fatal</span><span>(</span><span>&#34;Expected name&#34;</span><span>,</span> input<span>.</span>Name<span>,</span> <span>&#34;got&#34;</span><span>,</span> result<span>.</span>User<span>.</span>Name<span>)</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>This test does the following:</p>
<ol>
<li>Initializes the database using the <code>initDB</code> test helper, which sets up a full in-memory SQLite instance - no mocking required, and allows us to test the API end-to-end.</li>
<li>Creates and populates a <code>User</code> struct</li>
<li>Adds the user to the database by calling <code>AddUser</code></li>
<li>If <code>AddUser</code> returns a <code>200</code>, it calls <code>GetUser</code> and validates that the returned value matches the <code>User</code> we created in step 3.</li>
</ol>
<p>While this is a useful test for validating that our API isn’t completely broken, it’s limited by the hardcoded values for the user data - since this application will be exposed over the internet, it would be great to have some more robust testing for undefined data.</p>
<p>You could manually create more tests to check different code paths, but you’d likely miss a bunch of edge cases and it’d be awfully boring. That’s where fuzzing comes in handy.</p>
<h2>Fuzzing our API for SQL Injection</h2>
<p>A good way to write your first couple fuzz tests is to start from existing unit tests. So, let’s take <code>TestInsertUser</code>, and write <code>FuzzInsertUser</code>:</p>
<div data-language="go"><pre><code><span>func</span> <span>FuzzInsertUser</span><span>(</span>f <span>*</span>testing<span>.</span>F<span>)</span> <span>{</span>
    
    db <span>:=</span> <span>initDb</span><span>(</span>f<span>)</span>
    
    handlers <span>:=</span> <span>NewHandlers</span><span>(</span>db<span>)</span>

    
    f<span>.</span><span>Add</span><span>(</span><span>&#34;<a href="https://blog.fuzzbuzz.io/cdn-cgi/l/email-protection" data-cfemail="9cf6f3f4f2dceff1f5e8f4b2fff3f1">[email protected]</a>&#34;</span><span>,</span> <span>&#34;John Smith&#34;</span><span>,</span> <span>&#34;+1 234 567 8901&#34;</span><span>)</span>

    f<span>.</span><span>Fuzz</span><span>(</span><span>func</span><span>(</span>t <span>*</span>testing<span>.</span>T<span>,</span> email<span>,</span> name<span>,</span> phoneNumber <span>string</span><span>)</span> <span>{</span>
   	 
	 <span>if</span> <span>!</span>utf8<span>.</span><span>ValidString</span><span>(</span>email<span>)</span> <span>||</span> <span>!</span>utf8<span>.</span><span>ValidString</span><span>(</span>name<span>)</span> <span>||</span> <span>!</span>utf8<span>.</span><span>ValidString</span><span>(</span>phoneNumber<span>)</span> <span>{</span>
   		 <span>return</span>
   	 <span>}</span>
   	 <span>defer</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
   		 
   		 
   		 <span>callDeleteUser</span><span>(</span>t<span>,</span> handlers<span>,</span> email<span>)</span>
   	 <span>}</span><span>(</span><span>)</span>

   	 
   	 input <span>:=</span> AddUserRequest<span>{</span>
   		 User<span>{</span>
   			 Email<span>:</span>   	email<span>,</span>
   			 Name<span>:</span>    	name<span>,</span>
   			 PhoneNumber<span>:</span> phoneNumber<span>,</span>
   		 <span>}</span><span>,</span>
   	 <span>}</span>

   	 
   	 r <span>:=</span> <span>callAddUser</span><span>(</span>t<span>,</span> handlers<span>,</span> input<span>)</span>
   	 <span>if</span> r<span>.</span><span>Result</span><span>(</span><span>)</span><span>.</span>StatusCode <span>!=</span> <span>200</span> <span>{</span>
   		 
   		 
   		 <span>return</span>
   	 <span>}</span>

   	 
   	 
   	 r <span>=</span> <span>callGetUser</span><span>(</span>t<span>,</span> handlers<span>,</span> input<span>.</span>Email<span>)</span>
   	 <span>if</span> r<span>.</span><span>Result</span><span>(</span><span>)</span><span>.</span>StatusCode <span>!=</span> <span>200</span> <span>{</span>
   		 t<span>.</span><span>Fatal</span><span>(</span><span>&#34;Expected to get user back, got&#34;</span><span>,</span> r<span>.</span><span>Result</span><span>(</span><span>)</span><span>.</span>StatusCode<span>)</span>
   	 <span>}</span>

   	 
   	 result <span>:=</span> <span>&amp;</span>GetUserResponse<span>{</span><span>}</span>
   	 err <span>:=</span> json<span>.</span><span>Unmarshal</span><span>(</span>r<span>.</span>Body<span>.</span><span>Bytes</span><span>(</span><span>)</span><span>,</span> result<span>)</span>
   	 <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
   		 t<span>.</span><span>Fatal</span><span>(</span><span>&#34;Expected proper json response:&#34;</span><span>,</span> err<span>)</span>
   	 <span>}</span>
   	 <span>if</span> result<span>.</span>User<span>.</span>Name <span>!=</span> input<span>.</span>Name <span>{</span>
   		 t<span>.</span><span>Log</span><span>(</span><span>&#34;Expected:&#34;</span><span>,</span> <span>[</span><span>]</span><span>byte</span><span>(</span>input<span>.</span>Name<span>)</span><span>,</span> <span>&#34;got&#34;</span><span>,</span> <span>[</span><span>]</span><span>byte</span><span>(</span>result<span>.</span>User<span>.</span>Name<span>)</span><span>)</span>
   		 t<span>.</span><span>Fatal</span><span>(</span><span>&#34;Expected name&#34;</span><span>,</span> input<span>.</span>Name<span>,</span> <span>&#34;got&#34;</span><span>,</span> result<span>.</span>User<span>.</span>Name<span>)</span>
   	 <span>}</span>
    <span>}</span><span>)</span>
<span>}</span></code></pre></div>
<p>It maintains the structure of the unit test, with a key difference: rather than hard-coding <code>email</code>, <code>name</code>, and <code>phoneNumber</code> values, we leave the generation of these inputs up to the fuzzer. The result of this is, rather than testing that our Create and Get sequence works for a single input, we’re asserting that it works for all possible user inputs.</p>
<p>Run the fuzz test from the <code>03-rest-api directory</code>:</p>
<div data-language="shell"><pre><code>go <span>test</span> -run FuzzInsertUser -fuzz FuzzInsertUser ./handlers</code></pre></div>
<div data-language="bash"><pre><code>fuzz: elapsed: 0s, gathering baseline coverage: <span>0</span>/167 completed
fuzz: minimizing <span>3506</span>-byte failing input <span>file</span>
fuzz: elapsed: 0s, gathering baseline coverage: <span>42</span>/167 completed
--- FAIL: FuzzInsertUser <span>(</span><span>0</span>.15s<span>)</span>
	--- FAIL: FuzzInsertUser <span>(</span><span>0</span>.00s<span>)</span>
    	handlers_test.go:148: Expected to get user back, got <span>404</span>

	Failing input written to testdata/fuzz/FuzzInsertUser/41d2503b0ce697a867179dd69d6067cfd7067d17b76c0d3345d6af84a430b2b6
	To re-run:
	go <span>test</span> -run<span>=</span>FuzzInsertUser/41d2503b0ce697a867179dd69d6067cfd7067d17b76c0d3345d6af84a430b2b6
FAIL
<span>exit</span> status <span>1</span>
FAIL    github.com/fuzzbuzz/go-fuzzing-tutorial/03-rest-api/handlers    <span>0</span>.152s</code></pre></div>
<p>In under a second, our fuzz test found a bug in our code. It found an input that caused AddUser to return a <code>200</code>, but somehow failed to save the data in our DB, causing the GET to fail. Take a look at the input:</p>
<div data-language="shell"><pre><code><span>cat</span> handlers/testdata/fuzz/FuzzInsertUser/41d2503b0ce697a867179dd69d6067cfd7067d17b76c0d3345d6af84a430b2b6</code></pre></div>
<div data-language="bash"><pre><code>go <span>test</span> fuzz v1
string<span>(</span><span>&#34;0&#34;</span><span>)</span>
string<span>(</span><span>&#34;0&#34;</span><span>)</span>
string<span>(</span><span>&#34;&#39;&#34;</span><span>)</span></code></pre></div>
<p>We can see that the fuzzer shrunk each of the inputs down to a single character. The quote in the phone number field is suspect - let’s take a look at the <code>AddUser</code> handler:</p>
<div data-language="go"><pre><code>
   	<span>_</span><span>,</span> err <span>=</span> h<span>.</span>db<span>.</span><span>Exec</span><span>(</span>fmt<span>.</span><span>Sprintf</span><span>(</span><span>&#34;insert into users(name, email, phone_number) values (&#39;%s&#39;, &#39;%s&#39;, &#39;%s&#39;);&#34;</span><span>,</span>
   	 request<span>.</span>Name<span>,</span> request<span>.</span>Email<span>,</span> request<span>.</span>PhoneNumber<span>)</span><span>)</span>
    <span>if</span> err <span>!=</span> <span>nil</span> <span>&amp;&amp;</span> err <span>==</span> sqlite3<span>.</span>ErrConstraintUnique <span>{</span>
   	 
   	 c<span>.</span><span>JSON</span><span>(</span>http<span>.</span>StatusBadRequest<span>,</span> gin<span>.</span>H<span>{</span>
   		 <span>&#34;error&#34;</span><span>:</span> <span>&#34;email already added&#34;</span><span>,</span>
   	 <span>}</span><span>)</span>
   	 <span>return</span>
    <span>}</span>
</code></pre></div>
<p>It turns out, we’ve actually uncovered two bugs here:</p>
<ol>
<li>We’re not sanitizing our database inputs, opting instead for basic string interpolation to build up our query! This leaves the database exposed to a <strong>SQL injection attack</strong>, which could allow malicious users to run raw queries directly on the database, expose sensitive information, or delete data.</li>
<li>We’re not checking errors correctly: any error other than a unique constraint error is silently ignored, meaning any failed queries get silenced while the handler returns a 200 status.</li>
</ol>
<p>The fuzzer discovered all on its own that a quote was significant, and then used that character to cause the SQL error, and provided us with a simple input that reproduces the behavior.</p>
<p>To fix this, swap the query to use SQL argument interpolation which will properly sanitize the input, and make sure to add a catch-all error check at the end:</p>
<div data-language="go"><pre><code>
	<span>_</span><span>,</span> err <span>=</span> h<span>.</span>db<span>.</span><span>Exec</span><span>(</span>fmt<span>.</span><span>Sprintf</span><span>(</span><span>&#34;insert into users(name, email, phone_number) values (?, ?, ?);&#34;</span><span>)</span><span>,</span>
   	 request<span>.</span>Name<span>,</span> request<span>.</span>Email<span>,</span> request<span>.</span>PhoneNumber<span>)</span>
    <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
   	 <span>if</span> err <span>==</span> sqlite3<span>.</span>ErrConstraintUnique <span>{</span>
   		 
   		 c<span>.</span><span>JSON</span><span>(</span>http<span>.</span>StatusBadRequest<span>,</span> gin<span>.</span>H<span>{</span>
   			 <span>&#34;error&#34;</span><span>:</span> <span>&#34;email already added&#34;</span><span>,</span>
   		 <span>}</span><span>)</span>
   	 <span>}</span> <span>else</span> <span>{</span>
   		 
   		 c<span>.</span><span>JSON</span><span>(</span>http<span>.</span>StatusInternalServerError<span>,</span> gin<span>.</span>H<span>{</span>
   			 <span>&#34;error&#34;</span><span>:</span> err<span>.</span><span>Error</span><span>(</span><span>)</span><span>,</span>
   		 <span>}</span><span>)</span>
   	 <span>}</span>
   	 <span>return</span>
    <span>}</span>
</code></pre></div>
<p>After running the test again, we’ll see that the bugs are fixed.</p>
<p>With just a simple test, we were able to find and reproduce two of the most common bugs in REST APIs: SQL Injection, and unhandled errors.</p>
<h2>Fuzzing the API for Logic Bugs</h2>
<p>While our previous example is a useful technique, we’ve only tested a single sequence of calls. Writing tests for each of the (infinitely many) possible sets of call sequences for a CRUD app would be tedious and time-consuming. Luckily, we can easily extend the above test to generate arbitrary sequences of Create, Read, Update and Delete API calls. </p>
<p><code>FuzzSequenceHandlers</code> can be found in <code>handlers/handers_sequence_test.go</code>. What follows is an example of the test’s skeleton, to save space (you can <a href="https://github.com/fuzzbuzz/go-fuzzing-tutorial/blob/master/03-rest-api/handlers/handlers_sequence_test.go#L69" target="_blank" rel="nofollow">view the full test here</a>):</p>
<div data-language="go"><pre><code><span>const</span> <span>(</span>
    AddUser <span>=</span> <span>iota</span>
    GetUser
    UpdateUser
    DeleteUser
<span>)</span>

<span>type</span> State <span>struct</span> <span>{</span>	
    InDB	<span>bool</span>
    Updated <span>bool</span>
<span>}</span>

<span>func</span> <span>FuzzSequenceHandlers</span><span>(</span>f <span>*</span>testing<span>.</span>F<span>)</span> <span>{</span>
    db <span>:=</span> <span>initDb</span><span>(</span>f<span>)</span>

    handlers <span>:=</span> <span>NewHandlers</span><span>(</span>db<span>)</span>

    
    
    f<span>.</span><span>Add</span><span>(</span><span>[</span><span>]</span><span>byte</span><span>{</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>}</span><span>,</span> <span>&#34;<a href="https://blog.fuzzbuzz.io/cdn-cgi/l/email-protection" data-cfemail="43292c2b2d03302e2a372b6d202c2e">[email protected]</a>&#34;</span><span>,</span> <span>&#34;John Smith&#34;</span><span>,</span>
      <span>&#34;+1 234 567 8901&#34;</span><span>,</span> <span>&#34;+9 876 543 2109&#34;</span><span>)</span>

    f<span>.</span><span>Fuzz</span><span>(</span><span>func</span><span>(</span>t <span>*</span>testing<span>.</span>T<span>,</span> operations <span>[</span><span>]</span><span>byte</span><span>,</span> email<span>,</span> name<span>,</span> number1<span>,</span> number2 <span>string</span><span>)</span> <span>{</span>
   	 <span>if</span> <span>len</span><span>(</span>email<span>)</span> <span>==</span> <span>0</span> <span>{</span>
   		 <span>return</span>
   	 <span>}</span>
   	 <span>if</span> <span>!</span>utf8<span>.</span><span>ValidString</span><span>(</span>email<span>)</span> <span>||</span> <span>!</span>utf8<span>.</span><span>ValidString</span><span>(</span>name<span>)</span> <span>||</span>
	    <span>!</span>utf8<span>.</span><span>ValidString</span><span>(</span>number1<span>)</span> <span>||</span> <span>!</span>utf8<span>.</span><span>ValidString</span><span>(</span>number2<span>)</span> <span>{</span>
   		 <span>return</span>
   	 <span>}</span>
   	 <span>defer</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
   		 
		 
   		 <span>callDeleteUser</span><span>(</span>t<span>,</span> handlers<span>,</span> email<span>)</span>
   	 <span>}</span><span>(</span><span>)</span>
   	 state <span>:=</span> State<span>{</span><span>}</span>

   	 
   	 <span>if</span> <span>len</span><span>(</span>operations<span>)</span> <span>&gt;</span> <span>10</span> <span>{</span>
   		 operations <span>=</span> operations<span>[</span><span>:</span><span>10</span><span>]</span>
   	 <span>}</span>

   	 t<span>.</span><span>Log</span><span>(</span><span>&#34;Running&#34;</span><span>,</span> <span>len</span><span>(</span>operations<span>)</span><span>,</span> <span>&#34;operations&#34;</span><span>)</span>
   	 <span>for</span> i<span>,</span> operation <span>:=</span> <span>range</span> operations <span>{</span>
   		 t<span>.</span><span>Log</span><span>(</span><span>&#34;Operation:&#34;</span><span>,</span> i<span>+</span><span>1</span><span>)</span>
   		 <span>switch</span> operation <span>%</span> <span>4</span> <span>{</span>
   		 <span>case</span> AddUser<span>:</span>
   			t<span>.</span><span>Log</span><span>(</span><span>&#34;Adding&#34;</span><span>)</span>
			
   			t<span>.</span><span>Log</span><span>(</span><span>&#34;Add successful&#34;</span><span>)</span>
   			state<span>.</span>InDB <span>=</span> <span>true</span>
   			state<span>.</span>Updated <span>=</span> <span>false</span>
   			state<span>.</span><span>Log</span><span>(</span>t<span>)</span>
		 <span>case</span> GetUser<span>:</span>
   			t<span>.</span><span>Log</span><span>(</span><span>&#34;Getting&#34;</span><span>)</span>
			
			
			
   			t<span>.</span><span>Log</span><span>(</span><span>&#34;Get successful&#34;</span><span>)</span>
   			state<span>.</span><span>Log</span><span>(</span>t<span>)</span>
   		 <span>case</span> UpdateUser<span>:</span>
   			t<span>.</span><span>Log</span><span>(</span><span>&#34;Updating&#34;</span><span>)</span>
			
			
   			state<span>.</span><span>Log</span><span>(</span>t<span>)</span>
		 <span>case</span> DeleteUser<span>:</span>
   			t<span>.</span><span>Log</span><span>(</span><span>&#34;Deleting&#34;</span><span>)</span>
			
			state<span>.</span>InDB <span>=</span> <span>false</span>
   			state<span>.</span>Updated <span>=</span> <span>false</span>
   			state<span>.</span><span>Log</span><span>(</span>t<span>)</span>
   		 <span>}</span>
   	 <span>}</span>
    <span>}</span><span>)</span>
<span>}</span></code></pre></div>
<p>As you can see, our fuzz test accepts two new parameters:
a byte array named <code>operations</code>
a second phone number we can use to test <code>UpdateUser</code>.
The <code>operations</code> array is where the magic of this test lies: it allows us to create an array of numbers, which we then map to operations. So, if an element in the byte array, modulo 4, is equal to 0, we call <code>AddUser</code>. If it’s equal to 1, we call <code>GetUser</code>, and so on, looping through until we run out of numbers or arrive at our maximum.</p>
<p>Run this test with:</p>
<div data-language="shell"><pre><code>go <span>test</span> -run FuzzSequenceHandlers -fuzz FuzzSequenceHandlers</code></pre></div>
<div data-language="bash"><pre><code>fuzz: fuzz: elapsed: 0s, gathering baseline coverage: <span>0</span>/1 completed
fuzz: elapsed: 0s, gathering baseline coverage: <span>1</span>/1 completed, now fuzzing with <span>8</span> workers
fuzz: minimizing <span>77</span>-byte failing input <span>file</span>
fuzz: elapsed: 1s, minimizing
--- FAIL: FuzzSequenceHandlers <span>(</span><span>0</span>.70s<span>)</span>
	--- FAIL: FuzzSequenceHandlers <span>(</span><span>0</span>.00s<span>)</span>
    	handlers_sequence_test.go:95: Running <span>2</span> operations
    	handlers_sequence_test.go:97: Operation: <span>1</span>
    	handlers_sequence_test.go:154: Updating
    	handlers_sequence_test.go:171: Update successful
    	handlers_sequence_test.go:66: State, InDB: <span>true</span> Updated: <span>true</span>
    	handlers_sequence_test.go:97: Operation: <span>2</span>
    	handlers_sequence_test.go:122: Getting
    	handlers_sequence_test.go:128: Expected to get user back, got <span>404</span>
    
	Failing input written to testdata/fuzz/FuzzSequenceHandlers/a5b01abf7948a05ad8d65b3a834665f04bdd874a5d06191a5e980b8e46f70e8c
	To re-run:
	go <span>test</span> -run<span>=</span>FuzzSequenceHandlers/a5b01abf7948a05ad8d65b3a834665f04bdd874a5d06191a5e980b8e46f70e8c
FAIL
<span>exit</span> status <span>1</span>
FAIL    github.com/fuzzbuzz/go-fuzzing-tutorial/03-rest-api/handlers    <span>0</span>.708s</code></pre></div>
<p>Within 0.70s, our fuzz test found a buggy sequence of calls and reduced it down to a two-call sequence: an Update, followed by a Get. The Update should have failed, since there was no call to <code>AddUser</code> first, but instead it returned a 200 response, since <code>GetUser</code> was called afterwards.</p>
<p>Taking a look at <code>UpdateUser</code> in <code>handlers/handlers.go</code>, we can see that we missed a key error case:</p>
<div data-language="go"><pre><code>
  <span>_</span><span>,</span> err <span>=</span> h<span>.</span>db<span>.</span><span>Exec</span><span>(</span><span>&#34;update users set phone_number = ? where email = ?;&#34;</span><span>,</span> request<span>.</span>PhoneNumber<span>,</span> wantEmail<span>)</span>
    <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
   	 <span>if</span> err <span>!=</span> sql<span>.</span>ErrNoRows <span>{</span>
   		 c<span>.</span><span>JSON</span><span>(</span>http<span>.</span>StatusBadRequest<span>,</span> gin<span>.</span>H<span>{</span>
   			 <span>&#34;error&#34;</span><span>:</span> err<span>.</span><span>Error</span><span>(</span><span>)</span><span>,</span>
   		 <span>}</span><span>)</span>
   	 <span>}</span>
   	 <span>return</span>
    <span>}</span>
</code></pre></div>
<p>The handler doesn’t contain the case for actually returning a 404 properly, which resulted in this handler returning a 200 when attempting to update a user that does not exist.</p>
<p>Without a fuzz test, this issue would have likely been missed in code review, and would probably have made its way to production causing complicated, difficult-to-debug problems for users. </p>
<p>Using a fuzzer in this manner is a simple but effective way to simulate how users can interact with your API, and catch bugs that would otherwise go undetected during development. </p>
<h2>Fuzzing Around the HTTP Framework</h2>
<p>One thing you may have noticed is that all of the function calls made in these tests completely skip the HTTP layer. Instead, we opted to directly call our handler functions from the unit test.</p>
<p>This is done to optimize the speed of the tests - it’s much more efficient to execute a function call, than to make an HTTP request, even if it’s on the same machine. In fact, we’re not interested in testing the HTTP framework since we can assume they are already well tested, so by fuzzing the handlers directly, we’re able to test our underlying logic more efficiently.</p>
<h2>API Fuzzing in the Real World</h2>
<p>The average Go API in production is significantly more complex than the toy example presented, making it even more likely that issues like unhandled errors, SQL injection, and logical bugs go undetected by static analysis or unit tests. Developers can save time and energy by writing fewer, more robust API fuzz tests that simulate real-world interactions and end up uncovering more bugs.</p>
<p>The Go fuzzer is flexible and can often be adapted to very complex codebases, due to its ability to generate structured data. We encourage you to try writing a fuzz test for your code - it’s often a lot easier than you may think. And, if you hit any roadblocks or would like some pointers, come ask for some help in our <a href="https://discord.fuzzbuzz.io" target="_blank" rel="nofollow">Discord</a>.</p>
<p>By the way - we just opened sign ups for the Fuzzbuzz Beta, so anyone can start fuzzing code in CI/CD for free. <a href="https://beta.fuzzbuzz.io/signup" target="_blank" rel="nofollow">Create your account here</a>.</p></section></article></main></div></div></div></div>
  </body>
</html>
