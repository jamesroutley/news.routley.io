<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://foxmoss.com/blog/packet-filtering/">Original</a>
    <h1>How I block all 26M of your curl requests</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-bvzihdzo="">   <blockquote>
<p>All code in this blog post is fully open source at
<a href="https://github.com/FoxMoss/fox-xdp/">github.com/FoxMoss/fox-xdp</a>.</p>
</blockquote>
<p>Bots have always been a problem on the internet. Be it DDOSing, AI scrapers,
etc. It’s a treadmill problem and no solution will ever be perfect, but we can
block many minimum effort attempts.</p>
<p>I recently went down a coding rabbit hole. Packet filtering and analysis is a fascinating field.
There’s just a bone in my body that likes writing software at a scale that’s bigger than it’ll ever
be used. So how do you handle network requests fast? Well, write an operating system and custom
network drivers specifically optimized for speed. We won’t be doing that today, but we can get closer
to the bare metal fairly easily without sacrificing the Linux ecosystem. <a href="https://en.wikipedia.org/wiki/Express_Data_Path">XDP - Express Data
Path</a> is that way of getting closer to your network
device. And according to some benchmarks Wikipedia cites, you can drop 26 million packets per second
on consumer hardware. This is really good load handling, especially for a single server. Both Linux
and surprisingly Windows support XDP, but we’re just going to be focusing on Linux because that’s
what I have, and that’s what you’re going to read.</p>
<h3 id="so-how-do-we-actually-write-this">So how do we actually write this?</h3>
<p>XDP works on <a href="https://ebpf.io/">eBPF - Extended Berkeley Packet Filter</a>. We can just load our eBPF
filter, on to our network device with some XDP utilities, and our filter which will start taking in
all inbound requests. If we want we can also get our eBPF to pass our request back into the program
that loaded it in and do additional processing in userspace. This turns out to be ~400 lines of
boilerplate in C which you can read <a href="https://github.com/FoxMoss/fox-xdp">here</a>. This isn’t a
tutorial, you can figure things out. That’s not the real interesting bit, the real magic happens on
the filter.</p>
<p>8 billion devices run Java, and at least like a billion probably run eBPFs. eBPF is a tiny virtual
machine that hides in your kernel. You compile your code down to something that looks pretty low
level, you have your jumps and your registers and things you would expect, no SIMD, no x86 bloat but
it’s enough to have a decent <code>clang</code> compilation target.</p>
<p>So lets start to parse things out in a eBPF filter:</p>
<pre tabindex="0" data-language="c"><code><span><span>// headers here</span></span>
<span></span>
<span><span>SEC</span><span>(</span><span>&#34;prog&#34;</span><span>) </span><span>int</span><span> xdp_sock_prog</span><span>(</span><span>struct</span><span> xdp_md </span><span>*</span><span>ctx) {</span></span>
<span><span>  uint8_t</span><span> *</span><span>data </span><span>=</span><span> (</span><span>void</span><span> *</span><span>)(</span><span>long</span><span>)ctx</span><span>-&gt;</span><span>data</span><span>;</span></span>
<span><span>  void</span><span> *</span><span>data_end </span><span>=</span><span> (</span><span>void</span><span> *</span><span>)(</span><span>long</span><span>)ctx</span><span>-&gt;</span><span>data_end</span><span>;</span></span>
<span></span>
<span><span>  return</span><span> XDP_PASS;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>char</span><span> _license[] </span><span>SEC</span><span>(</span><span>&#34;license&#34;</span><span>) </span><span>=</span><span> &#34;GPL&#34;</span><span>;</span></span></code></pre>
<p>There’s a couple oddities there that I’ll explain. The kernel won’t load the program if it’s not
GPL, so that’s required at the bottom. The <code>data</code> start and <code>data_end</code> variables just point to the start
and end of your full packet, starting with the Data Link layer, that’s Ethernet frames. The OSI
model you reluctantly learned in college is actually going to come in handy here because we have to
write our own network parser. The other weird thing is that we’re grabbing the data_end, why?
Because we need to validate our program. One of the benefits for this all running on a reduced
instruction set is that we can easily validate if the program can accidentally cause an out of
bounds read given some input, because your network driver crashing while trying to filter
bad packets seems like a pretty easy attack vector, especially since most of eBPF filters are written
in C.</p>
<p>So here’s an example of this bounds check while we get our IP packet parsed. <code>iphdr</code> comes
graciously from our kernel headers and we can quickly check if that struct fits into our full data
buffer before we start reading any values.</p>
<pre tabindex="0" data-language="c"><code><span><span>#define</span><span> OVER</span><span>(x, d) (x </span><span>+</span><span> 1</span><span> &gt;</span><span> (</span><span>typeof</span><span>(</span><span>x</span><span>))d)</span></span>
<span><span>  </span></span>
<span><span>// ..</span></span>
<span><span>  struct</span><span> ethhdr </span><span>*</span><span>eth </span><span>=</span><span> data;</span></span>
<span></span>
<span><span>  struct</span><span> iphdr </span><span>*</span><span>ip </span><span>=</span><span> (</span><span>struct</span><span> iphdr </span><span>*</span><span>)(eth </span><span>+</span><span> 1</span><span>);</span></span>
<span></span>
<span><span>  if</span><span> (</span><span>OVER</span><span>(ip, data_end))</span></span>
<span><span>    return</span><span> XDP_PASS;</span></span>
<span></span>
<span><span>  // routers often drop packets with ip extensions so why bother parsing</span></span>
<span><span>  if</span><span> (ip</span><span>-&gt;</span><span>ihl </span><span>&gt;</span><span> 5</span><span>)</span></span>
<span><span>    return</span><span> XDP_PASS;</span></span>
<span></span>
<span><span>// ...</span></span></code></pre>
<p>So to fingerprint the client and determine whether or not a client is coming from curl we need to
parse the TLS packets. So once we just make sure everything looks good in TCP land, then if the
packet starts with the TLS handshake and the version we care about we can then start to get it’s
signature.</p>
<pre tabindex="0" data-language="c"><code><span><span>// ...</span></span>
<span><span>    void</span><span> *</span><span>start_payload </span><span>=</span><span> ((</span><span>uint8_t</span><span> *</span><span>)tcp) </span><span>+</span><span> (tcp</span><span>-&gt;</span><span>doff </span><span>*</span><span> 4</span><span>);</span></span>
<span></span>
<span><span>    if</span><span> (</span><span>OVER</span><span>(start_payload, data_end)) {</span></span>
<span><span>      return</span><span> XDP_PASS;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // all data we need to parse should be within 120 bytes</span></span>
<span><span>    if</span><span> (</span><span>OVER</span><span>(start_payload </span><span>+</span><span> 120</span><span>, data_end)) {</span></span>
<span><span>      return</span><span> XDP_PASS;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    if</span><span> (</span><span>!</span><span>(((</span><span>uint8_t</span><span> *</span><span>)start_payload)[</span><span>0</span><span>] </span><span>==</span><span> 0x</span><span>16</span><span> &amp;&amp;</span></span>
<span><span>          ((</span><span>uint8_t</span><span> *</span><span>)start_payload)[</span><span>1</span><span>] </span><span>==</span><span> 0x</span><span>03</span><span> &amp;&amp;</span></span>
<span><span>          ((</span><span>uint8_t</span><span> *</span><span>)start_payload)[</span><span>2</span><span>] </span><span>==</span><span> 0x</span><span>01</span><span>)) {</span></span>
<span><span>      return</span><span> XDP_PASS;</span></span>
<span><span>    }</span></span>
<span><span>// ...</span></span></code></pre>
<h3 id="so-how-do-you-fingerprint-a-tls-connection">So how do you fingerprint a TLS connection</h3>
<p>I for the longest time was unaware of TLS fingerprinting, it’s probably that way intentionally
because once lots of people know about it, it’s not hard to get around it, but I have nothing to
hide so let me breakdown how we do this.</p>
<p>The modern standard for TLS fingerprint is <a href="https://github.com/FoxIO-LLC/ja4">JA4</a> made by
<a href="https://foxio.io/">FoxIO</a> (no relation to me). The JA4 is just a string of some basic details about
the TLS connection, but it’s able to be traced back to your browser pretty easily. Here’s the full
explanation image that FoxIO provides:</p>
<p><img src="https://foxmoss.com/blog/packet-filtering/ja4.png" alt="JA4 Spec"/></p>
<p>What you may notice in particular is that JA4 needs a SHA256 hash to work, if we’re going to
calculate this entirely in eBPF we’re going to need to introduce a ton of complexity. Because what I
found out pretty quickly when I starting implementing SHA256 in a filter is that it’s hard to get it
all to fit into the 512 byte stack space. So I started thinking, you could probably get it all in
by using tail calls, chaining together multiple eBPFs in sequence, but that’s just more work when
really the point here is just to shrink down the space needed to store all the ciphers. So why not
just use a non-cryptographic hash function here and cut down on program size? Using a
cryptographically secure hash really doesn’t provide any benefits because an attacker can already
just mimic another browser, no hash cracking needed. So here’s the spec for the new format</p>
<p><img src="https://foxmoss.com/blog/packet-filtering/fst1.png" alt="FST1 Spec"/></p>
<p>You can read the official documentation <a href="https://github.com/FoxMoss/fox-xdp/blob/main/docs/fst1.md">here</a>.</p>
<p>Inside a TLS Client Hello, there’s just an arbitrary list of Cipher Suites. So what FST1 does and
the middle bit of JA4 does, is just parse them and hash them down. Each browser and HTTPS
implementation will use different ciphers, so we fingerprint that. And as an easy measure to avoid
storing duplicate lists of ciphers that are just in different orders we can sort the lists before
the hashing.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Jenkins_hash_function">Jenkins hash</a> is one of the simplest
hashing algorithms you can get, literally just add some numbers and shift the bits around a little.
Here’s what Wikipedia lists as a reference implementation.</p>
<pre tabindex="0" data-language="c"><code><span><span>uint32_t</span><span> jenkins_one_at_a_time_hash</span><span>(</span><span>const</span><span> uint8_t</span><span>*</span><span> key, </span><span>size_t</span><span> length) {</span></span>
<span><span>  size_t</span><span> i </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>  uint32_t</span><span> hash </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>  while</span><span> (i </span><span>!=</span><span> length) {</span></span>
<span><span>    hash </span><span>+=</span><span> key[i</span><span>++</span><span>];</span></span>
<span><span>    hash </span><span>+=</span><span> hash </span><span>&lt;&lt;</span><span> 10</span><span>;</span></span>
<span><span>    hash </span><span>^=</span><span> hash </span><span>&gt;&gt;</span><span> 6</span><span>;</span></span>
<span><span>  }</span></span>
<span><span>  hash </span><span>+=</span><span> hash </span><span>&lt;&lt;</span><span> 3</span><span>;</span></span>
<span><span>  hash </span><span>^=</span><span> hash </span><span>&gt;&gt;</span><span> 11</span><span>;</span></span>
<span><span>  hash </span><span>+=</span><span> hash </span><span>&lt;&lt;</span><span> 15</span><span>;</span></span>
<span><span>  return</span><span> hash;</span></span>
<span><span>}</span></span></code></pre>
<p>Now we also need to sort it, and that becomes trickier because I want to avoid making large arrays
that I would need to copy the Cipher Suites to on the tiny eBPF stack. So I embed the sorting
algorithm in the hashing function.</p>
<pre tabindex="0" data-language="c"><code><span><span>uint32_t</span><span> calculate_hash</span><span>(</span><span>uint16_t</span><span> *</span><span>data, </span><span>size_t</span><span> len) {</span></span>
<span><span>  uint32_t</span><span> hash </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>  uint16_t</span><span> lowest </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>  for</span><span> (</span><span>size_t</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> len; i</span><span>++</span><span>) {</span></span>
<span><span>    uint16_t</span><span> lowest_high </span><span>=</span><span> UINT16_MAX;</span></span>
<span><span>    for</span><span> (</span><span>size_t</span><span> j </span><span>=</span><span> 0</span><span>; j </span><span>&lt;</span><span> len; j</span><span>++</span><span>) {</span></span>
<span><span>      if</span><span> (data[j] </span><span>&lt;</span><span> lowest_high </span><span>&amp;&amp;</span><span> data[j] </span><span>&gt;</span><span> lowest) {</span></span>
<span><span>        lowest_high </span><span>=</span><span> data[j];</span></span>
<span><span>      }</span></span>
<span><span>    }</span></span>
<span><span>    lowest </span><span>=</span><span> lowest_high;</span></span>
<span><span>    hash </span><span>+=</span><span> lowest;</span></span>
<span><span>    hash </span><span>+=</span><span> hash </span><span>&lt;&lt;</span><span> 10</span><span>;</span></span>
<span><span>    hash </span><span>^=</span><span> hash </span><span>&gt;&gt;</span><span> 6</span><span>;</span></span>
<span><span>  }</span></span>
<span><span>  hash </span><span>+=</span><span> hash </span><span>&lt;&lt;</span><span> 3</span><span>;</span></span>
<span><span>  hash </span><span>^=</span><span> hash </span><span>&gt;&gt;</span><span> 11</span><span>;</span></span>
<span><span>  hash </span><span>+=</span><span> hash </span><span>&lt;&lt;</span><span> 15</span><span>;</span></span>
<span><span>  return</span><span> hash;</span></span>
<span><span>}</span></span></code></pre>
<p>Which is like a bastardized selection sort. The big O notation for it doesn’t look great being
O(n^2) but the major advantage is that we only need to store two numbers in memory other than the
hash. This is going to be more than enough for our use case here.</p>
<h3 id="putting-everything-together">Putting everything together</h3>
<p>Moving that into eBPF land we can pretty easily just tap into the ciphers,</p>
<pre tabindex="0" data-language="c"><code><span><span>// ...</span></span>
<span></span>
<span><span>    uint8_t</span><span> *</span><span>ciphers </span><span>=</span><span> (</span><span>uint8_t</span><span> *</span><span>)tlsh </span><span>+</span><span> sizeof</span><span>(</span><span>struct</span><span> tlshdr1);</span></span>
<span></span>
<span><span>    if</span><span> (</span><span>OVER</span><span>(ciphers, data_end)) {</span></span>
<span><span>      return</span><span> XDP_PASS;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    uint8_t</span><span> *</span><span>ciphers_end </span><span>=</span><span> (</span><span>void</span><span> *</span><span>)ciphers </span><span>+</span><span> real_count;</span></span>
<span><span>    if</span><span> (</span><span>OVER</span><span>(ciphers_end, data_end) </span><span>&amp;&amp;</span><span> ciphers </span><span>&gt;</span><span> data) {</span></span>
<span><span>      return</span><span> XDP_PASS;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    if</span><span> (real_count </span><span>&gt;</span><span> 800</span><span>) {</span></span>
<span><span>      return</span><span> XDP_PASS;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    uint32_t</span><span> my_hash </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>    uint32_t</span><span> j </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>    uint16_t</span><span> lowest </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>    bpf_for</span><span>(j, </span><span>0</span><span>, </span><span>800</span><span>) {</span></span>
<span><span>      if</span><span> (j </span><span>*</span><span> 2</span><span> &gt;=</span><span> real_count)</span></span>
<span><span>        break</span><span>;</span></span>
<span></span>
<span><span>      uint32_t</span><span> i </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>      uint16_t</span><span> lowest_high </span><span>=</span><span> UINT16_MAX;</span></span>
<span><span>      bpf_for</span><span>(i, </span><span>0</span><span>, </span><span>800</span><span>) {</span></span>
<span><span>        if</span><span> (i </span><span>*</span><span> 2</span><span> &gt;=</span><span> real_count)</span></span>
<span><span>          break</span><span>;</span></span>
<span><span>        uint16_t</span><span> val </span><span>=</span><span> 0</span><span>;</span></span>
<span></span>
<span><span>        if</span><span> (ciphers </span><span>+</span><span> i </span><span>*</span><span> 2</span><span> +</span><span> 1</span><span> &gt;</span><span> data_end)</span></span>
<span><span>          break</span><span>;</span></span>
<span><span>        if</span><span> (</span><span>bpf_xdp_load_bytes</span><span>(ctx, (</span><span>long</span><span>)(ciphers </span><span>-</span><span> data </span><span>+</span><span> i </span><span>*</span><span> 2</span><span>), </span><span>&amp;</span><span>val, </span><span>2</span><span>)</span></span>
<span><span>            &lt;</span><span> 0</span><span>)</span></span>
<span><span>          break</span><span>;</span></span>
<span></span>
<span><span>        if</span><span> (val </span><span>&lt;</span><span> lowest_high </span><span>&amp;&amp;</span><span> val </span><span>&gt;</span><span> lowest) {</span></span>
<span><span>          lowest_high </span><span>=</span><span> val;</span></span>
<span><span>        }</span></span>
<span><span>      }</span></span>
<span></span>
<span><span>      lowest </span><span>=</span><span> lowest_high;</span></span>
<span></span>
<span><span>      my_hash </span><span>+=</span><span> lowest;</span></span>
<span><span>      my_hash </span><span>+=</span><span> my_hash </span><span>&lt;&lt;</span><span> 10</span><span>;</span></span>
<span><span>      my_hash </span><span>^=</span><span> my_hash </span><span>&gt;&gt;</span><span> 6</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>    my_hash </span><span>+=</span><span> my_hash </span><span>&lt;&lt;</span><span> 3</span><span>;</span></span>
<span><span>    my_hash </span><span>^=</span><span> my_hash </span><span>&gt;&gt;</span><span> 11</span><span>;</span></span>
<span><span>    my_hash </span><span>+=</span><span> my_hash </span><span>&lt;&lt;</span><span> 15</span><span>;</span></span>
<span></span>
<span><span>// ...</span></span></code></pre>
<p>The <code>bpf_for</code> with the early returns is to keep the verifier happy, likewise with <code>bpf_xdp_load_bytes</code>
it yells at you for access the bytes raw even with bounds checking.</p>
<p>So I have the implementation working, just grabbing a printout of each request’s hashes we can see
what userspace gives us matches what the filter gives us. So now that we can detect we can start
blocking! Pulling up Wireshark we can just get a dump of the Cipher Suites, calculate the hash and
store it in a configuration file. So now how do we actually get data from userspace to the kernel?
We could embed it in the binary but that heavily limits the amount of hash we can actually fit. The
solution is eBPF maps, we can pass data back and forth by using a helpfully provided kernel hash map.</p>
<p>Surprising that we get a hash map here but not in native C, but I’m not complaining.</p>
<pre tabindex="0" data-language="c"><code><span><span>struct</span><span> {</span></span>
<span><span>  __uint</span><span>(type, BPF_MAP_TYPE_HASH);</span></span>
<span><span>  __type</span><span>(key, __u32);</span></span>
<span><span>  __type</span><span>(value, __u8);</span></span>
<span><span>  __uint</span><span>(max_entries, </span><span>64</span><span>);</span></span>
<span><span>} blocked </span><span>SEC</span><span>(</span><span>&#34;.maps&#34;</span><span>);</span></span></code></pre>
<p>The eBPF program can just look up the FST1 hash and if the value u8 is 1 and the key exists we can
then decide what to do with it. I just store a config value at the key of 0, so we can decide to
blacklist or whitelist any hashes that get activated.</p>
<p>So that’s about it, I grabbed the hash of my curl client and created a config file with it
blacklisted. - After accidentally killing my server trying to update the kernel version, then
reinstalling everything - I can now just run the fox-filter program, and provided the curl exhibits the
same behavior as the curl that I installed with Arch Linux, the filter should block the request.</p>
<h3 id="so-why">So why?</h3>
<p>This is of course overzealous to just block all curl requests, but with tools like
<a href="https://github.com/TecharoHQ/anubis/">Anubis</a> being largely ineffective. I think it’s fun to see bot
detection that can’t be bypassed by setting your user agent to</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Googlebot/2.1; +http://www.google.com/bot.html) Chrome/W.X.Y.Z Safari/537.36</span></span></code></pre>
<p>(Yes this is real at the time of writing, try it out yourself)</p>
<p>There’s ways to get around TLS signatures but it’s much harder and requires a lot more legwork to
get working, compounded even more if your forced to implement TLS extensions. It’s also a technique
that useful for passively viewing traffic patterns, and see when user agents lie.</p>
<h2 id="how-fast-is-it">How fast is it?</h2>
<p>Pretty fast! With some preliminary benchmarks it seems to beat doing it in user space by a hair. All
of this is still pretty fast either way.</p>
<p><img src="https://foxmoss.com/blog/packet-filtering/chart.png" alt="Benchmarks"/></p>
<h2 id="credits">Credits</h2>
<p>Big thanks to Sakura from Papyrus Networks (<a href="mailto:sakura@voxga.xyz">sakura@voxga.xyz</a>) for getting me interested in TLS fingerprinting.</p>
<p>Shout out to <a href="https://foxio.io/">FoxIO</a> for documenting these techniques.</p>
<p><a href="https://burtleburtle.net/bob/">Bob Jenkins</a> from the Jenkins hash.</p>
<p>Thanks to Nihaal for proofreading.</p>  </div></div>
  </body>
</html>
