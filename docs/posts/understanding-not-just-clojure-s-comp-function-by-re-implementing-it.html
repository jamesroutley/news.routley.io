<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evalapply.org/posts/lessons-from-reimplementing-clojure-comp-function/index.html">Original</a>
    <h1>Understanding not just Clojure&#39;s comp function by re-implementing it</h1>
    
    <div id="readability-page-1" class="page"><div id="the-very-top">
        
  <main id="main">
    <article id="blog-post">
  <header>
      <p>Understanding not just Clojure&#39;s comp function by re-implementing it</p>

      <p>
        
        <span>Published: 2025-08-08</span>
        <span>Updated: 2025-08-08</span>
        
      </p>

      <p>
        Because I realised thinking like this is not obvious to Clojure newcomers, especially those having non-FP first languages. Because I was there too, all those moons ago!
      </p>
     
     
  </header>
  <hr/>
  <section>
      <p>Someone working through the &#34;<a href="https://www.braveclojure.com/functional-programming/"><em>Brave Clojure</em></a>&#34; book asked <code>#beginners</code> in the Clojurians Zulip chat, for help about implementing <a href="https://clojuredocs.org/clojure.core/comp">comp</a> &#34;in their own words&#34;. <a href="https://clojurians.zulipchat.com/#narrow/channel/151763-beginners/topic/Understanding.20comp.20by.20reimpleneting.20it">Useful help followed in the Zulip thread</a>, of course. I was late to the party. Of course. But when has that ever stopped anyone on the Internet from generating a wall of text?</p>
<p>Having done so, I realised a bunch of ideas have to coalesce in the Clojure learner&#39;s mind to truly <em>See</em> the picture, and I certainly did not <em>See</em> it for a long time:</p>
<ul>
<li>Functions are first-class values at run-time, just like &#34;normal&#34; constants.
<ul>
<li><em>So</em> we can pass them around, and in Clojure, we can also put functions inside normal Clojure data structures (maps, lists, vectors, sets etc.).</li>
</ul></li>
<li>Pure functions, and the substitution principle of reducing functional expressions down to the smallest form.</li>
<li>Recursive thinking / inductive reasoning (same thing)
<ul>
<li>Constructing base (&#34;empty&#34;) case, unit case, two case, three-case, and using that to generalise to the n-case (of <code>n</code> arguments to a function).</li>
</ul></li>
<li>Familiarity with writing functions having variable arguments</li>
<li>Familiarity with the stdlib (reduce and reductions, for example).</li>
<li>How to use &#34;code as data&#34;, for self-education, if nothing else.</li>
</ul>
<p>So… <code>comp</code>…</p>
<p>The REPL says…</p>
<pre><code>user=&gt; (clojure.repl/doc comp)
-------------------------
clojure.core/comp
([] [f] [f g] [f g &amp; fs])
Takes a set of functions and returns a fn that is the composition
of those fns.  The returned fn takes a variable number of args,
applies the rightmost of fns to the args, the next
fn (right-to-left) to the result, etc.
</code></pre>
<p>This means:</p>
<ul>
<li><code>comp</code>&#39;s type signature is <code>List[Function] -&gt; Function</code>.</li>
<li>It accepts functions as arguments, ergo functions must be &#34;normal&#34; values.</li>
<li>It <em>must</em> always return a function.</li>
<li>By definition, the returned function must be of exactly one argument.</li>
</ul>
<p>We consult Clojure Docs for <a href="https://clojuredocs.org/clojure.core/comp">examples illustrating what comp does</a>.</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>filter</span> (<span>comp</span> <span>not</span> <span>zero?</span>)</span>
<span id="cb2-2"><a href="#cb2-2" target="_self" aria-hidden="true" tabindex="-1"></a>        [<span>0</span> <span>1</span> <span>0</span> <span>2</span> <span>0</span> <span>3</span> <span>0</span> <span>4</span>])</span>
<span id="cb2-3"><a href="#cb2-3" target="_self" aria-hidden="true" tabindex="-1"></a><span>;;=&gt; (1 2 3 4)</span></span>
<span id="cb2-4"><a href="#cb2-4" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>def</span><span> negative-quotient</span></span>
<span id="cb2-7"><a href="#cb2-7" target="_self" aria-hidden="true" tabindex="-1"></a>  (<span>comp</span> <span>-</span> <span>/</span>))</span>
<span id="cb2-8"><a href="#cb2-8" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" target="_self" aria-hidden="true" tabindex="-1"></a>(negative-quotient <span>8</span> <span>3</span>)</span>
<span id="cb2-10"><a href="#cb2-10" target="_self" aria-hidden="true" tabindex="-1"></a><span>;;=&gt; -8/3</span></span>
<span id="cb2-11"><a href="#cb2-11" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>def</span><span> concat-and-reverse</span></span>
<span id="cb2-14"><a href="#cb2-14" target="_self" aria-hidden="true" tabindex="-1"></a>  (<span>comp</span> (<span>partial</span> <span>apply</span> <span>str</span>)</span>
<span id="cb2-15"><a href="#cb2-15" target="_self" aria-hidden="true" tabindex="-1"></a>        <span>reverse</span></span>
<span id="cb2-16"><a href="#cb2-16" target="_self" aria-hidden="true" tabindex="-1"></a>        <span>str</span>))</span>
<span id="cb2-17"><a href="#cb2-17" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" target="_self" aria-hidden="true" tabindex="-1"></a>(concat-and-reverse <span>&#34;hello&#34;</span> <span>&#34;clojuredocs&#34;</span>)</span>
<span id="cb2-19"><a href="#cb2-19" target="_self" aria-hidden="true" tabindex="-1"></a><span>;;=&gt; &#34;scoderujolcolleh&#34;</span></span>
<span id="cb2-20"><a href="#cb2-20" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" target="_self" aria-hidden="true" tabindex="-1"></a><span>;; etc...</span></span></code></pre></div>
<p>Now, to rewrite it in one&#39;s on words.</p>
<p>What might <code>comp</code> be doing?</p>
<p><code>comp</code>&#39;s argument list indicates it must handle several &#34;arities&#34; of arguments:</p>
<ul>
<li><em><strong>zero argument case</strong></em>: <code>comp</code> of nothing should &#34;do nothing&#34;. But <code>comp</code> <u>must</u> return a function. So what is the function of one argument that does &#34;nothing&#34;? <code>identity</code>, as you identified it.</li>
<li><em><strong>unit argument case</strong></em>: <code>comp</code> of <code>f</code> must return a function that &#34;does <code>f</code>&#34; to <del>a single argument</del> <em>potentially any number of</em> arguments <a href="#fn1" target="_self" id="fnref1" role="doc-noteref"><sup>1</sup></a>.
<ul>
<li>Thus the return value of <code>(comp f)</code> must be <code>(fn [&amp; x] (apply f x))</code>.</li>
<li><em><strong>However, I will use a simplification in <code>my-comp</code></strong></em>, which is our re-implementation, because it helps better analyze what&#39;s going on. After developing the analysis, I undo the simplification.</li>
<li>So <em>assume for now,</em> that <code>my-comp</code> of <code>f</code> returns a function that &#34;does <code>f</code>&#34; to a <em>single</em> argument… <code>(fn [x] (f x))</code>.</li>
<li>Now, we can proceed to other cases…</li>
</ul></li>
<li><em><strong>two argument case</strong></em>: <code>my-comp</code> of <code>f</code> and <code>g</code> must return a function that <u>first</u> &#34;does <code>g</code> to a single argument&#34;, then &#34;does <code>f</code>&#34; to the return value of <code>(g x)</code>. This is <code>(fn [x] (f (g x)))</code>.
<ul>
<li>Note how we have continued using our simplification for <code>g</code> as well as <code>f</code>.</li>
</ul></li>
<li><em><strong>three case</strong></em>: <code>my-comp</code> of <code>f</code>, <code>g</code>, <code>h</code> must return <code>(fn [x] (f
 (g (h x))))</code>. BUT this reduces to the two-case… <code>(fn [x] (f (g
 x&#39;)))</code>, where <code>(h x)</code> returns some new value <code>x&#39;</code> (pronounced &#34;x prime&#34;).</li>
<li><em><strong>n case</strong></em>: and so on… the &#39;n&#39; case will follow the same (inductive) reasoning and collapse down to the two-case.</li>
</ul>
<p>So, we essentially need to handle zero, one, and two argument cases, and figure out how to use that solution to handle the fully general <code>n</code> argument case.</p>
<p>And with this thought, if we know <code>reduce</code>, we can <a href="https://knowyourmeme.com/photos/572078-how-to-draw-an-owl">draw the rest of the Owl</a>…</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> my-comp</span></span>
<span id="cb4-2"><a href="#cb4-2" target="_self" aria-hidden="true" tabindex="-1"></a>  [&amp; funcs]</span>
<span id="cb4-3"><a href="#cb4-3" target="_self" aria-hidden="true" tabindex="-1"></a>  (<span>reduce</span> (<span>fn</span> [f g]</span>
<span id="cb4-4"><a href="#cb4-4" target="_self" aria-hidden="true" tabindex="-1"></a>            (<span>fn</span> [x]</span>
<span id="cb4-5"><a href="#cb4-5" target="_self" aria-hidden="true" tabindex="-1"></a>              (f (g x))))</span>
<span id="cb4-6"><a href="#cb4-6" target="_self" aria-hidden="true" tabindex="-1"></a>          <span>identity</span></span>
<span id="cb4-7"><a href="#cb4-7" target="_self" aria-hidden="true" tabindex="-1"></a>          funcs))</span>
<span id="cb4-8"><a href="#cb4-8" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; ((my-comp <span>reverse</span> <span>str</span> <span>inc</span>) <span>41</span>)</span>
<span id="cb4-10"><a href="#cb4-10" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>\2</span> <span>\4</span>)</span>
<span id="cb4-11"><a href="#cb4-11" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; ((my-comp <span>str</span> <span>inc</span>) <span>41</span>)</span>
<span id="cb4-12"><a href="#cb4-12" target="_self" aria-hidden="true" tabindex="-1"></a><span>&#34;42&#34;</span></span>
<span id="cb4-13"><a href="#cb4-13" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; ((my-comp <span>inc</span>) <span>41</span>)</span>
<span id="cb4-14"><a href="#cb4-14" target="_self" aria-hidden="true" tabindex="-1"></a><span>42</span></span>
<span id="cb4-15"><a href="#cb4-15" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; ((my-comp) <span>41</span>)</span>
<span id="cb4-16"><a href="#cb4-16" target="_self" aria-hidden="true" tabindex="-1"></a><span>41</span></span></code></pre></div>
<p>If this looks freaky, fear not… It took me a <em>long</em> time to figure out how to think like that &#34;natually&#34;. And it still freaks me out that this kind of thing &#34;just works&#34;. Give it time, it will come to you.</p>
<p>In general, the technique used above is called the &#34;substitution principle&#34;… how we turned the three-case into the two-case.</p>
<p>We can do it because there is no difference between a pure function <code>f</code> called on some <code>x</code>, and the return value arrived at… i.e. If <code>(f
x)</code> returns <code>x&#39;</code>, then you could just as well say <code>x&#39;</code>, and the consumer of the return value can be none the wiser.</p>
<p>Incidentally, <a href="https://en.wikipedia.org/wiki/Constant_folding">constant folding</a> in compilers is the same thing. If the compiler has all the information about what is calling what, then it can just say…</p>
<blockquote>
<p>&#34;Weeeeell… Obviously the program does not need to keep doing the work again and again because it will always end up at the same value. So, here you go, the final return value as it is supposed to be, hard-coded into the compiled binary…&#34;</p>
</blockquote>
<p>So I guess I&#39;m saying that understanding <code>comp</code>, can help understand <code>compiler</code>. I&#39;ll show myself out… (:</p>
<p>But that was typed well past midnight.</p>
<p>This morning my brain realised that it&#39;s possible to directly show how the reduction process itself unfolds…</p>
<p>First, let&#39;s rewrite the <code>reduce</code> body so that it only generates the fully-formed expression without evaluating anything. This is one of the little joys of being able to write our programs in terms of the data structures of the language (&#34;homoiconicity&#34;).</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> my-comp-no-eval</span></span>
<span id="cb5-2"><a href="#cb5-2" target="_self" aria-hidden="true" tabindex="-1"></a>  [&amp; funcs]</span>
<span id="cb5-3"><a href="#cb5-3" target="_self" aria-hidden="true" tabindex="-1"></a>  (<span>reduce</span> (<span>fn</span> [f g]</span>
<span id="cb5-4"><a href="#cb5-4" target="_self" aria-hidden="true" tabindex="-1"></a>            `(<span>fn</span> [x]</span>
<span id="cb5-5"><a href="#cb5-5" target="_self" aria-hidden="true" tabindex="-1"></a>               (<span>~f</span> (<span>~g</span> x))))</span>
<span id="cb5-6"><a href="#cb5-6" target="_self" aria-hidden="true" tabindex="-1"></a>          <span>identity</span></span>
<span id="cb5-7"><a href="#cb5-7" target="_self" aria-hidden="true" tabindex="-1"></a>              funcs))</span>
<span id="cb5-8"><a href="#cb5-8" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; (my-comp-no-eval <span>reverse</span> <span>str</span> <span>inc</span>)</span>
<span id="cb5-10"><a href="#cb5-10" target="_self" aria-hidden="true" tabindex="-1"></a>(clojure.core/fn [user/x]</span>
<span id="cb5-11"><a href="#cb5-11" target="_self" aria-hidden="true" tabindex="-1"></a>  ((clojure.core/fn [user/x]</span>
<span id="cb5-12"><a href="#cb5-12" target="_self" aria-hidden="true" tabindex="-1"></a>     ((clojure.core/fn [user/x]</span>
<span id="cb5-13"><a href="#cb5-13" target="_self" aria-hidden="true" tabindex="-1"></a>        (#object[clojure.core$identity <span>0x42c2f48c</span> <span>&#34;clojure.core$identity@42c2f48c&#34;</span>]</span>
<span id="cb5-14"><a href="#cb5-14" target="_self" aria-hidden="true" tabindex="-1"></a>         (#object[clojure.core$reverse <span>0x41aaedaa</span> <span>&#34;clojure.core$reverse@41aaedaa&#34;</span>] user/x)))</span>
<span id="cb5-15"><a href="#cb5-15" target="_self" aria-hidden="true" tabindex="-1"></a>      (#object[clojure.core$str <span>0x303a5119</span> <span>&#34;clojure.core$str@303a5119&#34;</span>] user/x)))</span>
<span id="cb5-16"><a href="#cb5-16" target="_self" aria-hidden="true" tabindex="-1"></a>   (#object[clojure.core$inc <span>0x75b3673</span> <span>&#34;clojure.core$inc@75b3673&#34;</span>] user/x)))</span></code></pre></div>
<p>We can do one better, and directly visualise <em><strong>every step of the reduction process</strong></em>, using <code>reductions</code> instead of <code>reduce</code>.</p>
<p>Read this doozy &#34;bottom to top&#34;.</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> my-comp-no-eval-show-steps</span></span>
<span id="cb6-2"><a href="#cb6-2" target="_self" aria-hidden="true" tabindex="-1"></a>  [&amp; funcs]</span>
<span id="cb6-3"><a href="#cb6-3" target="_self" aria-hidden="true" tabindex="-1"></a>  (reductions (<span>fn</span> [f g]</span>
<span id="cb6-4"><a href="#cb6-4" target="_self" aria-hidden="true" tabindex="-1"></a>                `(<span>fn</span> [x]</span>
<span id="cb6-5"><a href="#cb6-5" target="_self" aria-hidden="true" tabindex="-1"></a>                   (<span>~f</span> (<span>~g</span> x))))</span>
<span id="cb6-6"><a href="#cb6-6" target="_self" aria-hidden="true" tabindex="-1"></a>              <span>identity</span></span>
<span id="cb6-7"><a href="#cb6-7" target="_self" aria-hidden="true" tabindex="-1"></a>              funcs))</span>
<span id="cb6-8"><a href="#cb6-8" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; (my-comp-no-eval-show-steps <span>reverse</span> <span>str</span> <span>inc</span>)</span>
<span id="cb6-10"><a href="#cb6-10" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" target="_self" aria-hidden="true" tabindex="-1"></a><span>;; FINAL REDUCTION...</span></span>
<span id="cb6-12"><a href="#cb6-12" target="_self" aria-hidden="true" tabindex="-1"></a><span>;; Retuns identity of whatever value is computed.</span></span>
<span id="cb6-13"><a href="#cb6-13" target="_self" aria-hidden="true" tabindex="-1"></a>(#object[clojure.core$identity <span>0x42c2f48c</span> <span>&#34;clojure.core$identity@42c2f48c&#34;</span>]</span>
<span id="cb6-14"><a href="#cb6-14" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" target="_self" aria-hidden="true" tabindex="-1"></a> <span>;; BEFORE THAT:</span></span>
<span id="cb6-16"><a href="#cb6-16" target="_self" aria-hidden="true" tabindex="-1"></a> <span>;; The &#39;two arguments case&#39; is reduced to the &#39;one argument case&#39;.</span></span>
<span id="cb6-17"><a href="#cb6-17" target="_self" aria-hidden="true" tabindex="-1"></a> (clojure.core/fn [user/x]</span>
<span id="cb6-18"><a href="#cb6-18" target="_self" aria-hidden="true" tabindex="-1"></a>   (#object[clojure.core$identity <span>0x42c2f48c</span> <span>&#34;clojure.core$identity@42c2f48c&#34;</span>]</span>
<span id="cb6-19"><a href="#cb6-19" target="_self" aria-hidden="true" tabindex="-1"></a>    (#object[clojure.core$reverse <span>0x41aaedaa</span> <span>&#34;clojure.core$reverse@41aaedaa&#34;</span>] user/x)))</span>
<span id="cb6-20"><a href="#cb6-20" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" target="_self" aria-hidden="true" tabindex="-1"></a> <span>;; BEFORE THAT:</span></span>
<span id="cb6-22"><a href="#cb6-22" target="_self" aria-hidden="true" tabindex="-1"></a> <span>;; The &#39;three arguments case&#39; is reduced to the &#39;two argument case&#39;</span></span>
<span id="cb6-23"><a href="#cb6-23" target="_self" aria-hidden="true" tabindex="-1"></a> (clojure.core/fn [user/x]</span>
<span id="cb6-24"><a href="#cb6-24" target="_self" aria-hidden="true" tabindex="-1"></a>   ((clojure.core/fn [user/x]</span>
<span id="cb6-25"><a href="#cb6-25" target="_self" aria-hidden="true" tabindex="-1"></a>      (#object[clojure.core$identity <span>0x42c2f48c</span> <span>&#34;clojure.core$identity@42c2f48c&#34;</span>]</span>
<span id="cb6-26"><a href="#cb6-26" target="_self" aria-hidden="true" tabindex="-1"></a>       (#object[clojure.core$reverse <span>0x41aaedaa</span> <span>&#34;clojure.core$reverse@41aaedaa&#34;</span>] user/x)))</span>
<span id="cb6-27"><a href="#cb6-27" target="_self" aria-hidden="true" tabindex="-1"></a>    (#object[clojure.core$str <span>0x303a5119</span> <span>&#34;clojure.core$str@303a5119&#34;</span>] user/x)))</span>
<span id="cb6-28"><a href="#cb6-28" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" target="_self" aria-hidden="true" tabindex="-1"></a> <span>;; THE VERY BEGINNING:</span></span>
<span id="cb6-30"><a href="#cb6-30" target="_self" aria-hidden="true" tabindex="-1"></a> <span>;; Starting form of the computation, before the reduction process kicks off.</span></span>
<span id="cb6-31"><a href="#cb6-31" target="_self" aria-hidden="true" tabindex="-1"></a> (clojure.core/fn [user/x]</span>
<span id="cb6-32"><a href="#cb6-32" target="_self" aria-hidden="true" tabindex="-1"></a>   ((clojure.core/fn [user/x]</span>
<span id="cb6-33"><a href="#cb6-33" target="_self" aria-hidden="true" tabindex="-1"></a>      ((clojure.core/fn [user/x]</span>
<span id="cb6-34"><a href="#cb6-34" target="_self" aria-hidden="true" tabindex="-1"></a>         (#object[clojure.core$identity <span>0x42c2f48c</span> <span>&#34;clojure.core$identity@42c2f48c&#34;</span>]</span>
<span id="cb6-35"><a href="#cb6-35" target="_self" aria-hidden="true" tabindex="-1"></a>          (#object[clojure.core$reverse <span>0x41aaedaa</span> <span>&#34;clojure.core$reverse@41aaedaa&#34;</span>] user/x)))</span>
<span id="cb6-36"><a href="#cb6-36" target="_self" aria-hidden="true" tabindex="-1"></a>       (#object[clojure.core$str <span>0x303a5119</span> <span>&#34;clojure.core$str@303a5119&#34;</span>] user/x)))</span>
<span id="cb6-37"><a href="#cb6-37" target="_self" aria-hidden="true" tabindex="-1"></a>    (#object[clojure.core$inc <span>0x75b3673</span> <span>&#34;clojure.core$inc@75b3673&#34;</span>] user/x))))</span></code></pre></div>
<p><em><strong>And finally, we have to undo our simplifying constraint…</strong></em></p>
<ul>
<li>Instead of saying <code>my-comp</code> always returns a function of one argument, we say <code>my-comp</code>, just like <code>comp</code> must return a function capable of handling <u>any</u> number of arguments.</li>
</ul>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>defn</span><span> my-comp-with-var-args-support</span></span>
<span id="cb7-2"><a href="#cb7-2" target="_self" aria-hidden="true" tabindex="-1"></a>  [&amp; funcs]</span>
<span id="cb7-3"><a href="#cb7-3" target="_self" aria-hidden="true" tabindex="-1"></a>  (<span>reduce</span> (<span>fn</span> [f g]</span>
<span id="cb7-4"><a href="#cb7-4" target="_self" aria-hidden="true" tabindex="-1"></a>            <span>;; &#34;wrap&#34; &#39;x&#39; into a variable-length collection</span></span>
<span id="cb7-5"><a href="#cb7-5" target="_self" aria-hidden="true" tabindex="-1"></a>            (<span>fn</span> [&amp; x]</span>
<span id="cb7-6"><a href="#cb7-6" target="_self" aria-hidden="true" tabindex="-1"></a>              <span>;; use apply to &#34;unwrap&#34; &#39;x&#39; and,</span></span>
<span id="cb7-7"><a href="#cb7-7" target="_self" aria-hidden="true" tabindex="-1"></a>              <span>;; call &#39;g&#39; with the unwrapped values</span></span>
<span id="cb7-8"><a href="#cb7-8" target="_self" aria-hidden="true" tabindex="-1"></a>              (f (<span>apply</span> g x))))</span>
<span id="cb7-9"><a href="#cb7-9" target="_self" aria-hidden="true" tabindex="-1"></a>          <span>identity</span></span>
<span id="cb7-10"><a href="#cb7-10" target="_self" aria-hidden="true" tabindex="-1"></a>          funcs))</span>
<span id="cb7-11"><a href="#cb7-11" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; ((my-comp-with-var-args-support <span>reverse</span> <span>str</span> <span>inc</span> <span>+</span>) <span>20</span> <span>20</span> <span>1</span>)</span>
<span id="cb7-13"><a href="#cb7-13" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>\2</span> <span>\4</span>)</span>
<span id="cb7-14"><a href="#cb7-14" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; ((my-comp-with-var-args-support <span>reverse</span> <span>str</span> <span>inc</span>) <span>20</span> <span>20</span> <span>1</span>)</span>
<span id="cb7-16"><a href="#cb7-16" target="_self" aria-hidden="true" tabindex="-1"></a>Execution error (ArityException) at user$my_comp_with_var_args_support$fn__134$fn__135/doInvoke (REPL<span>:8</span>).</span>
<span id="cb7-17"><a href="#cb7-17" target="_self" aria-hidden="true" tabindex="-1"></a>Wrong number of args (<span>3</span>) passed to: clojure.core/inc</span>
<span id="cb7-18"><a href="#cb7-18" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; ((my-comp-with-var-args-support <span>reverse</span> <span>str</span> <span>inc</span>) <span>41</span>)</span>
<span id="cb7-20"><a href="#cb7-20" target="_self" aria-hidden="true" tabindex="-1"></a>(<span>\2</span> <span>\4</span>)</span></code></pre></div>
<ul>
<li>And we retain error parity with <code>comp</code>… The error condition of any function is are part of that function&#39;s contract with its caller.</li>
</ul>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; ((my-comp-with-var-args-support) <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>)</span>
<span id="cb8-2"><a href="#cb8-2" target="_self" aria-hidden="true" tabindex="-1"></a>Execution error (ArityException) at user/eval139 (REPL<span>:1</span>).</span>
<span id="cb8-3"><a href="#cb8-3" target="_self" aria-hidden="true" tabindex="-1"></a>Wrong number of args (<span>5</span>) passed to: clojure.core/identity</span>
<span id="cb8-4"><a href="#cb8-4" target="_self" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" target="_self" aria-hidden="true" tabindex="-1"></a>user=&gt; ((<span>comp</span>) <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>)</span>
<span id="cb8-6"><a href="#cb8-6" target="_self" aria-hidden="true" tabindex="-1"></a>Execution error (ArityException) at user/eval141 (REPL<span>:1</span>).</span>
<span id="cb8-7"><a href="#cb8-7" target="_self" aria-hidden="true" tabindex="-1"></a>Wrong number of args (<span>5</span>) passed to: clojure.core/identity</span></code></pre></div>
<p>That&#39;s it for now.</p>
<p>If you like this, you may like to learn of the <a href="https://www.evalapply.org/posts/n-ways-to-fizzbuzz-in-clojure/index.html#main">n ways to fizzbuzz in Clojure</a>.</p>


  </section>
  
</article>
  </main>
      
    </div></div>
  </body>
</html>
