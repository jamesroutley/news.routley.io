<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://datastation.multiprocess.io/blog/2022-02-08-the-world-of-postgresql-wire-compatibility.html">Original</a>
    <h1>The world of PostgreSQL wire compatibility</h1>
    
    <div id="readability-page-1" class="page"><section>
  <div>
    
    
    <p>
      Published on <span>February 8, 2022</span> by 
    </p>
    <p><span>postgres</span><span>databases</span><span>python</span></p>
    
<p>
  A wire protocol is the format for interactions between a database
  server and its clients. It encompasses authentication, sending
  queries, receiving responses, and so on. It is a description of the
  exact bytes sent and received by servers and clients. It does NOT
  encompass the actual query language itself, let alone database
  semantics.
</p>

<p>
  Every server-client database has a wire protocol. (SQLite is an
  embedded database, not a server-client database, so it does not have
  a wire protocol.) Wire protocols are important to both database
  developers and database driver developers.
</p>
<p>
  Proprietary databases like Oracle and IBM Db2 find value in
  developing their own drivers. They don&#39;t tend to publish their wire
  protocol. Among other reasons, it&#39;s just not necessary since they
  develop their own drivers. Proprietary vendors tend to prefer a
  monolithic driver like ODBC/JDBC rather than native drivers since
  it&#39;s easier to develop one driver for all languages than one for
  each language. If someone wants to develop a native driver for a
  database without a published wire protocol they&#39;ll need to
  reverse-engineer the wire protocol. An example of this is the <a href="https://github.com/sijms/go-ora">go-ora</a>
  Oracle client for Go.
</p>
<p>
  Worth noting, among proprietary vendors, SQL Server actually does
  the opposite. Their wire protocol has
  been <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/b46a581a-39de-4745-b076-ec4dbb7d13ec">publicly
  documented</a> for over a decade. And more native drivers exist for
  SQL Server than for other proprietary vendors with their own wire
  protocol.
</p>
<p>
  In contrast, the wire protocols for open-source databases tend to be
  documented since it&#39;s just another part of an open-source
  system. Due to their popularity and age, PostgreSQL and MySQL wire
  protocols are particularly well documented. Native drivers exist for
  both databases in every major language.
</p>
<p>
  For this reason, a large number of newer database vendors just reuse
  the PostgreSQL or MySQL wire protocol. This means that every
  existing driver (and SQL GUI like <a href="https://datastation.multiprocess.io/">DataStation</a>) will
  work with them without any modification to driver code. This doesn&#39;t
  mean that any PostgreSQL or MySQL <i>query</i> will work with them since,
  as mentioned previously,
  query language and database semantics are independent of the
  wire protocol.
</p>
<h2>In Practice</h2>
<p>
  Let&#39;s write a simple program that can handle query text and read
  data from disk. If it implements the PostgreSQL wire protocol
  protocol, it would work with any existing PostgreSQL client. That
  would be neat!
</p>
<p>
  Someone
  already <a href="https://gist.github.com/matteobertozzi/7670985">wrote
  a small library</a> implementing the PostgreSQL server protocol in
  Python2. I <a href="https://gist.github.com/eatonphil/079f8654174b9b9c1953b76008d024ae">ported
  it to Python3</a> for the sake of this tutorial. So we can just grab
  that Python3 fork&#39;s code and edit the <code>query</code> method with
  some code that handles the query text and reads data from disk, and
  we&#39;d be done!
</p>
<p>
  To reiterate, the wire protocol doesn&#39;t specify anything about the
  query language. So let&#39;s support a single made-up
  query: <code>SELECT FROM x</code> where <code>x</code> can be a
  valid table name:
</p>
<pre><code>$ diff original.py pgserver.py
0a1
&gt; import json
189,190c190,202
&lt;     fields = [IntField(&#39;a&#39;), IntField(&#39;b&#39;)]
&lt;     rows = [[1, 2], [3, 4], [5, 6]]
---
&gt;     sql = sql.decode().upper()
&gt;     prefix = &#39;SELECT FROM &#39;
&gt;     if not sql.startswith(prefix):
&gt;       raise Exception(&#39;Bad query.&#39;)
&gt;
&gt;     table = sql.strip()[len(prefix):-2].strip().lower()
&gt;     try:
&gt;       with open(&#39;data/&#39;+table+&#39;.json&#39;) as f:
&gt;         d = json.load(f)
&gt;         fields = [IntField(k) for k in d[0].keys()]
&gt;         rows = [[row[field.name] for field in fields] for row in d]
&gt;     except Exception as e:
&gt;       raise Exception(&#39;Invalid table.&#39;) from e</code></pre>
<p>
  Now let&#39;s create a <code>data</code> directory where
  all the table JSON files will be stored. And let&#39;s create a few
  tables:
</p>
<pre><code>$ cat data/users.json
[
    {&#34;id&#34;: 0, &#34;age&#34;: 100},
    {&#34;id&#34;: 1, &#34;age&#34;: 45},
    {&#34;id&#34;: 2, &#34;age&#34;: 52}
]
$ cat data/users_organization.json
[
    {&#34;user_id&#34;: 0, &#34;organization_id&#34;: 0},
    {&#34;user_id&#34;: 1, &#34;organization_id&#34;: 1},
    {&#34;user_id&#34;: 2, &#34;organization_id&#34;: 0}
]</code></pre>
<p>
  Run it:
</p>
<pre><code>$ python pgserver.py
server running, try: $ psql -h localhost -p 55432
</code></pre>
<p>
  And in a separate terminal, open psql as suggested (enter any text
  when prompted for a password, this code doesn&#39;t do anything with
  it), and run some queries:
</p>
<pre><code>$ psql -h localhost -p 55432
Password for user phil:
psql (13.4, server 0.0.0)
Type &#34;help&#34; for help.

phil=&gt; select from users;
 id | age
----+-----
  0 | 100
  1 |  45
  2 |  52
(3 rows)

phil=&gt; select from users_organization;
 user_id | organization_id
---------+-----------------
       0 |               0
       1 |               1
       2 |               0
(3 rows)
</code></pre>
<p>
  That is really neat! Incidentally a similar technique can be used to
  help in testing a
  la <a href="https://github.com/jackc/pgmock">pgmock</a>.
</p>
<h2>Vendors</h2>
<p>
  But let&#39;s get back to the real world, dig into some of the
  databases that implement the PostgreSQL wire protocol, and see where else
  they diverge.
</p>
<p>
  And although this table mentions compatibility, don&#39;t take
  that to be a judgement call. Just because a database implements the
  PostgreSQL wire protocol does not mean it intends to be a drop-in
  replacement for PostgreSQL.
</p>
</div>
</section><section>
<div>
<p>
  * Not reusing PostgreSQL&#39;s parser does make it somewhat more likely
    for there to be differences in complex SQL queries compared to
    PostgreSQL
  </p>
<p>
  And a special shoutout to ClickHouse that according to its config
  example can <a href="https://github.com/ClickHouse/ClickHouse/blob/v22.1.3.7-stable/programs/server/config.xml#L114">pretend
  to be PostgreSQL and, separately, MySQL</a>. But since <a href="https://github.com/ClickHouse/ClickHouse/discussions/29705">this
  isn&#39;t documented</a> nor can I find the PostgreSQL parser code (but
  I can find the <a href="https://github.com/ClickHouse/ClickHouse/tree/master/src/Parsers/MySQL">MySQL
  parser code</a>) I won&#39;t include it in this list.
</p>
<p>
  I&#39;m sure I missed some. Message me with other PostgreSQL
  wire-compatible databases I should include here!
</p>
<h3>Syntax and engine support</h3>
<p>
  A parser is only the start of compatibility though. Just because a
  parser supports some syntax doesn&#39;t mean that the engine supports it
  too. But you can be more sure that if a parser doesn&#39;t support some
  syntax, the engine can&#39;t support it either (unless the project keeps
  dead code around, which isn&#39;t common).
</p>
<p>
  And an implementation that falls behind on parser support is likely
  to fall behind in other areas of compatibility. This is not to say
  that one vendor is better or worse. Excellent engineering can almost
  always overcome these types of obstacles. But there are always
  implications to technical design decisions.
</p>
<p>
  So just looking at parser support is not enough to talk about
  PostgreSQL query or semantic compatibility. But it is a starting
  point.
</p>
<h3>Wire protocol edge cases, another time</h3>
<p>
  Lastly, I said this post was about wire protocols but then I ended
  up focusing on the query language (which as I mentioned is separate
  from the wire protocol). The wire protocol does more than just wrap
  queries though. It includes more complex interactions
  like <code>COPY</code>-ing data or asynchronous requests or
  cancelling running requests.
</p>
<p>
  In this post I did not evaluate the level of completeness of each
  database&#39;s implementation of the wire protocol. I only looked into
  what they&#39;d do with basic queries. More could be done on evaluating
  the edge cases of the wire protocol in each implementation, in
  another post.
</p>
<p>
  Let me know about your ideas, questions, corrections!
</p>
<h4>Share</h4>
<blockquote><p lang="en" dir="ltr">There&#39;s a wide world of databases implementing the Postgres wire protocol. Databases like <a href="https://twitter.com/Yugabyte?ref_src=twsrc%5Etfw">@Yugabyte</a> <a href="https://twitter.com/TimescaleDB?ref_src=twsrc%5Etfw">@TimescaleDB</a> <a href="https://twitter.com/cratedb?ref_src=twsrc%5Etfw">@cratedb</a> <a href="https://twitter.com/QuestDb?ref_src=twsrc%5Etfw">@QuestDb</a> <a href="https://twitter.com/CockroachDB?ref_src=twsrc%5Etfw">@CockroachDB</a> . But what does that mean? And where does the wire protcol end?</p>— Multiprocess Labs (@multiprocessio) <a href="https://twitter.com/multiprocessio/status/1491164918057693185?ref_src=twsrc%5Etfw">February 8, 2022</a></blockquote> 

    <p>
      Questions? Feedback? Feel free to reach the author at phil@multiprocess.io.
    </p>
    
</div></section></div>
  </body>
</html>
