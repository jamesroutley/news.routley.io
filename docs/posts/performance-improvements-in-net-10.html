<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/">Original</a>
    <h1>Performance Improvements in .NET 10</h1>
    
    <div id="readability-page-1" class="page"><div id="single-wrapper">
    
    <article data-clarity-region="article" id="post-57952">
        <div data-bi-area="body_article" data-bi-id="post_page_body_article">
            <p>My kids <em>love</em> “Frozen”. They can sing every word, re-enact every scene, and provide detailed notes on the proper sparkle of Elsa’s ice dress. I’ve seen the movie more times than I can recount, to the point where, if you’ve seen me do any live coding, you’ve probably seen my subconscious incorporate an Arendelle reference or two. After so many viewings, I began paying closer attention to the details, like how at the very beginning of the film the ice harvesters are singing a song that subtly foreshadows the story’s central conflicts, the characters’ journeys, and even the key to resolving the climax. I’m slightly ashamed to admit I didn’t comprehend this connection until viewing number ten or so, at which point I also realized I had no idea if this ice harvesting was actually “a thing” or if it was just a clever vehicle for Disney to spin a yarn. Turns out, as I subsequently researched, it’s quite real.</p>
<p>In the 19th century, before refrigeration, ice was an incredibly valuable commodity. Winters in the northern United States turned ponds and lakes into seasonal gold mines. The most successful operations ran with precision: workers cleared snow from the surface so the ice would grow thicker and stronger, and they scored the surface into perfect rectangles using horse-drawn plows, turning the lake into a frozen checkerboard. Once the grid was cut, teams with long saws worked to free uniform blocks weighing several hundred pounds each. These blocks were floated along channels of open water toward the shore, at which point men with poles levered the blocks up ramps and hauled them into storage. Basically, what the movie shows.</p>
<p>The storage itself was an art. Massive wooden ice houses, sometimes holding tens of thousands of tons, were lined with insulation, typically straw. Done well, this insulation could keep the ice solid for months, even through summer heat. Done poorly, you would open the doors to slush. And for those moving ice over long distances, typically by ship, every degree, every crack in the insulation, every extra day in transit meant more melting and more loss.</p>
<p>Enter Frederic Tudor, the “Ice King” of Boston. He was obsessed with systemic efficiency. Where competitors saw unavoidable loss, Tudor saw a solvable problem. After experimenting with different insulators, he leaned on cheap sawdust, a lumber mill byproduct that outperformed straw, packing it densely around the ice to cut melt losses significantly. For harvesting efficiency, his operations adopted Nathaniel Jarvis Wyeth’s grid-scoring system, which produced uniform blocks that could be packed tightly, minimizing air gaps that would otherwise increase exposure in a ship’s hold. And to shorten the critical time between shore and ship, Tudor built out port infrastructure and depots near docks, allowing ships to load and unload much faster. Each change, from tools to ice house design to logistics, amplified the last, turning a risky local harvest into a reliable global trade. With Tudor’s enhancements, he had solid ice arriving in places like Havana, Rio de Janeiro, and even Calcutta (a voyage of four months in the 1830s). His performance gains allowed the product to survive journeys that were previously unthinkable.</p>
<p>What made Tudor’s ice last halfway around the world wasn’t one big idea. It was a plethora of small improvements, each multiplying the effect of the last. In software development, the same principle holds: big leaps forward in performance rarely come from a single sweeping change, rather from hundreds or thousands of targeted optimizations that compound into something transformative. .NET 10’s performance story isn’t about one Disney-esque magical idea; it’s about carefully shaving off nanoseconds here and tens of bytes there, streamlining operations that are executed trillions of times.</p>
<p>In the rest of this post, just as we did in Performance Improvements in <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/">.NET 9</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/">.NET 8</a>, <a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/">.NET 7</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6">.NET 6</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5">.NET 5</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0">.NET Core 3.0</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1">.NET Core 2.1</a>, and <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core">.NET Core 2.0</a>, we’ll dig into hundreds of the small but meaningful and compounding performance improvements since .NET 9 that make up .NET 10’s story (if you instead stay on LTS releases and thus are upgrading from .NET 8 instead of from .NET 9, you’ll see even more improvements based on the aggregation from all the <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/">improvements in .NET 9</a> as well). So, without further ado, go grab a cup of your favorite hot beverage (or, given my intro, maybe something a bit more frosty), sit back, relax, and “Let It Go”!</p>
<p>Or, hmm, maybe, let’s push performance “Into the Unknown”?</p>
<p>Let .NET 10 performance “Show Yourself”?</p>
<p>“Do You Want To Build a <del>Snowman</del> Fast Service?”</p>
<p>I’ll see myself out.</p>
<h2>Benchmarking Setup</h2>
<p>As in previous posts, this tour is chock full of micro-benchmarks intended to showcase various performance improvements. Most of these benchmarks are implemented using <a href="https://www.nuget.org/packages/BenchmarkDotNet/0.15.2">BenchmarkDotNet 0.15.2</a>, with a simple setup for each.</p>
<p>To follow along, make sure you have <a href="https://dotnet.microsoft.com/download/dotnet/9.0">.NET 9</a> and <a href="https://dotnet.microsoft.com/download/dotnet/10.0">.NET 10</a> installed, as most of the benchmarks compare the same test running on each. Then, create a new C# project in a new <code>benchmarks</code> directory:</p>
<pre><code>dotnet new console -o benchmarks
cd benchmarks</code></pre>
<p>That will produce two files in the <code>benchmarks</code> directory: <code>benchmarks.csproj</code>, which is the project file with information about how the application should be compiled, and <code>Program.cs</code>, which contains the code for the application. Finally, replace everything in <code>benchmarks.csproj</code> with this:</p>
<pre><code>&lt;Project Sdk=&#34;Microsoft.NET.Sdk&#34;&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFrameworks&gt;net10.0;net9.0&lt;/TargetFrameworks&gt;
    &lt;LangVersion&gt;Preview&lt;/LangVersion&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&#34;BenchmarkDotNet&#34; Version=&#34;0.15.2&#34; /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;</code></pre>
<p>With that, we’re good to go. Unless otherwise noted, I’ve tried to make each benchmark standalone; just copy/paste its whole contents into the Program.cs file, overwriting everything that’s there, and then run the benchmarks. Each test includes at its top a comment for the <code>dotnet</code> command to use to run the benchmark. It’s typically something like this:</p>
<pre><code>dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0</code></pre>
<p>which will run the benchmark in release on both .NET 9 and .NET 10 and show the compared results. The other common variation, used when the benchmark should only be run on .NET 10 (typically because it’s comparing two approaches rather than comparing one thing on two versions), is the following:</p>
<pre><code>dotnet run -c Release -f net10.0 --filter &#34;*&#34;</code></pre>
<p>Throughout the post, I’ve shown many benchmarks and the results I received from running them. Unless otherwise stated (e.g. because I’m demonstrating an OS-specific improvement), the results shown are from running them on Linux (Ubuntu 24.04.1) on an x64 processor.</p>
<pre><code>BenchmarkDotNet v0.15.2, Linux Ubuntu 24.04.1 LTS (Noble Numbat)
11th Gen Intel Core i9-11950H 2.60GHz, 1 CPU, 16 logical and 8 physical cores
.NET SDK 10.0.100-rc.1.25451.107
  [Host]     : .NET 9.0.9 (9.0.925.41916), X64 RyuJIT AVX-512F+CD+BW+DQ+VL+VBMI</code></pre>
<p>As always, a quick disclaimer: these are micro-benchmarks, timing operations so short you’d miss them by blinking (but when such operations run millions of times, the savings really add up). The exact numbers you get will depend on your hardware, your operating system, what else your machine is juggling at the moment, how much coffee you’ve had since breakfast, and perhaps whether Mercury is in retrograde. In other words, don’t expect your results to match mine exactly, but I’ve picked tests that should still be reasonably reproducible in the real world.</p>
<p>Now, let’s start at the bottom of the stack. Code generation.</p>
<h2>JIT</h2>
<p>Among all areas of .NET, the Just-In-Time (JIT) compiler stands out as one of the most impactful. Every .NET application, whether a small console tool or a large-scale enterprise service, ultimately relies on the JIT to turn intermediate language (IL) code into optimized machine code. Any enhancement to the JIT’s generated code quality has a ripple effect, improving performance across the entire ecosystem without requiring developers to change any of their own code or even recompile their C#. And with .NET 10, there’s no shortage of these improvements.</p>
<h3>Deabstraction</h3>
<p>As with many languages, .NET historically has had an “abstraction penalty,” those extra allocations and indirections that can occur when using high-level language features like interfaces, iterators, and delegates. Each year, the JIT gets better and better at optimizing away layers of abstraction, so that developers get to write simple code and still get great performance. .NET 10 continues this tradition. The result is that idiomatic C# (using interfaces, <code>foreach</code> loops, lambdas, etc.) runs even closer to the raw speed of meticulously crafted and hand-tuned code.</p>
<h4>Object Stack Allocation</h4>
<p>One of the most exciting areas of deabstraction progress in .NET 10 is the expanded use of escape analysis to enable stack allocation of objects. Escape analysis is a compiler technique to determine whether an object allocated in a method escapes that method, meaning determining whether that object is reachable after the method returns (for example, by being stored in a field or returned to the caller) or used in some way that the runtime can’t track within the method (like passed to an unknown callee). If the compiler can prove an object doesn’t escape, then that object’s lifetime is bounded by the method, and it can be allocated on the stack instead of on the heap. Stack allocation is much cheaper (just pointer bumping for allocation and automatic freeing when the method exits) and reduces GC pressure because, well, the object doesn’t need to be tracked by the GC. .NET 9 had already introduced some limited escape analysis and stack allocation support; .NET 10 takes this significantly further.</p>
<p><a href="https://github.com/dotnet/runtime/pull/115172">dotnet/runtime#115172</a> teaches the JIT how to perform escape analysis related to delegates, and in particular that a delegate’s <code>Invoke</code> method (which is implemented by the runtime) does not stash away the <code>this</code> reference. Then if escape analysis can prove that the delegate’s object reference is something that otherwise hasn’t escaped, the delegate can effectively evaporate. Consider this benchmark:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;y&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(42)]
    public int Sum(int y)
    {
        Func&lt;int, int&gt; addY = x =&gt; x + y;
        return DoubleResult(addY, y);
    }

    private int DoubleResult(Func&lt;int, int&gt; func, int arg)
    {
        int result = func(arg);
        return result + result;
    }
}</code></pre>
<p>If we just run this benchmark and compare .NET 9 and .NET 10, we can immediately tell something interesting is happening.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>.NET 9.0</td>
<td>19.530 ns</td>
<td>1.00</td>
<td>118 B</td>
<td>88 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Sum</td>
<td>.NET 10.0</td>
<td>6.685 ns</td>
<td>0.34</td>
<td>32 B</td>
<td>24 B</td>
<td>0.27</td>
</tr>
</tbody>
</table>
<p>The C# code for <code>Sum</code> belies complicated code generation by the C# compiler. It needs to create a <code>Func&lt;int, int&gt;</code>, which is “closing over” the <code>y</code> “local”. That means the compiler needs to “lift” <code>y</code> to no longer be an actual local, and instead live as a field on an object; the delegate can then point to a method on that object, giving it access to <code>y</code>. This is approximately what the IL generated by the C# compiler looks like when decompiled to C#:</p>
<pre><code>public int Sum(int y)
{
    &lt;&gt;c__DisplayClass0_0 c = new();
    c.y = y;

    Func&lt;int, int&gt; func = new(c.&lt;Sum&gt;b__0);

    return DoubleResult(func, c.y);
}

private sealed class &lt;&gt;c__DisplayClass0_0
{
    public int y;

    internal int &lt;Sum&gt;b__0(int x) =&gt; x + y;
}</code></pre>
<p>From that, we can see the closure is resulting in two allocations: an allocation for the “display class” (what the C# compiler calls these closure types) and an allocation for the delegate that points to the <code>&lt;Sum&gt;b__0</code> method on that display class instance. That’s what’s accounting for the <code>88</code> bytes of allocation in the .NET 9 results: the display class is 24 bytes, and the delegate is 64 bytes. In the .NET 10 version, though, we only see a 24 byte allocation; that’s because the JIT has successfully elided the delegate allocation. Here is the resulting assembly code:</p>
<pre><code>; .NET 9
; Tests.Sum(Int32)
       push      rbp
       push      r15
       push      rbx
       lea       rbp,[rsp+10]
       mov       ebx,esi
       mov       rdi,offset MT_Tests+&lt;&gt;c__DisplayClass0_0
       call      CORINFO_HELP_NEWSFAST
       mov       r15,rax
       mov       [r15+8],ebx
       mov       rdi,offset MT_System.Func&lt;System.Int32, System.Int32&gt;
       call      CORINFO_HELP_NEWSFAST
       mov       rbx,rax
       lea       rdi,[rbx+8]
       mov       rsi,r15
       call      CORINFO_HELP_ASSIGN_REF
       mov       rax,offset Tests+&lt;&gt;c__DisplayClass0_0.&lt;Sum&gt;b__0(Int32)
       mov       [rbx+18],rax
       mov       esi,[r15+8]
       cmp       [rbx+18],rax
       jne       short M00_L01
       mov       rax,[rbx+8]
       add       esi,[rax+8]
       mov       eax,esi
M00_L00:
       add       eax,eax
       pop       rbx
       pop       r15
       pop       rbp
       ret
M00_L01:
       mov       rdi,[rbx+8]
       call      qword ptr [rbx+18]
       jmp       short M00_L00
; Total bytes of code 112

; .NET 10
; Tests.Sum(Int32)
       push      rbx
       mov       ebx,esi
       mov       rdi,offset MT_Tests+&lt;&gt;c__DisplayClass0_0
       call      CORINFO_HELP_NEWSFAST
       mov       [rax+8],ebx
       mov       eax,[rax+8]
       mov       ecx,eax
       add       eax,ecx
       add       eax,eax
       pop       rbx
       ret
; Total bytes of code 32</code></pre>
<p>In both .NET 9 and .NET 10, the JIT successfully inlined <code>DoubleResult</code>, such that the delegate doesn’t escape, but then in .NET 10, it’s able to stack allocate it. Woo hoo! There’s obviously still future opportunity here, as the JIT doesn’t elide the allocation of the closure object, but that should be addressable with some more effort, hopefully in the near future.</p>
<p><a href="https://github.com/dotnet/runtime/pull/104906">dotnet/runtime#104906</a> from <a href="https://github.com/hez2010">@hez2010</a> and <a href="https://github.com/dotnet/runtime/pull/112250">dotnet/runtime#112250</a> extend this kind of analysis and stack allocation to arrays. How many times have you written code like this?</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public void Test()
    {
        Process(new string[] { &#34;a&#34;, &#34;b&#34;, &#34;c&#34; });

        static void Process(string[] inputs)
        {
            foreach (string input in inputs)
            {
                Use(input);
            }

            [MethodImpl(MethodImplOptions.NoInlining)]
            static void Use(string input) { }
        }
    }
}</code></pre>
<p>Some method I want to call accepts an array of inputs and does something for each input. I need to allocate an array to pass my inputs in, either explicitly, or maybe implicitly due to using <code>params</code> or a collection expression. Ideally moving forward there would be an overload of such a <code>Process</code> method that accepted a <code>ReadOnlySpan&lt;string&gt;</code> instead of a <code>string[]</code>, and I could then avoid the allocation by construction. But for all of these cases where I’m forced to create an array, .NET 10 comes to the rescue.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test</td>
<td>.NET 9.0</td>
<td>11.580 ns</td>
<td>1.00</td>
<td>48 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Test</td>
<td>.NET 10.0</td>
<td>3.960 ns</td>
<td>0.34</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>The JIT was able to inline <code>Process</code>, see that the array never leaves the frame, and stack allocate it.</p>
<p>Of course, now that we’re able to stack allocate arrays, we also want to be able to deal with a common way those arrays are used: via spans. <a href="https://github.com/dotnet/runtime/pull/113977">dotnet/runtime#113977</a> and <a href="https://github.com/dotnet/runtime/pull/116124">dotnet/runtime#116124</a> teach escape analysis to be able to reason about the fields in structs, which includes <code>Span&lt;T&gt;</code>, as it’s “just” a struct that stores a <code>ref T</code> field and an <code>int</code> length field.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private byte[] _buffer = new byte[3];

    [Benchmark]
    public void Test() =&gt; Copy3Bytes(0x12345678, _buffer);

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static void Copy3Bytes(int value, Span&lt;byte&gt; dest) =&gt;
        BitConverter.GetBytes(value).AsSpan(0, 3).CopyTo(dest);
}</code></pre>
<p>Here, we’re using <code>BitConverter.GetBytes</code>, which allocates a <code>byte[]</code> containing the bytes from the input (in this case, it’ll be a four-byte array for the <code>int</code>), then we slice off three of the four bytes, and we copy them to the destination span.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test</td>
<td>.NET 9.0</td>
<td>9.7717 ns</td>
<td>1.04</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Test</td>
<td>.NET 10.0</td>
<td>0.8718 ns</td>
<td>0.09</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>In .NET 9, we get the 32-byte allocation we’d expect for the <code>byte[]</code> in <code>GetBytes</code> (every object on 64-bit is at least 24 bytes, which will include the four bytes for the array’s length, and then the four bytes for the data will be in slots 24-27, and the size will be padded up to the next word boundary, for 32). In .NET 10, with <code>GetBytes</code> and <code>AsSpan</code> inlined, the JIT can see that the array doesn’t escape, and a stack allocated version of it can be used to seed the span, just as if it were created from any other stack allocation (like <code>stackalloc</code>). (This case also needed a little help from <a href="https://github.com/dotnet/runtime/pull/113093">dotnet/runtime#113093</a>, which taught the JIT that certain span operations, like the <code>Memmove</code> used internally by <code>CopyTo</code>, are non-escaping.)</p>
<h4>Devirtualization</h4>
<p>Interfaces and virtual methods are a critical aspect of .NET and the abstractions it enables. Being able to unwind these abstractions and “devirtualize” is then an important job for the JIT, which has taken notable leaps in capabilities here in .NET 10.</p>
<p>While arrays are one of the most central features provided by C# and .NET, and while the JIT exerts a lot of energy and does a great job optimizing many aspects of arrays, one area in particular has caused it pain: an array’s interface implementations. The runtime manufactures a bunch of interface implementations for <code>T[]</code>, and because they’re implemented differently from literally every other interface implementation in .NET, the JIT hasn’t been able to apply the same devirtualization capabilities it’s applied elsewhere. And, for anyone who’s dived deep into micro-benchmarks, this can lead to some odd observations. Here’s a performance comparison between iterating over a <code>ReadOnlyCollection&lt;T&gt;</code> using a <code>foreach</code> loop (going through its enumerator) and using a <code>for</code> loop (indexing on each element).</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34;
// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.ObjectModel;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private ReadOnlyCollection&lt;int&gt; _list = new(Enumerable.Range(1, 1000).ToArray());

    [Benchmark]
    public int SumEnumerable()
    {
        int sum = 0;
        foreach (var item in _list)
        {
            sum += item;
        }
        return sum;
    }

    [Benchmark]
    public int SumForLoop()
    {
        ReadOnlyCollection&lt;int&gt; list = _list;
        int sum = 0;
        int count = list.Count;
        for (int i = 0; i &lt; count; i++)
        {
            sum += _list[i];
        }
        return sum;
    }
}</code></pre>
<p>When asked “which of these will be faster”, the obvious answer is “<code>SumForLoop</code>“. After all, <code>SumEnumerable</code> is going to allocate an enumerator and has to make twice the number of interface calls (<code>MoveNext</code>+<code>Current</code> per iteration vs <code>this[int]</code> per iteration). As it turns out, the obvious answer is also wrong. Here are the timings on my machine for .NET 9:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
</tr>
</thead>
<tbody>
<tr>
<td>SumEnumerable</td>
<td>949.5 ns</td>
</tr>
<tr>
<td>SumForLoop</td>
<td>1,932.7 ns</td>
</tr>
</tbody>
</table>
<p>What the what?? If I change the <code>ToArray</code> to instead be <code>ToList</code>, however, the numbers are much more in line with our expectations.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
</tr>
</thead>
<tbody>
<tr>
<td>SumEnumerable</td>
<td>1,542.0 ns</td>
</tr>
<tr>
<td>SumForLoop</td>
<td>894.1 ns</td>
</tr>
</tbody>
</table>
<p>So what’s going on here? It’s super subtle. First, it’s necessary to know that <code>ReadOnlyCollection&lt;T&gt;</code> just wraps an arbitrary <code>IList&lt;T&gt;</code>, the <code>ReadOnlyCollection&lt;T&gt;</code>‘s <code>GetEnumerator()</code> returns <code>_list.GetEnumerator()</code> (I’m ignoring for this discussion the special-case where the list is empty), and <code>ReadOnlyCollection&lt;T&gt;</code>‘s indexer just indexes into the <code>IList&lt;T&gt;</code>‘s indexer. So far presumably this all sounds like what you’d expect. But where things gets interesting is around what the JIT is able to devirtualize. In .NET 9, it struggles to devirtualize calls to the interface implementations specifically on <code>T[]</code>, so it won’t devirtualize either the <code>_list.GetEnumerator()</code> call nor the <code>_list[index]</code> call. However, the enumerator that’s returned is just a normal type that implements <code>IEnumerator&lt;T&gt;</code>, and the JIT has no problem devirtualizing its <code>MoveNext</code> and <code>Current</code> members. Which means that we’re actually paying a lot more going through the indexer, because for <code>N</code> elements, we’re having to make <code>N</code> interface calls, whereas with the enumerator, we only need the one with <code>GetEnumerator</code> interface call and then no more after that.</p>
<p>Thankfully, this is now addressed in .NET 10. <a href="https://github.com/dotnet/runtime/pull/108153">dotnet/runtime#108153</a>, <a href="https://github.com/dotnet/runtime/pull/109209">dotnet/runtime#109209</a>, <a href="https://github.com/dotnet/runtime/pull/109237">dotnet/runtime#109237</a>, and <a href="https://github.com/dotnet/runtime/pull/116771">dotnet/runtime#116771</a> all make it possible for the JIT to devirtualize array’s interface method implementations. Now when we run the same benchmark (reverted back to using <code>ToArray</code>), we get results much more in line with our expectations, with both benchmarks improving from .NET 9 to .NET 10, and with <code>SumForLoop</code> on .NET 10 being the fastest.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>SumEnumerable</td>
<td>.NET 9.0</td>
<td>968.5 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>SumEnumerable</td>
<td>.NET 10.0</td>
<td>775.5 ns</td>
<td>0.80</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SumForLoop</td>
<td>.NET 9.0</td>
<td>1,960.5 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>SumForLoop</td>
<td>.NET 10.0</td>
<td>624.6 ns</td>
<td>0.32</td>
</tr>
</tbody>
</table>
<p>One of the really interesting things about this is how many libraries are implemented on the premise that it’s faster to use an <code>IList&lt;T&gt;</code>‘s indexer for iteration than it is to use its <code>IEnumerable&lt;T&gt;</code> for iteration, and that includes <code>System.Linq</code>. All these years, where LINQ has had specialized code paths for working with <code>IList&lt;T&gt;</code> when possible, while in many cases it’s been a welcome optimization, in <em>some</em> cases (such as when the concrete type is a <code>ReadOnlyCollection&lt;T&gt;</code>), it’s actually been a deoptimization.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.ObjectModel;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private ReadOnlyCollection&lt;int&gt; _list = new(Enumerable.Range(1, 1000).ToArray());

    [Benchmark]
    public int SkipTakeSum() =&gt; _list.Skip(100).Take(800).Sum();
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>SkipTakeSum</td>
<td>.NET 9.0</td>
<td>3.525 us</td>
<td>1.00</td>
</tr>
<tr>
<td>SkipTakeSum</td>
<td>.NET 10.0</td>
<td>1.773 us</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>Fixing devirtualization for array’s interface implementation then also has this transitive effect on LINQ.</p>
<p>Guarded Devirtualization (GDV) is also improved in .NET 10, such as from <a href="https://github.com/dotnet/runtime/pull/116453">dotnet/runtime#116453</a> and <a href="https://github.com/dotnet/runtime/pull/109256">dotnet/runtime#109256</a>. With <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#tiering-and-dynamic-pgo">dynamic PGO</a>, the JIT is able to instrument a method’s compilation and then use the resulting profiling data as part of emitting an optimized version of the method. One of the things it can profile are which types are used in a virtual dispatch. If one type dominates, it can special-case that type in the code gen and emit a customized implementation specific to that type. That then enables devirtualization in that dedicated path, which is “guarded” by the relevant type check, hence “GDV”. In some cases, however, such as if a virtual call was being made in a shared generic context, GDV would not kick in. Now it will.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public bool Test() =&gt; GenericEquals(&#34;abc&#34;, &#34;abc&#34;);

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static bool GenericEquals&lt;T&gt;(T a, T b) =&gt; EqualityComparer&lt;T&gt;.Default.Equals(a, b);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test</td>
<td>.NET 9.0</td>
<td>2.816 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Test</td>
<td>.NET 10.0</td>
<td>1.511 ns</td>
<td>0.54</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/110827">dotnet/runtime#110827</a> from <a href="https://github.com/hez2010">@hez2010</a> also helps more methods to be inlined by doing another pass looking for opportunities after later phases of devirtualization. The JIT’s optimizations are split up into multiple phases; each phase can make improvements, and those improvements can expose additional opportunities. If those opportunities would only be capitalized on by a phase that already ran, they can be missed. But for phases that are relatively cheap to perform, such as doing a pass looking for additional inlining opportunities, those phases can be repeated once enough other optimization has happened that it’s likely productive to do so again.</p>
<h3>Bounds Checking</h3>
<p>C# is a memory-safe language, an important aspect of modern programming languages. A key component of this is the inability to walk off the beginning or end of an array, string, or span. The runtime ensures that any such invalid attempt produces an exception, rather than being allowed to perform the invalid memory access. We can see what this looks like with a small benchmark:</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private int[] _array = new int[3];

    [Benchmark]
    public int Read() =&gt; _array[2];
}</code></pre>
<p>This is a valid access: the <code>_array</code> contains three elements, and the <code>Read</code> method is reading its last element. However, the JIT can’t be 100% certain that this access is in bounds (something could have changed what’s in the <code>_array</code> field to be a shorter array), and thus it needs to emit a check to ensure we’re not walking off the end of the array. Here’s what the generated assembly code for <code>Read</code> looks like:</p>
<pre><code>; .NET 10
; Tests.Read()
       push      rax
       mov       rax,[rdi+8]
       cmp       dword ptr [rax+8],2
       jbe       short M00_L00
       mov       eax,[rax+18]
       add       rsp,8
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 25</code></pre>
<p>The <code>this</code> reference is passed into the <code>Read</code> instance method in the <code>rdi</code> register, and the <code>_array</code> field is at offset 8, so the <code>mov rax,[rdi+8]</code> instruction is loading the address of the array into the <code>rax</code> register. Then the <code>cmp</code> is loading the value at offset 8 from that address; it so happens that’s where the length of the array is stored in the array object. So, this <code>cmp</code> instruction is the bounds check; it’s comparing <code>2</code> against that length to ensure it’s in bounds. If the array were too short for this access, the next <code>jbe</code> instruction would branch to the <code>M00_L00</code> label, which calls the <code>CORINFO_HELP_RNGCHKFAIL</code> helper function that throws an <code>IndexOutOfRangeException</code>. Any time you see this pair of <code>call CORINFO_HELP_RNGCHKFAIL</code>/<code>int 3</code> at the end of a method, there was at least one bounds check emitted by the JIT in that method.</p>
<p>Of course, we not only want safety, we also want great performance, and it’d be terrible for performance if every single read from an array (or string or span) incurred such an additional check. As such, the JIT strives to avoid emitting these checks when they’d be redundant, when it can prove by construction that the accesses are safe. For example, let me tweak my benchmark slightly, moving the array from an instance field into a <code>static readonly</code> field:</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly int[] s_array = new int[3];

    [Benchmark]
    public int Read() =&gt; s_array[2];
}</code></pre>
<p>We now get this assembly:</p>
<pre><code>; .NET 10
; Tests.Read()
       mov       rax,705D5419FA20
       mov       eax,[rax+18]
       ret
; Total bytes of code 14</code></pre>
<p>The <code>static readonly</code> field is immutable, arrays can’t be resized, and the JIT can guarantee that the field is initialized prior to generating the code for <code>Read</code>. Therefore, when generating the code for <code>Read</code>, it can know with certainty that the array is of length three, and we’re accessing the element at index two. Therefore, the specified array index is guaranteed to be within bounds, and there’s no need for a bounds check. We simply get two <code>mov</code>s, the first <code>mov</code> to load the address of the array (which, thanks to improvements in previous releases, is allocated on a heap that doesn’t need to be compacted such that the array lives at a fixed address), and the second <code>mov</code> to read the <code>int</code> value at the location of index two (these are <code>int</code>s, so index two lives <code>2 * sizeof(int) = 8</code> bytes from the start of the array’s data, which itself on 64-bit is offset 16 bytes from the start of the array reference, for a total offset of 24 bytes, or in hex 0x18, hence the <code>rax+18</code> in the disassembly).</p>
<p>Every release of .NET, more and more opportunities are found and implemented to eschew bounds checks that were previously being generated. .NET 10 continues this trend.</p>
<p>Our first example comes from <a href="https://github.com/dotnet/runtime/pull/109900">dotnet/runtime#109900</a>, which was inspired by the implementation of <code>BitOperations.Log2</code>. The operation has intrinsic hardware support on many architectures, and generally <code>BitOperations.Log2</code> will use one of the hardware intrinsics available to it for a very efficient implementation (e.g. <code>Lscnt.LeadingZeroCount</code>, <code>ArmBase.LeadingZeroCount</code>, or <code>X86Base.BitScanReverse</code>), however as a fallback implementation it uses a lookup table. The lookup table has 32 elements, and the operation involves computing a <code>uint</code> value and then shifting it down by 27 in order to get the top 5 bits. Any possible result is guaranteed to be a non-negative number less than 32, but indexing into the span with that result still produced a bounds check, and, as this is a critical path, “unsafe” code (meaning code that eschews the guardrails the runtime supplies by default) was then used to avoid the bounds check.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;value&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(42)]
    public int Log2SoftwareFallback2(uint value)
    {
        ReadOnlySpan&lt;byte&gt; Log2DeBruijn =
        [
            00, 09, 01, 10, 13, 21, 02, 29,
            11, 14, 16, 18, 22, 25, 03, 30,
            08, 12, 20, 28, 15, 17, 24, 07,
            19, 27, 23, 06, 26, 05, 04, 31
        ];

        value |= value &gt;&gt; 01;
        value |= value &gt;&gt; 02;
        value |= value &gt;&gt; 04;
        value |= value &gt;&gt; 08;
        value |= value &gt;&gt; 16;

        return Log2DeBruijn[(int)((value * 0x07C4ACDDu) &gt;&gt; 27)];
    }
}</code></pre>
<p>Now in .NET 10, the bounds check is gone (note the presence of the <code>call CORINFO_HELP_RNGCHKFAIL</code> in the .NET 9 assembly and the lack of it in the .NET 10 assembly).</p>
<pre><code>; .NET 9
; Tests.Log2SoftwareFallback2(UInt32)
       push      rax
       mov       eax,esi
       shr       eax,1
       or        esi,eax
       mov       eax,esi
       shr       eax,2
       or        esi,eax
       mov       eax,esi
       shr       eax,4
       or        esi,eax
       mov       eax,esi
       shr       eax,8
       or        esi,eax
       mov       eax,esi
       shr       eax,10
       or        eax,esi
       imul      eax,7C4ACDD
       shr       eax,1B
       cmp       eax,20
       jae       short M00_L00
       mov       rcx,7913CA812E10
       movzx     eax,byte ptr [rax+rcx]
       add       rsp,8
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 74

; .NET 10
; Tests.Log2SoftwareFallback2(UInt32)
       mov       eax,esi
       shr       eax,1
       or        esi,eax
       mov       eax,esi
       shr       eax,2
       or        esi,eax
       mov       eax,esi
       shr       eax,4
       or        esi,eax
       mov       eax,esi
       shr       eax,8
       or        esi,eax
       mov       eax,esi
       shr       eax,10
       or        eax,esi
       imul      eax,7C4ACDD
       shr       eax,1B
       mov       rcx,7CA298325E10
       movzx     eax,byte ptr [rcx+rax]
       ret
; Total bytes of code 58</code></pre>
<p>This improvement then enabled <a href="https://github.com/dotnet/runtime/pull/118560">dotnet/runtime#118560</a> to simplify the code in the real <code>Log2SoftwareFallback</code>, avoiding manual use of unsafe constructs.</p>
<p><a href="https://github.com/dotnet/runtime/pull/113790">dotnet/runtime#113790</a> implements a similar case, where the result of a mathematical operation is guaranteed to be in bounds. In this case, it’s the result of <code>Log2</code>. The change teaches the JIT to understand the maximum possible value that <code>Log2</code> could produce, and if that maximum is in bounds, then any result is guaranteed to be in bounds as well.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;value&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(12345)]
    public nint CountDigits(ulong value)
    {
        ReadOnlySpan&lt;byte&gt; log2ToPow10 =
        [
            1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
            6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
            10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
            15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20
        ];

        return log2ToPow10[(int)ulong.Log2(value)];
    }
}</code></pre>
<p>We can see the bounds check present in the .NET 9 output and absent in the .NET 10 output:</p>
<pre><code>; .NET 9
; Tests.CountDigits(UInt64)
       push      rax
       or        rsi,1
       xor       eax,eax
       lzcnt     rax,rsi
       xor       eax,3F
       cmp       eax,40
       jae       short M00_L00
       mov       rcx,7C2D0A213DF8
       movzx     eax,byte ptr [rax+rcx]
       add       rsp,8
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 45

; .NET 10
; Tests.CountDigits(UInt64)
       or        rsi,1
       xor       eax,eax
       lzcnt     rax,rsi
       xor       eax,3F
       mov       rcx,71EFA9400DF8
       movzx     eax,byte ptr [rcx+rax]
       ret
; Total bytes of code 29</code></pre>
<p>My choice of benchmark in this case was not coincidental. This pattern shows up in the <code>FormattingHelpers.CountDigits</code> internal method that’s used by the core primitive types in their <code>ToString</code> and <code>TryFormat</code> implementations, in order to determine how much space will be needed to store rendered digits for a number. As with the previous example, this routine is considered core enough that it was using unsafe code to avoid the bounds check. With this fix, the code was able to be changed back to using a simple span access, and even with the simpler code, it’s now also faster.</p>
<p>Now, consider this code:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;ids&#34;)]
public partial class Tests
{
    public IEnumerable&lt;int[]&gt; Ids { get; } = [[1, 2, 3, 4, 5, 1]];

    [Benchmark]
    [ArgumentsSource(nameof(Ids))]
    public bool StartAndEndAreSame(int[] ids) =&gt; ids[0] == ids[^1];
}</code></pre>
<p>I have a method that’s accepting an <code>int[]</code> and checking to see whether it starts and ends with the same value. The JIT has no way of knowing whether the <code>int[]</code> is empty or not, so it <em>does</em> need a bounds check; otherwise, accessing <code>ids[0]</code> could walk off the end of the array. However, this is what we see on .NET 9:</p>
<pre><code>; .NET 9
; Tests.StartAndEndAreSame(Int32[])
       push      rax
       mov       eax,[rsi+8]
       test      eax,eax
       je        short M00_L00
       mov       ecx,[rsi+10]
       lea       edx,[rax-1]
       cmp       edx,eax
       jae       short M00_L00
       mov       eax,edx
       cmp       ecx,[rsi+rax*4+10]
       sete      al
       movzx     eax,al
       add       rsp,8
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 41</code></pre>
<p>Note there are two jumps to the <code>M00_L00</code> label that handles failed bounds checks… that’s because there are two bounds checks here, one for the start access and one for the end access. But that shouldn’t be necessary. <code>ids[^1]</code> is the same as <code>ids[ids.Length - 1]</code>. If the code has successfully accessed <code>ids[0]</code>, that means the array is at least one element in length, and if it’s at least one element in length, <code>ids[ids.Length - 1]</code> will always be in bounds. Thus, the second bounds check shouldn’t be needed. Indeed, thanks to <a href="https://github.com/dotnet/runtime/pull/116105">dotnet/runtime#116105</a>, this is what we now get on .NET 10 (one branch to <code>M00_L00</code> instead of two):</p>
<pre><code>; .NET 10
; Tests.StartAndEndAreSame(Int32[])
       push      rax
       mov       eax,[rsi+8]
       test      eax,eax
       je        short M00_L00
       mov       ecx,[rsi+10]
       dec       eax
       cmp       ecx,[rsi+rax*4+10]
       sete      al
       movzx     eax,al
       add       rsp,8
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 34</code></pre>
<p>What’s really interesting to me here is the knock-on effect of having removed the bounds check. It didn’t just eliminate the <code>cmp/jae</code> pair of instructions that’s typical of a bounds check. The .NET 9 version of the code had this:</p>
<pre><code>lea edx,[rax-1]
cmp edx,eax
jae short M00_L00
mov eax,edx</code></pre>
<p>At this point in the assembly, the <code>rax</code> register is storing the length of the array. It’s calculating <code>ids.Length - 1</code> and storing the result into <code>edx</code>, and then checking to see whether <code>ids.Length-1</code> is in bounds of <code>ids.Length</code> (the only way it wouldn’t be is if the array were empty such that <code>ids.Length-1</code> wrapped around to <code>uint.MaxValue</code>); if it’s not, it jumps to the fail handler, and if it is, it stores the already computed <code>ids.Length - 1</code> into <code>eax</code>. By removing the bounds check, we get rid of those two intervening instructions, leaving these:</p>
<pre><code>lea edx,[rax-1]
mov eax,edx</code></pre>
<p>which is a little silly, as this sequence is just computing a decrement, and as long as it’s ok that flags get modified, it could instead just be:</p>
<pre><code>dec eax</code></pre>
<p>which, as you can see in the .NET 10 output, is exactly what .NET 10 now does.</p>
<p><a href="https://github.com/dotnet/runtime/pull/115980">dotnet/runtime#115980</a> addresses another case. Let’s say I have this method:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;start&#34;, &#34;text&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(&#34;abc&#34;, &#34;abc.&#34;)]
    public bool IsFollowedByPeriod(string start, string text) =&gt;
        start.Length &lt; text.Length &amp;&amp; text[start.Length] == &#39;.&#39;;
}</code></pre>
<p>We’re validating that one input’s length is less than the other, and then checking to see what comes immediately after it in the other. We know that <code>string.Length</code> is immutable, so a bounds check here is redundant, but until .NET 10, the JIT couldn’t see that.</p>
<pre><code>; .NET 9
; Tests.IsFollowedByPeriod(System.String, System.String)
       push      rbp
       mov       rbp,rsp
       mov       eax,[rsi+8]
       mov       ecx,[rdx+8]
       cmp       eax,ecx
       jge       short M00_L00
       cmp       eax,ecx
       jae       short M00_L01
       cmp       word ptr [rdx+rax*2+0C],2E
       sete      al
       movzx     eax,al
       pop       rbp
       ret
M00_L00:
       xor       eax,eax
       pop       rbp
       ret
M00_L01:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 42

; .NET 10
; Tests.IsFollowedByPeriod(System.String, System.String)
       mov       eax,[rsi+8]
       mov       ecx,[rdx+8]
       cmp       eax,ecx
       jge       short M00_L00
       cmp       word ptr [rdx+rax*2+0C],2E
       sete      al
       movzx     eax,al
       ret
M00_L00:
       xor       eax,eax
       ret
; Total bytes of code 26</code></pre>
<p>The removal of the bounds check almost halves the size of the function. If we don’t need to do a bounds check, we get to elide the <code>cmp/jae</code>. Without that branch, nothing is targeting <code>M00_L01</code>, and we can remove the <code>call/int</code> pair that were only necessary to support a bounds check. Then without the <code>call</code> in <code>M00_L01</code>, which was the only <code>call</code> in the whole method, the prologue and epilogue can be elided, meaning we also don’t need the opening and closing <code>push</code> and <code>pop</code> instructions.</p>
<p><a href="https://github.com/dotnet/runtime/pull/113233">dotnet/runtime#113233</a> improved handling “assertions” (facts the JIT claims and based on which the JIT makes optimizations) to be less order dependent. In .NET 9, this code:</p>
<pre><code>static bool Test(ReadOnlySpan&lt;char&gt; span, int pos) =&gt;
    pos &gt; 0 &amp;&amp;
    pos &lt;= span.Length - 42 &amp;&amp;
    span[pos - 1] != &#39;\n&#39;;</code></pre>
<p>was successfully removing the bounds check on the span access, but the following variant, which just switches the order of the first two conditions, was still incurring the bounds check.</p>
<pre><code>static bool Test(ReadOnlySpan&lt;char&gt; span, int pos) =&gt;
    pos &lt;= span.Length - 42 &amp;&amp;
    pos &gt; 0 &amp;&amp;
    span[pos - 1] != &#39;\n&#39;;</code></pre>
<p>Note that both conditions contribute an assertion (fact) that need to be merged in order to know the bounds check can be avoided. Now in .NET 10, the bounds check is elided, regardless of the order.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private string _s = new string(&#39;s&#39;, 100);
    private int _pos = 10;

    [Benchmark]
    public bool Test()
    {
        string s = _s;
        int pos = _pos;
        return
            pos &lt;= s.Length - 42 &amp;&amp;
            pos &gt; 0 &amp;&amp;
            s[pos - 1] != &#39;\n&#39;;
    }
}</code></pre>
<pre><code>; .NET 9
; Tests.Test()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       mov       ecx,[rdi+10]
       mov       edx,[rax+8]
       lea       edi,[rdx-2A]
       cmp       edi,ecx
       jl        short M00_L00
       test      ecx,ecx
       jle       short M00_L00
       dec       ecx
       cmp       ecx,edx
       jae       short M00_L01
       cmp       word ptr [rax+rcx*2+0C],0A
       setne     al
       movzx     eax,al
       pop       rbp
       ret
M00_L00:
       xor       eax,eax
       pop       rbp
       ret
M00_L01:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 55

; .NET 10
; Tests.Test()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       mov       ecx,[rdi+10]
       mov       edx,[rax+8]
       add       edx,0FFFFFFD6
       cmp       edx,ecx
       jl        short M00_L00
       test      ecx,ecx
       jle       short M00_L00
       dec       ecx
       cmp       word ptr [rax+rcx*2+0C],0A
       setne     al
       movzx     eax,al
       pop       rbp
       ret
M00_L00:
       xor       eax,eax
       pop       rbp
       ret
; Total bytes of code 45</code></pre>
<p><a href="https://github.com/dotnet/runtime/pull/113862">dotnet/runtime#113862</a> addresses a similar case where assertions weren’t being handled as precisely as they could have been. Consider this code:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private int[] _arr = Enumerable.Range(0, 10).ToArray();

    [Benchmark]
    public int Sum()
    {
        int[] arr = _arr;
        int sum = 0;

        int i;
        for (i = 0; i &lt; arr.Length - 3; i += 4)
        {
            sum += arr[i + 0];
            sum += arr[i + 1];
            sum += arr[i + 2];
            sum += arr[i + 3];
        }

        for (; i &lt; arr.Length; i++)
        {
            sum += arr[i];
        }

        return sum;
    }
}</code></pre>
<p>The <code>Sum</code> method is trying to do manual loop unrolling. Rather than incurring a branch on each element, it’s handling four elements per iteration. Then, for the case where the length of the input isn’t evenly divisible by four, it’s handling the remaining elements in a separate loop. In .NET 9, the JIT successfully elides the bounds checks in the main unrolled loop:</p>
<pre><code>; .NET 9
; Tests.Sum()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       xor       ecx,ecx
       xor       edx,edx
       mov       edi,[rax+8]
       lea       esi,[rdi-3]
       test      esi,esi
       jle       short M00_L02
M00_L00:
       mov       r8d,edx
       add       ecx,[rax+r8*4+10]
       lea       r8d,[rdx+1]
       add       ecx,[rax+r8*4+10]
       lea       r8d,[rdx+2]
       add       ecx,[rax+r8*4+10]
       lea       r8d,[rdx+3]
       add       ecx,[rax+r8*4+10]
       add       edx,4
       cmp       esi,edx
       jg        short M00_L00
       jmp       short M00_L02
M00_L01:
       cmp       edx,edi
       jae       short M00_L03
       mov       esi,edx
       add       ecx,[rax+rsi*4+10]
       inc       edx
M00_L02:
       cmp       edi,edx
       jg        short M00_L01
       mov       eax,ecx
       pop       rbp
       ret
M00_L03:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 92</code></pre>
<p>You can see this in the <code>M00_L00</code> section, which has the five <code>add</code> instructions (four for the summed elements, and one for the index). However, we still see the <code>CORINFO_HELP_RNGCHKFAIL</code> at the end, indicating this method has a bounds check. That’s coming from the final loop, due to the JIT losing track of the fact that <code>i</code> is guaranteed to be non-negative. Now in .NET 10, that bounds check is removed as well (again, just look for the lack of the <code>CORINFO_HELP_RNGCHKFAIL</code> call).</p>
<pre><code>; .NET 10
; Tests.Sum()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       xor       ecx,ecx
       xor       edx,edx
       mov       edi,[rax+8]
       lea       esi,[rdi-3]
       test      esi,esi
       jle       short M00_L01
M00_L00:
       mov       r8d,edx
       add       ecx,[rax+r8*4+10]
       lea       r8d,[rdx+1]
       add       ecx,[rax+r8*4+10]
       lea       r8d,[rdx+2]
       add       ecx,[rax+r8*4+10]
       lea       r8d,[rdx+3]
       add       ecx,[rax+r8*4+10]
       add       edx,4
       cmp       esi,edx
       jg        short M00_L00
M00_L01:
       cmp       edi,edx
       jle       short M00_L03
       test      edx,edx
       jl        short M00_L04
M00_L02:
       mov       esi,edx
       add       ecx,[rax+rsi*4+10]
       inc       edx
       cmp       edi,edx
       jg        short M00_L02
M00_L03:
       mov       eax,ecx
       pop       rbp
       ret
M00_L04:
       mov       esi,edx
       add       ecx,[rax+rsi*4+10]
       inc       edx
       cmp       edi,edx
       jg        short M00_L04
       jmp       short M00_L03
; Total bytes of code 102</code></pre>
<p>Another nice improvement comes from <a href="https://github.com/dotnet/runtime/pull/112824">dotnet/runtime#112824</a>, which teaches the JIT to turn facts it already learned from earlier checks into concrete numeric ranges, and then use those ranges to fold away later relational tests and bounds checks. Consider this example:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private int[] _array = new int[10];

    [Benchmark]
    public void Test() =&gt; SetAndSlice(_array);

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Span&lt;int&gt; SetAndSlice(Span&lt;int&gt; src)
    {
        src[5] = 42;
        return src.Slice(4);
    }
}</code></pre>
<p>We have to incur a bounds check for the <code>src[5]</code>, as the JIT has no evidence that <code>src</code> is at least six elements long. However, by the time we get to the <code>Slice</code> call, we know the span has a length of at least six, or else writing into <code>src[5]</code> would have failed. We can use that knowledge to remove the length check from within the <code>Slice</code> call (note the removal of the <code>call qword ptr [7F8DDB3A7810]</code>/<code>int 3</code> sequence, which is the manual length check and call to a throw helper method in <code>Slice</code>).</p>
<pre><code>; .NET 9
; Tests.SetAndSlice(System.Span`1&lt;Int32&gt;)
       push      rbp
       mov       rbp,rsp
       cmp       esi,5
       jbe       short M01_L01
       mov       dword ptr [rdi+14],2A
       cmp       esi,4
       jb        short M01_L00
       add       rdi,10
       mov       rax,rdi
       add       esi,0FFFFFFFC
       mov       edx,esi
       pop       rbp
       ret
M01_L00:
       call      qword ptr [7F8DDB3A7810]
       int       3
M01_L01:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 48

; .NET 10
; Tests.SetAndSlice(System.Span`1&lt;Int32&gt;)
       push      rax
       cmp       esi,5
       jbe       short M01_L00
       mov       dword ptr [rdi+14],2A
       lea       rax,[rdi+10]
       lea       edx,[rsi-4]
       add       rsp,8
       ret
M01_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 31</code></pre>
<p>Let’s look at one more, which has a very nice impact on bounds checking, even though technically the optimization is broader than just that. <a href="https://github.com/dotnet/runtime/pull/113998">dotnet/runtime#113998</a> creates assertions from <code>switch</code> targets. This means that the body of a <code>switch</code> case statement inherits facts about what was switched over based on what the <code>case</code> was, e.g. in a <code>case 3</code> for <code>switch (x)</code>, the body of that case will now “know” that <code>x</code> is three. This is great for very popular patterns with arrays, strings, and spans, where developers switch over the length and then index into available indices in the appropriate branches. Consider this:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private int[] _array = [1, 2];

    [Benchmark]
    public int SumArray() =&gt; Sum(_array);

    [MethodImpl(MethodImplOptions.NoInlining)]
    public int Sum(ReadOnlySpan&lt;int&gt; span)
    {
        switch (span.Length)
        {
            case 0: return 0;
            case 1: return span[0];
            case 2: return span[0] + span[1];
            case 3: return span[0] + span[1] + span[2];
            default: return -1;
        }
    }
}</code></pre>
<p>On .NET 9, each of those six <code>span</code> dereferences ends up with a bounds check:</p>
<pre><code>; .NET 9
; Tests.Sum(System.ReadOnlySpan`1&lt;Int32&gt;)
       push      rbp
       mov       rbp,rsp
M01_L00:
       cmp       edx,2
       jne       short M01_L02
       test      edx,edx
       je        short M01_L04
       mov       eax,[rsi]
       cmp       edx,1
       jbe       short M01_L04
       add       eax,[rsi+4]
M01_L01:
       pop       rbp
       ret
M01_L02:
       cmp       edx,3
       ja        short M01_L03
       mov       eax,edx
       lea       rcx,[783DA42091B8]
       mov       ecx,[rcx+rax*4]
       lea       rdi,[M01_L00]
       add       rcx,rdi
       jmp       rcx
M01_L03:
       mov       eax,0FFFFFFFF
       pop       rbp
       ret
       test      edx,edx
       je        short M01_L04
       mov       eax,[rsi]
       cmp       edx,1
       jbe       short M01_L04
       add       eax,[rsi+4]
       cmp       edx,2
       jbe       short M01_L04
       add       eax,[rsi+8]
       jmp       short M01_L01
       test      edx,edx
       je        short M01_L04
       mov       eax,[rsi]
       jmp       short M01_L01
       xor       eax,eax
       pop       rbp
       ret
M01_L04:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 103</code></pre>
<p>You can see the tell-tale bounds check sign (<code>CORINFO_HELP_RNGCHKFAIL</code>) under <code>M01_L04</code>, and no fewer than six jumps targeting that label, one for each <code>span[...]</code> access. But on .NET 10, we get this:</p>
<pre><code>; .NET 10
; Tests.Sum(System.ReadOnlySpan`1&lt;Int32&gt;)
       push      rbp
       mov       rbp,rsp
M01_L00:
       cmp       edx,2
       jne       short M01_L02
       mov       eax,[rsi]
       add       eax,[rsi+4]
M01_L01:
       pop       rbp
       ret
M01_L02:
       cmp       edx,3
       ja        short M01_L03
       mov       eax,edx
       lea       rcx,[72C15C0F8FD8]
       mov       ecx,[rcx+rax*4]
       lea       rdx,[M01_L00]
       add       rcx,rdx
       jmp       rcx
M01_L03:
       mov       eax,0FFFFFFFF
       pop       rbp
       ret
       xor       eax,eax
       pop       rbp
       ret
       mov       eax,[rsi]
       jmp       short M01_L01
       mov       eax,[rsi]
       add       eax,[rsi+4]
       add       eax,[rsi+8]
       jmp       short M01_L01
; Total bytes of code 70</code></pre>
<p>The <code>CORINFO_HELP_RNGCHKFAIL</code> and all the jumps to it have evaporated.</p>
<h3>Cloning</h3>
<p>There are other ways the JIT can remove bounds checking even when it can’t prove statically that every individual access is safe. Consider this method:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private int[] _arr = new int[16];

    [Benchmark]
    public void Test()
    {
        int[] arr = _arr;
        arr[0] = 2;
        arr[1] = 3;
        arr[2] = 5;
        arr[3] = 8;
        arr[4] = 13;
        arr[5] = 21;
        arr[6] = 34;
        arr[7] = 55;
    }
}</code></pre>
<p>Here’s the assembly code generated on .NET 9:</p>
<pre><code>; .NET 9
; Tests.Test()
       push      rax
       mov       rax,[rdi+8]
       mov       ecx,[rax+8]
       test      ecx,ecx
       je        short M00_L00
       mov       dword ptr [rax+10],2
       cmp       ecx,1
       jbe       short M00_L00
       mov       dword ptr [rax+14],3
       cmp       ecx,2
       jbe       short M00_L00
       mov       dword ptr [rax+18],5
       cmp       ecx,3
       jbe       short M00_L00
       mov       dword ptr [rax+1C],8
       cmp       ecx,4
       jbe       short M00_L00
       mov       dword ptr [rax+20],0D
       cmp       ecx,5
       jbe       short M00_L00
       mov       dword ptr [rax+24],15
       cmp       ecx,6
       jbe       short M00_L00
       mov       dword ptr [rax+28],22
       cmp       ecx,7
       jbe       short M00_L00
       mov       dword ptr [rax+2C],37
       add       rsp,8
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 114</code></pre>
<p>Even if you’re not proficient at reading assembly, the pattern should still be obvious. In the C# code, we have eight writes into the array, and in the assembly code, we have eight repetitions of the same pattern: <code>cmp ecx,LENGTH</code> to compare the length of the array against the required <code>LENGTH</code>, <code>jbe short M00_L00</code> to jump to the <code>CORINFO_HELP_RNGCHKFAIL</code> helper if the bounds check fails, and <code>mov dword ptr [rax+OFFSET],VALUE</code> to store <code>VALUE</code> into the array at byte offset <code>OFFSET</code>. Inside the <code>Test</code> method, the JIT can’t know how long <code>_arr</code> is, so it must include bounds checks. Moreover, it must include all of the bounds checks, rather than coalescing them, because it is forbidden from introducing behavioral changes as part of optimizations. Imagine instead if it chose to coalesce all of the bounds checks into a single check, and emitted this method as if it were the equivalent of the following:</p>
<pre><code>if (arr.Length &gt;= 8)
{
    arr[0] = 2;
    arr[1] = 3;
    arr[2] = 5;
    arr[3] = 8;
    arr[4] = 13;
    arr[5] = 21;
    arr[6] = 34;
    arr[7] = 55;
}
else
{
    throw new IndexOutOfRangeException();
}</code></pre>
<p>Now, let’s say the array was actually of length four. The original program would have filled the array with values <code>[2, 3, 5, 8]</code> before throwing an exception, but this transformed code wouldn’t (there wouldn’t be any writes to the array). That’s an observable behavioral change. An enterprising developer could of course <em>choose</em> to rewrite their code to avoid some of these checks, e.g.</p>
<pre><code>arr[7] = 55;
arr[0] = 2;
arr[1] = 3;
arr[2] = 5;
arr[3] = 8;
arr[4] = 13;
arr[5] = 21;
arr[6] = 34;</code></pre>
<p>By moving the last store to the beginning, the developer has given the JIT extra knowledge. The JIT can now see that <em>if</em> the first store succeeds, the rest are guaranteed to succeed as well, and the JIT will emit a single bounds check. But, again, that’s the developer choosing to change their program in a way the JIT must not. However, there are other things the JIT <em>can</em> do. Imagine the JIT chose to rewrite the method like this instead:</p>
<pre><code>if (arr.Length &gt;= 8)
{
    arr[0] = 2;
    arr[1] = 3;
    arr[2] = 5;
    arr[3] = 8;
    arr[4] = 13;
    arr[5] = 21;
    arr[6] = 34;
    arr[7] = 55;
}
else
{
    arr[0] = 2;
    arr[1] = 3;
    arr[2] = 5;
    arr[3] = 8;
    arr[4] = 13;
    arr[5] = 21;
    arr[6] = 34;
    arr[7] = 55;
}</code></pre>
<p>To our C# sensibilities, that looks unnecessarily complicated; the <code>if</code> and the <code>else</code> block contain <em>exactly</em> the same C# code. But, knowing what we now know about how the JIT can use known length information to elide bounds checks, it starts to make a bit more sense. Here’s what the JIT emits for this variant on .NET 9:</p>
<pre><code>; .NET 9
; Tests.Test()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       mov       ecx,[rax+8]
       cmp       ecx,8
       jl        short M00_L00
       mov       rcx,300000002
       mov       [rax+10],rcx
       mov       rcx,800000005
       mov       [rax+18],rcx
       mov       rcx,150000000D
       mov       [rax+20],rcx
       mov       rcx,3700000022
       mov       [rax+28],rcx
       pop       rbp
       ret
M00_L00:
       test      ecx,ecx
       je        short M00_L01
       mov       dword ptr [rax+10],2
       cmp       ecx,1
       jbe       short M00_L01
       mov       dword ptr [rax+14],3
       cmp       ecx,2
       jbe       short M00_L01
       mov       dword ptr [rax+18],5
       cmp       ecx,3
       jbe       short M00_L01
       mov       dword ptr [rax+1C],8
       cmp       ecx,4
       jbe       short M00_L01
       mov       dword ptr [rax+20],0D
       cmp       ecx,5
       jbe       short M00_L01
       mov       dword ptr [rax+24],15
       cmp       ecx,6
       jbe       short M00_L01
       mov       dword ptr [rax+28],22
       cmp       ecx,7
       jbe       short M00_L01
       mov       dword ptr [rax+2C],37
       pop       rbp
       ret
M00_L01:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 177</code></pre>
<p>The <code>else</code> block is compiled to the <code>M00_L00</code> label, which contains those same eight repeated blocks we saw earlier. But the <code>if</code> block (above the <code>M00_L00</code> label) is interesting. The only branch there is the initial <code>array.Length &gt;= 8</code> check I wrote in the C# code, emitted as the <code>cmp ecx,8</code>/<code>jl short M00_L00</code> pair of instructions. The rest of the block is just <code>mov</code> instructions (and you can see there are only four writes into the array rather than eight… the JIT has optimized the eight four-byte writes into four eight-byte writes). In our rewrite, we’ve manually cloned the code, so that in what we expect to be the vast, vast, vast majority case (presumably we wouldn’t have written the array writes in the first place if we thought they’d fail), we only incur the single length check, and then we have our “hopefully this is never needed” fallback case for the rare situation where it is. Of course, you shouldn’t (and shouldn’t need to) do such manual cloning. But, the JIT can do such cloning for you, and does.</p>
<p>“Cloning” is an optimization long employed by the JIT, where it will do this kind of code duplication, typically of loops, when it believes that in doing so, it can heavily optimize a common case. Now in .NET 10, thanks to <a href="https://github.com/dotnet/runtime/pull/112595">dotnet/runtime#112595</a>, it can employ this same technique for these kinds of sequences of writes. Going back to our original benchmark, here’s what we now get on .NET 10:</p>
<pre><code>; .NET 10
; Tests.Test()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       mov       ecx,[rax+8]
       mov       edx,ecx
       cmp       edx,7
       jle       short M00_L01
       mov       rdx,300000002
       mov       [rax+10],rdx
       mov       rcx,800000005
       mov       [rax+18],rcx
       mov       rcx,150000000D
       mov       [rax+20],rcx
       mov       rcx,3700000022
       mov       [rax+28],rcx
M00_L00:
       pop       rbp
       ret
M00_L01:
       test      edx,edx
       je        short M00_L02
       mov       dword ptr [rax+10],2
       cmp       ecx,1
       jbe       short M00_L02
       mov       dword ptr [rax+14],3
       cmp       ecx,2
       jbe       short M00_L02
       mov       dword ptr [rax+18],5
       cmp       ecx,3
       jbe       short M00_L02
       mov       dword ptr [rax+1C],8
       cmp       ecx,4
       jbe       short M00_L02
       mov       dword ptr [rax+20],0D
       cmp       ecx,5
       jbe       short M00_L02
       mov       dword ptr [rax+24],15
       cmp       ecx,6
       jbe       short M00_L02
       mov       dword ptr [rax+28],22
       cmp       ecx,7
       jbe       short M00_L02
       mov       dword ptr [rax+2C],37
       jmp       short M00_L00
M00_L02:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 179</code></pre>
<p>This structure looks almost identical to what we got when we manually cloned: the JIT has emitted the same code twice, except in one case, there are no bounds checks, and in the other case, there are all the bounds checks, and a single length check determines which path to follow. Pretty neat.</p>
<p>As noted, the JIT has been doing cloning for years, in particular for loops over arrays. However, more and more code is being written against spans instead of arrays, and unfortunately this valuable optimization didn’t apply to spans. Now with <a href="https://github.com/dotnet/runtime/pull/113575">dotnet/runtime#113575</a>, it does! We can see this with a basic looping example:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private int[] _arr = new int[16];
    private int _count = 8;

    [Benchmark]
    public void WithSpan()
    {
        Span&lt;int&gt; span = _arr;
        int count = _count;

        for (int i = 0; i &lt; count; i++)
        {
            span[i] = i;
        }
    }

    [Benchmark]
    public void WithArray()
    {
        int[] arr = _arr;
        int count = _count;

        for (int i = 0; i &lt; count; i++)
        {
            arr[i] = i;
        }
    }
}</code></pre>
<p>In both <code>WithArray</code> and <code>WithSpan</code>, we have the same loop, iterating from 0 to a <code>_count</code> with an unknown relationship to the length of <code>_arr</code>, so there has to be some kind of bounds checking emitted. Here’s what we get on .NET 9 for <code>WithSpan</code>:</p>
<pre><code>; .NET 9
; Tests.WithSpan()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       test      rax,rax
       je        short M00_L03
       lea       rcx,[rax+10]
       mov       eax,[rax+8]
M00_L00:
       mov       edi,[rdi+10]
       xor       edx,edx
       test      edi,edi
       jle       short M00_L02
       nop       dword ptr [rax]
M00_L01:
       cmp       edx,eax
       jae       short M00_L04
       mov       [rcx+rdx*4],edx
       inc       edx
       cmp       edx,edi
       jl        short M00_L01
M00_L02:
       pop       rbp
       ret
M00_L03:
       xor       ecx,ecx
       xor       eax,eax
       jmp       short M00_L00
M00_L04:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 59</code></pre>
<p>There’s some upfront assembly here associated with loading <code>_array</code> into a span, loading <code>_count</code>, and checking to see whether the count is 0 (in which case the whole loop can be skipped). Then the core of the loop is at <code>M00_L01</code>, which is repeatedly checking <code>edx</code> (which contains <code>i</code>) against the length of the span (in <code>eax</code>), jumping to <code>CORINFO_HELP_RNGCHKFAIL</code> if it’s an out-of-bounds access, writing <code>edx</code> (<code>i</code>) into the span at the next position, bumping up <code>i</code>, and then jumping back to <code>M00_L01</code> to keep iterating if <code>i</code> is still less than <code>count</code> (stored in <code>edi</code>). In other words, we have two checks per iteration: is <code>i</code> still within the bounds of the span, and is <code>i</code> still less than <code>count</code>. Now here’s what we get on .NET 9 for <code>WithArray</code>:</p>
<pre><code>; .NET 9
; Tests.WithArray()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       mov       ecx,[rdi+10]
       xor       edx,edx
       test      ecx,ecx
       jle       short M00_L01
       test      rax,rax
       je        short M00_L02
       cmp       [rax+8],ecx
       jl        short M00_L02
       nop       dword ptr [rax+rax]
M00_L00:
       mov       edi,edx
       mov       [rax+rdi*4+10],edx
       inc       edx
       cmp       edx,ecx
       jl        short M00_L00
M00_L01:
       pop       rbp
       ret
M00_L02:
       cmp       edx,[rax+8]
       jae       short M00_L03
       mov       edi,edx
       mov       [rax+rdi*4+10],edx
       inc       edx
       cmp       edx,ecx
       jl        short M00_L02
       jmp       short M00_L01
M00_L03:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 71</code></pre>
<p>Here, label <code>M00_L02</code> looks very similar to the loop we just saw in <code>WithSpan</code>, incurring both the check against <code>count</code> and the bounds check on every iteration. But note section <code>M00_L00</code>: it’s a clone of the same loop, still with the <code>cmp edx,ecx</code> that checks <code>i</code> against <code>count</code> on each iteration, but no additional bounds checking in sight. The JIT has cloned the loop, specializing one to not have bounds checks, and then in the upfront section, it determines which path to follow based on a single check against the array’s length (<code>cmp [rax+8],ecx</code>/<code>jl short M00_L02</code>). Now in .NET 10, here’s what we get for <code>WithSpan</code>:</p>
<pre><code>; .NET 10
; Tests.WithSpan()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       test      rax,rax
       je        short M00_L04
       lea       rcx,[rax+10]
       mov       eax,[rax+8]
M00_L00:
       mov       edx,[rdi+10]
       xor       edi,edi
       test      edx,edx
       jle       short M00_L02
       cmp       edx,eax
       jg        short M00_L03
M00_L01:
       mov       eax,edi
       mov       [rcx+rax*4],edi
       inc       edi
       cmp       edi,edx
       jl        short M00_L01
M00_L02:
       pop       rbp
       ret
M00_L03:
       cmp       edi,eax
       jae       short M00_L05
       mov       esi,edi
       mov       [rcx+rsi*4],edi
       inc       edi
       cmp       edi,edx
       jl        short M00_L03
       jmp       short M00_L02
M00_L04:
       xor       ecx,ecx
       xor       eax,eax
       jmp       short M00_L00
M00_L05:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 75</code></pre>
<p>As with <code>WithArray</code> in .NET 9, <code>WithSpan</code> for .NET 10 has the loop cloned, with the <code>M00_L03</code> block containing the bounds check on each iteration, and the <code>M00_L01</code> block eliding the bounds check on each iteration.</p>
<p>The JIT gains more cloning abilities in .NET 10, as well. <a href="https://github.com/dotnet/runtime/pull/110020">dotnet/runtime#110020</a>, <a href="https://github.com/dotnet/runtime/pull/108604">dotnet/runtime#108604</a>, and <a href="https://github.com/dotnet/runtime/pull/110483">dotnet/runtime#110483</a> make it possible for the JIT to clone <code>try/finally</code> blocks, whereas previously it would immediately bail out of cloning any regions containing such constructs. This might seem niche, but it’s actually quite valuable when you consider that <code>foreach</code>‘ing over an enumerable typically involves a hidden <code>try</code>/<code>finally</code> for the <code>finally</code> to call the enumerator’s <code>Dispose</code>.</p>
<p>Many of these different optimizations interact with each other. Dynamic PGO triggers a form of cloning, as part of the guarded devirtualization (GDV) mentioned earlier: if the instrumentation data reveals that a particular virtual call is generally performed on an instance of a specific type, the JIT can clone the resulting code into one path specific to that type and another path that handles any type. That then enables the specific-type code path to devirtualize the call and possibly inline it. And if it inlines it, that then provides more opportunities for the JIT to see that an object doesn’t escape, and potentially stack allocate it.
<a href="https://github.com/dotnet/runtime/pull/111473">dotnet/runtime#111473</a>,
<a href="https://github.com/dotnet/runtime/pull/116978">dotnet/runtime#116978</a>, <a href="https://github.com/dotnet/runtime/pull/116992">dotnet/runtime#116992</a>,
<a href="https://github.com/dotnet/runtime/pull/117222">dotnet/runtime#117222</a>, and <a href="https://github.com/dotnet/runtime/pull/117295">dotnet/runtime#117295</a> enable that, enhancing escape analysis to determine if an object only escapes when such a generated type test fails (when the target object isn’t of the expected common type).</p>
<p>I want to pause for a moment, because my words thus far aren’t nearly enthusiastic enough to highlight the magnitude of what this enables. The <code>dotnet/runtime</code> repo uses an automated performance analysis system which flags when benchmarks significantly improve or regress and ties those changes back to the responsible PR. This is what it looked like for this PR:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/ConditionalEscapeAnalysisImprovements.png" alt="Conditional Escape Analysis Triggering Many Benchmark Improvements"/>
We can see why this is so good from a simple example:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private int[] _values = Enumerable.Range(1, 100).ToArray();

    [Benchmark]
    public int Sum() =&gt; Sum(_values);

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static int Sum(IEnumerable&lt;int&gt; values)
    {
        int sum = 0;
        foreach (int value in values)
        {
            sum += value;
        }
        return sum;
    }
}</code></pre>
<p>With dynamic PGO, the instrumented code for <code>Sum</code> will see that <code>values</code> is generally an <code>int[]</code>, and it’ll be able to emit a specialized code path in the optimized <code>Sum</code> implementation for when it is. And then with this ability to do conditional escape analysis, for the common path the JIT can see that the resulting <code>GetEnumerator</code> produces an <code>IEnumerator&lt;int&gt;</code> that never escapes, such that along with all of the relevant methods being devirtualized and inlined, the enumerator can be stack allocated.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>.NET 9.0</td>
<td>109.86 ns</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Sum</td>
<td>.NET 10.0</td>
<td>35.45 ns</td>
<td>0.32</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>Just think about how many places in your apps and services you enumerate collections like this, and you can see why it’s such an exciting improvement. Note that these cases don’t always even require PGO. Consider a case like this:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly IEnumerable&lt;int&gt; s_values = new int[] { 1, 2, 3, 4, 5 };

    [Benchmark]
    public int Sum()
    {
        int sum = 0;
        foreach (int value in s_values)
        {
            sum += value;
        }
        return sum;
    }
}</code></pre>
<p>Here, the JIT can see that even though the <code>s_values</code> is typed as <code>IEnumerable&lt;int&gt;</code>, it’s always actually an <code>int[]</code>. In that case, <a href="https://github.com/dotnet/runtime/pull/111948">dotnet/runtime#111948</a> enables the return type to be retyped in the JIT as <code>int[]</code> and the enumerator can be stack allocated.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>.NET 9.0</td>
<td>16.341 ns</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Sum</td>
<td>.NET 10.0</td>
<td>2.059 ns</td>
<td>0.13</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>Of course, too much cloning can be a bad thing, in particular as it increases code size. <a href="https://github.com/dotnet/runtime/pull/108771">dotnet/runtime#108771</a> employs a heuristic to determine whether loops that <em>can</em> be cloned <em>should</em> be cloned; the larger the loop, the less likely it’ll be to be cloned.</p>
<h3>Inlining</h3>
<p>“Inlining”, which replaces a call to a function with a copy of that function’s implementation, has always been a critically important optimization. It’s easy to think about the benefits of inlining as just being about avoiding the overhead of a call, and while that can be meaningful (especially when considering security mechanisms like Intel’s Control-Flow Enforcement Technology, which slightly increases the cost of calls), generally the most benefit from inlining comes from knock-on benefits. Just as a simple example, if you have code like:</p>
<pre><code>int i = Divide(10, 5);

static int Divide(int n, int d) =&gt; n / d;</code></pre>
<p>if <code>Divide</code> doesn’t get inlined, then when <code>Divide</code> is called, it’ll need to perform the actual <code>idiv</code>, which is a relatively expensive operation. In contrast, if <code>Divide</code> is inlined, then the call site becomes:</p>
<pre><code>int i = 10 / 5;</code></pre>
<p>which can be evaluated at compile time and becomes just:</p>
<pre><code>int i = 2;</code></pre>
<p>More compelling examples were already seen throughout the discussion of escape analysis and stack allocation, which depend heavily on the ability to inline methods. Given the increased importance of inlining, it’s gotten even more focus in .NET 10.</p>
<p>Some of the .NET work related to inlining is about enabling more kinds of things to be inlined. Historically, a variety of constructs present in a method would prevent that method from even being considered for inlining. Arguably the most well known of these is exception handling: methods with exception handling clauses, e.g. <code>try/catch</code> or <code>try/finally</code>, would not be inlined. Even a simple method like <code>M</code> in this example:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private readonly object _o = new();

    [Benchmark]
    public int Test()
    {
        M(_o);
        return 42;
    }

    private static void M(object o)
    {
        Monitor.Enter(o);
        try
        {
        }
        finally
        {
            Monitor.Exit(o);
        }
    }
}</code></pre>
<p>does not get inlined on .NET 9:</p>
<pre><code>; .NET 9
; Tests.Test()
       push      rax
       mov       rdi,[rdi+8]
       call      qword ptr [78F199864EE8]; Tests.M(System.Object)
       mov       eax,2A
       add       rsp,8
       ret
; Total bytes of code 21</code></pre>
<p>But with a plethora of PRs, in particular <a href="https://github.com/dotnet/runtime/pull/112968">dotnet/runtime#112968</a>, <a href="https://github.com/dotnet/runtime/pull/113023">dotnet/runtime#113023</a>, <a href="https://github.com/dotnet/runtime/pull/113497">dotnet/runtime#113497</a>, and <a href="https://github.com/dotnet/runtime/pull/112998">dotnet/runtime#112998</a>, methods containing <code>try/finally</code> are no longer blocked from inlining (<code>try/catch</code> regions are still a challenge). For the same benchmark on .NET 10, we now get this assembly:</p>
<pre><code>; .NET 10
; Tests.Test()
       push      rbp
       push      rbx
       push      rax
       lea       rbp,[rsp+10]
       mov       rbx,[rdi+8]
       test      rbx,rbx
       je        short M00_L03
       mov       rdi,rbx
       call      00007920A0EE65E0
       test      eax,eax
       je        short M00_L02
M00_L00:
       mov       rdi,rbx
       call      00007920A0EE6D50
       test      eax,eax
       jne       short M00_L04
M00_L01:
       mov       eax,2A
       add       rsp,8
       pop       rbx
       pop       rbp
       ret
M00_L02:
       mov       rdi,rbx
       call      qword ptr [79202393C1F8]
       jmp       short M00_L00
M00_L03:
       xor       edi,edi
       call      qword ptr [79202393C1C8]
       int       3
M00_L04:
       mov       edi,eax
       mov       rsi,rbx
       call      qword ptr [79202393C1E0]
       jmp       short M00_L01
; Total bytes of code 86</code></pre>
<p>The details of the assembly don’t matter, other than it’s a whole lot more than was there before, because we’re now looking in large part at the implementation of <code>M</code>. In addition to methods with <code>try/finally</code> now being inlineable, other improvements have also been made around exception handling. For example, <a href="https://github.com/dotnet/runtime/pull/110273">dotnet/runtime#110273</a> and <a href="https://github.com/dotnet/runtime/pull/110464">dotnet/runtime#110464</a> enable the removal of <code>try/catch</code> and <code>try/fault</code> blocks if it can prove the <code>try</code> block can’t possibly throw. Consider this:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;i&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(42)]
    public int Test(int i)
    {
        try
        {
            i++;
        }
        catch
        {
            Console.WriteLine(&#34;Exception caught&#34;);
        }

        return i;
    }
}</code></pre>
<p>There’s nothing the <code>try</code> block here can do that will result in an exception being thrown (assuming the developer hasn’t enabled checked arithmetic, in which case it could possibly throw an <code>OverflowException</code>), yet on .NET 9 we get this assembly:</p>
<pre><code>; .NET 9
; Tests.Test(Int32)
       push      rbp
       sub       rsp,10
       lea       rbp,[rsp+10]
       mov       [rbp-10],rsp
       mov       [rbp-4],esi
       mov       eax,[rbp-4]
       inc       eax
       mov       [rbp-4],eax
M00_L00:
       mov       eax,[rbp-4]
       add       rsp,10
       pop       rbp
       ret
       push      rbp
       sub       rsp,10
       mov       rbp,[rdi]
       mov       [rsp],rbp
       lea       rbp,[rbp+10]
       mov       rdi,784B08950018
       call      qword ptr [784B0DE44EE8]
       lea       rax,[M00_L00]
       add       rsp,10
       pop       rbp
       ret
; Total bytes of code 79</code></pre>
<p>Now on .NET 10, the JIT is able to elide the <code>catch</code> and remove all ceremony related to the <code>try</code> because it can see that ceremony is pointless overhead.</p>
<pre><code>; .NET 10
; Tests.Test(Int32)
       lea       eax,[rsi+1]
       ret
; Total bytes of code 4</code></pre>
<p>That’s true even when the contents of the <code>try</code> calls into other methods that are then inlined, exposing their contents to the JIT’s analysis.</p>
<p>(As an aside, the JIT was already able to remove <code>try/finally</code> when the <code>finally</code> was empty, but <a href="https://github.com/dotnet/runtime/pull/108003">dotnet/runtime#108003</a> catches even more cases of checking for empty <code>finally</code>s again after most other optimizations have been run, in case they revealed additional empty blocks.)</p>
<p>Another example is “GVM”. Previously, any method that called a GVM, or generic virtual method (a virtual method with a generic type parameter), would be blocked from being inlined.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private Base _base = new();

    [Benchmark]
    public int Test()
    {
        M();
        return 42;
    }

    private void M() =&gt; _base.M&lt;object&gt;();
}

class Base
{
    public virtual void M&lt;T&gt;() { }
}</code></pre>
<p>On .NET 9, the above results in this assembly:</p>
<pre><code>; .NET 9
; Tests.Test()
       push      rax
       call      qword ptr [728ED5664FD8]; Tests.M()
       mov       eax,2A
       add       rsp,8
       ret
; Total bytes of code 17</code></pre>
<p>Now on .NET 10, with <a href="https://github.com/dotnet/runtime/pull/116773">dotnet/runtime#116773</a>, <code>M</code> can now be inlined.</p>
<pre><code>; .NET 10
; Tests.Test()
       push      rbp
       push      rbx
       push      rax
       lea       rbp,[rsp+10]
       mov       rbx,[rdi+8]
       mov       rdi,rbx
       mov       rsi,offset MT_Base
       mov       rdx,78034C95D2A0
       call      System.Runtime.CompilerServices.VirtualDispatchHelpers.VirtualFunctionPointer(System.Object, IntPtr, IntPtr)
       mov       rdi,rbx
       call      rax
       mov       eax,2A
       add       rsp,8
       pop       rbx
       pop       rbp
       ret
; Total bytes of code 57</code></pre>
<p>Another area of investment with inlining is to do with the heuristics around when methods should be inlined. Just inlining everything would be bad; inlining copies code, which results in more code, which can have significant negative repercussions. For example, inlining’s increased code size puts more pressure on caches. Processors have an instruction cache, a small amount of super fast memory in a CPU that stores recently used instructions, making them really fast to access again the next time they’re needed (such as the next iteration through a loop, or the next time that same function is called). Consider a method <code>M</code>, and 100 call sites to <code>M</code> that are all being accessed. If all of those share the same instructions for <code>M</code>, because the 100 call sites are all actually calling <code>M</code>, the instruction cache will only need to load <code>M</code>‘s instructions once. If all of those 100 call sites each have their own copy of <code>M</code>‘s instructions, then all 100 copies will separately be loaded through the cache, fighting with each other and other instructions for residence. The less likely it is that instructions are in the cache, the more likely it is that the CPU will stall waiting for the instructions to be loaded from memory.</p>
<p>For this reason, the JIT needs to be careful what it inlines. It tries hard to avoid inlining anything that won’t benefit (e.g. a larger method whose instructions won’t be materially influenced by the caller’s context) while also trying hard to inline anything that will materially benefit (e.g. small functions where the code required to call the function is similar in size to the contents of the function, functions with instructions that could be materially impacted by information from the call site, etc.) As part of these heuristics, the JIT has the notion of “boosts,” where observations it makes about things methods do boost the chances of that method being inlined. <a href="https://github.com/dotnet/runtime/pull/114806">dotnet/runtime#114806</a> gives a boost to methods that appear to be returning new arrays of a small, fixed length; if those arrays can instead be allocated in the caller’s frame, the JIT might then be able to discover they don’t escape and enable them to be stack allocated. <a href="https://github.com/dotnet/runtime/pull/110596">dotnet/runtime#110596</a> similarly looks for boxing, as the caller could possibly instead avoid the box entirely.</p>
<p>For the same purpose (and also just to minimize time spent performing compilation), the JIT also maintains a budget for how much it allows to be inlined into a method compilation… once it hits that budget, it might stop inlining anything. The budgeting scheme overall works <em>ok</em>, however in certain circumstances it can run out of budget at very inopportune times, for example doing a lot of inlining at top-level call sites but then running out of budget by the time it gets to small methods that are critically-important to inline for good performance. To help mitigate these scenarios, <a href="https://github.com/dotnet/runtime/pull/114191">dotnet/runtime#114191</a> and <a href="https://github.com/dotnet/runtime/pull/118641">dotnet/runtime#118641</a> more than double the JIT’s default inlining budget.</p>
<p>The JIT also pays a lot of attention to the number of local variables (e.g. parameters/locals explicitly in the IL, JIT-created temporary locals, promoted struct fields, etc.) it tracks. To avoid creating too many, the JIT would stop inlining once it was already tracking 512. But as other changes have made inlining more aggressive, this (strangely hardcoded) limit gets hit more often, leaving very valuable inlinees out in the cold. <a href="https://github.com/dotnet/runtime/pull/118515">dotnet/runtime#118515</a> removed this fixed limit and instead ties it to a large percentage of the number of locals the JIT is allowed to track (by default, this ends up almost doubling the limit used by the inliner).</p>
<h3>Constant Folding</h3>
<p>Constant folding is a compiler’s ability to perform operations, typically math, at compile-time rather than at run-time: given multiple constants and an expressed relationship between them, the compiler can “fold” those constants together into a new constant. So, if you have the C# code <code>int M(int i) =&gt; i + 2 * 3;</code>, the C# compiler does constant folding and emits that into your compilation as if you’d written <code>int M(int i) =&gt; i + 6;</code>. The JIT can and does also do constant folding, which is valuable especially when it’s based on information not available to the C# compiler. For example, the JIT can treat <code>static readonly</code> fields or <code>IntPtr.Size</code> or <code>Vector128&lt;T&gt;.Count</code> as constants. And the JIT can do folding across inlines. For example, if you have:</p>
<pre><code>int M1(int i) =&gt; i + M2(2 * 3);
int M2(int j) =&gt; j * Environment.ProcessorCount;</code></pre>
<p>the C# compiler will only be able to fold the <code>2 * 3</code>, and will emit the equivalent of:</p>
<pre><code>int M1(int i) =&gt; i + M2(6);
int M2(int j) =&gt; j * Environment.ProcessorCount;</code></pre>
<p>but when compiling <code>M1</code>, the JIT can inline <code>M2</code> and treat <code>ProcessorCount</code> as a constant (on my machine it’s 16), and produce the following assembly code for <code>M1</code>:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;i&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(42)]
    public int M1(int i) =&gt; i + M2(6);

    private int M2(int j) =&gt; j * Environment.ProcessorCount;
}</code></pre>
<pre><code>; .NET 9
; Tests.M1(Int32)
       lea       eax,[rsi+60]
       ret
; Total bytes of code 4</code></pre>
<p>That’s as if the code for <code>M1</code> had been <code>public int M1(int i) =&gt; i + 96;</code> (the displayed assembly renders hexadecimal, so the <code>60</code> is hexadecimal <code>0x60</code> and thus decimal <code>96</code>).</p>
<p>Or consider:</p>
<pre><code>string M() =&gt; GetString() ?? throw new Exception();

static string GetString() =&gt; &#34;test&#34;;</code></pre>
<p>The JIT will be able to inline <code>GetString</code>, at which point it can see that the result is non-<code>null</code> and can fold away the check for the <code>null</code> constant, at which point it can also dead-code eliminate the <code>throw</code>. Constant folding is useful on its own in avoiding unnecessary work, but it also often unlocks other optimizations, like dead-code elimination and bounds-check elimination. The JIT is already quite good at finding constant folding opportunities, and gets better in .NET 10. Consider this benchmark:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;s&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(&#34;test&#34;)]
    public ReadOnlySpan&lt;char&gt; Test(string s)
    {
        s ??= &#34;&#34;;
        return s.AsSpan();
    }
}</code></pre>
<p>Here’s the assembly that gets produced for .NET 9:</p>
<pre><code>; .NET 9
; Tests.Test(System.String)
       push      rbp
       mov       rbp,rsp
       mov       rax,75B5D6200008
       test      rsi,rsi
       cmove     rsi,rax
       test      rsi,rsi
       jne       short M00_L01
       xor       eax,eax
       xor       edx,edx
M00_L00:
       pop       rbp
       ret
M00_L01:
       lea       rax,[rsi+0C]
       mov       edx,[rsi+8]
       jmp       short M00_L00
; Total bytes of code 41</code></pre>
<p>Of particular note are those two <code>test rsi,rsi</code> instructions, which are <code>null</code> checks. The assembly starts by loading a value into <code>rax</code>; that value is the address of the <code>&#34;&#34;</code> string literal. It then uses <code>test rsi,rsi</code> to check whether the <code>s</code> parameter, which was passed into this instance method in the <code>rsi</code> register, is <code>null</code>. If it is <code>null</code>, the <code>cmove rsi,rax</code> instruction sets it to the address of the <code>&#34;&#34;</code> literal. And then… it does <code>test rsi,rsi</code> again? That second test is the <code>null</code> check at the beginning of <code>AsSpan</code>, which looks like this:</p>
<pre><code>public static ReadOnlySpan&lt;char&gt; AsSpan(this string? text)
{
    if (text is null) return default;
    return new ReadOnlySpan&lt;char&gt;(ref text.GetRawStringData(), text.Length);
}</code></pre>
<p>Now with <a href="https://github.com/dotnet/runtime/pull/111985">dotnet/runtime#111985</a>, that second <code>null</code> check, along with others, can be folded, resulting in this:</p>
<pre><code>; .NET 10
; Tests.Test(System.String)
       mov       rax,7C01C4600008
       test      rsi,rsi
       cmove     rsi,rax
       lea       rax,[rsi+0C]
       mov       edx,[rsi+8]
       ret
; Total bytes of code 25</code></pre>
<p>Similar impact comes from <a href="https://github.com/dotnet/runtime/pull/108420">dotnet/runtime#108420</a>, which is also able to fold a different class of <code>null</code> checks.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;condition&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(true)]
    public bool Test(bool condition)
    {
        string tmp = condition ? GetString1() : GetString2();
        return tmp is not null;
    }

    private static string GetString1() =&gt; &#34;Hello&#34;;
    private static string GetString2() =&gt; &#34;World&#34;;
}</code></pre>
<p>In this benchmark, <em>we</em> can see that neither <code>GetString1</code> nor <code>GetString2</code> return <code>null</code>, and thus the <code>is not null</code> check shouldn’t be necessary. The JIT in .NET 9 couldn’t see that, but its improved .NET 10 self can.</p>
<pre><code>; .NET 9
; Tests.Test(Boolean)
       mov       rax,7407F000A018
       mov       rcx,7407F000A050
       test      sil,sil
       cmove     rax,rcx
       test      rax,rax
       setne     al
       movzx     eax,al
       ret
; Total bytes of code 37

; .NET 10
; Tests.Test(Boolean)
       mov       eax,1
       ret
; Total bytes of code 6</code></pre>
<p>Constant folding also applies to SIMD (Single Instruction Multiple Data), instructions that enable processing multiple pieces of data at once rather than only one element at a time. <a href="https://github.com/dotnet/runtime/pull/117099">dotnet/runtime#117099</a> and <a href="https://github.com/dotnet/runtime/pull/117572">dotnet/runtime#117572</a> both enable more SIMD comparison operations to participate in folding.</p>
<h3>Code Layout</h3>
<p>When the JIT compiler generates assembly from the IL emitted by the C# compiler, it organizes that code into “basic blocks,” a sequence of instructions with one entry point and one exit point, no jumps inside, no branches out except at the end. These blocks can then be moved around as a unit, and the order in which these blocks are placed in memory is referred to as “code layout” or “basic block layout.” This ordering can have a significant performance impact because modern CPUs rely heavily on an instruction cache and on branch prediction to keep things moving fast. If frequently executed (“hot”) blocks are close together and follow a common execution path, the CPU can execute them with fewer cache misses and fewer mispredicted jumps. If the layout is poor, where the hot code is split into pieces far apart from each other, or where rarely executed (“cold”) code sits in between, the CPU can spend more time jumping around and refilling caches than doing actual work. Consider a tight loop executed millions of times. A good layout keeps the loop entry, body, and backward edge (the jump back to the beginning of the body to do the next iteration) right next to each other, letting the CPU fetch them straight from the cache. In a bad layout, that loop might be interwoven with unrelated cold blocks (say, a <code>catch</code> block for a <code>try</code> in the loop), forcing the CPU to load instructions from different places and disrupting the flow. Similarly, for an <code>if</code> block, the likely path should generally be the next block so no jump is required, with the unlikely branch behind a short jump away, as that better aligns with the sensibilities of branch predictors. Code layout heuristics control how that happens, and as a result, how efficient the resulting code is able to execute.</p>
<p>When determining the starting layout of the blocks (before additional optimizations are done for the layout), <a href="https://github.com/dotnet/runtime/pull/108903">dotnet/runtime#108903</a> employs a “loop-aware reverse post-order” traversal. A reverse post-order traversal is an algorithm for visiting the nodes in a control flow graph such that each block appears after its predecessors. The “loop aware” part means the traversal recognizes loops as units, effectively creating a block around the whole loop, and tries to keep the whole loop together as the layout algorithm moves things around. The intent here is to start the larger layout optimizations from a more sensible place, reducing the amount of later reshuffling and situations where loop bodies get broken up.</p>
<p>In the extreme, layout is essentially the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">traveling salesman problem</a>. The JIT must decide the order of basic blocks so that control transfers follow short, predictable paths and make efficient use of instruction cache and branch prediction. Just like the salesman visiting cities with minimal total travel distance, the compiler is trying to arrange blocks so that the “distance” between blocks, which might be measured in bytes or instruction fetch cost or something similar, is minimized. For any meaningfully-sized set of blocks, this is prohibitively expensive to compute optimally, as the number of possible orderings grows factorially with the number of blocks. Thus, the JIT has to rely on approximations rather than attempting an exact solution. One such approximation it employs now as of <a href="https://github.com/dotnet/runtime/pull/103450">dotnet/runtime#103450</a> (and then tweaked further in <a href="https://github.com/dotnet/runtime/pull/109741">dotnet/runtime#109741</a> and <a href="https://github.com/dotnet/runtime/pull/109835">dotnet/runtime#109835</a>) is a “3-opt,” which really just means that rather than considering all blocks together, it looks at only three and tries to produce an optimal ordering amongst those (there are only eight possible orderings to be checked). The JIT can choose to iterate through sets of three blocks until either it doesn’t see any more improvements or hits a self-imposed limit. Specifically when handling backward jumps, with <a href="https://github.com/dotnet/runtime/pull/110277">dotnet/runtime#110277</a>, it expands this “3-opt” to “4-opt” (four blocks).</p>
<p>.NET 10 also does a better job of factoring PGO data into layout. With dynamic PGO, the JIT is able to gather instrumentation data from an initial compilation and then use the results of that profiling to impact an optimized re-compilation. That data can lead to conclusions about what blocks are hot or cold, and which direction branches take, all information that’s valuable for layout optimization. However, data can sometimes be missing from these profiles, so the JIT has a “profile synthesis” algorithm that makes realistic guesses for these gaps in order to fill them in (if you’ve read or seen “Jurassic Park,” this is the JIT-equivalent to filling in gaps in the dinosaur DNA sequences with that from present-day frogs.) With <a href="https://github.com/dotnet/runtime/pull/111915">dotnet/runtime#111915</a>, that repairing of the profile data is now performed just before layout, so that layout has a more complete picture.</p>
<p>Let’s take a concrete example of all this. Here I’ve extracted the core function from <code>MemoryExtensions.BinarySearch</code>:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private int[] _values = Enumerable.Range(0, 512).ToArray();

    [Benchmark]
    public int BinarySearch()
    {
        int[] values = _values;
        return BinarySearch(ref values[0], values.Length, 256);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static int BinarySearch&lt;T, TComparable&gt;(
        ref T spanStart, int length, TComparable comparable)
        where TComparable : IComparable&lt;T&gt;, allows ref struct
    {
        int lo = 0;
        int hi = length - 1;
        while (lo &lt;= hi)
        {
            int i = (int)(((uint)hi + (uint)lo) &gt;&gt; 1);

            int c = comparable.CompareTo(Unsafe.Add(ref spanStart, i));
            if (c == 0)
            {
                return i;
            }
            else if (c &gt; 0)
            {
                lo = i + 1;
            }
            else
            {
                hi = i - 1;
            }
        }

        return ~lo;
    }
}</code></pre>
<p>And here’s the assembly we get for .NET 9 and .NET 10, diff’d from the former to the latter:</p>
<pre><code>; Tests.BinarySearch[[System.Int32, System.Private.CoreLib],[System.Int32, System.Private.CoreLib]](Int32 ByRef, Int32, Int32)
       push      rbp
       mov       rbp,rsp
       xor       ecx,ecx
       dec       esi
       js        short M01_L07
+      jmp       short M01_L03
M01_L00:
-      lea       eax,[rsi+rcx]
-      shr       eax,1
-      movsxd    r8,eax
-      mov       r8d,[rdi+r8*4]
-      cmp       edx,r8d
-      jge       short M01_L03
       mov       r9d,0FFFFFFFF
M01_L01:
       test      r9d,r9d
       je        short M01_L06
       test      r9d,r9d
       jg        short M01_L05
       lea       esi,[rax-1]
M01_L02:
       cmp       ecx,esi
-      jle       short M01_L00
-      jmp       short M01_L07
+      jg        short M01_L07
M01_L03:
+      lea       eax,[rsi+rcx]
+      shr       eax,1
+      movsxd    r8,eax
+      mov       r8d,[rdi+r8*4]
       cmp       edx,r8d
-      jg        short M01_L04
-      xor       r9d,r9d
+      jl        short M01_L00
+      cmp       edx,r8d
+      jle       short M01_L04
+      mov       r9d,1
       jmp       short M01_L01
M01_L04:
-      mov       r9d,1
+      xor       r9d,r9d
       jmp       short M01_L01
M01_L05:
       lea       ecx,[rax+1]
       jmp       short M01_L02
M01_L06:
       pop       rbp
       ret
M01_L07:
       mov       eax,ecx
       not       eax
       pop       rbp
       ret
; Total bytes of code 83</code></pre>
<p>We can see that the main change here is a block that’s moved (the bulk of <code>M01_L00</code> moving down to <code>M01_L03</code>). In .NET 9, the <code>lo &lt;= hi</code> “stay in the loop check” (<code>cmp ecx,esi</code>) is a backward conditional branch (<code>jle short M01_L00</code>), where every iteration of the loop except for the last jumps back to the top (<code>M01_L00</code>). In .NET 10, it instead does a forward branch to exit the loop only in the rarer case, otherwise falling through to the body of the loop in the common case, and then unconditionally branching back.</p>
<h3>GC Write Barriers</h3>
<p>The .NET garbage collector (GC) works on a generational model, organizing the managed heap according to how long objects have been alive. The newest allocations land in “generation 0” (gen0), objects that have survived at least one collection are promoted to “generation 1” (gen1), and those that have been around for longer end up in “generation 2” (gen2). This is based on the premise that most objects are temporary, and that once an object has been around for a while, it’s likely to stick around for a while longer. Splitting up the heap into generations enables for quickly collecting gen0 objects by only scanning the gen0 heap for remaining references to that object. The expectation is that all, or at least the vast majority, of references to a gen0 object are also in gen0. Of course, if a reference to a gen0 object snuck into gen1 or gen2, not scanning gen1 or gen2 during a gen0 collection could be, well, bad. To avoid that case, the JIT collaborates with the GC to track references from older to younger generations. Whenever there’s a reference write that could cross a generation, the JIT emits a call to a helper that tracks the information in a “card table,” and when the GC runs, it consults this table to see if it needs to scan a portion of the higher generations. That helper is referred to as a “GC write barrier.” Since a write barrier is potentially employed on every reference write, it must be super fast, and in fact the runtime has several different variations of write barriers so that the JIT can pick one optimized for the given situation. Of course, the fastest write barrier is one that doesn’t need to exist at all, so as with bounds checks, the JIT also exerts energy to try to prove when write barriers aren’t needed, eliding them when it can. And it can even more in .NET 10.</p>
<p><code>ref structs</code>, referred to in runtime vernacular as “byref-like types,” can never live on the heap, which means any reference fields in them will similarly never live on the heap. As such, if the JIT can prove that a reference write is targeting a field of a <code>ref struct</code>, it can elide the write barrier. Consider this example:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private object _object = new();

    [Benchmark]
    public MyRefStruct Test() =&gt; new MyRefStruct() { Obj1 = _object, Obj2 = _object, Obj3 = _object };

    public ref struct MyRefStruct
    {
        public object Obj1;
        public object Obj2;
        public object Obj3;
    }
}</code></pre>
<p>In the .NET 9 assembly, we can see three write barriers (<code>CORINFO_HELP_CHECKED_ASSIGN_REF</code>) corresponding to the three fields in <code>MyRefStruct</code> in the benchmark:</p>
<pre><code>; .NET 9
; Tests.Test()
       push      r15
       push      r14
       push      rbx
       mov       rbx,rsi
       mov       r15,[rdi+8]
       mov       rsi,r15
       mov       r14,r15
       mov       rdi,rbx
       call      CORINFO_HELP_CHECKED_ASSIGN_REF
       lea       rdi,[rbx+8]
       mov       rsi,r14
       call      CORINFO_HELP_CHECKED_ASSIGN_REF
       lea       rdi,[rbx+10]
       mov       rsi,r15
       call      CORINFO_HELP_CHECKED_ASSIGN_REF
       mov       rax,rbx
       pop       rbx
       pop       r14
       pop       r15
       ret
; Total bytes of code 59</code></pre>
<p>With <a href="https://github.com/dotnet/runtime/pull/111576">dotnet/runtime#111576</a> and <a href="https://github.com/dotnet/runtime/pull/111733">dotnet/runtime#111733</a> in .NET 10, all of those write barriers are elided:</p>
<pre><code>; .NET 10
; Tests.Test()
       mov       rax,[rdi+8]
       mov       rcx,rax
       mov       rdx,rax
       mov       [rsi],rcx
       mov       [rsi+8],rdx
       mov       [rsi+10],rax
       mov       rax,rsi
       ret
; Total bytes of code 25</code></pre>
<p>Much more impactful, however, are <a href="https://github.com/dotnet/runtime/pull/112060">dotnet/runtime#112060</a> and <a href="https://github.com/dotnet/runtime/pull/112227">dotnet/runtime#112227</a>, which have to do with “return buffers.” When a .NET method is typed to return a value, the runtime has to decide how that value gets from the callee back to the caller. For small types, like integers, floating-point numbers, pointers, or object references, the answer is simple: the value can be passed back via one or more CPU registers reserved for return values, making the operation essentially free. But not all values fit neatly into registers. Larger value types, such as structs with multiple fields, require a different strategy. In these cases, the caller allocates a “return buffer,” a block of memory, typically in the caller’s stack frame, and the caller passes a pointer to that buffer as a hidden argument to the method. The method then writes the return value directly into that buffer in order to provide the caller with the data. When it comes to write barriers, the challenge here is that there historically hasn’t been a requirement that the return buffer be on the stack; it’s technically feasible it could have been allocated on the heap, even if it rarely or never is. And since the callee doesn’t know where the buffer lives, any object reference writes needed to be tracked with GC write barriers. We can see that with a simple benchmark:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private string _firstName = &#34;Jane&#34;, _lastName = &#34;Smith&#34;, _address = &#34;123 Main St&#34;, _city = &#34;Anytown&#34;;

    [Benchmark]
    public Person GetPerson() =&gt; new(_firstName, _lastName, _address, _city);

    public record struct Person(string FirstName, string LastName, string Address, string City);
}</code></pre>
<p>On .NET 9, each field of the returned value type is incurring a <code>CORINFO_HELP_CHECKED_ASSIGN_REF</code> write barrier:</p>
<pre><code>; .NET 9
; Tests.GetPerson()
       push      r15
       push      r14
       push      r13
       push      rbx
       mov       rbx,rsi
       mov       rsi,[rdi+8]
       mov       r15,[rdi+10]
       mov       r14,[rdi+18]
       mov       r13,[rdi+20]
       mov       rdi,rbx
       call      CORINFO_HELP_CHECKED_ASSIGN_REF
       lea       rdi,[rbx+8]
       mov       rsi,r15
       call      CORINFO_HELP_CHECKED_ASSIGN_REF
       lea       rdi,[rbx+10]
       mov       rsi,r14
       call      CORINFO_HELP_CHECKED_ASSIGN_REF
       lea       rdi,[rbx+18]
       mov       rsi,r13
       call      CORINFO_HELP_CHECKED_ASSIGN_REF
       mov       rax,rbx
       pop       rbx
       pop       r13
       pop       r14
       pop       r15
       ret
; Total bytes of code 81</code></pre>
<p>Now in .NET 10, the calling convention has been updated to require that the return buffer live on the stack (if the caller wants the data somewhere else, it’s responsible for subsequently doing that copy). And because the return buffer is now guaranteed to be on the stack, the JIT can elide all GC write barriers as part of returning values.</p>
<pre><code>; .NET 10
; Tests.GetPerson()
       mov       rax,[rdi+8]
       mov       rcx,[rdi+10]
       mov       rdx,[rdi+18]
       mov       rdi,[rdi+20]
       mov       [rsi],rax
       mov       [rsi+8],rcx
       mov       [rsi+10],rdx
       mov       [rsi+18],rdi
       mov       rax,rsi
       ret
; Total bytes of code 35</code></pre>
<p><a href="https://github.com/dotnet/runtime/pull/111636">dotnet/runtime#111636</a> from <a href="https://github.com/a74nh">@a74nh</a> is also interesting from a performance perspective because, as is common in optimization, it trades off one thing for another. Prior to this change, Arm64 had one universal write barrier helper for all GC modes. This change brings Arm64 in line with x64 by routing through a <code>WriteBarrierManager</code> that selects among multiple <code>JIT_WriteBarrier</code> variants based on runtime configuration. In doing so, it makes each Arm64 write barrier a bit more expensive, by adding region checks and moving to a region-aware card marking scheme, but in exchange it lets the GC do less work: fewer cards in the card table get marked, and the GC can scan more precisely. <a href="https://github.com/dotnet/runtime/pull/106191">dotnet/runtime#106191</a> also helps reduce the cost of write barriers on Arm64 by tightening the hot-path comparisons and eliminating some avoidable saves and restores.</p>
<h3>Instruction Sets</h3>
<p>.NET continues to see meaningful optimizations and improvements across all supported architectures, along with various architecture-specific improvements. Here are a handful of examples.</p>
<h4>Arm SVE</h4>
<p>APIs for Arm SVE were introduced in .NET 9. As noted in the <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/#arm-sve">Arm SVE</a> section of last year’s post, enabling SVE is a multi-year effort, and in .NET 10, support is still considered experimental. However, the support has continued to be improved and extended, with PRs like <a href="https://github.com/dotnet/runtime/pull/115775">dotnet/runtime#115775</a> from <a href="https://github.com/snickolls-arm">@snickolls-arm</a> adding <code>BitwiseSelect</code> methods, <a href="https://github.com/dotnet/runtime/pull/117711">dotnet/runtime#117711</a> from <a href="https://github.com/jacob-crawley">@jacob-crawley</a> adding <code>MaxPairwise</code> and <code>MinPairwise</code> methods, and <a href="https://github.com/dotnet/runtime/pull/117051">dotnet/runtime#117051</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a> adding <code>VectorTableLookup</code> methods.</p>
<h4>Arm64</h4>
<p><a href="https://github.com/dotnet/runtime/pull/111893">dotnet/runtime#111893</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a>, <a href="https://github.com/dotnet/runtime/pull/111904">dotnet/runtime#111904</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a>, <a href="https://github.com/dotnet/runtime/pull/111452">dotnet/runtime#111452</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a>, <a href="https://github.com/dotnet/runtime/pull/112235">dotnet/runtime#112235</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a>, and <a href="https://github.com/dotnet/runtime/pull/111797">dotnet/runtime#111797</a> from <a href="https://github.com/snickolls-arm">@snickolls-arm</a> all improved .NET’s support for utilizing Arm64’s multi-operation compound instructions. For example, when implementing a compare and branch, rather than emitting a <code>cmp</code> against 0 followed by <code>beq</code> instruction, the JIT may now emit a <code>cbz</code> (“Compare and Branch on Zero”) instruction.</p>
<h4>APX</h4>
<p>Intel’s Advanced Performance Extensions (APX) was announced in 2023 as an extension of the x86/x64 instruction set. It expands the number of general-purpose registers from 16 to 32 and adds new instructions such as conditional operations designed to reduce memory traffic, improve performance, and lower power consumption. <a href="https://github.com/dotnet/runtime/pull/106557">dotnet/runtime#106557</a> from <a href="https://github.com/Ruihan-Yin">@Ruihan-Yin</a>, <a href="https://github.com/dotnet/runtime/pull/108796">dotnet/runtime#108796</a> from <a href="https://github.com/Ruihan-Yin">@Ruihan-Yin</a>, and <a href="https://github.com/dotnet/runtime/pull/113237">dotnet/runtime#113237</a> from <a href="https://github.com/Ruihan-Yin">@Ruihan-Yin</a> essentially teach the JIT how to speak the new dialect of assembly code (the REX and expanded EVEX encodings), and <a href="https://github.com/dotnet/runtime/pull/108799">dotnet/runtime#108799</a> from <a href="https://github.com/Ruihan-Yin">@Ruihan-Yin</a> updates the JIT to be able to use the expanded set of registers. The most impactful new instructions in APX are around conditional compares (<code>ccmp</code>), a concept the JIT already supports from targeting other instruction sets, and <a href="https://github.com/dotnet/runtime/pull/111072">dotnet/runtime#111072</a> from <a href="https://github.com/anthonycanino">@anthonycanino</a>, <a href="https://github.com/dotnet/runtime/pull/112153">dotnet/runtime#112153</a> from <a href="https://github.com/anthonycanino">@anthonycanino</a>, and <a href="https://github.com/dotnet/runtime/pull/116445">dotnet/runtime#116445</a> from <a href="https://github.com/khushal1996">@khushal1996</a> all teach the JIT how to make good use of these new instructions with APX.</p>
<h4>AVX512</h4>
<p>.NET 8 added broad support for AVX512, and .NET 9 significantly improved its handling and adoption throughout the core libraries. .NET 10 includes a plethora of additional related optimizations:</p>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/109258">dotnet/runtime#109258</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> and <a href="https://github.com/dotnet/runtime/pull/109267">dotnet/runtime#109267</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> expand the number of places the JIT is able to use EVEX embedded broadcasts, a feature that lets vector instructions read a single scalar element from memory and implicitly replicate it to all the lanes of the vector, without needing a separate broadcast or shuffle operation.</li>
<li><a href="https://github.com/dotnet/runtime/pull/108824">dotnet/runtime#108824</a> removes a redundant sign extension from broadcasts.</li>
<li><a href="https://github.com/dotnet/runtime/pull/116117">dotnet/runtime#116117</a> from <a href="https://github.com/alexcovington">@alexcovington</a> improves the code generated for <code>Vector.Max</code> and <code>Vector.Min</code> when AVX512 is supported.</li>
<li><a href="https://github.com/dotnet/runtime/pull/109474">dotnet/runtime#109474</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> improves “containment” (where an instruction can be eliminated by having its behaviors fully encapsulated by another instruction) for AVX512 widening intrinsics (similar containment-related improvements were made in <a href="https://github.com/dotnet/runtime/pull/110736">dotnet/runtime#110736</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> and <a href="https://github.com/dotnet/runtime/pull/111778">dotnet/runtime#111778</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a>).</li>
<li><a href="https://github.com/dotnet/runtime/pull/111853">dotnet/runtime#111853</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> improves <code>Vector128/256/512.Dot</code> to be better accelerated with AVX512.</li>
<li><a href="https://github.com/dotnet/runtime/pull/110195">dotnet/runtime#110195</a>, <a href="https://github.com/dotnet/runtime/pull/110307">dotnet/runtime#110307</a>, and <a href="https://github.com/dotnet/runtime/pull/117118">dotnet/runtime#117118</a> all improve how vector masks are handled. In AVX512, masks are special registers that can be included as part of various instructions to control which subset of vector elements should be utilized (each bit in a mask corresponds to one element in the vector). This enables operating on only part of a vector without needing extra branching or shuffling.</li>
<li><a href="https://github.com/dotnet/runtime/pull/115981">dotnet/runtime#115981</a> improves zeroing (where the JIT emits instructions to zero out memory, often as part of initializing a stack frame) on AVX512. After zeroing as much as it can with 64-byte instructions, it was falling back to using 16-byte instructions, when it could have used 32-byte instructions.</li>
<li><a href="https://github.com/dotnet/runtime/pull/110662">dotnet/runtime#110662</a> improves the code generated for <code>ExtractMostSignificantBits</code> (which is used by many of the searching algorithms in the core libraries) when working with <code>short</code> and <code>ushort</code> (and <code>char</code>, as most of those core library implementations reinterpret cast <code>char</code> as one of the others) by using EVEX mask support.</li>
<li><a href="https://github.com/dotnet/runtime/pull/113864">dotnet/runtime#113864</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> improves the code generated for <code>ConditionalSelect</code> when not used with mask registers.</li>
</ul>
<h4>AVX10.2</h4>
<p>.NET 9 added support and intrinsics for the AVX10.1 instruction set. With <a href="https://github.com/dotnet/runtime/pull/111209">dotnet/runtime#111209</a> from <a href="https://github.com/khushal1996">@khushal1996</a>, .NET 10 adds support and intrinsics for the AVX10.2 instruction set. <a href="https://github.com/dotnet/runtime/pull/112535">dotnet/runtime#112535</a> from <a href="https://github.com/khushal1996">@khushal1996</a> optimizes floating-point min/max operations with AVX10.2 instructions, while <a href="https://github.com/dotnet/runtime/pull/111775">dotnet/runtime#111775</a> from <a href="https://github.com/khushal1996">@khushal1996</a> enables floating-point conversions to utilize AVX10.2.</p>
<h4>GFNI</h4>
<p><a href="https://github.com/dotnet/runtime/pull/109537">dotnet/runtime#109537</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> adds intrinsics for the GFNI (Galois Field New Instructions) instruction set, which can be used for accelerating operations over Galois fields GF(2^8). These are common in cryptography, error correction, and data encoding.</p>
<h4>VPCLMULQDQ</h4>
<p><code>VPCLMULQDQ</code> is an x86 instruction set extension that adds vector support to the older <code>PCLMULQDQ</code> instruction, which performs carry-less multiplication over 64-bit integers. <a href="https://github.com/dotnet/runtime/pull/109137">dotnet/runtime#109137</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> adds new intrinsic APIs for <code>VPCLMULQDQ</code>.</p>
<h3>Miscellaneous</h3>
<p>Many more PRs than the ones I’ve already called out have gone into the JIT this release. Here are a few more:</p>
<ul>
<li><strong>Eliminating some covariance checks</strong>. Writing into arrays of reference types can require “covariance checks.” Imagine you have a class <code>Base</code> and two derived types <code>Derived1 : Base</code> and <code>Derived2 : Base</code>. Since arrays in .NET are covariant, I can have a <code>Derived1[]</code> and cast it successfully to a <code>Base[]</code>, but under the covers that’s still a <code>Derived1[]</code>. That means, for example, that any attempt to store a <code>Derived2</code> into that array should fail at runtime, even if it compiles. To achieve that, the JIT needs to insert such covariance checks when writing into arrays, but just like with bounds checking and write barriers, the JIT can elide those checks when it can prove statically that they’re not necessary. Such an example is with sealed types. If the JIT sees an array of type <code>T[]</code> and <code>T</code> is known to be sealed, <code>T[]</code> must exactly be a <code>T[]</code> and not some <code>DerivedT[]</code>, because there can’t be a <code>DerivedT</code>. So with a benchmark like this:
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private List&lt;string&gt; _list = new() { &#34;hello&#34; };

    [Benchmark]
    public void Set() =&gt; _list[0] = &#34;world&#34;;
}</code></pre>
<p>as long as the JIT can see that the array underlying the <code>List&lt;string&gt;</code> is a <code>string[]</code> (<code>string</code> is sealed), it shouldn’t need a covariance check. In .NET 9, we get this:</p>
<pre><code>; .NET 9
; Tests.Set()
       push      rbx
       mov       rbx,[rdi+8]
       cmp       dword ptr [rbx+10],0
       je        short M00_L00
       mov       rdi,[rbx+8]
       xor       esi,esi
       mov       rdx,78914920A038
       call      System.Runtime.CompilerServices.CastHelpers.StelemRef(System.Object[], IntPtr, System.Object)
       inc       dword ptr [rbx+14]
       pop       rbx
       ret
M00_L00:
       call      qword ptr [78D1F80558A8]
       int       3
; Total bytes of code 44</code></pre>
<p>Note that <code>CastHelpers.StelemRef</code> call… that’s the helper that performs the write with the covariance check. But now in .NET 10, thanks to <a href="https://github.com/dotnet/runtime/pull/107116">dotnet/runtime#107116</a> (which teaches the JIT how to resolve the exact type for the field of the closed generic), we get this:</p>
<pre><code>; .NET 10
; Tests.Set()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       cmp       dword ptr [rax+10],0
       je        short M00_L00
       mov       rcx,[rax+8]
       mov       edx,[rcx+8]
       test      rdx,rdx
       je        short M00_L01
       mov       rdx,75E2B9009A40
       mov       [rcx+10],rdx
       inc       dword ptr [rax+14]
       pop       rbp
       ret
M00_L00:
       call      qword ptr [762368116760]
       int       3
M00_L01:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 58</code></pre>
<p>No covariance check, thank you very much.</p></li>
<li><strong>More strength reduction</strong>. “Strength reduction” is a classic compiler optimization that replaces more expensive operations, like multiplications, with cheaper ones, like additions. In .NET 9, this was used to transform indexed loops that used multiplied offsets (e.g. <code>index * elementSize</code>) into loops that simply incremented a pointer-like offset (e.g. <code>offset += elementSize</code>), cutting down on arithmetic overhead and improving performance. In .NET 10, strength reduction has been extended, in particular with <a href="https://github.com/dotnet/runtime/pull/110222">dotnet/runtime#110222</a>. This enables the JIT to detect multiple loop induction variables with different step sizes and strength-reduce them by leveraging their greatest common divisor (GCD). Essentially, it creates a single primary induction variable based on the GCD of the varying step sizes, and then recovers each original induction variable by appropriately scaling. Consider this example:
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;numbers&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(&#34;128514801826028643102849196099776734920914944609068831724328541639470403818631040&#34;)]
    public int[] Parse(string numbers)
    {
        int[] results = new int[numbers.Length];
        for (int i = 0; i &lt; numbers.Length; i++)
        {
            results[i] = numbers[i] - &#39;0&#39;;
        }

        return results;
    }
}</code></pre>
<p>In this benchmark, we’re iterating through an input <code>string</code>, which is a collection of 2-byte <code>char</code> elements, and we’re storing the results into an array of 4-byte <code>int</code> elements. The core loop in the .NET 9 assembly looks like this:</p>
<pre><code>; .NET 9
M00_L00:
       mov       edx,ecx
       movzx     edi,word ptr [rbx+rdx*2+0C]
       add       edi,0FFFFFFD0
       mov       [rax+rdx*4+10],edi
       inc       ecx
       cmp       r15d,ecx
       jg        short M00_L00</code></pre>
<p>The <code>movzx edi,word ptr [rbx+rdx*2+0C]</code> is the read of <code>numbers[i]</code>, and the <code>mov [rax+rdx*4+10],edi</code> is the assignment to <code>results[i]</code>. <code>rdx</code> here is <code>i</code>, so each assignment is effectively having to do <code>i*2</code> to compute the byte offset of the <code>char</code> at index <code>i</code>, and similarly do <code>i*4</code> to compute the byte offset of the <code>int</code> at offset <code>i</code>. Now here’s the .NET 10 assembly:</p>
<pre><code>; .NET 10
M00_L00:
       movzx     edx,word ptr [rbx+rcx+0C]
       add       edx,0FFFFFFD0
       mov       [rax+rcx*2+10],edx
       add       rcx,2
       dec       r15d
       jne       short M00_L00</code></pre>
<p>The multiplication in the <code>numbers[i]</code> read is gone. Instead, it can just increment <code>rcx</code> by 2 on each iteration, treating that as the offset to the <code>i</code>th <code>char</code>, and then instead of multiplying by 4 to compute the <code>int</code> offset, it just multiples by 2.</p></li>
<li><strong>CSE integration with SSA</strong>. As with most compilers, the JIT employs common subexpression elimination (CSE) to find identical computations and avoid doing them repeatedly. <a href="https://github.com/dotnet/runtime/pull/106637">dotnet/runtime#106637</a> teaches the JIT how to do so in a more consistent manner by more fully integrating CSE with its Static Single Assignment (SSA) representation. This in turn allows for more optimizations to kick in, e.g. some of the strength reduction done around loop induction variables in .NET 9 wasn’t applying as much as it should have, and now it will.</li>
<li><strong><code>return someCondition ? true : false</code></strong>. There are often multiple ways to represent the same thing, but it often happens in compilers that certain patterns will be recognized during optimization while other equivalent ones won’t, and it can therefore behoove the compiler to first normalize the representations to all use the better recognized one. There’s a really common and interesting case of this with <code>return someCondition</code>, where, for reasons relating to the JIT’s internal representation, the JIT is better able to optimize with the equivalent <code>return someCondition ? true : false</code>. <a href="https://github.com/dotnet/runtime/pull/107499">dotnet/runtime#107499</a> normalizes to the latter. As an example of this, consider this benchmark:
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;i&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(42)]
    public bool Test1(int i)
    {
        if (i &gt; 10 &amp;&amp; i &lt; 20) return true;
        return false;
    }

    [Benchmark]
    [Arguments(42)]
    public bool Test2(int i) =&gt; i &gt; 10 &amp;&amp; i &lt; 20;
}</code></pre>
<p>On .NET 9, that results in this assembly code for <code>Test1</code>:</p>
<pre><code>; .NET 9
; Tests.Test1(Int32)
       sub       esi,0B
       cmp       esi,8
       setbe     al
       movzx     eax,al
       ret
; Total bytes of code 13</code></pre>
<p>The JIT has successfully recognized that it can change the two comparisons to instead be a subtraction and a single comparison, as if the <code>i &gt; 10 &amp;&amp; i &lt; 20</code> were instead written as <code>(uint)(i - 11) &lt;= 8</code>. But for <code>Test2</code>, .NET 9 produces this:</p>
<pre><code>; .NET 9
; Tests.Test2(Int32)
       xor       eax,eax
       cmp       esi,14
       setl      cl
       movzx     ecx,cl
       cmp       esi,0A
       cmovg     eax,ecx
       ret
; Total bytes of code 18</code></pre>
<p>Because of how the return condition is being represented internally by the JIT, it’s missing this particular optimization, and the assembly code more directly reflects what was written in the C#. But now in .NET 10, because of this normalization, we now get this for <code>Test2</code>, exactly what we got for <code>Test1</code>:</p>
<pre><code>; .NET 10
; Tests.Test2(Int32)
       sub       esi,0B
       cmp       esi,8
       setbe     al
       movzx     eax,al
       ret
; Total bytes of code 13</code></pre>
</li>
<li><strong>Bit tests</strong>. The C# compiler has a lot of flexibility in how it emits <code>switch</code> and <code>is</code> expressions. Consider a case like this: <code>c is &#39; &#39; or &#39;\t&#39; or &#39;\r&#39; or &#39;\n&#39;</code>. It could emit that as the equivalent of a series of cascading <code>if</code>/<code>else</code> branches, as an IL <code>switch</code> instruction, as a bit test, or as combinations of those. The C# compiler, though, doesn’t have all of the information the JIT has, such as whether the process is 32-bit or 64-bit, or knowledge of what instructions cost on given hardware. With <a href="https://github.com/dotnet/runtime/pull/107831">dotnet/runtime#107831</a>, the JIT will now recognize more such expressions that can be implemented as a bit test and generate the code accordingly.
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;c&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(&#39;s&#39;)]
    public void Test(char c)
    {
        if (c is &#39; &#39; or &#39;\t&#39; or &#39;\r&#39; or &#39;\n&#39; or &#39;.&#39;)
        {
            Handle(c);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        static void Handle(char c) { }
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test</td>
<td>.NET 9.0</td>
<td>0.4537 ns</td>
<td>1.02</td>
<td>58 B</td>
</tr>
<tr>
<td>Test</td>
<td>.NET 10.0</td>
<td>0.1304 ns</td>
<td>0.29</td>
<td>44 B</td>
</tr>
</tbody>
</table>
<p>It’s also common to see bit tests implemented in C# against shifted values; a constant mask is created with bits set at various indices, and then an incoming value to check is tested by shifting a bit to the corresponding index and seeing whether it aligns with one in the mask. For example, here is how <code>Regex</code> tests to see whether a provided <code>UnicodeCategory</code> is one of those that composes the “word” class (`\w`):</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Globalization;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;uc&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(UnicodeCategory.DashPunctuation)]
    public bool Test(UnicodeCategory uc) =&gt; (WordCategoriesMask &amp; (1 &lt;&lt; (int)uc)) != 0;

    private const int WordCategoriesMask =
        1 &lt;&lt; (int)UnicodeCategory.UppercaseLetter |
        1 &lt;&lt; (int)UnicodeCategory.LowercaseLetter |
        1 &lt;&lt; (int)UnicodeCategory.TitlecaseLetter |
        1 &lt;&lt; (int)UnicodeCategory.ModifierLetter |
        1 &lt;&lt; (int)UnicodeCategory.OtherLetter |
        1 &lt;&lt; (int)UnicodeCategory.NonSpacingMark |
        1 &lt;&lt; (int)UnicodeCategory.DecimalDigitNumber |
        1 &lt;&lt; (int)UnicodeCategory.ConnectorPunctuation;
}</code></pre>
<p>Previously, the JIT would end up emitting that similar to how it’s written: a shift followed by a test. Now with <a href="https://github.com/dotnet/runtime/pull/111979">dotnet/runtime#111979</a> from <a href="https://github.com/varelen">@varelen</a>, it can emit it as a bit test.</p>
<pre><code>; .NET 9
; Tests.Test(System.Globalization.UnicodeCategory)
       mov       eax,1
       shlx      eax,eax,esi
       test      eax,4013F
       setne     al
       movzx     eax,al
       ret
; Total bytes of code 22

; .NET 10
; Tests.Test(System.Globalization.UnicodeCategory)
       mov       eax,4013F
       bt        eax,esi
       setb      al
       movzx     eax,al
       ret
; Total bytes of code 15</code></pre>
</li>
<li><strong>Redundant sign extensions</strong>. With <a href="https://github.com/dotnet/runtime/pull/111305">dotnet/runtime#111305</a>, the JIT can now remove more redundant sign extensions (when you take a smaller size type, e.g. <code>int</code>, and convert it to a larger size type, e.g. <code>long</code>, while preserving the value’s sign). For example, with a test like this <code>public ulong Test(int x) =&gt; (uint)x &lt; 10 ? (ulong)x &lt;&lt; 60 : 0</code>, the JIT can now emit a <code>mov</code> (just copy the bits) instead of <code>movsxd</code> (move with sign extension), since it knows from the first comparison that the shift will only ever be performed with a non-negative <code>x</code>.</li>
<li><strong>Better division with BMI2</strong>. If the BMI2 instruction set is available, with <a href="https://github.com/dotnet/runtime/pull/116198">dotnet/runtime#116198</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a> the JIT can now use the <code>mulx</code> instruction (“Unsigned Multiply Without Affecting Flags”) to implement integer division, e.g.
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;value&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(12345)]
    public ulong Div10(ulong value) =&gt; value / 10;
}</code></pre>
<p>results in:</p>
<pre><code>; .NET 9
; Tests.Div10(UInt64)
       mov       rdx,0CCCCCCCCCCCCCCCD
       mov       rax,rsi
       mul       rdx
       mov       rax,rdx
       shr       rax,3
       ret
; Total bytes of code 24

; .NET 10
; Tests.Div10(UInt64)
       mov       rdx,0CCCCCCCCCCCCCCCD
       mulx      rax,rax,rsi
       shr       rax,3
       ret
; Total bytes of code 20</code></pre>
</li>
<li><strong>Better range comparison</strong>. When comparing a <code>ulong</code> expression against <code>uint.MaxValue</code>, rather than being emitted as a comparison, with <a href="https://github.com/dotnet/runtime/pull/113037">dotnet/runtime#113037</a> from <a href="https://github.com/shunkino">@shunkino</a> it can be handled more efficiently as a shift.
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;x&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(12345)]
    public bool Test(ulong x) =&gt; x &lt;= uint.MaxValue;
}</code></pre>
<p>resulting in:</p>
<pre><code>; .NET 9
; Tests.Test(UInt64)
       mov       eax,0FFFFFFFF
       cmp       rsi,rax
       setbe     al
       movzx     eax,al
       ret
; Total bytes of code 15

; .NET 10
; Tests.Test(UInt64)
       shr       rsi,20
       sete      al
       movzx     eax,al
       ret
; Total bytes of code 11</code></pre>
</li>
<li><strong>Better dead branch elimination</strong>. The JIT’s branch optimizer is already able to use implications from comparisons to statically determine the outcome of other branches. For example, if I have this:
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;x&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(42)]
    public void Test(int x)
    {
        if (x &gt; 100)
        {
            if (x &gt; 10)
            {
                Console.WriteLine();
            }
        }
    }
}</code></pre>
<p>the JIT generates this on .NET 9:</p>
<pre><code>; .NET 9
; Tests.Test(Int32)
       cmp       esi,64
       jg        short M00_L00
       ret
M00_L00:
       jmp       qword ptr [7766D3E64FA8]
; Total bytes of code 12</code></pre>
<p>Note there’s only a single comparison against 100 (0x64), with the comparison against 10 elided (as it’s implied by the previous comparison). However, there are many variations to this, and not all of them were handled equally well. Consider this:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;x&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(42)]
    public void Test(int x)
    {
        if (x &lt; 16)
            return;

        if (x &lt; 8)
            Console.WriteLine();
    }
}</code></pre>
<p>Here, the <code>Console.WriteLine</code> ideally wouldn’t appear in the emitted assembly at all, as it’s never reachable. Alas, on .NET 9, we get this (the <code>jmp</code> instruction here is a tail call to <code>WriteLine</code>):</p>
<pre><code>; .NET 9
; Tests.Test(Int32)
       push      rbp
       mov       rbp,rsp
       cmp       esi,10
       jl        short M00_L00
       cmp       esi,8
       jge       short M00_L00
       pop       rbp
       jmp       qword ptr [731ED8054FA8]
M00_L00:
       pop       rbp
       ret
; Total bytes of code 23</code></pre>
<p>With <a href="https://github.com/dotnet/runtime/pull/111766">dotnet/runtime#111766</a> on .NET 10, it successfully recognizes that by the time it gets to the <code>x &lt; 8</code>, that condition will always be <code>false</code>, and it can be eliminated. And once it’s eliminated, the initial branch is also unnecessary. So the whole method reduces to this:</p>
<pre><code>; .NET 10
; Tests.Test(Int32)
       ret
; Total bytes of code 1</code></pre>
</li>
<li><strong>Better floating-point conversion</strong>. <a href="https://github.com/dotnet/runtime/pull/114410">dotnet/runtime#114410</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a>, <a href="https://github.com/dotnet/runtime/pull/114597">dotnet/runtime#114597</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a>, and <a href="https://github.com/dotnet/runtime/pull/111595">dotnet/runtime#111595</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> all speed up conversions between floating-point and integers, such as by using <code>vcvtusi2s</code> when AVX512 is available, or when it isn’t, avoiding the intermediate <code>double</code> conversion.
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;i&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(42)]
    public float Compute(uint i) =&gt; i;
}</code></pre>
<pre><code>; .NET 9
; Tests.Compute(UInt32)
       mov       eax,esi
       vxorps    xmm0,xmm0,xmm0
       vcvtsi2sd xmm0,xmm0,rax
       vcvtsd2ss xmm0,xmm0,xmm0
       ret
; Total bytes of code 16

; .NET 10
; Tests.Compute(UInt32)
       vxorps    xmm0,xmm0,xmm0
       vcvtusi2ss xmm0,xmm0,esi
       ret
; Total bytes of code 11</code></pre>
</li>
<li><strong>Unrolling</strong>. When using <code>CopyTo</code> (or other “memmove”-based operations) with a constant source, <a href="https://github.com/dotnet/runtime/pull/108576">dotnet/runtime#108576</a> reduces costs by avoiding a redundant memory load. <a href="https://github.com/dotnet/runtime/pull/109036">dotnet/runtime#109036</a> unblocks more unrolling on Arm64 for <code>Equals</code>/<code>StartsWith</code>/<code>EndsWith</code>. And <a href="https://github.com/dotnet/runtime/pull/110893">dotnet/runtime#110893</a> enables unrolling non-zero fills (unrolling already happened for zero fills).
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private char[] _chars = new char[100];

    [Benchmark]
    public void Fill() =&gt; _chars.AsSpan(0, 16).Fill(&#39;x&#39;);
}</code></pre>
<pre><code>; .NET 9
; Tests.Fill()
       push      rbp
       mov       rbp,rsp
       mov       rdi,[rdi+8]
       test      rdi,rdi
       je        short M00_L00
       cmp       dword ptr [rdi+8],10
       jb        short M00_L00
       add       rdi,10
       mov       esi,10
       mov       edx,78
       call      qword ptr [7F3093FBF1F8]; System.SpanHelpers.Fill[[System.Char, System.Private.CoreLib]](Char ByRef, UIntPtr, Char)
       nop
       pop       rbp
       ret
M00_L00:
       call      qword ptr [7F3093787810]
       int       3
; Total bytes of code 49

; .NET 10
; Tests.Fill()
       push      rbp
       mov       rbp,rsp
       mov       rax,[rdi+8]
       test      rax,rax
       je        short M00_L00
       cmp       dword ptr [rax+8],10
       jl        short M00_L00
       add       rax,10
       vbroadcastss ymm0,dword ptr [78EFC70C9340]
       vmovups   [rax],ymm0
       vzeroupper
       pop       rbp
       ret
M00_L00:
       call      qword ptr [78EFC7447B88]
       int       3
; Total bytes of code 48</code></pre>
<p>Note the call to <code>SpanHelpers.Fill</code> in the .NET 9 assembly and the absence of it in the .NET 10 assembly.</p></li>
</ul>
<h2>Native AOT</h2>
<p>Native AOT is the ability for a .NET application to be compiled directly to assembly code at build-time. The JIT is still used for code generation, but only at build time; the JIT isn’t part of the shipping app at all, and no code generation is performed at run-time. As such, most of the optimizations to the JIT already discussed, as well as optimizations throughput the rest of this post, apply to Native AOT equally. Native AOT presents some unique opportunities and challenges, however.</p>
<p>One super power of the Native AOT tool chain is the ability to interpret (some) code at build-time and use the results of that execution rather than performing the operation at run-time. This is particularly relevant for static constructors, where the constructor’s code can be interpreted to initialize various <code>static readonly</code> fields, and then the contents of those fields can be persisted into the generated assembly; at run-time, the contents needs only be rehydrated from the assembly rather than being recomputed. This also potentially helps to make more code redundant and removable, if for example the static constructor and anything it (and only it) referenced were no longer needed. Of course, it would be dangerous and problematic if any arbitrary code could be run during build, so instead there’s a very filtered allow list and specialized support for the most common and appropriate constructs. <a href="https://github.com/dotnet/runtime/pull/107575">dotnet/runtime#107575</a> augments this “preinitialization” capability to support spans sourced from arrays, such that using methods like <code>.AsSpan()</code> doesn’t cause preinitialization to bail out. <a href="https://github.com/dotnet/runtime/pull/114374">dotnet/runtime#114374</a> also improved preinitialization, removing restrictions around accessing static fields of other types, calling methods on other types that have their own static constructors, and dereferencing pointers.</p>
<p>Conversely, Native AOT has its own challenges, specifically that size really matters and is harder to control. With a JIT available at run-time, code generation for only exactly what’s needed can be deferred until run-time. With Native AOT, <em>all</em> assembly code generation needs to be done at build-time, which means the Native AOT tool chain needs to work hard to determine the least amount of code it needs to emit to support everything the app might need to do at run-time. Most of the effort on Native AOT in any given release ends up being about helping it to further decrease the size of generated code. For example:</p>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/117411">dotnet/runtime#117411</a> enables folding bodies of generic instantations of the same method, essentially avoiding duplication by using the same code for copies of the same method where possible.</li>
<li><a href="https://github.com/dotnet/runtime/pull/117080">dotnet/runtime#117080</a> similarly helps improve the existing method body deduplication logic.</li>
<li><a href="https://github.com/dotnet/runtime/pull/117345">dotnet/runtime#117345</a> from <a href="https://github.com/huoyaoyuan">@huoyaoyuan</a> tweaks a bit of code in reflection that would previously artificially force the code to be preserved for all enumerators of all generic instantations of every collection type.</li>
<li><a href="https://github.com/dotnet/runtime/pull/112782">dotnet/runtime#112782</a> adds the same distinction that already existed for <code>MethodTable</code>s for non-generic methods (“is this method table visible to user code or not”) to generic methods, allowing more metadata for the non-user visible ones to be optimized away.</li>
<li><a href="https://github.com/dotnet/runtime/pull/118718">dotnet/runtime#118718</a> and <a href="https://github.com/dotnet/runtime/pull/118832">dotnet/runtime#118832</a> enable size reductions related to boxed enums. The former tweaks a few methods in <code>Thread</code>, <code>GC</code>, and <code>CultureInfo</code> to avoid boxing some enums, which means the code for those needn’t be generated. The latter tweaks the implementation of <code>RuntimeHelpers.CreateSpan</code>, which is used by the C# compiler as part of creating spans with constructs like collection expressions. <code>CreateSpan</code> is a generic method, and the Native AOT toolchain’s whole-program analysis would end up treating the generic type parameter as being “reflected on,” meaning the compiler had to assume any type parameter would be used with reflection and thus had to preserve relevant metadata. When used with enums, it would need to ensure support for boxed enums was kept around, and <code>System.Console</code> has such a use with an enum. That in turn meant that a simple “hello, world” console app couldn’t trim away that boxed enum reflection support; now it can.</li>
</ul>
<h2>VM</h2>
<p>The .NET runtime offers a wide range of services to managed applications, most obviously the garbage collector and the JIT compiler, but it also encompasses a host of other capabilities: assembly and type loading, exception handling, virtual method dispatch, interoperability support, stub generation, and so on. Collectively, all of these features are referred to as being a part of the .NET Virtual Machine (VM).</p>
<p><a href="https://github.com/dotnet/runtime/pull/108167">dotnet/runtime#108167</a> and <a href="https://github.com/dotnet/runtime/pull/109135">dotnet/runtime#109135</a> rewrote various runtime helpers from C in the runtime to C# in <code>System.Private.CoreLib</code>, including the “unboxing” helpers, which are used to unbox <code>object</code>s to value types in niche scenarios. This rewrite avoids overheads associated with transitioning between native and managed and also enables the JIT an opportunity to optimize in the context of callers, such as with inlining. Note that these unboxing helpers are only used in obscure situations, so it requires a bit of a complicated benchmark to demonstrate the impact:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[DisassemblyDiagnoser(0)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private object[] _objects = [new GenericStruct&lt;MyStruct, object&gt;()];

    [Benchmark]
    public void Unbox() =&gt; Unbox&lt;GenericStruct&lt;MyStruct, object&gt;&gt;(_objects[0]);

    private void Unbox&lt;T&gt;(object o) where T : struct, IStaticMethod&lt;T&gt;
    {
        T? local = (T?)o;
        if (local.HasValue)
        {
            T localCopy = local.Value;
            T.Method(ref localCopy);
        }
    }

    public interface IStaticMethod&lt;T&gt;
    {
        public static abstract void Method(ref T param);
    }

    struct MyStruct : IStaticMethod&lt;MyStruct&gt;
    {
        public static void Method(ref MyStruct param) { }
    }

    struct GenericStruct&lt;T, V&gt; : IStaticMethod&lt;GenericStruct&lt;T, V&gt;&gt; where T : IStaticMethod&lt;T&gt;
    {
        public T Value;

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void Method(ref GenericStruct&lt;T, V&gt; value) =&gt; T.Method(ref value.Value);
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unbox</td>
<td>.NET 9.0</td>
<td>1.626 ns</td>
<td>1.00</td>
<td>148 B</td>
</tr>
<tr>
<td>Unbox</td>
<td>.NET 10.0</td>
<td>1.379 ns</td>
<td>0.85</td>
<td>148 B</td>
</tr>
</tbody>
</table>
<p>What it means to move the implementation from native to managed is most easily seen just by looking at the generated assembly. Other than uninteresting and non-impactful changes in which registers happen to get assigned, the only real difference between .NET 9 and .NET 10 is a single instruction:</p>
<pre><code>-      call      CORINFO_HELP_UNBOX_NULLABLE
+      call      System.Runtime.CompilerServices.CastHelpers.Unbox_Nullable(Byte ByRef, System.Runtime.CompilerServices.MethodTable*, System.Object)</code></pre>
<p><a href="https://github.com/dotnet/runtime/pull/115284">dotnet/runtime#115284</a> streamlines how the runtime sets up and tears down the little code blocks (“funclets”) the runtime uses to implement <code>catch</code>/<code>finally</code> on x64. Historically, these funclets acted a lot like tiny functions, saving and restoring non-volatile CPU registers on entry and exit (a “non-volatile” register is effectively one where the caller can expect it to contain the same value after a function call as it did before the function call). This PR changes the contract so that funclets no longer need to preserve those registers themselves; instead, the runtime takes care of preserving them. That shrinks the prologs and epilogs the JIT emits for funclets, reduces instruction count and code size, and lowers the cost of entering and exiting exception handlers.</p>
<p>With <a href="https://github.com/dotnet/runtime/pull/114462">dotnet/runtime#114462</a>, the runtime now uses a single shared “template” for many of the small executable “stubs” it needs at runtime; stubs are tiny chunks of machine code that act as jump points, call counters, or patchable trampolines. Previously, each memory allocation for stubs would regenerate the same instructions over and over. The new approach builds one copy of the stub code in a read-only page and then maps that same physical page into every place it’s needed, while giving each allocation its own writable page for the per-stub data that changes at runtime. This lets hundreds of virtual stub pages all point to one physical code page, cutting memory use, reducing startup work, and improving instruction cache locality.</p>
<p>Also interesting are <a href="https://github.com/dotnet/runtime/pull/117218">dotnet/runtime#117218</a> and <a href="https://github.com/dotnet/runtime/pull/116031">dotnet/runtime#116031</a>, which together help optimize the generation of stack traces in large, heavily multi-threaded applications when being profiled.</p>
<h2>Threading</h2>
<p>The <code>ThreadPool</code> underlies most work in most .NET apps and services. It’s a critical-path component that has to be able to deal with all manners of workloads efficiently.</p>
<p><a href="https://github.com/dotnet/runtime/pull/109841">dotnet/runtime#109841</a> implemented an opt-in feature that <a href="https://github.com/dotnet/runtime/pull/112796">dotnet/runtime#112796</a> then enabled by default for .NET 10. The idea behind it is fairly straightforward, but to understand it, we first need to examine how the thread pool queues work items. The thread pool has multiple queues, typically one “global” queue and then one “local” queue per thread in the pool. When threads outside of the pool queue work, that work goes to the global queue, and when a thread pool thread queues work, especially a <code>Task</code> or work related to an <code>await</code>, that work item typically goes to that thread’s local queue. Then when a thread pool thread finishes whatever it was doing and goes in search of more work, it first checks its own local queue (treating its local queue as highest priority), then if that’s empty it checks the global queue, and then if that’s empty it goes and helps out the other threads in the pool by searching their queues for work to be done. This is all in an attempt to a) minimize contention on the global queue (if threads are mainly queueing and dequeuing from their own local queue, they’re not contending with each other), and b) prioritize work that’s logically part of already started work (the only way for work to get into a local queue is if that thread was processing a work item that created it). Generally, this works out well, but sometimes we get into degenerate scenarios, typically when an app does something that goes against best practices… like blocking.</p>
<p>Blocking a thread pool thread means that thread can’t service other work coming into the pool. If the blocking is brief, it’s generally fine, and if it’s longer, the thread pool tries to accommodate it by injecting more threads and finding a steady state at which things hum along. But a certain kind of blocking can be really problematic: <a href="https://devblogs.microsoft.com/dotnet/should-i-expose-synchronous-wrappers-for-asynchronous-methods/">“sync over async”</a>. With “sync over async”, one thread blocks while waiting for an asynchronous operation to complete, and if <em>that</em> operation needs to do something on the thread pool in order to complete, you now have one thread pool thread blocked waiting for another thread pool thread to pick up a particular work item and process it. This can quickly lead to the whole pool getting into a jam… especially with the thread local queues. If a thread is blocked on an operation that depends on work items in that thread’s local queue getting processed, that work item being picked off now depends on the global queue being exhausted and another thread coming along and stealing the work item from this thread’s queue. If there’s a steady stream of incoming work into the global queue, though, that will never happen; essentially, the highest priority work item has become the lowest priority work item.</p>
<p>So, back to these PRs. The idea is fairly simple: when the thread is about to block, and in particular when it’s about to block waiting on a <code>Task</code>, it first dumps its entire local queue into the global queue. That way, this work which was highest priority for the blocked thread has a fairer chance of being processed by other threads, rather than it being the lowest priority work for everyone. We can try to see the impact of this with a specifically-crafted workload:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34;
// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using System.Diagnostics;

int numThreads = Environment.ProcessorCount;
ThreadPool.SetMaxThreads(numThreads, 1);

ManualResetEventSlim start = new();
CountdownEvent allDone = new(numThreads);
new Thread(() =&gt;
{
    while (true)
    {
        for (int i = 0; i &lt; 10_000; i++)
        {
            ThreadPool.QueueUserWorkItem(_ =&gt; Thread.SpinWait(1));
        }

        Thread.Yield();
    }
}) { IsBackground = true }.Start();

for (int i = 0; i &lt; numThreads; i++)
{
    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        start.Wait();
        TaskCompletionSource tcs = new();

        const int LocalItemsPerThread = 4;
        var remaining = LocalItemsPerThread;
        for (int j = 0; j &lt; LocalItemsPerThread; j++)
        {
            Task.Run(() =&gt;
            {
                Thread.SpinWait(100);
                if (Interlocked.Decrement(ref remaining) == 0)
                {
                    tcs.SetResult();
                }
            });
        }

        tcs.Task.Wait();
        allDone.Signal();
    });
}

var sw = Stopwatch.StartNew();
start.Set();
Console.WriteLine(allDone.Wait(20_000) ?
    $&#34;Completed: {sw.ElapsedMilliseconds}ms&#34; :
    $&#34;Timed out after {sw.ElapsedMilliseconds}ms&#34;);</code></pre>
<p>This is:</p>
<ul>
<li>creating a noise thread that tries to keep the global queue inundated with new work</li>
<li>queuing <code>Environment.ProcessorCount</code> work items, each of which queues four work items to the local queue that all do a little work and then blocks on a <code>Task</code> until they all complete</li>
<li>waiting for those <code>Environment.ProcessorCount</code> work items to complete</li>
</ul>
<p>When I run this on .NET 9, it hangs, because there’s so much work in the global queue, no threads are able to process those sub-work items that are necessary to unblock the main work items:</p>
<pre><code>Timed out after 20002ms</code></pre>
<p>On .NET 10, it generally completes almost instantly:</p>
<pre><code>Completed: 4ms</code></pre>
<p>Some other tweaks were made to the pool as well:</p>
<ul>
<li><a href="https://github.com/dotnet/runtime/pull/115402">dotnet/runtime#115402</a> reduced the amount of spin-waiting done on Arm processors, bringing it more in line with x64.</li>
<li><a href="https://github.com/dotnet/runtime/pull/112789">dotnet/runtime#112789</a> reduced the frequency at which the thread pool checked CPU utilization, as in some circumstances it was adding noticeable overhead, and makes the frequency configurable.</li>
<li><a href="https://github.com/dotnet/runtime/pull/108135">dotnet/runtime#108135</a> from <a href="https://github.com/AlanLiu90">@AlanLiu90</a> removed a bit of lock contention that could happen under load when starting new thread pool threads.</li>
</ul>
<p>On the subject of locking, and only for developers that find themselves with a strong need to do really low-level low-lock development, <a href="https://github.com/dotnet/runtime/pull/107843">dotnet/runtime#107843</a> from <a href="https://github.com/hamarb123">@hamarb123</a> adds two new methods to the <code>Volatile</code> class: <code>ReadBarrier</code> and <code>WriteBarrier</code>. A read barrier has “load acquire” semantics, and is sometimes referred to as a “downward fence”: it prevents instructions from being reordered in such a way that memory accesses below/after the barrier move to above/before it. In contrast, a write barrier has “store release” semantics, and is sometimes referred to as an “upwards fence”: it prevents instructions from being reordered in such a way that memory accesses above/before the barrier move to below/after it. I find it helps to think about this with regards to a <code>lock</code>:</p>
<pre><code>A;
lock (...)
{
    B;
}
C;</code></pre>
<p>While in practice the implementation may provide stronger fences, by specification entering a <code>lock</code> has acquire semantics and exiting a <code>lock</code> has release semantics. Imagine if the instructions in the above code could be reordered like this:</p>
<pre><code>A;
B;
lock (...)
{
}
C;</code></pre>
<p>or like this:</p>
<pre><code>A;
lock (...)
{
}
B;
C;</code></pre>
<p>Both of those would be really bad. Thankfully, the barriers help us here. The acquire / read barrier semantics of entering the lock are a downwards fence: logically the brace that starts the lock puts downwards pressure on everything inside the lock to not move to before it, and the brace that ends the lock puts upwards pressure on everything inside the lock to not move to after it. Interestingly, nothing about the semantics of these barriers prevents this from happening:</p>
<pre><code>lock (...)
{
    A;
    B;
    C;
}</code></pre>
<p>These barriers are referred to as “half fences”; the read barrier prevents later things from moving earlier, but not the other way around, and the write barrier prevents earlier things from moving later, but not the other way around. (As it happens, though, while not required by specification, today the implementation of <code>lock</code> does use a full barrier on both enter and exit, so nothing before or after a <code>lock</code> will move into it.)</p>
<p>For <code>Task</code> in .NET 10, <code>Task.WhenAll</code> has a few changes to improve its performance. <a href="https://github.com/dotnet/runtime/pull/110536">dotnet/runtime#110536</a> avoids a temporary collection allocation when needing to buffer up tasks from an <code>IEnumerable&lt;Task&gt;</code>.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public Task WhenAllAlloc()
    {
        AsyncTaskMethodBuilder t = default;
        Task whenAll = Task.WhenAll(from i in Enumerable.Range(0, 2) select t.Task);
        t.SetResult();
        return whenAll;
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WhenAllAlloc</td>
<td>.NET 9.0</td>
<td>216.8 ns</td>
<td>1.00</td>
<td>496 B</td>
<td>1.00</td>
</tr>
<tr>
<td>WhenAllAlloc</td>
<td>.NET 10.0</td>
<td>181.9 ns</td>
<td>0.84</td>
<td>408 B</td>
<td>0.82</td>
</tr>
</tbody>
</table>
<p>And <a href="https://github.com/dotnet/runtime/pull/117715">dotnet/runtime#117715</a> from <a href="https://github.com/CuteLeon">@CuteLeon</a> avoids the overhead of the <code>Task.WhenAll</code> altogether when the input ends up just being a single task, in which case it simply returns that task instance.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public Task WhenAllAlloc()
    {
        AsyncTaskMethodBuilder t = default;
        Task whenAll = Task.WhenAll([t.Task]);
        t.SetResult();
        return whenAll;
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WhenAllAlloc</td>
<td>.NET 9.0</td>
<td>72.73 ns</td>
<td>1.00</td>
<td>144 B</td>
<td>1.00</td>
</tr>
<tr>
<td>WhenAllAlloc</td>
<td>.NET 10.0</td>
<td>33.06 ns</td>
<td>0.45</td>
<td>72 B</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p><a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/"><code>System.Threading.Channels</code></a> is one of the lesser-known but quite useful areas of threading in .NET (you can watch <a href="https://www.youtube.com/watch?v=J3IQBI5HVOw">Yet Another “Highly Technical Talk” with Hanselman and Toub</a> from Build 2025 to learn more about it). If you find yourself needing a queue to hand off some data between a producer and a consumer, you should likely look into <code>Channel&lt;T&gt;</code>. The library was introduced in .NET Core 3.0 as a small, robust, and fast producer/consumer queueing mechanism; it’s evolved since, such as gaining a <code>ReadAllAsync</code> method for consuming the contents of a channel as an <code>IAsyncEnumerable&lt;T&gt;</code> and a <code>PeekAsync</code> method for peeking at its contents without consuming. The original release supported <code>Channel.CreateUnbounded</code> and <code>Channel.CreateBounded</code> methods, and .NET 9 augmented those with a <code>Channel.CreateUnboundedPrioritized</code>. .NET 10 continues to expand on channels, both with functional improvements (such as with <a href="https://github.com/dotnet/runtime/pull/116097">dotnet/runtime#116097</a>, which adds an unbuffered channel implementation), and with performance improvements.</p>
<p>.NET 10 helps to to reduce overall memory consumption of an application using channels. One of the cross-cutting features channels supports is cancellation: you can cancel pretty much any interaction with a channel, which sports asynchronous methods for both producing and consuming data. When a reader or writer needs to pend, it creates (or reuses a pooled instance of) an <code>AsyncOperation</code> object that gets added to a queue; a later writer or reader that’s then able to satisfy a pending reader or writer dequeues one and marks it as completed. These queues were implemented with arrays, which makes it challenging to remove an entry from the middle of the queue if the associated operation gets canceled. So, rather than trying, it simply left the canceled object in the queue, and then when it would eventually get dequeued, it’s just thrown away and the dequeuer tries again. The theory was that, at steady state, you will quickly dequeue any canceled operations, and it’d be better to not exert a lot of effort to try to remove them more quickly. As it turns out, that assumption was problematic for some scenarios, where the workload wasn’t balanced, e.g. lots of readers would pend and timeout due to lack of writers, and each of those timed out readers would leave behind a canceled item in the queue. The next time a writer would come along, yes, all those canceled readers would get cleared out, but in the meantime, it would manifest as a notable increase in working set.</p>
<p><a href="https://github.com/dotnet/runtime/pull/116021">dotnet/runtime#116021</a> addresses that by switching from array-backed queues to linked-list-based queues. The waiter objects themselves double as the nodes in the linked lists, so the only additional memory overhead is a couple of fields for the previous and next nodes in the linked list. But even that modest increase is undesirable, so as part of the PR, it also tries to find compensating optimizations to balance things out. It’s able to remove a field from <code>Channel&lt;T&gt;</code>‘s custom implementation of <code>IValueTaskSource&lt;T&gt;</code> by applying a similar optimization that was made to <code>ManualResetValueTaskSourceCore&lt;T&gt;</code> in a previous release: it’s incredibly rare for an awaiter to supply an <code>ExecutionContext</code> (via use of the awaiter’s <code>OnCompleted</code> rather than <code>UnsafeOnCompleted</code> method), and even more so for that to happen when there’s also a non-default <code>TaskScheduler</code> or <code>SynchronizationContext</code> that needs to be stored, so rather than using two fields for those concepts, they just get grouped into one (which means that in the super duper rare case where both are needed, it incurs an extra allocation). Another field is removed for storing a <code>CancellationToken</code> on the instance, which on .NET Core can be retrieved from other available state. These changes then actually result in the size of the <code>AsyncOperation</code> waiter instance decreasing rather than increasing. Win win. It’s hard to see the impact of this change on throughput; it’s easier to just see what the impact is on working set in the degenerate case where canceled operations are never removed. If I run this code:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34;
// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using System.Threading.Channels;

Channel&lt;int&gt; c = Channel.CreateUnbounded&lt;int&gt;();

for (int i = 0; ; i++)
{
    CancellationTokenSource cts = new();
    var vt = c.Reader.ReadAsync(cts.Token);
    cts.Cancel();
    await ((Task)vt.AsTask()).ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing);

    if (i % 100_000 == 0)
    {
        Console.WriteLine($&#34;Working set: {Environment.WorkingSet:N0}b&#34;);
    }
}</code></pre>
<p>in .NET 9 I get output like this, with an ever increasing working set:</p>
<pre><code>Working set: 31,588,352b
Working set: 164,884,480b
Working set: 210,698,240b
Working set: 293,711,872b
Working set: 385,495,040b
Working set: 478,158,848b
Working set: 553,385,984b
Working set: 608,206,848b
Working set: 699,695,104b
Working set: 793,034,752b
Working set: 885,309,440b
Working set: 986,103,808b
Working set: 1,094,234,112b
Working set: 1,156,239,360b
Working set: 1,255,198,720b
Working set: 1,347,604,480b
Working set: 1,439,879,168b
Working set: 1,532,284,928b</code></pre>
<p>and in .NET 10, I get output like this, with a nice level steady state working set:</p>
<pre><code>Working set: 33,030,144b
Working set: 44,826,624b
Working set: 45,481,984b
Working set: 45,613,056b
Working set: 45,875,200b
Working set: 45,875,200b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b
Working set: 46,006,272b</code></pre>
<h2>Reflection</h2>
<p>.NET 8 added the <code>[UnsafeAccessor]</code> attribute, which enables a developer to write an <code>extern</code> method that matches up with some non-visible member the developer wants to be able to use, and the runtime fixes up the accesses to be just as if the target member was being used directly. .NET 9 then extended it with generic support.</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Reflection;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private List&lt;int&gt; _list = new List&lt;int&gt;(16);
    private FieldInfo _itemsField = typeof(List&lt;int&gt;).GetField(&#34;_items&#34;, BindingFlags.NonPublic | BindingFlags.Instance)!;

    private static class Accessors&lt;T&gt;
    {
        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = &#34;_items&#34;)]
        public static extern ref T[] GetItems(List&lt;T&gt; list);
    }

    [Benchmark]
    public int[] WithReflection() =&gt; (int[])_itemsField.GetValue(_list)!;

    [Benchmark]
    public int[] WithUnsafeAccessor() =&gt; Accessors&lt;int&gt;.GetItems(_list);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
</tr>
</thead>
<tbody>
<tr>
<td>WithReflection</td>
<td>2.6397 ns</td>
</tr>
<tr>
<td>WithUnsafeAccessor</td>
<td>0.7300 ns</td>
</tr>
</tbody>
</table>
<p>But there are still gaps in that story. The signature of the <code>UnsafeAccessor</code> member needs to align with the signature of the target member, but what if that target member has parameters that aren’t visible to the code writing the <code>UnsafeAccessor</code>? Or, what if the target member is static? There’s no way for the developer to express in the <code>UnsafeAccessor</code> on which type the target member exists.</p>
<p>For these scenarios, <a href="https://github.com/dotnet/runtime/pull/114881">dotnet/runtime#114881</a> augments the story with the <code>[UnsafeAccessorType]</code> attribute. The <code>UnsafeAccessor</code> method can type the relevant parameters as <code>object</code> but then adorn them with an <code>[UnsafeAccessorType(&#34;...&#34;)]</code> that provides a fully-qualified name of the target type. There are a bunch of examples then of this being used in <a href="https://github.com/dotnet/runtime/pull/115583">dotnet/runtime#115583</a>, which replaces most of the cross-library reflection done between libraries in .NET itself with use of <code>[UnsafeAccessor]</code>. An example of where this is handy is with a cyclic relationship between <code>System.Net.Http</code> and <code>System.Security.Cryptography</code>. <code>System.Net.Http</code> sits above <code>System.Security.Cryptography</code>, referencing it for critical features like <code>X509Certificate</code>. But <code>System.Security.Cryptography</code> needs to be able to make HTTP requests in order to download OCSP information, and with <code>System.Net.Http</code> referencing <code>System.Security.Cryptography</code>, <code>System.Security.Cryptography</code> can’t in turn explicitly reference <code>System.Net.Http</code>. It can, however, use reflection or <code>[UnsafeAccessor]</code> and <code>[UnsafeAccessorType]</code> to do so, and it does. It used to use reflection, now in .NET 10 it uses <code>[UnsafeAccessor]</code>.</p>
<p>There are a few other nice improvements in and around reflection. <a href="https://github.com/dotnet/runtime/pull/105814">dotnet/runtime#105814</a> from <a href="https://github.com/huoyaoyuan">@huoyaoyuan</a> updates <code>ActivatorUtilities.CreateFactory</code> to remove a layer of delegates. <code>CreateFactory</code> returns an <code>ObjectFactory</code> delegate, but under the covers the implementation was creating a <code>Func&lt;...&gt;</code> and then creating an <code>ObjectFactory</code> delegate for that <code>Func&lt;...&gt;</code>‘s <code>Invoke</code> method. The PR changes it to just create the <code>ObjectFactory</code> initially, which means every invocation avoids one layer of delegate invocation.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.DependencyInjection;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet(&#34;Microsoft.Extensions.DependencyInjection.Abstractions&#34;, &#34;9.0.9&#34;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet(&#34;Microsoft.Extensions.DependencyInjection.Abstractions&#34;, &#34;10.0.0-rc.1.25451.107&#34;));

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;NuGetReferences&#34;)]
public partial class Tests
{
    private IServiceProvider _sp = new ServiceCollection().BuildServiceProvider();
    private ObjectFactory _factory = ActivatorUtilities.CreateFactory(typeof(object), Type.EmptyTypes);

    [Benchmark]
    public object CreateInstance() =&gt; _factory(_sp, null);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>CreateInstance</td>
<td>.NET 9.0</td>
<td>8.136 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>CreateInstance</td>
<td>.NET 10.0</td>
<td>6.676 ns</td>
<td>0.82</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/112350">dotnet/runtime#112350</a> reduces some overheads and allocations as part of parsing and rendering <code>TypeName</code>s.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Reflection.Metadata;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;t&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(typeof(Dictionary&lt;List&lt;int[]&gt;[,], List&lt;int?[][][,]&gt;&gt;[]))]
    public string ParseAndGetName(Type t) =&gt; TypeName.Parse(t.FullName).FullName; 
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ParseAndGetName</td>
<td>.NET 9.0</td>
<td>5.930 us</td>
<td>1.00</td>
<td>12.25 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>ParseAndGetName</td>
<td>.NET 10.0</td>
<td>4.305 us</td>
<td>0.73</td>
<td>5.75 KB</td>
<td>0.47</td>
</tr>
</tbody>
</table>
<p>And <a href="https://github.com/dotnet/runtime/pull/113803">dotnet/runtime#113803</a> from <a href="https://github.com/teo-tsirpanis">@teo-tsirpanis</a> improves how <code>DebugDirectoryBuilder</code> in <code>System.Reflection.Metadata</code> uses <code>DeflateStream</code> to embed a PDB. The code was previously buffering the compressed output into an intermediate <code>MemoryStream</code>, and then that <code>MemoryStream</code> was being written to the <code>BlobBuilder</code>. With this change, the <code>DeflateStream</code> is wrapped directly around the <code>BlobBuilder</code>, enabling the compressed data to be propagated directly to <code>builder.WriteBytes</code>.</p>
<h2>Primitives and Numerics</h2>
<p>Every time I write one of these “Performance Improvements in .NET” posts, a part of me thinks “how could there possibly be more next time.” That’s especially true for core data types, which have received so much scrutiny over the years. Yet, here we are, with more to look at for .NET 10.</p>
<p><code>DateTime</code> and <code>DateTimeOffset</code> get some love in <a href="https://github.com/dotnet/runtime/pull/111112">dotnet/runtime#111112</a>, in particular with micro-optimizations around how instances are initialized. Similar tweaks show up in <a href="https://github.com/dotnet/runtime/pull/111244">dotnet/runtime#111244</a> for <code>DateOnly</code>, <code>TimeOnly</code>, and <code>ISOWeek</code>.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private DateTimeOffset _dto = new DateTimeOffset(2025, 9, 10, 0, 0, 0, TimeSpan.Zero);

    [Benchmark]
    public DateTimeOffset GetFutureTime() =&gt; _dto + TimeSpan.FromDays(1);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetFutureTime</td>
<td>.NET 9.0</td>
<td>6.012 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>GetFutureTime</td>
<td>.NET 10.0</td>
<td>1.029 ns</td>
<td>0.17</td>
</tr>
</tbody>
</table>
<p><code>Guid</code> gets several notable performance improvements in .NET 10. <a href="https://github.com/dotnet/runtime/pull/105654">dotnet/runtime#105654</a> from <a href="https://github.com/SirCxyrtyx">@SirCxyrtyx</a> imbues <code>Guid</code> with an implementation of <code>IUtf8SpanParsable</code>. This not only allows <code>Guid</code> to be used in places where a generic parameter is constrained to <code>IUtf8SpanParsable</code>, it gives <code>Guid</code> overloads of <code>Parse</code> and <code>TryParse</code> that operate on UTF8 bytes. This means if you have UTF8 data, you don’t first need to transcode it to UTF16 in order to parse it, nor use <code>Utf8Parser.TryParse</code>, which isn’t as optimized as is <code>Guid.TryParse</code> (but which does enable parsing out a <code>Guid</code> from the beginning of a larger input).</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers.Text;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private byte[] _utf8 = Encoding.UTF8.GetBytes(Guid.NewGuid().ToString(&#34;N&#34;));

    [Benchmark(Baseline = true)]
    public Guid TranscodeParse()
    {
        Span&lt;char&gt; scratch = stackalloc char[64];
        ReadOnlySpan&lt;char&gt; input = Encoding.UTF8.TryGetChars(_utf8, scratch, out int charsWritten) ?
            scratch.Slice(0, charsWritten) :
            Encoding.UTF8.GetString(_utf8);

        return Guid.Parse(input);
    }

    [Benchmark]
    public Guid Utf8ParserParse() =&gt; Utf8Parser.TryParse(_utf8, out Guid result, out _, &#39;N&#39;) ? result : Guid.Empty;

    [Benchmark]
    public Guid GuidParse() =&gt; Guid.Parse(_utf8);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>TranscodeParse</td>
<td>24.72 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Utf8ParserParse</td>
<td>19.34 ns</td>
<td>0.78</td>
</tr>
<tr>
<td>GuidParse</td>
<td>16.47 ns</td>
<td>0.67</td>
</tr>
</tbody>
</table>
<p><code>Char</code>, <code>Rune</code>, and <code>Version</code> also gained <code>IUtf8SpanParsable</code> implementations, in <a href="https://github.com/dotnet/runtime/pull/105773">dotnet/runtime#105773</a> from <a href="https://github.com/lilinus">@lilinus</a> and <a href="https://github.com/dotnet/runtime/pull/109252">dotnet/runtime#109252</a> from <a href="https://github.com/lilinus">@lilinus</a>. There’s not much of a performance benefit here for <code>char</code> and <code>Rune</code>; implementing the interface mainly yields consistency and the ability to use these types with generic routines parameterized based on that interface. But <code>Version</code> gains the same kinds of performance (and usability) benefits as did <code>Guid</code>: it now sports support for parsing directly from UTF8, rather than needing to transcode first to UTF16 and then parse that.</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private byte[] _utf8 = Encoding.UTF8.GetBytes(new Version(&#34;123.456.789.10&#34;).ToString());

    [Benchmark(Baseline = true)]
    public Version TranscodeParse()
    {
        Span&lt;char&gt; scratch = stackalloc char[64];
        ReadOnlySpan&lt;char&gt; input = Encoding.UTF8.TryGetChars(_utf8, scratch, out int charsWritten) ?
            scratch.Slice(0, charsWritten) :
            Encoding.UTF8.GetString(_utf8);

        return Version.Parse(input);
    }

    [Benchmark]
    public Version GuidParse() =&gt; Version.Parse(_utf8);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>TranscodeParse</td>
<td>46.48 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>GuidParse</td>
<td>35.75 ns</td>
<td>0.77</td>
</tr>
</tbody>
</table>
<p>Sometimes performance improvements come about as a side-effect of other work. <a href="https://github.com/dotnet/runtime/pull/110923">dotnet/runtime#110923</a> was intending to remove some pointer use from <code>Guid</code>‘s formatting implementation, but in doing so, it ended up also slightly improving throughput of the (admittedly rarely used) “X” format.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private char[] _dest = new char[64];
    private Guid _g = Guid.NewGuid();

    [Benchmark]
    public void FormatX() =&gt; _g.TryFormat(_dest, out int charsWritten, &#34;X&#34;);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>FormatX</td>
<td>.NET 9.0</td>
<td>3.0584 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>FormatX</td>
<td>.NET 10.0</td>
<td>0.7873 ns</td>
<td>0.26</td>
</tr>
</tbody>
</table>
<p><code>Random</code> (and its cryptographically-secure counterpart <code>RandomNumberGenerator</code>) continues to improve in .NET 10, with new methods (such as <code>Random.GetString</code> and <code>Random.GetHexString</code> from <a href="https://github.com/dotnet/runtime/pull/112162">dotnet/runtime#112162</a>) for usability, but also importantly with performance improvements to existing methods. Both <code>Random</code> and <code>RandomNumberGenerator</code> were given a handy <code>GetItems</code> method in .NET 8; this method allows a caller to supply a set of choices and the number of items desired, allowing <code>Random{NumberGenerator}</code> to perform “sampling with replacement”, selecting an item from the set that number of times. In .NET 9, these implementations were optimized to special-case a power-of-2 number of choices that’s less than or equal to 256. In such a case, we can avoid many trips to the underlying source of randomness by requesting bytes in bulk, rather than requesting an <code>int</code> per element. With the power-of-2 choice count, we can simply mask each byte to produce the index into the choices while not introducing bias. In .NET 10, <a href="https://github.com/dotnet/runtime/pull/107988">dotnet/runtime#107988</a> extends this to apply to non-power-of-2 cases, as well. We can’t just mask off bits as in the power-of-2 case, but we can do “rejection sampling,” which is just a fancy way of saying “if you randomly get a value outside of the allowed range, try again”.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Security.Cryptography;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private const string Base58 = &#34;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#34;;

    [Params(30)]
    public int Length { get; set; }

    [Benchmark]
    public char[] WithRandom() =&gt; Random.Shared.GetItems&lt;char&gt;(Base58, Length);

    [Benchmark]
    public char[] WithRandomNumberGenerator() =&gt; RandomNumberGenerator.GetItems&lt;char&gt;(Base58, Length);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Length</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WithRandom</td>
<td>.NET 9.0</td>
<td>30</td>
<td>144.42 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>WithRandom</td>
<td>.NET 10.0</td>
<td>30</td>
<td>73.68 ns</td>
<td>0.51</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>WithRandomNumberGenerator</td>
<td>.NET 9.0</td>
<td>30</td>
<td>23,179.73 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>WithRandomNumberGenerator</td>
<td>.NET 10.0</td>
<td>30</td>
<td>853.47 ns</td>
<td>0.04</td>
</tr>
</tbody>
</table>
<p><code>decimal</code> operations, specifically multiplication and division, get a performance bump, thanks to <a href="https://github.com/dotnet/runtime/pull/99212">dotnet/runtime#99212</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a>.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private decimal _n = 9.87654321m;
    private decimal _d = 1.23456789m;

    [Benchmark]
    public decimal Divide() =&gt; _n / _d;
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Divide</td>
<td>.NET 9.0</td>
<td>27.09 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Divide</td>
<td>.NET 10.0</td>
<td>23.68 ns</td>
<td>0.87</td>
</tr>
</tbody>
</table>
<p><code>UInt128</code> division similarly gets some assistance in <a href="https://github.com/dotnet/runtime/pull/99747">dotnet/runtime#99747</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a>, utilizing the X86 <code>DivRem</code> hardware intrinsic when dividing a value that’s larger than a <code>ulong</code> by a value that could fit in a <code>ulong</code>.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private UInt128 _n = new UInt128(123, 456);
    private UInt128 _d = new UInt128(0, 789);

    [Benchmark]
    public UInt128 Divide() =&gt; _n / _d;
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Divide</td>
<td>.NET 9.0</td>
<td>27.3112 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Divide</td>
<td>.NET 10.0</td>
<td>0.5522 ns</td>
<td>0.02</td>
</tr>
</tbody>
</table>
<p><code>BigInteger</code> gets a few improvements as well. <a href="https://github.com/dotnet/runtime/pull/115445">dotnet/runtime#115445</a> from <a href="https://github.com/Rob-Hague">@Rob-Hague</a> augments its <code>TryWriteBytes</code> method to use a direct memory copy when viable, namely when the number is non-negative such that it doesn’t need twos-complement tweaks.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Numerics;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private BigInteger _value = BigInteger.Parse(string.Concat(Enumerable.Repeat(&#34;1234567890&#34;, 20)));
    private byte[] _bytes = new byte[256];

    [Benchmark]
    public bool TryWriteBytes() =&gt; _value.TryWriteBytes(_bytes, out _);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>TryWriteBytes</td>
<td>.NET 9.0</td>
<td>27.814 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>TryWriteBytes</td>
<td>.NET 10.0</td>
<td>5.743 ns</td>
<td>0.21</td>
</tr>
</tbody>
</table>
<p>Also rare but fun, if you tried using <code>BigInteger.Parse</code> exactly with the string representation of <code>int.MinValue</code>, you’d end up allocating unnecessarily. That’s addressed by <a href="https://github.com/dotnet/runtime/pull/104666">dotnet/runtime#104666</a> from <a href="https://github.com/kzrnm">@kzrnm</a>, which tweaks the handling of this corner-case so that it’s appropriately recognized as a case that can be represented using a singleton for <code>int.MinValue</code> (the singleton already existed, it just wasn’t applied in this case).</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Numerics;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private string _int32min = int.MinValue.ToString();

    [Benchmark]
    public BigInteger ParseInt32Min() =&gt; BigInteger.Parse(_int32min);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ParseInt32Min</td>
<td>.NET 9.0</td>
<td>80.54 ns</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ParseInt32Min</td>
<td>.NET 10.0</td>
<td>71.59 ns</td>
<td>0.89</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>One area that got a lot of attention in .NET 10 is <code>System.Numerics.Tensors</code>. The <code>System.Numerics.Tensors</code> library was introduced in .NET 8, focusing on a <code>TensorPrimitives</code> class that provided various numerical routines on spans of <code>float</code>. .NET 9 then expanded <code>TensorPrimitives</code> with more operations and generic versions of them. Now in .NET 10, <code>TensorPrimitives</code> gains even more operations, with many of the existing ones also made faster for various scenarios.</p>
<p>To start, <a href="https://github.com/dotnet/runtime/pull/112933">dotnet/runtime#112933</a> adds over 70 new overloads to <code>TensorPrimitives</code>, including operations like <code>StdDev</code>, <code>Average</code>, <code>Clamp</code>, <code>DivRem</code>, <code>IsNaN</code>, <code>IsPow2</code>, <code>Remainder</code>, and many more. The majority of these operations are also vectorized, using shared implementations that are parameterized with generic operators. For example, the entirety of the <code>Decrement&lt;T&gt;</code> implementation is:</p>
<pre><code>public static void Decrement&lt;T&gt;(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : IDecrementOperators&lt;T&gt; =&gt;
    InvokeSpanIntoSpan&lt;T, DecrementOperator&lt;T&gt;&gt;(x, destination);</code></pre>
<p>where <code>InvokeSpanIntoSpan</code> is a shared routine used by almost 60 methods, each of which supplies its own operator that’s then used in the heavily-optimized routine. In this case, the <code>DecrementOperator&lt;T&gt;</code> is simply this:</p>
<pre><code>private readonly struct DecrementOperator&lt;T&gt; : IUnaryOperator&lt;T, T&gt; where T : IDecrementOperators&lt;T&gt;
{
    public static bool Vectorizable =&gt; true;
    public static T Invoke(T x) =&gt; --x;
    public static Vector128&lt;T&gt; Invoke(Vector128&lt;T&gt; x) =&gt; x - Vector128&lt;T&gt;.One;
    public static Vector256&lt;T&gt; Invoke(Vector256&lt;T&gt; x) =&gt; x - Vector256&lt;T&gt;.One;
    public static Vector512&lt;T&gt; Invoke(Vector512&lt;T&gt; x) =&gt; x - Vector512&lt;T&gt;.One;
}</code></pre>
<p>With that minimal implementation, which provides a decrement implementation for vectorized widths of 128 bits, 256 bits, 512 bits, and scalar, the workhorse routine is able to provide a very efficient implementation.</p>
<pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors.
// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Numerics.Tensors;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private float[] _src = Enumerable.Range(0, 1000).Select(i =&gt; (float)i).ToArray();
    private float[] _dest = new float[1000];

    [Benchmark(Baseline = true)]
    public void DecrementManual()
    {
        ReadOnlySpan&lt;float&gt; src = _src;
        Span&lt;float&gt; dest = _dest;
        for (int i = 0; i &lt; src.Length; i++)
        {
            dest[i] = src[i] - 1f;
        }
    }

    [Benchmark]
    public void DecrementTP() =&gt; TensorPrimitives.Decrement(_src, _dest);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>DecrementManual</td>
<td>288.80 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>DecrementTP</td>
<td>22.46 ns</td>
<td>0.08</td>
</tr>
</tbody>
</table>
<p>Wherever possible, these methods also utilize APIs on the underlying <code>Vector128</code>, <code>Vector256</code>, and <code>Vector512</code> types, including new corresponding methods introduced in <a href="https://github.com/dotnet/runtime/pull/111179">dotnet/runtime#111179</a> and <a href="https://github.com/dotnet/runtime/pull/115525">dotnet/runtime#115525</a>, such as <code>IsNaN</code>.</p>
<p>Existing methods are also improved. <a href="https://github.com/dotnet/runtime/pull/111615">dotnet/runtime#111615</a> from <a href="https://github.com/BarionLP">@BarionLP</a> improves <code>TensorPrimitives.SoftMax</code> by avoiding unnecessary recomputation of <code>T.Exp</code>. The softmax function involves computing <code>exp</code> for every element and summing them all together. The output for an element with value <code>x</code> is then the <code>exp(x)</code> divided by that sum. The previous implementation was following that outline, resulting in computing <code>exp</code> twice for each element. We can instead compute <code>exp</code> just once for each element, caching them temporarily in the destination while creating the sum, and then reusing those for the subsequent division, overwriting each with the actual result. The net result is close to doubling the throughput:</p>
<pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors.
// dotnet run -c Release -f net9.0 --filter **

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using System.Numerics.Tensors;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;9.0.9&#34;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;10.0.0-rc.1.25451.107&#34;));

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;NuGetReferences&#34;)]
public partial class Tests
{
    private float[] _src, _dst;

    [GlobalSetup]
    public void Setup()
    {
        Random r = new(42);
        _src = Enumerable.Range(0, 1000).Select(_ =&gt; r.NextSingle()).ToArray();
        _dst = new float[_src.Length];
    }

    [Benchmark]
    public void SoftMax() =&gt; TensorPrimitives.SoftMax(_src, _dst);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>SoftMax</td>
<td>.NET 9.0</td>
<td>1,047.9 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>SoftMax</td>
<td>.NET 10.0</td>
<td>649.8 ns</td>
<td>0.62</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/111505">dotnet/runtime#111505</a> from <a href="https://github.com/alexcovington">@alexcovington</a> enables <code>TensorPrimitives.Divide&lt;T&gt;</code> to be vectorized for <code>int</code>. The operation already supported vectorization for <code>float</code> and <code>double</code>, for which there’s SIMD hardware-accelerated support for division, but it didn’t support <code>int</code>, which lacks SIMD hardware-accelerated support. This PR teaches the JIT how to emulate SIMD integer division, by converting the <code>int</code>s to <code>double</code>s, doing <code>double</code> division, and then converting back.</p>
<pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors.
// dotnet run -c Release -f net9.0 --filter **

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using System.Numerics.Tensors;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;9.0.9&#34;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;10.0.0-rc.1.25451.107&#34;));

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;NuGetReferences&#34;)]
public partial class Tests
{
    private int[] _n, _d, _dst;

    [GlobalSetup]
    public void Setup()
    {
        Random r = new(42);
        _n = Enumerable.Range(0, 1000).Select(_ =&gt; r.Next(1000, int.MaxValue)).ToArray();
        _d = Enumerable.Range(0, 1000).Select(_ =&gt; r.Next(1, 1000)).ToArray();
        _dst = new int[_n.Length];
    }

    [Benchmark]
    public void Divide() =&gt; TensorPrimitives.Divide(_n, _d, _dst);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Divide</td>
<td>.NET 9.0</td>
<td>1,293.9 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Divide</td>
<td>.NET 10.0</td>
<td>458.4 ns</td>
<td>0.35</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/116945">dotnet/runtime#116945</a> further updates <code>TensorPrimitives.Divide</code> (as well as <code>TensorPrimitives.Sign</code> and <code>TensorPrimitives.ConvertToInteger</code>) to be vectorizable when used with <code>nint</code> or <code>nuint</code>. <code>nint</code> can be treated identically to <code>int</code> when in a 32-bit process and to <code>long</code> when in a 64-bit process; same for <code>nuint</code> with <code>uint</code> and <code>ulong</code>, respectively. So anywhere we’re successfully vectorizing for <code>int</code>/<code>uint</code> on 32-bit or <code>long</code>/<code>ulong</code> on 64-bit, we can also successfully vectorize for <code>nint</code>/<code>nuint</code>. <a href="https://github.com/dotnet/runtime/pull/116895">dotnet/runtime#116895</a> also enables vectorizing <code>TensorPrimitives.ConvertTruncating</code> when used to convert <code>float</code> to <code>int</code> or <code>uint</code> and <code>double</code> to <code>long</code> or <code>ulong</code>. Vectorization hadn’t previously been enabled because the underlying operations used had some undefined behavior; that behavior was fixed late in the .NET 9 cycle, such that this vectorization can now be enabled.</p>
<pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors.
// dotnet run -c Release -f net9.0 --filter **

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using System.Numerics.Tensors;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;9.0.9&#34;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;10.0.0-rc.1.25451.107&#34;));

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;NuGetReferences&#34;)]
public partial class Tests
{
    private float[] _src;
    private int[] _dst;

    [GlobalSetup]
    public void Setup()
    {
        Random r = new(42);
        _src = Enumerable.Range(0, 1000).Select(_ =&gt; r.NextSingle() * 1000).ToArray();
        _dst = new int[_src.Length];
    }

    [Benchmark]
    public void ConvertTruncating() =&gt; TensorPrimitives.ConvertTruncating(_src, _dst);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConvertTruncating</td>
<td>.NET 9.0</td>
<td>933.86 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>ConvertTruncating</td>
<td>.NET 10.0</td>
<td>41.99 ns</td>
<td>0.04</td>
</tr>
</tbody>
</table>
<p>Not to be left out, <code>TensorPrimitives.LeadingZeroCount</code> is also improved in <a href="https://github.com/dotnet/runtime/pull/110333">dotnet/runtime#110333</a> from <a href="https://github.com/alexcovington">@alexcovington</a>. When AVX512 is available, the change utilizes AVX512 instructions like <code>PermuteVar16x8x2</code> to vectorize <code>LeadingZeroCount</code> for all types supported by <code>Vector512&lt;T&gt;</code>.</p>
<pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors.
// dotnet run -c Release -f net9.0 --filter **

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using System.Numerics.Tensors;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;9.0.9&#34;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;10.0.0-rc.1.25451.107&#34;));

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;NuGetReferences&#34;)]
public partial class Tests
{
    private byte[] _src, _dst;

    [GlobalSetup]
    public void Setup()
    {
        _src = new byte[1000];
        _dst = new byte[_src.Length];
        new Random(42).NextBytes(_src);
    }

    [Benchmark]
    public void LeadingZeroCount() =&gt; TensorPrimitives.LeadingZeroCount(_src, _dst);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>LeadingZeroCount</td>
<td>.NET 9.0</td>
<td>401.60 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>LeadingZeroCount</td>
<td>.NET 10.0</td>
<td>12.33 ns</td>
<td>0.03</td>
</tr>
</tbody>
</table>
<p>In terms of changes that affected the most operations, <a href="https://github.com/dotnet/runtime/pull/116898">dotnet/runtime#116898</a> and <a href="https://github.com/dotnet/runtime/pull/116934">dotnet/runtime#116934</a> take the cake. Together, these PRs extend vectorization for almost 60 distinct operations to also accelerate for <code>Half</code>: <code>Abs</code>, <code>Add</code>, <code>AddMultiply</code>, <code>BitwiseAnd</code>, <code>BitwiseOr</code>, <code>Ceiling</code>, <code>Clamp</code>, <code>CopySign</code>, <code>Cos</code>, <code>CosPi</code>, <code>Cosh</code>, <code>CosineSimilarity</code>, <code>Decrement</code>, <code>DegreesToRadians</code>, <code>Divide</code>, <code>Exp</code>, <code>Exp10</code>, <code>Exp10M1</code>, <code>Exp2</code>, <code>Exp2M1</code>, <code>ExpM1</code>, <code>Floor</code>, <code>FusedAddMultiply</code>, <code>Hypot</code>, <code>Increment</code>, <code>Lerp</code>, <code>Log</code>, <code>Log10</code>, <code>Log10P1</code>, <code>Log2</code>, <code>Log2P1</code>, <code>LogP1</code>, <code>Max</code>, <code>MaxMagnitude</code>, <code>MaxMagnitudeNumber</code>, <code>MaxNumber</code>, <code>Min</code>, <code>MinMagnitude</code>, <code>MinMagnitudeNumber</code>, <code>MinNumber</code>, <code>Multiply</code>, <code>MultiplyAdd</code>, <code>MultiplyAddEstimate</code>, <code>Negate</code>, <code>OnesComplement</code>, <code>Reciprocal</code>, <code>Remainder</code>, <code>Round</code>, <code>Sigmoid</code>, <code>Sin</code>, <code>SinPi</code>, <code>Sinh</code>, <code>Sqrt</code>, <code>Subtract</code>, <code>Tan</code>, <code>TanPi</code>, <code>Tanh</code>, <code>Truncate</code>, and <code>Xor</code>. The challenge here is that <code>Half</code> doesn’t have accelerated hardware support, and today is not even supported by the vector types. In fact, even for its scalar operations, <code>Half</code> is manipulated internally by converting it to a <code>float</code>, performing the relevant operation as <code>float</code>, and then casting back, e.g. here’s the implementation of the <code>Half</code> multiplication operator:</p>
<pre><code>public static Half operator *(Half left, Half right) =&gt; (Half)((float)left * (float)right);</code></pre>
<p>For all of these <code>TensorPrimitives</code> operations, they previously would treat <code>Half</code> like any other unaccelerated type, and would just run a scalar loop that performed the operation on each <code>Half</code>. That means for each element, we’re converting it to <code>float</code>, then performing the operation, and then converting it back. As luck would have it, though, <code>TensorPrimitives</code> already defines the <code>ConvertToSingle</code> and <code>ConvertToHalf</code> methods, which are accelerated. We can then reuse those methods to do the same thing that’s already done for scalar operations but do it vectorized: take a vector of <code>Half</code>s, convert them all to <code>float</code>s, process all the <code>float</code>s, and convert them all back to <code>Half</code>s. Of course, I already stated that the vector types don’t support <code>Half</code>, so how can we “take a vector of <code>Half</code>“? By reinterpret casting the <code>Span&lt;Half&gt;</code> to <code>Span&lt;short&gt;</code> (or <code>Span&lt;ushort&gt;</code>), which allows us to smuggle the <code>Half</code>s through. And, as it turns out, even for scalar, the very first thing <code>Half</code>‘s <code>float</code> cast operator does is convert it to a <code>short</code>.</p>
<p>The net result is that a ton of operations can now be accelerated for <code>Half</code>.</p>
<pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors.
// dotnet run -c Release -f net9.0 --filter **

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using System.Numerics.Tensors;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;9.0.9&#34;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet(&#34;System.Numerics.Tensors&#34;, &#34;10.0.0-rc.1.25451.107&#34;));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;NuGetReferences&#34;)]
public partial class Tests
{
    private Half[] _x, _y, _dest;

    [GlobalSetup]
    public void Setup()
    {
        _x = new Half[1000];
        _y = new Half[_x.Length];
        _dest = new Half[_x.Length];
        var random = new Random(42);
        for (int i = 0; i &lt; _x.Length; i++)
        {
            _x[i] = (Half)random.NextSingle();
            _y[i] = (Half)random.NextSingle();
        }
    }

    [Benchmark]
    public void Add() =&gt; TensorPrimitives.Add(_x, _y, _dest);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add</td>
<td>.NET 9.0</td>
<td>5,984.3 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Add</td>
<td>.NET 10.0</td>
<td>481.7 ns</td>
<td>0.08</td>
</tr>
</tbody>
</table>
<p>The <code>System.Numerics.Tensors</code> library in .NET 10 now also includes stable APIs for tensor types (which use <code>TensorPrimitives</code> in their implementations). This includes a <code>Tensor&lt;T&gt;</code>, <code>ITensor&lt;,&gt;</code>, <code>TensorSpan&lt;T&gt;</code>, and <code>ReadOnlyTensorSpan&lt;T&gt;</code>. One of the really interesting things about these types is that they take advantage of the new C# 14 compound operators feature, and do so for a significant performance benefit. In previous versions of C#, you’re able to write custom operators, for example an addition operator:</p>
<pre><code>public class C 
{
    public int Value;

    public static C operator +(C left, C right) =&gt; new() { Value = left.Value + right.Value };
}</code></pre>
<p>With that type, I can write code like:</p>
<pre><code>C a = new() { Value = 42 };
C b = new() { Value = 84 };
C c = a + b;

Console.WriteLine(c.Value);</code></pre>
<p>which will print out <code>126</code>. I can also change the code to use a compound operator, <code>+=</code>, like this:</p>
<pre><code>C a = new() { Value = 42 };
C b = new() { Value = 84 };
a += b;

Console.WriteLine(a.Value);</code></pre>
<p>which will also print out <code>126</code>, because the <code>a += b</code> is always identical to <code>a = a + b</code>… or, at least it was. Now with C# 14, it’s possible for a type to not only define a <code>+</code> operator, it can also define a <code>+=</code> operator. If a type defines a <code>+=</code> operator, it will be used rather than expanding <code>a += b</code> as shorthand for <code>a = a + b</code>. And that has performance ramifications.</p>
<p>A tensor is basically a multidimensional array, and as with arrays, these can be big… really big. If I have a sequence of operations:</p>
<pre><code>Tensor&lt;int&gt; t1 = ...;
Tensor&lt;int&gt; t2 = ...;
for (int i = 0; i &lt; 3; i++)
{
    t1 += t2;
}</code></pre>
<p>and each of those <code>t1 += t2</code>s exands into <code>t1 = t1 + t2</code>, then for each I’m allocating a brand new tensor. If they’re big, that gets expensive right quick. But C# 14’s new user-defined compound operators, as initially added to the compiler in <a href="https://github.com/dotnet/roslyn/pull/78400">dotnet/roslyn#78400</a>, enable mutation of the target.</p>
<pre><code>public class C 
{
    public int Value;

    public static C operator +(C left, C right) =&gt; new() { Value = left.Value + right.Value };
    public static void operator +=(C other) =&gt; left.Value += other.Value;
}</code></pre>
<p>And that means that such compound operators on the tensor types can just update the target tensor in place rather than allocating a whole new (possibly very large) data structure for each computation. <a href="https://github.com/dotnet/runtime/pull/117997">dotnet/runtime#117997</a> adds all of these compound operators for the tensor types. (Not only are these using C# 14 user-defined compound operators, they’re doing so as extension operators, using the new C# 14 extension types feature. Fun!)</p>
<h2>Collections</h2>
<p>Handling collections of data is the lifeblood of any application, and as such every .NET release tries to eke out even more performance from collections and collection processing.</p>
<h3>Enumeration</h3>
<p>Iterating through collections is one of the most common things developers do. To make this as efficient as possible, the most prominent collection types in .NET (e.g. <code>List&lt;T&gt;</code>) expose struct-based enumerators (e.g. <code>List&lt;T&gt;.Enumerator</code>) which their public <code>GetEnumerator()</code> methods then return in a strongly-typed manner:</p>
<pre><code>public Enumerator GetEnumerator() =&gt; new Enumerator(this);</code></pre>
<p>This is in addition to their <code>IEnumerable&lt;T&gt;.GetEnumerator()</code> implementation, which ends up being implemented via an “explicit” interface implementation (“explicit” means the relevant method provides the interface method implementation but does not show up as a public method on the type itself), e.g. <code>List&lt;T&gt;</code>‘s implementation:</p>
<pre><code>IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator() =&gt;
    Count == 0 ? SZGenericArrayEnumerator&lt;T&gt;.Empty :
    GetEnumerator();</code></pre>
<p>Directly <code>foreach</code>‘ing over the collection allows the C# compiler to bind to the struct-based enumerator, enabling avoiding the enumerator allocation and being able to directly see the non-virtual methods on the enumerator, rather than working with an <code>IEnumerator&lt;T&gt;</code> and the interface dispatch required to invoke methods on it. That, however, falls apart once the collection is used polymorphically as an <code>IEnumerable&lt;T&gt;</code>; at that point, the <code>IEnumerable&lt;T&gt;.GetEnumerator()</code> is used, which is forced to allocate a new enumerator instance (except for special-cases, such as how <code>List&lt;T&gt;</code>‘s implementation shown above returns a singleton enumerator when the collection is empty).</p>
<p>Thankfully, as noted earlier in the JIT section, the JIT has been gaining super powers around dynamic PGO, escape analysis, and stack allocation. This means that in many situations, the JIT is now able to see that the most common concrete type for a given call site is a specific enumerator type and generate code specific to when it is that type, devirtualizing the calls, possibly inlining them, and then, if it’s able to do so sufficiently, stack allocating the enumerator. With the progress that’s been made in .NET 10, this now happens very frequently for arrays and <code>List&lt;T&gt;</code>. While the JIT is able to do this in general regardless of an object’s type, the ubiquity of enumeration makes it all that much more important for <code>IEnumerator&lt;T&gt;</code>, so <a href="https://github.com/dotnet/runtime/pull/116978">dotnet/runtime#116978</a> marks <code>IEnumerator&lt;T&gt;</code> as an <code>[Intrinsic]</code>, giving the JIT the ability to better reason about it.</p>
<p>However, some enumerators still needed a bit of help. Besides <code>T[]</code>, <code>List&lt;T&gt;</code> is the most popular collection type in .NET, and with the JIT changes, many <code>foreach</code>s of an <code>IEnumerable&lt;T&gt;</code> that are actually <code>List&lt;T&gt;</code> will successfully have the enumerator stack allocated. Awesome. That awesomeness dwindled, however, when trying out different sized lists. This is a benchmark that tests out enumerating a <code>List&lt;T&gt;</code> typed as <code>IEnumerable&lt;T&gt;</code>, with different lengths, along with benchmark results from early August 2025 (around .NET 10 Preview 7).</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter **

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private IEnumerable&lt;int&gt; _enumerable;

    [Params(500, 5000, 15000)]
    public int Count { get; set; }

    [GlobalSetup]
    public void Setup() =&gt; _enumerable = Enumerable.Range(0, Count).ToList();

    [Benchmark]
    public int Sum()
    {
        int sum = 0;
        foreach (int item in _enumerable) sum += item;
        return sum;
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Count</th>
<th>Mean</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>500</td>
<td>214.1 ns</td>
<td>–</td>
</tr>
<tr>
<td>Sum</td>
<td>5000</td>
<td>4,767.1 ns</td>
<td>40 B</td>
</tr>
<tr>
<td>Sum</td>
<td>15000</td>
<td>13,824.4 ns</td>
<td>40 B</td>
</tr>
</tbody>
</table>
<p>Note that for the <code>500</code> element <code>List&lt;T&gt;</code>, the allocation column shows that nothing was allocated on the heap, as the enumerator was successfully stack allocated. Fabulous. But then just increasing the size of the list caused it to no longer be stack-allocated. Why? The reason for the allocation in the jump from <code>500</code> to <code>5000</code> has to do with dynamic PGO combined with how <code>List&lt;T&gt;</code>‘s enumerator was written oh so many years ago.</p>
<p><code>List&lt;T&gt;</code>‘s enumerator’s <code>MoveNext</code> was structured like this:</p>
<pre><code>public bool MoveNext()
{
    if (_version == _list._version &amp;&amp; ((uint)_index &lt; (uint)_list._size))
    {
        ... // handle successfully getting next element
        return true;
    }

    return MoveNextRare();
}

private bool MoveNextRare()
{
    ... // handle version mismatch and/or returning false for completed enumeration
}</code></pre>
<p>The <code>Rare</code> in the name gives a hint as to why it’s split like this. The <code>MoveNext</code> method was kept as thin as possible for the common case of invoking <code>MoveNext</code>, namely all successful calls that return <code>true</code>; the only time <code>MoveNextRare</code> is needed, other than when the enumerator is misused, is for the final call to it after all elements have been yielded. That streamlining of <code>MoveNext</code> itself was done to make <code>MoveNext</code> inlineable. However, a lot has changed since this code was written, making it less important, and the separating out of <code>MoveNextRare</code> has a really interesting interaction with dynamic PGO. One of the things dynamic PGO looks for is whether code is considered hot (used a lot) or cold (used rarely), and that data influences whether a method should be considered for inlining. For shorter lists, dynamic PGO will see <code>MoveNextRare</code> invoked a reasonable number of times, and will consider it for inlining. And if all of the calls to the enumerator are inlined, the enumerator instance can avoid escaping the call frame, and can then be stack allocated. But once the list length grows to a much larger amount, that <code>MoveNextRare</code> method will start to look really cold, will struggle to be inlined, and will then allow the enumerator instance to escape, preventing it from being stack allocated. <a href="https://github.com/dotnet/runtime/pull/118425">dotnet/runtime#118425</a> recognizes that times have changed since this enumerator was written, with many changes to inlining heuristics and PGO and the like; it undoes the separating out of <code>MoveNextRare</code> and simplifies the enumerator. With how the system works today, the re-combined <code>MoveNext</code> is still inlineable, with or without PGO, and we’re able to stack allocate at the larger size.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Count</th>
<th>Mean</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>500</td>
<td>221.2 ns</td>
<td>–</td>
</tr>
<tr>
<td>Sum</td>
<td>5000</td>
<td>2,153.6 ns</td>
<td>–</td>
</tr>
<tr>
<td>Sum</td>
<td>15000</td>
<td>14,724.9 ns</td>
<td>40 B</td>
</tr>
</tbody>
</table>
<p>With that fix, we still had an issue, though. We’re now avoiding the allocation at lengths 500 and 5000, but at 15,000 we still see the enumerator being allocated. Now why? This has to do with <a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/#on-stack-replacement">OSR (on-stack replacement)</a>, which was introduced in .NET 7 as a key enabler for allowing tiered compilation to be used with methods containing loops. OSR allows for a method to be recompiled with optimizations even while it’s executing, and for an invocation of the method to jump from the unoptimized code for the method to the corresponding location in the newly optimized method. While OSR is awesome, it unfortunately causes some complications here. Once the list gets long enough, an invocation of the tier 0 (unoptimized) method will transition to the OSR optimized method… but OSR methods don’t contain dynamic PGO instrumentation (they used to, but it was removed because it led to problems if the instrumented code never got recompiled again and thus suffered regressions due to forever-more running with the instrumentation probes in place). Without the instrumentation, and in particular without the instrumentation for the tail portion of the method (where the enumerator’s <code>Dispose</code> method is invoked), even though <code>List&lt;T&gt;.Dispose</code> is a nop, the JIT may not be able to do the guarded devirtualization that enables the <code>IEnumerator&lt;T&gt;.Dispose</code> to be devirtualized and inlined. Meaning, ironically, that the nop <code>Dispose</code> causes escape analysis to see the enumerator instance escape, such that it can’t be stack allocated. Whew.</p>
<p>Thankfully, <a href="https://github.com/dotnet/runtime/pull/118461">dotnet/runtime#118461</a> addresses that in the JIT. Specifically for enumerators, this PR enables dynamic PGO to infer the missing instrumentation based on the earlier probes used with the other enumerator methods, which then enables it to successfully devirtualize and inline <code>Dispose</code>. So, for .NET 10, and the same benchmark, we end up with this lovely sight:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Count</th>
<th>Mean</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sum</td>
<td>500</td>
<td>216.5 ns</td>
<td>–</td>
</tr>
<tr>
<td>Sum</td>
<td>5000</td>
<td>2,082.4 ns</td>
<td>–</td>
</tr>
<tr>
<td>Sum</td>
<td>15000</td>
<td>6,525.3 ns</td>
<td>–</td>
</tr>
</tbody>
</table>
<p>Other types needed a bit of help as well. <a href="https://github.com/dotnet/runtime/pull/118467">dotnet/runtime#118467</a> addresses <code>PriorityQueue&lt;TElement, TPriority&gt;</code>‘s enumerator; it’s enumerator was a port of <code>List&lt;T&gt;</code>‘s and so was changed similarly.</p>
<p>Separately, <a href="https://github.com/dotnet/runtime/pull/117328">dotnet/runtime#117328</a> streamline’s <code>Stack&lt;T&gt;</code>‘s enumerator type, removing around half the lines of code that previously composed it. The previous enumerator’s <code>MoveNext</code> incurred five branches on the way to grabbing most next elements:</p>
<ul>
<li>It first did a version check, comparing the stack’s version number against the enumerator’s captured version number, to ensure the stack hadn’t been mutated since the time the enumerator was grabbed.</li>
<li>It then checked to see whether this was the first call to the enumerator, taking one path that lazily-initialized some state if it was and another path assuming already-initialized state if not.</li>
<li>Assuming this wasn’t the first call, it then checked whether enumeration had previously ended.</li>
<li>Assuming it hadn’t, it then checked whether there’s anything left to enumerate.</li>
<li>And finally, it dereferenced the underlying array, incurring a bounds check.</li>
</ul>
<p>The new implementation cuts that in half. It relies on the enumerator’s constructor initializing the current index to the length of the stack, such that each <code>MoveNext</code> call just decrements this value. When the data is exhausted, the count will go negative. This means that we can combine a whole bunch of these checks into a single check:</p>
<pre><code>if ((uint)index &lt; (uint)array.Length)</code></pre>
<p>and we’re left with just two branches on the way to reading any element: the version check and whether the index is in bounds. That reduction not only means there’s less code to process and fewer branches that might be improperly predicted, it also shrinks the size of the members to the point where they’re much more likely to be inlined, which in turns makes it much more likely that the enumerator object can be stack allocated.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private Stack&lt;int&gt; _direct = new Stack&lt;int&gt;(Enumerable.Range(0, 10));
    private IEnumerable&lt;int&gt; _enumerable = new Stack&lt;int&gt;(Enumerable.Range(0, 10));

    [Benchmark]
    public int SumDirect()
    {
        int sum = 0;
        foreach (int item in _direct) sum += item;
        return sum;
    }

    [Benchmark]
    public int SumEnumerable()
    {
        int sum = 0;
        foreach (int item in _enumerable) sum += item;
        return sum;
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>SumDirect</td>
<td>.NET 9.0</td>
<td>23.317 ns</td>
<td>1.00</td>
<td>331 B</td>
<td>–</td>
<td>NA</td>
</tr>
<tr>
<td>SumDirect</td>
<td>.NET 10.0</td>
<td>4.502 ns</td>
<td>0.19</td>
<td>55 B</td>
<td>–</td>
<td>NA</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SumEnumerable</td>
<td>.NET 9.0</td>
<td>30.893 ns</td>
<td>1.00</td>
<td>642 B</td>
<td>40 B</td>
<td>1.00</td>
</tr>
<tr>
<td>SumEnumerable</td>
<td>.NET 10.0</td>
<td>7.906 ns</td>
<td>0.26</td>
<td>381 B</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/117341">dotnet/runtime#117341</a> does something similar but for <code>Queue&lt;T&gt;</code>. <code>Queue&lt;T&gt;</code> has an interesting complication when compared to <code>Stack&lt;T&gt;</code>, which is that it can wrap around the length of the underlying array. Whereas with <code>Stack&lt;T&gt;</code>, we can always start at a particular index and just count down to 0, using that index as the offset into the array, with <code>Queue&lt;T&gt;</code>, the starting index can be anywhere in the array, and when walking from that index to the last element, we might need to wrap around back to the beginning. Such wrapping can be accomplished using <code>% array.Length</code> (which is what <code>Queue&lt;T&gt;</code> does on .NET Framework), but such a division operation can be relatively costly. An alternative, since we know the count can never be more than the array’s length, is to check whether we’ve already walked past the end of the array, and if we have, then subtract the array’s length to get to the corresponding location from the start of the array. The existing implementation in .NET 9 did just that:</p>
<pre><code>if (index &gt;= array.Length)
{
    index -= array.Length; // wrap around if needed
}

_currentElement = array[index];</code></pre>
<p>That is two branches, one for the check against the array length, and one for the bounds check. The bounds check can’t be eliminated here because the JIT hasn’t seen proof that the index is actually in-bounds and thus needs to be defensive. Instead, we can write it like this:</p>
<pre><code>if ((uint)index &lt; (uint)array.Length)
{
    _currentElement = array[index];
}
else
{
    index -= array.Length;
    _currentElement = array[index];
}</code></pre>
<p>An enumeration of a queue can logically be split into two parts: the elements from the head index to the end of the array, and the elements from the beginning of the array to the tail. All of the former now fall into the first block, which incurs only one branch because the JIT can use the knowledge gleaned from the comparison to eliminate the bounds check. It only incurs a bounds check when in the second portion of the enumeration.</p>
<p>We can more easily visualize the branch savings by using benchmarkdotnet’s <code>HardwareCounters</code> diagnoser, asking it to track <code>HardwareCounter.BranchInstructions</code> (this diagnoser only works on Windows). Note here, as well, that the changes not only improve throughput, they also enable the boxed enumerator to be stack allocated.</p>
<pre><code>// This benchmark was run on Windows for the HardwareCounters diagnoser to work.
// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Diagnosers;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HardwareCounters(HardwareCounter.BranchInstructions)]
[MemoryDiagnoser(displayGenColumns: false)]
[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private Queue&lt;int&gt; _direct;
    private IEnumerable&lt;int&gt; _enumerable;

    [GlobalSetup]
    public void Setup()
    {
        _direct = new Queue&lt;int&gt;(Enumerable.Range(0, 10));
        for (int i = 0; i &lt; 5; i++)
        {
            _direct.Enqueue(_direct.Dequeue());
        }

        _enumerable = _direct;
    }

    [Benchmark]
    public int SumDirect()
    {
        int sum = 0;
        foreach (int item in _direct) sum += item;
        return sum;
    }

    [Benchmark]
    public int SumEnumerable()
    {
        int sum = 0;
        foreach (int item in _enumerable) sum += item;
        return sum;
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>BranchInstructions/Op</th>
<th>Code Size</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>SumDirect</td>
<td>.NET 9.0</td>
<td>24.340 ns</td>
<td>1.00</td>
<td>79</td>
<td>251 B</td>
<td>–</td>
<td>NA</td>
</tr>
<tr>
<td>SumDirect</td>
<td>.NET 10.0</td>
<td>7.192 ns</td>
<td>0.30</td>
<td>37</td>
<td>96 B</td>
<td>–</td>
<td>NA</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SumEnumerable</td>
<td>.NET 9.0</td>
<td>30.695 ns</td>
<td>1.00</td>
<td>103</td>
<td>531 B</td>
<td>40 B</td>
<td>1.00</td>
</tr>
<tr>
<td>SumEnumerable</td>
<td>.NET 10.0</td>
<td>8.672 ns</td>
<td>0.28</td>
<td>50</td>
<td>324 B</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p><code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> also gets in on the fun. The dictionary is implemented as a collection of “buckets”, each of which of which is a linked list of entries. It had a fairly complicated enumerator for processing these structures, relying on jumping between cases of a switch statement, e.g.</p>
<pre><code>switch (_state)
{
    case StateUninitialized:
        ... // Initialize on first MoveNext.
        goto case StateOuterloop;

    case StateOuterloop:
        // Check if there are more buckets in the dictionary to enumerate.
        if ((uint)i &lt; (uint)buckets.Length)
        {
            // Move to the next bucket.
            ...
            goto case StateInnerLoop;
        }
        goto default;

    case StateInnerLoop:
        ... // Yield elements from the current bucket.
        goto case StateOuterloop;

    default:
        // Done iterating.
        ...
}</code></pre>
<p>If you squint, there are nested loops here, where we’re enumerating each bucket and for each bucket enumerating its contents. With how this is structured, however, from the JIT’s perspective, we could enter those loops from any of those <code>case</code>s, depending on the current value of <code>_state</code>. That produces something referred to as an “irreducible loop,” which is a loop that has multiple possible entry points. Imagine you have:</p>
<pre><code>A:
if (someCondition) goto B;
...

B:
if (someOtherCondition) goto A;</code></pre>
<p>Labels <code>A</code> and <code>B</code> form a loop, but that loop can be entered by jumping to either <code>A</code> or to <code>B</code>. If the compiler could prove that this loop were only ever enterable from <code>A</code> or only ever enterable from <code>B</code>, then the loop would be “reducible.” Irreducible loops are much more complex than reducible loops for a compiler to deal with, as they have more complex control and data flow and in general are harder to analyze. <a href="https://github.com/dotnet/runtime/pull/116949">dotnet/runtime#116949</a> rewrites the <code>MoveNext</code> method to be a more typical <code>while</code> loop, which is not only easier to read and maintain, it’s also reducible and more efficient, and because it’s more streamlined, it’s also inlineable and enables possible stack allocation.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Concurrent;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private ConcurrentDictionary&lt;int, int&gt; _ints = new(Enumerable.Range(0, 1000).ToDictionary(i =&gt; i, i =&gt; i));

    [Benchmark]
    public int EnumerateInts()
    {
        int sum = 0;
        foreach (var kvp in _ints) sum += kvp.Value;
        return sum;
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>EnumerateInts</td>
<td>.NET 9.0</td>
<td>4,232.8 ns</td>
<td>1.00</td>
<td>56 B</td>
<td>1.00</td>
</tr>
<tr>
<td>EnumerateInts</td>
<td>.NET 10.0</td>
<td>664.2 ns</td>
<td>0.16</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<h3>LINQ</h3>
<p>All of these examples show enumerating collections using a <code>foreach</code> loop, and while that’s obviously incredibly common, so too is using LINQ (Language Integrated Query) to enumerate and process collections. For in-memory collections, LINQ provides literally hundreds of extension methods for performing maps, filters, sorts, and a plethora of other operations over enumerables. It is incredibly handy, is thus used <em>everywhere</em>, and is thus important to optimize. Every release of .NET has seen improvements to LINQ, and that continues in .NET 10.</p>
<p>Most prominent from a performance perspective in this release are the changes to <code>Contains</code>. As discussed in depth in <a href="https://www.youtube.com/watch?v=xKr96nIyCFM">Deep .NET: Deep Dive on LINQ with Stephen Toub and Scott Hanselman</a> and <a href="https://www.youtube.com/watch?v=W4-NVVNwCWs">Deep .NET: An even DEEPER Dive into LINQ with Stephen Toub and Scott Hanselman</a>, the LINQ methods are able to pass information between them by using specialized internal <code>IEnumerable&lt;T&gt;</code> implementations. When you call <code>Select</code>, that might return an <code>ArraySelectIterator&lt;TSource, TResult&gt;</code> or an <code>IListSelectIterator&lt;TSource, TResult&gt;</code> or an <code>IListSkipTakeSelectIterator&lt;TSource, TResult&gt;</code> or one of any number of other types. Each of these types has fields that carry information about the source (e.g. the <code>IListSkipTakeSelectIterator&lt;TSource, TResult&gt;</code> has fields not only for the <code>IList&lt;TSource&gt;</code> source and the <code>Func&lt;TSource, TResult&gt;</code> selector, but also for the tracked min and max bounds based on previous <code>Skip</code> and <code>Take</code> calls), and they have overrides of virtual methods that allow for various operations to be specialized. This means sequences of LINQ methods can be optimized. For example, <code>source.Where(...).Select(...)</code> is optimized a) to combine both the filter and the map delegates into a single <code>IEnumerable&lt;T&gt;</code>, thus removing the overhead of an extra layer of interface dispatch, and b) to perform operations specific to the original source data type (e.g. if <code>source</code> was an array, the processing can be done directly on that array rather than via <code>IEnumerator&lt;T&gt;</code>).</p>
<p>Many of these optimizations make the most sense when a method returns an <code>IEnumerable&lt;T&gt;</code> that happens to be the result of a LINQ query. The producer of that method doesn’t know how the consumer will be consuming it, and the consumer doesn’t know the details of how the producer produced it. But since the LINQ methods flow context via the concrete implementations of <code>IEnumerable&lt;T&gt;</code>, significant optimizations are possible for interesting combinations of consumer and producer methods. For example, let’s say a producer of an <code>IEnumerable&lt;T&gt;</code> decides they want to always return data in ascending order, so they do:</p>
<pre><code>public static IEnumerable&lt;T&gt; GetData()
{
    ...
    return data.OrderBy(s =&gt; s.CreatedAt);
}</code></pre>
<p>But as it turns out, the consumer won’t be looking at all of the elements, and instead just wants the first:</p>
<pre><code>T value = GetData().First();</code></pre>
<p>LINQ optimizes this by having the enumerable returned from <code>OrderBy</code> provide a specialized implementation of <code>First</code>/<code>FirstOrDefault</code>: it doesn’t need to perform an <code>O(N log N)</code> sort (or allocate a lot of memory to hold all of the keys), it can instead just do an <code>O(N)</code> search for the smallest element in the source, because the smallest element would be the first to be yielded from <code>OrderBy</code>.</p>
<p><code>Contains</code> is ripe for these kinds of optimizations as well, e.g. <code>OrderBy</code>, <code>Distinct</code>, and <code>Reverse</code> all entail non-trivial processing and/or allocation, but if followed by a <code>Contains</code>, all that work can be skipped, as the <code>Contains</code> can just search the source directly. With <a href="https://github.com/dotnet/runtime/pull/112684">dotnet/runtime#112684</a>, this set of optimizations is extended to <code>Contains</code>, with almost 30 specialized implementations of <code>Contains</code> across the various iterator specializations.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private IEnumerable&lt;int&gt; _source = Enumerable.Range(0, 1000).ToArray();

    [Benchmark]
    public bool AppendContains() =&gt; _source.Append(100).Contains(999);

    [Benchmark]
    public bool ConcatContains() =&gt; _source.Concat(_source).Contains(999);

    [Benchmark]
    public bool DefaultIfEmptyContains() =&gt; _source.DefaultIfEmpty(42).Contains(999);

    [Benchmark]
    public bool DistinctContains() =&gt; _source.Distinct().Contains(999);

    [Benchmark]
    public bool OrderByContains() =&gt; _source.OrderBy(x =&gt; x).Contains(999);

    [Benchmark]
    public bool ReverseContains() =&gt; _source.Reverse().Contains(999);

    [Benchmark]
    public bool UnionContains() =&gt; _source.Union(_source).Contains(999);

    [Benchmark]
    public bool SelectManyContains() =&gt; _source.SelectMany(x =&gt; _source).Contains(999);

    [Benchmark]
    public bool WhereSelectContains() =&gt; _source.Where(x =&gt; true).Select(x =&gt; x).Contains(999);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>AppendContains</td>
<td>.NET 9.0</td>
<td>2,931.97 ns</td>
<td>1.00</td>
<td>88 B</td>
<td>1.00</td>
</tr>
<tr>
<td>AppendContains</td>
<td>.NET 10.0</td>
<td>52.06 ns</td>
<td>0.02</td>
<td>56 B</td>
<td>0.64</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ConcatContains</td>
<td>.NET 9.0</td>
<td>3,065.17 ns</td>
<td>1.00</td>
<td>88 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ConcatContains</td>
<td>.NET 10.0</td>
<td>54.58 ns</td>
<td>0.02</td>
<td>56 B</td>
<td>0.64</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DefaultIfEmptyContains</td>
<td>.NET 9.0</td>
<td>39.21 ns</td>
<td>1.00</td>
<td>–</td>
<td>NA</td>
</tr>
<tr>
<td>DefaultIfEmptyContains</td>
<td>.NET 10.0</td>
<td>32.89 ns</td>
<td>0.84</td>
<td>–</td>
<td>NA</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DistinctContains</td>
<td>.NET 9.0</td>
<td>16,967.31 ns</td>
<td>1.000</td>
<td>58656 B</td>
<td>1.000</td>
</tr>
<tr>
<td>DistinctContains</td>
<td>.NET 10.0</td>
<td>46.72 ns</td>
<td>0.003</td>
<td>64 B</td>
<td>0.001</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>OrderByContains</td>
<td>.NET 9.0</td>
<td>12,884.28 ns</td>
<td>1.000</td>
<td>12280 B</td>
<td>1.000</td>
</tr>
<tr>
<td>OrderByContains</td>
<td>.NET 10.0</td>
<td>50.14 ns</td>
<td>0.004</td>
<td>88 B</td>
<td>0.007</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ReverseContains</td>
<td>.NET 9.0</td>
<td>479.59 ns</td>
<td>1.00</td>
<td>4072 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ReverseContains</td>
<td>.NET 10.0</td>
<td>51.80 ns</td>
<td>0.11</td>
<td>48 B</td>
<td>0.01</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>UnionContains</td>
<td>.NET 9.0</td>
<td>16,910.57 ns</td>
<td>1.000</td>
<td>58664 B</td>
<td>1.000</td>
</tr>
<tr>
<td>UnionContains</td>
<td>.NET 10.0</td>
<td>55.56 ns</td>
<td>0.003</td>
<td>72 B</td>
<td>0.001</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SelectManyContains</td>
<td>.NET 9.0</td>
<td>2,950.64 ns</td>
<td>1.00</td>
<td>192 B</td>
<td>1.00</td>
</tr>
<tr>
<td>SelectManyContains</td>
<td>.NET 10.0</td>
<td>60.42 ns</td>
<td>0.02</td>
<td>128 B</td>
<td>0.67</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>WhereSelectContains</td>
<td>.NET 9.0</td>
<td>1,782.05 ns</td>
<td>1.00</td>
<td>104 B</td>
<td>1.00</td>
</tr>
<tr>
<td>WhereSelectContains</td>
<td>.NET 10.0</td>
<td>260.25 ns</td>
<td>0.15</td>
<td>104 B</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<p>LINQ in .NET 10 also gains some new methods, including <code>Sequence</code> and <code>Shuffle</code>. While the primary purpose of these new methods is not performance, they can have a meaningful impact on performance, due to how they’ve been implemented and how they integrate with the rest of the optimizations in LINQ. Take <code>Sequence</code>, for example. <code>Sequence</code> is similar to <code>Range</code>, in that its a source for numbers:</p>
<pre><code>public static IEnumerable&lt;T&gt; Sequence&lt;T&gt;(T start, T endInclusive, T step) where T : INumber&lt;T&gt;</code></pre>
<p>Whereas <code>Range</code> only works with <code>int</code> and produces a contiguous series of non-overflowing numbers starting at the initial value, <code>Sequence</code> works with any <code>INumber&lt;&gt;</code>, supports <code>step</code> values other than <code>1</code> (including negative values), and allows for wrapping around <code>T</code>‘s maximum or minimum. However, when appropriate (e.g. <code>step</code> is <code>1</code>), <code>Sequence</code> will try to utilize <code>Range</code>‘s implementation, which has internally been updated to work with any <code>T : INumber&lt;T&gt;</code>, even though its public API is still tied to <code>int</code>. That means that all of the optimizations afforded to <code>Range&lt;T&gt;</code> propagate to <code>Sequence&lt;T&gt;</code>.</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private List&lt;short&gt; _values = new();

    [Benchmark(Baseline = true)]
    public void Fill1()
    {
        _values.Clear();
        for (short i = 42; i &lt;= 1042; i++)
        {
            _values.Add(i);
        }
    }

    [Benchmark]
    public void Fill2()
    {
        _values.Clear();
        _values.AddRange(Enumerable.Sequence&lt;short&gt;(42, 1042, 1));
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fill1</td>
<td>1,479.99 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Fill2</td>
<td>37.42 ns</td>
<td>0.03</td>
</tr>
</tbody>
</table>
<p>My favorite new LINQ method, though, is <code>Shuffle</code> (introduced in <a href="https://github.com/dotnet/runtime/pull/112173">dotnet/runtime#112173</a>), in part because it’s very handy, but in part because of its implementation and performance focus. The purpose of <code>Shuffle</code> is to randomize the source input, and logically, it’s akin to a very simple implementation:</p>
<pre><code>public static IEnumerable&lt;T&gt; Shuffle&lt;T&gt;(IEnumerable&lt;T&gt; source)
{
    T[] arr = source.ToArray();
    Random.Shared.Shuffle(arr);
    foreach (T item in arr) yield return item;
}</code></pre>
<p>Worst case, this implementation is effectively what’s in LINQ. Just as in the worst case <code>OrderBy</code> needs to buffer up the whole input because it’s possible any item might be the smallest and thus need to be yielded first, <code>Shuffle</code> similarly needs to support the possibility that the last element should probabilistically be yielded first. However, there are a variety of special-cases in the implementation that allow it to perform significantly better than such a hand-rolled <code>Shuffle</code> implementation you might be using today.</p>
<p>First, <code>Shuffle</code> has some of the same characteristics as <code>OrderBy</code>, in that they’re both creating permutations of the input. That means that many of the ways we can specialize subsequent operations on the result of an <code>OrderBy</code> also apply to <code>Shuffle</code>. For example, <code>Shuffle.First</code> on an <code>IList&lt;T&gt;</code> can just select an element from the list at random. <code>Shuffle.Count</code> can just count the underlying source, since the order of the elements is irrelevant to the result. <code>Shuffle.Contains</code> can just perform the contains on the underlying source. Etc. But my two favorite sequences are <code>Shuffle.Take</code> and <code>Shuffle.Take.Contains</code>.</p>
<p><code>Shuffle.Take</code> provides an interesting optimization opportunity: whereas with <code>Shuffle</code> by itself we need to build the whole shuffled sequence, with a <code>Shuffle</code> followed immediately by a <code>Take(N)</code>, we only need to sample <code>N</code> items from the source. We still need those <code>N</code> items to be a uniformly random distribution, akin to what we’d get if we performed the buffering shuffle and then selected the first <code>N</code> items in the resulting array, but we can do so using an algorithm that allows us to avoid buffering everything. We need an algorithm that will let us iterate through the source data once, picking out elements as we go, and only ever buffering <code>N</code> items at a time. Enter “reservoir sampling.” I previously discussed reservoir sampling in <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/">Performance Improvements in .NET 8</a>, as it’s employed by the JIT as part of its dynamic PGO implementation, and we can use the algorithm here in <code>Shuffle</code> as well. Reservoir sampling provides exactly the single-pass, low-memory path we want: initialize a “reservoir” (an array) with the first <code>N</code> items, then as we scan the rest of the sequence, probabilistically overwrite one of the elements in our reservoir with the current item. The algorithm ensures that every element ends up in the reservoir with equal probability, yielding the same distribution as fully shuffling and taking <code>N</code>, but using only <code>O(N)</code> space and only making a single pass over an otherwise unknown-length source.</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private IEnumerable&lt;int&gt; _source = Enumerable.Range(1, 1000).ToList();

    [Benchmark(Baseline = true)]
    public List&lt;int&gt; ShuffleTakeManual() =&gt; ShuffleManual(_source).Take(10).ToList();

    [Benchmark]
    public List&lt;int&gt; ShuffleTakeLinq() =&gt; _source.Shuffle().Take(10).ToList();

    private static IEnumerable&lt;int&gt; ShuffleManual(IEnumerable&lt;int&gt; source)
    {
        int[] arr = source.ToArray();
        Random.Shared.Shuffle(arr);
        foreach (var item in arr)
        {
            yield return item;
        }
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ShuffleTakeManual</td>
<td>4.150 us</td>
<td>1.00</td>
<td>4232 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ShuffleTakeLinq</td>
<td>3.801 us</td>
<td>0.92</td>
<td>192 B</td>
<td>0.05</td>
</tr>
</tbody>
</table>
<p><code>Shuffle.Take.Contains</code> is even more fun. We now have a probability problem that reads like a brain teaser or an SAT question. “I have <code>totalCount</code> items of which <code>equalCount</code> match my target value, and we’re going to pick <code>takeCount</code> items at random. What is the probability that at least one of those <code>takeCount</code> items is one of the <code>equalCount</code> items?” This is called a hypergeometric distribution, and we can use an implementation of it for <code>Shuffle.Take.Contains</code>.</p>
<p>To make this easier to reason about, let’s talk candy. Imagine you have a jar of 100 jelly beans, of which 20 are your favorite flavor, Watermelon, and you’re going to pick 5 of the 100 beans at random; what are the chances you get at least one Watermelon? To solve this, we could reason through all the different ways we might get 1, 2, 3, 4, or 5 Watermelons, but instead, let’s do the opposite and think through how likely it is that we don’t get any (sad panda):</p>
<ul>
<li>The chance that our first pick isn’t a Watermelon is the number of non-Watermelons divided by the total number of beans, so <code>(100-20)/100</code>.</li>
<li>Once we’ve picked a bean out of the jar, we’re not putting it back, so the chance that our second pick isn’t a Watermelon is now <code>(99-20)/99</code> (we have one fewer bean, but our first pick wasn’t a Watermelon, so there’s the same number of Watermelons as there was before).</li>
<li>For a third pick, it’s now <code>(98-20)/98</code>.</li>
<li>And so on.</li>
</ul>
<p>After five rounds, we end up with <code>(80/100) * (79/99) * (78/98) * (77/97) * (76/96)</code>, which is ~32%. If the chances I don’t get a Watermelon are ~32%, then the chances I do get a Watermelon are ~68%. Jelly beans aside, that’s our algorithm:</p>
<pre><code>double probOfDrawingZeroMatches = 1;
for (long i = 0; i &lt; _takeCount; i++)
{
    probOfDrawingZeroMatches *= (double)(totalCount - i - equalCount) / (totalCount - i);
}

return Random.Shared.NextDouble() &gt; probOfDrawingZeroMatches;</code></pre>
<p>The net effect is we can compute the answer much more efficiently than with a naive implementation that shuffles and then separately takes and separately contains.</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private IEnumerable&lt;int&gt; _source = Enumerable.Range(1, 1000).ToList();

    [Benchmark(Baseline = true)]
    public bool ShuffleTakeContainsManual() =&gt; ShuffleManual(_source).Take(10).Contains(2000);

    [Benchmark]
    public bool ShuffleTakeContainsLinq() =&gt; _source.Shuffle().Take(10).Contains(2000);

    private static IEnumerable&lt;int&gt; ShuffleManual(IEnumerable&lt;int&gt; source)
    {
        int[] arr = source.ToArray();
        Random.Shared.Shuffle(arr);
        foreach (var item in arr)
        {
            yield return item;
        }
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ShuffleTakeContainsManual</td>
<td>3,900.99 ns</td>
<td>1.00</td>
<td>4136 B</td>
<td>1.00</td>
</tr>
<tr>
<td>ShuffleTakeContainsLinq</td>
<td>79.12 ns</td>
<td>0.02</td>
<td>96 B</td>
<td>0.02</td>
</tr>
</tbody>
</table>
<p><code>LINQ</code> in .NET 10 also sports some new methods that <em>are</em> about performance (at least in part), in particular <code>LeftJoin</code> and <code>RightJoin</code>, from <a href="https://github.com/dotnet/runtime/pull/110872">dotnet/runtime#110872</a>. I say these are about performance because it’s already possible to achieve the left and right join semantics using existing LINQ surface area, and the new methods do it more efficiently.</p>
<p><code>Enumerable.Join</code> implements an “inner join,” meaning only matching pairs from the two supplied collections appear in the output. For example, this code, which is joining based on the first letter in each string:</p>
<pre><code>IEnumerable&lt;string&gt; left = [&#34;apple&#34;, &#34;banana&#34;, &#34;cherry&#34;, &#34;date&#34;, &#34;grape&#34;, &#34;honeydew&#34;];
IEnumerable&lt;string&gt; right = [&#34;aardvark&#34;, &#34;dog&#34;, &#34;elephant&#34;, &#34;goat&#34;, &#34;gorilla&#34;, &#34;hippopotamus&#34;];
foreach (string result in left.Join(right, s =&gt; s[0], s =&gt; s[0], (s1, s2) =&gt; $&#34;{s1} {s2}&#34;))
{
    Console.WriteLine(result);
}</code></pre>
<p>outputs:</p>
<pre><code>apple aardvark
date dog
grape goat
grape gorilla
honeydew hippopotamus</code></pre>
<p>In contrast, a “left join” (also known as a “left outer join”) would yield the following:</p>
<pre><code>apple aardvark
banana
cherry
date dog
grape goat
grape gorilla
honeydew hippopotamus</code></pre>
<p>Note that it has all of the same output as with the “inner join,” except it has at least one row for every <code>left</code> element, even if there’s no matching element in the <code>right</code> row. And then a “right join” (also known as a “right outer join”) would yield the following:</p>
<pre><code>apple aardvark
date dog
 elephant
grape goat
grape gorilla
honeydew hippopotamus</code></pre>
<p>Again, all the same output as with the “inner join,” except it has at least one row for every <code>right</code> element, even if there’s no matching element in the <code>left</code> row.</p>
<p>Prior to .NET 10, there was no <code>LeftJoin</code> or <code>RightJoin</code>, but their semantics could be achieved using a combination of <code>GroupJoin</code>, <code>SelectMany</code>, and <code>DefaultIfEmpty</code>:</p>
<pre><code>public static IEnumerable&lt;TResult&gt; LeftJoin&lt;TOuter, TInner, TKey, TResult&gt;(
    this IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner,
    Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector,
    Func&lt;TOuter, TInner?, TResult&gt; resultSelector) =&gt;
    outer
    .GroupJoin(inner, outerKeySelector, innerKeySelector, (o, inners) =&gt; (o, inners))
    .SelectMany(x =&gt; x.inners.DefaultIfEmpty(), (x, i) =&gt; resultSelector(x.o, i));</code></pre>
<p><code>GroupJoin</code> creates a group for each <code>outer</code> (“left”) element, where the group contains all matching items from <code>inner</code> (“right”). We can flatten those results by using <code>SelectMany</code>, such that we end up with an output for each pairing, using <code>DefaultIfEmpty</code> to ensure that there’s always at least a default inner element to pair. We can do the exact same thing for a <code>RightJoin</code>: in fact, we can implement the right join just by delegating to the left join and flipping all the arguments:</p>
<pre><code>public static IEnumerable&lt;TResult&gt; RightJoin&lt;TOuter, TInner, TKey, TResult&gt;(
    this IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner,
    Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector,
    Func&lt;TOuter, TInner?, TResult&gt; resultSelector) =&gt;
    inner.LeftJoin(outer, innerKeySelector, outerKeySelector, (i, o) =&gt; resultSelector(o, i));</code></pre>
<p>Thankfully, you no longer need to do that yourself, and this isn’t how the new <code>LeftJoin</code> and <code>RightJoin</code> methods are implemented in .NET 10. We can see the difference with a benchmark:</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Linq;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private IEnumerable&lt;int&gt; Outer { get; } = Enumerable.Sequence(0, 1000, 2);
    private IEnumerable&lt;int&gt; Inner { get; } = Enumerable.Sequence(0, 1000, 3);

    [Benchmark(Baseline = true)]
    public void LeftJoin_Manual() =&gt;
        ManualLeftJoin(Outer, Inner, o =&gt; o, i =&gt; i, (o, i) =&gt; o + i).Count();

    [Benchmark]
    public int LeftJoin_Linq() =&gt;
        Outer.LeftJoin(Inner, o =&gt; o, i =&gt; i, (o, i) =&gt; o + i).Count();

    private static IEnumerable&lt;TResult&gt; ManualLeftJoin&lt;TOuter, TInner, TKey, TResult&gt;(
        IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner,
        Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector,
        Func&lt;TOuter, TInner?, TResult&gt; resultSelector) =&gt;
        outer
        .GroupJoin(inner, outerKeySelector, innerKeySelector, (o, inners) =&gt; (o, inners))
        .SelectMany(x =&gt; x.inners.DefaultIfEmpty(), (x, i) =&gt; resultSelector(x.o, i));
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>LeftJoin_Manual</td>
<td>29.02 us</td>
<td>1.00</td>
<td>65.84 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>LeftJoin_Linq</td>
<td>15.23 us</td>
<td>0.53</td>
<td>36.95 KB</td>
<td>0.56</td>
</tr>
</tbody>
</table>
<p>Moving on from new methods, existing methods were also improved in other ways. <a href="https://github.com/dotnet/runtime/pull/112401">dotnet/runtime#112401</a> from <a href="https://github.com/miyaji255">@miyaji255</a> improved the performance of <code>ToArray</code> and <code>ToList</code> following <code>Skip</code> and/or <code>Take</code> calls. In the specialized iterator implementation used for <code>Take</code> and <code>Skip</code>, this PR simply checks in the <code>ToList</code> and <code>ToArray</code> implementations whether the source is something from which we can easily get a <code>ReadOnlySpan&lt;T&gt;</code> (namely a <code>T[]</code> or <code>List&lt;T&gt;</code>). If it is, rather than copying elements one by one into the destination, it can slice the retrieved span and use its <code>CopyTo</code>, which, depending on the <code>T</code>, may even be vectorized.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private readonly IEnumerable&lt;string&gt; _source = Enumerable.Range(0, 1000).Select(i =&gt; i.ToString()).ToArray();

    [Benchmark]
    public List&lt;string&gt; SkipTakeToList() =&gt; _source.Skip(200).Take(200).ToList();
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>SkipTakeToList</td>
<td>.NET 9.0</td>
<td>1,218.9 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>SkipTakeToList</td>
<td>.NET 10.0</td>
<td>257.4 ns</td>
<td>0.21</td>
</tr>
</tbody>
</table>
<p>LINQ in .NET 10 also sees a few notable enhancements for Native AOT. The code for LINQ has grown over time, as all of these various specializations have found their way into the codebase. These optimizations are generally implemented by deriving specialized iterators from a base <code>Iterator&lt;T&gt;</code>, which has a bunch of <code>abstract</code> or <code>virtual</code> methods for performing the subsequent operation (e.g. <code>Contains</code>). With Native AOT, any use of a method like <code>Enumerable.Contains</code> then prevents the corresponding implementations on <em>all</em> of those specializations from being trimmed away, leading to non-trivial increase in assembly code size. As such, years ago multiple builds of <code>System.Linq.dll</code> were introduced into the <code>dotnet/runtime</code> build system: one focused on speed, and one focused on size. When building <code>System.Linq.dll</code> to go with coreclr, you’d end up with the speed-optimized build that has all of these specializations. When building <code>System.Linq.dll</code> to go with other flavors, like Native AOT, you’d instead get the size-optimized build, which eschews many of the LINQ optimizations that have been added in the last decade. And as this was a build-time decision, developers using one of these platforms didn’t get a choice; as you learn in kindergarten, “you get what you get and you don’t get upset.” Now in .NET 10, if you do forget what you learned in kindergarten and you do get upset, you have recourse: thanks to <a href="https://github.com/dotnet/runtime/pull/111743">dotnet/runtime#111743</a> and <a href="https://github.com/dotnet/runtime/pull/109978">dotnet/runtime#109978</a>, this setting is now a feature switch rather than a build-time configuration. So, in particular if you’re publishing for Native AOT and you’d prefer all the speed-focused optimizations, you can add <code>&lt;UseSizeOptimizedLinq&gt;false&lt;/UseSizeOptimizedLinq&gt;</code> to your project file and be happy.</p>
<p>However, the need for that switch is now also reduced significantly by <a href="https://github.com/dotnet/runtime/pull/118156">dotnet/runtime#118156</a>. When this size/speed split was previously introduced into the <code>System.Linq.dll</code> build, all of these specializations were eschewed, without a lot of an analysis for tradeoffs involved; as this was focused on optimizing for size, any specialized overrides were removed, no matter how much space they actually saved. Many of those savings turned out to be minimal, however, and in a variety of situations, the throughput cost was significant. This PR brings back some of the more impactful specializations where the throughput gains significantly outweigh the relatively-minimal size cost.</p>
<h3>Frozen Collections</h3>
<p>The <code>FrozenDictionary&lt;TKey, TValue&gt;</code> and <code>FrozenSet&lt;T&gt;</code> collection types were introduced in .NET 8 as collections optimized for the common scenario of creating a long-lived collection that’s then read from <em>a lot</em>. They spend more time at construction in exchange for faster read operations. Under the covers, this is achieved in part by having specializations of the implementations that are optimized for different types of data or shapes of input. .NET 9 improved upon the implementations, and .NET 10 takes it even further.</p>
<p><code>FrozenDictionary&lt;TKey, TValue&gt;</code> exerts a lot of energy for <code>TKey</code> as <code>string</code>, as that is such a common use case. It also has specializations for <code>TKey</code> as <code>Int32</code>. <a href="https://github.com/dotnet/runtime/pull/111886">dotnet/runtime#111886</a> and <a href="https://github.com/dotnet/runtime/pull/112298">dotnet/runtime#112298</a> extend that further by adding specializations for when <code>TKey</code> is any primitive integral type that’s the size of an <code>int</code> or smaller (e.g. <code>byte</code>, <code>char</code>, <code>ushort</code>, etc.) as well as enums backed by such primitives (which represent the vast, vast majority of enums used in practice). In particular, they handle the common case where these values are densely packed, in which case they implement the dictionary as an array that it can index into based on the integer’s value. This makes for a very efficient lookup, while not consuming too much additional space: it’s only used when the values are dense and thus won’t be wasting many empty slots in the array.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Frozen;
using System.Net;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;status&#34;)]
public partial class Tests
{
    private static readonly FrozenDictionary&lt;HttpStatusCode, string&gt; s_statusDescriptions =
        Enum.GetValues&lt;HttpStatusCode&gt;().Distinct()
            .ToFrozenDictionary(status =&gt; status, status =&gt; status.ToString());

    [Benchmark]
    [Arguments(HttpStatusCode.OK)]
    public string Get(HttpStatusCode status) =&gt; s_statusDescriptions[status];
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get</td>
<td>.NET 9.0</td>
<td>2.0660 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Get</td>
<td>.NET 10.0</td>
<td>0.8735 ns</td>
<td>0.42</td>
</tr>
</tbody>
</table>
<p>Both <code>FrozenDictionary&lt;TKey, TValue&gt;</code> and <code>FrozenSet&lt;T&gt;</code> also improve with regards to the alternate lookup functionality introduced in .NET 9. Alternate lookups are a mechanism that enables getting a proxy for a dictionary or set that’s keyed with a different key from <code>TKey</code>, most commonly a <code>ReadOnlySpan&lt;char&gt;</code> when <code>TKey</code> is <code>string</code>. As noted, both <code>FrozenDictionary&lt;TKey, TValue&gt;</code> and <code>FrozenSet&lt;T&gt;</code> achieve their goals by having different implementations based on the nature of the indexed data, and that specialization is achieved by virtual methods that derived specializations override. The JIT is typically able to minimize the costs of such virtuals, especially if the collections are stored in <code>static readonly</code> fields. However, the alternate lookup support complicated things, as it introduced a virtual method with a generic method parameter (the alternate key type), otherwise known as GVM. “GVM” might as well be a four-letter word in performance circles, as they’re hard for the runtime to optimize. The purpose of these alternate lookups is primarily performance, but the use of a GVM significantly reduced those performance gains. <a href="https://github.com/dotnet/runtime/pull/108732">dotnet/runtime#108732</a> from <a href="https://github.com/andrewjsaid">@andrewjsaid</a> addresses this by changing the frequency with which a GVM needs to be invoked. Rather than the lookup operation itself being a generic virtual method, the PR introduces a separate generic virtual method that retrieves a delegate for performing the lookup; the retrieval of that delegate still incurs GVM penalties, but once the delegate is retrieved, it can be cached, and invoking it does not incur said overheads. This results in measurable improvements on throughput.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Frozen;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly FrozenDictionary&lt;string, int&gt; s_d = new Dictionary&lt;string, int&gt; 
    {
        [&#34;one&#34;] = 1, [&#34;two&#34;] = 2, [&#34;three&#34;] = 3, [&#34;four&#34;] = 4, [&#34;five&#34;] = 5, [&#34;six&#34;] = 6, 
        [&#34;seven&#34;] = 7, [&#34;eight&#34;] = 8, [&#34;nine&#34;] = 9, [&#34;ten&#34;] = 10, [&#34;eleven&#34;] = 11, [&#34;twelve&#34;] = 12,
    }.ToFrozenDictionary();

    [Benchmark]
    public int Get()
    {
        var alternate = s_d.GetAlternateLookup&lt;ReadOnlySpan&lt;char&gt;&gt;();
        return
            alternate[&#34;one&#34;] + alternate[&#34;two&#34;] + alternate[&#34;three&#34;] + alternate[&#34;four&#34;] + alternate[&#34;five&#34;] +
            alternate[&#34;six&#34;] + alternate[&#34;seven&#34;] + alternate[&#34;eight&#34;] + alternate[&#34;nine&#34;] + alternate[&#34;ten&#34;] + 
            alternate[&#34;eleven&#34;] + alternate[&#34;twelve&#34;];
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get</td>
<td>.NET 9.0</td>
<td>133.46 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Get</td>
<td>.NET 10.0</td>
<td>81.39 ns</td>
<td>0.61</td>
</tr>
</tbody>
</table>
<h3>BitArray</h3>
<p><code>BitArray</code> provides support for exactly what its name says, a bit array. You create it with the desired number of values and can then read and write a <code>bool</code> for each index, turning the corresponding bit to <code>1</code> or <code>0</code> accordingly. It also provides a variety of helper operations for processing the whole bit array, such as for Boolean logic operations like <code>And</code> and <code>Not</code>. Where possible, those operations are vectorized, taking advantage of SIMD to process many bits per instruction.</p>
<p>However, for situations where you want to write custom manipulations of the bits, you only have two options: use the indexer (or corresponding <code>Get</code> and <code>Set</code> methods), which means multiple instructions required to process each bit, or use <code>CopyTo</code> to extract all of the bits to a separate array, which means you need to allocate (or at least rent) such an array and pay for the memory copy before you can then manipulate the bits. There’s also not a great way to then copy those bits back if you wanted to manipulate the <code>BitArray</code> in place.</p>
<p><a href="https://github.com/dotnet/runtime/pull/116308">dotnet/runtime#116308</a> adds a <code>CollectionsMarshal.AsBytes(BitArray)</code> method that returns a <code>Span&lt;byte&gt;</code> directly referencing the <code>BitArray</code>‘s underlying storage. This provides a very efficient way to get access to all the bits, which then makes it possible to write (or reuse) vectorized algorithms. Say, for example, you wanted to use a <code>BitArray</code> to represent a binary embedding (an “embedding” is a vector representation of the semantic meaning of some data, basically an array of numbers, each one corresponding to some aspect of the data; a binary embedding uses a single bit for each number). To determine how semantically similar two inputs are, you get an embedding for each and then perform a distance or similarity calculation on the two. For binary embeddings, a common distance metric is “hamming distance,” which effectively lines up the bits and tells you the number of positions that have different values, e.g. <code>0b1100</code> and <code>0b1010</code> have a hamming distance of 2. Helpfully, <code>TensorPrimitives.HammingBitDistance</code> provides an implementation of this, accepting two <code>ReadOnlySpan&lt;T&gt;</code>s and computing the number of bits that differ between them. With <code>CollectionsMarshal.AsBytes</code>, we can now utilize that helper directly with the contents of <code>BitArray</code>s, both saving us the effort of having to write it manually and benefiting from any optimizations in <code>HammingBitDistance</code> itself.</p>
<pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors.
// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections;
using System.Numerics.Tensors;
using System.Runtime.InteropServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private BitArray _bits1, _bits2;

    [GlobalSetup]
    public void Setup()
    {
        Random r = new(42);
        byte[] bytes = new byte[128];

        r.NextBytes(bytes);
        _bits1 = new BitArray(bytes);

        r.NextBytes(bytes);
        _bits2 = new BitArray(bytes);
    }

    [Benchmark(Baseline = true)]
    public long HammingDistanceManual()
    {
        long distance = 0;
        for (int i = 0; i &lt; _bits1.Length; i++)
        {
            if (_bits1[i] != _bits2[i])
            {
                distance++;
            }
        }

        return distance;
    }

    [Benchmark]
    public long HammingDistanceTensorPrimitives() =&gt;
        TensorPrimitives.HammingBitDistance(
            CollectionsMarshal.AsBytes(_bits1),
            CollectionsMarshal.AsBytes(_bits2));
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>HammingDistanceManual</td>
<td>1,256.72 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>HammingDistanceTensorPrimitives</td>
<td>63.29 ns</td>
<td>0.05</td>
</tr>
</tbody>
</table>
<p>The main motivation for this PR was adding the <code>AsBytes</code> method, but doing so triggered a series of other modifications that themselves help with performance. For example, rather than backing the <code>BitArray</code> with an <code>int[]</code> as was previously done, it’s now backed by a <code>byte[]</code>, and rather than reading elements one by one in the <code>byte[]</code>-based constructor, vectorized copy operations are now being used (they were already being used and continue to be used in the <code>int[]</code>-based constructor).</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private byte[] _byteData = Enumerable.Range(0, 512).Select(i =&gt; (byte)i).ToArray();

    [Benchmark]
    public BitArray ByteCtor() =&gt; new BitArray(_byteData);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteCtor</td>
<td>.NET 9.0</td>
<td>160.10 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>ByteCtor</td>
<td>.NET 10.0</td>
<td>83.07 ns</td>
<td>0.52</td>
</tr>
</tbody>
</table>
<h3>Other Collections</h3>
<p>There are a variety of other notable improvements in collections:</p>
<ul>
<li><strong><code>List&lt;T&gt;</code></strong>. <a href="https://github.com/dotnet/runtime/pull/107683">dotnet/runtime#107683</a> from <a href="https://github.com/karakasa">@karakasa</a> builds on a change that was made in .NET 9 to improve the performance of using <code>InsertRange</code> on a <code>List&lt;T&gt;</code> to insert a <code>ReadOnlySpan&lt;T&gt;</code>. When a full <code>List&lt;T&gt;</code> is appended to, the typical process is a new larger array is allocated, all of the existing elements are copied over (one array copy), and then the new element is stored into the array in the next available slot. If that same growth routine is used when <em>inserting</em> rather than <em>appending</em> an element, you possibly end up copying some elements twice: you first copy over all of the elements into the new array, and then to handle the insert, you may again need to copy some of the elements you already copied as part of shifting them to make room for the insertion at the new location. In the extreme, if you’re inserting at index 0, you copy all of the elements into the new array, and then you copy all of the elements again to shift them by one slot. The same applies when inserting a range of elements, so with this PR, rather than first copying over all of the elements and then shifting a subset, <code>List&lt;T&gt;</code> now grows by copying the elements above and below the target range for the insertion to their correct location and then fills in the target range with the inserted elements.
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private readonly int[] _data = [1, 2, 3, 4];

    [Benchmark]
    public List&lt;int&gt; Test()
    {
        List&lt;int&gt; list = new(4);
        list.AddRange(_data);
        list.InsertRange(0, _data);
        return list;
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test</td>
<td>.NET 9.0</td>
<td>48.65 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Test</td>
<td>.NET 10.0</td>
<td>30.07 ns</td>
<td>0.62</td>
</tr>
</tbody>
</table>
</li>
<li><strong><code>ConcurrentDictionary&lt;TKey, TValue&gt;</code></strong>. <a href="https://github.com/dotnet/runtime/pull/108065">dotnet/runtime#108065</a> from <a href="https://github.com/koenigst">@koenigst</a> changes how a <code>ConcurrentDictionary</code>‘s backing array is sized when it’s cleared. <code>ConcurrentDictionary</code> is implemented with an array of linked lists, and when the collection is constructed, a constructor parameter allows for presizing that array. Due to the concurrent nature of the dictionary and its implementation, <code>Clear</code>‘ing it necessitates creating a new array rather than just using part of the old one. When that new array was created, it reset to using the default size. This PR tweaks that to remember the initial capacity requested by the user, and using that initial size again when constructing the new array.
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Concurrent;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private ConcurrentDictionary&lt;int, int&gt; _data = new(concurrencyLevel: 1, capacity: 1024);

    [Benchmark]
    public void ClearAndAdd()
    {
        _data.Clear();
        for (int i = 0; i &lt; 1024; i++)
        {
            _data.TryAdd(i, i);
        }
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClearAndAdd</td>
<td>.NET 9.0</td>
<td>51.95 us</td>
<td>1.00</td>
<td>134.36 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>ClearAndAdd</td>
<td>.NET 10.0</td>
<td>30.32 us</td>
<td>0.58</td>
<td>48.73 KB</td>
<td>0.36</td>
</tr>
</tbody>
</table>
</li>
<li><strong><code>Dictionary&lt;TKey, TValue&gt;</code></strong>. <code>Dictionary</code> is one of the most popular collection types across .NET, and <code>TKey</code> == <code>string</code> is one of (if not <em>the</em>) most popular forms. <a href="https://github.com/dotnet/runtime/pull/117427">dotnet/runtime#117427</a> makes dictionary lookups with constant <code>string</code>s much faster. You might expect it would be a complicated change, but it ends up being just a few strategic tweaks. A variety of methods for operating on <code>string</code>s are already known to the JIT and already have optimized implementations for when dealing with constants. All this PR needed to do was change which methods <code>Dictionary&lt;TKey, TValue&gt;</code> was using in its optimized <code>TryGetValue</code> lookup path, and because that path is often inlined, a constant argument to <code>TryGetValue</code> can be exposed as a constant to these helpers, e.g. <code>string.Equals</code>.
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private Dictionary&lt;string, int&gt; _data = new() { [&#34;a&#34;] = 1, [&#34;b&#34;] = 2, [&#34;c&#34;] = 3, [&#34;d&#34;] = 4, [&#34;e&#34;] = 5 };

    [Benchmark]
    public int Get() =&gt; _data[&#34;a&#34;] + _data[&#34;b&#34;] + _data[&#34;c&#34;] + _data[&#34;d&#34;] + _data[&#34;e&#34;];
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get</td>
<td>.NET 9.0</td>
<td>33.81 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Get</td>
<td>.NET 10.0</td>
<td>14.02 ns</td>
<td>0.41</td>
</tr>
</tbody>
</table>
</li>
<li><strong><code>OrderedDictionary&lt;TKey, TValue&gt;</code></strong>. <a href="https://github.com/dotnet/runtime/pull/109324">dotnet/runtime#109324</a> adds new overloads of <code>TryAdd</code> and <code>TryGetValue</code> that provide the index of the added or retrieved element in the collection. This index can then be used in subsequent operations on the dictionary to access the same slot. For example, if you want to implement an <code>AddOrUpdate</code> operation on top of <code>OrderedDictionary</code>, you need to perform one or two operations, first trying to add the item, and then if found to already exist, updating it, and that update can benefit from targeting the exact index that contains the element rather than it needing to do another keyed lookup.
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private OrderedDictionary&lt;string, int&gt; _dictionary = new();

    [Benchmark(Baseline = true)]
    public void Old() =&gt; AddOrUpdate_Old(_dictionary, &#34;key&#34;, k =&gt; 1, (k, v) =&gt; v + 1);

    [Benchmark]
    public void New() =&gt; AddOrUpdate_New(_dictionary, &#34;key&#34;, k =&gt; 1, (k, v) =&gt; v + 1);

    private static void AddOrUpdate_Old(OrderedDictionary&lt;string, int&gt; d, string key, Func&lt;string, int&gt; addFunc, Func&lt;string, int, int&gt; updateFunc)
    {
        if (d.TryGetValue(key, out int existing))
        {
            d[key] = updateFunc(key, existing);
        }
        else
        {
            d.Add(key, addFunc(key));
        }
    }

    private static void AddOrUpdate_New(OrderedDictionary&lt;string, int&gt; d, string key, Func&lt;string, int&gt; addFunc, Func&lt;string, int, int&gt; updateFunc)
    {
        if (d.TryGetValue(key, out int existing, out int index))
        {
            d.SetAt(index, updateFunc(key, existing));
        }
        else
        {
            d.Add(key, addFunc(key));
        }
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Old</td>
<td>6.961 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>New</td>
<td>4.201 ns</td>
<td>0.60</td>
</tr>
</tbody>
</table>
</li>
<li><strong><code>ImmutableArray&lt;T&gt;</code></strong>. The <code>ImmutableCollectionsMarshal</code> class already exposes an <code>AsArray</code> method that enables retrieving the backing <code>T[]</code> from an <code>ImmutableArray&lt;T&gt;</code>. However, if you had an <code>ImmutableArray&lt;T&gt;.Builder</code>, there was previously no way to access the backing store it was using. <a href="https://github.com/dotnet/runtime/pull/112177">dotnet/runtime#112177</a> enables doing so, with an <code>AsMemory</code> method that retrieves the underlying storage as a <code>Memory&lt;T&gt;</code>.</li>
<li><strong><code>InlineArray</code></strong>. .NET 8 introduced <code>InlineArrayAttribute</code>, which can be used to attribute a struct containing a single field; the attribute accepts a count, and the runtime replicates the struct’s field that number of times, as if you’d logically copy/pasted the field repeatedly. The runtime also ensures that the storage is contiguous and appropriately aligned, such that if you had an indexible collection that pointed to the beginning of the struct, you could use it as an array. And it so happens such a collection exists: <code>Span&lt;T&gt;</code>. C# 12 then makes it easy to treat any such attributed struct as a span, e.g.
<pre><code>[InlineArray(8)]
internal struct EightStrings
{
    private string _field;
}
...
EightStrings strings = default;
Span&lt;string&gt; span = strings;</code></pre>
<p>The C# compiler will itself emit code that uses this capability. For example, if you use collection expressions to initialize a span, you’re likely triggering the compiler to emit an <code>InlineArray</code>. When I write this:</p>
<pre><code>public void M(int a, int b, int c, int d) 
{
    Span&lt;int&gt; span = [a, b, c, d];
}</code></pre>
<p>the compiler emits something like the following equivalent:</p>
<pre><code>public void M(int a, int b, int c, int d)
{
    &lt;&gt;y__InlineArray4&lt;int&gt; buffer = default(&lt;&gt;y__InlineArray4&lt;int&gt;);
    &lt;PrivateImplementationDetails&gt;.InlineArrayElementRef&lt;&lt;&gt;y__InlineArray4&lt;int&gt;, int&gt;(ref buffer, 0) = a;
    &lt;PrivateImplementationDetails&gt;.InlineArrayElementRef&lt;&lt;&gt;y__InlineArray4&lt;int&gt;, int&gt;(ref buffer, 1) = b;
    &lt;PrivateImplementationDetails&gt;.InlineArrayElementRef&lt;&lt;&gt;y__InlineArray4&lt;int&gt;, int&gt;(ref buffer, 2) = c;
    &lt;PrivateImplementationDetails&gt;.InlineArrayElementRef&lt;&lt;&gt;y__InlineArray4&lt;int&gt;, int&gt;(ref buffer, 3) = d;
    &lt;PrivateImplementationDetails&gt;.InlineArrayAsSpan&lt;&lt;&gt;y__InlineArray4&lt;int&gt;, int&gt;(ref buffer, 4);
}</code></pre>
<p>where it has defined that <code>&lt;&gt;y__InlineArray4</code> like this:</p>
<pre><code>[StructLayout(LayoutKind.Auto)]
[InlineArray(4)]
internal struct &lt;&gt;y__InlineArray4&lt;T&gt;
{
    [CompilerGenerated]
    private T _element0;
}</code></pre>
<p>This shows up elsewhere, too. For example, C# 13 introduced support for using <code>params</code> with collections other than arrays, including spans, so now I can write this:</p>
<pre><code>public void Caller(int a, int b, int c, int d) =&gt; M(a, b, c, d);

public void M(params ReadOnlySpan&lt;int&gt; span) { }</code></pre>
<p>and for <code>Caller</code> we’ll see very similar code emitted to what I previously showed, with the compiler manufacturing such an <code>InlineArray</code> type. As you might imagine, the popularity of the features that cause the compiler to produce these types has caused there to be a lot of them emitted. Each type is specific to a particular length, so while the compiler will reuse them, a) it can end up needing to emit a lot to cover different lengths, and b) it emits them as internal to each assembly that needs them, so there can end up being a lot of duplication. Looking just at the shared framework for .NET 9 (the core libraries like <code>System.Private.CoreLib</code> that ship as part of the runtime), there are ~140 of these types… all of which are for sizes no larger than 8. For .NET 10, <a href="https://github.com/dotnet/runtime/pull/113403">dotnet/runtime#113403</a> adds a set of public <code>InlineArray2&lt;T&gt;</code>, <code>InlineArray3&lt;T&gt;</code>, etc., that should cover the vast majority of sizes the compiler would otherwise need to emit types. In the near future, the C# compiler will be updated to use those new types when available instead of emitting its own, thereby yielding non-trivial size savings.</p></li>
</ul>
<h2>I/O</h2>
<p>In previous .NET releases, there have been concerted efforts that have invested a lot in improving specific areas of I/O performance, such as completely rewriting <code>FileStream</code> in .NET 6. Nothing as comprehensive as that was done for I/O in .NET 10, but there are some nice one-off improvements that can still have a measurable impact on certain scenarios.</p>
<p>On Unix, when a <code>MemoryMappedFile</code> is created and it’s not associated with a particular <code>FileStream</code>, it needs to create some kind of backing memory for the MMF’s data. On Linux, it’d try to use <code>shm_open</code>, which creates a shared memory object with appropriate semantics. However, in the years since <code>MemoryMappedFile</code> was initially enabled on Linux, the Linux kernel has added support for anonymous files and the <code>memfd_create</code> function that creates them. These are ideal for <code>MemoryMappedFile</code> and much more efficient, so <a href="https://github.com/dotnet/runtime/pull/105178">dotnet/runtime#105178</a> from <a href="https://github.com/am11">@am11</a> switches over to using <code>memfd_create</code> when it’s available.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.IO.MemoryMappedFiles;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public void MMF()
    {
        using MemoryMappedFile mff = MemoryMappedFile.CreateNew(null, 12345);
        using MemoryMappedViewAccessor accessor = mff.CreateViewAccessor();
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>MMF</td>
<td>.NET 9.0</td>
<td>9.916 us</td>
<td>1.00</td>
</tr>
<tr>
<td>MMF</td>
<td>.NET 10.0</td>
<td>6.358 us</td>
<td>0.64</td>
</tr>
</tbody>
</table>
<p><code>FileSystemWatcher</code> is improved in <a href="https://github.com/dotnet/runtime/pull/116830">dotnet/runtime#116830</a>. The primary purpose for this PR was to fix a memory leak, where on Windows disposing of a <code>FileSystemWatcher</code> while it was in use could end up leaking some objects. However, it also addresses a performance issue specific to Windows. <code>FileSystemWatcher</code> needs to pass a buffer to the OS for the OS to populate with file-changed information. That meant that <code>FileSystemWatcher</code> was allocating a managed array and then immediately pinning that buffer so it could pass a pointer to it into native code. For certain consumption of <code>FileSystemWatcher</code>, especially in scenarios where lots of <code>FileSystemWatcher</code> instances are created, that pinning could contribute to non-trivial heap fragmentation. Interestingly, though, this array is effectively never consumed as an array: all of the writes into it are performed in native code via the pointer that was passed to the OS, and all consumption of it in managed code to read out the events are done via a span. That means the array nature of it doesn’t really matter, and we’re better off just allocating a native rather than managed buffer that then requires pinning.</p>
<pre><code>// Run on Windows.
// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public void FSW()
    {
        using FileSystemWatcher fsw = new(Environment.CurrentDirectory);
        fsw.EnableRaisingEvents = true;
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>FSW</td>
<td>.NET 9</td>
<td>61.46 us</td>
<td>1.00</td>
<td>8944 B</td>
<td>1.00</td>
</tr>
<tr>
<td>FSW</td>
<td>.NET 10</td>
<td>61.21 us</td>
<td>1.00</td>
<td>744 B</td>
<td>0.08</td>
</tr>
</tbody>
</table>
<p><code>BufferedStream</code> gets a boost from <a href="https://github.com/dotnet/runtime/pull/104822">dotnet/runtime#104822</a> from <a href="https://github.com/ANahr">@ANahr</a>. There is a curious and problematic inconsistency in <code>BufferedStream</code> that’s been there since, well, forever as far as I can tell. It’s obviously been revisited in the past, and due to the super duper strong backwards compatibility concerns for .NET Framework (where a key feature is that the framework doesn’t change), the issue was never fixed. There’s even a <a href="https://github.com/microsoft/referencesource/blob/f7df9e2399ecd273e90908ac11caf1433e142448/mscorlib/system/io/bufferedstream.cs#L1263">comment in the code</a> to this point:</p>
<pre><code>// We should not be flushing here, but only writing to the underlying stream, but previous version flushed, so we keep this.</code></pre>
<p>A <code>BufferedStream</code> does what its name says. It wraps an underlying <code>Stream</code> and buffers access to it. So, for example, if it were configured with a buffer size of 1000, and you wrote 100 bytes to the <code>BufferedStream</code> at a time, your first 10 writes would just go to the buffer and the underlying <code>Stream</code> wouldn’t be touched at all. Only on the 11th write would the buffer be full and need to be flushed (meaning written) to the underlying <code>Stream</code>. So far, so good. Moreover, there’s a difference between flushing to the underlying stream and flushing the underlying stream. Those sound almost identical, but they’re not: in the former case, we’re effectively calling <code>_stream.Write(buffer)</code> to write the buffer to that stream, and in the latter case, we’re effectively calling <code>_stream.Flush()</code> to force any buffering <em>that</em> stream was doing to propagate it to <em>its</em> underlying destination. <code>BufferedStream</code> really shouldn’t be in the business of doing the latter when <code>Write</code>‘ing to the <code>BufferedStream</code>, and in general it wasn’t… except in one case. Whereas most of the writing-related methods would not call <code>_stream.Flush()</code>, for some reason <code>WriteByte</code> did. In particular for cases where the <code>BufferedStream</code> is configured with a small buffer, and where the underlying stream’s flush is relatively expensive (e.g. <code>DeflateStream.Flush</code> forces any buffered bytes to be compressed and emitted), that can be problematic for performance, nevermind the inconsistency. This change simply fixes the inconsistency, such that <code>WriteByte</code> no longer forces a flush on the underlying stream.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.IO.Compression;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private byte[] _bytes;

    [GlobalSetup]
    public void Setup()
    {
        _bytes = new byte[1024 * 1024];
        new Random(42).NextBytes(_bytes);
    }

    [Benchmark]
    public void WriteByte()
    {
        using Stream s = new BufferedStream(new DeflateStream(Stream.Null, CompressionLevel.SmallestSize), 256);
        foreach (byte b in _bytes)
        {
            s.WriteByte(b);
        }
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WriteByte</td>
<td>.NET 9.0</td>
<td>73.87 ms</td>
<td>1.00</td>
</tr>
<tr>
<td>WriteByte</td>
<td>.NET 10.0</td>
<td>17.77 ms</td>
<td>0.24</td>
</tr>
</tbody>
</table>
<p>While on the subject of compression, it’s worth calling out several improvements in <code>System.IO.Compression</code> in .NET 10, too. As noted in <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/">Performance Improvements in .NET 9</a>, <code>DeflateStream</code>/<code>GZipStream</code>/<code>ZLibStream</code> are managed wrappers around an underlying native <code>zlib</code> library. For a long time, that was the original <code>zlib</code> (<a href="https://github.com/madler/zlib">madler/zlib</a>). Then it was Intel’s <code>zlib-intel</code> fork (<a href="https://github.com/intel/zlib">intel/zlib</a>), which is now archived and no longer maintained. In .NET 9, the library switched to using <code>zlib-ng</code> (<a href="https://github.com/zlib-ng/zlib-ng">zlib-ng/zlib-ng</a>), which is a modernized fork that’s well-maintained and optimized for a large number of hardware architectures. .NET 9 is based on <code>zlib-ng</code> 2.2.1. <a href="https://github.com/dotnet/runtime/pull/118457">dotnet/runtime#118457</a> updates it to use <code>zlib-ng</code> 2.2.5. Compared with the 2.2.1 release, there are a variety of performance improvements in <code>zlib-ng</code> itself, which .NET 10 then inherits, such as improved used of AVX2 and AVX512. Most importantly, though, the update includes a <a href="https://github.com/zlib-ng/zlib-ng/pull/1938">revert</a> that undoes a cleanup change in the 2.2.0 release; the original change removed a workaround for a function that had been slow and was found to no longer be slow, but as it turns out, it’s still slow in some circumstances (long, <em>highly</em> compressible data), resulting in a throughput regression. The fix in 2.2.5 puts back the workaround to fix the regression.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.IO.Compression;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private byte[] _data = new HttpClient().GetByteArrayAsync(@&#34;https://raw.githubusercontent.com/dotnet/runtime-assets/8d362e624cde837ec896e7fff04f2167af68cba0/src/System.IO.Compression.TestData/DeflateTestData/xargs.1&#34;).Result;

    [Benchmark]
    public void Compress()
    {
        using ZLibStream z = new(Stream.Null, CompressionMode.Compress);
        for (int i = 0; i &lt; 100; i++)
        {
            z.Write(_data);
        }
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Compress</td>
<td>.NET 9.0</td>
<td>202.79 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Compress</td>
<td>.NET 10.0</td>
<td>70.45 us</td>
<td>0.35</td>
</tr>
</tbody>
</table>
<p>The managed wrapper for <code>zlib</code> also gains some improvements. <a href="https://github.com/dotnet/runtime/pull/113587">dotnet/runtime#113587</a> from <a href="https://github.com/edwardneal">@edwardneal</a> improves the case where multiple gzip payloads are being read from the underlying <code>Stream</code>. Due to its nature, multiple complete gzip payloads can be written one after the other, and a single <code>GZipStream</code> can be used to decompress all of them as if they were one. Each time it hit a boundary between payloads, the managed wrapper was throwing away the old interop handles and creating new ones, but it can instead take advantage of reset capabilities in the underlying <code>zlib</code> library, shaving off some cycles associated with freeing and re-allocating the underlying data structures. This is a very biased micro-benchmark (a stream containing a 1000 gzip payloads that each decompresses into a single byte), highlighting the worst case, but it exemplifies the issue:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.IO.Compression;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private MemoryStream _data;

    [GlobalSetup]
    public void Setup()
    {
        _data = new MemoryStream();
        for (int i = 0; i &lt; 1000; i++)
        {
            using GZipStream gzip = new(_data, CompressionMode.Compress, leaveOpen: true);
            gzip.WriteByte(42);
        }
    }

    [Benchmark]
    public void Decompress()
    {
        _data.Position = 0;
        using GZipStream gzip = new(_data, CompressionMode.Decompress, leaveOpen: true);
        gzip.CopyTo(Stream.Null);
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Decompress</td>
<td>.NET 9.0</td>
<td>331.3 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Decompress</td>
<td>.NET 10.0</td>
<td>104.3 us</td>
<td>0.31</td>
</tr>
</tbody>
</table>
<p>Other components that sit above these streams, like <code>ZipArchive</code>, have also improved. <a href="https://github.com/dotnet/runtime/pull/103153">dotnet/runtime#103153</a> from <a href="https://github.com/edwardneal">@edwardneal</a> updates <code>ZipArchive</code> to not rely on <code>BinaryReader</code> and <code>BinaryWriter</code>, avoiding their underlying buffer allocations and having more fine-grained control over how and when exactly data is encoded/decoded and written/read. And <a href="https://github.com/dotnet/runtime/pull/102704">dotnet/runtime#102704</a> from <a href="https://github.com/edwardneal">@edwardneal</a> reduces memory consumption and allocation when updating <code>ZipArchive</code>s. A <code>ZipArchive</code> update used to be “rewrite the world”: it loaded every entry’s data into memory and rewrote all the file headers, all entry data, and the “central directory” (what the zip format calls its catalog of all the entries in the archive). A large archive would have proportionally large allocation. This PR introduces change tracking plus ordering of entries so that only the portion of the file from the first actually affected entry (or one whose variable‑length metadata/data changed) is rewritten, rather than always rewriting the whole thing. The effects can be significant.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.IO.Compression;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private Stream _zip = new MemoryStream();

    [GlobalSetup]
    public void Setup()
    {
        using ZipArchive zip = new(_zip, ZipArchiveMode.Create, leaveOpen: true);

        Random r = new(42);
        for (int i = 0; i &lt; 1000; i++)
        {
            byte[] fileBytes = new byte[r.Next(512, 2048)];
            r.NextBytes(fileBytes);
            using Stream s = zip.CreateEntry($&#34;file{i}.txt&#34;).Open();
            s.Write(fileBytes);
        }
    }

    [Benchmark]
    public void Update()
    {
        _zip.Position = 0;
        using ZipArchive zip = new(_zip, ZipArchiveMode.Update, leaveOpen: true);
        zip.GetEntry(&#34;file987.txt&#34;)?.Delete();
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Update</td>
<td>.NET 9.0</td>
<td>987.8 us</td>
<td>1.00</td>
<td>2173.9 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>Update</td>
<td>.NET 10.0</td>
<td>354.7 us</td>
<td>0.36</td>
<td>682.22 KB</td>
<td>0.31</td>
</tr>
</tbody>
</table>
<p>(<code>ZipArchive</code> and <code>ZipFile</code> also gain async APIs in <a href="https://github.com/dotnet/runtime/pull/114421">dotnet/runtime#114421</a>, a long requested feature that allows using async I/O while loading, manipulating, and saving zips.)</p>
<p>Finally, somewhere between performance and reliability, <a href="https://github.com/dotnet/roslyn-analyzers/pull/7390">dotnet/roslyn-analyzers#7390</a> from <a href="https://github.com/mpidash">@mpidash</a> adds a new analyzer for <code>StreamReader.EndOfStream</code>. <code>StreamReader.EndOfStream</code> seems like it should be harmless, but it’s quite the devious little property. The intent is to determine whether the reader is at the end up of the underlying <code>Stream</code>. Seems easy enough. If the <code>StreamReader</code> still has previously read data buffered, obviously it’s not at the end. And if the reader has previously seen EOF, e.g. <code>Read</code> returned <code>0</code>, then it obviously is at the end. But in all other situations, there’s no way to know you’re at the end of the stream (at least in the general case) without performing a read, which means this property does something properties should never do: perform I/O. Worse than just performing I/O, that read can be a blocking operation, e.g. if the <code>Stream</code> represents a network stream for a <code>Socket</code>, and performing a read actually means blocking until data is received. Even worse, though, is when it’s used in an asynchronous method, e.g.</p>
<pre><code>while (!reader.EndOfStream)
{
    string? line = await reader.ReadLineAsync();
    ...
}</code></pre>
<p>Now not only might <code>EndOfStream</code> do I/O and block, it’s doing that in a method that’s supposed to do all of its waiting asynchronously.</p>
<p>What makes this even more frustrating is that <code>EndOfStream</code> isn’t even useful in a loop like that above. <code>ReadLineAsync</code> will return a <code>null</code> string if it’s at the end of the stream, so the loop would instead be better as:</p>
<pre><code>while (await reader.ReadLineAsync() is string line)
{
    ...
}</code></pre>
<p>Simpler, cheaper, and no ticking time bombs of synchronous I/O. Thanks to this new analyzer, any such use of <code>EndOfStream</code> in an async method will trigger <code>CA2024</code>:</p>
<p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/CA2024.png" alt="CA2024 Analyzer"/></p>
<h2>Networking</h2>
<p>Networking-related operations show up in almost every modern workload. Past releases of .NET have seen a lot of energy exerted on whittling away at networking overheads, as these components are used over and over and over, often in critical paths, and the overheads can add up. .NET 10 continues the streamlining trend.</p>
<p>As was seen with core primitives earlier, <code>IPAddress</code> and <code>IPNetwork</code> are both imbued with UTF8 parsing capabilities, thanks to <a href="https://github.com/dotnet/runtime/pull/102144">dotnet/runtime#102144</a> from <a href="https://github.com/edwardneal">@edwardneal</a>. As is the case with most other such types in the core libraries, the UTF8-based implementation and the UTF16-based implementation are mostly the same implementation, sharing most of their code via generic methods parameterized on <code>byte</code> vs <code>char</code>. And as a result of the focus on enabling UTF8, not only can you parse UTF8 bytes directly rather than needing to transcode first, the existing code actually gets a bit faster.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;, &#34;s&#34;)]
public partial class Tests
{
    [Benchmark]
    [Arguments(&#34;Fe08::1%13542&#34;)]
    public IPAddress Parse(string s) =&gt; IPAddress.Parse(s);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parse</td>
<td>.NET 9.0</td>
<td>71.35 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Parse</td>
<td>.NET 10.0</td>
<td>54.60 ns</td>
<td>0.77</td>
</tr>
</tbody>
</table>
<p><code>IPAddress</code> is also imbued with <code>IsValid</code> and <code>IsValidUtf8</code> methods, thanks to <a href="https://github.com/dotnet/runtime/pull/111433">dotnet/runtime#111433</a>. It was previously possible to test the validity of an address via <code>TryParse</code>, but when successful, that would allocate the <code>IPAddress</code>; if you don’t need the resulting object but just need to know whether it’s valid, the extra allocation is wasteful.</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private string _address = &#34;123.123.123.123&#34;;

    [Benchmark(Baseline = true)]
    public bool TryParse() =&gt; IPAddress.TryParse(_address, out _);

    [Benchmark]
    public bool IsValid() =&gt; IPAddress.IsValid(_address);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>TryParse</td>
<td>26.26 ns</td>
<td>1.00</td>
<td>40 B</td>
<td>1.00</td>
</tr>
<tr>
<td>IsValid</td>
<td>21.88 ns</td>
<td>0.83</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p><code>Uri</code>, used in the above benchmark, also gets some notable improvements. In fact, one of my favorite improvements in all of .NET 10 is in <code>Uri</code>. The feature itself isn’t a performance improvement, but there are some interesting performance-related ramifications for it. In particular, since forever, <code>Uri</code> has had a length limitation due to implementation details. <code>Uri</code> keeps track of various offsets in the input, such as where the host portion starts, where the path starts, where the query starts, and so on. The implementer chose to use <code>ushort</code> for each of these values rather than <code>int</code>. That means the maximum length of a <code>Uri</code> is then constrained to the lengths a <code>ushort</code> can describe, namely 65,535 characters. That sounds like a ridiculously long <code>Uri</code>, one no one would ever need to go beyond… until you consider data URIs. Data URIs embed a representation of arbitrary bytes, typically Base64 encoded, in the URI itself. This allows for files to be represented directly in links, and it’s become a common way for AI-related services to send and receive data payloads, like images. It doesn’t take a very large image to exceed 65K characters, however, especially with Base64 encoding increasing the payload size by ~33%. <a href="https://github.com/dotnet/runtime/pull/117287">dotnet/runtime#117287</a> finally removes that limitation, so now <code>Uri</code> can be used to represent very large data URIs, if desired. This, however, has some performance ramifications (beyond the few percentage increase in the size of <code>Uri</code>, to accomodate the extra <code>ushort</code> to <code>int</code> bytes). In particular, <code>Uri</code> implements path compression, so for example this:</p>
<pre><code>Console.WriteLine(new Uri(&#34;http://test/hello/../hello/../hello&#34;));</code></pre>
<p>prints out:</p>
<pre><code>http://test/hello</code></pre>
<p>As it turns out, the algorithm implementing that path compression is <code>O(N^2)</code>. Oops. With a limit of 65K characters, such a quadratic complexity isn’t a security concern (as <code>O(N^2)</code> operations can sometimes be, as if <code>N</code> is unbounded, it creates an attack vector where an attacker can do <code>N</code> work and get the attackee to do disproportionately more). But once the limit is removed entirely, it could be. As such, <a href="https://github.com/dotnet/runtime/pull/117820">dotnet/runtime#117820</a> compensates by making the path compression <code>O(N)</code>. And while in the general case, we don’t expect path compression to be a meaningfully impactful part of constructing <code>Uri</code>, in degenerate cases, even under the old limit, the change can still make a measurable improvement.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private string _input = $&#34;http://host/{string.Concat(Enumerable.Repeat(&#34;a/../&#34;, 10_000))}{new string(&#39;a&#39;, 10_000)}&#34;;

    [Benchmark]
    public Uri Ctor() =&gt; new Uri(_input);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctor</td>
<td>.NET 9.0</td>
<td>18.989 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Ctor</td>
<td>.NET 10.0</td>
<td>2.228 us</td>
<td>0.12</td>
</tr>
</tbody>
</table>
<p>In the same vein, the longer the URI, the more effort is required to do whatever validation is needed in the constructor. <code>Uri</code>‘s constructor needs to check whether the input has any Unicode characters that might need to be handled. Rather than checking all the characters one at a time, with <a href="https://github.com/dotnet/runtime/pull/107357">dotnet/runtime#107357</a>, <code>Uri</code> can now use <code>SearchValues</code> to more quickly rule out or find the first location of a character that needs to be looked at more deeply.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private string _uri;

    [GlobalSetup]
    public void Setup()
    {
        byte[] bytes = new byte[40_000];
        new Random(42).NextBytes(bytes);
        _uri = $&#34;data:application/octet-stream;base64,{Convert.ToBase64String(bytes)}&#34;;
    }

    [Benchmark]
    public Uri Ctor() =&gt; new Uri(_uri);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctor</td>
<td>.NET 9.0</td>
<td>19.354 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Ctor</td>
<td>.NET 10.0</td>
<td>2.041 us</td>
<td>0.11</td>
</tr>
</tbody>
</table>
<p>Other changes were made to <code>Uri</code> that further reduce construction costs in various other cases, too. For cases where the URI host is an IPv6 address, e.g. <code>http://[2603:1020:201:10::10f]</code>, <a href="https://github.com/dotnet/runtime/pull/117292">dotnet/runtime#117292</a> recognizes that scope IDs are relatively rare and makes the cases without a scope ID cheaper in exchange for making the cases with a scope ID a little more expensive.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public string CtorHost() =&gt; new Uri(&#34;http://[2603:1020:201:10::10f]&#34;).Host;
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>CtorHost</td>
<td>.NET 9.0</td>
<td>304.9 ns</td>
<td>1.00</td>
<td>208 B</td>
<td>1.00</td>
</tr>
<tr>
<td>CtorHost</td>
<td>.NET 10.0</td>
<td>254.2 ns</td>
<td>0.83</td>
<td>216 B</td>
<td>1.04</td>
</tr>
</tbody>
</table>
<p>(Note that the .NET 10 allocation is 8 bytes larger than the .NET 9 allocation due to the extra space required in this case for dropping the length limitation, as discussed earlier.)</p>
<p><a href="https://github.com/dotnet/runtime/pull/117289">dotnet/runtime#117289</a> also improves construction for cases where the URI requires normalization, saving some allocations by using normalization routines over spans (which were added in <a href="https://github.com/dotnet/runtime/pull/110465">dotnet/runtime#110465</a>) instead of needing to allocate <code>string</code>s for the inputs.</p>
<pre><code>using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public Uri Ctor() =&gt; new(&#34;http://some.host.with.ümlauts/&#34;);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctor</td>
<td>.NET 9.0</td>
<td>377.6 ns</td>
<td>1.00</td>
<td>440 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Ctor</td>
<td>.NET 10.0</td>
<td>322.0 ns</td>
<td>0.85</td>
<td>376 B</td>
<td>0.85</td>
</tr>
</tbody>
</table>
<p>Various improvements have also found their way into the HTTP stack. For starters, the download helpers on <code>HttpClient</code> and <code>HttpContent</code> have improved. These types expose helper methods for some of the most common forms of grabbing data; while a developer can grab the response <code>Stream</code> and consume that efficiently, for simple and common cases like “just get the whole response as a <code>string</code>” or “just get the whole response as a <code>byte[]</code>“, the <code>GetStringAsync</code> and <code>GetByteArrayAsync</code> make that really easy to do. <a href="https://github.com/dotnet/runtime/pull/109642">dotnet/runtime#109642</a> changes how these methods operate in order to better manage the temporary buffers that are required, especially in the case where the server hasn’t advertised a <code>Content-Length</code>, such that the client doesn’t know ahead of time how much data to expect and thus how much space to allocate.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;
using System.Net.Sockets;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private HttpClient _client = new();
    private Uri _uri;

    [GlobalSetup]
    public void Setup()
    {
        Socket listener = new(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        listener.Bind(new IPEndPoint(IPAddress.Loopback, 0));
        listener.Listen(int.MaxValue);
        _ = Task.Run(async () =&gt;
        {
            byte[] header = &#34;HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n&#34;u8.ToArray();
            byte[] chunkData = Enumerable.Range(0, 100).SelectMany(_ =&gt; &#34;abcdefghijklmnopqrstuvwxyz&#34;).Select(c =&gt; (byte)c).ToArray();
            byte[] chunkHeader = Encoding.UTF8.GetBytes($&#34;{chunkData.Length:X}\r\n&#34;);
            byte[] chunkFooter = &#34;\r\n&#34;u8.ToArray();
            byte[] footer = &#34;0\r\n\r\n&#34;u8.ToArray();
            while (true)
            {
                var server = await listener.AcceptAsync();
                server.NoDelay = true;
                using StreamReader reader = new(new NetworkStream(server), Encoding.ASCII);
                while (true)
                {
                    while (!string.IsNullOrEmpty(await reader.ReadLineAsync())) ;

                    await server.SendAsync(header);
                    for (int i = 0; i &lt; 100; i++)
                    {
                        await server.SendAsync(chunkHeader);
                        await server.SendAsync(chunkData);
                        await server.SendAsync(chunkFooter);
                    }
                    await server.SendAsync(footer);
                }
            }
        });

        var ep = (IPEndPoint)listener.LocalEndPoint!;
        _uri = new Uri($&#34;http://{ep.Address}:{ep.Port}/&#34;);
    }

    [Benchmark]
    public async Task&lt;byte[]&gt; ResponseContentRead_ReadAsByteArrayAsync()
    {
        using HttpResponseMessage resp = await _client.GetAsync(_uri);
        return await resp.Content.ReadAsByteArrayAsync();
    }

    [Benchmark]
    public async Task&lt;string&gt; ResponseHeadersRead_ReadAsStringAsync()
    {
        using HttpResponseMessage resp = await _client.GetAsync(_uri, HttpCompletionOption.ResponseHeadersRead);
        return await resp.Content.ReadAsStringAsync();
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ResponseContentRead_ReadAsByteArrayAsync</td>
<td>.NET 9.0</td>
<td>1.438 ms</td>
<td>1.00</td>
<td>912.71 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>ResponseContentRead_ReadAsByteArrayAsync</td>
<td>.NET 10.0</td>
<td>1.166 ms</td>
<td>0.81</td>
<td>519.12 KB</td>
<td>0.57</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ResponseHeadersRead_ReadAsStringAsync</td>
<td>.NET 9.0</td>
<td>1.528 ms</td>
<td>1.00</td>
<td>1166.77 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>ResponseHeadersRead_ReadAsStringAsync</td>
<td>.NET 10.0</td>
<td>1.306 ms</td>
<td>0.86</td>
<td>773.3 KB</td>
<td>0.66</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/117071">dotnet/runtime#117071</a> reduces overheads associated with HTTP header validation. In the <code>System.Net.Http</code> implementation, some headers have dedicated parsers for them, while many (the majority of custom ones that services define) don’t. This PR recognizes that for these, the validation that needs to be performed amounts to only checking for forbidden newline characters, and the objects that were being created for all headers weren’t necessary for these.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net.Http.Headers;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private readonly HttpResponseHeaders _headers = new HttpResponseMessage().Headers;

    [Benchmark]
    public void Add()
    {
        _headers.Clear();
        _headers.Add(&#34;X-Custom&#34;, &#34;Value&#34;);
    }

    [Benchmark]
    public object GetValues()
    {
        _headers.Clear();
        _headers.TryAddWithoutValidation(&#34;X-Custom&#34;, &#34;Value&#34;);
        return _headers.GetValues(&#34;X-Custom&#34;);
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add</td>
<td>.NET 9.0</td>
<td>28.04 ns</td>
<td>1.00</td>
<td>32 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Add</td>
<td>.NET 10.0</td>
<td>12.61 ns</td>
<td>0.45</td>
<td>–</td>
<td>0.00</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GetValues</td>
<td>.NET 9.0</td>
<td>82.57 ns</td>
<td>1.00</td>
<td>64 B</td>
<td>1.00</td>
</tr>
<tr>
<td>GetValues</td>
<td>.NET 10.0</td>
<td>23.97 ns</td>
<td>0.29</td>
<td>32 B</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>For folks using HTTP/2, <a href="https://github.com/dotnet/runtime/pull/112719">dotnet/runtime#112719</a> decreases per-connection memory consumption, by changing the <code>HPackDecoder</code> to lazily grow its buffers, starting from expected-case sizing rather than worst-case. (“HPACK” is the header compression algorithm used by HTTP/2, utilizing a table shared between client and server for managing commonly transmitted headers.) It’s a little hard to measure in a micro-benchmark, since in a real app the connections get reused (and the benefits here aren’t about temporary allocation but rather connection density and overall working set), but we can get a glimpse of it by doing what you’re not supposed to do and create a new <code>HttpClient</code> for each request (you’re not supposed to do that, or more specifically not supposed to create a new handler for each request, because doing so tears down the connection pool and the connections it contains… which is bad for an app but exactly what we want for our micro-benchmark).</p>
<pre><code>// For this benchmark, change the benchmark.csproj to start with:
//     &lt;Project Sdk=&#34;Microsoft.NET.Sdk.Web&#34;&gt;
// instead of:
//     &lt;Project Sdk=&#34;Microsoft.NET.Sdk&#34;&gt;
// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using System.Net;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using Microsoft.AspNetCore.Server.Kestrel.Core;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private WebApplication _app;

    [GlobalSetup]
    public async Task Setup()
    {
        var builder = WebApplication.CreateBuilder();
        builder.Logging.SetMinimumLevel(LogLevel.Warning);
        builder.WebHost.ConfigureKestrel(o =&gt; o.ListenLocalhost(5000, listen =&gt; listen.Protocols = HttpProtocols.Http2));

        _app = builder.Build();
        _app.MapGet(&#34;/hello&#34;, () =&gt; Results.Text(&#34;hi from kestrel over h2c\n&#34;));
        var serverTask = _app.RunAsync();
        await Task.Delay(300);
    }

    [GlobalCleanup]
    public async Task Cleanup()
    {
        await _app.StopAsync();
        await _app.DisposeAsync();
    }

    [Benchmark]
    public async Task Get()
    {
        using var client = new HttpClient()
        {
            DefaultRequestVersion = HttpVersion.Version20,
            DefaultVersionPolicy = HttpVersionPolicy.RequestVersionExact
        };

        var response = await client.GetAsync(&#34;http://localhost:5000/hello&#34;);
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get</td>
<td>.NET 9.0</td>
<td>485.9 us</td>
<td>1.00</td>
<td>83.19 KB</td>
<td>1.00</td>
</tr>
<tr>
<td>Get</td>
<td>.NET 10.0</td>
<td>445.0 us</td>
<td>0.92</td>
<td>51.79 KB</td>
<td>0.62</td>
</tr>
</tbody>
</table>
<p>Also, on Linux and macOS, all HTTP use (and, more generally, all socket interactions) gets a tad cheaper from <a href="https://github.com/dotnet/runtime/pull/109052">dotnet/runtime#109052</a>, which eliminates a <code>ConcurrentDictionary&lt;&gt;</code> lookup for each asynchronous operation that completes on a <code>Socket</code>.</p>
<p>And for all you Native AOT fans, <a href="https://github.com/dotnet/runtime/pull/117012">dotnet/runtime#117012</a> also adds a feature switch that enables trimming out the HTTP/3 implementation from <code>HttpClient</code>, which can represent a very sizeable and “free” space savings if you’re not using HTTP/3 at all.</p>
<h2>Searching</h2>
<p>Someone once told me that computer science was “all about sorting and searching.” That’s not far off. Searching in one way, shape, or form is an integral part of many applications and services.</p>
<h3>Regex</h3>
<p>Whether you love or hate the terse syntax, regular expressions (regex) continue to be an integral part of software development, with applications as part of both software and the software development process. As such, it’s had robust support in .NET since the early days of the platform, with the <code>System.Text.RegularExpressions</code> namespace providing a feature-rich set of regex capabilities. The performance of <code>Regex</code> was improved significantly in .NET 5 (<a href="https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/">Regex Performance Improvements in .NET 5</a>) and then again in .NET 7, which also saw a significant amount of new functionality added (<a href="https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7/">Regular Expression Improvements in .NET 7</a>). It’s continued to be improved in every release since, and .NET 10 is no exception.</p>
<p>As I’ve discussed in previous blog posts about regex and performance, there are two high-level ways regex engines are implemented, either with backtracking or without. Non-backtracking engines typically work by creating some form of finite automata that represents the pattern, and then for each character consumed from the input, moves around the deterministic finite automata (DFA, meaning you can be in only a single state at a time) or non-deterministic finite automata (NFA, meaning you can be in multiple states at a time), transitioning from one state to another. A key benefit of a non-backtracking engine is that it can often make linear guarantees about processing time, where an input string of length <code>N</code> can be processed in worst-case <code>O(N)</code> time. A key downside of a non-backtracking engine is it can’t support all of the features developers are familiar with in modern regex engines, like back references. Backtracking engines are named as such because they’re able to “backtrack,” trying one approach to see if there’s a match and then going back and trying another. If you have the regex pattern <code>\w*\d</code> (which matches any number of word characters followed by a single digit) and supply it with the string <code>&#34;12&#34;</code>, a backtracking engine is likely to first try treating both the <code>&#39;1&#39;</code> and the <code>&#39;2&#39;</code> as word characters, then find that it doesn’t have anything to fulfill the <code>\d</code>, and thus backtrack, instead treating only the <code>&#39;1&#39;</code> as being consumed by the <code>\w*</code>, and leaving the <code>&#39;2&#39;</code> to be consumed by the <code>\d</code>. Backtracking is how engines support features like back references, variable-length lookarounds, conditional expressions, and more. They can also have excellent performance, especially on the average and best cases. A key downside, however, is their worst case, where on some patterns they can suffer from “catastrophic backtracking.” That happens when all of that backtracking leads to exploring the same input over and over and over again, possibly consuming much more than linear time.</p>
<p>Since .NET 7, .NET has had an opt-in non-backtracking engine, which is what you get with <code>RegexOptions.NonBacktracking</code>, Otherwise, it uses a backtracking engine, whether using the default interpreter, or a regex compiled to IL (<code>RegexOptions.Compiled</code>), or a regex emitted as a custom C# implementation with the regex source generator (<code>[GeneratedRegex(...)]</code>). These backtracking engines can yield exceptional performance, but due to their backtracking nature, they are susceptible to bad worst-case performance, which is why specifying timeouts to a <code>Regex</code> is often encouraged, especially when using patterns of unknown provenance. Still, there are things backtracking engines can do to help mitigate some such backtracking, in particular avoiding the need for some of the backtracking in the first place.</p>
<p>One of the main tools backtracking engines offer for reduced backtracking is an “atomic” construct. Some regex syntaxes surface this via “possessive quantifiers,” while others, including .NET, surface it via “atomic groups.” They’re fundamentally the same thing, just expressed in the syntax differently. An atomic group in .NET’s regex syntax is a group that is never backtracked into. If we take our previous <code>\w*\d</code> example, we could wrap the <code>\w*</code> loop in an atomic group like this: <code>(?&gt;\w*)\d</code>. In doing so, whatever that <code>\w*</code> consumes won’t change via backtracking after exiting the group and moving on to whatever comes after it in the pattern. So if I try to match <code>&#34;12&#34;</code> with such a pattern, it’ll fail, because the <code>\w*</code> will consume both characters, the <code>\d</code> will have nothing to match, and no backtracking will be applied, because the <code>\w*</code> is wrapped in an atomic group and thus exposes no backtracking opportunities.</p>
<p>In that example, wrapping the <code>\w*</code> with an atomic group changes the meaning of the pattern, and thus it’s not something that a regex engine could choose to do automatically. However, there are many cases where wrapping otherwise backtracking constructs in an atomic group does not observably change behavior, because any backtracking that would otherwise happen would provably never be fruitful. Consider a pattern <code>a*b</code>. <code>a*b</code> is observably identical to <code>(?&gt;a*)b</code>, which says that the <code>a*</code> should not be backtracked into. That’s because there’s nothing the <code>a*</code> can “give back” (which can only be <code>a</code>s) that would satisfy what comes next in the pattern (which is only <code>b</code>). It’s thus valid for a backtracking engine to transform how it processes <code>a*b</code> to instead be the equivalent of how it processes <code>(?&gt;a*)b</code>. And the .NET regex engine has been capable of such transformations since .NET 5. This can result in massive improvements to throughput. With backtracking, waving my hands, we effectively need to execute everything after the backtracking construct for each possible position we could backtrack to. So, for example, with <code>\w*SOMEPATTERN</code>, if the <code>w*</code> successfully initially consumes 100 characters, we then possibly need to try to match <code>SOMEPATTERN</code> up to 100 different times, as we may need to backtrack up to 100 times and re-evaluate <code>SOMEPATTERN</code> each time we give back one of the things initially matched. If we instead make that <code>(?&gt;\w*)</code>, we eliminate all but one of those! That makes improvements to this ability to automatically transform backtracking constructs to be non-backtracking possibly massive improvements in performance, and practically every release of .NET since .NET 5 has increased the set of patterns that are automatically transformed. .NET 10 included.</p>
<p>Let’s start with <a href="https://github.com/dotnet/runtime/pull/117869">dotnet/runtime#117869</a>, which teaches the regex optimizer about more “disjoint” sets. Consider the previous example of <code>a*b</code>, and how I said we can make that <code>a*</code> loop atomic because there’s nothing <code>a*</code> can “give back” that matches <code>b</code>. That is a general statement about auto-atomicity: a loop can be made atomic if it’s guaranteed to end with something that can’t possibly match the thing that comes after it. So, if I have <code>[abc]+[def]</code>, that loop can be made atomic, because there’s nothing <code>[abc]</code> can match that <code>[def]</code> can also match. In contrast, if the expression were instead <code>[abc]+[cef]</code>, that loop must not be made atomic automatically, as doing so could change behavior. The sets <em>do</em> overlap, as both can match <code>&#39;c&#39;</code>. So, for example, if the input were just <code>&#34;cc&#34;</code>, the original expression should match it (the <code>[abc]*</code> loop would match <code>&#39;c&#39;</code> with one iteration of the loop and then the second <code>&#39;c&#39;</code> would satisfy the <code>[cef]</code> set), but if the expression were instead <code>(?&gt;[abc]+)[cef]</code>, it would no longer match, as the <code>[abc]+</code> would consume both <code>&#39;c&#39;</code>s, and there’d be nothing left for the <code>[cef]</code> set to match. Two sets that don’t have any overlap are referred to as being “disjoint,” and so the optimizer needs to be able to prove the disjointedness of sets in order to perform these kinds of auto-atomicity optimizations. The optimizer was already able to do so for many sets, in particular ones that were composed purely of characters or character ranges, e.g. <code>[ace]</code> or <code>[a-zA-Z0-9]</code>. But many sets are instead composed of entire Unicode categories. For example, when you write <code>\d</code>, unless you’ve specified <code>RegexOptions.ECMAScript</code> that’s the same as <code>\p{Nd}</code>, which says “match any character in the Unicode category of Number decimal digits”, aka all characters for which <code>char.GetUnicodeCategory</code> returns <code>UnicodeCategory.DecimalDigitNumber</code>. And the optimizer was unable to reason about overlap between such sets. So, for example, if you had the expression <code>\w*\p{Sm}</code>, that matches anything that’s any number of word characters followed by a math symbol (<code>UnicodeCategory.MathSymbol</code>). <code>\w</code> is actually just a set of eight specific Unicode categories, such that the previous expression behaves identically to if I’d written <code>[\p{Ll}\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{Mn}\p{Nd}\p{Pc}]*\p{Sm}</code> (<code>\w</code> is composed of <code>UnicodeCategory.UppercaseLetter</code>, <code>UnicodeCategory.LowercaseLetter</code>, <code>UnicodeCategory.TitlecaseLetter</code>, <code>UnicodeCategory.ModiferLetter</code>, <code>UnicodeCategory.OtherLetter</code>, <code>UnicodeCategory.NonSpacingMark</code>, <code>UnicodeCategory.ModiferLetter</code>, <code>UnicodeCategory.DecimalDigitNumber</code>, and <code>UnicodeCategory.ConnectorPunctuation</code>). Note that none of those eight categories is the same as <code>\p{Sm}</code>, which means they’re disjoint, which means we can safely change that loop to being atomic without impacting behavior; it just makes it faster. One of the easiest ways to see the effect of this is to look at the output from the regex source generator. Before the change, if I look at the XML comment generated for that expression, I get this:</p>
<pre><code>/// ○ Match a word character greedily any number of times.
/// ○ Match a character in the set [\p{Sm}].</code></pre>
<p>and after, I get this:</p>
<pre><code>/// ○ Match a word character atomically any number of times.
/// ○ Match a character in the set [\p{Sm}].</code></pre>
<p>That one word change in the first sentence makes a huge difference. Here’s the relevant portion of the C# code emitted by the source generator for the matching routine before the change:</p>
<pre><code>// Match a word character greedily any number of times.
//{
    charloop_starting_pos = pos;

    int iteration = 0;
    while ((uint)iteration &lt; (uint)slice.Length &amp;&amp; Utilities.IsWordChar(slice[iteration]))
    {
        iteration++;
    }

    slice = slice.Slice(iteration);
    pos += iteration;

    charloop_ending_pos = pos;
    goto CharLoopEnd;

    CharLoopBacktrack:

    if (Utilities.s_hasTimeout)
    {
        base.CheckTimeout();
    }

    if (charloop_starting_pos &gt;= charloop_ending_pos)
    {
        return false; // The input didn&#39;t match.
    }
    pos = --charloop_ending_pos;
    slice = inputSpan.Slice(pos);

    CharLoopEnd:
//}</code></pre>
<p>You can see how backtracking influences the emitted code. The core loop in there is iterating through as many word characters as it can match, but then before moving on, it remembers some position information about where it was. It also sets up a label for where subsequent code should jump to if it needs to backtrack; that code undoes one of the matched characters and then retries everything that came after it. If the code needs to backtrack again, it’ll again undo one of the characters and retry. And so on. Now, here’s what the code looks like after the change:</p>
<pre><code>// Match a word character atomically any number of times.
{
    int iteration = 0;
    while ((uint)iteration &lt; (uint)slice.Length &amp;&amp; Utilities.IsWordChar(slice[iteration]))
    {
        iteration++;
    }

    slice = slice.Slice(iteration);
    pos += iteration;
}</code></pre>
<p>All of that backtracking gunk is gone; the loop matches as much as it can, and that’s that. You can see the effect this has one some cases with a micro-benchmark like this:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_input = new string(&#39; &#39;, 100);
    private static readonly Regex s_regex = new Regex(@&#34;\s+\S+&#34;, RegexOptions.Compiled);

    [Benchmark]
    public int Count() =&gt; s_regex.Count(s_input);
}</code></pre>
<p>This is a simple test where we’re trying to match any positive number of whitespace characters followed by any positive number of non-whitespace characters, giving it an input composed entirely of whitespace. Without atomicity, the engine is going to consume all of the whitespace as part of the <code>\s+</code> but will then find that there isn’t any non-whitespace available to match the <code>\S+</code>. What does it do then? It backtracks, gives back one of the hundred spaces consumed by <code>\s+</code>, and tries again to match the <code>\S+</code>. It won’t match, so it backtracks again. And again. And again. A hundred times, until it has nothing left to try and gives up. With atomicity, all that backtracking goes away, allowing it to fail faster.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 9.0</td>
<td>183.31 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 10.0</td>
<td>69.23 ns</td>
<td>0.38</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/117892">dotnet/runtime#117892</a> is a related improvement. In regex, <code>\b</code> is called a “word boundary”; it checks whether the wordness of the previous character (whether the previous character matches <code>\w</code>) matches the wordness of the next character, calling it a boundary if they differ. You can see this in the engine’s <code>IsBoundary</code> helper’s implementation, which follows (note that according to <a href="http://www.unicode.org/reports/tr18/">TR18</a> whether a character is considered a boundary word char is <em>almost</em> exactly the same as <code>\w</code>, except with two additional zero-width Unicode characters also included):</p>
<pre><code>internal static bool IsBoundary(ReadOnlySpan&lt;char&gt; inputSpan, int index)
{
    int indexM1 = index - 1;
    return ((uint)indexM1 &lt; (uint)inputSpan.Length &amp;&amp; RegexCharClass.IsBoundaryWordChar(inputSpan[indexM1])) !=
           ((uint)index &lt; (uint)inputSpan.Length &amp;&amp; RegexCharClass.IsBoundaryWordChar(inputSpan[index]));
}</code></pre>
<p>The optimizer already had a special-case in its auto-atomicity logic that had knowledge of boundaries and their relationship to <code>\w</code> and <code>\d</code>, specifically. So, if you had <code>\w+\b</code>, the optimizer would recognize that in order for the <code>\b</code> to match, what comes after what the <code>\w+</code> matches must necessarily not match <code>\w</code>, because then it wouldn’t be a boundary, and thus the <code>\w+</code> could be made atomic. Similarly, with a pattern of <code>\d+\b</code>, it would recognize that what came after must not be in <code>\d</code>, and could make the loop atomic. It didn’t generalize this, though. Now in .NET 10, it does. This PR teaches the optimizer how to recognize subsets of <code>\w</code>, because, as with the special-case of <code>\d</code>, any subset of <code>\w</code> can similarly benefit: if what comes before the <code>\b</code> is a word character, what comes after must not be. Thus, with this PR, an expression like <code>[a-zA-Z]+\b</code> will now have the loop made atomic.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_input = &#34;Supercalifragilisticexpialidocious1&#34;;
    private static readonly Regex s_regex = new Regex(@&#34;^[A-Za-z]+\b&#34;, RegexOptions.Compiled);

    [Benchmark]
    public int Count() =&gt; s_regex.Count(s_input);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 9.0</td>
<td>116.57 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 10.0</td>
<td>21.74 ns</td>
<td>0.19</td>
</tr>
</tbody>
</table>
<p>Just doing a better job of set disjointedness analysis is helpful, but more so is actually recognizing whole new classes of things that can be made atomic. In prior releases, the auto-atomicity optimizations only kicked in for loops over single characters, e.g. <code>a*</code>, <code>[abc]*?</code>, <code>[^abc]*</code>. That is obviously only a subset of loops, as many loops are composed of more than just a single character; loops can surround any regex construct. Even a capture group thrown into the mix would knock the auto-atomicity behavior off the rails. Now with <a href="https://github.com/dotnet/runtime/pull/117943">dotnet/runtime#117943</a>, a significant number of loops involving more complicated constructs can be made atomic. Loops larger than a single character are tricky, though, as there are more things that need to be taken into account when reasoning through atomicity. With a single character, we only need to prove disjointedness for that one character with what comes after it. But, consider an expression like <code>([a-z][0-9])+a1</code>. Can that loop be made atomic? What comes after the loop (<code>&#39;a&#39;</code>) is provably disjoint from what ends the loop (<code>[0-9]</code>), and yet making this loop atomic automatically would change behavior and be a no-no. Imagine if the input were <code>&#34;b2a1&#34;</code>. That matches; if this expression is processed normally, the loop would match a single iteration, consuming the <code>&#34;b2&#34;</code>, and then the <code>a1</code> after the loop would consume the corresponding <code>a1</code> in the input. But, if the loop were made atomic, e.g. <code>(?&gt;([a-z][0-9])+)a1</code>, the loop would end up performing two iterations and consuming both the <code>&#34;b2&#34;</code> and the <code>&#34;a1&#34;</code>, leaving nothing for the <code>a1</code> in the pattern. As it turns out, we not only need to ensure what ends the loop is disjoint from what comes after it, we also need to ensure that what starts the loop is disjoint from what comes after it. That’s not all, though. Now consider an expression <code>^(a|ab)+$</code>. This matches an entire input composed of <code>&#34;a&#34;</code>s and <code>&#34;ab&#34;</code>s. Given an input string like <code>&#34;aba&#34;</code>, this will match successfully, as it will consume the <code>&#34;ab&#34;</code> with the second branch of the alternation, and then consume the remaining <code>a</code> with the first branch of the alternation on the next iteration of the loop. But now consider what happens if we make the loop atomic: <code>^(?&gt;(a|ab)+)$</code>. Now on that same input, the initial <code>a</code> in the input will be consumed by the first branch of the alternation, and that will satisfy the loop’s minimum bound of 1 iteration, exiting the loop. It’ll then proceed to validate that it’s at the end of the string, and fail, but with the loop now atomic, there’s nothing to backtrack into, and the whole match fails. Oops. The problem here is that the loop’s ending must not only be disjoint with what comes next, and the loop’s beginning must not only be disjoint with what comes next, but because it’s a loop, what comes next can actually be itself, which means the loop’s beginning and ending must be disjoint from each other. Those criteria significantly limit to what patterns this can be applied, but even with that, it’s still surprisingly common: <code>dotnet/runtime-assets</code> (which contains test assets for use with <code>dotnet/runtime</code>) contains a <a href="https://github.com/dotnet/runtime-assets/blob/f9ac0b368d930728d6740686de29b5276958d15b/src/System.Text.RegularExpressions.TestData/Regex_RealWorldPatterns.json">database of regex patterns</a> sourced from appropriately-licensed nuget packages, yielding almost 20,000 unique patterns, and more than 7% of those were positively impacted by this.</p>
<p>Here is an example that’s searching <a href="https://www.gutenberg.org/cache/epub/3200/pg3200.txt">“The Entire Project Gutenberg Works of Mark Twain”</a> for sequences of all lowercase ASCII words, each followed by a space, and then all followed by an uppercase ASCII letter.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_input = new HttpClient().GetStringAsync(@&#34;https://www.gutenberg.org/cache/epub/3200/pg3200.txt&#34;).Result;
    private static readonly Regex s_regex = new Regex(@&#34;([a-z]+ )+[A-Z]&#34;, RegexOptions.Compiled);

    [Benchmark]
    public int Count() =&gt; s_regex.Count(s_input);
}</code></pre>
<p>In previous releases, that inner loop would be made atomic, but the outerloop would remain greedy (backtracking). From the XML comment generated by the source generator, we get this:</p>
<pre><code>/// ○ Loop greedily at least once.
///     ○ 1st capture group.
///         ○ Match a character in the set [a-z] atomically at least once.
///         ○ Match &#39; &#39;.
/// ○ Match a character in the set [A-Z].</code></pre>
<p>Now in .NET 10, we get this:</p>
<pre><code>/// ○ Loop atomically at least once.
///     ○ 1st capture group.
///         ○ Match a character in the set [a-z] atomically at least once.
///         ○ Match &#39; &#39;.
/// ○ Match a character in the set [A-Z].</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 9.0</td>
<td>573.4 ms</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 10.0</td>
<td>504.6 ms</td>
<td>0.88</td>
</tr>
</tbody>
</table>
<p>As with any optimization, auto-atomicity should never change observable behavior; it should just make things faster. And as such, every case where atomicity is automatically applied requires it being reasoned through to ensure that the optimization is of sound logic. In some cases, the optimization was written to be conservative, as the relevant reasoning through the logic wasn’t previously done. An example of that is addressed by <a href="https://github.com/dotnet/runtime/pull/118191">dotnet/runtime#118191</a>, which makes a few tweaks to how boundaries are handled in the auto-atomicity logic, removing some constraints that were put in place but which, as it turns out, are unnecessary. The core logic that implements the atomicity analysis is a method that looks like this:</p>
<pre><code>private static bool CanBeMadeAtomic(RegexNode node, RegexNode subsequent, ...)</code></pre>
<p><code>node</code> is the representation for the part of the regex that’s being considered for becoming atomic (e.g. a loop) and <code>subsequent</code> is what comes immediately after it in the pattern; the method then proceeds to validate <code>node</code> against <code>subsequent</code> to see whether it can prove there wouldn’t be any behavioral changes if <code>node</code> were made atomic. However, not all cases are sufficiently handled just by validating against <code>subsequent</code> itself. Consider a pattern like <code>a*b*\w</code>, where <code>node</code> represents <code>a*</code> and <code>subsequent</code> represents <code>b*</code>. <code>a</code> and <code>b</code> are obviously disjoint, and so <code>node</code> can be made atomic with regards to <code>subsequent</code>, but… here <code>subsequent</code> is also “nullable,” meaning it might successfully match 0 characters (the loop has a lower bound of 0). And in such a case, what comes after the <code>a*</code> won’t necessarily be a <code>b</code> but could be what comes after the <code>b*</code>, which here is a <code>\w</code>, which overlaps with <code>a</code>, and as such, it would be a behavioral change to make this into <code>(?&gt;a*)b*\w</code>. Consider an input of just <code>&#34;a&#34;</code>. With the original pattern, <code>a*</code> would successfully match the empty string with 0 iterations, <code>b*</code> would successfully match the empty string with 0 iterations, and then <code>\w</code> would successfully match the input <code>&#39;a&#39;</code>. But with the atomicized pattern, <code>(?&gt;a*)</code> would successfully match the input <code>&#39;a&#39;</code> with a single iteration, leaving nothing to match the <code>\w</code>. As such, when <code>CanBeMadeAtomic</code> detects that <code>subsequent</code> may be nullable and successfully match the empty string, it needs to iterate to also validate against what comes after <code>subsequent</code> (and possibly again and again if what comes next itself keeps being nullable).</p>
<p><code>CanBeMadeAtomic</code> already factored in boundaries (<code>\b</code> and <code>\B</code>), but it did so with the conservative logic that since a boundary is “zero-width” (meaning it doesn’t consume any input), it must always require checking what comes after it. But that’s not actually the case. Even though a boundary is zero-width, it still makes guarantees about what comes next: if the prior character is a word character, the next is guaranteed to not be with a successful match. And as such, we can safely make this more liberal and not require checking what comes next.</p>
<p>This last example also highlights an interesting aspect of this auto-atomicity optimization in general. There is nothing this optimization provides that the developer writing the regex in the first place couldn’t have done themselves. Instead of <code>a*b</code>, a developer can write <code>(?&gt;a*)b</code>. Instead of <code>[a-z]+(?= )</code>, a developer can write <code>(?&gt;[a-z]+)(?= )</code>. And so on. But when was the last time you explicitly added an atomic group to a regex you authored? Of the almost 20,000 regular expression patterns in the aforementioned database of real-world regexes sourced from nuget, care to guess how many include an explicitly written atomic group? The answer: ~100. It’s just not something developers in general think to do, so although the optimization transforms the user’s pattern into something they could have written themselves, it’s an incredibly valuable optimization, especially since now in .NET 10 over 70% of those patterns have at least one construct upgraded to be atomic.</p>
<p>The auto-atomicity optimization is an example of the optimizer removing unnecessary work. A key example of that, but certainly not the only example. Several additional PRs in .NET 10 have also eliminated unnecessary work, in other ways.</p>
<p><a href="https://github.com/dotnet/runtime/pull/118084">dotnet/runtime#118084</a> is a fun example of this, but to understand it, we first need to understand lookarounds. A “lookaround” is a regex construct that makes its contents zero-width. Whereas when a set like “[abc]” matches it consumes a single character from the input, or when a loop like “[abc]{3,5}” matches it’ll consume between 3-5 characters from the input, lookarounds (as with other zero-width constructs, like anchors) don’t consume anything. You wrap a lookaround around a regex expression, and it effectively makes the consumption temporary, e.g. if I wrap <code>[abc]{3,5}</code> in a positive lookahead as <code>(?=[abc]{3,5})</code>, that will end up performing the whole match for the 3-5 set characters, but those characters won’t remain consumed after exiting the lookaround; the lookaround is just performing a test to ensure the inner pattern matches but the position in the input is reset upon exiting the lookaround. This is again visualized easily by looking at the code emitted by the regex source generator for a pattern like <code>(?=[abc]{3,5})abc</code>:</p>
<pre><code>// Zero-width positive lookahead.
{
    int positivelookahead_starting_pos = pos;

    // Match a character in the set [a-c] atomically at least 3 and at most 5 times.
    {
        int iteration = 0;
        while (iteration &lt; 5 &amp;&amp; (uint)iteration &lt; (uint)slice.Length &amp;&amp; char.IsBetween(slice[iteration], &#39;a&#39;, &#39;c&#39;))
        {
            iteration++;
        }

        if (iteration &lt; 3)
        {
            return false; // The input didn&#39;t match.
        }

        slice = slice.Slice(iteration);
        pos += iteration;
    }

    pos = positivelookahead_starting_pos;
    slice = inputSpan.Slice(pos);
}

// Match the string &#34;abc&#34;.
if (!slice.StartsWith(&#34;abc&#34;))
{
    return false; // The input didn&#39;t match.
}</code></pre>
<p>We can see that the lookaround is caching the starting position, then proceeding to try to match the loop it contains, and if successful, resetting the matching position to what it was when the lookaround was entered, then continuing on to perform the match for what comes after the lookaround.</p>
<p>These examples have been for a particular flavor of lookaround, called a positive lookahead. There are four variations of lookarounds composed of two choices: positive vs negative, and lookahead vs lookbehind. Lookaheads validate the pattern starting from the current position and proceeding forwards (as matching typically is), while lookbehinds validate the pattern starting from just before the current position and extending backwards. Positive indicates that the pattern should match, while negative indicates that the pattern should not match. So, for example, the negative lookbehind <code>(?&lt;!\w)</code> will match if what comes before the current position is not a word character.</p>
<p>Negative lookarounds are particularly interesting, because, unlike every other regex construct, they guarantee that the pattern they contain <em>doesn’t</em> match. That also makes them special in other regards, in particular around capture groups. For a positive lookaround, even though they’re zero width, anything capture groups inside of the lookaround capture still remain to outside of the lookaround, e.g. <code>^(?=(abc))\1$</code>, which entails a backreference successfully matching what’s captured by the capture group inside of the positive lookahead, will successfully match the input <code>&#34;abc&#34;</code>. But because <em>negative</em> lookarounds guarantee their content doesn’t match, it would be counter-intuitive if anything captured inside of a negative lookaround persisted past the lookaround… so it doesn’t. The capture groups inside of a negative lookaround are still possibly meaningful, in particular if there’s a backreference also <em>inside of</em> the same lookaround that refers back to the capture group, e.g. the pattern <code>^(?!(ab)\1cd)ababc</code> is checking to see whether the input does not begin with <code>ababcd</code> but does begin with <code>ababc</code>. But if there’s no backreference, the capture group is useless, and we don’t need to do any work for it as part of processing the regex (work like remembering where the capture occurred). Such capture groups can be completely eliminated from the node tree as part of the optimization phase, and that’s exactly what <a href="https://github.com/dotnet/runtime/pull/118084">dotnet/runtime#118084</a> does. Just as developers often use backtracking constructs without thinking to make them atomic, developers also often use capture groups purely as a grouping mechanism without thinking of the possibility of making them non-capturing groups. Since captures in general need to persist to be examined by the <code>Match</code> object returned from a <code>Regex</code>, we can’t just eliminate all capture groups that aren’t used internally in the pattern, but we can for these negative lookarounds. Consider a pattern like <code>(?&lt;!(access|auth)\s)token</code>, which is looking for the word <code>&#34;token&#34;</code> when it’s <em>not</em> preceeded by <code>&#34;access &#34;</code> or <code>&#34;auth &#34;</code>; the developer here (me, in this case) did what’s fairly natural, putting a group around the alternation so that the <code>\s</code> that follows either word can be factored out (if it were instead <code>access|auth\s</code>, the whitespace set would only be in the second branch of the alternation and wouldn’t apply to the first). But my “simple” grouping here is actually a capture group by default; to get it to be non-capturing, I’d either need to write it as a non-capturing group, i.e. <code>(?&lt;!(?:access|auth)\s)token</code>, or I’d need to use <code>RegexOptions.ExplicitCapture</code>, which turns all non-named capture groups into non-capturing groups.</p>
<p>We can similarly remove other work related to lookarounds. As noted, positive lookarounds exist to transform any pattern into a zero-width pattern, i.e. don’t consume anything. That’s all they do. If the pattern being wrapped by the positive lookaround is already zero-width, the lookaround contributes nothing to the behavior of the expression and can be removed. So, for example, if you have <code>(?=$)</code>, that can be transformed into just <code>$</code>. That’s exactly what <a href="https://github.com/dotnet/runtime/pull/118091">dotnet/runtime#118091</a> does.</p>
<p><a href="https://github.com/dotnet/runtime/pull/118079">dotnet/runtime#118079</a> and <a href="https://github.com/dotnet/runtime/pull/118111">dotnet/runtime#118111</a> handle other transformations relative to zero-width assertions, in particular with regards to loops. For whatever reason, you’ll see developers wrapping zero-width assertions inside of loops, either making such assertions optional (e.g. <code>\b?</code>) or with some larger upper bound (e.g. <code>(?=abc)*</code>). But these zero-width assertions don’t consume anything; their sole purpose is to flag whether something is true or false at the current position. If you make such a zero-width assertion optional, then you’re saying “check whether it’s true or false, and then immediately ignore the answer, because both answers are valid”; as such, the whole expression can be removed as a nop. Similarly, if you wrap a loop with an upper bound greater than 1 around such an expression, you’re saying “check whether it’s true or false, now without changing anything check again, and check again, and check again.” There’s a common English expression that’s something along the lines of “insanity is doing the same thing over and over again and expecting different results.” That applies here. There may be behavioral benefits to invoking the zero-width assertion once, but repeating it beyond that is a pure waste: if it was going to fail, it would have failed the first time. Mostly. There’s one specific case where the difference is actually observable, and that has to do with an interesting feature of .NET regexes: capture groups track <em>all</em> matched captures, not just the last. Consider this program:</p>
<pre><code>// dotnet run -c Release -f net10.0

using System.Diagnostics;
using System.Text.RegularExpressions;

Match m = Regex.Match(&#34;abc&#34;, &#34;^(?=(\\w+)){3}abc$&#34;);
Debug.Assert(m.Success);

foreach (Group g in m.Groups)
{
    foreach (Capture c in g.Captures)
    {
        Console.WriteLine($&#34;Group: {g.Name}, Capture: {c.Value}&#34;);
    }
}</code></pre>
<p>If you run that, you may be surprised to see that capture group #1 (the explicit group I have inside of the lookahead) provides three capture values:</p>
<pre><code>Group: 0, Capture: abc
Group: 1, Capture: abc
Group: 1, Capture: abc
Group: 1, Capture: abc</code></pre>
<p>That’s because the loop around the positive lookahead does three iterations, each iteration matches <code>&#34;abc&#34;</code>, and each successful capture is persisted for subsequent inspection via the <code>Regex</code> APIs. As such, we can’t optimize any loop around zero-width assertions by lowering the upper bound from greater than 1 to 1; we can only do so if it doesn’t contain any captures. And that’s what these PRs do. Given a loop that wraps a zero-width assertion that does not contain a capture, if the lower bound of the loop is 0, the whole loop and its contents can be eliminated, and if the upper bound of the loop is greater than 1, the loop itself can be removed, leaving only its contents in its stead.</p>
<p>Any time work like this is eliminated, it’s easy to construct monstrous, misleading micro-benchmarks… but it’s also a lot of fun, so, I’ll allow myself it this time.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_input = new HttpClient().GetStringAsync(@&#34;https://www.gutenberg.org/cache/epub/3200/pg3200.txt&#34;).Result;
    private static readonly Regex s_regex = new Regex(@&#34;(?=.*\bTwain\b.*\bConnecticut\b)*.*Mark&#34;, RegexOptions.Compiled);

    [Benchmark]
    public int Count() =&gt; s_regex.Count(s_input);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 9.0</td>
<td>3,226.024 ms</td>
<td>1.000</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 10.0</td>
<td>6.605 ms</td>
<td>0.002</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/118083">dotnet/runtime#118083</a> is similar. “Repeaters” are a name for a regex loop that has the same lower and upper bound, such that the contents of the loop “repeats” that fixed number of times. Typically you’ll see these written out using the <code>{N}</code> syntax, e.g. <code>[abc]{3}</code> is a repeater that requires three characters, any of which can be <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, or <code>&#39;c&#39;</code>. But of course it could also be written out in long-form, just by manually repeating the contents, e.g. <code>[abc][abc][abc]</code>. Just as we saw how we can condense loops around zero-width assertions when specified in loop form, we can do the exact same thing when manually written out. So, for example, <code>\b\b</code> is the same as just <code>\b{2}</code>, which is just <code>\b</code>.</p>
<p>Another nice example of removing unnecessary work is <a href="https://github.com/dotnet/runtime/pull/118105">dotnet/runtime#118105</a>. Boundary assertions are used in many expressions, e.g. it’s quite common to see a simple pattern like <code>\b\w+\b</code>, which is trying to match an entire word. When the regex engine encounters such an assertion, historically it’s delegated to the <code>IsBoundary</code> helper shown earlier. There is, however, some subtle unnecessary work here, which is more obvious when you see what the regex source generator outputs for an expression like <code>\b\w+\b</code>. This is what the output looks like on .NET 9:</p>
<pre><code>// Match if at a word boundary.
if (!Utilities.IsBoundary(inputSpan, pos))
{
    return false; // The input didn&#39;t match.
}

// Match a word character atomically at least once.
{
    int iteration = 0;
    while ((uint)iteration &lt; (uint)slice.Length &amp;&amp; Utilities.IsWordChar(slice[iteration]))
    {
        iteration++;
    }

    if (iteration == 0)
    {
        return false; // The input didn&#39;t match.
    }

    slice = slice.Slice(iteration);
    pos += iteration;
}

// Match if at a word boundary.
if (!Utilities.IsBoundary(inputSpan, pos))
{
    return false; // The input didn&#39;t match.
}</code></pre>
<p>Pretty straightforward: match the boundary, consume as many word characters as possible, then again match a boundary. Except if you look back at the definition of <code>IsBoundary</code>, you’ll notice that it’s doing two checks, one against the previous character and one against the next character.</p>
<pre><code>internal static bool IsBoundary(ReadOnlySpan&lt;char&gt; inputSpan, int index)
{
    int indexM1 = index - 1;
    return ((uint)indexM1 &lt; (uint)inputSpan.Length &amp;&amp; RegexCharClass.IsBoundaryWordChar(inputSpan[indexM1])) !=
           ((uint)index &lt; (uint)inputSpan.Length &amp;&amp; RegexCharClass.IsBoundaryWordChar(inputSpan[index]));
}</code></pre>
<p>Now, look at that, and look back at the generated code, and look at this again, and back at the source generated code again. See anything unnecessary? When we perform the first boundary comparison, we are dutifully checking the previous character, which is necessary, but then we’re checking the current character, which is about to checked against <code>\w</code> by the subsequent <code>\w+</code> loop. Similarly for the second boundary check, we just finished matching <code>\w+</code>, which will have only successfully matched if there was at least one word character. While we still need to validate that the subsequent character is not a boundary character (there are two characters considered boundary characters that aren’t word characters), we don’t need to re-validate the previous character. So, <a href="https://github.com/dotnet/runtime/pull/118105">dotnet/runtime#118105</a> overhauls boundary handling in the compiler and source generator to emit customized boundary checks based on surrounding knowledge. If it can prove that the subsequent construct will validate that a character is a word character, then it only needs to validate that the previous character is not a boundary character; similarly, if it can prove that the previous construct will have already validated that a character is a word character, then it only needs to validate that the next character isn’t. This leads to this tweaked source generated code now on .NET 10:</p>
<pre><code>// Match if at a word boundary.
if (!Utilities.IsPreWordCharBoundary(inputSpan, pos))
{
    return false; // The input didn&#39;t match.
}

// Match a word character atomically at least once.
{
    int iteration = 0;
    while ((uint)iteration &lt; (uint)slice.Length &amp;&amp; Utilities.IsWordChar(slice[iteration]))
    {
        iteration++;
    }

    if (iteration == 0)
    {
        return false; // The input didn&#39;t match.
    }

    slice = slice.Slice(iteration);
    pos += iteration;
}

// Match if at a word boundary.
if (!Utilities.IsPostWordCharBoundary(inputSpan, pos))
{
    return false; // The input didn&#39;t match.
}</code></pre>
<p>Those <code>IsPreWordCharBoundary</code> and <code>IsPostWordCharBoundary</code> helpers are just half the checks in the main boundary helper. In cases where there are lots of boundary tests being performed, the reduced check count can add up.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_input = new HttpClient().GetStringAsync(@&#34;https://www.gutenberg.org/cache/epub/3200/pg3200.txt&#34;).Result;
    private static readonly Regex s_regex = new Regex(@&#34;\ba\b&#34;, RegexOptions.Compiled | RegexOptions.IgnoreCase);

    [Benchmark]
    public int CountStandaloneAs() =&gt; s_regex.Count(s_input);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>CountStandaloneAs</td>
<td>.NET 9.0</td>
<td>20.58 ms</td>
<td>1.00</td>
</tr>
<tr>
<td>CountStandaloneAs</td>
<td>.NET 10.0</td>
<td>19.25 ms</td>
<td>0.94</td>
</tr>
</tbody>
</table>
<p>The <code>Regex</code> optimizer is all about pattern recognition: it looks for sequences and shapes it recognizes and performs transforms over those to put them into a more efficiently-processable form. One example of this is with alternations around coalescable branches. Let’s say you have an alternation <code>a|e|i|o|u</code>. You could process that as an alternation, but it’s also much more efficiently represented and processed as the equivalent set <code>[aeiou]</code>. There is an optimization that does such transformations as part of handling alternations. However, through .NET 9, it only handled single characters and sets, but not negated sets. For example, it would transform <code>a|e|i|o|u</code> into <code>[aeiou]</code>, and it would transform <code>[aei]|[ou]</code> into <code>[aeiou]</code>, but it would not merge negations like <code>[^\n]</code>, otherwise known as <code>.</code> (when not in <code>RegexOptions.Singleline</code> mode). When developers want a set that represents all characters, there are various idioms they employ, such as <code>[\s\S]</code>, which says “this is a set of all whitespace and non-whitespace characters”, aka everything. Another common idiom is <code>\n|.</code>, which is the same as <code>\n|[^\n]</code>, which says “this is an alternation that matches either a newline or anything other than a newline”, aka also everything. Unfortunately, while examples like <code>[\d\D]</code> have been handled well, <code>.|\n</code> has not, because of the gap in the alternation optimization. <a href="https://github.com/dotnet/runtime/pull/118109">dotnet/runtime#118109</a> improves that, such that such “not” cases are mergable as part of the existing optimization. That takes a relatively expensive alternation and converts it into a super fast set check. And while, in general, set containment checks are very efficient, this one is as efficient as you can get, as it’s always true. We can see an example of this with a pattern intended to match C-style comment blocks.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private const string Input = &#34;&#34;&#34;
        /* This is a comment. */
        /* Another comment */
        /* Multi-line
           comment */
        &#34;&#34;&#34;;
    private static readonly Regex s_regex = new Regex(@&#34;/\*(?:.|\n)*?\*/&#34;, RegexOptions.Compiled);

    [Benchmark]
    public int Count() =&gt; s_regex.Count(Input);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 9.0</td>
<td>344.80 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 10.0</td>
<td>93.59 ns</td>
<td>0.27</td>
</tr>
</tbody>
</table>
<p>Note that there’s another change that helps .NET 10 here, <a href="https://github.com/dotnet/runtime/pull/118373">dotnet/runtime#118373</a>, though I hesitate to call it out as a performance improvement since it’s really more of a bug fix. As part of writing this post, these benchmark numbers were showing some oddities (it’s important in general to be skeptical of benchmark results and to investigate anything that doesn’t align with reason and expectations). The result of investigating was a one-word change that yielded significant speedups on this test, specifically when using <code>RegexOptions.Compiled</code> (the bug didn’t exist in the source generator). As part of handling lazy loops, there’s a special-case for when the lazy loop is around a set that matches any character, which, thanks to the previous PR, <code>(?:.|\n)</code> now does. That special-case recognizes that if the lazy loop matches anything, we can efficiently find the end of the lazy loop by searching for whatever comes after the loop (e.g. in this test, the loop is followed by the literal <code>&#34;*/&#34;</code>). Unfortunately, the helper that emits that <code>IndexOf</code> call was passed the wrong node from the pattern: it was being passed the object representing the <code>(?:.|\n)</code> any-set rather than the <code>&#34;*/&#34;</code> literal, which resulted in it emitting the equivalent of <code>IndexOfAnyInRange((char)0, &#39;\uFFFF&#39;)</code> rather than the equivalent of <code>IndexOf(&#34;*/&#34;)</code>. Oops. It was still functionally correct, in that the <code>IndexOfAnyInRange</code> call would successfully match the first character and the loop would re-evaluate from that location, but that means that rather than efficiently skipping using SIMD over a bunch of positions that couldn’t possibly match, we were doing non-trivial work for each and every position along the way.</p>
<p><a href="https://github.com/dotnet/runtime/pull/118087">dotnet/runtime#118087</a> represents another interesting transformation related to alternations. It’s very common to come across alternations with empty branches, possibly because that’s what the developer wrote, but more commonly as an outcome of other transformations that have happened. For example, given the pattern <code>\r\n|\r</code>, which is trying to match line endings that begin with <code>\r</code>, there is an optimization that will factor out a common prefix of all of the branches, producing the equivalent of <code>\r(?:\n|)</code>; in other words, <code>\r</code> followed by either a line feed or empty. Such an alternation is a perfectly valid representation for this concept, but there’s a more natural one: <code>?</code>. Behaviorally, this pattern is identical to <code>\r\n?</code>, and because the latter is more common and more canonical, the regex engine has more optimizations that recognize this loop-based form, for example coalescing with other loops, or auto-atomicity. As such, this PR finds all alternations of the form <code>X|</code> and transforms them into <code>X?</code>. Similarly, it finds all alternations of the form <code>|X</code> and transforms them into <code>X??</code>. The difference between <code>X|</code> and <code>|X</code> is whether <code>X</code> is tried first or empty is tried first; similarly, the difference between the greedy <code>X?</code> loop and the lazy <code>X??</code> loop is whether <code>X</code> is tried first or empty is tried first. The impact of this can be seen in the code generated for the previously cited example. Here is the source-generated code for the heart of the matching routine for <code>\r\n|\r</code> on .NET 9:</p>
<pre><code>// Match &#39;\r&#39;.
if (slice.IsEmpty || slice[0] != &#39;\r&#39;)
{
    return false; // The input didn&#39;t match.
}

// Match with 2 alternative expressions, atomically.
{
    int alternation_starting_pos = pos;

    // Branch 0
    {
        // Match &#39;\n&#39;.
        if ((uint)slice.Length &lt; 2 || slice[1] != &#39;\n&#39;)
        {
            goto AlternationBranch;
        }

        pos += 2;
        slice = inputSpan.Slice(pos);
        goto AlternationMatch;

        AlternationBranch:
        pos = alternation_starting_pos;
        slice = inputSpan.Slice(pos);
    }

    // Branch 1
    {      
        pos++;
        slice = inputSpan.Slice(pos);
    }

    AlternationMatch:;
}</code></pre>
<p>Now, here’s what’s produced on .NET 10:</p>
<pre><code>// Match &#39;\r&#39;.
if (slice.IsEmpty || slice[0] != &#39;\r&#39;)
{
    return false; // The input didn&#39;t match.
}

// Match &#39;\n&#39; atomically, optionally.
if ((uint)slice.Length &gt; (uint)1 &amp;&amp; slice[1] == &#39;\n&#39;)
{
    slice = slice.Slice(1);
    pos++;
}</code></pre>
<p>The optimizer recognized that the <code>\r\n|\r</code> was the same as <code>\r(?:\n|)</code>, which is the same as <code>\r\n?</code>, which is the same as <code>\r(?&gt;\n?)</code>, which it can produce much simplified code for, given that it no longer needs any backtracking.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_input = new HttpClient().GetStringAsync(@&#34;https://www.gutenberg.org/cache/epub/3200/pg3200.txt&#34;).Result;
    private static readonly Regex s_regex = new Regex(@&#34;ab|a&#34;, RegexOptions.Compiled);

    [Benchmark]
    public int Count() =&gt; s_regex.Count(s_input);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 9.0</td>
<td>23.35 ms</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 10.0</td>
<td>18.73 ms</td>
<td>0.80</td>
</tr>
</tbody>
</table>
<p>.NET 10 also features improvements to <code>Regex</code> that go beyond just this form of work elimination. <code>Regex</code>‘s matching routines are logically factored into two pieces: finding as quickly as possible the next place that could possibly match (<code>TryFindNextPossibleStartingPosition</code>), and then performing the full matching routine at that location (<code>TryMatchAtCurrentPosition</code>). It’s desirable that <code>TryFindNextPossibleStartingPosition</code> both does its work as quickly as possible while also significantly limiting the number of locations a full match should be performed. <code>TryFindNextPossibleStartingPosition</code>, for example, could operate very quickly just by always saying that the next index in the input should be tested, which would result in the full matching logic being performed at every index in the input; that’s not great for performance. Instead, the optimizer analyzes the pattern looking for things that would allow it to quickly search for viable starting locations, e.g. fixed strings or sets at known offsets in the pattern. Anchors are some of the most valuable things the optimizer can find, as they significantly inhibit the possible places matching is valid; the ideal pattern begins with a beginning anchor (<code>^</code>), which then means the only possible place matching can be successful is at index 0.</p>
<p>We previously discussed lookarounds, but as it turns out, until .NET 10, lookarounds weren’t factored into what <code>TryFindNextPossibleStartingPosition</code> should look for. <a href="https://github.com/dotnet/runtime/pull/112107">dotnet/runtime#112107</a> changes that. It teaches the optimizer when and how to explore positive lookaheads at the beginning of a pattern for constructs that could help it more efficiently find starting locations. For example, in .NET 9, for the pattern <code>(?=^)hello</code>, here’s what the source generator emits for <code>TryFindNextPossibleStartingPosition</code>:</p>
<pre><code>private bool TryFindNextPossibleStartingPosition(ReadOnlySpan&lt;char&gt; inputSpan)
{
    int pos = base.runtextpos;

    // Any possible match is at least 5 characters.
    if (pos &lt;= inputSpan.Length - 5)
    {
        // The pattern has the literal &#34;hello&#34; at the beginning of the pattern. Find the next occurrence.
        // If it can&#39;t be found, there&#39;s no match.
        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_indexOfString_hello_Ordinal);
        if (i &gt;= 0)
        {
            base.runtextpos = pos + i;
            return true;
        }
    }

    // No match found.
    base.runtextpos = inputSpan.Length;
    return false;
}</code></pre>
<p>The optimizer found the <code>&#34;hello&#34;</code> string in the pattern and is thus searching for that as part of finding the next possible place to do the full match. That would be excellent, if it weren’t for the lookahead that also says any match must happen at the beginning of the input. Now in .NET 10, we get this:</p>
<pre><code>private bool TryFindNextPossibleStartingPosition(ReadOnlySpan&lt;char&gt; inputSpan)
{
    int pos = base.runtextpos;

    // Any possible match is at least 5 characters.
    if (pos &lt;= inputSpan.Length - 5)
    {
        // The pattern leads with a beginning (\A) anchor.
        if (pos == 0)
        {
            return true;
        }
    }

    // No match found.
    base.runtextpos = inputSpan.Length;
    return false;
}</code></pre>
<p>That <code>pos == 0</code> check is critical, because it means we will only ever attempt the full match in one location and we can avoid the search that would happen even if we never found a good location to perform the match. Again, any time you eliminate work like this, you can construct tantalizing micro-benchmarks…</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_input = new HttpClient().GetStringAsync(@&#34;https://www.gutenberg.org/cache/epub/3200/pg3200.txt&#34;).Result;
    private static readonly Regex s_regex = new Regex(@&#34;(?=^)hello&#34;, RegexOptions.Compiled);

    [Benchmark]
    public int Count() =&gt; s_regex.Count(s_input);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 9.0</td>
<td>2,383,784.95 ns</td>
<td>1.000</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 10.0</td>
<td>17.43 ns</td>
<td>0.000</td>
</tr>
</tbody>
</table>
<p>That same PR also improved optimizations over alternations. It’s already the case that the branches of alternations are analyzed looking for common prefixes that can be factored out. For example, given the pattern <code>abc|abd</code>, the optimizer will spot the shared <code>&#34;ab&#34;</code> prefix at the beginning of each branch and factor that out, resulting in <code>ab(?:c|d)</code>, and will then see that each branch of the remaining alternation are individual characters, which it can convert into a set, <code>ab[cd]</code>. If, however, the branches began with anchors, these optimizations wouldn’t be applied. Given the pattern <code>^abc|^abd</code>, the code generators would end up emitting this exactly as it’s written, with an alternation with two branches, the first branch checking for the beginning and then matching <code>&#34;abc&#34;</code>, the second branch also checking for the beginning and then matching <code>&#34;abd&#34;</code>. Now in .NET 10, the anchor can be factored out, such that <code>^abc|^abd</code> ends up being rewritten as <code>^ab[cd]</code>.</p>
<p>As a small tweak, <a href="https://github.com/dotnet/runtime/pull/112065">dotnet/runtime#112065</a> also helps improve the source generated code for repeaters by using a more efficient searching routine. Let’s take the pattern <code>[0-9a-f]{32}</code> as an example. This is looking for sequences of 32 lowercase hex digits. In .NET 9, the implementation of that ends up looking like this:</p>
<pre><code>// Match a character in the set [0-9a-f] exactly 32 times.
{
    if ((uint)slice.Length &lt; 32)
    {
        return false; // The input didn&#39;t match.
    }

    if (slice.Slice(0, 32).IndexOfAnyExcept(Utilities.s_asciiHexDigitsLower) &gt;= 0)
    {
        return false; // The input didn&#39;t match.
    }
}</code></pre>
<p>Simple, clean, fairly concise, and utilizing the vectorized <code>IndexOfAnyExcept</code> to very efficiently validate that the whole sequence of 32 characters are lowercase hex. We can do a tad bit better, though. The <code>IndexOfAnyExcept</code> method not only needs to find whether the span contains something other than one of the provided values, it needs to specify the index at which that found value occurs. That’s only a few instructions, but it’s a few unnecessary instructions, since here that exact index isn’t utilized… the implementation only cares whether it’s <code>&gt;= 0</code>, meaning whether anything was found or not. As such, we can instead use the <code>Contains</code> variant of this method, which doesn’t need to spend extra cycles determining the exact index. Now in .NET 10, this is generated:</p>
<pre><code>// Match a character in the set [0-9a-f] exactly 32 times.
if ((uint)slice.Length &lt; 32 || slice.Slice(0, 32).ContainsAnyExcept(Utilities.s_asciiHexDigitsLower))
{
    return false; // The input didn&#39;t match.
}</code></pre>
<p>Finally, the .NET 10 SDK includes a new analyzer related to <code>Regex</code>. It’s oddly common to see code that determines whether an input matches a <code>Regex</code> written like this: <code>Regex.Match(...).Success</code>. While functionally correct, that’s much more expensive than <code>Regex.IsMatch(...)</code>. For all of the engines, <code>Regex.Match(...)</code> requires allocating a new <code>Match</code> object and supporting data structures (except when there isn’t a match found, in which case it’s able to use an empty singleton); in contrast, <code>IsMatch</code> doesn’t need to allocate such an instance because it doesn’t need to return such an instance (as an implementation detail, it may still use a <code>Match</code> object, but it can reuse one rather than creating a new one each time). It can also avoid other inefficiencies. <code>RegexOptions.NonBacktracking</code> is “pay-for-play” with the information it needs to gather. Determining just <em>whether</em> there’s a match is cheaper than determining exactly where the match begins and ends, which is cheaper still than determining all of the captures that make up that match. <code>IsMatch</code> is thus the cheapest, only needing to determine that there is a match, not exactly where it is or what the exact captures are, whereas <code>Match</code> needs to determine all of that. <code>Regex.Matches(...).Count</code> is similar; it’s having to gather all of the relevant details and allocate a whole bunch of objects, whereas <code>Regex.Count(...)</code> can do so in a much more efficient manner. <a href="https://github.com/dotnet/roslyn-analyzers/pull/7547">dotnet/roslyn-analyzers#7547</a> adds CA1874 and CA1875, which flag these cases and recommend use of <code>IsMatch</code> and <code>Count</code>, respectively.</p>
<p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/CA1874.png" alt="Analyzer and fixer for CA1874"/></p>
<p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/CA1875.png" alt="Analyzer and fixer for CA1875"/></p>
<pre><code>// dotnet run -c Release -f net10.0 --filter **

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_input = new HttpClient().GetStringAsync(@&#34;https://www.gutenberg.org/cache/epub/3200/pg3200.txt&#34;).Result;
    private static readonly Regex s_regex = new Regex(@&#34;\b\w+\b&#34;, RegexOptions.NonBacktracking);

    [Benchmark(Baseline = true)]
    public int MatchesCount() =&gt; s_regex.Matches(s_input).Count;

    [Benchmark]
    public int Count() =&gt; s_regex.Count(s_input);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>MatchesCount</td>
<td>680.4 ms</td>
<td>1.00</td>
<td>665530176 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>219.0 ms</td>
<td>0.32</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p><code>Regex</code> is one form of searching, but there are other primitives and helpers throughout .NET for various forms of searching, and they’ve seen meaningful improvements in .NET 10, as well.</p>
<h3>SearchValues</h3>
<p>When discussing performance improvements in .NET 8, I called out two changes that were my favorites. The first was dynamic PGO. The second was <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#searchvalues"><code>SearchValues</code></a>.</p>
<p><code>SearchValues</code> provides a mechanism for precomputing optimal strategies for searching. .NET 8 introduced overloads of <code>SearchValues.Create</code> that produce <code>SearchValues&lt;byte&gt;</code> and <code>SearchValues&lt;char&gt;</code>, and corresponding overloads of <code>IndexOfAny</code> and friends that accept such instances. If there’s a set of values you’ll be searching for over and over and over, you can create one of these instances once, cache it, and then use it for all subsequent searches for those values, e.g.</p>
<pre><code>private static readonly SearchValues&lt;char&gt; s_validBase64Chars = SearchValues.Create(&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#34;);

internal static bool IsValidBase64(ReadOnlySpan&lt;char&gt; input) =&gt;
    input.ContainsAnyExcept(s_validBase64Chars);</code></pre>
<p>There are a plethora of different implementations used by <code>SearchValues&lt;T&gt;</code> behind the scenes, each of which is selected and configured based on the <code>T</code> and the exact nature of the target values for which we’re searching. <a href="https://github.com/dotnet/runtime/pull/106900">dotnet/runtime#106900</a> adds another, which both helps to shave off several instructions in the core vectorized search loop, and helps to highlight just how nuanced these different algorithms can be. Previously, if four target <code>byte</code> values were provided, and they weren’t in a contiguous range, <code>SearchValues.Create</code> would choose an implementation that just uses four vectors, one per target byte, and does four comparisons (one against each target vector) for each input vector being tested. However, there’s already a specialization that’s used for more than five target bytes when all of the target bytes are ASCII. This PR allows that specialization to be used for both four or five targets when the lower nibble (the bottom four bits) of each of the targets is unique, and in doing so, it becomes several instructions cheaper: rather than doing four comparisons, it can do a single shuffle and equality check.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly byte[] s_haystack = new HttpClient().GetByteArrayAsync(@&#34;https://www.gutenberg.org/cache/epub/3200/pg3200.txt&#34;).Result;
    private static readonly SearchValues&lt;byte&gt; s_needle = SearchValues.Create(&#34;\0\r&amp;&lt;&#34;u8);

    [Benchmark]
    public int Count()
    {
        int count = 0;

        ReadOnlySpan&lt;byte&gt; haystack = s_haystack.AsSpan();
        int pos;
        while ((pos = haystack.IndexOfAny(s_needle)) &gt;= 0)
        {
            count++;
            haystack = haystack.Slice(pos + 1);
        }

        return count;
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Count</td>
<td>.NET 9.0</td>
<td>3.704 ms</td>
<td>1.00</td>
</tr>
<tr>
<td>Count</td>
<td>.NET 10.0</td>
<td>2.668 ms</td>
<td>0.72</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/107798">dotnet/runtime#107798</a> improves another such algorithm, when AVX512 is available. One of the fallback strategies used by <code>SearchValues.Create&lt;char&gt;</code> is a vectorized “probabilistic map”, basically a Bloom filter. It has a bitmap that stores a bit for each <code>byte</code> of the <code>char</code>; when testing to see whether the <code>char</code> is in the target set, it checks to see whether the bit for each of the <code>char</code>‘s <code>byte</code>s is set. If at least one isn’t set, the <code>char</code> definitely isn’t in the target set. If both are set, more validation will need to be done to determine the actual inclusion of that value in the set. This can make it very efficient to rule out large amounts of input that definitely are not in the set and then only spend more effort on input that might be. The implementation involves various shuffle, shift, and permute operations, and this change is able to use a better set of instructions that reduce the number needed.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly SearchValues&lt;char&gt; s_searchValues = SearchValues.Create(&#34;ßäöüÄÖÜ&#34;);
    private string _input = new string(&#39;\n&#39;, 10_000);

    [Benchmark]
    public int IndexOfAny() =&gt; _input.AsSpan().IndexOfAny(s_searchValues);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>IndexOfAny</td>
<td>.NET 9.0</td>
<td>437.7 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>IndexOfAny</td>
<td>.NET 10.0</td>
<td>404.7 ns</td>
<td>0.92</td>
</tr>
</tbody>
</table>
<p>While .NET 8 introduced support for <code>SearchValues&lt;byte&gt;</code> and <code>SearchValues&lt;char&gt;</code>, .NET 9 introduced support for <code>SearchValues&lt;string&gt;</code>. <code>SearchValues&lt;string&gt;</code> is used a bit differently from <code>SearchValues&lt;byte&gt;</code> and <code>SearchValues&lt;char&gt;</code>; whereas <code>SearchValues&lt;byte&gt;</code> is used to search for target <code>byte</code>s within a collection of <code>byte</code>s and <code>SearchValues&lt;char&gt;</code> is used to search for target <code>char</code>s within a collection of <code>char</code>s, <code>SearchValues&lt;string&gt;</code> is used to search for target <code>string</code>s within a single <code>string</code> (or span of <code>char</code>s). In other words, it’s a multi-substring search. Let’s say you have the regular expression <code>(?i)hello|world</code>; that is specifying that it should look for either “hello” or “world” in a case-insensitive manner; the <code>SearchValues</code> equivalent of that is <code>SearchValues.Create([&#34;hello&#34;, &#34;world&#34;], StringComparison.OrdinalIgnoreCase)</code> (in fact, if you specify that pattern, the <code>Regex</code> compiler and source generator will use such a <code>SearchValues.Create</code> call under the covers in order to optimize the search).</p>
<p><code>SearchValues&lt;string&gt;</code> also gets better in .NET 10. A key algorithm used by <code>SearchValues&lt;string&gt;</code> whenever possible and relevant is called “Teddy,” and enables performing a vectorized search for multiple substrings. In its core processing loop, when using AVX512, there are two instructions, a <code>PermuteVar8x64x2</code> and an <code>AlignRight</code>; <a href="https://github.com/dotnet/runtime/pull/107819">dotnet/runtime#107819</a> recognizes that those can be replaced by a single <code>PermuteVar64x8x2</code>. Similarly, when on Arm64, <a href="https://github.com/dotnet/runtime/pull/118110">dotnet/runtime#118110</a> plays the instructions game and replaces a use of <code>ExtractNarrowingSaturateUpper</code> with the slightly cheaper <code>UnzipEven</code>.</p>
<p><code>SearchValues&lt;string&gt;</code> is also able to optimize searching for a single string, spending more time to come up with optimal search parameters than does a simpler <code>IndexOf(string, StringComparison)</code> call. Similar to the approach with the probabilistic maps employed earlier, the vectorized search can yield false positives that then need to be weeded out. In some cases by construction, however, we know that false positives aren’t possible; <a href="https://github.com/dotnet/runtime/pull/108368">dotnet/runtime#108368</a> extends an existing optimization that was case-sensitive only to also apply in some case-insensitive uses, such that we can avoid doing the extra validation step in more cases. For the candidate verification that remains, <a href="https://github.com/dotnet/runtime/pull/108365">dotnet/runtime#108365</a> also significantly reduces overhead in a variety of cases, including adding specialized handling for needles (the things being searched for) of up to 16 characters (previously it was only up to 8), and precomputing more information to make the verification faster.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(@&#34;https://www.gutenberg.org/cache/epub/3200/pg3200.txt&#34;).Result;

    private static readonly Regex s_the = new(&#34;the&#34;, RegexOptions.IgnoreCase | RegexOptions.Compiled);
    private static readonly Regex s_something = new(&#34;something&#34;, RegexOptions.IgnoreCase | RegexOptions.Compiled);

    [Benchmark]
    public int CountThe() =&gt; s_the.Count(s_haystack);

    [Benchmark]
    public int CountSomething() =&gt; s_something.Count(s_haystack);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>CountThe</td>
<td>.NET 9.0</td>
<td>9.881 ms</td>
<td>1.00</td>
</tr>
<tr>
<td>CountThe</td>
<td>.NET 10.0</td>
<td>7.799 ms</td>
<td>0.79</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CountSomething</td>
<td>.NET 9.0</td>
<td>2.466 ms</td>
<td>1.00</td>
</tr>
<tr>
<td>CountSomething</td>
<td>.NET 10.0</td>
<td>2.027 ms</td>
<td>0.82</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/118108">dotnet/runtime#118108</a> also adds a “packed” variant of the single-string implementation, meaning it’s able to handle common cases like ASCII more efficiently by ignoring a character’s upper zero byte in order to fit twice as much into a vector.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private static readonly string s_haystack = string.Concat(Enumerable.Repeat(&#34;Sherlock Holm_s&#34;, 8_000));
    private static readonly SearchValues&lt;string&gt; s_needles = SearchValues.Create([&#34;Sherlock Holmes&#34;], StringComparison.OrdinalIgnoreCase);

    [Benchmark] 
    public bool ContainsAny() =&gt; s_haystack.AsSpan().ContainsAny(s_needles);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>ContainsAny</td>
<td>.NET 9.0</td>
<td>58.41 us</td>
<td>1.00</td>
</tr>
<tr>
<td>ContainsAny</td>
<td>.NET 10.0</td>
<td>16.32 us</td>
<td>0.28</td>
</tr>
</tbody>
</table>
<h3>MemoryExtensions</h3>
<p>The searching improvements continue beyond <code>SearchValues</code>, of course. Prior to .NET 10, the <code>MemoryExtensions</code> class already had a wealth of support for searching and manipulating spans, with extension methods like <code>IndexOf</code>, <code>IndexOfAnyExceptInRange</code>, <code>ContainsAny</code>, <code>Count</code>, <code>Replace</code>, <code>SequenceCompare</code>, and more (the set was further extended as well by <a href="https://github.com/dotnet/runtime/pull/112951">dotnet/runtime#112951</a>, which added <code>CountAny</code> and <code>ReplaceAny</code>), but the vast majority of these were limited to work with <code>T</code> types constrained to be <code>IEquatable&lt;T&gt;</code>. And in practice, many of the types you want to search do in fact implement <code>IEquatable&lt;T&gt;</code>. However, you might be in a generic context with an unconstrained <code>T</code>, such that even if the <code>T</code> used to instatiate the generic type or method is equatable, it’s not evident in the type system and thus the <code>MemoryExtensions</code> method couldn’t be used. And of course there are scenarios where you want to be able to supply a different comparison routine. Both of these scenarios show up, for example, in the implementation of LINQ’s <code>Enumerable.Contains</code>; if the source <code>IEnumerable&lt;TSource&gt;</code> is actually something we could treat as a span, like <code>TSource[]</code> or <code>List&lt;TSource&gt;</code>, it’d be nice to be able to just delegate to the optimized <code>MemoryExtensions.Contains&lt;T&gt;</code>, but a) <code>Enumerable.Contains</code> doesn’t constrain its <code>TSource : IEquatable&lt;TSource&gt;</code>, and b) <code>Enumerable.Contains</code> accepts an optional comparer.</p>
<p>To address this, <a href="https://github.com/dotnet/runtime/pull/110197">dotnet/runtime#110197</a> adds ~30 new overloads to the <code>MemoryExtensions</code> class. These overloads all parallel existing methods, but remove the <code>IEquatable&lt;T&gt;</code> (or <code>IComparable&lt;T&gt;</code>) constraint on the generic method parameter and accept an optional <code>IEqualityComparer&lt;T&gt;?</code> (or <code>IComparer&lt;T&gt;</code>). When no comparer or a default comparer is supplied, they can fall back to using the same vectorized logic for relevant types, and otherwise can provide as optimal an implementation as they can muster, based on the nature of <code>T</code> and the supplied comparer.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private IEnumerable&lt;int&gt; _data = Enumerable.Range(0, 1_000_000).ToArray();

    [Benchmark]
    public bool Contains() =&gt; _data.Contains(int.MaxValue, EqualityComparer&lt;int&gt;.Default);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Contains</td>
<td>.NET 9.0</td>
<td>213.94 us</td>
<td>1.00</td>
</tr>
<tr>
<td>Contains</td>
<td>.NET 10.0</td>
<td>67.86 us</td>
<td>0.32</td>
</tr>
</tbody>
</table>
<p>(It’s also worth highlighting that with the “first-class” span support in C# 14, many of these extensions from <code>MemoryExtensions</code> now naturally show up directly on types like <code>string</code>.)</p>
<p>This kind of searching often shows up as part of other APIs. For example, encoding APIs often need to first find something to be encoded, and that searching can be accelerated by using one of these efficiently implemented search APIs. There are dozens and dozens of existing examples of that throughout the core libraries, many of the places using <code>SearchValues</code> or these various <code>MemoryExtensions</code> methods. <a href="https://github.com/dotnet/runtime/pull/110574">dotnet/runtime#110574</a> adds another, speeding up <code>string.Normalize</code>‘s argument validation. The current implementation walks character by character looking for the first surrogate. The new implementation gives that a jump start by using <code>IndexOfAnyInRange</code>.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private string _input = &#34;This is a test. This is only a test. Nothing to see here. \u263A\uFE0F&#34;;

    [Benchmark]
    public string Normalize() =&gt; _input.Normalize();
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Normalize</td>
<td>.NET 9.0</td>
<td>104.93 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Normalize</td>
<td>.NET 10.0</td>
<td>88.94 ns</td>
<td>0.85</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/110478">dotnet/runtime#110478</a> similarly updates <code>HttpUtility.UrlDecode</code> to use the vectorized <code>IndexOfAnyInRange</code>. It also avoids allocating the resulting <code>string</code> if nothing needs to be decoded.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Web;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public string UrlDecode() =&gt; HttpUtility.UrlDecode(&#34;aaaaabbbbb%e2%98%ba%ef%b8%8f&#34;);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>UrlDecode</td>
<td>.NET 9.0</td>
<td>59.42 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>UrlDecode</td>
<td>.NET 10.0</td>
<td>54.26 ns</td>
<td>0.91</td>
</tr>
</tbody>
</table>
<p>Similarly, <a href="https://github.com/dotnet/runtime/pull/114494">dotnet/runtime#114494</a> employs <code>SearchValues</code> in <code>OptimizedInboxTextEncoder</code>, which is the core implementation that backs the various encoders like <code>JavaScriptEncoder</code> and <code>HtmlEncoder</code> in the <code>System.Text.Encodings.Web</code> library.</p>
<h2>JSON</h2>
<p>JSON is at the heart of many different domains, having become the lingua franca of data interchange on the web. With <code>System.Text.Json</code> as the recommended library for working with JSON in .NET, it is constantly evolving to meet additional performance requirements. .NET 10 sees it updated with both improvements to the performance of existing methods as well as new methods specifically geared towards helping with performance.</p>
<p>The <code>JsonSerializer</code> type is layered on top of the lower-level <code>Utf8JsonReader</code> and <code>Utf8JsonWriter</code> types. When serializing, <code>JsonSerializer</code> needs an instance of <code>Utf8JsonWriter</code>, which is a <code>class</code>, and any associated objects, such as an <code>IBufferWriter</code> instance. For any temporary buffers it requires, it’ll use rented buffers from <code>ArrayPool&lt;byte&gt;</code>, but for these helper objects, it maintains its own cache, to avoid needing to recreate them at very high frequencies. That cache was being used for all asynchronous streaming serialization operations, but as it turns out, it wasn’t being used for synchronous streaming serialization operations. <a href="https://github.com/dotnet/runtime/pull/112745">dotnet/runtime#112745</a> fixes that to make the use of the cache consistent, avoiding these intermediate allocations.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.Json;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private Data _data = new();
    private MemoryStream _stream = new();

    [Benchmark]
    public void Serialize()
    {
        _stream.Position = 0;
        JsonSerializer.Serialize(_stream, _data);
    }

    public class Data
    {
        public int Value1 { get; set; }
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serialize</td>
<td>.NET 9.0</td>
<td>115.36 ns</td>
<td>1.00</td>
<td>176 B</td>
<td>1.00</td>
</tr>
<tr>
<td>Serialize</td>
<td>.NET 10.0</td>
<td>77.73 ns</td>
<td>0.67</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>Earlier when discussing collections, it was noted that <code>OrderedDictionary&lt;TKey, TValue&gt;</code> now exposes overloads of methods like <code>TryAdd</code> that return the relevant item’s index, which then allows subsequent access to avoid the more costly key-based lookup. As it turns out, <code>JsonObject</code>‘s indexer needs to do that, first indexing into the dictionary by key, doing some checks, and then indexing again. It’s now been updated to use these new overloads. As those lookups typically dominate the cost of using the setter, this can upwards of double throughput of <code>JsonObject</code>‘s indexer:</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.Json.Nodes;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private JsonObject _obj = new();

    [Benchmark]
    public void Set() =&gt; _obj[&#34;key&#34;] = &#34;value&#34;;
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set</td>
<td>.NET 9.0</td>
<td>40.56 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Set</td>
<td>.NET 10.0</td>
<td>16.96 ns</td>
<td>0.42</td>
</tr>
</tbody>
</table>
<p>Most of the improvements in <code>System.Text.Json</code>, however, are actually via new APIs. This same “avoid a double lookup” issue shows up in other places, for example wanting to add a property to a <code>JsonObject</code> but only if it doesn’t yet exist. With <a href="https://github.com/dotnet/runtime/pull/111229">dotnet/runtime#111229</a> from <a href="https://github.com/Flu">@Flu</a>, that’s addressed with a new <code>TryAdd</code> method (as well as a <code>TryAdd</code> overload and an overload of the existing <code>TryGetPropertyValue</code> that, as with <code>OrderedDictionary&lt;&gt;</code>, returns the index of the property).</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.Json.Nodes;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private JsonObject _obj = new();
    private JsonNode _value = JsonValue.Create(&#34;value&#34;);

    [Benchmark(Baseline = true)]
    public void NonOverwritingSet_Manual()
    {
        _obj.Remove(&#34;key&#34;);
        if (!_obj.ContainsKey(&#34;key&#34;))
        {
            _obj.Add(&#34;key&#34;, _value);
        }
    }

    [Benchmark]
    public void NonOverwritingSet_TryAdd()
    {
        _obj.Remove(&#34;key&#34;);
        _obj.TryAdd(&#34;key&#34;, _value);
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>NonOverwritingSet_Manual</td>
<td>16.59 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>NonOverwritingSet_TryAdd</td>
<td>14.31 ns</td>
<td>0.86</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/109472">dotnet/runtime#109472</a> from <a href="https://github.com/karakasa">@karakasa</a> also imbues <code>JsonArray</code> with new <code>RemoveAll</code> and <code>RemoveRange</code> methods. In addition to the usability benefits these can provide, they have the same performance benefits they have on <code>List&lt;T&gt;</code> (which is not a coincidence, given that <code>JsonArray</code> is, as an implementation detail, a wrapper for a <code>List&lt;JsonNode?&gt;</code>). Removing “incorrectly” from a <code>List&lt;T&gt;</code> can end up being an <code>O(N^2)</code> endeavor, e.g. when I run this:</p>
<pre><code>// dotnet run -c Release -f net10.0

using System.Diagnostics;

for (int i = 100_000; i &lt; 700_000; i += 100_000)
{
    List&lt;int&gt; items = Enumerable.Range(0, i).ToList();

    Stopwatch sw = Stopwatch.StartNew();
    while (items.Count &gt; 0)
    {
        items.RemoveAt(0); // uh oh
    }
    Console.WriteLine($&#34;{i} =&gt; {sw.Elapsed}&#34;);
}</code></pre>
<p>I get output like this:</p>
<pre><code>100000 =&gt; 00:00:00.2271798
200000 =&gt; 00:00:00.8328727
300000 =&gt; 00:00:01.9820088
400000 =&gt; 00:00:03.9242008
500000 =&gt; 00:00:06.9549009
600000 =&gt; 00:00:11.1104903</code></pre>
<p>Note how as the list length grows linearly, the elapsed time is growing non-linearly. That’s primarily because each <code>RemoveAt(0)</code> is requiring the entire remainder of the list to shift down, which is <code>O(N)</code> in the length of the list. That means we get <code>N + (N-1) + (N-2) + ... + 1</code> operations, which is <code>N(N+1)/2</code>, which is <code>O(N^2)</code>. Both <code>RemoveRange</code> and <code>RemoveAll</code> are able to avoid those costs by doing the shifting only once per element. Of course, even without such methods, I could have written my previous removal loop in a way that keeps it linear, namely by repeatedly removing the last element rather than the first (and, of course, if I <em>really</em> intended on removing everything, I could have just used <code>Clear</code>). Typical use, however, ends up removing a smattering of elements, and being able to just delegate and not worry about accidentally incurring a non-linear overhead is helpful.</p>
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.Json.Nodes;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private JsonArray _arr;

    [IterationSetup]
    public void Setup() =&gt;
        _arr = new JsonArray(Enumerable.Range(0, 100_000).Select(i =&gt; (JsonNode)i).ToArray());

    [Benchmark]
    public void Manual()
    {
        int i = 0;
        while (i &lt; _arr.Count)
        {
            if (_arr[i]!.GetValue&lt;int&gt;() % 2 == 0)
            {
                _arr.RemoveAt(i);
            }
            else
            {
                i++;
            }
        }
    }

    [Benchmark]
    public void RemoveAll() =&gt; _arr.RemoveAll(static n =&gt; n!.GetValue&lt;int&gt;() % 2 == 0);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>Manual</td>
<td>355.230 ms</td>
<td>–</td>
</tr>
<tr>
<td>RemoveAll</td>
<td>2.022 ms</td>
<td>24 B</td>
</tr>
</tbody>
</table>
<p>(Note that while <code>RemoveAll</code> in this micro-benchmark is more than 150x faster, it does have that small allocation that the manual implementation doesn’t. That’s due to a closure in the implementation while delegating to <code>List&lt;T&gt;.RemoveAll</code>. This could be avoided in the future if necessary.)</p>
<p>Another frequently-requested new method is from <a href="https://github.com/dotnet/runtime/pull/116363">dotnet/runtime#116363</a>, which adds new <code>Parse</code> methods to <code>JsonElement</code>. If a developer wants a <code>JsonElement</code> and only needs it temporarily, the most efficient mechanism available today is still the right answer: <code>Parse</code> a <code>JsonDocument</code>, use its <code>RootElement</code>, and then <em>only</em> when done with the <code>JsonElement</code>, dispose of the <code>JsonDocument</code>, e.g.</p>
<pre><code>using (JsonDocument doc = JsonDocument.Parse(json))
{
    DoSomething(doc.RootElement);
}</code></pre>
<p>That, however, is really only viable when the <code>JsonElement</code> is used in a scoped manner. If a developer needs to hand out the <code>JsonElement</code>, they’re left with three options:</p>
<ol>
<li><code>Parse</code> into a <code>JsonDocument</code>, clone its <code>RootElement</code>, dispose of the <code>JsonDocument</code>, hand out the clone. While using <code>JsonDocument</code> is good for the temporary case, making a clone like this entails a fair bit of overhead:
<pre><code>JsonElement clone;
using (JsonDocument doc = JsonDocument.Parse(json))
{
    clone = doc.RootElement.Clone();
}
return clone;</code></pre>
</li>
<li><code>Parse</code> into a <code>JsonDocument</code> and just hand out its <code>RootElement</code>. Please <em>do not do this</em>! <code>JsonDocument.Parse</code> creates a <code>JsonDocument</code> that’s backed by an array from the <code>ArrayPool&lt;&gt;</code>. If you don’t <code>Dispose</code> of the <code>JsonDocument</code> in this case, an array will be rented and then never returned to the pool. That’s not the end of the world; if someone else requests an array from the pool and the pool doesn’t have one cached to give them, it’ll just manufacture one, so eventually the pool’s arrays will be replenished. But the arrays in the pool are generally “more valuable” than others, because they’ve generally been around longer, and are thus more likely to be in higher generations. By using an <code>ArrayPool</code> array rather than a new array for a shorter-lived <code>JsonDocument</code>, you’re more likely throwing away an array that’ll have net more impact on the overall system. The impact of that is not easily seen in a micro-benchmark.
<pre><code>return JsonDocument.Parse(json).RootElement; // please don&#39;t do this</code></pre>
</li>
<li>Use <code>JsonSerializer</code> to deserialize a <code>JsonElement</code>. This is a simple and reasonable one-liner, but it does invoke the <code>JsonSerializer</code> machinery, which brings in more overhead.
<pre><code>return JsonSerializer.Deserialize&lt;JsonElement&gt;(json);</code></pre>
</li>
</ol>
<p>Now in .NET 10, there’s a fourth option:</p>
<ul>
<li>Use <code>JsonElement.Parse</code>. This is the right answer. Use this instead of (1), (2), or (3).
<pre><code>//  dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.Json;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private const string JsonString = &#34;&#34;&#34;{ &#34;name&#34;: &#34;John&#34;, &#34;age&#34;: 30, &#34;city&#34;: &#34;New York&#34; }&#34;&#34;&#34;;

    [Benchmark]
    public JsonElement WithClone()
    {
        using JsonDocument d = JsonDocument.Parse(JsonString);
        return d.RootElement.Clone();
    }

    [Benchmark]
    public JsonElement WithoutClone() =&gt;
        JsonDocument.Parse(JsonString).RootElement; // please don&#39;t do this in production code

    [Benchmark]
    public JsonElement WithDeserialize() =&gt;
        JsonSerializer.Deserialize&lt;JsonElement&gt;(JsonString);

    [Benchmark]
    public JsonElement WithParse() =&gt;
        JsonElement.Parse(JsonString);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>WithClone</td>
<td>303.7 ns</td>
<td>344 B</td>
</tr>
<tr>
<td>WithoutClone</td>
<td>249.6 ns</td>
<td>312 B</td>
</tr>
<tr>
<td>WithDeserialize</td>
<td>397.3 ns</td>
<td>272 B</td>
</tr>
<tr>
<td>WithParse</td>
<td>261.9 ns</td>
<td>272 B</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>With JSON being used as an encoding for many modern protocols, streaming large JSON payloads has become very common. And for most use cases, it’s already possible to stream JSON well with <code>System.Text.Json</code>. However, in previous releases there wasn’t been a good way to stream partial string properties; string properties had to have their values written in one operation. If you’ve got small strings, that’s fine. If you’ve got really, really large strings, and those strings are lazily-produced in chunks, however, you ideally want the ability to write those chunks of the property as you have them, rather than needing to buffer up the value in its entirety. <a href="https://github.com/dotnet/runtime/pull/101356">dotnet/runtime#101356</a> augmented <code>Utf8JsonWriter</code> with a <code>WriteStringValueSegment</code> method, which enables such partial writes. That addresses the majority case, however there’s a very common case where additional encoding of the value is desirable, and an API that automatically handles that encoding helps to be both efficient and easy. These modern protocols often transmit large blobs of binary data within the JSON payloads. Typically, these blobs end up being Base64 strings as properties on some JSON object. Today, outputting such blobs requires Base64-encoding the whole input and then writing the resulting <code>byte</code>s or <code>char</code>s in their entirety into the <code>Utf8JsonWriter</code>. To address that, <a href="https://github.com/dotnet/runtime/pull/111041">dotnet/runtime#111041</a> adds a <code>WriteBase64StringSegment</code> method to <code>Utf8JsonWriter</code>. For those sufficiently motivated to reduce memory overheads, and to enable the streaming of such payloads, <code>WriteBase64StringSegment</code> enables passing in a span of bytes, which the implementation will Base64-encode and write to the JSON property; it can be called multiple times with <code>isFinalSegment=false</code>, such that the writer will continue appending the resulting Base64 data to the property, until it’s called with a final segment that ends the property. (<code>Utf8JsonWriter</code> has long had a <code>WriteBase64String</code> method, this new <code>WriteBase64StringSegment</code> simply enables it to be written in pieces.) The primary benefit of such a method is reduced latency and working set, as the entirety of the data payload needn’t be buffered before being written out, but we can still come up with a throughput benchmark that shows benefits:</p>
<pre><code>//  dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers;
using System.Text.Json;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private Utf8JsonWriter _writer = new(Stream.Null);
    private Stream _source = new MemoryStream(Enumerable.Range(0, 10_000_000).Select(i =&gt; (byte)i).ToArray());

    [Benchmark]
    public async Task Buffered()
    {
        _source.Position = 0;
        _writer.Reset();

        byte[] buffer = ArrayPool&lt;byte&gt;.Shared.Rent(0x1000);

        int totalBytes = 0;
        int read;
        while ((read = await _source.ReadAsync(buffer.AsMemory(totalBytes))) &gt; 0)
        {
            totalBytes += read;
            if (totalBytes == buffer.Length)
            {
                byte[] newBuffer = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length * 2);
                Array.Copy(buffer, newBuffer, totalBytes);
                ArrayPool&lt;byte&gt;.Shared.Return(buffer);
                buffer = newBuffer;
            }
        }

        _writer.WriteStartObject();
        _writer.WriteBase64String(&#34;data&#34;, buffer.AsSpan(0, totalBytes));
        _writer.WriteEndObject();
        await _writer.FlushAsync();

        ArrayPool&lt;byte&gt;.Shared.Return(buffer);
    }

    [Benchmark]
    public async Task Streaming()
    {
        _source.Position = 0;
        _writer.Reset();

        byte[] buffer = ArrayPool&lt;byte&gt;.Shared.Rent(0x1000);

        _writer.WriteStartObject();
        _writer.WritePropertyName(&#34;data&#34;);
        int read;
        while ((read = await _source.ReadAsync(buffer)) &gt; 0)
        {
            _writer.WriteBase64StringSegment(buffer.AsSpan(0, read), isFinalSegment: false);
        }
        _writer.WriteBase64StringSegment(default, isFinalSegment: true);
        _writer.WriteEndObject();
        await _writer.FlushAsync();

        ArrayPool&lt;byte&gt;.Shared.Return(buffer);
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
</tr>
</thead>
<tbody>
<tr>
<td>Buffered</td>
<td>3.925 ms</td>
</tr>
<tr>
<td>Streaming</td>
<td>1.555 ms</td>
</tr>
</tbody>
</table>
<p>.NET 9 saw the introduction of the <code>JsonMarshal</code> class and the <code>GetRawUtf8Value</code> method, which provides raw access to the underlying bytes of property values fronted by a <code>JsonElement</code>. For situations where the name of the property is also needed, <a href="https://github.com/dotnet/runtime/pull/107784">dotnet/runtime#107784</a> from <a href="https://github.com/mwadams">@mwadams</a> provides a corresponding <code>JsonMarshal.GetRawUtf8PropertyName</code> method.</p>
<h2>Diagnostics</h2>
<p>Over the years, I’ve seen a fair number of codebases introduce a <code>struct</code>-based <code>ValueStopwatch</code>; I think there are even a few still floating around the <code>Microsoft.Extensions</code> libraries. The premise behind these is that <code>System.Diagnostics.Stopwatch</code> is a <code>class</code>, but it simply wraps a <code>long</code> (a timestamp), so rather than writing code like the following that allocates:</p>
<pre><code>Stopwatch sw = Stopwatch.StartNew();
... // something being measured
sw.Stop();
TimeSpan elapsed = sw.Elapsed;</code></pre>
<p>you could write:</p>
<pre><code>ValueStopwatch sw = ValueStopwatch.StartNew();
... // something being measured
sw.Stop();
TimeSpan elapsed = sw.Elapsed;</code></pre>
<p>and avoid the allocation. <code>Stopwatch</code> subsequently gained helpers that make such a <code>ValueStopwatch</code> less appealing, since as of .NET 7, I can write it instead like this:</p>
<pre><code>long start = Stopwatch.GetTimestamp();
... // something being measured
long end = Stopwatch.GetTimestamp();
TimeSpan elapsed = Stopwatch.GetElapsedTime(start, end);</code></pre>
<p>However, that’s not quite as natural as the original example, that just uses <code>Stopwatch</code>. Wouldn’t it be nice if you could write the original example and have it executed as if it were the latter? With all the investments in .NET 9 and .NET 10 around escape analysis and stack allocation, you now can. <a href="https://github.com/dotnet/runtime/pull/111834">dotnet/runtime#111834</a> streamlines the <code>Stopwatch</code> implementation so that <code>StartNew</code>, <code>Elapsed</code>, and <code>Stop</code> are fully inlineable. At that point, the JIT can see that the allocated <code>Stopwatch</code> instance never escapes the frame, and it can be stack allocated.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Diagnostics;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[DisassemblyDiagnoser]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public TimeSpan WithGetTimestamp()
    {
        long start = Stopwatch.GetTimestamp();
        Nop();
        long end = Stopwatch.GetTimestamp();

        return Stopwatch.GetElapsedTime(start, end);
    }

    [Benchmark]
    public TimeSpan WithStartNew()
    {
        Stopwatch sw = Stopwatch.StartNew();
        Nop();
        sw.Stop();

        return sw.Elapsed;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static void Nop() { }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Code Size</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>WithGetTimestamp</td>
<td>.NET 9.0</td>
<td>28.95 ns</td>
<td>1.00</td>
<td>148 B</td>
<td>–</td>
<td>NA</td>
</tr>
<tr>
<td>WithGetTimestamp</td>
<td>.NET 10.0</td>
<td>28.32 ns</td>
<td>0.98</td>
<td>130 B</td>
<td>–</td>
<td>NA</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>WithStartNew</td>
<td>.NET 9.0</td>
<td>38.62 ns</td>
<td>1.00</td>
<td>341 B</td>
<td>40 B</td>
<td>1.00</td>
</tr>
<tr>
<td>WithStartNew</td>
<td>.NET 10.0</td>
<td>28.21 ns</td>
<td>0.73</td>
<td>130 B</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/117031">dotnet/runtime#117031</a> is a nice improvement that helps reduce working set for anyone using an <code>EventSource</code> and that has events with really large IDs. For efficiency purposes, <code>EventSource</code> was using an array to map event ID to the data for that ID; lookup needs to be really fast, since the lookup is performed on every event write in order to look up the metadata for the event being written. In many <code>EventSource</code>s, the developer authors events with a small, contiguous range of IDs, and the array ends up being very dense. But if a developer authors any event with a really large ID (which we’ve seen happen in multiple real-world projects, due to splitting events into multiple partial class definitions shared between different projects and selecting IDs for each file unlikely to conflict with each other), an array is still created with a length to accomodate that large ID, which can result in a really big allocation that persists for the lifetime of the event source, and a lot of that allocation ends up just being wasted space. Thankfully, since <code>EventSource</code> was written years ago, the performance of <code>Dictionary&lt;TKey, TValue&gt;</code> has increased significantly, to the point where it’s able to efficiently handle the lookups without needing the event IDs to be dense. Note that there should really only ever be one instance of a given <code>EventSource</code>-derived type; the recommended pattern is to store one into a static readonly field and just use that one. So the overheads incurred as part of this are primarily about the impact that single large allocation has on working set for the duration of the process. To make it easier to demonstrate, though, I’m doing something you’d never, ever do, and creating a new instance per event. Don’t try this at home, or at least not in production.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Diagnostics;
using System.Diagnostics.Tracing;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private MyListener _listener = new();

    [Benchmark]
    public void Oops()
    {
        using OopsEventSource oops = new();
        oops.Oops();
    }

    [EventSource(Name = &#34;MyTestEventSource&#34;)]
    public sealed class OopsEventSource : EventSource
    {
        [Event(12_345_678, Level = EventLevel.Error)]
        public void Oops() =&gt; WriteEvent(12_345_678);
    }

    private sealed class MyListener : EventListener
    {
        protected override void OnEventSourceCreated(EventSource eventSource) =&gt; 
            EnableEvents(eventSource, EventLevel.Error);
    }
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Oops</td>
<td>.NET 9.0</td>
<td>1,876.21 us</td>
<td>1.00</td>
<td>1157428.01 KB</td>
<td>1.000</td>
</tr>
<tr>
<td>Oops</td>
<td>.NET 10.0</td>
<td>22.06 us</td>
<td>0.01</td>
<td>19.21 KB</td>
<td>0.000</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/dotnet/runtime/pull/107333">dotnet/runtime#107333</a> from <a href="https://github.com/AlgorithmsAreCool">@AlgorithmsAreCool</a> reduces thread contention involved in starting and stopping an <code>Activity</code>. <code>ActivitySource</code> maintains a thread-safe list of listeners, which only changes on the rare occasion that a listener is registered or unregistered. Any time an <code>Activity</code> is created or destroyed (which can happen at very high frequency), each listener gets notified, which requires walking through the list of listeners. The previous code used a lock to protect that listeners list, and to avoid notifying the listener while holding the lock, the implementation would take the lock, determine the next listener, release the lock, notify the listener, and rinse and repeat until it had notified all listeners. This could result in significant contention, as multiple threads started and stopped <code>Activity</code>s. Now with this PR, the list switches to be an immutable array. Each time the list changes, a new array is created with the modified set of listeners. This makes the act of changing the listeners list much more expensive, but, as noted, that’s generally a rarity. And in exchange, notifying listeners becomes much cheaper.</p>
<p><a href="https://github.com/dotnet/runtime/pull/117334">dotnet/runtime#117334</a> from <a href="https://github.com/petrroll">@petrroll</a> avoids the overheads of callers needing to interact with null loggers by excluding them in <code>LoggerFactory.CreateLoggers</code>, while <a href="https://github.com/dotnet/runtime/pull/117342">dotnet/runtime#117342</a> seals the <code>NullLogger</code> type so type checks against <code>NullLogger</code> (e.g. <code>if (logger is NullLogger</code>) can be made more efficient by the JIT. And <a href="https://github.com/dotnet/roslyn-analyzers/pull/7290">dotnet/roslyn-analyzers#</a> from <a href="https://github.com/mpidash">@mpidash</a> will help developers to realize that their logging operations aren’t as cheap as they thought they might be. Consider this code:</p>
<pre><code>[LoggerMessage(Level = LogLevel.Information, Message = &#34;This happened: {Value}&#34;)]
private static partial void Oops(ILogger logger, string value);

public static void UnexpectedlyExpensive()
{
    Oops(NullLogger.Instance, $&#34;{Guid.NewGuid()} {DateTimeOffset.UtcNow}&#34;);
}</code></pre>
<p>It’s using the logger source generator, which will emit an implementation dedicated to this log method, including a log level check so that it doesn’t pay the bulk of the costs associated with logging unless the associated level is enabled:</p>
<pre><code>[global::System.CodeDom.Compiler.GeneratedCodeAttribute(&#34;Microsoft.Extensions.Logging.Generators&#34;, &#34;6.0.5.2210&#34;)]
private static partial void Oops(global::Microsoft.Extensions.Logging.ILogger logger, global::System.String value)
{
    if (logger.IsEnabled(global::Microsoft.Extensions.Logging.LogLevel.Information))
    {
        __OopsCallback(logger, value, null);
    }
}</code></pre>
<p>Except, the call site is doing non-trivial work, creating a new <code>Guid</code>, fetching the current time, and allocating a string via string interpolation, even though it might be wasted work if <code>LogLevel.Information</code> isn’t available. This CA1873 analyzer flags that:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/CA1873.png" alt="Analyzer for expensive logging sites"/></p>
<h2>Cryptography</h2>
<p>A ton of effort went into cryptography in .NET 10, almost entirely focused on post‑quantum cryptography (PQC). PQC refers to a class of cryptographic algorithms designed to resist attacks from quantum computers, machines that could one day render classic cryptographic algorithms like Rivest–Shamir–Adleman (RSA) or Elliptic Curve Cryptography (ECC) insecure by efficiently solving problems such as integer factorization and discrete logarithms. With the looming threat of “harvest now, decrypt later” attacks (where a well-funded attacker idly captures encrypted internet traffic, expecting that they’ll be able to decrypt and read it later) and the multi-year process required to migrate critical infrastructure, the transition to quantum‑safe cryptographic standards has become an urgent priority. In this light, .NET 10 adds support for ML-DSA (a National Institute of Standards and Technology PQC digital signature algorithm), Composite ML-DSA (a draft Internet Engineering Task Force specification for creating signatures that combine ML-DSA with a classical crypto algorithm like RSA), SLH-DSA (another NIST PQC signature algorithm), and ML-KEM (a NIST PQC key encapsulation algorithm). This is an important step towards quantum-resistant security, enabling developers to begin experimenting with and planning for post-quantum identity and authenticity scenarios. While this PQC effort is not about performance, the design of them is very much focused on more modern sensibilities that have performance as a key motivator. While older types, like those that derive from <code>AsymmetricAlgorithm</code>, are design around arrays, with support for spans tacked on later, the new types are design with spans at the center, and with array-based APIs available only for convenience.</p>
<p>There are, however, some cryptography-related changes in .NET 10 that are focused squarely on performance. One is around improving OpenSSL “digest” performance. .NET’s cryptography stack is built on top of the underlying platform’s native cryptographic libraries; on Linux, that means using OpenSSL, making it a hot path for common operations like hashing, signing, and TLS. “Digest algorithms” are the family of cryptographic hash functions (for example, SHA‑256, SHA‑512, SHA‑3) that turn arbitrary input into fixed‑size fingerprints; they’re used all of the place, from verifying packages to TLS handshakes to content de-duplication. While .NET can use OpenSSL 1.x if that’s what’s offered by the OS, since .NET 6 it’s been focusing more and more on optimizing for and lighting-up with OpenSSL 3 (the previously-discussed PQC support requires OpenSSL 3.5 or later). With OpenSSL 1.x, OpenSSL exposed getter functions like <code>EVP_sha256()</code>, which were cheap functions that just returned a direct pointer to the <code>EVP_MD</code> for the relevant hash implementation. OpenSSL 3.x introduced a provider model, with a fetch function (<code>EVP_MD_fetch</code>) for retrieving the provider-backed implementation. To keep source compatibility, the 1.x-era getter functions were changed to return pointers to compatibility shims: when you pass one of these legacy <code>EVP_MD</code> pointers into operations like <code>EVP_DigestInit_ex</code>, OpenSSL performs an “implicit fetch” under the covers to resolve the actual implementation. That implicit fetch path adds extra work, on each use. Instead, OpenSSL recommends consumers do an explicit fetch and then cache the result for reuse. That’s what <a href="https://github.com/dotnet/runtime/pull/118613">dotnet/runtime#118613</a> does. The result is leaner and faster cryptographic hash operations on OpenSSL‑based platforms.</p>
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Security.Cryptography;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private byte[] _src = new byte[1024];
    private byte[] _dst = new byte[SHA256.HashSizeInBytes];

    [GlobalSetup]
    public void Setup() =&gt; new Random(42).NextBytes(_src);

    [Benchmark]
    public void Hash() =&gt; SHA256.HashData(_src, _dst);
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hash</td>
<td>.NET 9.0</td>
<td>1,206.8 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Hash</td>
<td>.NET 10.0</td>
<td>960.6 ns</td>
<td>0.80</td>
</tr>
</tbody>
</table>
<p>A few other performance niceties have also found their way in.</p>
<ul>
<li><strong><code>AsnWriter.Encode</code></strong>. <a href="https://github.com/dotnet/runtime/pull/106728">dotnet/runtime#106728</a> and <a href="https://github.com/dotnet/runtime/pull/112638">dotnet/runtime#112638</a> add and then use throughout the crypto stack a callback-based mechanism to <code>AsnWriter</code> that enables encoding without forced allocation for the temporary encoded state.</li>
<li><strong><code>SafeHandle</code> singleton</strong>. <a href="https://github.com/dotnet/runtime/pull/109391">dotnet/runtime#109391</a> employs a singleton <code>SafeHandle</code> in more places in <code>X509Certificate</code> to avoid temporary handle allocation.</li>
<li><strong>Span-based <code>ProtectedData</code></strong>. <a href="https://github.com/dotnet/runtime/pull/109529">dotnet/runtime#109529</a> from <a href="https://github.com/ChadNedzlek">@ChadNedzlek</a> adds <code>Span&lt;byte&gt;</code>-based overloads to the <code>ProtectedData</code> class that enable protecting data without requiring the source or destinations to be in allocated arrays.</li>
<li><strong><code>PemEncoding</code> UTF-8</strong>. <a href="https://github.com/dotnet/runtime/pull/109438">dotnet/runtime#109438</a> adds UTF-8 support to <code>PemEncoding</code>. <code>PemEncoding</code>, a utility class for parsing and formatting PEM (Privacy-Enhanced Mail)-encoded data such as that used in certificates and keys, previously worked only with <code>char</code>s. As was then done in <a href="https://github.com/dotnet/runtime/pull/109564">dotnet/runtime#109564</a>, this change makes it possible to parse UTF8 data directly without first needing to transcode to UTF16.</li>
<li><strong><code>FindByThumbprint</code></strong>. <a href="https://github.com/dotnet/runtime/pull/109130">dotnet/runtime#109130</a> adds an <code>X509Certification2Collection.FindByThumbprint</code> method. The implementation uses a stack-based buffer for the thumbprint value for each candidate certificate, eliminating the arrays that would otherwise be created in a naive manual implementation. <a href="https://github.com/dotnet/runtime/pull/113606">dotnet/runtime#113606</a> then utilized this in <code>SslStream</code>.</li>
<li><strong><code>SetKey</code></strong> <a href="https://github.com/dotnet/runtime/pull/113146">dotnet/runtime#113146</a> adds a span-based <code>SymmetricAlgorithm.SetKey</code> method which can then be used to avoid creating unnecessary arrays.</li>
</ul>
<h2>Peanut Butter</h2>
<p>As in every .NET release, there are a large number of PRs that help with performance in some fashion. The more of these that are addressed, the more the overall overhead for applications and services is lowered. Here are a smattering from this release:</p>
<ul>
<li><strong>GC</strong>. DATAS (Dynamic Adaptation To Application Sizes) was introduced in .NET 8 and enabled by default in .NET 9. Now in .NET 10, <a href="https://github.com/dotnet/runtime/pull/105545">dotnet/runtime#105545</a> tuned DATAS to improve its overall behavior, cutting unnecessary work, smoothing out pauses (especially under high allocation rates), correcting fragmentation accounting that could cause extra short collections (gen1), and other such tweaks. The net result is fewer unnecessary collections, steadier throughput, and more predictable latency for allocation-heavy workloads. <a href="https://github.com/dotnet/runtime/pull/118762">dotnet/runtime#118762</a> also adds several knobs for configuring how DATAS behaves, and in particular settings to fine-tune how Gen0 grows.</li>
<li><strong>GCHandle</strong>. The GC supports various types of “handles” that allow for explicit management of resources in relation to GC operation. For example, you can create a “pinning handle,” which ensures that the GC will not move the object in question. Historically, these handles were surfaced to developers via the <code>GCHandle</code> type, but it has a variety of issues, including that it’s really easy to misuse due to lack of strong typing. To help address that, <a href="https://github.com/dotnet/runtime/pull/111307">dotnet/runtime#111307</a> introduces a few new strongly-typed flavors of handles, with <code>GCHandle&lt;T&gt;</code>, <code>PinnedGCHandle&lt;T&gt;</code>, and <code>WeakGCHandle&lt;T&gt;</code>. These should not only address some of the usability issues, they’re also able to shave off a bit of the overheads incurred by the old design.
<pre><code>// dotnet run -c Release -f net10.0 --filter &#34;*&#34;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.InteropServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private byte[] _array = new byte[16];

    [Benchmark(Baseline = true)]
    public void Old() =&gt; GCHandle.Alloc(_array, GCHandleType.Pinned).Free();

    [Benchmark]
    public void New() =&gt; new PinnedGCHandle&lt;byte[]&gt;(_array).Dispose();
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Old</td>
<td>27.80 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>New</td>
<td>22.73 ns</td>
<td>0.82</td>
</tr>
</tbody>
</table>
</li>
<li><strong>Mono interpreter</strong>. The mono interpreter gained optimized support for several opcodes, including switches (<a href="https://github.com/dotnet/runtime/pull/107423">dotnet/runtime#107423</a>), new arrays (<a href="https://github.com/dotnet/runtime/pull/107430">dotnet/runtime#107430</a>), and memory barriers (<a href="https://github.com/dotnet/runtime/pull/107325">dotnet/runtime#107325</a>). But arguably more impactful was a series of more than a dozen PRs that enabled the interpreter to vectorize more operations with WebAssembly (Wasm). This included contributions like <a href="https://github.com/dotnet/runtime/pull/114669">dotnet/runtime#114669</a>, which enabled vectorization of shift operations, and <a href="https://github.com/dotnet/runtime/pull/113743">dotnet/runtime#113743</a>, which enabled vectorization of a plethora of operations like <code>Abs</code>, <code>Divide</code>, and <code>Truncate</code>. Other PRs used the Wasm-specific intrinsic APIs in more places, in order to accelerate on Wasm routines that were already accelerated on other architectures using architecture-specific intrinsics, e.g. <a href="https://github.com/dotnet/runtime/pull/115062">dotnet/runtime#115062</a> used <code>PackedSimd</code> in the workhorse methods behind the hex conversion routines on <code>Convert</code>, like <code>Convert.FromBase64String</code>.</li>
<li><strong>FCALLs</strong>. There are many places in the lower-layers of <code>System.Private.CoreLib</code> where managed code needs to call into native code in the runtime. There are two primary ways this transition from managed to native has happened, historically. One method is through what’s called a “QCALL”, essentially just a DllImport (P/Invoke) into native functions exposed by the runtime. The other, which historically was the dominant mechansim, is an “FCALL,” which is a more complex and specialized pathway that allows direct access to managed objects from native code. FCALLs were once the standard, but over time, more of them were converted to QCALLs. This shift improves reliability (since FCALLs are notoriously tricky to implement correctly) and can also boost performance, as FCALLs require helper method frames, which QCALLs can often avoid. A ton of PRs in .NET 10 went into removing FCALLs, like <a href="https://github.com/dotnet/runtime/pull/107218">dotnet/runtime#107218</a> for helper method frames in <code>Exception</code>, <code>GC</code>, and <code>Thread</code>, <a href="https://github.com/dotnet/runtime/pull/106497">dotnet/runtime#106497</a> for helper method frames in <code>object</code>, <a href="https://github.com/dotnet/runtime/pull/107152">dotnet/runtime#107152</a> for those used in connecting to profilers, <a href="https://github.com/dotnet/runtime/pull/108415">dotnet/runtime#108415</a> and <a href="https://github.com/dotnet/runtime/pull/108535">dotnet/runtime#108535</a> for ones in reflection, and over a dozen others. In the end, all FCALLS that touched managed memory or threw exceptions were removed.</li>
<li><strong>Converting hex.</strong> Recent .NET releases added methods to <code>Convert</code> like <code>FromHexString</code> and <code>TryToHexStringLower</code>, but such methods all used UTF16. <a href="https://github.com/dotnet/runtime/pull/117965">dotnet/runtime#117965</a> adds overloads of these that work with UTF8 bytes.</li>
<li><strong>Formatting.</strong> String interpolation is backed by “interpolated string handlers.” When you interpolate with a string target type, by default you get the <code>DefaultInterpolatedStringHandler</code> that comes from <code>System.Runtime.CompilerServices</code>. That implementation is able to use stack-allocated memory and the <code>ArrayPool&lt;&gt;</code> for reduced allocation overheads as it’s buffering up text formatted to it. While very advanced, other code, including other interpolated string handlers, can use <code>DefaultInterpolatedStringHandler</code> as an implementation detail. However, when doing so, such code only could get access to the final output as a <code>string</code>; the underlying buffer wasn’t exposed. <a href="https://github.com/dotnet/runtime/pull/112171">dotnet/runtime#112171</a> adds a <code>Text</code> property to <code>DefaultInterpolatedStringHandler</code> for code that wants access to the already formatted text in a <code>ReadOnlySpan&lt;char&gt;</code>.</li>
<li><strong>Enumeration-related allocations.</strong> <a href="https://github.com/dotnet/runtime/pull/118288">dotnet/runtime#118288</a> removes a handful of allocations related to enumeration, for example removing a <code>string.Split</code> call in <code>EnumConverter</code> and replacing it with a <code>MemoryExtensions.Split</code> call that doesn’t need to allocate either the <code>string[]</code> or the individual <code>string</code> instances.</li>
<li><strong>NRBF decoding.</strong> <a href="https://github.com/dotnet/runtime/pull/107797">dotnet/runtime#107797</a> from <a href="https://github.com/teo-tsirpanis">@teo-tsirpanis</a> removes an array allocation used in a <code>decimal</code> constructor call, replacing it instead with a collection expression targeting a span, which will result in the state being stack allocated.</li>
<li><strong>TypeConverter allocations.</strong> <a href="https://github.com/dotnet/runtime/pull/111349">dotnet/runtime#111349</a> from <a href="https://github.com/AlexRadch">@AlexRadch</a> reduces some parsing overheads in the <code>TypeConverter</code>s for <code>Size</code>, <code>SizeF</code>, <code>Point</code>, and <code>Rectangle</code> by using more modern APIs and constructs, such as the span-based <code>Split</code> method and string interpolation.</li>
<li><strong>Generic math conversions.</strong> Most of the <code>TryConvertXx</code> methods using the various primitive’s implementations of the generic math interfaces are marked as <code>MethodImplOptions.AggressiveInlining</code>, to help the JIT realize they should always be inlined, but a few stragglers were left out. <a href="https://github.com/dotnet/runtime/pull/112061">dotnet/runtime#112061</a> from <a href="https://github.com/hez2010">@hez2010</a> fixes that.</li>
<li><strong>ThrowIfNull.</strong> C# 14 now supports the ability to write extension static methods. This is a huge boon for libraries that need to support downlevel targeting, as it means static methods can be polyfilled just as instance methods can be. There are many libraries in .NET that build not only for the latest runtimes but also for .NET Standard 2.0 and .NET Framework, and those libraries have been unable to use helper static methods like <code>ArgumentNullException.ThrowIfNull</code>, which can help to streamline call sites and make methods more inlineable (in addition, of course, to tidying up the code). Now that the dotnet/runtime repo builds with a C# 14 compiler, <a href="https://github.com/dotnet/runtime/pull/114644">dotnet/runtime#114644</a> replaced ~2500 call sites in such libraries with use of a <code>ThrowIfNull</code> polyfill.</li>
<li><strong>FileProvider Change Tokens</strong>. <a href="https://github.com/dotnet/runtime/pull/116175">dotnet/runtime#116175</a> reduces allocation in <code>PollingWildCardChangeToken</code> by using allocation-free mechanisms for computing hashes, while <a href="https://github.com/dotnet/runtime/pull/115684">dotnet/runtime#115684</a> from <a href="https://github.com/rameel">@rameel</a> reduces allocation in <code>CompositeFileProvider</code> by avoiding taking up space for nop <code>NullChangeToken</code>s.</li>
<li><strong>String interpolation.</strong> <a href="https://github.com/dotnet/runtime/pull/114497">dotnet/runtime#114497</a> removes a variety of null checks when dealing with nullable inputs, shaving off some overheads of the interpolation operation.
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    private string _value = &#34; &#34;;

    [Benchmark]
    public string Interpolate() =&gt; $&#34;{_value} {_value} {_value} {_value}&#34;;
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Interpolate</td>
<td>.NET 9.0</td>
<td>34.21 ns</td>
<td>1.00</td>
</tr>
<tr>
<td>Interpolate</td>
<td>.NET 10.0</td>
<td>29.47 ns</td>
<td>0.86</td>
</tr>
</tbody>
</table>
</li>
<li><strong><code>AssemblyQualifiedName</code></strong>. <code>Type.AssemblyQualifiedName</code> previously recomputed the result on every access. As of <a href="https://github.com/dotnet/runtime/issues/118389">dotnet/runtime#118389</a>, it’s now cached.
<pre><code>// dotnet run -c Release -f net9.0 --filter &#34;*&#34; --runtimes net9.0 net10.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(displayGenColumns: false)]
[HideColumns(&#34;Job&#34;, &#34;Error&#34;, &#34;StdDev&#34;, &#34;Median&#34;, &#34;RatioSD&#34;)]
public partial class Tests
{
    [Benchmark]
    public string AQN() =&gt; typeof(Dictionary&lt;int, string&gt;).AssemblyQualifiedName!;
}</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>AQN</td>
<td>.NET 9.0</td>
<td>132.345 ns</td>
<td>1.007</td>
<td>712 B</td>
<td>1.00</td>
</tr>
<tr>
<td>AQN</td>
<td>.NET 10.0</td>
<td>1.218 ns</td>
<td>0.009</td>
<td>–</td>
<td>0.00</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2>What’s Next?</h2>
<p>Whew! After all of that, I hope you’re as excited as I am about .NET 10, and more generally, about the future of .NET.</p>
<p>As you’ve seen in this tour (and in those for previous releases), the story of .NET performance is one of relentless iteration, systemic thinking, and the compounding effect of many targeted improvements. While I’ve highlighted micro-benchmarks to show specific gains, the real story isn’t about these benchmarks… it’s about making real-world applications more responsive, more scalable, more sustainable, more economical, and ultimately, more enjoyable to build and use. Whether you’re shipping high-throughput services, interactive desktop apps, or resource-constrained mobile experiences, .NET 10 offers tangible performance benefits to you and your users.</p>
<p>The best way to appreciate these improvements is to try <a href="https://dotnet.microsoft.com/download/dotnet/10.0">.NET 10 RC1</a> yourself. Download it, run your workloads, measure the impact, and share your experiences. See awesome gains? Find a regression that needs fixing? Spot an opportunity for further improvement? Shout it out, open an issue, even send a PR. Every bit of feedback helps make .NET better, and we look forward to continuing to build with you.</p>
<p>Happy coding!</p>
        </div><!-- .entry-content -->

        <!-- AI Disclaimer -->
            </article>
    
</div></div>
  </body>
</html>
