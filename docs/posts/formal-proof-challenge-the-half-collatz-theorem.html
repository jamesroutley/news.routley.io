<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickdrozd.github.io/2022/06/07/half-collatz.html">Original</a>
    <h1>Formal Proof Challenge: The Half-Collatz Theorem</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    

<ol>
  <li><a href="#orgf7a64b1">The Collatz Conjecture</a></li>
  <li><a href="#orgedbbb30">The Half-Collatz Theorem</a></li>
  <li><a href="#orgdf1f4bc">Challenge: Formally prove the Half-Collatz function to be total.</a></li>
</ol>





<p>Recently I posted about an extension of Peano arithmetic (PA) called <strong><a href="https://nickdrozd.github.io/2022/04/07/collatz-arithmetic.html">Collatz arithmetic</a></strong> (CA). CA is just like PA, except that it has the <strong>Collatz conjecture</strong> (CC) appended as an additional axiom. If CC is provably false in PA, then CA is inconsistent; and if CC is provably true in PA, then CA is just the same as PA. But if, as <a href="https://www.jstor.org/stable/10.4169/amer.math.monthly.120.03.192">John Conway</a> proposed, CC is <strong>unsettleable</strong>, then CA is a consistent proper extension of PA.</p>

<p>Recall the Collatz transformation <em>CT : N -&gt; N</em>:</p>

<ul>
  <li>if <em>n</em> is even, <em>CT(n) = n/2</em>;</li>
  <li>if <em>n</em> is odd, <em>CT(n) = 3n + 1</em>;</li>
</ul>

<p>And the Collatz loop function <em>C</em> is defined as follows:</p>

<ul>
  <li><em>C(0) = 1</em>;</li>
  <li><em>C(1) = 1</em>;</li>
  <li><em>C(n) = C(CT(n))</em>;</li>
</ul>

<p>The Collatz conjecture says that <em>C(n) = 1</em> for all <em>n</em>, or in other words, that <em>C</em> is a <strong><a href="https://nickdrozd.github.io/2022/04/01/total-partial-functions.html">total function</a></strong>.</p>





<p>Note that if <em>n</em> is odd, then <em>3n + 1</em> will be even, and so every application of the odd rule will immediately be followed by an application of the even rule. This means that the odd rule can be <strong>accelerated</strong> slightly:</p>

<ul>
  <li>if <em>n</em> is odd, <em>CT(n) = 3k + 2</em>, where <em>n = 2k + 1</em>.</li>
</ul>

<p>The Collatz loop function applies the odd and even rules until the value reaches 1, and then it terminates. Suppose instead we start from an odd number and then apply the accelerated odd rule until an even number is reached, and then stop. Will this loop function always terminate? I called this the <strong>Half Collatz cojecture</strong> (HCC) and proposed it as an example of a theorem that could be proved in CA but not in PA.</p>

<p>Well, it turns out that is not the case. Alert reader <a href="https://isaacg1.github.io/blog/">Isaac Grosof</a> pointed out to me that <strong>HCC was proved more than fifteen years ago</strong>, and is in fact just a theorem of PA. I guess Half Collatz Theorem (HCT) would be a more appropriate name.</p>

<p>To be clear, we define the Half-Collatz transformation <em>HT</em> on odd numbers:</p>

<ul>
  <li><em>HT(n = 2k + 1) = 3k + 2</em>.
    <ul>
      <li>Or equivalently, <em>HT(n = 2k + 1) = n + k + 1</em>).</li>
    </ul>
  </li>
</ul>

<p>And the Half-Collatz function <em>HC</em>:</p>

<ul>
  <li><em>HC(n) = HC(HT(n))</em> if <em>n</em> is odd;</li>
  <li><em>HC(n) = n</em> otherwise.</li>
</ul>

<p><strong><em>HC</em> is provably total</strong>. To see why, observe this <strong>key fact</strong> (which can be proved with a little algebra):</p>

<ul>
  <li><em>HT(n) + 1 = (3/2)(n + 1)</em> (assuming <em>n</em> is odd).</li>
</ul>

<p>Further, if <em>HT(n)</em> is still odd, then <em>HT(HT(n)) = (3/2)(3/2)(n + 1)</em>. So repeatedly applying <em>HT</em> entails repeatedly halving <em>n + 1</em>. But a number can only be halved so many times, and exactly how many is known as the number’s <strong>2-adic valuation</strong>. Specifically, this is the greatest <em>m</em> such that <em>2<sup>m</sup></em> divides <em>n</em>.</p>

<p>For example:</p>

<ul>
  <li><em>n = 15</em>. <em>n + 1</em> = 16, the 2-adic valuation of which is 4. The trajectory of repeated applications of <em>HT</em> goes: 15 -&gt; 23 -&gt; 35 -&gt; 53 -&gt; 80, which makes 4 applications.</li>
  <li><em>n = 13</em>. <em>n + 1</em> = 14, with a 2-adic valuation of just 1. And 13 undergoes a trajectory of length 1: 13 -&gt; 20.</li>
</ul>

<p>In general, <strong>the length of the trajectory of <em>n</em> under repeated applications of <em>HT</em> is exactly the 2-adic valuation of <em>n + 1</em></strong>. The 2-adic valuation function is total, and therefore so is the Half-Collatz function.</p>





<p>That’s the hand-wavy natural language version of the proof. But as is well-known, constructing a <strong>formal proof</strong> can be quite a bit trickier. And when I say “formal proof”, I mean a proof in a programming language such as: <strong>Lean, Coq, Idris, Agda, etc.</strong></p>

<p>The challenge here is simple (to state): <strong>formally prove that the Half-Collatz function is total</strong>.</p>

<p>I’ll lay out some basic definitions as starting points, but feel free to modify them. The language used here is Idris. I imagine that anyone who has read this far can figure out how to translate it into their own language of choice.</p>

<p>To say that <em>n</em> is even is just to say that there is a <em>k</em> such that <em>n = 2k</em>, and to say that <em>n</em> is odd is just to say that there is a <em>k</em> such that <em>n = 2k + 1</em>.</p>

<figure><pre><code data-lang="idris">Even : Nat -&gt; Type
Even n = (k : Nat ** n = k + k)

Odd : Nat -&gt; Type
Odd n = (k : Nat ** n = 1 + (k + k))</code></pre></figure>

<p>A handy fact is that every number is either even or odd (proof left as a warmup exercise).</p>

<figure><pre><code data-lang="idris">total
evenOrOdd : (n : Nat) -&gt; Either (Even n) (Odd n)</code></pre></figure>

<p>Next, there is the 2-adic valuation function. I’ve implemented this with an <strong><code>assert_smaller</code></strong> statement, justified because <em>2/k &lt; k</em>. Except when <em>k = 0</em>; that gets the output 0 here, which is arbitrary. I’m sure there is a more elegant implementation.</p>

<figure><pre><code data-lang="idris">total
twoAdicValuation : Nat -&gt; Nat
twoAdicValuation n = loop 0 n where
  loop : Nat -&gt; Nat -&gt; Nat
  loop acc 0 = 0
  loop acc k =
    case evenOrOdd k of
      -- odd
      Right _ =&gt; acc
      -- even
      Left (j ** _) =&gt; loop (S acc) $ assert_smaller k j</code></pre></figure>

<p>After those basics, there is the Half-Collatz function itself. As usual, we define the transformation function <code>ht</code> (defined only for odd numbers) and the looping function <code>halfCollatz</code>. For convenience, the output of <code>halfCollatz</code> is the list of numbers reached in its trajectory.</p>

<figure><pre><code data-lang="idris">total
ht : Odd n -&gt; Nat
ht (k ** _) = 2 + 3 * k

partial
halfCollatz : Nat -&gt; List Nat
halfCollatz n = n ::
  case evenOrOdd n of
    -- even
    Left  _ =&gt; []
    -- odd
    Right prf =&gt; halfCollatz $ ht prf</code></pre></figure>

<p>Last, there is the <strong>key fact</strong> mentioned earlier. I was able to prove a modified version of this in Idris, but the proof is tedious, long-winded, and not even a little bit enlightening. Being a merciful blogger, I spare the reader the details.</p>

<figure><pre><code data-lang="idris">total
keyFact : {n : Nat} -&gt; (odd : Odd n) -&gt; 2 + 2 * (h odd) = 3 + (3 * n)</code></pre></figure>

<p>Most of these functions are accompanied by a <strong><code>total</code> declaration</strong>. This means that the <strong>totality checker</strong> is able to verify that the function definition will always terminate one way or another. In the case of recursive functions, it must be shown that some input argument will always shrink down towards some base case.</p>

<p>In contrast, <code>halfCollatz</code> is flagged as <code>partial</code>. It is defined recursively, but the argument does not shrink. To make the challenge even more specific: <strong>flip the <code>partial</code> flag to <code>total</code></strong>.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
