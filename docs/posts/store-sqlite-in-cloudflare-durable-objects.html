<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ma.rkusa.st/store-sqlite-in-cloudflare-durable-objects">Original</a>
    <h1>Store SQLite in Cloudflare Durable Objects</h1>
    
    <div id="readability-page-1" class="page"><section role="main">
<p>This is my journey of creating a proof-of-concept of persisting an SQLite database in a Cloudflare Durable Object. It is not meant as a tutorial, but rather as something I myself can get back to to revisit what and why I did certain things.</p>
<h2>The Plan<a href="#the-plan" id="the-plan" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>Everything started with me wanting a way of saving an SQLite database close to my <a href="https://developers.cloudflare.com/workers/">Cloudflare workers</a> (just <em>Workers</em> in the following).</p>
<h3>Where to store SQLite on Cloudflare?<a href="#where-to-store-sqlite-on-cloudflare-" id="where-to-store-sqlite-on-cloudflare-" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h3>
<p>While Workers can easily interact with anything that speaks HTTP, I&#39;d like to be able to use something serverless, and preferably something that also lives on the edge, or at least close to it. Cloudflare offers two persistent storage products for its workers right now. There are <a href="https://developers.cloudflare.com/workers/learning/how-kv-works">Workers KV</a> (<em>KV</em> in the following) and <a href="https://developers.cloudflare.com/workers/learning/using-durable-objects">Durable Objects</a> (<em>DO</em> in the following). Soon there is also <a href="https://blog.cloudflare.com/introducing-r2-object-storage/">R2 Storage</a>, a S3 compatible object storage, which I am not going to cover here as I don&#39;t have access to it yet.</p>
<p>Both Workers KV and Durable objects are key-value stores. The main difference between both are their consistency guarantees. Workers KV is eventually-consistent while Durable Objects is strongly-consistent. All other differences are mostly a result of those different consistencies.</p>
<p>So which one to choose?</p>
<p>First, let&#39;s  look at their limitations. KV can store values of up to 25 MiB with no total limit for paid accounts (<a href="https://developers.cloudflare.com/workers/platform/limits#kv-limits">KV Limits</a>). DO has a total limit of 10 GB per account (can be raised by contacting Cloudflare) and a value limit of 128 KiB (<a href="https://developers.cloudflare.com/workers/platform/limits#durable-objects">DO Limits</a>).</p>
<p>Neither 25 MiB nor 128 KiB are enough as an upper limit for an SQL database. Fortunately, this is not a deal breaker, as we can split up the SQLite database file into blocks and persist one block as one value.</p>
<p>The SQLite file conveniently consists out of one or multiple pages of the same size. The size of a page is a power of two between 512 and 65536 inclusive (see <a href="https://www.sqlite.org/fileformat.html">SQLite File Format</a>). The default page size is 4096 bytes. One single read/write call of SQLite never crosses page boundaries. This makes splitting the file into blocks particularly easy.</p>
<p>The maximum page size fits both KV and DO, so neither of them is ruled out yet. Let&#39;s think about their consistencies next. If the database file is split across multiple key-value pairs, we have to make sure that all pages (all key-value pairs) are always up to date when accessing the database. This is not guaranteed to be the case with an eventually-consistent storage, so KV is not an option here.</p>
<p>With DO being strongly-consistent, we have our SQLite store. It of course comes with drawbacks compared to KV that are necessary to achieve the higher consistency guarantees. In a nutshell, one DO only exists once. It is unique. Calls to it are routed to its <em>point-of-presence that owns it</em>. This leads to higher latencies compared to KV. The latency depends on where a requests hits the Cloudflare network and where the DO is located.</p>
<p>The <a href="https://blog.cloudflare.com/introducing-workers-durable-objects/">DO introduction blog post</a> also confirmed that DO is a reasonable choice for this use-case:</p>
<blockquote>
<p>That said, every big distributed database – whether it be relational, document, graph, etc. – is, at some low level, composed of &#34;chunks&#34; or &#34;shards&#34; that store one piece of the overall data. The job of a distributed database is to coordinate between chunks.</p>
<p>We see a future of edge databases that store each &#34;chunk&#34; as a Durable Object. By doing so, it will be possible to build databases that operate entirely at the edge, fully distributed with no regions or home location. These databases need not be built by us; anyone can potentially build them on top of Durable Objects. Durable Objects are only the first step in the edge storage journey.</p>
</blockquote>
<h3>How to store the SQLite database file in a DO?<a href="#how-to-store-the-sqlite-database-file-in-a-do-" id="how-to-store-the-sqlite-database-file-in-a-do-" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h3>
<p>This is fortunately not as difficult as it might sound. SQLite already offers pluggable file-systems - aka. virtual file systems (<a href="https://www.sqlite.org/vfs.html">VFS</a>). So I <em>just</em> have to write my own virtual file system, which stores each page of the database file into a separate DO key-value, and plug it into SQLite.</p>
<h3>How to run SQLite on Workers?<a href="#how-to-run-sqlite-on-workers-" id="how-to-run-sqlite-on-workers-" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h3>
<p>SQLite is written in C, while workers is based on V8 isolates, so it mainly runs JavaScript. Fortunately, it also supports running WASM through initialising and calling WASM modules via JavaScript. Emscripten can be used to build WASM from C, but I&#39;d rather use it through Rust (using <a href="https://github.com/rusqlite/rusqlite"><code>rusqlite</code></a>), so this is what I focus on right-away. Workers can also be written entirely in Rust using <a href="https://github.com/cloudflare/workers-rs"><code>worker-rs</code></a>.</p>
<h3>The initial plan<a href="#the-initial-plan" id="the-initial-plan" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h3>
<p>With that all out of the way, the initial plan is to write a worker using <code>worker-rs</code>. Use <code>rusqlite</code> to create and use the SQLite database. Save each page of the database file into a separate DO key-value and persisted into the DO using a custom virtual file system.</p>
<h2>Compile SQLite to WASM for target <code>wasm-unknown-unknown</code><a href="#compile-sqlite-to-wasm-for-target-wasm-unknown-unknown" id="compile-sqlite-to-wasm-for-target-wasm-unknown-unknown" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>With <code>worker-rs</code> this should just be a matter of using <code>rusqlite</code> and building the project via <code>wrangler dev</code> or <code>wrangler publish</code>. With a plain Rust project, it would be a matter of building via <code>cargo build --target wasm32-unknown-unknown</code>. I am using the <code>bundled</code> feature for the build:</p>
<pre><code>rusqlite = { version = &#34;0.26&#34;, features = [&#34;bundled&#34;] }
</code></pre>
<p>Does it work? Nope.</p>
<p>It doesn&#39;t like the usage of <code>&lt;stdio.h&gt;</code>.</p>
<pre><code><span><span><span>warning:</span></span><span> sqlite3/sqlite3.c:13699:10: fatal error: <span><span>&#39;</span>stdio.h<span>&#39;</span></span> file not found</span>
<span><span>warning: </span></span><span><span>warning:</span></span><span>          ^<span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span></span>
<span><span>warning:</span></span><span> 1 error generated.</span>
</span></code></pre>
<p>Fortunately, there is an open PR to improve the WASM compatibility: <a href="https://github.com/rusqlite/rusqlite/pull/1010">rusqlite/rusqlite#1010</a>.</p>
<p>Let&#39;s try using the fork instead:</p>
<pre><code>rusqlite = { git = &#34;https://github.com/trevyn/rusqlite.git&#34;, branch = &#34;wasm32-unknown-unknown&#34;, features = [&#34;bundled&#34;] }
</code></pre>
<p>Which brings us to:</p>
<pre><code><span><span><span>...</span></span>
  <span><span>CC</span></span><span> = Some(<span><span>&#34;</span>/usr/local/opt/llvm/bin/clang<span>&#34;</span></span></span><span></span><span>)</span>
<span><span>...</span></span>
<span><span>error</span></span><span> occurred: Failed to find tool. Is <span><span>`</span><span><span>clang</span></span><span>`</span></span> installed<span>?</span></span>
</span></code></pre>
<p>I am on a MacBook and <code>/usr/local/opt/llvm/bin/clang</code> indeed doesn&#39;t exist on my machine. My solution was to first install <code>llvm</code> via Homebrew:</p>
<pre><code><span><span><span>brew</span></span><span> install llvm</span>
</span></code></pre>
<p>And then instruct Cargo via environment variables where my <code>clang</code> is located:</p>
<pre><code><span><span>CC</span><span>=</span><span>/opt/homebrew/opt/llvm/bin/clang</span> <span>\
</span>  <span><span>cargo</span></span><span> build<span><span> --</span>release</span><span><span> --</span>target</span> wasm32-unknown-unknown</span>
</span></code></pre>
<p>Still nope:</p>
<pre><code><span><span><span>error</span></span><span> occurred: Failed to find tool. Is <span><span>`</span><span><span>/usr/local/opt/llvm/bin/llvm-ar</span></span><span>`</span></span> installed<span>?</span></span>
</span></code></pre>
<p>Let&#39;s also tell it where <code>llvm-ar</code> is located:</p>
<pre><code><span><span>CC</span><span>=</span><span>/opt/homebrew/opt/llvm/bin/clang</span> <span>\
</span><span><span>AR</span></span><span>=/opt/homebrew/opt/llvm/bin/llvm-ar <span>\
</span>  cargo build<span><span> --</span>release</span><span><span> --</span>target</span> wasm32-unknown-unknown</span>
</span></code></pre>
<p>Aaannnnd ... it builds!</p>
<h2>Build the Virtual File System<a href="#build-the-virtual-file-system" id="build-the-virtual-file-system" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>Building a VFS for SQLite is a matter of subclassing three objects: <a href="https://www.sqlite.org/c3ref/vfs.html"><code>sqlite3_vfs</code></a>, <a href="https://www.sqlite.org/c3ref/io_methods.html"><code>sqlite3_io_methods</code></a> and <a href="https://www.sqlite.org/c3ref/file.html"><code>sqlite3_file</code></a>. A <a href="https://www.sqlite.org/src/doc/trunk/src/test_demovfs.c">demo implementation that uses POSIX</a> functions is provided, too.</p>
<p>With that I had enough information to build <a href="https://github.com/rkusa/sqlite-vfs"><code>sqlite-vfs</code></a>, a Rust library that wraps all the necessary interactions with the C SQLite library and exposes a much simpler Rust trait. I&#39;ll not go into the details of this library here.</p>
<p>Implementing this trait is enough for a simple VFS. I only implemented as much as was necessary for my use-case (e.g. I skipped memory mapped files). The trait is:</p>
<pre><code><span><span><span>pub</span> <span>trait</span> <span>File</span>: Read + Seek + Write <span><span>{</span>
    <span><span><span>fn</span> </span><span>file_size</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span>u64</span>, <span>std<span>::</span></span><span>io<span>::</span></span>Error<span>&gt;</span></span></span></span><span>;</span>
</span><span><span>}</span></span></span>

<span><span>pub</span> <span>trait</span> <span>Vfs</span> <span><span>{</span>
    <span>type</span> <span>File</span><span>:</span> File<span>;</span>

    <span><span><span>fn</span> </span><span>open</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>path</span><span>:</span> <span>&amp;</span>Path, <span>flags</span><span>:</span> OpenFlags</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span><span><span>Self</span><span>::</span></span></span>File, <span>std<span>::</span></span><span>io<span>::</span></span>Error<span>&gt;</span></span></span></span><span>;</span>
    <span><span><span>fn</span> </span><span>delete</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>path</span><span>:</span> <span>&amp;</span>Path</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span>(</span><span>)</span>, <span>std<span>::</span></span><span>io<span>::</span></span>Error<span>&gt;</span></span></span></span><span>;</span>
    <span><span><span>fn</span> </span><span>exists</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>_path</span><span>:</span> <span>&amp;</span>Path</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span>bool</span>, <span>std<span>::</span></span><span>io<span>::</span></span>Error<span>&gt;</span></span></span></span><span>;</span>

    <span><span><span>fn</span> </span><span>access</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>_path</span><span>:</span> <span>&amp;</span>Path, <span>_write</span><span>:</span> <span>bool</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span>bool</span>, <span>std<span>::</span></span><span>io<span>::</span></span>Error<span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>Ok</span><span><span>(</span><span>true</span></span><span><span>)</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>The implementation of the trait for saving each page as a separate object works as follows.</p>
<p>The <code>PagesVfs</code> is a struct that is generic over the page size.</p>
<pre><code><span><span><span>pub</span> <span>struct</span> </span><span><span><span>PagesVfs</span><span><span>&lt;</span>const PAGE_SIZE<span>:</span> <span>usize</span><span>&gt;</span></span></span></span><span>;</span>
</span></code></pre>
<p>It uses a <code>Pages</code> struct as the <code>File</code> associate type, which in return is a map of page index to <code>Page</code>, the <code>count</code> of pages in total and the current <code>offset</code> for reading and writing. Each <code>Page</code> is simply its <code>data</code> and a <code>dirty</code> flag to keep track of whether it changed. The structs use the rather new Rust feature of <a href="https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html"><code>const generics</code></a>.</p>
<pre><code><span><span><span>impl</span></span><span><span><span>&lt;</span>const PAGE_SIZE<span>:</span> <span>usize</span><span>&gt;</span></span></span><span> Vfs <span>for</span></span><span> <span>PagesVfs</span><span><span>&lt;</span>PAGE_SIZE<span>&gt;</span></span> </span><span><span><span>{</span>
    <span>type</span> <span>File</span> <span>=</span> <span>Pages<span>&lt;</span>PAGE_SIZE<span>&gt;</span></span><span>;</span>

    </span><span><span>}</span></span></span>

<span><span>struct</span> </span><span><span><span>Page</span><span><span>&lt;</span>const PAGE_SIZE<span>:</span> <span>usize</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
    <span>data</span><span>:</span> [<span>u8</span>; PAGE_SIZE],
    <span>dirty</span><span>:</span> <span>bool</span>,
</span><span><span>}</span></span></span>

<span><span>pub</span> <span>struct</span> </span><span><span><span>Pages</span><span><span>&lt;</span>const PAGE_SIZE<span>:</span> <span>usize</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
    <span>count</span><span>:</span> <span>usize</span>,
    <span>offset</span><span>:</span> <span>usize</span>,
    <span>blocks</span><span>:</span> <span>HashMap<span>&lt;</span><span>u32</span>, <span>Page<span>&lt;</span>PAGE_SIZE<span>&gt;</span></span><span>&gt;</span></span>,
</span><span><span>}</span></span></span>
</span></code></pre>
<p>The implementation of the trait is rather straight forward. I&#39;ll spare you all the boring details. Just one example, the <code>std::io::Read</code> is simply:</p>
<pre><code><span><span><span>impl</span></span><span><span><span>&lt;</span>const PAGE_SIZE<span>:</span> <span>usize</span><span>&gt;</span></span></span><span> Read <span>for</span></span><span> <span>Pages</span><span><span>&lt;</span>PAGE_SIZE<span>&gt;</span></span> </span><span><span><span>{</span>
    <span><span><span>fn</span> </span><span>read</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span>, <span>buf</span><span>:</span> <span>&amp;</span><span>mut</span> [<span>u8</span>]</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>std<span>::</span></span><span>io<span>::</span></span><span>Result<span>&lt;</span><span>usize</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>let</span> offset <span>=</span> <span>self</span>.offset <span>%</span> <span>PAGE_SIZE</span><span>;</span>
        <span>let</span> block <span>=</span> <span>self</span>.<span>current</span><span><span>(</span></span><span><span>)</span></span><span>?</span><span>;</span>
        <span>let</span> n <span>=</span> <span><span>(</span><span>&amp;</span>block.data<span><span>[</span>offset<span>..</span><span>]</span></span></span><span><span>)</span></span>.<span>read</span><span><span>(</span>buf</span><span><span>)</span></span><span>?</span><span>;</span>
        <span>self</span>.offset <span>+</span><span>=</span> n<span>;</span>
        <span>Ok</span><span><span>(</span>n</span><span><span>)</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>The main building-block for it and all other methods is to get the offset into a page via <code>self.offset % PAGE_SIZE</code>, and the index of the current page via <code>self.offset / PAGE_SIZE</code>.</p>
<p>Getting the current page and interacting with the external <code>get_page</code> and <code>put_page</code> mentioned at the beginning is thus a matter of:</p>
<pre><code><span><span><span>impl</span></span><span><span><span>&lt;</span>const PAGE_SIZE<span>:</span> <span>usize</span><span>&gt;</span></span></span><span> <span>Pages</span><span><span>&lt;</span>PAGE_SIZE<span>&gt;</span></span> </span><span><span><span>{</span>
    <span><span><span>fn</span> </span><span>current</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span>&amp;</span><span>mut</span> <span>Page<span>&lt;</span>PAGE_SIZE<span>&gt;</span></span>, <span>std<span>::</span></span><span>io<span>::</span></span>Error<span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>let</span> index <span>=</span> <span>self</span>.offset <span>/</span> <span>PAGE_SIZE</span><span>;</span>

        <span>if</span> <span>let</span> <span>Entry<span>::</span></span>Vacant<span><span>(</span>entry</span><span><span>)</span></span> <span>=</span> <span>self</span>.blocks.<span>entry</span><span><span>(</span>index <span>as</span> <span>u32</span></span><span><span>)</span></span> <span><span>{</span>
            <span>let</span> data <span>=</span> <span>Self</span><span><span>::</span></span>get_page<span><span>(</span>index <span>as</span> <span>u32</span></span><span><span>)</span></span><span>;</span>
            entry.<span>insert</span><span><span>(</span>Page <span><span>{</span>
                data<span>:</span> data.<span>unwrap_or_else</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>[</span><span>0</span><span>;</span> <span>PAGE_SIZE</span><span>]</span></span></span></span><span><span>)</span></span><span>,</span>
                dirty<span>:</span> <span>false</span><span>,</span>
            </span><span><span>}</span></span></span><span><span>)</span></span><span>;</span>
        </span><span><span>}</span></span>

        <span>Ok</span><span><span>(</span><span>self</span>.blocks.<span>get_mut</span><span><span>(</span><span>&amp;</span><span><span>(</span>index <span>as</span> <span>u32</span></span><span><span>)</span></span></span><span><span>)</span></span>.<span>unwrap</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span>
    </span><span><span>}</span></span></span>

    <span><span><span>pub</span> <span>fn</span> </span><span>get_page</span></span><span><span><span>(</span><span>ix</span><span>:</span> <span>u32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Option<span>&lt;</span><span><span>[</span><span>u8</span><span>;</span></span> PAGE_SIZE]<span>&gt;</span></span></span> </span><span><span><span>{</span>
            </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>put_page</span></span><span><span><span>(</span><span>ix</span><span>:</span> <span>u32</span>, <span>data</span><span>:</span> *const <span>u8</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
            </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>The whole code can be found here: <a href="https://github.com/rkusa/do-sqlite/blob/main/wasm/src/vfs.rs">github.com/rkusa/do-sqlite/blob/main/wasm/src/vfs.rs</a></p>
<p>It is maybe worth noting that I am no expert when it comes to <code>unsafe</code> Rust, so take the <code>unsafe</code> code in this repo with a grain of salt.</p>
<h2>Use the VFS in a DO<a href="#use-the-vfs-in-a-do" id="use-the-vfs-in-a-do" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>Using the VFS in a DO is – in theory – as simple as interacting with the DO&#39;s <a href="https://developers.cloudflare.com/workers/runtime-apis/durable-objects#transactional-storage-api">Transactional storage API</a> inside of the <code>get_page</code> and <code>put_page</code> methods in the previous code block.</p>
<p>This, however, doesn&#39;t work. The VFS is synchronous while calls to the storage are asynchronous. For example, the <code>get</code> method has the following signature:</p>
<pre><code><span><span><span>get</span></span><span><span>&lt;</span><span>T</span><span>&gt;</span></span><span>(</span><span>key</span>: <span>string</span><span>,</span> <span>options</span><span>?</span><span>:</span> <span>Object</span><span>)</span>: <span>Promise</span><span>&lt;</span><span>T</span> <span>|</span> <span>undefined</span><span>&gt;</span>
</span></code></pre>
<p>The worker runs, same as the browser, as a single thread using cooperative multitasking. It is thus impossible to await an asynchronous method in the synchronous context of the VFS. One might think one could just have an endless loop polling the promise (or future in the Rust context) until it is completed. But this is impossible in a single-threaded environment, since the endless loop would block forever and never switch to actually running any other async task. It would require at least two threads to do that (and it would be a bad idea even then).</p>
<p>Fortunately, the <a href="https://github.com/WebAssembly/binaryen"><code>wasm-opt</code></a> tool has an option to asyncify methods in a WASM. It therefore rewrites the WASM and allows to pause and resume the execution. This is exactly what I need to call async functions from within the sync context of the VFS.</p>
<p>It has one drawback though. I need control over how the WASM module is initialised so that I can use the <a href="https://github.com/GoogleChromeLabs/asyncify"><code>Asyncify</code> wrapper</a> and to provide the corresponding async imports. This is something I don&#39;t easily have control over using <code>worker-rs</code>, since <code>worker-rs</code> takes care of generating all the necessary JavaScript glue code for me.</p>
<p>So one step back. <code>worker-rs</code> cannot be used. At least for now – I am sure there is a way to make it work. But the easier way forward is to write the worker and DO in JavaScript and write a WASM module that only takes care of querying the SQLite database.</p>
<h2>Target: <code>wasm32-unknown-unknown</code> vs <code>wasm32-wasi</code><a href="#target--wasm32-unknown-unknown-vs-wasm32-wasi" id="target--wasm32-unknown-unknown-vs-wasm32-wasi" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>Before diving into the asyncification, I have take full control over the WASM initialisation and thus its imports and exports.</p>
<p>While I could theoretically still build for <code>wasm32-unknown-unknown</code>, this target has a major drawback. A lot of libraries automatically use <a href="https://github.com/rustwasm/wasm-bindgen"><code>wasm-bindgen</code></a> as soon as you build for it.</p>
<p>I want control over the module initialisation, which means that I am writing the glue code for JavaScript myself. This doesn&#39;t work if my dependencies assume <code>wasm-bindgen</code> and generate an endless amount of <code>__wbindgen</code> imports and exports. Let&#39;s inspect the build for <code>wasm32-unknown-unknown</code>.</p>
<pre><code><span><span><span>wasmer</span></span><span> inspect target/wasm32-unknown-unknown/release/do_sqlite.wasm</span>
</span></code></pre>
<p>Excerpt of the output:</p>
<pre><code>Imports:
  Functions:
    &#34;__wbindgen_placeholder__&#34;.&#34;__wbindgen_describe&#34;: [I32] -&gt; []
    &#34;__wbindgen_placeholder__&#34;.&#34;__wbg_getRandomValues_98117e9a7e993920&#34;: [I32, I32] -&gt; []
    &#34;__wbindgen_placeholder__&#34;.&#34;__wbg_randomFillSync_64cc7d048f228ca8&#34;: [I32, I32, I32] -&gt; []
    &#34;__wbindgen_placeholder__&#34;.&#34;__wbg_process_2f24d6544ea7b200&#34;: [I32] -&gt; [I32]
    &#34;__wbindgen_placeholder__&#34;.&#34;__wbindgen_is_object&#34;: [I32] -&gt; [I32]
    &#34;__wbindgen_placeholder__&#34;.&#34;__wbg_versions_6164651e75405d4a&#34;: [I32] -&gt; [I32]
    ...
  Memories:
  Tables:
  Globals:
Exports:
  Functions:
    &#34;__wbindgen_describe___wbg_crypto_98fc271021c7d2ad&#34;: [] -&gt; []
    &#34;__wbindgen_describe___wbg_getRandomValues_98117e9a7e993920&#34;: [] -&gt; []
    &#34;__wbindgen_describe___wbg_modulerequire_3440a4bcf44437db&#34;: [] -&gt; []
    &#34;__wbindgen_describe___wbg_randomFillSync_64cc7d048f228ca8&#34;: [] -&gt; []
    &#34;__wbindgen_describe___wbg_msCrypto_a2cdb043d2bfe57f&#34;: [] -&gt; []
    ...
</code></pre>
<p>I had to trim down the output a lot. There are 716 imports/exports in total that have the <code>__wbindgen</code> prefix.</p>
<p>So <code>wasm32-unknown-unknown</code> simply isn&#39;t going to work. I need kind of a <em>neutral</em> WASM target. Let&#39;s see what WASM targets we can choose from:</p>
<pre><code><span><span><span><span><span>%</span></span></span></span><span> rustup target list</span> <span>|</span> <span><span>grep</span></span><span> wasm</span>
<span><span>wasm32-unknown-emscripten</span></span><span> (installed</span><span></span><span>)</span>
<span><span>wasm32-unknown-unknown</span></span><span> (installed</span><span></span><span>)</span>
<span><span>wasm32-wasi</span></span><span> (installed</span><span></span><span>)</span>
</span></code></pre>
<p>The <code>emscripten</code> target also assumes JavaScript glue code from my experience, so <code>wasm32-wasi</code> is the only one left - so I am going with that.</p>
<h2>Build SQLite for WASI for <code>wasm32-wasi</code><a href="#build-sqlite-for-wasi-for-wasm32-wasi" id="build-sqlite-for-wasi-for-wasm32-wasi" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>If you are wondering, WASI is <em>a modular system interface for WebAssembly</em>. Head over to <a href="https://wasi.dev">wasi.dev</a> for a more detailed introduction.</p>
<p>There is some work required to get <code>rusqlite</code> to build for <code>wasm32-wasi</code>. Let&#39;s walk through all errors and their solutions.</p>
<pre><code><span><span><span>cargo</span></span><span> build<span><span> --</span>target</span> wasm32-wasi</span>
</span></code></pre>
<p>Similar to trying to build for <code>wasm32-unknown-unknown</code>, it complains about not finding <code>stdio.h</code>.</p>
<pre><code><span><span>cargo:warning</span><span>=</span><span>sqlite3/sqlite3.c:13699:10:</span> <span><span>fatal</span></span><span> error: <span><span>&#39;</span>stdio.h<span>&#39;</span></span> file not found</span>
<span>cargo:warning</span><span>=</span><span>#include</span> <span></span><span><span>&lt;</span>stdio.h<span>&gt;</span>
</span><span>cargo:warning</span><span>=</span>         <span><span>^<span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span></span></span>
<span>cargo:warning</span><span>=</span><span>1</span> <span><span>error</span></span><span> generated.</span>
</span></code></pre>
<p>The previously <a href="https://github.com/rusqlite/rusqlite/pull/1010">mentioned PR for <code>wasm32-unknown-unknown</code> compatibility</a> solved this by including libc <code>.c</code> files from OpenBSD. My go to solution is different though. I prefer to build using the <a href="https://github.com/WebAssembly/wasi-sdk"><code>wasi-sdk</code></a> (a WASI-enabled WebAssembly C/C++ toolchain).</p>
<p>At first we need to build the <code>wasi-sdk</code>. Here is a shell script I am using for that in various projects (you might have to install <code>cmake</code> and/or <code>ninja</code>: <code>brew install cmake ninja</code>):</p>
<pre><code><span><span><span>set</span></span><span> <span><span>-</span>e</span></span>
<span><span>cd</span></span><span> wasm</span>
<span><span>git</span></span><span> clone<span><span> --</span>branch</span> wasi-sdk-14 https://github.com/WebAssembly/wasi-sdk.git</span>
<span><span>cd</span></span><span> wasi-sdk</span>
<span><span>git</span></span><span> submodule update<span><span> --</span>init</span><span><span> --</span>recursive</span></span>
<span>NINJA_FLAGS</span><span>=</span><span>-v</span> <span><span>make</span></span><span> package</span>
<span><span>tar</span></span><span><span><span> -</span>xzf</span> dist/wasi-sdk-<span>*</span>.tar.gz<span><span> -</span>C</span> dist</span>
</span></code></pre>
<p>This clones and builds the <code>wasi-sdk</code> into <code>./wasm/wasi-sdk</code>. The build toolchain can then be found at <code>./wasm/wasi-sdk/dist/wasi-sdk-14.0/bin</code>, and the WASI sysroot at <code>./wasm/wasi-sdk/dist/wasi-sdk-14.0/share/wasi-sysroot</code>. The build will take a while (~15min on my M1). Alternatively, if you are not on a Mac ARM, you can use a <a href="https://github.com/WebAssembly/wasi-sdk/releases/tag/wasi-sdk-14">prebuild sysroot and binaries</a> instead.</p>
<p>I found that the easiest way to get cargo to use all the build tools from the <code>wasi-sdk</code> is to prepend the <code>PATH</code> env var with the <code>bin</code> directory of the <code>wasi-sdk</code> build. While I usually prefer calling <code>cargo</code> directly and setup everything else in <code>.config/cargo.toml</code>, I couldn&#39;t find a way to set all build tools in <code>.config/cargo.toml</code>. So a Makefile it is. After putting everything together, the Makefile (at <code>./wasm/Makefile</code>) looks like:</p>
<pre><code><span><span><span>ifndef</span> DEBUG</span>
<span>	cargo_build_flags</span> <span>+=</span> <span>--release</span>
<span>endif</span>

<span><span>.PHONY</span></span><span>:</span> <span><span>build</span></span><span>
</span><span><span>build</span></span><span>:</span>
<span></span><span></span><span>	<span><span>PATH</span><span>=</span><span><span><span>&#34;</span><span>$(</span><span>shell</span> <span><span><span>pwd</span></span></span><span>)</span>/wasi-sdk/dist/wasi-sdk-14.0/bin:<span><span>${</span>PATH<span>}</span></span><span>&#34;</span></span></span> <span>\</span>
	<span><span>CFLAGS</span></span><span>=<span><span>&#34;</span>--sysroot=<span>$(</span><span>shell</span> <span><span><span>pwd</span></span></span><span>)</span>/wasi-sdk/dist/wasi-sdk-14.0/share/wasi-sysroot<span>&#34;</span></span> <span>\</span>
		cargo build<span><span> --</span>target</span> wasm32-wasi <span><span>$(</span>cargo_build_flags<span>)</span></span></span></span>
</span></span></code></pre>
<p>With the Makefile above, <code>make build</code> creates a release build, and <code>make build DEBUG=1</code> builds a debug build.</p>
<p>Let&#39;s try building again:</p>
<pre><code><span><span><span>make</span></span><span> build</span>
</span></code></pre>
<p>The previous error is fixed, but a new one is thrown. It now complains about not finding <code>pthread.h</code>.</p>
<pre><code><span><span>cargo:warning</span><span>=</span><span>sqlite3/sqlite3.c:27215:10:</span> <span><span>fatal</span></span><span> error: <span><span>&#39;</span>pthread.h<span>&#39;</span></span> file not found</span>
<span>cargo:warning</span><span>=</span><span>#include</span> <span></span><span><span>&lt;</span>pthread.h<span>&gt;</span>
</span><span>cargo:warning</span><span>=</span>         <span><span>^<span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span><span><span>~</span></span></span></span>
<span>cargo:warning</span><span>=</span><span>1</span> <span><span>error</span></span><span> generated.</span>
</span></code></pre>
<p>The <code>wasi-sdk</code> doesn&#39;t have support for <code>pthread.h</code> yet (see <a href="https://github.com/WebAssembly/wasi-libc/issues/209">WebAssembly/wasi-libc#209</a>). A workaround for most libraries is to look at build flags that remove everything related to pthreads from the library you are trying to build.</p>
<p>In case of SQLite, I found various flags to achieve that. One being <a href="https://www.sqlite.org/compile.html#threadsafe">SQLITE_THREADSAFE=0`</a>, which disables code used to operate sqlite safely in multithreaded environments. I&#39;d assume our WASM to be single-threaded, so I think I&#39;d be safe to disable it. However, I didn&#39;t dig deeper into this, because adding this build flag brings us to the next set of errors:</p>
<pre><code><span><span>cargo:warning</span><span>=</span><span>#error</span> <span><span><span><span>&#34;</span>WASI lacks a true mmap; to enable minimal mmap emulation, <span>\
</span>cargo:warning= ^
cargo:warning=sqlite3/sqlite3.c:34696:42: error: use of undeclared identifier &#39;fchmod&#39;
cargo:warning=  { <span>&#34;</span></span>fchmod<span><span>&#34;</span>,       (sqlite3_syscall_ptr)fchmod,          0  },
cargo:warning=                                         ^
cargo:warning=sqlite3/sqlite3.c:34719:42: error: use of undeclared identifier &#39;fchown&#39;
cargo:warning=  { <span>&#34;</span></span>fchown<span><span>&#34;</span>,       (sqlite3_syscall_ptr)fchown,          0 },
cargo:warning=                                         ^
cargo:warning=sqlite3/sqlite3.c:34726:42: error: use of undeclared identifier &#39;geteuid&#39;
cargo:warning=  { <span>&#34;</span></span>geteuid<span><span>&#34;</span>,      (sqlite3_syscall_ptr)geteuid,         0 },
cargo:warning=                                         ^
cargo:warning=sqlite3/sqlite3.c:34733:42: error: use of undeclared identifier &#39;mmap&#39;
cargo:warning=  { <span>&#34;</span></span>mmap<span><span>&#34;</span>,         (sqlite3_syscall_ptr)mmap,            0 },
cargo:warning=                                         ^
cargo:warning=sqlite3/sqlite3.c:34740:42: error: use of undeclared identifier &#39;munmap&#39;
cargo:warning=  { <span>&#34;</span></span>munmap<span><span>&#34;</span>,       (sqlite3_syscall_ptr)munmap,          0 },
cargo:warning=                                         ^
cargo:warning=sqlite3/sqlite3.c:34822:22: error: invalid application of &#39;sizeof&#39; to an incomplete type &#39;struct unix_syscall []&#39;
cargo:warning=    for(i=0; i&lt;sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
cargo:warning=                     ^~~~~~~~~~
...
</span></span></span></span></code></pre>
<p>This looks a lot like OS specific stuff that is not available in WASI. While looking into how to get rid of this code, I found the <code>SQLITE_OS_OTHER</code> flag. When this flag is set, built-in OS interfaces (for Unix, Windows, and OS/2) are omitted. Exactly what I was looking for.</p>
<p>Let&#39;s try building again.</p>
<pre><code><span><span><span>make</span></span><span> build</span>
</span></code></pre>
<p>Aaannndd... it builds!</p>
<p>I also found out that with <code>SQLITE_OS_OTHER</code> being set, it doesn&#39;t seem to matter anymore whether <code>SQLITE_THREADSAFE</code> is set to <code>1</code> or <code>0</code> - both build.</p>
<p>There is a PR for <code>rusqlite</code> now, to fix its WASI compatibility (<a href="https://github.com/rusqlite/rusqlite/pull/1116"><code>rusqlite/rusqlite#1116</code></a>; someone beat me to it).</p>
<p>While it builds now, does it also run? Nope. Trying to run it fails with:</p>
<pre><code>WebAssembly.instantiate(): Import #1 module=\&#34;env\&#34; function=\&#34;sqlite3_os_init\&#34; error: function import requires a callable
</code></pre>
<p>But this was to be expected, as <a href="https://www.sqlite.org/compile.html">the docs</a> clearly state:</p>
<blockquote>
<p>Applications must also supply implementations for the <code>sqlite3_os_init()</code> and <code>sqlite3_os_end()</code> interfaces. The usual practice is for the supplied <code>sqlite3_os_init()</code> to invoke <code>sqlite3_vfs_register()</code>. SQLite will automatically invoke <code>sqlite3_os_init()</code> when it initializes.</p>
</blockquote>
<p>A minimal <code>sqlite3_os_init</code> would simply register a custom virtual file system:</p>
<pre><code><span><span><span>#</span><span>[</span><span>no_mangle</span><span>]</span></span>
<span>extern</span> <span><span>&#34;</span>C<span>&#34;</span></span> <span><span><span>fn</span> </span><span>sqlite3_os_init</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>i32</span></span> </span><span><span><span>{</span>
    <span>ffi<span>::</span></span>sqlite3_vfs_register<span><span>(</span><span>CUSTOM_VFS</span><span>,</span> <span>false</span> <span>as</span> <span>i32</span></span><span><span>)</span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>As a side-note, if <code>sqlite3_os_init</code> isn&#39;t registering a VFS, or if it isn&#39;t returning <code>0</code> (as in no error), you might get a rather unhelpful error like:</p>
<pre><code>RuntimeError: unreachable
    at wasm://wasm/010bf20e:wasm-function[1716]:0x2a1b64
    at wasm://wasm/010bf20e:wasm-function[1764]:0x2a84cb
    at wasm://wasm/010bf20e:wasm-function[1782]:0x2aa2e3
    at wasm://wasm/010bf20e:wasm-function[1829]:0x2b3a23
</code></pre>
<p>With being able to build SQLite for <code>wasm32-wasi</code>, we can continue looking into how to initialise and use it.</p>
<h2>WASI imports<a href="#wasi-imports" id="wasi-imports" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>When inspecting the build WASM module, you find various required imports:</p>
<pre><code><span><span><span>wasmer</span></span><span> inspect target/wasm32-wasi/release/do_sqlite.wasm </span>
</span></code></pre>
<pre><code>Imports:
  Functions:
    &#34;wasi_snapshot_preview1&#34;.&#34;random_get&#34;: [I32, I32] -&gt; [I32]
    &#34;wasi_snapshot_preview1&#34;.&#34;clock_time_get&#34;: [I32, I64, I32] -&gt; [I32]
    &#34;wasi_snapshot_preview1&#34;.&#34;fd_write&#34;: [I32, I32, I32, I32] -&gt; [I32]
    &#34;wasi_snapshot_preview1&#34;.&#34;poll_oneoff&#34;: [I32, I32, I32, I32] -&gt; [I32]
    &#34;wasi_snapshot_preview1&#34;.&#34;environ_get&#34;: [I32, I32] -&gt; [I32]
    &#34;wasi_snapshot_preview1&#34;.&#34;environ_sizes_get&#34;: [I32, I32] -&gt; [I32]
    &#34;wasi_snapshot_preview1&#34;.&#34;proc_exit&#34;: [I32] -&gt; []
</code></pre>
<p>WASI offers a huge amount of methods. Fortunately, it is modular and our module will only require the once that are actually used. We have to provide the once it uses or the WASM module isn&#39;t going to run otherwise.</p>
<p>While there is a WASI implementation for Workers: <a href="https://github.com/cloudflare/workers-wasi"><code>cloudflare/workers-wasi</code></a>, I prefer to implement each import manually - especially when there are so few and especially while I am still experimenting. This helps me to keep the full picture of what&#39;s going on.</p>
<p>Providing my own implementation basically looks like:</p>
<pre><code><span><span><span>const</span> <span><span><span>instance</span></span> </span><span>=</span> <span>await</span> <span><span>WebAssembly</span><span>.</span><span>instantiate</span></span><span>(</span><span>module</span><span>,</span> <span><span>{</span>
  <span><span>wasi_snapshot_preview1</span></span><span><span><span>:</span></span> <span><span>{</span>

<span>    <span><span>random_get</span></span><span><span>(</span><span>offset</span><span><span>:</span> <span>number</span></span><span>,</span> <span>length</span><span><span>:</span> <span>number</span></span><span>)</span></span> <span><span>{</span>
      <span><span>const</span> <span><span><span>buffer</span></span> </span><span>=</span> <span><span>new</span> <span><span>Uint8Array</span></span><span>(</span>
        <span>instance</span><span>.</span><span>exports</span><span>.</span><span>memory</span><span>.</span><span>buffer</span><span>,</span>
        <span>offset</span><span>,</span>
        <span>length</span>
      <span>)</span></span></span><span>;</span>
      <span><span>crypto</span><span>.</span><span>getRandomValues</span></span><span>(</span><span>buffer</span><span>)</span><span>;</span>

      <span>return</span> <span>ERRNO_SUCCESS</span><span>;</span>
    <span>}</span></span></span><span>,</span>


<span>    <span><span>clock_time_get</span></span><span><span>(</span><span>)</span></span> <span><span>{</span>
      <span>throw</span> <span><span>new</span> <span><span>Error</span></span><span>(</span><span><span>&#34;</span>clock_time_get not implemented<span>&#34;</span></span><span>)</span></span><span>;</span>
    <span>}</span></span></span><span>,</span>
    

</span></span></span></span></span></code></pre>
<p>The imports are specified when instantiating the WASM module, and are added under the <code>wasi_snapshot_preview1</code> namespace. As hinted in the snippet above (for <code>clock_time_get</code>), I usually throw a not implemented error for all imports at first, and only implement them when I see them being used.</p>
<p>The <code>fd_write</code> is a special one, because I usually only implement it for <code>stdout</code> and <code>stderr</code> and not any other file descriptor (so not for actual files):</p>
<pre><code><span><span><span>fd_write</span></span><span>(</span>
  <span>fd</span>: <span>number</span><span>,</span>
  <span>iovsOffset</span>: <span>number</span><span>,</span>
  <span>iovsLength</span>: <span>number</span><span>,</span>
  <span>nwrittenOffset</span>: <span>number</span>
<span>)</span> <span><span>{</span>
  <span>if</span> <span>(</span><span>fd</span> <span>!==</span> <span>1</span> <span>&amp;&amp;</span> <span>fd</span> <span>!==</span> <span>2</span><span>)</span> <span><span>{</span>
    <span>return</span> <span>ERRNO_BADF</span><span>;</span>
  <span>}</span></span>

  <span><span>const</span> <span><span><span>decoder</span></span> </span><span>=</span> <span><span>new</span> <span><span>TextDecoder</span></span><span>(</span><span>)</span></span></span><span>;</span>
  <span><span>const</span> <span><span><span>memoryView</span></span> </span><span>=</span> <span><span>new</span> <span><span>DataView</span></span><span>(</span><span>instance</span><span>.</span><span>exports</span><span>.</span><span>memory</span><span>.</span><span>buffer</span><span>)</span></span></span><span>;</span>
  <span><span>let</span> <span><span><span>nwritten</span></span> </span><span>=</span> <span>0</span></span><span>;</span>
  <span>for</span> <span>(</span><span><span>let</span> <span><span><span>i</span></span> </span><span>=</span> <span>0</span></span><span>;</span> <span>i</span> <span>&lt;</span> <span>iovsLength</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span><span>{</span>
    <span><span>const</span> <span><span><span>dataOffset</span></span> </span><span>=</span> <span><span>memoryView</span><span>.</span><span>getUint32</span></span><span>(</span><span>iovsOffset</span><span>,</span> <span>true</span><span>)</span></span><span>;</span>
    <span>iovsOffset</span> <span>+=</span> <span>4</span><span>;</span>

    <span><span>const</span> <span><span><span>dataLength</span></span> </span><span>=</span> <span><span>memoryView</span><span>.</span><span>getUint32</span></span><span>(</span><span>iovsOffset</span><span>,</span> <span>true</span><span>)</span></span><span>;</span>
    <span>iovsOffset</span> <span>+=</span> <span>4</span><span>;</span>

    <span><span>const</span> <span><span><span>data</span></span> </span><span>=</span> <span><span>new</span> <span><span>Uint8Array</span></span><span>(</span>
      <span>instance</span><span>.</span><span>exports</span><span>.</span><span>memory</span><span>.</span><span>buffer</span><span>,</span>
      <span>dataOffset</span><span>,</span>
      <span>dataLength</span>
    <span>)</span></span></span><span>;</span>
    <span><span>const</span> <span><span><span>s</span></span> </span><span>=</span> <span><span>decoder</span><span>.</span><span>decode</span></span><span>(</span><span>data</span><span>)</span></span><span>;</span>
    <span>nwritten</span> <span>+=</span> <span>data</span><span>.</span><span>byteLength</span><span>;</span>
    <span><span><span>switch</span> <span>(</span><span>fd</span><span>)</span></span> <span><span>{</span>
      <span><span>case</span> <span>1</span></span><span><span>:</span></span> 
        <span><span>console</span><span>.</span><span>log</span></span><span>(</span><span>s</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span><span>case</span> <span>2</span></span><span><span>:</span></span> 
        <span><span>console</span><span>.</span><span>error</span></span><span>(</span><span>s</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span><span>default</span></span><span><span>:</span></span>
        <span>return</span> <span>ERRNO_BADF</span><span>;</span>
    </span><span>}</span></span>
  <span>}</span></span>

  <span><span>memoryView</span><span>.</span><span>setUint32</span></span><span>(</span><span>nwrittenOffset</span><span>,</span> <span>nwritten</span><span>,</span> <span>true</span><span>)</span><span>;</span>

  <span>return</span> <span>ERRNO_SUCCESS</span><span>;</span>
<span>}</span></span>
</span></code></pre>
<p>With that out of the way, it is time to get back to asyncifying the WASM module.</p>
<h2>Asyncify WASM<a href="#asyncify-wasm" id="asyncify-wasm" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>As a recap, the asyncification is necessary to call the async storage APIs from the sync VFS.</p>
<p>The asyncification is achieved by unwinding and rewinding the local stack. With <code>wasm-opt</code>, this is done on a WASM level as post-build transformation. This makes it a language-agnostic approach. Once a WASM module is asyncified it needs to be used through the JavaScript wrapper <a href="https://github.com/GoogleChromeLabs/asyncify"><code>Asyncify</code></a>. A good introduction into asyncify can be found here: <a href="https://web.dev/asyncify/">Using asynchronous web APIs from WebAssembly</a>.</p>
<p>This is how it is used. First I had to add WASM imports, which correspond to external functions in Rust:</p>
<pre><code><span><span>extern</span> <span><span>&#34;</span>C<span>&#34;</span></span> <span><span>{</span>
    <span><span><span>pub</span> <span>fn</span> </span><span>get_page</span></span><span><span><span>(</span><span>ix</span><span>:</span> <span>u32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> </span></span><span>*</span><span>mut</span> <span>u8</span><span>;</span>
    <span><span><span>pub</span> <span>fn</span> </span><span>put_page</span></span><span><span><span>(</span><span>ix</span><span>:</span> <span>u32</span>, <span>ptr</span><span>:</span> *const <span>u8</span></span><span><span><span>)</span></span></span></span><span>;</span>
</span><span><span>}</span></span>
</span></code></pre>
<p>I am then using those imports in my VFS:</p>
<pre><code><span><span><span>impl</span></span><span><span><span>&lt;</span>const PAGE_SIZE<span>:</span> <span>usize</span><span>&gt;</span></span></span><span> <span>Pages</span><span><span>&lt;</span>PAGE_SIZE<span>&gt;</span></span> </span><span><span><span>{</span>
    <span><span><span>pub</span> <span>fn</span> </span><span>get_page</span></span><span><span><span>(</span><span>ix</span><span>:</span> <span>u32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Option<span>&lt;</span><span><span>[</span><span>u8</span><span>;</span></span> PAGE_SIZE]<span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>unsafe</span> <span><span>{</span>
            <span>let</span> ptr <span>=</span> <span>crate</span><span><span>::</span></span>get_page<span><span>(</span>ix</span><span><span>)</span></span><span>;</span>
            <span>if</span> ptr.<span>is_null</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
                <span>None</span>
            </span><span><span>}</span></span> <span>else</span> <span><span>{</span>
                <span>let</span> slice <span>=</span> <span>slice<span>::</span></span>from_raw_parts_mut<span><span>(</span>ptr<span>,</span> <span>PAGE_SIZE</span></span><span><span>)</span></span><span>;</span>
                slice<span><span>[</span><span>..</span><span>]</span></span>.<span>try_into</span><span><span>(</span></span><span><span>)</span></span>.<span>ok</span><span><span>(</span></span><span><span>)</span></span>
            </span><span><span>}</span></span>
        </span><span><span>}</span></span>
    </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>put_page</span></span><span><span><span>(</span><span>ix</span><span>:</span> <span>u32</span>, <span>data</span><span>:</span> <span>&amp;</span>[<span>u8</span>; PAGE_SIZE]</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
        <span>unsafe</span> <span><span>{</span>
            <span>crate</span><span><span>::</span></span>put_page<span><span>(</span>ix<span>,</span> data.<span>as_ptr</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
        </span><span><span>}</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>With that integrated, I can build the WASM file as done previously and once build, post-process it via <code>wasm-opt</code>:</p>
<pre><code><span><span><span>wasm-opt</span></span><span><span><span> -</span>O</span><span><span> --</span>asyncify</span><span><span> --</span>pass-arg</span> <a href="https://ma.rkusa.st/cdn-cgi/l/email-protection" data-cfemail="f19082889f92989788dc989c819e838582b1949f87df818485">[email protected]</a>_page,env.get_page <span>\
</span>  wasm/target/wasm32-wasi/release/do_sqlite.wasm <span>\
</span><span><span>  -</span>o</span> dist/do_sqlite.wasm</span>
</span></code></pre>
<p>The flags <code>--asyncify --pass-arg <a href="https://ma.rkusa.st/cdn-cgi/l/email-protection" data-cfemail="e687959f88858f809fcb8f8b9689949295a6838890c8969392">[email protected]</a>_page,env.get_page</code> tell the tool that both the <code>put_page</code> and <code>get_page</code> imports are asynchronous.</p>
<p>I then have to initialise the WASM module using the <code>Asyncify</code> wrapper and provide async implementations of <code>get_page</code> and <code>put_page</code>:</p>
<pre><code><span><span><span>const</span> <span><span><span>instance</span></span> </span><span>=</span> <span>await</span> <span><span>Asyncify</span><span>.</span><span>instantiate</span></span><span>(</span><span>module</span><span>,</span> <span><span>{</span>
  <span><span>env</span></span><span><span><span>:</span></span> <span><span>{</span>
    <span><span>async</span> <span><span>get_page</span></span><span><span>(</span><span>ix</span><span><span>:</span> <span>number</span></span><span>)</span></span><span><span>:</span> <span>Promise</span><span><span>&lt;</span></span><span><span>number</span></span><span><span>&gt;</span></span> </span><span><span>{</span>
      <span><span>const</span> <span><span><span>page</span></span><span><span>:</span> <span>Array</span><span><span>&lt;</span></span><span><span>number</span></span><span><span>&gt;</span></span> </span></span><span>=</span>
        <span>(</span><span>await</span> <span><span>storage</span><span>.</span><span>get</span></span><span><span>&lt;</span><span>Array</span><span><span>&lt;</span></span><span><span>number</span></span><span><span>&gt;</span></span><span>&gt;</span></span><span>(</span><span><span>String</span></span><span>(</span><span>ix</span><span>)</span><span>)</span><span>)</span> <span>??</span> <span><span>new</span> <span><span>Array</span></span><span>(</span><span>4096</span><span>)</span></span></span><span>;</span>

      <span><span>const</span> <span><span><span>offset</span></span><span><span>:</span> <span>number</span> </span></span><span>=</span> <span>await</span> <span>(</span><span>instance</span><span>.</span><span>exports</span><span>.</span><span>alloc</span> <span>as</span> <span>Function</span><span>)</span><span>(</span>
        <span>4096</span>
      <span>)</span></span><span>;</span>
      <span><span>const</span> <span><span><span>dst</span></span> </span><span>=</span> <span><span>new</span> <span><span>Uint8Array</span></span><span>(</span>
        <span>(</span><span>instance</span><span>.</span><span>exports</span><span>.</span><span>memory</span> <span>as</span> <span>WebAssembly</span><span>.</span><span>Memory</span><span>)</span><span>.</span><span>buffer</span><span>,</span>
        <span>offset</span><span>,</span>
        <span>4096</span>
      <span>)</span></span></span><span>;</span>
      <span><span>dst</span><span>.</span><span>set</span></span><span>(</span><span><span>Array</span><span>.</span><span>from</span></span><span>(</span><span><span>new</span> <span><span>Uint8Array</span></span><span>(</span><span>page</span><span>)</span></span><span>)</span><span>)</span><span>;</span>

      <span>return</span> <span>offset</span><span>;</span>
    <span>}</span></span></span><span>,</span>

    <span><span>async</span> <span><span>put_page</span></span><span><span>(</span><span>ix</span><span><span>:</span> <span>number</span></span><span>,</span> <span>ptr</span><span><span>:</span> <span>number</span></span><span>)</span></span> <span><span>{</span>
      <span><span>const</span> <span><span><span>page</span></span> </span><span>=</span> <span><span>new</span> <span><span>Uint8Array</span></span><span>(</span>
        <span>(</span><span>instance</span><span>.</span><span>exports</span><span>.</span><span>memory</span> <span>as</span> <span>WebAssembly</span><span>.</span><span>Memory</span><span>)</span><span>.</span><span>buffer</span><span>,</span>
        <span>ptr</span><span>,</span>
        <span>4096</span>
      <span>)</span></span></span><span>;</span>
      <span>await</span> <span><span>storage</span><span>.</span><span>put</span></span><span>(</span><span><span>String</span></span><span>(</span><span>ix</span><span>)</span><span>,</span> <span><span>Array</span><span>.</span><span>from</span></span><span>(</span><span>page</span><span>)</span><span>,</span> <span><span>{</span><span>}</span></span><span>)</span><span>;</span>
    <span>}</span></span></span><span>,</span>
  <span>}</span></span></span><span>,</span>
<span>}</span></span><span>)</span></span><span>;</span>
</span></code></pre>
<p>That&#39;s it. The WASM module is now able to interact with the async storage APIs.</p>
<h2>Increase Asyncify Stack Size<a href="#increase-asyncify-stack-size" id="increase-asyncify-stack-size" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>With all pieces together now, does it run? Yes and not. Depending on the query I&#39;ve tested, I ran into yet another very helpful error:</p>
<pre><code>RuntimeError: unreachable
    at wasm://wasm/010bf772:wasm-function[1833]:0x2b3c6e
</code></pre>
<p>Some <code>println!()</code> debugging later, I&#39;ve found that the error happens once the WASM execution is resumed. When the WASM execution is paused, all locals at the point of pausing are saved. Before execution is resumed, all those locals are restored. <code>Asyncify</code> allocates memory to persist those locals between pausing and resuming. This memory has a size of <code>1024</code> byte and is apparently simply not enough for this use-case.</p>
<p>The stack size is unfortunately not configurable. According to <a href="https://github.com/GoogleChromeLabs/asyncify/blob/master/asyncify.mjs#L17-L27"><code>Asyncify</code>&#39;s code</a>, it assumes that the first 1024 bytes of the WASM memory are unused uses that. I&#39;d rather properly allocate memory for it. Since it is writing the stack start and end locations at an offset of 16, I simply overwrite those values with the location of a bigger and properly allocated memory location for now:</p>
<pre><code><span><span><span>const</span> <span><span><span>STACK_SIZE</span></span> </span><span>=</span> <span>4096</span></span><span>;</span>
<span><span>const</span> <span><span><span>DATA_ADDR</span></span> </span><span>=</span> <span>16</span></span><span>;</span>
<span><span>const</span> <span><span><span>ptr</span></span> </span><span>=</span> <span>await</span> <span><span>exports</span><span>.</span><span>alloc</span></span><span>(</span><span>STACK_SIZE</span><span>)</span></span><span>;</span>
<span><span>new</span> <span><span>Int32Array</span></span><span>(</span><span>exports</span><span>.</span><span>memory</span><span>.</span><span>buffer</span><span>,</span> <span>DATA_ADDR</span><span>,</span> <span>2</span><span>)</span><span><span>.</span><span>set</span></span><span>(</span><span><span>[</span>
  <span>ptr</span><span>,</span>
  <span>ptr</span> <span>+</span> <span>STACK_SIZE</span><span>,</span>
<span>]</span></span><span>)</span></span><span>;</span>
</span></code></pre>
<p>That&#39;s it. With that I had SQLite running in a Cloudflare Durable Object.</p>
<h2>Conclusion<a href="#conclusion" id="conclusion" aria-hidden="true" tabindex="-1"><svg fill="none" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
</svg></a></h2>
<p>Let me emphasise again: this is just an experiment. It is not in a state where I&#39;d use it for an actual app yet. Here are some open points / concerns / future work:</p>
<ul>
<li>I am setting SQLite&#39;s journal mode to <code>memory</code> right now, which could lead to data loss. I&#39;d have to extend the VFS to be capable of also persisting the journal file into the DO.</li>
<li>I am not happy with the the overhead that comes with pausing/resuming via <code>Asyncify</code>.</li>
<li>I have a bad feeling about <code>Asyncify</code>&#39;s stack size. I could imagine that I&#39;d have to increase it further the more the database grows / or the larger the query result is.</li>
<li>The 128MB memory size of Workers might be a limiting factor when the database grows to a certain size. A possible improvement here would be to use a LRU cache for the pages and basically dispose pages that have been read in the past, but were not used recently.</li>
<li>I need to make some more research and testing to be sure that the DO isn&#39;t writing to the storage concurrently.</li>
<li>The current solution isn&#39;t capable of running DB transactions across multiple calls to the DO (and might never be actually).</li>
<li>I&#39;d need to make an estimation of the expected costs of running SQLite on a DO to feel save actually deploying it for an app.</li>
<li>A replication between multiple DO&#39;s living on different Cloudflare locations would be neat (maybe based on <a href="https://litestream.io/">litestream.io</a>).</li>
</ul>
<p>The code can be found here:</p>
<ul>
<li><a href="https://github.com/rkusa/sqlite-vfs">github.com/rkusa/sqlite-vfs</a></li>
<li><a href="https://github.com/rkusa/do-sqlite">github.com/rkusa/do-sqlite</a></li>
<li><a href="https://github.com/rkusa/wasm-sqlite">github.com/rkusa/wasm-sqlite</a></li>
</ul>
<p>I&#39;ll continue experimenting.</p>
</section></div>
  </body>
</html>
