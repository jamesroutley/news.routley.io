<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jappie.me/death-to-type-classes.html">Original</a>
    <h1>Death to Type Classes</h1>
    
    <div id="readability-page-1" class="page"><div><figure><img alt="Death (XIII) tarot card" src="https://jappie.me/images/2025/death-2.jpg"/><figcaption> Death (<span>XIII</span>) Symbolizes significant change, transformation, and endings, rather than literal physical death. </figcaption></figure><p>Have you ever seen a Number grazing in the fields? Or a Functor chirping in the trees? No? That‚Äôs because they‚Äôre <span>LIES</span>. <span>LIES</span> told by the bourgeoisie to keep common folk down. But I say <span>NO</span>, no longer shall we be kept down by deceit! Come brothers and sisters, come and let us create a system of values. Where values are no longer constrained by their type class, but instead merged as a signature into a module. Come comrades, let us open the¬†Backpack.</p><p>Here we explore an alternative universe where we neglect the existence of type classes in favor of the Backpack module system. This ends up looking like <a href="https://ocaml.org/">OCaml</a> in <a href="https://www.haskell.org/?uwu=true">Haskell</a>. Let us begin with¬†Functor.</p><div><pre><span></span><span>signature</span> <span>Death</span><span>.</span><span>Functor</span><span>.</span><span>Signature</span> <span>(</span><span>Functor</span> <span>,</span> <span>map</span><span>)</span> <span>where</span>

<span>import</span> <span>Prelude</span> <span>()</span>

<span>data</span> <span>Functor</span> <span>a</span>
<span>map</span> <span>::</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>Functor</span> <span>a</span> <span>-&gt;</span> <span>Functor</span> <span>b</span>
</pre></div><p>This is a <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Functor.html#t:Functor">functorüòº</a>, and this is also a <a href="https://ocaml.org/docs/functors">functorüê´</a>. Functorüòº is the categorical functor where we embed one category into another. In this case, the category is that of sets and functions<sup id="fnref-not-a-category"><a href="#fn-not-a-category">2</a></sup>, where types are the sets and functions are the uh, functions. But it‚Äôs also an OCaml module functorüê´, where the data keyword introduces a hole into a signature, which we can later fill in with a proper type.<sup id="fnref-ocaml-cat-tangent"><a href="#fn-ocaml-cat-tangent">1</a></sup></p><p>We‚Äôve got to hide Prelude because the Functor type class from base gets imported by default. Signatures like the one just introduced can be used by importing them as if they were normal modules. All a signature does is promise to the compiler we‚Äôll make a proper module for that <em>later</em>. We can just start using our functor right now. For example, in that same impl, package I‚Äôve an auxiliary module for Functor, providing some¬†utilities:</p><div><pre><span></span><span>module</span> <span>Death.Functor</span> <span>(</span><span>module</span> <span>X</span> <span>,</span> <span>(</span><span>&lt;$&gt;</span><span>)</span> <span>,</span> <span>(</span><span>&lt;$</span><span>))</span> <span>where</span>

<span>import</span> <span>Death.Functor.Signature</span> <span>as</span> <span>X</span>
<span>import</span> <span>Prelude</span> <span>(</span><span>const</span><span>)</span>

<span>(</span><span>&lt;$&gt;</span><span>)</span> <span>::</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>Functor</span> <span>a</span> <span>-&gt;</span> <span>Functor</span> <span>b</span>
<span>(</span><span>&lt;$&gt;</span><span>)</span> <span>=</span> <span>map</span>

<span>(</span><span>&lt;$</span><span>)</span> <span>::</span> <span>b</span> <span>-&gt;</span> <span>Functor</span> <span>a</span> <span>-&gt;</span> <span>Functor</span> <span>b</span>
<span>(</span><span>&lt;$</span><span>)</span> <span>b</span> <span>=</span> <span>map</span> <span>(</span><span>const</span> <span>b</span><span>)</span>
</pre></div><p>As long as a module implements the signature, you get the stuff that depends on it implemented ‚Äúfor free‚Äù. The code depending on the signature is abstract. You want to keep your signatures small so more code is abstract, similar to how you want to keep typeclass definitions small so you can have smaller instances, keeping code that depends on the typeclass abstract. Let‚Äôs make an ‚Äúinstance‚Äù of our Functor signature, for the <code>Maybe</code> datatype, with the power of¬†modules:</p><div><pre><span></span><span>module</span> <span>Death.Functor.Maybe</span> <span>(</span><span>Functor</span> <span>,</span> <span>map</span><span>)</span> <span>where</span>

<span>import</span> <span>Prelude</span><span>(</span><span>Maybe</span><span>(</span><span>..</span><span>),</span> <span>(</span><span>$</span><span>))</span>

<span>type</span> <span>Functor</span> <span>=</span> <span>Maybe</span>

<span>map</span> <span>::</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>Functor</span> <span>a</span> <span>-&gt;</span> <span>Functor</span> <span>b</span>
<span>map</span> <span>fab</span> <span>=</span> <span>\</span><span>case</span>
  <span>Just</span> <span>x</span> <span>-&gt;</span> <span>Just</span> <span>$</span> <span>fab</span> <span>x</span>
  <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</pre></div><p>Now it‚Äôs worth pointing out that we‚Äôve got to do a fair bit of cabal work to make the compiler realize the instance. In Cabal, our main library with the signatures looks like¬†this:</p><div><pre><span></span>library
  signatures:
      Death.Functor.Signature
  exposed-modules:
      Death.Functor
  hs-source-dirs:
      src/sig
</pre></div><p>Then our implementing library definition looks¬†like:</p><div><pre><span></span>library impl
  exposed-modules:
      Death.Functor.Maybe
  hs-source-dirs:
      src/impl
</pre></div><p>If Cabal misses a module for a signature it‚Äôll give you an error like¬†this:</p><div><pre><span></span>cabal build
Resolving dependencies...
Error:
    Non-library component has unfilled requirements: Death.Functor
    In the stanza <span>&#39;executable exe&#39;</span>
    In the inplace package <span>&#39;death-1.0.0&#39;</span>
</pre></div><p>This guarantees all signatures have implementations whenever you build a final executable. To solve that error you realize it with ‚Äúsome‚Äù implementation. The client doesn‚Äôt care what¬†implementation:</p><div><pre><span></span>library app
  exposed-modules:
      Death
  hs-source-dirs:
      src/app
  mixins:
       death (Death.Functor.Signature as Death.Functor.Maybe)
</pre></div><p>What we‚Äôre saying in the mixin field is that the import <code>Death.Functor.Signature</code> should in fact be called <code>Death.Functor.Maybe</code>. Which makes it use the Maybe implementation whenever it encounters <code>Death.Functor.Signature</code>. Alternatively, we could‚Äôve just called it by the same name in the impl package as the signature. I only discovered this later. However, this renaming allows you to implement multiple module signatures in the same package, so you can use several functors within the same module as well, for example, here we‚Äôre using the <code>List</code>, <code>Maybe</code> and <code>IO</code> Functors all in one¬†module:</p><div><pre><span></span><span>{-# <abbr>LANGUAGE</abbr> RebindableSyntax #-}</span>

<span>module</span> <span>Death</span> <span>(</span><span>main</span><span>)</span> <span>where</span>

<span>import</span> <span>Maybe.Functor</span>
<span>import</span> <span>Maybe.Applicative</span>
<span>import</span> <span>Maybe.Monad</span>
<span>import</span> <span>qualified</span> <span>List.Functor</span> <span>as</span> <span>LF</span>
<span>import</span> <span>qualified</span> <span>IO.Monad</span> <span>as</span> <span>IO</span>
<span>import</span> <span>Death.BusinessLogic</span><span>(</span><span>business</span><span>)</span>

<span>commonFaith</span> <span>::</span> <span>Maybe</span> <span>String</span>
<span>commonFaith</span> <span>=</span> <span>Just</span> <span>&#34;no longer constrained by deceit&#34;</span>

<span>marchOfValues</span> <span>::</span> <span>[</span><span>Int</span><span>]</span>
<span>marchOfValues</span> <span>=</span> <span>[</span><span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>]</span>

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>(</span><span>print</span> <span>@</span><span>(</span><span>Functor</span> <span>String</span><span>)</span> <span>$</span> <span>do</span>
   <span>cryOfUprising</span> <span>&lt;-</span> <span>(</span><span>\</span><span>x</span> <span>-&gt;</span> <span>(</span><span>&#34;rise up&#34;</span> <span>&lt;&gt;</span> <span>x</span><span>))</span> <span>&lt;$&gt;</span> <span>pure</span> <span>&#34;brothers and sisters&#34;</span>
   <span>chorusOfTruth</span> <span>&lt;-</span> <span>commonFaith</span>
   <span>pure</span> <span>$</span> <span>cryOfUprising</span> <span>&lt;&gt;</span> <span>&#34;  against the lies&#34;</span> <span>&lt;&gt;</span> <span>chorusOfTruth</span> 
                        <span>&lt;&gt;</span> <span>show</span> <span>((</span><span>+</span><span>1</span><span>)</span> <span>LF</span><span>.&lt;$&gt;</span> <span>marchOfValues</span><span>)</span>
   <span>)</span> <span>IO</span><span>.&gt;&gt;</span> <span>business</span>
</pre></div><p>We use <code>RebindableSyntax</code> to inform <span>GHC</span> to use whatever <code>&gt;&gt;=</code> is in scope for <code>do</code>. In this case that‚Äôs the <code>&gt;&gt;=</code> from <code>Maybe.Monad</code>. As long as you satisfy the signature, it‚Äôs happy üòº. <code>do</code> has nothing to do with Monads! Who lied to¬†you?</p><p>Ah right about that business. Yes, we can‚Äôt do commercial code like this; this is disgusting. We need an effect system.<sup id="fnref-effect-system"><a href="#fn-effect-system">3</a></sup> Fortunately, we‚Äôve got a versatile one-trick pony. This is our business¬†code:</p><div><pre><span></span><span>business</span> <span>::</span> <span>Functor</span> <span>()</span>
<span>business</span> <span>=</span> <span>do</span>
  <span>writeLine</span> <span>&#34;file name:&#34;</span>
  <span>systemOfValues</span> <span>&lt;-</span> <span>readLine</span>
  <span>writeLine</span> <span>&#34;file content:&#34;</span>
  <span>truthOfTheFields</span> <span>&lt;-</span> <span>readLine</span>

  <span>writeLine</span> <span>&#34;writing file...&#34;</span>
  <span>writeFile</span> <span>systemOfValues</span> <span>truthOfTheFields</span>

  <span>writeLine</span> <span>&#34;reading it again to make sure its <abbr>ISO</abbr> 42038 compliant&#34;</span>
  <span>uprisingAgainstDeceit</span> <span>&lt;-</span> <span>readFile</span> <span>systemOfValues</span>

  <span>writeLine</span> <span>uprisingAgainstDeceit</span>
</pre></div><p>At this point we don‚Äôt know what Functor is, we want it to be <span>IO</span> in our realized implementation. In our tests we can set it to a state monad for example. So we can make sure it does everything correctly in memory,<sup id="fnref-good-idea"><a href="#fn-good-idea">4</a></sup> without having to rely on these unreliable file¬†systems.</p><p>Working backwards from our business logic implementation, we need to define some signatures to support our business¬†logic:</p><div><pre><span></span><span>signature</span> <span>Death</span><span>.</span><span>Effects</span><span>.</span><span>FileSystem</span> <span>(</span><span>readFile</span> <span>,</span> <span>writeFile</span><span>)</span> <span>where</span>

<span>import</span> <span>Prelude</span><span>(</span><span>String</span><span>,</span> <span>FilePath</span><span>)</span>
<span>import</span> <span>Death.Functor.Signature</span>

<span>readFile</span>  <span>::</span> <span>FilePath</span> <span>-&gt;</span> <span>Functor</span> <span>String</span>
<span>writeFile</span> <span>::</span> <span>FilePath</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>Functor</span> <span>()</span>
</pre></div><p>Actually, I now realize we could‚Äôve just renamed Prelude on top of our FileSystem effect to get the realized implementation. Instead, I made a separate¬†module:</p><div><pre><span></span><span>module</span> <span>Death.Effects.FileSystem</span>
  <span>(</span> <span>readFile</span>
  <span>,</span> <span>writeFile</span>
  <span>)</span>
<span>where</span>

<span>import</span> <span>Prelude</span><span>(</span><span>IO</span><span>,</span> <span>readFile</span><span>,</span> <span>writeFile</span><span>)</span>
</pre></div><p>When you stare at hammers long enough everything becomes a nail! Actually, I think the state implementation is more¬†interesting:</p><div><pre><span></span><span>module</span> <span>Death.Effects.FileSystem</span>
  <span>(</span> <span>readFile</span>
  <span>,</span> <span>writeFile</span>
  <span>)</span>
<span>where</span>

<span>import</span> <span>Prelude</span><span>(</span><span>String</span><span>,</span> <span>FilePath</span><span>,</span> <span>(</span><span>$</span><span>))</span>
<span>import</span> <span>Death.Functor.Signature</span>
<span>import</span> <span>Data.Map</span> <span>qualified</span> <span>as</span> <span>Map</span>
<span>import</span> <span>Data.Maybe</span><span>(</span><span>fromMaybe</span><span>)</span>
<span>import</span> <span>Death.Functor.State</span>

<span>readFile</span>  <span>::</span> <span>FilePath</span> <span>-&gt;</span> <span>Functor</span> <span>String</span>
<span>readFile</span> <span>path</span> <span>=</span> <span>Functor</span> <span>$</span> 
    <span>\</span><span>state</span> <span>-&gt;</span> <span>(</span><span>state</span><span>,</span> <span>fromMaybe</span> <span>&#34;&#34;</span> <span>$</span> <span>Map</span><span>.</span><span>lookup</span> <span>path</span> <span>(</span><span>fileSystem</span>  <span>state</span><span>))</span>

<span>writeFile</span> <span>::</span> <span>FilePath</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>Functor</span> <span>()</span>
<span>writeFile</span> <span>path</span> <span>contents</span> <span>=</span> <span>Functor</span> <span>$</span> 
    <span>\</span><span>state</span> <span>-&gt;</span> <span>(</span><span>state</span> <span>{</span><span>fileSystem</span> <span>=</span> <span>Map</span><span>.</span><span>insert</span> <span>path</span> <span>contents</span> <span>(</span><span>fileSystem</span> <span>state</span><span>)},</span> <span>()</span><span>)</span>
</pre></div><p>It‚Äôs interesting in that it‚Äôs boring. For people out of the loop, this is basically a one-for-one copy of the state monad. No fancy types at all. There is nothing going on here. I feel stupid for pointing out you can do this. <sup id="fnref-crazy"><a href="#fn-crazy">5</a></sup></p><p>Here I used the same name trick to unify the modules with their respective signatures in the cabal file, which cleans it up a¬†bit:</p><div><pre><span></span>library app
  exposed-modules:
      Death
  hs-source-dirs:
      src/app
  build-depends:
      death:impl,
      death:effects,
      death:effects-io,
      death:effects-app,
</pre></div><p><code>death:effects-app</code> declares our actual ‚Äúbusiness‚Äù logic, and we unify the <code>death:effects</code> signatures with the modules from <code>death:effects-io</code>. This is a lot nicer to use than having to use that strange mixin <span>DSL</span>, which is not hard, the Cabal errors are just bad in formatting and output prioritization. Sometimes the important errors get buried in dozens of other not relevant lines!<sup id="fnref-example-cabal"><a href="#fn-example-cabal">6</a></sup></p><p>Our test suite uses the state monad implementation¬†instead:</p><div><pre><span></span>test-suite unit
  main-is: Test.hs
  hs-source-dirs:
      test
  build-depends:
      death:effects-app,
      death:effects-state,
</pre></div><p>and it works as¬†expected:</p><div><pre><span></span><span>unitTests</span> <span>::</span> <span>TestTree</span>
<span>unitTests</span> <span>=</span> <span>testGroup</span> <span>&#34;Unit tests&#34;</span>
  <span>[</span>
    <span>testCase</span> <span>&#34;run business logic main&#34;</span> <span>$</span> <span>do</span>
      <span>let</span> <span>(</span><span>result</span><span>,</span> <span>()</span><span>)</span> <span>=</span> <span>unFunctor</span> <span>Death</span><span>.</span><span>business</span> <span>$</span> <span>State</span> <span>{</span>
        <span>lineInput</span> <span>=</span> <span>&#34;awesomeFile&#34;</span><span>,</span>
        <span>linesOutput</span> <span>=</span> <span>[]</span><span>,</span>
        <span>fileSystem</span> <span>=</span> <span>mempty</span>
        <span>}</span>
      <span>result</span> <span>@?=</span> <span>State</span> <span>{</span>
        <span>lineInput</span> <span>=</span> <span>&#34;awesomeFile&#34;</span><span>,</span>
        <span>linesOutput</span> <span>=</span> <span>[</span><span>&#34;awesomeFile&#34;</span><span>,</span><span>&#34;reading it again to make sure its <abbr>ISO</abbr> 42038 compliant&#34;</span><span>,</span><span>&#34;writing file...&#34;</span><span>,</span><span>&#34;file content:&#34;</span><span>,</span><span>&#34;file name:&#34;</span><span>],</span>
        <span>fileSystem</span> <span>=</span> <span>Map</span><span>.</span><span>fromList</span><span>[(</span><span>&#34;awesomeFile&#34;</span><span>,</span> <span>&#34;awesomeFile&#34;</span><span>)]</span>
        <span>}</span>
</pre></div><p>There, we created an effect system replacement by doing nothing. All we did was take a position of technical extremism, and then watched. This post wrote itself after we took up the initial position and watched. Everything flows, I‚Äôm sorry dear reader I tricked you! Doing nothing was the real system of values I wanted to show, to those who can see. This post isn‚Äôt about Backpack.<sup id="fnref-dead-serious"><a href="#fn-dead-serious">7</a></sup></p><p>What does our Backpack effect system provide? No fancy types mean easy-to-solve error messages. Although in trade we get more cabal error messages, which could be improved.<sup id="fnref2-example-cabal"><a href="#fn-example-cabal">6</a></sup> We have full <span>IO</span> support in capabilities, including <a href="https://hackage.haskell.org/package/ghc-prim-0.13.0/docs/GHC-Prim.html#continuations">continuations</a>.<sup id="fnref-pointing-out"><a href="#fn-pointing-out">8</a></sup> Monomorphic effects improve error messages over say, <a href="https://jappie.me/a-brief-intro-to-mtl.html"><span>MTL</span></a>, where error messages point to wrong places due to the polymorphism. It has different, potentially faster compile-time characteristics. All implementations can, for example, be compiled in parallel, although the additional packages enforcement <a href="https://www.parsonsmatt.org/2019/11/27/keeping_compilation_fast.html">goes against that</a>. The runtime is as fast as <span>IO</span>, because we can set the underlying monad to anything as long as we provide the implementation. Even though I don‚Äôt think speed is that important for effect systems. For production use, the bottleneck is rarely <span>CPU</span>-bound for effects. However, it can be for test suites that do everything in¬†memory.</p><p>In this post we also replaced the standard type classes. I don‚Äôt think we‚Äôre gaining a lot by doing this. We‚Äôve got to be explicit now which <code>Functor</code> or <code>Monad</code> we‚Äôre importing, and you can‚Äôt have <code>do</code> notation for different Monads in the same module. Backpack actually can define constraints in the signatures. So you don‚Äôt have to replace standard typeclasses like I did in this post to use Backpack. I did this anyway because it allowed me to do some basic initial experimentation. Furthermore I felt it necessary to tear down these fake idols for shock and¬†awe.</p><p>I‚Äôd actually love to see someone take Backpack more seriously and build an effect system on top of that, providing a bunch of default signatures and implementations. Experimenting with Backpack is easy, it‚Äôs already baked in <span>GHC</span> and Cabal. DeathüíÄ to type classes! Open the¬†Backpack!</p><h2 id="sources">sources</h2><ul>
<li>I made a <a href="https://github.com/jappeace/death">reference implementation</a> just to make sure I wasn‚Äôt talking out of my arse and verify it was all¬†possible.</li>
<li>This repository has been invaluable: <a href="https://github.com/danidiaz/really-small-backpack-example/tree/master/lesson2-signatures">danidiaz, really-small-backpack-example, Apr 7,¬†2021</a></li>
<li>Main backpack thesis, how it all works under the hood: <a href="https://github.com/ezyang/thesis/releases">Edward Z. Yang, <span>BACKPACK</span>: <span>TOWARDS</span> <span>PRACTICAL</span> <span>MIX</span>-<span>IN</span> <span>LINKING</span> <span>IN</span> <span>HASKELL</span>, Oct 10,¬†2017 </a></li>
<li><a href="https://www.haskellforall.com/2012/05/scrap-your-type-classes.html">Gabby wrote</a> a similar idea in a wildly different implementation. Although, some languages consider records and modules as the same¬†thing.</li>
</ul></div></div>
  </body>
</html>
