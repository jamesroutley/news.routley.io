<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cceckman.com/writing/branchless-utf8-encoding/">Original</a>
    <h1>Branchless UTF-8 Encoding</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Can you encode UTF-8 without branches?</p>
<p><a href="https://github.com/cceckman/unicode-branchless/blob/main/src/lib.rs" rel="external" target="_blank">Yes</a>.</p>
<h2 id="the-question">The question</h2>


<p>In a <a target="_blank" href="https://www.recurse.com/scout/click?t=8238c6d9149cbd0865752e535795d509">Recurse</a> chat, <a href="https://github.com/ngoldbaum" rel="external" target="_blank">Nathan Goldbaum</a> asked:</p>
<blockquote>
<p>I know how to decode UTF-8 using bitmath and some LUTs (see <a href="https://github.com/skeeto/branchless-utf8" rel="external" target="_blank">https://github.com/skeeto/branchless-utf8</a>), but if I want to to go from a codepoint to UTF-8, is there a way to do it without branches?</p>
<p>To start with, is there a way to write this C function, which returns the number of bytes needed to store the UTF-8 bytes for the codepoint without any branches? Or would I need a huge look-up-table?</p>
</blockquote>
<details>
  <summary>The C function</summary>
<blockquote>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>int</span>
</span></span><span><span><span>num_utf8_bytes_for_codepoint</span><span>(</span><span>uint32_t</span> <span>code</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>code</span> <span>&lt;=</span> <span>0x7F</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>1</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>else</span> <span>if</span> <span>(</span><span>code</span> <span>&lt;=</span> <span>0x07FF</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>2</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>else</span> <span>if</span> <span>(</span><span>code</span> <span>&lt;=</span> <span>0xFFFF</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>((</span><span>code</span> <span>&gt;=</span> <span>0xD800</span><span>)</span> <span>&amp;&amp;</span> <span>(</span><span>code</span> <span>&lt;=</span> <span>0xDFFF</span><span>))</span> <span>{</span>
</span></span><span><span>            <span>// surrogates are invalid UCS4 code points
</span></span></span><span><span><span></span>            <span>return</span> <span>-</span><span>1</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>return</span> <span>3</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>else</span> <span>if</span> <span>(</span><span>code</span> <span>&lt;=</span> <span>0x10FFFF</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>4</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>else</span> <span>{</span>
</span></span><span><span>        <span>// codepoint is outside the valid unicode range
</span></span></span><span><span><span></span>        <span>return</span> <span>-</span><span>1</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></blockquote>
</details>
<p>I pondered this but didn’t immediately see a way to do it without a huge (2^32) lookup table.</p>
<h2 id="the-almost-answer">The almost answer</h2>
<p>Until <a href="http://lmb.io/" rel="external" target="_blank">Lorenz</a> pointed out:</p>
<blockquote>
<p>Very handwavy idea: encode a 32 bit code point into utf8 but store the result in a 32bit word again. Count the number of leading / trailing zeroes to figure out how many bytes are necessary. Write four bytes into the output buffer but only advance your position in the output by the number of bytes you really need.</p>
</blockquote>
<p>Aha!</p>
<p>The number of leading zeros will range from 12 to 32<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> –
a very reasonable size for a lookup table.
From there, we could look up other parameters by length (no more than 4).</p>
<p>I fired off a draft into the chat, then came back to test (and fix) it in the evening.
When I got the tests passing, it looked like this:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Return the number of bytes required to UTF-8 encode a codepoint.
</span></span></span><span><span><span>/// Returns 0 for surrogates and out-of-bounds values.
</span></span></span><span><span><span></span><span>const</span><span> </span><span>fn</span> <span>utf8_bytes_for_codepoint</span><span>(</span><span>codepoint</span>: <span>u32</span><span>)</span><span> </span>-&gt; <span>usize</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>len</span><span> </span><span>=</span><span> </span><span>LEN</span><span>[</span><span>codepoint</span><span>.</span><span>leading_zeros</span><span>()</span><span> </span><span>as</span><span> </span><span>usize</span><span>]</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Handle surrogates via bit-twiddling.
</span></span></span><span><span><span></span><span>    </span><span>// Rust guarantees true == 1 and false == 0:
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>surrogate_bit</span><span> </span><span>=</span><span> </span><span>((</span><span>codepoint</span><span> </span><span>&gt;=</span><span> </span><span>0xD800</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>(</span><span>codepoint</span><span> </span><span>&lt;=</span><span> </span><span>0xDFFF</span><span>))</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>// Extend that one bit into three, and use its inverse as a mask for length
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>surrogate_mask</span><span> </span><span>=</span><span> </span><span>surrogate_bit</span><span> </span><span>&lt;&lt;</span><span> </span><span>2</span><span> </span><span>|</span><span> </span><span>surrogate_bit</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>|</span><span> </span><span>surrogate_bit</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Handle exceeded values via bit-twiddling.
</span></span></span><span><span><span></span><span>    </span><span>// Unfortunately, these don&#39;t align precisely with a leading-zero boundary;
</span></span></span><span><span><span></span><span>    </span><span>// the largest codepoint is U+10FFFF.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>exceeded_bit</span><span> </span><span>=</span><span> </span><span>(</span><span>codepoint</span><span> </span><span>&gt;</span><span> </span><span>0x10_FFFF</span><span>)</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exceeded_mask</span><span> </span><span>=</span><span> </span><span>exceeded_bit</span><span> </span><span>&lt;&lt;</span><span> </span><span>2</span><span> </span><span>|</span><span> </span><span>exceeded_bit</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>|</span><span> </span><span>exceeded_bit</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>len</span><span> </span><span>&amp;</span><span> </span><span>!</span><span>surrogate_mask</span><span> </span><span>&amp;</span><span> </span><span>!</span><span>exceeded_mask</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Length, based on the number of leading zeros.
</span></span></span><span><span><span></span><span>const</span><span> </span><span>LEN</span>: <span>[</span><span>u8</span><span>;</span><span> </span><span>33</span><span>]</span><span> </span><span>=</span><span> </span><span>[</span><span>
</span></span></span><span><span><span>    </span><span>// 0-10 leading zeros: not valid
</span></span></span><span><span><span></span><span>    </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>// 11-15 leading zeros: 4 bytes
</span></span></span><span><span><span></span><span>    </span><span>4</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>4</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>//16-20 leading zeros: 3 bytes
</span></span></span><span><span><span></span><span>    </span><span>3</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>3</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>// 21-24 leading zeros: 2 bytes
</span></span></span><span><span><span></span><span>    </span><span>2</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>2</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>// 25-32 leading zeros: 1 byte
</span></span></span><span><span><span></span><span>    </span><span>1</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>1</span><span>,</span><span>
</span></span></span><span><span><span></span><span>];</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Encode a UTF-8 codepoint.
</span></span></span><span><span><span>/// Returns a buffer and the number of valid bytes in the buffer.
</span></span></span><span><span><span>///
</span></span></span><span><span><span>/// To add this codepoint to a string, append all four bytes in order,
</span></span></span><span><span><span>/// and record that (usize) bytes were added to the string.
</span></span></span><span><span><span>///
</span></span></span><span><span><span>/// Returns a length of zero for invalid codepoints (surrogates and out-of-bounds values).
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>branchless_utf8</span><span>(</span><span>codepoint</span>: <span>u32</span><span>)</span><span> </span>-&gt; <span>([</span><span>u8</span><span>;</span><span> </span><span>4</span><span>],</span><span> </span><span>usize</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>len</span><span> </span><span>=</span><span> </span><span>utf8_bytes_for_codepoint</span><span>(</span><span>codepoint</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>buf</span><span> </span><span>=</span><span> </span><span>[</span><span>
</span></span></span><span><span><span>        </span><span>PREFIX</span><span>[</span><span>len</span><span>][</span><span>0</span><span>]</span><span> </span><span>|</span><span> </span><span>((</span><span>codepoint</span><span> </span><span>&gt;&gt;</span><span> </span><span>SHIFT</span><span>[</span><span>len</span><span>][</span><span>0</span><span>])</span><span> </span><span>&amp;</span><span> </span><span>MASK</span><span>[</span><span>len</span><span>][</span><span>0</span><span>]</span><span> </span><span>as</span><span> </span><span>u32</span><span>)</span><span> </span><span>as</span><span> </span><span>u8</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>PREFIX</span><span>[</span><span>len</span><span>][</span><span>1</span><span>]</span><span> </span><span>|</span><span> </span><span>((</span><span>codepoint</span><span> </span><span>&gt;&gt;</span><span> </span><span>SHIFT</span><span>[</span><span>len</span><span>][</span><span>1</span><span>])</span><span> </span><span>&amp;</span><span> </span><span>MASK</span><span>[</span><span>len</span><span>][</span><span>1</span><span>]</span><span> </span><span>as</span><span> </span><span>u32</span><span>)</span><span> </span><span>as</span><span> </span><span>u8</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>PREFIX</span><span>[</span><span>len</span><span>][</span><span>2</span><span>]</span><span> </span><span>|</span><span> </span><span>((</span><span>codepoint</span><span> </span><span>&gt;&gt;</span><span> </span><span>SHIFT</span><span>[</span><span>len</span><span>][</span><span>2</span><span>])</span><span> </span><span>&amp;</span><span> </span><span>MASK</span><span>[</span><span>len</span><span>][</span><span>2</span><span>]</span><span> </span><span>as</span><span> </span><span>u32</span><span>)</span><span> </span><span>as</span><span> </span><span>u8</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>PREFIX</span><span>[</span><span>len</span><span>][</span><span>3</span><span>]</span><span> </span><span>|</span><span> </span><span>((</span><span>codepoint</span><span> </span><span>&gt;&gt;</span><span> </span><span>SHIFT</span><span>[</span><span>len</span><span>][</span><span>3</span><span>])</span><span> </span><span>&amp;</span><span> </span><span>MASK</span><span>[</span><span>len</span><span>][</span><span>3</span><span>]</span><span> </span><span>as</span><span> </span><span>u32</span><span>)</span><span> </span><span>as</span><span> </span><span>u8</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>];</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>(</span><span>buf</span><span>,</span><span> </span><span>len</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>type</span> <span>Table</span><span> </span><span>=</span><span> </span><span>[[</span><span>u8</span><span>;</span><span> </span><span>4</span><span>];</span><span> </span><span>5</span><span>];</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Byte prefix for a continuation byte.
</span></span></span><span><span><span></span><span>const</span><span> </span><span>CONTINUE</span>: <span>u8</span> <span>=</span><span> </span><span>0b1000_0000</span><span>;</span><span>
</span></span></span><span><span><span></span><span>const</span><span> </span><span>PREFIX</span>: <span>Table</span><span> </span><span>=</span><span> </span><span>[</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0</span><span>u8</span><span>;</span><span> </span><span>4</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0b1100_0000</span><span>,</span><span> </span><span>CONTINUE</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0b1110_0000</span><span>,</span><span> </span><span>CONTINUE</span><span>,</span><span> </span><span>CONTINUE</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0b1111_0000</span><span>,</span><span> </span><span>CONTINUE</span><span>,</span><span> </span><span>CONTINUE</span><span>,</span><span> </span><span>CONTINUE</span><span>],</span><span>
</span></span></span><span><span><span></span><span>];</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// We must arrange that the most-significant bytes are always in byte 0.
</span></span></span><span><span><span></span><span>const</span><span> </span><span>SHIFT</span>: <span>Table</span><span> </span><span>=</span><span> </span><span>[</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0</span><span>u8</span><span>;</span><span> </span><span>4</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>6</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>12</span><span>,</span><span> </span><span>6</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>18</span><span>,</span><span> </span><span>12</span><span>,</span><span> </span><span>6</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span></span><span>];</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>const</span><span> </span><span>MASK</span>: <span>Table</span><span> </span><span>=</span><span> </span><span>[</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0</span><span>u8</span><span>;</span><span> </span><span>4</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0x7f</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0x1f</span><span>,</span><span> </span><span>0x3f</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0x0f</span><span>,</span><span> </span><span>0x3f</span><span>,</span><span> </span><span>0x3f</span><span>,</span><span> </span><span>0</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>[</span><span>0x07</span><span>,</span><span> </span><span>0x3f</span><span>,</span><span> </span><span>0x3f</span><span>,</span><span> </span><span>0x3f</span><span>],</span><span>
</span></span></span><span><span><span></span><span>];</span><span>
</span></span></span></code></pre></div><h2 id="the-branches">The branches</h2>
<p>No if statements, loops, or other conditionals. So, branchless, right?</p>
<p>…well, no.
If we peek at <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DEArgoKkl9ZATwDKjdAGFUtEywYgAzAFZSjgBk8BkwAOXcAI0xiEEkANlIAB1QFQjsGFzcPbz9k1NsBIJDwliiY%2BMtMawKGIQImYgJM909fSur0uoaCIrDI6NiE827m7Lbhxt6SssGASktUE2Jkdg4Aeg2AamwGNCxNpk25ABUAMQBaAA5Nvcxk4IIAOgBSDQBBDbXNgCVMAiWGAoDpsIiYqFRogcGOhNgQEJhNgx%2BsRNqgqJsAG5iPAwiIATwImCBwVh8JBYIhxBe70%2Brw%2BW2OqAO6BhcLwQNu90EsKZh3MxGCwFIB0SiUcB1otE2/CWIIJRM2JJIWDIdM%2BUJhxEwaGIrIQTAImwgZjwAC9MLM5YSgQB3aIIpgszCsplwhH8wXU%2BlrNVbX7/YiA4H0Ixw1Ho83EJn8FHBLG0HE3DB3VAPIEQBRLKPAA0KwwwxYEc5o84RRbQoHxkxE2ZexImCLShgg4iGZAIegKBQAfRMBColwgnNTghAmxMXgATJbzs8vNgjc8fAAhEyXOfLzaSJcAEWFJvNlueAHZl3TNhfNvRDSHNnOd%2BP%2B5du/jrd2Y93hw8h8muQRZhu56Xte5Loved4rkBl6Xso3zYKcACSAAaS7LiGu6oRou53seThGj%2BWB/ne85zguQgABIIacxyoehPg7phu5HpOcSbAAsm8QgANK0YwGErlh9EHECE7TsJ46XKQUHQZssHwchvEMPxy5cNhJ54VAX7cqRpGbBRVE0SudEMSuqn0cxrEcdxinKWZD5MCJU6Wg5ElSe8MkwXBiEoUZfH0ahk5qbh%2BFaYaOnznplHUTZ/kroF5l3ix7GcTxvlKbFy7xfZjliS5a5uW8HkXnJ3kxSZy5eEFGkESmDzEdgun6dFaXKZVCXPElVmpWhfnlW12Xjk54n5dJGFeGe7zSRAoJUMKIYAZNx4MZN7xoIChpUM2fYDi%2B8o9h%2BoU1X%2BY6iTOukHgiJ4TYVwF/FejDEQ%2BATYKEqGhY89COoK3aRikEDOSJqTmtheVA5ggErTdF5bOR%2Bb0JsmbENmuaVnghwRIQ5wEDaOLoAmRhetBfpmIawAmA0hiEgqBCmJdXgMfTmxcBq0piEoj3gRoIDSSBiPI4SL6EI9IW/iOYUkYzGiqDulwaBoFkdaxR1i8RTic9Lpya7MAPjmDENQ5sWzYKohLQqSBqoiEIJCw8roIFqmDCvmusIoQxIMBi0Tsy5hwsA5ADW0okPdoYIDzd186gOYC37CiB%2BBkfR5ggvi2rXh4ZOOF4YnuYp6rc54cz6kI1mUe5xjBD69JMNwwimCqCszrOpiYjVqj6OY9juP48AhOXlscgMDG/zMIStB4sKbrs%2BgAhgBwhrYsAzaJFqyDslUeKbDjYaHJ9%2BBGOcv0guW6ANHi%2BtE18bpXg0wBEoaoWKkCcgdSpGia5rfcXiB9eN1g6B53AsrOqukpZcA0N2D%2BpwdYXQvrdQ0v9MBNwAbHeOjNEHIMAenAumxM7Fwwf/LBadC5Z02AQ50Kcq7uVus2RWmwwBgBzjHAOiVWIMPISggOdITzLTeHSAgeIxSbGOEwCI8NwKoVQmuDcW4xqbh8HI7hNItgBEYMAOEwoIgOWbgIUkCIkSlEhGie6X0jCbF%2BgoL0a1zCbGeqEMcUj1zjU2F4fqwtJHUOhl8DQ5xwEmP3sAcx0QUhjgYKgQ08YcTSQ0MKGJmw4kJNiUk%2BJyTEmGx9J49JTMuC%2BJ8P4wUQSowKDHJIK0RJpLSC3MKSpNThQbGrmsLgcRziTg0PksxFixxeDKQoaSXhhT9JcQM4Z6SGm4JyZOUpe8CmdNwT06Sk5hSLNwUsupGSDZbEnD4c4U52mBNmczV84NMlcGFKcpmZzLkXOuac7h/lxpKPpJsZc8pNgr0wDQVQQcUSHDWrYJEBp0hlKsQIGxTgADyoRjgIVCHIbAJ1ricwiOAuW3Y5Zy31tYw0JVkJjhEWIumD4PEG0wtI5x256IFWgphVJsTdxUsvJhZFKK0XouFBCqFMK4WpPpaNASzLwGsrluyyF0LYXYBFZy8VdLKV8uXBoAVXAhVxI5WK7lmxVVcolRq0VWreWTXuddX0mwADqCIWAkwOEjQwd9zaGmviwFIRZUhLzwDQUQ3IjlAgaA6WgNomB4ndmU%2BJIL1qRQMni0R4jGbEupQJMlm4KV7jlWkhJ%2BqSUrgSCk7Nglk2ZNQlwZZWa02yvzaZSSTMi0yrzXww1jysXJW4pGgl7jIJlvlQm2RpaM3ytUMeWaObq0MovJhVQXAB1Sy8BOodKbVAaAnaoKdsTF0TvTXG3tGhjzLqXfEld26qDpsUZDDg8xaCcB8LwTwHAtCkFQJwb4lqFCLGWJdScXgeCkAIJoE98x/YgB8BoR4GgvCXDiLLAAnMeUDk5LjHgSGejgkheAsAkMKq9N670cF4MUmJX7r0ntIHAWASA0AsESHQaI5BKCkfI/QGIxAuCXC8DEmgtBCTEGKdNb9pAMbMGIHiTgH7eNn3BREbQ2o8MftI2wQQ4KGDj241gUEwAnBiFoMU7gvAsB%2ByMOIfDpB8Cr1sJ7DTN767aj7KsD9DwqjcYTBEVs/GXBYG4zTPAKHNOkE9sQMsSgdyYB08AHu375hUAMMABQAA1PAmAbTgrFFej9/BBAiDEOwKQMhBCKBUOofTuhTkGCMCAUw5h9B4AiMUyA8xUCJBqBp844LeCoG8wKLAlX/rtAk%2BkBw0JRieFOYEYIfRDExFOXkNIAg%2Bt6HGzUKYyI9BWC6wILojQpunMWzYTo9RJhDemAMdb22miuBaAtw7c2RsSHmE%2BpYKxLv6HPZe7jmHNglYIMgJmjwmNAaNLgQgwcOrvtmLwPDWhtakHhI6AYHW/2SHA48cDcQuDvvAxoScSPjyFoqAhpDpAUMotIOhprnBsMgFwyF09nBJyPf05h4H5OvNe265IIAA%3D" rel="external" target="_blank">the (optimized) code</a> in Compiler Explorer,
we can see the x86_64 assembly has <strong>two different kinds of branches</strong>.</p>
<h3 id="count-leading-zeros">Count leading zeros</h3>
<p>There’s a branch right at the start of the function:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span>            <span>test</span>    <span>esi</span><span>,</span> <span>esi</span>
</span></span><span><span>            <span>je</span>      <span>.LBB0_1</span>
</span></span><span><span>            <span>bsr</span>     <span>eax</span><span>,</span> <span>esi</span>
</span></span><span><span>            <span>xor</span>     <span>eax</span><span>,</span> <span>31</span>
</span></span><span><span>            <span>jmp</span>     <span>.LBB0_3</span>
</span></span><span><span>    <span>.LBB0_1:</span>
</span></span><span><span>            <span>mov</span>     <span>eax</span><span>,</span> <span>32</span>
</span></span><span><span>    <span>.LBB0_3:</span>
</span></span><span><span>            <span>mov</span>     <span>eax</span><span>,</span> <span>eax</span>
</span></span></code></pre></div><p>I wasn’t sure what this was about until I stepped through it.
The “special” case seems to be when the input (<code>esi</code>) is zero;
then it returns 32.</p>
<p>Why the special case? Compiler Explorer’s tooltip for the <code>bsr</code> instruction says:</p>
<blockquote>
<p>If the content source operand is 0, the content of the destination operand is undefined.</p>
</blockquote>
<p>So on x86_64 processors,
we have to branch to say “a 32-bit zero value has 32 leading zeros”.
Put differently, the “count leading zeros” intrinsic isn’t necessarily a branchless
instruction.
This might look nicer on another architecture!</p>
<h3 id="bounds-checks">Bounds checks</h3>
<p>The other jump seems to be a conflation of the several array-bounds checks.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span>        <span>cmp</span>     <span>eax</span><span>,</span> <span>4</span>
</span></span><span><span>        <span>ja</span>      <span>.LBB0_5</span>
</span></span><span><span>        <span>...</span>
</span></span><span><span><span>LBB0_5:</span>
</span></span><span><span>        <span>lea</span>     <span>rdx</span><span>,</span> <span>[</span><span>rip</span> <span>+</span> <span>.L__unnamed_5</span><span>]</span>
</span></span><span><span>        <span>mov</span>     <span>esi</span><span>,</span> <span>5</span>
</span></span><span><span>        <span>mov</span>     <span>rdi</span><span>,</span> <span>rax</span>
</span></span><span><span>        <span>call</span>    <span>qword</span> <span>ptr</span> <span>[</span><span>rip</span> <span>+</span> <span>core</span><span>::</span><span>panicking</span><span>::</span><span>panic_bounds_check</span><span>::</span><span>h8307ccead484a122@GOTPCREL</span><span>]</span>
</span></span></code></pre></div><p>All of the jump arrays have the same bound (4), so the compiler can
decide to only check once – and still get Rust’s famous safety guarantees.</p>
<p>In principle, if the compiler optimized through the <code>LEN</code> table,
it could eliminate this check as well; the <code>LEN</code> value is never
greater than 4, which is a valid index for all tables.
But apparently the constants don’t propagate that far.</p>
<h2 id="eliminating-branching">Eliminating branching</h2>
<p>Changing the code and dropping to <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DEArgoKkl9ZATwDKjdAGFUtEywZ7HAGTwNMAHLuAEaYxCAAzABMpAAOqAqEdgwubh568Ym2Ar7%2BQSyh4dGWmNbZDEIETMQEqe6eXCVlyZXVBLmBIWGRMeZtdemNfTUd%2BYU9AJSWqCbEyOwcAPTLANTYDGhYK0wrcgAqAGIAtAAcK5uY8X4EAHQApBoAgsuLKwBKmASzDArbK8EmKhUMLbBjoFYEBCYFYMLrEFaoKgrABuYjw4OCAE8CJhfn4IVD/oDgcR7k8Xg9nqs9qhtuhwZC8L8LldBBDaTtzMQ/MBSNtYrFHNtaLQVvxZv9sbiVviSFgyJSXqDwcRMGhiAyEEwCCsIGY8AAvTATSU434AdzC0KY9MwDNpkOhXJ5ZKpi0Vqw%2BX2IPz%2B9CMkIRSKNxFp/HhflRtHR5wwl1Q11%2BEAUs1DwG10sM4JmBCOiKOwRmYN%2BUZMuImrtiJmCYoY/2IhmQCHoCgUAH0TAQqCcICyE4IQCsTNETUc7hFsLq7gBWABCJhO49nK0kM4AInz9UaTXcAOyzykrI8reg6/0rcdroddk5trFmtvhtt9669uOsggTJeH494JHIKhgDASAsABYA2yYVswnKBQd33H9j2PSClBqYCIHPccnEvFcvwiA8nkQvc1wQk9PiJJFsJMH4mGBC94IIxDjxnfDHkYtiVgAKmUN5sAOABJAANG5gE%2BDsNihZAAGs7XQxgKxEggxKbNVpPQCANC/Bj2PYvcnF1N8sA/C8J3HScOKEAAJPiDj2YTRKo5SpJk/15Ps8SVJkjTNNY7TfKPO4ogANk4gBZR4hAAaTsxSHIk1TZIYVyYvcpy1I07ZfmHKITUgocTlIEjtK4nj%2BKEhSlLi5y5OiiqPLUrhvL8tjdP0l82VM0zOMs6zbPK2K6oSpLatSiAGsaprtIC4KOLCyKav6kaXPmlL4oajKhxHdaFwKrTfOK3jBOWxz4qWvqVpk7LCqalqoDanUOonLqrJso7KrU063OOi6JnGibmqC0Lwqis6vve6qQbeiBsq2zbcu2q62P20rXoGj7ktBiAIl%2Bv6boM%2BNrmM7BOvM57es%2ByG0eG%2BKsexv6mIBmagZRxbwfJgasZh6G4fyhGL2nYjdqI78nhIiAASoPkXMpIWRZFqIImYvxo38ddKTQH4dSoOtO27O8pXbJ87rxj9Byy0dOq3aE9xYxDT1IutsO8bAAmYu6bnoG0eTbEMEggHLMsSI11y2wPMGFx4SNWCys3oFYU2INMMxLPAdmCQgjgIc10XQZXgFdRDPTMHVgBMapDBxaUCFMK2ImI2uVi4ZUxTEJRjLrq8NBAEi7fjxOcTvQg29a99%2B3ukz640VQ1xODR0qmqbdTu4ysInqeDnXn6Q8NMO8Mj15sFUHEwQJbUEX8f5B%2BuB0EFVTA%2BSzIdW8IPEGGRMJW9ynYWEgySxRIe3gCQm7mRXuqB0z92/goX%2B2FQHgMwAPMeK89JRDonpWBGYEHL0wg3VBcdUxgIwWnAg4c94rGjmCWOmBVDzDtHaFEYgyzJ1TunTO2dc752PKsOQDBwxfGYDiWgmI%2BSOlbugAQYAOA6jRMAOssRVTICZKUTEKws6Bh2B7fARgjg%2B3%2BEWdA1RMThwLq8R0J5qgiXMLGQyo8ZS/DkAFWcXANDr3Xhwo8dsqE0KwOgTB2FjY2M6pPJxbYXEHH9o/beRjjweOoZgWhPjIHQPrp4uJ3jfERCQSsFBLUUnxPSZkxuOTYl5KISQ3aGEAbAXQRAn%2BF5KlgFyWkxJ0tdwCwjk8AgmJBQrD2EwYIsdsLMWYguJcK5VZ4RWNOcZLEPSvG8IwQBCA%2BTBEgnQgQBJoSwgKCCREpFPZGBWD7BQrp1aWKdgEQcwzFwTIiArfmQ8hm7VWBoI4Ti9maOAIcsICRBwMFQDqKM6ISIaD5CClYYKIWgqheC6FkKVjLFIVwLgrzpzvJ5F80MChBySFNLiEi0gVx8gJcSvkCKnmLC4IFI4UQNBooOUcwcERcUKBIhEPkbKVgcq5aS905KsnIqiDijR6KGVZOZSRGIWS%2BSSslWSnyR5VhRGnEcaIdLPmisbveMOu1GgNz5Lqg1%2BqjV6ulvzMpVIVizilCsORmAaCqD/vCHY6tbCwm1MkXFJyBCWKcAAeQCHsPiAQ5DYFNmcbCGhghONnm2Wes9w6nJ1NxA6AlBy9P6TXK8jz5V81nBoEZEzVz8x2jm5icKIXrhLYROckakUxrjWCv1Aag0hthZWkiZao11tjXGvkTbA3BuwH2/1A7W3gvbYLGtXakU9tnsO5tg752jqHSsftLaibFtNXXGZ5JXgAHVoQsCLtsBOhgRInx1KYlgCRcyJBkX%2BPAog2Rat%2BNUa0tBzRMExC/XF4KvUaxWN1Gyaa%2BkDPrtm6teaC3LiLRuDtNbYWgonaWucgVEPjs3ZOxxkq0Mwow3BrDXB8oNxw0hzDEczW71lo8RNKxZoRRAxmh5c54NQeuTB5DkHJ67glnhit5GuOqC4LxyeEQRNkYIyhvNqgNAidUGJ0F8mROcaYjWmTu5FMKfBUpzTVBkPTOlk8DgUxaCcGnLwTwHAtCkFQJwN4x6FAzDmFbeWPBSAEE0MZqYkkQCSEkDcAAnDSrgURdwzw0FEULQV9CcEkLwFgEg52Wes7ZjgvAsUgo81Z4zpA4CwCQGgFgsQ6BhHIJQQrxX6DhGIERiIIKaC0BxMQLFYtPOkDTswYgmJOBuY6wY31wRtBqiy25wrbBBC%2BoYIItroETDACcGIWgWLuC8CwN/Iw4hsukHwPI2wb9lvWaoWqTsCw3PXFKG16MwQGxdZcFgNrVc8AJZW6QN%2BxBCxKDXJgdbwBc6eamFQAwwAFAADU8CYHNL6wUlm3P8EECIMQ7ApAyEEIoFQ6gtu6EaAYIwIBTDmH0HgYIWLIBTFQLEGCnAjhHAAp8v5bZZvgWQtBZIvwjh6XJ7megb9aCXjc6gN73IsAk79k0YbyQHBggGJ4KIjQfB%2BE6Ns8IGnMhJAENLkAsu4gJDVwwUYcIQAaasOLgQrQaga618bmwLQqgjAV2MboRvbe1FcPUTXQxnf66V4bqYjnZjzAkCZszFm2upZWPjggyAG43BOBEG4tKIC4EIP/AKEQGq8Cy1oH6pAoQ2m6KLnz05pzx93AFk4u5ZcBYC7uCvu5pwxY4HF0gCXo2kGS7wVL6WQCZf%2B0HjgUQQ9bc7%2B53vr334S8kEAA%3D%3D%3D" rel="external" target="_blank">unsafe array accesses</a>
eliminates the array bounds check.
But still, there’s still the count-leading-zeros branch at the start.
Can we get rid of that?</p>
<p>Let’s take another look at a bit of the code –
specifically, how we handle out-of-bounds values:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>exceeded_bit</span><span> </span><span>=</span><span> </span><span>(</span><span>codepoint</span><span> </span><span>&gt;</span><span> </span><span>0x10_FFFF</span><span>)</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span></code></pre></div><p>The trick I pulled here was to cast a boolean (true or false) to an integer
(1 or 0).
Rust’s semantics guarantee this conversion is safe,
and it happens to be a representation the hardware can work with;
it doesn’t appear to incur a conditional after compilation.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<p>I used these booleans-as-integers to perform masking to zero.
But you know what else we can do with integers?</p>
<p><strong>Addition.</strong></p>
<h2 id="the-answer">The answer</h2>
<p>We can get rid of all the branches by tweaking the length-computing function:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>const</span><span> </span><span>fn</span> <span>utf8_bytes_for_codepoint</span><span>(</span><span>codepoint</span>: <span>u32</span><span>)</span><span> </span>-&gt; <span>usize</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>len</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>// In Rust, true casts to 1 and false to 0, so we can &#34;just&#34; sum lengths.
</span></span></span><span><span><span></span><span>    </span><span>len</span><span> </span><span>+=</span><span> </span><span>(</span><span>codepoint</span><span> </span><span>&gt;</span><span> </span><span>0x7f</span><span>)</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>len</span><span> </span><span>+=</span><span> </span><span>(</span><span>codepoint</span><span> </span><span>&gt;</span><span> </span><span>0x7ff</span><span>)</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>len</span><span> </span><span>+=</span><span> </span><span>(</span><span>codepoint</span><span> </span><span>&gt;</span><span> </span><span>0xffff</span><span>)</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// As before:
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>surrogate_bit</span><span> </span><span>=</span><span> </span><span>((</span><span>codepoint</span><span> </span><span>&gt;=</span><span> </span><span>0xD800</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>(</span><span>codepoint</span><span> </span><span>&lt;=</span><span> </span><span>0xDFFF</span><span>))</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>surrogate_mask</span><span> </span><span>=</span><span> </span><span>surrogate_bit</span><span> </span><span>&lt;&lt;</span><span> </span><span>2</span><span> </span><span>|</span><span> </span><span>surrogate_bit</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>|</span><span> </span><span>surrogate_bit</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exceeded_bit</span><span> </span><span>=</span><span> </span><span>(</span><span>codepoint</span><span> </span><span>&gt;</span><span> </span><span>0x10_FFFF</span><span>)</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exceeded_mask</span><span> </span><span>=</span><span> </span><span>exceeded_bit</span><span> </span><span>&lt;&lt;</span><span> </span><span>2</span><span> </span><span>|</span><span> </span><span>exceeded_bit</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>|</span><span> </span><span>exceeded_bit</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>len</span><span> </span><span>&amp;</span><span> </span><span>!</span><span>surrogate_mask</span><span> </span><span>&amp;</span><span> </span><span>!</span><span>exceeded_mask</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This is the answer to Nathan’s original question, about working out the number of bytes.
Compiler explorer confirms that, with optimizations enabled, <a href="https://godbolt.org/#g:!%28%28g:!%28%28g:!%28%28h:codeEditor,i:%28filename:%271%27,fontScale:14,fontUsePx:%270%27,j:1,lang:rust,selection:%28endColumn:2,endLineNumber:22,positionColumn:2,positionLineNumber:22,selectionStartColumn:2,selectionStartLineNumber:22,startColumn:2,startLineNumber:22%29,source:%27%23%5Bno_mangle%5D%0Aconst+fn+utf8_bytes_for_codepoint%28codepoint:+u32%29+-%3E+usize+%7B%0A++++let+mut+len+%3D+1%3B%0A++++//+In+Rust,+true+casts+to+1+and+false+to+0,+so+we+can+%22just%22+sum+lengths.%0A++++len+%2B%3D+%28codepoint+%3E+0x7f%29+as+usize%3B%0A++++len+%2B%3D+%28codepoint+%3E+0x7ff%29+as+usize%3B%0A++++len+%2B%3D+%28codepoint+%3E+0xffff%29+as+usize%3B%0A%0A++++//+Handle+surrogates+via+bit-twiddling.%0A++++//+Rust+guarantees+true+%3D%3D+1+and+false+%3D%3D+0:%0A++++let+surrogate_bit+%3D+%28%28codepoint+%3E%3D+0xD800%29+%26%26+%28codepoint+%3C%3D+0xDFFF%29%29+as+usize%3B%0A++++//+Extend+that+one+bit+into+three,+and+use+its+inverse+as+a+mask+for+length%0A++++let+surrogate_mask+%3D+surrogate_bit+%3C%3C+2+%7C+surrogate_bit+%3C%3C+1+%7C+surrogate_bit%3B%0A%0A++++//+Handle+exceeded+values+via+bit-twiddling.%0A++++//+Unfortunately,+these+don!%27t+align+precisely+with+a+leading-zero+boundary%3B%0A++++//+the+largest+codepoint+is+U%2B10FFFF.%0A++++let+exceeded_bit+%3D+%28codepoint+%3E+0x10_FFFF%29+as+usize%3B%0A++++let+exceeded_mask+%3D+exceeded_bit+%3C%3C+2+%7C+exceeded_bit+%3C%3C+1+%7C+exceeded_bit%3B%0A%0A++++len+%26+!!surrogate_mask+%26+!!exceeded_mask%0A%7D%27%29,l:%275%27,n:%270%27,o:%27Rust+source+%231%27,t:%270%27%29%29,k:44.92012780022726,l:%274%27,m:100,n:%270%27,o:%27%27,s:0,t:%270%27%29,%28g:!%28%28h:compiler,i:%28compiler:r1830,filters:%28b:%270%27,binary:%271%27,binaryObject:%271%27,commentOnly:%270%27,debugCalls:%271%27,demangle:%270%27,directives:%270%27,execute:%271%27,intel:%270%27,libraryCode:%270%27,trim:%271%27,verboseDemangling:%270%27%29,flagsViewOpen:%271%27,fontScale:14,fontUsePx:%270%27,j:1,lang:rust,libs:!%28%29,options:%27-O%27,overrides:!%28%29,selection:%28endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1%29,source:1%29,l:%275%27,n:%270%27,o:%27+rustc+1.83.0+%28Editor+%231%29%27,t:%270%27%29%29,header:%28%29,k:55.07987219977275,l:%274%27,m:100,n:%270%27,o:%27%27,s:0,t:%270%27%29%29,l:%272%27,n:%270%27,o:%27%27,t:%270%27%29%29,version:4" rel="external" target="_blank">this function is branchless</a>.</p>
<p>Happily, this transformation also allowed the compiler to realize <code>len &lt;= 4</code> on all paths,
and to statically eliminate the array bounds check.
That means <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DEArgoKkl9ZATwDKjdAGFUtEywYgA7KUcAZPAZMADl3ACNMYhAAJmjSAAdUBUI7Bhc3D28EpJSBAKDQlgio2MtMa1sBIQImYgJ0908fK0wbVOragnyQ8MiYuPNOhszmmrruwuL%2BgEpLVBNiZHYOAHoVsDAAagAhYkNkBHoFBU3GNHwjTdQqTfPMRMCCE8fUTbkAFQAxAFoADgA6ACkGgAgmsNsCwestu8EIYANYnIibYJMAhwhibfjETbozCbACOJkw5lSm0M6E2fhIjAAXliSLiEPj4ZgAJ6bQLJYAIAhA0HgrYghgc4iYFhMQKBYCbFh4Qask61fFyoL8qEQgXQzZCTD43kEeIKEBrYCEBAmML/NAsFYKVmYIgrMJ7BgHI4Kb4mAhUX4MnFYc7S9WQtYrTbYN0YfFMN5fP63aMPQTqsObABKjoWDCVmzCJioVEi5IYlLxmwYvRx102ADcxHhKWE2QQSZzMeX84XIqm1qG1pt3q8mOgywh5YmsMmCLjh5tzMRpaRyfF4o5ybRaAyFnmW23AldiFgyP3wxTNmK0EemWjNhAzHhaZhprvWycAO6RGOjzBl17lhdg1PU8MyzYgc3JTZ6CMdErhuJ9iFebF23rWhG0ne5UEeE4IAUBZEOANE23PeYCG%2Ba5vjCeZSxOVDiQUaZ1XiS0sUxF19kOEkFAAfW9X0IDuacQE2EwAGZohfb5AVE7A70BABWbYTF%2BaTtk2SQFIAEWXB8nxfQEvG2SFNhMqDHTMzFpM0kSfV%2BbjmzfbjsW4wSsMEASkzcghplU4zTPoGcu02KzgsUvzTNM5R02wT4AEkAA0FO2aCtKSjQtOCrwnDvDypy84KZOk2ShAACViz53iSlL5M0tKtP06IADZNgAWRBIQAGkqsYVLFPSmryROMSJMGkTflIcKIs2KKYoS7qGF67YuAygzsqgVzHgK7Aip1MqKvmxblpqhrmrazqDpqpKjuspghvEl9brGibQSmyLorixLFOq2rFOiFaspyjbBC2nbSvKyqvp6y7fvq4Kmta9qushhboe2P6Bse4aHqG8bJoimaPoun7tlE/61tyzDNqK0G9oh5KoeJ0njrh07EaJpKmZuu6Rsx3GXtM1LRKM0FJogLtl2gnyRa8WqRdBNAcxnKhMT4uyHJJJySBczzHgpoSRPuzYpJkkTkifTLhZBCKAtlb0LIK6zlqFyaB1izF0zMCxcVMfFRHMJFXi4EtKSoMQlFnTYNGXBRXk/W5DDh6JtE9wFYnndwLOAdEFHVa3GDhozROsvX8p2jRVC8KhsdNx9MF8/mTOgguQpLqmTfLyuq9G3S6%2Bdhv7dTwvi6Bmcy9UQtC2rnv65BF3wxKil6HT4gCKI2i8FjMJCG%2BAh30bdA0KMXPTIHD3zE2YATFqQxWzbAgfYdkKg/PUPaHDqyQo0EBJptvCV9QQirZ7KEAdoDHWwNqZF0jqoTSvwNAaBOqnZqrcIGiScJ/GBnwsHTCnmbXulsIoDmwKoVspYbwzgEPiLeM4XhMjFJgZc54zD4kIM8BgtZIjh0erGCU9p/SZ3RD/cyf9V5AN4fCUBIiAFEWAaPNB0lsrREytlKRgDMCyIKugtBmwg6rWXqI9R1CZ5z02AvUsS9MCqCWL%2BX8dYxD0TrBvPM29d770PsAY%2BJkBxyAYNiAgJhmCtloGyZceJw7oAEGADgM4GzAExPES88pygcj3rBWM9ARzSm%2BAhV4VEAnoFqGyGehDwzlgMMQYAJIZwj05CcOQg8uAaCwVgzxZkZyWOsVgdAGiW41LHo07izTPi4NrsU/y5kOl6i6dxcRoDJk2O6dQzRCjNhKL0fM6ZSyFErN0QDDZv5ZHGP7k3JBmwNiqJkbM05Gx9ndPEZCAystZ6ggIGyNcg4mBhCXiFJKSVlKqXUoLNS8kgUPK1DsPcmwEmYBoKofhsYFa2ErGiMk6t1QK3Pk4AA8sEd4sVghyGwMJZSoCNBhEafA7i8D4EzwxTOAmCVhLvE%2Bd8qBvz%2B5pX%2BULQFNVnpWwFn1ZcUdI5Cq0nyiKaVyUUqpdS5c2LcX4sJUK0VvLJqSq4BqjQMr4FypxXigl2BdUKoNSq7Saq%2BpSo1dq4V8r9VKs2LaxVhqHV6qdWKh5l0%2B7PKhJsAA6iqT25IV6GEqeQpkKokhkW5AwPANBRDA3VkqMUG53xMDZGw18%2BINDooEOfMGFUmUsvxD8sKHK%2BpcrUhpVVZbtjCrraa8VArtiNWVSKyO7qa1cDiJsFtbb%2Bpms7eNHR3be39r5aCuWII6UI06oWr5xa2Wlv5SZTlKluVVoHcu0KtaK5UFbXWjtW60qqC4Hu6Bokz0HurUevqqgNCXtUBeoVj7L2HolbejQPhz0Pqfd%2Bw9E7vWpyZtsZAVBgAQDfN5VKoIWAYFxFUk4BkCGmWYbcPYrYQDf0MuxN0nFji8VsjpWy9k9w8WciPR5Ryj3RGA5B6DW7lYCIQBAfShk8amWQngdskd/j/HLlgwZzSLbsdejbYAqA5HWVViRxy5HwEEAgHgHyXrXqifMqm1B1kDi1Ew1QRCLBeLiUU1LLdqmpr/AlPECAq1kB6OQP8Ig3FAJGBY/8W6MmSSuegixkzZmzP/ACe%2BPY8RuIkAgAgsZfnBpKDqNxTABINgQA017cTXtU5/UMhQVQjzhJIeS48s5YAfmGVS5R2IvnVOUY5TLMF1HaNVPoxFRjOH3RcSc6wTALHhP9ya4yLjB5s18dUAJoZ3XTOqZtmLUjEtGD6SgS1vDPFVbGci35sTEnQFIMTUlXj31VtmZtsl0B2moggD06gAzw0Vs9ai5sCzTArM2bsw51ATn77Slc%2B5xNrnHOoHfEEdAPmRN%2BYCwwILD3QvEAgAANVaJhoI74gcqdu7dGLBA4sJcgEg5Ly5UvKeQ69KrR6avS00hwWYtBODyV4J4DgWhSCoE4GfGcMcFhLDhqJHgpACCaHJ7MeEIBJCSH%2BAATmiBoLtXg4EaFiF4Jq%2BhOCSF4CwCQOraf08ZxwXgxoo487p%2BT0gcBYBIBtPEOgkRyCUFN%2BbqIxAuC/FElHGgtBWzEGNGLXnpAt7MGIGyTgXPveFKxWEbQrQ9dc5tGwQQWKGDBM91gfMwAnBiDfv73gWAJRGHEPr0g%2BBLy2A4caHPljWjemWFzx45RPdoXYr7lwWBPfvZV9wXgHDiBUSUJpcUIb3G89mFQAwwAFDQ7wJgd8WK1y065/wQQIgxDsCkDIQQigVDqBz7oLg%2BgQ0gFMOYfQeAwjGkgLMVA8RKg5k4N8LFvBUBt8XFgI/LGygVFSA4UswxPCb/8IEHoRQ%2Bib8SGSHPw/z0EANyAYAmCrD0BaDaCqDGHqFcEaGgPKDD3aHgMgL/yiE30GDqBAOwPQJ/0mH/1mFZ0WAXwpypxp0901wvE9mQB0X%2BAdz4zvFwEIEZCAy4GmF4D1y0BwVIGZBHD6CfwF3knkj4y8BF1%2BDly4BFxFy8Dly8HkgVw4CV1IBVwpVIHVxv04G1xAF1z7woI4GiCoJz0124IMNIDb2SHsEkCAA%3D" rel="external" target="_blank">the full code</a> is branchless as well. Victory!</p>
<h2 id="the-caveats">The caveats</h2>
<p>While this is <em>branchless</em>, I make absolutely no claim that it is <em>optimized</em> –
my only goal here was a proof-of-concept of branchlessness.
I haven’t even benchmarked it!</p>
<p>Chris Wellons notes in <a href="https://nullprogram.com/blog/2017/10/06/" rel="external" target="_blank">his post about branchless decoding</a>
that a DFA-based decoder can have similar performance;
SIMD and other “use what the hardware gives you” techniques
are probably even better.
I wouldn’t bet on my encoder over the one in your favorite standard library.</p>
<p>I also make no claims of usefulness.
But you’re welcome to do just about anything with the code:
I hereby release it under the MIT license. The full code is
<a href="https://cceckman.com/r/unicode-branchless" rel="external" target="_blank">here</a>,
along with the tests I used to match it against Rust’s implementation.</p>
<h2 id="thanks">Thanks!</h2>
<p>Thanks Nathan for the question and Lorenz for the insights!
Any mistakes remaining are my own – give me a shout if you spot them!</p>
<div>
  <p><a href="mailto:charles@cceckman.com">E-mail</a></p>
  <p><a ref="me" href="https://hachyderm.io/@cceckman">Fediverse</a></p>
  
  
</div>

<div role="doc-endnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I wanted to make this a total function, so the length lookup covers 0 to 32 inclusive. <a href="#fnref:1" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:2">
<p>Of course, as we saw <a href="#count-leading-zeros">above</a>,
“what the compiler does” can be opaque.
I’m just talking about what <code>rustc +1.83 -O</code> does today – your mileage may vary! <a href="#fnref:2" role="doc-backlink">↩︎</a></p>
</li>
</ol>
</div>
</div></div>
  </body>
</html>
