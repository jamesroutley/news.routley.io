<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://coredumped.dev/2025/06/18/making-tramp-go-brrrr./">Original</a>
    <h1>Making TRAMP go Brrrr</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>I recently changed jobs and found myself in a position where I would need to do a lot of work over TRAMP. I had used TRAMP before and it tended to be slow. Since I would be using it all day now I figured I should take some time to make it faster.</p>
<h2 id="tramp-is-great">
    <a href="#tramp-is-great">
      TRAMP is great
    </a>
</h2>
<p>TRAMP really is an amazing piece of technology. It supports a huge number of protocols and for the most part, it lets you pretend that you are working with on a local system. You can copy files around, run programs, run shells, and for the most part everything just works.</p>
<p>But TRAMP unfortunately has a propensity for being slow. Sometimes this is not TRAMPs fault and comes from how it is used. In my testing, each call through TRAMP takes about 50-100ms. Compare that to a normal external process call in Emacs which would take around 1 ms. Workflows that work fine on a local machine become unbearable when working remotely. However, this doesn’t mean that TRAMP has to be slow. If you run <code>emacs -Q</code> and use TRAMP you will normally find it quite snappy.</p>
<h2 id="getting-started">
    <a href="#getting-started">
      Getting started
    </a>
</h2>
<p>First, let’s set up some of the basic settings. These settings below will prevent TRAMP from creating a bunch of extra files and use scp directly when moving files.</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>(</span><span>setq</span> <span>remote-file-name-inhibit-locks</span> <span>t</span>
</span></span><span><span>      <span>tramp-use-scp-direct-remote-copying</span> <span>t</span>
</span></span><span><span>      <span>remote-file-name-inhibit-auto-save-visited</span> <span>t</span><span>)</span>
</span></span></code></pre></div><p>In order to open a file on a remote host, TRAMP needs to copy the file contents to your local machine. Most TRAMP methods have two ways to copy files; inline or out-of-band. Out-of-band will use external methods like <code>rsync</code> or <code>scp</code>, while inline will send compressed base64 encoded text over the SSH session and then decode it on the other side. This works best for small files where the overhead of creating a new connection is not worth it. This is by default set to 10KB. However, I found in my testing that the best value was much bigger than that.</p>
<figure><img src="https://ntietz.com/images/tramp/inline_vs_OOB.png"/>
</figure>

<p>You can see in the graph above that inline is faster all the way up until about 2MB. After that point inline continues to grow linearly (the x-axis is logarithmic) while the out-of-band copying is sub-linear. Generally the slower the connection, the bigger the gap between inline and out-of-band. In the graph above it is 250ms, but on some slower connections I have observed that gap to be closer to 750ms. Interestingly, the cutoff always seems to be around 2MB, at least on my machines.</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>(</span><span>setq</span> <span>tramp-copy-size-limit</span> <span>(</span><span>*</span> <span>1024</span> <span>1024</span><span>)</span> <span>;; 1MB</span>
</span></span><span><span>      <span>tramp-verbose</span> <span>2</span><span>)</span>
</span></span></code></pre></div><p>I also found that using <code>rsync</code> as your method makes updating an existing file (i.e. making a small change to a file and saving it) about 3-4 times faster than using <code>scp</code>.  I don’t use <code>rsync</code> though because it breaks remote shells.</p>
<h2 id="use-direct-async">
    <a href="#use-direct-async">
      Use Direct Async
    </a>
</h2>
<p>When creating a new process in Emacs, you have two options: synchronous or asynchronous. Async processes have historically been really slow over TRAMP, because it has to create a new connection for every async process. However recent version of TRAMP have added a feature called <a href="https://www.gnu.org/software/TRAMP/#Improving-performance-of-asynchronous-remote-processes-1">direct async process</a> that makes this significantly faster. This feature alone will take many packages (like magit or git-gutter) from completely unusable to bearable over TRAMP. Here is how you configure it with TRAMP <code>2.7</code>.</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>(</span><span>connection-local-set-profile-variables</span>
</span></span><span><span> <span>&#39;remote-direct-async-process</span>
</span></span><span><span> <span>&#39;</span><span>((</span><span>tramp-direct-async-process</span> <span>.</span> <span>t</span><span>)))</span>
</span></span><span><span>
</span></span><span><span><span>(</span><span>connection-local-set-profiles</span>
</span></span><span><span> <span>&#39;</span><span>(</span><span>:application</span> <span>tramp</span> <span>:machine</span> <span>&#34;server&#34;</span><span>)</span>
</span></span><span><span> <span>&#39;remote-direct-async-process</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>(</span><span>setq</span> <span>magit-tramp-pipe-stty-settings</span> <span>&#39;pty</span><span>)</span>
</span></span></code></pre></div><p>We have to add that extra setting to get magit to work. See <a href="https://github.com/magit/magit/issues/5220">this issue</a> for more details. You can double check that this mode is working by calling <code>M-: (tramp-direct-async-process-p)</code> on a remote file. make sure to change <code>&#34;server&#34;</code> to the name of your remote.</p>
<h2 id="fix-remote-compile">
    <a href="#fix-remote-compile">
      Fix remote compile
    </a>
</h2>
<p>Newer versions of TRAMP will use <a href="https://www.gnu.org/software/TRAMP/#Using-ssh-connection-sharing-1">SSH connection sharing</a> for much faster connections, that don’t require you to enter your password each time you connect. The <code>compile</code> command disables this feature, so we want to turn it back on.</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>(</span><span>with-eval-after-load</span> <span>&#39;tramp</span>
</span></span><span><span>  <span>(</span><span>with-eval-after-load</span> <span>&#39;compile</span>
</span></span><span><span>    <span>(</span><span>remove-hook</span> <span>&#39;compilation-mode-hook</span> <span>#&#39;</span><span>tramp-compile-disable-ssh-controlmaster-options</span><span>)))</span>
</span></span></code></pre></div><h2 id="how-to-debug-perf-issues">
    <a href="#how-to-debug-perf-issues">
      How to debug perf issues
    </a>
</h2>
<p>So what can we do to make working over TRAMP faster? If you are like me and already have an existing config, it is more than likely that some packages you are using are not going to play nicely over TRAMP due to the extra overhead. There will be certain operations like changing modes, moving the cursor, or saving a buffer that has inexplicable delays.</p>
<p>When you encounter this, you should use the profiler. use <code>M-x profiler-start</code> before  behavior that is slow and then <code>M-x profiler-stop</code> and <code>M-x profiler-report</code> afterwards. This will give you a hierarchical list of where Emacs was spending its time. If this is an issue related to TRAMP you should see <code>tramp-wait-for-output</code> be a significant portion of the total time. But it is not always clear what is actually causing TRAMP to be called. In this case, you can use <code>debug-on-entry</code>  on <code>TRAMP_send-command</code> to get a backtrace when something calls TRAMP. This will let you see the exact commands that are calling out to TRAMP and causing the slow down. In my case, I found a couple of the features of doom modeline were causing a lot of delays.</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>(</span><span>remove-hook</span> <span>&#39;evil-insert-state-exit-hook</span> <span>#&#39;</span><span>doom-modeline-update-buffer-file-name</span><span>)</span>
</span></span><span><span><span>(</span><span>remove-hook</span> <span>&#39;find-file-hook</span> <span>#&#39;</span><span>doom-modeline-update-buffer-file-name</span><span>)</span>
</span></span><span><span><span>(</span><span>remove-hook</span> <span>&#39;find-file-hook</span> <span>&#39;forge-bug-reference-setup</span><span>)</span>
</span></span></code></pre></div><h2 id="magit">
    <a href="#magit">
      Magit
    </a>
</h2>
<p>magit is one of Emacs super powers, consistently rated as one of the best packages. I use it for practically everything related to git. Unfortunately, it is quite slow over TRAMP. On my remote repo’s it can take 10-20 seconds just to run <code>magit-status</code>. And every time you run a command it needs to refresh the whole status buffer, leading to more delays. Magit is designed to run on a local machine where shell commands are cheap. A simple magit command might run 30 individual shell commands. This can be a big overhead over TRAMP.</p>
<p>So here is my advice for working with magit over TRAMP.</p>
<ol>
<li>Use <code>magit-dispatch</code> and <code>magit-file-dispatch</code> instead of doing everything from the status buffer. This will let you quickly execute commands without waiting for the status buffer to load and refresh each time. Only use the status buffer when you need to get a high-level view of your repo or need to operate on large numbers of files.</li>
<li>Don’t be afraid to just run a shell command. Running <code>M-S-! git branch foo</code> or <code>M-S-! git commit -m &#34;Update foo&#34;</code> will often be faster than waiting 8 seconds for magit to populate all branch targets over ssh, or load the git commit interface. Some things like cherry-picking or rebasing are still much easier in magit, despite the overhead.</li>
<li>Try and remove anything extra that magit might try and do. Here are some settings I am using.</li>
</ol>
<!-- raw HTML omitted -->
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>(</span><span>defun</span> <span>$magit-auto-revert-not-remote</span> <span>(</span><span>orig-fun</span> <span>&amp;rest</span> <span>args</span><span>)</span>
</span></span><span><span>  <span>(</span><span>unless</span> <span>(</span><span>and</span> <span>buffer-file-name</span> <span>(</span><span>file-remote-p</span> <span>buffer-file-name</span><span>))</span>
</span></span><span><span>    <span>(</span><span>apply</span> <span>orig-fun</span> <span>args</span><span>)))</span>
</span></span><span><span>
</span></span><span><span><span>;; Don&#39;t auto-revert remote files</span>
</span></span><span><span><span>(</span><span>advice-add</span> <span>&#39;magit-turn-on-auto-revert-mode-if-desired</span>
</span></span><span><span>            <span>:around</span>
</span></span><span><span>            <span>#&#39;</span><span>$magit-auto-revert-not-remote</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>;; don&#39;t show the diff by default in the commit buffer. Use `C-c C-d&#39; to display it</span>
</span></span><span><span><span>(</span><span>setq</span> <span>magit-commit-show-diff</span> <span>nil</span><span>)</span>
</span></span><span><span><span>;; don&#39;t show git variables in magit branch</span>
</span></span><span><span><span>(</span><span>setq</span> <span>magit-branch-direct-configure</span> <span>nil</span><span>)</span>
</span></span><span><span><span>;; don&#39;t automatically refresh the status buffer after running a git command</span>
</span></span><span><span><span>(</span><span>setq</span> <span>magit-refresh-status-buffer</span> <span>nil</span><span>)</span>
</span></span></code></pre></div><p>A lot of this slowness could be alleviated with some better caching. When I first started testing this I found <code>forge-dispatch</code> to be extremely slow. Some profiling showed that <a href="https://github.com/magit/forge/discussions/712">magit was making 176 calls over TRAMP</a>, even though it only needed 6 of them. This has since been fixed, but there is more performance to be gained. I tried to <a href="https://github.com/magit/magit/pull/5228">implement a magit caching mechanism</a> and it was a huge boost for performance (though it is still very rough). I stopped working on it because the magit maintainer <a href="https://github.com/magit/magit/pull/5228#issuecomment-2379743798">said that he is hoping 2025 will be the year</a> to add caching to the whole magit workflow! If you are interested in seeing that happen, consider sponsoring <a href="https://github.com/sponsors/tarsius">here</a>.</p>
<h3 id="speed-git">
    <a href="#speed-git">
      Speed Git
    </a>
</h3>
<p>Even with all the settings above, opening the status buffer and staging a few files is still quite slow. So I created a simple mode that just opens a status buffer and lets me easily stage some files. It doesn’t have any of the fancy features or folding headers of the magit status buffer, but it is nearly instantaneous. When I want to quickly stage or unstage some files, this is what I reach for. I am not interested in trying to maintain this as a proper package, but <a href="https://github.com/CeleritasCelery/emacs.d/blob/master/speed-git.el">here</a> is the source if you are interested.</p>
<h2 id="lsp">
    <a href="#lsp">
      LSP
    </a>
</h2>
<p>LSP mode works over TRAMP, but unfortunately not with the direct async process feature. There is a <a href="https://github.com/emacs-lsp/lsp-mode/issues/4573">workaround</a> you can use though. Another alternative is <a href="https://github.com/manateelazycat/lsp-bridge">lsp-bridge</a>, but I was not able to test it because it requires the remote python to be built with FFI support, which my server does not have. Even though it is supported, LSP over TRAMP can be kind of slow, so I tend not to use it. Rather than adding <code>lsp</code> to the major mode hook, I added this function that will not enable LSP by default on remote hosts. It also removes other functionality that can tend to cause a slowdown.</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>(</span><span>defun</span> <span>$lsp-unless-remote</span> <span>()</span>
</span></span><span><span>  <span>(</span><span>if</span> <span>(</span><span>file-remote-p</span> <span>buffer-file-name</span><span>)</span>
</span></span><span><span>      <span>(</span><span>progn</span> <span>(</span><span>eldoc-mode</span> <span>-1</span><span>)</span>
</span></span><span><span>             <span>(</span><span>setq-local</span> <span>completion-at-point-functions</span> <span>nil</span><span>))</span>
</span></span><span><span>    <span>(</span><span>lsp</span><span>)))</span>
</span></span></code></pre></div><h2 id="cache-everything">
    <a href="#cache-everything">
      Cache everything
    </a>
</h2>
<p>If sending calls over TRAMP is so expensive, the best thing we can do is not run them. TRAMP already has some built-in caching for things like remote files, but it only keeps them for a short while. Anything that doesn’t go through TRAMP will be a win. I created this function for just that purpose:</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>(</span><span>defun</span> <span>memoize-remote</span> <span>(</span><span>key</span> <span>cache</span> <span>orig-fn</span> <span>&amp;rest</span> <span>args</span><span>)</span>
</span></span><span><span>  <span>&#34;Memoize a value if the key is a remote path.&#34;</span>
</span></span><span><span>  <span>(</span><span>if</span> <span>(</span><span>and</span> <span>key</span>
</span></span><span><span>           <span>(</span><span>file-remote-p</span> <span>key</span><span>))</span>
</span></span><span><span>      <span>(</span><span>if-let</span> <span>((</span><span>current</span> <span>(</span><span>assoc</span> <span>key</span> <span>(</span><span>symbol-value</span> <span>cache</span><span>))))</span>
</span></span><span><span>          <span>(</span><span>cdr</span> <span>current</span><span>)</span>
</span></span><span><span>        <span>(</span><span>let</span> <span>((</span><span>current</span> <span>(</span><span>apply</span> <span>orig-fn</span> <span>args</span><span>)))</span>
</span></span><span><span>          <span>(</span><span>set</span> <span>cache</span> <span>(</span><span>cons</span> <span>(</span><span>cons</span> <span>key</span> <span>current</span><span>)</span> <span>(</span><span>symbol-value</span> <span>cache</span><span>)))</span>
</span></span><span><span>          <span>current</span><span>))</span>
</span></span><span><span>    <span>(</span><span>apply</span> <span>orig-fn</span> <span>args</span><span>)))</span>
</span></span></code></pre></div><p>I can then use it to cache things I don’t want TRAMP to be looking up all the time. Here are some things that get called very frequently and don’t really change. If I ever want to reset the cache, I can reset the variable to <code>nil</code>.</p>
<div><pre tabindex="0"><code data-lang="emacs-lisp"><span><span><span>;; Memoize current project</span>
</span></span><span><span><span>(</span><span>defvar</span> <span>project-current-cache</span> <span>nil</span><span>)</span>
</span></span><span><span><span>(</span><span>defun</span> <span>memoize-project-current</span> <span>(</span><span>orig</span> <span>&amp;optional</span> <span>prompt</span> <span>directory</span><span>)</span>
</span></span><span><span>  <span>(</span><span>memoize-remote</span> <span>(</span><span>or</span> <span>directory</span>
</span></span><span><span>                       <span>project-current-directory-override</span>
</span></span><span><span>                       <span>default-directory</span><span>)</span>
</span></span><span><span>                   <span>&#39;project-current-cache</span> <span>orig</span> <span>prompt</span> <span>directory</span><span>))</span>
</span></span><span><span>
</span></span><span><span><span>(</span><span>advice-add</span> <span>&#39;project-current</span> <span>:around</span> <span>#&#39;</span><span>memoize-project-current</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>;; Memoize magit top level</span>
</span></span><span><span><span>(</span><span>defvar</span> <span>magit-toplevel-cache</span> <span>nil</span><span>)</span>
</span></span><span><span><span>(</span><span>defun</span> <span>memoize-magit-toplevel</span> <span>(</span><span>orig</span> <span>&amp;optional</span> <span>directory</span><span>)</span>
</span></span><span><span>  <span>(</span><span>memoize-remote</span> <span>(</span><span>or</span> <span>directory</span> <span>default-directory</span><span>)</span>
</span></span><span><span>                   <span>&#39;magit-toplevel-cache</span> <span>orig</span> <span>directory</span><span>))</span>
</span></span><span><span><span>(</span><span>advice-add</span> <span>&#39;magit-toplevel</span> <span>:around</span> <span>#&#39;</span><span>memoize-magit-toplevel</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>;; memoize vc-git-root</span>
</span></span><span><span><span>(</span><span>defvar</span> <span>vc-git-root-cache</span> <span>nil</span><span>)</span>
</span></span><span><span><span>(</span><span>defun</span> <span>memoize-vc-git-root</span> <span>(</span><span>orig</span> <span>file</span><span>)</span>
</span></span><span><span>  <span>(</span><span>let</span> <span>((</span><span>value</span> <span>(</span><span>memoize-remote</span> <span>(</span><span>file-name-directory</span> <span>file</span><span>)</span> <span>&#39;vc-git-root-cache</span> <span>orig</span> <span>file</span><span>)))</span>
</span></span><span><span>    <span>;; sometimes vc-git-root returns nil even when there is a root there</span>
</span></span><span><span>    <span>(</span><span>when</span> <span>(</span><span>null</span> <span>(</span><span>cdr</span> <span>(</span><span>car</span> <span>vc-git-root-cache</span><span>)))</span>
</span></span><span><span>      <span>(</span><span>setq</span> <span>vc-git-root-cache</span> <span>(</span><span>cdr</span> <span>vc-git-root-cache</span><span>)))</span>
</span></span><span><span>    <span>value</span><span>))</span>
</span></span><span><span><span>(</span><span>advice-add</span> <span>&#39;vc-git-root</span> <span>:around</span> <span>#&#39;</span><span>memoize-vc-git-root</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>;; memoize all git candidates in the current project</span>
</span></span><span><span><span>(</span><span>defvar</span> <span>$counsel-git-cands-cache</span> <span>nil</span><span>)</span>
</span></span><span><span><span>(</span><span>defun</span> <span>$memoize-counsel-git-cands</span> <span>(</span><span>orig</span> <span>dir</span><span>)</span>
</span></span><span><span>  <span>(</span><span>$memoize-remote</span> <span>(</span><span>magit-toplevel</span> <span>dir</span><span>)</span> <span>&#39;$counsel-git-cands-cache</span> <span>orig</span> <span>dir</span><span>))</span>
</span></span><span><span><span>(</span><span>advice-add</span> <span>&#39;counsel-git-cands</span> <span>:around</span> <span>#&#39;</span><span>$memoize-counsel-git-cands</span><span>)</span>
</span></span></code></pre></div><h2 id="future-work">
    <a href="#future-work">
      Future work
    </a>
</h2>
<p>All this work has made TRAMP quite usable for me. There are still things that are slow, but almost nothing that just doesn’t work. For most of the work I do I hardly notice that I am working over a remote protocol. However, in writing all this, I kept thinking to myself “There has to be a better way to do this”. I have started to think of ways to fundamentally improve the performance of TRAMP that would involve changes to the package itself. I plan to write more on that soon, so stay tuned!</p>

  </div></div>
  </body>
</html>
