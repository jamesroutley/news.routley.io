<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zwischenzugs.com/2022/01/04/practical-shell-patterns-i-actually-use/">Original</a>
    <h1>Practical Shell Patterns I Use</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Over the decades I’ve been using the shell, there are thousands of reusable patterns I’ve picked up from looking over others’ shoulders and googling.</p>



<p>Unfortunately, I’ve forgotten about 95% of them.</p>



<p>So here, I list many of the patterns I <em>actually use often enough to be able to remember</em>. If you want to get them under your fingers, your mileage may vary depending on your tastes and what you most commonly use the shell for.</p>



<p>I’m acutely aware that for most of these tips there are better/faster/more elegant ways to achieve the same thing, but that’s not the point here. The point is to reflect on what actually stuck, so that others may save time by spending their time learning what is more likely to stick. I will mention alternative methods and why they <em>didn’t</em> take as we go, as well as theoretical limitations or flaws in the methods I actually use.</p>



<p>I’m going to cover:</p>



<ul><li>Get The Last Field From The Output</li><li>Use <code>sed</code> To Extract</li><li>‘Do For All’ with <code>xargs</code></li><li>Kill All Processes</li><li>Find Files Ending With…</li><li>Process Files With <code>sed | sh</code></li><li>Give Me All The Output With <code>2&gt;&amp;1</code></li><li>Separate Lines With <code>tr</code></li><li>Quick Infinite Loop</li><li>Inline Files</li></ul>



<h4 id="get-the-last-field-from-the-output">Get The Last Field From The Output</h4>



<pre>$ [commands] | awk &#39;{print $NF}&#39; </pre>



<p>This is what I most commonly use <code>awk</code> for on the command line. I also use it where I might most elegantly use <code>cut</code>, by selecting a specific field with (for example, for the second field) <code>awk &#39;{print $2}&#39;</code> (see below ‘Kill All Processes’).</p>



<p>In the top example, <code>NF</code> stands for ‘number of fields’, which matches the last field (since <code>awk</code> is not zero-indexed). The last field in the command pipeline is commonly a filename, so I often chain this command with <code>xargs</code> to process each file in turn with a new command (see below “‘Do For All’ With <code>xargs</code>“).</p>



<p>You can also use <code>cut</code> for this kind of thing, but I have found that a mixture of <code>awk</code> and <code>sed</code> have sufficed for me to achieve what I want. I do use <code>cut</code> every now and then, though.</p>







<p>When using pipelines, you frequently want to extract a specific part of each line that is output. </p>



<p>My goto command for this is <code>sed</code>, which is well worth investing time in. Before you do that, you have to have a reasonably good understanding of regular expressions, which is even more worth investing time in.</p>



<p>The <code>sed</code> pattern I use most often is the search and replace one (<code>s/</code>FIND/REPLACE/), an example of which is below. This example takes the contents of the <code>/etc/passwd</code> database and outputs the username and default shell for each account on the system:</p>



<pre>$ cat /etc/passwd | sed &#39;s/\([^:]*\):.*:\(.*\)/user: \1 shell: \2/&#39;</pre>



<p><code>sed</code> (which is short for ‘stream editor’) can take a filename as an argument, but if none is supplied it assumes it’s receiving lines through standard input.</p>



<p>The first character of the <code>sed</code> script (which is ‘<code>s</code>‘ in the example) indicates the command <code>sed</code> is being given (in bold below), followed by the default separator (which is a forward slash).</p>



<pre><code><strong>s/</strong>\([^:]*\):.*:\(.*\)/user: \1 shell: \2/</code></pre>



<p>Then, what follows (up to the next forward slash) is the regular expression pattern to match in each line (in bold below):</p>



<pre> <code>s/<strong>\([^:]*\):.*:\(.*\)</strong>/user: \1 shell: \2/</code></pre>



<p>Within those toenail clippings, you see two sets of opening and closing parentheses. Each of these is escaped by a backslash (to distinguish them from just matching the parentheses characters as characters):</p>



<ul><li><code>\([^:]*\)</code></li><li><code>\(.*\)</code></li></ul>



<p>The first one ‘captures’ the username, while the second one ‘captures’ their shell. These are then referenced in the ‘replace’ part of the <code>sed</code> command by their number order:</p>



<pre> <code>s/\([^:]*\):.*:\(.*\)/<strong>user: \1 shell: \2</strong>/</code></pre>



<p>which produces the output (on my system)…</p>



<pre>user: nobody shell: /usr/bin/false
user: root shell: /bin/sh
user: daemon shell: /usr/bin/false
[...]</pre>



<p><code>sed</code> definitely requires some effort to learn, but it will quickly repay you if you ever do any text processing.</p>



<hr/>



<p><strong>If you like this post, you may be interested in my book</strong> <a href="https://leanpub.com/learnbashthehardway">Learn Bash the Hard Way</a></p>



<div><figure><a href="https://leanpub.com/learnbashthehardway"><img data-attachment-id="4192" data-permalink="https://zwischenzugs.com/2018/01/06/ten-things-i-wish-id-known-about-bash/hero/" data-orig-file="https://zwischenzugs.files.wordpress.com/2018/01/hero.png" data-orig-size="600,957" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hero" data-image-description="" data-image-caption="" data-medium-file="https://zwischenzugs.files.wordpress.com/2018/01/hero.png?w=188" data-large-file="https://zwischenzugs.files.wordpress.com/2018/01/hero.png?w=600" src="https://zwischenzugs.files.wordpress.com/2018/01/hero.png?w=188" alt="hero" srcset="https://zwischenzugs.files.wordpress.com/2018/01/hero.png?w=188 188w, https://zwischenzugs.files.wordpress.com/2018/01/hero.png?w=376 376w, https://zwischenzugs.files.wordpress.com/2018/01/hero.png?w=94 94w" sizes="(max-width: 188px) 100vw, 188px"/></a></figure></div>



<p>Preview available <a href="https://leanpub.com/learnbashthehardway/read_sample" target="_blank" rel="noreferrer noopener">here</a>.</p>



<hr/>



<h4 id="do-for-all-with-xargs">‘Do For All’ With <code>xargs</code></h4>



<p><code>xargs</code> is one of the most powerful and time-saving commands to use on the terminal. But it remains impenetrable to some (just ask Jim below), which is a shame, as with a little work it’s not that difficult to get to grips with. </p>



<figure><div>
<div><blockquote data-width="550" data-dnt="true"><p lang="en" dir="ltr">I have never figured out xargs after 35 years of Unix/Linux. Always picked a workaround instead.</p>— Jim Golab (@austwitnerd) <a href="https://twitter.com/austwitnerd/status/1475439688706138116?ref_src=twsrc%5Etfw">December 27, 2021</a></blockquote></div>
</div></figure>



<p>Before giving a real-world example, let’s go through it with a simple example. Create and move into a folder, creating three files:</p>



<pre>$ mkdir xargs_example &amp;&amp; cd xargs_example &amp;&amp; touch 1 2 3 &amp;&amp; ls
1 2 3</pre>



<p>Now, by default, xargs takes all the items passed in, and passes them as arguments to the given command:</p>



<pre>$ ls | xargs -t ls -l
ls -l 1 2 3
-rw-r--r--  1 imiell  staff  0  3 Jan 11:07 1
-rw-r--r--  1 imiell  staff  0  3 Jan 11:07 2
-rw-r--r--  1 imiell  staff  0  3 Jan 11:07 3</pre>



<p>(We are using the <code>-t</code> flag here for explanatory purposes, to show the commands that actually get run; generally, you don’t need it.)</p>



<p>The <code>-n</code> flag allows you to process a number of arguments at once. Try this to see what I mean:</p>



<pre>$ ls | xargs -n2 -t ls -l
ls -l 1 2
-rw-r--r--  1 imiell  staff  0  3 Jan 11:07 1
-rw-r--r--  1 imiell  staff  0  3 Jan 11:07 2
ls -l 3
-rw-r--r--  1 imiell  staff  0  3 Jan 11:07 3</pre>



<p>Most often, I use <code>-n1</code>, to run the command on each argument separately:</p>



<pre>$ ls | xargs -n1 -t ls -l
ls -l 1
-rw-r--r--  1 imiell  staff  0  3 Jan 11:07 1
ls -l 2
-rw-r--r--  1 imiell  staff  0  3 Jan 11:07 2
ls -l 3
-rw-r--r--  1 imiell  staff  0  3 Jan 11:07 3</pre>



<p>Here’s a real-world example I used recently:</p>



<pre>find . | \
  grep azurerm | \
  grep tf$ | \
  xargs -n1 dirname | \
  sed &#39;s/^.\///&#39;</pre>



<p>It:</p>



<ul><li>outputs all non-hidden files in or under the current working folder</li><li>of those files, selects only those files that have <code>azurerm</code> in their name</li><li>of those files, selects only those that end with <code>tf</code> (eg <code>./azurerm/somefile.tf</code>)</li><li>for each of those files, strips the full path of the filename of the pathname, resulting in the bare filename, preceded by a dot and forward slash (eg <code>./somefile.tf</code>)</li><li>for each of those files, removes the leading dot and forward slash, leaving the final bare filename (eg <code>somefile.tf</code>)</li></ul>



<p>But what if the argument doesn’t go at the end of the command given to <code>xargs</code>? In that case I use the <code>-I</code> flag, which allows you to replace the arguments that would be applied with a string of your choice. In this example I moved all files with ‘<code>Aug</code>‘ in them to a specific folder:</p>



<pre>$ ls | grep Aug | xargs -IXXX mv XXX aug_folder</pre>



<p>Be aware that naive use of <code>xargs</code> can lead to problems in scripts. What if your files have spaces in them, or even newlines? What if there are more arguments than can be handled by the command? I’m not going to cover these nuances here, but it’s well covered in this <a rel="noreferrer noopener" href="https://mywiki.wooledge.org/BashPitfalls#Using_xargs_without_-0" target="_blank">excellent resource</a> for more advanced bash usage.</p>



<p>I also regularly tidy up dodgy filenames with <code><a href="https://github.com/dharple/detox#overview" target="_blank" rel="noreferrer noopener">detox</a></code> on my servers.</p>



<h4 id="kill-all-processes">Kill All Processes</h4>



<p>Now you’ve seen <code>awk</code> and <code>xargs</code>, you can use these to quickly kill all processes that match. I used this quite often to kill off some pesky Virtual Machine processes that sometimes get left over in a corner case and prevent me from running up more:</p>



<pre>$ ps -ef | grep VBoxHeadless | awk &#39;{print $2}&#39; | xargs kill -9</pre>



<p>Again, you have to be careful with your <code>grep</code> here to ensure that you don’t accidentally kill</p>



<p>Also be careful with the <code>-9</code> argument to <code>kill</code>. You should only use that when it doesn’t respond to the default <code>kill</code> signal (<code>TERM</code> rather than <code>-9</code>‘s <code>KILL</code>), which allows the process to tidy up after itself if it chooses to.</p>



<h4 id="find-files-ending-with">Find Files Ending With…</h4>



<p>I often find myself looking for where files are on my system. The <code>mlocate</code> database is easily installable if you don’t have it, and invaluable for speeding up file lookups using the <code>fi</code>nd command. For example, I often need to find files across the filesystem that end with a specific suffix:</p>



<pre>$ sudo updatedb
$ sudo locate cfg | grep \.cfg$</pre>



<h4 id="process-files-with-sed-sh">Process Files With <code>sed | sh</code></h4>



<p>Often you want to run a command on a files extracted (or transformed) by a <code>sed</code> command, and with a little tweaking this is easily done by creating a shell script using <code>sed</code>, and then piping it to a shell. This example looks for https links at the start of lines in the <code>doc.md</code> file, and opens them up in a browser using the <code>open</code> command available on Macs: </p>



<pre id="grep-https-git-gitops-first-steps-readme-md-sed-s-h-open-1-g-sh">$ grep ^.https doc.md | sed &#39;s/^.(h[^])]).*/open \1/&#39; | sh</pre>



<p>There are alternate ways to do this with <code>xargs</code>, but I use this when I want to see what the resulting script will actually look like before running it (by leaving off the ‘<code>| sh</code>‘ at the end before running it in).</p>



<h4 id="give-me-all-the-output-with-2-1">Give Me All The Output With <code>2&gt;&amp;1</code></h4>



<p>Some commands separate their output into ‘standard’ output, and ‘error’ output. By default, <code>grep</code> only looks at the ‘standard’ output, and the ‘error’ output is ignored (because it goes to a separate ‘file handle’, but you don’t need to understand that right now).</p>



<p>For example, I was searching for a particular flag in the <code>openssl</code> command recently, and realised that <code>openssl</code>‘s help flag outputs to standard error by default. So adding <code>2&gt;&amp;1</code> (which redirects ‘error’ output to wherever the ‘standard’ output is pointed) ensures that the output is <code>grep</code>-able. </p>



<pre>$ openssl x509 -h 2&gt;&amp;1 | grep -i common </pre>



<p>If you want to redirect the output to a file, you need to get the ordering right:</p>



<pre>$ openssl x509 -h &gt; openssl_help.txt 2&gt;&amp;1.   # RIGHT!</pre>



<p>If the file redirect comes <em>after</em> the <code>2&gt;&amp;1</code>, then the standard error output still goes to the terminal.</p>



<pre>$ openssl x509 -h 2&gt;&amp;1 &gt; openssl_help.txt.   # WRONG!</pre>



<p>It’s best to think of this by considering that the command is read from left to right, so in the ‘right’ one, the interpreter ‘sees’:</p>



<ul><li>Redirect standard output to the file <code>openssl_help.txt</code>, then</li><li>Redirect standard error to wherever standard output is pointing </li></ul>



<p>and both outputs are pointed at the file. In the ‘wrong’ one:</p>



<ul><li>Redirect standard error to wherever standard output is pointing (which at the moment is the terminal), then</li><li>Redirect standard output to the file <code>openssl_help.txt</code></li></ul>



<p>and standard error is still pointed at the terminal, while standard output is redirected to the file <code>openssl_help.txt</code>.</p>



<h4 id="separate-lines-with-tr">Separate Lines With <code>tr</code></h4>



<p><code>tr</code> is a handy command used in a variety of contexts. Its job is to replace individual characters in a stream of output. While <code>sed</code> can be used for this purpose, <code>tr</code> has a couple of advantages over it in certain contexts:</p>



<ul><li>It’s easier to use than sed</li><li>It’s not line-oriented, so it ‘dumbly’ just replaces characters without concern for line separation</li></ul>



<p>Here’s an example I used it for recently, to get each item in my <code>PATH</code> variable shown, one per line.</p>



<pre>$ env | grep -w PATH | tr &#39;:&#39; &#39;\n&#39;
PATH=/usr/local/sbin
/usr/local/Caskroom/google-cloud-sdk/latest/google-cloud-sdk/bin
/usr/local/opt/coreutils/bin
/usr/local/opt/grep/libexec/gnubin</pre>



<p>Also, <code>tr</code> is often used to remove problematic characters from a stream of output. For example, to turn a set of lines into a single line, you can run:</p>



<pre>$ tr -d &#39;\n&#39;</pre>



<p>which removes all the ‘newlines’ from a stream.</p>



<h4 id="quick-infinite-loop">Quick Infinite Loop</h4>



<p>A pattern you very often need is an infinite loop. This is the way I usually get one on the command line.</p>



<pre>$ while true; do … ; done</pre>



<p>You can use the <code>break</code> keyword to escape this infinite loop.</p>



<h4 id="inline-files">Inline Files</h4>



<p>Creating files can be a faff, so it’s really useful to be able to just create a file inline on the command line.</p>



<p>You can do this with a ‘heredoc’ like this:</p>



<pre>$ cat &gt; afile &lt;&lt; SOMESTRING
The contents of the file are written here.
Just keep typing until you are done, then
end with the string you specified at the
end of the first line.
SOMESTRING</pre>



<p>That creates a file called <code>afile</code> with the contents between the first and last line.</p>



<p>You can even go one stage further, and substitute where you would formerly have used the filename using the <code>&lt;()</code> construct (see point 6 <a rel="noreferrer noopener" href="https://zwischenzugs.com/2018/01/06/ten-things-i-wish-id-known-about-bash/" target="_blank">here</a>).</p>



<pre>$ kubectl apply -f &lt;(cat &lt;&lt; EOF
…
EOF
)</pre>



<hr/>



<p><strong><em>If you like this, you might like one of my books:</em></strong></p>



<div><figure><a href="https://leanpub.com/b/learngitbashandterraformthehardway" target="_blank" rel="noreferrer noopener"><img data-attachment-id="4450" data-permalink="https://zwischenzugs.com/2018/08/06/anatomy-of-a-linux-dns-lookup-part-iv/learngitbashandterraformthehardway/" data-orig-file="https://zwischenzugs.files.wordpress.com/2018/08/learngitbashandterraformthehardway.png" data-orig-size="563,356" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="LearnGitBashandTerraformtheHardWay" data-image-description="" data-image-caption="" data-medium-file="https://zwischenzugs.files.wordpress.com/2018/08/learngitbashandterraformthehardway.png?w=300" data-large-file="https://zwischenzugs.files.wordpress.com/2018/08/learngitbashandterraformthehardway.png?w=563" src="https://zwischenzugs.files.wordpress.com/2018/08/learngitbashandterraformthehardway.png?w=357&amp;h=225" alt="LearnGitBashandTerraformtheHardWay" srcset="https://zwischenzugs.files.wordpress.com/2018/08/learngitbashandterraformthehardway.png?w=357&amp;h=225 357w, https://zwischenzugs.files.wordpress.com/2018/08/learngitbashandterraformthehardway.png?w=150&amp;h=95 150w, https://zwischenzugs.files.wordpress.com/2018/08/learngitbashandterraformthehardway.png?w=300&amp;h=190 300w, https://zwischenzugs.files.wordpress.com/2018/08/learngitbashandterraformthehardway.png 563w" sizes="(max-width: 357px) 100vw, 357px"/></a><figcaption>Buy in a bundle <a href="https://leanpub.com/b/learngitbashandterraformthehardway" target="_blank" rel="noreferrer noopener">here</a></figcaption></figure></div>



<hr/>



<p>If you enjoyed this, then please consider <a rel="noreferrer noopener" href="https://www.buymeacoffee.com/zwischenzugs" target="_blank">buying me a coffee</a> to encourage me to do more.</p>



<figure><a href="https://www.buymeacoffee.com/zwischenzugs"><img loading="lazy" data-attachment-id="5328" data-permalink="https://zwischenzugs.com/bmc-button/" data-orig-file="https://zwischenzugs.files.wordpress.com/2021/05/bmc-button.png" data-orig-size="1090,306" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="bmc-button" data-image-description="" data-image-caption="" data-medium-file="https://zwischenzugs.files.wordpress.com/2021/05/bmc-button.png?w=300" data-large-file="https://zwischenzugs.files.wordpress.com/2021/05/bmc-button.png?w=1024" src="https://zwischenzugs.files.wordpress.com/2021/05/bmc-button.png?w=1024" alt="" width="253" height="70" srcset="https://zwischenzugs.files.wordpress.com/2021/05/bmc-button.png?w=249 249w, https://zwischenzugs.files.wordpress.com/2021/05/bmc-button.png?w=499 499w, https://zwischenzugs.files.wordpress.com/2021/05/bmc-button.png?w=150 150w, https://zwischenzugs.files.wordpress.com/2021/05/bmc-button.png?w=300 300w" sizes="(max-width: 253px) 100vw, 253px"/></a></figure>
	</div></div>
  </body>
</html>
