<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://johnnysswlab.com/make-your-programs-run-faster-by-better-using-the-data-cache/">Original</a>
    <h1>Make your programs run faster by better using the data cache (2020)</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>We at <strong>Johnny’s Software Lab LLC</strong> are experts in performance. If performance is in any way concern in your software project, feel free to <a href="https://johnnysswlab.com/contact/">contact us</a>.</em></p><p>Developers are confronted all the times with the need to speed up their programs and the most obvious way is to come up with a fancy new algorithm with a lower <a href="https://en.wikipedia.org/wiki/Time_complexity" target="_blank" rel="noreferrer noopener">complexity</a>. Instead of O(n<sup>2</sup>) complexity our new algorithm has a lower complexity of O(n log n) and we can carry on happily to our next challenge. This is the best way to go, but often not the possible way. What now? Is there a way to squeeze out more performance out of our existing algorithm. Well actually there is. It’s called: low-level optimizations.</p><p>First a little bit about low-level optimizations. Low level optimizations are all about how to best exploit the particularities of the underlying architecture to get better performance. This is the first post in the line of posts that will deal with low-level optimizations. We will explore some ideas on how to better leverage memory cache subsystems.  For those who are already familiar with memory cache in modern day multiprocessor systems, feel free to <a href="#tips">skip</a> <em>Data Cache </em>chapter.</p><h2>Data Cache</h2><p>Computer systems in general consist of processor and memory. In modern day systems memory is hundreds of times slower than the processor, so processor often has to wait for memory to deliver the data. Clever hardware engineers have come up with a solution to offset the difference in speed: they add a small yet very fast memory called cache memory<sup><a href="#footnote_0_77" id="identifier_0_77" title="Modern day multiprocessor systems have complicated hierarchy of cache memories that is beyond the scope of this article">1</a></sup> that compensates for the difference in speed. When the processor wants to access data in the main memory, it first check if the data is already present in the cache memory, and if so, it gets its data very fast. Otherwise it will have to wait for the main memory to provide the data and this involves a lot of wasted processor cycles.</p><p>Normally cache memory is split into instruction cache memory and data cache memory. The purpose of the first is to speed up access to instructions and the purpose of the second is to speed up access to data used by instructions. In this article we are concerned only about how to speed up your program by better using the data cache memory.</p><h3>Why does the memory cache make the system run faster?</h3><p>So why does adding cache memory works? After all, the program can access any memory location at any time, therefore the data should never even be in the cache. In theory yes, but in practice accessing memory locations in random fashion is something real programs almost never do. </p><p>There are two principles that govern the behavior of the real world programs. The first is called <em>temporal locality </em>and it essentially means that if the processor is currently accessing a certain memory address, there is a high probability it will access the same memory address in the near future (think a counter in a loop). The second is called <em>spatial locality</em> and what it means is that if the processor is currently accessing a certain memory address, there is a high probability it will access neighboring memory addresses in the near future (think running through arrays). </p><h3>Data Cache Internal Organization</h3><p>Let’s now look at how cache memory looks from within. Cache memory is divided into cache lines and in modern processors each cache line can typically hold 64 bytes of data. One cache line corresponds to one 64 byte block in the main memory. Access to one byte within a 64 byte memory block means that the whole 64 byte memory block will be loaded into the cache line. When the block is fetched into the cache line, a mapping is created between the cache line and the original memory block. All accesses made by the processor to the same memory block will be served from the cache. When the cache line is not used for a long time or cache needs to make place for new data, the cache memory returns the modified block back to the main memory. Notice that this happens like magic and programs are not aware of it.</p><h2 id="tips">Tips for making your program run faster</h2><p>So, now when you have an overview of how data caches work, let’s move on to some actual tips on how to better exploit your data cache in order to make your programs run faster.</p><p>A note: in the following chapters, I will use the term <em>array</em> for both traditional C style arrays and C++ <code>std::vector</code><em> </em>and <code>std::array</code><em> </em>classes. Also, I will use the term <em>class</em> for both C style <code>struct </code>and C++ style <code>class</code><em>.</em></p><h3>Tip: When accessing data linearly, use vectors or arrays</h3><p>Linked lists, hash maps, dictionaries etc. are great data structures for many things, but they are not cache friendly. Iterating through such a data structure involves many cache misses. If performance is important, stick to arrays. If that is not possible, try to use more exotic data structures that combine cache efficiency of the arrays and flexibility of other data structures. <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Gap_buffer" target="_blank">Gap buffer</a> is an example of one such data structure. It is a combination of arrays and linked lists, and it allows excellent cache efficiency combined with ability to cheaply insert or remove elements. Another one is <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Judy_array" target="_blank">Judy array</a>, a tree implementation of a sparse array that is cheap to insert and remove elements and which is cache-friendly.</p><h3>Tip: Variables you access often together should be close to one-another in memory</h3><p>If there are several variables that are accessed together, they should be declared one after another. This increases the likelihood that the other variable will already be in the cache after the processor has accessed the first variable, thus avoiding cache misses.</p><p>Consider following class:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class free_memory_list {
  void* head;                 /// Pointer to the beginning of the list
  Statistics statistics;      /// Statistics about list usage
  int count;                  /// Number of elements in the list
  Allocator* base_allocator;  /// Pointer to the class used for memory 
                              /// allocation and deallocation
};</pre><p>This class implements a linked pointer list. If our program uses that class in such manner that it access variables <code>head </code>and <code>count</code> as a bundle, then they should be placed one after another in the class definition. In that case we increase the probability they will actually be in the same cache line.</p><h3>Tip: Use array of values instead of array of pointers</h3><p>First idea when comes to mind when speaking about arrays of classes or structs is to use pointers instead of values. This solution has many advantages over arrays of values, including run-time polymorphism and less memory usage in case of unallocated elements in the array, but with a performance penalty. Accessing the variable using a pointer invariably involves a cache miss. So for fast array access dispense with the pointers and go with values.</p><p>So now when we have array of classes as values, we have things going for us. Every time we access an element in the array, the cache prefetcher will get more elements that are close to the one we are currently accessing. If we are accessing elements of the array that are adjacent to one another, the data cache is maximally utilized.</p><h3>Tip: Optimize access to array of classes or structs</h3><p>If we are accessing elements of the array in random fashion, we can expect some cache misses. But we can have more or less misses depending on how we organized data in our class. Example:</p><p>Let’s assume we have a class <code>my_class</code> and let <code>sizeof(my_class)</code> equals 48. First element of the array starts at offset zero, second element of the array starts at offset 48, third element start at offset 96 and fourth element at offset 144. If our cache has cache lines size of 64 bytes, this means the first element will fit cache line zero (bytes 0-47), second element will be split between cache line zero and cache line one (bytes 48 – 63 go to cache line zero and bytes 64-95 to cache line one), third element will be split between cache line one and cache line two (bytes 96-127 go to cache line one and bytes 128-143 go to cache line two) and fourth element will fit the third cache line (144 – 191).</p><p>In case there is a random access to the elements of the class, having one element split between two cache lines can be bad from the perspective of data cache utilization. The cache memory will need two accesses to the main memory in order to read a single element. So how to avoid it? How to make each element fit the minimal number of cache lines? Here are the rules:</p><ul><li>Size of class needs to be a multiple of cache line size</li><li>Starting address of the array needs to be a multiple of cache line size</li></ul><p>To make the size of class a multiple of cache line size, we can either manually add padding or ask the compiler to do that for us, C++11 allows this with <code>alignas(64)</code> specifier. If this is not available GCC/CLANG compiler offers <code>__attribute__((aligned (64)))</code><em>.</em></p><p>To make the starting address of array a multiple of cache line size, we can either allocate a bit more memory than we need and then manually determine the start of the array so that the array is correctly aligned. Better solution is to ask the compiler and libraries to help us; we could use <code>posix_memalign</code> to allocate aligned memory on the heap, or <code>alignas(64)</code> and <code>__attribute__((aligned (64)))</code><em> </em>for aligned memory on stack and global memory. Here is an example on how to manually allocate array of classes using <code>posix_memalign</code>:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">my_class* array_of_my_class;
posix_memalign((void**)array_of_my_class, 64, SIZE * sizeof(my_class));
for (size_t i = 0; i &lt; SIZE; i++) {
    ::new (&amp;array_of_my_class[i]) my_class(i);
}</pre><p>The syntax looks a bit scary but it actually isn’t. We declare a pointer to <code>my_class</code> that we will use to hold the allocated array. Next we allocate memory for the array using <code>posix_memalign</code>. We specify the alignment parameter to 64. And finally, in loop, we call the constructor for each element of the array. Notice that we are using <code>::new </code>operator, this operator doesn’t do the memory allocation, instead it executes the constructor on the piece of memory provided as an argument.</p><h3>Tip: Access data in your matrices efficiently</h3><p>If your program works with matrices, you need to be aware how matrices are stored in memory. Matrices are by definition two dimensional, whereas memory is one dimensional. C and C++ compilers lay out matrices row by row. What this means is if we access an element of the matrix, several following elements in the same row will be available in the data cache as well.</p><p>This seems trivial, but it can have a profound effect on performance. Consider the simple matrix multiplication algorithm:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">void multiply_matrices(int in_matrix1[][N], int in_matrix2[][N], int result[][N]) 
{ 
    int i, j, k; 
    for (i = 0; i &lt; N; i++) { 
        for (j = 0; j &lt; N; j++) { 
            result[i][j] = 0; 
            for (k = 0; k &lt; N; k++) {
                result[i][j] += in_matrix1[i][k] *  
                             in_matrix2[k][j]; 
   
        } 
    } 
} </pre><pre><code>Courtesy of https://www.geeksforgeeks.org/c-program-multiply-two-matrices/</code></pre><p>It runs through <code>in_matrix1</code> row-wise and through <code>in_matrix2</code> column-wise, Now, <code>in_matrix1</code> works fine with regards to caching, but<code><code>in_matri</code>x2</code> is a disaster for the cache. Every access to next element in <code><code>in_matrix2</code></code> results in cache miss, and even though not easily visible, there is a large performance penalty to this simple solution.</p><p>And the fix? It’s super simple. Perform a transformation called <em>loop interchange</em>. Move the loop over <code>j</code> to the innermost position. The modified solution looks like this:</p><pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">void multiply_matrices(int in_matrix1[][N], int in_matrix2[][N], int result[][N]) 
{ 
    int i, j, k; 
    for (i = 0; i &lt; N; i++) { 
        for (j = 0; j &lt; N; j++) { 
            result[i][j] = 0; 
        }
        for (k = 0; k &lt; N; k++) {
            for (j = 0; j &lt; N; j++) {
                result[i][j] += in_matrix1[i][k] *  
                             in_matrix2[k][j]; 
   
        } 
    } 
} </pre><p>With this transformation, the access patterns of all three arrays have changed. We are running through <code>result</code> row-wise (originally it was a constant access), <code>in_matrix1</code> is now a constant access (originally it was row-wise) and we are running through <code>in_matrix2</code> row-wise (originally it was column-wise). Avoiding column-wise accesses has a tremendous impact on performance.</p><h3>Tip: Avoid padding in your classes and structs</h3><p>A small note about data alignment: for all primitive data types, if data type is 4 bytes in size, its starting address needs to be divisible by 4. If data type is 8 bytes in size, its starting address needs to be divisible by 8. If the variable of size N starts at address that is divisible by N, we say that the variable is <em>correctly aligned</em> or just <em>aligned</em>, otherwise it is <em>unaligned</em>. An alignment requirement is often made by hardware and it is enforced by the compiler as much as possible. Now moving on.</p><p>To make sure that data in your classes and structs are correctly aligned, C and C++ compilers can add padding: these are unused bytes added between members of your class to make sure all the members are correctly aligned. Consider following example:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class my_class {
  int my_int;
  double my_double;
  int my_second_int;
};</pre><p>One would expect that the size of this structure is <code>sizeof(int) + sizeof(double) + sizeof(int) = 16</code>. However, double needs to be eight bytes aligned, so after the member <code>my_int </code>compiler adds four bytes of padding so that <code>my_double</code> is correctly aligned. So we arrive to 20 bytes.</p><p>Additionally, in order to make the class data correctly aligned in arrays, the class takes the alignment requirements of the member with the highest alignment requirement. And the size of class needs to be a multiple of its alignment. In above example, ints have alignment requirements of 4 and doubles have an alignment requirement of 8, therefore our class needs to be 8 bytes aligned. And since the size of class needs to be multiple of its alignment, the compiler adds additional 4 bytes of padding at the end of the class, so the size of the class goes up from original 20 to 24 bytes.</p><p>How does the padding influence the cache efficiency? Let’s say our cache memory has a 64 byte cache line. In our example, only 2.7 instances of <code>my_class</code> can fit a cache line, as opposed to four instances that we would expect without padding. Also, padding bytes are loaded into the cache memory, but your program never uses them.</p><p>So, in order to better use the cache, sort the variables in the declaration of your classes by size from largest to smallest<sup><a href="#footnote_1_77" id="identifier_1_77" title="There are also other ways to avoid padding, but this is the simplest.">2</a></sup>. This guarantees that compiler will not insert any padding and that the program will better use the data cache. Here is the same class with slightly modified order of members that avoid  padding:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class my_class {
  double my_double;
  int my_int;
  int my_second_int;
};</pre><p>Size of this class is now 16 bytes and four instances fit a single cache line.</p><p>There is a tool you can use to explore the paddings in your classes called <em>pahole.</em> It needs to be built from sources since the version in the repositories doesn’t support C++11. Additionally, there is a visualization tool for Visual Studio Code called <em><a href="https://github.com/Viladoman/StructLayout" target="_blank" rel="noreferrer noopener">StuctLayout</a></em> (thanks Nikos Patsiouras for the tip!).</p><h3>Tip: Use smaller types if possible</h3><p>One of the ways to avoid padding in classes and therefore fit more data in the data cache is to use smaller types. Sometimes we declare four integers, but actually four short integers would suffice. Or maybe you have several bool variables in definition of your classes that you use to hold various flags. Instead of using bool, you could use chars or bool bit field, e.g:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class my_class {
public:
    bool my_bool1:1;
    bool my_bool2:1;
    bool my_bool3:1;
    bool my_bool4:1;
    int my_int:1;
};</pre><p>In the above example, each bool takes one bit. But the compiler will insert padding after <code>my_bool4</code> in order to correctly align <code>my_int</code>. This can be avoided by rearranging the order of members of <code>my_class</code>.</p><p>Another example: one 64 byte cache line fits eight integers or four long integers. If you have an array of 1M elements, integer version takes 4MB whereas long integer version takes 8MB. It is obvious that loading 8MB into the cache is slower than loading 4MB.</p><p>The tip especially applies to random memory accesses, which are seen when accessing hash maps and trees, or dereferencing pointers. This is the case where you can expect the largest speed improvements!</p><p>But beware! Processors internally work best with native word sizes (e.g. 8 bytes in modern 64 bit architectures, or less in architectures in embedded systems). Non-native word sizes might result in additional instructions generated, which can result in lower performance. Therefore always measure!</p><h3>Tip: Avoid heap allocation if stack could do</h3><p>Heap is inefficient for several reasons:</p><ul><li>Calls to <code>malloc</code> and <code>free</code> are slow</li><li>Access to those locations is indirect and it will result in cache misses more often</li></ul><p>On the other hand, top of the stack is almost always in cache and super fast to allocate and deallocate. There are several tricks you could use to speed things up. If your program needs to allocate variable sized array, consider allocating array on the stack instead of heap (GCC but also some other compilers support this). If your program needs to allocate a lot of small memory blocks using <code>malloc</code>, consider allocating one large block and then splitting it into smaller according to your needs. If your program allocates and deallocates many objects of the same type, consider caching memory blocks instead returning them with <code>free</code>, so they will be quickly to allocate if later needed.</p><h3>Tip: Use your data while still in cache</h3><p>Ideally we would like to load data from the memory to the cache exactly once, do some modification on it, and then return them back to the operating memory. If you need to fetch the same data two times, you are not using the cache optimally.</p><p>Example of finding a minimal and maximal element of the array.</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int * a = initialize_array(size);
int min = find_min(a, size);
int max = find_max(a, size);</pre><p>We have calls to two functions here, one that finds maximum and one that finds minimum in the array. Each function has its own loop, and inside the loop it iterates through the elements of the array. Assuming array is big enough, the elements of the array will be loaded into the cache two times.</p><p>Solution is simple: do all the work on the array inside one loop. Here is the corrected version:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int * a = initialize_array(size);
int min = a[0];
int max = a[0];
for (int i = 0; i &lt; size; i++) {
  min = std::min(a[i], min);
  max = std::max(a[i], max);
}</pre><p>Here we iterate through the array only once. Array data are loaded to the data cache only once, which utilizes the data cache much better.</p><h3>Tip: Avoid writing to memory if possible</h3><p>All writes to memory go through the data cache<sup><a href="#footnote_2_77" id="identifier_2_77" title="It is possible to write directly to memory without going through data cache, e.g. most implementations of memcpy do that. But it is very rare we want to do that in our programs">3</a></sup>. When a write is made, the cache marks that cache line as “dirty”. If a cache line is dirty, that means that it is different from the content of the memory and sooner or later its content will have to me written back to memory. This causes the slowdown. Check out these two algorithms:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">void sort_fast(int* a, int len) {
    for (int i = 0; i &lt; len; i++) {
        int min = a[i];
        int min_index = i;
        for (int j = i+1; j &lt; len; j++) {
            if (a[j] &lt; min) {
                min = a[j];
                min_index = j;
            }
        }
        std::swap(a[i], a[min_index]);
    }
}

void sort_slow(int* a, int len) {
    for (int i = 0; i &lt; len; i++) {
        for (int j = i+1; j &lt; len; j++) {
            if (a[j] &lt; a[i]) {
                std::swap(a[j], a[i]);
            }
        }
    }
}</pre><p>The above code shows two similar functions for sorting numbers. They both work the same way. They find the smallest element and put it at the position zero, then they find the next smallest element and put it at the position one etc.</p><p>Function <code>sort_slow</code> looks for the element of the array that is smaller than the <code>a[i]</code> and if found immediately swaps them. It continues to swap elements every time an element is found that is smaller then <code>a[i]</code>. Function <code>sort_fast</code> looks for the element of the array that is smaller than <code>a[i]</code> but it doesn’t do swapping, instead it keeps the new smallest element in a temporary variables <code>min</code> and <code>min_index</code> (compiler probably uses a register for these temporary variables). When the function finishes running through the array and has found the ultimate smallest element, only then it replaces the content of <code>a[i]</code> and <code>a[min_index]</code>. Function <code>sort_fast</code> is two times faster than <code>sort_slow</code> on my system.</p><h3>Tip: Align your data properly</h3><p>Your variables need to be aligned properly. This makes sure that the whole variable is located in a single cache line, as opposed to being split between two cache lines. If your system doesn’t support access to misaligned variables, things could get very slow because your operating system might emulate the access to misaligned memory addresses.</p><p>Most of the time compiler makes sure the data is aligned properly, but easygoing developers might create places with misaligned memory accesses. This often happens when converting pointers from one type to another. Example of a bad alignment:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">unsigned char serialized_data[1024];
read_data(serialized_data);
int* header_pointer = (int*) (serialized_data + 3);
int header = *header_pointer; </pre><p>In this example, we convert char pointer to int pointer thus making <code>header_pointer</code> misaligned. Dereferencing <code>header_pointer</code> creates a misaligned memory access. On some architecture the program would crash, on others it will slow down. A corrected example:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">unsigned char serialized_data[1024];
read_data(serialized_data);
int* header_pointer = (int*) (serialized_data + 3);
int header;
memcpy(&amp;header, header_pointer, sizeof(int));
</pre><p>Here, we use <code>memcpy</code> to copy the value from the input array to header variable. Function <code>memcpy</code> doesn’t need a proper alignment and this code better exploits the data cache and it is portable.</p><h3 id="prefetching">Tip: Use software prefetching</h3><p>If your algorithm does not access its data one by one, but instead jumps around the memory in random fashion, you can use software prefetching to tell the processor which data you will be accessing so it has time to load them into cache before they are needed. For example, GCC and CLANG compilers offer <em>__builtin_prefetch</em> builtin that allows software prefetching. Here we give an example of binary search algorithm:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int binarySearch(int *array, int number_of_elements, int key) {
    int low = 0, high = number_of_elements-1, mid;
    while(low &lt;= high) {
        mid = (low + high)/2;
#ifdef DO_PREFETCH
        // low path
        __builtin_prefetch (&amp;array[(mid + 1 + high)/2], 0, 1);
        // high path
        __builtin_prefetch (&amp;array[(low + mid - 1)/2], 0, 1);
#endif

        if(array[mid] &lt; key)
            low = mid + 1; 
        else if(array[mid] == key)
             return mid;
        else if(array[mid] &gt; key)
             high = mid-1;
        }
}
</pre><pre><code>Courtesy: Low-Level Programming: C, Assembly, and Program Execution on Intel® 64 Architecture, Igor Zhirkov</code></pre><p>Binary search algorithm runs through the array non-sequentially and hardware cache prefetcher faces with a lot of cache misses. Int the binary search algorithm from above, we prefetch both new <code>low </code>and new <code>high </code>before we figured out which of those two values we will need. And when we actually need the data, it is already present in the cache.</p><p>The downside in this particular algorithm is that we are fetching two values, and one of those values we will never be used. This can have effect on the performance since some cache lines now need to leave the cache to make place for unused value; if another program is running on another core that uses the same cache, it could lead to performance degradation for both programs.</p><p>We talk in great length about how to efficiently use data prefetching in the <a href="https://johnnysswlab.com/use-explicit-data-prefetching-to-faster-process-your-data-structure/" target="_blank" rel="noreferrer noopener">post about explicit prefetching and nano threads</a>.</p><p><i>Like what you are reading? Follow us on <a rel="noreferrer noopener" href="https://www.linkedin.com/company/johnysswlab" target="_blank">LinkedIn </a>, <a rel="noreferrer noopener" href="https://twitter.com/johnnysswlab" target="_blank">Twitter</a> or <a rel="noreferrer noopener" href="https://mastodon.online/@johnnysswlab" target="_blank">Mastodon</a> and get notified as soon as new content becomes available.</i></p><h2>Experiments</h2><p>Let’s see how these tips help us on our real-world problems. For testing we are using a regular general purpose system AMD A8-4500M CPU with four cores, 16KB of L1 data cache per core and 2MB of L2 data cache per core (two cores share 2MB of L2 data cache). This system has 12GB of memory.</p><h3>Matrix multiplication</h3><p>There is an excellent but a lengthy article written by Ulrich Drepper on cache optimizations available <a rel="noreferrer noopener" href="https://lwn.net/Articles/255364/" target="_blank">here</a>. He starts with naïve version of matrix multiplication algorithm and refines it until he comes to a optimized version that is almost ten times faster. In his experiment, he used a 1000×1000 matrix consisting of doubles. First optimization he did was transposing the matrix before multiplication, this alone has brought performance increase of 76.6%! A number worth noticing.</p><h3 id="binarysearch">Binary Search Algorithm with Software Prefetch</h3><p>We implemented a binary search algorithm that uses software prefetching from the previous chapter and we used to test it how the memory cache subsystem works when the programmer explicitly uses prefetching. The source code of the program we are using to test is available at <a rel="noreferrer noopener" href="https://github.com/ibogosavljevic/johnysswlab" target="_blank">github</a>. To run it, simply execute <code>make binary_search_runtimes</code> and <code>make binary_search_cache_misses</code>.</p><p>We generated a sorted random integer array of length 10K, 100K, 1M, 10M and 100M elements that we use to perform binary search on. We call this <code>input_array</code> and the length of the array is our <em>working set</em>. Next, we generate another array that holds the indexes we use for searching. We call this <code>index_array</code>. We use several different approaches to generate the indexes for the <code>index_array</code>. We use a random approach to generate elements for the <code>index_array</code>, but we also use a non-random stride based approach. If the stride is N, first element of the <code>index_array</code> is 0, seconds is N, third is 2N etc, until we reach the end of the array and wrap around.</p><p>So calls to binary search looks like this:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""> for (int i = 0; i &lt; len; i++) {
    binarySearch(inputArray, len, inputArray[indexArray[i]]);
 }</pre><p>We tested for both random <code>index_array</code> and <code>index_array</code> with strides 1, 100 and 10K. We fixed the size of the <code>index_array</code> at 10M which means we are performing 10M searches. For <code>index_array</code> with random access, these are the results:</p><figure><table><tbody><tr><td>Working Set</td><td>Prefetching Off</td><td>Prefetching On</td><td>Speed Difference</td></tr><tr><td>10K</td><td>1673ms</td><td>1777ms</td><td>-6.2%</td></tr><tr><td>100K</td><td>2478ms</td><td>2426ms</td><td>+2.1%</td></tr><tr><td>1M</td><td>4519ms</td><td>3996ms</td><td>+11.6%</td></tr><tr><td>10M</td><td>8804ms</td><td>7096ms</td><td>+19.4%</td></tr><tr><td>100M</td><td>14970ms</td><td>11685ms</td><td>+21.9%</td></tr></tbody></table><figcaption>Binary Search Running Time (ms) vs Working Set Size, Random Access</figcaption></figure><p>For random access, software prefetching is slower only for the smallest data set of 10K. As the working set increases, so does the algorithm with software prefetching becomes faster that the common algorithm. Speed difference is about 20% for large working sets, and it will probably remain that way even if the working set size increases further.</p><p>What happens if we are not accessing random elements, but instead we are accessing elements with constant stride? Since this is a synthetic test, we are looking for an element whose position we know in advance. E.g. if the stride is 100, we know the position of the first element which is 0 and we are looking for value <code>input_array[0]</code>. In the next iteration we are looking for an element <code>input_array[100]</code> etc. How does the cache behave in that case? Here are the results:</p><figure><table><tbody><tr><td>Working Set</td><td>Prefetching Off</td><td>Prefetching On</td><td>Speed Difference</td></tr><tr><td>10K</td><td>977ms</td><td>1168ms</td><td>-19.5%</td></tr><tr><td>100K</td><td>1122ms</td><td>1380ms</td><td>-23.0%</td></tr><tr><td>1M</td><td>1367ms</td><td>1623ms</td><td>-18.7%</td></tr><tr><td>10M</td><td>1610ms</td><td>1892ms</td><td>-17.5%</td></tr><tr><td>100M</td><td>1813ms</td><td>2171ms</td><td>-19.7%</td></tr></tbody></table><figcaption>Binary Search Running Time (ms) vs Working Set Size, Stride = 1</figcaption></figure><figure><table><tbody><tr><td>Working Set</td><td>Prefetching Off</td><td>Prefetching On</td><td>Speed Difference</td></tr><tr><td>10K</td><td>1112ms</td><td>1418ms</td><td>-27.5%</td></tr><tr><td>100K</td><td>1766ms</td><td>1942ms</td><td>-9.7%</td></tr><tr><td>1M</td><td>3018ms</td><td>2792ms</td><td>+7.5%</td></tr><tr><td>10M</td><td>3236ms</td><td>3019ms</td><td>+6.7%</td></tr><tr><td>100M</td><td>3356ms</td><td>3182ms</td><td>+5.2%</td></tr></tbody></table><figcaption>Binary Search Running Time (ms) vs Working Set Size, Stride = 100</figcaption></figure><figure><table><tbody><tr><td>Working Set</td><td>Prefetching Off</td><td>Prefetching On</td><td>Speed Difference</td></tr><tr><td>10K</td><td>760ms</td><td>984ms</td><td>-29.5%</td></tr><tr><td>100K</td><td>1049ms</td><td>1508ms</td><td>-43.8%</td></tr><tr><td>1M</td><td>2739ms</td><td>2640ms</td><td>+3.6%</td></tr><tr><td>10M</td><td>4402ms</td><td>7490ms</td><td>-70.1%</td></tr><tr><td>100M</td><td>10395ms</td><td>8251ms</td><td>-20.6%</td></tr></tbody></table><figcaption>Binary Search Running Time (ms) vs Working Set Size, Stride = 10K</figcaption></figure><p>For stride = 1, the common algorithm beats the software prefetching algorithm every time. This doesn’t surprise however because all the data from the previous iteration is already in cache, and since the stride is 1, the current iteration has almost all the data in cache.</p><p>For stride = 100, as expected, for small working set the general algorithm beats the software prefetching algorithm. But as the working set increases, the software prefetching algorithm takes over and is on average 6% faster. Why is in this case faster on average 6% compared to 20% in completely random case? If our working set is 10M, on average the algorithm finishes in around 20 steps. Out of these 20 steps, data will already be in the cache 14 of the steps from the previous search. So, only in the last 6 steps will software prefetching make sense.</p><p>For stride = 10K we see a very weird behavior that the general algorithm is faster than the software prefetching algorithm. Why? The answer is that with a 10K stride we reduce the working set size by 10K. For the input working set of 10M, this reduces it to a working set to only 10K. So even for the largest set size (10M) the general purpose algorithm is faster, with almost the same percentage as general purpose algorithm with random indexes and working set 10K.</p><p>How about cache performance? What kind of impact does prefetching has on cache performance. Let us compare results of perf<sup><a href="#footnote_3_77" id="identifier_3_77" title="Perf is a Linux’ profiler, an excellent tool I will write about">4</a></sup> command with and without prefetching:</p><figure><table><tbody><tr><td>Parameter</td><td>Prefetching Off</td><td>Prefetching On</td><td>Difference</td><td></td></tr><tr><td>Cache References</td><td>409M</td><td>649M</td><td>+58.7%</td><td></td></tr><tr><td>Cache Misses</td><td>155M</td><td>254M</td><td>+63.9%</td><td></td></tr><tr><td>Cycles</td><td>31481M</td><td>25648M</td><td>-18.5%</td><td></td></tr><tr><td>Instructions</td><td>6659M</td><td>10647M</td><td>+59.9%</td><td></td></tr></tbody></table><figcaption>Cache Performance, Cycles and Instructions Data for Two Versions of Binary Search</figcaption></figure><p>The results are interesting. The software prefetching version has more cache references, more cache misses and more instructions executed compared to a regular version. What does this mean is that the software prefetching version actually does more work. But it is nevertheless faster, because it does more work in smaller number of cycles. Modern processor can execute more than one instruction per cycle, but this number falls down if the processor needs to wait for the data to be fetched from the main memory. If we count the number of instructions per cycle, it is 0.42 for software prefetching version and 0.21 for regular version. This is a huge difference.</p><h3 id="linkedlist">Cache Friendly Linked List</h3><p>Seconds experiment is a cache-friendly linked list (these lists are also called <em>unrolled linked lists</em>). Regular linked lists are very cache unfriendly, iterating through such a structure results in many cache misses.  How can we do better?</p><p>Regular linked list typically consists of linked list nodes, and each node holds a value and pointer to the next node. In our implementation, linked list node can hold more than one value and the number of values is specified  as a template parameter to the <code>linked_list</code> class. We tested for linked list nodes that can hold 1, 2, 4 and 8 values, with the expectation that the bigger the number of values in the node, there will be less cache misses. The source code of the program we are using to test is available at <a rel="noreferrer noopener" href="https://github.com/ibogosavljevic/johnysswlab" target="_blank">github</a>. To run it, simply execute <code>make linked_list_runtimes</code> and <code>make linked_list_cache_misses</code>.</p><p>The only thing we are interested in testing is iterating through the list. For insertion, removal etc. our implementation is faster than simple linked list as well,  but most of the performance improvements comes from having less memory allocations, not better usage of data cache.</p><p>Here is the source code of a single list node:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">    class linked_list_node {
    public:
        char used_elems[count];
        linked_list_node* next;
        char values[count * sizeof(Type)];
        ...
};</pre><p>Template constant <code>count</code> holds the number of values in a single list node and template constant <code>Type</code> is the type we are keeping in the node. Since a node has more than one value, we mark which values are actually used in array <code>used_elems</code>. Notice we are using chars to hold used values, not bools. On my machine bool takes four bytes, whereas char takes one byte. This choice does increase performance of the list, since more other data from the node will be prefetched in the cache.</p><p>Now let’s get down to measurements.<sup><a href="#footnote_4_77" id="identifier_4_77" title="You can execute the tests on your system as well, just download the source code and run make linked_list_runtimes to execute the tests.">5</a></sup> Bellow chart measures time needed to iterate through the linked list<sup><a href="#footnote_5_77" id="identifier_5_77" title="We perform 30 iterations and then measure the average">6</a></sup>, depending on the number of values in node (1, 2, 4 and 8) and type size the linked list is holding.</p>   <p>The results look excellent! For smallest type size, iterating through a linked list with two values in node takes 43% less time than iterating through a linked list with one value and this number remains roughly the same for all type sizes.</p><p>Also note that the bigger the type size in the list, the more sense does it make to have more values in a single linked list node. For 4 bytes type size difference between node with two values and node with four values is small, but for 32 bytes type size this difference is significant.</p><p>What about cache performance? What is the number of memory reads<sup><a href="#footnote_6_77" id="identifier_6_77" title="Memory reads and data cache reads are the same thing because all reads go through the cache">7</a></sup> and data cache miss rate for our test? First lets measure how many memory reads<sup><a href="#footnote_7_77" id="identifier_7_77" title="We measure only memory data reads since iterating through a list doesn’t involve memory writes">8</a></sup> does our program make:</p>   <p>As you can see, the more values stored in a single node, there will be less memory reads altogether.  This is to be expected since there is less pointer arithmetic involved. Please note that number of memory reads in our case doesn’t depend on the type size.</p><p>What about cache misses? We used the tool <a rel="noreferrer noopener" href="https://valgrind.org/docs/manual/cg-manual.html" target="_blank">cachegrind </a>to measure cache miss rates<sup><a href="#footnote_8_77" id="identifier_8_77" title="In our example there were almost no LL cache misses so we measured only L1 cache misses">9</a></sup>. It can give information about cache misses per function or per line.  Here are the results:</p>   <p>General trend is: if there are more values in a linked list note, there will be less cache misses.  For smallest type, cache rate miss is 3% for 8 values in node compared to 10% for 1 value in node. Similar ratio is observed also for larger types.</p><p>The other trend: the bigger the type size in a linked list node, the bigger the cache miss rate. For 4 bytes type size cache miss rate is 10% in worst case and 3% in best case. For 32 bytes type size cache miss rate is 20% in worst case and 13.6% in best case. Nothing unexpected. When we are accessing a first value in the node, the cache prefetcher will load values in surrounding memory addresses so when we need them later, they will already be in the cache. If the type is bigger there is less chance that the prefetcher will load useful data, so this is the reason for additional cache misses.</p><h2>Final Words</h2><p>So what’s the conclusion? There is definitely something interesting to say about data cache optimizations, both in our experiments and generally.</p><h3>Final Words on Experiments</h3><p>So what is the conclusion? Let’s talk first about our experiments: all three experiments have shown that careful programming with focus on better using data cache will achieve performance gains. Optimized matrix multiplication has an excellent performance gains compared to the non-optimized version, but apart from matrices, it is rarely the case that we can do a simple manipulation on the data structure to make our structure more cache-friendly. And in my professional experience, I have rarely seen matrices used as data structures.</p><p>Second experiment was about software prefetching. We indeed see performance increase on binary search with the software prefetching, but performance increase is only relevant for working sets that do not fit the data cache. Please note that software prefetching comes with a price: our system executes more instructions and loads more data into cache which could in some cases lead to worse performance elsewhere<sup><a href="#footnote_9_77" id="identifier_9_77" title="Example if another program is running on the core that shares the same L1 cache">10</a></sup>. Good thing about software prefetching is that it is easy to implement and it can be used to speed up iterating  through all kinds of structures: linked lists, trees, heaps etc. Yet, careful measurement is needed to make sure that performance gains are worth it.</p><p>And our third experiment  was about cache friendly linked lists. Again we see with a nice speed improvements. Improvements come from several sources: less memory allocation, smaller data cache miss rate and less instructions needed for pointer arithmetic. The only drawback are more complicated implementation and an increased memory consumption since it might happen that a single node is not optimally filled. But generally, I think these drawbacks are worth the effort.</p><h3>Final Words on Data Cache Optimizations</h3><p>As our experiments have shown, and from my earlier experience, the optimizations indeed bring the performance speeds, and there are numerous applications where this is needed. Performance increase depend on many factors and can range from few percent to 100% or even more.</p><p>However, some of the recommendation made here will make your program more difficult to understand and more difficult to debug. And developers have been thought to avoid exactly this, for good reasons. In order to maximally benefit from these optimizations, you will need to carefully profile your program to find the bottlenecks and focus on speeding up those, instead of applying these tips everywhere in your code. Keep your interfaces clean and avoid intermodule dependencies first, then replacing your slow code with a faster one will be simple and you can enjoy the performance increase without  sacrificing maintainability.</p><p><i>Like what you are reading? Follow us on <a rel="noreferrer noopener" href="https://www.linkedin.com/company/johnysswlab" target="_blank">LinkedIn </a>, <a rel="noreferrer noopener" href="https://twitter.com/johnnysswlab" target="_blank">Twitter</a> or <a rel="noreferrer noopener" href="https://mastodon.online/@johnnysswlab" target="_blank">Mastodon</a> and get notified as soon as new content becomes available.</i></p><p>Featured image courtesy of: <a rel="noreferrer noopener" href="https://www.androidauthority.com/what-is-cache-memory-gary-explains-681747/" target="_blank">https://www.androidauthority.com/what-is-cache-memory-gary-explains-681747/</a></p><h2>Further Read</h2><p><a rel="noreferrer noopener" href="https://lwn.net/Articles/255364/" target="_blank">Ulrich Drepper “What every programmer should know about memory”</a></p><p><a rel="noreferrer noopener" href="https://www.androidauthority.com/what-is-cache-memory-gary-explains-681747/" target="_blank">What is cache memory – Gary explains</a></p><p><a href="https://www.agner.org/optimize/?e=0#0" target="_blank" rel="noreferrer noopener">Agner.org – Software Optimization Resources</a></p></div></div>
  </body>
</html>
