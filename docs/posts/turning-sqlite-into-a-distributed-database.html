<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://univalence.me/posts/mvsqlite">Original</a>
    <h1>Turning SQLite into a Distributed Database</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>mvSQLite is the <a href="https://github.com/losfair/mvsqlite" target="_blank">open-source</a>, SQLite-compatible distributed database. We decoupled SQLite&#39;s storage layer onto FoundationDB to offer massive yet &#34;bottomless&#34; scalability, point-in-time reads, and the strictest level of consistency.</p>
<h2>On the surface</h2>
<p>There are already so many nice &#34;multi-machine&#34; SQLite flavors: rqlite, dqlite, and Litestream. However I believe what mvSQLite offers is unique: it is not just <em>replicated</em> but really <em>distributed</em>, it offers not only read but also write scalability, it provides the strictest consistency, and it is a drop-in addition to SQLite.</p>
<h3>Read and write scalability</h3>
<p>The underlying technology of mvSQLite, FoundationDB, provides a solid <em>foundation</em> for scalability. FoundationDB is known to scale linearly at least <a href="https://apple.github.io/foundationdb/known-limitations.html#cluster-size" target="_blank">until 500 cores</a>. However, there is still something mvSQLite needs to do, especially on the write side.</p>
<p><strong>Concurrent writes</strong>. Read scalability is trivial: you just add more machines to the cluster. Scaling writes without breaking serializability is the hard part though, and SQLite itself has not supported concurrent writes until <a href="https://www.sqlite.org/cgi/src/doc/begin-concurrent/doc/begin_concurrent.md" target="_blank">very recently</a>. Correctly implementing concurrent writes in a distributed system is even more difficult, and it looks like an interesting problem for us to solve!</p>
<p>In each transaction, SQLite reads a set of pages, and writes another set of pages. There is the following observation on serializability:</p>
<p><strong>The decision to write to a page is correct under the causal assumption that none of the pages read in the same transaction have changed before the write.</strong></p>
<p>Therefore, if the concurrent execution of two or more transactions do not break each other&#39;s causal assumptions, they don&#39;t conflict and can be committed together. From a transaction&#39;s perspective, it&#39;s always serializable and linearizable. This check is implemented in mvSQLite by checking at commit time the versions of the pages in the read set: if any version is larger than the read version of the current transaction, the commit is aborted and a conflict error is returned.</p>
<p>There are caveats though. For example, SQLite always modifies the “<a href="https://www.sqlite.org/fileformat.html" target="_blank">file change counter</a>” field in the first page after each transaction. If this change is persisted, the entire concurrent-write mechanism would be useless - any two concurrent transactions on the same database will conflict. mvSQLite works around the problem by overwriting the change counter with zero in the persisted version, and maintaining a per-connection virtual change counter at the client side.</p>
<p><strong>Automatic sharding</strong>. Other systems with synchronous replication like rqlite and dqlite are replicated systems, not fully distributed ones, because they replicate the entire database with a single consensus group. This works when you have 3 or 5 machines in the cluster and a single writer, but does not scale well further. In the mvSQLite case though, FoundationDB manages sharding automatically and safely, and <a href="https://apple.github.io/foundationdb/performance.html" target="_blank">scales well</a> to hundreds of CPU cores.</p>
<h3>Stricter than ACID</h3>
<p>SQLite is an ACID database, and mvSQLite actually provides stricter guarantees than ACID!</p>
<p><strong>External consistency</strong>. mvSQLite is <em>externally consistent</em>, which is stricter than strong consistency, and is the strictest consistency level for transaction-processing systems.</p>
<p><strong>Synchronous replication</strong>. FoundationDB, does synchronous replication and ensures durability. When the SQLite API tells you a transaction is committed, it is. Application crashes, power failures, or losing <code>replication_factor - 1</code> storage servers in the cluster do not cause data loss.</p>
<p>By the way, you still have the option to do global eventually-consistent low-latency reads when needed - FoundationDB supports asynchronous replication (DR) to different regions.</p>
<h3>Point-in-time reads</h3>
<p>As its name stands for, mvSQLite is a database with MVCC (multi-version concurrency control) support. It&#39;s not just the traditional type of MVCC where concurrent transactions see their own snapshots - you can actually open a snapshot of the database at any time in the past and read from it. So something like a <code>DROP TABLE</code> won&#39;t cause data loss any more, and the app can integrate with the mechanism to provide high-level versioning features.</p>
<h3>Drop-in addition</h3>
<p>Usually no changes to your SQLite-based application is needed to get it working with mvSQLite. Two integration methods are available:</p>
<ul>
<li><code>LD_PRELOAD</code>. If your application is dynamically linked to <code>libsqlite3.so</code>, this method is recommended because it is more efficient and has no OS-specific dependency. Set the <code>LD_PRELOAD=libmvsqlite_preload.so</code> environment variable and it should &#34;just work&#34;.</li>
<li>Work-in-progress: <a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace" target="_blank">FUSE</a> (Filesystem in USErspace). This method is more universal and works with statically linked SQLite3 too.</li>
</ul>
<p>However, if the application attempts to operate on the database in an unsupported way (e.g. enabling WAL by setting <code>pragma journal_mode = wal</code>, or reading/writing the database outside SQLite), mvSQLite will get confused and refuse to work. Fix the application if that&#39;s the case!</p>
<h2>Inside the system</h2>
<p>This section mostly contains answers to commonly-asked questions about mvSQLite.</p>
<h3>Not just FoundationDB</h3>
<p>From a first glance it might seem easy to glue a transactional block layer on top of FoundationDB: just map SQLite transactions onto FDB transactions, map SQLite VFS reads/writes to FDB ones, and you&#39;re done?</p>
<p>Well, you can do it, but the resulting system might not be very useful due to a few important limits of FoundationDB:</p>
<ul>
<li>The longest transaction duration is 5 seconds.</li>
<li>The size (keys read and written + values written) of a transaction must not exceed 10MB.</li>
<li>All written data is kept in memory before commit.</li>
</ul>
<p>Additionally, there is no way to read the version of the database from some time in the past, so we don&#39;t have the primitives to support point-in-time reads.</p>
<h3>No local journals</h3>
<p>SQLite was designed to run on real block devices. These devices do not support transactional writes across pages, so the application needs to come up with its own way to perform <a href="https://www.sqlite.org/atomiccommit.html" target="_blank">atomic commits</a>. SQLite, along with most other databases, achieves that with journaling. SQLite supports two journal modes: the rollback journal and the WAL (write-ahead log).</p>
<p>mvSQLite does not rely on SQLite&#39;s own atomic commit mechanisms to ensure ACID properties. Instead, it treats the VFS “unlock” operation as the “transaction visibility fence” and performs atomic commit with primitives provided by FoundationDB. There&#39;s still a WAL all the way down on FDB&#39;s storage servers, but that&#39;s no longer something the SQLite layer needs to take care of.</p>
<h3>Efficient data encoding</h3>
<p>mvSQLite minimizes the overhead of storing every version of a page by using delta encoding. When a small portion of a page is changed, only the difference between the new and old versions are stored.</p>
<p>Maybe you feel that there are a lot of details uncovered in this post - and I think so too! I&#39;m working on another blog post that introduces the deeper internals of mvSQLite. Stay tuned by subscribing to my <a href="https://univalence.me/api/feed" target="_blank">RSS feed</a>.</p>
<h2>Worst case with beta software</h2>
<p>Like with anything before 1.0, I need to put a big warning here: <strong>mvSQLite is beta software and contains bugs</strong>. It&#39;s normal to have concern about data reliability: although no data corruption bugs have yet been observed in the current version, what if under some special cases a rare code path is triggered and corrupts some random data? Let&#39;s think about the worst case: What if there is a bug in mvSQLite that somehow causes a <code>clear_range(&#39;&#39;, &#39;\\xff&#39;)</code> to be executed and you lose all the data in the entire cluster?</p>
<p>That&#39;s where FoundationDB&#39;s backup system comes to be useful. You can do <a href="https://apple.github.io/foundationdb/backups.html" target="_blank">continuous, real-time backup</a> to an external object storage service such as S3 and recover to any point in the past. No data is lost after a full range-clear. Even if all disks in the FDB cluster get broken at the same time, you only lose a few seconds of data. And with proper permissions on the S3 access keys, nobody can delete already backed up data even if they have the keys!</p>

</div></div></div>
  </body>
</html>
