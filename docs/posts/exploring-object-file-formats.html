<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maskray.me/blog/2024-01-14-exploring-object-file-formats">Original</a>
    <h1>Exploring Object File Formats</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      
        <p>My journey with the LLVM project began with a deep dive into the
world of lld and binary utilities. Countless hours were spent unraveling
the intricacies of object file formats and shaping LLVM&#39;s relevant
components. Though my interests have since broadened, object file
formats remain a personal fascination, often drawing me into discussions
around potential changes within LLVM.</p>
<p>This article compares several prominent object file formats, drawing
upon my experience and insights.</p>
<p>At the heart of each format lies the representation of essential
components like symbols, sections, and relocations. For each control
structure, We&#39;ll begin with ELF, a widely used format, before venturing
into the landscapes of other notable formats.</p>
<h2 id="history-of-object-file-formats">History of object file
formats</h2>
<p>Before delving into the technical side, I will share some notes about
my archaeological journey.</p>
<h3 id="a.out">a.out</h3>
<p>The a.out format was designed for PDP-11 and appeared on the first
version of Unix. The quantities were 16-bit, but can be naturally
extended to 32-bit or 64-bit.</p>
<p>In Proceedings of the Summer 1990 USENIX Conference, <em>ELF: An
Object File to Mitigate Mischievous Misoneism</em> by James Q. Arnold
provided some description.</p>
<blockquote>
<p>For 32-bit machines, the a.out format was extended in several ways.
Most obviously, 16-bit quantities were enlarged to 32-bit values. The
symbol table changed to allow names of unlimited length. Relocation
entries also changed significantly. Larger programs and different
relocation conventions made it necessary to associate a relocation entry
with an explicit address, instead of relying on the implicit
correspondence between program sections and relocation records.</p>
</blockquote>
<p>Many Unix and Unix-like operating systems, including SunOS, HP-UX,
BSD, and Linux, used a.out before switching to ELF.</p>
<p>The most noticeable extension is dynamic shared library support.
(This feature is distinct from static shared library, where each shared
library needs a fixed address in the address space.) There are two
flavors:</p>
<ul>
<li>In 1988, SunOS 4.0 was released with an extended a.out binary format
with dynamic shared library support.</li>
<li>In 1993, on NetBSD, <a target="_blank" rel="noopener" href="https://github.com/NetBSD/src/commit/97ca10e37476fb84a20a8ec4b0be3188db703670">https://github.com/NetBSD/src/commit/97ca10e37476fb84a20a8ec4b0be3188db703670</a>
(<code>A linker supporting shared libraries.</code>) and <a target="_blank" rel="noopener" href="https://github.com/NetBSD/src/commit/3d68d0acaed0a32f929b2c174146c62940005a18">https://github.com/NetBSD/src/commit/3d68d0acaed0a32f929b2c174146c62940005a18</a>
(<code>A linker supporting shared libraries (run-time part).</code>)
added shared library support similar to the SunOS scheme.</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://man.freebsd.org/cgi/man.cgi?a.out(5)">FreeBSD
a.out(5)</a> provides a nice description.</p>
<p>If you follow recent years&#39; Linux kernel news, there were some
discussions when Linux eventually <a target="_blank" rel="noopener" href="https://git.kernel.org/linus/987f20a9dcce3989e48d87cff3952c095c994445">removed
a.out support</a> in 2022.</p>
<h3 id="coff">COFF</h3>
<p>a.out supports three fixed loadable sections TEXT, DATA, and BSS,
which is too restrictive. COFF introduces custom section support and
allows up to 32767 sections. The ELF paper contains some remarks:</p>
<blockquote>
<p>Common Object File Format (COFF), was designed primarily to support
electronic switching systems (the telephone network). Its distinguishing
features were multiple sections (text, data, uninitialized memory,
reserved memory, overlays, etc.), some support for multiple target
processors, defined structures for symbol tables and relocations, and
debugging information tailored for the C language.</p>
</blockquote>
<p>According to <code>scnhdr.h</code> in System V Release 2 for NS32xxx,
COFF was designed no later than 1982. Then, System V Release 3 adopted
COFF, which motivated a lot of follow-ups.</p>
<ul>
<li>Windows extended COFF to the <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">Portable
Executable (PE) format</a>.</li>
<li>Texas Instruments <a target="_blank" rel="noopener" href="https://software-dl.ti.com/ccs/esd/documents/sdto_cgt_A-Brief-History-of-TI-Object-File-Formats.html">modified
COFF</a> for its TI toolset and then switched to ELF.</li>
<li>ECOFF used by Tru64 UNIX changed symbol representation.</li>
<li>IBM developed XCOFF (COFF combined with the TOC module format
concept, CSECT, etc) and used it for AIX.</li>
</ul>
<p>Key drawbacks:</p>
<ul>
<li>Hard-wiring debugging information tailored for the C language into
the symbol structure is complex, space-inefficient, and ugly.</li>
<li>The auxiliary symbol record design is inflexible and
inefficient.</li>
<li>Not 32-bit-aligned symbol and section structures caused performance
issue to earlier systems.</li>
<li>No support for <a href="https://maskray.me/blog/2021-04-25-weak-symbol">weak
symbols</a>. PE implemented an inflexible weak definition mechanism
called &#34;weak externals&#34;.</li>
</ul>
<h3 id="mach-o">Mach-O</h3>
<p>Carnegie Mellon University developed the Mach kernel as a proof of
the microkernel concept. The operating system used a format derived from
a.out with minor modifications, named the Mach object file format. The
abbreviation, Mach-O, is often used instead. The NeXTSTEP operating
system and then Darwin adopted Mach-O.</p>
<p>Dynamic shared library support on Mach-O came later than other object
file formats. In a NeXTSTEP manual released in 1995, I can find
<code>MH_FVMLIB</code> (fixed virtual memory library, which appears to
be a static shared library scheme) but not <code>MH_DYLIB</code> (used
by modern macOS for .dylib files).</p>
<p>Key drawbacks:</p>
<ul>
<li>No <a href="https://maskray.me/blog/2021-07-25-comdat-and-section-group">COMDAT</a>
support.</li>
<li>Scarcity of relocation types.</li>
<li>255 section limit. <code>.subsections_via_symbols</code> has some
downsides (discussed later).</li>
</ul>
<p>In my opinion, Mach-O is the most limited among Mach-O/PE/ELF.
However, I want to acknowledge certain innovative features like
<code>.subsections_via_symbols</code> and
<code>S_ATTR_LIVE_SUPPORT</code>.</p>
<h3 id="elf">ELF</h3>
<p>Frustrations and inherent constraints of COFF, coupled with a
self-imposed byte order dilemma, AT&amp;T introduced a groundbreaking
format: Executable and Linking Format (ELF). ELF revisited fixed content
and hard-wired concepts in previous object file formats, removed
unnecessary elements, and made control structures more flexible.</p>
<p>This pivotal shift was embraced by System V Release 4, marking a new
era in object file format design. In the 1990s, many Unix and Unix-like
operating systems, including Solaris, IRIX, HP-UX, Linux, and FreeBSD,
switched to ELF.</p>
<h2 id="symbols">Symbols</h2>
<p>The minimum of a symbol control structure needs to encode the name,
section, and value. We can require that every symbol is defined in
relation to some section. We can use a section index of zero to
represent an undefined symbol.</p>
<p>In a minimum object file format with only few hard-coded sections
(a.out), the section field can be omitted. A type field can be used to
decide whether the symbol can reference a function or a data object.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>The symbol name is represented as a 32-bit index into the string
table. A 32-bit integer suffices, while a 16-bit integer would be too
small.</p>
<p><code>st_shndx</code> uses a size-saving trick. The 16-bit member
encodes a section index. If the member is <code>SHN_XINDEX</code>
(0xffff), then the actual value is contained in the associated section
of type <code>SHT_SYMTAB_SHNDX</code>. This is a very nice trick because
the number of sections are almost always smaller than 0xff00. In
pathologic cases, there can be more sections, where a section of type
<code>SHT_SYMTAB_SHNDX</code> is needed.</p>
<p><code>st_info</code> specifies the symbol&#39;s type (4 bits) and binding
(4 bits) attributes. Types are allocated very conservatively and usually
imply different linker behaviors. The inherently different linker
behaviors for symbol types are not that many. So 4 bits seem small, they
are sufficient in practice. As we will learn, this is significantly
smaller than COFF&#39;s type and storage class representation. A symbol&#39;s
binding is for the local/weak/global distinction. The reserved 4 bits
can accommodate more values, but only GNU reserves one value
(<code>STB_GNU_UNIQUE</code>) (a misfeature in my opinion).</p>
<p>In COFF, function symbols can use an auxiliary symbol record to
encode the size of function (<code>x_fsize</code>;
<code>TotalSize</code> in PE). In ELF, <code>st_size</code> is a fixed
member, used for copy relocations and symbolizers. If we eliminate copy
relocations and don&#39;t need the symbolization heuristics, this field will
become garbage.</p>
<p>Here is a demonstration if we remove <code>st_size</code>.
</p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<h3 id="symbols-a.out">Symbols (a.out)</h3>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>a.out uses a <code>nlist</code> to represent a symbol table entry. In
the original format for PDP-11, the assembler generates symbols of at
most 7 bytes. <code>n_name[8]</code> can hold the name with a NUL end.
Unix&#39;s appreciation of shorter identifier names is related to this:)</p>
<p>To support longer names, extensions add a string table after the
symbol table, and allow <code>n_name</code> to be interpreted as an
index (<code>n_strx</code>) into the string table. This member then
becomes a size-saving trick by inlining a short name (8 bytes or less)
into the structure. Some variants, like binutils&#39; 64-bit a.out format,
use an index exclusively and removed <code>n_name</code>.</p>
<p><code>n_type</code>, broken down into three sub-fields, describes
whether a symbol is defined or undefined, external or local, and the
symbol type. The values listed on the FreeBSD manpage are also used on
PDP-11.</p>
<p>For a defined symbol, <code>n_type</code> describes whether it is
relative to TEXT, DATA, or BSS.</p>
<h3 id="symbols-coff">Symbols (COFF)</h3>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>COFF adopts a.out&#39;s approach to save space in symbol names. This
likely made sense when most symbols were shorter. However, with today&#39;s
often lengthy symbol names, this inlining technique complicates code and
increases the control structure size (from 4 to 8 bytes).</p>
<p>The section number is a 16-bit signed integer, supporting up to
32,767 sections. Positive values indicate a section index, while special
values include:</p>
<ul>
<li><code>N_UNDEF</code> (0): Undefined symbol (distinct from a.out&#39;s
<code>n_type</code> representation).</li>
<li><code>N_ABS</code> (-1): Symbol has an absolute value.</li>
<li><code>N_DEBUG</code> (-2): Special debugging symbol (value is
meaningless).</li>
</ul>
<p>COFF&#39;s <code>n_type</code> and <code>n_sclass</code> encode C&#39; type
and storage class information. PE assigns longer names to these types
and storage classes longer names, e.g.,
<code>IMAGE_SYM_TYPE_CHAR/IMAGE_SYM_TYPE_SHORT</code>,
<code>IMAGE_SYM_CLASS_AUTOMATIC/IMAGE_SYM_CLASS_EXTERNAL</code>. While
values are mostly consistent, minor differences exist:</p>
<ul>
<li>PE&#39;s <code>IMAGE_SYM_TYPE_VOID</code> (1) is different from System V
Release 3&#39;s
<code>#define T_ARG 1 /* function argument (only used by compiler) */</code>.</li>
<li>PE&#39;s <code>IMAGE_SYM_CLASS_WEAK_EXTERNAL</code> (105) is different
from System V Release 3&#39;s
<code>#define C_ALIAS 105 /* duplicate tag */</code>.</li>
</ul>
<p>Symbols with <code>C_EXT</code>
(<code>IMAGE_SYM_CLASS_EXTERNAL</code>) are global and added to the
linker&#39;s global symbol table, akin to ELF&#39;s <code>STB_GLOBAL</code>
symbol binding.</p>
<p>System V ships a symbolic debugger (sdb), which utilizes
<code>n_type</code> and <code>n_sclass</code>. If we acknowledge that
the debugging information format is outdated, <code>n_type</code> and
<code>n_class</code> serve as a wasteful counterpart to to ELF&#39;s
<code>st_info</code>.</p>
<p><code>n_numaux</code> relates to Auxiliary Symbol Records, allowing
extra information but introducing non-uniform symbol table entries.
While seemingly beneficial, their use cases are limited and could often
be encoded using separate sections. In PE, an auxiliary symbol record
can represent weak definitions, but weak references are not supported.
They can also provide extra information to section symbols.</p>
<p>ECOFF defines Local Symbol Entry (SYMR) and External Symbol Entry
(EXTR).</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>typedef</span> <span><span>struct</span> {</span></span></pre></td></tr></tbody></table></figure>
<h3 id="symbols-mach-o">Symbols (Mach-O)</h3>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>Mach-O&#39;s <code>nlist</code> and <code>nlist_64</code> are not that
different from a.out&#39;s, with <code>n_other</code> changed to
<code>n_sect</code> to indicate the section index. The 8-bit n_sect
field restricts representable sections to 255 without out-of-band data
(discussed later). If we extend <code>n_sect</code> to 32-bit, with
alignment padding the structure size will increase to 24 bytes, the same
as <code>Elf64_Sym</code>.</p>
<p>Like a.out, the <code>N_EXT</code> bit of <code>n_type</code>
indicates an external symbol. The <code>N_PEXT</code> bit indicates a
private external symbol.</p>
<p>Key bits in <code>n_desc</code> are <code>N_WEAK_DEF</code>,
<code>N_WEAK_REF</code>, and <code>N_ALT_ENTRY</code>.</p>
<h2 id="sections">Sections</h2>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>The section name is represented as a 32-bit index into the string
table. If we use a 16-bit integer, a large number of section names with
a symbol suffix (e.g. <code>.text.foo</code> <code>.text.bar</code>)
could make the index overflow.</p>
<p><code>sh_type</code> categorizes the section&#39;s contents and
semantics. It avoids hard-coding magic names in many scenarios.
Technically a 16-bit type could work pretty well but was deemed
insufficient for flexibility.</p>
<p><code>sh_flags</code> describe miscellaneous attributes, e.g.
writable and executable permissions, and whether the section should
appear in a loadable segment. This member is 32-bit in
<code>Elf32_Shdr</code> while 64-bit in <code>Elf64_Shdr</code>. In
practice no architecture defines flags for bits 32 to 63, therefore this
member is somewhat wasteful.</p>
<p>Location and size. <code>sh_offset</code> gives the byte offset from
the beginning of the file to the first byte in the section. To support
object files larger than 4GiB, this member has to be 64-bit.
<code>sh_size</code> gives the section&#39;s size in bytes. A section type
of <code>SHT_NOBITS</code> occupies no space in the file. To support
sections larger than 4GiB, this member has to be 64-bit.</p>
<p>Address and alignment. <code>sh_addr</code> describes the address at
which the section&#39;s first byte should reside for an executable or shared
object. It should be zero for relocatable files.
<code>sh_addralign</code> holds the address alignment. In practice this
member must be a power of 2 even if the generic ABI does not require so.
This member is 64-bit in ELF64, which allows an alignment up to
<code>2**63</code>. In practice, an alignment larger than the page size
(or the largest huge page size, if huge pages are enabled) does not make
sense, and a maxiumm value of 2**31 is sufficient. Therefore, we could
use a log2 value to hold the alignment.</p>
<p>Connection information. <code>sh_link</code> holds a section index.
<code>sh_info</code> holds either a section index or a symbol index. If
you recall that <code>st_shndx</code> is 16 bits for very solid reason,
you will know that the two fields are somewhat wasteful.</p>
<p>For a table of fixed-size entries, <code>sh_entsize</code> holds the
entry size in bytes. In some use cases this member is not a power of
two. In practice, one byte suffices.</p>
<p>While ELF&#39;s section header structure is designed for flexibility,
potential optimizations could reduce its size without significant loss
of functionality. By using smaller data types for <code>sh_flags</code>,
<code>sh_link</code>, <code>sh_info</code>, and <code>sh_entsize</code>
based on practical needs, we could make the structure significantly
smaller. </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>// 32 bytes</span></pre></td></tr></tbody></table></figure>
<p>Reducing <code>sh_type</code> into 2 bytes loses flexibility a bit.
If this deems insufficient, we could take 3 bits from
<code>sh_addralign</code> (by turning it into a bitfield) and give them
to <code>sh_type</code>.</p>
<h3 id="sections-coff">Sections (COFF)</h3>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>// COFF (System V Release 3), 40 bytes, when sizeof(long) == 4</span></pre></td></tr></tbody></table></figure>
<p>PE&#39;s section control structure demonstrates a minor modification
compared to COFF, <code>s_paddr =&gt; VirtualSize</code>.</p>
<p>The presented structure measures as 40 bytes when <code>long</code>
is 4 bytes. If we extend
<code>s_paddr, s_vaddr, s_size, s_scnptr, s_relptr, s_lnnoptr</code> to
8 bytes, the structure will be of 64 bytes.</p>
<p>The section name supports up to 8 bytes. A longer name would require
an extension similar to the symbol control structure.</p>
<p>Encoding both <code>s_paddr</code> and <code>s_vaddr</code> is
wasteful. ELF encodes the physical address in the segment and therefore
removes the member from its section structure.</p>
<p>COFF embeds the location and size of relocations into the section
structure. This is actually pretty nice. A 16-bit <code>s_nreloc</code>
may appear restritive but is sufficient for relocatable files. In
practice, the number of relocations can exceed 65536 for a single
section using relocatable linking.</p>
<p><code>s_lnnoptr</code> and <code>s_nlnno</code> point to line number
entries, which relate addresses to source file line numbers. The
embedded nature is inflexible. </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>This simple format is deprecated. In DWARF, special opcodes in line
number information can encode the information in a more space-efficient
way and present more information like the column number.</p>
<h3 id="sections-mach-o">Sections (Mach-O)</h3>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>How does Mach-O end up with such a huge section structure? Let&#39;s find
out...</p>
<p>A Mach-O binary is divided into segments, each housing one or more
sections. The section structure encodes the section name and the segment
name, both can be up to 16 bytes. This representation allows the section
names to be read without a string table, but restrictive for descriptive
names. Section semantics are derived from the name (unlike ELF).</p>
<p>The segment name is redundantly encoded within the section structure.
We could derive the segment from the section name and flags, e.g.,
<code>S_ATTR_SOME_INSTRUCTIONS =&gt; __TEXT</code> ,
<code>S_ZEROFILL =&gt; ZeroFill __DATA</code> .</p>
<p>There is a severe limitation: maximum of 255 sections due to
<code>nlist::n_sect</code> being a <code>uint8_t</code>. This is
apparently too restrictive. Thankfully, an innovative feature
<code>.subsections_via_symbols</code> overcomes the limitation. The
feature uses a monolithic section with &#34;atoms&#34; dividing it into pieces
(subsections). This is more size-efficient than ELF&#39;s
<code>-ffunction-sections -fdata-sections -fno-unique-section-names</code>.
However, there are assembler limitations, relocation processing
complexity, and potential loss of ability to ensure that two non-local
symbols are not reordered.</p>
<p>Like COFF, Mach-O embeds the location and size of relocations into
the section structure.</p>
<p>The three trailing reserved members are a bad idea. They increase the
size considerably. A better approach would be to just change the version
number when the structure needs to grow. It&#39;s unlikely that an older
consumer can interepret a new section with new members set for new
semantics.</p>
<h2 id="relocations">Relocations</h2>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p><code>r_info</code> specifies the symbol table index with respect to
which the relocation must be made, and the type of relocation to
apply.</p>
<ul>
<li>ELFCLASS32: 8-bit type, 24-bit symbol index</li>
<li>ELFCLASS64: 32-bit type, 32-bit symbol index</li>
</ul>
<p>There are two variants, REL and RELA. Let&#39;s quote the generic
ABI:</p>
<blockquote>
<p>As specified previously, only Elf32_Rela and Elf64_Rela entries
contain an explicit addend. Entries of type Elf32_Rel and Elf64_Rel
store an implicit addend in the location to be modified. Depending on
the processor architecture, one form or the other might be necessary or
more convenient. Consequently, an implementation for a particular
machine may use one form exclusively or either form depending on
context.</p>
</blockquote>
<p>Relocatable files need a lot of relocatable types while executables
and shared objects need only a few. The former is often called static
relocations while the latter is called dynamic relocations.</p>
<p>Of the few dynamic relocation types, most do not need the addend
member. lld provides an option <code>-z rel</code> to use
<code>SHT_REL/DT_REL</code> dynamic relocations.</p>
<p>If we disregard the REL dynamic relocation scenario, then all modern
architectures use RELA exclusively. Most architectures encode the
immediate with only few bits, which are inadequate for many relocatable
file uses.</p>
<p>ELFCLASS64, with its 64-bit members, doubles the size compared to
ELFCLASS32&#39;s 32-bit members. Since relocations often comprise a
substantial portion of object files, this size difference can lead to
user concerns. However, in practice, a 24-bit symbol index is often
sufficient, even in 64-bit contexts. Therefore, if a 64-bit
architecture&#39;s relocation type requirements are less than 256,
ELFCLASS32 can be a viable and more size-efficient option.</p>
<h3 id="relocations-a.out">Relocations (a.out)</h3>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p><code>r_symbolnum</code> mirrors ELF&#39;s <code>ELF32_R_SYM</code>.</p>
<p>The other bitfields, resembling ELF&#39;s <code>ELF32_R_TYPE</code>, but
split into distinct fields:</p>
<ul>
<li><code>r_pcrel</code></li>
<li><code>r_length</code></li>
<li>others</li>
</ul>
<p>Reserving dedicated semantics for individual bits can limit
adaptability. COFF and ELF opted to remove bitfields in favor of a type
to provide greater flexibility.</p>
<h3 id="relocations-coff">Relocations (COFF)</h3>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>This format resembles ELF&#39;s <code>Elf32_Rel</code>.</p>
<p><code>r_vaddr</code> gives the virtual address of the location at
which to apply the relocation action. If we interpret
<code>r_vaddr</code> as an offset (as PE does) and restrict section size
to 32 bits, we could reuse this structure for 64-bit architectures.</p>
<p><code>r_symndx</code> is a 32-bit symbol table index.</p>
<p><code>r_type</code> is a 16-bit relocation type, limited in number
compared to ELF.</p>
<p>COFF generally supports fewer relocation types than ELF. System V
Release 3 defines very few relocations for each architecture. In
binutils, <code>include/coff/*.h</code> files define relocations for
more architectures.</p>
<p>While ELF uses the REL/RELA for both relocatable files and
executables, in PE image files, the import address table and base
relocation table (<code>.reloc</code>) are a completely different
design.</p>
<h3 id="relocations-mach-o">Relocations (Mach-O)</h3>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>Mach-O&#39;s relocation structure closely mirrors a.out&#39;s with adapted
<code>r_symbolnum</code> meaning. When <code>r_extern == 0</code>
(local), the <code>r_symbolnum</code> member references a section index
instead of a symbol index. This is to support custom sections, breaking
the three-section limitation (text, data, and bss) of traditional
a.out.</p>
<p>As aforementioned, dedicating bits to bitfields
(<code>r_pcrel</code>, <code>r_length</code>, and
<code>r_scattered</code> greatly restricted the number of relocation
types.</p>
<p>Related to the relocation type limitation, a
<code>.long foo - .</code> in a data section requires a pair of
relocations, <code>SUBTRACTOR</code> and<code>/UNSIGNED</code>. I have
some notes on <a href="https://maskray.me/blog/2023-06-18-port-llvm-xray-to-apple-systems">Port LLVM XRay
to Apple systems</a>.</p>
<p>Mach-O uses a number of sections in the <code>__LINKEDIT</code>
segment to communicate information to dyld.</p>


<p>Dennis MacAlistair Ritchie&#39;s <a target="_blank" rel="noopener" href="https://www.bell-labs.com/usr/dmr/www/man51.pdf"><code>A.OUT (V)</code>
manpage</a> (1971) describes the original a.out format. The header
contains 6 words.</p>
<ul>
<li>a &#34;br .+14&#34; instruction (205(8))</li>
<li>The size of the program text</li>
<li>The size of the symbol table</li>
<li>The size of the relocation bits area</li>
<li>The size of a data area</li>
<li>A zero word (unused at present)</li>
</ul>
<p>The text relocations are implicit.</p>
<p>Later versions introduced new magic numbers, separated text
relocations and data relocations, and added an entry point
(<code>a_entry</code>).</p>
<h2 id="size-comparison">Size comparison</h2>
<p>TODO</p>
<h2 id="size-reduction-opportunities">Size reduction opportunities</h2>
<p>ELFCLASS32 structures are already compact, offering limited size
reduction potential. ELFCLASS64 structures, while flexible, can be
optimized by sacrificing some flexibility (64-bit quantities). The
64-bit symbol control structure is compact, but section and relocation&#39;s
are quite wasteful if we can sacrifice some flexibility.</p>
<p>As the ELF paper acknowledges, &#34;Relocatable and executable files do
not necessarily have the same constraints, and we considered using two
file formats. Eventually, we decided the two activities were similar
enough that a single format would suffice.&#34; There are more tools
inspecting executables than relocatable files. So, naturally, we might
want to change just relocatable files. Can we use ELFCLASS32 relocatable
files for 64-bit architectures?</p>
<p>Well, x86-64 and AArch64 make a clear distinct of ELFCLASS32 and
ELFCLASS64. ELFCLASS32 is for ILP32 (x32, aarch64_ilp32) while
ELFCLASS64 is for LP64. However, the discontinued Itanium architecture
sets a precedent that ELFCLASS32 can be used for LP64 programs. Quoting
its psABI (<em>Intel Itanium Processorspecific Application Binary
Interface (ABI)</em>).</p>
<blockquote>
<p>For Itanium architecture ILP32 relocatable (i.e. of type ET_REL)
objects, the file class value in e_ident[EI_CLASS] must be ELFCLASS32.
For LP64 relocatable objects, the file class value may be either
ELFCLASS32 or ELFCLASS64, and a conforming linker must be able to
process either or both classes. ET_EXEC or ET_DYN object file types must
use ELFCLASS32 for ILP32 and ELFCLASS64 for LP64 programs.</p>
<p>Addresses appearing in ELFCLASS32 relocatable objects for LP64
programs are implicitly extended to 64 bits by zero-extending.</p>
<p>Note: Some constructs legal in LP64 programs, e.g. absolute 64-bit
addresses outside the 32-bit range, may require use of an ELFCLASS64
relocatable object file.</p>
</blockquote>
<p>Given the prior art, it seems promising to allow ELFCLASS32 when the
code size concerns people. Ideally there should be a marker to
distinguish ILP32 and LP64-using-ELFCLASS32 object files.</p>
<p>The primary changes reside in the assembler and linker. It&#39;s also
important to ensure that binary manipulation programs (like objcopy) and
dump tools are happy with them.</p>
<p>Further optimization potential lies in exploring the use of
<code>Elf32_Rel</code> instead of <code>Elf32_Rela</code> for even
smaller relocations.</p>
<h3 id="replacing-control-structures">Replacing control structures</h3>
<p>This approach is independent of whether ELFCLASS32 is adopted and can
be applied to both ELFCLASS32 and ELFCLASS64. The ELF paper is clear,
&#34;ELF allows extension and redefinition for other control structures.&#34;
However, caution is warranted due to the significant impact on the
ecosystem as many tools rely on the existing structures.</p>
<p>One promising example is <code>Elf32_Shdr_minimized</code>, a custom
structure reduced to 32 bytes from the standard
<code>Elf32_Shdr</code>&#39;s 40 bytes. While I would be nervous, but if we
reduce <code>sh_type</code> to a <code>uint16_t</code>, the structure
size can reduce to 28 bytes.</p>
<h2 id="stabs">stabs</h2>
<p>Earlier debuggers operated using a debugging information format
called &#34;stabs&#34; (short for symbol table entries; dating back to at least
UNIX/32V in 1979). Stabs is encoded using extra symbol table entries in
the a.out object file format.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>.stabs &#34;string&#34;,type,other,desc,value</span></pre></td></tr></tbody></table></figure>
<p>Stabs was ported to COFF for System V Release 2, used on some
machines. System V Release 4 switched to ELF and abandoned stabs in
favor of a newly developed format called DWARF. Its debugger sdb was
rewritten to support DWARF, and stabs was no longer supported. (The
first version of DWARF was later published by the UNIX International
Programming Languages Special Interest Group (SIG) in January 1992.)</p>
<p>However, stabs continued to be used in other operating systems,
including *BSD, AIX, and IRIX. For example, the GNU assembler added
stabs support for ELF (<code>n_strx</code> is 32-bit).</p>
<p>GCC 13 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/git/gitweb.cgi?p=gcc.git;h=7e0db0cdf01e9c885a29cb37415f5bc00d90c029">removed
stabs support</a>.</p>
<p>Stabs is less efficient than DWARF. When compiling a non-trivial
program (so that the boilerplate in DWARF is less significant), you may
observe that <code>.stab</code> and <code>.stabstr</code> consume more
space than <code>.debug_*</code> sections, even if DWARF is more
expressive and contains more information.</p>
<h2 id="todo">TODO</h2>
<p>WebAssembly</p>

      
    </div></div>
  </body>
</html>
