<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/fzf-shell-integration/">Original</a>
    <h1>A Practical Guide to fzf: Shell Integration</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/darth_vador_searching_skywalker.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/darth_vador_searching_skywalker.jpg" alt=""/></picture><p>This article is part of a series about fzf:</p><p>In the <a href="https://thevaluable.dev/practical-guide-fzf-example/">previous article of this series</a>, Davina (your colleague developer) explained how powerful fzf can be to create our own fuzzy search and, to an extent, our own TUIs.</p><p>Good news everyone: Davina is back! This time, her mission is to explain how to integrate fzf with the shell. This integration adds many new functionalities to your favorite shell, making it even more powerful.</p><p>You can use fzf’s shell integration if you use either Bash, <a href="https://thevaluable.dev/zsh-install-configure-mouseless/">Zsh</a>, or Fish. I’m not the biggest fan of Fish (it’s not POSIX compatible), so I will focus mostly on Bash and Zsh in this article.</p><p>More specifically, we’ll see:</p><ul><li>What keystrokes we can use to fuzzy search through files and directories.</li><li>How to use a completion using fzf in the shell.</li><li>How to customize keybindings and completions.</li><li>How to launch fzf in tmux panes automatically.</li></ul><p>I encourage you to try out the different configurations described in this article. To follow along, you can download the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-fzf" target="_blank" rel="noopener">companion project</a> and run the different commands from there. Most of the screenshots are executed from this <code>guide-fzf</code> directory.</p><p>Keybinding and completion are possible thnaks to a couple of files which need to be sourced in your shell. I’m using Arch Linux (by the way), so for me these files are located in the directory <code>/usr/share/fzf/</code>. You can also find them in the <a href="https://github.com/junegunn/fzf/tree/master/shell" target="_blank" rel="noopener">official repository of fzf</a>. The files with the extension <code>.bash</code> need to be sourced if you use Bash; the same for Zsh.</p><p>Here’s how I source them in my <code>zshrc</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>source</span> /usr/share/fzf/key-bindings.zsh
</span></span><span><span><span>source</span> /usr/share/fzf/completion.zsh
</span></span></code></pre></div><p>Depending on what OS you’re running and how you’ve installed fzf on your machine, these files might be in a different place. You can also copy them manually somewhere in your system and source them, too.</p><p>Let’s now dive in these files to see what secrets they hold!</p><h2 id="keybinding-with-fzf">Keybinding with fzf</h2><p>Let’s begin by the keybindings: what keystrokes can we hit in our shells to invoke the power of fzf?</p><h3 id="keystrokes-available">Keystrokes Available</h3><p>If you open the file “key-bindings.bash”, you’ll see the different binding declared at the end of the file, using the commands <code>bind</code>.</p><p>Here’s the list of all keystrokes available:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>CTRL-t</code></td><td>Fuzzy find all files and subdirectories of the working directory, and output the selection to STDOUT.</td></tr><tr><td><code>ALT-c</code></td><td>Fuzzy find all subdirectories of the working directory, and run the command “cd” with the output as argument.</td></tr><tr><td><code>CTRL-r</code></td><td>Fuzzy find through your shell history, and output the selection to STDOUT.</td></tr></tbody></table><p>My life would be grimmer without <code>CTRL-r</code>. I’m searching in my shell history all the time, to run similar commands I ran in the past. Here’s how it looks in my shell:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-search-history.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-search-history.jpg" alt="Using fzf in the shell to search the history"/></picture><p>The keystroke <code>CTRL-t</code> is also very useful if you want to quickly edit a file. I just have to type <code>vim</code> in my terminal followed by <code>CTRL-t</code> to search the file I want to edit.</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-search-files-dirs.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-search-files-dirs.jpg" alt="Using fzf in the shell to search the files and directories"/></picture><p>Finally, <code>ALT-c</code> is useful if you want to search for and move into a subdirectory.</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-search-dirs.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-search-dirs.jpg" alt="Using fzf in the shell to search the files"/></picture><p>This is great, but what I’d like to do now is to configure all of these keystrokes according to my own specific needs.</p><h3 id="customizing-fzf-keybindings">Customizing fzf Keybindings</h3><p>If you look a bit closer at the completion file, you’ll find three functions called by our three keystrokes:</p><table><tbody><tr><th>Keystroke</th><th>Bash function</th><th>Zsh function</th></tr><tr><td><code>CTRL-t</code></td><td><code>__fzf_select__</code></td><td><code>__fsel</code></td></tr><tr><td><code>CTRL-r</code></td><td><code>__fzf_history__</code></td><td><code>fzf-history-widget</code></td></tr><tr><td><code>ALT-c</code></td><td><code>__fzf_cd__</code></td><td><code>fzf-cd-widget</code></td></tr></tbody></table><p>The body of these functions will give you the commands executed each time you hit one of the keystrokes. For example, here’s the command running when you hit <code>CTRL-t</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>cmd</span><span>=</span><span>&#34;</span><span>${</span><span>FZF_CTRL_T_COMMAND</span><span>:-</span><span>&#34;command find -L . -mindepth 1 \\( -path &#39;*/\\.*&#39; -o -fstype &#39;sysfs&#39; -o -fstype &#39;devfs&#39; -o -fstype &#39;devtmpfs&#39; -o -fstype &#39;proc&#39; \\) -prune \
</span></span></span><span><span><span>-o -type f -print \
</span></span></span><span><span><span>-o -type d -print \
</span></span></span><span><span><span>-o -type l -print 2&gt; /dev/null | cut -b3-&#34;</span><span>}</span><span>&#34;</span>
</span></span></code></pre></div><p>Here, the command <code>find</code> is used with many different expressions to filter the result of the search. If you want to know more about find, I’ve <a href="https://themouseless.dev/posts/find-guide-example-mouseless/" target="_blank" rel="noopener">written an article about it here</a>.</p><p>We can also see that the command itself can be overwritten with the value of the environment variable <code>FZF_CTRL_T_COMMAND</code>. There are more environment variables available to overwrite commands; you can find them at the beginning of the completion file. Here’s the list:</p><table><tbody><tr><th>Environment variable</th><th>Keystroke</th></tr><tr><td><code>FZF_CTRL_T_COMMAND</code></td><td><code>CTRL-t</code></td></tr><tr><td><code>FZF_ALT_C_COMMAND</code></td><td><code>ALT-c</code></td></tr></tbody></table><p>We can’t change the default command for <code>CTRL-r</code>, to search through the shell history. It’s because there are some scripts involved here; an AWK script for Zsh, a Perl script for Bash.</p><p>Looking at the beginning of the “keystroke” file, you’ll see other environment variables allowing us to set fzf’s default options depending on the keystroke we use:</p><table><tbody><tr><th>Environment variables</th><th>Keystroke</th></tr><tr><td><code>FZF_CTRL_T_OPTS</code></td><td><code>CTRL-t</code></td></tr><tr><td><code>FZF_CTRL_R_OPTS</code></td><td><code>CTRL-r</code></td></tr><tr><td><code>FZF_ALT_C_OPTS</code></td><td><code>ALT-c</code></td></tr></tbody></table><p>Here’s an example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>export</span> <span>FZF_CTRL_T_OPTS</span><span>=</span><span>&#34;--height 60% \
</span></span></span><span><span><span>--border sharp \
</span></span></span><span><span><span>--layout reverse \
</span></span></span><span><span><span>--prompt &#39;∷ &#39; \
</span></span></span><span><span><span>--pointer ▶ \
</span></span></span><span><span><span>--marker ⇒&#34;</span>
</span></span></code></pre></div><p>If you run the above in your shell, these options will be given to fzf each time you hit <code>CTRL-t</code>.</p><p>What about changing the keystrokes themselves? If you look at the end of the file “key-bindings.bash”, you’ll see their definitions. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>bind</span> -m emacs-standard <span>&#39;&#34;\ec&#34;: &#34; \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d&#34;&#39;</span>
</span></span><span><span><span>bind</span> -m vi-command <span>&#39;&#34;\ec&#34;: &#34;\C-z\ec\C-z&#34;&#39;</span>
</span></span><span><span><span>bind</span> -m vi-insert <span>&#39;&#34;\ec&#34;: &#34;\C-z\ec\C-z&#34;&#39;</span>
</span></span></code></pre></div><p>The keystroke itself is <code>\ec</code> here, meaning <code>ALT-c</code>. Let’s say that we don’t like to use <code>ALT-c</code>, but instead we’d like to use <code>CTRL-e</code>. First, we need to find in the file <code>key-bindings.bash</code> the good keystroke:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>bind</span> -m emacs-standard <span>&#39;&#34;\ec&#34;: &#34; \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d&#34;&#39;</span>
</span></span></code></pre></div><p>Next, we need to add the following to our bashrc:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>bind</span> -m emacs-standard <span>&#39;&#34;\C-e&#34;: &#34; \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d&#34;&#39;</span>
</span></span></code></pre></div><p>Here, we create a new keystroke using <code>CTRL-e</code> (represented by <code>\C-e</code>), which will do the same as <code>ALT-c</code>.</p><p>For Zsh, if you look into the file “key-bindings.zsh”, you’ll see the different keybindings set in the different functions themselves. The idea stays the same; first, we need to find the different keystrokes we want to change:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>zle     -N             fzf-cd-widget
</span></span><span><span>bindkey -M emacs <span>&#39;\ec&#39;</span> fzf-cd-widget
</span></span><span><span>bindkey -M vicmd <span>&#39;\ec&#39;</span> fzf-cd-widget
</span></span><span><span>bindkey -M viins <span>&#39;\ec&#39;</span> fzf-cd-widget
</span></span></code></pre></div><p>Then, we can add the following to our zshrc:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>zle     -N            fzf-cd-widget
</span></span><span><span>bindkey -M emacs <span>&#39;\C-e&#39;</span> fzf-cd-widget
</span></span><span><span>bindkey -M vicmd <span>&#39;\C-e&#39;</span> fzf-cd-widget
</span></span><span><span>bindkey -M viins <span>&#39;\C-e&#39;</span> fzf-cd-widget
</span></span></code></pre></div><p>It’s also possible to unbind <code>ALT-c</code> if you want to. I’ve already written an <a href="https://thevaluable.dev/zsh-line-editor-configuration-mouseless/">article about Zsh and keybindings</a> if you want to know more about that. For now, here’s how to unbind the default keystroke <code>ALT-c</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>bindkey -rM emacs <span>&#39;\ec&#39;</span>
</span></span><span><span>bindkey -rM vicmd <span>&#39;\ec&#39;</span>
</span></span><span><span>bindkey -rM viins <span>&#39;\ec&#39;</span>
</span></span></code></pre></div><h2 id="completion-using-fzf">Completion Using fzf</h2><p>Having some keystrokes to fire fzf and search through your files, directories, or history is really useful, but it’s only half the functionalities fzf gives us to make the shell even more powerful. The other half is about completion.</p><h3 id="command-and-trigger">Command and Trigger</h3><p>Let’s type the following in our shell, followed by the <code>TAB</code> key:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-vim.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-vim.jpg" alt="We can trigger fzf&#39;s completion with two stars followed by hitting tab"/></picture><p>You can then select the files and directories you want (multi-selection is enabled here), and Vim will open them all.</p><p>There are two important elements in the command above: <code>vim</code> (the command itself), and <code>**</code>, which fzf recognizes as a trigger for completion. Said differently, if you don’t write <code>**</code>, hitting <code>TAB</code> won’t trigger fzf.</p><p>The completion will be different depending on the command. For example, we just saw that triggering the completion with Vim will give you files and directories (the default behavior for most commands). But if you try to complete “cd” for example, you’ll get only directories:</p><p>Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-cd.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-cd.jpg" alt="The completion for cd will only display directories"/></picture><p>Whatever is put before the trigger will be used as query for fzf. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>cd</span> mouseless-book-behind-scene**
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-cd-query.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-cd-query.jpg" alt="It&#39;s possible to add a query before the completion trigger"/></picture><p>You’ll notice that you can’t have multiple selections here; after all, “cd” needs only one argument.</p><p>When you think about it, most commands get some paths (files or directories) as arguments; as a result, fzf’s give you paths by default for the completion. As we just saw, other commands will only give you directories. Here’s the complete list of these commands:</p><ul><li><code>cd</code></li><li><code>pushd</code></li><li><code>rmdir</code></li></ul><p>If you look in the file “completion.bash”, you can search for the two variables <code>a_cmds</code> and <code>d_cmds</code>. The first is used for completing paths, the second to only complete directories. For Zsh it’s the same, except that everything which is not part of the value of the variable <code>d_cmds</code> will be completed with paths.</p><p>Of course, there are commands expecting other arguments than file or directory paths. Some of them are supported out of the box; here’s the complete list:</p><table><tbody><tr><th>Command</th><th>Completion</th></tr><tr><td><code>export</code></td><td>Environment variables</td></tr><tr><td><code>unset</code></td><td>Environment variables</td></tr><tr><td><code>unalias</code></td><td>Aliases (use the command <code>alias</code> under the hood).</td></tr><tr><td><code>ssh</code></td><td>Hosts (grep entries from <code>~/.ssh/config</code>, <code>~/.ssh/config.d/* </code>, and <code>/etc/ssh/ssh_config</code>).</td></tr><tr><td><code>telnet</code></td><td>Hosts (grep entries from <code>/etc/hosts</code>).</td></tr><tr><td><code>kill</code></td><td>Processes (use the command <code>ps -ef</code> under the hood).</td></tr></tbody></table><p>Looking at the completion files, how do we know what command triggers what completion? The name of the functions can help here; for example, <code>_fzf_complete_export</code> will trigger the completion after the command <code>export</code>, at least for Zsh. For Bash, the functions are called differently, referencing what they complete instead of what command they complete; for example <code>_fzf_var_completion()</code> complete environment variables.</p><h3 id="customizing-the-completion">Customizing the Completion</h3><p>If you look at one of the completion files, you’ll see again at the very top of the file all the environment variables you can use to customize the completion.</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># - $FZF_TMUX               (default: 0)</span>
</span></span><span><span><span># - $FZF_TMUX_OPTS          (default: &#39;-d 40%&#39;)</span>
</span></span><span><span><span># - $FZF_COMPLETION_TRIGGER (default: &#39;**&#39;)</span>
</span></span><span><span><span># - $FZF_COMPLETION_OPTS    (default: empty)</span>
</span></span></code></pre></div><p>There’s one environment variable missing, however: <code>$FZF_COMPLETION_DIR_COMMANDS</code>. It allows us to specify the commands which should only be completed with directories. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>export</span> <span>FZF_COMPLETION_DIR_COMMANDS</span><span>=</span><span>&#34;cd pushd rmdir tree&#34;</span>
</span></span></code></pre></div><p>Here, I’ve added back the three commands which should have directory paths as completion (<code>cd</code>, <code>pushd</code>, and <code>rmdir</code>), and I’ve added <code>tree</code>. Next, if we try to complete <code>tree **</code>, we’ll get the following:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-tree.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-tree.jpg" alt="We can assign new commands to fzf directory-only completion"/></picture><p>Here are the two other interesting environment variables referenced at the beginning of the file (let’s forget about the tmux related ones for now):</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>$FZF_COMPLETION_TRIGGER</span> <span>(</span>default: <span>&#39;**&#39;</span><span>)</span>
</span></span><span><span><span>$FZF_COMPLETION_OPTS</span>    <span>(</span>default: empty<span>)</span>
</span></span></code></pre></div><p>It’s self-explanatory enough: the first one allow us to change the completion trigger, and the second one can let us add some options to fzf each time we trigger the completion.</p><p>What about changing the different commands used for the completion themselves? You can create two functions to do so:</p><ul><li><code>_fzf_compgen_path</code></li><li><code>_fzf_compgen_dir</code></li></ul><p>Here are the default commands:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>_fzf_compgen_path<span>()</span> <span>{</span>
</span></span><span><span>find -L <span>&#34;</span><span>$1</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span>      -name .git -prune -o -name .hg -prune -o -name .svn -prune -o <span>\(</span> -type d -o -type f -o -type l <span>\)</span> <span>\
</span></span></span><span><span><span></span>      -a -not -path <span>&#34;</span><span>$1</span><span>&#34;</span> -print 2&gt; /dev/null <span>|</span> sed <span>&#39;s@^\./@@&#39;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>_fzf_compgen_dir<span>()</span> <span>{</span>
</span></span><span><span>    find -L <span>&#34;</span><span>$1</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span>      -name .git -prune -o -name .hg -prune -o -name .svn -prune -o -type d <span>\
</span></span></span><span><span><span></span>      -a -not -path <span>&#34;</span><span>$1</span><span>&#34;</span> -print 2&gt; /dev/null <span>|</span> sed <span>&#39;s@^\./@@&#39;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Instead of using <code>find</code>, we could use <a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">ripgrep</a> or <a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener">fd</a> for example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>_fzf_compgen_path<span>()</span> <span>{</span>
</span></span><span><span>    rg --files --glob <span>&#34;!.git&#34;</span> . <span>&#34;</span><span>$1</span><span>&#34;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>_fzf_compgen_dir<span>()</span> <span>{</span>
</span></span><span><span>   fd --type d --hidden --follow --exclude <span>&#34;.git&#34;</span> . <span>&#34;</span><span>$1</span><span>&#34;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We change here the default completion “path” to only complete files, and not files <em>and</em> directories.</p><h2 id="managing-your-own-completion">Managing your Own Completion</h2><p>The first way to create our own custom completion is to simply create a new function named <code>_fzf_complete_&lt;cmd_name&gt;</code>. For example, to create a completion for the “git” command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>_fzf_complete_git<span>()</span> <span>{</span>
</span></span><span><span>  _fzf_complete -- <span>&#34;</span><span>$@</span><span>&#34;</span> &lt; &lt;<span>(</span>
</span></span><span><span>    <span>echo</span> log
</span></span><span><span>    <span>echo</span> diff
</span></span><span><span>  <span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>With this, you can run <code>git **</code>, and you’ll have the choice between <code>log</code> or <code>diff</code> for the completion. That’s a naive approach however, because you need to add here all the completions possible. Here’s a more useful function:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>_fzf_complete_git<span>()</span> <span>{</span>
</span></span><span><span>  _fzf_complete -- <span>&#34;</span><span>$@</span><span>&#34;</span> &lt; &lt;<span>(</span>
</span></span><span><span>    git --help -a <span>|</span> grep -E <span>&#39;^\s+&#39;</span> <span>|</span> awk <span>&#39;{print $1}&#39;</span>
</span></span><span><span>  <span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>This will allow you to complete all git subcommands using fzf!</p><p>There is another interesting function allowing us to give any command for completing any CLI out there: the “comprun” function. For example, if we want to run a specific command to complete the CLI “tree”, we can run the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>_fzf_comprun<span>()</span> <span>{</span>
</span></span><span><span>  <span>local</span> <span>command</span><span>=</span><span>$1</span>
</span></span><span><span>  <span>shift</span>
</span></span><span><span>
</span></span><span><span>  <span>case</span> <span>&#34;</span><span>$command</span><span>&#34;</span> in
</span></span><span><span>    tree<span>)</span>         find . -type d <span>|</span> fzf --preview <span>&#39;tree -C {}&#39;</span> <span>&#34;</span><span>$@</span><span>&#34;</span><span>;;</span>
</span></span><span><span>    *<span>)</span>            fzf <span>&#34;</span><span>$@</span><span>&#34;</span> <span>;;</span>
</span></span><span><span>  <span>esac</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Then, if you try to complete <code>tree **</code>, it will run the corresponding commands (the <code>find . -type d</code> command). The <code>$@</code> at the end pass all the arguments given to fzf. The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-comprun-tree.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-comprun-tree.jpg" alt="We can customize fzf&#39;s completion with the comprun function"/></picture><h2 id="fzf-and-tmux">fzf and tmux</h2><p>If you’re using <a href="https://thevaluable.dev/tmux-config-mouseless/">tmux</a> already, you can force fzf to open in a new pane of your tmux session. To do so, you need to use a script wrapping fzf, called <code>fzt-tmux</code>. Of course, you already need to be in a tmux session for the following to work:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-tmux-pane.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-tmux-pane.jpg" alt="fzf can run in a tmux pane"/></picture><p>Do you remember the environment variables at the beginning of the completion files? Two of them are directly about tmux:</p><table><tbody><tr><th>Environment variable</th><th>Description</th><th>Default when empty</th></tr><tr><td><code>FZF_TMUX</code></td><td>If set to 1, fzf’s will open in a new tmux pane when using a keystroke or the completion.</td><td><code>0</code></td></tr><tr><td><code>FZF_TMUX_OPTS</code></td><td>Gives default options to fzf; automatically use a new pane for keystrokes or the completion if the value of the variable is not empty.</td><td><code>-d 40%</code></td></tr></tbody></table><p>Said differently, if you already give a value to <code>FZF_TMUX_OPTS</code>, there is no need to set <code>FZF_TMUX</code> to <code>1</code>; keybindings and completion will always open in a new tmux pane in that case.</p><p>There’s even a short man page you can read: <code>man fzf-tmux</code>. The most noticeable option is <code>-p</code>, to open fzf in a tmux floating pane. You can try it by yourself easily:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-tmux-floating-pane.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-shell-integration/fzf-completion-tmux-floating-pane.jpg" alt="fzf can run in a floating tmux pane"/></picture><p>How fancy!</p><h2 id="more-power-to-the-shell">More Power to the Shell</h2><p>You can now configure and customize fzf following your craziest wishes. You can adapt it to match your workflow in the holy shell!</p><p>What did we see in this article?</p><ul><li>We can use multiple keystrokes in our shell to launch fzf: <code>CTRL-t</code>, <code>CTRL-r</code>, and <code>ALT-c</code>. We can customize the options given to fzf, as well as the commands used to populate fzf’s list.</li><li>We can also complete some shell commands using fzf, by default triggered with <code>**</code> (followed by <code>TAB</code>). Really handy to find files or directory quickly, or anything else you want!</li><li>We have different ways to create our own completion: using the “comprun” function, or by defining our own custom functions.</li><li>We can also open fzf inside a tmux pane automatically (even a floating one), when using keybindings or completion, using the wrapper script <code>fzf-tmux</code>.</li></ul><p>The shell is already a powerful environment, and fzf makes it even more useful. It has been a huge game changer for my own workflow throughout the years.</p><p>Don’t hesitate to share in the comments your favorite hacks for fzf to behave exactly as you want it to.</p></section></article></div></div>
  </body>
</html>
