<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://text-incubation.com/AI&#43;code&#43;is&#43;legacy&#43;code&#43;from&#43;day&#43;one">Original</a>
    <h1>AI code is legacy code?</h1>
    
    <div id="readability-page-1" class="page"><p>It seems like there are a few stages in the life of a codebase (and/or parts of it), that dictate its likelihood of deep improvement.

1. When something is new, and you’re the one who built it: *“Oh yeah — we should just change to doing it that way instead”*
2. When something is new, and someone else built it: *“It was probably done this way because of {recent temporary-but-ambient context}. If necessary, I can consider prioritizing.”*
3. When something is older, and you’re the one who built it: *“Oh yeah — we probably should have done it that way. If it becomes necessary to, I can consider prioritizing.”*
4. When something is older, and someone else built it: *“I wonder why it was done that way. Probably only worth revisiting if it becomes an issue.”*

Software evolves more rapidly under the maintenance of its original creator, and in proportion to how recently it was written.

This is efficient — it would be wasteful to “improve” software that already works, has worked for a while, especially when the risks of introducing major changes are not as comprehensively understood as they would be by the original creator.

Some second-order, AI-oriented, conclusions/formulations:

- AI is “stateless” in an important way, even with its context windows. It can infer why something may have been written in a particular way, but it (currently) does not have access to the actual/point-in-time reasoning the way an actual engineer/maintainer would.
- Every iteration is written by “someone else,” and with no more working memory than that of someone rereading your code and building up context from scratch. It ultimately still doesn’t remember-remember the *circuits* that turned the original prompts/inputs into particular outputs.
- AI-generated software starts its life aged, in the last bullet stage — without the benefit of “recency”, nor with its original creator as its maintainer. Legacy code.

There’s a good chance AI-savvy engineers already solve for this in their workflows; cleverly-constructed prompts and context windows, well-annotated code, etc. The above feel more like the inertial direction of this stuff.

My hunch is that the real reason this won’t actually matter, is that “code” itself is a type of state, that prompts + large context windows will *replace* —  increasingly “complex” software will simultaneously run on far *fewer* lines of code, and more of its functionality will rely on prompts with smarter models. Prompt-generated code seems like a short/medium-term bridge.

People deeper in the AI rabbit-hole likely have a ton of counterarguments + corrections to make — which I’d be interested in hearing!

[krrishd](https://twitter.com)
[discuss on hacker news](https://news.ycombinator.com/item?id=43888225)</p></div>
  </body>
</html>
