<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://slawlor.github.io/ractor/quickstart/">Original</a>
    <h1>Ractor – a Rust Actor Framework</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          


        </header>
      

      <section itemprop="text">
        
          
        
        <h2 id="some-notations-to-keep-in-mind">Some notations to keep in mind</h2>

<p>While working through this quickstart, a few notations we want to clarify for readers.</p>

<h3 id="messaging-actors">Messaging actors</h3>

<p>Since we’re trying to model as best we can around <a href="https://www.erlang.org/doc/man/gen_server.html#call-2">Erlang’s practices</a>, message sends in
Ractor can occur in 2 ways, first-and-forget and waiting on a reply. Their notations however follow the Erlang naming schemes of “cast” and “call”
respectively.</p>

<h2 id="installation">Installation</h2>

<p>Install <code>ractor</code> by adding the following to your Cargo.toml dependencies</p>

<div><div><pre><code><span>[dependencies]</span>
<span>ractor</span> <span>=</span> <span>&#34;0.9&#34;</span>
</code></pre></div></div>

<h2 id="your-first-actor">Your first actor</h2>

<p>We have to, of course, start with the iconic “Hello world” sample. We want to build an actor
that’s going to print “Hello world” for every message sent to it. Let’s begin by defining our
actor and filling in the necessary bits. We’ll start with out message definition</p>

<div><div><pre><code><span>pub</span> <span>enum</span> <span>MyFirstActorMessage</span> <span>{</span>
    <span>/// Print&#39;s hello world</span>
    <span>PrintHelloWorld</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>Then we follow up with the most basic required actor definition</p>

<div><div><pre><code><span>use</span> <span>ractor</span><span>::{</span><span>Actor</span><span>,</span> <span>ActorRef</span><span>,</span> <span>ActorProcessingErr</span><span>};</span>

<span>pub</span> <span>struct</span> <span>MyFirstActor</span><span>;</span>

<span>#[async_trait::async_trait]</span>
<span>impl</span> <span>Actor</span> <span>for</span> <span>MyFirstActor</span> <span>{</span>
    <span>type</span> <span>State</span> <span>=</span> <span>();</span>
    <span>type</span> <span>Msg</span> <span>=</span> <span>MyFirstActorMessage</span><span>;</span>
    <span>type</span> <span>Arguments</span> <span>=</span> <span>();</span>

    <span>async</span> <span>fn</span> <span>pre_start</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>_myself</span><span>:</span> <span>ActorRef</span><span>&lt;</span><span>Self</span><span>::</span><span>Msg</span><span>&gt;</span><span>,</span> <span>_arguments</span><span>:</span> <span>Self</span><span>::</span><span>Arguments</span><span>)</span>
        <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>::</span><span>State</span><span>,</span> <span>ActorProcessingErr</span><span>&gt;</span> 
    <span>{</span>
        <span>Ok</span><span>(())</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Let’s break down what we’re doing here, firstly we need our actor’s struct-type which we’re calling <code>MyFirstActor</code>.
We are then defining our <code>Actor</code> behavior, which minimally needs to define three types</p>

<ol>
  <li><code>State</code> - The “state” of the actor, for stateless actors this can be simply <code>()</code> denoting that the actor has no mutable state</li>
  <li><code>Msg</code> - The actor’s message type.</li>
  <li><code>Arguments</code> - Startup arguments which are consumed by <code>pre_start</code> in order to construct initial state. This is helpful for say a
TCP actor which is spawned from a TCP listener actor. The listener needs to pass the owned stream to the new actor, and <code>Arguments</code> is
there to facilitate that so the other actor can properly build it’s state without <code>clone()</code>ing structs with potential side effects.</li>
</ol>

<p>Lastly we are defining the actor’s startup routine in <code>pre_start</code> which emits the initial state of the actor upon success. Once this
is run, your actor is alive and healthy just waiting for messages to be received!</p>

<p><strong>Well that’s all fine and dandy, but how is this going to print hello world?!</strong> Well we haven’t defined that bit yet, we need to
wire up a message handler. Let’s do that!</p>

<div><div><pre><code><span>#[async_trait::async_trait]</span>
<span>impl</span> <span>Actor</span> <span>for</span> <span>MyFirstActor</span> <span>{</span>
    <span>type</span> <span>State</span> <span>=</span> <span>();</span>
    <span>type</span> <span>Msg</span> <span>=</span> <span>MyFirstActorMessage</span><span>;</span>
    <span>type</span> <span>Arguments</span> <span>=</span> <span>();</span>

    <span>async</span> <span>fn</span> <span>pre_start</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>_myself</span><span>:</span> <span>ActorRef</span><span>&lt;</span><span>Self</span><span>::</span><span>Msg</span><span>&gt;</span><span>,</span> <span>_arguments</span><span>:</span> <span>Self</span><span>::</span><span>Arguments</span><span>)</span>
        <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>::</span><span>State</span><span>,</span> <span>ActorProcessingErr</span><span>&gt;</span>
    <span>{</span>
        <span>Ok</span><span>(())</span>
    <span>}</span>

    <span>async</span> <span>fn</span> <span>handle</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>_myself</span><span>:</span> <span>ActorRef</span><span>&lt;</span><span>Self</span><span>::</span><span>Msg</span><span>&gt;</span><span>,</span> <span>message</span><span>:</span> <span>Self</span><span>::</span><span>Msg</span><span>,</span> <span>_state</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Self</span><span>::</span><span>State</span><span>)</span> 
        <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(),</span> <span>ActorProcessingErr</span><span>&gt;</span>
    <span>{</span>
        <span>match</span> <span>message</span> <span>{</span>
            <span>MyFirstActorMessage</span><span>::</span><span>PrintHelloWorld</span> <span>=&gt;</span> <span>{</span>
                <span>println!</span><span>(</span><span>&#34;Hello world!&#34;</span><span>);</span>
            <span>}</span>
        <span>}</span>
        <span>Ok</span><span>(())</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Ok now that looks better! Here we’ve added the message handler <code>handle()</code> method which will be executed for every message received in
the queue.</p>

<h2 id="all-together-now">All together now</h2>

<p>Let’s wire it all up into a proper program now.</p>

<div><div><pre><code><span>#[tokio::main]</span>
<span>async</span> <span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>// Build an ActorRef along with a JoinHandle which lives for the life of the </span>
    <span>// actor. Most of the time we drop this handle, but it&#39;s handy in the </span>
    <span>// main function to wait for clean actor shut-downs (all stop handlers will</span>
    <span>// have completed)</span>
    <span>let</span> <span>(</span><span>actor</span><span>,</span> <span>actor_handle</span><span>)</span> <span>=</span> <span>Actor</span><span>::</span><span>spawn</span><span>(</span><span>None</span><span>,</span> <span>MyFirstActor</span><span>,</span> <span>())</span><span>.await</span><span>.expect</span><span>(</span><span>&#34;Actor failed to start&#34;</span><span>);</span>
    
    <span>for</span> <span>_i</span> <span>in</span> <span>0</span><span>..</span><span>10</span> <span>{</span>
        <span>// Sends a message, with no reply</span>
        <span>actor</span><span>.cast</span><span>(</span><span>MyFirstActorMessage</span><span>::</span><span>PrintHelloWorld</span><span>)</span><span>.expect</span><span>(</span><span>&#34;Failed to send message to actor&#34;</span><span>);</span>
    <span>}</span>

    <span>// give a little time to print out all the messages</span>
    <span>tokio</span><span>::</span><span>time</span><span>::</span><span>sleep</span><span>(</span><span>tokio</span><span>::</span><span>time</span><span>::</span><span>Duration</span><span>::</span><span>from_millis</span><span>(</span><span>100</span><span>))</span><span>.await</span><span>;</span>

    <span>// Cleanup</span>
    <span>actor</span><span>.stop</span><span>(</span><span>None</span><span>);</span>
    <span>actor_handle</span><span>.await</span><span>.unwrap</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<h2 id="adding-state">Adding State</h2>

<p>Now what if we wanted to ask the actor for some information? Like the number of hello-worlds that it has printed thus far
in its lifecycle, let’s see what that might look like.</p>

<div><div><pre><code><span>use</span> <span>ractor</span><span>::{</span><span>Actor</span><span>,</span> <span>ActorRef</span><span>,</span> <span>ActorProcessingErr</span><span>,</span> <span>RpcReplyPort</span><span>};</span>

<span>pub</span> <span>enum</span> <span>MyFirstActorMessage</span> <span>{</span>
    <span>/// Print&#39;s hello world</span>
    <span>PrintHelloWorld</span><span>,</span>
    <span>/// Replies with how many hello worlds have occurred</span>
    <span>HowManyHelloWorlds</span><span>(</span><span>RpcReplyPort</span><span>&lt;</span><span>u16</span><span>&gt;</span><span>),</span>
<span>}</span>

<span>pub</span> <span>struct</span> <span>MyFirstActor</span><span>;</span>

<span>#[async_trait::async_trait]</span>
<span>impl</span> <span>Actor</span> <span>for</span> <span>MyFirstActor</span> <span>{</span>
    <span>type</span> <span>State</span> <span>=</span> <span>u16</span><span>;</span>
    <span>type</span> <span>Msg</span> <span>=</span> <span>MyFirstActorMessage</span><span>;</span>
    <span>type</span> <span>Arguments</span> <span>=</span> <span>();</span>

    <span>async</span> <span>fn</span> <span>pre_start</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>_myself</span><span>:</span> <span>ActorRef</span><span>&lt;</span><span>Self</span><span>::</span><span>Msg</span><span>&gt;</span><span>,</span> <span>_arguments</span><span>:</span> <span>Self</span><span>::</span><span>Arguments</span><span>)</span>
        <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>::</span><span>State</span><span>,</span> <span>ActorProcessingErr</span><span>&gt;</span>
    <span>{</span>
        <span>Ok</span><span>(</span><span>0</span><span>)</span>
    <span>}</span>

    <span>async</span> <span>fn</span> <span>handle</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>_myself</span><span>:</span> <span>ActorRef</span><span>&lt;</span><span>Self</span><span>::</span><span>Msg</span><span>&gt;</span><span>,</span> <span>message</span><span>:</span> <span>Self</span><span>::</span><span>Msg</span><span>,</span> <span>state</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Self</span><span>::</span><span>State</span><span>)</span> 
        <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(),</span> <span>ActorProcessingErr</span><span>&gt;</span>
    <span>{</span>
        <span>match</span> <span>message</span> <span>{</span>
            <span>MyFirstActorMessage</span><span>::</span><span>PrintHelloWorld</span> <span>=&gt;</span> <span>{</span>
                <span>println!</span><span>(</span><span>&#34;Hello world!&#34;</span><span>);</span>
                <span>*</span><span>state</span> <span>+=</span> <span>1</span><span>;</span>
            <span>}</span>
            <span>MyFirstActorMessage</span><span>::</span><span>HowManyHelloWorlds</span><span>(</span><span>reply</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>if</span> <span>reply</span><span>.send</span><span>(</span><span>*</span><span>state</span><span>)</span><span>.is_err</span><span>()</span> <span>{</span>
                    <span>println!</span><span>(</span><span>&#34;Listener dropped their port before we could reply&#34;</span><span>);</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>Ok</span><span>(())</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>There’s a bit to unpack here, so let’s start with the basics.</p>

<ol>
  <li>We changed the type of the <code>Actor::State</code> to be a <code>u16</code> so that the actor could maintain some internal state which is the count of the number of times it’s printed “Hello world”</li>
  <li>We changed the hello-world message handling to increment the state every time it prints</li>
  <li>We added a new message type <code>MyFirstActorMessage::HowManyHelloWorlds</code> which has an argument of type <code>RpcReplyPort</code>. This is one of the primary ways actors can inter-communicate, via remote procedure calls. This call is a message which provides the response channel (the “port”) as an argument, so the receiver doesn’t need to know who asked. We’ll look at how we construct this in a bit</li>
  <li>We added a hander match arm for this message type, which sends the reply back when requested.</li>
</ol>

<h3 id="running-a-stateful-sample">Running a stateful sample</h3>

<p>Very similar to the non-stateful example, we’ll wire it up as such!</p>

<div><div><pre><code><span>#[tokio::main]</span>
<span>async</span> <span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>// Build an ActorRef along with a JoinHandle which lives for the life of the </span>
    <span>// actor. Most of the time we drop this handle, but it&#39;s handy in the </span>
    <span>// main function to wait for clean actor shut-downs (all stop handlers will</span>
    <span>// have completed)</span>
    <span>let</span> <span>(</span><span>actor</span><span>,</span> <span>actor_handle</span><span>)</span> <span>=</span> 
        <span>Actor</span><span>::</span><span>spawn</span><span>(</span><span>None</span><span>,</span> <span>MyFirstActor</span><span>,</span> <span>())</span>
            <span>.await</span>
            <span>.expect</span><span>(</span><span>&#34;Actor failed to start&#34;</span><span>);</span>
    
    <span>for</span> <span>_i</span> <span>in</span> <span>0</span><span>..</span><span>10</span> <span>{</span>
        <span>// Sends a message, with no reply</span>
        <span>actor</span><span>.cast</span><span>(</span><span>MyFirstActorMessage</span><span>::</span><span>PrintHelloWorld</span><span>)</span>
            <span>.expect</span><span>(</span><span>&#34;Failed to send message to actor&#34;</span><span>);</span>
    <span>}</span>

    <span>let</span> <span>hello_world_count</span> <span>=</span> 
        <span>ractor</span><span>::</span><span>call_t!</span><span>(</span><span>actor</span><span>,</span> <span>MyFirstActorMessage</span><span>::</span><span>HowManyHelloWorlds</span><span>,</span> <span>100</span><span>)</span>
        <span>.expect</span><span>(</span><span>&#34;RPC failed&#34;</span><span>);</span>
    
    <span>println!</span><span>(</span><span>&#34;Actor replied with {} hello worlds!&#34;</span><span>,</span> <span>hello_world_count</span><span>);</span>

    <span>// Cleanup</span>
    <span>actor</span><span>.stop</span><span>(</span><span>None</span><span>);</span>
    <span>actor_handle</span><span>.await</span><span>.unwrap</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p><strong>WHOA</strong> what is <code>call_t!</code>?! That’s a handy macro which constructs our RPC call for us! There’s are three macro variants to ease development use for actor messaging</p>

<ol>
  <li><code>cast!</code> - alias of <code>actor.cast(MESG)</code>, simply send a message to the actor non-blocking</li>
  <li><code>call!</code> - alias of <code>actor.call(|reply| MESG(reply))</code> which builds our message for us without having to provide a lambda function to take the reply port as an argument to construct the message type. We don’t need to actually build &amp; wait on the port, the RPC functionality will do that for us.</li>
  <li><code>call_t!</code> - Same as <code>call!</code> but with a timeout argument</li>
</ol>

<p>Checkout <a href="https://docs.rs/ractor/latest/ractor/macro.call.html">docs.rs on RPCs</a> for more detailed information on these macros.</p>

<p>In this brief example, we’re having our actor send our 10 messages, and then sending a final query message to read
the current count and print it. We’re additionally giving it 100ms to execute (hence the use of <code>call_t!</code>) or return
a timeout result.</p>

        
      </section>

      

      

      
    </div></div>
  </body>
</html>
