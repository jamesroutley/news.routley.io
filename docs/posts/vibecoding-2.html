<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2026/01/20/vibecoding-2.html">Original</a>
    <h1>Vibecoding #2</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <header>
          
          <time datetime="2026-01-20">Jan 20, 2026</time>
        </header>
        <p>
          I feel like I got substantial value out of Claude today, and want to
          document it. I am at the tail end of AI adoption, so I don’t expect to
          say anything particularly useful or novel. However, I am constantly
          complaining about the lack of boring AI posts, so it’s only proper if
          I write one.
        </p>
        <section id="Problem-Statement">
          <h2><a href="#Problem-Statement">Problem Statement</a></h2>
          <p>
            At TigerBeetle, we are big on
            <a href="https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/ARCHITECTURE.md#simulation-testing">deterministic simulation testing</a>. We even use it
            <a href="https://tigerbeetle.com/blog/2025-11-28-tale-of-four-fuzzers/#fuzzer-5-can-i-count-no">to track performance</a>, to some degree. Still, it is crucial to
            verify performance numbers on a real cluster in its natural
            high-altitude habitat.
          </p>
          <p>
            To do that, you need to procure six machines in a cloud, get your
            custom version of <code>tigerbeetle</code>
            binary on them, connect cluster’s replicas together and hit them
            with load. It feels like, quarter of a century into the third
            millennium, “run stuff on six machines” should be a problem just a
            notch harder than opening a terminal and typing <code>ls</code>, but
            I personally don’t know how to solve it without wasting a day. So, I
            spent a day vibecoding my own square wheel.
          </p>
          <p>
            The <em>general</em> shape of the problem is that I want to spin a
            fleet of ephemeral machines with given specs on demand and run
            ad-hoc commands in a SIMD fashion on them. I don’t want to manually
            type slightly different commands into a six-way terminal split, but
            I also do want to be able to ssh into a specific box and poke it
            around.
          </p>
        </section>
        <section id="Solution">
          <h2><a href="#Solution">Solution</a></h2>
          <p>My idea for the solution comes from these three sources:</p>
          <ul>
            <li>
              <a href="https://github.com/catern/rsyscall">https://github.com/catern/rsyscall</a>
            </li>
            <li>
              <a href="https://peter.bourgon.org/blog/2011/04/27/remote-development-from-mac-to-linux.html">https://peter.bourgon.org/blog/2011/04/27/remote-development-from-mac-to-linux.html</a>
            </li>
            <li>
              <a href="https://github.com/dsherret/dax">https://github.com/dsherret/dax</a>
            </li>
          </ul>
          <p>
            The big idea of <code>rsyscall</code> is that you can program
            distributed system in direct style. When programming locally, you do
            things by issuing syscalls:
          </p>

          <figure>
            <pre><code><span><span>const</span> fd = open(<span>&#34;/etc/passwd&#34;</span>);</span></code></pre>
          </figure>
          <p>
            This API works for doing things on remote machines, if you specify
            which machine you want to run the syscall on:
          </p>

          <figure>
            <pre><code><span><span>const</span> fd_local = open(.host, <span>&#34;/etc/passwd&#34;</span>);</span>
<span><span>const</span> fd_cloud = open(.{.addr = <span>&#34;1.2.3.4&#34;</span>}, <span>&#34;/etc/passwd&#34;</span>);</span></code></pre>
          </figure>
          <p>
            Direct manipulation is the most natural API, and it pays to extend
            it over the network boundary.
          </p>
          <hr/>
          <p>
            Peter’s post is an application of a similar idea to a narrow,
            mundane task of developing on Mac and testing on Linux. Peter
            suggests two scripts:
          </p>
          <p>
            <code>remote-sync</code> synchronizes a local and remote projects.
            If you run <code>remote-sync</code> inside <code>~/p/tb</code>
            folder, then <code>~/p/tb</code> materializes on the remote machine.
            <code>rsync</code> does the heavy lifting, and the wrapper script
            implements <code>DWIM</code> behaviors.
          </p>
          <p>
            It is typically followed by
            <span><code>remote-run some --command</code>,</span>
            which runs command on the remote machine in the matching directory,
            forwarding output back to you.
          </p>
          <p>
            So, when I want to test local changes to <code>tigerbeetle</code> on
            my Linux box, I have roughly the following shell session:
          </p>

          <figure>
            <pre><code><span><span>$</span> cd ~/p/tb/work</span>
<span><span>$</span> code . # hack here</span>
<span><span>$</span> remote-sync</span>
<span><span>$</span> remote-run ./zig/zig build test</span></code></pre>
          </figure>
          <p>
            The killer feature is that shell-completion works. I first type the
            command I want to run, taking advantage of the fact that local and
            remote commands are the same, paths and all, then hit <code>^A</code> and prepend <code>remote-run</code> (in reality, I have
            <code>rr</code> alias that combines sync&amp;run).
          </p>
          <p>
            The big thing here is not the commands per se, but the shift in the
            mental model. In a traditional ssh &amp; vim setup, you have to
            juggle two machines with a separate state, the local one and the
            remote one. With <code>remote-sync</code>, the state is the same
            across the machines, you only choose whether you want to run
            commands here or there.
          </p>
          <p>
            With just two machines, the difference feels academic. But if you
            want to run your tests across
            <em>six</em> machines, the ssh approach fails — you don’t want to
            re-vim your changes to source files six times, you really do want to
            separate the place where the code is edited from the place(s) where
            the code is run. This is a general pattern — if you are not sure
            about a particular aspect of your design, try increasing the
            cardinality of the core abstraction from 1 to 2.
          </p>
          <hr/>
          <p>
            The third component, <code>dax</code> library, is pretty mundane —
            just a JavaScript library for shell scripting. The notable aspects
            there are:
          </p>
          <ul>
            <li>
              <p>
                JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literals</a>, which allow implementing command
                interpolation in a safe by construction way. When processing
                <span><code> $`ls ${paths}`</code>,</span>
                a string is never materialized, it’s arrays all the way to the
                <code>exec</code> syscall (
                <a href="https://matklad.github.io/2021/07/30/shell-injection.html">more on the topic</a>).
              </p>
            </li>
            <li>
              <p>
                JavaScript’s async/await, which makes managing <em>concurrent</em> processes (local or remote) natural:
              </p>

              <figure>
                <pre><code><span><span>await</span> <span>Promise</span>.<span>all</span>([</span>
<span>  $<span>`sleep 5`</span>,</span>
<span>  $<span>`remote-run sleep 5`</span>,</span>
<span>]);</span></code></pre>
              </figure>
            </li>
            <li>
              <p>
                Additionally, deno specifically
                <a href="https://docs.deno.com/api/deno/~/Deno.CommandOptions.detached">valiantly strives</a>
                to impose process-level structured concurrency, ensuring that no
                processes spawned by the script outlive the script itself,
                unless explicitly marked <code>detached</code> — a
                <a href="https://github.com/oconnor663/duct.py/blob/0764961a8c799873a9375d4100ae9ddbee624594/gotchas.md#killing-grandchild-processes">sour</a>
                <a href="http://catern.com/process.html#orgaf6e157">spot</a> of
                UNIX.
              </p>
            </li>
          </ul>
          <hr/>
          <p>
            Combining the three ideas, I now have a deno script, called <code>box</code>, that provides a multiplexed interface for running
            ad-hoc code on ad-hoc clusters.
          </p>
          <p>A session looks like this:</p>

          <figure>
            <pre><code><span></span>
<span><span>$</span> cd ~/p/tb/work</span>
<span><span>$</span> git status --short</span>
<span><span> M src/lsm/forest.zig</span></span>
<span><span></span></span>
<span></span>
<span><span>$</span> box create 3</span>
<span><span>108.129.172.206,52.214.229.222,3.251.67.25</span></span>
<span><span></span></span>
<span><span>$</span> box list</span>
<span><span>0 108.129.172.206</span></span>
<span><span>1 52.214.229.222</span></span>
<span><span>2 3.251.67.25</span></span>
<span><span></span></span>
<span></span>
<span><span>$</span> box sync 0,1,2</span>
<span><span></span></span>
<span></span>
<span><span>$</span> box run 0 pwd</span>
<span><span>/home/alpine/p/tb/work</span></span>
<span><span></span></span>
<span><span>$</span> box run 0 ls</span>
<span><span>CHANGELOG.md  LICENSE       README.md     build.zig</span></span>
<span><span>docs/         src/          zig/</span></span>
<span><span></span></span>
<span></span>
<span><span>$</span> box run 0,1,2 ./zig/download.sh</span>
<span><span>Downloading Zig 0.14.1 release build...</span></span>
<span><span>Extracting zig-x86_64-linux-0.14.1.tar.xz...</span></span>
<span><span>Downloading completed (/home/alpine/p/tb/work/zig/zig)!</span></span>
<span><span>Enjoy!</span></span>
<span><span></span></span>
<span></span>
<span><span>$</span> box run 0,1,2 \</span>
<span>    ./zig/zig build -Drelease -Dgit-commit=$(git rev-parse HEAD)</span>
<span><span></span></span>
<span></span>
<span><span>$</span> box run 0,1,2 \</span>
<span>    ./zig-out/bin/tigerbeetle format \</span>
<span>    --cluster=0 --replica=?? --replica-count=3 \</span>
<span>    0_??.tigerbeetle</span>
<span><span>2026-01-20 19:30:15.947Z info(io): opening &#34;0_0.tigerbeetle&#34;...</span></span>
<span><span></span></span>
<span></span>
<span><span>$</span> box destroy 0,1,2</span></code></pre>
          </figure>
          <p>
            I like this! Haven’t used in anger yet, but this is something I
            wanted for a long time, and now I have it
          </p>
        </section>
        <section id="Structure">
          <h2><a href="#Structure">Structure</a></h2>
          <p>
            The problem with implementing above is that I have zero practical
            experience with modern cloud. I only created my AWS account today,
            and just looking at the console interface ignited the urge to
            re-read The Castle. Not my cup of pu-erh. But I had a hypothesis
            that AI should be good at wrangling baroque cloud API, and it mostly
            held.
          </p>
          <p>
            I started with a couple of paragraphs of rough, super high-level
            description of what I want to get. Not a specification at all, just
            a general gesture towards unknown unknowns. Then I asked ChatGPT to
            expand those two paragraphs into a more or less complete spec to
            hand down to an agent for implementation.
          </p>
          <p>
            This phase surfaced a bunch of unknowns for me. For example, I
            wasn’t thinking at all that I somehow need to identify machines,
            ChatGPT suggested using random hex numbers, and I realized that I do
            need 0,1,2 naming scheme to concisely specify batches of machines.
            While thinking about this, I realized that sequential numbering
            scheme also has an advantage that I <em>can’t</em> have two
            concurrent clusters running, which is a desirable property for my
            use-case. If I forgot to shutdown a machine, I’d rather get an error
            on trying to re-create a machine with the same name, then to
            silently avoid the clash. Similarly, turns out the questions of
            permissions and network access rules are something to think about,
            as well as what region and what image I need.
          </p>
          <p>
            With the spec document in hand, I turned over to Claude code for
            actual implementation work. The first step was to further refine the
            spec, asking Claude if anything is unclear. There were couple of
            interesting clarifications there.
          </p>
          <p>
            First, the original ChatGPT spec didn’t get what I meant with my
            “current directory mapping” idea, that I want to materialize a local
            <code>~/p/tb/work</code> as remote <code>~/p/tb/work</code>, even if
            <code>~</code> are different. ChatGPT generated an incorrect
            description <em>and</em> an incorrect example. I manually corrected
            example, but wasn’t able to write a concise and correct description.
            Claude fixed that working from the example. I feel like I need to
            internalize this more — for current crop of AI, examples seem to be
            far more valuable than rules.
          </p>
          <p>
            Second, the spec included my desire to auto-shutdown machines once I
            no longer use them, just to make sure I don’t forget to turn the
            lights off when leaving the room. Claude grilled me on what
            <em>precisely</em> I want there, and I asked it to DWIM the thing.
          </p>
          <p>
            The spec ended up being 6KiB of English prose. The final
            implementation was 14KiB of TypeScript. I wasn’t keeping the spec
            and the implementation perfectly in sync, but I think they ended up
            pretty close in the end. Which means that prose specifications are
            somewhat more compact than code, but not
            <em>much</em> more compact.
          </p>
          <p>
            My next step was to try to just one-shot this. Ok, this is
            embarrassing, and I usually avoid swearing in this blog, but I just
            typoed that as “one-shit”, and, well, that is one flavorful
            description I won’t be able to improve upon. The result was just not
            good (more on why later), so I almost immediately decided to throw
            it away and start a more incremental approach.
          </p>
          <p>
            In my <a href="https://matklad.github.io/2025/08/31/vibe-coding-terminal-editor.html">previous vibe-post</a>, I noticed that LLM are good at closing the
            loop. A variation here is that LLMs are good at producing results,
            and not necessarily good code. I am pretty sure that, if I had let
            the agent to iterate on the initial script and actually <em>run</em>
            it against AWS, I would have gotten something working. I didn’t want
            to go that way for three reasons:
          </p>
          <ul>
            <li>
              Spawning VMs takes time, and that significantly reduces the
              throughput of agentic iteration.
            </li>
            <li>
              No way I let the agent run with a real AWS account, given that AWS
              doesn’t have a fool-proof way to cap costs.
            </li>
            <li>
              I am fairly confident that this script will be a part of my
              workflow for at least several years, so I care <em>more</em> about
              long-term code maintenance, than immediate result.
            </li>
          </ul>
          <p>
            And, as I said, the code didn’t feel good, for these specific
            reasons:
          </p>
          <ul>
            <li>
              It wasn’t the code that I would have written, it lacked my
              character, which made it hard for me to understand it at a glance.
            </li>
            <li>
              The code lacked any character whatsoever. It could have worked, it
              wasn’t “naively bad”, like the first code you write when you are
              learning programming, but there wasn’t anything good there.
            </li>
            <li>
              I never know what the code <em>should</em> be up-front. I don’t
              design solutions, I discover them in the process of refactoring.
              Some of my best work was spending a quiet weekend rewriting large
              subsystems implemented before me, because, with <em>an</em>
              implementation at hand, it was possible for me to see the actual,
              beautiful core of what <em>needs</em> to be done. With a
              slop-dump, I just don’t get to even see what could be wrong.
            </li>
            <li>
              In particular, while you are working the code (as in “wrought
              iron”), you often go back to requirements and change them.
              Remember that ambiguity of my request to “shut down idle cluster”?
              Claude tried to DWIM and created some horrific mess of bash
              scripts, timestamp files, PAM policy and systemd units. But the
              right answer there was “lets maybe not have that feature?” (in
              contrast, simply shutting the machine down after 8 hours is a
              one-liner).
            </li>
          </ul>
          <p>
            The incremental approach worked much better, Claude is good at
            filling-in the blanks. The very first thing I did for <code>box-v2</code> was manually typing-in:
          </p>

          <figure>
            <pre><code><span><span>type</span> <span>CLI</span> =</span>
<span>  | <span>CLICreate</span></span>
<span>  | <span>CLIDestroy</span></span>
<span>  | <span>CLIList</span></span>
<span>  | <span>CLISync</span></span>
<span></span>
<span><span>type</span> <span>BoxList</span> = <span>string</span>[];</span>
<span><span>type</span> <span>CLICreate</span> = { <span>tag</span>: <span>&#34;create&#34;</span>; <span>count</span>: <span>number</span> };</span>
<span><span>type</span> <span>CLIDestroy</span> = { <span>tag</span>: <span>&#34;destroy&#34;</span>; <span>boxes</span>: <span>BoxList</span> };</span>
<span><span>type</span> <span>CLIList</span> = { <span>tag</span>: <span>&#34;list&#34;</span> };</span>
<span><span>type</span> <span>CLISync</span> = { <span>tag</span>: <span>&#34;sync&#34;</span>; <span>boxes</span>: <span>BoxList</span>; };</span>
<span></span>
<span><span>function</span> <span>fatal</span>(<span>message: <span>string</span></span>): <span>never</span> {</span>
<span>  <span>console</span>.<span>error</span>(message);</span>
<span>  <span>Deno</span>.<span>exit</span>(<span>1</span>);</span>
<span>}</span>
<span></span>
<span><span>function</span> <span>CLIParse</span>(<span>args: <span>string</span>[]</span>): <span>CLI</span> {</span>
<span></span>
<span>}</span></code></pre>
          </figure>
          <p>
            Then I asked Claude to complete the <code>CLIParse</code> function,
            and I was happy with the result. Note
            <a href="https://haskellforall.com/2026/01/prompting-101-show-dont-tell"><em>Show, Don’t Tell</em></a>
          </p>
          <p>
            I am not <em>asking</em> Claude to avoid throwing an exception and
            fail fast instead. I just give <code>fatal</code>
            function, and it code-completes the rest.
          </p>
          <p>
            I can’t say that the code <em>inside</em> <code>CLIParse</code> is
            top-notch. I’d probably written something more spartan. But the
            important part is that, at this level, I don’t care. The abstraction
            for parsing CLI arguments feel right to me, and the details I can
            always fix later. This is how this overall vibe-coding session
            transpired — I was providing structure, Claude was painting by the
            numbers.
          </p>
          <p>
            In particular, with that CLI parsing structure in place, Claude had
            little problem adding new subcommands and new arguments in a
            satisfactory way. The only snag was that, when I asked to add an
            optional path to <code>sync</code>, it went with <code>string |
              null</code>, while I strongly prefer <code>string |
              undefined</code>. Obviously, its better to pick your null in
            JavaScript and stick with it. The fact that <code>undefined</code>
            is unavoidable predetermines the winner. Given that the argument was
            added as an incremental small change, course-correcting was trivial.
          </p>
          <p>
            The null vs undefined issue perhaps illustrates my complaint about
            the code lacking character.
            <code>| null</code> is the default non-choice. <code>|
              undefined</code> is an insight, which I personally learned from VS
            Code LSP implementation.
          </p>
          <p>
            The hand-written skeleton/vibe-coded guts worked not only for the
            CLI. I wrote
          </p>

          <figure>
            <pre><code><span><span>async</span> <span>function</span> <span>main</span>(<span></span>) {</span>
<span>  <span>const</span> cli = <span>CLIParse</span>(<span>Deno</span>.<span>args</span>);</span>
<span></span>
<span>  <span>if</span> (cli.<span>tag</span> === <span>&#34;create&#34;</span>) <span>return</span> <span>await</span> <span>mainCreate</span>(cli.<span>count</span>);</span>
<span>  <span>if</span> (cli.<span>tag</span> === <span>&#34;destroy&#34;</span>) <span>return</span> <span>await</span> <span>mainDestroy</span>(cli.<span>boxes</span>);</span>
<span>  ...</span>
<span>}</span>
<span></span>
<span><span>async</span> <span>function</span> <span>mainDestroy</span>(<span>boxes: <span>string</span>[]</span>) {</span>
<span>  <span>for</span> (<span>const</span> box <span>of</span> boxes) {</span>
<span>    <span>await</span> <span>instanceDestroy</span>(box);</span>
<span>  }</span>
<span>}</span>
<span></span>
<span><span>async</span> <span>function</span> <span>instanceDestroy</span>(<span>id: <span>string</span></span>) {</span>
<span></span>
<span>}</span></code></pre>
          </figure>
          <p>
            and then asked Claude to write the body of a particular function
            according to the SPEC.md.
          </p>
          <p>
            Unlike with the CLI, Claude wasn’t able to follow this pattern
            itself. With one example it’s not obvious, but the overall structure
            is that <code>instanceXXX</code> is the AWS-level operation on a
            single box, and
            <code>mainXXX</code> is the CLI-level control flow that deals with
            looping and parallelism. When I asked Claude to implement <code>box
              run</code>, <em>without</em> myself doing the <code>main</code> /
            <code>instance</code> split, Claude failed to noticed it and needed
            a course correction.
          </p>
        </section>
        <section id="Implementation">
          <h2><a href="#Implementation">Implementation</a></h2>
          <p>
            <em>However</em>, Claude was <em>massively</em> successful with the
            actual logic. It would have taken me hours to acquire specific,
            non-reusable knowledge to write:
          </p>

          <figure>
            <pre><code><span></span>
<span><span>const</span> instanceMarketOptions = <span>JSON</span>.<span>stringify</span>({</span>
<span>  <span>MarketType</span>: <span>&#34;spot&#34;</span>,</span>
<span>  <span>SpotOptions</span>: { <span>InstanceInterruptionBehavior</span>: <span>&#34;terminate&#34;</span> },</span>
<span>});</span>
<span><span>const</span> tagSpecifications = <span>JSON</span>.<span>stringify</span>([</span>
<span>  { <span>ResourceType</span>: <span>&#34;instance&#34;</span>, <span>Tags</span>: [{ <span>Key</span>: moniker, <span>Value</span>: id }] },</span>
<span>]);</span>
<span></span>
<span><span>const</span> result = <span>await</span> $<span>`aws ec2 run-instances \</span></span>
<span><span>  --image-id <span>${image}</span> \</span></span>
<span><span>  --instance-type <span>${instanceType}</span> \</span></span>
<span><span>  --key-name <span>${moniker}</span> \</span></span>
<span><span>  --security-groups <span>${moniker}</span> \</span></span>
<span><span>  --instance-market-options <span>${instanceMarketOptions}</span> \</span></span>
<span><span>  --user-data <span>${userDataBase64}</span> \</span></span>
<span><span>  --tag-specifications <span>${tagSpecifications}</span> \</span></span>
<span><span>  --output json`</span>.<span>json</span>();</span>
<span></span>
<span><span>const</span> instanceId = result.<span>Instances</span>[<span>0</span>].<span>InstanceId</span>;</span>
<span></span>
<span></span>
<span><span>await</span> $<span>`aws ec2 wait instance-status-ok --instance-ids <span>${instanceId}</span>`</span>;</span></code></pre>
          </figure>
          <p>
            I want to be careful — I can’t vouch for <em>correctness</em> and
            especially <em>completeness</em> of the above snippet. However,
            given that the nature of the problem is such that I can just run the
            code and see the result, I am fine with it. If I were writing this
            myself, trial-and-error would totally be my approach as well.
          </p>
          <p>
            Then there’s synthesis — with several instance commands implemented,
            I noticed that many started with querying AWS to resolve symbolic
            machine name, like “1”, to the AWS name/IP. At that point I realized
            that resolving symbolic names is a fundamental part of the problem,
            and that it should only happen once, which resulting in the
            following refactored shape of the code:
          </p>

          <figure>
            <pre><code><span><span>async</span> <span>function</span> <span>main</span>(<span></span>) {</span>
<span>  <span>const</span> cli = <span>CLIParse</span>(<span>Deno</span>.<span>args</span>);</span>
<span>  <span>const</span> instances = <span>await</span> <span>instanceMap</span>();</span>
<span></span>
<span>  <span>if</span> (cli.<span>tag</span> === <span>&#34;create&#34;</span>) <span>return</span> <span>await</span> <span>mainCreate</span>(instances, cli.<span>count</span>);</span>
<span>  <span>if</span> (cli.<span>tag</span> === <span>&#34;destroy&#34;</span>) <span>return</span> <span>await</span> <span>mainDestroy</span>(instances, cli.<span>boxes</span>);</span>
<span>  ...</span>
<span>}</span></code></pre>
          </figure>
          <p>
            Claude was ok with extracting the logic, but messed up the overall
            code layout, so the final code motions were on me. “Context”
            arguments go <em>first</em>, not last, common prefix is more
            valuable than common suffix because of visual alignment.
          </p>
          <p>
            The original “one-shotted” implementation also didn’t do up-front
            querying. This is an example of a shape of a problem I only discover
            when working with code closely.
          </p>
          <hr/>
          <p>
            Of course, the script didn’t work perfectly the first time and we
            needed quite a few iterations on the real machines both to fix
            coding bugs, as well gaps in the spec. That was an interesting
            experience of speed-running rookie mistakes. Claude made naive bugs,
            but was also good at fixing them.
          </p>
          <p>
            For example, when I first tried to <code>box ssh</code> after <code>box create</code>, I got an error. Pasting it into Claude
            immediately showed the problem. Originally, the code was doing
            <span><code>aws ec2 wait
                instance-running</code></span>
            and not
            <span><code>aws ec2 wait
                instance-status-ok</code>.</span>
          </p>
          <p>
            The former checks if instance is logically created, the latter waits
            until the OS is booted. It makes sense that these two exist, and the
            difference is clear (and its also clear that OS booted != SSH demon
            started). Claude’s value here is in providing specific names for the
            concepts I already know to exist.
          </p>
          <p>
            Another fun one was about the disk. I noticed that, while the
            instance had an SSD, it wasn’t actually used. I asked Claude to
            mount it as home, but that didn’t work. Claude immediately asked me
            to run
            <span><code>$ box run 0 cat
                /var/some/unintuitive/long/path.log</code></span>
            and that log immediately showed the problem. This is remarkable! 50%
            of my typical Linux debugging day is wasted not knowing that a
            useful log exists, and the other 50% is for searching for the log I
            know should exist <em>somewhere</em>.
          </p>
          <p>
            After the fix, I lost the ability to SSH. Pasting the error
            immediately gave the answer — by mounting over <code>/home</code>,
            we were overwriting ssh keys configured prior.
          </p>
          <p>
            There were couple of more iterations like that. Rookie mistakes <em>were</em> made, but they were debugged and fixed <em>much</em>
            faster than my personal knowledge allows (and again, I feel that is
            trivia knowledge, rather than deep reusable knowledge, so I am happy
            to delegate it!).
          </p>
          <p>
            It worked satisfactorily in the end, and, what’s more, I am happy to
            maintain the code, at least to the extent that I personally need it.
            Kinda hard to measure productivity boost here, but, given just the
            sheer number of CLI flags required to make this work, I am pretty
            confident that time was saved, even factoring the writing of the
            present article!
          </p>
        </section>
        <section id="Coda">
          <h2><a href="#Coda">Coda</a></h2>
          <p>
            I’ve recently read <em>The Art of Doing Science and Engineering</em>
            by Hamming (of distance and code), and one story stuck with me:
          </p>

          <figure>
            <blockquote>
              <p>
                A psychologist friend at Bell Telephone Laboratories once built
                a machine with about 12 switches and a red and a green light.
                You set the switches, pushed a button, and either you got a red
                or a green light. After the first person tried it 20 times they
                wrote a theory of how to make the green light come on. The
                theory was given to the next victim and they had their 20 tries
                and wrote their theory, and so on endlessly. The stated purpose
                of the test was to study how theories evolved.
              </p>
              <p>
                But my friend, being the kind of person he was, had connected
                the lights to a random source! One day he observed to me that no
                person in all the tests (and they were all high-class Bell
                Telephone Laboratories scientists) ever said there was no
                message. I promptly observed to him that not one of them was
                either a statistician or an information theorist, the two
                classes of people who are intimately familiar with randomness. A
                check revealed I was right!
              </p>
            </blockquote>
          </figure>
        </section>
      </article>
    </div></div>
  </body>
</html>
