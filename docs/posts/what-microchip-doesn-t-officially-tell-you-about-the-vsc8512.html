<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://serd.es/2025/07/04/Switch-project-pt3.html">Original</a>
    <h1>What Microchip doesn&#39;t (officially) tell you about the VSC8512</h1>
    
    <div id="readability-page-1" class="page"><div>
      <section id="main_content">
        <article>
  
  <a href="https://serd.es/2025/07/04/Switch-project-pt3.html">
    <time datetime="2025-07-04T08:00:00-07:00">
        2025-07-04 08:00
    </time>
  </a>
  <p>This is part 3 of my ongoing series about LATENTRED, my project to create an open source 1U managed Ethernet switch
from scratch.</p>

<p>Here’s a quick, or maybe not-so-quick, update about the PHY on the line card and some of my troubles (and solutions).</p>

<p>And probably more internal details than you want to know, but hey - maybe this will be useful to somebody. Not a lot of pretty pictures either. One day I do want to decap one for fun, but I have better things to do with my time than try to fully netlist-extract a large 65nm IC just to figure out some undocumented registers.</p>

<h2 id="background">Background</h2>

<p>I chose the VSC8512 as the PHY for the line card because it had a QSGMII interface (which used much less pins than SGMII), but also (so I thought) had a fully open datasheet with no NDAs required.</p>

<p>Typically I’m used to seeing parts that are either fully NDA’d (with a trivial product brief and no register info etc, or sometimes not even pinout info, public), or fully open. Sometimes I find components with specific documents restricted, but it’s almost always clear that “this document/ref design exists, you can’t get it without an NDA, but we are openly telling you we’re holding it back”.</p>

<p>In my previous post I mentioned that there was no documentation for how to change the SERDES TX equalizer settings on the PHY side of the QSGMII. I opened a support case and Microchip responded saying that additional info was available in the “confidential reference manual” for the part which required an NDA. The rest of the reply was pretty generic and mentioned indirect register access but no specifics.</p>

<p>I was quite annoyed at this, as I had specifically chosen the part believing there was no restricted documentation. Since signing an NDA wasn’t an option, it seemed I had the choice of suboptimal signal integrity or figuring things out from the limited public information. The eye was still reasonably open as-is and my cables and boards didn’t have a ton of insertion loss, so worst case things would probably work with the default TX config.</p>

<p>But why would I settle for bad SI when I could read a bunch of poorly documented code and datasheets deliberately missing details?</p>

<h2 id="what-we-have-to-go-on">What we have to go on</h2>

<p>So, we know there is a confidential reference manual. But there’s a lot of docs available to the public - after all, I was able to make a board, bring up the PHY, and pass packets without it.</p>

<ul>
  <li>VSC8512 datasheet (VMDS-10396). This is 139 pages of meat including what I thought was a complete set of registers.</li>
  <li>VSC8512 hardware design checklist (DS00004697A)</li>
  <li>VSC8504 Serdes6G IBIS-AMI model. This is for the 4-port version of the same PHY but is linked on the product web page; presumably the 04 and 12 use the same IP.</li>
  <li>VSC742x / 85x2 reference design guide (UG1037). This describes a 24-port switch reference design using a SparX-III / Caracal switch ASIC (including 12 integrated PHYs) paired with a VSC85x2. Not a ton interesting here.</li>
  <li>Microchip Ethernet Switch API (MESA), MIT licensed HAL for Microchip/Vitesse PHYs and switches available on GitHub. As you’ll see in a bit, this is an absolute gold mine of information but it’s (perhaps intentionally) not well documented what a lot of the bitfields and APIs do.</li>
</ul>

<h2 id="initial-observations">Initial observations</h2>

<p>It’s pretty easy to see that the VSC8512 is a nerfed switch ASIC. There’s an entire DDR I/O controller that’s unused (over a dozen VDD_IODDR pins you’re instructed to ground, plus a large group of NC pins in the surrounding area). So docs for the un-crippled switch ASIC, which I suspected and later confirmed was the VSC742x, are potentially of interest too.</p>

<p>The IBIS-AMI model included the magic name “Serdes6G”. Searching for this turned up some additional docs, most notably AN3743 (DS00003743A) which purports to be about the VSC74xx / 84xx but seems to be describing something very similar to what’s on the 8512.</p>

<p>Between the various documents I was able to conclude that the VSC8512 is made on an unspecified 65nm process (I should decap one at some point and figure out whose / see what it looks like… Luton first stepping is mentioned as being fabbed at TSMC in <code>vtss_phy_do_page_chk</code> so I suspect the rest are as well).</p>

<p>The SERDES macro was developed by the “German Design Center” (in the Dortmund area, according to some LinkedIn hits from a google search) - interesting to know, but not particularly useful in this context.</p>

<p>The IBIS model describes some very useful parameters. We don’t know how to actually set them yet, but we know they exist, their ranges, and (most importantly) their names:</p>

<ul>
  <li><code>OB_LEV</code>: amplitude / main cursor tap, 0 to 63</li>
  <li><code>OB_PREC</code>: pre-cursor FFE tap, -15 to +15</li>
  <li><code>OB_POST0</code>: post cursor 0 FFE tap, -31 to +31</li>
  <li><code>OB_POST1</code>: post cursor 1 FFE tap, -15 to +15</li>
  <li><code>OB_POL</code>: output invert</li>
  <li><code>OB_SER_H</code>: coarse slew rate adjust (slow/fast)</li>
  <li><code>OB_SER</code>: fine slew rate adjust, 0 to 15</li>
</ul>

<p>These were all critical key words to look for elsewhere in docs and code, and ultimately put me on the track of success.</p>

<p>Of note is that this SERDES offers more knobs on the output driver than most: slew rate control is rare on IOs of this class (most just run as fast as possible all the time), and most TX FFEs only have a single post-cursor tap, while this one has two.</p>

<p>MESA is not super well documented, you have to know what you’re looking for. But there’s a ton of detail once you do.</p>

<p>I already knew that the relevant PHY driver code in MESA was in <code>mepa/vtss/src/phy_1g</code>. The relevant files are <code>vtss_phy.*</code> (main driver) and <code>vtss_phy_init_scripts.*</code> (sequences of canned register writes for configuration in various modes and working around silicon bugs in old silicon steppings).</p>

<p>I had previously looked at the PHY init scripts and grabbed the important register settings out of them for a few things. There was also a microcode patch for an internal 8051 MCU (good to know this exists!) however I didn’t include the microcode patch in my firmware because the D stepping (rev 0x3) of the VSC8512, the only one you can still get, has fixes for most of the errata the patch fixes other than something in 100baseFX mode that I don’t care about.</p>

<p><code>vtss_phy.h</code> has an enum with a bunch of different device families and the VSC8512 is mentioned in a comment as being <code>VTSS_PHY_FAMILY_ATOM</code>. Comments elsewhere refer to it at Atom12. Luton26, Viper, and Elise appear to be very similar as most switch statements take the same path for these parts; Tesla and Nano are also close relatives. The VSC8504 is a Tesla, interestingly - not an Atom - but seems to use the same SERDES or a very close version.</p>

<p>The initialization scripts are in a function called <code>luton26_atom12_revCD_init_script</code> which suggests Luton26 and Atom12 are register and bug-for-bug compatible for most configuration. This makes sense, since Luton26 is the VSC742x and I already suspected Atom12 was a nerfed PHY-only version of the same platform for other reasons (identical pinouts, etc).</p>

<p>This adds VMDS-10393, the VSC742x datasheet, to our reading list as something potentially worth looking at.</p>

<p>Interestingly, the VSC742x has a MIPS core not an 8051. It’s possible the comments are wrong and this isn’t actually an 8051 (I didn’t try disassembling the microcode patch); it’s also possible that there is an 8051 core that’s separate from the MIPS. Maybe in the PHY fuse configuration of the die, the MIPS is disabled and the 8051 provides all of the minimal management infrastructure from a ROM or something.</p>

<h2 id="known-register-interfaces">Known register interfaces</h2>

<p>The VSC8512 responds to 12 consecutive MDIO addresses, one per PHY (base address selected by strap pins). On the LATENTRED line card, one PHY is mapped at MDIO address 0-11 and the second at 12-23. Some operations are global and should be addressed to PHY 0 within the device, while others are per-PHY and should be addressed to the appropriate port index.</p>

<p>The VSC8512 has three separate documented register interfaces, all accessed via MDIO (there’s one more that we’ll get to later).</p>

<ul>
  <li>The IEEE standard MDIO register space from 0x00 to 0x0f. This works as you’d expect with any other PHY.</li>
  <li>IEEE standard indirect MMD register access using registers 0xd and 0xe. This works as you’d expect, but is only used for accessing five registers for EEE (energy efficient Ethernet).</li>
  <li>Vendor defined registers, selected by a page/bank index in register 0x1f. Note that the bank selector remaps the entire 31-register address space, i.e. when the page selector is not 0x0000 the IEEE standard registers are not available.</li>
</ul>

<p>There are five documented pages and two known undocumented ones.</p>

<h3 id="page-0x0000-base--main-datasheet-51--52">Page 0x0000: Base / Main (datasheet 5.1 / 5.2)</h3>

<p>There seems to be a formatting error in the doc (somebody accidentally made register 0x17 a level 2 heading instead of level 3) so the PDF ToC and section numbering is borked.</p>

<p>This page includes the IEEE standard registers and some vendor specific ones related to baseT extended status and error detection.</p>

<p>Other features and tidbits of note:</p>
<ul>
  <li>Chicken bits in register 0x12 for things like disabling MDI-X, bypassing the 100baseTX 4b5b coder, and disabling a workaround for problems when the device is paired with a specific old Broadcom PHY.</li>
  <li>Error counters in 0x13 - 0x15 for detecting various link faults</li>
  <li>SFP vs baseT selectors in 0x17</li>
  <li>Jumbo frame enable in 0x18</li>
  <li>Interrupt control and status in 0x19 / 0x1a</li>
  <li>Auxiliary control/status in 0x1c. This lets you detect things like MDI vs MDI-X state, pair swap, polarity inversion, etc. It also provides fields containing duplex and speed state duplicating those in IEEE standard register 0, but reporting the actually negotiated speed/duplex. (Fun tidbit, register 0 readback is not well defined in the spec! Some PHYs like the KSZ9031 let you read back the current negotiated state, while others like the VSC8512 always read the last value written)</li>
</ul>

<h3 id="page-0x0001-extended-1-datasheet-53">Page 0x0001: Extended 1 (datasheet 5.3)</h3>

<p>This page mostly has config for the low speed (1 Gbps) SERDES used for gigabit SFP applications. I’m not using these on the switch, so I’m pretty much ignoring them.</p>

<p>There’s also a built in test pattern packet generator in register 0x1d/1e which is cool, although since I’m driving the PHYs from an FPGA I’d rather build my own test pattern generator in fabric so I can seed them with a PRBS or something to make validation easier.</p>

<h3 id="page-0x0002-extended-2-datasheet-54">Page 0x0002: Extended 2 (datasheet 5.4)</h3>

<p>This page contains some fine-tuning registers for adjusting baseT signal amplitude and linearity to compensate for performance of various magnetics. If/when I end up doing full 1000baseT signal quality compliance (this would be a nice feature to add to ngscopeclient eventually) I’ll likely use these.</p>

<p>There’s also a few other miscellaneous settings related to EEE.</p>

<h3 id="page-0x0003-extended-3-datasheet-55">Page 0x0003: Extended 3 (datasheet 5.5)</h3>

<p>This page contains config and status related to the serial MAC interface (SGMII / QSGMII). Note that actual SERDES PHY controls such as equalizers and inversion are not here.</p>

<h3 id="page-0x0010-gpio--mcu-datasheet-56">Page 0x0010: GPIO / MCU (datasheet 5.6)</h3>

<p>This page is a fun one.</p>

<p>There’s a bunch of “boring” registers related to the GPIO pins, an I2C mux intended for external SFPs, recovered clock debug outputs, etc.</p>

<p>But… there’s also register 0x12 which is basically a mailbox to the internal MCU. We’ll be talking a lot more about this later on, but there’s lots of fun to be had here.</p>

<h3 id="page-0x2a30-test-undocumented">Page 0x2a30: Test (undocumented)</h3>

<p>I have no idea what this does, it’s not mentioned in the datasheet at all and the code has no comments or details whatsoever. Probably chicken bits. I haven’t tried poking any of the values to see if I can see any difference in behavior.</p>

<p>MESA has a function <code>luton26_atom12_revCD_init_script</code> that writes the following values:</p>

<ul>
  <li>0x14 = 0x4420</li>
  <li>0x18 = 0x0c00</li>
  <li>0x9 = 0x18c8</li>
  <li>0x8: set MSB, leave other bits unchanged</li>
  <li>0x5 = 0x1320</li>
  <li>After rest of init, clear MSB of 0x8</li>
</ul>

<h3 id="page-0x52b5-token-ring--black-magic-undocumented">Page 0x52b5: Token Ring / black magic (undocumented)</h3>

<p>No idea what this does either. Datasheet doesn’t mention it, most MESA code just calls it TR, but a few bits call it Token Ring.</p>

<p>I can’t imagine that is correct, there’s no reason for a 1984-era protocol to be present in a modern Ethernet PHY. Maybe somebody saw the acronym and filled it in wrong? IDK.</p>

<p>Anyway, the PHY init script has a big block of triplet writes to 0x12, 0x11, 0x10, always in that order. No comments or clues as to what it does, other than that 10baseT vs 10baseTe mode require a different sequence in one spot, and the final write is commented as “Improve 100BASE-TX link startup robustness to address interop issue”.</p>

<p>Guessing these are chicken bits of some sort too, but who knows.</p>

<p>EDIT: <code>vtss_phy_optimize_receiver_init</code> mentions some stuff about registers called <code>half_comp_en</code> and <code>half_adc</code>. There’s also some stuff in <code>vtss_phy_power_opt</code> that someone might want to dig into eventually. Seems to be some sort of link training to save power by reducing TX amplitude or something? <code>vtss_phy_optimize_receiver_reconfig</code> talks about <code>vga_state</code> as well.</p>

<p>Very rough conjecture and not tested in the slightest:</p>
<ul>
  <li>0x12: read pointer</li>
  <li>0x11: read/write data register</li>
  <li>0x10: write pointer</li>
</ul>

<p><code>vtss_phy_debug_tr_regdump_print</code> may also be worth looking at, it suggests that 0x10 might be a read pointer too?</p>

<h2 id="mcb-macro-configuration-bus">MCB (Macro Configuration Bus)</h2>

<p>The VSC742x datasheet goes into a little more detail about this - basically it’s a separate bus used for configuring the SERDES6G.</p>

<p>There’s no direct access to the MCB on the VSC8512 from the outside. Instead, you issue a command to the MCU to read all MCB registers from a SERDES macro into a working buffer (“PRAM”, “cfg_buf”, or “shadow registers”), use peek/poke commands to manipulate this buffer, then issue another command to write it back to one or more SERDES macros.</p>

<h2 id="understanding-the-mcu-interface">Understanding the MCU interface</h2>

<p>So now we’re back to trying to understanding the MCU interface a bit more to try and figure out how to do fun things with it (and to solve my original problem of configuring the equalizer).</p>

<p>Starting with the SERDES register field names, most notably <code>post0</code> as this is the one I care about the most (the first post cursor tap provides de-emphasis to open the eye up) I started searching through the MESA code for anything that looked relevant.</p>

<p>There’s a function <code>vtss_phy_cfg_ob_post0</code> in <code>vtss_phy_1g_api.h</code>, with an accurate-ish yet useless comment “Debug function for setting the ob post0 patch”. You’d never know what this did from the prototype or comment if you didn’t dig as deep into the platform as I had, although looking at the source and seeing some of the implementation gated behind a <code>#ifdef VTSS_FEATURE_SERDES_MACRO_SETTINGS</code> might give a hint. Interestingly another part of the headers say “do not change” the post1 tap from the power-on default of zero, perhaps there’s a silicon bug around this?</p>

<p>This function does some minimal error checking, then calls <code>vtss_phy_cfg_ob_post0_private</code> which has a slightly less useless comment “Function to set the ob_post0 parameter after configuring the 6G macro for QSGMII for ATOM12”. After some more validation and checking that we are in fact on an Atom12 (there’s a separate code path for Tesla)…</p>

<p>It just does a big pile of reads and writes to register 0x12 in the GPIO/MCU page, aka register “18G”, “Global Command and SerDes Configuration”, or <code>VTSS_PHY_MICRO_PAGE</code> depending on where you look.</p>

<p>So what is it? All we have is a single 16-bit register (inside of the proprietary extended MDIO register window scheme, but we’ll forget about that for the time being). Can’t be that complicated.</p>

<h3 id="instruction-formats">Instruction formats</h3>

<p>Bit 15 is actually documented: set high to execute a command, poll for it to self clear before doing anything else.</p>

<p>After some digging through <code>vtss_phy.c</code> and the VSC8512 datasheet, I made some progress.  There’s actually two different instruction word formats for the remaining bits.</p>

<h4 id="bit-14-set-indirect-pointer-format">Bit 14 set: Indirect pointer format</h4>

<p>This instruction sets a 15-bit pointer <code>mem_addr</code> into the MCU memory address space used by peek/poke commands.</p>

<ul>
  <li><code>[15]</code>: always 1 (execute command)</li>
  <li><code>[14]</code>: always 1 (select indirect pointer mode)</li>
  <li><code>[13]</code>: always 0 (seems to be dontcare)</li>
  <li><code>[12]</code>: segment / base address select (1 = 0x4000, 0 = 0x0000)</li>
  <li><code>[11:0]</code>: low bits of pointer</li>
</ul>

<h4 id="bit-14-clear-command-format">Bit 14 clear: Command format</h4>

<p>This instruction executes a command and optionally returns data.</p>

<ul>
  <li><code>[15]</code>: always 1 (execute command)</li>
  <li><code>[14]</code>: always 0 (select command mode)</li>
  <li><code>[13:4]</code>: arguments, opcode dependent</li>
  <li><code>[3:0]</code>: opcode</li>
</ul>

<h3 id="command-codes">Command codes</h3>

<h4 id="0x0-set-mac-mode--write-mcb-to-shadow-registers">0x0: Set MAC mode / write MCB to shadow registers</h4>

<p>Two commands are documented in datasheet table 77:</p>
<ul>
  <li><code>80b0</code>: select 12 phy SGMII mode</li>
  <li><code>80a0</code>: select 12 phy QSGMII mode</li>
</ul>

<p>One undocumented command is known from MESA:</p>
<ul>
  <li><code>9cc0</code>: write shadow registers from <code>cfg_buf</code> to one or more MCB ports selected by the <code>addr_vec</code> bitmask. There’s probably some bitfields to crack here (maybe related to 0x03 command syntax)? to access other stuff.</li>
</ul>

<p>It looks like Tesla uses <code>80e0</code> for QSGMII mode but I haven’t seen this used in any of the Atom12/Luton26 code.</p>

<h4 id="0x1-set-serdes-media-mode-for-dual-mode-sfpbaset-interfaces">0x1: Set SERDES media mode for dual mode SFP/baseT interfaces</h4>

<p>Two commands are documented in datasheet table 77:</p>

<ul>
  <li><code>[15]</code>: always 1 (execute command)</li>
  <li><code>[14]</code>: always 0 (select command mode)</li>
  <li><code>[13:12]</code>: always 0 (reserved/ignored?)</li>
  <li><code>[11:8]</code>: bitmask of port 11:8 indexes, 1 to set mode, 0 to preserve</li>
  <li><code>[7:4]</code>: 0x8 for 1000baseX, 0x9 for 100baseFX, other values reserved</li>
  <li><code>[3:0]</code>: opcode (always <code>4&#39;h1</code>)</li>
</ul>

<h4 id="0x2-unknown-not-observed">0x2: Unknown, not observed</h4>

<h4 id="0x3-read-mcb-to-shadow-registers">0x3: Read MCB to shadow registers</h4>

<p>One undocumented command is known from MESA. This command reads the entire 36 byte MCB from a single SERDES macro into a variable called <code>cfg_buf</code>, located in the 8051 memory at address <code>0x47cf</code>.</p>

<ul>
  <li><code>[15]</code>: always 1 (execute command)</li>
  <li><code>[14]</code>: always 0 (select command mode)</li>
  <li><code>[13:12]</code>: always 0 (reserved/ignored?)</li>
  <li><code>[11:8]</code>: SERDES macro index on the specified MCB, see below</li>
  <li><code>[7:4]</code>: MCB bus index, see below</li>
  <li><code>[3:0]</code>: opcode (always <code>4&#39;h3</code>)</li>
</ul>

<p>MCB bus indexes for the VSC8512:</p>
<ul>
  <li>0: SERDES1G macros</li>
  <li>1: SERDES6G macros</li>
  <li>2: LCPLL</li>
</ul>

<p>SERDES1G macro indexes on MCB bus 0:</p>
<ul>
  <li>0: SERDES1G macro 0 (SGMII lane 1)</li>
  <li>1: SERDES1G macro 1 (SGMII lane 2)</li>
  <li>2: SERDES1G macro 2 (SGMII lane 4)</li>
  <li>3: SERDES1G macro 3 (SGMII lane 5)</li>
  <li>4: SERDES1G macro 4 (SGMII lane 7 / SFP port 11)</li>
  <li>5: SERDES1G macro 5 (SGMII lane 8 / SFP port 10)</li>
  <li>6: SERDES1G macro 6 (SGMII lane 10 / SFP port 9)</li>
  <li>7: SERDES1G macro 7 (SGMII lane 11 / SFP port 8)</li>
</ul>

<p>SERDES6G macro indexes on MCB bus 1:</p>
<ul>
  <li>0: SERDES6G macro 0 (SGMII lane 0 / not used for QSGMII)</li>
  <li>1: SERDES6G macro 1 (SGMII lane 3 / QSGMII lane 0)</li>
  <li>2: SERDES6G macro 2 (SGMII lane 6 / QSGMII lane 1)</li>
  <li>3: SERDES6G macro 3 (SGMII lane 9 / QSGMII lane 2)</li>
</ul>

<h4 id="0x4-suspend-8051-patch">0x4: Suspend 8051 patch</h4>

<p>This disables updated 8051 firmware (and I guess reverts to the ROM version) temporarily.</p>

<ul>
  <li><code>[15]</code>: always 1 (execute command)</li>
  <li><code>[14]</code>: always 0 (select command mode)</li>
  <li><code>[13:12]</code>: always <code>2&#39;b01</code></li>
  <li><code>[11:4]</code>: <code>8&#39;h01</code> to suspend microcode, <code>8&#39;h0</code> to resume</li>
  <li><code>[3:0]</code>: opcode (always <code>4&#39;h4</code>)</li>
</ul>

<h4 id="0x5-unknown-not-observed">0x5: Unknown, not observed</h4>

<h4 id="0x6-byte-poke">0x6: Byte poke</h4>

<p>This writes a single byte at <code>mem_addr</code> on the 8051.</p>

<ul>
  <li><code>[15]</code>: always 1 (execute command)</li>
  <li><code>[14]</code>: always 0 (select command mode)</li>
  <li><code>[13]</code>: always 0 (reserved/ignored?)</li>
  <li><code>[12]</code>: if 1, <code>mem_addr</code> is incremented after the poke. if 0, <code>mem_addr</code> is unchanged</li>
  <li><code>[11:4]</code>: byte to write to <code>mem_addr</code></li>
  <li><code>[3:0]</code>: opcode (always <code>4&#39;h6</code>)</li>
</ul>

<h4 id="0x7-byte-peek">0x7: Byte peek</h4>

<p>This reads a single byte from <code>mem_addr</code> on the 8051.</p>

<p>Write format:</p>

<ul>
  <li><code>[15]</code>: always 1 (execute command)</li>
  <li><code>[14]</code>: always 0 (select command mode)</li>
  <li><code>[13]</code>: always 0 (reserved/ignored?)</li>
  <li><code>[12]</code>: if 1, <code>mem_addr</code> is incremented after the peek. if 0, <code>mem_addr</code> is unchanged</li>
  <li><code>[11:4]</code>: always 0 (reserved/ignored?)</li>
  <li><code>[3:0]</code>: opcode (always <code>4&#39;h7</code>)</li>
</ul>

<p>Result readback format:</p>

<ul>
  <li><code>[15]</code>: busy bit, poll until zero</li>
  <li><code>[14:12]</code>: reserved, ignore</li>
  <li><code>[11:4]</code>: byte read from MCU memory</li>
  <li><code>[3:0]</code>: reserved, ignore</li>
</ul>

<h4 id="0x8---0xc-unknown-not-observed">0x8 - 0xc: Unknown, not observed</h4>

<h4 id="0xd-squelch-workaround">0xd: Squelch workaround</h4>

<p>Not sure what this does, it seems only implemented or necessary in Tesla / Viper parts but noted here to explain the hole in the opcode space</p>

<h4 id="0xe-unknown-not-observed">0xe: Unknown, not observed</h4>

<h4 id="0xf-unimplemented--nop">0xf: Unimplemented / nop</h4>

<p>This is used in some pieces of the code such as <code>vtss_atom_patch_suspend</code> to temporarily disable the 8051 EEE microcode patch during TDR testing because apparently issuing an unimplemented command makes the patch suspend. Why not use command 0x4? Who knows.</p>

<p>Per comment in the code “Note that this is necessary only because the patch for EEE consumes the micro continually to service all 12 PHYs in a timely manner and workaround one of the weaknesses in gigabit EEE in Luton26/Atom12.”</p>

<h3 id="mcu-address-space">MCU address space</h3>

<p>I have not yet attempted to read or mess with most of the 8051 address space.</p>

<p>From looking at MESA, the following addresses, names, and values are known (this is not all inclusive, just what I’ve looked at). These appear to correlate with the bitfield names in <code>SERDES6G_ANA_CFG</code> in vtss_phy.h. While the macro names refer to Tesla, looking at the code it appears Tesla uses the same or very similar SERDES as Luton26/Atom12 so it’s very likely that all of these field names map directly.</p>

<h4 id="47cb--name-unknown"><code>47cb</code> / name unknown</h4>

<p>Seems related to SERDES loopback, see <code>vtss_phy_serdes_fmedia_loopback_private</code></p>

<h4 id="47ce--addr_vec"><code>47ce</code> / <code>addr_vec</code></h4>

<p>Bitmask of SERDES6G macros to write shadow registers back to when sending <code>9cc0</code> command.</p>

<ul>
  <li><code>[7:4]</code>: reserved, write as zero</li>
  <li><code>[3:0]</code>: write enable mask for SERDES6G lanes 3:0. 1=write, 0=ignore</li>
</ul>

<h4 id="47cf--cfg_buf0--cfg_vec70"><code>47cf</code> / <code>cfg_buf[0]</code> / <code>cfg_vec[7:0]</code></h4>

<p>Unknown</p>

<h4 id="47d0--cfg_buf1--cfg_vec158"><code>47d0</code> / <code>cfg_buf[1]</code> / <code>cfg_vec[15:8]</code></h4>

<p>Unknown</p>

<h4 id="47d1--cfg_buf2---cfg_vec2316"><code>47d1</code> / <code>cfg_buf[2]</code> /  <code>cfg_vec[23:16]</code></h4>

<p>Unknown</p>

<h4 id="47d2--cfg_buf3--cfg_vec3124"><code>47d2</code> / <code>cfg_buf[3]</code> / <code>cfg_vec[31:24]</code></h4>

<ul>
  <li><code>[7:5]</code>: unknown</li>
  <li><code>[4]</code>: facility loopback in QSGMII mode if I’m reading code right? header calls it <code>VTSS_TESLA_SERDES6G_ANA_CFG_PWD_TX_6G</code>)</li>
  <li><code>[3:0]</code>: unknown</li>
</ul>

<h4 id="47d3--cfg_buf4--cfg_vec3932"><code>47d3</code> / <code>cfg_buf[4]</code> / <code>cfg_vec[39:32]</code></h4>

<p>Unknown</p>

<h4 id="47d4--cfg_buf5--cfg_vec4740"><code>47d4</code> / <code>cfg_buf[5]</code> / <code>cfg_vec[47:40]</code></h4>

<p>Unknown</p>

<h4 id="47d5--cfg_buf6--cfg_vec5548"><code>47d5</code> / <code>cfg_buf[6]</code> / <code>cfg_vec[55:48]</code></h4>

<p>Unknown</p>

<h4 id="47d6--cfg_buf7--cfg_vec6356"><code>47d6</code> / <code>cfg_buf[7]</code> / <code>cfg_vec[63:56]</code></h4>

<p>Unknown</p>

<h4 id="47d7--cfg_buf8--cfg_vec7164"><code>47d7</code> / <code>cfg_buf[8]</code> / <code>cfg_vec[71:64]</code></h4>

<p>Unknown</p>

<h4 id="47d8--cfg_buf9--cfg_vec7972"><code>47d8</code> / <code>cfg_buf[9]</code> / <code>cfg_vec[79:72]</code></h4>

<ul>
  <li><code>[7:5]</code>: low 3 bits of <code>ob_post0</code>, output buffer postcursor 0 tap</li>
  <li><code>[4:0]</code>: unknown</li>
</ul>

<h4 id="47d9--cfg_buf10--cfg_vec8780"><code>47d9</code> / <code>cfg_buf[10]</code> / <code>cfg_vec[87:80]</code></h4>

<ul>
  <li><code>[7]</code>: unknown</li>
  <li><code>[6]</code>: <code>ib_rst</code></li>
  <li><code>[5:3]</code>: unknown</li>
  <li><code>[2:0]</code>: high 3 bits of <code>ob_post0</code>, output buffer postcursor 0 tap</li>
</ul>

<h4 id="47da--cfg_buf11--cfg_vec9588"><code>47da</code> / <code>cfg_buf[11]</code> / <code>cfg_vec[95:88]</code></h4>

<p>See <code>vtss_phy_atom12_cfg_ib_cterm_ena_private</code></p>

<ul>
  <li><code>[7:4]</code>: unknown</li>
  <li><code>[3]</code>: <code>ib_cterm_ena</code></li>
  <li><code>[2]</code>: <code>ib_eq_mode</code></li>
  <li><code>[1:0]</code>: unknown</li>
</ul>

<h4 id="other-cfg_buf">Other cfg_buf</h4>

<p>According to <code>vtss_phy_atom12_patch_setttings_get_private</code> (note the typo), the <code>cfg_buf</code> array is 36 bytes long, while it’s 38 on Tesla. So maybe <code>VTSS_TESLA_SERDES6G_DIG_CFG_PRBS_SEL_6G</code> and higher registers are unavailable on Atom12?</p>

<p>Registers and fields mentioned in passing in the code worth digging into:</p>

<p>ob_cfg0:</p>
<ul>
  <li><code>ena1v_mode</code></li>
  <li><code>ob_pol</code></li>
  <li><code>ob_post0</code></li>
  <li><code>ob_post1</code></li>
  <li><code>ob_sr_h</code></li>
  <li><code>ob_resistor_ctr</code></li>
  <li><code>ob_sr</code></li>
</ul>

<p>ob_cfg1:</p>
<ul>
  <li><code>ob_ena_cas</code></li>
  <li><code>ob_lev</code></li>
</ul>

<p>des_cfg:</p>
<ul>
  <li><code>phy_ctrl</code></li>
  <li><code>mbtr_ctrl</code></li>
  <li><code>bw_hyst</code></li>
  <li><code>bw_ana</code></li>
</ul>

<p>ib_cfg0:</p>
<ul>
  <li><code>ib_rtrm_adj</code></li>
  <li><code>ib_sig_det_clk_sel</code></li>
  <li><code>ib_reg_pat_sel_offset</code></li>
  <li><code>ib_cal_ena</code></li>
</ul>

<p>ib_cfg1:</p>
<ul>
  <li><code>ib_tjtag</code></li>
  <li><code>ib_tsdet</code></li>
  <li><code>ib_scaly</code></li>
  <li><code>ib_frc_offset</code></li>
</ul>

<p>ib_cfg2:</p>
<ul>
  <li><code>ib_tinfv</code></li>
  <li><code>ib_tcalv</code></li>
  <li><code>ib_ureg</code></li>
</ul>

<p>ib_cfg3: mentioned, didn’t look at in any detail</p>

<p>ib_cfg4: mentioned, didn’t look at in any detail</p>

<h4 id="47f3--stat_buf"><code>47f3</code> / <code>stat_buf</code></h4>

<p>8 bytes long, no other details reversed.</p>

<p>Digging in <code>vtss_phy_chk_serdes_init_mac_mode_private</code> will probably shed light on variables <code>sys_rst</code>, <code>ena_lane</code>, <code>pll_fsm_ena</code>, <code>hrate</code>, <code>qrate</code>, <code>if_mode</code>, <code>ib_fx100_ena</code>, <code>des_cpmd_sel</code>, <code>des_100fx_cpmd_ena</code> but I haven’t spent any time on this.</p>

<p><code>vtss_serdes6g_tesla_rcpll_status_get_private</code> suggests the following fields for the RC PLL (SERDES1G?):</p>
<ul>
  <li>bit 10: <code>out_of_range</code></li>
  <li>bit 11: <code>cal_error</code></li>
  <li>bit 12: <code>cal_not_done</code></li>
</ul>

<p><code>vtss_lcpll_tesla_status_get_private</code> suggests the following fields for the LC PLL (SERDES6G?):</p>
<ul>
  <li>bit 45: <code>lock_status</code></li>
  <li>bit 36: <code>cal_done</code></li>
  <li>bit 35: <code>cal_error</code></li>
  <li>bit 32: <code>fsm_lock</code></li>
  <li>bit 31:29: <code>fsm_stat</code></li>
  <li>bit 18:14: <code>gain_stat</code></li>
</ul>

<h2 id="qsgmii-equalizer-testing">QSGMII equalizer testing</h2>

<p>So, with all that, where does that leave us?</p>

<p>I now know how to tune at least the critical post-cursor tap 0 to do basic de-emphasis:</p>
<ul>
  <li>Read MCB registers from SERDES lane 1 (first QSGMII lane) with <code>0x03</code> command into shadow regsters</li>
  <li>Poke <code>ob_post0</code> using the indirect access command to set the pointer followed by a pair of <code>0x07</code> / <code>0x06</code> peek / poke operations to read-modify-write this field without changing others</li>
  <li>Poke addr_vec to <code>0x0e</code> to select all three of the four total SERDES6G lanes that are used for QSGMII</li>
  <li>Send <code>0x9cc0</code> command to push the new register values to all SERDES instances</li>
</ul>

<p>I’m on the edge of figuring out a lot more by guessing what the bitfield names in the header mean (this post is in part my notes in case I want to get back to this and tune other configuration like output amplitude).</p>

<p>With the default post0 tap value (I believe 0x02 from MESA comments, but have not actually tried to read back) the signal is totally usable, but there is just a smidgeon of eye closure.
<a href="https://serd.es/assets/qsgmii-tune-01.png"><img src="https://serd.es/assets/qsgmii-tune-01-800.png" alt="ngscopeclient screenshot showing an eye pattern that is just barely closed from perfect"/></a></p>

<p>As a test I tried turning it up much higher, to 0x0f, to see if I was poking the registers right. This worked, but gave a grossly overequalized result.</p>

<p><a href="https://serd.es/assets/qsgmii-tune-03.png"><img src="https://serd.es/assets/qsgmii-tune-03-800.png" alt="ngscopeclient screenshot showing a massively overequalized signal with huge spikes on transitions and double-banding on the eye pattern"/></a></p>

<p>I was happy with how things looked at 0x04. The eye is fully open, all bits are the same height, and the eye is open enough to drive a bus through. This is through a foot of Samtec ARC6, two feet of Koaxis KF086, two ARF6 connector transitions, a SMPM connector launch, and about 75 mm of total PCB trace.</p>

<p>The eye actually passes the QSGMII <em>transmit</em> eye mask, not just the RX mask shown here. I think it’ll do.</p>

<p><a href="https://serd.es/assets/qsgmii-tune-02.png"><img src="https://serd.es/assets/qsgmii-tune-02-800.png" alt="ngscopeclient screenshot showing a well equalized signal"/></a></p>

<h2 id="conclusions">Conclusions</h2>

<p>Who needs NDAed datasheets when you can just read public driver code and work out the bits they’re not telling you?</p>

<p>There’s room for a lot more fun, maybe one day if I’m bored I’ll try getting code execution or a ROM dump or something out of the 8051 on the PHY. But for now the signal integrity tweaks are done so mission accomplished.</p>

<p>Like this post? <a href="https://ioc.exchange/@azonenberg/FIXME">Drop me a comment on Mastodon</a></p>

</article>

      </section>
    </div></div>
  </body>
</html>
