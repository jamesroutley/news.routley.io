<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/williamw520/toposort">Original</a>
    <h1>Show HN: Zig Topological Sort Library for Parallel Processing</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">TopoSort is a highly efficient Zig library for performing topological sort on dependency graph.  This small library is packed with the following features:</p>
<ul dir="auto">
<li>Building dependency graph from dependency data.</li>
<li>Performing topological sort on the dependency graph.</li>
<li>Generating dependence-free subsets for parallel processing.</li>
<li>Cycle detection and cycle reporting.</li>
<li>Support different node types.</li>
</ul>

<ul dir="auto">
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a>
<ul dir="auto">
<li><a href="#memory-ownership">Memory Ownership</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#more-usage">More Usage</a></li>
</ul>
</li>
<li><a href="#command-line-tool">CLI Tool</a></li>
<li><a href="#benchmarks">Benchmarks</a></li>
<li><a href="#license">License</a></li>
</ul>

<p dir="auto">Go to the <a href="https://github.com/williamw520/toposort/releases">Releases</a> page.
Pick a release to add to your project.
Identify the file asset URL for the release version.
E.g. <a href="https://github.com/williamw520/toposort/archive/refs/tags/1.0.2.tar.gz">https://github.com/williamw520/toposort/archive/refs/tags/1.0.2.tar.gz</a></p>
<p dir="auto">Use <code>zig fetch</code> to add the TopoSort package to your Zig project.
Run the following command to fetch the TopoSort package:</p>
<div dir="auto" data-snippet-clipboard-copy-content="  zig fetch --save https://github.com/williamw520/toposort/archive/refs/tags/&lt;VERSION&gt;.tar.gz"><pre>  zig fetch --save https://github.com/williamw520/toposort/archive/refs/tags/<span>&lt;</span>VERSION<span>&gt;</span>.tar.gz</pre></div>
<p dir="auto"><code>zig fetch</code> updates your <code>build.zig.zon</code> file with the URL with file hash added in the .dependency section of the file.</p>
<div dir="auto" data-snippet-clipboard-copy-content=".{
    .name = &#34;my-project&#34;,
    ...
    .dependencies = .{
+       .toposort = .{
+           .url = &#34;zig fetch https://github.com/williamw520/toposort/archive/refs/tags/&lt;VERSION&gt;.tar.gz&#34;,
+           .hash = &#34;toposort-...&#34;,
+       },
    },
}"><pre>.{
    .name = &#34;my-project&#34;,
    ...
    .dependencies = .{
<span><span>+</span>       .toposort = .{</span>
<span><span>+</span>           .url = &#34;zig fetch https://github.com/williamw520/toposort/archive/refs/tags/&lt;VERSION&gt;.tar.gz&#34;,</span>
<span><span>+</span>           .hash = &#34;toposort-...&#34;,</span>
<span><span>+</span>       },</span>
    },
}</pre></div>
<p dir="auto">Update your <code>build.zig</code> with the lines for toposort.</p>
<div dir="auto" data-snippet-clipboard-copy-content="  pub fn build(b: *std.Build) void {
      ...
+     const opts = .{ .target = target, .optimize = optimize };
+     const toposort_module = b.dependency(&#34;toposort&#34;, opts).module(&#34;toposort&#34;);
      ...
      const exe = b.addExecutable(.{
          .name = &#34;my_project&#34;,
          .root_module = exe_mod,
      });
+     exe.root_module.addImport(&#34;toposort&#34;, toposort_module);"><pre>  pub fn build(b: *std.Build) void {
      ...
<span><span>+</span>     const opts = .{ .target = target, .optimize = optimize };</span>
<span><span>+</span>     const toposort_module = b.dependency(&#34;toposort&#34;, opts).module(&#34;toposort&#34;);</span>
      ...
      const exe = b.addExecutable(.{
          .name = &#34;my_project&#34;,
          .root_module = exe_mod,
      });
<span><span>+</span>     exe.root_module.addImport(&#34;toposort&#34;, toposort_module);</span></pre></div>
<p dir="auto">The <code>.addImport(&#34;toposort&#34;)</code> call let you import the module into your Zig source files.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const toposort = @import(&#34;toposort&#34;);"><pre><span>const</span> <span>toposort</span> <span>=</span> <span>@import</span>(<span>&#34;toposort&#34;</span>);</pre></div>

<p dir="auto">Usage typically follows the following steps in your Zig source file.</p>

<div dir="auto" data-snippet-clipboard-copy-content="const toposort = @import(&#34;toposort&#34;);
const TopoSort = toposort.TopoSort;
const SortResult = toposort.SortResult;"><pre><span>const</span> <span>toposort</span> <span>=</span> <span>@import</span>(<span>&#34;toposort&#34;</span>);
<span>const</span> <span>TopoSort</span> <span>=</span> <span>toposort</span>.<span>TopoSort</span>;
<span>const</span> <span>SortResult</span> <span>=</span> <span>toposort</span>.<span>SortResult</span>;</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Initialization and memory management.</h4><a id="user-content-initialization-and-memory-management" aria-label="Permalink: Initialization and memory management." href="#initialization-and-memory-management"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="    const T = usize;  // node data type
    var tsort = try TopoSort(T).init(allocator, .{});
    defer tsort.deinit();"><pre>    <span>const</span> <span>T</span> <span>=</span> <span>usize</span>;  <span>// node data type</span>
    <span>var</span> <span>tsort</span> <span>=</span> <span>try</span> <span>TopoSort</span>(<span>T</span>).<span>init</span>(<span>allocator</span>, .{});
    <span>defer</span> <span>tsort</span>.<span>deinit</span>();</pre></div>
<p dir="auto">The data type of the node value is provided as a comptime type to TopoSort(T).</p>

<div dir="auto" data-snippet-clipboard-copy-content="    try tsort.add(101, 102);    // node 102 depends on the leading node 101
    try tsort.add(102, 103);
    try tsort.add(101, 104);"><pre>    <span>try</span> <span>tsort</span>.<span>add</span>(<span>101</span>, <span>102</span>);    <span>// node 102 depends on the leading node 101</span>
    <span>try</span> <span>tsort</span>.<span>add</span>(<span>102</span>, <span>103</span>);
    <span>try</span> <span>tsort</span>.<span>add</span>(<span>101</span>, <span>104</span>);</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Performing the topological sort</h4><a id="user-content-performing-the-topological-sort" aria-label="Permalink: Performing the topological sort" href="#performing-the-topological-sort"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="    const result = try tsort.sort();"><pre>    <span>const</span> <span>result</span> <span>=</span> <span>try</span> <span>tsort</span>.<span>sort</span>();</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="    if (result.has_cycle()) {
        for (result.get_cycle_set().items) |id| {
            const cyclic_node = result.get_node(id);
            ...
        }
    }"><pre>    <span>if</span> (<span>result</span>.<span>has_cycle</span>()) {
        <span>for</span> (<span>result</span>.<span>get_cycle_set</span>().<span>items</span>) <span>|</span><span>id</span><span>|</span> {
            <span>const</span> <span>cyclic_node</span> <span>=</span> <span>result</span>.<span>get_node</span>(<span>id</span>);
            <span>...</span>
        }
    }</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Otherwise, process the sorted non-cyclic result</h4><a id="user-content-otherwise-process-the-sorted-non-cyclic-result" aria-label="Permalink: Otherwise, process the sorted non-cyclic result" href="#otherwise-process-the-sorted-non-cyclic-result"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="    const sets: ArrayList(ArrayList(T)) = result.get_sorted_sets();
    for (sets.items) |subset| {     // the node sets are in topological order
        for (subset.items) |node| { // nodes within each set are dependence free from each other.
            ...
        }
    }"><pre>    <span>const</span> <span>sets</span>: <span>ArrayList</span>(<span>ArrayList</span>(<span>T</span>)) <span>=</span> <span>result</span>.<span>get_sorted_sets</span>();
    <span>for</span> (<span>sets</span>.<span>items</span>) <span>|</span><span>subset</span><span>|</span> {     <span>// the node sets are in topological order</span>
        <span>for</span> (<span>subset</span>.<span>items</span>) <span>|</span><span>node</span><span>|</span> { <span>// nodes within each set are dependence free from each other.</span>
            <span>...</span>
        }
    }</pre></div>
<p dir="auto">TopoSort figures out the nodes that have no dependence with each other
in the linear order of the topological sequence and groups them together as subsets.
This allows you to run/process the nodes of each subset in parallel.</p>
<p dir="auto">The subsets themselves are in topological order. If there&#39;s no need for
parallel processing, the nodes in each subset can be processed sequentially,
which fit in the overall topological order of all the nodes.</p>

<p dir="auto">Nodes are passed in by value in <code>add()</code> and are stored by value in the TopoSort&#39;s Data struct.
For simple type like integer (e.g. u16, u32), the node values are simply copied.
For slice and pointer node type (e.g. []const u8), the memory for the nodes
are not duplicated. Memory is owned and managed by the caller.</p>

<p dir="auto">The <code>Toposort.init()</code> function takes in optional configurations. E.g.</p>
<div dir="auto" data-snippet-clipboard-copy-content="    const T = usize;  // node data type
    var tsort = try TopoSort(T).init(allocator, .{
        verbose = true,
        max_range = 4000,
    });"><pre>    <span>const</span> <span>T</span> <span>=</span> <span>usize</span>;  <span>// node data type</span>
    <span>var</span> <span>tsort</span> <span>=</span> <span>try</span> <span>TopoSort</span>(<span>T</span>).<span>init</span>(<span>allocator</span>, .{
        <span>verbose</span> <span>=</span> <span>true</span>,
        <span>max_range</span> <span>=</span> <span>4000</span>,
    });</pre></div>
<p dir="auto">Setting the <code>verbose</code> flag prints internal messages while sorting.</p>
<p dir="auto">The <code>max_range</code> property sets the maximum value of the node item value.
E.g. For node values ranging from 1, 2, 3, 20, 75, ... 100, 100 is the
maximum value. If all your node values are positive integers,
passing in a number type (u16, u32, u64, etc) for the node data type and
setting the <code>max_range</code> let TopoSort use a simpler data structure with
faster performance.  Building a dependency tree can be more than 3X or 4X faster.
Compare the 3rd benchmark and 4th benchmark in tests.zig.</p>

<div dir="auto"><h4 tabindex="-1" dir="auto">To use a slice/string for the node type,</h4><a id="user-content-to-use-a-slicestring-for-the-node-type" aria-label="Permalink: To use a slice/string for the node type," href="#to-use-a-slicestring-for-the-node-type"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="    const T = []const u8;
    var tsort = try TopoSort(T).init(allocator, .{});"><pre><code>    const T = []const u8;
    var tsort = try TopoSort(T).init(allocator, .{});
</code></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">To get a list of topologically sorted nodes.</h4><a id="user-content-to-get-a-list-of-topologically-sorted-nodes" aria-label="Permalink: To get a list of topologically sorted nodes." href="#to-get-a-list-of-topologically-sorted-nodes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="    const T = []const u8;
    var list = ArrayList(T).init(allocator);    // list to hold the returned nodes.
    defer list.deinit();
    for ((try result.get_sorted_list(&amp;list)).items) |node| {
        ...
    }"><pre><code>    const T = []const u8;
    var list = ArrayList(T).init(allocator);    // list to hold the returned nodes.
    defer list.deinit();
    for ((try result.get_sorted_list(&amp;list)).items) |node| {
        ...
    }
</code></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">To add dependency similar to the Makefile rule format.</h4><a id="user-content-to-add-dependency-similar-to-the-makefile-rule-format" aria-label="Permalink: To add dependency similar to the Makefile rule format." href="#to-add-dependency-similar-to-the-makefile-rule-format"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Add the dependent node A to the leading B node.  A: B</p>
<div data-snippet-clipboard-copy-content="    const T = []const u8;
    var tsort = try TopoSort(T).init(allocator, .{});
    try tsort.add_dep(&#34;A&#34;, &#34;B&#34;);    // A: B
    try tsort.add_dep(&#34;B&#34;, &#34;C&#34;);    // B: C
    try tsort.add_dep(&#34;B&#34;, &#34;D&#34;);    // B: D
    try tsort.add_deps(&#34;B&#34;, &amp;[_]T{ &#34;E&#34;, &#34;F&#34;, &#34;G&#34; });    // B: E F G
    
    var nodes = ArrayList(T).init(allocator);
    try nodes.append(&#34;E&#34;);
    try nodes.append(&#34;F&#34;);
    try nodes.append(&#34;G&#34;);
    try tsort.add_deps(&#34;B&#34;, nodes.items);"><pre><code>    const T = []const u8;
    var tsort = try TopoSort(T).init(allocator, .{});
    try tsort.add_dep(&#34;A&#34;, &#34;B&#34;);    // A: B
    try tsort.add_dep(&#34;B&#34;, &#34;C&#34;);    // B: C
    try tsort.add_dep(&#34;B&#34;, &#34;D&#34;);    // B: D
    try tsort.add_deps(&#34;B&#34;, &amp;[_]T{ &#34;E&#34;, &#34;F&#34;, &#34;G&#34; });    // B: E F G
    
    var nodes = ArrayList(T).init(allocator);
    try nodes.append(&#34;E&#34;);
    try nodes.append(&#34;F&#34;);
    try nodes.append(&#34;G&#34;);
    try tsort.add_deps(&#34;B&#34;, nodes.items);
</code></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">To traverse the list of nodes in the graph,</h4><a id="user-content-to-traverse-the-list-of-nodes-in-the-graph" aria-label="Permalink: To traverse the list of nodes in the graph," href="#to-traverse-the-list-of-nodes-in-the-graph"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="    for (result.get_nodes().items) |node| {
        ...
    }"><pre>    <span>for</span> (<span>result</span>.<span>get_nodes</span>().<span>items</span>) <span>|</span><span>node</span><span>|</span> {
        <span>...</span>
    }</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">To traverse the dependency graph recursively,</h4><a id="user-content-to-traverse-the-dependency-graph-recursively" aria-label="Permalink: To traverse the dependency graph recursively," href="#to-traverse-the-dependency-graph-recursively"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="    const T = usize;  // node data type
    var tsort = try TopoSort(T).init(allocator, .{});
    ...
    const result = try tsort.sort();
    visit_tree(result, null, result.get_root_set());

    fn visit_tree(result: SortResult(T), lead_id: ?u32, dependent_ids: ArrayList(u32)) {
        if (lead_id) |id| { // lead_id is optional since the root nodes have no leading nodes.
            const lead_node = result.get_node(lead_id);
            ...
        }
        for (dependent_ids.items) |node_id| {
            const dependent_node = result.get_node(node_id);
            ...
            visit_tree(result, node_id, result.get_dependents(node_id));
        }
    }"><pre>    <span>const</span> <span>T</span> <span>=</span> <span>usize</span>;  <span>// node data type</span>
    <span>var</span> <span>tsort</span> <span>=</span> <span>try</span> <span>TopoSort</span>(<span>T</span>).<span>init</span>(<span>allocator</span>, .{});
    <span>...</span>
    <span>const</span> <span>result</span> <span>=</span> <span>try</span> <span>tsort</span>.<span>sort</span>();
    <span>visit_tree</span>(<span>result</span>, <span>null</span>, <span>result</span>.<span>get_root_set</span>());

    <span>fn</span> <span>visit_tree</span>(<span>result</span>: <span>SortResult</span>(<span>T</span>), <span>lead_id</span>: <span>?</span><span>u32</span>, <span>dependent_ids</span>: <span>ArrayList</span>(<span>u32</span>)) {
        <span>if</span> (<span>lead_id</span>) <span>|</span><span>id</span><span>|</span> { <span>// lead_id is optional since the root nodes have no leading nodes.</span>
            <span>const</span> <span>lead_node</span> <span>=</span> <span>result</span>.<span>get_node</span>(<span>lead_id</span>);
            <span>...</span>
        }
        <span>for</span> (<span>dependent_ids</span>.<span>items</span>) <span>|</span><span>node_id</span><span>|</span> {
            <span>const</span> <span>dependent_node</span> <span>=</span> <span>result</span>.<span>get_node</span>(<span>node_id</span>);
            <span>...</span>
            <span>visit_tree</span>(<span>result</span>, <span>node_id</span>, <span>result</span>.<span>get_dependents</span>(<span>node_id</span>));
        }
    }</pre></div>

<p dir="auto">TopoSort comes with a command line interface (CLI) tool <code>toposort-cli</code>,
which uses the TopoSort library internally.  The data file it used follows
the simple dependent rule format of Makefile. E.g.</p>

<p dir="auto">Sample invocations on the test data:</p>
<div data-snippet-clipboard-copy-content="  zig-out/bin/toposort-cli --data data/data.txt
  zig-out/bin/toposort-cli --data data/data.txt --verbose
  zig-out/bin/toposort-cli --data data/data2.txt
  zig-out/bin/toposort-cli --data data/data_cycle1.txt
  zig-out/bin/toposort-cli --data data/data_cycle2.txt
  zig-out/bin/toposort-cli --data data/data_num.txt --int"><pre><code>  zig-out/bin/toposort-cli --data data/data.txt
  zig-out/bin/toposort-cli --data data/data.txt --verbose
  zig-out/bin/toposort-cli --data data/data2.txt
  zig-out/bin/toposort-cli --data data/data_cycle1.txt
  zig-out/bin/toposort-cli --data data/data_cycle2.txt
  zig-out/bin/toposort-cli --data data/data_num.txt --int
</code></pre></div>

<p dir="auto">TopoSort comes with some benchmark tests.</p>
<p dir="auto">Rnn <code>zig build test -Doptimize=ReleaseFast</code> to run the benchmarks.</p>

<p dir="auto">TopoSort is <a href="https://github.com/williamw520/toposort/blob/master/LICENSE">MIT licensed</a>.</p>

<p dir="auto">For more information on the Zig build system, check out these resources:</p>
<ul dir="auto">
<li><a href="https://ziglang.org/learn/build-system/" rel="nofollow">Zig Build System</a></li>
<li><a href="https://ziggit.dev/t/build-system-tricks/" rel="nofollow">Build System Tricks</a></li>
</ul>
</article></div></div>
  </body>
</html>
