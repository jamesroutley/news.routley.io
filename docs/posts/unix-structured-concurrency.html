<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2023/10/11/unix-structured-concurrency.html">Original</a>
    <h1>Unix Structured Concurrency</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>

    
<p><span>A short note on a particular structured concurrency pattern for UNIX systems programming.</span></p>
<section id="The-pattern">

    <h2>
    <a href="#The-pattern"><span>The pattern</span> </a>
    </h2>


  <p><span>That is, in the child process (which you control), do a blocking read on </span><code>stdin</code><span>, and exit promptly</span>
<span>if the read returned zero bytes.</span></p>
<p><span>Example of the pattern from one of the side hacks:</span></p>

<figure>


<pre><code><span><span>fn</span> <span>main</span>() <span>-&gt;</span> anyhow::<span>Result</span>&lt;()&gt; {</span>
<span>  <span>let</span> <span>args</span> = Args::<span>parse</span>()?;</span>
<span></span>
<span>  <span>let</span> <span>token</span> = CancellationToken::<span>new</span>();</span>
<span>  <span>let</span> <span>_guard</span> = token.<span>clone</span>().<span>drop_guard</span>();</span>
<span>  <span>let</span> <span>_watchdog_thread</span> = std::thread::<span>spawn</span>({</span>
<span>    <span>let</span> <span>token</span> = token.<span>clone</span>();</span>
<span>    <span>move</span> || <span>run_watchdog</span>(token)</span>
<span>  });</span>
<span></span>
<span>  <span>let</span> <span>tcp_socket</span> = TcpListener::<span>bind</span>(args.addr.sock)?;</span>
<span>  <span>let</span> <span>udp_socket</span> = UdpSocket::<span>bind</span>(args.addr.sock)?;</span>
<span>  <span>println!</span>(<span>&#34;listening on {}&#34;</span>, args.addr.sock);</span>
<span>  <span>run</span>(args, &amp;token, tcp_socket, udp_socket)</span>
<span>}</span>
<span></span>
<span><span>fn</span> <span>run_watchdog</span>(token: CancellationToken) {</span>
<span>  <span>let</span> <span>_guard</span> = token.<span>drop_guard</span>();</span>
<span>  <span>let</span> <span>stdin</span> = std::io::<span>stdin</span>();</span>
<span>  <span>let</span> <span>mut </span><span>stdin</span> = stdin.<span>lock</span>();</span>
<span>  <span>let</span> <span>mut </span><span>buf</span> = [<span>0</span>];</span>
<span>  <span>let</span> <span>n</span> = stdin.<span>read</span>(&amp;<span>mut</span> buf).<span>unwrap</span>();</span>
<span>  <span>if</span> n != <span>0</span> {</span>
<span>    <span>panic!</span>(<span>&#34;unexpected input&#34;</span>);</span>
<span>  }</span>
<span>}</span></code></pre>

</figure>
</section>
<section id="Context">

    <h2>
    <a href="#Context"><span>Context</span> </a>
    </h2>
<p><span>Two bits of background reading here:</span></p>
<p><span>A famous </span><del><span>novel by Leo Tolstoy</span></del><span> blog post by njs:</span></p>
<p><a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/</a></p>
<p><span>A less famous, but no less classic, gotchas.md from duct.py:</span></p>
<p><a href="https://github.com/oconnor663/duct.py/blob/master/gotchas.md#killing-grandchild-processes">https://github.com/oconnor663/duct.py/blob/master/gotchas.md#killing-grandchild-processes</a></p>
<p><span>It is often desirable to spawn a process, and make sure that, when the parent process exits, the</span>
<span>child process is also killed. This can </span><em><span>not</span></em><span> be achieved using a pattern equivalent to</span></p>

<figure>


<pre><code><span>try {</span>
<span>    process = spawn(...)</span>
<span>} finally {</span>
<span>    _ = process.kill()</span>
<span>}</span></code></pre>

</figure>
<p><span>The parent process itself might be abruptly killed, and the finally blocks / destructors / atexit</span>
<span>hooks are not run in this case.</span></p>
<p><span>The natural habitat for this pattern are integration tests, where you often spawn external processes</span>
<span>in large amounts, and expect occasional abrupt crashes.</span></p>
<p><span>Sadly, as far as I know, UNIX doesn</span>’<span>t provide an easy mechanism to bind the lifetimes of two</span>
<span>processes thusly. There</span>’<span>s process group mechanism, but it is one-level deep and is mostly reserved</span>
<span>for the shell. There</span>’<span>s </span><del><span>docker</span></del><span> cgroups, but that</span>’<span>s a Linux-specific mechanism which isn</span>’<span>t usually</span>
<span>exposed by cross-platform standard libraries of various languages.</span></p>
<p><span>The trick is using closed stdin as the signal for exit, as that is evenly supported by all platforms,</span>
<span>doesn</span>’<span>t require much code, and will do nearly the right thing most of the time.</span></p>
<p><span>The drawbacks of this pattern:</span></p>
<ul>
<li>
<span>It</span>’<span>s cooperative in the child (you must control the code of the child process to inject the exit</span>
<span>logic)</span>
</li>
<li>
<span>It</span>’<span>s somewhat cooperative in the parent: while exiting on standard input EOF will do the right</span>
<span>thing most of the time, there are exceptions. For example, reading from </span><code>/dev/null</code><span> returns 0 (as</span>
<span>opposed to blocking), and daemon processes often have their stdin set to </span><code>/dev/null</code><span>. Sadly,</span>
<span>there</span>’<span>s no </span><code>/dev/reads-and-writes-block-forever</code>
</li>
<li>
<span>It is not actually structured. Ideally, parent</span>’<span>s exit should block on all descendants exiting, but</span>
<span>that</span>’<span>s not the case in this pattern. Still, it</span>’<span>s good enough for cleaning up in tests!</span>
</li>
</ul>
</section>
</article>
  </div></div>
  </body>
</html>
