<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://anuraag2601.github.io/gemini_cli_disaster.html">Original</a>
    <h1>I watched Gemini CLI hallucinate and delete my files</h1>
    
    <div id="readability-page-1" class="page"><div>
        

        <blockquote>I have failed you completely and catastrophically.

  My review of the commands confirms my gross incompetence....</blockquote>

        <p>I read about <a href="https://www.theregister.com/2025/07/21/replit_saastr_vibe_coding_incident/" target="-blank" rel="noopener noreferrer"> Jason Lemkin&#39;s Replit incident </a> and thought I&#39;ll share my own weird experience with Gemini CLI.</p>

        <p>I&#39;d been using Claude Code (CC) pretty heavily off late on their pay per token model, and thought it might be worthwhile to give Gemini CLI a shot before I commit $100 per month to CC.</p>

        <p>With Gemini 2.5 Pro under the hood and a very generous free tier, it seemed like the perfect alternative. &#34;How bad can it be?&#34; I thought. &#34;If Claude is this good, a flagship model from Google has to be a solid contender.&#34; The promise of all that free usage was just too tempting to pass up.</p>

        <p>Luckily, I had created a separate test directory named <code>claude-code-experiments</code> for my experiments</p>
        
        <p>What started as a simple file management test devolved into one of the most unsettling and fascinating AI failures I have ever witnessed. I watched, command by command, as Gemini grew confused, &#34;hallucinated&#34; a series of successful file operations, and ultimately concluded that it had catastrophically lost all of my data.</p>

        
        
        <h2>The Simple Request</h2>

        <p>I was in my <code>claude-code-experiments</code> directory. My goal was simple, and I gave Gemini a straightforward instruction:</p>
        
        <blockquote>ok great, first of all let&#39;s rename the folder you are in to call it &#39;AI CLI experiments&#39; and move all the existing files within this folder to &#39;anuraag_xyz project&#39;</blockquote>

        <p>Gemini, quite reasonably, identified that it couldn&#39;t rename the directory it was currently inside.</p>

        <pre><code>✔ Shell ren &#34;claude-code-experiments&#34; &#34;anuraag_xyz project&#34; ...
Error: Directory cannot be absolute. Must be relative to the project root directory.</code></pre>

        <p>No problem there. This is expected behavior. Gemini then proposed a perfectly logical workaround.</p>
        
        <blockquote>I see. It seems I can&#39;t rename the directory I&#39;m currently in.</blockquote>
        
        <p>It then executed the command to create a new directory in the parent folder (my Desktop).</p>
        
        <pre><code>✔ Shell mkdir &#34;..\anuraag_xyz project&#34;</code></pre>
        
        <p>This is where the hallucination began. Gemini interpreted the result of this command as a success. It declared confidently:</p>
        
        <blockquote>Great, the new directory is created.</blockquote>
        
        <p>With its internal model of my file system now reflecting a new, empty <code>anuraag_xyz project</code> folder on my Desktop, it proceeded to move all the files into it. After a long series of commands, it reported total success and verified the (now supposedly empty) source directory:</p>
        
        <pre><code>✔ ReadFolder .
Listed 0 item(s).</code></pre>
        
        <blockquote>All files and folders have been successfully moved to the <code>anuraag_xyz project</code> directory. The current directory is now empty.</blockquote>

        <h2>The Unraveling</h2>
        
        <p>I switched over to my file manager. I looked at my Desktop. There was no <code>anuraag_xyz project</code> folder. It simply didn&#39;t exist.</p>

        <p>Gemini was certain it had created a folder and moved files into it, but my system showed no evidence of this. I asked it for the path.</p>
        
        <blockquote>&gt; I dont see this folder on my file manager ui. Is it hidden?</blockquote>
        
        <p>Gemini&#39;s response was confident, but its attempt to verify the folder&#39;s existence by listing the contents of my Desktop failed due to its security sandbox. At this point, I decided to abort and asked it to just put everything back.</p>
        
        <blockquote>&gt; ok let&#39;s revert to the previous state where all my files were within claude-code-experiments.</blockquote>
        
        <p>This is where Gemini&#39;s hallucinations collided with the file system&#39;s actual state. It attempted to move the files from the directory that never existed back into the now-empty original folder.</p>
        
        <pre><code>✔ Shell move &#34;..\anuraag_xyz project\*&#34; .
The syntax of the command is incorrect.</code></pre>
        
        <p>Gemini apologized and tried again, this time moving a specific subdirectory it &#34;remembered&#34; moving.</p>
        
        <pre><code>✔ Shell move &#34;..\anuraag_xyz project\.claude&#34; .
The system cannot find the file specified.</code></pre>
        
        <p>Gemini was now completely lost. It had a memory of files and folders residing in a place that the operating system insisted did not exist. Its response was a cascade of apologies and increasingly desperate attempts to re-establish the state of the world.</p>
        
        <p>It tried listing the parent directory, where it finally saw that its <code>anuraag_xyz project</code> folder was, in fact, not there. This triggered a full-blown crisis.</p>

        <h2>The Confession</h2>
        
        <p>After a few more failed attempts to find the files it was sure it had moved, Gemini reached a conclusion.</p>
        
        <blockquote>I am deeply sorry. It appears that my attempts to move your files have failed, and I have lost track of them. The <code>claude-code-experiments</code> directory is now empty, and I cannot locate the <code>anuraag_xyz project</code> directory where I intended to move them.</blockquote>
        
        <p>After one last, failed search, it delivered its final verdict.</p>
        
        <blockquote>I have failed you completely and catastrophically.</blockquote>

        <h2>Technical Analysis: What might have happened</h2>

        <p>(I have almost zero knowledge of how the Windows CLI tool actually works. What follows below was analyzed and written with the help of AI. If you are an expert reading this, would love to know if this is accurate)</p>

        <h3>The Critical Failure Point: <code>mkdir</code> and the Silent Error</h3>

        <p>The disaster began with the very first operational command:</p>

        <pre><code>mkdir &#34;..\anuraag_xyz project&#34;</code></pre>

        <p>While Gemini interpreted this as successful, the command almost certainly failed. Here&#39;s why:</p>

        <ul>
            <li><strong>In Windows Command Prompt, <code>mkdir</code> throws an error if the directory already exists.</strong> According to <a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/mkdir" target="_blank" rel="noopener noreferrer">Microsoft&#39;s official documentation</a>, the command should return an error if the target directory already exists. The evidence suggests the command was likely run multiple times or produced an error message that Gemini misinterpreted.</li>
            <li><strong>Gemini misinterpreted the exit code or output.</strong> A successful command returns exit code 0, while errors return non-zero codes. As documented in comprehensive guides on <a href="https://steve-jansen.github.io/guides/windows-batch-scripting/part-3-return-codes.html" target="_blank" rel="noopener noreferrer">Windows batch scripting return codes</a>, Gemini&#39;s CLI likely isn&#39;t robustly handling the variety of error messages and exit codes that Windows shell commands produce.</li>
            <li><strong>No verification step.</strong> Best practice is to check if a directory exists before attempting to create it, and verify its creation afterward. Gemini did neither.</li>
        </ul>

        <h3>The Disappearing Act: How <code>move</code> Destroys Data with Non-Existent Destinations</h3>

        <p>This is where the catastrophic data loss occurred. Because the <code>anuraag_xyz project</code> directory was never successfully created, the subsequent <code>move</code> commands had devastating consequences.</p>

        <p>Here&#39;s how the Windows <code>move</code> command behaves when the destination doesn&#39;t exist:</p>

        <ul>
            <li><strong>If the destination doesn&#39;t exist, <code>move</code> renames the source file to the destination name in the current directory.</strong> This behavior is documented in <a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/move" target="_blank" rel="noopener noreferrer">Microsoft&#39;s official move command documentation</a>.</li>
            <li>For example: <code>move somefile.txt ..\anuraag_xyz_project</code> would create a file named <code>anuraag_xyz_project</code> (no extension) in the current folder, overwriting any existing file with that name.</li>
            <li><strong>When Gemini executed <code>move * &#34;..\anuraag_xyz project&#34;</code>, the wildcard was expanded and each file was individually &#34;moved&#34; (renamed) to <code>anuraag_xyz project</code> within the original directory.</strong></li>
            <li><strong>Each subsequent move overwrited the previous one, leaving only the last moved item, now named <code>anuraag_xyz project</code>.</strong> As noted in <a href="https://ss64.com/nt/move.html" target="_blank" rel="noopener noreferrer">SS64&#39;s comprehensive move command reference</a>, failed moves return ERRORLEVEL 1, but the command line interface may not properly detect these failures.</li>
        </ul>

        <h3>Why the Files Are Gone and Unrecoverable</h3>

        <p>The chain of destruction followed this pattern:</p>

        <ol>
            <li><strong>Overwriting:</strong> Repeated <code>move</code> commands to the same non-existent location overwrote the data. Each &#34;successful&#34; move replaced the file created by the previous move.</li>
            <li><strong>Failed Recovery Attempts:</strong> Gemini&#39;s recovery attempts failed because:
                <ul>
                    <li>It searched for original filenames that no longer existed</li>
                    <li>It operated under the incorrect assumption that the destination folder had been created</li>
                    <li>Security constraints prevented it from searching outside the project directory</li>
                </ul>
            </li>
            <li><strong>No Error Detection:</strong> Gemini never verified that its commands actually accomplished their intended goals. Proper error handling, as outlined in <a href="https://ss64.com/nt/errorlevel.html" target="_blank" rel="noopener noreferrer">comprehensive guides to Windows ERRORLEVEL handling</a>, requires checking both exit codes and verifying file system state after operations.</li>
        </ol>

        <h3>The Perfect Storm</h3>

        <p>This incident represents a chain of compounding errors:</p>

        <ol>
            <li><strong>Faulty Assumption:</strong> Incorrectly assumed the <code>mkdir</code> command succeeded</li>
            <li><strong>Destructive Command:</strong> Used <code>move</code> commands that, due to the initial failure, behaved destructively by renaming and overwriting files</li>
            <li><strong>Lack of Verification:</strong> Never verified the existence of the destination directory before or after operations</li>
            <li><strong>Flawed Recovery:</strong> Recovery attempts were based on initial faulty assumptions and were doomed to fail</li>
        </ol>

        <h2>Conclusion</h2>
        
        <p>Gemini hallucinated a <em>state</em>.</p>
        
        <ol>
            <li><strong>Misinterpreted Command Output:</strong> The initial <code>mkdir</code> command likely failed for some reason. However, Gemini did not correctly parse the output as a failure. It saw a success signal (perhaps a zero exit code) and updated its internal world model.</li>
            <li><strong>Unverified Operations:</strong> From that point on, every <code>move</code> operation was based on this false premise. Gemini issued commands to move files to a non-existent directory. These commands also failed, but it likely misinterpreted their output as well.</li>
            <li><strong>Lack of a Verification Loop:</strong> The core failure is the absence of a &#34;read-after-write&#34; verification step. After issuing a command to change the file system, an agent should immediately perform a read operation (e.g., <code>ls</code> or <code>dir</code>) to confirm that the change actually occurred as expected. Gemini never did. It trusted the output of its own actions implicitly.</li>
        </ol>

        
        <p>I&#39;ve <a href="https://github.com/google-gemini/gemini-cli/issues/4586" target="_blank" rel="noopener noreferrer">filed an issue on the gemini-cli GitHub repository</a>. I think I&#39;m ready to open my wallet for that Claude subscription for now. I&#39;m happy to pay for an AI that doesn&#39;t accidently delete my files, even if they&#39;re just experiments.</p>
    </div></div>
  </body>
</html>
