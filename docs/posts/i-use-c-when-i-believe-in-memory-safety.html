<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gavinhoward.com/2023/02/why-i-use-c-when-i-believe-in-memory-safety/">Original</a>
    <h1>I use C when I believe in memory safety</h1>
    
    <div id="readability-page-1" class="page"><div><p><strong>tl;dr</strong>: C is the only existing language I like to actually write.</p><h2 id="introduction">Introduction</h2><p>The NSA, bad as they are, released some <a href="https://media.defense.gov/2022/Nov/10/2003112742/-1/-1/0/CSI_SOFTWARE_MEMORY_SAFETY.PDF">good advice</a> recently.</p><p><a href="https://news.ycombinator.com/item?id=33553668">It</a> <a href="https://news.ycombinator.com/item?id=33560227">caused</a> <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2739r0.pdf">a</a> <a href="https://www.thecodedmessage.com/posts/stroustrup-response/">major</a> <a href="https://news.ycombinator.com/item?id=34627406">brouhaha</a>.</p><p>Which is stupid because it‚Äôs common sense advice at this point, and without a
good reason, this advice should be followed by default.</p><p>I <em>especially</em> don‚Äôt buy the arguments of Bjarne Stroustrup that C++ is not that
bad.</p><div><p>In fact, I think the complexity of C++ makes it <em>worse</em> than C.</p><p>I hate C++.</p></div><p>Jimmy Hartzell is right that</p><blockquote><p>For memory safety, ‚Äúmuch of‚Äù is not really good enough, and ‚Äúcould be made‚Äù is
practically worthless. Fundamentally, the point is that memory safety in C++
is a project being actively worked on, and close to existing. Meanwhile, Rust
(and Swift, C#, Java, and others) already implements memory safety.</p></blockquote><p>As much as I hate the <a href="https://enet4.github.io/rust-tropes/rust-evangelism-strike-force/">Rust Evangelism Strike Force</a>, they are right about
this, and Rust is the current best option for a C or C++ programmer.</p><p>So‚Ä¶my <a href="https://git.yzena.com/Yzena/Yc">current project</a>, an ostensibly professional project, is in C.</p><p>Am I a hypocrite?</p><p>Yes, actually, but please hear me out for the rest of the post. I have reasons,
I promise.</p><h2 id="documentation">Documentation</h2><p>The first reason is that I document everything about my assumptions.</p><p>Rust is great in many ways, and it is great at having code document itself.</p><p>For example, with explicit pointer types, it‚Äôs easy to see that they make it
easier to see how to use function parameters properly.</p><p>C just has value and pointer types. A pointer could be dynamically allocated or
point to something in an ancestor‚Äôs stack. Or something else entirely.</p><p>Rust has better type safety. You give C a <code>void*</code>, and it just shrugs
and accepts it as a pointer to anything.</p><p>Rust <em>is</em> better in those ways. Objectively.</p><p>I make up for it in various ways:</p><ul><li>I document <em>all</em> of my assumptions that I can think of, usually with code (in
asserts).</li><li>I document <em>every</em> function, its parameters and their uses.</li><li>I document <em>every</em> struct, every field, every enum.</li><li>I write design documents and development documents.</li></ul><p>This means that I get many of the advantages of Rust and also have good
documentation, which is delightful for my users later.</p><p>That‚Äôs not to say that Rust is better here; I just like that this forces me to
write documentation.</p><h2 id="i-work-alone">I Work Alone</h2><p>Second, I work alone on code that is entirely in my head.</p><p>Rust is great for teams because it removes many things that make working on team
code dangerous. The items mentioned above are some.</p><p>I work alone, however, because I like to keep my code in my head and working
with people means parts of the code are only in their head.</p><p>This also means that the bigger the language is, the less space I have in my
head for the code.</p><p>Rust is too big for my small brain, unfortunately.</p><h2 id="rust-isnt-fun-for-me">Rust Isn‚Äôt Fun for Me</h2><p>This brings me to my next reason: I don‚Äôt enjoy Rust.</p><p>Now, before the RESF gets on my case, let me say that this is purely a
<em>personal</em> preference! I am <em>not</em> saying that Rust is bad.</p><p>I‚Äôve written code in <em>so</em> many languages:</p><ul><li>C</li><li>C++</li><li>Rust</li><li>Haskell</li><li>Go</li><li>Python</li><li>PHP</li><li>Ruby</li><li>Zig</li><li>Bash</li><li>POSIX <code>sh</code></li><li><code>bc</code></li><li><code>dc</code></li><li>JavaScript</li><li>Clojure</li><li>Java</li><li>C#</li><li>Various assembly languages</li><li>GLSL</li><li>Common Lisp</li><li>Racket</li><li>Julia</li><li>Tcl</li><li>Vim script</li></ul><p>I have also studied far more, such as:</p><ul><li>ML</li><li>OCaml</li><li>HAL/S</li><li>Pascal</li><li>Objective-C</li><li>MATLAB</li><li>Modula-2</li><li>Coq</li><li>Isabelle/HOL</li><li>Ada/SPARK</li></ul><p>and many more.</p><p>When it comes to the enjoyment of programming, I hate <em>all</em> of them. With a
passion.</p><p>Except for C.</p><p>üò≤</p><p>That‚Äôs right: C is the only existing language I like to actually <em>write</em>.</p><p>I‚Äôm not kidding either; I am far more productive writing in C than anything else
by <em>orders of magnitude</em>. My mind just <em>works</em> with C, and I don‚Äôt know why.</p><p>That matters more with me than most programmers, too. From my experience, I am a
temperamental programmer; if my environment is not correct, I can‚Äôt program
effectively.</p><p>I can‚Äôt program effectively if I‚Äôm tired.</p><p>I can‚Äôt program effectively if I‚Äôm listening to slow music. (True story.)</p><p>I can‚Äôt program effectively if I‚Äôm overwhelmed by a task.</p><p>I can‚Äôt program effectively if I don‚Äôt have the entire software in my head.</p><p>I can‚Äôt program effectively if I think my wife is mad at me.</p><p>I‚Äôm usually overthinking things when I think that. My wife is lovely and
patient.</p><p>And finally, I can‚Äôt program effectively in a language I do not like.</p><p>I‚Äôve turned down a job offer because it was in C++, and I hate C++.</p><p>So I don‚Äôt use Rust or another memory-safe language because chances are, I‚Äôve
tried it, and I just can‚Äôt work effectively in it.</p><p>I know this is a personal problem and not a Rust problem. But boy, am I good at
C.</p><p>And I <em><strong>love</strong></em> it.</p><p>I love it so much that I actually enjoy <em>hunting down memory bugs and memory
leaks!</em></p><p>I know, I‚Äôm a freak.</p><p>But because I enjoy it, I <em>do</em> it.</p><h2 id="discipline">Discipline</h2><p>This brings me to my next reason: I have the discipline to write C at a high
level.</p><p>Discipline takes many forms in this case:</p><ul><li>I use only unsigned integers to avoid undefined behavior. I even simulate
signed 2‚Äôs complement with unsigned integers.</li><li>I run Clang and GCC with <code>-Wall</code>, <code>-pedantic</code>, and <code>-Werror</code>. This means I
eliminate <em>all</em> warnings at every stage of development.</li><li>I even run Clang with <code>-Weverything</code>, except for <a href="https://clang.llvm.org/docs/DiagnosticsReference.html#wpadded"><code>-Wpadded</code></a> because I
don‚Äôt care about padding in my structs (I carefully choose their layout) and
except for <a href="https://clang.llvm.org/docs/DiagnosticsReference.html#wc-98-c-11-c-14-c-17-compat"><code>-Wc++98-compat</code></a> because I don‚Äôt care about C++ 98
compatibility, which interferes with C11 <code>stdalign.h</code>.</li><li>I run sanitizers on my test suite and eliminate <em>everything</em>. Yes,
<em>everything</em>, even false positives.</li><li>I run Valgrind on my test suite and eliminate <em>everything</em>.</li><li>I run Helgrind on my test suite and eliminate <em>everything</em>, even false
positives.</li><li>I run static analyzers and eliminate <em>everything</em>, even false positives.</li></ul><p>You have no idea how <em>good</em> it feels to run Valgrind, or Clang, or ASan, or
TSan, again and again, smashing bugs again and again and finally see <em>nothing</em>.</p><p>Ah, sweet bliss and satisfaction.</p><p>I‚Ä¶may have just a touch of OCD when programming.</p><h2 id="experience">Experience</h2><p>That leads to the next reason: experience.</p><p>I have spent <em>so</em> much time with C doing that bug smashing, which means I have
spent more time with C than any other language. I know C <em>far</em> better than
anything else that might compete, and it isn‚Äôt even close.</p><p>That time would be hard to make up. If I started with Rust today, I believe it
would take me about a decade to get as good with Rust as I am with C.</p><p>That‚Äôs a lot of lost time.</p><h2 id="compilation-times">Compilation Times</h2><p>Lost time is central to the next reason: compilation times.</p><p>Now, I know Rust is getting a <em>lot</em> better. This is great!</p><p>But it‚Äôs still slow. On my 16-core machine, I can do a clean build of my
<a href="https://git.yzena.com/Yzena/Yc">current project</a> in the same amount of time it can take Rust to build <em>one
file</em>. This includes the test suite, which uses C for many separate test cases.</p><p>Another aspect is that the C file include model, as bad as it may be, is still
embarrassingly parallel. Rust is good, but it isn‚Äôt <em>as</em> good.</p><p>This is one reason I‚Äôve designed <a href="https://gavinhoward.com/tag/yao/">my language</a> to need as few dependencies
between files as possible, to recover some of that embarrassingly parallel
sweetness.</p><h2 id="custom-memory-safety">Custom Memory Safety</h2><p>The next reason is that during my time with C, I have developed a custom
software stack designed around memory safety.</p><ul><li>I have special array types that I use instead of straight pointers, and those
arrays store their bounds.</li><li>I have macros to index those arrays with a bounds check.</li><li>I have macros to calculate pointers from those arrays with a bounds check.</li><li>I have a stack allocator that allows me to pretend I have <code>alloca()</code> on every
platform.</li><li>The stack allocator lets me base <em>every</em> allocation in a stack frame.</li><li>The stack allocator knows about destructors, so it will call destructors when
freeing memory.</li><li>The stack allocator will free everything allocated in a scope if I call one
particular function.</li><li>The stack allocator will free everything allocated in a function if I call one
particular function.</li><li>I use structured concurrency, which means that if I pass data to a new thread,
I ensure that thread does <em>not</em> outlive the data passed to it.</li></ul><p>Simply put: every piece of data can trace its ancestry to a particular spot on
the stack, and data is <em>never</em> given to another object if that object‚Äôs lifetime
exceeds that of the data.</p><p>This means RAII, which means lifetimes and ownership, which means borrowing,
which means I‚Äôve reinvented the best parts of Rust in portable C11.</p><p>Basically. Having a compiler enforce stuff statically is still better.</p><p>All of this means that items are <em>always</em> deallocated in the same function they
were allocated in or as part of the same parent object that owns them.</p><p>This <em>vastly</em> reduces my double frees and use-after-frees. And because <em>all</em> of
my code does this, without exception, I might just eliminate them with enough
testing.</p><p>And the bounds checks obviously reduce the buffer overflows.</p><p>Of course, Jimmy Hartzell‚Äôs words still apply: anything less than perfect is not
good enough.</p><p>In other words, I am not using C; I am actually using the partially memory-safe
Gavin D. Howard dialect of C.</p><h2 id="i-will-rewrite-it">I Will Rewrite It</h2><p>The final reason is the only one that justifies my decision: my code <em>will</em> be
rewritten in a memory-safe language.</p><p>No, it won‚Äôt be Rust. It‚Äôs my own language. It‚Äôs called <a href="https://gavinhoward.com/tag/yao/">Yao</a>.</p><p>It‚Äôs currently under development as part of my <a href="https://git.yzena.com/Yzena/Yc">current project</a>, which is
why I‚Äôm not using it now.</p><p>As part of its bootstrap process, it will always be able to transpile to C.
That‚Äôs why I‚Äôm starting in C.</p><p>In fact, part of the reason I built custom memory safety stuff is so that Yao
could transpile to C and still be memory-safe.</p><p>This is the only reason I could justify that decision. All of the other reasons
above are excuses. <em>This</em> is the <em>real</em> reason.</p><p>That doesn‚Äôt mean that there are not <em>other</em> reasons to use C. I used it before,
to build a <a href="https://git.gavinhoward.com/gavin/bc"><code>bc</code></a> in C, but I did that because <code>bc</code> is needed to bootstrap a
Linux system, when only a C compiler and basic POSIX utilities are available
since <code>bc</code> is, itself, a basic POSIX utility. That justified the decision to use
C for <code>bc</code>.</p><p>But <em>nothing</em>, and I mean <em>nothing</em>, could justify the decision to use C for
software that nobody needs unless there was a plan to get memory safety soon.</p><p>And I do mean <em>soon</em>. I‚Äôm building a business around my <a href="https://git.yzena.com/Yzena/Yc">current project</a>,
and as part of that business, and because <a href="https://gavinhoward.com/2022/10/we-must-professionalize-programming-to-preserve-society-and-computing-freedom/">I believe I should</a>, I will
accept some liability for that project <em>for paying customers</em>.</p><p>You can bet that I do <em>not</em> want to accept liability for a project written in C.
It will be rewritten as soon as possible.</p><p>The other advantage of doing it as soon as possible is that there‚Äôs less to
rewrite.</p><h2 id="conclusion">Conclusion</h2><p>So those are my reasons.</p><p>Of course, you may disagree with my decision, and <em>that‚Äôs a valid opinion</em>. It‚Äôs
a <em>good</em> opinion.</p><p>But I can tell you this: I would not write this software at all if I didn‚Äôt
enjoy writing it. And I only enjoy C.</p><p>So for me personally, using C is inevitable.</p></div></div>
  </body>
</html>
