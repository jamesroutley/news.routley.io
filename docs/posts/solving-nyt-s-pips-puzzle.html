<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/solving-nyt-pips-puzzle">Original</a>
    <h1>Solving NYT&#39;s Pips Puzzle</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Pips is The New York Times&#39; daily puzzle where you have to place dominos onto a board within a set of region restrictions.</p><p>I wrote a solver for Pips by encoding the game logic and searching through a tree of legal game states until a complete board is found, along with optimizations to make it ~16× more efficient than a brute-force search.</p><p>I built a UI to help me debug my solver which you can see running below.</p><div><div><div><div><p>Puzzle: </p><!-- --><p>Easy 16th Oct 2025</p></div></div><p>Loading puzzle...</p></div></div><p>I also built a visualization of the search tree.
It shows the set of visited nodes. It&#39;s running in sync with the board above.
This gave me an intuitive understanding of how the search algorithm and optimizations were behaving.</p><p>A quick reminder of the region restrictions so it&#39;s easier for you non-players to follow along:</p><ul><li>Sum (all tiles must sum to <code>X</code>)</li><li>Equal (all tiles must be the same)</li><li>Not Equal (all tiles must not be the same)</li><li>Less/Greater (all tiles must sum to be less/greater than <code>X</code>)</li></ul><h2 id="recursing-the-tree">Recursing the Tree</h2><p>In order to solve a puzzle, I first needed to define the concept of a &#34;puzzle&#34; in code. So I created these types:</p><pre><div><div><p><span>type</span><span> </span><span>Pip</span><span> </span><span>=</span><span> </span><span>0</span><span> </span><span>|</span><span> </span><span>1</span><span> </span><span>|</span><span> </span><span>2</span><span> </span><span>|</span><span> </span><span>3</span><span> </span><span>|</span><span> </span><span>4</span><span> </span><span>|</span><span> </span><span>5</span><span> </span><span>|</span><span> </span><span>6</span><span>;</span><span></span></p><p><span></span><span>type</span><span> </span><span>DominoType</span><span> </span><span>=</span><span> </span><span>`</span><span>${</span><span>Pip</span><span>}</span><span>|</span><span>${</span><span>Pip</span><span>}</span><span>`</span><span>;</span><span></span></p><p><span></span><span>type</span><span> </span><span>DominoCounts</span><span> </span><span>=</span><span> Record</span><span>&lt;</span><span>DominoType</span><span>,</span><span> </span><span>number</span><span>&gt;</span><span>;</span><span></span></p><p><span></span><span>type</span><span> </span><span>Coord</span><span> </span><span>=</span><span> </span><span>[</span><span>number</span><span>,</span><span> </span><span>number</span><span>]</span><span>;</span><span></span></p><p><span></span><span>type</span><span> </span><span>Region</span><span> </span><span>=</span><span> </span></p><p><span>    </span><span>|</span><span> </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;sum&#39;</span><span>,</span><span> target</span><span>:</span><span> </span><span>number</span><span>,</span><span> cells</span><span>:</span><span> Coord</span><span>[</span><span>]</span><span> </span><span>}</span><span></span></p><p><span>    </span><span>|</span><span> </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;equal&#39;</span><span>,</span><span> cells</span><span>:</span><span> Coord</span><span>[</span><span>]</span><span> </span><span>}</span><span></span></p><p><span>    </span><span>|</span><span> </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;nequal&#39;</span><span>,</span><span> cells</span><span>:</span><span> Coord</span><span>[</span><span>]</span><span> </span><span>}</span><span></span></p><p><span>    </span><span>|</span><span> </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;less&#39;</span><span>,</span><span> target</span><span>:</span><span> </span><span>number</span><span>,</span><span> cells</span><span>:</span><span> Coord</span><span>[</span><span>]</span><span> </span><span>}</span><span></span></p><p><span>    </span><span>|</span><span> </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;greater&#39;</span><span>,</span><span> target</span><span>:</span><span> </span><span>number</span><span>,</span><span> cells</span><span>:</span><span> Coord</span><span>[</span><span>]</span><span> </span><span>}</span></p></div></div></pre><p>Which lets me define Easy/16/10/25 like so:</p><pre><div><div><p><span>const</span><span> Easy16thOct25</span><span>:</span><span> PuzzleDefinition </span><span>=</span><span> </span><span>{</span><span></span></p><p><span>    title</span><span>:</span><span> </span><span>&#39;Easy 16th Oct 2025&#39;</span><span>,</span><span></span></p><p><span>    cells</span><span>:</span><span> </span><span>[</span><span></span></p><p><span>        </span><span>[</span><span>0</span><span>,</span><span> </span><span>0</span><span>]</span><span>,</span><span> </span><span>[</span><span>0</span><span>,</span><span> </span><span>1</span><span>]</span><span>,</span><span> </span><span>[</span><span>0</span><span>,</span><span> </span><span>2</span><span>]</span><span>,</span><span> </span><span>[</span><span>0</span><span>,</span><span> </span><span>3</span><span>]</span><span>,</span><span></span></p><p><span>        </span><span>[</span><span>1</span><span>,</span><span> </span><span>0</span><span>]</span><span>,</span><span></span></p><p><span>        </span><span>[</span><span>2</span><span>,</span><span> </span><span>0</span><span>]</span><span>,</span><span> </span><span>[</span><span>2</span><span>,</span><span> </span><span>1</span><span>]</span><span>,</span><span> </span><span>[</span><span>2</span><span>,</span><span> </span><span>2</span><span>]</span><span>,</span><span> </span><span>[</span><span>2</span><span>,</span><span> </span><span>3</span><span>]</span><span>,</span><span></span></p><p><span>        </span><span>[</span><span>3</span><span>,</span><span> </span><span>3</span><span>]</span><span>,</span><span></span></p><p><span>        </span><span>[</span><span>4</span><span>,</span><span> </span><span>0</span><span>]</span><span>,</span><span> </span><span>[</span><span>4</span><span>,</span><span> </span><span>1</span><span>]</span><span>,</span><span> </span><span>[</span><span>4</span><span>,</span><span> </span><span>2</span><span>]</span><span>,</span><span> </span><span>[</span><span>4</span><span>,</span><span> </span><span>3</span><span>]</span><span>,</span><span></span></p><p><span>    </span><span>]</span><span>,</span><span></span></p><p><span>    regions</span><span>:</span><span> </span><span>[</span><span></span></p><p><span>        </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;sum&#39;</span><span>,</span><span> target</span><span>:</span><span> </span><span>7</span><span>,</span><span> cells</span><span>:</span><span> </span><span>[</span><span>[</span><span>0</span><span>,</span><span> </span><span>0</span><span>]</span><span>,</span><span> </span><span>[</span><span>1</span><span>,</span><span> </span><span>0</span><span>]</span><span>]</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>        </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;sum&#39;</span><span>,</span><span> target</span><span>:</span><span> </span><span>6</span><span>,</span><span> cells</span><span>:</span><span> </span><span>[</span><span>[</span><span>0</span><span>,</span><span> </span><span>1</span><span>]</span><span>,</span><span> </span><span>[</span><span>0</span><span>,</span><span> </span><span>2</span><span>]</span><span>]</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>        </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;sum&#39;</span><span>,</span><span> target</span><span>:</span><span> </span><span>12</span><span>,</span><span> cells</span><span>:</span><span> </span><span>[</span><span>[</span><span>2</span><span>,</span><span> </span><span>0</span><span>]</span><span>,</span><span> </span><span>[</span><span>2</span><span>,</span><span> </span><span>1</span><span>]</span><span>]</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>        </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;equal&#39;</span><span>,</span><span> cells</span><span>:</span><span> </span><span>[</span><span>[</span><span>2</span><span>,</span><span> </span><span>2</span><span>]</span><span>,</span><span> </span><span>[</span><span>2</span><span>,</span><span> </span><span>3</span><span>]</span><span>,</span><span> </span><span>[</span><span>3</span><span>,</span><span> </span><span>3</span><span>]</span><span>,</span><span> </span><span>[</span><span>4</span><span>,</span><span> </span><span>3</span><span>]</span><span>]</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>        </span><span>{</span><span> kind</span><span>:</span><span> </span><span>&#39;less&#39;</span><span>,</span><span> target</span><span>:</span><span> </span><span>3</span><span>,</span><span> cells</span><span>:</span><span> </span><span>[</span><span>[</span><span>4</span><span>,</span><span> </span><span>0</span><span>]</span><span>]</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>    </span><span>]</span><span>,</span><span></span></p><p><span>    dominos</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>&#39;5|5&#39;</span><span>:</span><span> </span><span>1</span><span>,</span><span> </span><span>&#39;2|6&#39;</span><span>:</span><span> </span><span>1</span><span>,</span><span> </span><span>&#39;4|5&#39;</span><span>:</span><span> </span><span>1</span><span>,</span><span> </span><span>&#39;1|6&#39;</span><span>:</span><span> </span><span>1</span><span>,</span><span> </span><span>&#39;0|4&#39;</span><span>:</span><span> </span><span>1</span><span>,</span><span> </span><span>&#39;3|4&#39;</span><span>:</span><span> </span><span>1</span><span>,</span><span> </span><span>&#39;5|6&#39;</span><span>:</span><span> </span><span>1</span><span>,</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>}</span><span>;</span></p></div></div></pre><p>The core part of my solver is a Depth-First Search (DFS) which goes through all the legal pair placements. There are two important concepts here.</p><ol start="1"><li>We&#39;re picking the next <em>pair</em> of cells, not the next single cell.</li><li>Pips boards are not rectangles. They can be any grid shape.</li></ol><p>My solver starts by building an adjacency list so that, later, when my solver loops over the free cells, it&#39;s easy to find its neighbors (where the other end of the domino can land).</p><pre><div><div><p><span>// Generate adjacency list showing which cells are neighbors</span><span></span></p><p><span></span><span>// e.g.</span><span></span></p><p><span></span><span>// input cells: [ [ 0, 1 ], [ 0, 2 ], [ 1, 1 ], [ 1, 2 ] ]</span><span></span></p><p><span></span><span>// output neighbors: [ [ 1, 2 ], [ 3, 0 ], [ 3, 0 ], [ 2, 1 ] ]</span><span></span></p><p><span></span><span>// which describes the grid graph:</span><span></span></p><p><span></span><span>// (0,1) -- (0,2)</span><span></span></p><p><span></span><span>//   |        |</span><span></span></p><p><span></span><span>// (1,1) -- (1,2)</span><span></span></p><p><span></span><span>function</span><span> </span><span>buildCells</span><span>(</span><span>cells</span><span>:</span><span> Coord</span><span>[</span><span>]</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> idByKey </span><span>=</span><span> </span><span>new</span><span> </span><span>Map</span><span>&lt;</span><span>string</span><span>,</span><span> </span><span>number</span><span>&gt;</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>    cells</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>[</span><span>r</span><span>,</span><span> c</span><span>]</span><span>,</span><span> i</span><span>)</span><span> </span><span>=&gt;</span><span> idByKey</span><span>.</span><span>set</span><span>(</span><span>cellKey</span><span>(</span><span>r</span><span>,</span><span> c</span><span>)</span><span>,</span><span> i</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>const</span><span> </span><span>M</span><span> </span><span>=</span><span> cells</span><span>.</span><span>length</span><span>;</span><span></span></p><p><span>    </span><span>const</span><span> neighbors</span><span>:</span><span> </span><span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span> </span><span>=</span><span> </span><span>Array</span><span>.</span><span>from</span><span>(</span><span>{</span><span> length</span><span>:</span><span> </span><span>M</span><span> </span><span>}</span><span>,</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>[</span><span>]</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>(</span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>M</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>const</span><span> </span><span>[</span><span>r</span><span>,</span><span> c</span><span>]</span><span> </span><span>=</span><span> cells</span><span>[</span><span>i</span><span>]</span><span>;</span><span></span></p><p><span>        </span><span>// Check all 4 cardinal neighbors</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>(</span><span>const</span><span> </span><span>[</span><span>rr</span><span>,</span><span> cc</span><span>]</span><span> </span><span>of</span><span> </span><span>[</span><span>[</span><span>r</span><span>,</span><span> c </span><span>+</span><span> </span><span>1</span><span>]</span><span>,</span><span> </span><span>[</span><span>r </span><span>+</span><span> </span><span>1</span><span>,</span><span> c</span><span>]</span><span>,</span><span> </span><span>[</span><span>r</span><span>,</span><span> c </span><span>-</span><span> </span><span>1</span><span>]</span><span>,</span><span> </span><span>[</span><span>r </span><span>-</span><span> </span><span>1</span><span>,</span><span> c</span><span>]</span><span>]</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>const</span><span> hit </span><span>=</span><span> idByKey</span><span>.</span><span>get</span><span>(</span><span>cellKey</span><span>(</span><span>rr</span><span>,</span><span> cc</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>hit </span><span>!==</span><span> </span><span>undefined</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                neighbors</span><span>[</span><span>i</span><span>]</span><span>.</span><span>push</span><span>(</span><span>hit</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>{</span><span> </span><span>M</span><span>,</span><span> neighbors </span><span>}</span><span>;</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>My solver uses recursion to perform the DFS. It tries to place every domino at once until it hits an illegal board state, then backtracks to the nearest legal board state and continues.</p><p>I&#39;ve commented out the less interesting sections to give you an overview.</p><pre><div><div><p><span>async</span><span> </span><span>function</span><span> </span><span>solve</span><span>(</span><span></span></p><p><span>    cells</span><span>:</span><span> Coord</span><span>[</span><span>]</span><span>,</span><span></span></p><p><span>    regions</span><span>:</span><span> Region</span><span>[</span><span>]</span><span>,</span><span></span></p><p><span>    dominos</span><span>:</span><span> DominoCounts</span><span>,</span><span></span></p><p><span></span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// Adjacency list of neighbors from the above snippet</span><span></span></p><p><span>    </span><span>const</span><span> </span><span>{</span><span> </span><span>M</span><span>,</span><span> neighbors </span><span>}</span><span> </span><span>=</span><span> </span><span>buildCells</span><span>(</span><span>cells</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// Pick all possible pairs of neighboring cells to place a domino on</span><span></span></p><p><span>    </span><span>function</span><span> </span><span>pickPairs</span><span>(</span><span>)</span><span>:</span><span> </span><span>[</span><span>number</span><span>,</span><span> </span><span>number</span><span>]</span><span>[</span><span>]</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>let</span><span> i </span><span>=</span><span> </span><span>-</span><span>1</span><span>;</span><span></span></p><p><span>        </span><span>// Choose the first empty cell</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>(</span><span>let</span><span> k </span><span>=</span><span> </span><span>0</span><span>;</span><span> k </span><span>&lt;</span><span> </span><span>M</span><span>;</span><span> k</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>board</span><span>[</span><span>k</span><span>]</span><span> </span><span>===</span><span> </span><span>null</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                i </span><span>=</span><span> k</span><span>;</span><span></span></p><p><span>                </span><span>break</span><span>;</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// No more cells to place a domino on</span><span></span></p><p><span>        </span><span>// =&gt; we&#39;ve solved the puzzle</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>i </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>[</span><span>]</span><span> </span><span>}</span><span></span></p><p><span>        </span><span>// Collect all empty neighbors</span><span></span></p><p><span>        </span><span>const</span><span> pairs</span><span>:</span><span> </span><span>[</span><span>number</span><span>,</span><span> </span><span>number</span><span>]</span><span>[</span><span>]</span><span> </span><span>=</span><span> </span><span>[</span><span>]</span><span>;</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>(</span><span>let</span><span> j </span><span>of</span><span> neighbors</span><span>[</span><span>i</span><span>]</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>board</span><span>[</span><span>j</span><span>]</span><span> </span><span>===</span><span> </span><span>null</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                pairs</span><span>.</span><span>push</span><span>(</span><span>[</span><span>i</span><span>,</span><span> j</span><span>]</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>return</span><span> pairs</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// Place domino by mutating `board` and `remaining`</span><span></span></p><p><span>    </span><span>function</span><span> </span><span>place</span><span>(</span><span>i</span><span>:</span><span> </span><span>number</span><span>,</span><span> a</span><span>:</span><span> Pip</span><span>,</span><span> j</span><span>:</span><span> </span><span>number</span><span>,</span><span> b</span><span>:</span><span> Pip</span><span>)</span><span> </span><span>{</span><span> </span><span>/* .. */</span><span>}</span><span></span></p><p><span>    </span><span>// Unplace domino by mutating `board` and `remaining`</span><span></span></p><p><span>    </span><span>function</span><span> </span><span>unplace</span><span>(</span><span>i</span><span>:</span><span> </span><span>number</span><span>,</span><span> a</span><span>:</span><span> Pip</span><span>,</span><span> j</span><span>:</span><span> </span><span>number</span><span>,</span><span> b</span><span>:</span><span> Pip</span><span>)</span><span>:</span><span> </span><span>void</span><span> </span><span>{</span><span> </span><span>/* .. */</span><span> </span><span>}</span><span></span></p><p><span>    </span><span>// Checks regions are legal (and further checks when optimizations are enabled)</span><span></span></p><p><span>    </span><span>function</span><span> </span><span>checks</span><span>(</span><span>board</span><span>:</span><span> </span><span>(</span><span>Pip </span><span>|</span><span> </span><span>null</span><span>)</span><span>[</span><span>]</span><span>)</span><span>:</span><span> </span><span>boolean</span><span> </span><span>{</span><span> </span><span>/* .. */</span><span> </span><span>}</span><span></span></p><p><span>    </span><span>async</span><span> </span><span>function</span><span> </span><span>dfs</span><span>(</span><span>)</span><span>:</span><span> </span><span>Promise</span><span>&lt;</span><span>boolean</span><span>&gt;</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>const</span><span> pairs </span><span>=</span><span> </span><span>pickPairs</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>pairs</span><span>.</span><span>length </span><span>===</span><span> </span><span>0</span><span>)</span><span> </span><span>return</span><span> </span><span>false</span><span>;</span><span></span></p><p><span>        </span><span>// Try each possible pair</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>(</span><span>const</span><span> </span><span>[</span><span>i</span><span>,</span><span> j</span><span>]</span><span> </span><span>of</span><span> pairs</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>for</span><span> </span><span>(</span><span>const</span><span> t </span><span>in</span><span> remaining</span><span>)</span><span> </span><span>if</span><span> </span><span>(</span><span>remaining</span><span>[</span><span>t</span><span>]</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                </span><span>const</span><span> </span><span>[</span><span>a</span><span>,</span><span> b</span><span>]</span><span> </span><span>=</span><span> t</span><span>.</span><span>split</span><span>(</span><span>&#39;|&#39;</span><span>)</span><span>.</span><span>map</span><span>(</span><span>Number</span><span>)</span><span>;</span><span></span></p><p><span>                </span><span>// Orientation 1</span><span></span></p><p><span>                </span><span>if</span><span> </span><span>(</span><span>place</span><span>(</span><span>i</span><span>,</span><span> a</span><span>,</span><span> j</span><span>,</span><span> b</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                    </span><span>// Check rules first to trim the search space</span><span></span></p><p><span>                    </span><span>// then continue searching</span><span></span></p><p><span>                    </span><span>if</span><span> </span><span>(</span><span>checks</span><span>(</span><span>board</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>await</span><span> </span><span>dfs</span><span>(</span><span>)</span><span>)</span><span> </span><span>return</span><span> </span><span>true</span><span>;</span><span></span></p><p><span>                    </span><span>unplace</span><span>(</span><span>i</span><span>,</span><span> a</span><span>,</span><span> j</span><span>,</span><span> b</span><span>)</span><span>;</span><span></span></p><p><span>                </span><span>}</span><span></span></p><p><span>                </span><span>// Orientation 2</span><span></span></p><p><span>                </span><span>// (same as above with `a` and `b` swapped)</span><span></span></p><p><span>                </span><span>if</span><span> </span><span>(</span><span>place</span><span>(</span><span>i</span><span>,</span><span> b</span><span>,</span><span> j</span><span>,</span><span> a</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                    </span><span>if</span><span> </span><span>(</span><span>checks</span><span>(</span><span>board</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>await</span><span> </span><span>dfs</span><span>(</span><span>)</span><span>)</span><span> </span><span>return</span><span> </span><span>true</span><span>;</span><span></span></p><p><span>                    </span><span>unplace</span><span>(</span><span>i</span><span>,</span><span> b</span><span>,</span><span> j</span><span>,</span><span> a</span><span>)</span><span>;</span><span></span></p><p><span>                </span><span>}</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>return</span><span> </span><span>false</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>await</span><span> </span><span>dfs</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>{</span><span> solution</span><span>:</span><span> solved</span><span>,</span><span> cells</span><span>,</span><span> nodes </span><span>}</span><span>;</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>A branch of the search tree becomes dead when it fails the region check inside the <code>checks()</code> call. I loop each region and verify that the rule has not been broken e.g. if the sum of the cells is more than the sum constraint for that region.</p><pre><div><div><p><span>for</span><span> </span><span>(</span><span>const</span><span> r </span><span>of</span><span> regions</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// `vals` is the partial or complete list of this region&#39;s values</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>r</span><span>.</span><span>kind </span><span>===</span><span> </span><span>&#39;sum&#39;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>const</span><span> sum </span><span>=</span><span> vals</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>a</span><span>,</span><span> b</span><span>)</span><span> </span><span>=&gt;</span><span> a </span><span>+</span><span> b</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>// Prune if partial sum already exceeds target</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>sum </span><span>&gt;</span><span> r</span><span>.</span><span>target</span><span>)</span><span> </span><span>return</span><span> </span><span>false</span><span>;</span><span></span></p><p><span>        </span><span>// When region filled, sum must match exactly</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>vals</span><span>.</span><span>length </span><span>===</span><span> r</span><span>.</span><span>cells</span><span>.</span><span>length </span><span>&amp;&amp;</span><span> sum </span><span>!==</span><span> r</span><span>.</span><span>target</span><span>)</span><span> </span><span>return</span><span> </span><span>false</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// .. rest of region checks</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Up to this point, I&#39;ve described a brute-force method that searches every possible value. This method can be applied to other puzzle games where the number of legal board states can be checked within a reasonable amount of time.</p><p>When I run the solver against the Hard/16/20/25 puzzle, it checks 21337 nodes and takes 35 milliseconds (even with my unoptimized code which is rather wasteful indeed).</p><p>Once I had the solver up and running, I added a few optimizations to see how low I could get the node count for a range of Pips puzzles. FYI you can scrape Pips puzzles from the New York Times website if you check the network tab!</p><h2 id="optimizations">Optimizations</h2><p>Let me show you the unoptimized solver taking on Hard/16/20/25. Watch it for a minute and see if you can think of any optimizations that would lower the number of nodes that the solver needs to visit.</p><p>Are there any checks we can perform to kill branches sooner?</p><div><div><div><div><p>Puzzle: </p><!-- --><p>Hard 16th Oct 2025</p></div></div><p>Loading puzzle...</p></div></div><p>The first optimization I found was quite silly and simple and had a huge impact. If you recall the <code>solver()</code> function code from above, for each domino I check both orientations. For example, <code>5|6</code> can also be placed like <code>6|5</code>. However, I didn&#39;t have a check for when the sides of the domino are the same! So the solver would do a lot of duplicate work for dominos like <code>3|3</code>.</p><p>The fix was simple: check for matching sides before searching the branch for the flipped orientation.</p><pre><div><div><p><span>// Orientation 2</span><span></span></p><p><span></span><span>if</span><span> </span><span>(</span><span>!</span><span>(</span><span>flags</span><span>?.</span><span>SKIP_DUPLICATE_DOMINOES</span><span> </span><span>&amp;&amp;</span><span></span></p><p><span>    </span><span>// Check for matching sides</span><span></span></p><p><span>    a </span><span>===</span><span> b</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// .. only then search the branch</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>This reduced the number of nodes required for Hard/16/20/25 from 21337 to 7618.</p><p>I found the next optimization after watching the solver for a while. I noticed that the solver would place a domino in a way that created an isolated cell (i.e. only room for a domino <em>half</em>) – and then keep going down the branch for a while! To a human, avoiding placements that create isolated cells is the most obvious thing in the world. So much so, that I forgot about implementing such a rule when I was writing the first version of the solver.</p><p>For example, below is a Pips board with a single-row in an unsolvable state due to the domino (<code>6|5</code>) that has isolated a cell on the left (the <code>_</code> are empty cells).</p><pre></pre><p>To implement this optimization, I added a new check into my <code>checks()</code> function to trim branches as soon as they had created an isolated cell.</p><pre><div><div><p><span>function</span><span> </span><span>checkForIsolatedEmptyCells</span><span>(</span><span>)</span><span>:</span><span> </span><span>boolean</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>(</span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>M</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>board</span><span>[</span><span>i</span><span>]</span><span> </span><span>===</span><span> </span><span>null</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>// Check if this empty cell has any empty neighbors</span><span></span></p><p><span>            </span><span>const</span><span> hasEmptyNeighbor </span><span>=</span><span> neighbors</span><span>[</span><span>i</span><span>]</span><span>.</span><span>some</span><span>(</span><span>j </span><span>=&gt;</span><span> board</span><span>[</span><span>j</span><span>]</span><span> </span><span>===</span><span> </span><span>null</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>!</span><span>hasEmptyNeighbor</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                </span><span>return</span><span> </span><span>true</span><span>;</span><span> </span><span>// Found an isolated empty cell</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>false</span><span>;</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Combined with skipping duplicate dominos, this optimization lowered the nodes required for Hard/16/20/25 from 7618 to 5777.</p><p>The final optimization I added made the region check more intelligent. Up to this point, my region check required the region to be in an illegal state. However, there are cases when we know <em>ahead</em> of time that, even though a region isn&#39;t illegal yet, given the remaining dominos it is no longer possible to satisfy the region condition.</p><p>For example, if I&#39;ve just played a <code>6</code> into an equals-region and I have no other spare dominos with a <code>6</code>, then I will never be able to complete that region, and I can trim the branch there and then.</p><p>I added a new check to my <code>checks()</code> function that asserts that, given what we know, and what we can work out without too much complexity, all the board&#39;s regions must be solvable in the future.</p><p>To keep the code snippet brief, I&#39;ll just show the equals and not-equals checks.</p><pre><div><div><p><span>for</span><span> </span><span>(</span><span>const</span><span> region </span><span>of</span><span> regions</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// Count how many empty cells remain in this region</span><span></span></p><p><span>    </span><span>const</span><span> emptyCells </span><span>=</span><span> region</span><span>.</span><span>cells</span><span>.</span><span>length </span><span>-</span><span> placedVals</span><span>.</span><span>length</span><span>;</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>emptyCells </span><span>===</span><span> </span><span>0</span><span>)</span><span> </span><span>continue</span><span>;</span><span> </span><span>// Region already filled</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>region</span><span>.</span><span>kind </span><span>===</span><span> </span><span>&#39;equal&#39;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Only check if at least one cell has been placed</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>placedVals</span><span>.</span><span>length </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>const</span><span> mustMatch </span><span>=</span><span> placedVals</span><span>[</span><span>0</span><span>]</span><span>;</span><span></span></p><p><span>            </span><span>const</span><span> availablePips </span><span>=</span><span> sparePips</span><span>.</span><span>filter</span><span>(</span><span>p </span><span>=&gt;</span><span> p </span><span>===</span><span> mustMatch</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>// We must have enough matching domino parts</span><span></span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>availablePips</span><span>.</span><span>length </span><span>&lt;</span><span> emptyCells</span><span>)</span><span> </span><span>return</span><span> </span><span>false</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>region</span><span>.</span><span>kind </span><span>===</span><span> </span><span>&#39;nequal&#39;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Must have enough unique values that differ from placed values</span><span></span></p><p><span>        </span><span>const</span><span> uniqueAvailable </span><span>=</span><span> </span><span>new</span><span> </span><span>Set</span><span>(</span><span>sparePips</span></p><p><span>            </span><span>.</span><span>filter</span><span>(</span><span>p </span><span>=&gt;</span><span> </span><span>!</span><span>placedVals</span><span>.</span><span>includes</span><span>(</span><span>p</span><span>)</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>uniqueAvailable</span><span>.</span><span>size </span><span>&lt;</span><span> emptyCells</span><span>)</span><span> </span><span>return</span><span> </span><span>false</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// .. rest of region types</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Adding on this intelligent-regions-check reduced the nodes needed to solve Hard/16/20/25 from 5777 to 1355!</p><p>Here&#39;s the optimized solver running on the same Hard/16/20/25 puzzle as the start of this section, now checking almost 16× less nodes.</p><div><div><div><div><p>Puzzle: </p><!-- --><p>Hard 16th Oct 2025</p></div></div><p>Loading puzzle...</p></div></div><p>I also tried some <em>move ordering</em> ideas but wasn&#39;t able to get anything working that didn&#39;t regress most of the puzzles I was testing with.</p><p>Move ordering is a really great lever when you have a DFS/backtracking solver that&#39;s <em>correct but slow</em>. Changing the order that you search the tree doesn&#39;t alter the completeness, or correctness, it only changes the order that the tree is explored. The hope is that this nudges the solver to find the golden branch sooner rather than later.</p><p>It felt odd that I wasn&#39;t able to get move ordering working since I&#39;ve been able to apply it in my <a href="https://healeycodes.com/building-my-own-chess-engine">chess</a>, <a href="https://healeycodes.com/building-and-solving-sokoban">sokoban</a>, and <a href="https://healeycodes.com/solving-queuedle">queuedle solvers</a>! I must be missing something about tile-like puzzles like Pips.</p><p>I ran out of time to add further optimizations but my intuition is that I&#39;ve only scratched the surface here. I also haven&#39;t spent any time making the solver code run faster (e.g. things like <a href="https://healeycodes.com/visualizing-chess-bitboards">bitboards</a>).</p><h2 id="ui">UI</h2><p>I&#39;ve inlined two kinds of component in this post. The Pips board aims to be a faithful-ish clone of the Pips UI on the NYT website. It&#39;s more cramped (you could also say, badly designed) and sterile but I&#39;ve grown to like it.</p><p>The Pips board uses React to render fixed sized divs with fixed sized regions that use absolute position and z-indexes to handle the layers. The tree-view I showed at the top draws lines onto a canvas with a little bit of angle math.</p><p>When I was wiring the solver up to the UI I ran into two problems.</p><p>The first problem was that the solver&#39;s internal board is made up of individual <em>cells</em> not dominos. Even though the cells are placed and unplaced in pairs, as soon as they land on the board that relationship is lost. So when I first saw the rendered board, it was a bunch of separated dominos halves (squares). I had to go back and track the domino pair relationship.</p><p>The second problem was performance issues when drawing the canvas. My initial implementation did a complete re-draw of the canvas for every node. So obviously, this is extremely wasteful but it worked fine and I just wanted to ship it. To add some back-off, I pushed the new trees into a buffer and only rendered the latest one (dropping old data), I also used <code>requestAnimationFrame</code> / <code>cancelAnimationFrame</code> to drop frames. Hopefully this should stabilize the animation on your slow device but let me know otherwise!</p><p>All the code for the solver and the UI are embedded in this website and the relevant code file can be <a href="https://github.com/healeycodes/healeycodes.com/blob/main/components/visuals/pips/components.tsx">found here</a>.</p></div></div></div>
  </body>
</html>
