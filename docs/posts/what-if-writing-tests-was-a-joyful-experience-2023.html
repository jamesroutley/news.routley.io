<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.janestreet.com/the-joy-of-expect-tests/">Original</a>
    <h1>What if writing tests was a joyful experience? (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>At Jane Street we use a pattern/library called “expect tests” that
makes test-writing feel like a REPL session, or like exploratory
programming in a Jupyter notebook—with feedback cycles so fast and
joyful that it feels almost tactile. Having used them for some time now
this is the only way I’d ever want to write tests.</p>

<p>Other languages call these “snapshot” tests—see for example Rust’s
  <a href="https://github.com/rust-analyzer/expect-test">expect-test</a>, which seems to have been inspired
  by our library, or Javascript’s <a href="https://jestjs.io/docs/snapshot-testing#inline-snapshots">Jest</a>. We
  were first put onto the idea ourselves by Mercurial’s <a href="https://www.mercurial-scm.org/wiki/WritingTests">unified
  testing format</a>, and so-called <a href="https://bitheap.org/cram/">“cram”
  tests</a>, for testing shell sessions.</p>

<p>In most testing frameworks I’ve used, even the simplest assertions
require a surprising amount of toil. Suppose you’re writing a test for
a <code>fibonacci</code> function. You start writing <code>assert fibonacci(15) ==
...</code> and already you’re forced to think. What <em>does</em> <code>fibonacci(15)</code>
equal? If you already know, terrific—but what are you meant to do
if you don’t?</p>

<p>I think you’re supposed to write some nonsense, like <code>assert
fibonacci(15) == 8</code>, then when the test says “WRONG! Expected 8, got
610”, you’re supposed to copy and paste the 610 from your terminal
buffer into your editor.</p>

<p>This is insane!</p>

<p>Here’s how you’d do it with an expect test:</p>

<div><pre><code><span>printf</span> <span>&#34;%d&#34;</span> <span>(</span><span>fibonacci</span> <span>15</span><span>);</span>
<span>[%</span><span>expect</span> <span>{||}]</span>
</code></pre>
</div>

<p>The <code>%expect</code> block starts out blank precisely because you don’t know
what to expect. You let the computer figure it out for you. In our
setup, you don’t just get a build failure telling you that you want
610 instead of a blank string. You get a diff showing you the exact
change you’d need to make to your file to make this test pass; and
with a keybinding you can “accept” that diff. The Emacs buffer you’re
in will literally be overwritten in place with the new contents [1]:</p>

<p><img src="https://blog.janestreet.com/the-joy-of-expect-tests/outputFile.gif"/>
</p>

<p>It’s hard to overstate how powerful this workflow is. To “write a
test” you just drop an <code>[%expect]</code> block below some code and it will
get filled in with whatever that code prints.</p>

<p>Just the other day I was writing a tricky little function that rounds
numbers under an unusual set of constraints; it was exactly the kind
of thing you’d want to write in a REPL or Jupyter notebook, to iterate
quickly against lots of examples. All I had to do was write the
following right below my function:</p>

<div><pre><code><span>let</span><span>%</span><span>expect_test</span> <span>&#34;Test the [round] function on [examples]&#34;</span> <span>=</span>
  <span>Ascii_table</span><span>.</span><span>simple_list_table</span>
    <span>[</span> <span>&#34;n&#34;</span><span>;</span> <span>&#34;f(n)&#34;</span> <span>]</span>
    <span>(</span><span>List</span><span>.</span><span>map</span> <span>examples</span> <span>~</span><span>f</span><span>:(</span><span>fun</span> <span>n</span> <span>-&gt;</span> <span>[</span> <span>n</span><span>;</span> <span>round</span> <span>n</span> <span>]</span> <span>|&gt;</span> <span>List</span><span>.</span><span>map</span> <span>~</span><span>f</span><span>:</span><span>string_of_float</span><span>));</span>
  <span>[%</span><span>expect</span> <span>{||}]</span>
</code></pre>
</div>

<p>and voila my editor produced a little table of results. Naturally my
first implementation had all kinds of bugs—some entries in the table
looked wrong. Improving the function became a matter of fiddling,
observing the diffs that produced, fiddling some more, and so on,
until the table finally looked the way I liked. (Had I wanted, I could
have at that point used something like <a href="https://blog.janestreet.com/quickcheck-for-core/">Quickcheck</a> to do
exhaustive fuzz testing.) The table meantime lived on as
documentation—indeed for many functions, seeing a handful of example
inputs and outputs is a lot clearer than a prose description.</p>

<p>Of course, the table is not just an exploratory aid and a bit of
documentation but also, you know, a test. If someone ever tweaks my
function or any of its dependencies, the frozen output in the
<code>[%expect]</code> block guards against unexpected behavior. In expect tests,
regressions are just diffs.</p>

<p>(In general, although it’s possible to inline tests right where the
code is written, at Jane Street we tend to clearly separate test and
real code. Tests live in their own directory and are written against
the public interface, or, when testing private implementations,
against a <code>For_testing</code> module exported just for that purpose.)</p>



<p>Back when I worked at a Ruby web dev shop we used to write a lot of
tests like the following, taken from a <a href="https://semaphoreci.com/community/tutorials/getting-started-with-rspec">blog post</a> about RSpec,
a popular Ruby testing framework:</p>

<div><pre><code><span>before</span> <span>do</span>
  <span>@book</span> <span>=</span> <span>Book</span><span>.</span><span>new</span><span>(</span><span>:title</span> <span>=&gt;</span> <span>&#34;RSpec Intro&#34;</span><span>,</span> <span>:price</span> <span>=&gt;</span> <span>20</span><span>)</span>
  <span>@customer</span> <span>=</span> <span>Customer</span><span>.</span><span>new</span>
  <span>@order</span> <span>=</span> <span>Order</span><span>.</span><span>new</span><span>(</span><span>@customer</span><span>,</span> <span>@book</span><span>)</span>

  <span>@order</span><span>.</span><span>submit</span>
<span>end</span>

<span>describe</span> <span>&#34;customer&#34;</span> <span>do</span>
  <span>it</span> <span>&#34;puts the ordered book in customer&#39;s order history&#34;</span> <span>do</span>
    <span>expect</span><span>(</span><span>@customer</span><span>.</span><span>orders</span><span>).</span><span>to</span> <span>include</span><span>(</span><span>@order</span><span>)</span>
    <span>expect</span><span>(</span><span>@customer</span><span>.</span><span>ordered_books</span><span>).</span><span>to</span> <span>include</span><span>(</span><span>@book</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>describe</span> <span>&#34;order&#34;</span> <span>do</span>
  <span>it</span> <span>&#34;is marked as complete&#34;</span> <span>do</span>
    <span>expect</span><span>(</span><span>@order</span><span>).</span><span>to</span> <span>be_complete</span>
  <span>end</span>

  <span>it</span> <span>&#34;is not yet shipped&#34;</span> <span>do</span>
    <span>expect</span><span>(</span><span>@order</span><span>).</span><span>not_to</span> <span>be_shipped</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>

<p>This is a perfectly lovely test. But think: everything in those
<code>describe</code> blocks had to be written by hand. The programmer first had
to decide what properties they cared about—(<code>customer.orders</code>,
<code>customer.ordered_books</code>, <code>order.complete</code>, <code>order.shipped</code>)—then
also had to say explicitly what state they expected each field to be
in. Then they had to type it all out.</p>

<p>My main claim is that all that deciding and typing is painful enough
that it actually discourages you from writing tests. Tests become a
bummer instead of a multi-tool that helps you:</p>

<ul>
  <li>visualize behavior as you hack on an implementation</li>
  <li>express and document intent</li>
  <li>freeze a carefully crafted version of that output to protect against
regressions</li>
</ul>

<p>If RSpec had expect tests one could have simply written:</p>

<div><pre><code><span>expect_test</span> <span>&#34;#submit&#34;</span> <span>do</span>
  <span>@book</span> <span>=</span> <span>Book</span><span>.</span><span>new</span><span>(</span><span>:title</span> <span>=&gt;</span> <span>&#34;RSpec Intro&#34;</span><span>,</span> <span>:price</span> <span>=&gt;</span> <span>20</span><span>)</span>
  <span>@customer</span> <span>=</span> <span>Customer</span><span>.</span><span>new</span>
  <span>@order</span> <span>=</span> <span>Order</span><span>.</span><span>new</span><span>(</span><span>@customer</span><span>,</span> <span>@book</span><span>)</span>

  <span>@order</span><span>.</span><span>submit</span>
  <span>p</span> <span>@customer</span><span>.</span><span>orders</span>
  <span>p</span> <span>@order</span>
  <span>expect</span> <span>&#34;&#34;</span>
<span>end</span>
</code></pre>
</div>

<p>and all the same state would have been made visible.</p>



<p>I hear you already: tests <em>should</em> be explicit. You <em>want</em> to define
up front the properties you care about, the output you’re expecting,
and so on. (Especially in TDD.)  You don’t want to just dump a bunch
of state and leave it to the reader to sort out what’s going on. And
you don’t want to have to wait for your function to be written to be
able to write tests for it.</p>

<p>You’re right! But expect tests can be just as targeted as a classical
unit test. I can always print out <code>order.shipped?</code> and type the string
<code>&#34;false&#34;</code> in my expect block. I can do this before I’ve written any
code and I’ll get the same sorts of errors as someone doing TDD with
RSpec.</p>

<p>The difference is that I don’t have to do that. Or I can defer doing
that until after I’ve done the fast-and-loose thing of “just seeing
what happens.” That’s the beauty of a blank expect block: it is an
invitation to the runtime to tell you what it’s thinking.</p>

<p>Of course, one of the downsides of just dumping state without doing
any filtering is that you can get lost in a bunch of irrelevant
details, and it’s harder for the reader to know what’s important, both
when they read the test the first time, and when a code change causes
the test output to change. It also makes it more likely that you’ll
pick up spurious changes.</p>

<p>Thus the art of expect tests is in producing output that tells a
concise story, capturing the state you care about. The best tests
take pains to elide unnecessary detail. Usually they use helper
functions and custom pretty-printers to craft the output.</p>

<p>When expect tests were first adopted at Jane Street, they spread like
wildfire. Now they form the better part of our test suite,
complemented in places by <a href="https://blog.janestreet.com/quickcheck-for-core/">property-based
testing</a>. Classical assertion-style unit tests still have
their place—just a much smaller one.</p>



<p>The tedium of writing your expected output by hand only grows with the
complexity of your actual system. A table of numbers is one
thing—imagine trying to describe the state of the DOM in a web
application or the state of an order book in a financial exchange.</p>

<h2 id="web-ui-tests">Web UI tests</h2>

<p>Here’s an excerpt of a real test from a toy web app built using
<a href="https://github.com/janestreet/bonsai">Bonsai</a>, Jane Street’s open-source web framework for OCaml. (Think
React or Elm.) One of Bonsai’s most powerful features is its ability
to let you easily write realistic tests, in which you programatically
manipulate UI elements and watch your DOM evolve.</p>

<p>In this example, we’re testing the behavior of a
user-selector. Whatever you type in the text box gets appended to a
little “hello” message:</p>

<div><pre><code>let%expect_test &#34;shows hello to a specified user&#34; =
  let handle = Handle.create (Result_spec.vdom Fn.id) hello_textbox in
  Handle.show handle;
  [%expect
    {|
    &lt;div&gt;
      &lt;input oninput&gt; &lt;/input&gt;
      &lt;span&gt; hello  &lt;/span&gt;
    &lt;/div&gt; |}];
  Handle.input_text handle ~get_vdom:Fn.id ~selector:&#34;input&#34; ~text:&#34;Bob&#34;;
  Handle.show_diff handle;
  [%expect
    {|
      &lt;div&gt;
        &lt;input oninput&gt; &lt;/input&gt;
<span>-      &lt;span&gt; hello  &lt;/span&gt;
</span><span>+      &lt;span&gt; hello Bob &lt;/span&gt;
</span>      &lt;/div&gt; |}];
</code></pre>
</div>

<p>Notice that there are two expect blocks. (This allows you to make
multiple assertions within a given scenario and to scope setup/helper
code to just that scenario.)</p>

<p>The first makes our UI visible, and the second—which contains a
diff—shows some behavior after you programatically input some
text. Bonsai will even show you how html attributes or class names
change in response to user input. Tests can include mock server calls,
and can involve changes not just to the UI but to the state that
drives it. With tests like these you can write an entire component
without opening your browser.</p>

<h2 id="tests-of-low-level-system-operations">Tests of low-level system operations</h2>

<p>Our popular <a href="https://github.com/janestreet/magic-trace">magic-trace</a> tool, which uses Intel
Processor Trace to collect and display high-resolution traces of a
program’s execution, makes heavy use of expect tests. Some are simple,
for example this one that tests the program’s symbol demangler:</p>

<div><pre><code><span>let</span> <span>demangle_symbol_test</span> <span>symbol</span> <span>=</span>
  <span>let</span> <span>demangle_symbol</span> <span>=</span> <span>Demangle_ocaml_symbols</span><span>.</span><span>demangle</span> <span>symbol</span> <span>in</span>
  <span>print_s</span> <span>[%</span><span>sexp</span> <span>(</span><span>demangle_symbol</span> <span>:</span> <span>string</span> <span>option</span><span>)]</span>
<span>;;</span>

<span>let</span><span>%</span><span>expect_test</span> <span>&#34;real mangled symbol&#34;</span> <span>=</span>
  <span>demangle_symbol_test</span> <span>&#34;camlAsync_unix__Unix_syscalls__to_string_57255&#34;</span><span>;</span>
  <span>[%</span><span>expect</span> <span>{|</span> <span>(</span><span>Async_unix</span><span>.</span><span>Unix_syscalls</span><span>.</span><span>to_string</span><span>)</span> <span>|}]</span>
<span>;;</span>

<span>let</span><span>%</span><span>expect_test</span> <span>&#34;proper hexcode&#34;</span> <span>=</span>
  <span>demangle_symbol_test</span> <span>&#34;caml$3f&#34;</span><span>;</span>
  <span>[%</span><span>expect</span> <span>{|</span> <span>(?)</span> <span>|}]</span>
<span>;;</span>

<span>let</span><span>%</span><span>expect_test</span> <span>&#34;when the symbol is not a demangled ocaml symbol&#34;</span> <span>=</span>
  <span>demangle_symbol_test</span> <span>&#34;dr__$3e$21_358&#34;</span><span>;</span>
  <span>[%</span><span>expect</span> <span>{|</span> <span>()</span> <span>|}]</span>
<span>;;</span>
</code></pre>
</div>

<p>Others serve as a kind of stable documentation, giving visibility into
the guts of the running system—like this test that demonstrates
what a trace of an OCaml exception will actually look like (shortened
for clarity):</p>

<div><pre><code><span>let</span><span>%</span><span>expect_test</span> <span>&#34;A raise_notrace OCaml exception&#34;</span> <span>=</span>
  <span>let</span> <span>ocaml_exception_info</span> <span>=</span>
    <span>Magic_trace_core</span><span>.</span><span>Ocaml_exception_info</span><span>.</span><span>create</span>
      <span>~</span><span>entertraps</span><span>:[|</span> <span>0x411030</span><span>L</span> <span>|]</span>
      <span>~</span><span>pushtraps</span><span>:[|</span> <span>0x41100b</span><span>L</span> <span>|]</span>
      <span>~</span><span>poptraps</span><span>:[|</span> <span>0x411026</span><span>L</span> <span>|]</span>
  <span>in</span>
  <span>let</span><span>%</span><span>map</span> <span>()</span> <span>=</span>
    <span>Perf_script</span><span>.</span><span>run</span> <span>~</span><span>ocaml_exception_info</span> <span>~</span><span>trace_scope</span><span>:</span><span>Userspace</span> <span>&#34;ocaml_exceptions.perf&#34;</span>
  <span>in</span>
  <span>[%</span><span>expect</span>
    <span>{|</span>
    <span>23860</span><span>/</span><span>23860</span> <span>426567</span><span>.</span><span>068172167</span><span>:</span>                            <span>1</span>   <span>branches</span><span>:</span><span>uH</span><span>:</span>   <span>call</span>                           <span>411021</span> <span>camlRaise_test__entry</span><span>+</span><span>0x71</span> <span>(</span><span>foo</span><span>.</span><span>so</span><span>)</span> <span>=&gt;</span>           <span>410</span><span>f70</span> <span>camlRaise_test__raise_after_265</span><span>+</span><span>0x0</span> <span>(</span><span>foo</span><span>.</span><span>so</span><span>)</span>
    <span>-&gt;</span>      <span>3</span><span>ns</span> <span>BEGIN</span> <span>camlRaise_test__raise_after_265</span>
    <span>-&gt;</span>      <span>6</span><span>ns</span> <span>BEGIN</span> <span>camlRaise_test__raise_after_265</span>
    <span>-&gt;</span>      <span>9</span><span>ns</span> <span>BEGIN</span> <span>camlRaise_test__raise_after_265</span>
    <span>-&gt;</span>     <span>13</span><span>ns</span> <span>BEGIN</span> <span>camlRaise_test__raise_after_265</span>
    <span>-&gt;</span>     <span>13</span><span>ns</span> <span>BEGIN</span> <span>camlRaise_test__raise_after_265</span>
    <span>-&gt;</span>     <span>13</span><span>ns</span> <span>BEGIN</span> <span>camlRaise_test__raise_after_265</span>
    <span>-&gt;</span>     <span>13</span><span>ns</span> <span>BEGIN</span> <span>camlRaise_test__raise_after_265</span>
    <span>-&gt;</span>     <span>14</span><span>ns</span> <span>BEGIN</span> <span>camlRaise_test__raise_after_265</span>
    <span>...</span>
   <span>|}%]</span>
</code></pre>
</div>

<h2 id="state-machine-tests">State machine tests</h2>

<p>Here’s a test from a toy system at Jane Street that processes
marketdata. (We use this system as part of one of our “dev teach-ins,”
two-week internal classes put on for developers meant to expose them
to different systems, libraries, ideas, and idioms from around the
firm: e.g. <em>Advanced functional programming</em> or <em>Performance
engineering</em>.) The goal of this particular test is to show how the
state of a two-sided order book with “buys” and “sells” responds to an
incoming order.</p>

<p>To write the test, all you have to do is set up the situation, then
drop a blank <code>[%expect]</code> block:</p>

<div><pre><code>let d = create_marketdata_processor () in
(* Do some preprocessing to define the symbol with id=1 as &#34;APPL&#34; *)
process_next_event_in_queue d
  {|
((timestamp (2019-05-03 12:00:00-04:00))
 (payload (Add_order (
     (symbol_id 1)
     (order_id  1)
     (dir       Buy)
     (price     10.00)
     (size      1)
     (is_active true)))))
|};
<span>+ [%expect {||}];
</span></code></pre>
</div>

<p>The compiler then figures out what should go inside the block. You’ll
find that you get a build error telling you that it’s not supposed to
be blank. Accepting the proposed diff, you end up with a block like
this:</p>

<div><pre><code>[%expect {|
process_next_event_in_queue d
  {|
((timestamp (2019-05-03 12:00:00-04:00))
 (payload (Add_order (
     (symbol_id 1)
     (order_id  1)
     (dir       Buy)
     (price     10.00)
     (size      1)
     (is_active true)))))
|};
[%expect {|
<span>+ ((book_event
+     (Order_added ((order_id 1) (dir Buy) (price 10.0000000) (size 1))))
+    (book
+     ((instrument_name AAPL)
+      (book ((buy (((price 10.0000000) (orders ((1 1)))))) (sell ()))))))
</span>|}];
</code></pre>
</div>

<p>This is beautiful: a plain-text representation of the state of your
system. The expect block <em>shows</em> you the order book. By keeping the
order book small and simple, you ensure the test is legible. But you
don’t need to make any specific assertions about it.</p>

<p>Compare what you might write for that last block in RSpec-land:</p>

<div><pre><code><span>expect</span> <span>@book</span><span>[</span><span>&#34;AAPL&#34;</span><span>].</span><span>sell</span> <span>to_be</span> <span>empty</span>
<span>expect</span> <span>@book</span><span>[</span><span>&#34;AAPL&#34;</span><span>].</span><span>buy</span><span>[</span><span>0</span><span>].</span><span>price</span> <span>to_equal</span> <span>10</span>
<span>expect</span> <span>@book_events</span> <span>to</span><span>.</span><span>include</span><span>(</span><span>@order</span><span>)</span>
</code></pre>
</div>

<p>Explicitly checking every aspect of the entire state of the order book
would be too tedious, so instead, you write a handful of what you
think are the most important assertions. This takes thinking, typing,
and time.</p>

<p>It also leaves you vulnerable later, when someone borks the
implementation of the order engine. Let’s say that now it mangles the
size of orders as it adds them to the book. Whereas the handcrafted
assertions above will continue to pass—you never said anything
about the <em>size</em> of the order on the book—the expect test will fail
with a nice little diff showing you that <code>size 1</code> inadvertently became
<code>size 100</code>.</p>

<p>Of course it is not always true that expect tests catch more than
regular unit tests—you have exactly the same level of flexibility
in each—but by relieving you from having to dream up exactly what
you want to assert, expect tests make it easier to implicitly assert
more. Ironically, they capture things you never expected them to.</p>



<p>This style of testing encourages you to make printing itself easy,
because most tests involve little more than setting up some data and
printing it. And indeed at Jane Street, we use code generators (like
<a href="https://github.com/janestreet/ppx_sexp_conv">ppx_sexp_conv</a>) that make it trivial to create a stringified
representation of just about any type. (You’ll have noticed above that
we lean heavily on S-expressions.)</p>

<p>People find expect tests so convenient that they’ll sometimes go to
great lengths to create helpers for producing plain text output, even
in places where you might not expect it. For instance in
<a href="https://github.com/janestreet/hardcaml">Hardcaml</a>, an open-source DSL for writing FPGA simulations
that Jane Street now maintains, many of the tests feature square
<a href="https://github.com/janestreet/hardcaml/blob/master/docs/waveforms.mdx">plain-text
waveforms</a>
that show you exactly what e.g. your clock and clear lines are doing:</p>

<div><pre><code>let%expect_test &#34;counter&#34; =
  let waves = testbench ()
  Waveform.print ~display_height:12 waves
  [%expect {|
<span>+ ┌Signals────────┐┌Waves──────────────────────────────────────────────┐
+ │clock          ││┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌──│
+ │               ││    └───┘   └───┘   └───┘   └───┘   └───┘   └───┘  │
+ │clear          ││                        ┌───────┐                  │
+ │               ││────────────────────────┘       └───────────────   │
+ │incr           ││        ┌───────────────┐                          │
+ │               ││────────┘               └───────────────────────   │
+ │               ││────────────────┬───────┬───────┬───────────────   │
+ │dout           ││ 00             │01     │02     │00                │
+ │               ││────────────────┴───────┴───────┴───────────────   │
+ │               ││                                                   │
+ └───────────────┘└───────────────────────────────────────────────────┘
</span>  |}]
</code></pre>
</div>



<p>I hope this post encourages more people to try the “snapshot” style of
testing. My own experience with it is that I never want to go back to
a workflow where my computer isn’t finishing my tests for me. If
nothing else, an editor integration that can take an expected result
and put it in its proper place in an assertion goes a long way. Typing
those assertions by hand feels somewhat like fixing the formatting of
source code by hand: something I was perfectly content doing for years
until a tool came along that made the previous practice seem faintly
ridiculous.</p>

<p>From the looks of it, this idiom—which again we didn’t invent; we
borrowed it from Mercurial, though I’m not sure if that’s the ur
source or if it goes further back—seems to be catching on more
widely. Maybe someday it’ll go truly mainstream.</p>



<p>[1] We used to call these things
<a href="https://en.wikipedia.org/wiki/Quine">quine</a> tests because in effect
you’re dealing with a program that knows how to print its own
source.</p>

        </div></div>
  </body>
</html>
