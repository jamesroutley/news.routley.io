<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dantleech.com/blog/2024/02/18/my-php-problems/">Original</a>
    <h1>My PHP Problems</h1>
    
    <div id="readability-page-1" class="page"><div><p>For the past months I‚Äôve been keeping a list of things I encountered in PHP
that I‚Äôve found to be <em>problematic</em>, or in other words <strong>things that annoy
me</strong>.</p><p><img src="https://www.dantleech.com/images/2024-02-18/problems.png" alt="problems"/>
<em>me having problems and being annoyed</em></p><p>This is not my definitive list and things that annoy me in PHP largely depend
on the things I‚Äôm working on, and for the past month I‚Äôve been working on:</p><ul><li><a href="https://github.com/phpactor/phpactor">Phpactor</a>: PHP language server</li><li><a href="https://github.com/php-tui/php-tui">PHP-TUI</a> TUI framework and port of Rust‚Äôs Ratatui.</li><li><a href="https://github.com/php-tui/cli-parser">CLI Parser</a>: me messing about creating a new CLI argument parser</li><li><a href="#">Work Project</a>: large E-Commerce project based on Spryker - my current day contract.</li></ul><p>There are lots of things I <strong>like</strong> in PHP and some of the points that follow
would annoy me in other languages too!</p><h2 id="constructors">Constructors <a href="#constructors">¬∂</a></h2><p>This is a strange one, yet one that bothers me. I clearly see the need for
static constructors, but I also cringe when using them unnecessarily. Should I
use static constructors for <em>everything</em>, a specific subset of objects or
introduce them only when required?</p><p>What‚Äôs the big deal you ask? <strong>Consistency</strong> is the deal. I don‚Äôt want to have
to type <code>new</code> only to realise there the class has a private constructor or that there are
static constructors which I should be using, but I also don‚Äôt want to
introduce pointless indirection fo the <em>sake</em> of consistency:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>// instantiation with the new keyword
</span></span></span><span><span><span></span><span>new</span> <span>Foobar</span>([<span>&#39;foo1&#39;</span>, <span>&#39;foo2&#39;</span>]);
</span></span><span><span>
</span></span><span><span><span>// static new
</span></span></span><span><span><span></span><span>Foobar</span><span>::</span><span>new</span>([<span>&#39;foo1&#39;</span>, <span>&#39;foo2&#39;</span>]);
</span></span><span><span>
</span></span><span><span><span>// dedicated constructor with variadic
</span></span></span><span><span><span></span><span>Foobar</span><span>::</span><span>fromFoos</span>(<span>...</span>$foos);
</span></span></code></pre></div><p>Langauges such as Rust and Go do not have this problem, mainly because they
don‚Äôt have the <code>new</code> keyword!</p><p>Both languages feature ‚Äústructs‚Äù which can be created directly without a
constructor and both have unwritten conventions on using constructor functions
(in Rust they are conventionally attached to the struct - similarly to static
constructors in PHP).</p><p>The <strong>disadvantage</strong> of bypassing (or simply not having) a constructor is that you permit the
‚Äúunsupervised‚Äù creation of the data structure - you can‚Äôt control and enforce
the <a href="https://ddd-practitioners.com/home/glossary/business-invariant/">business invariants</a>. However this is mitigated in both languages as they
both have <em>package level visibility</em> and <em>a strong type system</em>.</p><p>Am I suggesting we abolish the <code>new</code> keyword and adopt better types and
package level visibility? Yes? No? Maybe? I don‚Äôt know. The truth is it‚Äôs
just something that <strong>bugs me</strong>.</p><h2 id="annotations-vs-attributes">Annotations vs. Attributes <a href="#annotations-vs-attributes">¬∂</a></h2><p>Our static analysis tools use annotations:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>class</span> <span>Foobar</span>
</span></span><span><span>{
</span></span><span><span>    <span>/**
</span></span></span><span><span><span>     * @var Foobar[]
</span></span></span><span><span><span>     */</span>
</span></span><span><span>    <span>public</span> <span>array</span> $foobars;
</span></span><span><span>}
</span></span></code></pre></div><p>This is painful when you need to use this metadata in other contexts:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>class</span> <span>FoobarDTO</span>
</span></span><span><span>{
</span></span><span><span>    <span>/**
</span></span></span><span><span><span>     * @var Foobar[]
</span></span></span><span><span><span>     */</span>
</span></span><span><span>    <span>#[Collection(type: &#34;Foobar&#34;)]
</span></span></span><span><span><span></span>    <span>public</span> <span>array</span> $foobars;
</span></span><span><span>}
</span></span></code></pre></div><p>So our tooling can switch to attributes? Let‚Äôs look at a generic type defined
with an annotation:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>FoobarDTO</span>
</span></span><span><span>{
</span></span><span><span>    <span>/**
</span></span></span><span><span><span>     * @var Foobar&lt;string,Closure(string):int&gt;
</span></span></span><span><span><span>     */</span>
</span></span><span><span>    <span>public</span> <span>Foobar</span> $foobar;
</span></span><span><span>}
</span></span></code></pre></div><p>In attribute land this becomes:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>use</span> <span>Php\Type\</span>{<span>GenericClassType</span>,<span>StringType</span>,<span>IntType</span>};
</span></span><span><span>
</span></span><span><span><span>class</span> <span>FoobarDTO</span>
</span></span><span><span>{
</span></span><span><span>    <span>#[GenericClassType(&#39;Foobar&#39;, [
</span></span></span><span><span><span></span>        <span>new</span> <span>StringType</span>(),
</span></span><span><span>        <span>new</span> <span>ClosureType</span>(<span>new</span> <span>StringType</span>(), <span>new</span> <span>IntType</span>()),
</span></span><span><span>    ])]
</span></span><span><span>    <span>public</span> <span>Foobar</span> $foobar;
</span></span><span><span>}
</span></span></code></pre></div><p>Is that better? Of course not, it‚Äôs <strong>HORRIBLE</strong>. We are importing <strong>types</strong> for
<strong>types</strong>. We could also <a href="https://jmsyst.com/libs/serializer/master/reference/annotations#type">imagine</a>:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>use</span> <span>Php\Type</span>;
</span></span><span><span>
</span></span><span><span><span>class</span> <span>FoobarDTO</span>
</span></span><span><span>{
</span></span><span><span>    <span>#[Type(&#39;Foobar&lt;string,Closure(string):int&gt;&#39;)]
</span></span></span><span><span><span></span>    <span>public</span> <span>Foobar</span> $foobar;
</span></span><span><span>}
</span></span></code></pre></div><p>This would at least enable lower the barrier for sharing this metadata,
although from a usage point of view it‚Äôs arguably more cumbersome than an
annotation, it‚Äôs still annoying.</p><p>Generics would solve much of this pain, but it is <a href="https://stitcher.io/blog/generics-in-php-3">tricky</a>.
One solution that has been discussed is extending the PHP parser to accept
(<a href="https://en.wikipedia.org/wiki/Type_erasure">but ignore</a>) generic annotations
purely for the sake of static analysis tools, for example:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>class</span> <span>Hello</span>
</span></span><span><span>{
</span></span><span><span>    <span>public</span> <span>Foobar</span><span>&lt;</span><span>string</span>,<span>Closure</span><span>&gt;</span> $foobar;
</span></span><span><span>}
</span></span></code></pre></div><p>This would allow the <code>array&lt;Foobar&gt;</code> syntax, and maybe we can even get away with other exotic types like <code>Closure</code>:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>use</span> <span>Php\Type</span>;
</span></span><span><span>
</span></span><span><span><span>class</span> <span>FoobarDTO</span>
</span></span><span><span>{
</span></span><span><span>    <span>public</span> <span>Foobar</span><span>&lt;</span><span>string</span>,<span>Closure</span>(<span>string</span>)<span>:</span><span>int</span><span>&gt;</span> $foobar;
</span></span><span><span>}
</span></span></code></pre></div><p><strong>I like this</strong>! The PHP engine at runtime will only see
<code>Foobar</code> but the Reflection API will provide access to the ‚Äúrich‚Äù types
facilitating static analysis tools and helping to eliminate many of the
incidental problems we have in the ecosystem.</p><h2 id="no-nested-attributes">No Nested Attributes <a href="#no-nested-attributes">¬∂</a></h2><p>While working on a prototype for
<a href="https://github.com/phpbench/phpbench">PHPBench</a> I was experimenting with
allowing users to compose benchmarking pipelines.</p><p>PHPBench needs to analyse files which may not even have the same autoloader as
the main process:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>use</span> <span>Phpbenchx\Instructions\Iterations</span>;
</span></span><span><span><span>use</span> <span>Phpbenchx\Instructions\PhpSampler</span>;
</span></span><span><span>
</span></span><span><span><span>final</span> <span>class</span> <span>TimeBench</span>
</span></span><span><span>{
</span></span><span><span>    <span>#[Iterations(10, new PhpSampler(reps: 10, warmup: 1))]
</span></span></span><span><span><span></span>    <span>public</span> <span>function</span> <span>benchTime</span>()<span>:</span> <span>void</span>
</span></span><span><span>    {
</span></span><span><span>        <span>foreach</span> ([<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>] <span>as</span> $b) {
</span></span><span><span>            <span>foreach</span> ([<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>] <span>as</span> $b) {
</span></span><span><span>                <span>usleep</span>(<span>1</span>);
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>    }
</span></span></code></pre></div><p>Nice! But there‚Äôs a catch. The <code>Iterations</code> attribute is just a class <strong>name</strong>. We
can reflect the name using native reflection because, it‚Äôs <strong>just</strong> a
<em>name</em>. The <code>new PhpSampler</code> however is a <em>value</em> and will invoke the
autoloader and fail because PHPBench doesn‚Äôt necessarily exist in that
autoloader.</p><p>Nested attributes would look something like this I guess:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>final</span> <span>class</span> <span>TimeBench</span>
</span></span><span><span>{
</span></span><span><span>    <span>#[Iterations(10, PhpSampler(reps: 10, warmup: 1))]
</span></span></span><span><span><span></span>    <span>public</span> <span>function</span> <span>benchTime</span>()<span>:</span> <span>void</span>
</span></span><span><span>    {
</span></span><span><span>        <span>// ...
</span></span></span><span><span><span></span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>This would allow PHPBench to read the attributes even if they did not exist in
the other process.</p><p><strong>what‚Äôs that</strong>? you say this approach is <strong>flawed</strong>?, and you‚Äôre probably right, but
it would still be nice if refecting ‚Äúnested‚Äù attributes didn‚Äôt require the
autoloader.</p><p>See the
<a href="https://wiki.php.net/rfc/attributes_v2#why_are_nested_attributes_not_allowed">RFC</a> for the reasons why
nested were excluded from the final implementation.</p><h2 id="serializationdeserialization">Serialization/deserialization <a href="#serializationdeserialization">¬∂</a></h2><p>This is something that didn‚Äôt really <em>bother</em> me until I used <a href="https://pkg.go.dev/encoding/json">Go</a> and <a href="https://serde.rs/">Rust</a>.</p><p>Deserializing byte streams to objects is our daily bread. Whether it be HTTP
requests or RPC messages. We need to ingest bytes and map them to data
structures.</p><p>In PHP we start with:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span>$userData <span>=</span> $_POST[<span>&#39;user&#39;</span>];
</span></span><span><span>$user <span>=</span> <span>new</span> <span>User</span>(
</span></span><span><span>   $userData[<span>&#39;firstName&#39;</span>],
</span></span><span><span>   $userData[<span>&#39;lastName&#39;</span>]
</span></span><span><span>);
</span></span></code></pre></div><p>If you‚Äôre <strong>lucky</strong> there may be even be some <code>if (!array_key_exists</code> or even
<code>Assert::arrayHasKey</code> but more often than not we see people <a href="https://www.youtube.com/watch?v=lDK9QqIzhwk">living on a
prayer</a> and just assuming that
everything will kinda work out.</p><p>We then have
serialization libraries such as <a href="https://github.com/schmittjoh/serializer">JMS
Serializer</a> and later the <a href="https://symfony.com/doc/current/components/serializer.html">Symfony
Serializer</a>. This
is a <em>huge</em> improvement, but both libraries are complex.</p><p>Maybe I was <strong>burned</strong> by <strong>JMS serializer</strong> earlier in my career, and I
still have <strong>nightmares</strong> about debugging the <code>Serializer</code> stack in <strong>API Platform</strong>.
I don‚Äôt instinctively reach for these tools when I‚Äôm writing a tool and
instead wrote my own simple library to <a href="https://github.com/dantleech/invoke">deserialize into
objects</a> because I wanted to do this:</p><div><pre tabindex="0"><code data-lang="php"><span><span>$config <span>=</span> <span>Invoke</span><span>::</span><span>new</span>(<span>Config</span><span>::</span><span>class</span>, $config);
</span></span></code></pre></div><p>My library has no other API. It maps to an object <strong>field-for-field</strong> via.
the <strong>constructor</strong> and throws useful exceptions if values have the wrong
types, are missing or if there are extra fields. (<em>it has some serious
limitations too, and I wouldn‚Äôt recommend using it in your projects</em>).</p><p><strong>PROTIP</strong>: Map to <strong><a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTOs</a></strong>. Don‚Äôt use <a href="https://jmsyst.com/libs/serializer/master/cookbook/exclusion_strategies">serialization groups</a> to ‚Äúreuse‚Äù objects for multiple use cases. Don‚Äôt <a href="https://symfony.com/doc/current/forms.html#building-forms">map to entities</a>. DTOs are the correct targets for deserialization. This is not controversial.</p><p>Even more recently we have <a href="https://github.com/CuyZ/Valinor">Valinor</a> which
parses type annotations used by PHPStan and Psalm, including <em>generics</em>. Even
<em>more</em> recently we have <a href="https://github.com/Crell/Serde">Serde</a> which has been
created by somebody who obviously <em>feels my pain</em>.</p><p>Valinor is probably my favourite library as it doesn‚Äôt require you to
duplicate your type definitions with annotations and your DTOs can be
completely agnostic of the serialization library.</p><p>Let‚Äôs look at deserializing a <a href="https://github.com/dantleech/strava-rs">Strava Activity</a> in Rust:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[derive(Serialize, Deserialize)]</span>
</span></span><span><span><span>pub</span> <span>struct</span> <span>Activity</span> {
</span></span><span><span>    <span>pub</span> id: <span>i64</span>,
</span></span><span><span>    <span>pub</span> title: String,
</span></span><span><span>    <span>pub</span> activity_type: String,
</span></span><span><span>    <span>pub</span> description: String,
</span></span><span><span>    <span>pub</span> distance: <span>f64</span>,
</span></span><span><span>    <span>pub</span> average_speed: Option<span>&lt;</span><span>f64</span><span>&gt;</span>,
</span></span><span><span>    <span>pub</span> moving_time: <span>i64</span>,
</span></span><span><span>    <span>pub</span> elapsed_time: <span>i64</span>,
</span></span><span><span>}
</span></span><span><span><span>let</span> activity: <span>Activity</span> <span>=</span> serde_json::from_str(<span>&#34;/** json payload */&#34;</span>.as_str())<span>?</span>;
</span></span></code></pre></div><p>With Valinor:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Activity</span> {
</span></span><span><span>    <span>public</span> <span>int</span> $id;
</span></span><span><span>    <span>public</span> <span>string</span> $title;
</span></span><span><span>    <span>public</span> <span>string</span> $activity_type;
</span></span><span><span>    <span>public</span> <span>string</span> $description;
</span></span><span><span>    <span>public</span> <span>float</span> $distance;
</span></span><span><span>    <span>public</span> <span>?</span><span>float</span> $average_speed;
</span></span><span><span>    <span>public</span> <span>int</span> $moving_time;
</span></span><span><span>    <span>public</span> <span>int</span> $elapsed_time;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>$mapper <span>=</span> (<span>new</span> <span>MapperBuilder</span>())<span>-&gt;</span><span>mapper</span>();
</span></span><span><span>$activity <span>=</span> $mapper<span>-&gt;</span><span>map</span>(<span>Activity</span><span>::</span><span>class</span>, <span>Source</span><span>::</span><span>json</span>(<span>&#39;// json payload&#39;</span>)); 
</span></span></code></pre></div><p><strong>Not a bad comparison</strong>! In fact it‚Äôs even possible that Valinor, since it now also supports
<a href="https://valinor.cuyz.io/latest/serialization/normalizer/">serialization</a>,
<strong>SOLVES</strong> this issue for me. But until I can prove it otherwise,
serialization/deserialization in PHP still <strong>annoys me</strong> but hey, at least
it‚Äôs not Node.</p><p><a href="https://stitcher.io/blog/constructor-promotion-in-php-8">Promoted properties</a> are nice, let‚Äôs use one!</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>class</span> <span>Foobar</span> {
</span></span><span><span>    <span>public</span> <span>function</span> __construct(<span>private</span> <span>Foobar</span> <span>...</span>$foobars) {}
</span></span><span><span>}
</span></span></code></pre></div><p>Oops, can‚Äôt use variadics in promoted properties. Why!?! See <a href="https://stitcher.io/blog/constructor-promotion-in-php-8#variadic-parameters-cannot-be-promoted">generics</a>.</p><h2 id="iterator-to-array-preserve-keys">Iterator to Array: Preserve Keys <a href="#iterator-to-array-preserve-keys">¬∂</a></h2><p>I get bitten by this over and again, <code>yield from</code> to <code>yield</code> from
another generator:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>function</span> <span>one</span>() {
</span></span><span><span>    <span>yield</span> <span>&#39;bar&#39;</span>;
</span></span><span><span>    <span>yield</span> <span>from</span> <span>two</span>();
</span></span><span><span>}
</span></span><span><span><span>function</span> <span>two</span>() {
</span></span><span><span>    <span>yield</span> <span>&#39;bar&#39;</span>;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>$bars <span>=</span> <span>iterator_to_array</span>(<span>one</span>());
</span></span><span><span><span>var_dump</span>($bars);
</span></span></code></pre></div><p>Shows:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>array</span>(<span>1</span>) {
</span></span><span><span>  [<span>0</span>]<span>=&gt;</span>
</span></span><span><span>  <span>string</span>(<span>3</span>) <span>&#34;bar&#34;</span>
</span></span><span><span>}
</span></span></code></pre></div><p>And then passing the second argument as <code>false</code>:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>// ...
</span></span></span><span><span><span></span>$bars <span>=</span> <span>iterator_to_array</span>(<span>one</span>(), <span>false</span>);
</span></span></code></pre></div><p>I get answer I was expecting:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>array</span>(<span>2</span>) {
</span></span><span><span>  [<span>0</span>]<span>=&gt;</span>
</span></span><span><span>  <span>string</span>(<span>3</span>) <span>&#34;bar&#34;</span>
</span></span><span><span>  [<span>1</span>]<span>=&gt;</span>
</span></span><span><span>  <span>string</span>(<span>3</span>) <span>&#34;bar&#34;</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Why? because <code>false</code> is <code>preserve_keys</code>.</p><p>Why does this bother me? Because over the years I assume the wrong default
behavior, and after realising my error I pass <code>true</code> here.</p><p>Am I saying this is wrong? Are my instincts wrong? Am <strong>I</strong> the problem? I don‚Äôt know. It just
<strong>annoyed me</strong>.</p><h2 id="iterators-vs-arrays">Iterators vs. Arrays <a href="#iterators-vs-arrays">¬∂</a></h2><p>Why do we <em>even need to call</em> <code>iterator_to_array</code>! Why can‚Äôt <code>array_map</code> and
friends accept an iterator?</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span>$collection <span>=</span> <span>fetch_a_penguin_collection</span>();
</span></span><span><span><span>var_dump</span>($collection<span>::</span><span>class</span>);
</span></span><span><span><span>// PenguinCollection
</span></span></span><span><span><span></span>
</span></span><span><span>$collection <span>=</span> <span>array_map</span>(<span>iterator_to_array</span>($foobars, <span>true</span><span>|</span><span>false</span>), <span>function</span> (<span>Penguin</span> $penguin) {
</span></span><span><span>    <span>return</span> $penguin;
</span></span><span><span>});
</span></span><span><span><span>var_dump</span>(<span>get_type</span>($collection));
</span></span><span><span><span>// array
</span></span></span></code></pre></div><p>Well, it would seem that there is <strong>more than one way to skin an iterator</strong> and
<em>implicitly</em> mapping an iterator to an array doesn‚Äôt really make much sense.</p><p>Should it be allowed to pass iterators to array functions? <strong>No, probably
not</strong>. Has it <strong>bugged</strong> üêû me repeatedly? Yes it has. Am I wrong to be bugged? ü§∑</p><h2 id="short-closures-cannot-have-statements">Short closures cannot have statements <a href="#short-closures-cannot-have-statements">¬∂</a></h2><p>I <strong>like</strong> short closures! <strong>But</strong> I find my self converting my beloved short closures back to long closures
whenever:</p><ul><li>I need to add a statement</li><li>I need to debug it[*]</li></ul><p>I‚Äôd much prefer to enjoy the short syntax while also being able to have
multiple statements:</p><div><pre tabindex="0"><code data-lang="php"><span><span>$func <span>=</span> <span>fn</span>($foo) <span>=&gt;</span> {
</span></span><span><span>    <span>echo</span> <span>&#39;hello&#39;</span>;
</span></span><span><span>    <span>echo</span> <span>&#39;world&#39;</span>;
</span></span><span><span>    <span>return</span> <span>&#39;goodbye&#39;</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>This would be better, and yes it can capture variables automatically and no
that‚Äôs not confusing.</p><p>[*] <em>yes I am one of those primitive developers that doesn‚Äôt use a step
debugger all the time</em></p><p>There is another great atricle <a href="https://stitcher.io/blog/why-we-need-multi-line-short-closures-in-php">here which broadly argues for multi-line
closures</a>.</p><h2 id="statement-blocks-in-general">Statement Blocks in General <a href="#statement-blocks-in-general">¬∂</a></h2><p>And why stop there?</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span>$foo <span>=</span> <span>match</span> ($bar) {
</span></span><span><span>    <span>&#39;foo&#39;</span> <span>=&gt;</span> {
</span></span><span><span>        $a <span>=</span> <span>1</span>;
</span></span><span><span>        <span>return</span> $a;
</span></span><span><span>    },
</span></span><span><span>};
</span></span></code></pre></div><p>or even arbitrary scoping like in Rust?</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span>$foo <span>=</span> <span>0</span>;
</span></span><span><span>{
</span></span><span><span>    $bar <span>=</span> <span>1</span>;
</span></span><span><span>    $foo <span>+=</span> $bar;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>assert</span>(<span>false</span> <span>===</span> <span>isset</span>($bar));
</span></span></code></pre></div><h2 id="functions-that-return-false">Functions that return false <a href="#functions-that-return-false">¬∂</a></h2><p>Now we‚Äôre getting to the good old stuff.</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span>$value <span>=</span> <span>json_decode</span>(<span>&#39;this is not valid json&#39;</span>);
</span></span><span><span><span>var_dump</span>($value);
</span></span><span><span><span>// NULL
</span></span></span><span><span><span></span>$value <span>=</span> <span>json_decode</span>(<span>&#39;null&#39;</span>);
</span></span><span><span><span>var_dump</span>($value);
</span></span><span><span><span>// NULL
</span></span></span></code></pre></div><p>So ‚Ä¶ <code>json_decode</code> returns NULL if there is an error, but it also returns
NULL if the value is err. <code>null</code> (a valid JSON string).</p><p>We can pass <code>flags: JSON_THROW_ON_ERROR</code> to both, and get a really great an
informative error:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>Fatal error: Uncaught JsonException: Syntax error
</span></span></code></pre></div><p>What about <code>file_get_contents</code>?</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>&lt;?</span><span>php</span>
</span></span><span><span>
</span></span><span><span><span>var_dump</span>(<span>file_get_contents</span>(<span>&#39;this/doesnt/exist&#39;</span>));
</span></span><span><span><span>// false
</span></span></span></code></pre></div><p>I love the smell of <code>false</code> in the morning, but despite that I do wish that
all PHP‚Äôs built-in functions threw exceptions. We have the famous
<a href="https://github.com/thecodingmachine/safe">safe</a> library which does just that!
But if you‚Äôre like me then you don‚Äôt like coupling huge amounts of code in
perpetuity to an external library.</p><p>Is there anything we can do about this without breaking all the code?
<code>declare(throw_exceptions=true)</code> maybe? probably not ü§∑. If all functions
threw exceptions however I would be <strong>less annoyed</strong>.</p><h2 id="inline-classes">Inline Classes <a href="#inline-classes">¬∂</a></h2><p>In Go you can efficiently declare structs within structs to create
deep data structures:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>struct</span> <span>Foobar</span> {
</span></span><span><span>   <span>Foobar</span> <span>struct</span> {
</span></span><span><span>      <span>Foo</span> <span>string</span>
</span></span><span><span>      <span>Bar</span> <span>string</span>
</span></span><span><span>   }
</span></span><span><span>}
</span></span></code></pre></div><p>In PHP you can‚Äôt and we need to declare them separately:</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>class</span> <span>FooAndBar</span> {
</span></span><span><span>    <span>public</span> <span>string</span> $foo;
</span></span><span><span>    <span>public</span> <span>string</span> $bar;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Foobar</span> {
</span></span><span><span>   <span>public</span> <span>FooAndBar</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>Would this be a good idea?</p><div><pre tabindex="0"><code data-lang="php"><span><span><span>class</span> <span>Foobar</span> {
</span></span><span><span>   <span>public</span> <span>class</span> <span>{</span>
</span></span><span><span>      <span>public</span> <span>string</span> $foo;
</span></span><span><span>      <span>public</span> <span>string</span> $bar;
</span></span><span><span>   } $foobar;
</span></span><span><span>}
</span></span></code></pre></div><p>I don‚Äôt know. But it would sure make some things easier.</p><h2 id="conclusion">Conclusion <a href="#conclusion">¬∂</a></h2><p>This is a <em>subjective</em> post about things that <strong>annoy me</strong>, some of the
points are invalid and for sure people with far more context and brain power
than I have have considered them. It is also to be expected that I take for
granted things that would <strong>annoy other people</strong>.</p><p>If I had to choose one thing to fix in PHP it would be <strong>generics support</strong>.
Of the 11 annoyances 3 of them would be solved by generics. Generics support,
even by type erasure, would, I think, take the language to the next level.</p><p>I still enjoy PHP in comparison to some other languages, and it certainly has
practical some advantages over Rust and Go and I‚Äôm excited to see it evolve
more!</p></div></div>
  </body>
</html>
