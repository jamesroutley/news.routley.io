<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://luqman.ca/blog/multi-kernel-drifting/">Original</a>
    <h1>Multi-Kernel Drifting</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>I was setting up some automation to build Windows images pre-loaded with some drivers and software
(a story for another day). I had already gotten it working with QEMU under KVM on Linux but wanted
to port it to <a href="https://github.com/oxidecomputer/propolis">propolis</a> on our illumos distro, Helios.
I figured it should be mostly straightforward; maybe a couple different flags or utilities to futz
around with the disk images and mount them. Which was the case. Mostly. That is except for the one
minor detail of not being able to mount an NTFS image.</p>
<pre data-lang="console"><code data-lang="console"><span>$ pfexec mount -F ntfs-3g $LOOPBACK_DEV /mnt/test
</span><span>fuse: mount failed: Not a directory
</span></code></pre>
<h2 id="the-setup">the setup</h2>
<p>Ok, let&#39;s step back a second. To give some context, I was trying to create a raw image that
contained an NTFS partition. Maybe it didn&#39;t like the way I created the GPT? Ok, let&#39;s try
something simpler and forget partitions for a moment and just try solely creating an NTFS file
system:</p>
<ol>
<li>Create an empty disk image:</li>
</ol>
<pre data-lang="console"><code data-lang="console"><span>$ qemu-img create -f raw test.img 8G
</span><span>Formatting &#39;test.img&#39;, fmt=raw size=8589934592
</span></code></pre>
<ol start="2">
<li>Create loopback device:</li>
</ol>
<pre data-lang="console"><code data-lang="console"><span>$ pfexec lofiadm -l -a test.img
</span><span>/dev/dsk/c2t1d0p0
</span></code></pre>
<ol start="3">
<li>Create an NTFS file system:</li>
</ol>
<pre data-lang="console"><code data-lang="console"><span>$ mkntfs -Q /dev/dsk/c2t1d0p0
</span><span>The sector size was not specified for /dev/dsk/c2t1d0p0 and it could not be obtained automatically.  It has been set to 512 bytes.
</span><span>The partition start sector was not specified for /dev/dsk/c2t1d0p0 and it could not be obtained automatically.  It has been set to 0.
</span><span>The number of sectors per track was not specified for /dev/dsk/c2t1d0p0 and it could not be obtained automatically.  It has been set to 0.
</span><span>The number of heads was not specified for /dev/dsk/c2t1d0p0 and it could not be obtained automatically.  It has been set to 0.
</span><span>Cluster size has been automatically set to 4096 bytes.
</span><span>To boot from a device, Windows needs the &#39;partition start sector&#39;, the &#39;sectors per track&#39; and the &#39;number of heads&#39; to be set.
</span><span>Windows will not be able to boot from this device.
</span><span>Creating NTFS volume structures.
</span><span>mkntfs completed successfully. Have a nice day.
</span></code></pre>
<p>Ok, that&#39;s a lot of warnings (that I did handle properly in the real scenario!) but shouldn&#39;t be
relevant right now. We don&#39;t care if Windows can&#39;t boot off of this image.</p>
<ol start="4">
<li>Mount the file system:</li>
</ol>
<pre data-lang="console"><code data-lang="console"><span>$ pfexec mount -F ntfs-3g /dev/dsk/c2t1d0p0 /mnt/test
</span><span>fuse: mount failed: Not a directory
</span></code></pre>
<p>Something&#39;s clearly wrong.</p>
<h3 id="linux">linux</h3>
<p>Mind you this same scenario using the fuse-based ntfs-3g driver works in linux:</p>
<pre data-lang="console"><code data-lang="console"><span>➜  ~ qemu-img create -f raw test.img 8G
</span><span>Formatting &#39;test.img&#39;, fmt=raw size=8589934592
</span><span>➜  ~ sudo losetup -f --show test.img   
</span><span>/dev/loop1
</span><span>➜  ~ sudo mkntfs -Q /dev/loop1
</span><span>The partition start sector was not specified for /dev/loop1 and it could not be obtained automatically.  It has been set to 0.
</span><span>The number of sectors per track was not specified for /dev/loop1 and it could not be obtained automatically.  It has been set to 0.
</span><span>The number of heads was not specified for /dev/loop1 and it could not be obtained automatically.  It has been set to 0.
</span><span>Cluster size has been automatically set to 4096 bytes.
</span><span>To boot from a device, Windows needs the &#39;partition start sector&#39;, the &#39;sectors per track&#39; and the &#39;number of heads&#39; to be set.
</span><span>Windows will not be able to boot from this device.
</span><span>Creating NTFS volume structures.
</span><span>mkntfs completed successfully. Have a nice day.
</span><span>➜  ~ mkdir test
</span><span>➜  ~ sudo mount -t ntfs-3g /dev/loop1 test
</span><span>➜  ~ echo hello &gt; test/world
</span><span>➜  ~ cat test/world 
</span><span>hello
</span></code></pre>
<h2 id="ntfs-3g">ntfs-3g</h2>
<p>If you&#39;re using NTFS on non-Windows chances are you&#39;re using some <a href="https://github.com/tuxera/ntfs-3g">ntfs-3g</a>
based driver. It is used along with Filesystem in USErspace (FUSE) to provide access to NTFS volumes.
This arrangement consists of two parts: the FUSE kernel driver and the userspace application that
links against <code>libfuse</code>. In this case, that is <code>ntfs-3g</code>.</p>
<p>Let&#39;s skip the <code>mount</code> wrapper and just ask <code>ntfs-3g</code> directly to mount our image:</p>
<pre data-lang="console"><code data-lang="console"><span>$ pfexec ntfs-3g /dev/dsk/c2t1d0p0 /mnt/test
</span><span>fuse: mount failed: Not a directory
</span></code></pre>
<p>Alas, still no good. I guess we gotta dig.</p>
<h3 id="truss">truss</h3>
<p>On Linux you have <code>strace</code> to trace system calls. On Illumos there&#39;s <code>truss</code>:</p>
<pre data-lang="console"><code data-lang="console"><span>$ pfexec truss ntfs-3g /dev/dsk/c2t1d0p0 /mnt/test                                                                                                                                                          
</span><span>execve(&#34;/opt/ooce/ntfs-3g/bin/ntfs-3g&#34;, 0xFFFFFC7FFFDFDE48, 0xFFFFFC7FFFDFDE68)  argc = 3                                                                                                                   
</span><span>sysinfo(SI_MACHINE, &#34;i86pc&#34;, 257)               = 6
</span><span>[...snip...]
</span><span>mount(&#34;/devices/pseudo/lofi@1:q&#34;, &#34;/mnt/test&#34;, MS_NOSUID|MS_OPTIONSTR, &#34;fuse&#34;, 0x00000000, 0, 0x00E63E60, 1024) Err#20 ENOTDIR
</span><span>open(&#34;/usr/lib/locale/en_US.UTF-8/LC_MESSAGES/SUNW_OST_OSLIB.mo&#34;, O_RDONLY) Err#2 ENOENT
</span><span>fstat(2, 0xFFFFFC7FFFDFC720)                    = 0
</span><span>fuse: mount failed: write(2, &#34; f u s e :   m o u n t  &#34;.., 20)  = 20
</span><span>Not a directorywrite(2, &#34; N o t   a   d i r e c t&#34;.., 15)       = 15
</span><span>
</span><span>write(2, &#34;\n&#34;, 1)                               = 1
</span><span>close(5)                                        = 0
</span><span>fdsync(4, FSYNC)                                = 0
</span><span>fcntl(4, F_SETLK, 0xFFFFFC7FFFDFDBD0)           = 0
</span><span>close(4)                                        = 0
</span><span>_exit(21)
</span><span>
</span></code></pre>
<p>Hmmm, <code>mount(&#34;/devices/pseudo/lofi@1:q&#34;, &#34;/mnt/test&#34;, MS_NOSUID|MS_OPTIONSTR, &#34;fuse&#34;, 0x00000000, 0, 0x00E63E60, 1024) Err#20 ENOTDIR</code>.</p>
<p>That <code>ENOTDIR</code> error is not from <code>ntfs-3g</code>, in fact we see it returns an exit code of <code>21</code> and the
manual page tells us that&#39;s an &#34;Unclassified FUSE error&#34;.</p>
<p>The <code>mount</code> syscall here is what returned that <code>ENOTDIR</code> and its manual page says:</p>
<pre><code><span>       ENOTDIR
</span><span>                       The dir argument is not a directory, or a component of
</span><span>                       a path prefix is not a directory.
</span></code></pre>
<p>Not a directory you say?</p>
<pre data-lang="console"><code data-lang="console"><span>$ file /mnt/test
</span><span>/mnt/test:      directory
</span></code></pre>
<p>Presumably it is the fuse kernel driver which is handling the <code>mount</code> syscall in this case. One
quick way to check: <a href="http://dtrace.org/blogs/about/">DTrace</a>.</p>
<h3 id="dtrace">dtrace</h3>
<p><a href="https://illumos.org/books/dtrace/chp-intro.html#chp-intro">DTrace on illumos</a> offers a wealth of
information on a live system. With a lot of introspection capabilities, it makes for a great
debugging tool. I&#39;m still learning to reach for it, but it works perfectly here:</p>
<pre><code><span>$ pfexec dtrace -n &#39;fuse::return /arg1 == ENOTDIR &amp;&amp; pid == $target/ { stack(); }&#39; -c &#34;ntfs-3g /dev/dsk/c2t1d0p0 /mnt/test&#34;
</span><span>dtrace: description &#39;fuse::return &#39; matched 98 probes
</span><span>fuse: mount failed: Not a directory
</span><span>dtrace: pid 11852 has exited
</span><span>CPU     ID                    FUNCTION:NAME
</span><span>  1  17911                fuse_mount:return 
</span><span>              genunix`fsop_mount+0x14
</span><span>              genunix`domount+0x948
</span><span>              genunix`mount+0xfe
</span><span>              genunix`syscall_ap+0x98
</span><span>              unix`sys_syscall+0x17d
</span></code></pre>
<p>So what did we do there? We ran dtrace (<code>pfexec dtrace</code>) and:</p>
<ol>
<li>
<p>told it what probes to match (<code>fuse::return</code>)</p>
<p>Probes are specified as <code>[[[provider:] module:] function:] name</code>, where any unspecified field
acts as a wildcard.</p>
<p>We want to match the exit (<code>return</code>) probe of any function in the <code>fuse</code> kernel module.</p>
</li>
<li>
<p>for any such probes, a predicate to further filter them (<code>/arg1 == ENOTDIR &amp;&amp; pid == $target/</code>)</p>
<p><code>arg1</code> for a <code>return</code> probe corresponds to its return value. Here we compare to the error we&#39;re
looking for: <code>ENOTDIR</code>.</p>
<p><code>pid == $target</code> is to further constrain it by using the provided <code>$target</code> macro which refers
to:</p>
</li>
<li>
<p>the command we want to trace (<code>-c &#34;ntfs-3g /dev/dsk/c2t1d0p0 /mnt/test&#34;</code>)</p>
</li>
<li>
<p>and what actions to take for any matches (<code>{ stack(); }</code>)</p>
<p>DTrace has a number of actions to inspect the system, here we use the <code>stack()</code> to record and
print out the kernel stack trace for our matched probes.</p>
</li>
</ol>
<h2 id="fuse">FUSE</h2>
<p>FUSE seems to be the one stumbling over our supposedly &#34;not a directory&#34; directory. Now that
<code>dtrace</code> was helpful enough to point out where the error comes from, let&#39;s take a look at the
<a href="https://github.com/jurikm/illumos-fusefs/blob/ef9a33d4a18131a8c0e50002b138b0431e5db616/kernel/fuse_vfsops.c#L367">code</a>.</p>
<p>It certainly doesn&#39;t take long to find the spot:</p>
<pre data-lang="c"><code data-lang="c"><span>static int
</span><span>fuse_mount</span><span>(</span><span>struct</span><span> vfs *</span><span>vfsp</span><span>, </span><span>struct</span><span> vnode *</span><span>mvp</span><span>, </span><span>struct</span><span> mounta *</span><span>uap</span><span>,
</span><span>    </span><span>struct</span><span> cred *</span><span>cr</span><span>)
</span><span>{
</span><span>	fuse_vfs_data_t	 *vfsdata;
</span><span>	fuse_session_t	 *se;
</span><span>	dev_t dev;
</span><span>	</span><span>char </span><span>*fdstr;
</span><span>	</span><span>int</span><span> err;
</span><span>
</span><span>	</span><span>if </span><span>(</span><span>secpolicy_fs_mount</span><span>(cr, mvp, vfsp) != </span><span>0</span><span>)
</span><span>		</span><span>return </span><span>(EPERM);
</span><span>
</span><span>	</span><span>if </span><span>(mvp-&gt;v_type != VDIR)
</span><span>		</span><span>return </span><span>(ENOTDIR);
</span></code></pre>
<p>Every file is allocated a <code>vnode</code> and <code>mvp</code> here should represent the one for our mountpoint
(<code>/mnt/test</code>). <code>mount</code> understandably requires you only mount things at a directory and so every
file system driver should verify that is the case, just as FUSE does here. But if <code>/mnt/test</code>
isn&#39;t a directory (<code>VDIR</code>), what is it?</p>
<p>Back to dtrace!</p>
<pre data-lang="console"><code data-lang="console"><span>$ pfexec dtrace -n &#39;fuse_mount:entry /pid == $target/ { printf(&#34;v_type = %d&#34;, args[1]-&gt;v_type); }&#39; -c &#34;ntfs-3g /dev/dsk/c2t1d0p0 /mnt/test&#34;
</span><span>dtrace: description &#39;fuse_mount:entry &#39; matched 1 probe
</span><span>fuse: mount failed: Not a directory
</span><span>dtrace: pid 11921 has exited
</span><span>CPU     ID                    FUNCTION:NAME
</span><span>  6  17910                 fuse_mount:entry v_type = 2
</span></code></pre>
<p>This time we match just on entry to <code>fuse_mount</code> and for an entry probe we have access to <code>args</code>,
which allows typed access to the function arguments. In this case we print out the <code>v_type</code> field
of the second arg (<code>mvp = args[1]</code>). Let&#39;s take a look at the <a href="https://github.com/illumos/illumos-gate/blob/1a613b61205f4ee9a9fb00184dbe6cae17a6ede7/usr/src/uts/common/sys/vnode.h#L161-L174">enum definition</a>:</p>
<pre data-lang="c"><code data-lang="c"><span>typedef enum</span><span> vtype {
</span><span>	VNON	= </span><span>0</span><span>,
</span><span>	VREG	= </span><span>1</span><span>,
</span><span>	VDIR	= </span><span>2</span><span>,
</span><span>	VBLK	= </span><span>3</span><span>,
</span><span>	VCHR	= </span><span>4</span><span>,
</span><span>	VLNK	= </span><span>5</span><span>,
</span><span>	VFIFO	= </span><span>6</span><span>,
</span><span>	VDOOR	= </span><span>7</span><span>,
</span><span>	VPROC	= </span><span>8</span><span>,
</span><span>	VSOCK	= </span><span>9</span><span>,
</span><span>	VPORT	= </span><span>10</span><span>,
</span><span>	VBAD	= </span><span>11
</span><span>} </span><span>vtype_t</span><span>;
</span></code></pre>
<p>...it&#39;s <code>VDIR</code>?</p>
<p>This is when I started questioning my sanity a little. Theories of weird corruption happening
between function entry and the condition check. Was <code>secpolicy_fs_mount</code> secretly modifying it?
(No.)</p>
<p>Eventually I decide to look at the actual code running on my machine and use the kernel debugger
to disassemble the <code>fuse</code> module in-memory:</p>
<pre data-lang="asm"><code data-lang="asm"><span>$ pfexec mdb </span><span>-</span><span>k                                                                                       
</span><span>Loading modules: </span><span>[ </span><span>unix genunix specfs dtrace mac </span><span>cpu</span><span>.generic uppc apix scsi_vhci zfs sata </span><span>ip </span><span>hook neti sockfs arp usba xhci mm smbios stmf stmf_sbd lofs crypto random cpc ufs logindmux nsmb ptm smbsrv nf
</span><span>s </span><span>]                                                
</span><span>&gt; fuse`fuse_mount::dis                            
</span><span>[...snip...]
</span><span>fuse_mount</span><span>+0x28</span><span>:                </span><span>call   </span><span>+0x3a21ec3       </span><span>&lt;secpolicy_fs_mount&gt;
</span><span>fuse_mount</span><span>+0x2d</span><span>:                testl  %</span><span>eax</span><span>,</span><span>%</span><span>eax
</span><span>fuse_mount</span><span>+0x2f</span><span>:                </span><span>jne    </span><span>+0x110   </span><span>&lt;fuse_mount</span><span>+0x145</span><span>&gt;
</span><span>fuse_mount</span><span>+0x35</span><span>:                cmpl   </span><span>$0x2,0x30</span><span>(%</span><span>r13</span><span>)
</span><span>fuse_mount</span><span>+0x3a</span><span>:                movl   </span><span>$0x14,</span><span>%</span><span>ebx
</span><span>fuse_mount</span><span>+0x3f</span><span>:                </span><span>jne    </span><span>+0x100   </span><span>&lt;fuse_mount</span><span>+0x145</span><span>&gt;
</span></code></pre>
<p><code>0x14</code> is <code>ENOTDIR</code> and the <code>cmpl   $0x2,0x30(%r13)</code> would line up with the <code>v_type != VDIR</code> check.
But a quick <a href="https://godbolt.org/z/axM6bMPx4">hacked-up</a> validation of that offset does not square:</p>
<blockquote>
<p>v_type is at: 0x28</p>
</blockquote>
<p>How about comparing other file system drivers since they all have the same check:</p>
<p>NFS?</p>
<pre data-lang="asm"><code data-lang="asm"><span>nfs_mount</span><span>+0x66</span><span>:                 </span><span>call   </span><span>+0x3678985       </span><span>&lt;secpolicy_fs_mount&gt;                                                                                                                                
</span><span>nfs_mount</span><span>+0x6b</span><span>:                 testl  %</span><span>eax</span><span>,</span><span>%</span><span>eax                                                                                                                                                            
</span><span>nfs_mount</span><span>+0x6d</span><span>:                 </span><span>jne    </span><span>+0x2fd   </span><span>&lt;nfs_mount</span><span>+0x370</span><span>&gt;                                                                                                                                           
</span><span>nfs_mount</span><span>+0x73</span><span>:                 cmpl   </span><span>$0x2,0x28</span><span>(%</span><span>rbx</span><span>)                                                                                                                                                      
</span><span>nfs_mount</span><span>+0x77</span><span>:                 </span><span>jne    </span><span>+0x31b   </span><span>&lt;nfs_mount</span><span>+0x398</span><span>&gt;
</span><span>[...snip...]
</span><span>nfs_mount</span><span>+0x398</span><span>:                movl   </span><span>$0x14,</span><span>%</span><span>eax       </span><span># ENOTDIR
</span><span>nfs_mount</span><span>+0x39d</span><span>:                </span><span>jmp    </span><span>-0x2f    </span><span>&lt;nfs_mount</span><span>+0x370</span><span>&gt;
</span></code></pre>
<p>It uses an offset of <code>0x28</code>. We need another data point, tmpfs?</p>
<pre data-lang="asm"><code data-lang="asm"><span>tmp_mount</span><span>+0x58</span><span>:                 </span><span>call   </span><span>+0x3f1a993       </span><span>&lt;secpolicy_fs_mount&gt;
</span><span>tmp_mount</span><span>+0x5d</span><span>:                 testl  %</span><span>eax</span><span>,</span><span>%</span><span>eax
</span><span>tmp_mount</span><span>+0x5f</span><span>:                 movl   %</span><span>eax</span><span>,</span><span>%</span><span>r15d
</span><span>tmp_mount</span><span>+0x62</span><span>:                 </span><span>jne    </span><span>+0xc     </span><span>&lt;tmp_mount</span><span>+0x70</span><span>&gt;
</span><span>tmp_mount</span><span>+0x64</span><span>:                 cmpl   </span><span>$0x2,0x28</span><span>(%</span><span>rbx</span><span>)
</span><span>tmp_mount</span><span>+0x68</span><span>:                 movl   </span><span>$0x14,</span><span>%</span><span>r15d      </span><span># ENOTDIR
</span><span>tmp_mount</span><span>+0x6e</span><span>:                 </span><span>je     </span><span>+0x30    </span><span>&lt;tmp_mount</span><span>+0xa0</span><span>&gt;
</span></code></pre>
<p>It also uses an offset of <code>0x28</code>.</p>
<h3 id="local-build">local build</h3>
<p>Something&#39;s definitely going on here. At this point it&#39;s looking like the fuse driver has a
different idea of what the <code>vnode</code> struct looks like. If for some reason it was compiled without
<code>_LP64</code> defined then an offset of <code>0x30</code> could make sense but would certainly lead to other issues.
And this is definitely a 64-bit module:</p>
<pre data-lang="console"><code data-lang="console"><span>$ file /usr/kernel/drv/amd64/fuse
</span><span>/usr/kernel/drv/amd64/fuse:     ELF 64-bit LSB relocatable AMD64 Version 1
</span></code></pre>
<p>This is the point I took a detour into building the module locally. After some time trawling
through build scripts I got it built. TL;DR:</p>
<pre data-lang="bash"><code data-lang="bash"><span>wget</span><span> https://mirrors.omnios.org/fuse/Version-1.4.tar.gz</span><span> -O</span><span> illumos-fusefs-Version-1.4.tar.gz
</span><span>gtar</span><span> xf illumos-fusefs-Version-1.4.tar.gz
</span><span>cd illumos-fusefs-Version-1.4/kernel/amd64
</span><span>PATH</span><span>=</span><span>$</span><span>PATH</span><span>:/opt/onbld/bin/i386 </span><span>dmake</span><span> CC=gcc CFLAGS=</span><span>&#34;</span><span>-fident -fno-builtin -fno-asm -nodefaultlibs -Wall -Wno-unknown-pragmas -Wno-unused -fno-inline-functions -m64 -mcmodel=kernel -g -O2 -fno-inline -ffreestanding -fno-strict-aliasing -Wpointer-arith -gdwarf-2 -std=gnu99 -mno-red-zone -D_KERNEL -D__SOLARIS__ -mindirect-branch=thunk-extern -mindirect-branch-register</span><span>&#34;
</span></code></pre>
<p>Now to check what offset our newly built driver uses:</p>
<pre data-lang="asm"><code data-lang="asm"><span>$ objdump </span><span>-</span><span>D fuse | less
</span><span>0000000000008040 </span><span>&lt;fuse_mount&gt;:
</span><span>[...snip...]
</span><span>    </span><span>8069</span><span>:       e8 </span><span>00 00 00 00          </span><span>call   </span><span>806e &lt;fuse_mount</span><span>+0x2e</span><span>&gt;
</span><span>    806e:       </span><span>85 </span><span>c0                   </span><span>test   </span><span>%</span><span>eax</span><span>,</span><span>%</span><span>eax
</span><span>    </span><span>8070</span><span>:       0f </span><span>85 </span><span>0c </span><span>01 00 00       </span><span>jne    </span><span>8182 </span><span>&lt;fuse_mount</span><span>+0x142</span><span>&gt;
</span><span>    </span><span>8076</span><span>:       </span><span>83 </span><span>7b </span><span>28 02             </span><span>cmpl   </span><span>$0x2,0x28</span><span>(%</span><span>rbx</span><span>)
</span><span>    807a:       </span><span>41 </span><span>be </span><span>14 00 00 00       </span><span>mov    </span><span>$0x14,</span><span>%</span><span>r14d
</span><span>    </span><span>8080</span><span>:       0f </span><span>85 </span><span>fc </span><span>00 00 00       </span><span>jne    </span><span>8182 </span><span>&lt;fuse_mount</span><span>+0x142</span><span>&gt;
</span></code></pre>
<p>It&#39;s <code>0x28</code>! Not <code>0x30</code>! Does that mean it would work? Let&#39;s try</p>
<pre data-lang="console"><code data-lang="console"><span># unload the current driver
</span><span>$ modinfo | grep fuse
</span><span>257 fffffffff800d000   d188 284   1  fuse (fuse driver)
</span><span>257 fffffffff800d000   d188  28   1  fuse (filesystem for fuse)
</span><span>$ pfexec modunload -i 257                                                                      
</span><span>
</span><span># load the newly built one
</span><span>$ pfexec modload ./fuse
</span><span>
</span><span># try mounting the image again
</span><span>$ pfexec ntfs-3g /dev/dsk/c2t1d0p0 /mnt/test                                                                                   
</span><span>$ echo hello &gt; /mnt/test/world
</span><span>$ cat /mnt/test/world 
</span><span>hello
</span></code></pre>
<p>🎉 Success! 🎉</p>
<p>Although, in this case success just brings more questions than answers.</p>
<h2 id="breakthrough">breakthrough</h2>
<p>At this point I&#39;m really confused. Using the pre-built binary package fails on Helios. Building the
driver locally works on Helios.</p>
<p>I also gave <a href="https://omnios.org/">OmniOS</a> (a different Illumos distro and the source for a lot of
the build scripts used for Helios packages) a try. The pre-built packages worked there too. But it
was on OmniOS that I discovered that the &#34;bad&#34; offset of <code>0x30</code> was actually fine!? And not just
for the FUSE driver but also NFS and tmpfs.</p>
<p>Eventually while trying to figure out this odd difference between Helios and OmniOS came the
breakthrough. Recall we were able to use typed arguments in our DTrace commands; that is enabled
by the fact that a lot of software on Illumos comes with Compressed Type Format (CTF) data. CTF is
a compact representation of data types and function signatures stored inside ELF objects. It is
much smaller than the DWARF it is derived from. The smaller footprint makes it easy to ship by
default and enable rich usescases like DTrace.</p>
<p>We can use <code>ctfdump</code> to print out all the CTF data in our pre-built vs locally built driver and
compare the <code>vnode</code> definitions used:</p>
<p>First for the local build:</p>
<pre data-lang="console"><code data-lang="console"><span>$ ctfdump -t ./fuse | grep -A 8 &#39;struct vnode (&#39;
</span><span>  &lt;208&gt; struct vnode (216 bytes)
</span><span>        v_lock type=98 off=0
</span><span>        v_flag type=28 off=64
</span><span>        v_count type=28 off=96
</span><span>        v_data type=36 off=128
</span><span>        v_vfsp type=735 off=192
</span><span>        v_stream type=736 off=256
</span><span>        v_type type=230 off=320
</span><span>        v_rdev type=65 off=384
</span></code></pre>
<p><code>v_type</code> is at offset 320 bits = 40 / 0x28 bytes, as expected. What about the pre-built:</p>
<pre data-lang="console"><code data-lang="console"><span>$ ctfdump -t /usr/kernel/drv/amd64/fuse | grep -A 8 &#39;struct vnode (&#39;
</span><span>  &lt;229&gt; struct vnode (224 bytes)
</span><span>        v_lock type=103 off=0
</span><span>        v_flag type=28 off=64
</span><span>        v_count type=28 off=96
</span><span>        v_phantom_count type=28 off=128
</span><span>        v_data type=37 off=192
</span><span>        v_vfsp type=830 off=256
</span><span>        v_stream type=831 off=320
</span><span>        v_type type=255 off=384
</span></code></pre>
<p>Would you look at that <code>v_type</code> shows an offset of 384 bits = 48 / 0x30 bytes. The even more
suspicious line is this field that&#39;s not present in our local version: <code>v_phantom_count</code> (aptly
named in this instance).</p>
<p>So uh, what gives? The <a href="https://github.com/illumos/illumos-gate/blob/1a613b61205f4ee9a9fb00184dbe6cae17a6ede7/usr/src/uts/common/sys/vnode.h#L284-L292">upstream</a> header
(which we&#39;re more or less using in Helios) certainly doesn&#39;t contain it. A little searching
leads us to <a href="https://github.com/TritonDataCenter/illumos-joyent/pull/305">this PR</a> adding it
to SmartOS&#39;s (another distro) illumos fork. But what&#39;s probably more relevant in this case is
that it also exists in the <a href="https://github.com/omniosorg/illumos-omnios/blob/f8bf0ba10cd0088767e6da200297cfe385ae0ac3/usr/src/uts/common/sys/vnode.h#L291">OmniOS fork</a>.</p>
<p>A couple messages later and that more-or-less explains it: this package meant for Helios was
accidentally built on an OmniOS box, which has a slightly different definition of some kernel
structure.</p>
<p><img src="https://luqman.ca/blog/multi-kernel-drifting/images/multi-track-drifting-meme.jpg" alt="Mutli-Track Drifting Meme: Train labeled &#34;FUSE&#34; with front wheels on track labeled &#34;OmniOS Kernel&#34; and back labeled &#34;Helios Kernel&#34;. Bottom panel is close-up of manga character&#39;s eyes looking surprised/intense with action bubble to the left, &#34;MULTI-KERNEL DRIFTING!!!&#34;"/></p>

        </div></div>
  </body>
</html>
